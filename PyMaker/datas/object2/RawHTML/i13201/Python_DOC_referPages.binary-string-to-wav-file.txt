<div class="post-text" itemprop="text">
<p>I'm trying to write a wav upload function for my webapp. The front end portion seems to be working great. The problem is my backend (python). When it receives the binary data I'm not sure how to write it to a file. I tried using the basic write functon, and the sound is corrupt... Sounds like "gobbly-gook". Is there a special way to write wav files in Python?</p>
<p>Here is my backend... Not really much to it.</p>
<pre><code>form = cgi.FieldStorage()
fileData = str(form.getvalue('data'))

with open("audio", 'w') as file:
    file.write(fileData)
</code></pre>
<p>I even tried...</p>
<pre><code>with open("audio", 'wb') as file:
    file.write(fileData)
</code></pre>
<p>I am using aplay to play the sound, and I noticed that all the properties are messed up as well.</p>
<p>Before:
Signed 16 bit Little Endian, Rate 44100 Hz, Stereo</p>
<p>After upload:
Unsigned 8 bit, Rate 8000 Hz, Mono</p>
</div>
<div class="post-text" itemprop="text">
<p>Perhaps the <a href="https://docs.python.org/3/library/wave.html" rel="nofollow">wave module</a> might help?</p>
<pre><code>import wave
import struct
import numpy as np

rate = 44100

def sine_samples(freq, dur):
    # Get (sample rate * duration) samples on X axis (between freq
    # occilations of 2pi)
    X = (2*np.pi*freq/rate) * np.arange(rate*dur)

    # Get sine values for these X axis samples (as integers)
    S = (32767*np.sin(X)).astype(int)

    # Pack integers as signed "short" integers (-32767 to 32767)
    as_packed_bytes = (map(lambda v:struct.pack('h',v), S))
    return as_packed_bytes

def output_wave(path, frames):
    # Python 3.X allows the use of the with statement
    # with wave.open(path,'w') as output:
    #     # Set parameters for output WAV file
    #     output.setparams((2,2,rate,0,'NONE','not compressed'))
    #     output.writeframes(frames)

    output = wave.open(path,'w')
    output.setparams((2,2,rate,0,'NONE','not compressed'))
    output.writeframes(frames)
    output.close()

def output_sound(path, freq, dur):
    # join the packed bytes into a single bytes frame
    frames = b''.join(sine_samples(freq,dur))

    # output frames to file
    output_wave(path, frames)

output_sound('sine440.wav', 440, 2)
</code></pre>
<p><strong>EDIT:</strong></p>
<p>I think in your case, you might only need:</p>
<pre><code>packedData = map(lambda v:struct.pack('h',v), fileData)
frames = b''.join(packedData)
output_wave('example.wav', frames)
</code></pre>
<p>In this case, you just need to know the sampling rate. Check the wave module for information on the other output file parameters (i.e. the arguments to the <code>setparams</code> method).</p>
</div>
<div class="post-text" itemprop="text">
<p>The code I pasted will write a wav file as long as the data isn't corrupt. It was not necessary to use the wave module.</p>
<pre><code>with open("audio", 'w') as file:
    file.write(fileData)
</code></pre>
<p>I was originally reading the file in Javascript as FileAPI.readAsBinaryString. I changed this to FileAPI.readAsDataURL, and then decoded it in python using base64.decode(). Once I decoded it I was able to just write the data to a file. The .wav file was in perfect condition.</p>
</div>
<span class="comment-copy">What is <code>cgi.FieldStorage()</code>? Also you shouldn't be making a string out of binary data.</span>
<span class="comment-copy">The CGI (Common Gateway Interface) is what i use to get HTTP requests. My sound file binary data is sent through an AJAX request, and the script reads the binary string from cgi.FieldStorage.</span>
<span class="comment-copy">So you are using Python's build in <a href="https://docs.python.org/3/library/cgi.html" rel="nofollow noreferrer"><code>cgi</code></a> module? In the case of POSTing raw sound data, I don't think you should be using <code>cgi.FieldStorage</code> at all. I forget how CGI works, but I think you just read the data from stdin; <code>FieldStorage</code> looks like it's meant for <code>&lt;form&gt;</code> tags.</span>
<span class="comment-copy">If the downloaded data isn't formatted as a <a href="https://en.wikipedia.org/wiki/WAV#Specification" rel="nofollow noreferrer">WAV file</a> then simply writing to a file is too simplistic. Python has a <a href="https://docs.python.org/2/library/wave.html" rel="nofollow noreferrer"><code>wave</code> module</a> that would help.</span>
<span class="comment-copy">@Mark Ransom - If I use that then I have to set all the parameters (e.g. framerate and nframes). If the user is uploading a file, I don't think I will have those parameters available.</span>
<span class="comment-copy">My only concern with this is the uploaded files. I won't know the frequency or the duration. That's why I was hoping to just make a binary copy. I'm using file.readAsBinaryString in Javascript. I'm guessing I'm going to have to get the frequency, duration, and etc... before I send it up to my python?</span>
<span class="comment-copy">I don't think so. I just put that code in there as an example of how to generate raw binary data. I'll update my comment.</span>
<span class="comment-copy">I was able to do it with the code I posted above. The sent data was actually messed up. I fixed it by sending it as base64 encoded, instead of just binary. Thanks for the help anyway though.</span>
