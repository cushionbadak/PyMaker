<div class="post-text" itemprop="text">
<p>I found a line of code that searches for and replaces a string if it appears in text on this answer:</p>
<p><a href="https://stackoverflow.com/questions/7812524/search-for-a-line-that-contains-some-text-replace-complete-line-python">Search for a line that contains some text, replace complete line python</a></p>
<pre><code>outFile.writelines("process.control.timeout=900\n" 
                  if "process.control.timeout" in line else line 
                     for line in process)
</code></pre>
<p>I modified it and used it three times in a row like so:</p>
<pre><code>def runSearch(self):
    outFile.writelines("aFile=" + aFilename + "\n" if "aFile=" in line else line for line in searchFile)
    outFile.writelines("bFile=" + bFilename + "\n" if "bFile=" in line else line for line in searchFile)
    outFile.writelines("cFile=" + cFilename + "\n" if "cFile=" in line else line for line in searchFile)
</code></pre>
<p>The problem is, the only line that works is the first one. Why is this and how do I solve it?</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm going to guess that <code>searchFile</code> is a <em>file</em> (which you created with a call to <code>open</code>), not a list.</p>
<p>File objects have an internal pointer to their current location. When you <code>read</code> something from a file, the internal pointer gets updated - so a future call to <code>read</code> will not return the same result.</p>
<p>Iterating over the lines in a file, as you do here (<code>line for line in searchFile</code>) is another example of an operation which changes your current position in the file. You can think of iterating a file as calling <code>read</code> lots of times, under the hood.</p>
<p>So once you've iterated through all the lines in a file, you've reached the end, and subsequent <code>read</code>s from the file will return nothing. You can test this by getting the current position of the file after you've iterated using <a href="https://docs.python.org/3/library/io.html#io.IOBase.tell" rel="nofollow"><code>tell</code></a>:</p>
<pre><code>print(searchFile.tell())  # will be 0
outFile.writelines("aFile=" + aFilename + "\n" if "aFile=" in line else line for line in searchFile)
print(searchFile.tell())  # will be some large number of bytes
</code></pre>
<hr/>
<p>There are two ways to get around this. One option is to <a href="https://docs.python.org/3/library/io.html#io.IOBase.seek" rel="nofollow">reset the file's position</a> to 0 after you've read it.</p>
<pre><code>outFile.writelines("aFile=" + aFilename + "\n" if "aFile=" in line else line for line in searchFile)
searchFile.seek(0)
outFile.writelines("bFile=" + bFilename + "\n" if "bFile=" in line else line for line in searchFile)
searchFile.seek(0)
outFile.writelines("cFile=" + cFilename + "\n" if "cFile=" in line else line for line in searchFile)
searchFile.seek(0)
</code></pre>
<p>The other option is to read the file once and store the contents in a list.</p>
<pre><code>lines = searchFile.readlines()
outFile.writelines("aFile=" + aFilename + "\n" if "aFile=" in line else line for line in lines)
outFile.writelines("bFile=" + bFilename + "\n" if "bFile=" in line else line for line in lines)
outFile.writelines("cFile=" + cFilename + "\n" if "cFile=" in line else line for line in lines)
</code></pre>
<p>You should choose the first option if your file is too big to fully read into memory, and the second option if you want to be able to close your input file quickly.</p>
</div>
<span class="comment-copy">What is <code>searchFile</code>? Can we see the definition?</span>
