<div class="post-text" itemprop="text">
<p>This came up in <a href="https://youtu.be/MCs5OvhV9S4?t=42m17s" rel="noreferrer">a recent PyCon talk</a>.</p>
<p>The statement</p>
<pre><code>[] = []
</code></pre>
<p>does nothing meaningful, but it does not throw an exception either. I have the feeling this must be due to unpacking rules. You can do <a href="http://openbookproject.net/thinkcs/python/english3e/tuples.html#tuple-assignment" rel="noreferrer">tuple unpacking</a> with lists too, e.g.,</p>
<pre><code>[a, b] = [1, 2]
</code></pre>
<p>does what you would expect. As logical consequence, this also should work, when the number of elements to unpack is 0, which would explain why assigning to an empty list is valid. This theory is further supported by what happens when you try to assign a non-empty list to an empty list:</p>
<pre><code>&gt;&gt;&gt; [] = [1]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: too many values to unpack
</code></pre>
<p>I would be happy with this explanation, if the same would also be true for tuples. If we can unpack to a list with 0 elements, we should also be able to unpack to a tuple with 0 elements, no? However:</p>
<pre><code>&gt;&gt;&gt; () = ()
  File "&lt;stdin&gt;", line 1
SyntaxError: can't assign to ()
</code></pre>
<p>It seems like unpacking rules are not applied for tuples as they are for lists. I cannot think of any explanation for this inconsistency. Is there a reason for this behavior? </p>
</div>
<div class="post-text" itemprop="text">
<p>The comment by @user2357112 that this seems to be coincidence appears to be correct. The relevant part of the Python source code is in <a href="https://hg.python.org/cpython/file/0351b0cb31d6/Python/ast.c#l916"><code>Python/ast.c</code></a>:</p>
<pre><code>switch (e-&gt;kind) {
    # several cases snipped
    case List_kind:
        e-&gt;v.List.ctx = ctx;
        s = e-&gt;v.List.elts;
        break;
    case Tuple_kind:
        if (asdl_seq_LEN(e-&gt;v.Tuple.elts))  {
            e-&gt;v.Tuple.ctx = ctx;
            s = e-&gt;v.Tuple.elts;
        }
        else {
            expr_name = "()";
        }
        break;
    # several more cases snipped
}
/* Check for error string set by switch */
if (expr_name) {
    char buf[300];
    PyOS_snprintf(buf, sizeof(buf),
                  "can't %s %s",
                  ctx == Store ? "assign to" : "delete",
                  expr_name);
    return ast_error(c, n, buf);
}
</code></pre>
<p><code>tuple</code>s have an explicit check that the length is not zero and raise an error when it is. <code>list</code>s do not have any such check, so there's no exception raised.</p>
<p>I don't see any particular reason for allowing assignment to an empty list when it is an error to assign to an empty tuple, but perhaps there's some special case that I'm not considering. I'd suggest that this is probably a (trivial) bug and that the behaviors should be the same for both types.</p>
</div>
<div class="post-text" itemprop="text">
<p>I decided to try to use <code>dis</code> to figure out what's going on here, when I tripped over something curious:</p>
<pre><code>&gt;&gt;&gt; def foo():
...   [] = []
... 
&gt;&gt;&gt; dis.dis(foo)
  2           0 BUILD_LIST               0
              3 UNPACK_SEQUENCE          0
              6 LOAD_CONST               0 (None)
              9 RETURN_VALUE        
&gt;&gt;&gt; def bar():
...   () = ()
... 
  File "&lt;stdin&gt;", line 2
SyntaxError: can't assign to ()
</code></pre>
<p>Somehow the Python <em>compiler</em> special-cases an empty tuple on the LHS. This difference varies from <a href="https://docs.python.org/2/reference/simple_stmts.html#assignment-statements" rel="noreferrer">the specification</a>, which states:</p>
<blockquote>
<p>Assignment of an object to a single target is recursively defined as follows.</p>
<p>...</p>
<ul>
<li>If the target is a target list enclosed in parentheses or in square brackets: The object must be an iterable with the same number of items as there are targets in the target list, and its items are assigned, from left to right, to the corresponding targets.</li>
</ul>
</blockquote>
<p>So it looks like you've found a legitimate, although ultimately inconsequential, bug in CPython (2.7.8 and 3.4.1 tested).</p>
<p>IronPython 2.6.1 exhibits the same difference, but Jython 2.7b3+ has a stranger behavior, with <code>() = ()</code> starting a statement with seemingly no way to end it.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's a bug.</p>
<p><a href="http://bugs.python.org/issue23275" rel="nofollow">http://bugs.python.org/issue23275</a></p>
<p>However, it seems to be harmless so I doubt it would get fixed for fear of breaking working code.</p>
</div>
<div class="post-text" itemprop="text">
<p>“Assigning to a list” is the wrong way to think about it.</p>
<p>In all cases you are <em>unpacking</em>: The Python interpreter creates an unpacking instruction from all three ways to write it, there are no lists or tuples involved on the left hand side (code courtesy of <a href="//www.reddit.com/user/old-man-prismo" rel="nofollow">/u/old-man-prismo</a>):</p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; def f():
...     iterable = [1, 2]
...     a, b = iterable
...     (c, d) = iterable
...     [e, f] = iterable
...
&gt;&gt;&gt; from dis import dis
&gt;&gt;&gt; dis(f)
  2           0 LOAD_CONST               1 (1)
              3 LOAD_CONST               2 (2)
              6 BUILD_LIST               2
              9 STORE_FAST               0 (iterable)

  3          12 LOAD_FAST                0 (iterable)
             15 UNPACK_SEQUENCE          2
             18 STORE_FAST               1 (a)
             21 STORE_FAST               2 (b)

  4          24 LOAD_FAST                0 (iterable)
             27 UNPACK_SEQUENCE          2
             30 STORE_FAST               3 (c)
             33 STORE_FAST               4 (d)

  5          36 LOAD_FAST                0 (iterable)
             39 UNPACK_SEQUENCE          2
             42 STORE_FAST               5 (e)
             45 STORE_FAST               6 (f)
             48 LOAD_CONST               0 (None)
             51 RETURN_VALUE      
</code></pre>
<p>As you can see, all three statements are exactly the same.</p>
<p>What unpacking does now is basically:</p>
<pre class="lang-py prettyprint-override"><code>_iterator = iter(some_iterable)
a = next(_iterator)
b = next(_iterator)
for superfluous_element in _iterator:
    # this only happens if there’s something left
    raise SyntaxError('Expected some_iterable to have 2 elements')
</code></pre>
<p>Analoguously for more or less names on the left side.</p>
<p>Now as @blckknght said: The compiler for some reason checks if the left hand side is an empty tuple and disallows that, but not if it’s an empty list.</p>
<p>It’s only consistent and logical to allow assigning to 0 names: Why not? You basically just assert that the iterable on the right hand side is empty. That opinion also seems to emerge as consensus in the <a href="https://bugs.python.org/issue23275" rel="nofollow">bug report</a> @gecko mentioned: Let’s allow <code>() = iterable</code>.</p>
</div>
<span class="comment-copy">@ozgur but unpacking with tuples does work: <code>a, b = 1, 2</code> is valid ...</span>
<span class="comment-copy">I am not sure but I think <code>[] = []</code> is not unpacking. However, I got suprised when I saw this would be doable: <code>[a, b] = [1, 2]</code>. Instead, I would do <code>a, b = (1, 2)</code></span>
<span class="comment-copy">I get the feeling there isn't going to be any interesting principle at work here. The best answer will probably be something like "here's the section of the code generator where it checks the validity of the LHS of an assignment, and here's the check that catches <code>()</code> but lets <code>[]</code> through". Maybe it'll be because <code>()</code> is recognized as a constant or something.</span>
<span class="comment-copy">@ozgur it's not about mutation - the same <code>[] = [1]</code> and <code>{} = {'a':1}</code> also raises error. it's maybe () acts like the method itself. beacuse <code>[].__add_([[]])</code> results <code>[[]]</code> but, <code>().__add__(((())))</code> just ().</span>
<span class="comment-copy">There is a <a href="http://bugs.python.org/issue23275" rel="nofollow noreferrer">python bug</a> dating from january 2015 showing the cause in the Python sources. Note that both assignments should be illegal according to the documentation. The discussion seems to lean slightly towards allowing assignment to <code>()</code></span>
<span class="comment-copy">It is perfectly legal in python 2.7 to a have a tuple of length 0.</span>
<span class="comment-copy">@clj: Not on the left side of an assignment it isn't.</span>
<span class="comment-copy">I was just about to post a similar answer. I was pretty surprised when I found the code and saw that it was a specific check for empty tuples, rather than a more general check that happens to apply to empty tuples but not empty lists.</span>
<span class="comment-copy">The bug is now fixed allowing for tuples in the right hand side too: <a href="https://bugs.python.org/issue23275" rel="nofollow noreferrer">bugs.python.org/issue23275</a></span>
<span class="comment-copy"><a href="https://docs.python.org/3/reference/simple_stmts.html#assignment-statements" rel="nofollow noreferrer">According to the spec</a>, it should reject both <code>[] = []</code> and <code>() = []</code>.</span>
<span class="comment-copy">I accepted @Blckknght's answer because it accurately answers my question, but this one is great too! Didn't know about <code>dis</code> before.</span>
