<div class="post-text" itemprop="text">
<p>Breaking from a <code>map</code> works as expected:</p>
<pre><code>def worker(x):
    print("worker call x=%s" % x)
    return x

for x in map(worker, range(5)):
    print(x)
    if x == 2:
        break

worker call x=0
0
worker call x=1
1
worker call x=2
2
</code></pre>
<p>But if I do the same with <code>multiprocessing</code>, I get this:</p>
<pre><code>from multiprocessing import Pool

pool = Pool(2)
for x in pool.map(worker, range(5)):
    print(x)
    if x == 2:
        break
pool.close()
pool.join()

0
1
2
worker call x=0
worker call x=1
worker call x=2
worker call x=3
worker call x=4
</code></pre>
<p>Why is multiprocessing's map behaving differently? How to avoid the unnecessary function calls?</p>
</div>
<div class="post-text" itemprop="text">
<p>multiprocessing's map behaves differently because it does not literate over the map iterable object synchronously as the built-in map does, it splits each iteration into a separate process immediately and joins the results.</p>
<p>In case you're not familiar with concurrent principles I will try to briefly explain this a little better.</p>
<p>In your first example using the built-in map the code would create an iterable object that allows you execute <code>worker</code> one at a time, in sequence. The fact that it executes one at a time and in sequence means that your function that prints <code>worker call x=</code> will always print first before execution continues onto the inside of your loop which will print just the value of <code>x</code>. It also means that when your loop hits 2 you can exit the loop without any extra calls to either map or the loop's body itself. This is a synchronous operation, everything is polite and waits its turn to execute.</p>
<p>In your second example, using the multiprocessing map code would still create an iterable object that processes <code>worker(x)</code>. This time, however, you are not executing each call to <code>worker(x)</code> one at a time (synchronously). The multiprocessing map call will immediately send out all of the map calls to separate processes to execute first, then combine the results. Your loop then executes the combined results and again stops at 2 as you've instructed it to. Unfortunately, all of the map entries were already executed in separate processes so while the body of the loop was executed the minimal number of times, the map was not.</p>
<p>Hopefully that helps you understand the why a little better.</p>
</div>
<div class="post-text" itemprop="text">
<p>The fundimental nature of <code>multiprocessing.Pool</code>s is that, as soon as you say <code>pool.map(...)</code>, it submits all the tasks in the passed iterable to the queue for the worker processes to do. Once such a task is put into the pool, it will eventually be consumed by a worker process and processed. Nothing you do with the result can change that. </p>
</div>
<div class="post-text" itemprop="text">
<p>It should be noted that if you have tried first version with Python2.x (I did), result would have been:</p>
<pre><code>worker call x=0
worker call x=1
worker call x=2
worker call x=3
worker call x=4
0
1
2
</code></pre>
<p>without any multiprocessing involved.</p>
<p>The difference is that in Python 2, <a href="https://docs.python.org/2.7/library/functions.html#map" rel="nofollow">doc</a> states:</p>
<blockquote>
<p>Apply function to every item of iterable and return a list of the results...</p>
</blockquote>
<p>when Python 3 <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow">doc</a> states:</p>
<blockquote>
<p>Return an iterator that applies function to every item of iterable, yielding the results...</p>
</blockquote>
<p>That means that <code>map</code> was changed in Python 3 to return an iterable instead of a list.</p>
<p>And even in Python 3, <code>multiprocessing.pool.Pool.map</code> doc says:</p>
<blockquote>
<p>A parallel equivalent of the map() built-in function (it supports only one iterable argument though). <strong>It blocks until the result is ready.</strong></p>
</blockquote>
<p>(emphasize mine)</p>
<p>That means that the method first computes the result list by spawning multiple processes and only then returns a full result object instead of yielding a values each time a subprocess ends. In that way, it is closer to Python2 <code>map</code> builtin than to Python3 one.</p>
</div>
