<div class="post-text" itemprop="text">
<p>I have to figure out how to print a frequency set. So far this is my code, but it keeps skipping the first number in the list. I assume that's because I have previous starting at <code>data[0]</code> but I don't know how else to fix that </p>
<pre><code>def frequencies(data):

    data.sort()

    count = 0
    previous = data[0]

    print("data\tfrequency") # '\t' is the TAB character

    for d in data:
        if d == previous:
            # same as the previous, so just increment the count
            count += 1
        else:
            # we've found a new item so print out the old and reset the count
            print(str(previous) + "\t" + str(count))
            count = 1

        previous = d
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python comes with a built in <a href="https://docs.python.org/3.5/library/collections.html#collections.Counter" rel="nofollow">Counter</a> type for counting frequencies for you. This doesn't solve the original problem with the code, but it does what you want it to do.</p>
<pre><code>&gt;&gt;&gt; data = [1,2,3,4,2,2,3,5]
&gt;&gt;&gt; c = Counter(data)
&gt;&gt;&gt; c
Counter({2: 3, 3: 2, 1: 1, 4: 1, 5: 1})
&gt;&gt;&gt; for key in sorted(c.keys()):
...     print('{}\t{}'.format(key, c[key]))
...
1   1
2   3
3   2
4   1
5   1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your diagnosis is correct.  The first time through the loop, <code>if d == previous</code> will always be <code>True</code>, so the first group never gets printed.  (Or, even worse, if the list is empty, then <code>previous = data[0]</code> crashes.)</p>
<hr/>
<p>The simple way to get the job done is to use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow"><code>itertools.groupby()</code></a>.  Look at the linked documentation to see how it could be implemented.</p>
<pre><code>for datum, group in itertools.groupby(sorted(data)):
    print('{0}\t{1}'.format(datum, len(list(group))))
</code></pre>
<p>In addition, I am suggesting:</p>
<ul>
<li>changing <code>data.sort()</code> to <code>sorted(data)</code>, so as to avoid having the caller see the side-effect of altering the list order.</li>
<li>Using <code>str.format()</code> instead of concatenation with two explicit <code>str()</code> type conversions.</li>
</ul>
<hr/>
<p>If you wanted to salvage your existing implementation, the quick fix would be to add an exception for the first pass:</p>
<pre><code>for i, d in enumerate(data):
    if i &gt; 0 and d == previous:
        â€¦
</code></pre>
<p>You wouldn't even have to initialize <code>count</code> and <code>previous</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Are you sure it's skipping the first one and not the last one? Right now it looks like it's ONLY printing information when you cross over from one data value to another. So if the entire file is one data value (e.g. a bunch of 1s), you'll never hit the "else" statement and never print. </p>
<p>You can get around this simply by printing the previous value and count one final time after the loop has completed. </p>
<p>Your first value should still be counted because you're initializing "previous" to the first value in data, so when you enter the loop, d == previous and you increment the count. That part looks like it'll do what you expect it to do. </p>
<p>If this isn't right, could you provide a simple input/output? </p>
</div>
<div class="post-text" itemprop="text">
<p>Source for <a href="https://stackoverflow.com/questions/10079216/skip-first-entry-in-for-loop-in-python">skipping first item</a></p>
<pre><code>from itertools import islice
for car in islice(cars, 1, None):
    # do something
</code></pre>
<hr/>
<p>For counting consecutive values, <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">itertools.groupby()</a> suggested by 200_success doesn't do the trick (Count() doesn't either) since these don't count adjacency but overall count. However, the presented question says 'frequency', and that CAN be counted with Count() or groupby().</p>
<p>A third alternative would be using a dict (better value-get time with keys as input):</p>
<pre><code>from collections import defaultdict

appearances = defaultdict(int)
for curr in a:
    appearances[curr] += 1
</code></pre>
</div>
