<div class="post-text" itemprop="text">
<p>Consider I have a non-empty array of integers: <code>A0..An</code>. And consider a parameter <code>P where 0 &lt; P &lt;=n</code>. I need to find a minimum absolute difference between left and right subarray splited by P. For example:</p>
<pre><code>  A[0] = 3
  A[1] = 1
  A[2] = 2
  A[3] = 4
  A[4] = 3

P = 1, difference = |3 − 10| = 7 
P = 2, difference = |4 − 9| = 5 
P = 3, difference = |6 − 7| = 1 
P = 4, difference = |10 − 3| = 7
</code></pre>
<p>The solution in this case is <code>1</code></p>
<p>I finished with the code below:</p>
<pre><code>def solution(A):
    lsum, rsum = A[0], sum(A[1:])
    diff = abs(rsum - lsum)
    p = 1
    while True:
        lsum += A[p]
        rsum -= A[p]
        next = abs(rsum - lsum)
        if next &lt; diff:
            diff = next
            p += 1
        else:
            return diff
</code></pre>
<p>but I my solution has some bugs. It works in some cases but return wrong answer in some conditions. For example: in condition like <code>large sequence, numbers from -1 to 1, length = ~100,000</code> it returns the wrong answer</p>
<p>P.S.: I finished with solution below:</p>
<pre><code> def solution(lst):
    lsum, rsum = lst[0], sum(lst[1:])
    diff = abs(lsum - rsum)
    for i in xrange(1, len(lst) - 1):
        lsum += lst[i]
        rsum -= lst[i]
        ndiff = abs(lsum - rsum)
        diff = min(diff, ndiff)
    return diff
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The bug is this:</p>
<pre><code>if next &lt; diff:
    diff = next
    p += 1
else:
    return diff
</code></pre>
<p>You terminate if <code>next</code> is not improving on <code>diff</code>. This is wrong, since you still might find a better solution later on.</p>
<p>Other than that, I think your idea goes in the right direction. What you should do to fix your bug is go through the whole array unconditionally and just return <code>diff</code>in the end.
Like so:</p>
<pre><code>def solution(A):
    lsum, rsum = A[0], sum(A[1:])
    diff = abs(rsum - lsum)
    p = 1
    while p &lt; (len(A)-1):
        lsum += A[p]
        rsum -= A[p]
        next = abs(rsum - lsum)
        if next &lt; diff:
            diff = next
        p += 1
    return diff
</code></pre>
<p>(Note: I tried to modify as little as possible, i.e. to stay as close to your code as possible. Also, I did not really test this. But I hope you get the idea.)</p>
</div>
<div class="post-text" itemprop="text">
<p>This is more concise yet still O(n):</p>
<pre><code>import itertools

def min_diff(A):
    total = sum(A)
    return min(abs(total - lsum - lsum) for lsum in itertools.accumulate(A))
</code></pre>
<p><a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow"><code>itertools.accumulate</code></a> is available from Python 3.2 up.</p>
</div>
<div class="post-text" itemprop="text">
<p>EDIT (the previous solution had a high complexity, my bad)</p>
<p>This is a remake of yours, but getting rid of the indexing on the list
and using the <code>min</code> built-in function to get the minimum.</p>
<pre><code>def solution(a):
    lsum = a[0]
    rsum = sum(a)-lsum
    dfs = [abs(rsum-lsum),]
    for el in a[1:]:
        lsum+=el
        rsum-=el
        dfs.append(abs(rsum-lsum))
    return min(dfs)
</code></pre>
<p>calling it with</p>
<pre><code>sol = solution([3,1,2,4,3])
print(sol)
</code></pre>
<p>produces</p>
<pre><code>1
</code></pre>
</div>
<span class="comment-copy">You are searching for <code>P</code>, not the <code>difference</code>? That wasn't 100% clear for me from the question.</span>
<span class="comment-copy">@NiklasR: I agree, the question is not very well phrased. Still, he is looking for the difference and not for P. He says the solution is <code>1</code>. If <code>P</code> was what he cared about, the solution would have been 3.</span>
<span class="comment-copy">Complexity is exactly <code>O(n)</code>, why do you want a better solution? Or what kind of 'better'?</span>
<span class="comment-copy">better in what sence? Probably a python purist can do this in one line.. But I'm pretty sure you can't do it better than in O(n).</span>
<span class="comment-copy">I think your code have question: if the difference list is [1, 2, 0], your code will return 1 rather 0.</span>
<span class="comment-copy">There is a bug. It doesn't work for an array of two elements</span>
<span class="comment-copy">@kharandziuk I wrote that I didn't test and it just is to give an idea.. I can fix it later, when I am at a pc. But if you found it, can't you fix it? I was rly just pointing out the bug which I just saw while reading your code...</span>
<span class="comment-copy">@kharandziuk Hey. I'm at a pc now and I tested a few small examples with 2 elements in the array. [1,4] =&gt; 3, [5,2] =&gt; 3, [5, -2] =&gt; 3. The last one suggest that the complete array is taken vs an empty one. Is this one the one which you mean is wrong? should both arrays be non-empty?</span>
<span class="comment-copy">@kharandziuk: Oh, I just saw from your solution, that you probably want  both arrays to be non-empty. I adjusted my code to comply with yours. (Edit: btw. thx for accepting my answer although it still contained a bug). Hopefully it is fine now...;)</span>
<span class="comment-copy">love itertools! <code>accumulate()</code> is python3 only though.</span>
<span class="comment-copy">I guess complexity in such case O(n^2)</span>
<span class="comment-copy">It seems slower, <code>O(n^2)</code></span>
<span class="comment-copy">now edited to comply with O(n)</span>
