<div class="post-text" itemprop="text">
<p>I've got an extension module that needs to support Python 2 and Python 3.  When it loads, I want to do something like <code>from __future__ import print_function</code> so that if anyone tries to do this:</p>
<pre><code>PyRun_SimpleString("print 'foo'");
</code></pre>
<p>it will fail, but if they do this:</p>
<pre><code>PyRun_SimpleString("print('foo', file=sys.stdout)");
</code></pre>
<p>it will succeed.  I've tried a number of things, including <code>PyRun_SimpleString</code> of the from future statement.  like this:</p>
<pre><code>PyRun_SimpleString("from __future__ import print_function");
</code></pre>
<p>and I've also tried calling <code>PyImport_ImportModuleEx</code> like this:</p>
<pre><code>PyImport_ImportModuleEx("__future__", nullptr, nullptr, fromlist);
</code></pre>
<p>where <code>fromlist</code> is a <code>PyObject</code> representing the list <code>["print_function"]</code></p>
<p>Neither of these works.  Is it possible to make this work?</p>
</div>
<div class="post-text" itemprop="text">
<p>PyRun_SimpleString doesn't have anywhere to specify compiler flags, but there's a <a href="https://docs.python.org/3/c-api/veryhigh.html" rel="nofollow">whole host of related functions</a> with more options available. For example, <code>PyRun_SimpleStringFlags</code> does what <code>PyRun_SimpleString</code> does, but with a <code>flags</code> argument to specify compiler flags. <code>__future__</code> statements executed with <code>PyRun_SimpleStringFlags</code> can modify the <code>flags</code>, and the change will be seen by other calls using the same <code>flags</code>.</p>
<p>You can initialize <code>flags</code> with future statements, or with the C-level flag definitions. Most of the possible flags aren't listed in the C-api documentation (since the C-api documentation kind of sucks), but you can find them in the <code>__future__</code> module or in several parts of the Python source code.</p>
<pre><code>&gt;&gt;&gt; import __future__
&gt;&gt;&gt; for name in dir(__future__):
...     if name.startswith('CO_'):
...         print name
...
CO_FUTURE_ABSOLUTE_IMPORT
CO_FUTURE_DIVISION
CO_FUTURE_PRINT_FUNCTION
CO_FUTURE_UNICODE_LITERALS
CO_FUTURE_WITH_STATEMENT
CO_GENERATOR_ALLOWED
CO_NESTED
</code></pre>
<p>For example, you could run a string under the effects of <code>from __future__ import print_function</code> with</p>
<pre><code>PyCompilerFlags flags = {CO_FUTURE_PRINT_FUNCTION};
PyRun_SimpleStringFlags(command, &amp;flags);
</code></pre>
<p>If you want to save the effects of user-executed future statements, you'd save the PyCompilerFlags struct somewhere and use the same one for all calls.</p>
<hr/>
<p>With that said, I don't think automatically applying <code>from __future__ import print_function</code> is the right thing to do. It'll surprise people expecting the default behavior of whatever interpreter they're on. Also, <code>PyRun_InteractiveOneFlags</code> might be useful for letting the user input multi-line Python statements.</p>
</div>
<span class="comment-copy">Why is your extension module using <code>PyRun_SimpleString</code>, especially to print things?</span>
<span class="comment-copy">It's not exactly, this is for the sake of illustrating the problem.  It does, however, expose an embedded interpreter.  i.e. you can perform some actions within the program to drop to a python prompt, or you can run some commands that execute python code and display the interpreter's output (those commands are passed through via <code>PyRun_SimpleString</code>.  What I need is a way to disable print statements so that if anyone runs a print statement, they will get an error.</span>
<span class="comment-copy">That's a pretty different problem from the one you're asking about, and the solution is pretty different.</span>
<span class="comment-copy">Umm, ok?  I'm not sure I follow.  The commands users are entering get passed through to <code>PyRun_SimpleString</code>.  Therefore by making sure that <code>PyRun_SimpleString("print 'foo'")</code> generates an error, I also make sure that it generates an error when they enter that command.  Which is the problem I am trying to solve.  It might help me to understand what you're getting at if you were a little bit less ambiguous in your statements.</span>
<span class="comment-copy">The question you've asked is about getting the effects of future statements in calls to <code>PyRun_SimpleString</code>, while the problem you're actually trying to solve is running user-provided Python code under the effects of future statements. <code>PyRun_SimpleString</code> isn't the tool for the job.</span>
<span class="comment-copy">Thanks, that's helpful.  Is there any way to get the set of flags the interpreter is currently under the effects of?  This way I could get that set of flags, and add in <code>CO_FUTURE_PRINT_FUNCTION</code>.  This is in an extension module that has to support both Py2 and Py3 with a single codebase and -- in particular -- a single set of tests.  So mandating print function is the best way (that I know of) to ensure that the test suite always passes all the time.</span>
<span class="comment-copy">@ZacharyTurner: I don't think that's something the interpreter exposes. I did figure out how to preserve flags from one statement to the next, though. As for the test suite, if you preserve user-executed future statements, you can just put <code>from __future__ import print_function</code> in your test setup.</span>
