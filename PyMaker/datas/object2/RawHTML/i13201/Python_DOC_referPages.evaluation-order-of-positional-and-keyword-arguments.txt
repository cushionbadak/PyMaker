<div class="post-text" itemprop="text">
<p>Consider this contrived<sup>*</sup> example:</p>
<pre><code>def count(one, two, three):
    print one
    print two
    print three
</code></pre>
<p>Three shall be the number thou shalt count, and the number of the counting
shall be three.</p>
<pre><code>&gt;&gt;&gt; x = [1, 2, 3]
&gt;&gt;&gt; count(*map(int, x), three=x.pop())
1
2
3
</code></pre>
<p>Four shalt thou not count,</p>
<pre><code>&gt;&gt;&gt; x = [1, 2, 3, 4]
&gt;&gt;&gt; count(*map(int, x), three=x.pop())
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: count() got multiple values for keyword argument 'three'
</code></pre>
<p>neither count thou two, excepting that thou then proceed to three.</p>
<pre><code>&gt;&gt;&gt; x = [1, 2]
&gt;&gt;&gt; count(*map(int, x), three=x.pop())
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: count() takes exactly 3 arguments (2 given)
</code></pre>
<p>Five is right out.</p>
<pre><code>&gt;&gt;&gt; x = [1, 2, 3, 4, 5]
&gt;&gt;&gt; count(*map(int, x), three=x.pop())
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: count() takes exactly 3 arguments (5 given)
</code></pre>
<p>After having read <a href="https://stackoverflow.com/q/17948369/4621513">this question</a>,
I would actually have thought that <code>x = [1, 2]</code> is the only one that works, because</p>
<ul>
<li>first, <code>map(int, x)</code> would be evaluated, <code>one</code> set to <code>1</code> and <code>two</code> set to <code>2</code></li>
<li>then, <code>x</code> still <code>[1, 2]</code>, <code>x.pop()</code> would be evaluated and <code>three</code> set to <code>2</code>, too.</li>
</ul>
<p>My expectation for <code>x = [1, 2, 3]</code> was to get the error that I actually saw
for <code>x = [1, 2, 3, 4]</code>.</p>
<p>What is going on here? Why are the arguments seemingly not evaluated from left to right? Are keyword arguments evaluated first?</p>
<hr/>
<p><sup>*</sup>actually my real code corresponds to <code>x = [1, 2, 3]</code>, which works, but I wasn't sure it was safe, and after reading the other question I thought it shouldn't actually work.</p>
<p>I'm using Python 2.7, if that matters.</p>
</div>
<div class="post-text" itemprop="text">
<h2>Python 2.7</h2>
<p>If we look at the CPython source related to creating the AST(<a href="https://hg.python.org/cpython/file/2.7/Python/ast.c#l1978" rel="nofollow"><code>ast_for_call</code></a>) for a function call the order of argument evaluation turns out to be:</p>
<pre><code>return Call(func, args, keywords, vararg, kwarg, func-&gt;lineno,
                func-&gt;col_offset, c-&gt;c_arena);
</code></pre>
<p>ie. args --&gt; keywords --&gt; vararg --&gt; kwarg</p>
<p>So, in your case the keyword argument is evaluated first and then the star based expression(<code>vararg</code>) is evaluated.</p>
<p><strong>Byte code:</strong></p>
<pre><code>&gt;&gt;&gt; dis.dis(lambda: func(1, 2, *('k', 'j', 'l'), z=1, y =2, three=x.pop(), **{kwarg:1}))
  1           0 LOAD_GLOBAL              0 (func)
              3 LOAD_CONST               1 (1)         # arg
              6 LOAD_CONST               2 (2)         # arg
              9 LOAD_CONST               3 ('z')       # keyword
             12 LOAD_CONST               1 (1)
             15 LOAD_CONST               4 ('y')       # keyword
             18 LOAD_CONST               2 (2)
             21 LOAD_CONST               5 ('three')   # keyword
             24 LOAD_GLOBAL              1 (x)
             27 LOAD_ATTR                2 (pop)
             30 CALL_FUNCTION            0
             33 LOAD_CONST               9 (('k', 'j', 'l')) #vararg
             36 BUILD_MAP                1
             39 LOAD_CONST               1 (1)
             42 LOAD_GLOBAL              3 (kwarg)     #kwarg
             45 STORE_MAP
             46 CALL_FUNCTION_V
</code></pre>
<p>Hence in your case the <code>pop()</code> call will happen first followed by the <code>varargs</code> evaluation.</p>
<p>So, if <code>three</code> is a part of <code>kwargs</code> then we will get an error with <code>map</code>:</p>
<pre><code>&gt;&gt;&gt; x = [1, 2, 3]
&gt;&gt;&gt; count(*map(float, x), **{'three': x.pop()})
Traceback (most recent call last):
  File "&lt;ipython-input-133-e8831565af13&gt;", line 1, in &lt;module&gt;
    count(*map(float, x), **{'three': x.pop()})
TypeError: count() got multiple values for keyword argument 'three'
</code></pre>
<p>It will work if we do it *lazily:</p>
<pre><code>&gt;&gt;&gt; x = [1, 2, 3]
&gt;&gt;&gt; count(*(float(y) for y in x), **{'three': x.pop()})
1.0, 2.0, 3
</code></pre>
<p><sub>*The reason why generator works and <code>map</code> or list comprehension fails is explained at the end.</sub></p>
<hr/>
<h2>Python 3.5</h2>
<p>The <a href="https://hg.python.org/cpython/file/3.5/Python/ast.c#l2617" rel="nofollow"><code>ast_for_call</code></a> function here only maintains two lists: <code>args</code> and <code>keywords</code>. </p>
<p>Here the <code>varargs</code> are inserted into the args list and <code>kwargs</code> go to the <code>keywords</code> list. So, in the end the call looks like:</p>
<pre><code>return Call(func, args, keywords, func-&gt;lineno, func-&gt;col_offset, c-&gt;c_arena);
</code></pre>
<p><strong>Byte code:</strong></p>
<pre><code>&gt;&gt;&gt; dis.dis(lambda: func(1, 2, *('k', 'j', 'l'), z=1, y =2, three=x.pop(), **{kwarg:1}))
  1           0 LOAD_GLOBAL              0 (func)
              3 LOAD_CONST               1 (1)
              6 LOAD_CONST               2 (2)
              9 LOAD_CONST               9 (('k', 'j', 'l'))
             12 LOAD_CONST               6 ('z')
             15 LOAD_CONST               1 (1)
             18 LOAD_CONST               7 ('y')
             21 LOAD_CONST               2 (2)
             24 LOAD_CONST               8 ('three')
             27 LOAD_GLOBAL              1 (x)
             30 LOAD_ATTR                2 (pop)
             33 CALL_FUNCTION            0 (0 positional, 0 keyword pair)
             36 LOAD_GLOBAL              3 (kwarg)
             39 LOAD_CONST               1 (1)
             42 BUILD_MAP                1
             45 CALL_FUNCTION_VAR_KW   770 (2 positional, 3 keyword pair)
             48 RETURN_VALUE
</code></pre>
<p>Now things can get a little exciting if the expression yielding the <code>varargs</code> is lazy:</p>
<pre><code>&gt;&gt; def count(one, two, three):
        print (one, two, three)
...
&gt;&gt;&gt; x = [1, 2, 3]
&gt;&gt;&gt; count(*map(float, x), three=x.pop())  # map is lazy in Python 3
1.0 2.0 3
&gt;&gt;&gt; x = [1, 2, 3]
&gt;&gt;&gt; count(*[float(y) for y in x], three=x.pop())
Traceback (most recent call last):
  File "&lt;ipython-input-25-b7ef8034ef4e&gt;", line 1, in &lt;module&gt;
    count(*[float(y) for y in x], three=x.pop())
TypeError: count() got multiple values for argument 'three'
</code></pre>
<p><strong>Byte code:</strong></p>
<pre><code>&gt;&gt;&gt; dis.dis(lambda: count(*map(float, x), three=x.pop()))
  1           0 LOAD_GLOBAL              0 (count)
              3 LOAD_GLOBAL              1 (map)
              6 LOAD_GLOBAL              2 (float)
              9 LOAD_GLOBAL              3 (x)
             12 CALL_FUNCTION            2 (2 positional, 0 keyword pair)
             15 LOAD_CONST               1 ('three')
             18 LOAD_GLOBAL              3 (x)
             21 LOAD_ATTR                4 (pop)
             24 CALL_FUNCTION            0 (0 positional, 0 keyword pair)
             27 CALL_FUNCTION_VAR      256 (0 positional, 1 keyword pair)
             30 RETURN_VALUE
&gt;&gt;&gt; dis.dis(lambda: count(*[float(y) for y in x], three=x.pop()))
  1           0 LOAD_GLOBAL              0 (count)
              3 LOAD_CONST               1 (&lt;code object &lt;listcomp&gt; at 0x103b63930, file "&lt;ipython-input-28-1cc782164f20&gt;", line 1&gt;)
              6 LOAD_CONST               2 ('&lt;lambda&gt;.&lt;locals&gt;.&lt;listcomp&gt;')
              9 MAKE_FUNCTION            0
             12 LOAD_GLOBAL              1 (x)
             15 GET_ITER
             16 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
             19 LOAD_CONST               3 ('three')
             22 LOAD_GLOBAL              1 (x)
             25 LOAD_ATTR                2 (pop)
             28 CALL_FUNCTION            0 (0 positional, 0 keyword pair)
             31 CALL_FUNCTION_VAR      256 (0 positional, 1 keyword pair)
             34 RETURN_VALUE
</code></pre>
<p>The lazy call works because unpacking(aka actual evaluation of the generator) doesn't happen until the function is actually called, hence in this case <code>pop()</code> call will remove the 3 first and then later on map will only pass 1, 2.</p>
<p>But, in the case of list comprehension the list object already contains 3 items and then even though <code>pop()</code> removed 3 later on we are still passing two values for the third argument.</p>
</div>
<span class="comment-copy">You pop an element off so you are left with two args in the first example</span>
<span class="comment-copy">But why do I <code>pop</code> before I <code>map</code>?</span>
<span class="comment-copy">Because reasons. Honestly there's no obvious expected behavior here. If any of these worked I would consider it entirely luck and wouldn't rely on it. Write clearly and avoid mutation where possible otherwise it's very difficult to reason about what should happen.</span>
<span class="comment-copy">The statement and the example following it below the "CPython implementation detail" seems relevant here: <a href="https://docs.python.org/3/reference/expressions.html#calls" rel="nofollow noreferrer">Python Language Reference » Expressions » Calls</a>: "although the <code>*expression</code> syntax may appear <i>after</i> some keyword arguments, it is processed <i>before</i> the keyword arguments"</span>
<span class="comment-copy">Thanks for the detailed insight! So to summarize: It happens to work in CPython 2.7, but not in general in 3.5, except when using <code>map</code>; but it's an implementation detail and cannot be relied on?</span>
<span class="comment-copy">@mkrieger1 It's not an implementation detail but a version detail, Python 2 and Python 3 are handling things differently. But across different implementation the output should match, for example I tested on PyPy 2.7.9 and it works same as CPython 2.7.10. Things have changed between Python 3.4 and 3.5 as well, for example now something like <code>count(*(1,), *(2, 3))</code> is valid(because of <a href="https://docs.python.org/3/whatsnew/3.5.html#whatsnew-pep-448" rel="nofollow noreferrer">PEP-448</a>) in Python 3.5 but not in older versions of Python 3.x.</span>
