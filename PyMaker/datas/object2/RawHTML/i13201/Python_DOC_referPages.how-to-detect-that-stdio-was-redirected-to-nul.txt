<div class="post-text" itemprop="text">
<p>I'm developing a package to fix several issues with Unicode in Python run in standard Windows console environment: <a href="https://github.com/Drekin/win-unicode-console" rel="nofollow">https://github.com/Drekin/win-unicode-console</a>. The key operation is to replace the standard stream objects when needed. For this I need to detect whether the standard streams were redirected or not. Python method <code>isatty()</code> works OK with one exception: If a stream was redirected to <code>nul</code>, then <code>isatty()</code> returns <code>True</code>.</p>
<p>My question is how to detect whether a Windows handle leads to a console or to <code>nul</code>? Is there a WinAPI function for that?</p>
</div>
<div class="post-text" itemprop="text">
<p>The C runtime's <a href="https://msdn.microsoft.com/en-us/library/f4s0ddew" rel="nofollow"><code>_isatty</code></a> function returns true for files that access character devices, i.e. files for which <a href="https://msdn.microsoft.com/en-us/library/aa364960" rel="nofollow"><code>GetFileType</code></a> returns <code>FILE_TYPE_CHAR</code>. To detect a console handle in particular you can call <a href="https://msdn.microsoft.com/en-us/library/ms683167" rel="nofollow"><code>GetConsoleMode</code></a>. This call fails for a non-console handle. To get the underlying Windows handle to pass to this function, call <a href="https://docs.python.org/3/library/msvcrt.html#msvcrt.get_osfhandle" rel="nofollow"><code>msvcrt.get_osfhandle</code></a>. For example:</p>
<pre class="lang-python prettyprint-override"><code>import ctypes
import msvcrt

kernel32 = ctypes.WinDLL('kernel32', use_last_error=True)
ERROR_INVALID_HANDLE = 6

def isconsole(fd):
    handle = msvcrt.get_osfhandle(fd)
    if kernel32.GetConsoleMode(handle, ctypes.byref(ctypes.c_uint())):
        return True
    last_error = ctypes.get_last_error()
    if last_error != ERROR_INVALID_HANDLE:
        raise ctypes.WinError(last_error)
    return False
</code></pre>
</div>
<span class="comment-copy">Thank you again. I currently use <code>kernel32.GetLastError</code> and <code>kernel32.GetStdHandle</code> instead of <code>ctypes.get_last_error</code> and <code>msvcrt.get_osfhandle</code>, respectively. Is there a reason to prefer one over another?</span>
<span class="comment-copy">@user87690, I could change the answer to use <code>GetStdHandle</code>. The C runtime tries to keep file descriptors 0, 1, and 2 in sync with Windows <code>StandardInput</code>, <code>StandardOutput</code>, and <code>StandardError</code>. But a program might manually call <code>SetStdHandle</code>, bypassing the CRT. Which do you prefer, to use the handle associated with the C standard file descriptor, or to always use the Windows standard handle?</span>
<span class="comment-copy">@user87690, as to calling <code>GetLastError</code> directly, that's generally OK. However, there is a lot of code between high-level Python statements, so I prefer to load the DLL with <code>use_last_error=True</code> to capture the thread's last error in a thread-local variable. ctypes swaps this thread-local in via <code>SetLastError</code> just before calling the target function, and swaps it back out via <code>GetLastError</code> just after the call. It's accessed by calling <code>ctypes.get_last_error</code> and <code>ctypes.set_last_error</code>.</span>
