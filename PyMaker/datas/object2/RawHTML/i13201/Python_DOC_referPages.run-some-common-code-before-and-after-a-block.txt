<div class="post-text" itemprop="text">
<p>In a current project, I found myself often writing code like so:</p>
<pre><code>statement_x()

do_something()
do_other_thing()

statement_y()

# ...

statement_x()

do_third_thing()
do_fourth_thing()

statement_y()
</code></pre>
<p>As you can see, <code>statement_x</code> and <code>statement_y</code> often get repeated, and they are always paired, but I am unable to condense them into a single statement. What I would really like is a language construct like this:</p>
<pre><code>def env wrapping:
    statement_x()

    run_code

    statement_y()
</code></pre>
<p>In this case, I'm pretending <code>env</code> is a Python keyword indicating a special "sandwich function" that runs certain statements before and after a given block, the point of entry of the block being indicated by the second keyword <code>run_code</code>.</p>
<p>My above program can now be made more readable using this construct:</p>
<pre><code>env wrapping:
    do_something()
    do_other_thing()

env wrapping:
    do_third_thing()
    do_fourth_thing()
</code></pre>
<p>Which I mean to have the exact same behavior.</p>
<hr/>
<p>As far as I know such a construct does not exist, and the point of my question is not to speculate on future Python features. However, surely this situation of "run some common code before and after a variable block" must occur often enough that Python has a convenient way of dealing with it! What is this way? Or is the Pythonic solution to simple give up and accept the repetition?</p>
<p><strong><em>PS:</em></strong> I realize that I could write a function that takes the variable statements as an argument, but that would not be very user-friendly - I would end up writing huge lists of statements inside the parens of my function.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <a href="https://docs.python.org/3/reference/compound_stmts.html#the-with-statement" rel="nofollow"><code>with</code> statement</a>.</p>
<p>Example using <a href="https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager" rel="nofollow"><code>contextlib.contextmanager</code></a>:</p>
<pre><code>import contextlib                                                               

@contextlib.contextmanager
def doing_xy():
    print('statement_x')
    yield
    print('statement_y')
</code></pre>
<p>Example usage:</p>
<pre><code>&gt;&gt;&gt; with doing_xy():
...     print('do_something')
...     print('do_other_thing')
... 
statement_x
do_something
do_other_thing
statement_y
&gt;&gt;&gt; with doing_xy():
...     print('do_third_thing')
...     print('do_fourth_thing')
... 
statement_x
do_third_thing
do_fourth_thing
statement_y
</code></pre>
</div>
<span class="comment-copy">A further benefit of the <code>with</code> statement is that the <code>statement_y</code> bit that runs after the block of code gets run even if the block raised an exception.</span>
<span class="comment-copy">@Blckknght, To do that, <code>yield</code> statement and the rest should be guarded with <code>try .. finally ...</code>.</span>
<span class="comment-copy">Ah, yeah, I should have said: "it allows you to have <code>statement_y</code> run even if an exception is raised". You do have to do a little bit of work to enable it.</span>
