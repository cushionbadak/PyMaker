<div class="post-text" itemprop="text">
<p>I want to create all possible distributions of n items. This refers to the commonly known pigeonhole principle.</p>
<p>The following values are the result of Microsoft Excel:</p>
<pre><code>get_distributions(list, number_of_items_to_distribute)
get_distributions([], 1) = [[1]]
get_distributions([], 2) = [[1, 1], [2]]
get_distributions([], 3) = [[1, 1, 1], [1, 2], [2, 1], [3]]
get_distributions([], 4) = [[1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [1, 3], [2, 1, 1], [2, 2], [3, 1], [4]]
</code></pre>
<p>I already have some code, but there are some issues with deleting the temporary lists.</p>
<pre><code>all_distributions = []

def get_distributions(distribution, items):

    print('call with distribution = ' + str(distribution) + ', items = ' + str(items))
    print('---------------')

    # base case
    if items == 0:
        all_distributions.append(distribution)
        print('end: ' + str(distribution))
        distribution.clear()
        return []

    # recursion
    else:
        for i in range(1, items + 1):
            distribution.append(i)
            get_distributions(distribution, items - i)
</code></pre>
<p>With this I get good results printed out after "end: ", but some values like [1, 2] (calling with n = 3) are missing. Additionally to this the values are not appended to my all_distributions.</p>
<p>I'm interested in the way I tried to solve this problem. Is this a good approach or am I absolutely wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>The main problem with your code is that the list <code>all_distributions</code> ends up containing many references to the same input list <code>distribution</code>. When you call <code>all_distributions.append(distribution)</code>, the list <code>distribution</code> is not copied into the list <code>all_distributions</code>, but merely a reference to the list is appended. You can fix this by explicitly inserting a copy: <code>all_distributions.append(list(distribution))</code></p>
<p>A minimal fix to your code is to insert copies, remove <code>distribution.clear()</code> in the base case, and adding <code>distribution.pop()</code> after the recursive call:</p>
<pre><code>all_distributions = []

def get_distributions(distribution, items):
    if items == 0:
        all_distributions.append(list(distribution))
    else:
        for i in range(1, items + 1):
            distribution.append(i)
            get_distributions(distribution, items - i)
            distribution.pop()

get_distributions([], 3)
print(all_distributions)
</code></pre>
<p>Outputs: <code>[[1, 1, 1], [1, 2], [2, 1], [3]]</code></p>
<hr/>
<p>A better way is to avoid using <code>distribution.append</code>, and instead using the plus operator on lists, like so:</p>
<pre><code>def get_distributions(distribution, items):
    if items == 0:
        all_distributions.append(distribution)
    else:
        for i in range(1, items + 1):
            d = distribution + [i]
            get_distributions(d, items - i)
</code></pre>
<p>The plus operator on lists creates a new list by concatenating the two given lists. In this case, we are concatenating a single element <code>i</code> on the right side of <code>distribution</code> to get a new copy containing the elements in <code>distribution</code> followed by <code>i</code>.</p>
<hr/>
<p>Another improvement is to avoid the global variable <code>all_distributions</code>, and instead return the list of distributions:</p>
<pre><code>def get_distributions(distribution, items):
    if items == 0:
        return [distribution]
    else:
        all_distributions = []
        for i in range(1, items + 1):
            d = distribution + [i]
            all_distributions += get_distributions(d, items - i)
        return all_distributions

print(get_distributions([], 4))
</code></pre>
<p>Outputs: <code>[[1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [1, 3], [2, 1, 1], [2, 2], [3, 1], [4]]</code></p>
</div>
<span class="comment-copy">what does clear method?, list hasn't this attribute</span>
<span class="comment-copy">@PasqualGuerrero: The <code>clear</code> method exists in Python 3. <a href="https://docs.python.org/3/tutorial/datastructures.html" rel="nofollow noreferrer">docs.python.org/3/tutorial/datastructures.html</a></span>
<span class="comment-copy">The <code>list(distribution)</code> may still parse distribution allocation to <code>all_distributions</code> so that 'all_distribtuions` is altered as <code>distribution</code> is. The best way would be to use <code>deepcopy</code>. <code>from copy import deepcopy as dc</code> then change <code>list(distribution)</code> to <code>dc(distribution)</code></span>
<span class="comment-copy">@GabrielS.Gusm√£o: <code>deepcopy</code> is overkill in this situation, as there is no reason the elements in <code>distribution</code> should recursively be copied; using <code>copy.copy</code> is sufficient. Of course, in this case, <code>distribution</code> contains integers, so it does not matter, but you should always think before choosing <code>copy</code> or <code>deepcopy</code>.</span>
<span class="comment-copy">You're right. That is true indeed. But <code>list</code> should not be used anyways. Change it so I can upvote the answer.</span>
