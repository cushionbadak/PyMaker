<div class="post-text" itemprop="text">
<p>How to match anything except two or more consecutive spaces in a regex? </p>
<p>I have a test string like </p>
<pre><code>string = ' a      title of foo        b '
</code></pre>
<p>I would like to capture <code>title of foo</code> from string. Basically, this means that we start with any number of spaces, followed by a combination of letters and spaces, but never more than one consecutive space, and then again by any number of spaces. </p>
<p>Attempt (in python). </p>
<pre><code>string = '      title of foo        '
match = re.match('\s*([^\s{2,}])*\s*', string)
</code></pre>
<p>This doesn't work because the square brackets need a list, I think. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use this lookahead based regex:</p>
<pre><code>&gt;&gt;&gt; string = ' a      title of foo        b '

&gt;&gt;&gt; print re.search(r'\S+(?:(?!\s{2}).)+', string).group()
title of foo
</code></pre>
<p><a href="https://regex101.com/r/kR5rK4/1" rel="nofollow">RegEx Demo</a></p>
</div>
<div class="post-text" itemprop="text">
<p>It would be easier to just use:</p>
<pre><code>stripped_string = string.strip()
</code></pre>
<p>The function <code>strip()</code> removes the whitespace from the start and end of a string.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you want to <em>match</em> everything <em>except</em> X, it's often simpler to <em>split</em> by X instead. In other words: Instead of inverting the regex, invert the operation.</p>
<p>In your case, just <a href="https://docs.python.org/3/library/re.html#re.split" rel="nofollow"><code>re.split</code></a> by two or more spaces, i.e.<code>\s{2,}</code>, and keep what remains.</p>
<pre><code>&gt;&gt;&gt; text = '      title of foo       more text   and some more     '
&gt;&gt;&gt; re.split(r'\s{2,}', text)
['', 'title of foo', 'more text', 'and some more', '']
</code></pre>
<p>This will yield two additional empty matches at the very beginning and the end of the string, but you can easily get rid of them, e.g. using <code>filter</code>, or a list comprehension:</p>
<pre><code>&gt;&gt;&gt; filter(None, re.split(r'\s{2,}', text))
['title of foo', 'more text', 'and some more']
</code></pre>
<p>In my opinion, this is much simpler and more concise than a complex regex using lots of lookaheads and stuff to actually match the part that's <em>not</em> two or more spaces.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would go with</p>
<pre><code>/(\b\w+(?: \w+\b)+)/
</code></pre>
<p><a href="https://regex101.com/r/xC3bZ4/1" rel="nofollow">regex101</a></p>
<p>You can use <code>code generator</code> on the left side of that page to give you this generated version:</p>
<pre><code>import re
p = re.compile(ur'(\b\w+(?: \w+\b)+)')
test_str = u"string = ' a      title of foo        b '"

re.findall(p, test_str)
</code></pre>
<p>Your match would then contain only <code>title of foo</code> without any of the other strings containing more than a single space between the words.</p>
<p>If you don't know whether your characters will always be <code>\w</code> word characters, but can contain anything other than whitespace, you can change <code>\w</code> to <code>\S</code> so it will match things like</p>
<pre><code>rabbit :gold: !whisker?
</code></pre>
<p>as those contain only a single space between them.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think this looks fairly clean but it does rely on double spaces existing either side of the text. I prefer anubhava's solution.</p>
<pre><code>string = ' a      title of foo        b '
regex=r'(?&lt;=  )(\S.*?\S?)(?=  )'
output=re.findall(regex, string)[0]
</code></pre>
</div>
<span class="comment-copy">Instead of matching, you could try splitting by 2 or more spaces</span>
<span class="comment-copy">@tobias_k Doesn't the split function take single characters as delimiters? How would this work?</span>
<span class="comment-copy">You're right this would work, but there are examples that are harder so I will edit my question.</span>
<span class="comment-copy">Fair enough! Although I will probably now get horribly downvoted...</span>
