<div class="post-text" itemprop="text">
<p>I understand that given an iterable such as</p>
<pre><code>&gt;&gt;&gt; it = [1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>I can turn it into a list and slice off the ends at arbitrary points with, for example</p>
<pre><code>&gt;&gt;&gt; it[1:-2]
[2, 3, 4, 5, 6, 7]
</code></pre>
<p>or reverse it with</p>
<pre><code>&gt;&gt;&gt; it[::-1]
[9, 8, 7, 6, 5, 4, 3, 2, 1]
</code></pre>
<p>or combine the two with</p>
<pre><code>&gt;&gt;&gt; it[1:-2][::-1]
[7, 6, 5, 4, 3, 2]
</code></pre>
<p>However, trying to accomplish this in a single operation produces in some results that puzzle me:</p>
<pre><code>&gt;&gt;&gt; it[1:-2:-1] 
[]
&gt;&gt;&gt;&gt; it[-1:2:-1] 
[9, 8, 7, 6, 5, 4]
&gt;&gt;&gt;&gt; it[-2:1:-1]
[8, 7, 6, 5, 4, 3]
</code></pre>
<p>Only after much trial and error, do I get what I'm looking for:</p>
<pre><code>&gt;&gt;&gt; it[-3:0:-1]
[7, 6, 5, 4, 3, 2]
</code></pre>
<p>This makes my head hurt (and can't help readers of my code):</p>
<pre><code>&gt;&gt;&gt; it[-3:0:-1] == it[1:-2][::-1]
True
</code></pre>
<p>How can I make sense of this? Should I even be pondering such things?</p>
<hr/>
<p>FWYW, my code does a lot of truncating, reversing, and listifying of iterables, and I was looking for something that was faster and clearer (yes, don't laugh) than <code>list(reversed(it[1:-2]))</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is because in a slice like - </p>
<pre><code>list[start:stop:step]
</code></pre>
<p><code>start</code> is <strong><em>inclusive</em></strong>, resultant list starts at index <code>start</code>.</p>
<p><code>stop</code> is <strong><em>exclusive</em></strong>, that is the resultant list only contains elements till <code>stop - 1</code> (and not the element at <code>stop</code>).</p>
<p>So for your case<code>it[1:-2]</code> - the <code>1</code> is <em>inclusive</em> , that means the slice result starts at index <code>1</code> , whereas the <code>-2</code> is <em>exclusive</em> , hence the last element of the slice index would be from index <code>-3</code>.</p>
<p>Hence, if you want the reversed of that, you would have to do <code>it[-3:0:-1]</code> - only then <code>-3</code> would be included in the sliced result, and the sliced result would go upto <code>1</code> index.</p>
</div>
<div class="post-text" itemprop="text">
<p>The important things to understand in your slices are</p>
<ul>
<li><p>Start will be included in the slice</p></li>
<li><p>Stop will <strong>NOT</strong> be included in the slice</p></li>
<li><p>If you want to slice backwards, the step value should be a negative value.</p></li>
</ul>
<p>Basically the range which you specify is a half-open (half-closed) range.</p>
<hr/>
<p>When you say <code>it[-3:0:-1]</code> you are actually starting from the third element from the back, till we reach <code>0</code> (not including zero), step one element at a time backwards.</p>
<pre><code>&gt;&gt;&gt; it[-3:0:-1]
[7, 6, 5, 4, 3, 2]
</code></pre>
<p>Instead, you can realize the start value like this</p>
<pre><code>&gt;&gt;&gt; it[len(it)-3 : 0 : -1]
[7, 6, 5, 4, 3, 2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think the other two answers disambiguate the usage of <a href="https://docs.python.org/3/library/functions.html#slice" rel="nofollow"><code>slicing</code></a> and give a clearer image of how its parameters work. </p>
<hr/>
<p>But, since your question also involves <strong><em>readability</em></strong> -- which, let's not forget, <strong><em>is a big factor especially in Python</em></strong> -- I'd like to point out how you can improve it slightly by assigning <code>slice()</code> objects to variables thus removing all those hardcoded <code>:</code> separated numbers. </p>
<p>Your truncate and reverse slice object could, alternatively, be coded with a usage implying name :</p>
<pre><code>rev_slice = slice(-3, 0, -1)
</code></pre>
<p>In some other config-like file. You could then use it in its named glory within slicing operations to make this <em>a bit</em> more easy on the eyes :</p>
<pre><code>it[rev_slice]  # [7, 6, 5, 4, 3, 2] 
</code></pre>
<p>This might be a trivial thing to mention, but I think it's probably worth it.</p>
</div>
<div class="post-text" itemprop="text">
<p>Why not create a function for readability:</p>
<pre><code>def listify(it, start=0, stop=None, rev=False):
    if stop is None:
        the_list = it[start:]
    else:
        the_list = it[start:stop]
    if rev:
        return the_list[::-1]
    else:
        return the_list

listify(it, start=1, stop=-2)  # [2, 3, 4, 5, 6, 7]
listify(it, start=1, stop=-2, rev=True)  # [7, 6, 5, 4, 3, 2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A good way to intuitively understand the Python slicing syntax is to see how it maps to the corresponding C <code>for</code> loop.</p>
<p>A slice like</p>
<pre><code>x[a:b:c]
</code></pre>
<p>gives you the same elements as</p>
<pre><code>for (int i = a; i &lt; b; i += c) {
  ...
}
</code></pre>
<p>The special cases are just default values:</p>
<ul>
<li><code>a</code> defaults to 0</li>
<li><code>b</code> defaults to <code>len(x)</code></li>
<li><code>c</code> defaults to 1</li>
</ul>
<p>Plus one more special case:</p>
<ul>
<li>if <code>c</code> is negative, then <code>a</code> and <code>b</code> are swapped and the <code>&lt;</code> is inverted to a <code>&gt;</code></li>
</ul>
</div>
<span class="comment-copy">I guess what this means is that "stride" really wasn't in the minds of the designers when they though about slice syntax (which has some conveniences, to be sure).</span>
<span class="comment-copy">Yea, I believe this could be a good read for that, not completely related to slicing, but does mention that - <a href="http://python-history.blogspot.in/2013/10/why-python-uses-0-based-indexing.html" rel="nofollow noreferrer">python-history.blogspot.in/2013/10/…</a></span>
<span class="comment-copy"><code>[7, 6, 5, 4, 3, 2]</code> is what I'm looking for, not <code>[8, 7, 6, 5, 4, 3, 2]</code> — i.e., <code>it[1:-2][::-1]</code>.</span>
<span class="comment-copy">Any idea on how performance of <code>slice</code> with a stride compares with <code>list</code> + <code>reversed</code>?</span>
<span class="comment-copy">Hm, this has been adressed <a href="http://stackoverflow.com/questions/3705670/best-way-to-create-a-reversed-list-in-python">here</a> so linking to this answer is the right thing to do (instead of just copying the contents). Additionally, as mentioned in the comments you'll have to make a tradeoff between readability and slight speed performance. If you have really large arrays, why don't you tackle this with good ol' numpy?</span>
<span class="comment-copy">Your statement that "<code>a</code> and <code>b</code> are swapped" in the negative step case seems very misleading. I think you mean that the default values are swapped, but that's not quite true. The default start value for a reversed slice is <code>-1</code> and the default end value is <code>-len(x)-1</code>. You can't specify that end index with a positive number, if you start at <code>len(x)-1</code> and try counting down, the end index will be <code>-1</code>, which means something different.</span>
<span class="comment-copy">@Blckknght: Good point. My mental model usually only thinks about the positive case. I'm not sure how best to articulate the negative case here.</span>
<span class="comment-copy">Hmm, looking in <a href="https://hg.python.org/cpython/file/default/Objects/listobject.c#l2415" rel="nofollow noreferrer">the cpython source for <code>list</code> slicing</a>, I see it doesn't directly use <code>stop</code> at all in the C <code>for</code> loop, but rather uses the computed number of items that will be in the slice and just counts that many items while incrementing an index variable by <code>step</code>. The <a href="https://hg.python.org/cpython/file/default/Objects/sliceobject.c#l246" rel="nofollow noreferrer">code for slice objects</a> that does the length calculation has <code>if (step &lt; 0)</code> checks all over the place.</span>
<span class="comment-copy">It might be more useful to think in Python, rather than <code>C</code>. Except where negative or (otherwise out of bounds) start or stop values are concerned, <code>x[start:stop:step]</code> is a lot like <code>[x[i] for i in range(start, stop, step)]</code>. You can get exactly correct handling of the edge cases by using a <code>slice</code> object and calling its <code>indicies</code> method with the length of our list to get the parameters for <code>range</code>: <code>[x[i] for i in range(*slice(start, stop, step).indicies(len(x)))]</code></span>
