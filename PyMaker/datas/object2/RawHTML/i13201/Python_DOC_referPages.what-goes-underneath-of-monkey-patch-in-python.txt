<div class="post-text" itemprop="text">
<p>I'm a bit confused and trying to understand what goes underneath in the hope that I would understand Monkey Patch better. </p>
<p>I've read <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="nofollow">Where to patch</a> and I understand that I have to patch from where you use the module. But in the documentation. </p>
<pre><code>a.py
    -&gt; Defines SomeClass

b.py
    -&gt; from a import SomeClass
    -&gt; some_function instantiates SomeClass
</code></pre>
<p>If I do this <code>from a import SomeClass</code> </p>
<p>Then I have to patch like this.</p>
<p><code>@patch('b.SomeClass')</code></p>
<p>However, why if I import the module like this. </p>
<p><code>import a</code></p>
<p>I instead have to use the patch like this.</p>
<p><code>@patch('a.SomeClass')</code></p>
<p>I only understand how to use the patch but I don't understand why is this the case? Is it the way Python import module?</p>
</div>
<div class="post-text" itemprop="text">
<p>The goal is to intercept, and modify, the reference that will be used by functions whose behavior you want to affect. Initially, <code>a.SomeClass</code> and <code>b.SomeClass</code> point to the same object; but the patch will replace one of these references with something else.</p>
<p>In the documentation, the example is that you want to modify the <code>SomeClass</code> that is seen and used by <code>some_function</code>. So what matters is how <code>some_function()</code> refers to <code>SomeClass</code>:</p>
<ol>
<li><p>If <code>some_function</code> contains a reference to plain <code>SomeClass</code>, it will be resolved to a variable in its own module: <code>b</code> in this example (and incidentally <code>b</code> created this variable by importing it). Hence <code>b.SomeClass</code> is what needs to be patched.</p></li>
<li><p>If <code>some_function</code> explicitly refers to <code>a.SomeClass</code>, then that's the reference that needs to be patched.</p></li>
</ol>
<p>Suppose module <code>b.py</code> contains <em>both</em> of these lines:</p>
<pre><code>import a
from a import SomeClass
</code></pre>
<p>Which reference should be patched? Why, the one that is used by <code>some_function</code>! What matters is not how it's imported into <code>b</code>, but how it's accessed by the code that uses it.</p>
</div>
<div class="post-text" itemprop="text">
<p>This all has to do with namespaces.</p>
<p>Inside of <code>b.py</code>, when the command <code>from a import SomeClass</code> executes, <code>SomeClass</code> is added to the <em>namespace</em> of module <code>b</code>. Thus, you have <code>b.SomeClass</code>.</p>
<p>In the other case, when still inside of <code>b.py</code> and you execute the command <code>import a</code>, all that happens is that the module <code>b</code> now has access to the namespace of module <code>a</code>. So from a global point of view, the class being used inside of <code>b</code> is still <code>a.SomeClass</code>.</p>
</div>
