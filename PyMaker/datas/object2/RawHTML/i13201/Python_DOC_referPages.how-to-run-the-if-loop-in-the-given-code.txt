<div class="post-text" itemprop="text">
<p>Code works from <code>count=0</code> to count=9. Then it does not get in to the other elif code. I have commented which part is not working below. I have tried so many time by checking the value of count, still I could not find why the code doesn't work</p>
<pre><code>count =0
for line in sys.stdin:
  line = line.strip()
  print(count)
  if (count==0):
    a = int(line)                   #no of series
    count=1


  elif(count==1):             #2nd line 2 players 3 mtches
    plyrs_mtchs=[]  
    plyrs_mtchs= line.split()
    print(plyrs_mtchs)
    count+=1                        # #no of players , no of matches

  elif(count==2 or count==6):              
    players.append(str(line))
    print(players)
    count+=1


  elif(count==3,5 or count==7,9):               
    currenplyr = players[len(players)-1]        
    predict.append(line.split())
    count+=1


  elif(count==10 or count==11): #this code doesn't work      
    actual.append(line.split())
    count+=1

  elif(count==12):              #this code doesnt work
    actual.append(line.split())
    count+=1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your expression:</p>
<pre><code>elif(count==3,5 or count==7,9):               
</code></pre>
<p>does not do what you think it does. You are not testing if <code>count</code> has one of 4 possible values there. Python sees this as 3 different expressions forming a tuple:</p>
<pre><code>count==3
5 or count==7
9
</code></pre>
<p>producing the output</p>
<pre><code>(False, 5, 9)
</code></pre>
<p>if <code>count</code> is not equal to 3 and </p>
<pre><code>(True, 5, 9)
</code></pre>
<p>if it is. <code>5 or &lt;some other expression</code> will always return <code>5</code> because it is a non-zero numeric value, so true, and it doesn't matter what the other side of the <code>or</code> operator evaluates as anymore.</p>
<p>A tuple with 3 elements is <em>always true</em> in a boolean context, because it is a non-empty container. As such, that <code>elif</code> branch is <strong>always</strong> going to match if preceding <code>if</code> or <code>elif</code> tests failed.</p>
<p>See the <a href="https://docs.python.org/3/library/stdtypes.html#truth-value-testing" rel="nofollow"><em>Truth Value Testing</em></a> and <a href="https://docs.python.org/3/library/stdtypes.html#boolean-operations-and-or-not" rel="nofollow"><em>Boolean Operations</em></a> sections for details on how boolean testing and <code>or</code> work.</p>
<p>Use the <a href="https://docs.python.org/3/reference/expressions.html#membership-test-operations" rel="nofollow"><code>in</code> operator membership test</a> instead:</p>
<pre><code>elif count in {3, 5, 7, 9}:
</code></pre>
<p>where the test will be true if <code>count</code> has a value that's in the set of 4 possible values.</p>
</div>
<span class="comment-copy"><code>elif(count==3,5 or count==7,9)</code> won't work either.</span>
<span class="comment-copy">It works well no problem with it</span>
<span class="comment-copy">On the contrary, that is <i>exactly</i> your problem.</span>
<span class="comment-copy">@Pieters: Very nice and detailed answer. Just curious why you prefer a set in <code>count in {1, 2}</code> over a much simpler constant object - a tuple - like <code>count in (1, 2)</code>? Has the set an advantage? Thanks.</span>
<span class="comment-copy">@VPfB yes, set membership tests are faster (O(1) constant time). The Python 3 compiler actually stores a <code>frozenset()</code> object with the bytecode as it cannot be mutated anyway.</span>
<span class="comment-copy">@Pieters: Just tried a quick timing test and the set is faster indeed. Did not expect that for a really small set, because a hash must be computed. Learned something new again. Thanks.</span>
<span class="comment-copy">finally I found what it really was. Thanks for the explanation.</span>
