<div class="post-text" itemprop="text">
<p>So would this <code>par</code>:</p>
<pre><code>path = u'/a/b/c'
lam = lambda f: f.lower().startswith(u'distantlod')
par = functools.partial(lam, path)
</code></pre>
<p>and this <code>par</code>:</p>
<pre><code>path = u'/a/b/c'
startsWith = path.lower().startswith
par = lambda: startsWith(u'distantlod')
</code></pre>
<p>be equivalent ? If not why ?</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's my experiment with cProfile to see if I can confirm @yuvi's measurements above.</p>
<p><strong>CODE</strong>: <code>par_profile.py</code></p>
<pre><code>import cProfile as profile
import functools


path = u'/a/b/c'

lam = lambda f: f.lower().startswith(u'distantlod')
par = functools.partial(lam, path)

startsWith = path.lower().startswith
par2 = lambda: startsWith(u'distantlod')


if __name__ == '__main__':
    profile.run("for _ in range(1000000): par()")
    profile.run("for _ in range(1000000): par2()")
</code></pre>
<p><strong>OUT</strong></p>
<pre><code>$ python par_profile.py 
         3000003 function calls in 0.536 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.148    0.148    0.536    0.536 &lt;string&gt;:1(&lt;module&gt;)
  1000000    0.242    0.000    0.388    0.000 par_profile.py:7(&lt;lambda&gt;)
        1    0.000    0.000    0.536    0.536 {built-in method exec}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
  1000000    0.054    0.000    0.054    0.000 {method 'lower' of 'str' objects}
  1000000    0.092    0.000    0.092    0.000 {method 'startswith' of 'str' objects}


         2000003 function calls in 0.347 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.130    0.130    0.347    0.347 &lt;string&gt;:1(&lt;module&gt;)
  1000000    0.126    0.000    0.218    0.000 par_profile.py:11(&lt;lambda&gt;)
        1    0.000    0.000    0.347    0.347 {built-in method exec}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
  1000000    0.092    0.000    0.092    0.000 {method 'startswith' of 'str' objects}
</code></pre>
<p>Firstly it looks like these measurements on my machine tally with @yuvi's numbers:</p>
<ul>
<li><code>par</code> is about 540 nanoseconds</li>
<li><code>par2</code> is about 350 nanoseconds</li>
</ul>
<p>So I agree <code>par2</code> looks faster by about 200 ns.</p>
<p>It looks like if you're trying to compare <code>lambda</code> and <code>partial</code> it's not a fair test - <code>par2</code> has one less call since it doesn't call <code>lower</code>, whereas <code>par</code> does.</p>
<p>To illustrate why, <code>startsWith</code> could be rewritten as:</p>
<pre><code>lower_path = path.lower()
startsWith = lower_path.startswith
</code></pre>
<p>... so <code>par2</code> is just a <code>lambda</code> that contains a single <code>startswith</code> whereas <code>par</code> is a partial that contains both <code>lower</code> and <code>startswith</code> calls.</p>
<p>Therefore they are not equivalent and <code>par</code> is slower as a result.</p>
<p><strong>WHY?</strong></p>
<p>The question is "why <code>f.lower().startswith</code> is not inlined - what prohibits the language from inlining it?"</p>
<p>Firstly, this Python itself does not prohibit this kind of inlining - it's the different Python implementations that makes the decisions, in the case of my tests above it's cpython 3.</p>
<p>Secondly, <code>partial</code>'s job is not to inline functions, it just...</p>
<blockquote>
<p>“freezes” some portion of a function’s arguments and/or keywords resulting in a new object with a simplified signature (<a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow">doc</a>)</p>
</blockquote>
<p>Instead if you're looking at something that will do inlining in Python, then I'd check out something like <a href="http://numba.pydata.org/numba-doc/0.17.0/user/jit.html" rel="nofollow">Numba's jit</a> or run some experiments with PyPy (please post back here if you find some interesting improvements).</p>
<p>If you're not able to find anything that'll do the inlining you're looking for, then maybe it's a good case for a new Python module!</p>
</div>
<span class="comment-copy">Perhaps related: <a href="http://stackoverflow.com/questions/3252228/python-why-is-functools-partial-necessary">What functionality does functools.partial offer that you can't get through lambdas?</a></span>
<span class="comment-copy">@yuvi: It is related but does not answer this particular question - also related is: <a href="http://stackoverflow.com/q/17388438/281545">stackoverflow.com/q/17388438/281545</a></span>
<span class="comment-copy">Could you clarify how you define 'equivalent'?</span>
<span class="comment-copy">@jamesc: in terms of performance (what inline is about). <code>par</code> is a function in both cases doing the same thing when called as par() - but in the second case <code>path.lower().startswith</code> is inlined in the call (saving us two dots). It seems python could do this in the first case - does it do it and if not why (or what am I missing) ?</span>
<span class="comment-copy">If you want to compare performance you can always <a href="https://docs.python.org/2/library/timeit.html" rel="nofollow noreferrer">timeit</a></span>
<span class="comment-copy">Thanks - what I am asking however is <i>why</i> <code>f.lower().startswith</code> is not inlined - what prohibits the language from inlining it ?</span>
<span class="comment-copy">Updated to include my answer on why. Hope you find it helpful.</span>
