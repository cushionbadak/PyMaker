<div class="post-text" itemprop="text">
<p>I am trying to make a Warning waver which can look for known warnings in a log file. </p>
<p>The warnings in the waving file are copied directly from the log file during a review of the warnings. </p>
<p>The mission here is to make it as simple as possible. But i found that directly copying was a bit problematic due to that fact that the warnings could contain absolute paths. </p>
<p>So I added a "tag" which could be inserted into a warning which the system should look for. The whole string would then look like this. </p>
<pre><code>WARNING:HDLParsers:817 - ":RE[.*]:/modules/top/hdl_src/top.vhd" Line :RE[.*]: Choice . is not a locally static expression.
</code></pre>
<p>The tag is <strong>:RE[<em>Insert RegEx here</em>]:</strong>. 
In the above warning string there are two of these tags which I am trying to find using Python3 regex tool. And my pattern is the following:</p>
<pre><code>(:RE\[.*\]\:)
</code></pre>
<p>See <a href="https://regex101.com/r/qC6dT6/1" rel="nofollow" title="regex101">RegEx101</a> for reference</p>
<p>My problem with the above is that, when there are two tags in my string it finds only one result extended from the first to the last tag. how do i setup the regex so it will find each tag ?</p>
<p>Regards</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>re.findall</code> with the following regex that <strong>assumes that the regular expression inside the square brackets spans from <code>:RE[</code> up to the <code>]</code> that is followed by <code>]</code></strong>:</p>
<pre><code>:RE\[.*?]:
</code></pre>
<p>See <a href="https://regex101.com/r/uB4lM0/1" rel="nofollow">regex demo</a>. The <code>.*?</code> matches 0 or more characters other than a newline but as few as possible. See <a href="http://www.rexegg.com/regex-quantifiers.html#lazy_solution" rel="nofollow">rexegg.com description of a lazy quantifier solution</a>:</p>
<blockquote>
<p>The lazy <code>.*?</code> guarantees that the quantified dot only matches as many characters as needed for the rest of the pattern to succeed. </p>
</blockquote>
<p>See <a href="https://ideone.com/fork/CsBk76" rel="nofollow">IDEONE demo</a></p>
<pre><code>import re
p = re.compile(r':RE\[.*?]:')
test_str = "# Even more commments\nWARNING:HDLParsers:817 - \":RE[.*]:/modules/top/hdl_src/cpu_0342.vhd\" Line :RE[.*]: Choice . is not a locally static expression."
print(p.findall(test_str))
</code></pre>
<p>If you need to get the contents between the <code>[</code> and <code>]</code>, use a capturing group so that <code>re.findall</code> could extract just those contents:</p>
<pre><code>p = re.compile(r':RE\[(.*?)]:')
</code></pre>
<p>See <a href="https://ideone.com/SktLd2" rel="nofollow">another demo</a></p>
<p>To obtain indices, use <a href="https://docs.python.org/3/library/re.html#re.finditer" rel="nofollow"><code>re.finditer</code></a> (see <a href="https://ideone.com/BEO0Hy" rel="nofollow">this demo</a>):</p>
<blockquote>
<p><strong><code>re.finditer(pattern, string, flags=0)</code></strong><br/>
  Return an iterator yielding match objects over all non-overlapping matches for the <code>RE</code> pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result unless they touch the beginning of another match.</p>
</blockquote>
<pre><code>p = re.compile(r':RE\[(.*?)]:')
print([x.start(1) for x in p.finditer(test_str)])
</code></pre>
</div>
<span class="comment-copy">don't be greedy, <code>(:RE\[.*?\]\:)</code>, <a href="https://regex101.com/r/qC6dT6/2" rel="nofollow noreferrer">regex101.com/r/qC6dT6/2</a> .</span>
<span class="comment-copy">Are you using <code>re.findall</code> or <code>re.match</code>?</span>
<span class="comment-copy">Well, it depends on what can be inside <code>[]</code>. If there can be no <code>[</code> or <code>]</code>, use a negated class: <a href="https://regex101.com/r/eY6zX1/1" rel="nofollow noreferrer"><code>:RE\[[^[\]]*\]\:</code></a> with <code>re.findall</code>. Have a look at <a href="https://ideone.com/ulo2Sn" rel="nofollow noreferrer">the demo</a>. However, I guess you need the lazy dot matching here.</span>
<span class="comment-copy">@Avinash Raj - Works in regex 101. though not in Python3 re.search.</span>
<span class="comment-copy">@ppperry - i am using re.search. need the indexes</span>
<span class="comment-copy">This is what i was looking for thank you</span>
