<div class="post-text" itemprop="text">
<p>I'm wondering how to use a list to format multiple of the same keyword in Python 3.4. The way I have it set up is a user can pass in a string that has multiple keywords for names that the program will generate in their place, and the result should be a sentence with the keywords replaced with names.</p>
<p>I have already created a method to generate the names based on how many the program sees in the strings the user passes in, but cannot replace them at once because of the nature of the string. Since the string has multiple of the same keyword (for example {name}), I need to be able to replace each one of them with a unique string. Is that possible in Python 3.4?</p>
<p>The string the user passes in could be</p>
<pre><code>"{name} had a wonderful day at the park, but then {name} came and ruined it"
</code></pre>
<p>and after the program has generated the names it should be</p>
<pre><code>"John had a wonderful day at the park, but then Bob came and ruined it"
</code></pre>
<p>Cheers.</p>
<p>EDIT: To add, I didn't find anything about using lists or having multiple keywords but unique replacements, so if I have to do it another way than replace it's OK too.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/stdtypes.html#str.replace" rel="nofollow"><code>string.replace</code></a> with the optional <code>count</code> parameter and limit it to only replace one name each time:</p>
<pre><code>&gt;&gt;&gt; names = ['John', 'Bob']
&gt;&gt;&gt; message = "{name} had a wonderful day at the park, but then {name} came and ruined it"
&gt;&gt;&gt; i = 0;
&gt;&gt;&gt; while '{name}' in message:
...     message = message.replace('{name}', names[i], 1)
...     i += 1
... 
&gt;&gt;&gt; message
'John had a wonderful day at the park, but then Bob came and ruined it'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <code>count</code> parameter:</p>
<pre><code>&gt;&gt;&gt; s = "{name} had a wonderful day at the park, but then {name} came and ruined it"
&gt;&gt;&gt; s = s.replace('{name}', 'John', count=1)
&gt;&gt;&gt; s
'John had a wonderful day at the park, but then {name} came and ruined it'

&gt;&gt;&gt; s = s.replace('{name}', 'Bob', count=1)
&gt;&gt;&gt; s
'John had a wonderful day at the park, but then Bob came and ruined it'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you have pre-generated a list of items for each replacement based on how many times they occur, you can use <a href="https://docs.python.org/3/library/re.html#re.sub" rel="nofollow"><code>re.sub</code></a> to programmatically pick the next item from the list.  This will have much better performance than <code>str.replace</code>, esp. if you have a large dictionary of keywords and and a large text.</p>
<p>For example:</p>
<pre><code>import re

# Function to look up an item and return the next thing in its list.
def replace(m):
    return D[m.group(1)].pop(0)

D = {'name' : ['John','Bob'], 'place' : ['park']}

text = "{name} had a wonderful day at the {place}, but then {name} came and ruined it"
new_text = re.sub('{(.*?)}',replace,text)
print(new_text)
</code></pre>
<p>Output:</p>
<pre><code>John had a wonderful day at the park, but then Bob came and ruined it
</code></pre>
<p>It seems like you'd want a different variable for different names, however.  Then you can just use <code>format</code> with a dictionary:</p>
<p>import re</p>
<pre><code>D = {'name1':'John', 'name2':'Bob', 'place':'park'}
text = "{name1} had a wonderful day at the {place}, but then {name2} came and ruined it. {name2} is a jerk!"
print(text.format(**D))
</code></pre>
<p>Output:</p>
<pre><code>John had a wonderful day at the park, but then Bob came and ruined it. Bob is a jerk!
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If I understand you right, this should work: <br/>
<code>first_name = Bob</code> <br/>
<code>second_name = Sam</code><br/>
<code>"%s had a wonderful day at the park, but then %s came and ruined it" % (first_name, second_name)</code></p>
<p>Probably the cleanest way to do it</p>
</div>
<div class="post-text" itemprop="text">
<p>In case the phrase is always well spaced as in the example, you can do</p>
<pre><code>s = "{name} had a wonderful day at the park, but then {name} came and ruined it"
names = ['John', 'Bob']
ni = iter(names)
outs = ' '.join(next(ni) if el=='{name}' else el for el in s.split())
print(outs)
</code></pre>
<p>which produces</p>
<pre><code>'John had a wonderful day at the park, but then Bob came and ruined it'
</code></pre>
</div>
<span class="comment-copy">Can you show what code you have so far?</span>
<span class="comment-copy">The code itself is really messy, but it basically chooses random names based on the amount of {name} it finds into a list. The string is read from a text file and the program is used through the command line. Also, since I'm also using possessives, it has two different {name}-variables, but it's in Finnish so it's {nimi} and {nimen}</span>
<span class="comment-copy">I think the point was <code>{name}</code> is more descriptive for a template.</span>
<span class="comment-copy">Ah right, but if he didn't know he could do it with %s this offers him a much more concise way that all the .replace() functions</span>
<span class="comment-copy">They could use <code>{}</code>, or <code>{0}</code> and <code>{1}</code></span>
<span class="comment-copy">I suppose. Anyway, it might be helpful, it might not, but it's out there at least if he wants to use it</span>
<span class="comment-copy">The way the string is formatted is with an user-defined amount of {name}s, so this wouldn't work as I would need to create a new variable for each {name}, which to my understanding isn't possible. Thanks anyways.</span>
