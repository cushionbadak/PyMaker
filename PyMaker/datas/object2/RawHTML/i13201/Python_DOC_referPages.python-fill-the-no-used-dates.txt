<div class="post-text" itemprop="text">
<p>I have list like this:</p>
<pre><code>data = [
    (datetime.datetime(2015,1,1), 666),
    (datetime.datetime(2015,1,3), 777),
    (datetime.datetime(2015,2,1), 888),   
]
</code></pre>
<p>Do you guys have any idea how can I fill other date by 0? To get:</p>
<pre><code>data = [
    (datetime.datetime(2015,1,1), 666),
    (datetime.datetime(2015,1,2), 0),
    (datetime.datetime(2015,1,3), 777),
    (datetime.datetime(2015,1,4), 0),
    (datetime.datetime(2015,1,5), 0),
    (datetime.datetime(2015,1,6), 0),
    ... etc,
    (datetime.datetime(2015,2,1), 888),   
]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Once the start date is the first and the end is the last just create a set of all dates in the list, get the difference in days between the start and end then loop over that range of days, if the date is not in the set yield a tuple of the start date with n days added using timedelta and 0. If it does exist just yield the next item from the data list:</p>
<pre><code>from datetime import datetime, timedelta
from operator import itemgetter

data = [
    (datetime(2015, 1, 1), 666),
    (datetime(2015, 1, 3), 777),
    (datetime(2015, 2, 1), 888),
]


def add_missing(l):
    st = set(map(itemgetter(0), data))
    it = iter(l)
    start, end = data[0][0], data[-1][0]
    for day in range((end - start).days + 1):
        dte = start + timedelta(days=day)
        if dte not in st:
            yield (dte, 0)
        else:
            yield next(it)

data[:] = add_missing(data)
</code></pre>
<p>data will then contain your dates in order:</p>
<pre><code>[(datetime.datetime(2015, 1, 1, 0, 0), 666),
 (datetime.datetime(2015, 1, 2, 0, 0), 0),
 (datetime.datetime(2015, 1, 3, 0, 0), 777),
 (datetime.datetime(2015, 1, 4, 0, 0), 0),
 (datetime.datetime(2015, 1, 5, 0, 0), 0),
 (datetime.datetime(2015, 1, 6, 0, 0), 0),
 (datetime.datetime(2015, 1, 7, 0, 0), 0),
 (datetime.datetime(2015, 1, 8, 0, 0), 0),
 (datetime.datetime(2015, 1, 9, 0, 0), 0),
 (datetime.datetime(2015, 1, 10, 0, 0), 0),
 (datetime.datetime(2015, 1, 11, 0, 0), 0),
 (datetime.datetime(2015, 1, 12, 0, 0), 0),
 (datetime.datetime(2015, 1, 13, 0, 0), 0),
 (datetime.datetime(2015, 1, 14, 0, 0), 0),
 (datetime.datetime(2015, 1, 15, 0, 0), 0),
 (datetime.datetime(2015, 1, 16, 0, 0), 0),
 (datetime.datetime(2015, 1, 17, 0, 0), 0),
 (datetime.datetime(2015, 1, 18, 0, 0), 0),
 (datetime.datetime(2015, 1, 19, 0, 0), 0),
 (datetime.datetime(2015, 1, 20, 0, 0), 0),
 (datetime.datetime(2015, 1, 21, 0, 0), 0),
 (datetime.datetime(2015, 1, 22, 0, 0), 0),
 (datetime.datetime(2015, 1, 23, 0, 0), 0),
 (datetime.datetime(2015, 1, 24, 0, 0), 0),
 (datetime.datetime(2015, 1, 25, 0, 0), 0),
 (datetime.datetime(2015, 1, 26, 0, 0), 0),
 (datetime.datetime(2015, 1, 27, 0, 0), 0),
 (datetime.datetime(2015, 1, 28, 0, 0), 0),
 (datetime.datetime(2015, 1, 29, 0, 0), 0),
 (datetime.datetime(2015, 1, 30, 0, 0), 0),
 (datetime.datetime(2015, 1, 31, 0, 0), 0),
 (datetime.datetime(2015, 2, 1, 0, 0), 888)]
</code></pre>
<p>Based on your logic and expected output the data is ordered but if it  happened to be  random you could use min and max to get the start and end:</p>
<pre><code>def add_missing(l):
    st = set(map(itemgetter(0), data))
    it = iter(l)
    start, end = min(st), max(st)
    for day in range((end - start).days + 1):
        dte = start + timedelta(days=day)
        if dte not in st:
            yield (dte, 0)
        else:
            yield next(it)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To return zero for missing dates, you could use <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow"><code>collections.defaultdict</code></a>:</p>
<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; data = [
...     (datetime(2015,1,1), 666),
...     (datetime(2015,1,3), 777),
...     (datetime(2015,2,1), 888),
... ]
&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; x = defaultdict(int, data)
&gt;&gt;&gt; x[datetime(2015,1,1)]
666
&gt;&gt;&gt; x[datetime(2015,1,2)]
0
</code></pre>
<p><code>defaultdict</code> allows you to get values without creating a list that covers all values from the earliest date in the original list to the latest date. But if you need it; it is easy to make one:</p>
<pre><code>&gt;&gt;&gt; from datetime import timedelta
&gt;&gt;&gt; def date_interval(lo, hi, step):
...     while lo &lt;= hi:
...         yield lo
...         lo += step
... 
&gt;&gt;&gt; [(d, x[d]) for d in date_interval(min(x), max(x), timedelta(1))]
[(datetime.datetime(2015, 1, 1, 0, 0), 666),
 (datetime.datetime(2015, 1, 2, 0, 0), 0),
 (datetime.datetime(2015, 1, 3, 0, 0), 777),
 (datetime.datetime(2015, 1, 4, 0, 0), 0),
 (datetime.datetime(2015, 1, 5, 0, 0), 0),
 ...
 (datetime.datetime(2015, 1, 30, 0, 0), 0),
 (datetime.datetime(2015, 1, 31, 0, 0), 0),
 (datetime.datetime(2015, 2, 1, 0, 0), 888)]
</code></pre>
</div>
