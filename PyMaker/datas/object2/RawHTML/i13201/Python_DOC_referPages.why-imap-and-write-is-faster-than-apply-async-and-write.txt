<div class="post-text" itemprop="text">
<p>imap version:</p>
<pre><code>import os
import multiprocessing as mp
import timeit
import string
import random


PROCESSES = 5
FILE = 'test_imap.txt'



def remove_file():
    try:
        os.remove(FILE)
    except FileNotFoundError:
        pass


def produce(i):
    return [''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(32)) for i in range(100000)]


def imap_version():
    with mp.Pool(PROCESSES) as p:
        with open(FILE, 'a') as fp:
            for lines in p.imap_unordered(produce, range(5)):
                for line in lines:
                    fp.write(line + '\n')


if __name__ == '__main__':
    remove_file()
    imap_version_result = timeit.repeat("imap_version()", setup="from __main__ import imap_version", repeat=5, number=5)
    print('imap result:', imap_version_result)
</code></pre>
<p>apply_async version:</p>
<pre><code>import os
import multiprocessing as mp
import timeit
import string
import random


PROCESSES = 5
FILE = 'test_apply.txt'



def remove_file():
    try:
        os.remove(FILE)
    except FileNotFoundError:
        pass


def produce():
    return [''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(32)) for i in range(100000)]


def worker():
    lines = produce()
    with open(FILE, 'a') as fp:
        for line in lines:
            fp.write(line + '\n')


def apply_version():
    with mp.Pool(PROCESSES) as p:
        processes = []
        for i in range(5):
            processes.append(p.apply_async(worker))

        while True:
            if all((p.ready() for p in processes)):
                break


if __name__ == '__main__':
    remove_file()
    apply_version_result = timeit.repeat("apply_version()", setup="from __main__ import apply_version", repeat=5, number=5)
    print('apply result', apply_version_result)
</code></pre>
<p>Results:</p>
<pre><code>imap result: [62.71130559899029, 62.65627204600605, 62.534730065002805, 62.67373917000077, 62.74415319500258]
apply result [72.03727042900573, 72.17959955699916, 72.2304800950078, 72.02653418600676, 72.11620796499483]
</code></pre>
<p>I expected <code>imap</code> to be slower because child processes need to pickle the results to the main process and then write to file, whereas each child process in <code>apply_async</code> directly write the results to file. Instead, <code>imap</code> is slower than <code>apply_async</code>.</p>
<p>Why is this so?</p>
<p>nb: This was done using Python 3.4.3 on Mac OS X 10.11</p>
</div>
<div class="post-text" itemprop="text">
<p>A quick glance at your source code shows that the <code>imap_version()</code> opens your output file once per process where <code>apply_version()</code> opens it once per worker which is 5 times per process due to being inside your <code>range(5)</code> loop.</p>
<p><code>with open(FILE, 'a') as fp</code> is called 125 times in your async version vs 25 times in your imap version.</p>
</div>
<div class="post-text" itemprop="text">
<p>My guess is the busy loop is the culprit (besides it being an anti-pattern in its own right).</p>
<p>By checking the state yourself, you do redundant work: <code>multiprocessing</code>'s machinery does pretty much the same with the work queue behind the scenes (in <code>multiprocessing.pool.Pool._handle_workers()</code> running in a separate thread). On the other hand, <code>IMapIterator.next</code> uses <code>threading.Condition(threading.Lock())</code> to suspend the main thread's execution until an item is ready (so <code>_handle_workers</code> runs unhindered - remember that only one thread can run Python code at each moment).</p>
<p>Anyway, this is but another guess. The only decisive evidence would be a <a href="https://docs.python.org/3/library/profile.html?highlight=profile#instant-user-s-manual" rel="nofollow">profiling</a> result.</p>
</div>
<span class="comment-copy">Have you checked what the bottleneck is? Have you considered the downsides of resource contention?</span>
<span class="comment-copy">FWIW, in my testing, the two scripts are only a few seconds apart (~28.5 seconds for the <code>imap</code> version, and ~31.5 for the <code>apply_async</code> version).</span>
<span class="comment-copy">Also, adding a <code>time.sleep(0.4)</code> in your <code>while True</code> loop reduces the runtime of the <code>apply_async</code> version from ~31.5 to ~30 seconds. Try it on your system and see how much it improves performance. Doing that keeps your while loop from hogging CPU time from the workers.</span>
<span class="comment-copy">@KarolyHorvath how do you check what the bottleneck is?</span>
<span class="comment-copy">@nljson: that's your effort? Asking the same thing from me?</span>
<span class="comment-copy">I don't get it, how would that affect performance? Would you mind giving more explanation?</span>
<span class="comment-copy">Your file IO is included in your timing function so it is skewing the results. Opening a file 5x more often will add a bit of overhead when you are trying to benchmark results.</span>
<span class="comment-copy">So, does that mean I should stick to <code>imap</code> or are there any changes that might make <code>apply_async</code> version faster?</span>
<span class="comment-copy">You can change the <code>apply_async</code> version to work the same way as the <code>imap</code> version by moving the file io into the <code>p in processes</code> loop instead of during the data generation process.</span>
<span class="comment-copy">Exactly the same as <code>imap_apply()</code>. <code>with mp.Pool(PROCESSES) as p:</code>, open file, do your <code>apply_async</code> work, wait for results, write to file.</span>
