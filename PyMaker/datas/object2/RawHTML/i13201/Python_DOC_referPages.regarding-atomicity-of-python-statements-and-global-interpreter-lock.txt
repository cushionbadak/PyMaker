<div class="post-text" itemprop="text">
<p>I read somewhere that indexing a list e.g. l[3] is an atomic operation. Is the atomicity achieved because of global interpreter lock.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, indexing <strong>should</strong> be atomic, as long as you do it on a native list, and not one where someone could have redirected <code>__getitem__</code>; however, that's an <em>implementation detail</em>, and you can't rely on it.</p>
<p>No, it's not solely because of the GIL, but because switching between threads is only allowed between single interpreter instructions, and indexing is such a single instruction, but only in CPython. </p>
<p>Takeaway: <strong>Do not rely on atomicity in a high level scripting language such as python</strong>; if you need barriers, then use semaphores or explicitly atomic data types.</p>
</div>
<span class="comment-copy">Related: <a href="http://effbot.org/pyfaq/what-kinds-of-global-value-mutation-are-thread-safe.htm" rel="nofollow noreferrer">What kinds of global value mutation are thread-safe?</a></span>
<span class="comment-copy">@unutbu: yeah, I stumbled across that, too, but its age is unknown and I can't verify whether it applies to modern Python, too.</span>
<span class="comment-copy">@unutbu: official py2.7 source: <a href="https://docs.python.org/2/faq/library.html#what-kinds-of-global-value-mutation-are-thread-safe" rel="nofollow noreferrer">docs.python.org/2/faq/…</a> Closing sentence: <b>When in doubt, use a mutex!</b></span>
<span class="comment-copy">@MarcusMüller: Thanks for the link to the docs. It also applies to CPython3: <a href="https://docs.python.org/3/faq/library.html#what-kinds-of-global-value-mutation-are-thread-safe" rel="nofollow noreferrer">docs.python.org/3/faq/…</a></span>
