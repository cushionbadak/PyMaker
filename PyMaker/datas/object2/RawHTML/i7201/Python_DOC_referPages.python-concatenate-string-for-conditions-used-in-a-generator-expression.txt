<div class="post-text" itemprop="text">
<p>I have a set of conditions for a generator expression which will vary, and if possible, I thought to try concatenate the conditions as a string, and use this string variable inside the generator expression:</p>
<p>The following works fine:</p>
<pre><code>Total = sum(sale["Date"] == date for sale in Sales_Store)
</code></pre>
<p>Where date is an integer, and Sales_Store a list of dictionaries with same keys, "Date" is one of the key names. it returns the number of sales in the sales store which satisfy this condition.</p>
<p>But this gives error: unsupported operand type(s) for +: 'int' and 'str'</p>
<pre><code>strTest = "sale[\"Date\"] == date for sale in Sales_Store"
Total = sum(strTest)
</code></pre>
<p>Of course, I only want this condition in the generator expression if a certain other condition holds true, and have several other conditions to concatenate with this, each condition only applying in certain circumstances.</p>
<p>So do you know if there is way to make this concatenation work?</p>
</div>
<div class="post-text" itemprop="text">
<p>Strings are not executable code. Python won't look at a string and execute it if it could possibly be. You need to express your conditions differently.</p>
<p>You could just create a function that given <em>one</em> dictionary returns a boolean; for a simple expression you can create that function using the <code>lambda</code> syntax:</p>
<pre><code>condition = lambda d: d['Date'] == date
</code></pre>
<p>for larger tests you can use a <code>def condition(d):</code> function definition and use multiple statements, etc. Functions are executable expressions!</p>
<p>Then use that in a <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer"><code>map()</code> call</a> to apply the condition to each dictionary:</p>
<pre><code>sum(map(condition, Sales_Store))
</code></pre>
<p>If you need to <em>dynamically</em> change the conditions, then build a sequence of tests, and use the <a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow noreferrer"><code>any()</code></a> or <a href="https://docs.python.org/3/library/functions.html#all" rel="nofollow noreferrer"><code>all()</code></a> functions to combine these tests:</p>
<pre><code>conditions = (test1, test2, test3)
all_conditions = lambda d: all(t(d) for t in conditions)
any_condition = lambda d: any(t(d) for t in conditions)

all_conditions_sum = map(all_conditions, Sales_Store)
any_conditions_sum = map(any_conditions, Sales_Store)
</code></pre>
<p>As you can probably tell from the function names, <code>any()</code> will return <code>True</code> if <em>one</em> of the tests is true, <code>all()</code> if <em>all</em> of the tests are true.</p>
<p>How you select the tests to go into the <code>conditions</code> sequence is up to you. You could, for example, have a dictionary mapping a user-friendly string to a function and let an end-user decide.</p>
</div>
<div class="post-text" itemprop="text">
<p>Have you tried int() function convert everything to integers before addition?</p>
</div>
<span class="comment-copy">Nitpick: you don't have a list comprehension, you have a generator expression.</span>
<span class="comment-copy">Strings are not executable code. Python won't look at a string and execute it if it could possibly be.</span>
<span class="comment-copy">@Md.RezwanulHaque: the question is pretty clear without more code. I'm not sure what you expect to learn from 'full code'. For incomplete problems we ask for an <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>, never the full code.</span>
<span class="comment-copy">To add to this, the reason why OP has that specific error is because the <code>sum</code> function starts with the value 0 by default and adds values to it; that is where the <code>int</code> is coming from.</span>
<span class="comment-copy">Very helpful @Martijn Pieters, fyi what I should have mentioned probably is that the content of conditions actually depends on content of current 'sale' dictionary within the 'Sales_Store' list.</span>
<span class="comment-copy">fyi if anyone else reads this one day, I did    Total = sum(conditions(sale, date, end, p_id, c_id, s_id, r_id) for sale in Sales_Store)     and then as @Martijn suggestion, created function    def conditions (sal,...):    where had to change each variable name because it's function, bit ugly but it worked, this was for certain website challenge, so in real life would use proper database app I guess but not an option I think for this. fyi my final code worked for 10 out of 12 test inputs, timed out for other 2, I guess this was overall algo though, sorry still getting used markdown in comment.</span>
<span class="comment-copy"><code>bool</code> is a subclass of <code>int</code>, <code>True</code> and <code>False</code> <b>are integers already</b>, values <code>1</code> and <code>0</code>. How is this going to help with extracting the conditions out to a separate entity?</span>
