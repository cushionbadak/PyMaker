<div class="post-text" itemprop="text">
<p>In python 3.x, I am trying to implement a class that would be a proxy for a sequence given as a parameter. The proxy also takes a function that is called on each element of the input sequence.</p>
<p>What would be the correct way for the proxy class to implement the <code>__getitem__</code>, <code>__iter__</code> and <code>__len__</code> methods dynamically depending on their availability in the input sequence. Here is my attempt at doing this (I am calling my sequences "providers" and the function is a "transform"):</p>
<pre><code>class TransformProviderProxy:

    def __init__(self, input_provider, transform):
        self.input_provider = input_provider
        self.transform = transform

    def __iter__(self):
        # Use generator expressions to produce a new iterator when requested
        return (self.transform(data_sample) for data_sample in self.input_provider)

    def __getattr__(self, name):
        if name == "__getitem__" and hasattr(self.input_provider, "__getitem__"):
            return self._getitem_impl
        elif name == "__len__" and hasattr(self.input_provider, "__len__"):
            return self._len_impl
        else:
            return None

    def _getitem_impl(self, index):
        return self.transform(self.input_provider[index])

    def _len_impl(self):
        return len(self.input_provider)
</code></pre>
<p>However that fails because it seems that python bypasses <code>__getattr__</code> when looking for <code>__getitem__</code>. What would be the correct way to do this ?</p>
<p>As a bonus, would there be a way to do this while having my Proxy class inherit dynamically from <code>collections.abc.Sequence</code> or <code>collections.abc.Iterable</code> depending on the input sequence ?</p>
<p>PS: I also thought about just implementing <code>__getitem__</code> anyway and relying on catching TypeError when trying to call it on a non-indexable input sequence, but I would like to be able to check if my proxy class is indexable by looking for the presence of <code>__getitem__</code> without having to explicitly call it with an index.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just implement <code>__getitem__</code> and <code>__len__</code>. It will fail with the appropriate error message if the <code>input_provider</code> doesn't implement these operations:</p>
<pre><code>class TransformProviderProxy:

    def __init__(self, input_provider, transform):
        self.input_provider = input_provider
        self.transform = transform

    def __iter__(self):
        # Use generator expressions to produce a new iterator when requested
        return (self.transform(data_sample) for data_sample in self.input_provider)

    def __getitem__(self, index):
        return self.transform(self.input_provider[index])

    def __len__(self):
        return len(self.input_provider)
</code></pre>
<p>Just as example:</p>
<pre><code>&gt;&gt;&gt; t = TransformProviderProxy(2, lambda x: x+2)
&gt;&gt;&gt; t[1]
TypeError: 'int' object is not subscriptable

&gt;&gt;&gt; t = TransformProviderProxy([1,2,3,4], lambda x: x+2)
&gt;&gt;&gt; t[1]
4
</code></pre>
</div>
<span class="comment-copy">I edited my question just before you posted your answer sorry (you were too fast for me !). I had thought about this but I wanted to be able able to check if my class was indexable (ideally by checking if it was an instance of <code>collections.abc.Sequence</code>) without having to explicitly try to index it. Maybe I should just accept that your way is the more pythonic way ?</span>
<span class="comment-copy">Yes, <a href="https://docs.python.org/3/glossary.html#term-eafp" rel="nofollow noreferrer">EAFP (easier to ask forgiveness than permission)</a> is considered more "pythonic" than <a href="https://docs.python.org/3/glossary.html#term-lbyl" rel="nofollow noreferrer">LBYL (look before you leap)</a>. However you might want to checkout the 3rd party module <a href="http://wrapt.readthedocs.io/en/latest/wrappers.html#proxies-and-wrappers" rel="nofollow noreferrer"><code>wrapt</code> and it's <code>ObjectProxy</code></a>. That could contain some (already built) solution for your immediate problem. Sorry I haven't seen your last paragraph before ... :(</span>
