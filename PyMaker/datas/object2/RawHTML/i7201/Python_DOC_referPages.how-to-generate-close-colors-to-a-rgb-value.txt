<div class="post-text" itemprop="text">
<p>I'd like to be able to generate multiple colors close to one RGB color as the schema below.</p>
<p><a href="https://i.stack.imgur.com/10XUn.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/10XUn.png"/></a></p>
<p>Here's the what I've made using Python :</p>
<pre><code>def similarColors(rgb, loop=6):
    difference = 30
    colors = []
    for i in range(loop):
        red = rgb[0]
        red_highest = red + difference
        red_lowest = red - difference
        red = randint(red_lowest, red_highest)

        green = rgb[1]
        green_highest = green + difference
        green_lowest = green - difference
        green = randint(green_lowest, green_highest)

        blue = rgb[2]
        blue_highest = blue + difference
        blue_lowest = blue - difference
        blue = randint(blue_lowest, blue_highest)

        colors.append([red, green, blue])
    return colors

palette = similarColors([244, 83, 28])
</code></pre>
<p><strong>Question:</strong> I feel like I'm overcomplicating things with this method is there a way to make the code above cleaner and shorter? </p>
<p>I'd like to avoid doing the same process for each color (red, blue, green) separately, I am also not sure if this method is really precise for what I'm trying to achieve.</p>
</div>
<div class="post-text" itemprop="text">
<p>We can condense that code quite a bit by looping over the RGB components. However, there's a bug in your current algorithm: it can produce color channel values that are &lt; 0 or &gt; 255, so we need to fix that.</p>
<pre><code>from random import randint

def similarColors(rgb, loop=6):
    colors = []
    delta = 30
    for i in range(loop):
        new_rgb = [randint(max(0, x - delta), min(x + delta, 255)) for x in rgb]  
        colors.append(new_rgb)                
    return colors

colors = similarColors([244, 83, 28])
print(colors)
</code></pre>
<p><strong>typical output</strong></p>
<pre><code>[[249, 75, 28], [226, 111, 34], [235, 85, 46], [228, 66, 28], [244, 62, 8], [233, 102, 21]]
</code></pre>
<hr/>
<p>You said: "I am also not sure if this method is really precise for what I'm trying to achieve". I don't know exactly what you're trying to achieve, but one problem I can see is that the human visual system is not equally sensitive to R, G, &amp; B. So a change by a given amount in one channel will not have the same effect as the same change in another channel. To deal with that properly you need to work in a colorspace that's more closely aligned to the human visual system, eg <a href="https://en.wikipedia.org/wiki/Lab_color_space" rel="nofollow noreferrer">Lab color space</a>. However, we can get a reasonable approximation by using scaling factors on the channel deltas.</p>
<p>The Wikipedia article on <a href="https://en.wikipedia.org/wiki/Grayscale" rel="nofollow noreferrer">Grayscale</a> provides a formula that can be used to compute the luminance of a RGB color:</p>
<pre><code>y = 0.299*R + 0.587*G + 0.114*B
</code></pre>
<p>This formula was used in analog NTSC &amp; PAL television.</p>
<p>Here's a version of the above code that uses those scaling factors. We divide our base <code>delta</code> by those scaling factors, so the blue delta is the largest &amp; the green delta is smallest, because the eye is most sensitive to green and least sensitive to blue.</p>
<pre><code>def similarColors(rgb, loop=6):
    colors = []
    delta = 10
    deltas = [round(delta / u) for u in (0.299, 0.587, 0.114)]
    for i in range(loop):
        new_rgb = [randint(max(0, x - delta), min(x + delta, 255)) 
            for x, delta in zip(rgb, deltas)]
        colors.append(new_rgb)
    return colors

colors = similarColors([244, 83, 28])
print(colors)
</code></pre>
<p><strong>typical output</strong></p>
<pre><code>[[236, 84, 65], [233, 74, 78], [226, 93, 73], [249, 88, 89], [240, 84, 40], [226, 75, 22]]
</code></pre>
<p>To make that code more efficient, since we're using a fixed base <code>delta</code> we could pre-compute the <code>deltas</code> array, rather than re-computing it each time we call <code>similarColors</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>There's no need to copy-paste each color, you could use a for loop like this:</p>
<pre><code>def similarColors(rgb, loop=6, difference=30):
    colors = []
    for _ in range(loop):
        color = []
        for curr_color in rgb:
            color.append(randint(curr_color - difference, curr_color + difference))
        colors.append(color)

    return colors
</code></pre>
<p>Notice I also put <code>difference</code> in the parameters.</p>
<p>And there's a bug where the rgb parts can be &lt; 0 or &gt; 255, you could fix that by using <code>max(0, min(255, randint(curr_color - difference, curr_color + difference)))</code> instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you can use <code>numpy</code>, a <strong>much more compact solution</strong> is this:</p>
<pre><code>import numpy as np

def similarColors(rgb, loop=6):
    delta = 30
    origClrs = np.tile(np.array(rgb), (loop, 1))
    randOffsets = np.random.randint(-delta, delta, size=(loop, 3))
    return origClrs + randomOffsets
</code></pre>
</div>
<span class="comment-copy">I've added a new version to my answer that (partially) compensates for the fact that the human visual system isn't equally sensitive to red, green, and blue.</span>
<span class="comment-copy">Now make it in place, and I'd say it's even easier - no return value, and applying this on every pixel of a picture automatically alters the picture</span>
<span class="comment-copy">@Sanitiy Every Python function returns something: <code>None</code> is returned if there's no object explicitly returned. Sure, the function could accept a list arg and we could extend that with the new color list. That'd be better than extending a global <code>colors</code> list. I don't know what you mean exactly by "applying this on every pixel of a picture" because <code>similarColor</code> takes a single color value as its arg and returns 6 color values.</span>
<span class="comment-copy">For the precision I meant that if the color is orange, it'll show shades of oranges instead of other colors.</span>
<span class="comment-copy">@Lindow Ah, ok. The new version is a <i>bit</i> better in that respect. But we can do better if we work in the HSV or HLS color space. By making the hue delta small the new colors will have a similar hue to the original color. Take a look at the <a href="https://docs.python.org/3/library/colorsys.html" rel="nofollow noreferrer"><code>colorsys</code></a> module, which has the conversion functions you'll need, try to code something, and if you get stuck, ask a new question.</span>
