<div class="post-text" itemprop="text">
<p>I have a set of functions in python that gets the same 2 parameters + other parameters. </p>
<pre><code>def myMethodA (param1, param2, specificParm)
    do code

 def myMethodB (param1, param2, specificParm1 specificParam2)
    do code
</code></pre>
<p>I waned to create a decorator that replace the need to call with the first 2 parameters by pushing the parameters before calling the function:</p>
<pre><code>@withParams()
def myMethodA (specificParam)
        do code
</code></pre>
<p>But if I omit the parameters then the decorator can't call it either and if I leave them then the caller need to specify them as well.  </p>
<p>anyway to solve this?
Can I do something with args* but still have named parameters for specificParam?
Also, How can I reference param1 and param2 inside myMethodA </p>
</div>
<div class="post-text" itemprop="text">
<p>It sounds like you may want <code>functools.partial</code>.  It returns a new function with some parameters already specified:</p>
<pre><code>import functools

def withParams(func):
    return functools.partial(func,1,2)

@withParams
def myMethodA (param1, param2, specificParam):
    print(param1,param2,specificParam)

@withParams
def myMethodB (param1, param2, specificParam1, specificParam2):
    print(param1,param2,specificParam1, specificParam2)

myMethodA(10)
myMethodB(12,13)
</code></pre>
<blockquote>
<pre><code>1 2 10
1 2 12 13
</code></pre>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>You can add those two parameters when you call the function in the decorator's wrapper function as part of the <code>kwargs</code>. All decorated functions will automatically have those two parameters passed as keyword arguments before making the call:</p>
<pre><code>def withParams(func):
    def wrapper(*args, **kwargs):
        kwargs['param1'] = 1
        kwargs['param2'] = 2
        return func(*args, **kwargs)
    return wrapper

@withParams
def add(specificparam, *args, **kwargs):
      print(specificparam)  # 3
      print(args)           # (4,)
      print(kwargs)         # {'param2': 2, 'param1': 1}
      return specificparam + sum(args) + sum(kwargs.values())

print(add(3,4)) # 10
</code></pre>
<p>You can drop the <code>args</code> part if all you'll be passing from the main function call are the <em>specific parameters</em> for each function.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd recommend you go old school, and just reassign the names using <a href="https://docs.python.org/3/library/functools.html?highlight=functools.partial#functools.partial" rel="nofollow noreferrer"><code>functools.partial</code></a>:</p>
<pre><code># module foo

def func1(common_1, common_2, specific_1):
    pass

def func2(common_1, common_2, specific_2, specific_3):
    pass
</code></pre>
<p>Then elsewhere (or lower in the file, if you like) you can do this:</p>
<pre><code>import functools

import foo

common_args = (1, 'fred')
foo.func1 = functools.partial(foo.func1, *common_args)
foo.func2 = functools.partial(foo.func2, *common_args)

# ...

foo.func1('special')

foo.func2('equally special', 'but different')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Sounds like you need <code>functools.partial</code>, to pre-populate the "constant" parameters:</p>
<pre><code>&gt;&gt;&gt; from functools import partial

&gt;&gt;&gt; def myMethodA(param1, param2, specificParm):
        print("myMethodA(", param1, param2, specificParm, ")")

&gt;&gt;&gt;&gt; def myMethodB (param1, param2, specificParm1, specificParam2):
        print("myMethodB(", param1, param2, specificParm1, specificParam2, ")")

&gt;&gt;&gt; preMethodA = partial(myMethodA, "p1", "p2")
&gt;&gt;&gt; preMethodB = partial(myMethodB, "p1", "p2")
&gt;&gt;&gt; preMethodA(34)
myMethodA( p1 p2 34 )
&gt;&gt;&gt; preMethodB(8, 9)
myMethodB( p1 p2 8 9 )
</code></pre>
</div>
<span class="comment-copy">Take a look at <code>functools.partial</code> too</span>
<span class="comment-copy">This looks great but how does <code>myMethodA(10)</code> works if the signature is myMethodA (param1, param2, specificParam)?</span>
<span class="comment-copy">Both options solve the problem and both can be used. I picked the partial since the syntax is cleaner</span>
<span class="comment-copy">That's what a decorator does. Assigns a new function object to the function name. In this case the new function takes two fewer arguments and calls the original function with the two provided parameters plus any additional.</span>
<span class="comment-copy">@EranWitkon Anyway, I think Marktolonen answer is a great fit. +1</span>
<span class="comment-copy">This what I was hopping but isn't decorator just a function call? How would adding two parameters to a function that doesn;t expect them would work? I would expect to get something like ' method expected 1 parameter but 3 supplied</span>
<span class="comment-copy">Also, in this way, I can not reference param1 and param2 in myMethodA as they are not defined.</span>
<span class="comment-copy">@EranWitkon You could use <code>*args</code> in your function to collect <code>param2</code> and <code>param2</code> with the other arguments. See update.</span>
<span class="comment-copy">Yes, this is good but I wanted to still have the specific params with explicit names.  <code>def add(spesificParm1 spesificParam2, *args, **kwargs):</code></span>
<span class="comment-copy">@EranWitkon If you update your question with these requirements, I can improve the answer to fit them :)</span>
