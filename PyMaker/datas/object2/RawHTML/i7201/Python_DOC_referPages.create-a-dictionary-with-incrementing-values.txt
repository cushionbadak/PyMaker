<div class="post-text" itemprop="text">
<p>I have a list and I want to generate a dictionary <code>d</code> taking out duplicates and excluding a single item, such that the first key has value 0, the second has value 1, and so on.</p>
<p>I have written the following code:</p>
<pre><code>d = {}
i = 0
for l in a_list:
    if (l not in d) and (l != '&lt;'):
        d[l] = i
        i += 1
</code></pre>
<p>If <code>a_list = ['a', 'b', '&lt;', 'c', 'b', 'd']</code>, after running the code <code>d</code> contains <code>{'a': 0, 'b': 1, 'c': 2, 'd':3}</code>. Order is not important.
Is there a more elegant way to obtain the same result?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>{b: a for a, b in enumerate(set(a_list) - {'&lt;'})}
</code></pre>
<p><code>set(a_list)</code> creates a set from <code>a_list</code>.
That effectively strips duplicate numbers in <code>a_list</code>, as a <code>set</code> can only contain unique values.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>dict.fromkeys</code> to get your unique occurrences (minus values you don't want), then <code>.update</code> it to apply the sequence, eg:</p>
<pre><code>a_list = ['a', 'b', '&lt;', 'c', 'b', 'd']

d = dict.fromkeys(el for el in a_list if el != '&lt;')
d.update((k, i) for i, k in enumerate(d))
</code></pre>
<p>Gives you:</p>
<pre><code>{'a': 0, 'b': 1, 'd': 2, 'c': 3}
</code></pre>
<p>If order is important, then use <code>collections.OrderedDict.fromkeys</code> to retain the ordering of the original values, or sort the unique values if they should be alphabetical instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>What is needed here is an ordereddict and to manually filter the list:</p>
<pre><code>from collections import OrderedDict

d = OrderedDict()

new_list = []

a_list = [1,3,2,3,2,1,3,2,3,1]

for i in a_list:
    if i not in new_list:
        new_list.append(i)

for i, a in enumerate(new_list):
    if a != "&lt;":
       d[i] = a
</code></pre>
<p>Output:</p>
<pre><code>OrderedDict([(0, 1), (1, 3), (2, 2)])
</code></pre>
<p>If original order is not important:</p>
<pre><code>final_d = {i:a for i, a in enumerate(set(a_list)) if a != "&lt;"}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I personally find recursion quite elegant, tail-recursion especially so:</p>
<pre><code>def f( d, a_list ):
    if a_list:
        if a_list[0] not in d and a_list[0] != '&lt;':
            d[a_list[0]] = len(d)            
        return f( d, a_list[1:] )
    else:
        return d
</code></pre>
<p>So that</p>
<pre><code>f( {}, "acbcbabcbabcb" )
</code></pre>
<p>will yield</p>
<pre><code>{'a': 0, 'c': 1, 'b': 2}
</code></pre>
<p>just like the original code does on the same input (modulo order of the keys).</p>
</div>
<div class="post-text" itemprop="text">
<p>If truly:</p>
<blockquote>
<p>Order is not important.</p>
</blockquote>
<pre><code>{k: i for i, k in enumerate(filter(lambda x: x not in "&lt;", set(a_list)))}
# {'a': 3, 'b': 1, 'c': 0, 'd': 2}
</code></pre>
<p>EDIT: @qnnnnez's answer takes advantage of set operations, giving an elegant version of the latter code.</p>
<p>Otherwise you can implement the <code>unique_everseen</code> <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">itertools recipe</a> to preserve order.  For convenience, you can import it from a library that implements this recipe for you, i.e. <code>more_itertools</code>.</p>
<pre><code>from more_itertools import unique_everseen

{k: i for i, k in enumerate(filter(lambda x: x not in "&lt;", unique_everseen(a_list)))}
# {'a': 0, 'b': 1, 'c': 2, 'd': 3}
</code></pre>
</div>
<span class="comment-copy">Can you provide a sample output of what you expect based on a sample input?</span>
<span class="comment-copy">It would really help clarify exactly what you are looking for if you could provide that sample input/output and clarify if order is required....</span>
<span class="comment-copy">Is order required?</span>
<span class="comment-copy">This is elegant.  Nice idea to use set operations.</span>
<span class="comment-copy">You can generalize this with <code>if el not in "&lt;"</code>.  Then is can apply to any string of blacklisted characters, e.g. <code>"&lt;&gt;{}["</code> etc.</span>
<span class="comment-copy">if there are multiple backlisted chars I would rather use <code>set(a_list).difference(blacklisted_chars)</code> inside the <code>dict.fromkeys</code> than a <code>not in</code> in the comprehension (simply because it could have a much better runtime performance).</span>
<span class="comment-copy"><code>d = dict.fromkeys(a_list)</code>, <code>d.remove('&lt;')</code> avoids the list comprehension and evaluating the blacklisted char multiple times. Follow with the <code>d.update(...)</code>.</span>
<span class="comment-copy">@IceArdor I see where you're going with that. Although, there's no list-comp - just a gen-exp - so that's not a big deal. There's no <code>dict.remove</code> method, so you'd have to use <code>del d['&lt;']</code> and prepare for an exception where it's not present or use <code>d.pop('&lt;', None)</code> instead. There's not much different for a single value whether it's filtered out first or left to be reduced to a single key in the dictionary and then removed. In the case of multi-values, the original can be changed to <code>if el not in "&lt;&gt;!@[]"</code> easily, but would then require N many key deletions afterwards with your suggestion.</span>
<span class="comment-copy">Sorry I forgot to mention a further requirement, I edited the question</span>
<span class="comment-copy">@AreTor fixed. Please see my recent edit. The code will not store "&lt;" as a key in <code>d</code>.</span>
<span class="comment-copy">This <i>still</i> produces different result than original code for <code>a_list=[1,3,2,3,2,1,3,2,3,1]</code></span>
<span class="comment-copy">In what way is this more elegant than the original?</span>
<span class="comment-copy">Stating example output w/o corresponding input is worse than useless.</span>
<span class="comment-copy">I've seen so many variations of this solution, and this is the first time I've seen it done with recursion. Pretty neat!</span>
