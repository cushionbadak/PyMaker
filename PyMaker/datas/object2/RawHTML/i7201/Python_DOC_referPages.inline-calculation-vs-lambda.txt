<div class="post-text" itemprop="text">
<pre><code>lst = [randint(0,i) for i in range(0,1000)]
start = time.time()
lst = [item*item for item in lst]
end = time.time()
print('%.7f' %(start - end))

f = lambda x: x**2

lst = [randint(0,i) for i in range(0,1000)]
start = time.time()
lst = [f(item) for item in lst]
end = time.time()
print('%.7f' %(start - end))
</code></pre>
<p>The time for inline calculation ranges from 0.0000665 to 0.0000813.
Whereas that for lambda is somewhere in the range 0.0004215 to 0.0004265.
Why is there such a huge difference in time?</p>
</div>
<div class="post-text" itemprop="text">
<p>I can see 2 possible reasons:</p>
<ol>
<li><code>item * item</code> yields the same result as <code>item ** 2</code>, but you're making an assumption about implementation of <code>**</code> operator. Still, more important reason is...</li>
<li><code>lambda</code> is really a function - it has the same closure as a function you'd declare with <code>def</code> in the same scope, and in the same way as such function, it will get it's own stack frame when executed. Creating, pushing and dropping such frame take time and this is probably what introduces such a big overhead. Quoting from <a href="https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions" rel="nofollow noreferrer">here</a>:</li>
</ol>
<blockquote>
<p>Semantically, they (lambdas) are just syntactic sugar for a normal
  function definition.</p>
</blockquote>
<p>Try benchmarking following calculations:</p>
<ul>
<li>inline <code>item*item</code></li>
<li>inline <code>item **2</code></li>
<li>usage of <code>def foo(x): return x*x</code></li>
<li>usage of <code>def foo(x): return x**2</code></li>
<li>usage of <code>lambda x: x*x</code></li>
<li>usage of <code>lambda x: x**2</code></li>
</ul>
<p>and you'll figure out real reasons (please share these results too, I'm sorta interested myself). I'd expect 2 first ways to be similiar in efficiency, and following 4 also similiar to each other, but slower by few orders of magnitude than those inline ones.</p>
<p>Also: use <a href="https://docs.python.org/2/library/timeit.html" rel="nofollow noreferrer"><code>timeit</code></a> intead of <code>time.time()</code> - it is more reliable. <a href="https://stackoverflow.com/questions/7370801/measure-time-elapsed-in-python">Here</a>'s a wider list of possibilities when it comes to measuring time of execution, though I'd really recommend <code>timeit</code>, as it is created exactly for the kind of job that you want to do here.</p>
</div>
<span class="comment-copy">the two cases are not comparable, in the first case you're simply iterating over a list raising items to power 2, in the second case you're call the lambda function passing it the variable doing the calculation then returning the item, of-course function calls take much longer than multiplication</span>
<span class="comment-copy">The calling takes that much of time?</span>
<span class="comment-copy"><code>x**2</code> works different than <code>x*x</code>...</span>
<span class="comment-copy">A function call means a jump to different place in memory,intialising the local variables, etc..</span>
<span class="comment-copy">@Djokester Yes. When you make a function call, Python calls several other methods on the function object behind the scenes. It must also create a new frame for the function call. All of these things take more time than simply doing <code>x*x</code>.</span>
