<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/949098/python-split-a-list-based-on-a-condition">Python: split a list based on a condition?</a>
<span class="question-originals-answer-count">
                    29 answers
                </span>
</li>
</ul>
</div>
<p>Let's say I have a list of numbers and I want to split this list into two sublists: one for odd numbers and another one for evens.</p>
<pre><code>evens, odds = [], []
for e in numbers:
    if e % 2 == 0:
        evens.append(e)
    else:
        odds.append(e)
</code></pre>
<p>I wonder if there is a one-liner for this problem while keeping the same order of complexity.</p>
<p>I tried using <code>itertools.groupby</code> but the list needs to be ordered first so I'd be achieving a <code>O(2n)</code> rather than <code>O(n)</code>:</p>
<pre><code>def is_even(n):
    return n % 2 == 0

lst = sorted(lst, key=is_even)
grouper = itertools.groupby(lst, key=is_even)
lst1, lst2 = [list(v) for k, v in grouper]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about using the ternary operator prior to append:</p>
<pre><code>evens, odds = [], []
for e in numbers:
    (odds if e % 2 else evens).append(e)
</code></pre>
<p>Of course you could do this inside a list comprehension, but it's not Pythonic to use a comprehension for it's side-effects because you create a potentially large unwanted list of <code>None</code> values. You could instead use the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">itertools consume recipe</a> if you want to take that route.</p>
</div>
<div class="post-text" itemprop="text">
<p>You <em>could</em> abuse list comprehension, but please <strong>don't</strong> do that in production code.</p>
<pre><code>nums = range(6)
odds = []
evens = []
[odds.append(num) if num % 2 == 1 else evens.append(num) for num in nums]
print(odds, evens)
# [1, 3, 5] [2, 4]
</code></pre>
</div>
<span class="comment-copy">As a side note, <code>O(2n)</code> and <code>O(n)</code> have the same magnitude and most of the time can be treated as equal.</span>
<span class="comment-copy">O(2n) is the same as O(n), just saying...</span>
<span class="comment-copy">@DeepSpace yeah I know, but it's still twice as slow, it just bothers me and I'd rather do it as efficient as possible</span>
<span class="comment-copy">And by the way, while we are at it, your <code>groupby</code> solution is not <code>O(2n)</code>. Since <code>sorted</code> is using quicksort the complexity of your second solution is (on average) <code>O(nlogn + n)</code>.</span>
<span class="comment-copy">@DeepSpace true that I really didn't stop to think what sorting algorithm was being used, my point was that it added extra level of complexity that the first loop doesn't introduce</span>
<span class="comment-copy">Not the easiest to read, but I think that this answer fit the most as it's O(n).</span>
<span class="comment-copy">can you elaborate on how to use <code>consume</code> for this question?</span>
<span class="comment-copy">@dabadaba would be like <code>consume((odds if e % 2 else evens).append(e) for e in numbers)</code></span>
<span class="comment-copy">@dabadaba In fact for your case you could use <code>collections.deque(((odds if e % 2 else evens).append(e) for e in numbers), maxlen=0)</code></span>
<span class="comment-copy">that is pretty nice! i'll try to remember that recipe...</span>
<span class="comment-copy">oh no I'd rather not exploit list comprehension like that</span>
<span class="comment-copy">This is a bad way of using list comprehension</span>
<span class="comment-copy">That is really not the job the comprehension list were made for...</span>
<span class="comment-copy">@ettanany Which I point out by using the words "abuse" and "don't do that".</span>
<span class="comment-copy">@Darkaird See above</span>
