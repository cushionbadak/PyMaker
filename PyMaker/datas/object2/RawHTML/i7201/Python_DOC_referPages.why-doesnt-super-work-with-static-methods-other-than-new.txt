<div class="post-text" itemprop="text">
<p>I understand that <code>__new__</code> is a static method and <code>super()</code> can be called from it create a new object, like so:</p>
<pre><code>&gt;&gt;&gt; class A:
...     def __new__(cls):
...         print('__new__ called')
...         return super().__new__(cls)
...
&gt;&gt;&gt; a = A()
__new__ called
</code></pre>
<p>Why doesn't the <code>super</code> call work with other static methods? Why does the following fail?</p>
<pre><code>&gt;&gt;&gt; class B:
...     @staticmethod
...     def funcB():
...         print('funcB called')
...
&gt;&gt;&gt; class C(B):
...     @staticmethod
...     def funcC():
...         print('funcC called')
...         super().funcB()
...
&gt;&gt;&gt; c = C()
&gt;&gt;&gt; c.funcC()
funcC called
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 5, in funcC
RuntimeError: super(): no arguments
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>super()</code> with no arguments in Python 3 is basically a hack over its argument based version.</p>
<p>When <code>super()</code> gets no arguments it fetches the first argument i.e the class using a special cell variable named <code>__class__</code> and for second argument it will get the first local variable from the stack(which is going to be function's first argument).</p>
<p>In case of <code>__new__</code> it can get both(<code>__class__</code> and <code>cls</code>) and works fine.</p>
<p>But in this case for example there's no second variable available apart from <code>__class__</code> hence it fails.</p>
<pre><code>class A:
  @staticmethod
  def func():
    super().func()  # super(__class__, &lt;missing&gt;).func()


A().func()  # RuntimeError: super(): no arguments
</code></pre>
<p>Now if we change it to accept an argument then things change:</p>
<pre><code>class A:
  @staticmethod
  def func(foo):
    super().func()


# This fails because super(B, 1).func() doesn't make sense.
A().func(1)  # TypeError: super(type, obj): obj must be an instance or subtype of type
# Works! But as there's no parent to this class with func() it fails as expected.
A().func(A())  # AttributeError: 'super' object has no attribute 'func'
</code></pre>
<p>Hence the only solution is to make the things explicit with <code>super()</code> in your case:</p>
<pre><code>super(C, C).funcC()
</code></pre>
<hr/>
<p>In general I am not sure why the implementation in case of staticmethod can't make an exception and use <code>__class__</code> for both the arguments to make it work.</p>
<hr/>
<p>Related <a href="https://github.com/python/cpython/blob/3.6/Objects/typeobject.c#L7434" rel="noreferrer">CPython code</a>:</p>
<pre><code>static int
super_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    superobject *su = (superobject *)self;
    PyTypeObject *type = NULL;
    PyObject *obj = NULL;
    PyTypeObject *obj_type = NULL;

    if (!_PyArg_NoKeywords("super", kwds))
        return -1;
    if (!PyArg_ParseTuple(args, "|O!O:super", &amp;PyType_Type, &amp;type, &amp;obj))
        return -1;

    if (type == NULL) {
        /* Call super(), without args -- fill in from __class__
           and first local variable on the stack. */
        PyFrameObject *f;
        PyCodeObject *co;
        Py_ssize_t i, n;
        f = PyThreadState_GET()-&gt;frame;
        if (f == NULL) {
            PyErr_SetString(PyExc_RuntimeError,
                            "super(): no current frame");
            return -1;
        }
        co = f-&gt;f_code;
        if (co == NULL) {
            PyErr_SetString(PyExc_RuntimeError,
                            "super(): no code object");
            return -1;
        }
        if (co-&gt;co_argcount == 0) {
            PyErr_SetString(PyExc_RuntimeError,
                            "super(): no arguments");
            return -1;
        }
        ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are right, but <code>__new__</code> is a static method (special-cased so you need not declare it as such) that takes the class of which an instance was requested as its first argument. Its ideal behavior is somewhat like a <strong>classmethod</strong>.</p>
<p>But when you call a <strong>staticmethod</strong> method, the method does not receive anything, an has no way to know from what object or class it was called. That's the reason why you cannot access super in a <strong>staticmethod</strong>.</p>
<p>Therefore, <strong>new</strong> by definition has a class argument in it and can use super along with it.</p>
<p>For your logic you should make a call to instatiate your object and call the function that you want to call from there.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>__new__</code> is treated as a special-case by the python interpreter (pretty much all the "dunder" methods are). One aspect of this special case handling is to make <code>super</code> have access to the underlying class object when normally a <code>staticmethod</code> does not.  You can search for <code>__new__</code> in <a href="https://github.com/python/cpython/blob/3.6/Objects/typeobject.c" rel="nofollow noreferrer">the source code for the <code>type</code> object</a> to take a peek at what is going on under the hood.</p>
<p>To solve what you were trying to do with inheritance, you probably want a <code>classmethod</code>.</p>
<pre><code>&gt;&gt;&gt; class B:
...     @classmethod
...     def funcB(cls):
...         print('funcB called')
...
&gt;&gt;&gt; class C(B):
...     @classmethod
...     def funcC(cls):
...         print('funcC called')
...         super().funcB()
...
&gt;&gt;&gt; c = C()
&gt;&gt;&gt; c.funcC()
funcC called
funcB called
</code></pre>
</div>
<span class="comment-copy"><a href="https://bugs.python.org/issue15753" rel="nofollow noreferrer">bugs.python.org/issue15753</a>. <code>super(C, C).funcC()</code> would work in your case.</span>
<span class="comment-copy">Thanks for clarifying, <code>super(C, C).funcB()</code> does work. One thing: when we write <code>super(type, type2)</code> then as per the documentation <code>type2</code> should be a subclass of <code>type</code>. But here both the types are same, i.e. <code>C</code>.</span>
<span class="comment-copy">@Deb Every type is a subtype of itself.</span>
<span class="comment-copy"><code>super()</code> doesn't care about who called a function, <code>super()</code> uses <code>__class__</code> variable to figure out the class of the current function.</span>
<span class="comment-copy"><a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer"><code>__new__</code></a> is a static method.</span>
<span class="comment-copy">@AshwiniChaudhary I realize that they say static method there, but I wouldn't be surprised if that is a documentation error.  I'm going to dig into that.  It behaves as a class method because it gets the class object passed to it.</span>
<span class="comment-copy">@AshwiniChaudhary Looks like you are right... <a href="https://github.com/python/cpython/blob/3.6/Objects/typeobject.c#L2597" rel="nofollow noreferrer">it's in the C source code</a>.  It seems that the reason is because <code>__new__</code> treated specially by the interpreter.</span>
<span class="comment-copy">@AshwiniChaudhary I prefer to read the source to understand what they are doing so I can understand the cause, not the effect.</span>
<span class="comment-copy">I don't remember stopping you. :-|</span>
