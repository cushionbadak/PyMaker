<div class="post-text" itemprop="text">
<p>I have a list of objects with multiple attributes. I want to filter the list based on one attribute of the object (country_code), i.e.</p>
<p>Current list</p>
<pre><code>elems = [{'region_code': 'EUD', 'country_code': 'ROM', 'country_desc': 'Romania', 'event_number': '6880'}, 
{'region_code': 'EUD', 'country_code': 'ROM', 'country_desc':'Romania', 'event_number': '3200'}, 
{'region_code': 'EUD', 'country_code': 'ROM', 'country_desc': 'Romania', 'event_number': '4000'}, 
{'region_code': 'EUD', 'country_code': 'SVN', 'country_desc': 'Slovenia', 'event_number': '6880'}, 
{'region_code': 'EUD', 'country_code': 'NLD', 'country_desc':'Netherlands', 'event_number': '6880'}, 
{'region_code': 'EUD', 'country_code': 'BEL', 'country_desc':'Belgium', 'event_number': '6880'}]
</code></pre>
<p>Desired list</p>
<pre><code>elems = [{'region_code': 'EUD', 'country_code': 'ROM', 'country_desc': 'Romania', 'event_number': '6880'}, 
{'region_code': 'EUD', 'country_code': 'SVN', 'country_desc': 'Slovenia', 'event_number': '6880'}, 
{'region_code': 'EUD', 'country_code': 'NLD', 'country_desc': 'Netherlands', 'event_number': '6880'}, 
{'region_code': 'EUD', 'country_code': 'BEL', 'country_desc': 'Belgium', 'event_number': '6880'}]
</code></pre>
<p>I can achieve this by creating a dictionary and a for-loop, but I feel like there's an easier way in python using the filter() or reduce() functions, I just can't figure out how.</p>
<p><strong>Can anyone simplify the below code using in-built python functions? Performance is a big factor because the real data will be substantial.</strong></p>
<p>Working code:</p>
<pre><code>unique = {}
for elem in elems:
  if elem['country_code'] not in unique.keys():
     unique[elem['country_code']] = elem

print(unique.values())
</code></pre>
<p>Worth noting I have also tried the code below, but it performs worse than the current working code:</p>
<pre><code>unique = []
for elem in elems:
    if not any(u['country_code'] == elem['country_code'] for u in unique):
        unique.append(elem)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think your first approach is already pretty close to being optimal. Dictionary lookup is fast (just as fast as in a <code>set</code>) and the loop is easy to understand, even though a bit lengthy (by Python standards), but you should not sacrifice readability for brevity.</p>
<p>You can, however, shave off one line using <code>setdefault</code>, and you might want to use <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>collections.OrderedDict()</code></a> so that the elements in the resulting list are in their orginal order. Also, note that in Python 3, <code>unique.values()</code> is not a list but a view on the dict.</p>
<pre><code>unique = collections.OrderedDict()
for elem in elems:
    unique.setdefault(elem["country_code"], elem)
</code></pre>
<p>If you really, <em>really</em> want to use <code>reduce</code>, you can use the empty dict as an initializer and then use <code>d.setdefault(k,v) and d</code> to set the value (if not present) and return the modified dict.</p>
<pre><code>unique = reduce(lambda unique, elem: unique.setdefault(elem["country_code"], elem) and unique,
                elems, collections.OrderedDict())
</code></pre>
<p>I would just use the loop, though.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think that your approach is just fine. It would be slightly better to check <code>elem['country_code'] not in unique</code> instead of <code>elem['country_code'] not in unique.keys()</code>.</p>
<p>However, here is another way to do it with a list comprehension:</p>
<pre><code>visited = set()
res = [e for e in elems
        if e['country_code'] not in visited
        and not visited.add(e['country_code'])]
</code></pre>
<p>The last bit abuses the fact that <code>not None == True</code> and <code>list.add</code> returns <code>None</code>.</p>
</div>
<span class="comment-copy">I think your first working code, with the dict, is pretty optimal. Maybe use <code>collections.OrderedDict</code> so the order is the same as in the list, if that's important. Also, no need to call <code>.keys()</code>.</span>
<span class="comment-copy">setdefault where have you been all my life?? This works well, thanks!</span>
<span class="comment-copy">thanks @Yakym - this is quick and clean. I'm going to go with tobias_k's answer because it's less code change but the performance is the same. Thanks!</span>
