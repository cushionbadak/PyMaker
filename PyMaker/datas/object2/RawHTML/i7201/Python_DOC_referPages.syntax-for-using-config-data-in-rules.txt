<div class="post-text" itemprop="text">
<p>Is there someplace that fully describes use of config data in snakemake rules?</p>
<p>There is an example in the user guide of this in a yaml file:</p>
<pre><code>samples:
    A: data/samples/A.fastq
    B: data/samples/B.fastq
</code></pre>
<p>Then, it is used in a rule like this:</p>
<pre><code>bam=expand("sorted_reads/{sample}.bam", sample=config["samples"]),
</code></pre>
<p>It seems like the above would replace {sample} to "data/samples/A.fastq" rather than by "A" (and "B" etc.) as it apparently does.  </p>
<p>What is the right way to make use of config data in output rules, e.g. to help form the output filename?  This form doesn't work:</p>
<pre><code>output: "{config.dataFolder}/{ID}/{ID}.yyy"
</code></pre>
<p>I'm looking for syntax guidance if I define complex structured data in the yaml file - how do I make use of it in the snake rules?  When do I use Python syntax and when do I use SnakeMake syntax?</p>
<p>The yaml and JSON config files are severely limited in that they cannot use values defined earlier in the file to define new values, right?  And that's something that would often be done when setting configuration parameters.</p>
<p>What is the advantage of using a configfile?  Why not instead just use include: an include a python file to define parameters?</p>
<p>A useful thing would be a reference manual that describes the details of SnakeMake thoroughly.  The current website is kind of scattered, takes a while to find things that you remember seeing previously somewhere in it.</p>
</div>
<div class="post-text" itemprop="text">
<p>How should config data be used in "output" rules?  I found that the output string cannot contain {config.} values.  However, they can be included using Python code, as follows:</p>
<pre><code>output: config["OutputDir"] + "/myfile.txt"
</code></pre>
<p>But, this method does NOT work (in either output: or input:):</p>
<pre><code>params: config=config
output: "{params.config[OutputDir]}/myfile.txt"
</code></pre>
<p>However, it DOES work in "shell:":</p>
<pre><code>params: config=config
output: config["OutputDir"] + "/myfile.txt"
shell: echo "OutputDir is {params.config[OutputDir]}" &gt; {output}
</code></pre>
<p>Notice that there are no quotes around OutputDir inside the [] in the shell cmd.  The {} method of expanding values in a string does not use quotes around the keys.</p>
<p>Can config data be defined snakefile-wise OR python-wise?  YES! </p>
<p>Parameters can be defined in a .yaml file included using 'configfile', or via a regular Python file included using 'include'.  The latter is IMHO superior, since .yaml files don't allow definitions to reference previous ones, something that would be common in all but the simplest configuration files.</p>
<p>To define the "OutputDir" parameter above using yaml:</p>
<p>xxx.yaml:</p>
<pre><code>OutputDir: DATA_DIR
</code></pre>
<p>snakefile:</p>
<pre><code>configfile: 'xxx.yaml'
</code></pre>
<p>To define it using Python to be exactly compatible with above:</p>
<p>xxx.py:</p>
<pre><code>config['OutputDir'] = "DATA_DIR"
</code></pre>
<p>snakefile:</p>
<pre><code>include: 'xxx.py'
</code></pre>
<p>Or, to define a simple variable 'OutputDir' in a Python included configuration file and then use it in a rule:</p>
<p>xxx.py:</p>
<pre><code>OutputDir = "DATA_DIR"
</code></pre>
<p>snakefile:</p>
<pre><code>include: 'xxx.py'
rule:
    output: OutputDir + "/myfile.txt"
</code></pre>
<p>Multi-nested dictionaries and lists can be easily defined and accessed, both via .yaml files and python files.  Example:</p>
<pre><code>MACBOOK&gt; cat cfgtest.yaml
cfgtestYAML:

    A: 10
    B: [1, 2, 99]
    C:
        nst1: "hello"
        nst2: ["big", "world"]

MACBOOK&gt; cat cfgtest.py
cfgtestPY = {

    'X': -2,
    'Y': range(4,7),
    'Z': {
        'nest1': "bye",
        'nest2': ["A", "list"]
        }
    }

MACBOOK&gt; cat cfgtest
configfile: "cfgtest.yaml"
include: "cfgtest.py"

rule:
    output: 'cfgtest.txt'
    params: YAML=config["cfgtestYAML"], PY=cfgtestPY
    shell:
        """
        echo "params.YAML[A]: {params.YAML[A]}"             &gt;{output}
        echo "params.YAML[B]: {params.YAML[B]}"             &gt;&gt;{output}
        echo "params.YAML[B][2]: {params.YAML[B][2]}"       &gt;&gt;{output}
        echo "params.YAML[C]: {params.YAML[C]}"             &gt;&gt;{output}
        echo "params.YAML[C][nst1]: {params.YAML[C][nst1]}" &gt;&gt;{output}
        echo "params.YAML[C][nst2]: {params.YAML[C][nst2]}" &gt;&gt;{output}
        echo "params.YAML[C][nst2][1]: {params.YAML[C][nst2][1]}" &gt;&gt;{output}

        echo "" &gt;&gt;{output}

        echo "params.PY[X]: {params.PY[X]}"                 &gt;&gt;{output}
        echo "params.PY[Y]: {params.PY[Y]}"                 &gt;&gt;{output}
        echo "params.PY[Y][2]: {params.PY[Y][2]}"           &gt;&gt;{output}
        echo "params.PY[Z]: {params.PY[Z]}"                 &gt;&gt;{output}
        echo "params.PY[Z][nest1]: {params.PY[Z][nest1]}"     &gt;&gt;{output}
        echo "params.PY[Z][nest2]: {params.PY[Z][nest2]}"     &gt;&gt;{output}
        echo "params.PY[Z][nest2][1]: {params.PY[Z][nest2][1]}" &gt;&gt;{output}
        """

MACBOOK&gt; snakemake -s cfgtest
Provided cores: 1
Rules claiming more threads will be scaled down.
Job counts:
    count   jobs
    1   1
    1

rule 1:
    output: cfgtest.txt
    jobid: 0

Finished job 0.
1 of 1 steps (100%) done

MACBOOK&gt; cat cfgtest.txt
params.YAML[A]: 10
params.YAML[B]: 1 2 99
params.YAML[B][2]: 99
params.YAML[C]: {'nst1': 'hello', 'nst2': ['big', 'world']}
params.YAML[C][nst1]: hello
params.YAML[C][nst2]: big world
params.YAML[C][nst2][1]: world

params.PY[X]: -2
params.PY[Y]: range(4, 7)
params.PY[Y][2]: 6
params.PY[Z]: {'nest1': 'bye', 'nest2': ['A', 'list']}
params.PY[Z][nest1]: bye
params.PY[Z][nest2]: A list
params.PY[Z][nest2][1]: list
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>YAML Configuration</h1>
<p>This has to do with the nesting of YAML files, see an example <a href="https://stackoverflow.com/questions/8912659/multiple-level-nesting-in-yaml">here</a>.</p>
<p>The config["samples"] request will return both 'A' and 'B'. I'm my head I think of it returning a list, but I am not positive on the variable type.</p>
<p>By using the configfile as listed here:
<a href="https://snakemake.readthedocs.io/en/latest/tutorial/advanced.html" rel="nofollow noreferrer">https://snakemake.readthedocs.io/en/latest/tutorial/advanced.html</a></p>
<p>You can link in the following YAML configuration files, in YAML format.</p>
<p><em>settings/config.yaml:</em></p>
<pre><code>samples:
    A
    B
</code></pre>
<p>OR</p>
<p><em>settings/config.yaml:</em></p>
<pre><code>sampleID:
    123
    124
    125
baseDIR:
    data
</code></pre>
<p>Resulting call with YAML config access</p>
<p><em>Snakefile:</em></p>
<pre><code>configfile: "settings/config.yaml"

rule all:
    input:
        expand("{baseDIR}/{ID}.bam", baseDIR=config["baseDIR"], ID=config["sampleID"]),


rule fastq2bam:
    input:
        expand("{{baseDIR}}/{{ID}}.{readDirection}.fastq", readDirection=['1','2'])
    output:
        "{baseDIR}/{ID}.bam"
        #Note different number of {}, 1 for wildcards not in expand.
        #Equivalent line with 'useless' expand call would be:
        #expand("{{baseDIR}}/{{ID}}.bam")

    shell:
    """
    bwa mem {input[0]} {input[1]} &gt; {output}
    """
</code></pre>
<p>Dummy examples, just trying to exemplify the use of different strings and config variables. I use wildcards in the fastq2bam rule. Typically I only use config variables to set things in my rule 'all', when possible this is best practice. I cannot say if the shell call actually works for bwa mem, but I think you get the idea of what I'm implying.</p>
<p>A larger version of a Snakefile can be seen <a href="https://snakemake.readthedocs.io/en/latest/tutorial/advanced.html" rel="nofollow noreferrer">here</a></p>
<p>Once the configfile is setup, to reference anything in it, use 'config'. It can be used to access deep into a YAML as needed. Here I'll go down 3 hypothetical levels, like so:</p>
<pre><code>hypothetical_var = config["yamlVarLvl1"]["yamlVarLvl2"]["yamlVarLvl3"]
</code></pre>
<p>Equates to (I'm not POSITIVE about the typing, I think it converts to strings)</p>
<pre><code> hypothetical_var = ['124', '125', '126', '127', '128', '129']
</code></pre>
<p>If the YAML is:</p>
<pre><code>yamlVarLvl1:
    yamlVarLvl2:
        yamlVarLvl3:
            '124'
            '125'
            '126'
            '127'
            '128'
            '129'
</code></pre>
<h1>Code Organization</h1>
<p>Python and Snakemake code, for the most part can be interleaved in certian places. I would advise against this as it will make the code difficult to maintain. It's up to the user to decide how to implement this. E.g, using the run or the shell directive changes how to access the variables. </p>
<p>YAML and JSON files are preferred configuration variable files as I believe the provide some support for editting and Command-Line Interface over-ridding of variables. This would not be as clean if it was implemented using externally imported python variables. Also it helps my brain, knowing python files do things, and YAML files store things.</p>
<p>YAML is always an external file, but...</p>
<ol>
<li>If you are using a single Snakefile, put the supporting python at the top?</li>
<li>If you are using a multi-file system, consider having the supporting python scripts externalized. </li>
</ol>
<h1>Tutorials</h1>
<p>I think a perfect vignette is difficult to design. I'm trying to teach my group about Snakemake, and I have over 40 pages of personally written documentation, I've provided three 1hr+ presentations with PowerPoint slideshows, I've read nearly the entire ReadTheDocs.io manual for Snakemake, and I just recently finished going through the list of additional <a href="https://snakemake.readthedocs.io/en/latest/project_info/more_resources.html" rel="nofollow noreferrer">resources</a>, yet, I'm still learning too! </p>
<p>Side note, I found this <a href="http://slowkow.com/notes/snakemake-tutorial/" rel="nofollow noreferrer">tutorial</a>  to be very nice as well.</p>
<p>Does that provide enough context?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is there someplace that fully describes use of config data in snakemake rules?</p>
</blockquote>
<p>There is no limit to what you can put in the config file, provided it can be parsed into python objects. Basically, "your imagination is the limit".</p>
<blockquote>
<p>What is the right way to make use of config data in output rules, e.g. to help form the output filename?</p>
</blockquote>
<p>I extract things from the config outside the rules, in plain python.</p>
<p>Instead of <code>output: "{config.dataFolder}/{ID}/{ID}.yyy"</code>, I would do:</p>
<pre><code>data_folder = config.dataFolder

rule name_of_the_rule:
    output:unction
        os.path.join(data_folder, "{ID}", "{ID}.yyy")
</code></pre>
<p>I guess that with what you tried, snakemake has problems formatting the string when there is a mix of things coming from the wildcards, and others. But maybe the following works in python 3.6, using <a href="https://docs.python.org/3/whatsnew/3.6.html#whatsnew36-pep498" rel="nofollow noreferrer">formatted string litterals</a>: <code>output: f"{config.dataFolder}/{ID}/{ID}.yyy"</code>. I haven't checked.</p>
<blockquote>
<p>I'm looking for syntax guidance if I define complex structured data in the yaml file - how do I make use of it in the snake rules? When do I use Python syntax and when do I use SnakeMake syntax?</p>
</blockquote>
<p>In the snakefile, I typically read the config file to extract configuration information <strong>before</strong> the rules. This is essentially pure python except that a <code>config</code> object is directly made available by Snakemake for convenience. You could probably just use plain standard python using <code>config = json.load("config.json")</code> or <code>config = yaml.load("config.yaml")</code>.</p>
<p>In the snakefile, outside the rules, you can do whatever computations you want in python. This can be before reading the config as well as after. You can define functions that can be used in rules (for instance to generate rule's inputs), compute lists of things that will be used as wildcards. I think the only thing is that an object needs to be defined before the rules that use it.</p>
<p>Snakemake syntax seems mainly a means of describing the rules. Within the <code>run</code> part of a rule, you can use whatever python you want, knowing that you have access to a <code>wildcards</code> object to help you. Input and output of rules are lists of file paths, and you can use python in order to build them.</p>
</div>
<span class="comment-copy">To overcome the limitations of yaml or JSON, you can read things from the config, and then, within the snakefile (and before the rules), apply python code on things read from the config file.</span>
<span class="comment-copy">Interestingly, the first-level member of "params" can be accessed with "." or "[]", but all subsequent levels must use "[]".  E.g. "params.PY[X]" and "params[PY][X]" are identical, but "params.PY.X" doesn't work.</span>
<span class="comment-copy">Method 2 in above post cannot work. Braces in <code>input</code>, <code>output</code>, <code>params</code>, ... are there to denote wildcards. In contrast, braces in the shell directive or the expand function are there to format strings, exactly like the python method <code>str.format</code>.</span>
<span class="comment-copy">Thanks, I edited the method to make it correct.</span>
<span class="comment-copy">Thanks for the info.  I put a lot of questions into one, since I can only post one question per 90 minutes.  One you didn't answer was, how should config data be used in "output" rules?  I found that this works:</span>
<span class="comment-copy">No worries, I also understand you are doing your best, and I thank you for moving this discussion from the Google Groups to here.  Input and output access to the configfile are identical. The only differents between the input and output directives is that the input directive can use input fuctions, whereas,  I do not believe there is any ability to put a function in the output.</span>
<span class="comment-copy">Maybe it helps to mention that, regardless of using YAML or JSON, Snakemake simply reads the respective config file into a Python dictionary that is globally accessible as <code>config</code>. The reading happens via the <code>json</code> module of the standard library or the <code>pyyaml</code> library. Nothing special here. This also means that integers and floats are converted properly, and if you don't place quotes around them in the config file, they are proper ints or floats in the resulting dictionary.</span>
