<div class="post-text" itemprop="text">
<p>While parsing attributes using <a href="https://docs.python.org/3/library/stdtypes.html#object.__dict__" rel="noreferrer"><code>__dict__</code></a>, my <a href="https://docs.python.org/3/library/functions.html?highlight=staticmethod#staticmethod" rel="noreferrer"><code>@staticmethod</code></a> is not <a href="https://docs.python.org/3/library/functions.html?highlight=staticmethod#callable" rel="noreferrer"><code>callable</code></a>.</p>
<pre class="lang-py prettyprint-override"><code>Python 2.7.5 (default, Aug 29 2016, 10:12:21)
[GCC 4.8.5 20150623 (Red Hat 4.8.5-4)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; from __future__ import (absolute_import, division, print_function)
&gt;&gt;&gt; class C(object):
...   @staticmethod
...   def foo():
...     for name, val in C.__dict__.items():
...       if name[:2] != '__':
...          print(name, callable(val), type(val))
...
&gt;&gt;&gt; C.foo()
foo  False  &lt;type 'staticmethod'&gt;
</code></pre>
<ul>
<li>How is this possible?</li>
<li>How to check if a static method is callable?</li>
</ul>
<hr/>
<p>I provide below a more detailed example:</p>
<h2>Script <code>test.py</code></h2>
<pre class="lang-py prettyprint-override"><code>from __future__ import (absolute_import, division, print_function)

class C(object):

  @staticmethod
  def foo():
    return 42

  def bar(self):
    print('Is bar() callable?', callable(C.bar))
    print('Is foo() callable?', callable(C.foo))
    for attribute, value in C.__dict__.items():
      if attribute[:2] != '__':
        print(attribute, '\t', callable(value), '\t', type(value))

c = C()
c.bar()
</code></pre>
<h2>Result for python2</h2>
<pre class="lang-py prettyprint-override"><code>&gt; python2.7 test.py
Is bar() callable? True
Is foo() callable? True
bar      True    &lt;type 'function'&gt;
foo      False   &lt;type 'staticmethod'&gt;
</code></pre>
<h2>Same result for python3</h2>
<pre class="lang-py prettyprint-override"><code>&gt; python3.4 test.py
Is bar() callable? True
Is foo() callable? True
bar      True    &lt;class 'function'&gt;
foo      False   &lt;class 'staticmethod'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The reason for this behavior is the descriptor protocol. The <code>C.foo</code> won't return a <code>staticmethod</code> but a normal function while the <code>'foo'</code> in <code>__dict__</code> is a <a href="https://docs.python.org/library/functions.html#staticmethod" rel="nofollow noreferrer"><code>staticmethod</code></a> (and <code>staticmethod</code> is a descriptor).</p>
<p>In short <code>C.foo</code> isn't the same as <code>C.__dict__['foo']</code> in this case - but rather <code>C.__dict__['foo'].__get__(C)</code> (see also the section in the documentation of the <a href="https://docs.python.org/reference/datamodel.html#implementing-descriptors" rel="nofollow noreferrer">Data model on descriptors</a>):</p>
<pre><code>&gt;&gt;&gt; callable(C.__dict__['foo'].__get__(C))
True
&gt;&gt;&gt; type(C.__dict__['foo'].__get__(C))
function

&gt;&gt;&gt; callable(C.foo)
True
&gt;&gt;&gt; type(C.foo)
function

&gt;&gt;&gt; C.foo is C.__dict__['foo'].__get__(C)
True
</code></pre>
<hr/>
<p>In your case I would check for callables using <a href="https://docs.python.org/library/functions.html#getattr" rel="nofollow noreferrer"><code>getattr</code></a> (which knows about descriptors and how to access them) instead of what is stored as value in the class <code>__dict__</code>:</p>
<pre><code>def bar(self):
    print('Is bar() callable?', callable(C.bar))
    print('Is foo() callable?', callable(C.foo))
    for attribute in C.__dict__.keys():
        if attribute[:2] != '__':
            value = getattr(C, attribute)
            print(attribute, '\t', callable(value), '\t', type(value))
</code></pre>
<p>Which prints (on python-3.x):</p>
<pre><code>Is bar() callable? True
Is foo() callable? True
bar      True    &lt;class 'function'&gt;
foo      True    &lt;class 'function'&gt;
</code></pre>
<p>The types are different on python-2.x but the result of <code>callable</code> is the same:</p>
<pre><code>Is bar() callable? True
Is foo() callable? True
bar      True    &lt;type 'instancemethod'&gt;
foo      True    &lt;type 'function'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can't check if a <code>staticmethod</code> object is callable or not. This was discussed on the tracker in <a href="https://bugs.python.org/issue20309" rel="nofollow noreferrer">Issue 20309 -- Not all method descriptors are callable</a> and closed as "not a bug". </p>
<p>In short, there's been no rationale for implementing <code>__call__</code> for staticmethod objects. The built-in <code>callable</code> has no way to know that the <code>staticmethod</code> object is something that essentially "holds" a callable. </p>
<p>Though you could implement it (for <code>staticmethod</code>s and <code>classmethod</code>s), it would be a maintenance burden that, as previously mentioned, has no real motivating use-cases. </p>
<hr/>
<p>For your case, you can use <code>getattr(C, name)</code> to perform a look-up for the object named <code>name</code>; this is equivalent to performing <code>C.&lt;name&gt;</code>. <code>getattr</code>, after finding the staticmethod object, will invoke its <code>__get__</code> to get back the callable it's managing. You can then use <code>callable</code> on that. </p>
<p>A nice primer on descriptors can be found in the docs, take a look at <a href="https://docs.python.org/2.7/howto/descriptor.html#static-methods-and-class-methods" rel="nofollow noreferrer">Descriptor HOWTO</a>.</p>
</div>
<span class="comment-copy">Thanks for your explanation. What should I change in my first snippet in order to known that <code>foo</code> is <code>callable</code>? Should I use <code>print(name, callable(val.__get__(C)))</code>? Or should I use something like <code>if type(name) == types.StaticmethodType</code>? Please advice a fix ;-) Cheers</span>
<span class="comment-copy">Ah, I knew I forgot something. I updated the answer :)</span>
<span class="comment-copy">üëç Yep <code>getattr(C, attribute)</code> does the job and I see that your <code>type(value)</code> returns now <code>&lt;type 'instancemethod'&gt;</code> instead of <code>&lt;type 'staticmethod'&gt;</code> in my code.</span>
<span class="comment-copy">Thanks for your excellent rational. I request the same as for MSeifert: What should I change in my first snippet in order to known that <code>foo</code> is <code>callable</code>? Should I use <code>print(name, callable(val.__get__(C)))</code>? Or should I use something like <code>if type(name) == types.StaticmethodType</code>? Please advice a fix ;-) Cheers</span>
<span class="comment-copy">@olibre <code>callable(getattr(C, name))</code> is one option, it is always better than grabbing dunders (<code>__get__</code>)</span>
<span class="comment-copy">üëç I have just successfully tested <code>getattr(C, attribute)</code>. You may write your comment in your answer. I see that <code>type(getattr(C, attribute))</code> returns <code>&lt;type 'instancemethod'&gt;</code> instead of <code>&lt;type 'staticmethod'&gt;</code> in my code. You may also explain it within your answer. Cheers</span>
<span class="comment-copy"><code>getattr</code> is definitely the indisputably right option. The entire problem is that <code>obj.attr</code> does a bit more than just <code>obj.__dict__['attr']</code>, and just blindly trying to do <code>obj.__class__.__dict__['attr'].__get__(obj.__class__)</code> isn't right either because it ignores instance attributes, mro and non-descriptor attributes. <code>getattr</code> knows about all the complexities and does the right thing.</span>
<span class="comment-copy">@olibre That's good. Both those objects (depending on Python version) are callable. Using <code>getattr</code> you've invoked the descriptor protocol (calling <code>staticmethod_obj.__get__</code>) and get back the callable it wraps. Take a look at the tutorial on <a href="https://docs.python.org/2.7/howto/descriptor.html#static-methods-and-class-methods" rel="nofollow noreferrer">descriptors</a> for a nice overview.</span>
