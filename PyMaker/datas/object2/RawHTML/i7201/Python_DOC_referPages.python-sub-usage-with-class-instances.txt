<div class="post-text" itemprop="text">
<pre><code>class Point:

    def __init__(self, x = 0, y = 0):
      self.x = x
      self.y = y

    def __sub__(self, other):
        x = self.x + other.x
        y = self.y + other.y
        return Point(x,y)

p1 = Point(3, 4)
p2 = Point(1, 2)
result = p1-p2
print(result.x, result.y) # prints (4,6)
</code></pre>
<p>Can anyone explain how the above code works. Can't get my head around it.
I understand that <code>__sub__</code> is an operator overloader in python and intercepts the p1-p2 call. But how does it work with two separate instances of class ?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>__sub__</code> is supposed to be the magic method equivalent of <code>-</code> arithmetic operator, so not sure why you're <em>adding</em> them... </p>
<p>That aside, when you do <code>p1 - p2</code>, it is the same as <code>p1.__sub__(p2)</code>. The <code>__sub__</code> function is invoked on <code>p1</code>, the calculation made and the new <code>Point</code> object returned.</p>
</div>
<div class="post-text" itemprop="text">
<p>Now you edited the question, the answer is simple:</p>
<pre><code>p1 = Point(3, 4)
p2 = Point(1, 2)
result = p1-p2
</code></pre>
<p>You have two points as arguments <code>self, other</code>, so, self, obviously in your example would be <strong><code>p1</code></strong>, and other is <strong><code>p2</code></strong>, after doing all the calculation, you return a new <strong>Point</strong>, so, <code>p1</code> and <code>p2</code> are not modified.</p>
<blockquote>
<p>Important advice</p>
</blockquote>
<p>The most rare thing, is that you call it <code>__sub__</code>, but indeed, you are actually <em>adding</em>! I mean, please... either change the method definition and replace + by -, or change <code>__sub__</code>... just a piece of advice.</p>
</div>
<span class="comment-copy">Any particular part?</span>
<span class="comment-copy"><code>p1-p2</code> will result in a <code>p1.__sub__(p2)</code> call...</span>
<span class="comment-copy">That looks like the implementation for an <code>__add__()</code> method, not <code>__sub__()</code>.  As for how it works: <code>p1-p2</code> gets turned into <code>p1.__sub__(p2)</code>.</span>
<span class="comment-copy">3. Data model → 3.3. Special method names → <a href="https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types" rel="nofollow noreferrer">3.3.7. Emulating numeric types</a></span>
<span class="comment-copy">@IgnacioVazquez-Abrams I don't quite understand how subtract operation on two instances get intercepted by` __sub__` . All others try to give the text book output of the code, but don't explain how it really works in terms of class instances.</span>
<span class="comment-copy">Well... as always, totally right every word :D, it's a plus one pal.</span>
<span class="comment-copy">cᴏʟᴅsᴘᴇᴇᴅ thanks for the edit! more professional now ;)</span>
<span class="comment-copy">"you call it sub, but indeed, you are actually adding " I suppose that's the whole point of operator overloading. Performing an arbitrary operation by intercepting an operation - subtract in this case.</span>
<span class="comment-copy">@SamRohn of course! please don't misunderstand me, this advice is just for people who may use your code, and well... imagine, in school they teach that sum two points is.. sum x and y, and sub, sub x and y, so when I do p1 - p2, I hope this sub... not sum... I hope I was clear, and I hope my answer helped you</span>
<span class="comment-copy">More professional and worthy of a +1 for sure :p</span>
