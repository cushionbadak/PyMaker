<div class="post-text" itemprop="text">
<p>I have a list of dictionaries.  I want the average age of people whose age is less than 25.</p>
<p>I know my divisor is wrong but I am not sure how to adjust it inside of the comprehension.</p>
<p>I am getting 81/8 = 10.125.  I should be getting 81/5 = 16.2.  How do I get the divisor to match the number of elements being added?</p>
<pre><code>people = [{'name': 'John', 'age': 47, 'hobbies': ['Python', 'cooking', 'reading']},
          {'name': 'Mary', 'age': 16, 'hobbies': ['horses', 'cooking', 'art']},
          {'name': 'Bob', 'age': 14, 'hobbies': ['Python', 'piano', 'cooking']},
          {'name': 'Sally', 'age': 11, 'hobbies': ['biking', 'cooking']},
          {'name': 'Mark', 'age': 54, 'hobbies': ['hiking', 'camping', 'Python', 'chess']},
          {'name': 'Alisa', 'age': 52, 'hobbies': ['camping', 'reading']},
          {'name': 'Megan', 'age': 21, 'hobbies': ['lizards', 'reading']},
          {'name': 'Amanda', 'age': 19, 'hobbies': ['turtles']},
          ]


print(float(sum(d['age'] for d in people if d['age'] &lt; 25)) / len(people))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Instead of doing it all in one list comprehension, I'd split it up into two commands like so:</p>
<pre><code>&gt;&gt;&gt; under_25 = [x['age'] for x in people if x['age'] &lt; 25]
&gt;&gt;&gt; avg_age = sum(under_25)/float(len(under_25))
</code></pre>
<p>Doing all of this in one list comprehension would require you to do it twice (once for the sum in the numerator and another time for the length in the denominator). I think this is more readable as well. </p>
<p>You could even try doing it in a for loop:</p>
<pre><code>count = 0
s = 0
for person in people:
    if person['age'] &lt; 25:
        s += person['age']
        count += 1
avg_age = float(s)/count
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The easiest solution would be to use <a href="http://www.numpy.org/" rel="nofollow noreferrer"><code>numpy</code></a> with a conditional list comprehension:</p>
<pre><code>import numpy as np

&gt;&gt;&gt; np.mean([p['age'] for p in people if 'age' in p and p['age'] &lt; 25])
16.199999999999999
</code></pre>
<p>Using a pure python solution, you should keep track of the total and the count as you evaluate each element in the collection.  This reduces the memory footprint, as you do not need to store all of the values that match your criteria.  Note that I used a generator in the enumeration.</p>
<pre><code>total_age = 0.
for n, age in enumerate((p['age'] for p in people if 'age' in p and p['age'] &lt; 25), start=1):
    total_age += age
&gt;&gt;&gt; print(total_age / n)
16.2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python has a <a href="https://docs.python.org/3/library/statistics.html#module-statistics" rel="nofollow noreferrer"><code>statistics</code></a> module that contains a <a href="https://docs.python.org/3/library/statistics.html#statistics.mean" rel="nofollow noreferrer"><code>mean</code></a> function:</p>
<pre><code>&gt;&gt;&gt; from statistics import mean
&gt;&gt;&gt; mean(d['age'] for d in people if d['age'] &lt; 25)
16.2
</code></pre>
<p>Or if you have <code>pandas</code> you could do it with boolean indexing:</p>
<pre><code>&gt;&gt;&gt; import pandas as pd

&gt;&gt;&gt; df = pd.DataFrame(people, columns=['name', 'age', 'hobbies'])
&gt;&gt;&gt; df[df['age'] &lt; 25]['age'].mean()
16.2
</code></pre>
<p>The <code>df[df['age'] &lt; 25]</code> only contains those rows that have an age below 25 and the <code>['age'].mean()</code> then calculates the mean of the "age" column.</p>
</div>
