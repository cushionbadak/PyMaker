<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/28312490/i-am-trying-to-make-a-function-which-return-max-from-nested-list">I am trying to make a function which return max from nested list?</a>
<span class="question-originals-answer-count">
                    6 answers
                </span>
</li>
</ul>
</div>
<p>Right now I'm stuck at a problem and can't seem to figure it out.
I have a list/tuple, which can in turn contain many lists/tuples/ints. I need to find the maximum value out of the object, and hence I need to look into all levels inside the object. As an example, I have the item:</p>
<pre><code>(5, (1,2), [[1],[2]])
</code></pre>
<p>I need to write a function which returns me 5, which is the max value inside the object. </p>
<p>Few more examples:</p>
<pre><code>([[2, 1, 5], [4, 2], 6], ([2, 1], (7, 7, 5), 6))
</code></pre>
<p>Function should return 7</p>
<pre><code>((4,), (2,), (6, 2), (3, 6, 2))
</code></pre>
<p>Function should return 6</p>
<pre><code>[[[[[[6]]]]]]
</code></pre>
<p>Function should return 6</p>
<p>Edit 1:</p>
<p>I did try this myself. This is how I thought to solve it.</p>
<pre><code>def function1(x): 

global flatList    
flatList = []

for i in x:
    if type(i) is int or type(i) is float:
        flatList.append(i)
    else:
        max_val(i)

if len(flatList) != 0:
    return max(flatList)
</code></pre>
<p>I used Python Tutor to see what is wrong with my code, and I know that every time I recursively call my function, the flatList variable is getting assigned back to an empty list, and hence, the flatList will only contain the element from the last recursive call, if I am guessing correctly. I also cannot create the flatList variable outside the function, as it is one of the requirements of the assignment that I do not create any global variables of my own.</p>
</div>
<div class="post-text" itemprop="text">
<p>Let’s try to tackle the problem together: You probably do know how to get the maximum value of a non-nested iterable (being it a list, tuple, or whatever). You can use the built-in <a href="https://docs.python.org/3/library/functions.html#max" rel="nofollow noreferrer"><code>max()</code></a> function, or alternatively write your own if you may not use a built-in function for your task.</p>
<p>We’ll assume for now that we have a <code>max</code> function (self-written or not) that accepts a non-nested iterable and returns the maximum, e.g:</p>
<pre><code>&gt;&gt;&gt; max([2, 1, 5])
5
&gt;&gt;&gt; max((7, 7, 5))
7
</code></pre>
<p>So we know how to solve this for the easiest case: non-nested iterables. Now let’s go one level up: We have an iterable of iterables, for example this:</p>
<pre><code>lst = [[2, 1, 5], [4, 2]]
</code></pre>
<p>How do we get the maximum here? We first get the maximum for each sublist and then get the maximum of all calculated maximums. Something like this:</p>
<pre><code>maximums = []
for sublist in lst:
    maximums.append(max(sublist))
print(max(maximums)) # 5
</code></pre>
<p>So far so good. Now let’s assume that our list <code>lst</code> also contains single numbers, so it’s an uneven list:</p>
<pre><code>lst = [[2, 1, 5], 8, [4, 2], 2]
</code></pre>
<p>So when we loop through the items of the list, we need to either just take the number or calculate the maximum for the sublist:</p>
<pre><code>maximums = []
for item in lst:
    if isinstance(item, int):
        # item is a number itself, so it’s the maximum of itself
        maximums.append(item)
    else:
        maximums.append(max(sublist))
print(max(maximums)) # 8
</code></pre>
<p>So now we have the ability to max an iterable that contains mixed values. Now what we need to do is make sure that this works for any level of nestedness. For this purpose, we use <a href="https://en.wikipedia.org/wiki/Recursion" rel="nofollow noreferrer">recursion</a>: We start at the outermost list and iterate through its items. When the item is a number, we can just keep the number. When its an iterable, we calculate its maximum using our solution. Afterwards we get the maximum of all collected maximums:</p>
<pre><code>def nested_max(iterable):
    maximums = []
    for item in iterable:
        if isinstance(item, int):
            # still nothing to do with simple numbers
            maximums.append(item)
        else:
            # we encountered an iterable but we do not know how deep it is; so instead of
            # using the simple `max` function, we use our `nested_max` function recursively
            maximums.append(nested_max(item))

    # maximums only contains numbers, so we can use the normal `max` here
    return max(maximums)
</code></pre>
<p>And that’s it! Let’s give it a try:</p>
<pre><code>&gt;&gt;&gt; nested_max((5, (1,2), [[1],[2]]))
5
&gt;&gt;&gt; nested_max(([[2, 1, 5], [4, 2], 6], ([2, 1], (7, 7, 5), 6)))
7
&gt;&gt;&gt; nested_max(((4,), (2,), (6, 2), (3, 6, 2)))
6
&gt;&gt;&gt; nested_max([[[[[[6]]]]]])
6
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you don't mind an external library you could use <a href="https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html" rel="nofollow noreferrer"><code>deepflatten</code></a> from <code>iteration_utilities</code> (disclaimer: I'm the author) and pythons <a href="https://docs.python.org/library/functions.html#max" rel="nofollow noreferrer"><code>max</code></a> function.</p>
<pre><code>from iteration_utilities import deepflatten

a = (5, (1,2), [[1],[2]])
b = ([[2, 1, 5], [4, 2], 6], ([2, 1], (7, 7, 5), 6))
c = ((4,), (2,), (6, 2), (3, 6, 2))
d = [[[[[[6]]]]]]

&gt;&gt;&gt; max(deepflatten(a))
5
&gt;&gt;&gt; max(deepflatten(b))
7
&gt;&gt;&gt; max(deepflatten(c))
6
&gt;&gt;&gt; max(deepflatten(d))
6
</code></pre>
<p>A rough pure-python equivalent of <code>deepflatten</code> can be found in the linked documentation. It is:</p>
<pre><code>def deepflatten(iterable, depth=None, types=None, ignore=None):
    if depth is None:
        depth = float('inf')
    if depth == -1:
        yield iterable
    else:
        for x in iterable:
            if ignore is not None and isinstance(x, ignore):
                yield x
            if types is None:
                try:
                    iter(x)
                except TypeError:
                    yield x
                else:
                    for item in deepflatten(x, depth - 1, types, ignore):
                        yield item
            elif not isinstance(x, types):
                yield x
            else:
                for item in deepflatten(x, depth - 1, types, ignore):
                    yield item
</code></pre>
</div>
<span class="comment-copy">Stack Overflow is not here to do your homework.</span>
<span class="comment-copy">I think I saw this question yesterday already.</span>
<span class="comment-copy">I closed this question just yesterday as a dupe @Jean-FrançoisFabre ... looking for that now.</span>
<span class="comment-copy">@Jean-FrançoisFabre <a href="https://stackoverflow.com/questions/45380115/python-finding-the-max-in-a-tuple-of-int-tuple-and-list" title="python finding the max in a tuple of int tuple and list">stackoverflow.com/questions/45380115/…</a></span>
<span class="comment-copy">@COLDSPEED: There was still another question with the exact same problem, yesterday. I wrote a nice recursive answer, but cannot find it anymore. Has it been deleted too?</span>
<span class="comment-copy">@RoryDaulton You're right. I edited the answer. :)</span>
<span class="comment-copy">I like the edit--more general and useful than the OP requested, so better for the rest of us.</span>
<span class="comment-copy">The problem of flattening an arbitrarily nested list of lists is already handled properly in other questions though, e.g. <a href="https://stackoverflow.com/q/2158395/216074">Flatten (an irregular) list of lists</a>.</span>
