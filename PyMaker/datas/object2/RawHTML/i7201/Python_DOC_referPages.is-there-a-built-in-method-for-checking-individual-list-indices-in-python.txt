<div class="post-text" itemprop="text">
<p>Python has a built in functionality for checking the validity of entire slices: <a href="https://docs.python.org/3/reference/datamodel.html?highlight=slice.indices#slice.indices" rel="nofollow noreferrer"><code>slice.indices</code></a>. Is there something similar that is built-in for individual indices?</p>
<p>Specifically, I have an index, say <code>a = -2</code> that I wish to normalize with respect to a 4-element list. Is there a method that is equivalent to the following already built in?</p>
<pre><code>def check_index(index, length):
    if index &lt; 0:
        index += length
    if index &lt; 0 or index &gt;= length:
        raise IndexError(...)
</code></pre>
<p>My end result is to be able to construct a tuple with a single non-<code>None</code> element. I am currently using <code>list.__getitem__</code> to do the check for me, but it seems a little awkward/overkill:</p>
<pre><code>items = [None] * 4
items[a] = 'item'
items = tuple(items)
</code></pre>
<p>I would like to be able to do</p>
<pre><code>a = check_index(a, 4)
items = tuple('item' if i == a else None for i in range(4))
</code></pre>
<p>Everything in this example is pretty negotiable. The only things that are fixed is that I am getting <code>a</code> in a way that can have all of the problems that an arbitrary index can have and that the final result has to be a <code>tuple</code>.</p>
<p>I would be more than happy if the solution used numpy and only really applied to numpy arrays instead of Python sequences. Either one would be perfect for the application I have in mind.</p>
</div>
<div class="post-text" itemprop="text">
<p>If I understand correctly, you can use <code>range(length)[index]</code>, in your example <code>range(4)[-2]</code>. This properly handles negative and out-of-bounds indices. At least in recent versions of Python, <code>range()</code> doesn't literally create a full list so this will have decent performance even for large arguments.</p>
<p>If you have a large number of indices to do this with in parallel, you <em>might</em> get better performance doing the calculation with Numpy vectorized arithmetic, but I don't think the technique with <code>range</code> will work in that case. You'd have to manually do the calculation using the implementation in your question.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a function called <code>numpy.core.multiarray.normalize_axis_index</code> which does exactly what I need. It is particularly useful to be because the implementation I had in mind was for <code>numpy</code> array indexing:</p>
<pre><code>from numpy.core.multiarray import normalize_axis_index

&gt;&gt;&gt; normalize_axis_index(3, 4)
3
&gt;&gt;&gt; normalize_axis_index(-3, 4)
1
&gt;&gt;&gt; normalize_axis_index(-5, 4)
...
numpy.core._internal.AxisError: axis -5 is out of bounds for array of dimension 4
</code></pre>
<p>The function was added in version 1.13.0. The source for this function is available <a href="https://github.com/numpy/numpy/blob/5a08e209863038b411bc506893093c5a4b8377c9/numpy/core/src/multiarray/multiarraymodule.c#L4067" rel="nofollow noreferrer">here</a>, and the documentation source is <a href="https://github.com/numpy/numpy/blob/5a08e209863038b411bc506893093c5a4b8377c9/numpy/add_newdocs.py#L6739" rel="nofollow noreferrer">here</a>.</p>
</div>
<span class="comment-copy">Wait, do you want a tuple or an array? It's hard to tell.</span>
<span class="comment-copy">Have a look here <a href="http://code.activestate.com/recipes/579000/" rel="nofollow noreferrer">code.activestate.com/recipes/579000</a></span>
<span class="comment-copy">@user2357112. Final result is a tuple. It will be used to create an index into an array, so I am willing to look at array-only methods for doing the index check.</span>
<span class="comment-copy">@RajanChauhan. I am not sure I understand how that is even remotely relevant.</span>
<span class="comment-copy">Any particular reason you don't want to go through the intermediate list? It seems perfectly fine to me, and <a href="http://ideone.com/7fdvTz" rel="nofollow noreferrer">it's faster</a>.</span>
<span class="comment-copy">In terms of what I want: <code>r = range(4); a = r[a]; items = tuple('item' if i == a else None for i in r)</code>. Not bad at all. I will wait a little while before selecting just in case.</span>
<span class="comment-copy">@MadPhysicist BTW if you're literally trying to do just that, I wonder if something along the lines of <code>tuple([None] * a + ['item'] + [None] * (length - a - 1))</code> would be more efficient... not sure as I haven't tested it, but it might be worth a try.</span>
<span class="comment-copy">Not really, since you end up creating a bunch of intermediate lists. I am also creating a couple of these indices, so that the range and <code>a</code> both get reused.</span>
<span class="comment-copy">In older versions, you just use <code>xrange</code> instead of range.</span>
