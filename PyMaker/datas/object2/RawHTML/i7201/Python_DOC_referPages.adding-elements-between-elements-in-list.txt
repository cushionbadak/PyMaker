<div class="post-text" itemprop="text">
<p>If I have a list eg.</p>
<pre><code>[1,2,3]
</code></pre>
<p>and a function f(), how do I insert such that the new list is like:</p>
<pre><code>[1, f(1), 2, f(2), 3, f(3)]? 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use:</p>
<pre><code>[y for x in data for y in (x,f(x))]
</code></pre>
<p>with <code>data</code> the initial list, and <code>f</code> of course the function you want to apply.</p>
<p>For example if <code>f</code> is the <code>str</code> function (converts a number to its textual equivalent), it will generate:</p>
<pre><code>&gt;&gt;&gt; data = [1,2,3]
&gt;&gt;&gt; f = str
&gt;&gt;&gt; [y for x in data for y in (x,f(x))]
[1, '1', 2, '2', 3, '3']
</code></pre>
<p>So here we obtain <code>[1, '1', 2, '2', 3, '3']</code> where <code>1</code> is the initial <code>1</code>, and <code>'1'</code> is <code>f(1)</code>.</p>
<p><strong>Benchmarks</strong>: I altered the <a href="https://stackoverflow.com/a/45494808/67579">following test setup</a> to:</p>
<pre><code>import pandas as pd
from timeit import timeit
from itertools import chain

wvo = lambda d, f: [y for x in d for y in (x,f(x))]
max = lambda d, f: list(chain.from_iterable(zip(d, map(f, d))))
mrc = lambda d, f: sum([[x,f(x)] for x in d], [])
chi = lambda d,f: [j for k in map(lambda x: (x, f(x)), d) for j in k]
mar = lambda d,f: [ee for e in zip (d, map (f, d)) for ee in e]

results = pd.DataFrame(
    index=pd.Index([1, 3, 10, 30, 100, 300,
                    1000, 3000, 10000, 30000, 100000], name='N'),
    columns='wvo max mrc chi mar'.split(),
    dtype=float
)

for i in results.index:
    pd.concat([df] * i, ignore_index=True)
    d = list(range(i))
    f = str
    for j in results.columns:
        stmt = '{}(d,f)'.format(j)
        setp = 'from __main__ import d, f, {}'.format(j)
        results.set_value(i, j, timeit(stmt, setp, number=10))
</code></pre>
<p>This means we can test the different answers for different file sizes using pandas. For every configuration, we perform 10 tests with timeit.</p>
<p>This generates the following timings (in seconds):</p>
<pre><code>             wvo       max          mrc       chi       mar
N                                                          
1       0.000016  0.000029     0.000018  0.000022  0.000020
3       0.000026  0.000029     0.000031  0.000034  0.000026
10      0.000057  0.000053     0.000061  0.000076  0.000062
30      0.000145  0.000122     0.000210  0.000200  0.000145
100     0.000440  0.000347     0.000899  0.000588  0.000407
300     0.001263  0.000637     0.004416  0.001721  0.000680
1000    0.002425  0.001897     0.040877  0.003796  0.002325
3000    0.009269  0.009798     0.289162  0.015486  0.008430
10000   0.037131  0.032563     3.823171  0.044008  0.030609
30000   0.078577  0.060828    53.803486  0.096703  0.066899
100000  0.255477  0.195669  1094.482380  0.289030  0.191143
</code></pre>
<p>Or in relative terms (best is <code>1.00</code>):</p>
<pre><code>         wvo   max      mrc   chi   mar Best
N                                           
1       1.00  1.78     1.11  1.36  1.19  wvo
3       1.03  1.15     1.23  1.32  1.00  mar
10      1.08  1.00     1.17  1.45  1.18  max
30      1.19  1.00     1.73  1.65  1.20  max
100     1.27  1.00     2.59  1.69  1.17  max
300     1.98  1.00     6.93  2.70  1.07  max
1000    1.28  1.00    21.55  2.00  1.23  max
3000    1.10  1.16    34.30  1.84  1.00  mar
10000   1.21  1.06   124.90  1.44  1.00  mar
30000   1.29  1.00   884.52  1.59  1.10  max
100000  1.34  1.02  5725.98  1.51  1.00  mar
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>In [18]: lst = [1,2,3]

In [19]: def f(x):
    ...:     return x**2
    ...:

In [20]: from itertools import chain

In [21]: list(chain.from_iterable(zip(lst, map(f, lst))))
Out[21]: [1, 1, 2, 4, 3, 9]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A slightly different approach from Willem's answer, that avoids two loops:</p>
<pre><code>sum([[x,f(x)] for x in my_list], [])
</code></pre>
<ul>
<li><p><code>[x, f(x)]</code> creates a list of two elements with the current element and the function applied to it.</p></li>
<li><p><code>sum(..., [])</code> flattens the list.</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; data = [1, 2, 3]
&gt;&gt;&gt; f = lambda x : x + 1
&gt;&gt;&gt; [ee for e in zip (data, map (f, data)) for ee in e]
[1, 2, 2, 3, 3, 4]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>map</code> and <code>list comprehension</code>:</p>
<pre><code>f = lambda x: x**3
a = [1, 2, 3]
output = [j for k in map(lambda x: (x, f(x)), a) for j in k]
print(output)
</code></pre>
<p>Output:</p>
<pre><code>[1, 1, 2, 8, 3, 27]
</code></pre>
</div>
<span class="comment-copy">Have you tried anything here to get to your solution? Would be great to see your attempt to help correct your problems.</span>
<span class="comment-copy"><a href="https://docs.python.org/2/tutorial/datastructures.html" rel="nofollow noreferrer">https://docs.python.org/2/tutorial/datastructures.html</a></span>
<span class="comment-copy">Right, because <code>sum</code> works without looping, and repeated list concatenations are more efficient… This is a lot worse; having a loop isn’t a bad thing.</span>
<span class="comment-copy">Did not dv (did +1), but it is not because you do not see a loop, that there is no loop. Slicing or extending works with loops internally...  The only question I have is whether Python uses <code>__add__</code> or <code>__iadd__</code> because in the former case, this will result in an <i>O(n^2)</i> algorithm.</span>
<span class="comment-copy">Basd on a quick experiment, the initial value <code>[]</code> is not updated. So that probably means that it uses <code>__add__</code>. This <a href="https://stackoverflow.com/questions/31054393/why-doesnt-python-take-advantage-of-iadd-for-sum-and-chained-operators">question</a> confirms it.</span>
<span class="comment-copy"><code>sum</code> should <i>not</i> be used for iterables. It’s very inefficient for that. Even <a href="https://docs.python.org/3/library/functions.html#sum" rel="nofollow noreferrer">the documentation</a> explicitly notes that one should use <code>itertools.chain</code> instead.</span>
<span class="comment-copy">I agree that this has <code>O(n^2)</code> complexity and that having two loops is completely not a bad thing, but I do however disagree that this is much more inefficient. Running tests on the two approaches resulted in comparable times in every each case. Although it is not the most viable solution, it is not true that internal methods are much less efficient than top-level loops. Additionally, I really doubt the OP needed an extremely performant approach given the tests they provided.</span>
