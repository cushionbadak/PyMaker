<div class="post-text" itemprop="text">
<p>I finally upgraded my python version and I was discovering the new features added. Among other things, I was scratching my head around the new <a href="https://docs.python.org/3/reference/datamodel.html#object.__init_subclass__" rel="noreferrer"><code>__init_subclass__</code></a> method. From the docs:</p>
<blockquote>
<p>This method is called whenever the containing class is subclassed. cls
  is then the new subclass. If defined as a normal instance method, this
  method is implicitly converted to a class method.</p>
</blockquote>
<p>So I started to playing around with it a little bit, following the example in the docs:</p>
<pre><code>class Philosopher:
    def __init_subclass__(cls, default_name, **kwargs):
        super().__init_subclass__(**kwargs)
        print(f"Called __init_subclass({cls}, {default_name})")
        cls.default_name = default_name

class AustralianPhilosopher(Philosopher, default_name="Bruce"):
    pass

class GermanPhilosopher(Philosopher, default_name="Nietzsche"):
    default_name = "Hegel"
    print("Set name to Hegel")

Bruce = AustralianPhilosopher()
Mistery = GermanPhilosopher()
print(Bruce.default_name)
print(Mistery.default_name)
</code></pre>
<p>Produces this output:</p>
<pre><code>Called __init_subclass(&lt;class '__main__.AustralianPhilosopher'&gt;, 'Bruce')
'Set name to Hegel'
Called __init_subclass(&lt;class '__main__.GermanPhilosopher'&gt;, 'Nietzsche')
'Bruce'
'Nietzsche'
</code></pre>
<p>I understand that this method is called <em>after</em> the subclass definition, but my questions are particularly about the usage of this feature. I read the <a href="https://www.python.org/dev/peps/pep-0487/#new-ways-of-using-classes" rel="noreferrer">PEP 487</a> article as well, but didn't help me much. Where would this method be helpful? Is it for:</p>
<ul>
<li>the superclass to register the subclasses upon creation?</li>
<li>forcing the subclass to set a field at definition time?</li>
</ul>
<p>Also, do I need to understand the <a href="https://docs.python.org/3/reference/datamodel.html#object.__set_name__" rel="noreferrer"><code>__set_name__</code></a> to fully comprehend its usage?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>__init_subclass__</code> and <code>__set_name__</code> are orthogonal mechanisms - they're not tied to each other, just described in the same PEP. Both are features that needed a full-featured metaclass before. The PEP 487 addresses <em>2</em> of the most common uses of metaclasses:</p>
<ul>
<li>how to let the parent know when it is being subclassed (<code>__init_subclass__</code>)</li>
<li>how to let a descriptor class know the name of the property it is used for (<code>__set_name__</code>)</li>
</ul>
<p>As the PEP says:</p>
<blockquote>
<p>While there are many possible ways to use a metaclass, the <strong>vast majority of use cases falls into just three categories: some initialization code running after class creation, the initialization of descriptors and keeping the order in which class attributes were defined.</strong></p>
<p>The first two categories can easily be achieved by having simple hooks into the class creation:</p>
<ul>
<li>An <code>__init_subclass__</code> hook that initializes all subclasses of a given class.</li>
<li>upon class creation, a <code>__set_name__</code> hook is called on all the attribute (descriptors) defined in the class, and</li>
</ul>
<p>The third category is the topic of another PEP, <a href="https://www.python.org/dev/peps/pep-0520/" rel="noreferrer">PEP 520</a>.</p>
</blockquote>
<p>Notice also, that while <code>__init_subclass__</code> is a replacement for using a metaclass in <em>this</em> class's inheritance tree, <code>__set_name__</code> in a <em>descriptor class</em> is a replacement for using a metaclass for the class that has an instance of the <em>descriptor as an attribute</em>.</p>
</div>
<div class="post-text" itemprop="text">
<p>PEP 487 sets out to take two common metaclass usecases and make them more accessible without having to understand all the ins and outs of metaclasses. The two new features, <code>__init_subclass__</code> and <code>__set_name__</code> are otherwise <em>independent</em>, they don't rely on one another.</p>
<p><code>__init_subclass__</code> is just a hook method. You can use it for anything you want. It is useful for both registering subclasses in some way, <em>and</em> for setting default attribute values on those subclasses.</p>
<p>We recently used this to provide 'adapters' for different version control systems, for example:</p>
<pre><code>class RepositoryType(Enum):
    HG = auto()
    GIT = auto()
    SVN = auto()
    PERFORCE = auto()

class Repository():
    _registry = {t: {} for t in RepositoryType}

    def __init_subclass__(cls, scm_type=None, name=None, **kwargs):
        super().__init_subclass__(**kwargs)
        if scm_type is not None:
            cls._registry[scm_type][name] = cls

class MainHgRepository(Repository, scm_type=RepositoryType.HG, name='main'):
    pass

class GenericGitRepository(Repository, scm_type=RepositoryType.GIT):
    pass
</code></pre>
<p>This trivially let us define handler classes for specific repositories without having to resort to using a metaclass or decorators.</p>
</div>
<div class="post-text" itemprop="text">
<p>The main point of <code>__init_subclass__</code> was, as the title of the PEP suggest, to offer a simpler form of customization for classes. </p>
<p>It's a hook that allows you to tinker with classes w/o the need to know about metaclasses, keep track of all aspects of class construction or worry about metaclass conflicts down the line. As <a href="http://grokbase.com/t/python/python-ideas/153hynf2mm/simpler-customization-of-class-creation-next-round#20150409ep7rox3gxud5mkjck5meak2mdq" rel="nofollow noreferrer">a message</a> by Nick Coghlan on the early phase of this PEP states:</p>
<blockquote>
<p>The main intended readability/maintainability benefit is from the
  perspective of more clearly distinguishing the "customises subclass
  initialisation" case from the "customises runtime behaviour of
  subclasses" case.</p>
<p>A full custom metaclass doesn't provide any indication of the scope of
  impact, while <code>__init_subclass__</code> more clearly indicates that there's no
  persistent effects on behaviour post-subclass creation.</p>
</blockquote>
<p>Metaclasses are considered magic for a reason, you don't know what their effects will be after the class will be created. <code>__init_subclass__</code>, on the other hand, is just another class method, it runs once and then it's done. <a href="https://docs.python.org/3/reference/datamodel.html#object.__init_subclass__" rel="nofollow noreferrer">(see its documentation for exact functionality.)</a> </p>
<hr/>
<p>The whole point of PEP 487 is about simplifying (i.e removing the need to use) metaclasses for some common uses.</p>
<p><code>__init_subclass__</code> takes care of post-class initialization while  <code>__set_name__</code> (which makes sense only for descriptor classes) was added to simplify initializing descriptors. Beyond that, they aren't related.</p>
<p>The third common case for metaclasses (keeping definition order) which is mentioned, <a href="https://www.python.org/dev/peps/pep-0520/" rel="nofollow noreferrer">was also simplified</a>. This was addressed w/o a hook, by using an ordered mapping for the namespace (which in Python 3.6 is a <code>dict</code>, but that's an implementation detail :-)</p>
</div>
<div class="post-text" itemprop="text">
<p>I would like to add some references related to metaclasses and <code>__init_subclass__</code> that may be helpful.</p>
<p><em>Background</em></p>
<p><code>__init_subclass__</code> was introduced as an alternative to creating metaclasses.
Here is a 2-minute summary of <a href="https://www.python.org/dev/peps/pep-0487/" rel="nofollow noreferrer">PEP 487</a> in a <a href="https://youtu.be/hk85RUtQsBI?t=3m50s" rel="nofollow noreferrer">talk</a> by one of the core developers, Brett Cannon.</p>
<p><em>Recommended References</em></p>
<ul>
<li>Guido van Rossum's <a href="https://python-history.blogspot.com/search?updated-min=2009-01-01T00:00:00-08:00&amp;updated-max=2010-01-01T00:00:00-08:00&amp;max-results=19" rel="nofollow noreferrer">blog post</a> on the early history of metaclasses in Python</li>
<li>Jake Vanderplas's <a href="https://jakevdp.github.io/blog/2012/12/01/a-primer-on-python-metaclasses/" rel="nofollow noreferrer">blog post</a> looking more deeply on implementing metaclasses</li>
</ul>
</div>
<span class="comment-copy">I haven't dealt with metaclasses that much to fully understand its usage, but thanks to your explanation (and the others) it looks like there are plenty of situations where we need to "finish" the definition of a subclass after its declaration.</span>
<span class="comment-copy">Nice example. Reading other answers as well, I understand this is like a shortcut to extend the functionalities of base classes without having to handle with metaclasses.</span>
<span class="comment-copy">@MartijnPieters in the <code>GenericGitRepository</code> are you missing the <code>name</code> attribute in the class definition? great example, I love it.</span>
<span class="comment-copy">@JulianCamilleri: no, the point is that the <code>name</code> parameter is optional.</span>
<span class="comment-copy">Sorry for all the questions @MartijnPieters; was curious as to what happens at this stage: <code>cls._registry[scm_type][name] = cls</code> when <code>name</code> is <code>None</code> - is there a mechanism of some sort that I'm missing?</span>
<span class="comment-copy">Then <code>None</code> is the key in the second level. That’s just as valid a key as a string name. So you can have a bunch of named classes and one “default” and unnamed option registered under the key <code>None</code>.</span>
