<div class="post-text" itemprop="text">
<p>I am wondering why <code>repr(int)</code> is faster than <code>str(int)</code>. With the following code snippet:</p>
<pre><code>ROUNDS = 10000

def concat_strings_str():
    return ''.join(map(str, range(ROUNDS)))

def concat_strings_repr():
    return ''.join(map(repr, range(ROUNDS)))

%timeit concat_strings_str()
%timeit concat_strings_repr()
</code></pre>
<p>I get these timings (python 3.5.2, but very similar results with 2.7.12):</p>
<pre><code> 1.9 ms ± 17.9 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
 1.38 ms ± 9.07 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
</code></pre>
<p>If I'm on the right path, <a href="https://github.com/python/cpython/blob/abda8ddd3e4927bda1b58cf60a5d09db186f6ca5/Objects/longobject.c#L4989" rel="noreferrer">the same function <code>long_to_decimal_string</code> is getting called</a> below the hood.</p>
<p>Did I get something wrong or what else is going on that I am missing?</p>
<hr/>
<p><strong>update</strong>:
This probably has nothing to with <code>int</code>'s <code>__repr__</code> or <code>__str__</code> methods but with the differences between <code>repr()</code> and <code>str()</code>, as <code>int.__str__</code> and <code>int.__repr__</code> are in fact comparably fast:</p>
<pre><code>def concat_strings_str():
    return ''.join([one.__str__() for one in range(ROUNDS)])

def concat_strings_repr():
    return ''.join([one.__repr__() for one in range(ROUNDS)])

%timeit concat_strings_str()
%timeit concat_strings_repr()
</code></pre>
<p>results in:</p>
<pre><code>2.02 ms ± 24.3 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
2.05 ms ± 7.07 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Because using <code>str(obj)</code> must first go through <code>type.__call__</code> then <a href="https://github.com/python/cpython/blob/master/Objects/typeobject.c#L921" rel="nofollow noreferrer"><code>str.__new__</code> (create a new string)</a> then <a href="https://github.com/python/cpython/blob/master/Objects/unicodeobject.c#L15052" rel="nofollow noreferrer"><code>PyObject_Str</code> (make a string out of the object)</a> which invokes <a href="https://github.com/python/cpython/blob/a66f9c6bb134561a24374f10e8c35417d356ce14/Objects/object.c#L538" rel="nofollow noreferrer"><code>int.__str__</code></a> and, <em>finally</em>, uses the function you linked.</p>
<p><code>repr(obj)</code>, which corresponds to <code>builtin_repr</code>, directly calls <a href="https://github.com/python/cpython/blob/master/Python/bltinmodule.c#L2048" rel="nofollow noreferrer"><code>PyObject_Repr</code> (get the object repr)</a> which then calls <a href="https://github.com/python/cpython/blob/a66f9c6bb134561a24374f10e8c35417d356ce14/Objects/object.c#L485" rel="nofollow noreferrer"><code>int.__repr__</code></a> which uses the same function as <code>int.__str__</code>.</p>
<p>Additionally, the path they take through <a href="https://github.com/python/cpython/blob/master/Python/ceval.c#L4824" rel="nofollow noreferrer"><code>call_function</code></a> (the function that handles the <a href="https://docs.python.org/3/library/dis.html#opcode-CALL_FUNCTION" rel="nofollow noreferrer"><code>CALL_FUNCTION</code> opcode</a> that's generated for calls) is <em>slightly</em> different. </p>
<p>From the master branch on GitHub (CPython 3.7): </p>
<ul>
<li><code>str</code> goes through <a href="https://github.com/python/cpython/blob/6969eaf4682beb01bc95eeb14f5ce6c01312e297/Objects/call.c#L136" rel="nofollow noreferrer"><code>_PyObject_FastCallKeywords</code></a> (which is the one that calls <code>type.__call__</code>). Apart from performing more checks, this also needs to create a tuple to hold the positional arguments (see <a href="https://github.com/python/cpython/blob/6969eaf4682beb01bc95eeb14f5ce6c01312e297/Objects/call.c#L1270" rel="nofollow noreferrer"><code>_PyStack_AsTuple</code></a>). </li>
<li><code>repr</code> goes through <a href="https://github.com/python/cpython/blob/6969eaf4682beb01bc95eeb14f5ce6c01312e297/Objects/call.c#L717" rel="nofollow noreferrer"><code>_PyCFunction_FastCallKeywords</code></a> which calls <a href="https://github.com/python/cpython/blob/6969eaf4682beb01bc95eeb14f5ce6c01312e297/Objects/call.c#L588" rel="nofollow noreferrer"><code>_PyMethodDef_RawFastCallKeywords</code></a>. <code>repr</code> is also lucky because, since it only accepts a single argument (the switch leads it to the <code>METH_0</code> case in <code>_PyMethodDef_RawFastCallKeywords</code>) there's no need to create a tuple, just <a href="https://github.com/python/cpython/blob/6969eaf4682beb01bc95eeb14f5ce6c01312e297/Objects/call.c#L640" rel="nofollow noreferrer">indexing of the args</a>. </li>
</ul>
<p>As your update states, this isn't about <code>int.__repr__</code> vs <code>int.__str__</code>,  they are the same function after all; it's all about how <code>repr</code> and <code>str</code> reach them. <code>str</code> just needs to work a bit harder. </p>
</div>
<div class="post-text" itemprop="text">
<p>I just compared the <code>str</code> and <code>repr</code> implementations in the 3.5 branch.
See <a href="https://github.com/python/cpython/blob/v3.5.2/Objects/object.c#L457-L552" rel="noreferrer">here</a>.</p>
<p>There seems to be more checks in <code>str</code>: <a href="https://i.stack.imgur.com/eI092.jpg" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/eI092.jpg"/></a> </p>
</div>
<div class="post-text" itemprop="text">
<p>There are several possibilities because the CPython functions that are responsible for the <a href="https://github.com/python/cpython/blob/v3.5.2/Objects/object.c#L499-L552" rel="noreferrer"><code>str</code></a> and <a href="https://github.com/python/cpython/blob/v3.5.2/Objects/object.c#L457-L497" rel="noreferrer"><code>repr</code></a> return are slightly different.</p>
<p>But I guess the primary reason is that <code>str</code> is a <code>type</code> (a class) and the <a href="https://github.com/python/cpython/blob/v3.5.2/Objects/unicodeobject.c#L14739-L14758" rel="noreferrer"><code>str.__new__</code></a> method has to call <a href="https://github.com/python/cpython/blob/v3.5.2/Objects/unicodeobject.c#L14755" rel="noreferrer"><code>__str__</code></a> while <code>repr</code> can directly go to <code>__repr__</code>.</p>
</div>
<span class="comment-copy">I have Python 2.7.13 on windows 10 as I see absolutelty no significant difference on my machine. Did you try switching the order and see if it is some sort of system resource affect?</span>
<span class="comment-copy">@gbtimmon the order makes no difference</span>
<span class="comment-copy">I'm able to reliably reproduce on OS X using <code>python3 -m timeit "''.join(map(repr, range(10000)))"</code> and the equivalent <code>str</code> version or numerous runs. That should eliminate most concerns about caches, etc. But the difference goes away if I get rid of the <code>join</code>. <code>python3 -m timeit "map(str, range(10000))"</code></span>
<span class="comment-copy">@RobNapier without the <code>join</code> the <code>repr</code> (or <code>str</code>) does not actually get called.</span>
<span class="comment-copy">@RobNapier in python3 <code>map</code> returns an iterator so this doesn't actually do anything - you would need to construct the list, e.g. <code>python3 -m timeit "list(map(str, range(10000)))"</code></span>
