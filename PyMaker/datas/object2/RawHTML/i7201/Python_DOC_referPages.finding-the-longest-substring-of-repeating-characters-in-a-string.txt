<div class="post-text" itemprop="text">
<p>(this is the basis for <a href="http://codeforces.com/problemset/gymProblem/101306/A" rel="nofollow noreferrer">this codeforces problem</a>)</p>
<p>I try not to get help with codeforces problems unless i'm really, really, stuck, which happens to be now.</p>
<blockquote>
Your first mission is to find the password of the Martian database. To achieve this, your best secret agents have already discovered the following facts:

The password is a substring of a given string composed of a sequence of non-decreasing digits
The password is as long as possible
The password is always a palindrome
A palindrome is a string that reads the same backwards. racecar, bob, and noon are famous examples.

Given those facts, can you find all possible passwords of the database?

Input
The first line contains n, the length of the input string (1 ≤ n ≤ 105).

The next line contains a string of length n. Every character of this string is a digit.

The digits in the string are in non-decreasing order.

Output
On the first line, print the number of possible passwords, k.

On the next k lines, print the possible passwords in alphabetical order.
</blockquote>
<p>My observations are:</p>
<ol>
<li><p>A palindrome in a non-decreasing string is simply a string of repeating characters (eg. "4444" or "11" ) </p></li>
<li><p>on character <code>i</code>, the last instance of i - the first instance of i +1 = length of the repeating character</p></li>
<li><p>Keeping track of the max password length and then filtering out every item that is shorter than the max password length guarantees that the passwords outputted are of max length</p></li>
</ol>
<p>my solution based on these observations is:</p>
<pre><code>n,s = [input() for i in range(2)]#input

maxlength = 0

results = []


for i in s:
    length = (s.rfind(i)-s.find(i))+1 

    if int(i*(length)) not in results and length&gt;=maxlength:

        results.append(int(i*(length))) 

        maxlength = length 



#filer everything lower than the max password length out
results = [i for i in results if len(str(i))&gt;=maxlength]


#output
print(len(results))

for y in results:
    print(y)
</code></pre>
<p>unfortunately, this solution is wrong, in fact and fails on the 4th test case. I do not understand what is wrong with the code, and so i cannot fix it. Can someone help with this? </p>
<p>Thanks for reading!</p>
</div>
<div class="post-text" itemprop="text">
<p>Your program will fail on:</p>
<pre><code>4
0011
</code></pre>
<p>It will return just <code>11</code>.</p>
<p>The problem is that the length of <code>str(int('00'))</code> is equal to 1.</p>
<p>You could fix it by removing the <code>int</code> and <code>str</code> calls from your program (i.e. saving the answers as strings instead of ints).</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/a/45397744/21945">Peter de Rivaz</a> seems to have identified the problem with your code, however, if you are interested in a different way to solve this problem consider using a regular expression.</p>
<pre><code>import sys
import re

next(sys.stdin)             # length not needed in Python    
s = next(sys.stdin)

repeats = r'(.)\1+'
for match in re.finditer(repeats, s):
    print(match.group())
</code></pre>
<p>The pattern <code>(.)\1+</code> will find all substrings of repeated digits. Output for input</p>
<pre>
10
3445556788
</pre>
<p>would be:</p>
<pre>
44
555
88
</pre>
<p>If <a href="https://docs.python.org/3/library/re.html#re.finditer" rel="nofollow noreferrer"><code>re.finditer()</code></a> finds that there are no repeating digits then either the string is empty, or it consists of a sequence of increasing non-repeating digits. The first case is excluded since <em>n</em> must be greater than 0. For the second case the input is already sorted alphabetically, so just output the length and each digit.</p>
<p>Putting it together gives this code:</p>
<pre><code>import sys
import re

next(sys.stdin)                 # length not needed in Python
s = next(sys.stdin).strip()

repeats = r'(.)\1+'
passwords = sorted((m.group() for m in re.finditer(repeats, s)),
                    key=len, reverse=True)

passwords = [s for s in passwords if len(s) == len(passwords[0])]

if len(passwords) == 0:
    passwords = list(s)

print(len(passwords))
print(*passwords, sep='\n')
</code></pre>
<p>Note that the matching substrings are extracted from the <code>match</code> object and then sorted by length descending. The code relies on the fact that digits in the input must not decrease so a second alphabetic sort of the candidate passwords is not required.</p>
</div>
<span class="comment-copy">Is it failing b/c it generates the wrong answer, or b/c it takes too long?</span>
<span class="comment-copy">Your problem basically reduces to finding the total number of palindromes present in the given string with length&gt;1. Correct me if I am wrong and please provide me a counterexample if you can.</span>
<span class="comment-copy">It failed because it generated the wrong answer. Also, it does not mean just palindromes in the given string with length &gt;1, it means length &gt;= longest found palindrome. For example, if i find a palindrome "44", and then i find another "77777", i must discard the "44" and any other shorter palindromes since it is not maximum length anymore. <b>fortunately though, Peter de Rivas kindly pointed out that the issue was with storing the answers as ints instead of strings!</b></span>
