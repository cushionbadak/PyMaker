<div class="post-text" itemprop="text">
<p>I'm curious about the <code>@property</code> annotation in Python 3.</p>
<p>I know I can manipulate state between calls to a property like this ...</p>
<pre><code>class Obj:
    _x = 0
    @property
    def x(self):
        self._x += 1
        return self._x

obj = Obj()
print(obj.x)
print(obj.x)
</code></pre>
<p>... which prints:</p>
<pre><code>1
2
</code></pre>
<p>However, is it possible keep this mechanism after it has been passed to a function?</p>
<p>Take the following function:</p>
<pre><code>def f(x):
    print(x)
    print(x)
</code></pre>
<p>Say we cannot change it, meaning we can't simply pass the object to the function and use the properties directly. Is it possible to pass it only the property, or something to that effect, such that each time <code>x</code> is "used" in the function <code>x</code> increments? Is there maybe a way to do this by manipulating and passing the class or object itself? Something similar to <code>__call__(self, ...)</code>, or adding <code>@property</code> to the class itself or the <code>__init__(self, ...)</code> of the class?</p>
<p>I've tried the following naive approaches ...</p>
<pre><code>obj = Obj()
f(obj.x)
</code></pre>
<p>... and ...</p>
<pre><code>obj = Obj()
f(getattr(obj, 'x'))
</code></pre>
<p>Both print ...</p>
<pre><code>1
1
</code></pre>
<p>... which makes sense seeing as it is evaluated before it is passed to <code>f</code>. I also tried to extend <code>Obj</code>:</p>
<pre><code>class Obj:
    _x = 0
    @property
    def x(self):
        self._x += 1
        return self._x
    def y(self):
        return x
</code></pre>
<p>... and then go ...</p>
<pre><code>obj = Obj()
f(obj.y)
</code></pre>
<p>... but it produces ...</p>
<pre><code>&lt;bound method Obj.y of &lt;__main__.Obj object at 0x000002379E015748&gt;&gt;
&lt;bound method Obj.y of &lt;__main__.Obj object at 0x000002379E015748&gt;&gt;
</code></pre>
<p>This also makes sense seeing as we're simply getting the method itself and passing it to the <code>f</code> function.</p>
<p>Just a note: This isn't a real world problem/example. I'm simply trying to understand the principles and limits of python itself.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <em>property()</em> wrapper is a <a href="https://docs.python.org/3/glossary.html#term-descriptor" rel="nofollow noreferrer">descriptor</a>, meaning that it is only invoked by dotted access, like <code>a.x</code>, and not by plain variable access.</p>
<p>To trigger a method invocation or function call with just a variable reference, I think it would be necessary to <a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow noreferrer">exec()</a> code in a custom locals namespace:</p>
<pre><code>&gt;&gt;&gt; def add_ten(x):
        return x + 10

&gt;&gt;&gt; class NS(dict):
        def __getitem__(self, key):
            value = dict.__getitem__(self, key)
            if key == 'x':
                return add_ten(value)
            return value

&gt;&gt;&gt; exec('print(x + 2)', globals(), NS(x=5))
17
</code></pre>
<p>In the above example, just a reference to the variable <em>x</em> is enough to trigger a call to <em>add_ten()</em>.</p>
<p>This is likely more trouble than its worth, but as you say, you just wanted to see what is possible :-)</p>
</div>
<span class="comment-copy"><a href="https://www.python.org/download/releases/2.2.3/descrintro/" rel="nofollow noreferrer">python.org/download/releases/2.2.3/descrintro</a></span>
<span class="comment-copy">Properties are <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptors</a>. Note, what is actually happening is that when you access <code>obj.x</code>, is essentially <code>Obj.x.__get__(obj, Obj)</code></span>
<span class="comment-copy">Whenever we assign or retrieve any object attribute like <code>x</code> in your decorator class above, Python searches it in the object's <b>dict</b> dictionary. Try <code>obj.__dict__</code> to see it yourself, it will return <code>{'_x': 3}</code>. Also <code>type(obj.x)</code> will return an <code>int</code>, not a <code>method</code>.</span>
