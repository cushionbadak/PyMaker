<div class="post-text" itemprop="text">
<p>To do: </p>
<p>Convert <code>python</code> to <code>ythonpay</code> (i.e. pick up a first letter, put it in the end and add 'ay' and make sure the user has not entered in the word numbers or alphanumeric word )</p>
<pre><code>def check(word):    
      if word.isalnum() or word.isdigit():  
        print ("Enter valid word!")  
      else:  
        print ("Thank You for Entering a valid word!")  
        first_letter = word[0]  
        new_word = word.strip(word[0])  
        PygLatin = new_word+first_letter+"ay"  
        print (PygLatin) 

word= input("enter a word:").lower()  
result = check(word)  
</code></pre>
<p>result I got:</p>
<p>1&gt;&gt; <code>enter a word</code> -&gt; <code>python</code></p>
<p>2&gt;&gt; <code>Enter valid word!</code></p>
</div>
<div class="post-text" itemprop="text">
<p>There are two fundamental issues with your code (and one stylistic issue).</p>
<p>Usually you want functions to <strong><em>return</em></strong> something.  For example your intention is to take a word, move the first letter to the end of the word, and add "ay" ... in other words to render it in "<a href="https://en.wikipedia.org/wiki/Pig_Latin" rel="nofollow noreferrer">Pig Latin</a>."</p>
<p>But you're <strong><em>print</em></strong>-ing the results rather than <strong><em>return</em></strong>-ing them.  You might think that using <strong><em>print</em></strong> returns a value (in the sense that it "returned" something to your screen or terminal).  But that's not what "return" means in computer programming.  The Python <em>return</em> statement is how your function returns a result to the rest of the program following any particular invocation (or "call to") your function.</p>
<p>Here's the simplest function that would work:</p>
<pre><code>def pigify(word):
    return word[1:]+word[0].lower()+'ay'
</code></pre>
<p>... that will take a "slice" of the word from a one character offset into the string all the way to the end of the string.  That's what [1:] means ... it describes a range of characters, how far to the start of the range and then how far to go to get up to (but not including) the end.  Then it adds the first character (which is "zero characters" from the beginning of the string), converts that to lower case (which is harmless for all characters, and only affects capital letters) and then it adds the literal string "ay" ... and it takes all of that and returns it.</p>
<pre><code>pig_latin = pigify("Python")
print(pig_latin)
# ---&gt; prints "ythonpay"
</code></pre>
<p>The other issue with your code is that you're calling string methods in a confused way.  <em>word.alnum()</em> will return True only if all the characters are alphanumeric and <em>word.isdigit()</em> will return True only if all of the characters are numeric.  That's the same as just calling <em>word.isdigit()</em> since digits are a proper subset of the alphanumeric character set.  In other words the only strings that will pass your code will be those which contain no letters (or other characters); clearly not what you intended.</p>
<p>You probably would prefer to check that the string consists entirely of alphabetic characters:</p>
<pre><code>def pigify(word):
    if word.isalpha():
        return word[1:]+word[0].lower()+'ay'
    # or else? ....
</code></pre>
<p>This leaves you with the question of what you should do with an invalid argument (value passed to your function's "word" parameter by the caller).</p>
<p>You could print an error message.  But that's consider poor programming practice.  You could return some special value such as Python's <strong><em>None</em></strong> value; but then code that calls your function must either check the results every time, or results can cause some other error far removed from where your function was called (where this non-string value was returned).</p>
<p>You can also raise an exception:</p>
<pre><code>def pigify(word):
    if word.isalpha():
        return word[1:]+word[0].lower()+'ay'
    raise ValueError("Invalid input for pigify()")
</code></pre>
<p>... note that I don't need to explicitly spell out <em>else</em> in this case; the control flow only reaches that statement if I didn't return a value, only when it's an error.  Any other time the control flow returns to the calling code (the part of the program that called my <em>pigify()</em> function).</p>
<p>Another thing I could do is decide that <em>pigify()</em> simply returns anything that doesn't look like a "word" exactly as it was passed:</p>
<pre><code>def pigify(word):
    if word.isalpha():
        return word[1:]+word[0].lower()+'ay'
    else:
        return word
</code></pre>
<p>... here I could just <em>return word</em> without the <em>else:</em> as it did before with the <em>raise</em> statement.  But I personally think that looks wrong; so I've explicitly spelled out the <em>else:</em> clause purely for stylistic reasons.</p>
<p>Mostly you want your program to be composed of functions (or objects with methods) that work with manipulate the data, and then a smaller body of code (possibly functions or object and their methods) which then "render" the results of those manipulations.  Any time you're writing a function which manipulations or transforms data <strong>and</strong> writes those results to the screen or into a web page, or out to a file or database, you should pause and reconsider your design.  The transformative/manipulations and and computations might be re-useable while the code which writes results is typically quite specific.  So interleaving one with the other is usually a bad decision.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/stdtypes.html#str.isdigit" rel="nofollow noreferrer"><em>str.isdigit()</em></a> and <a href="https://docs.python.org/3/library/stdtypes.html#str.isalnum" rel="nofollow noreferrer"><em>str.isalnum()</em></a> methods only return true if <em>all</em> of the characters match the criteria.  Your test is written so that you want to detect whether <em>any</em> of the characters match the criteria:</p>
<pre><code>&gt;&gt;&gt; word = 'abc123'
&gt;&gt;&gt; word.isdigit()
False
&gt;&gt;&gt; any(map(str.isdigit, word))
True
</code></pre>
<p>So you can amend the code to start with something like this:</p>
<pre><code>def check(word):
    if not word.isalnum() or any(map(str.isdigit, word)):
        print ("Enter valid word!")
    else:
        print ("Thank You for Entering a valid word!")
    ...
</code></pre>
<p>FWIW, <a href="https://docs.python.org/3/library/stdtypes.html#str.isalpha" rel="nofollow noreferrer"><em>str.isalpha()</em></a> would be easier to use because digits are already excluded.</p>
</div>
<div class="post-text" itemprop="text">
<p>In your code, you have problem with <code>isalnum()</code> which returns true if string contains only alphabets, only numbers or contains both alphabets and numbers so you can try to match if string only contains alphabets and execute your code as follow:</p>
<pre><code>def check(word):
    if word.isalpha(): # process only if word contains only alphabets
        print("Thank You for Entering a valid word : {}!".format(word))
        print(word[1:] + word[0] + "ay") # slicing is better choice in your case
    else:
        print("Enter valid word!!!")

word = input("enter a word:")
result = check(word.lower())
</code></pre>
</div>
<span class="comment-copy">The answer depends on what you are trying to achieve. What is not a valid input?</span>
<span class="comment-copy">Another tip: You can create (in 1 row) the PygLatin variable like this: <b>PygLatin = "{}{}ay".format(word[1:],word[0])</b></span>
