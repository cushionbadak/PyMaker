<div class="post-text" itemprop="text">
<p><code>alist += [4]</code> and <code>alist = alist + [4]</code> are different as the first changes the reference of alist whereas the latter doesn't. I tried this below on IDLE by using <code>id()</code> and it seems like it is correct claim.</p>
<p>Code executed on IDLE (Python 3.6.1)</p>
<pre><code>&gt;&gt;&gt; alist = [1, 2, 3]
&gt;&gt;&gt; id(alist)
50683952
&gt;&gt;&gt; alist += [4]
&gt;&gt;&gt; id(alist)
50683952
&gt;&gt;&gt; alist = alist + [4]
&gt;&gt;&gt; id(alist)
50533080
</code></pre>
<p>Here is documentation for <code>id()</code> : <a href="https://docs.python.org/3/library/functions.html#id" rel="nofollow noreferrer">https://docs.python.org/3/library/functions.html#id</a></p>
<p>Is it possible to get reference to memory address programatically, identify whether the location has a list or a dictionary, read the contents and update the content using reference?</p>
<p><code>NOTE:</code> I found 2 relevant stackoverflow posts but I am not sure if they answer my question.</p>
<ul>
<li><a href="https://stackoverflow.com/questions/16408472/print-memory-address-of-python-variable">print memory address of Python variable</a></li>
<li><a href="https://stackoverflow.com/questions/121396/accessing-object-memory-address">Accessing object memory address</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You are trying to do something like in C, with a <strong>Dereference operator</strong>, such as * , you can read more about it in <a href="https://stackoverflow.com/questions/14224831/meaning-of-referencing-and-dereferencing">this question</a>.
 I'm sure that Python has no support for doing what you are trying to achieve, you have to change your mind paradigm, think different to get the results you want.</p>
<p>As you read, you can <strong>"get the memory address"</strong> from an object, but you want ever find a way (at least in python 2 - 3) to <strong>get the way back</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>If you need to check if a Python object is a dict or list, use <code>isinstance</code>. If you need to check if the unique identifier for an object (related to memory address, I believe), use <code>id</code>. If you need to check equality by value, use <code>==</code>.</p>
<p>There is no reason to do what you are doing right now: everything in Python is a reference-counted, garbage-collected pointer, you should not worry about how this is implemented. In addition to being prone to break version to version, it also is intentionally not exported in the Python API.</p>
<p>If you need the address of a <code>PyObject</code> in the C API, well it's already a pointer (and already done for you). You can use the C API to check if a pointer that is known to be a PyObject is a <code>dict</code>  or <code>list</code> accordingly.</p>
</div>
<span class="comment-copy">What <code>id</code> returns aren't memory locations. You cannot access those with python. In fact, you cannot access it in any language (even C, all you get are the logical addresses).</span>
<span class="comment-copy">ah ok, but the documentation says id() is the address of the object in memory.</span>
<span class="comment-copy">A misnomer, certainly. It is only an integer giving an <i>indication</i> of the object's reference, which vaguely resembles a memory reference.</span>
<span class="comment-copy">I also see no reason to do what you are doing. It seems like the exact definition of an anti-pattern in Python. If you need a unique identifier based on identity, use <code>id()</code>. If you need a by-value comparison, use <code>==</code>.</span>
<span class="comment-copy">The fact that <code>id</code> returns the memory address is an implementation detail of Cpython</span>
