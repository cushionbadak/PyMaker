<div class="post-text" itemprop="text">
<p>I have a set of 1000000 market-baskets containing 1-4 items each. I would like to calculate the frequency of each unique combination of items purchased. </p>
<p>The data is organized as such:</p>
<pre><code>[in] print(training_df.head(n=5))

[out]                     product_id
transaction_id                      
0000001                   [P06, P09]
0000002         [P01, P05, P06, P09]
0000003                   [P01, P06]
0000004                   [P01, P09]
0000005                   [P06, P09]
</code></pre>
<p>In this example [P06, P09] has a frequency of two and all other combinations have a frequency of one. I have created the following binary matrix and calculated the frequency of each individual item as such:</p>
<pre><code># Create a matrix for the transactions
from sklearn.preprocessing import MultiLabelBinarizer

product_ids = ['P{:02d}'.format(i+1) for i in range(10)]

mlb = MultiLabelBinarizer(classes = product_ids)
training_df1 = training_df.drop('product_id', 1).join(pd.DataFrame(mlb.fit_transform(training_df['product_id']),
                          columns=mlb.classes_,
                          index=training_df.index))

# Calculate the support count for each product (frequency)
train_product_support = {}
for column in training_df1.columns:
    train_product_support[column] = sum(training_df1[column]&gt;0)
</code></pre>
<p>How can I calculate the frequency of each unique combination of 1-4 items that are present in the data? </p>
</div>
<div class="post-text" itemprop="text">
<p>Well, since you cant use <code>df.groupby('product_id').count()</code>, this is the best I could come up with. We make a dict with the string representation of lists as keys, and count occurrences in it.</p>
<pre><code>counts = dict()
for i in df['product_id']:
    key = i.__repr__()
    if key in counts:
        counts[key] += 1
    else:
        counts[key] = 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Maybe:</p>
<pre><code>df['frozensets'] = df.apply(lambda row: frozenset(row.product_id),axis=1)
df['frozensets'].value_counts()
</code></pre>
<p>Creates a column of frozensets (hashable, and ignoring ordering) from product_ids, and then counts the number of each unique value.</p>
</div>
<span class="comment-copy">this is how I would solve this as well, but I would guess that order does not matter. therefore I would throw in <code>key = sorted(key)</code> to make any arrangement of the same items equivalent</span>
<span class="comment-copy"><code>defaultdict</code> is probably nicer to work with <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a></span>
<span class="comment-copy">Might also want a <code>frozenset</code> instead of a <code>str</code> <a href="https://docs.python.org/3/library/stdtypes.html#frozenset" rel="nofollow noreferrer">docs.python.org/3/library/stdtypes.html#frozenset</a></span>
<span class="comment-copy">I'll read up on <code>frozenset</code> and <code>defaultdict</code>, thanks. OP, if order doesn't matter, make sure to sort as pointed out by @JasonStein</span>
<span class="comment-copy">@JasonStein i tried your suggestion but get "TypeError: unhashable type: 'list'" I wanted to add it just to be sure, but I think that each row is already ordered (ie- "P01,P09" and NO "P09,P01"</span>
<span class="comment-copy">This sorts the data from greatest frequency to least frequency (of unique combinations). How can I further sort the unique combinations according to the number of items in the combination?</span>
