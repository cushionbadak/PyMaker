<div class="post-text" itemprop="text">
<pre><code>def flatten(t):
    list = []
    for i in t:
        if(type(i) != list and type(i) != tuple):
            list.append(i)
        else:
            list.extend(flatten(i))
    return list
</code></pre>
<p>Here is the function that I've written to flatten a list or a tuple that looks something like</p>
<pre><code>l = ((5, (1,2), [[1],[2]]))
</code></pre>
<p>when I do</p>
<pre><code>flatten(l)
</code></pre>
<p>I expected to get a list </p>
<pre><code>[5, 1, 2, 1, 2]
</code></pre>
<p>but I instead get</p>
<pre><code>[5, 1, 2, [[1], [2]]]
</code></pre>
<p>I am not really sure why this happens because</p>
<pre><code>    else:
        list.extend(flatten(i))
</code></pre>
<p>this part of the code will retrieve the int inside the third element of the tuple which is [[1],[2]] by calling it recursively. What am I missing here?</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>You've assigned the built-in <code>list</code> to a list instance in your function, so the type check no longer works properly for list objects.</p>
<p>You should use a different name for the accumulator list, say, <code>lst</code>:</p>
<pre><code>def flatten(t):
    lst = []
    for i in t:
        if type(i) != list and type(i) != tuple:
            lst.append(i)
        else:
            lst.extend(flatten(i))
    return lst
</code></pre>
<p>OTOH, you could do both checks at once using <code>isinstance</code> which also ensures that the objects you're running your checks against are actually types:</p>
<pre><code>...
if not isinstance(i, (list, tuple)):
    ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You masked the name <code>list</code>:</p>
<pre><code>list = []
...
    if(type(i) != list and ...
</code></pre>
<p><code>type(i)</code> is never going to be equal to <code>[]</code>.</p>
<p>Use a different name for your list:</p>
<pre><code>result = []
</code></pre>
<p>You also want to use <a href="https://docs.python.org/3/library/functions.html#isinstance" rel="nofollow noreferrer"><code>isinstance()</code></a> instead of <code>type()</code> with equality tests:</p>
<pre><code>def flatten(t):
    result = []
    for i in t:
        if not isinstance(i, (list, tuple)):
            result.append(i)
        else:
            result.extend(flatten(i))
    return list
</code></pre>
<p>this would have told you much earlier that you were not comparing with a type:</p>
<pre><code>&gt;&gt;&gt; list = []
&gt;&gt;&gt; isinstance(['foo'], (list, tuple))
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: isinstance() arg 2 must be a type or tuple of types
</code></pre>
<p>The exception is thrown because <code>[]</code> is not a type.</p>
<p>You could use a generator here to avoid the need to append or extend a new list object repeatedly. If you put the <code>isinstance()</code> type check <em>outside</em> the loop you can support non-sequences with the same function:</p>
<pre><code>def flatten(t):
    if not isinstance(t, (list, tuple)):
        yield t
        return
    for i in t:
        yield from flatten(i)

result = list(flatten(some_sequence_or_single_value))
</code></pre>
</div>
<span class="comment-copy"><code>list = []</code> is the problem. Try not to shadow built-in names/functions like <code>list</code>, etc. That only leads to trouble.</span>
<span class="comment-copy">It would be better to use <code>isinstance</code>. That way you also get an exception if you accidentally shadowed a name.</span>
<span class="comment-copy">@MSeifert Yup added, thanks.</span>
