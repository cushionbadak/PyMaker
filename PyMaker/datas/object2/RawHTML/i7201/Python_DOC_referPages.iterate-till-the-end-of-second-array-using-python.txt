<div class="post-text" itemprop="text">
<p>I have done something like this:  </p>
<pre><code>d = [('e', 0), ('f', 1), ('e', 0), ('f', 1)]
e = ['a']
d = [(n,j) for n,(i,j) in zip(e,d)]
d
[('a',0)]
</code></pre>
<p>I was just tryig to replace the equivalent tuple value with the array value, without changing the associated numbers. But the list only goes till the len of array <code>e</code> and not <code>d</code>. What I want to get as output is something like this:  </p>
<pre><code>d
[('a', 0), ('f', 1), ('e', 0), ('f', 1)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just add the unprocessed tail of <code>d</code> to the processed part:</p>
<pre><code>[(n,j) for n,(i,j) in zip(e,d)] + d[len(e):]
#[('a', 0), ('f', 1), ('e', 0), ('f', 1)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>itertools.zip_longest</code>:</p>
<pre><code>[(n or i, j) for n,(i,j) in itertools.zip_longest(e, d)]
</code></pre>
<p>Check the <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer">doc</a></p>
</div>
<div class="post-text" itemprop="text">
<p>If it's acceptable to mutate the original <code>d</code> list, I'd simply replace the first <code>d</code> tuples by iterating on <code>e</code>:</p>
<pre><code>d = [('e', 0), ('f', 1), ('e', 0), ('f', 1)]
e = ['a']

for i, new_letter in enumerate(e):
    d[i] = (new_letter, d[i][1])

print(d)
# [('a', 0), ('f', 1), ('e', 0), ('f', 1)]
</code></pre>
<p>Note that Python tuples are immutable. <code>d[i][0] = new_letter</code> would fail with the error:</p>
<blockquote>
<p>TypeError: 'tuple' object does not support item assignment</p>
</blockquote>
<p>The above code modifies the <code>d</code> list in place by replacing old tuples with new ones. It cannot modify the old tuples.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think the problem is the zip function. The documentation says that (zip) "Returns an iterator of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables. The iterator stops when the shortest input iterable is exhausted." </p>
<p><code>[(n,j) for n,(i,j) in zip(e,d)] + d[len(e):]</code> should do the trick</p>
</div>
<span class="comment-copy">Thank you sir this worked.</span>
<span class="comment-copy">you mean <code>zip_longest</code> right?</span>
<span class="comment-copy">@Jean-Fran√ßoisFabre, yes, i did not saw the py3 tag, thanks!</span>
<span class="comment-copy">you can drop <code>fillvalue=None</code> as this is default.</span>
<span class="comment-copy">Thank you for your answers. It is a good option for me.</span>
<span class="comment-copy">I tried that too. It gave me error saying: <code>'tuple' object does not support item assignment</code> Hence I rejected the idea</span>
<span class="comment-copy">seriously, my god. it worked too. I am still doubtful about myself what I made wrong, whereas I followed the similar process previously.</span>
<span class="comment-copy">Yes.. I got it. The problem is with the assignment of value that I did. You have assigned the value like this <code>d[i] = (new_letter, d[i][1])</code> where as I assigned like this <code>d[i][0] = new_letter</code></span>
<span class="comment-copy">Thank you for explanation. But let me edit your post for formatting properly.</span>
