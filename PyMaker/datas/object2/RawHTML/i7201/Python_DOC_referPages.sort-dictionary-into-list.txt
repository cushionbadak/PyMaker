<div class="post-text" itemprop="text">
<p>There are already a lot of questions about sorting dictionaries but I can't find the right answer to my question.</p>
<p>I have the dictionary  v:</p>
<pre><code>v = {3:4.0, 1:-2.0, 10:3.5, 0:1.0}
</code></pre>
<p>We have to turn the dictionary v into a sorted list.</p>
<pre><code>lijst(v) = [1.0, -2.0, 0.0, 4.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 3.5]
</code></pre>
<p>I have tried working with this code:</p>
<pre><code>def lijst(x):
    return sorted(x.items(), key=lambda x: x[1])
</code></pre>
<p>This is the list I receive:</p>
<pre><code>lijst(v) = [(1, -2.0), (0, 1.0), (10, 3.5), (3, 4.0)]
</code></pre>
<p>Does anyone know how to convert this into a list of values sorted in order of their key, with the missing values padded with zero?</p>
</div>
<div class="post-text" itemprop="text">
<p>Just use <a href="https://docs.python.org/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain.from_iterable</code></a> to flatten your result (the list of tuples):</p>
<pre><code>&gt;&gt;&gt; import itertools

&gt;&gt;&gt; list(itertools.chain.from_iterable([(1, -2.0), (0, 1.0), (10, 3.5), (3, 4.0)]))
[1, -2.0, 0, 1.0, 10, 3.5, 3, 4.0]
</code></pre>
<hr/>
<p>In case I misunderstood your original request and the dictionary represents a "sparse vector" (where the keys are the indices) you could simply populate a list containing only zeros:</p>
<pre><code>&gt;&gt;&gt; res = [0.0]*(max(v)+1)       # create a dummy list containing only zeros
&gt;&gt;&gt; for idx, val in v.items():   # populate the requested indices
...     res[idx] = val 
&gt;&gt;&gt; res
[1.0, -2.0, 0.0, 4.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 3.5]
</code></pre>
<p>Or if you have NumPy you could also avoid the <code>for</code>-loop:</p>
<pre><code>&gt;&gt;&gt; import numpy as np

&gt;&gt;&gt; arr = np.zeros(max(v)+1)
&gt;&gt;&gt; arr[list(v.keys())] = list(v.values())
&gt;&gt;&gt; arr
array([ 1. , -2. ,  0. ,  4. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  3.5])
</code></pre>
<p>The last approach relies on the fact that even though the order of <code>keys</code> and <code>values</code> is arbitrary they nevertheless directly correspond as long as there is no modification of the dictionary:</p>
<blockquote>
<p>Keys and values are iterated over in an arbitrary order which is non-random, varies across Python implementations, and depends on the dictionaryâ€™s history of insertions and deletions. <strong>If keys, values and items views are iterated over with no intervening modifications to the dictionary, the order of items will directly correspond.</strong></p>
</blockquote>
<p>Source <a href="https://docs.python.org/library/stdtypes.html#dictionary-view-objects" rel="nofollow noreferrer">4.10.1. Dictionary view objects</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can try this using <code>chain</code> from <code>itertools</code>:</p>
<pre><code>from itertools import chain

v = {3:4.0, 1:-2.0, 10:3.5, 0:1.0}

final_output = list(chain(*sorted(v.items(), key=lambda x: x[1])))
</code></pre>
<p>Output:</p>
<pre><code>[1, -2.0, 0, 1.0, 10, 3.5, 3, 4.0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way to concatenate the (key, value) pairs is by using <code>sum()</code> with an initial value:</p>
<pre><code>&gt;&gt;&gt; sum(sorted(v.items(), key=lambda x:x[1]), ())
(1, -2.0, 0, 1.0, 10, 3.5, 3, 4.0)
</code></pre>
<p>This returns a tuple. Pass it to <code>list()</code> if you really, really need a list.</p>
<p>P.S. As rightly pointed out by @MSeifert in the comments, this almost certainly has O(n**2) time complexity whereas <code>list(chain(...))</code> is likely amortized linear.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another option is to use the <code>yield from</code> syntax <a href="https://docs.python.org/3/whatsnew/3.3.html#pep-380-syntax-for-delegating-to-a-subgenerator" rel="nofollow noreferrer">introduced in Python 3.3</a>:</p>
<pre><code>&gt;&gt;&gt; lst = [(1, -2.0), (0, 1.0), (10, 3.5), (3, 4.0)]
&gt;&gt;&gt; list([(yield from tup) for tup in lst])
[1, -2.0, 0, 1.0, 10, 3.5, 3, 4.0]
&gt;&gt;&gt; 
</code></pre>
<p><strong>Caveat</strong>: Note that using <code>yield from</code> this way inside of list comprehension may not be "offical syntax" and some (including Guido) <a href="https://stackoverflow.com/questions/32139885/yield-in-list-comprehensions-and-generator-expressions">consider it a bug</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use list-comprehension to achieve what you want, for example:</p>
<p>if you want to keep <code>0.0</code> place holders for items that aren't available:</p>
<pre><code>[v.get(i, 0.0) for i in range(max(v.keys())+1)]
</code></pre>
<p>output:</p>
<pre><code>[1.0, -2.0, 0.0, 4.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 3.5]
</code></pre>
<p>If you don't want <code>0.0</code> place holders you can use:</p>
<pre><code>[v.get(i) for i in range(max(v.keys())+1) if v.get(i) is not None]
</code></pre>
<p>output:</p>
<pre><code>[1.0, -2.0, 4.0, 3.5]
</code></pre>
<p><strong>Explanation:</strong></p>
<p>when you use <code>range()</code> it will generate a sorted list so you don't have to worry about sorting, then it will try to get items from dictionary as per that list. In the first example if the key doesn't exist a <code>0.0</code> will be returned while in the 2nd example <code>None</code> will be returned and will be ignored because of the <code>if-statement</code> in the expression.</p>
<p><strong>EDIT:</strong></p>
<p>As Christian mentioned, you can change the 2nd option for more efficiency to:</p>
<pre><code>[v[i] for i in range(max(v.keys())+1) if i in v]
</code></pre>
<p>This will avoid calling <code>v.get(i)</code> twice.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is not strictly answering the question but rather trying to understand what you may be trying to achieve. If you are trying to implement sparse vectors, before spending time on a new implementation you may want to look into <a href="https://docs.scipy.org/doc/scipy/reference/sparse.html" rel="nofollow noreferrer">scipy.sparse</a>.</p>
<p>For example:</p>
<pre><code>from scipy.sparse import dok_matrix
v = {3:4.0, 1:-2.0, 10:3.5, 0:1.0}
m = dok_matrix((11,1))
m.update(v)
</code></pre>
<p>The advantage of sparse matrices is that (depending on the fraction of nonzero elements) they may take less memory and/or allow faster computations.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>v = {3:4.0, 1:-2.0, 10:3.5, 0:1.0}
print sorted(v.values())
</code></pre>
<p>Result</p>
<pre><code>[-2.0, 1.0, 3.5, 4.0]
</code></pre>
</div>
<span class="comment-copy">FYI, the reason you are getting answers that give very different results (i.e. some give the result <code>[1.0, -2.0, 0.0, 4.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 3.5]</code> and some give <code>[1, -2.0, 0, 1.0, 10, 3.5, 3, 4.0]</code>) is "flattening a list" means something <i>very</i> different from the answer you were actually looking for. You would have gotten more consistent answers if you changed the last question to "Does anyone know how to convert this into a list of values sorted in order of their key, with the missing values padded with zero?"</span>
<span class="comment-copy">@SethMMorton thank you, I've edited the question.</span>
<span class="comment-copy">Note that this will (probably) have <code>O(n**2)</code> runtime behavior.</span>
<span class="comment-copy">@MSeifert: Good point, thanks. I've added the caveat to the answer.</span>
<span class="comment-copy">Even though it's a fun alternative (+1): It's generally not considered pythonic to use a list comprehension for it's side-effects.</span>
<span class="comment-copy">@MSeifert  Really? I didn't think this was using a list comprehension for side-effects. My understanding is that <code>[(yield from tup) for tup in lst]</code> returns a generator expression. This is passed to <code>list()</code> which repeatedly calls <code>next</code> on the generator and <code>(yield from tup)</code> is returned each time. Because of that, it seemed like it was using the actually list comprehension and not just it's side-effects. Correct me if I'm wrong?</span>
<span class="comment-copy">I'm not exactly sure but the list-comprehension does in fact create a list of <code>None</code>s (even though you never see them because they are attached to the <code>StopIteration</code> in the end) and the outer <code>list()</code> just catches the yielded values. But I've <a href="https://stackoverflow.com/q/32139885/5393381">seen people calling it a bug</a> (but I'm not clear which part is the "buggy part") so I'm definitely not sure if it should be advocated as a syntax that's officially supported.</span>
<span class="comment-copy">@MSeifert Ah, I see. Thanks. I'll add a caveat to my answer concerning the nature of <code>yield from</code> in comprehensions.</span>
<span class="comment-copy">Note: This won't work in 3.8 and it is deprecated in 3.7</span>
<span class="comment-copy">Your second solution must make two calls to <code>dict.get</code> and thus is inefficient. You can instead simply test if <code>i</code> is in <code>v</code>'s keys and then add <code>v[i]</code> if so: <code>[v[i] for i in range(max(v.keys()) + 1) if i in v]</code>. This method is faster by about a factor of two.</span>
<span class="comment-copy">@ChristianDean Edited, thanks!</span>
