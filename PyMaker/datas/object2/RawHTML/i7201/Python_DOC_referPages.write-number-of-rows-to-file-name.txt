<div class="post-text" itemprop="text">
<p>I dont have any idea how to update my code below to the level that I can write the amount of changed row - in the CSV - to the file name. </p>
<p>I have did some stuff with count and row, but it is making any sense.  </p>
<p>Can somebody give me some tips</p>
<pre><code>import csv
import glob
import os

rows = []

for in_csv in glob.glob('C:/code/convert/Image/In/*.csv'):
    print in_csv

    with open(in_csv, 'rb') as f_input:
        reader = csv.reader(f_input)

        try:
            all = []
            row = next(reader)
            row.insert(0, 'l_panoramic')
            all.append(row)

            for k, row in enumerate(reader):
                all.append(['l_panoramic_{:06}'.format(k)] + row)

            name, ext = os.path.splitext(in_csv)

            with open("{}_{}{}".format(name, len(rows), ext), 'wb') as f_output:
                writer = csv.writer(f_output, delimiter = ';')
                writer.writerows(all)
                print  "  {} lines found".format(len(rows))
        except StopIteration as e:
            print "  No lines found"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This could be done using the <code>glob</code> library to create your list of CSV files. Use <a href="https://docs.python.org/3/library/os.path.html?highlight=splitext#os.path.splitext" rel="nofollow noreferrer"><code>splitext()</code></a> to take then existing filename and split it into a filename and extension, the number of rows can then be easily added using a <code>format()</code> statement as follows:</p>
<pre><code>import csv
import glob
import os

rows = []

for in_csv in glob.glob('a*.csv'):
    print in_csv

    with open(in_csv, 'rb') as f_input:
        reader = csv.reader(f_input)

        try:
            row = next(reader)
            row.insert(0, 'L_panoramic')
            rows.append(row)

            for k, row in enumerate(reader):
                rows.append(['l_panoramic_{:06}'.format(k)] + row)

            name, ext = os.path.splitext(in_csv)

            with open("{}_{}{}".format(name, len(rows), ext), 'wb') as f_output:        
                writer = csv.writer(f_output, delimiter = ';')
                writer.writerows(rows)
                print  "  {} lines found".format(len(rows))
        except StopIteration as e:
            print "  No lines found"
</code></pre>
<p>You were already creating a list of rows to be written, so once this list is complete, you will know how many rows there are. With this you can then open the output file with the number of rows added to the name, and write all the rows to it.</p>
</div>
<span class="comment-copy"><i>to the level that I can write the amount of changed row - in the CSV - to the file name</i>  What is the amount of the changed row?</span>
<span class="comment-copy">Do you want to write in the second file, the number of rows of the first?</span>
<span class="comment-copy">I want to write to the new file, in Out. But to the file name. So it takes the file name - 170728.csv (in the 'In' Folder) and in the 'Out' folder 170728_1915.csv (for having 1915 rows in the CSV. That means in my case 1915 panoramics.</span>
<span class="comment-copy">Hi, ok I think I am getting where you are going. But where do i leave my In and Output folder?</span>
<span class="comment-copy">I just simplified your logic for the sake of simplicity. It should just write the files back into the same folder at the moment. You could also use <code>os.path.join()</code> to prepend a different output folder (which is better than using string concatenation as it correctly handles file separators)</span>
<span class="comment-copy">Ok, i get that. There is a error coming up: TypeError: 'newline' is an invalid keyword argument for this function</span>
<span class="comment-copy">Which version of Python are you using?</span>
<span class="comment-copy">2.7 if I remove newline to:  with open(str(in_csv), 'rb',) as f_input: -  then It blocks on all.apend(row) - with StopIteration</span>
