<div class="post-text" itemprop="text">
<p>Suppose I have a <code>set</code> of file rename operations:</p>
<pre><code>renames={(current_1,new_1),(current_2,new_2),...}
</code></pre>
<p>It is guaranteed that the files <code>current_1,current_2,...</code> exist and that the new files <code>new_1,new_2,...</code> are unique.
All files are instances of <a href="https://docs.python.org/3/library/pathlib.html" rel="nofollow noreferrer"><code>pathlib.Path</code></a>.</p>
<p>They may be, however, files that are currently named as another file has to be renamed: i.e. it may exist an instance of <code>current_i==new_j</code>.</p>
<p>What would be an elegant way to implement the rename operations? Note that I can't just iterate over <code>renames</code> and rename each file, because I have to be prepared for a situation where the new name conflicts with the name of a file yet to be renamed.</p>
<p>I'm specifically looking for an implementation in Python3, and I would like renames to be kept a <code>set</code> in the form above. </p>
<p>A simple way is to temporarily prefix the files:</p>
<pre><code>temporal_prefix="a big string guaranteed not to appear in file names"
for current,new in renames:
    current.rename(current.with_name(temporal_prefix+current.name))
for current,new in renames:
    current.with_name(temporal_prefix+current.name).rename(new)
</code></pre>
<p>But this is not very elegant and it requires up to double the needed file operations. And finding a good prefix may be a problem in and of itself.
Is it possible to do this in one loop, using the minimum number of file operations?</p>
</div>
<div class="post-text" itemprop="text">
<p>There isn't much point trying to be too clever because renaming isn't an expensive operstion and the error you get when a file exists is pretty clear and can be trapped and dealt with. You can even test for the existence of each file first and avoid having to trap errors if you want but if you think most files won't have a problem it's probably a waste of time</p>
<p>Just use a data structure like a queue to hold your renames, start processing them from head to tail and upon finding a failure due to existing, put the rename back on the end of the queue so your loop will come around to it again later. Most renames will probably succeed first time, those that don't will probably succeed second time</p>
<p>I havent don't posted any example code because I've never touched python in my life (sorry). In pseudocode I would:</p>
<pre><code>While(renameQueue.hasItems)
  to_rename = renameQueue.dequeue()
  Try
    File.Rename(to_rename.oldName, to-rename.newName)
  OnError FILE_EXISTS
    new_name = system.getRandomTempFilename()
    File.Rename(to_rename.oldName, new_name)
    to_rename.oldName = new_name
    renameQueue.enqueue(to_rename)
  End Try
End While
</code></pre>
</div>
<span class="comment-copy">With persistence and hard work you will probably solve this.</span>
<span class="comment-copy">Wait... I've run into a problem with this. For something like [(A,B),(B,A)] where both A and B exist... the loop will never exit. In general this happens if there is a closed "chain" of renames.</span>
<span class="comment-copy">It's a good point; it looks like quite a narrow edge case in that it's restricted to pairs that seek to swap the names over or worse, cycle names around (ab,bc,ca). Perhaps extend the re-enqueue logic so that it renames the file right now to a temp random file name and put this new tempname-&gt; desired name pair on the queue</span>
<span class="comment-copy">Added pseudocode</span>
