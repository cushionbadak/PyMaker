<div class="post-text" itemprop="text">
<p>I have a large list of tuples e.g. <code>[ (1,2), (1,3), (1,4), (2,1), (2,3) ]</code> etc. I want to convert it to <code>[ (1, [1,2,3,4]), (2, [1,3] ) ]</code> efficiently. I am grouping tuples by the first element of each tuple i.e. <code>(1,2), (1,3), (1,4)</code> becomes <code>(1, [2,3,4])</code> (also see the Haskell version below). I doubt that this can be done in one pass? <strong>The input list is always ordered.</strong></p>
<p>In <code>python</code> in tried using <code>defaultdict</code> which I thought was the natural solution without reinventing the wheel. It works well but it does not preserve the order of keys. One solution is to use ordered <code>defaultdict</code> as <a href="https://stackoverflow.com/questions/6190331/can-i-do-an-ordered-default-dict-in-python">explained here</a>.</p>
<p>Anyway, I'd like to know the language independent and efficient solution to this problem. My current solution requires two passes and one call to <code>set( )</code> on a list.</p>
<p><strong>Update</strong></p>
<p>I am thinking of implementing following Haskell version:</p>
<pre><code>a = [ (1,2), (1,3), (1,4), (2,1), (2,3) ] 
b = groupBy (\ x y -&gt; fst x == fst y ) 
b 
[[(1,2),(1,3),(1,4)],[(2,1),(2,3)]]  
map (\x -&gt; (fst .head $ x, map snd x ) ) b 
[(1,[2,3,4]),(2,[1,3])]
</code></pre>
<h1>Performance of answers</h1>
<p>I implemented two answers (coldspeed and pm2ring). On moderate size lists (upto 10^4 elements)  PM2 ring solution is faster; at size 10^5, both takes same time, on larger list COLDSPEED starts winning. Below are the numbers (with python3).</p>
<p>First column is number of entries in list, second is time taken by <code>coldspeed</code> and third column has time taken by <code>pm2 ring</code> solutions. All times are in second.</p>
<pre><code>10 0.0001 0.0000
100 0.0001 0.0000
1000 0.0005 0.0001
10000 0.0044 0.0014
100000 0.0517 0.0452
1000000 0.5579 1.5249
</code></pre>
<p>Script is here <a href="http://github.com/dilawar/playground/raw/master/Python/so_group_tuple.py" rel="nofollow noreferrer">http://github.com/dilawar/playground/raw/master/Python/so_group_tuple.py</a></p>
<h3>With Ashwini optimization</h3>
<p><code>PM 2Ring</code> solution is even faster (roughly 3x - 5x) with Ashwini's suggestions. </p>
<pre><code>10 4.887580871582031e-05 1.2636184692382812e-05
100 0.00010132789611816406 2.0742416381835938e-05
1000 0.0005109310150146484 0.000110626220703125
10000 0.004467487335205078 0.0009067058563232422
100000 0.05056118965148926 0.017516136169433594
1000000 0.6100358963012695 0.26450490951538086
10000000 6.092756509780884 2.8253660202026367
</code></pre>
<h2>With PYPY</h2>
<p>Somewhat mixed results. Last column is ratio of column 2 and column 3.</p>
<pre><code>pypy so_group_tuple.py 
(10, [1.6927719116210938e-05, 3.409385681152344e-05], 0.4965034965034965)
(100, [4.601478576660156e-05, 8.296966552734375e-05], 0.5545977011494253)
(1000, [0.010258913040161133, 0.0019040107727050781], 5.388054094665665)
(10000, [0.0002448558807373047, 0.00021600723266601562], 1.1335540838852096)
(100000, [0.002658843994140625, 0.0018231868743896484], 1.45834967961292)
(1000000, [0.0833890438079834, 0.02979302406311035], 2.7989452709245284)
(10000000, [1.0556740760803223, 0.6789278984069824], 1.5549133841124023)
</code></pre>
<p><strong>I am going with <code>PM 2Ring</code> solution since it is much faster till list size 10^5</strong>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do this with <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="noreferrer"><code>itertools.groupby</code></a>, and using <code>zip</code> to rearrange the data from the collected groups:</p>
<pre><code>from itertools import groupby
from operator import itemgetter

a = [(1, 2), (1, 3), (1, 4), (2, 1), (2, 3)]
b = [(k, list(list(zip(*g))[1])) for k, g in groupby(a, itemgetter(0))]
print(b)
</code></pre>
<p><strong>output</strong></p>
<pre><code>[(1, [2, 3, 4]), (2, [1, 3])]
</code></pre>
<hr/>
<p>That list comp is a bit dense. Here's a variation using a traditional <code>for</code> loop that prints an intermediate result to make it a little easier to see what's going on.</p>
<pre><code>b = []
for k, g in groupby(a, itemgetter(0)):
    t = list(zip(*g))
    print(t)
    b.append(list(t[1]))

print('Output', b)
</code></pre>
<p><strong>output</strong></p>
<pre><code>[(1, 1, 1), (2, 3, 4)]
[(2, 2), (1, 3)]
Output [[2, 3, 4], [1, 3]]
</code></pre>
<hr/>
<p>As Ashwini Chaudhary mentions in the comments, nesting another list comp in there makes the code <em>much</em> more readable, it's probably also more efficient, since it avoids a couple of calls.</p>
<pre><code>b = [(k, [x for _, x in g]) for k, g in groupby(a, itemgetter(0))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You may use the <code>collections.OrderedDict</code> (<code>import collections</code> first):</p>
<pre><code>In [983]: o = collections.OrderedDict()

In [984]: for x in t:
     ...:     o.setdefault(x[0], []).append(x[1])
     ...:     
</code></pre>
<p>Now, convert <code>o.items()</code> to a list:</p>
<pre><code>In [985]: list(o.items())
Out[985]: [(1, [2, 3, 4]), (2, [1, 3])]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>May be if the input list is already ordered, it is not required to use any other ordering function or feature to again reorder the list. 
Below code will automatically give the output as you've shown.</p>
<pre><code>mylistarr = ((1, 2), (1, 3), (1, 4), (2, 1), (2, 3))
output = dict()
for tuple in mylistarr:
    if tuple[0] not in anotherlist:
        output[tuple[0]] = list()
        output[tuple[0]].append(tuple[0])
    output[tuple[0]].append(tuple[1])
print output
</code></pre>
<p>Output:
{1: [1, 2, 3, 4], 2: [2, 1, 3]}</p>
</div>
<span class="comment-copy">Please include your current solution, and clarify what the problem is - it's not clear to me how you're getting from your first to your second list.</span>
<span class="comment-copy"><a href="https://docs.python.org/2/library/collections.html#ordereddict-objects" rel="nofollow noreferrer">OrderedDict</a>?</span>
<span class="comment-copy">Is the input list always ordered like that? BTW, you have a typo in that list.</span>
<span class="comment-copy">Is your expected output actually <code>[ (1, [2,3,4]), (2, [1,3] ) ]</code>? I Don't know from where the <code>1</code> from the list in the first tuple comes from.</span>
<span class="comment-copy">Thanks for adding that timing info. You should take a look at <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer">timeit</a>, it's a little more accurate (and convenient) than doing it manually with the <code>time</code> module.</span>
<span class="comment-copy">Good 'ol LC is easier to read: <code>[x for _, x in g]</code>.</span>
<span class="comment-copy">@AshwiniChaudhary Indeed it is! Thanks for that.</span>
<span class="comment-copy">@AshwiniChaudhary You suggestions have made this implementation faster. I've added some benchmark.</span>
<span class="comment-copy">Though this is easy to read, it is somewhat slower than <code>PM 2Ring</code> solutions on list of size upto 10^5 - 10^6. I've added some benchmark in question body.</span>
<span class="comment-copy">@Dilawar Performance isn't the only consideration. If you want speed use C ;) You should go with what is the most simplest, clearest, easiest to read and understand. Understandably PM 2Ring's solution works and is nice to look at, but I would want to <i>actually</i> know what my code is doing. In the end it's up to you. Cheers.</span>
<span class="comment-copy"><code>anotherlist = dict()</code> is bad naming.</span>
