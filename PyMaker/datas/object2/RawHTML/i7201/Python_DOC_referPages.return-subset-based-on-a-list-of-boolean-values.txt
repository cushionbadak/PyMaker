<div class="post-text" itemprop="text">
<p>I'm trying to slice a dataframe based on list of values, how would I go about this?</p>
<p>Say I have a list, l, and it looks like: <code>[0,1,0,0,1,1,0,0,0,1]</code></p>
<p>I want to return all rows in a dataframe, df, based on if the value in the list is a 1. In this example, I would include rows where index is 1, 4, 5, and 9. Any easy way to do this? Apologize if this is an easy question but I am still getting used to dataframes.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use masking here:</p>
<pre><code>df[np.array([0,1,0,0,1,1,0,0,0,1],dtype=bool)]
</code></pre>
<p>So we construct a boolean array with true and false. Every place where the array is True is a row we select.</p>
<p>Mind that we do <em>not</em> filter inplace. In order to retrieve the result, you have to assign the result to an (optionally different) variable:</p>
<pre><code>df2 = df[np.array([0,1,0,0,1,1,0,0,0,1],dtype=bool)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Convert the list to a boolean array and then use boolean indexing:</p>
<pre><code>df = pd.DataFrame(np.random.randint(10, size=(10, 3)))

df[np.array(lst).astype(bool)]
Out: 
   0  1  2
1  8  6  3
4  2  7  3
5  7  2  3
9  1  3  4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Setup</strong><br/>
Borrowed @ayhan's setup  </p>
<pre><code>df = pd.DataFrame(np.random.randint(10, size=(10, 3)))
</code></pre>
<p><strong>Without <code>numpy</code></strong><br/>
not the fastest, but it holds its own and is definitely the shortest.</p>
<pre><code>df[list(map(bool, lst))]

   0  1  2
1  3  5  6
4  6  3  2
5  5  7  6
9  0  0  1
</code></pre>
<hr/>
<p><strong>Timing</strong> </p>
<pre><code>results.div(results.min(1), 0).round(2).pipe(lambda d: d.assign(Best=d.idxmin(1)))

         ayh   wvo   pir   mxu   wen Best
N                                        
1       1.53  1.00  1.02  4.95  2.61  wvo
3       1.06  1.00  1.04  5.46  2.84  wvo
10      1.00  1.00  1.00  4.30  2.73  ayh
30      1.00  1.05  1.24  4.06  3.76  ayh
100     1.16  1.00  1.19  3.90  3.53  wvo
300     1.29  1.00  1.32  2.50  2.38  wvo
1000    1.54  1.00  2.19  2.24  3.85  wvo
3000    1.39  1.00  2.17  1.81  4.55  wvo
10000   1.22  1.00  2.21  1.35  4.36  wvo
30000   1.19  1.00  2.26  1.39  5.36  wvo
100000  1.19  1.00  2.19  1.31  4.82  wvo
</code></pre>
<hr/>
<pre><code>fig, (a1, a2) = plt.subplots(2, 1, figsize=(6, 6))
results.plot(loglog=True, lw=3, ax=a1)
results.div(results.min(1), 0).round(2).plot.bar(logy=True, ax=a2)
fig.tight_layout()
</code></pre>
<p><a href="https://i.stack.imgur.com/jScmh.png" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/jScmh.png"/></a></p>
<hr/>
<p><strong>Testing Code</strong> </p>
<pre><code>ayh = lambda d, l: d[np.array(l).astype(bool)]
wvo = lambda d, l: d[np.array(l, dtype=bool)]
pir = lambda d, l: d[list(map(bool, l))]
wen = lambda d, l: d.loc[[i for i, x in enumerate(l) if x == 1], :]

def mxu(d, l):
    a = np.array(l)
    return d.query('@a != 0')

results = pd.DataFrame(
    index=pd.Index([1, 3, 10, 30, 100, 300,
                    1000, 3000, 10000, 30000, 100000], name='N'),
    columns='ayh wvo pir mxu wen'.split(),
    dtype=float
)

for i in results.index:
    d = pd.concat([df] * i, ignore_index=True)
    l = lst * i
    for j in results.columns:
        stmt = '{}(d, l)'.format(j)
        setp = 'from __main__ import d, l, {}'.format(j)
        results.set_value(i, j, timeit(stmt, setp, number=10))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>yet another "creative" approach:</p>
<pre><code>In [181]: a = np.array(lst)

In [182]: df.query("index * @a &gt; 0")
Out[182]:
   0  1  2
1  1  5  5
4  0  2  0
5  4  9  9
9  2  2  5
</code></pre>
<p>or <a href="https://stackoverflow.com/questions/45494649/pandas-dataframe-return-subset-based-on-a-list-of-boolean-values/45494910?noredirect=1#comment77951484_45494910">much better variant from @ayhan</a>:</p>
<pre><code>In [183]: df.query("@a != 0")
Out[183]:
   0  1  2
1  1  5  5
4  0  2  0
5  4  9  9
9  2  2  5
</code></pre>
<p>PS i've also borrowed @Ayhan's setup</p>
</div>
<div class="post-text" itemprop="text">
<p>Or maybe find the position of 1 in your <code>list</code> and slice from the <code>Dataframe</code></p>
<pre><code>df.loc[[i for i,x in enumerate(lst) if x == 1],:]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Selecting using a list of Booleans is something <a href="https://docs.python.org/3/library/itertools.html#itertools.compress" rel="nofollow noreferrer"><code>itertools.compress</code></a> does well.</p>
<p>Given</p>
<pre><code>&gt;&gt;&gt; df = pd.DataFrame(np.random.randint(10, size=(10, 2)))
&gt;&gt;&gt; selectors = [0, 1, 0, 0, 1, 1, 0, 0, 0, 1]
</code></pre>
<p>Code</p>
<pre><code>&gt;&gt;&gt; selected_idxs = list(itertools.compress(df.index, selectors))   # [1, 4, 5, 9]
&gt;&gt;&gt; df.iloc[selected_idxs, :]
   0  1
1  1  9
4  3  4
5  4  1
9  8  9
</code></pre>
</div>
<span class="comment-copy"><a href="https://stackoverflow.com/help/someone-answers">Here</a> is something to consider when you have received valuable answers.</span>
<span class="comment-copy">Could you please testing <code>df.loc[[i for i,x in enumerate(lst) if x == 1],:]</code>, it should be the slowest one , but just curious how slow it will be ...</span>
<span class="comment-copy">@Wen I've updated</span>
<span class="comment-copy">Thank you ~Mine is the worst for no doubt T_T</span>
<span class="comment-copy">Wouldn't <code>df.query("@a &gt; 0")</code> suffice?</span>
<span class="comment-copy">@ayhan, yes, indeed, thank you! That looks much cleaner.</span>
