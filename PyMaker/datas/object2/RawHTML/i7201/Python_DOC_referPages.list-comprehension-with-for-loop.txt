<div class="post-text" itemprop="text">
<p>How can I double <strong>the first <em>n</em> odd numbers</strong> in a list using list comprehension?</p>
<p>Here is my solution:</p>
<pre><code>&gt;&gt;&gt; n = 2
&gt;&gt;&gt; lst = [1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; lst = [num for num in lst if num % 2 == 1] + [num for num in lst if num % 2 == 0]
&gt;&gt;&gt; lst = [num * 2 for num in lst[:n]] + lst[n:]
&gt;&gt;&gt; print(lst)
[2, 6, 5, 2, 4, 6]
</code></pre>
<p>You can see that I can't keep the same order of <code>lst</code> anymore...</p>
<p>More example:</p>
<pre><code>n = 2
lst = [2, 2, 2, 2, 1, 2, 3]
output: lst = [2, 2, 2, 2, 2, 2, 6]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Name things with specificity, and the logic is exposed. </p>
<blockquote>
<p>How can I double the first n odd numbers in a list using list comprehension?</p>
</blockquote>
<p>We have odd numbers: <code>v for v in l if n%2</code>. This is a filter. 
We can take the first <code>n</code> of them using <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow noreferrer"><code>islice(odds, n)</code></a>. We call this a slice, other languages might call it "take". And doubling them is a per item operation, so a map. Join these operations and we arrive at one answer to your question:</p>
<pre><code>[v*2 for v in islice((v for v in l if n%2), n)]
</code></pre>
<p>However, that isn't what you wanted. The issue is specificity; your question doesn't say what to do with other items than the first <code>n</code> odd ones, so I have just ignored them. </p>
<p>So what do do if we want a replication of all the items your question did not mention? This means we have three groups: early odds, late odds, and evens, all processed distinctly. The latter may be mixed in arbitrarily, while we know late odds come after early odds. It's impractical to split them in individual streams, as you've shown, since that doesn't preserve their relative order. </p>
<p>I'll apply a few more itertools functions to solve this problem. </p>
<pre><code>from itertools import repeat, chain
oddfactors = chain(repeat(2, n), repeat(1))
outlist = [v*next(oddfactors) if v%2 else v
           for v in inlist]
</code></pre>
<p>Note that the iterator <code>oddfactors</code> is read for each odd item, not even items, because the if-else expression doesn't evaluate the expression if it's not being used. The iterator is consumed and you need to create another to perform the work again. </p>
<p>It is possible to place the <code>oddfactors</code> iterator's creation (and entire scope) within the list comprehension, but the first way I can think of is incredibly ugly:</p>
<pre><code>from itertools import repeat, chain
outlist = [v*next(oddfactors) if v%2 else v
           for v,oddfactors in zip(
            inlist, 
            repeat(chain(repeat(2, n), repeat(1)))
           )]
</code></pre>
<p>The trick here is to ensure we create the chained iterator only once, then feed it into each mapping operation. This exercise sure didn't help readability or performance. Using a nested comprehension would make it a bit cleaner but there's still only the one iterator, so it's a misleading hack.</p>
<pre><code>outlist = [v*next(oddfactors) if v%2 else v
           for oddfactors in [chain(repeat(2, n), repeat(1))]
           for v in inlist]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h3>Solution for the original requirement to *“double the first <code>n</code> numbers in a list if it’s odd”:</h3>
<p>Since you do not want to <em>remove</em> any items from your original list, you cannot use the filter of the list comprehension syntax (the <code>if</code> after the <code>for</code>). So what you need to do instead is simply transform the item you are putting into the target list.</p>
<p>Your logic is something like this for an element <code>x</code> at index <code>i</code>:</p>
<pre><code>def transform(x, i, n):
    if i &lt; n:
        if x % 2 == 1:
            return x * 2
    return x
</code></pre>
<p>So you can use that exact function and use it in your list comprehension:</p>
<pre><code>&gt;&gt;&gt; n = 2
&gt;&gt;&gt; lst = [1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; [transform(x, i, n) for i, x in enumerate(lst)]
[2, 2, 3, 4, 5, 6]
</code></pre>
<p>And of course, you can put this also inline into the list comprehension:</p>
<pre><code>&gt;&gt;&gt; [x * 2 if i &lt; n and x % 2 == 1 else x for i, x in enumerate(lst)]
[2, 2, 3, 4, 5, 6]
</code></pre>
<hr/>
<h3>First <code>n</code> odd numbers:</h3>
<p>If you want to find the first <em>n odd numbers</em>, you cannot solve this like this. In order to solve this, you need to actually <em>remember</em> how many odd numbers you encountered before while going through the list. This means that you need to have some kind of “memory”. Such a thing is not a good fit for a list comprehension since list comprehensions are supposed to transform one item at a time without having side effects.</p>
<p>So instead, you would simply do this the straightforward way:</p>
<pre><code>n = 2
lst = [2, 2, 2, 2, 1, 2, 3]
result = []
for x in lst:
   if x % 2 == 1 and n &gt; 0:
       result.append(x * 2)
       n -= 1
   else:
       result.append(x)
print(result) # [2, 2, 2, 2, 2, 2, 6]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For this to work, you'll need to keep count of odd numbers that you've already seen. For example, you could instantiate the <code>itertools.count</code> generator and advance it each time the odd number is encountered:</p>
<pre><code>from itertools import count
def f(l, n):
    odd = count()
    return [x * 2 if x % 2 and next(odd) &lt; n else x for x in l]
</code></pre>
<pre><code>&gt;&gt;&gt; f([1, 2, 3, 4, 5, 6], 2)
[2, 2, 6, 4, 5, 6]
&gt;&gt;&gt; f([2, 2, 2, 2, 1, 2, 3], 2)
[2, 2, 2, 2, 2, 2, 6]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the ternary operator.</p>
<pre><code>lst = [1, 2, 3, 4, 5, 6]
lst = [x * 2 if x % 2 == 1 and i &lt;= n else x for i, x in enumerate(lst)]
</code></pre>
<p>or </p>
<pre><code>lst[:n] = [x * 2 if x % 2 == 1 else x for x in lst[:n]]
</code></pre>
<p>Update: Under the new requirement of <strong>doubling first <code>n</code> odd integers</strong>:</p>
<pre><code>lst = [1, 2, 3, 4, 5, 6]

class Doubler:
    def __init__(self, n):
        self.n = n
    def proc(self, x):
        if self.n &gt; 0 and x % 2:
            self.n -= 1
            return 2 * x
        return x

# Double first 2 odd elements
d = Doubler(n=2)
res = [d.proc(x) for x in lst]
print(res)
# [2, 2, 6, 4, 5, 6]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about this?</p>
<pre><code>n = 2
lst = [1, 2, 3, 4, 5, 6]

for i in range(n):
   lst[i]= lst[i]*2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>[num if num%2 else 2*num for num in list]. num if a if b else c will return a if b is true, otherwise c.</p>
</div>
<span class="comment-copy">Could you explain why the "second example" isn't <code>[2, 2, 2, 2, 2, 2, 6]</code>. You wanted to double the first <code>n</code> (in this case 2) odd numbers.</span>
<span class="comment-copy">Edited, it was a typo.</span>
<span class="comment-copy">But if <code>n = 2</code> and <code>lst = [2, 2, 2, 2, 1, 2, 3]</code> then your solution is wrong. Maybe I should add some more declaration?</span>
<span class="comment-copy">So you want to double the first <code>n</code> odd numbers, instead of looking at just the first <code>n</code> numbers in the list? That’s totally not what you were saying in your question though. Regardless of that, with the help you got so far , did you try to solve it yourself?</span>
<span class="comment-copy">No, I didn't...</span>
<span class="comment-copy">This solution doesn't use a list comprehension.</span>
