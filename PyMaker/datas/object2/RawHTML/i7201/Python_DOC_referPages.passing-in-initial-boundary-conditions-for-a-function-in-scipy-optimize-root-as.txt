<div class="post-text" itemprop="text">
<p>I am trying to solve a non linear system. Here is the code for a toy problem.</p>
<pre><code>import collections
import numpy as np
import scipy

def flat(x):
    ''' flattens a shallow list
        ex: [[1,2,3],[4,5],[6]] ----&gt; flattens to [1,2,3,4,5]
        numpy flatten does not work on lists.
    '''
    if isinstance(x, collections.Iterable):
        return [a for i in x for a in flat(i)]
    else:
        return [x]


def func(X):
    '''setups the matrix dynamic equation and the set of constraints
    '''
    A = [[0,1,0,1],[2,1,0,4],[1,4,1,3],[3, 2, 1,0]]
    A1 = [[1,0,1,-1], [0,-1,2,1],[1,2,0,1],[1,2,0,-2]]
    x = X[:-1]
    alpha = X[-1]
    x0 = [1,2,3,4]
    y = x - x0
    # x[0] = 0.5
    # x[3] = 0.3
    dyneqn = np.dot(A,y) + alpha * np.dot(A1,x)
    cons = (1/2.0)*np.dot(x.T,np.dot(A1,x)) + np.dot([-1,1,2,-3], x) + 0.5
    return flat([dyneqn, cons])

sol = scipy.optimize.root(func,[1,-1,2,0,-1])
sol.x
</code></pre>
<p><strong>Problem Statement</strong></p>
<p>The argument <code>X</code> of the objective function <code>f</code> has five unknowns that we are solving for. I want to set the first parameter, i.e., <code>X[0]=0.5</code>and the fourth  parameter i.e., <code>X[3] = 0.3</code> and solve for the remaining <code>3 unknowns</code>. Let us assume for simplicity that such a solution exists and my initial guess is somehow a good one.</p>
<p><strong>Attempt</strong>:</p>
<p>I know I should probably pass these arguments to the <code>args=()</code> argument in <code>scipy.optimize.root</code>. I tried setting</p>
<pre><code>args = (X[0]=0.5, X[3]=0.3)
init_guess = [0.5,-1,2,0.3,-1]
scipy.optimize.root(func,init_guess, args=args)
</code></pre>
<p>This is obviously wrong. </p>
<p><strong>Question?</strong> How can I fix this?.</p>
<p><em>Note: I added the flat function so that the code is self contained. It has nothing to do with this question</em>.</p>
</div>
<div class="post-text" itemprop="text">
<p>From your example I reconstruct that you want to solve for the second and third component of some vector <code>x</code> as well as the parameter <code>alpha</code>. With the <code>args</code> keyword of <a href="https://docs.scipy.org/doc/scipy-0.18.1/reference/generated/scipy.optimize.root.html" rel="nofollow noreferrer"><code>scipy.optmize.root</code></a> that would look something like</p>
<pre><code>def func(x_solve, x0, x3):
    #x_solve.size should be 3 
    x = np.empty(4)
    x[0], x[3] = x0, x3
    x[1:3] = x_solve[:2]
    alpha = x_solve[2]
    ...

scipy.optimize.root(func, [-1,2,-1], args=(.5, .3))
</code></pre>
<p>As Azat and kazemakase pointed out, I'm also not sure if you actually want to use <code>root</code>, but the usage of <a href="https://docs.scipy.org/doc/scipy-0.18.1/reference/generated/scipy.optimize.root.html" rel="nofollow noreferrer">scipy.optimize.minimize</a> is pretty much the same.</p>
<p><strong>Edit:</strong> It should be possible to have a flexible set of fixed variables by using a dictionary as an additional argument which specifies those:</p>
<pre><code>def func(x_solve, fixed):
    x = x_solve[:-1] # last value is alpha
    for idx in fixed.keys(): # overwrite fixed entries
        x[idx] = fixed[idx]
    alpha = x_solve[-1]

# fixed variables, key is the index
fixed_vars = {0:.5, 3:.3}

# find roots
scipy.optimize.root(func, 
                    [.5, -1, 2, .3, -1], 
                    args=(fixed_vars,))
</code></pre>
<p>That way, when the optimizer in <code>root</code> numerically evaluates the Jacobian it obtains zero for the fixed variables and should therefore leave those invariant. However, that might lead to complications in the convergence of the algorithm.</p>
</div>
<div class="post-text" itemprop="text">
<p>Typically with <code>scipy</code> functions like root, minimize, etc</p>
<pre><code>root(func, x0, args=(a, b, c, ...))
</code></pre>
<p>requires a <code>func</code> that accepts:</p>
<pre><code>func(x0, a, b, c, ...)
    # do something those arguments
    return value
</code></pre>
<p><code>x0</code> is the value that <code>root</code> varies, <code>a,b,c</code> are <code>args</code> value that are passed unchanged to your function.  Depending of the problem <code>x0</code> may be an array.  The nature of the <code>args</code> is entirely up to you.</p>
</div>
<span class="comment-copy">what do you expect from <code>(X[0]=0.5, X[3]=0.3)</code>?</span>
<span class="comment-copy">if i understood correctly your <code>flat</code> function is the same as <code>list</code> from result of <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer"><code>itertools.chain</code></a></span>
<span class="comment-copy">I just want to concatenate <code>dyneqn</code>and <code>cons</code> as a single array. <code>flat</code> just does that.</span>
<span class="comment-copy">There is probably a nicer way to write this problem without the flat function. But that is not my question.</span>
<span class="comment-copy">Are you sure <code>root</code> is the function you should use? It solves a system of equations exactly, which means the number of equations must be equal to the number of free parameters. From the problem statement it seems like <code>minimize</code> might be more appropriate. hpaulj's answer applies to that too.</span>
<span class="comment-copy">Is there anyway I can do this without re-arranging the arguments of the function?. The reason is I will have to do the same calculation for different permutations of <code>setting parameters to constants</code>. For example in a second case I will have to set <code>x0=0.5</code> and solve for the rest of the parameters x1, x2, x3, alpha</span>
<span class="comment-copy">I added a solution that would <i>probably</i> work. It's not very nice though.</span>
<span class="comment-copy">I will try this out. I will actually provide the analytical Jacobian for the solver just to make its life easier and of course to make it faster. In my experience providing the Jacobian just makes everything work out nicely.</span>
<span class="comment-copy">Yes, thats usually a good Idea. Just mind that you adapt it similarly such that it returns zero for all partial derivatives of variables in the <code>fixed</code> dictionary.</span>
<span class="comment-copy">I have a question to ask regarding your suggestion to use minimize. I can only use minimize on a scaler valued function, correct?. But my function is vector valued. <code>f(X) = 0</code> means zero vector on the right hand side. How can I use minimize on a vector valued function?. It doesn't make sense to me. Can you clarify?</span>
<span class="comment-copy">I was trying to do what  this answer <a href="https://stackoverflow.com/a/37202169/6431877">stackoverflow.com/a/37202169/6431877</a> suggested. So If I understand you correctly I will have to re-write my function to make this work?. Can you clarify a little more?</span>
<span class="comment-copy">In the link, the distinction between <code>x</code> and <code>k</code> is pretty clear.  <code>k</code> is fixed, <code>x</code> varies.  You split <code>X</code> into <code>x</code> and <code>alpha</code>.  Are you searching for a value of <code>x</code> that returns a 0 value?</span>
<span class="comment-copy">Well I am searching for an <code>X</code> value for which <code>func(X) = 0</code> but some values of <code>X</code> are fixed. specifically the first and the second to last variables.</span>
<span class="comment-copy"><code>X = [x0, x1, x2, x3, alpha]</code> and <code>x0</code> and <code>x3</code> does not vary and I want to solve <code>f(X) = 0</code> for the rest.</span>
<span class="comment-copy">So isn't my answer below doing what you want? It does keep <code>x0</code> and <code>x3</code> constant. What do you mean by <code>f(x) =0</code>? Your <code>func</code> is a vector valued function. Do you expect all entries to be zero?</span>
