<div class="post-text" itemprop="text">
<p>I can do this:</p>
<pre><code>class Blah2:
    atttr = 5
    aa = atttr


ob = Blah2
print(ob.aa)
</code></pre>
<p><a href="http://ideone.com/pKxMc2" rel="nofollow noreferrer">http://ideone.com/pKxMc2</a></p>
<p>So I assumed I could as well do this:</p>
<pre><code>class Blah1:
    atttr = 5


class Blah2(Blah1):
    aa = atttr


ob = Blah2
print(ob.aa)
</code></pre>
<p>Nope I can't: <a href="http://ideone.com/6HS1MO" rel="nofollow noreferrer">http://ideone.com/6HS1MO</a></p>
<p>SPits out the following error:</p>
<pre><code>Traceback (most recent call last):
  File "./prog.py", line 5, in &lt;module&gt;
  File "./prog.py", line 6, in Blah2
NameError: name 'atttr' is not defined
</code></pre>
<p>Why doesn't this work and how to make it working?</p>
</div>
<div class="post-text" itemprop="text">
<p>The class block scope only exists temporarily during class definition.  After class definition, you would have to access that attribute via the class object, i.e. <code>Blah1.atttr</code>.  </p>
<p>This is documented under the <a href="https://docs.python.org/3/reference/executionmodel.html" rel="nofollow noreferrer">execution model</a> section.</p>
<blockquote>
<p>Class definition blocks and arguments to exec() and eval() are special in the context of name resolution. A class definition is an executable statement that may use and define names. These references follow the normal rules for name resolution with an exception that unbound local variables are looked up in the global namespace. The namespace of the class definition becomes the attribute dictionary of the class. <strong>The scope of names defined in a class block is limited to the class block</strong>; it does not extend to the code blocks of methods â€“ this includes comprehensions and generator expressions since they are implemented using a function scope.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Your problem is fixed like this: </p>
<pre><code>class Blah1:
    atttr = 5


class Blah2(Blah1):
    aa = BLah1.atttr
</code></pre>
<p>However, as pointed out in the comments, this is a weird thing to do. Now you have this: </p>
<pre><code>&gt;&gt;&gt; ob = Blah2()
&gt;&gt;&gt; assert ob.aa == ob.atttr
True
</code></pre>
<p>EDIT: As stated in wim's answer, the cause of this is how scoping works inside of a class definition. When you do this: </p>
<pre><code>class C():
    a = 1
</code></pre>
<p>It is pretty much equivalent to this: </p>
<pre><code>C = type('C', (), {}) # &lt;--- dynamic class creation function
C.a = 1
</code></pre>
<p>As you can see, in order to access that <code>a</code> anywhere outside of the class definition body, you have to refer to it using the class (or an instance of the class): <code>C.a</code> or <code>c().a</code>. But note this "gotcha": </p>
<pre><code>class C():
    a = 1

c = C()
c.a = 2
print(C.a) #  prints 1!!!
</code></pre>
<p>It prints 1 because after the second line above, there is now both a <code>c</code> attribute <code>a</code> and a <code>C</code> attribute <code>a</code>, and they are two different objects: </p>
<pre><code>&gt;&gt;&gt; vars(c)
{'a': 2}
&gt;&gt;&gt; vars(C)
{'a': 1}
</code></pre>
<p>If you want <code>c.a</code> to not override <code>C.a</code>, you need to learn about properties and descriptors. Maybe start <a href="https://stackoverflow.com/a/27568860/2437514">here</a>. </p>
</div>
<span class="comment-copy">You should probably start by creating instances of those classes, and not access the attributes on the classes themselves.</span>
<span class="comment-copy">Why do you need to do this? You are aware that <code>Blah2</code> and <code>Blah1</code> are <i>classes</i>, not <i>instances</i>, yes? And instances inherit their parent's fields, not classes</span>
