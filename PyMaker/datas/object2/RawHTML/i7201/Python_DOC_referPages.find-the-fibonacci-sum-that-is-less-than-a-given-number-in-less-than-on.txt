<div class="post-text" itemprop="text">
<p>I am trying to work on a problem and part of the solution is to find the sum of finbonacci numbers that is less than an input number. Now the upper limit of the input number is 10**9. I have reduced the problem to the following O(n) solution, I was wondering if there is a more efficient solution. </p>
<pre><code>b=[1, 2, 4, 7, 12, 20, 33, 54, 88, 143, 232, 376, 609, 986, 1596, 2583, 4180, 6764, 
10945, 17710, 28656, 46367, 75024, 121392, 196417, 317810, 514228, 832039, 
1346268, 2178308, 3524577, 5702886, 9227464, 14930351, 24157816, 
39088168, 63245985, 102334154, 165580140, 267914295, 433494436, 701408732, 1134903169, 1836311902]

def test_lambda(a):
    list_numbers= filter(lambda x: x&lt;=a, b)
    return len(list_numbers)
</code></pre>
<p>As you can see I am comparing the values of the list b with the given input and returning the elements that are less than the given number.</p>
<p>b is the list of sum of fibonaccis numbers upto that index, so the 1st number is 1, the sum is 1, the 2nd is 1 the sum is 2, the 3rd 2 the sum 4...</p>
</div>
<div class="post-text" itemprop="text">
<p>You can simply use <em>binary search</em> (for instance using the <a href="https://docs.python.org/3/library/bisect.html#bisect.bisect_right" rel="nofollow noreferrer"><code>bisect_right</code></a> function) for that:</p>
<pre><code>from bisect import bisect_right

def test_lambda(a):
    return bisect_right(list_numbers,a)
</code></pre>
<p>Or if you want the sum that is less than the input number, you can use:</p>
<pre><code>from bisect import bisect_right

def less_than(a):
    return a[bisect_right(list_numbers,a)-1]
</code></pre>
<p>This works since the list is pre-calculated and is strictly incrementing. So that means that it is an ordered list. Binary search works in <em>O(log n)</em> so searching is done efficiently. Furthermore I would add <code>0</code> to the list (at the first position), such that queries with <code>0</code> as input are resolved as well:</p>
<pre><code>from bisect import bisect_right

b=[0, 1, 2, 4, 7, 12, 20, 33, 54, 88, 143, 232, 376, 609, 986, 1596, 2583, 
   4180, 6764, 10945, 17710, 28656, 46367, 75024, 121392, 196417, 317810,
   514228, 832039, 1346268, 2178308, 3524577, 5702886, 9227464, 14930351,
   24157816, 39088168, 63245985, 102334154, 165580140, 267914295, 433494436,
   701408732, 1134903169, 1836311902
  ]

def less_than(a):
    return a[bisect_right(list_numbers,a)-1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This can be done in O(logn)*O(logn) using matrix exponentiation please refer to the link below <br/>
<a href="https://math.stackexchange.com/questions/1102452/modulus-of-sum-of-sequence-of-fibonacci-numbers">https://math.stackexchange.com/questions/1102452/modulus-of-sum-of-sequence-of-fibonacci-numbers</a> <br/>
incase you don't have enough memory to store all 10^9 sums you can use this O(logn) to calculate the i'th sum, if you want the sum less than equal to the given input you can just binary search for i</p>
</div>
<span class="comment-copy">Do you know there is a solution of less than O(n), or you just want one?</span>
<span class="comment-copy">Simply use binary search...</span>
<span class="comment-copy">I don't know if there is a solution that is less than O(n)...</span>
<span class="comment-copy">@fazkan The only thing I can think of is to use the formula for the n'th element: <a href="https://www.math.hmc.edu/funfacts/ffiles/10002.4-5.shtml" rel="nofollow noreferrer">math.hmc.edu/funfacts/ffiles/10002.4-5.shtml</a></span>
<span class="comment-copy">The sum of the first n Fibonacci numbers is fib(n+2)-1. As for efficiently finding the nearest Fibonacci number to a given number, please see <a href="https://stackoverflow.com/a/40683466/4014959">stackoverflow.com/a/40683466/4014959</a></span>
<span class="comment-copy">what is the efficiency of bisect_right, I read somewhere that its not log(n)...</span>
<span class="comment-copy">@fazkan: it is definitely <i>O(log n)</i> for searching (definitely given the elements are all different), as is documented in the <code>insort_left</code> function.</span>
