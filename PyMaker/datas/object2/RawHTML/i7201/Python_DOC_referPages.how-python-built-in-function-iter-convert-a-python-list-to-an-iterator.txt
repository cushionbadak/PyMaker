<div class="post-text" itemprop="text">
<p>I have read my materials, which tell that a python iterator must have both <code>__iter__</code> and <code>__next__</code> method, but an iterable just needs <code>__iter__</code>. I check a list and find it has no <code>__next__</code> method. When using <code>iter()</code> on it, it will become an iterator. This means that <code>iter()</code> will add a <code>__next__</code> method to a list to convert it to an iterator? If yes, how does this happen? </p>
</div>
<div class="post-text" itemprop="text">
<p>No. <code>iter</code> <em>returns an iterator</em>, it does not convert the list into an iterator. It doesn't modify the list at all, and certainly, the list does  not get a <code>__next__</code> method.</p>
<pre><code>&gt;&gt;&gt; x = [1,2]
&gt;&gt;&gt; it = iter(x)
&gt;&gt;&gt; it
&lt;list_iterator object at 0x101c021d0&gt;
&gt;&gt;&gt; x.__next__
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'list' object has no attribute '__next__'
&gt;&gt;&gt;
</code></pre>
<p>Lists are <em>iterables</em>, not <em>iterators</em>. They implement a <code>__iter__</code> method, thus they are iterable:</p>
<pre><code>&gt;&gt;&gt; x.__iter__
&lt;method-wrapper '__iter__' of list object at 0x101bcf248&gt;
</code></pre>
<p>But not <code>__next__</code>, thus they are not iterators:</p>
<pre><code>&gt;&gt;&gt; next(x)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'list' object is not an iterator
</code></pre>
<p>Iterators themselves are iterable, by definition, since they implement <code>__iter__</code> as well. Consider:</p>
<pre><code>&gt;&gt;&gt; x = [1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; it = iter(x)
&gt;&gt;&gt; it
&lt;list_iterator object at 0x101c02358&gt;
&gt;&gt;&gt; it.__iter__
&lt;method-wrapper '__iter__' of list_iterator object at 0x101c02358&gt;
</code></pre>
<p><strike>Most</strike> iterators <strong>should</strong> simply return themselves when you use <code>iter</code> on them:</p>
<pre><code>&gt;&gt;&gt; it2 = iter(it)
&gt;&gt;&gt; it, it2
(&lt;list_iterator object at 0x101c02358&gt;, &lt;list_iterator object at 0x101c02358&gt;)
&gt;&gt;&gt; it is it2
True
&gt;&gt;&gt;
</code></pre>
<p>Indeed, this is a <a href="https://docs.python.org/3/glossary.html#term-iterator" rel="nofollow noreferrer">requirement of the iterator protocol</a>: </p>
<blockquote>
<p>"Iterators are required to have an <code>__iter__()</code> method that returns the
  iterator object itself so every iterator is also iterable and may be
  used in most places where other iterables are accepted."</p>
</blockquote>
<p>Note, again, they <em>are the same iterator</em>:</p>
<pre><code>&gt;&gt;&gt; next(it)
1
&gt;&gt;&gt; next(it2)
2
&gt;&gt;&gt; next(it)
3
&gt;&gt;&gt; next(it)
4
&gt;&gt;&gt; next(it2)
5
&gt;&gt;&gt; list(it)
[6, 7, 8, 9]
&gt;&gt;&gt; next(it2)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration
</code></pre>
<p>So an <em>iterator</em> implements <code>__iter__</code> and <code>__next__</code>, an <em>iterable</em> just means that it implements <code>__iter__</code>. What is <em>returned</em> by <code>__iter__</code> is an iterator, so that must implement <code>__next__</code>.</p>
</div>
<span class="comment-copy">Nice summary: <a href="http://nvie.com/posts/iterators-vs-generators/" rel="nofollow noreferrer">nvie.com/posts/iterators-vs-generators</a></span>
<span class="comment-copy">crucially, the <code>__next__</code> method is <i>on the thing</i> that <code>iter</code> returns</span>
<span class="comment-copy">Note: <i>All</i> iterators must have a <code>__iter__</code> implementation that returns the iterator object itself, not just "most". This is <a href="https://docs.python.org/3/glossary.html#term-iterator" rel="nofollow noreferrer">a requirement of the iterator protocol</a>: "Iterators are required to have an __iter__() method that returns the iterator object itself so every iterator is also iterable and may be used in most places where other iterables are accepted." Other parts of Python rely on this; one canonical and efficient duck-typing approach to test if something is an iterator is to test <code>obj is iter(someobj)</code>.</span>
<span class="comment-copy">@ShadowRanger yes, you are absolutely correct. Of course, there is nothing stopping you from breaking this, but I certainly wouldn't suggest doing that. I will update to reflect this.</span>
