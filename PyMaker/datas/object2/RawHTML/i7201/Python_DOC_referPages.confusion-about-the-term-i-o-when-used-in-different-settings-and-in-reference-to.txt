<div class="post-text" itemprop="text">
<p>It seems when I google what I\O is,  I get hits that show it stands for "Input" and "Output".
I see blogs on Python titled, "Python File I\O --Part 19, Advanced File Input and Output "
If I go to the Python docs  and search for input/output:
<a href="https://docs.python.org/3/tutorial/inputoutput.html" rel="nofollow noreferrer">https://docs.python.org/3/tutorial/inputoutput.html</a>
The examples are limited to print statements and reading/writing files.</p>
<p>I see no examples of web-services or networking as Input/Output in the "Input and Output" section of the Python docs, despite
seeing  the term I/O used often with these concepts. Is I/O containing the same meaning when referring to web-services and networks as well? </p>
<p>I've been doing a lot of reading on the GIL and multi-threading recently and
the term <code>I/O bound</code> has popped up in addition to <code>I/O</code>.</p>
<p>I/O bound seems to refer to a state where there is a lot of CPU idleness, 
due to the slowness of getting data to the CPU. Multi-threading seems to be used often with Webservices and Networking because I'm assuming there is a lot of 
CPU idleness, i.e I/O bound heavy tasks because you are always for waiting a user-input to act upon.</p>
<p>Now are the <code>print</code> statements as well read/write files also considered I/O bound tasks?</p>
<p>Finally, the term <code>I/O</code> has also popped up in the Python Docs regarding GIL:</p>
<p>"The GIL is controversial because it prevents multithreaded CPython programs 
from taking full advantage of multiprocessor systems in certain situations.    Note that potentially blocking or long-running operations,, <strong>such as I/O</strong> image processing, and NumPy number crunching, happen outside the GIL. Therefore it is only in multithreaded programs that spend a lot of time inside the GIL, interpreting CPython bytecode, that the GIL becomes a bottleneck."</p>
<p>So the reference to I/O in this text, says that all I/O tasks bypass the GIL --
so does that mean <code>print, reading and write to files, webservices, networking</code> etc -- all these types of tasks bypass the GIL and are can be exploited by multithreading? </p>
<p>Thank you. </p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, I/O stands for Input/Output. This is from the point of view of your program. Input can come from many different sources, such as a keyboard, mouse, or network connection. Similarly, Output can be sent to many different sources. Most programming languages define input and output operations which can work with a variety of sources and destinations. This makes is much easier to write code because we just receive and send data without worrying about the details of where it comes from or goes to.</p>
</div>
<span class="comment-copy">Operations in the core interpreter or extension modules that may block or otherwise not need the interpreter for a relatively long time will typically release the GIL beforehand to allow another thread to access the interpreter. When the operation completes the thread has to wait to reacquire the GIL before it can resume executing Python bytecode.</span>
<span class="comment-copy">Thank you. How exactly is this determined? Is it the interpreter or OS that determines which operations will take a long time and which won't? Is this hard-coded in the interpreter or a behavior of the OS?</span>
<span class="comment-copy">The GIL is a lock that's managed within the Python process. Other than the fact that basic primitives (e.g. semaphores) depend on the OS, the high-level behavior is a function of the implementation of CPython. The points that release the GIL are almost always hard-coded. For example, a function will use the <code>Py_BEGIN_ALLOW_THREADS</code> macro to release the GIL before making a system call to <a href="https://github.com/python/cpython/blob/v3.6.2/Python/fileutils.c#L1191" rel="nofollow noreferrer">read from a file</a>.</span>
