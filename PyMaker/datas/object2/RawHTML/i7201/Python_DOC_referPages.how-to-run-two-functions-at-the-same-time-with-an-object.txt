<div class="post-text" itemprop="text">
<p>So I found an example that shows</p>
<pre><code>import threading
from threading import Thread

def func1():
    print 'Working'

def func2():
    print 'Working'

if __name__ == '__main__':
    Thread(target = func1).start()
    Thread(target = func2).start()
</code></pre>
<p>and this works.</p>
<p>But how does it work when I usually have an object with the function.
Here are 2 functions I normally use.</p>
<pre><code>statusbar()
copyfrom(servername.strip())
</code></pre>
<p>How do I add servername.strip() to the below?</p>
<pre><code>Thread(target = statusbar).start()
Thread(target = copyfrom).start()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>target</code> should be a function, so define your <em>own</em> function that does what you want:</p>
<pre><code>def doSomething():
  copyfrom(servername.strip())
</code></pre>
<p>and hand it to your <code>Thread</code>.</p>
<pre><code>Thread(target=doSomething).start()
</code></pre>
<p>If you want to do it in a single line, you could use an anonymous function:</p>
<pre><code>Thread(target=lambda: copyfrom(servername.strip())).start()
</code></pre>
<hr/>
<p>As <a href="https://stackoverflow.com/users/4909087/c%E1%B4%8F%CA%9F%E1%B4%85s%E1%B4%98%E1%B4%87%E1%B4%87%E1%B4%85">cᴏʟᴅsᴘᴇᴇᴅ</a> mentions in his answer, you can also specify arguments for the callback as a tuple:</p>
<pre><code>Thread(target=copyfrom, args=(servername.strip(), )).start()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can pass arguments to <a href="https://docs.python.org/3/library/threading.html#threading.Thread" rel="nofollow noreferrer"><code>threading.Thread</code></a>, so this should work:</p>
<pre><code>Thread(target=statusbar).start()
Thread(target=copyfrom, args=(servername.strip(), )).start()
</code></pre>
<p>This is, in my opinion, the simplest option.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use either lambda or local functions:</p>
<pre><code>Thread(target = lambda: copyfrom(servername.strip())).start()
</code></pre>
<p>or</p>
<pre><code>def thread_func():
  copyfrom(servername.strip())
Thread(target = thread_func).start()
</code></pre>
<p>In python you can define function in function (local functions, lambda is also kind of this), and inside functions can access names from it's parent function. Even after execution left original function 
Keep in mind, that this will prolong lifetime of objects in parent's function. So:</p>
<pre><code>def foo():
  s = '... very long string ...'
  def substr(a, b):
    return s[a:b]
  return substr
a = foo()
</code></pre>
<p>Now you can use <code>a</code> to access <code>s</code>. But as long as <code>a</code> exists, <code>s</code> will also, as <code>a</code> keeps reference to <code>substr</code>, which keeps reference to <code>s</code>.</p>
</div>
<span class="comment-copy">Pinging @Prox to see if this has been resolved.</span>
<span class="comment-copy">Good answer for this particular use case.</span>
