<div class="post-text" itemprop="text">
<p>This is my code:</p>
<pre><code>class myclass:
    def __init__(self):
        self.value = 5

    def __getattr__(self, attrname):
        if attrname == 'value':
            return 10

X = myclass()
print X.value
</code></pre>
<p>I suppose the output value should be <code>10</code> (<code>__getattr__</code> modifies returned value). However output is <code>5</code>.</p>
<p>If I remove initialization of value:</p>
<pre><code>class myclass:

    def __getattr__(self, attrname):
        if attrname == 'value':
            return 10

X = myclass()
print X.value
</code></pre>
<p>It works as expected (returns <code>10</code>).
Why?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>__getattr__</code> is only used for <strong>missing</strong> attributes. See the <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattr__" rel="nofollow noreferrer">documentation</a>:</p>
<blockquote>
<p>Called when an attribute lookup has not found the attribute in the usual places (i.e. it is not an instance attribute nor is it found in the class tree for self).</p>
</blockquote>
<p>In your first example, <code>'value'</code> is not a missing attribute; it was set in <code>__init__</code>. Note that it doesn't matter where it was set, only that it exists.</p>
<p>If you must intercept <strong>all</strong> attribute access, you need to implement the <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattribute__" rel="nofollow noreferrer"><code>__getattribute__</code> hook</a> instead.</p>
</div>
<span class="comment-copy">But <b>setattr</b> works for missing and not-missing attributes, right?</span>
<span class="comment-copy">@HashDoe: yes, because setting an attribute would <i>add</i> that attribute if it was missing.</span>
<span class="comment-copy">@HashDoe Also in 3.X for builtin accesses only <code>__getattr__</code> and <code>__getattribute__</code> are not intercepted this matters for proxy classes when they proxy other objects and expect their operator overloading methods to be called.</span>
<span class="comment-copy">@direprobs: you mean special methods perhaps? Yes, <code>__getattribute__</code> will be bypassed for some of those, but that's not specific to Python 3, that's the same in Python 2. See <a href="https://docs.python.org/3/reference/datamodel.html#special-method-lookup" rel="nofollow noreferrer"><i>Special method lookup</i></a>.</span>
<span class="comment-copy">@MartijnPieters Yes, that's what I meant. Yup, you're right it's not just in 3.X but for new-style classes in both lines 2.X &amp; 3.X.</span>
