<div class="post-text" itemprop="text">
<p>Say I'm having a following code in C</p>
<pre><code>union u_type
{
    uint32_t data;
    uint8_t  chunk[4];
} 32bitsdata;

32bitsdata.chunk[0] = some number;
32bitsdata.chunk[1] = some number;
32bitsdata.chunk[2] = some number;
32bitsdata.chunk[3] = some number;

printf("Data in 32 bits: %d\n", 32bitsdata.data);
</code></pre>
<p>How could I do similar thing in python?</p>
<p>I'm trying to read a binary file (byte by byte) - already got it working, and combining every 3 bytes into one int. Heard struct would do the trick, but I'm not really sure how.</p>
<p>Best,</p>
<p>Henry</p>
</div>
<div class="post-text" itemprop="text">
<p>What about <a href="https://docs.python.org/3.6/library/ctypes.html#ctypes.c_uint" rel="noreferrer">ctypes</a>?   </p>
<pre class="lang-python prettyprint-override"><code>from ctypes import (
        Union, Array, 
        c_uint8, c_uint32, 
        cdll, CDLL
) 

class uint8_array(Array):
    _type_ = c_uint8
    _length_ = 4

class u_type(Union):
    _fields_ = ("data", c_uint32), ("chunk", uint8_array)

# load printf function from Dynamic Linked Libary libc.so.6 (I'm use linux)
libc = CDLL(cdll.LoadLibrary('libc.so.6')._name)
printf = libc.printf

if __name__ == "__main__":
    # initialize union
    _32bitsdata = u_type()
    # set values to chunk
    _32bitsdata.chunk[:] = (1, 2, 3, 4)
    # and print it
    printf(b"Data in 32 bits: %d\n", _32bitsdata.data)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is what you would do. First, let's create the raw bytes we need, I'll cheat and use <code>numpy</code>:</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; arr = np.array((8,4,2,4,8), dtype=np.uint32)
&gt;&gt;&gt; arr
array([8, 4, 2, 4, 8], dtype=uint32)
&gt;&gt;&gt; raw_bytes = arr.tobytes()
&gt;&gt;&gt; raw_bytes
b'\x08\x00\x00\x00\x04\x00\x00\x00\x02\x00\x00\x00\x04\x00\x00\x00\x08\x00\x00\x00'
</code></pre>
<p>These could have easily been read from a file. Now, using the <code>struct</code> module is trivial. We use the unsigned int format character <code>'I'</code>:</p>
<pre><code>&gt;&gt;&gt; import struct
&gt;&gt;&gt; list(struct.iter_unpack('I', raw_bytes))
[(8,), (4,), (2,), (4,), (8,)]
</code></pre>
<p>Note, each time we iterate we get back a tuple, since our struct has one member, it is a list of singleton tuples. But this is trivial to get into a flat python list:</p>
<pre><code>&gt;&gt;&gt; [t[0] for t in struct.iter_unpack('I', raw_bytes)]
[8, 4, 2, 4, 8]
</code></pre>
<p>Another alternative is to read them into an <code>array.array</code>:</p>
<pre><code>&gt;&gt;&gt; import array
&gt;&gt;&gt; my_array = array.array('I', raw_bytes)
&gt;&gt;&gt; my_array
array('I', [8, 4, 2, 4, 8])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You asked about C union, but if your objective is to group 3 bytes into an int, you could use Python <a href="https://docs.python.org/3/library/struct.html#struct.unpack" rel="nofollow noreferrer">struct.unpack</a> instead.</p>
<pre><code>import struct

chunk = bytearray()
chunk.append(0x00)   # some number
chunk.append(0xc0)   # some number
chunk.append(0xff)   # some number
chunk.append(0xee)   # some number

# Convert to a 32-bit unsigned int.
# You didn't specify the byte-order, so I'm using big-endian.
# If you want little-endian instead, replace the '&gt;' symbol by '&lt;'.
data = struct.unpack('&gt;I', chunk)[0]  # unpack returns a tupple, but we only need the first value

print(hex(data))  # the terminal prints 0xc0ffee
</code></pre>
</div>
<span class="comment-copy">You can just store four numbers inside four variables, Python doesn't require types...</span>
<span class="comment-copy">That's not the point I'm asking. Union is convenient in this way because it could convert all 4 of the 8 bits to one 32 bits. I'm doing a project that needs to parse the data into bytes, so that's why I need this similar function in python.</span>
<span class="comment-copy">But because there's no types, there's therefore no need for a union in Python. I mean, you can create your own class for this, but I don't see any reason why.</span>
<span class="comment-copy">There's no use for a <code>union</code> in Python.  In Python, <i>data</i> has a type, but <i>variables</i> don't.  This means that the variable-type / data-type mismatch that <code>union</code> is supposed to work around simply can't happen.</span>
<span class="comment-copy">@shjnlee it's part of the standard library. It should be easy to grasp if you have a C background. Check out the <a href="https://docs.python.org/3/library/struct.html" rel="nofollow noreferrer">docs</a>. You probably want to look at <code>struct.iter_unpack</code></span>
<span class="comment-copy">Very nice. I figured there was something in ctypes for an exact translation.</span>
