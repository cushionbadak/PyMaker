<div class="post-text" itemprop="text">
<p>In thread, I have a loop that reads input from the user console.  The main thread is busy with a Tkinter mainloop().  How do I terminate this program?</p>
<blockquote>
<pre><code>while True:
    ln = sys.stdin.readline()
    try:
        ln = ln[:-1]  # Remove LF from line
        if len(ln)==0: continue  # Ignore blank lines
        ...and so on
</code></pre>
<p>The main thead calls startGUI() which contains a tk.mainloop() call.  When I press the X close button on the window (this is Linux), Tkinter closes the window and mainloop() returns.  I then try to close stdin hoping that sys.stdin will close and cause sys.stdin.readline() will terminate with a nice EOF allowing my stdinLoop thread terminate.</p>
<pre><code># Start up the GUI window
startGUI()  # Doesn't return until GUI window is closed, tk.mainloop is called here
#
# Wait for stdinLoop thread to finish
sys.stdin.close()  # Hopefully cause stdinTh to close
print("waiting for stdinTh to join")
stdinTh.join()
print("joined stdinTh")
</code></pre>
</blockquote>
<p>The sys.stdin.realine() never returns after the sys.stdin.close().  (The stdinTh.join() was there to synchronize the closing.)</p>
<p>I think Python readline() is doing something <em>clever</em> (in something called NetCommand) that doesn't return cleanly when stdin is closed.</p>
<p>Does Python think it is <em>evil</em> to have both a Tkinter GUI and use stdin interactively?  </p>
<p>I tried using sys.stdin.read(1), but is seems buffer up a line and returns the whole line -- rather than reading one byte/char as I thought a read(1) would.</p>
</div>
<div class="post-text" itemprop="text">
<h2>Make the thread a daemon thread that will be terminated automatically</h2>
<p>Start the stdin-reading thread with <a href="https://docs.python.org/3/library/threading.html#threading.Thread.daemon" rel="nofollow noreferrer"><code>daemon=True</code></a>. It will then automatically terminate when the main thread terminates. You don’t need to do anything with stdin explicitly. (You also don’t get a chance to clean up in the stdin-reading thread.)  For example:</p>
<blockquote>
<pre><code>stdinTh = threading.Thread(target=stdinLoop, name="stdinTh")
stdinTh.daemon = True
stdinTh.start()
</code></pre>
</blockquote>
<h2>If you can’t or don’t want to use a daemon thread</h2>
<p><code>sys.stdin.readline()</code> eventually boils down to a blocking <a href="http://man7.org/linux/man-pages/man2/read.2.html" rel="nofollow noreferrer"><code>read()</code></a> system call.</p>
<p><code>read()</code> on <code>stdin</code> does not return when <code>stdin</code> is closed. I’m not sure why you expect it to. This is not Python-specific behavior. At least on my Linux/glibc system, the same happens in C.</p>
<p>You can break out of a blocking <code>read()</code> by sending a signal (such as <code>SIGUSR1</code>) to the blocked thread. In C, you could use <a href="http://man7.org/linux/man-pages/man3/pthread_kill.3.html" rel="nofollow noreferrer"><code>pthread_kill()</code></a> for that. Python does not provide an easy way to do this, and for good reason; but if you insist, you can <a href="https://stackoverflow.com/a/16146048/200445">do it with <code>ctypes</code></a>.</p>
<p>But a cleaner/safer approach is to use <a href="https://docs.python.org/3/library/select.html#select.select" rel="nofollow noreferrer"><code>select.select</code></a> to read from <em>either</em> stdin <em>or</em> an inter-thread communication pipe, whichever is available first:</p>
<pre><code>import os, select, sys, threading, time

def printer_loop(quit_pipe):
    while True:
        sys.stdout.write("Say something: ")
        sys.stdout.flush()
        (readable, _, _) = select.select([sys.stdin, quit_pipe], [], [])
        if quit_pipe in readable:
            print("Our time is up!")
            break
        # This is not exactly right, because `sys.stdin` could become
        # ready for reading before there's a newline on there, so
        # `readline` could still block. Ideally you would do some
        # custom buffering here.
        line = sys.stdin.readline()
        print("You said: '%s' - well said!" % line.strip())

def main():
    print("Starting thread...")
    (pipe_read, pipe_write) = os.pipe()
    thread = threading.Thread(target=printer_loop, args=(pipe_read,))
    thread.start()
    time.sleep(5)
    print("Interrupting thread...")
    os.write(pipe_write, b'.')
    print("Joining thread...")
    thread.join()
    print("All done!...")

if __name__ == '__main__':
    main()
</code></pre>
<p>This is not portable to Windows, where you can’t <code>select()</code> on <code>sys.stdin</code>.</p>
</div>
<span class="comment-copy">Python doesn't think it's evil, but it's certainly not how GUI programs are designed to run. Depending on how you start the GUI there may not even be a stdin for it to read from. What are you trying to accomplish with both a GUI and reading from stdin?</span>
<span class="comment-copy">@BryanOakley, true, not conventional, I use the console for typing 'debugging' commands to the app.  The GUI is the real thing the (end) user would interact with.</span>
<span class="comment-copy">I thought read() would terminate when the pipe is closed because it would see an EOF,  right?  (I'll try the deamon=true and the select.select.)  It is odd that read(1) returns a complete line where read(1) on a 'file' object (stdin is supposed to be a file object isn't it?) is supposed to return 1 byte/char.</span>
<span class="comment-copy">@Ribo “I thought read() would terminate when the pipe is closed because it would see an EOF” — as I said, this doesn’t happen for me even in C</span>
<span class="comment-copy">@Ribo “read(1) returns a complete line” — I’m not sure why; can’t reproduce; probably best to ask a separate question</span>
