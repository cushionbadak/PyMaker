<div class="post-text" itemprop="text">
<pre><code>async def run_check(shell_command):
    p = await asyncio.create_subprocess_shell(shell_command,
                    stdin=PIPE, stdout=PIPE, stderr=STDOUT)
    fut = p.communicate()
    try:
        pcap_run = await asyncio.wait_for(fut, timeout=5)
    except asyncio.TimeoutError:
        p.kill()
        await p.communicate()

def get_coros(pcap_list):
    for pcap_loc in pcap_list:
        for pcap_check in get_pcap_executables():
            tmp_coro = (run_check('{args}'
            .format(e=sys.executable, args=args)))
            if tmp_coro != False:
                coros.append(tmp_coro)
     return coros

async def main():
    pcap_list_gen = print_dir_cointent()
    for pcap_list in pcap_list_gen:
        p_coros = get_coros(pcap_list)
        for f in asyncio.as_completed(p_coros):
            res = await f

loop = asyncio.get_event_loop()
loop.run_until_complete(main())
loop.close()
</code></pre>
<p><strong>pcap_list_gen</strong> is a generator of PCAP lists which contain multile lists.
I get <em>[OS: Error: To many open file]</em> if I pass all pcaps in a single list, so decided to group them into list of smaller size and process one at a time.</p>
<p>Each <strong>pcap_list</strong> is a list of multiple PCAPS.
I want the next iteration of the loop to only start once the first iteration is finished.</p>
<pre><code>for pcap_list in pcap_list_gen:
    p_coros = get_coros(pcap_list)
        for f in asyncio.as_completed(p_coros):
            res = await f
</code></pre>
<p>As per my knowledge: The first loop is getting executed properly asa the iteration goes to next loop it throws error.</p>
<p><strong>Traceback:</strong></p>
<pre><code>Exception ignored in: &lt;generator object BaseSubprocessTransport._connect_pipes at 0x7f7b7c165830&gt;
Traceback (most recent call last):
  File "/usr/lib/python3.5/asyncio/base_subprocess.py", line 188, in _connect_pipes
    waiter.set_exception(exc)
  File "/usr/lib/python3.5/asyncio/futures.py", line 349, in set_exception
    self._schedule_callbacks()
  File "/usr/lib/python3.5/asyncio/futures.py", line 242, in _schedule_callbacks
    self._loop.call_soon(callback, self)
  File "/usr/lib/python3.5/asyncio/base_events.py", line 497, in call_soon
    handle = self._call_soon(callback, args)
  File "/usr/lib/python3.5/asyncio/base_events.py", line 506, in _call_soon
    self._check_closed()
  File "/usr/lib/python3.5/asyncio/base_events.py", line 334, in _check_closed
    raise RuntimeError('Event loop is closed')
RuntimeError: Event loop is closed
[ERROR]  Task was destroyed but it is pending!
task: &lt;Task pending coro=&lt;BaseSubprocessTransport._connect_pipes() done, defined at /usr/lib/python3.5/asyncio/base_subprocess.py:156&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt;&gt;
</code></pre>
<p><strong>More logs</strong></p>
<pre><code>RuntimeError: Event loop is closed
Exception ignored in: &lt;bound method BaseSubprocessTransport.__del__ of &lt;_UnixSubprocessTransport closed pid=70435 running stdin=&lt;_UnixWritePipeTransport closing fd=12 open&gt;&gt;&gt;
Traceback (most recent call last):
  File "/usr/lib/python3.5/asyncio/base_subprocess.py", line 126, in __del__
  File "/usr/lib/python3.5/asyncio/base_subprocess.py", line 101, in close
  File "/usr/lib/python3.5/asyncio/unix_events.py", line 568, in close
  File "/usr/lib/python3.5/asyncio/unix_events.py", line 560, in write_eof
  File "/usr/lib/python3.5/asyncio/base_events.py", line 497, in call_soon
  File "/usr/lib/python3.5/asyncio/base_events.py", line 506, in _call_soon
  File "/usr/lib/python3.5/asyncio/base_events.py", line 334, in _check_closed
RuntimeError: Event loop is closed
[ERROR]  Task exception was never retrieved
future: &lt;Task finished coro=&lt;ClassificationCheck.run_check() done, defined at ./regression.py:159&gt; exception=RuntimeError('cannot reuse already awaited coroutine',)&gt;
Traceback (most recent call last):
  File "/usr/lib/python3.5/asyncio/tasks.py", line 239, in _step
    result = coro.send(None)
RuntimeError: cannot reuse already awaited coroutine
</code></pre>
<p><strong>O/P of _p_coros_  after for loop iteration in main() as</strong></p>
<pre><code>P_COROS(1st iteration):  [&lt;coroutine object ClassificationCheck.run_check at 0x7f746d984ca8&gt;, &lt;coroutine object ClassificationCheck.run_check at 0x7f746d984db0&gt;, &lt;coroutine object ClassificationCheck.run_check at 0x7f746d984f68&gt;, &lt;coroutine object ClassificationCheck.run_check at 0x7f746d984fc0&gt;]
awating in block 'finally'
awating in block 'finally'
awating in block 'finally'
awating in block 'finally'
P_COROS(2nd iteration):  [&lt;coroutine object ClassificationCheck.run_check at 0x7f746d984ca8&gt;, &lt;coroutine object ClassificationCheck.run_check at 0x7f746d984db0&gt;, &lt;coroutine object ClassificationCheck.run_check at 0x7f746d984f68&gt;, &lt;coroutine object ClassificationCheck.run_check at 0x7f746d984fc0&gt;, &lt;coroutine object ClassificationCheck.run_check at 0x7f746d943048&gt;, &lt;coroutine object ClassificationCheck.run_check at 0x7f746d9430f8&gt;]
Traceback (most recent call last):
  File "./regression.py", line 325, in &lt;module&gt;
    loop.run_until_complete(ClassCheck.main())
  File "/usr/lib/python3.5/asyncio/base_events.py", line 387, in run_until_complete
    return future.result()
  File "/usr/lib/python3.5/asyncio/futures.py", line 274, in result
    raise self._exception
  File "/usr/lib/python3.5/asyncio/tasks.py", line 239, in _step
    result = coro.send(None)
  File "./regression.py", line 201, in main
    res = await f
  File "/usr/lib/python3.5/asyncio/tasks.py", line 492, in _wait_for_one
    return f.result()  # May raise f.exception().
  File "/usr/lib/python3.5/asyncio/futures.py", line 274, in result
    raise self._exception
  File "/usr/lib/python3.5/asyncio/tasks.py", line 239, in _step
    result = coro.send(None)
RuntimeError: cannot reuse already awaited coroutine
Exception ignored in: &lt;bound method BaseEventLoop.__del__ of &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;&gt;
Traceback (most recent call last):
  File "/usr/lib/python3.5/asyncio/base_events.py", line 431, in __del__
  File "/usr/lib/python3.5/asyncio/unix_events.py", line 58, in close
  File "/usr/lib/python3.5/asyncio/unix_events.py", line 139, in remove_signal_handler
  File "/usr/lib/python3.5/signal.py", line 47, in signal
TypeError: signal handler must be signal.SIG_IGN, signal.SIG_DFL, or a callable object
Exception ignored in: &lt;bound method BaseSubprocessTransport.__del__ of &lt;_UnixSubprocessTransport closed pid=89531 running stdin=&lt;_UnixWritePipeTransport closing fd=8 open&gt;&gt;&gt;
Traceback (most recent call last):
  File "/usr/lib/python3.5/asyncio/base_subprocess.py", line 126, in __del__
  File "/usr/lib/python3.5/asyncio/base_subprocess.py", line 101, in close
  File "/usr/lib/python3.5/asyncio/unix_events.py", line 568, in close
  File "/usr/lib/python3.5/asyncio/unix_events.py", line 560, in write_eof
  File "/usr/lib/python3.5/asyncio/base_events.py", line 497, in call_soon
  File "/usr/lib/python3.5/asyncio/base_events.py", line 506, in _call_soon
  File "/usr/lib/python3.5/asyncio/base_events.py", line 334, in _check_closed
RuntimeError: Event loop is closed
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Warning says that at the moment you call <code>loop.close()</code> something related to process still running. I guess you should <a href="https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.asyncio.subprocess.Process.wait" rel="nofollow noreferrer">wait()</a> for it's termination (read also note at the link). Try this:</p>
<pre><code>try:
    pcap_run = await asyncio.wait_for(fut, timeout=5)
except asyncio.TimeoutError:
    p.terminate()
finally:
    await p.wait()
</code></pre>
<p><strong>Upd:</strong></p>
<p>Oh, you probably used global <code>coros</code> variable:</p>
<pre><code>def get_coros(pcap_list):
    coros = []  # &lt;--------------- create new list to fill
    for pcap_loc in pcap_list:
        for pcap_check in get_pcap_executables():
            tmp_coro = (run_check('{args}'
            .format(e=sys.executable, args=args)))
            if tmp_coro != False:
                coros.append(tmp_coro)
     return coros
</code></pre>
</div>
<span class="comment-copy">Relevant <a href="https://stackoverflow.com/questions/30558040/understanding-asyncio-already-running-forever-loop-and-pending-tasks">understanding-asyncio</a></span>
<span class="comment-copy">I am still getting the same error (<i>RuntimeError: cannot reuse already awaited coroutine</i>), see my original posts I have added more logs. Also tried p.communicate() got same traceback/</span>
<span class="comment-copy">@NabaChinde I updated code snippet in answer, can you test if it'll work?</span>
<span class="comment-copy">Getting the same issue. I don't think the issues here are related to <i>TimeOut</i> as I am not using the data which will cause <i>TimeOut</i>. I think it is because of the 1st for loop in main. Please check my update logs for <i>p_coros</i> in <i>main()</i> under this <b>O/P of <i>p_coros</i> after for loop iteration in main() as</b></span>
<span class="comment-copy">the reason I am confident that the issue happens with the 2nd iteration of for loops because when I use a limited number of pcap files such that the for loop just iterate one time over the <i>pcap_list_gen</i>. i:e when <b>len(pcap_list_gen) == 1</b>, it does not fail.</span>
<span class="comment-copy">@NabaChinde, I updated answer. I guess we close to solution :)</span>
