<div class="post-text" itemprop="text">
<p>I am new to Python and I'm in need of a circular list. I have a list of 5 tags:</p>
<pre><code>taglist = ["faint", "shocking", "frosty", "loved", "sadness"]
</code></pre>
<p>I have another list with monotonically increasing values:</p>
<pre><code>list = [1,2,3,4,5,6,7]
</code></pre>
<p>I want to create another list using the <code>taglist</code> by the length of <code>list</code>. If <code>list</code> has 7 items, I want a new list of tags like below.</p>
<pre><code>newtaglist = ["faint", "shocking", "frosty", "loved", "sadness","faint", "shocking"]
</code></pre>
<p>And this list will go on like that as circular filling. How can I do this?</p>
<p><strong>SOLVED:</strong> Thank you all who answered in this post. Now I am confused to select the answer. :( Everyone seems good one. Though I have used The one with  simpler one.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>newtaglist</code> can be generated using a modulo operator to make sure the index is in range</p>
<pre><code>taglist = ["faint", "shocking", "frosty", "loved", "sadness"]
num_list = [1,2,3,4,5,6,7]
newtaglist = [taglist[i % len(taglist)] for i in xrange(len(num_list))]
</code></pre>
<p>Yielding:</p>
<blockquote>
<p>['faint', 'shocking', 'frosty', 'loved', 'sadness', 'faint', 'shocking']</p>
</blockquote>
<p>Run it <a href="https://repl.it/JodP" rel="nofollow noreferrer">here</a></p>
</div>
<div class="post-text" itemprop="text">
<p>The easiest way is use <a href="https://docs.python.org/3/library/itertools.html#itertools.cycle" rel="noreferrer"><em>itertools.cycle</em></a> which was designed for this particular purpose.</p>
<pre><code>&gt;&gt;&gt; from itertools import cycle, islice
&gt;&gt;&gt; baselist = [1,2,3,4,5,6,7]
&gt;&gt;&gt; taglist = ["faint", "shocking", "frosty", "loved", "sadness"]
&gt;&gt;&gt; list(islice(cycle(taglist), len(baselist)))
['faint', 'shocking', 'frosty', 'loved', 'sadness', 'faint', 'shocking']
</code></pre>
<p>Another way is to multiply (repeat) the list to make it large enough, then slice-off any excess:</p>
<pre><code>&gt;&gt;&gt; baselist = [1,2,3,4,5,6,7]
&gt;&gt;&gt; taglist = ["faint", "shocking", "frosty", "loved", "sadness"]
&gt;&gt;&gt; n = len(baselist)
&gt;&gt;&gt; (taglist * -(n // -len(taglist)))[:n]
['faint', 'shocking', 'frosty', 'loved', 'sadness', 'faint', 'shocking']
</code></pre>
<p>The double-negation is used to convert floor-division to ceiling-division which rounds-up whenever there is a remainder.  That makes sure the list multiplication always gives at least as many elements as needed.</p>
</div>
<div class="post-text" itemprop="text">
<p>Also, in python <code>list</code> is built-in function, dont use <code>list</code> as variable name.</p>
<pre><code>taglist = ["faint", "shocking", "frosty", "loved", "sadness"]
print(len(taglist))
list_ = [1,2,3,4,5,6,7]
print(len(list_))

diff = len(list_) - len(taglist)

for i in range(0, diff):
  taglist.append(taglist[i])
print(taglist)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Where n is the desired length:</p>
<pre><code>[taglist[i % len(taglist)] for i in range(n)]
</code></pre>
<p>Or you could use Raymond's suggestion of</p>
<pre><code>from itertools import cycle
infiniteTagList = cycle(taglist)
[next(infiniteTagList) for i in range(n)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Multiplying plus slicing:</p>
<pre><code>&gt;&gt;&gt; taglist = ['a', 'b', 'c', 'd', 'e']
&gt;&gt;&gt; length = 13
&gt;&gt;&gt; 
&gt;&gt;&gt; q, r = divmod(length, len(taglist))
&gt;&gt;&gt; taglist * q + taglist[:r]
['a', 'b', 'c', 'd', 'e', 'a', 'b', 'c', 'd', 'e', 'a', 'b', 'c']
</code></pre>
</div>
<span class="comment-copy">I have used this method.</span>
<span class="comment-copy">In case you care about runtime, this is actually the slowest method, about 10x slower than all the others <a href="https://repl.it/JpkQ" rel="nofollow noreferrer">which are fairly similar in the example I've linked to</a>.</span>
<span class="comment-copy">Thanks for the codes from repl ... ! So, stefans use of divmod is the  fastest one.</span>
<span class="comment-copy">Using the multiply method seems good for me, new way of learning of newthings.</span>
<span class="comment-copy">Although it isn't in the question, if he wants to loop more than once through the list, this will fail. I think adding a <code>tag_length = len(taglist)</code> before the loop and then <code>taglist.append(taglist[i % tag_length])</code> might fix that. Didn't test it though. <b>Edit</b> something like this, but I think this goes the wrong direction through the list...</span>
<span class="comment-copy">@mtkilic Thanks for pointing the "list" one. :)</span>
