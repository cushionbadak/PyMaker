<div class="post-text" itemprop="text">
<pre><code>Jamies_string = "Hello there {my name is jamie}".split()

print(Jamies_string)
</code></pre>
<p>Output here:</p>
<pre><code>['Hello', 'there', '{my', 'name', 'is', 'jamie}']
</code></pre>
<p>Desired output here:</p>
<pre><code>['Hello', 'there', '{', 'my', 'name', 'is', 'jamie', '}']
</code></pre>
<p>I really want to stay away from any soltutions that involve the use of the re library, thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>One solution is to create a function that categorises characters and use that as a key function for <code>itertools.groupby()</code>:</p>
<pre><code>WHITESPACE = 0
LETTERS = 1
DIGITS = 2
SYMBOLS = 3

def character_class(c):
    if c.isspace():
        return WHITESPACE
    if c.isalpha():
        return LETTERS
    if c.isdigit():
        return DIGITS
    return SYMBOLS

s = "Hello there {my name is jamie}"
tokens = [
    "".join(chars)
    for cls, chars in itertools.groupby(s, character_class)
    if cls != WHITESPACE
]
print(tokens)
</code></pre>
<p>prints</p>
<pre><code>['Hello', 'there', '{', 'my', 'name', 'is', 'jamie', '}']
</code></pre>
<p>You clarified that you want to avoid regular expressions for performance reasons.  The approach in this answer is definitely slower than correctly using regular expressions.  However, I don't think your project is at a stage where you need to worry about performance.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could add spaces around those symbols first, then use <code>split()</code>, e.g.</p>
<pre><code>&gt;&gt;&gt; s = "Hello there {my name is jamie}"
&gt;&gt;&gt; s.replace("{", " { ").replace("}", " } ").split()
['Hello', 'there', '{', 'my', 'name', 'is', 'jamie', '}']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The string you're using is similar to <a href="https://docs.python.org/3/library/string.html#formatstrings" rel="nofollow noreferrer">format string</a> in Python. If so, you could use <a href="https://docs.python.org/3/library/string.html#string.Formatter" rel="nofollow noreferrer"><code>Formatter</code></a> class to parse it:</p>
<pre><code>from string import Formatter


def solve(s):
    for f in Formatter().parse(s):
        yield from f[0].split()
        if f[1]:
            yield from ['{'] + f[1].split() + ['}']
</code></pre>
<p><strong>Demo:</strong></p>
<pre><code>&gt;&gt;&gt; list(solve("Hello there {my name is jamie}"))
['Hello', 'there', '{', 'my', 'name', 'is', 'jamie', '}']

&gt;&gt;&gt; list(solve("Hello there {my name is jamie} {hello world} end."))
['Hello', 'there', '{', 'my', 'name', 'is', 'jamie', '}', '{', 'hello', 'world', '}', 'end.']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Make a pass through the string and put whitespace around all punctuation characters then split on white space.</p>
<pre><code>&gt;&gt;&gt;&gt; import string
&gt;&gt;&gt; s = "Hello there {my name is jamie}"
&gt;&gt;&gt; s = ''.join(c if c.isalnum() or c.isspace() else ' {} '.format(c) for c in s)
&gt;&gt;&gt; s.split()
['Hello', 'there', '{', 'my', 'name', 'is', 'jamie', '}']
&gt;&gt;&gt; 
</code></pre>
<hr/>
<p>Expanding that third line a bit --</p>
<pre><code>a = []
for c in s:
    if not c.isalnum() and not c.isspace():
        c = ' ' + c + ' '
    a.append(c)

s = ''.join(a)
s.split()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way (not as clean as other answers, but it works):</p>
<pre><code>def tokenize(string):
    WHITESPACE = 0 #Borrowed from Sven's answer
    LETTERS = 1
    DIGITS = 2
    SYMBOLS = 3
    def character_class(c):
        if c.isspace():
            return WHITESPACE
        elif c.isalpha():
            return LETTERS
        elif c.isdigit():
            return DIGITS
        return SYMBOLS

    lastType = character_class(string[0])
    chunk = ""

    for i, char in enumerate(string):
        charType = character_class(char)
        if charType == WHITESPACE:
            if chunk: #Only yield if non-empty
                yield chunk
            chunk = ""
            lastType = character_class(string[i + 1]) #Type of next character because we want the next part to not have leading whitespace
            continue #Don't add to chunk
        elif charType != lastType: #Different type
            if chunk: #Only yield if non-empty
                yield chunk
            chunk = ""
            lastType = charType
        chunk += char
    if chunk:
        yield chunk
print(list(tokenize("Hello there {my name is jamie}")))
</code></pre>
<p>Sample output:</p>
<pre><code>['Hello', 'there', '{', 'my', 'name', 'is', 'jamie', '}']
</code></pre>
<p>This is more or less manually doing what <code>itertools.groupby</code> does.</p>
</div>
<span class="comment-copy">Why to you want to stay away from regular expressions?  They are definitvely overused, but sometimes they are indeed the right solution.</span>
<span class="comment-copy">Hi, I'm trying out making a programming language and I want it to be as efficient as possible.</span>
<span class="comment-copy">@JamieJohnson One regex split will be more efficient than most other alternatives you can think of.</span>
<span class="comment-copy">it's better not to split at all in those cases, and extract the tokens one by one, without creating lists. Using regular expression is what <code>ply</code> (python lex-yacc) uses, so I guess it's pretty efficient. I myself did the splitting using replace+split, and it's clearly less efficient.</span>
<span class="comment-copy">If you want to write a parser, look into <a href="https://github.com/webmaven/python-parsing-tools" rel="nofollow noreferrer">some parser library</a>.</span>
<span class="comment-copy">groupby is a nice alternative to regexes, yeah.</span>
