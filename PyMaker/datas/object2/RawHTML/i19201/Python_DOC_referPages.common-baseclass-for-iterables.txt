<div class="post-text" itemprop="text">
<p>I'm trying to create a method which only accepts an iterable parameter, such as <code>list</code>, <code>tuple</code>, <code>set</code> or <code>dict</code>.</p>
<p>Here's my code:</p>
<pre><code>class MjmMenuControl(MjmBaseMenu):
    def __init__(self, items=None):
        iterables = (dict, list, set, tuple)
        for iterable in iterables:
            if isinstance(items, iterable):
                ...
                break
</code></pre>
<p>However, I was wondering if there's an easier way, such as <code>if isinstance(items, &lt;iterable_base_class&gt;):</code> but I couldn't find anything.</p>
<p>I already tried finding baseclass for <code>list</code> etc. but they all seem to derive from <code>object</code>:</p>
<pre><code>&gt;&gt;&gt; inspect.getmro(list)
(&lt;class 'list'&gt;, &lt;class 'object'&gt;)
&gt;&gt;&gt; inspect.getmro(tuple)
(&lt;class 'tuple'&gt;, &lt;class 'object'&gt;)
</code></pre>
<p>Is this possible or do I have to stick with the awful <code>for</code> loop?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, use <a href="http://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable" rel="nofollow"><code>collections.abc.Iterable</code></a>:</p>
<pre><code>&gt;&gt;&gt; from collections import abc
&gt;&gt;&gt; isinstance(set(), abc.Iterable)
True
&gt;&gt;&gt; isinstance((), abc.Iterable)
True
&gt;&gt;&gt; isinstance([], abc.Iterable)
True
&gt;&gt;&gt; isinstance('', abc.Iterable)
True
&gt;&gt;&gt; isinstance({}, abc.Iterable)
True
&gt;&gt;&gt; isinstance(0, abc.Iterable)
False
</code></pre>
<p>However, I'd just have the method <em>assume</em> it is passed an iterable, it's the responsibility of the <em>caller</em> to ensure the correct type is passed in.</p>
<p>The <a href="https://docs.python.org/3/library/collections.abc.html" rel="nofollow"><code>collections.abc</code> module</a> is new in Python 3.3; its contents formerly lived in the <a href="https://docs.python.org/2/library/collections.html" rel="nofollow"><code>collections</code> module</a> instead, albeit that the names are still available in the old location even in Python 3.3 and up.</p>
</div>
<div class="post-text" itemprop="text">
<p>One weakness of the <code>collections.abc.Iterable</code> option is it can't cope with custom iterable classes like this...</p>
<pre><code>from collections.abc import Iterable

class MyIterable(object):
    def __getitem__(self, index):
        if index &gt;= 10:
            raise IndexError
        return index

&gt;&gt;&gt; myiter = MyIterable()
&gt;&gt;&gt; isinstance(myiter, Iterable)
False
&gt;&gt;&gt; [i for i in myiter]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>It's often claimed that the 'Pythonic' way of doing this is to use <a href="http://en.wikipedia.org/wiki/Duck_typing" rel="nofollow">duck typing</a>, i.e. to try treating the object as an iterable, and handling the exception if it fails. For example...</p>
<pre><code>class MjmMenuControl(MjmBaseMenu):
    def __init__(self, items=None):
        try:
            for item in items:
                do_something_with(item)
        except TypeError:
            # If we get here, 'items' is not iterable
            do_something_else()
</code></pre>
<p>...however, both methods have the weakness of treating strings to be the same thing as, say, lists, which isn't usually what you want. Usually you want to test for an iterable <strong>container</strong>, which is slightly different, so it's common to see code which treats strings as a special case like this...</p>
<pre><code>class MjmMenuControl(MjmBaseMenu):
    def __init__(self, items=None):
        if isinstance(items, (str, bytes)):
            do_something_else()
        else:
            try:
                for item in items:
                    do_something_with(item)
            except TypeError:
                # If we get here, 'items' is not iterable
                do_something_else()
</code></pre>
<p>...which is a little messy, but gets the job done.</p>
</div>
<span class="comment-copy">"if there's an easier way" - yes, omit the type check altogether.</span>
<span class="comment-copy">As a side note, you don't actually need the <code>for</code> loop, <code>isinstance</code> can take in a tuple as the second parameter such that it returns <code>True</code> if the first parameter is an instance of <i>any</i> of the classes in the tuple.</span>
<span class="comment-copy">@Volatility Ahh thanks for the tip. :)</span>
<span class="comment-copy">Thanks a lot, I'll accept asap :) Can you also explain why it doesn't show in <code>inspect.getmro()</code>, I thought it shows all base classes? Also the method accepts any type of parameter but does different things for different types so that's the real reason I need to check whether it's iterable or not. I thought giving an example where my program only accepts an iterable would be easier to understand :)</span>
<span class="comment-copy"><code>list</code> and <code>tuple</code> are not subclasses here, they are just distinct types that happen to implement the same protocols. <i>There is no iterable baseclass</i>.</span>
<span class="comment-copy">If you need to alter behaviour, then testing for <code>Iterable</code> can be a good option, yes.</span>
<span class="comment-copy">Alright thanks for your help!</span>
<span class="comment-copy">@qarma: I note that the Python 3 documentation for the <a href="https://docs.python.org/3/library/collections.abc.html" rel="nofollow noreferrer"><code>collections.abc</code> module</a> states it was originally part of <code>collections</code>; the Python 3 version still has aliases in place too.</span>
<span class="comment-copy">I've changed <code>basestring</code> to <code>(str, bytes)</code> since the question is tagged python-3.x, where they no longer have a common subclass (aside from <code>object</code>).</span>
<span class="comment-copy">You should be using <code>__iter__</code> instead of <code>__getitem__</code> <i>anyway</i>.</span>
<span class="comment-copy">@lvc Oops. My bad. :)</span>
<span class="comment-copy">No, <code>__getitem__</code> implies other types; see the <code>Sequence</code> ABC, for example, but also the <code>Mapping</code> ABC. <code>__getitem__</code> support is there for old-style types really, <code>__iter__</code> is a more recent addition that your newer code really should use instead.</span>
<span class="comment-copy">Ah. I hadn't picked up on the minor distinction between <code>Sequence</code> and <code>Iterable</code>, although they are kind of similar. It's possible that what the OP is really after is the former, not the latter. TBH, I started with Python about 15 years ago, and I haven't really had time to keep up with all the new features. I shall have to investigate further. :)</span>
