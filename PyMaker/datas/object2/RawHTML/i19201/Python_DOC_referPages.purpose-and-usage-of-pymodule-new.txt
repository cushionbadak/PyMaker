<div class="post-text" itemprop="text">
<p>At face value, the C-API function <code>PyModule_New</code> and <code>PyModule_NewObject</code> obviously creates a new module object.  </p>
<p>The <a href="http://docs.python.org/3/c-api/module.html#PyModule_New" rel="nofollow">official Python Documentation</a> provides the following explanation for <code>PyModule_NewObject</code>:</p>
<blockquote>
<p>Return a new module object with the <strong>name</strong> attribute set to name.
  Only the moduleâ€™s <strong>doc</strong> and <strong>name</strong> attributes are filled in; the
  caller is responsible for providing a <strong>file</strong> attribute.</p>
</blockquote>
<p><code>PyModule_New</code> does the same thing, except it accepts a C string (<code>char*</code>) as an argument for the module name, instead of a <code>PyObject*</code> string.</p>
<p>Okay, so this is pretty straightforward, but...  </p>
<p>My question is: <strong>what is the use of calling the API function <code>PyModule_NewObject</code>?</strong> </p>
<p>Sure, theoretically it would be great for a situation where you want to dynamically create a new module.  But the problem is that, in practice, after creating a new module object, the only way to do anything useful to it would be to add objects (like methods, classes, variables, etc.) to the module's <code>__dict__</code> attribute.  This way users of the module could import it and actually do something with it.  </p>
<p>The problem is that the <code>__dict__</code> attribute of a module is <strong><em>read-only</em></strong>:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; x = re
&gt;&gt;&gt; re.__dict__ = { "foo" : "bar" }
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: readonly attribute
</code></pre>
<p><br/></p>
<p>So, in practice, there's really no way to do anything useful with a dynamically created module, as far as I can see.  So what then, is the purpose of the C API function <code>PyModule_New</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>PyModule_New</code> is the constructor for module objects. It's exposed to pure Python code too, as the <code>__new__</code> method of the <code>types.ModuleType</code> class.</p>
<p>It probably is pretty rare for user code to need to use either of those, since you usually get modules by importing them. However, the machinery used by the Python interpreter uses <code>PyModule_New</code> to make the module objects when an import is requested.</p>
<p>You can see this in <a href="http://hg.python.org/cpython/file/225022955c65/Python/import.c#l624" rel="nofollow"><code>import.c</code> in the Python source</a>:</p>
<pre><code>/* Get the module object corresponding to a module name.
First check the modules dictionary if there's one there,
if not, create a new one and insert it in the modules dictionary.
Because the former action is most common, THIS DOES NOT RETURN A
'NEW' REFERENCE! */

PyImport_AddModule(const char *name)
{
    PyObject *modules = PyImport_GetModuleDict();
    PyObject *m;

    if ((m = PyDict_GetItemString(modules, name)) != NULL &amp;&amp;
        PyModule_Check(m))
        return m;
    m = PyModule_New(name);
    if (m == NULL)
        return NULL;
    if (PyDict_SetItemString(modules, name, m) != 0) {
        Py_DECREF(m);
        return NULL;
    }
    Py_DECREF(m); /* Yes, it still exists, in modules! */

    return m;
}
</code></pre>
<p>As for how to set values in a new module object, you can use regular attribute access. In Python code (rather than C), that's simple:</p>
<pre><code>import types

mymodule = types.ModuleType("mymodule")
mymodule.foo = "foo"
</code></pre>
<p>Note that a module created this way can't be imported anywhere else unless you do some additional work. For instance, you can add it to the modules lookup dictionary, <code>sys.modules</code>:</p>
<pre><code>import sys

sys.modules["mymodule"] = mymodule
</code></pre>
<p>Now other modules can import <code>mymodule</code> by name.</p>
</div>
