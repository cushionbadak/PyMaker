<div class="post-text" itemprop="text">
<p>Say I have a list of applications, described as a custom object.  I decided to do a deepcopy of the original application list, so that I could have one list that acts like a pool of available applications.  To assign applications, I randomly select a subset of the pool, and then find those applications in the original list, so that I can update their info. Then, assigned applications are removed from the pool.  But, for some reason, the applications can never be found in the original list:</p>
<pre><code>list1 = [App1,App2,App3,App4,App5]
pool = copy.deepcopy(list1)
num_apps = rand.randrange(0,5)
random.shuffle(pool)
selected_apps = copy.deepcopy(pool[:num_apps])
for app in selected_apps:
    locn = list1.index(app)
    print locn
</code></pre>
<p>The above code will actually return a ValueError that a item in selected_apps can't be found.  Is the error due to the fact that I'm making deep copies of lists that contain objects that aren't native to Python, or something else?</p>
</div>
<div class="post-text" itemprop="text">
<p>When using <code>list.index</code> it uses comparison operator (<code>==</code>) to check whether the items are the same, which in turn uses <a href="https://docs.python.org/3/reference/datamodel.html#object.__eq__" rel="nofollow"><code>__eq__</code></a> method, <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow">from documentation</a>:</p>
<blockquote>
<p>User-defined classes have <code>__eq__()</code> and <code>__hash__()</code> methods by default; with them, <strong>all objects compare unequal (except with themselves)</strong> and <code>x.__hash__()</code> returns an appropriate value such that <code>x == y</code> implies both that <code>x is y</code> and <code>hash(x) == hash(y)</code>.</p>
</blockquote>
<p>You can demonstrate this by:</p>
<pre><code>&gt;&gt;&gt; class A(object):
...     def __init__(self):
...         self.x = 0
... 
&gt;&gt;&gt; a = A()
&gt;&gt;&gt; a.x = 5
&gt;&gt;&gt; b = a
&gt;&gt;&gt; b == a
True
&gt;&gt;&gt; c = copy.deepcopy(a)
&gt;&gt;&gt; c == a
False
</code></pre>
<p>In CPython <code>id()</code> returns memory address of an object, so <code>__eq__</code> returns true if ids match:</p>
<pre><code>&gt;&gt;&gt; id(a) 
140389541757224
&gt;&gt;&gt; id(b)
140389541757224
&gt;&gt;&gt; id(c)
140389541757336
</code></pre>
<p>So you just need to implement <code>__eq__</code> method and <code>__ne__</code>:</p>
<blockquote>
<p>There are no implied relationships among the comparison operators. The truth of <code>x==y</code> does not imply that <code>x!=y</code> is false. Accordingly, when defining <code>__eq__()</code>, one should also define <code>__ne__()</code> so that the operators will behave as expected.</p>
</blockquote>
<pre><code>&gt;&gt;&gt; class A(object):
...     def __init__(self):
...         self.x = 0
...     def __eq__(self, o):
...         return self.x == o.x
...     def __ne__(self, o):
...         return self.x != o.x
... 
&gt;&gt;&gt; a = A()
&gt;&gt;&gt; a.x = 5
&gt;&gt;&gt; b = a
&gt;&gt;&gt; c = copy.deepcopy(a)
&gt;&gt;&gt; d = A()
&gt;&gt;&gt; d.x = 4
&gt;&gt;&gt; a == b
True
&gt;&gt;&gt; a == c
True
&gt;&gt;&gt; a is b
True
&gt;&gt;&gt; a is c
False
&gt;&gt;&gt; a == d
False
</code></pre>
<p>Also notice this:</p>
<blockquote>
<p>If a class does not define an <code>__eq__()</code> method it should not define a <code>__hash__()</code> operation either; if it defines <code>__eq__()</code> but not <code>__hash__()</code>, its instances <strong>will not be usable as items in hashable collections</strong>. </p>
</blockquote>
</div>
<span class="comment-copy">Have you implemented the <code>__eq__</code> method for your App classes? More than likely what is happening is that the .index method has no way of comparing two App objects that are the same since you have done a deep copy and their memory addresses have changed.</span>
<span class="comment-copy">Ah, I haven't tried implementing the <code>__eq__</code> method. I'll look into it, thanks!</span>
