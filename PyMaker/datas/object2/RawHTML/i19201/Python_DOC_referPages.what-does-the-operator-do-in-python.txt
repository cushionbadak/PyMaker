<div class="post-text" itemprop="text">
<p>I'm looking at some Python code which used the <code>@</code> symbol, but I have no idea what it does. I also do not know what to search for as searching Python docs or Google does not return relevant results when the <code>@</code> symbol is included.</p>
</div>
<div class="post-text" itemprop="text">
<p>An <code>@</code> symbol at the beginning of a line is used for class, function and method <em>decorators</em>.</p>
<p>Read more here:</p>
<p><a href="http://www.python.org/dev/peps/pep-0318/" rel="noreferrer">PEP 318: Decorators</a></p>
<p><a href="http://wiki.python.org/moin/PythonDecorators" rel="noreferrer">Python Decorators</a></p>
<p>The most common Python decorators you'll run into are:</p>
<p><a href="http://docs.python.org/library/functions.html#property" rel="noreferrer">@property</a></p>
<p><a href="http://docs.python.org/library/functions.html#classmethod" rel="noreferrer">@classmethod</a></p>
<p><a href="http://docs.python.org/library/functions.html#staticmethod" rel="noreferrer">@staticmethod</a></p>
<p>If you see an <code>@</code> in the middle of a line, that's a different thing, matrix multiplication. Scroll down to see other answers that address that use of <code>@</code>.</p>
</div>
<div class="post-text" itemprop="text">
<h2>Preamble</h2>
<p>I admit it took more than a few moments to fully grasp this concept for me, so I'll share what I've learned to save others the trouble.</p>
<p>The name <strong>decorator</strong> - the thing we define using the <code>@</code> syntax before a function definition - was probably the main culprit here.</p>
<h2>Example</h2>
<pre><code>class Pizza(object):
    def __init__(self):
        self.toppings = []

    def __call__(self, topping):
        # When using '@instance_of_pizza' before a function definition
        # the function gets passed onto 'topping'.
        self.toppings.append(topping())

    def __repr__(self):
        return str(self.toppings)

pizza = Pizza()

@pizza
def cheese():
    return 'cheese'
@pizza
def sauce():
    return 'sauce'

print pizza
# ['cheese', 'sauce']
</code></pre>
<p>This shows that the <code>function</code>/<code>method</code>/<code>class</code> you're defining after a <strong>decorator</strong> is just basically passed on as an <code>argument</code> to the <code>function</code>/<code>method</code> immediately after the <code>@</code> sign.</p>
<h2>First sighting</h2>
<p>The microframework <strong>Flask</strong> introduces <strong>decorators</strong> from the very beginning in the following format:</p>
<pre><code>from flask import Flask
app = Flask(__name__)

@app.route("/")
def hello():
    return "Hello World!"
</code></pre>
<p>This in turn translates to:</p>
<pre><code>rule      = "/"
view_func = hello
# They go as arguments here in 'flask/app.py'
def add_url_rule(self, rule, endpoint=None, view_func=None, **options):
    pass
</code></pre>
<p>Realizing this finally allowed me to feel at peace with Flask.</p>
</div>
<div class="post-text" itemprop="text">
<p>This code snippet:</p>
<pre><code>def decorator(func):
   return func

@decorator
def some_func():
    pass
</code></pre>
<p>Is equivalent to this code:</p>
<pre><code>def decorator(func):
    return func

def some_func():
    pass

some_func = decorator(some_func)
</code></pre>
<p>In the definition of a decorator you can add some modified things that wouldn't be returned by a function normally.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.5 you can overload <code>@</code> as an operator. It is named as <code>__matmul__</code>, because it is designed to do matrix multiplication, but it can be anything you want. See <a href="http://www.python.org/dev/peps/pep-0465/" rel="noreferrer">PEP465</a> for details.</p>
<p>This is a simple implementation of matrix multiplication.</p>
<pre><code>class Mat(list):
    def __matmul__(self, B):
        A = self
        return Mat([[sum(A[i][k]*B[k][j] for k in range(len(B)))
                    for j in range(len(B[0])) ] for i in range(len(A))])

A = Mat([[1,3],[7,5]])
B = Mat([[6,8],[4,2]])

print(A @ B)
</code></pre>
<p>This code yields:</p>
<pre><code>[[18, 14], [62, 66]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>What does the “at” (@) symbol do in Python?</h1>
<p>In short, it is used in decorator syntax and for matrix multiplication.</p>
<p>In the context of decorators, this syntax:</p>
<pre><code>@decorator
def decorated_function():
    """this function is decorated"""
</code></pre>
<p>is equivalent to this:</p>
<pre><code>def decorated_function():
    """this function is decorated"""

decorated_function = decorator(decorated_function)
</code></pre>
<p>In the context of matrix multiplication, <code>a @ b</code> invokes <code>a.__matmul__(b)</code> - making this syntax:</p>
<pre><code>a @ b
</code></pre>
<p>equivalent to </p>
<pre><code>dot(a, b)
</code></pre>
<p>and </p>
<pre><code>a @= b
</code></pre>
<p>equivalent to </p>
<pre><code>a = dot(a, b)
</code></pre>
<p>where <code>dot</code> is, for example, the numpy matrix multiplication function and <code>a</code> and <code>b</code> are matrices.</p>
<h2>How could you discover this on your own?</h2>
<blockquote>
<p>I also do not know what to search for as searching Python docs or Google does not return relevant results when the @ symbol is included.</p>
</blockquote>
<p>If you want to have a rather complete view of what a particular piece of python syntax does, look directly at the grammar file. For the Python 3 branch:</p>
<pre><code>~$ grep -C 1 "@" cpython/Grammar/Grammar 

decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE
decorators: decorator+
--
testlist_star_expr: (test|star_expr) (',' (test|star_expr))* [',']
augassign: ('+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&amp;=' | '|=' | '^=' |
            '&lt;&lt;=' | '&gt;&gt;=' | '**=' | '//=')
--
arith_expr: term (('+'|'-') term)*
term: factor (('*'|'@'|'/'|'%'|'//') factor)*
factor: ('+'|'-'|'~') factor | power
</code></pre>
<p>We can see here that <code>@</code> is used in three contexts:</p>
<ul>
<li>decorators</li>
<li>an operator between factors</li>
<li>an augmented assignment operator</li>
</ul>
<h2>Decorator Syntax:</h2>
<p>A google search for "decorator python docs" gives as one of the top results, the "Compound Statements" section of the "Python Language Reference." Scrolling down to the <a href="https://docs.python.org/3/reference/compound_stmts.html#class-definitions" rel="noreferrer">section on function definitions</a>, which we can find by searching for the word, "decorator", we see that... there's a lot to read. But the word, <a href="https://docs.python.org/3/glossary.html#term-decorator" rel="noreferrer">"decorator" is a link to the glossary</a>, which tells us:</p>
<blockquote>
<h3>decorator</h3>
<p>A function returning another function, usually applied as a function transformation using the <code>@wrapper</code> syntax. Common
  examples for decorators are <code>classmethod()</code> and <code>staticmethod()</code>.</p>
<p>The decorator syntax is merely syntactic sugar, the following two
  function definitions are semantically equivalent:</p>
<pre><code>def f(...):
    ...
f = staticmethod(f)

@staticmethod
def f(...):
    ...
</code></pre>
<p>The same concept exists for classes, but is less commonly used there.
  See the documentation for function definitions and class definitions
  for more about decorators.</p>
</blockquote>
<p>So, we see that</p>
<pre><code>@foo
def bar():
    pass
</code></pre>
<p>is semantically the same as:</p>
<pre><code>def bar():
    pass

bar = foo(bar)
</code></pre>
<p>They are not exactly the same because Python evaluates the foo expression (which could be a dotted lookup and a function call) before bar with the decorator (<code>@</code>) syntax, but evaluates the foo expression <em>after</em> bar in the other case.</p>
<p><sub>(If this difference makes a difference in the meaning of your code, you should reconsider what you're doing with your life, because that would be pathological.)</sub></p>
<h3>Stacked Decorators</h3>
<p>If we go back to the function definition syntax documentation, we see:</p>
<blockquote>
<pre><code>@f1(arg)
@f2
def func(): pass
</code></pre>
<p>is roughly equivalent to</p>
<pre><code>def func(): pass
func = f1(arg)(f2(func))
</code></pre>
</blockquote>
<p>This is a demonstration that we can call a function that's a decorator first, as well as stack decorators. Functions, in Python, are first class objects - which means you can pass a function as an argument to another function, and return functions. Decorators do both of these things.</p>
<p>If we stack decorators, the function, as defined, gets passed first to the decorator immediately above it, then the next, and so on.</p>
<p>That about sums up the usage for <code>@</code> in the context of decorators.</p>
<h2>The Operator, <code>@</code></h2>
<p>In the lexical analysis section of the language reference, we have a <a href="https://docs.python.org/3/reference/lexical_analysis.html#operators" rel="noreferrer">section on operators</a>, which includes <code>@</code>, which makes it also an operator:</p>
<blockquote>
<p>The following tokens are operators:</p>
<pre><code>+       -       *       **      /       //      %      @
&lt;&lt;      &gt;&gt;      &amp;       |       ^       ~
&lt;       &gt;       &lt;=      &gt;=      ==      !=
</code></pre>
</blockquote>
<p>and in the next page, the Data Model, we have the <a href="https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types" rel="noreferrer">section, emulating numeric types</a>, </p>
<blockquote>
<pre><code>object.__add__(self, other)
object.__sub__(self, other) 
object.__mul__(self, other) 
object.__matmul__(self, other) 
object.__truediv__(self, other) 
object.__floordiv__(self, other)
</code></pre>
<p>[...]
  These methods are called to implement the binary arithmetic operations (<code>+</code>, <code>-</code>, <code>*</code>, <code>@</code>, <code>/</code>, <code>//</code>, [...]</p>
</blockquote>
<p>And we see that <code>__matmul__</code> corresponds to <code>@</code>. If we search the documentation for "matmul" we get a link to <a href="https://docs.python.org/3/whatsnew/3.5.html?highlight=matmul#pep-465-a-dedicated-infix-operator-for-matrix-multiplication" rel="noreferrer">What's new in Python 3.5</a> with "matmul" under a heading "PEP 465 - A dedicated infix operator for matrix multiplication".</p>
<blockquote>
<p>it can be implemented by defining <code>__matmul__()</code>, <code>__rmatmul__()</code>, and
  <code>__imatmul__()</code> for regular, reflected, and in-place matrix multiplication.</p>
</blockquote>
<p>(So now we learn that <code>@=</code> is the in-place version). It further explains:</p>
<blockquote>
<p>Matrix multiplication is a notably common operation in many fields of
  mathematics, science, engineering, and the addition of @ allows
  writing cleaner code:</p>
<pre><code>S = (H @ beta - r).T @ inv(H @ V @ H.T) @ (H @ beta - r)
</code></pre>
<p>instead of:</p>
<pre><code>S = dot((dot(H, beta) - r).T,
        dot(inv(dot(dot(H, V), H.T)), dot(H, beta) - r))
</code></pre>
</blockquote>
<p>While this operator can be overloaded to do almost anything, in <code>numpy</code>, for example, we would use this syntax to calculate the inner and outer product of arrays and matrices:</p>
<pre><code>&gt;&gt;&gt; from numpy import array, matrix
&gt;&gt;&gt; array([[1,2,3]]).T @ array([[1,2,3]])
array([[1, 2, 3],
       [2, 4, 6],
       [3, 6, 9]])
&gt;&gt;&gt; array([[1,2,3]]) @ array([[1,2,3]]).T
array([[14]])
&gt;&gt;&gt; matrix([1,2,3]).T @ matrix([1,2,3])
matrix([[1, 2, 3],
        [2, 4, 6],
        [3, 6, 9]])
&gt;&gt;&gt; matrix([1,2,3]) @ matrix([1,2,3]).T
matrix([[14]])
</code></pre>
<h3>Inplace matrix multiplication: <code>@=</code></h3>
<p>While researching the prior usage, we learn that there is also the inplace matrix multiplication. If we attempt to use it, we may find it is not yet implemented for numpy:</p>
<pre><code>&gt;&gt;&gt; m = matrix([1,2,3])
&gt;&gt;&gt; m @= m.T
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: In-place matrix multiplication is not (yet) supported. Use 'a = a @ b' instead of 'a @= b'.
</code></pre>
<p>When it is implemented, I would expect the result to look like this:</p>
<pre><code>&gt;&gt;&gt; m = matrix([1,2,3])
&gt;&gt;&gt; m @= m.T
&gt;&gt;&gt; m
matrix([[14]])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>What does the “at” (@) symbol do in Python?</p>
</blockquote>
<p>@ symbol is a syntactic sugar python provides to utilize <code>decorator</code>,<br/>
to paraphrase the question, It's exactly about what does decorator do in Python?</p>
<p>Put it simple <code>decorator</code> allow you to modify a given function's definition without touch its innermost (it's closure).<br/>
It's the most case when you import wonderful package from third party. You can visualize it, you can use it, but you cannot touch its innermost and its heart.   </p>
<p>Here is a quick example,<br/>
suppose I define a <code>read_a_book</code> function on Ipython</p>
<pre><code>In [9]: def read_a_book():
   ...:     return "I am reading the book: "
   ...: 
In [10]: read_a_book()
Out[10]: 'I am reading the book: '
</code></pre>
<p>You see, I forgot to add a name to it.<br/>
How to solve such a problem? Of course, I could re-define the function as:</p>
<pre><code>def read_a_book():
    return "I am reading the book: 'Python Cookbook'"
</code></pre>
<p>Nevertheless, what if I'm not allowed to manipulate the original function, or if there are thousands of such function to be handled.</p>
<p>Solve the problem by thinking different and define a new_function  </p>
<pre><code>def add_a_book(func):
    def wrapper():
        return func() + "Python Cookbook"
    return wrapper
</code></pre>
<p>Then employ it.</p>
<pre><code>In [14]: read_a_book = add_a_book(read_a_book)
In [15]: read_a_book()
Out[15]: 'I am reading the book: Python Cookbook'
</code></pre>
<p>Tada, you see, I amended <code>read_a_book</code> without touching it inner closure. Nothing stops me equipped with <code>decorator</code>.</p>
<p>What's about <code>@</code></p>
<pre><code>@add_a_book
def read_a_book():
    return "I am reading the book: "
In [17]: read_a_book()
Out[17]: 'I am reading the book: Python Cookbook'
</code></pre>
<p><code>@add_a_book</code> is a fancy and handy way to say <code>read_a_book = add_a_book(read_a_book)</code>, it's a syntactic sugar, there's nothing more fancier about it.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are referring to some code in a python notebook which is using <strong>Numpy</strong> library, then <code>@ operator</code> means <strong>Matrix Multiplication</strong>. For example:</p>
<pre><code>import numpy as np
def forward(xi, W1, b1, W2, b2):
    z1 = W1 @ xi + b1
    a1 = sigma(z1)
    z2 = W2 @ a1 + b2
    return z2, a1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Starting with Python 3.5, the '@' is used as a dedicated infix symbol for MATRIX MULTIPLICATION (PEP 0465 -- see <a href="https://www.python.org/dev/peps/pep-0465/" rel="noreferrer">https://www.python.org/dev/peps/pep-0465/</a>)</p>
</div>
<div class="post-text" itemprop="text">
<p>@ symbol is also used to access variables inside a plydata / pandas dataframe query, <code>pandas.DataFrame.query</code>.
Example:</p>
<pre><code>df = pandas.DataFrame({'foo': [1,2,15,17]})
y = 10
df &gt;&gt; query('foo &gt; @y') # plydata
df.query('foo &gt; @y') # pandas
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It indicates that you are using a decorator. Here is <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240808" rel="nofollow">Bruce Eckel's example</a> from 2008.</p>
</div>
<div class="post-text" itemprop="text">
<p>To say what others have in a different way:  yes, it is a decorator.</p>
<p>In Python, it's like:</p>
<ol>
<li>Creating a function (follows under the @ call)</li>
<li>Calling another function to operate on your created function.  This returns a new function.  The function that you call is the argument of the @.</li>
<li>Replacing the function defined with the new function returned.</li>
</ol>
<p>This can be used for all kinds of useful things, made possible because functions are objects and just necessary just instructions.</p>
</div>
<span class="comment-copy">It looks like it can also be a matrix multiplication operator as well: <a href="https://stackoverflow.com/a/21563036/5049813">stackoverflow.com/a/21563036/5049813</a></span>
<span class="comment-copy">In the case Flasks's <code>app.route("/")</code>:  this function returns a function, which you invoke with your <code>hello()</code> as an argument</span>
<span class="comment-copy">You also have the <code>@=</code> (in-place) operator, which is <code>__imatmul__</code>.</span>
