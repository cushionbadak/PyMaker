<div class="post-text" itemprop="text">
<p>I'm trying to learn how to use the thread module. I followed along with the instructions here: <a href="http://effbot.org/zone/tkinter-threads.htm" rel="nofollow">http://effbot.org/zone/tkinter-threads.htm</a></p>
<p>My hope is the test script will:</p>
<ol>
<li>Print out the "count" every two seconds</li>
<li>Show a pop-up dialog window (also every 2 seconds)</li>
<li>The pop-ups should be allowed to accumulate (if I don't click "OK" for a while, there should be
multiple pop-ups)</li>
</ol>
<p>However, when I run this script it will freeze the main window and after a while crash. I think I'm not implementing the thread module correctly.</p>
<p>Could someone please have a look and point out what I'm doing wrong?</p>
<p>Here is what I've tried so far:</p>
<pre><code>from Tkinter import *
import thread
import Queue
import time

class TestApp:
    def __init__(self, parent):
        self.super_Parent = parent
        self.main_container = Frame(parent)
        self.main_container.pack()
        self.top_frame = Frame(self.main_container)
        self.top_frame.pack(side=TOP)
        self.bottom_frame = Frame(self.main_container)
        self.bottom_frame.pack(side=TOP)
        self.text_box = Text(self.top_frame)
        self.text_box.config(height=20, width=20)
        self.text_box.pack()
        self.queue = Queue.Queue()
        self.update_me()

    def show_popup(self):
        self.my_popup = Toplevel(self.main_container)
        self.my_popup.geometry('100x100')
        self.popup_label = Label(self.my_popup, text="Hello!")
        self.popup_label.pack(side=TOP)
        self.pop_button = Button(self.my_popup, text="OK", command=self.my_popup.destroy)
        self.pop_button.pack(side=TOP)

    def write(self, line):
        self.queue.put(line)

    def update_me(self):
        try:
            while 1:
                line = self.queue.get_nowait()
                if line is None:
                    self.text_box.delete(1.0, END)
                else:
                    self.text_box.insert(END, str(line))
                self.text_box.see(END)
                self.text_box.update_idletasks()
        except Queue.Empty:
            pass
        self.text_box.after(100, self.update_me)

def pipeToWidget(input, widget):
    widget.write(input)

def start_thread():
    thread.start_new(start_test, (widget,))

def start_test(widget):
    count = 0
    while True:
        pipeToWidget(str(count) + "\n", widget)
        count += 1
        time.sleep(2)
        widget.show_popup()

root = Tk()
widget = TestApp(root)
start_button = Button(widget.bottom_frame, command=start_thread)
start_button.configure(text="Start Test")
start_button.pack(side=LEFT)
root.title("Testing Thread Module")
root.mainloop()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I can't reproduce your problem, but I can see why it would happen.</p>
<p>You're using the <code>queue</code> to pass messages from the background thread to the main thread for updating <code>text_box</code>, which is correct. But you're also calling <code>widget.show_popup()</code> from the background thread, which means it creates and displays a new <code>Toplevel</code> in the background thread. That's <em>not</em> correct.</p>
<p>All UI code must run in the same thread—not all UI code for each top-level window, all UI code <em>period</em>. On some platforms, you may get away with running each window in its own thread (or even free-threading everything), but that isn't <em>supposed</em> to work, and definitely will crash or do improper things on some platforms. (Also, that single UI thread has to be the initial thread on some platforms, but that isn't relevant here.)</p>
<hr/>
<p>So, to fix this, you need to do the same dance for creating the popups that you do for updating the textbox.</p>
<p>The obvious way to do that is to move the <code>widget.show_popup()</code> to the loop in <code>update_me()</code>. If you want it to happen 2 seconds after the textbox updates, just add <code>self.top_frame.after(2000, self.show_popup)</code> to the method.</p>
<p>But I'm guessing you're trying to teach yourself how to have multiple independent updating mechanisms, so telling you "just use a single update queue for everything" may not be a good answer. In that case, just create two queues, and a separate update method servicing each queue. Then, do your <code>pipeToWidget</code>, sleep 2 seconds, then <code>pipeToPopup</code>.</p>
<hr/>
<p>Another way around this is to use <a href="http://tkinter.unpythonic.net/wiki/mtTkinter" rel="nofollow"><code>mtTkinter</code></a>. It basically does exactly what you're doing, but makes it automatic, pushing each actual Tk GUI call onto a queue to be run later by the main loop. Of course your objects themselves have to be thread-safe, and this also means that you have to deal with the GUI calls from one thread getting interleaved with calls from another thread. But as long as neither of those is a problem (and they don't seem to be in your case), it's like magic.</p>
<hr/>
<p>If you want to know <em>why</em> this is freezing and/or crashing for you on Win7 and not for me on OS X 10.8… well, you really need to look into a mess of Tcl, C, and Python code, and also at how each thing is built. And, unless it's something simple (like your Tk build isn't free-threaded), it wouldn't tell you much anyway. The code isn't supposed to work, and if it seems to work for me… that probably just means it would work every time until the most important demo of my career, at which point it would fail.</p>
</div>
<span class="comment-copy">First, as the <a href="http://docs.python.org/2/library/thread.html" rel="nofollow noreferrer"><code>thread</code></a> docs say repeatedly, the <a href="http://docs.python.org/3/library/thread.html" rel="nofollow noreferrer"><code>threading</code></a> module "provides an easier to use and higher-level API", and you should strongly consider using it instead.</span>
<span class="comment-copy">Meanwhile… are you sure this is exactly the code you're running? When I run it (OS X 10.8.3 with 64-bit Apple Python 2.7.2), it seems to work exactly as described, no freezing or crashing.</span>
<span class="comment-copy">@abarnert Okay, I'll read up on threading. Also, yes I'm running the exact code on Win 7 Python 2.7.3</span>
<span class="comment-copy">Yep, I'm trying to wrap my head around thread(ing) which is a new concept for me. Thanks for your explanation. Moving it to the loop in update_me() made it work. :)</span>
<span class="comment-copy">Cool. I will take a look at mtTkinter as well. Thanks again.</span>
<span class="comment-copy">@DirtyPenguin: If you're not sure which thread each piece of code is running in, there's a simple way to check: give each new <code>threading.Thread</code> a name at construction time, and add a line to print out <code>threading.current_thread().name</code> and what you're about to call, before each Tk call. Then you'll see "Background: About to call Toplevel()`, and you'll know that for whatever reason you're doing it from the wrong thread.</span>
