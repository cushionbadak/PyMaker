<div class="post-text" itemprop="text">
<p>Is there a package or language construct in R that facilitates or provides the implementation of "<a href="http://docs.python.org/3/tutorial/classes.html#generators" rel="noreferrer">Python-like generators</a>"?</p>
<p>By "Python-like generators" I mean functions that keep state between calls, in R syntax and borrowing the keyword <strong>yield</strong> from Python will be something like:</p>
<pre><code>iterable.fun &lt;- function(){
  yield list('a','b','c')
}
</code></pre>
<p>With <strong>yield</strong> instead of a <strong>return</strong>, then calling the function three consecutive times would give:</p>
<pre><code>&gt; iterable.fun()
  'a'
&gt; iterable.fun()
  'b'
&gt; iterable.fun()
  'c'
</code></pre>
<p>Edit: I left out an aspect of Python generators that makes them different from iterators. It is that the whole list of objects to iterate on is not built on the first call and then iterated, but each function call creates the one element that will return for that call.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>iterators</code> package has this functionality</p>
<pre><code>library(iterators)
abc &lt;- iter(c('a','b','c'))
nextElem(abc)
## [1] "a"
nextElem(abc)
## [1] "b"
nextElem(abc)
## [1] "c"
</code></pre>
<p>Or you could use <code>lambda.r</code> and <code>&lt;&lt;-</code>. This example is modified from</p>
<p><a href="http://cartesianfaith.wordpress.com/2013/01/05/infinite-generators-in-r/">http://cartesianfaith.wordpress.com/2013/01/05/infinite-generators-in-r/</a></p>
<p>there are more examples in the blog post</p>
<pre><code>library(lambda.r)
seq.gen(start) %as% {
  value &lt;- start - 1L
  function() {
    value &lt;&lt;- value + 1L
    return(value)
  }
}



foo &lt;- seq.gen(1)
foo()
## [1] 1
foo()
## [1] 2
foo()
## [1] 3
</code></pre>
<p>note that you could also use a regular function to do this.</p>
<pre><code>seq.gen &lt;-function(start) {
  value &lt;- start - 1L
  function() {
    value &lt;&lt;- value + 1L
    return(value)
  }
}
foo2 &lt;- seq.gen(1)
foo2()
## [1] 1
foo2()
## [1] 2
foo2()
## [1] 3
</code></pre>
<p>If you want to select from a possible list, then you could perhaps do so using <code>switch</code></p>
<pre><code>seq.char(start) %as% {
  value &lt;- start - 1L
  function() {
    value &lt;&lt;- value + 1L
    return(switch(value,'a','b','c'))
  }
}

foo.char &lt;- seq.char(1)
 foo.char()
## [1] "a"
 foo.char()
## [1] "b"
 foo.char()
## [1] "c"
</code></pre>
</div>
<span class="comment-copy">R tries to be a functional language.  This request can only be fulfilled by a non-functional approach.  You can subvert the functionality with <code>&lt;&lt;-</code> if necessary, but it's probably better to think of what you want as an end result, and find a functional solution.</span>
<span class="comment-copy">Similar question: <a href="http://stackoverflow.com/questions/23509381/lazy-sequences-in-r">stackoverflow.com/questions/23509381/lazy-sequences-in-r</a></span>
<span class="comment-copy">Also, Luke Tierney wrote up a <a href="http://homepage.cs.uiowa.edu/~luke/R/lazy/lazy.pdf" rel="nofollow noreferrer">Lazy List Implementation</a>.</span>
<span class="comment-copy">Thanks for your answer, unfortunately an iterator is not what I was talking about and I think I didn't make it clear for those unfamiliar with Python generator functions.</span>
<span class="comment-copy">@papirrin -- see my edit.</span>
<span class="comment-copy">Nice edit, it even answer the questions I didn't do.</span>
