<div class="post-text" itemprop="text">
<p>I am trying to use <a href="http://www.voidspace.org.uk/python/mock" rel="noreferrer">Pythons mock package</a> to mock Pythons <code>requests</code> module. What are the basic calls to get me working in below scenario?</p>
<p>In my views.py, I have a function that makes variety of requests.get() calls with different response each time</p>
<pre><code>def myview(request):
  res1 = requests.get('aurl')
  res2 = request.get('burl')
  res3 = request.get('curl')
</code></pre>
<p>In my test class I want to do something like this but cannot figure out exact method calls</p>
<p>Step 1:</p>
<pre><code># Mock the requests module
# when mockedRequests.get('aurl') is called then return 'a response'
# when mockedRequests.get('burl') is called then return 'b response'
# when mockedRequests.get('curl') is called then return 'c response'
</code></pre>
<p>Step 2:</p>
<p>Call my view</p>
<p>Step 3: </p>
<p>verify response contains 'a response', 'b response' , 'c response'</p>
<p>How can I complete Step 1 (mocking the requests module)?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is how you can do it (you can run this file as-is):</p>
<pre><code>import requests
import unittest
from unittest import mock

# This is the class we want to test
class MyGreatClass:
    def fetch_json(self, url):
        response = requests.get(url)
        return response.json()

# This method will be used by the mock to replace requests.get
def mocked_requests_get(*args, **kwargs):
    class MockResponse:
        def __init__(self, json_data, status_code):
            self.json_data = json_data
            self.status_code = status_code

        def json(self):
            return self.json_data

    if args[0] == 'http://someurl.com/test.json':
        return MockResponse({"key1": "value1"}, 200)
    elif args[0] == 'http://someotherurl.com/anothertest.json':
        return MockResponse({"key2": "value2"}, 200)

    return MockResponse(None, 404)

# Our test case class
class MyGreatClassTestCase(unittest.TestCase):

    # We patch 'requests.get' with our own method. The mock object is passed in to our test case method.
    @mock.patch('requests.get', side_effect=mocked_requests_get)
    def test_fetch(self, mock_get):
        # Assert requests.get calls
        mgc = MyGreatClass()
        json_data = mgc.fetch_json('http://someurl.com/test.json')
        self.assertEqual(json_data, {"key1": "value1"})
        json_data = mgc.fetch_json('http://someotherurl.com/anothertest.json')
        self.assertEqual(json_data, {"key2": "value2"})
        json_data = mgc.fetch_json('http://nonexistenturl.com/cantfindme.json')
        self.assertIsNone(json_data)

        # We can even assert that our mocked method was called with the right parameters
        self.assertIn(mock.call('http://someurl.com/test.json'), mock_get.call_args_list)
        self.assertIn(mock.call('http://someotherurl.com/anothertest.json'), mock_get.call_args_list)

        self.assertEqual(len(mock_get.call_args_list), 3)

if __name__ == '__main__':
    unittest.main()
</code></pre>
<p><strong>Important Note:</strong> If your <code>MyGreatClass</code> class lives in a different package, say <code>my.great.package</code>, you have to mock <code>my.great.package.requests.get</code> instead of just 'request.get'. In that case your test case would look like this:</p>
<pre><code>import unittest
from unittest import mock
from my.great.package import MyGreatClass

# This method will be used by the mock to replace requests.get
def mocked_requests_get(*args, **kwargs):
    # Same as above


class MyGreatClassTestCase(unittest.TestCase):

    # Now we must patch 'my.great.package.requests.get'
    @mock.patch('my.great.package.requests.get', side_effect=mocked_requests_get)
    def test_fetch(self, mock_get):
        # Same as above

if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>Enjoy!</p>
</div>
<div class="post-text" itemprop="text">
<p>Try using the <a href="https://github.com/getsentry/responses" rel="noreferrer">responses library</a>:</p>
<pre><code>import responses
import requests

@responses.activate
def test_simple():
    responses.add(responses.GET, 'http://twitter.com/api/1/foobar',
                  json={'error': 'not found'}, status=404)

    resp = requests.get('http://twitter.com/api/1/foobar')

    assert resp.json() == {"error": "not found"}

    assert len(responses.calls) == 1
    assert responses.calls[0].request.url == 'http://twitter.com/api/1/foobar'
    assert responses.calls[0].response.text == '{"error": "not found"}'
</code></pre>
<p>provides quite a nice convenience over setting up all the mocking yourself</p>
<p>There's also <a href="https://github.com/gabrielfalcao/HTTPretty" rel="noreferrer">HTTPretty</a>:</p>
<p>it's not specific to <code>requests</code> library, more powerful in some ways though I found it doesn't lend itself so well to inspecting the requests that it intercepted, which <code>responses</code> does quite easily</p>
<p>and <a href="https://github.com/patrys/httmock" rel="noreferrer">httmock</a>:</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is what worked for me:</p>
<pre><code>import mock
@mock.patch('requests.get', mock.Mock(side_effect = lambda k:{'aurl': 'a response', 'burl' : 'b response'}.get(k, 'unhandled request %s'%k)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I used <a href="http://requests-mock.readthedocs.org/en/latest/matching.html#simple">requests-mock</a> for writing tests for separate module:</p>
<pre><code># module.py
import requests

class A():

    def get_response(self, url):
        response = requests.get(url)
        return response.text
</code></pre>
<p>And the tests:</p>
<pre><code># tests.py
import requests_mock
import unittest

from module import A


class TestAPI(unittest.TestCase):

    @requests_mock.mock()
    def test_get_response(self, m):
        a = A()
        m.get('http://aurl.com', text='a response')
        self.assertEqual(a.get_response('http://aurl.com'), 'a response')
        m.get('http://burl.com', text='b response')
        self.assertEqual(a.get_response('http://burl.com'), 'b response')
        m.get('http://curl.com', text='c response')
        self.assertEqual(a.get_response('http://curl.com'), 'c response')

if __name__ == '__main__':
    unittest.main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>this is how you mock requests.post, change it to your http method</p>
<pre><code>@patch.object(requests, 'post')
def your_test_method(self, mockpost):
    mockresponse = Mock()
    mockpost.return_value = mockresponse
    mockresponse.text = 'mock return'

    #call your target method now
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to mock a fake response, another way to do it is to simply instantiate an instance of the base HttpResponse class, like so:</p>
<pre><code>from django.http.response import HttpResponseBase

self.fake_response = HttpResponseBase()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One possible way to work around requests is using the library betamax, it records all requests and after that if you make a request in the same url with the same parameters the betamax will use the recorded request, I have been using it to test web crawler and it save me a lot time.</p>
<pre><code>import os

import requests
from betamax import Betamax
from betamax_serializers import pretty_json


WORKERS_DIR = os.path.dirname(os.path.abspath(__file__))
CASSETTES_DIR = os.path.join(WORKERS_DIR, u'resources', u'cassettes')
MATCH_REQUESTS_ON = [u'method', u'uri', u'path', u'query']

Betamax.register_serializer(pretty_json.PrettyJSONSerializer)
with Betamax.configure() as config:
    config.cassette_library_dir = CASSETTES_DIR
    config.default_cassette_options[u'serialize_with'] = u'prettyjson'
    config.default_cassette_options[u'match_requests_on'] = MATCH_REQUESTS_ON
    config.default_cassette_options[u'preserve_exact_body_bytes'] = True


class WorkerCertidaoTRT2:
    session = requests.session()

    def make_request(self, input_json):
        with Betamax(self.session) as vcr:
            vcr.use_cassette(u'google')
            response = session.get('http://www.google.com')
</code></pre>
<p><a href="https://betamax.readthedocs.io/en/latest/" rel="nofollow noreferrer">https://betamax.readthedocs.io/en/latest/</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Just a helpful hint to those that are still struggling, converting from urllib or urllib2/urllib3 to requests AND trying to mock a response- I was getting a slightly confusing error when implementing my mock:</p>
<p><code>with requests.get(path, auth=HTTPBasicAuth('user', 'pass'), verify=False) as url:</code></p>
<blockquote>
<p>AttributeError: __enter__</p>
</blockquote>
<p>Well, of course, if I knew anything about how <code>with</code> works (I didn't), I'd know it was a vestigial, unnecessary <a href="https://www.python.org/dev/peps/pep-0343/" rel="nofollow noreferrer">context</a> (from <a href="https://www.python.org/dev/peps/pep-0343/" rel="nofollow noreferrer">PEP 343</a>). Unnecessary when using the requests library because it does basically the same thing for you <a href="https://github.com/requests/requests/blob/5c1f72e80a7d7ac129631ea5b0c34c7876bc6ed7/requests/api.py#L59" rel="nofollow noreferrer">under the hood</a>. Just remove the <code>with</code> and use bare <code>requests.get(...)</code> and <a href="https://english.stackexchange.com/questions/20346/bobs-your-uncle-no-hes-not">Bob's your uncle</a>.</p>
</div>
<span class="comment-copy">check <a href="http://cramer.io/2014/05/20/mocking-requests-with-responses/" rel="nofollow noreferrer">David Cramer's blog article</a> on this topic</span>
<span class="comment-copy">The above comment's link doesn't work for me with the trailing slash, <a href="http://cramer.io/2014/05/20/mocking-requests-with-responses" rel="nofollow noreferrer">without it</a> works ok</span>
<span class="comment-copy">broken for me now</span>
<span class="comment-copy">yup broken. do you have another useful resource?</span>
<span class="comment-copy">Here's the working link  <a href="http://cra.mr/2014/05/20/mocking-requests-with-responses" rel="nofollow noreferrer">cra.mr/2014/05/20/mocking-requests-with-responses</a></span>
<span class="comment-copy">MockResponse class is a great idea! I was trying to fake a resuests.Response class object but it wasn't easy. I could use this MockResponse in place of the real thing. Thank you!</span>
<span class="comment-copy">And in Python 2.x, just replace <code>from unittest import mock</code> with <code>import mock</code> and the rest works as is. You do need to install the <code>mock</code> package separately.</span>
<span class="comment-copy">Fantastic. I had to make a slight change in Python 3 as <code>mock_requests_get</code> needed to <code>yield</code> instead of <code>return</code> because of the change to returning iterators in Python 3.</span>
<span class="comment-copy">that was what the question was originally asking about. I've figured out ways (pack the app into package and fixture a test_client() to do the call ). thanks for the post though, was still using the backbone of the code.</span>
<span class="comment-copy">Copied this and works wonderful. Changed the if-statements with a Pythonic switch-case instead though :)</span>
<span class="comment-copy">this is perfect</span>
<span class="comment-copy">At a glance, I didn't see a way for <code>responses</code> to match a wildcard url - that is, implement callback logic like "take the last part of the url, look it up in a Map, and return the corresponding value". Is that possible, and I'm just missing it?</span>
<span class="comment-copy">@scubbo you can pass a pre-compiled regex as the url param and use the callback style <a href="https://github.com/getsentry/responses#dynamic-responses" rel="nofollow noreferrer">github.com/getsentry/responses#dynamic-responses</a> this will give you the wildcard behaviour you want I think (can access the passed url on the <code>request</code> arg received by the callback func)</span>
<span class="comment-copy">That works, thank you! I'll submit a PR to include that in the documentation.</span>
<span class="comment-copy">This will work if you are expecting text/html responses. If you are mocking a REST API, want to check status code, etc. then the answer from Johannes[<a href="https://stackoverflow.com/a/28507806/3559967]">stackoverflow.com/a/28507806/3559967]</a> is probably the way to go.</span>
<span class="comment-copy">For Python 3, use <code>from unittest import mock</code>. <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer">docs.python.org/3/library/unittest.mock.html</a></span>
<span class="comment-copy">What if I want to mock a function?  How to mock this for example: mockresponse.json() = {"key": "value"}</span>
<span class="comment-copy">@primoz, I used an anonymous function/lambda for that: <code>mockresponse.json = lambda: {'key': 'value'}</code></span>
<span class="comment-copy">Or <code>mockresponse.json.return_value = {"key": "value"}</code></span>
<span class="comment-copy">Yes, but solves problem only in django framework.</span>
