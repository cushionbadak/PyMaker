<div class="post-text" itemprop="text">
<p>I have a script in Python 2.7 converted in executable with py2exe. The INPUT data is a text file where the delimiter need to be valid following this function:</p>
<pre><code># Check if delimeter is valid
def get_parse(filename, delimiters=['\t', ',', ' ', ':', ';', '-']):
    with open(filename) as f:
        f.next()
        secondline = f.next()
    for delimiter in delimiters:
        if len(secondline.rstrip().split(delimiter)) &gt;= 3:
            return delimiter
    raise Exception("couldn't find a delimiter that worked!")
</code></pre>
<p>When the delimiter is not valid (ex: a dot) i am looking for two solution in a Python elegant way:</p>
<ul>
<li>Until the right INPUT data is not load you can not pass to OUTFILE</li>
</ul>
<p>or</p>
<ul>
<li>The script break the code, show the error, but the windows (when is a
*.exe) doesn't close immediately leaving the user without an explanation</li>
</ul>
<hr/>
<pre><code>INPUT = raw_input("Input (*.txt): ")
while not os.path.exists(INPUT):
      print IOError("No such file or directory: %s" % INPUT)
      INPUT = raw_input("Input (*.txt): ")
try:
    parse = get_parse(INPUT)
except Exception:
    print ValueError("Delimiter type not valid")
    break
OUTPUT = raw_input("Output (*.txt): ")
</code></pre>
<p>with this solution (break) the Window of my *.exe file close leaving the user without an explanation</p>
</div>
<div class="post-text" itemprop="text">
<p>You are not really searching for a delimiter, just a character in a string. You should really use the CSV module for this.</p>
<pre><code>from __future__ import print_function

delimiters=['\t', ',', ' ', ':', ';', '-']

def getfile():
    fname =""
    while fname is "":
            fname = str.lower(raw_input("Input(*.txt): "))
            while fname.endswith(".txt") is not True:
                    print ("File must be .txt")
                    fname = str.lower(raw_input("Input(*.txt): "))
            if fname.endswith(".txt"):
                try:
                    with open(fname,'rb') as f:
                        parsed = False
                        while not parsed:
                            data = f.readline()
                            for d in delimiters:
                                if d in data:
                                    print ("Delimiter: {0} found".format(d))
                                    parsed = True
                                    # do your additional stuff here
                                else:
                                    print ("Unable to find delimiter {0}".format(d))
                                    parsed = True
                except IOError as e:
                    print( "Error: ", e)

getfile()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can hook the exception handler for uncaught exceptions using <a href="http://docs.python.org/library/sys.html#sys.excepthook" rel="nofollow noreferrer"><code>sys.excepthook</code></a>, and have it call <a href="http://docs.python.org/2/library/functions.html#raw_input" rel="nofollow noreferrer"><code>raw_input()</code></a> (or <a href="http://docs.python.org/3/library/functions.html#input" rel="nofollow noreferrer"><code>input()</code></a> in 3.x) as per <a href="https://stackoverflow.com/a/1000968/786020">this answer</a>.</p>
<p>For a quick example:</p>
<pre><code>import sys
def wait_on_uncaught_exception(type, value, traceback):
    print 'My Error Information'
    print 'Type:', type
    print 'Value:', value
    print 'Traceback:', traceback
    raw_input("Press any key to exit...")
sys.excepthook=wait_on_uncaught_exception
</code></pre>
<p>Just modify that to have whatever output or whatever you want (I suggest looking into the <a href="http://docs.python.org/2/library/traceback.html" rel="nofollow noreferrer"><code>traceback</code></a> module).</p>
<p>But if you want it more specific to your code, then just put <code>raw_input("Press any key to exit...")</code> in the solution you already have, and it should be fine. The above should provide a more general solution.</p>
</div>
<span class="comment-copy">Thanks Freakish, but the second time of INPUT you go to OUTPUT :)</span>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/1000900/how-to-keep-a-python-script-output-window-open">How to keep a Python script output window open?</a></span>
<span class="comment-copy">a possible solution is add: raw_input("press any key to exit")&lt;br/&gt; print "Exiting....."&lt;br/&gt; break</span>
<span class="comment-copy">That's not a possible solution to what you asked for: <code>"Until the right INPUT data is not load you can not pass to OUTFILE"</code> AND <code>"The script break the code, show the error, but the windows (when is a *.exe) doesn't close immediately leaving the user without an explanation"</code>. Yes, if all you wanted to do was keep the window open after the error occurred, a <code>raw_input('...')</code> would suffice, however you also asked that nothing happen unless the correct input file was loaded. With the code snippet I provided, nothing will happen until it has a file with the <code>txt</code> extension (which met your reqs).</span>
<span class="comment-copy">not bad. It's a good start point to work</span>
<span class="comment-copy">a possible solution is add:  raw_input("press any key to exit")&lt;br/&gt; print "Exiting....."&lt;br/&gt; break</span>
<span class="comment-copy">@Gianni - They'll never see that last <code>"Exiting....."</code> since <a href="http://stackoverflow.com/a/11365708/786020"><code>sys.excepthook</code> is only called when the whole stack is unwound and no exception handler was found, just before the program would exit.</a> It would print and quit too fast for the user to see, which was your original problem.</span>
<span class="comment-copy">Hey Poik thanks for your suggestion, I got the point. I think (from my software design point of view) it's important that the user understand  that the text file has a delimiter not valid. The text file is floating number and using "." as delimiter can be a problem. I want to avoid this/</span>
<span class="comment-copy">@Gianni - Right. I was just helping with the programmatic side. It's up to you to help your users. :3 If there's a specific point I missed, or something else I can help with, don't hesitate to ask.</span>
