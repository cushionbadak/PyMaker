<div class="post-text" itemprop="text">
<p>I have a numpy array of shape (6,2)</p>
<pre><code>[[00,01],
 [10,11],
 [20,21],
 [30,31],
 [40,41],
 [50,51]]
</code></pre>
<p>I need a sliding window with step size 1 and window size 3 likes this:</p>
<pre><code>[[00,01,10,11,20,21],
 [10,11,20,21,30,31],
 [20,21,30,31,40,41],
 [30,31,40,41,50,51]]
</code></pre>
<p>I'm looking for a numpy solution. If your solution could parametrize the the shape of the original array as well as the window size and step size, that'd great. </p>
<p>I found this related answer <a href="https://stackoverflow.com/questions/4936620/using-strides-for-an-efficient-moving-average-filter">Using strides for an efficient moving average filter</a> but I don't see how to specify the stepsize there and how to collapse the window from the 3d to a continuous 2d array. Also this <a href="https://stackoverflow.com/questions/6822725/rolling-or-sliding-window-iterator-in-python">Rolling or sliding window iterator in Python</a> but that's in Python and I'm not sure how efficient that is. Also, it supports elements but does not join them together in the end if each element has multiple features.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>In [1]: import numpy as np

In [2]: a = np.array([[00,01], [10,11], [20,21], [30,31], [40,41], [50,51]])

In [3]: w = np.hstack((a[:-2],a[1:-1],a[2:]))

In [4]: w
Out[4]: 
array([[ 0,  1, 10, 11, 20, 21],
       [10, 11, 20, 21, 30, 31],
       [20, 21, 30, 31, 40, 41],
       [30, 31, 40, 41, 50, 51]])
</code></pre>
<p>You could write this in as a function as so:</p>
<pre><code>def window_stack(a, stepsize=1, width=3):
    n = a.shape[0]
    return np.hstack( a[i:1+n+i-width:stepsize] for i in range(0,width) )
</code></pre>
<hr/>
<p>This doesn't really depend on the shape of the original array, as long as <code>a.ndim = 2</code>.  Note that I never use either lengths in the interactive version.  The second dimension of the shape is irrelevant; each row can be as long as you want.   Thanks to @Jaime's suggestion, you can do it without checking the shape at all:</p>
<pre><code>def window_stack(a, stepsize=1, width=3):
    return np.hstack( a[i:1+i-width or None:stepsize] for i in range(0,width) )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>You can do a vectorized sliding window in numpy using fancy indexing.</strong></p>
<pre><code>&gt;&gt;&gt; import numpy as np

&gt;&gt;&gt; a = np.array([[00,01], [10,11], [20,21], [30,31], [40,41], [50,51]])

&gt;&gt;&gt; a
array([[ 0,  1],
       [10, 11],
       [20, 21],                      #define our 2d numpy array
       [30, 31],
       [40, 41],
       [50, 51]])

&gt;&gt;&gt; a = a.flatten()

&gt;&gt;&gt; a
array([ 0,  1, 10, 11, 20, 21, 30, 31, 40, 41, 50, 51])    #flattened numpy array

&gt;&gt;&gt; indexer = np.arange(6)[None, :] + 2*np.arange(4)[:, None]

&gt;&gt;&gt; indexer
array([[ 0,  1,  2,  3,  4,  5],
       [ 2,  3,  4,  5,  6,  7],            #sliding window indices
       [ 4,  5,  6,  7,  8,  9],
       [ 6,  7,  8,  9, 10, 11]])

&gt;&gt;&gt; a[indexer]
array([[ 0,  1, 10, 11, 20, 21],
       [10, 11, 20, 21, 30, 31],            #values of a over sliding window
       [20, 21, 30, 31, 40, 41],
       [30, 31, 40, 41, 50, 51]])

&gt;&gt;&gt; np.sum(a[indexer], axis=1)
array([ 63, 123, 183, 243])         #sum of values in 'a' under the sliding window.
</code></pre>
<p><strong>Explanation for what this code is doing.</strong></p>
<p>The <code>np.arange(6)[None, :]</code> creates a row vector 0 through 6, and <code>np.arange(4)[:, None]</code> creates a column vector 0 through 4.  This results in a 4x6 matrix where each row (six of them) represents a window, and the number of rows (four of them) represents the number of windows.  The multiple of 2 makes the sliding window slide 2 units at a time which is necessary for sliding over each tuple.  Using numpy array slicing you can pass the sliding window into the flattened numpy array and do aggregates on them like sum.</p>
</div>
<div class="post-text" itemprop="text">
<p>The solution is </p>
<p><code>np.lib.stride_tricks.as_strided(a, shape=(4,6), strides=(8,4))</code>.</p>
<p>Using strides is intuitive when you start thinking in terms of pointers/addresses. </p>
<p>The <code>as_strided()</code> method has 3 arguments. </p>
<ol>
<li>data</li>
<li>shape</li>
<li>strides</li>
</ol>
<p><em>data</em> is the array on which we would operate.</p>
<p>To use <code>as_strided()</code> for implementing sliding window functions, we must compute the shape of the output beforehand. In the question, (4,6) is the shape of output. If the dimensions are not correct, we end up reading garbage values. This is because we are accessing data by moving the pointer by a couple of bytes (depending on data type).</p>
<p>Determining the correct value of <em>strides</em> is essential to get expected results.
Before calculating strides, find out the memory occupied by each element using <code>arr.strides[-1]</code>. In this example, the memory occupied by one element is 4 bytes.
Numpy arrays are created in row major fashion. The first element of the next row is right next to the last element of the current row.</p>
<p>Ex:
0 , 1 | 10, 11 | ...</p>
<p>10 is right next to 1. </p>
<p>Imagine the 2D array reshaped to 1D (This is acceptable as the data is stored in a row-major format). The first element of each row in the output is the odd indexed element in the 1D array.
0, 10, 20, 30, ..</p>
<p>Therefore, the number of steps in memory we need to take to move from 0 to 10, 10 to 20, and so on is <em>2 *  mem size of element</em>. Each row has a stride of 2 * 4bytes = 8.
For a given row in the output, all the elements are adjacent to each other in our imaginary 1D array. To get the next element in a row, just take one stride equal to the size of an element. The value of column stride is 4 bytes.</p>
<p>Therefore, <code>strides=(8,4)</code></p>
<p>An alternate explanation:
The output has a shape of (4,6). Column stride <code>4</code>. So, the first row elements start at index <code>0</code> and have 6 elements each spaced 4 bytes apart.
After the first row is collected, the second row starts 8 bytes away from the starting of the current row. The third row starts 8 bytes away from the starting point of the second row and so on.</p>
<p>Shape determines the number of rows and columns we need. strides define the memory steps to start a row and collect a column element</p>
</div>
<div class="post-text" itemprop="text">
<p>A short list comprehension is possible with <a href="https://more-itertools.readthedocs.io/en/latest/api.html" rel="nofollow noreferrer"><code>more_itertools.windowed</code></a><sup>1</sup>:</p>
<p><strong>Given</strong></p>
<pre><code>import numpy as np
import more_itertools as mit


a = [["00","01"],
     ["10","11"],
     ["20","21"],
     ["30","31"],
     ["40","41"],
     ["50","51"]]

b = np.array(a)
</code></pre>
<p><strong>Code</strong></p>
<pre><code>np.array([list(mit.flatten(w)) for w in mit.windowed(a, n=3)])
</code></pre>
<p>or</p>
<pre><code>np.array([[i for item in w for i in item] for w in mit.windowed(a, n=3)])
</code></pre>
<p>or</p>
<pre><code>np.array(list(mit.windowed(b.ravel(), n=6)))
</code></pre>
<p>Output</p>
<pre><code>array([['00', '01', '10', '11', '20', '21'],
       ['10', '11', '20', '21', '30', '31'],
       ['20', '21', '30', '31', '40', '41'],
       ['30', '31', '40', '41', '50', '51']], 
      dtype='&lt;U2')
</code></pre>
<p>Sliding windows of size <code>n=3</code> are created and flattened.  Note the default step size is <code>more_itertools.windowed(..., step=1)</code>.</p>
<hr/>
<p><strong>Performance</strong></p>
<p>As an array, the accepted answer is fastest.</p>
<pre><code>%timeit np.hstack((a[:-2], a[1:-1], a[2:]))
# 37.5 µs ± 1.88 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
%timeit np.hstack((b[:-2], b[1:-1], b[2:]))
# 12.9 µs ± 166 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)

%timeit np.array([list(mit.flatten(w)) for w in mit.windowed(a, n=3)])
# 23.2 µs ± 1.73 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
%timeit np.array([[i for item in w for i in item] for w in mit.windowed(a, n=3)])
# 21.2 µs ± 999 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)
%timeit np.array(list(mit.windowed(b.ravel(), n=6)))
# 43.4 µs ± 374 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)
</code></pre>
<p><sup><sub>A third-party library that implements <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">itertool recipes</a> and many helpful tools.</sub></sup></p>
</div>
<span class="comment-copy"><a href="https://gist.github.com/seberg/3866040" rel="nofollow noreferrer">gist.github.com/seberg/3866040</a>   Multidimensional rolling_window for numpy</span>
<span class="comment-copy">thanks. the function misses the last row though</span>
<span class="comment-copy">Fixed it.  I had the +1 in there but then removed it in another edit.  Added commentary related to that.</span>
<span class="comment-copy">It doesn't work with stepsize &gt; 1. Anyway, most people only need stepsize 1 so it's good enough. I just remove that as a parameter</span>
<span class="comment-copy">For the <code>[:-i]</code> not working thing, I have seen <code>[:-i or None]</code> used.</span>
<span class="comment-copy">exactly, my solution was to switch between <code>hstack</code> and <code>vstack</code>, I'll check your solution out!</span>
<span class="comment-copy">This should be the correct answer. I wish I could give you more upvotes.</span>
<span class="comment-copy">One could also write <code>indexer = np.arange(6).reshape(1, -1) + 2 * np.arange(4).reshape(-1, 1)</code> ... I found that more familiar than the <code>[None, :]</code> notation.</span>
<span class="comment-copy">Very good explanation of shape and strides. Thanks!</span>
<span class="comment-copy">Note that if you omit the 3rd argument, then the <code>strides</code> value is taken from the array you pass in as the first argument. That saves you having to figure this out yourself.</span>
