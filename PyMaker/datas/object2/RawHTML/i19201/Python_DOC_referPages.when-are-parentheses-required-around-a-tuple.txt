<div class="post-text" itemprop="text">
<p>Is there a reference somewhere defining precisely when enclosing tuples with parentheses is or is not required?  </p>
<p>Here is an example that surprised me recently:</p>
<pre><code>&gt;&gt;&gt; d = {}
&gt;&gt;&gt; d[0,] = 'potato'
&gt;&gt;&gt; if 0, in d:
  File "&lt;stdin&gt;", line 1
    if 0, in d:
        ^
SyntaxError: invalid syntax
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The combining of expressions to create a tuple using the comma token is termed an <a href="http://docs.python.org/3/reference/expressions.html#expression-lists"><code>expression_list</code></a>.  The rules of <a href="http://docs.python.org/3/reference/expressions.html#operator-precedence">operator precedence</a> do not cover expression lists; this is because expression lists are not themselves expressions; they become expressions when enclosed in parentheses.</p>
<p>So, an unenclosed <code>expression_list</code> is allowed anywhere in Python that it is specifically allowed by the language grammar, but <em>not</em> where an <code>expression</code> as such is required.</p>
<p>For example, the grammar of the <a href="http://docs.python.org/3/reference/compound_stmts.html#the-if-statement">if statement</a> is as follows:</p>
<pre><code>if_stmt ::=  "if" expression ":" suite
             ( "elif" expression ":" suite )*
             ["else" ":" suite]
</code></pre>
<p>Because the production <code>expression</code> is referenced, unenclosed <code>expression_list</code>s are not allowed as the subject of the <code>if</code> statement.  However, the <a href="http://docs.python.org/3/reference/compound_stmts.html#the-for-statement">for statement</a> accepts an <code>expression_list</code>:</p>
<pre><code>for_stmt ::=  "for" target_list "in" expression_list ":" suite
              ["else" ":" suite]
</code></pre>
<p>So the following is allowed:</p>
<pre><code>for x in 1, 2, 3:
    print(x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Anywhere you are allowed to use the <a href="http://docs.python.org/2/reference/expressions.html#expression-lists" rel="noreferrer"><code>expression_list</code></a> term, you do not need to use parenthesis.</p>
<p>The <a href="http://docs.python.org/2/reference/compound_stmts.html#the-if-statement" rel="noreferrer"><code>if</code> statement</a> requires an <code>expression</code>, and does not support an <code>expression_list</code>.</p>
<p>Examples of syntax that does allow <code>expression_list</code>:</p>
<ul>
<li>The <a href="http://docs.python.org/2/reference/simple_stmts.html#the-return-statement" rel="noreferrer"><code>return</code> statement</a></li>
<li><a href="http://docs.python.org/2/reference/expressions.html#yield-expressions" rel="noreferrer"><code>yield</code> expressions</a></li>
<li><a href="http://docs.python.org/2/reference/simple_stmts.html#assignment-statements" rel="noreferrer">assignment</a>
(including <a href="http://docs.python.org/2/reference/simple_stmts.html#augmented-assignment-statements" rel="noreferrer">augmented assignment</a>)</li>
<li>The <a href="http://docs.python.org/2/reference/compound_stmts.html#the-for-statement" rel="noreferrer"><code>for</code> statement</a>.</li>
</ul>
<p>Grepping the <a href="http://docs.python.org/2/reference/expressions.html" rel="noreferrer">Expressions</a>, <a href="http://docs.python.org/2/reference/simple_stmts.html" rel="noreferrer">Simple</a> and <a href="http://docs.python.org/2/reference/compound_stmts.html" rel="noreferrer">Compound statements</a> documentation for <code>expression_list</code> will tell you all locations that <code>expression_list</code> is used in the Python grammar.</p>
</div>
<div class="post-text" itemprop="text">
<p>Parentheses are also required when you want <strong>to avoid ambiguity</strong>.</p>
<p>The following are two different expressions... just because something is an 'expression list', doesn't result in the expression list you might expect :)</p>
<pre><code>(1, 2, 3) + (4, 5) # results in (1, 2, 3, 4, 5) because + does sequence.extend on the tuples
1, 2, 3 + 4, 5     # this results in (1, 2, 7, 5) because + adds the elements, since there were no parentheses to protect the separate tuples
</code></pre>
</div>
<span class="comment-copy">I find it especially interesting that <code>for k, in d: print k</code> does work in that case.</span>
<span class="comment-copy">The <a href="http://docs.python.org/2/reference/grammar.html" rel="nofollow noreferrer">Python grammar</a> will show you what <i>is</i> allowed, for example, in an <code>if</code> statement. You'd have to read over the full grammar to figure out where unparenthesized tuples are accepted, which is why I'm not posting this as an answer.</span>
<span class="comment-copy">...I fail to understand how you could have been <i>surprised</i> by the <code>for</code> failing with <code>0,</code>... python identifiers must start with a (unicode)letter or underscore and <code>0</code> is not a valid python identifier hence I would have <i>expected</i> a <code>SyntaxError</code> there.</span>
<span class="comment-copy">That's why David said <code>for k,</code> not <code>for 0,</code> (It works i.e. it successfully does tuple unpacking into <code>k</code> for the case where the dict keys are 1-element tuples)</span>
<span class="comment-copy">+1 That certainly explains why <code>for k, in d</code> works (because <code>for k, v in d</code> works).</span>
<span class="comment-copy">Question: Should you write it <code>for x in 1, 2, 3:</code> or <code>for x in (1, 2, 3):</code>? I've always written it the second way, but that was because I didn't know the first way was valid until just now when I tried. Now I'm wondering if the <code>()</code> are unnecessary noise, or if they somehow help in reading the code. Does PEP8 provide any guidance on this?</span>
<span class="comment-copy">@ArtOfWarfare there's no specific guidance in PEP8. It might help to compare with <code>if</code> statements, where parentheses are recommended only for a condition that spans multiple lines. So: <code>for x in (1, &lt;newline&gt; 2, &lt;newline&gt; 3):</code>.</span>
<span class="comment-copy">Oh yeah? How about <code>1,2,3 + 4,5</code>? It doesn't result in the expression list you might expect...</span>
<span class="comment-copy">@smci what has that got to do with my answer? What outcome did you expect?</span>
<span class="comment-copy">Because <code>1,2,3 + 4,5</code> results in the expression <code>1,2,7,5</code>, which is not what a casual reader would expect, and comes from overloading <code>+</code> for sequence append.</span>
<span class="comment-copy">@smci sorry, but <code>1, 2, 7, 5</code> is <i>exactly</i> what I'd expect. Each part between commas is an expression; the whole is an <code>expression_list</code>. There is no grammar rule that sums expression lists; instead <code>+</code> is part of one of the contained expressions (<code>3 + 4</code>). To add up two tuples, make two separate expressions by adding parentheses.</span>
<span class="comment-copy">Yes I know that. However, non-Python users or people who missed the lack of trailing comma would expect a concatenated tuple <code>1,2,3, + 4,5,</code> . What a difference the trailing comma makes.</span>
