<div class="post-text" itemprop="text">
<p>I've already looked at other threads on this, but most don't go into enough setup detail which is where I need help. </p>
<p>I have an Ubuntu based VPS running with nginx, serving PHP sites through php-cgi on port 9000. </p>
<p>I'd like to start doing more with Python, so I've written a deployment script which I essentially want to use as a post-receive hook on my local GitLab server as my first python script. I can run this script successfully by running <code>python script.py</code> on the command line but in order to use this as a post-receive hook I need it be able to access it via http. </p>
<p>I looked at <a href="http://wiki.nginx.org/PythonFlup" rel="nofollow">this guide</a> on the nginx wiki but partway down is says to:</p>
<blockquote>
<p>And start the django fastcgi process:</p>
<p><code>python ./manage.py runfcgi host=127.0.0.1 port=8080</code></p>
</blockquote>
<p>Now, like I said I am pretty new to python, and I have never used the Django framework. Can anyone assit on how I am supposed to start the fastcgi server?  Do I replace <code>./manage.py</code> with the name of my script? Any help would be appriciated as everything I've found online refers to working with Django. </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Do I replace ./manage.py with the name of my script?</p>
</blockquote>
<p>No. It's highly unlikely your script is a <em>FastCGI</em> server, or that it can accept HTTP requests of any kind since you mention running it over the command line. (From what little I know of <em>FastCGI</em>, an app supporting it has to be able to handle a stream of requests coming in over stdin in a specific format, so there's definitely some plumbing involved.)</p>
<p>I'd say the easiest approach would be to use <em>some</em> web framework just to act as HTTP/FastCGI middleware. For your use a "microframework" like <a href="http://flask.pocoo.org/docs/deploying/fastcgi/" rel="nofollow"><em>Flask</em></a> (or even <a href="http://pythonpaste.org/" rel="nofollow"><em>Paste</em></a> but I found the documentation inscrutable) sounds like it'd work fine. The idea would be to have two interfaces to your main code, one that can handle command line arguments, and one that can handle a HTTP request, ultimately both would just call one function that actually does the work. (If you want to keep the command-line version of the app.)</p>
<p>The Flask documentation also mentions <a href="http://flask.pocoo.org/docs/deploying/uwsgi/" rel="nofollow">using <em>uWSGI</em></a> or <a href="http://flask.pocoo.org/docs/deploying/wsgi-standalone/" rel="nofollow">standalone workers</a> as deployment options. I'm not familiar with the former; <strike>the latter I wouldn't recommend for a simple, low-traffic app for the same reasons as the approach in the next paragraph.</strike></p>
<p>Considering you use a VPS, you might even be able to just run the app as a standalone server process using <a href="http://docs.python.org/3/library/http.server.html" rel="nofollow">the <code>http.server</code> module</a><strike>, but I'm not sure that's the better choice unless you absolutely want to avoid using any sort of framework. You'd have to make sure the app starts up if the server is rebooted or that it restarts when it crashes and it seems easier to just have <em>nginx</em> do the job of the supervisor.</strike></p>
<p><strong>UPDATE:</strong> Scratch that, it seems that <em>nginx</em> won't handle supervising a <em>FastCGI</em> worker process for you, which would've been the main advantage of the approach. In light of that it doesn't matter which of the three approaches you use since you'll have to set up a service supervisor one way or the other. I'd say go with <em>uWSGI</em> since <em>flup</em> (which is needed for <em>Flask+FastCGI</em>) seems abandoned since 2011, and the <em>uWSGI</em> protocol is apparently supported in <em>nginx</em> natively. Otherwise you'd need to use a different webserver than nginx, one that will manage a FastCGI worker for you. If this is an option, I'd consider <a href="http://www.cherokee-project.com/" rel="nofollow"><em>Cherokee</em></a>, which can be configured using a web GUI.</p>
<p><strong>tl;dr:</strong> you need to write a (very simple) webapp. While it is feasible to do this without a web framework of any kind, in my opinion using one is easier, since you some (nontrivial) plumbing for free and there's a lot of guidance available on how to deploy them.</p>
</div>
<span class="comment-copy">@Vitaliy How can that <i>possibly</i> be relevant if the question is how to expose this code over HTTP?</span>
<span class="comment-copy">@Vitaliy I don't understand how that is relevant? It doesn't even use a database anyway.</span>
<span class="comment-copy">you should read the articles linked to in the answer to <a href="http://stackoverflow.com/questions/11216658/what-is-the-disadvantage-of-using-djangos-fastcgi-server" title="what is the disadvantage of using djangos fastcgi server">stackoverflow.com/questions/11216658/â€¦</a>  ;  tldr- cgi isn't really recommended for Python development, WSGI is the modern protocol.</span>
<span class="comment-copy">@JonathanVanasco Isn't WSGI mostly used as an abstract interface between an appserver like <i>paster</i> and <i>gunicorn</i> in a setup where you have Apache/nginx reverse-proxy to a bunch of worker processes? Direct support for it in "real" webservers isn't really a thing. If the OP already has a nginx server that he knows has FastCGI enabled and configured, there's nothing really wrong with going with it. (It doesn't seem like the WSGI module is standard in nginx, so it might not be available in their build, and <a href="http://wiki.nginx.org/NgxWSGIModule" rel="nofollow noreferrer">the documentation for it</a> looks scary.)</span>
<span class="comment-copy">WSGI is used as an abstract interface like that, but it also drives the design principles of things like Flask , Paste, web.py etc.  nginx ships with wsgi support through the uwsgi server.  there's nothing wrong with staying in CGI - it's just an old &amp; outdated method for web scripting.  if you're learning how to use python for web stuff, it makes more sense to learn the current technology than old stuff that people don't really use.  plus you get the benefits of middleware, local test servers (through whatever framework), and don't have to use the cgi module.</span>
<span class="comment-copy"><a href="http://webpy.org" rel="nofollow noreferrer">webpy.org</a> is an even smaller framework ;   to reiterate my comment to the question: when it comes to Python web development, CGI is deprecated and WSGI is the current recommended approach.</span>
<span class="comment-copy">@JonathanVanasco It'd be even better if you could provide an answer on how to wire up nginx with a WSGI app. I seriously doubt it's just a drop-in replacement, seeing as WSGI requires either switching to a proxy+workers architecture, or adding a third-party module to nginx. I'd argue that FastCGI is perfectly fine for an app of the OP's scope, and that the benefits of proxy+workers don't apply here. You're essentially sending the OP to do some yak-shaving just for the sake of avoiding CGI.</span>
<span class="comment-copy">@JonathanVanasco And for what it's worth, I don't see how FastCGI and WSGI are mutually exclusive technologies. FastCGI is an "on-the-wire" protocol that allows a "worker" Python process to be reused for multiple HTTP requests. WSGI is an abstract way of representing those HTTP requests on the Python side. If I understand the docs I linked to correctly, all <code>flup</code> does is that it parses FCGI requests and converts them to WSGI calls that any Python framework will understand. So the choice isn't FCGI vs. WSGI, it's FCGI vs. standalone HTTP workers vs. embedding Python in the front server.</span>
<span class="comment-copy">@JonathanVanasco In fact, the SO question you linked to says the very same thing. And links to a bunch of other questions that <i>also</i> say comparing the two is meaningless. They serve entirely different purposes in the architecture.</span>
<span class="comment-copy">Just what I was after, thanks everyone. I'll look at getting uWSGI installed now, I only started with Fast CGI as thats what I was using for PHP. I'm always up fro better solutions if their are any available.</span>
