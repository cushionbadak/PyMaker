<div class="post-text" itemprop="text">
<p>I'm writing a python program which upper-cases all input (a replacement for the non-working <code>tr '[:lowers:]' '[:upper:]'</code>). The locale is <code>ru_RU.UTF-8</code> and I use <code>PYTHONIOENCODING=UTF-8</code> to set the STDIN/STDOUT encodings. This correctly sets <code>sys.stdin.encoding</code>. <strong>So, why do I still need to explicitly create a decoding wrapper if <code>sys.stdin</code> already knows the encoding?</strong> If I don't create the wrapping reader, the <code>.upper()</code> function doesn't work correctly (does nothing for non-ASCII characters).</p>
<pre><code>import sys, codecs
sys.stdin = codecs.getreader(sys.stdin.encoding)(sys.stdin) #Why do I need this?
for line in sys.stdin:
    sys.stdout.write(line.upper())
</code></pre>
<p>Why does <code>stdin</code> have <code>.encoding</code> if it doesn't use it?</p>
</div>
<div class="post-text" itemprop="text">
<p>To answer "why", we need to understand Python 2.x's built-in <a href="http://docs.python.org/2/library/stdtypes.html#bltin-file-objects" rel="nofollow"><code>file</code></a> type, <a href="http://docs.python.org/2/library/stdtypes.html#file.encoding" rel="nofollow"><code>file.encoding</code></a>, and their relationship.</p>
<p>The built-in <code>file</code> object deals with raw bytes---always reads and writes raw bytes.</p>
<p>The <code>encoding</code> attribute describes the encoding of the raw bytes in the stream. This attribute may or may not be present, and may not even be reliable (e.g. we set <code>PYTHONIOENCODING</code> incorrectly in the case of standard streams).</p>
<p>The only time any automatic conversion is performed by <code>file</code> objects is when writing <code>unicode</code> object to that stream. In that case it will use the <code>file.encoding</code> if available to perform the conversion.</p>
<p>In the case of reading data, the file object will not do any conversion because it returns raw bytes. The <code>encoding</code> attribute in this case is a hint for the user to perform conversions manually.</p>
<p><code>file.encoding</code> is set in your case because you set the <code>PYTHONIOENCODING</code> variable and the <code>sys.stdin</code>'s <code>encoding</code> attribute was set accordingly. To get a text stream we have to wrap it manually as you have done in your example code.</p>
<p>To think about it another way, imagine that we didn't have a separate text type (like Python 2.x's <code>unicode</code> or Python 3's <code>str</code>). We can still work with text by using raw bytes, but keeping track of the encoding used. This is kind of how the <code>file.encoding</code> is meant to be used (to be used for tracking the encoding). The reader wrappers that we create automatically does the tracking and conversions for us.</p>
<p>Of course, automatically wrapping <code>sys.stdin</code> would be nicer (and that is what Python 3.x does), but changing the default behaviour of <code>sys.stdin</code> in Python 2.x will break backwards compatibility.</p>
<p>The following is a comparison of <code>sys.stdin</code> in Python 2.x and 3.x:</p>
<pre><code># Python 2.7.4
&gt;&gt;&gt; import sys
&gt;&gt;&gt; type(sys.stdin)
&lt;type 'file'&gt;
&gt;&gt;&gt; sys.stdin.encoding
'UTF-8'
&gt;&gt;&gt; w = sys.stdin.readline()
## ... type stuff - enter
&gt;&gt;&gt; type(w)
&lt;type 'str'&gt;           # In Python 2.x str is just raw bytes
&gt;&gt;&gt; import locale
&gt;&gt;&gt; locale.getdefaultlocale()
('en_US', 'UTF-8')
</code></pre>
<p>The <a href="https://docs.python.org/3/library/io.html#io.TextIOWrapper" rel="nofollow"><code>io.TextIOWrapper</code> class</a> is part of the standard library since Python 2.6. This class has an <code>encoding</code> attribute that is used to convert raw bytes to-and-from Unicode. </p>
<pre><code># Python 3.3.1
&gt;&gt;&gt; import sys
&gt;&gt;&gt; type(sys.stdin)
&lt;class '_io.TextIOWrapper'&gt;
&gt;&gt;&gt; sys.stdin.encoding
'UTF-8'
&gt;&gt;&gt; w = sys.stdin.readline()
## ... type stuff - enter
&gt;&gt;&gt; type(w)
&lt;class 'str'&gt;        # In Python 3.x str is Unicode
&gt;&gt;&gt; import locale
&gt;&gt;&gt; locale.getdefaultlocale()
('en_US', 'UTF-8')
</code></pre>
<p>The <code>buffer</code> attribute provides access to the raw byte stream backing <code>stdin</code>; this is usually a <code>BufferedReader</code>. Note below that it does <strong>not</strong> have an <code>encoding</code> attribute.</p>
<pre><code># Python 3.3.1 again
&gt;&gt;&gt; type(sys.stdin.buffer)
&lt;class '_io.BufferedReader'&gt;
&gt;&gt;&gt; w = sys.stdin.buffer.readline()
## ... type stuff - enter
&gt;&gt;&gt; type(w)
&lt;class 'bytes'&gt;      # bytes is (kind of) equivalent to Python 2 str
&gt;&gt;&gt; sys.stdin.buffer.encoding
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: '_io.BufferedReader' object has no attribute 'encoding'
</code></pre>
<p>In Python 3 the presence or absence of the <code>encoding</code> attribute is consistent with the type of stream used. </p>
</div>
<span class="comment-copy">What python version? try <code>line.decode(your_encoding).upper()</code></span>
<span class="comment-copy">@Ark-kun because Python2.x uses bytes for strings... So you need to convert to unicode (using decode) so "upper" can work beyond the ASCII range. Using Python3.x should not show this problem because all strings are unicode</span>
<span class="comment-copy">@JBernardo Data which is not used by the class methods shouldn't be in a class. It's as if <code>stdin</code> had a <code>.currentphaseofmoon</code> or <code>.numberoffilesondisk</code> property. My point is that this property does nothing (if this is the case) and is useless and confusing.  To compare, <code>.Net</code>'s <code>Stream</code> class (byte-based) doesn't have the <code>.Encoding</code> property - only the <code>StreamReader</code> has it.</span>
<span class="comment-copy">@Ark-kun The property by itself does nothing. But it is there because you may need if you want to convert the data to text. Just because you don't use something all the time or because it is not automatic, doesn't mean it is not useful. If the incoming data were binary and it tried to convert to unicode automatically, you would be much more pissed...</span>
<span class="comment-copy">Those are very different things. If the process is printing into a terminal, it will try to discover the encoding used by it -- and you can configure your terminal to use any encoding you want (Python gets that information, but <code>.Net</code>may not). The locale module uses system-wide information</span>
<span class="comment-copy">Thanks for the answer. It confirmed my belief that <code>Python 2</code>'s design was bad. Objects (unless they are simple data-storage-only structures) shouldn't contain data that they don't use. The <code>file</code> class shouldn't either use its <code>.encoding</code> property or remove it. This design flaw was fixed in <code>Python 3</code>. .Net handles this the same way: there are byte-based <code>Stream</code>s (you can only write bytes to them) and encoding-aware <code>TextReader</code>/<code>TextWriter</code>-derived wrapper classes. You can use <code>StreamReader.BaseStream</code> to gain access to the underlying bytes. <code>Console.In</code> is a <code>TextReader</code> (encoding-aware).</span>
<span class="comment-copy">Good to know that <code>Python 3</code> seems to have also got rid of the non-Unicode strings (though there are still things like <code>BufferedReader.readline()</code>).</span>
