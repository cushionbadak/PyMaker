<div class="post-text" itemprop="text">
<p>I have to open &amp; write to about 10 different files all within the same loop.
e.g:</p>
<pre><code>for i in range(0,10):
    try:
        a=5
        file1 = open("file1.txt",'w+')
        file2 = open("file2.txt",'w+')
        #... etc

        print(str(a),file=file1)
        print(str(a)+"hi",file=file2)
        # ... etc
    except: 
        #error handling
</code></pre>
<p>Now what I'd like to do is be able to get specific exception information such as what file was being opened/written to within the general exception. From my current understanding, I'd have to do something like this to achieve what I want:</p>
<pre><code>for i in range(0,5):
    a=5
    try:
        file1 = open("file1.txt",'w+')
        print(str(a),file=file1)
    except: 
        #error handling for file1
    try:
        file2 = open("file2.txt",'w+')
        print(str(a)+"hi",file=file2)
    except: 
        #error handling for file2
</code></pre>
<p>...Which is going to get extremely clunky and unattractive when I have to do this for about 10 different files. Is there any way to get (for example) the filename info out of a general exception like in my first example? Basically so the exception could report things like "error when writing to file1" without a try/except specifically for file1 operations.</p>
<p>edit: This is a massive over-simplification of the data being written to the file. str(a) and str(a)+"hi" are not really good representations of the data actually being written; file1 may need a hardcoded integer, where file2 may need a string formatted with multiple variables. to generalize the opening/writing process into a loop isn't going to work very nicely.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="http://docs.python.org/3/library/sys.html#sys.exc_info" rel="noreferrer"><code>sys.exc_info</code></a> to get information about the exception currently being handled, including the exception object itself. An <code>IOError</code> exception contains all of the information you need, including the filename, the errno, and a string describing the error:</p>
<pre><code>import sys

try:
    f1 = open('example1')
    f2 = open('example2')
except IOError:
    type, value, traceback = sys.exc_info()
    print('Error opening %s: %s' % (value.filename, value.strerror))
</code></pre>
<p>Execution in the <code>try</code> block will obviously still halt after the first exception.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="https://docs.python.org/2/library/traceback.html" rel="noreferrer" title="traceback">traceback</a> module:</p>
<pre><code>traceback.print_exc()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You mention using a loop, but you're not actually using a loop.  Use a loop.  That way you can write each file, one at a time, inside a single <code>try</code> block.  You don't appear to be doing anything with the files except write one value to each, so you don't need to keep them all open.</p>
<pre><code>for filename in ['file1.txt', 'file2.txt', ...]:
    try:
        with open(filename, 'w+') as f:
            f.write(str(a)+"whatever")
    except IOError:
        print("Error occurred with", filename)
</code></pre>
<p>Edit: If you have wildly different things to write to the different files, create a dictionary or other data structure ahead of time storing the mapping between files and data, then use that in the loop.</p>
<pre><code>data = {'file1.txt': str(a), 'file2.txt': 'something else', 'file3.txt': str(a)+str(b)}

for filename, output in data.items():
    try:
        with open(filename, 'w+') as f:
            f.write(output)
    except IOError:
        print("Error occurred with", filename)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When using <code>exc_type, value, exc_traceback = sys.exc_info()</code>, note that the filename that generated the exception can be obtained through the following: </p>
<pre><code>exc_traceback.tb_frame.f_locals.get('filename')
</code></pre>
</div>
<span class="comment-copy">I meant for the included code to be considered as though it was already in a loop. ill fix that.  But regardless this doesn't really solve my problem. The things being written to these files are not necessarily similar in any way, shape, or form. file1 might need a hard-coded "1" printed to it, file2 might need a variable printed to it, and file3 might need the multiple variables. what would end up happening is a giant if-statement within the "with"; e.g. "if filename=file1, write this; if filename=file2, write that; if filename=file3, write this other thing". Code will be just as clunky</span>
<span class="comment-copy">@user891876: See my edited answer.  Prearrange the relationship between files and data, then write each piece of data to its associated file in the loop.</span>
<span class="comment-copy">what if I don't want to print to file3 if length(str(a)+str(b))&gt;5?  each file needs definitely its own logic.</span>
<span class="comment-copy">@user891876: Then, in the precalculation, put the empty string as the value for <code>file3</code> in that case.  Or you could include a simple check in the loop for a "don't write" value like None, and put None in the precalculated values.  The point is that you can decide what you're going to write to every file before you begin to open any of the files.</span>
<span class="comment-copy">@user891876: More generally, the more complicated the logic is for deciding what to do with each file, the less you can avoid "clunky" code.  If you're trying to do 10 totally different sets of complicated operations to 10 files, that's not one operation, it's 10 operations, and you can't expect to be able to do them all at once.  As much as possible, though, you should do the clunky part before you open the files, because that will help to separate logic errors in creating the data (which are under your control) from I/O errors when writing the data (which may not be under your control).</span>
