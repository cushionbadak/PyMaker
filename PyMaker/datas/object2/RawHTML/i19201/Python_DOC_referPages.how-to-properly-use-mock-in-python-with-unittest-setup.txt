<div class="post-text" itemprop="text">
<p>In my attempt to learn TDD, trying to learn unit testing and using mock with python.  Slowly getting the hang of it, but unsure if I'm doing this correctly.  Forewarned: I'm stucking using python 2.4 because the vendor API's come as pre-compiled 2.4 pyc files, so I'm using mock 0.8.0 and unittest ( not unittest2 )</p>
<p>Given this example code in 'mymodule.py'</p>
<pre><code>import ldap

class MyCustomException(Exception):
    pass

class MyClass:
    def __init__(self, server, user, passwd):
        self.ldap = ldap.initialize(server)
        self.user = user
        self.passwd = passwd

    def connect(self):
        try:
            self.ldap.simple_bind_s(self.user, self.passwd)
        except ldap.INVALID_CREDENTIALS:
            # do some stuff
            raise MyCustomException
</code></pre>
<p>Now in my test case file 'test_myclass.py', I want to mock the ldap object out.  ldap.initialize returns the ldap.ldapobject.SimpleLDAPObject, so I figured that'd be the method I'd have to mock out.</p>
<pre><code>import unittest
from ldap import INVALID_CREDENTIALS
from mock import patch, MagicMock
from mymodule import MyClass

class LDAPConnTests(unittest.TestCase):
    @patch('ldap.initialize')
    def setUp(self, mock_obj):
        self.ldapserver = MyClass('myserver','myuser','mypass')
        self.mocked_inst = mock_obj.return_value

    def testRaisesMyCustomException(self):
        self.mocked_inst.simple_bind_s = MagicMock()
        # set our side effect to the ldap exception to raise
        self.mocked_inst.simple_bind_s.side_effect = INVALID_CREDENTIALS
        self.assertRaises(mymodule.MyCustomException, self.ldapserver.connect)

    def testMyNextTestCase(self):
        # blah blah
</code></pre>
<p>Leads me to a couple of questions:</p>
<ol>
<li>Does that look right? :)</li>
<li>Is that the proper way to try and mock an object that gets instantiated within the class I'm testing?</li>
<li>Is it ok to be calling the @patch decorator on setUp or is this going to cause weird side effects?</li>
<li>Is there anyway to get mock to raise the ldap.INVALID_CREDENTIALS exception without having to import the exception into my testcase file?</li>
<li>Should I be using patch.object() instead and if so, how?</li>
</ol>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>patch()</code> as a class decorator, not just as a function decorator. You can then pass in the mocked function as before:</p>
<pre><code>@patch('mymodule.SomeClass')
class MyTest(TestCase):

    def test_one(self, MockSomeClass):
        self.assertIs(mymodule.SomeClass, MockSomeClass)
</code></pre>
<p>See: <a href="https://docs.python.org/3.5/library/unittest.mock-examples.html#applying-the-same-patch-to-every-test-method" rel="noreferrer">26.5.3.4. Applying the same patch to every test method</a> (which also lists alternatives)</p>
<p>It makes more sense to set up the patcher this way on setUp if you want the patching to be done for all the test methods.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you have many patches to apply and you want them to apply to things initialised in the setUp methods too try this:</p>
<pre><code>def setUp(self):
    self.patches = {
        "sut.BaseTestRunner._acquire_slot": mock.Mock(),
        "sut.GetResource": mock.Mock(spec=GetResource),
        "sut.models": mock.Mock(spec=models),
        "sut.DbApi": make_db_api_mock()
    }

    self.applied_patches = [mock.patch(patch, data) for patch, data in self.patches.items()]
    [patch.apply for patch in self.applied_patches]
    .
    . rest of setup
    .


def tearDown(self):
    patch.stopall()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'll start by answering your questions, and then I'll give a detailed example of how <code>patch()</code> and <code>setUp()</code> interact.</p>
<ol>
<li>I don't think it looks right, see my answer to question #3 in this list for details.</li>
<li>Yes, the actual call to patch looks like it should mock the object you want.</li>
<li>No, you almost never want to use the <code>@patch()</code> decorator on <code>setUp()</code>. You got lucky, because the object is created in <code>setUp()</code> and never gets created during the test method.</li>
<li>I don't know of any way to make a mock object raise an exception without importing that exception into your test case file.</li>
<li>I don't see any need for <code>patch.object()</code> here. It just lets you patch attributes of an object instead of specifying the target as a string.</li>
</ol>
<p>To expand on my answer to question #3, the problem is that the <code>patch()</code> decorator only applies while the decorated function is running. As soon as <code>setUp()</code> returns, the patch is removed. In your case, that works, but I bet it would confuse someone looking at this test. If you really only want the patch to happen during <code>setUp()</code>, I would suggest using the <code>with</code> statement to make it obvious that the patch is going to be removed.</p>
<p>The following example has two test cases. <code>TestPatchAsDecorator</code> shows that decorating the class will apply the patch during the test method, but not during <code>setUp()</code>. <code>TestPatchInSetUp</code> shows how you can apply the patch so that it's in place during both <code>setUp()</code> and the test method. Calling <code>self.addCleanUp()</code> makes sure that the patch will be removed during <code>tearDown()</code>.</p>
<pre><code>import unittest
from mock import patch


@patch('__builtin__.sum', return_value=99)
class TestPatchAsDecorator(unittest.TestCase):
    def setUp(self):
        s = sum([1, 2, 3])

        self.assertEqual(6, s)

    def test_sum(self, mock_sum):
        s1 = sum([1, 2, 3])
        mock_sum.return_value = 42
        s2 = sum([1, 2, 3])

        self.assertEqual(99, s1)
        self.assertEqual(42, s2)


class TestPatchInSetUp(unittest.TestCase):
    def setUp(self):
        patcher = patch('__builtin__.sum', return_value=99)
        self.mock_sum = patcher.start()
        self.addCleanup(patcher.stop)

        s = sum([1, 2, 3])

        self.assertEqual(99, s)

    def test_sum(self):
        s1 = sum([1, 2, 3])
        self.mock_sum.return_value = 42
        s2 = sum([1, 2, 3])

        self.assertEqual(99, s1)
        self.assertEqual(42, s2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'd like to point out a variation of the accepted answer in which a <code>new</code> argument is passed to the <code>patch()</code> decorator:</p>
<pre><code>from unittest.mock import patch, Mock

MockSomeClass = Mock()

@patch('mymodule.SomeClass', new=MockSomeClass)
class MyTest(TestCase):
    def test_one(self):
        # Do your test here
</code></pre>
<p>Note that in this case, it is no longer necessary to add the second argument, <code>MockSomeClass</code>, to every test method, which can save a lot of code repetition.</p>
<p>An explanation of this can be found at <a href="https://docs.python.org/3/library/unittest.mock.html#patch" rel="nofollow noreferrer">https://docs.python.org/3/library/unittest.mock.html#patch</a>:</p>
<blockquote>
<p>If <code>patch()</code> is used as a decorator and <em>new</em> is omitted, the created mock is passed in as an extra argument to the decorated function. </p>
</blockquote>
<p>The answers above all omit <em>new</em>, but it can be convenient to include it.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can create a patched inner function and call it from <code>setUp</code>.</p>
<p>If your original <code>setUp</code> function is:</p>
<pre><code>def setUp(self):
    some_work()
</code></pre>
<p>Then you can patch it by changing it to:</p>
<pre><code>def setUp(self):
    @patch(...)
    def mocked_func():
        some_work()

    mocked_func()
</code></pre>
</div>
<span class="comment-copy">1-3) Seems fine to me...    4) <code>import ldap</code> instead and set <code>side_effect = ldap.INVALID_CREDENTIALS</code>?</span>
<span class="comment-copy">You can always make the same test but with simplier objects made by yourself...</span>
<span class="comment-copy">For the same thing for pre-Python3 Mock (hosted on <a href="http://www.voidspace.org.uk/python/mock/" rel="nofollow noreferrer">voidspace.org.uk/python/mock</a>), see <a href="http://www.voidspace.org.uk/python/mock/examples.html#applying-the-same-patch-to-every-test-method" rel="nofollow noreferrer">Applying the same patch to every test method</a>.</span>
<span class="comment-copy">I just ran into an issue where I had a class-level mock on a TestCase class and assumed it would already be in place when making a call in the <code>setUp()</code> method.  THIS IS NOT THE CASE; class-level mocks are not applied in time for use in <code>setUp()</code>.  I solved the issue by, instead, creating a helper method that I use within all my tests.  Not sure this is the best approach, but it works.</span>
<span class="comment-copy">@berto If you expand your comment in an Answer, I think it will be helpful. It's a different and probably easier solution than the others here.</span>
<span class="comment-copy">consider to use <code>patch.stop_all()</code> in <code>tearDown()</code>.</span>
<span class="comment-copy">I tried this - seems that the applied_patches also need to be started.  Consider a line like: <code>for patch in self.applied_patches: patch.start()</code></span>
<span class="comment-copy">It's <code>stopall</code>, not <code>stop_all</code>.</span>
<span class="comment-copy">In fairness - I'd now use the "self.addCleanup(patch)" method now. Time to update this answer.</span>
<span class="comment-copy"><code>self.addCleanup(patch.stopall)</code></span>
<span class="comment-copy">I think you'd like to give a hyperlink to the <i>answer #3</i> that you have mentioned since SO sorts the answers based on the points they receive.</span>
<span class="comment-copy">I see what you mean, @ErdinEray, but I was actually talking about my answer to <i>question</i> #3 by the OP.</span>
<span class="comment-copy">Thanks for this! This helps a lot especially when there are many mocked classes of functions where no special return value or similar is needed. Keeps the test case function definitions cleaner.</span>
