<div class="post-text" itemprop="text">
<p>I create a function which returns an value specified by an variable. Like</p>
<pre><code>y = 1.
def f(x):
    return y
</code></pre>
<p>I need this function as an function object to create another object</p>
<pre><code>dist = dist.distribution(f, other_variables)
</code></pre>
<p>this works fine. But if i want to create several different distribution objects (with different functions f in the sense that y changes) Like</p>
<pre><code>dist = dist.distribution(f, other_variables)
y = 2.
dist2 = dist.distribution(f, other_variables)
</code></pre>
<p>Then all distribution objects only return the last specified value y. I.e.</p>
<pre><code>dist.f()(1.)
&gt;&gt;&gt;&gt; 2.
dist2.f()(1.)
&gt;&gt;&gt;&gt; 2.
</code></pre>
<p>Instead of the expected</p>
<pre><code>dist.f()(1.)
&gt;&gt;&gt;&gt; 12.
dist2.f()(1.)
&gt;&gt;&gt;&gt; 2.
</code></pre>
<p>The problem clearly is, that the function f accesses the variable only when it is called and not one time initially. </p>
<p>Is there a way around it?
What I want at the end is:
A function with one variable only (x, although this doesnt do anything in this case, it is needed in others), which returns the value of y of the moment, when the distribution is created. So in principle I want that at the initialisation of the distribution, the given function is deepcopyed, in the sense, that it is no longer influenced by any change of variables.
Is this possible?</p>
</div>
<div class="post-text" itemprop="text">
<p>Don't use globals for this. There is no need to 'deepcopy' the function either; the <code>y</code> global is not part of the function state <em>at all</em>.</p>
<p>Use a function factory that provides a scoped value instead, or use a <code>functools.partial()</code> to provide a default argument to your function.</p>
<p>Function factory:</p>
<pre><code>def produce_f(y):
    def f(x):
        return y
    return f

dist = dist.distribution(produce_f(1.), other_variables)
</code></pre>
<p>Now <code>y</code> is a scoped value for <code>f</code>, <code>produce_f()</code> returns a <em>new</em> <code>f</code> every time it is called, and <code>y</code> is stored as a cell variable for <code>f</code>.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; f1 = produce_f(12.)
&gt;&gt;&gt; f2 = produce_f(42.)
&gt;&gt;&gt; f1('foo')
12.0
&gt;&gt;&gt; f2('foo')
42.0
</code></pre>
<p>Using <a href="http://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow"><code>functools.partial()</code></a>:</p>
<pre><code>from functools import partial

def f(y, x):
    return y

dist = dist.distribution(partial(f, 1.), other_variables)
</code></pre>
<p>Here <code>partial(f, 1.)</code> produces a new callable that will call <code>f(1., ...)</code> whenever called, appending any extra arguments passed in.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; f1 = partial(f, 12.)
&gt;&gt;&gt; f2 = partial(f, 42.)
&gt;&gt;&gt; f1('foo')
12.0
&gt;&gt;&gt; f2('foo')
42.0
</code></pre>
</div>
<span class="comment-copy">Cool the partial solution is exactly the answer I searched for... I tried the $produce_f(y)$ way but it didnt worked out. Maybe I had made a mistake in when exactly y was set and f was produced. Whaa this press-enter-to-post confuses me, sry for the edits^^</span>
<span class="comment-copy">Nope, not with these techniques it won't.</span>
<span class="comment-copy">Thank you for your promt answer, I'll try it tomorrow</span>
