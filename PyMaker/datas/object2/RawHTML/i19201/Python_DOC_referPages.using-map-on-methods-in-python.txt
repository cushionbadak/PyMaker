<div class="post-text" itemprop="text">
<p>I have some classes in Python:</p>
<pre><code>class Class1:
    def method(self):
        return 1
class Class2:
    def method(self):
        return 2
</code></pre>
<p>and a list <code>myList</code> whose elements are all either instances of <code>Class1</code> or <code>Class2</code>. I'd like to create a new list whose elements are the return values of <code>method</code> called on each element of <code>myList</code>. I have tried using a "virtual" base class</p>
<pre><code>class Class0:
    def method(self):
        return 0
class Class1(Class0):
    def method(self):
        return 1
class Class2(Class0):
    def method(self):
        return 2
</code></pre>
<p>But if I try <code>map(Class0.method, myList)</code> I just get <code>[0, 0, 0, ...]</code>. I'm a bit new to Python, and I hear that "duck typing" is preferred to actual inheritance, so maybe this is the wrong approach. Of course, I can do</p>
<pre><code>[myList[index].method() for index in xrange(len(myList))]
</code></pre>
<p>but I like the brevity of <code>map</code>. Is there a way to still use <code>map</code> for this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use</p>
<pre><code>map(lambda e: e.method(), myList)
</code></pre>
<p>But I think this is better:</p>
<pre><code>[e.method() for e in myList]
</code></pre>
<p>Â </p>
<p>PS.: I don't think there is <em>ever</em> a need for <code>range(len(collection))</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="http://docs.python.org/3/library/operator.html#operator.methodcaller" rel="nofollow">operator.methodcaller</a> tool is exactly what you're looking for:</p>
<pre><code>map(methodcaller("method"), myList)
</code></pre>
<p>Alternatively you can use a list comprehension:</p>
<pre><code>[obj.method() for obj in myList]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is best:</p>
<pre><code>[o.method() for o in myList]
</code></pre>
<p>Map seems to be favored by people pining for Haskell or Lisp, but Python has fine iterative structures you can use instead.</p>
</div>
<span class="comment-copy">I think I've run across a few cases where my choices were <code>range(len(collection))</code> or using an <code>enumerate</code> where I throw away the value portion...  But those cases are <i>extremely</i> rare and generally mean that the code needs to be re-factored anyway ...</span>
<span class="comment-copy">Whoops, forgot that you can just loop through the actual objects instead of getting them by index. I do like the <code>lambda</code> though, especially since my code is actually for a Scheme interpreter!</span>
<span class="comment-copy">This one is used a lot less than <code>attrgetter</code> or <code>itemgetter</code> but I like it.  +1 from me.</span>
<span class="comment-copy">Methodcaller is more interesting when you pass in arguments in addition to the method name:  <code>map(methodcaller('replace', 'big', 'huge'), sentences)</code>.</span>
<span class="comment-copy">Interesting. I've never seen <code>methodcaller</code> before.</span>
