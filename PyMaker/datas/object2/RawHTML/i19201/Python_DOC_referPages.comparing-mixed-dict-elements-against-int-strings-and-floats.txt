<div class="post-text" itemprop="text">
<p>I would like to be able to make comparisons in a mixed-type dictionary (containing int, floats, strings, numpy.arrays). My minimal example has a list of dictionaries and I would like a function (or generator) to iterate over that list and pick out the elements (dicts) that contain key-value pairs as specified by **kwargs input to that function (or generator).  </p>
<pre class="lang-py prettyprint-override"><code>import re
list_of_dicts = [{'s1':'abcd', 's2':'ABC', 'i':42, 'f':4.2},
                 {'s2':'xyz', 'i':84, 'f':8.4}]

def find_list_element(**kwargs):
    for s in list_of_dicts:
        for criterion, criterion_val in kwargs.iteritems():
            if type(criterion_val) is str:
                if re.match(criterion_val, s.get(criterion, 'unlikely_return_val')):
                    yield s
                    continue
            if s.get(criterion, None) == criterion_val:
                yield s

print [a for a in find_list_element(i=41)]       # []
print [a for a in find_list_element(i=42)]       # [{'i': 42, 's2': 'ABC', 's1': 'abcd', 'f': 4.2}]
print [a for a in find_list_element(s1='xyz')]   # []
print [a for a in find_list_element(s2='xyz')]   # [{'i': 84, 's2': 'xyz', 'f': 8.4}]
print [a for a in find_list_element(s2='[a-z]')] # [{'i': 84, 's2': 'xyz', 'f': 8.4}]
</code></pre>
<p>My two problems with the above are:</p>
<ol>
<li><p>If the function asks for a a comparison that is a string, I would like to switch to regex matching (re.search or re.match) instead of plain string comparison. In the above code this is accomplished through the reviled type checking and it doesn't look all that elegant. Are there better solutions not involving type checking? Or maybe, this is a case where type checking is allowed in python?</p></li>
<li><p><code>**kwargs</code> can of course contain more than one comparison. Currently I can only think of a solution involving some flags (<code>found = False</code> switched to a <code>found = True</code> and evaluated at the end of each iteration of <code>list_of_dicts</code>). Is there some clever way to accumulate the comparison results for each s before deciding on whether to yield it or not?</p></li>
</ol>
<p>Are there ways to make this whole walk through this collection of dicts prettier?</p>
<p>PS: The actual use case for this involves the representation of acquired MRI datasets (BRUKER). Datasets are characterized through parameter files that I have converted to dicts that are part of the objects representing said scans. I am collecting these datasets and would like to further filter them based on certain criteria given by these parameter files. These parameters can be strings, numbers and some other less handy types.</p>
<h2>UPDATE and Distilled Answer</h2>
<p>If I head to come up with a consensus answer derived from the input by @BrenBarn and @srgerg it would be this</p>
<pre><code>list_of_dicts = [{'s1':'abcd', 's2':'ABC', 'i':42, 'f':4.2},
                 {'s2':'xyz', 'i':84, 'f':8.4}]

 # just making up some comparison strategies
def regex_comp(a,b): return re.match(a,b)
def int_comp(a,b): return a==b
def float_comp(a,b): return round(a,-1) == round (b,-1)

pre_specified_comp_dict = {frozenset(['s1','s2']) : regex_comp,
                           frozenset(['i']): int_comp,
                           frozenset(['f']): float_comp}

def fle_new(**kwargs):
    chosen_comps={}
    for key in kwargs.keys():
        # remember, the keys here are frozensets
        cand_comp = [x for x in pre_specified_comp_dict if key in x]
        chosen_comps[key] = pre_specified_comp_dict[cand_comp[0]]

    matches = lambda d: all(k in d and chosen_comps[k](v, d[k])
                            for k, v in kwargs.items())

    return filter(matches, list_of_dicts)
</code></pre>
<p>Now the only challenge would be to come up with a pain-free strategy of creating <code>pre_specified_comp_dict</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>It seems okay to me to use type-checking in this situation, as you really do want totally different behavior depending on the type.  However, you should make your typecheck a bit smarter.  Use <code>if isinstance(criterion_val, basestring)</code> rather than a direct check for <code>str</code> type.  This way, it will still work for unicode strings.</p>
<p>The way to avoid typechecking would be to pre-specify the comparison type for each field.  Looking at your sample data, it looks like each field always has a consistent type (e.g., s1 is always a string).  If that's the case, you could create an explicit mapping between the field names and the type of comparison, something like:</p>
<pre><code>regex_fields = ['s1', 's2']
</code></pre>
<p>Then in your code, instead of the type check, do <code>if criterion in regex_fields</code> to see if the field is one that should be compared with a regex.  If you have more than just two types of comparison, you could use a dict mapping field names to some kind of ID for the comparison operation.</p>
<p>The advantage of this is that it encodes your assumptions more explicitly, so that if some weird data gets in (e.g., a string where you expect a number), an error will be raised instead of silently applying the type-appropriate comparison.  It also keeps the relationship between fields and comparisons "separate" rather than burying it in the middle of the actual comparison code.</p>
<p>This might especially be worth doing if you had a large number of fields with many different comparison operations for differnet subsets of them.  In that case, it might be better to predefine which comparisons apply to which field <em>names</em> (as opposed to which types), rather than deciding on-the-fly for each comparison.  As long as you always know based on the field name what type of comparison to do, this will keep things cleaner.  It does add maintenance overhead if you need to add a new field, though, so I probably wouldn't do it if this was just a script for a private audience.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's how I would implement your <code>find_list_element</code> function. It still uses The Reviled Type Checking (TM), but it looks a little more eloquent IMHO:</p>
<pre><code>def find_list_element(**kwargs):
    compare = lambda e, a: re.match(e, a) is not None if isinstance(e, str) else e == a
    matches = lambda d: all(k in d and compare(v, d[k]) for k, v in kwargs.items())
    return filter(matches, list_of_dicts)
</code></pre>
<p>(I'm using Python 3, by the way, though the code works in Python 2.7 but should use <code>basestring</code> rather than <code>str</code> as BrenBarn has already pointed out).</p>
<p>Note that I have used Python's <a href="http://docs.python.org/3/library/functions.html#all" rel="nofollow">all</a> function to avoid having to accumulate the comparison results.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can see my code below which solves the need for more than one comparisons:</p>
<pre><code>def find_dict(**kwargs):
    for data in lds: # lds is the same as list_of_dicts
        for key, val in kwargs.iteritems():
                 if not data.get(key, False) == val: return False
         else:
                 yield data
</code></pre>
<p>O/P:</p>
<pre><code>find_dict(i=42, s1='abcd')
{'i': 42, 's2': 'ABC', 's1': 'abcd', 'f': 4.2}
</code></pre>
<p>I have not included the code for regex comparision!</p>
<p>Cheers!</p>
</div>
<span class="comment-copy">Just out of curiosity, what is your use case for this function?</span>
<span class="comment-copy">@Blender: Question edited to comment on the use case</span>
<span class="comment-copy"><code>print list(find_list_element(i=42))</code> No need for a list comprehension there.</span>
<span class="comment-copy">If you find that your lookups are overwhelmingly of one type (strings, for instance), you could just assume that the argument is a string, but wrap the whole thing in a <code>try:... except TypeError:</code> block. You know, "ask forgiveness, not permission"</span>
<span class="comment-copy">I'd use a <code>set</code> for the <code>regex_fields</code> but otherwise, I concur.</span>
<span class="comment-copy">I like the pre-specification of the comparison code. A little tedious to set up initially since there are lots of fields but I should be able to create this list automatically and tweak by hand. Lovely. Thanks</span>
<span class="comment-copy">This looks compact and the accumulation of comparison results is tantalizing. Except, when I run your code, it returns all of `list_of_dicts'. Something I wasn't able to debug yet.</span>
<span class="comment-copy">Strange. It onyl returns the relevant elements of <code>list_of_dicts</code> for me. I've tried both Python 3.3 and 2.7.</span>
<span class="comment-copy">I double checked. Bizarre. Did you construct <code>list_of_dicts</code> differently?</span>
<span class="comment-copy">I copied your code to construct it.</span>
<span class="comment-copy">It gets stranger still: When I run it on the commandline it works as you say, in my IDE (spyder) it misbehaves when run in the current session but is OK when I open a new interpreter. Anyway, your code behaves as you promised and if married to @BrenBarn's idea of pre-specified comparison will do the deed quite nicely.</span>
<span class="comment-copy">SyntaxError: 'return' with argument inside generator. I don't think you can mix a <code>return False</code> with a <code>yield data</code>. Also, your indentation seems off.</span>
<span class="comment-copy">I have taken the liberty to edit your post (feel free to revert if you don't agree, preferably with a comment)</span>
<span class="comment-copy">Maybe, because in my original code I wrote <code>return data</code> but I later changed it here for your understanding. After all my main motive was to explain the logic.</span>
