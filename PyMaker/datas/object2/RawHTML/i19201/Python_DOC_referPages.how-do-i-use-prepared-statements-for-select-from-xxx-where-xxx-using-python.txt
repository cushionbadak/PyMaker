<div class="post-text" itemprop="text">
<p>I have use a dict to store the condition, the number of keys and value in not fixed, such as</p>
<pre><code>dict = {}
dict['v1'] = 'abc'
dict['v2'] = 123
...
dict['vn'] = xxx
</code></pre>
<p>My sql format is  </p>
<blockquote>
<p>select * from tablename where v1 = 'abc' and v2 = 123 and ... vn = xxx</p>
</blockquote>
<p>I have tried to turn the sql like this first:</p>
<blockquote>
<p>sql = "select * from tablename where v1 = %s and v2 = %s and ... vn = %s"</p>
</blockquote>
<p>The format below can avoid sql injection, the question is that I dont know the number of values, how to write this  prepared statements. Thanks in advance.</p>
<blockquote>
<p>cursor.execute(sql, dict[v1], dict[v2], ..., dict[vn])</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>The following should work:</p>
<pre><code>sql = 'select * from tablename where ' + ' and '.join(k + ' = %s' for k in data)
cursor.execute(sql, tuple(data.values()))
</code></pre>
<p>Make sure you don't make any modifications to the dict between creating the <code>sql</code> string and executing the statement, since the ordering could change if you do.</p>
<p>Note that I renamed your dict to <code>data</code>, you shouldn't use <code>dict</code> as a variable name because it will mask the built-in type.</p>
<p>I'm not completely sure if the conversion to a tuple is necessary.</p>
</div>
<div class="post-text" itemprop="text">
<p>Perhaps overkill, but you could use the excellent <a href="http://www.sqlalchemy.org/" rel="nofollow">SqlAlchemy</a> library:</p>
<pre><code>from sqlalchemy.sql import select
from sqlalchemy import create_engine, MetaData, Table
engine = create_engine('mysql://your_connection_string')
meta = MetaData()
table = Table('table_name', meta, autoload=True, autoload_with=engine)
s = select([table])
for key, val in dict.items():
   s = s.where(getattr(table.c, key)==val)
for row in conn.execute(s):
    print row
</code></pre>
<p>It may be worth it if you plan on doing a lot of SQL in your Python.</p>
<p><a href="http://docs.sqlalchemy.org/en/latest/core/tutorial.html" rel="nofollow">http://docs.sqlalchemy.org/en/latest/core/tutorial.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I would use something like following to paramerise the execute function:</p>
<pre><code>def print_test(sql, param1, param2, param3, param4, param5):
    # just output some of the parameters..
    print param2, param3

print_test("whatever", *(i for i in range(5)))
</code></pre>
<p>Above is a simple example to illustrate what is happening in the print_test function. I am assuming that you would like some kind of sorting, therefore an <a href="http://docs.python.org/3/library/collections.html?highlight=collections.ordereddict#collections.OrderedDict" rel="nofollow">OrderedDict</a> would be a good fit for you. Then, you can simply export the values and the order will be consistent. Cast them as a tuple and the execute function will unroll what it needs.</p>
</div>
<span class="comment-copy">It works, thx, :)</span>
<span class="comment-copy">watch out for the ordering in data.values() - it may look sorted but there are no guarantees</span>
