<div class="post-text" itemprop="text">
<p>I am trying to pass a list as an argument to a command line program. Is there an <a href="https://docs.python.org/3/library/argparse.html" rel="noreferrer"><code>argparse</code></a> option to pass a list as option?</p>
<pre><code>parser.add_argument('-l', '--list',
                      type=list, action='store',
                      dest='list',
                      help='&lt;Required&gt; Set flag',
                      required=True)
</code></pre>
<p>Script is called like below</p>
<pre><code>python test.py -l "265340 268738 270774 270817"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>TL;DR</strong></p>
<p>Use the <code>nargs</code> option or the <code>'append'</code> setting of the <code>action</code> option (depending on how you want the user interface to behave).</p>
<p><strong>nargs</strong></p>
<pre><code>parser.add_argument('-l','--list', nargs='+', help='&lt;Required&gt; Set flag', required=True)
# Use like:
# python arg.py -l 1234 2345 3456 4567
</code></pre>
<p><code>nargs='+'</code> takes 1 or more arguments, <code>nargs='*'</code> takes zero or more.</p>
<p><strong>append</strong></p>
<pre><code>parser.add_argument('-l','--list', action='append', help='&lt;Required&gt; Set flag', required=True)
# Use like:
# python arg.py -l 1234 -l 2345 -l 3456 -l 4567
</code></pre>
<p>With <code>append</code> you provide the option multiple times to build up the list.</p>
<p><strong>Don't use <code>type=list</code>!!!</strong> - There is probably no situation where you would want to use <code>type=list</code> with <code>argparse</code>. Ever.</p>
<hr/>
<p>Let's take a look in more detail at some of the different ways one might try to do this, and the end result.</p>
<pre><code>import argparse

parser = argparse.ArgumentParser()

# By default it will fail with multiple arguments.
parser.add_argument('--default')

# Telling the type to be a list will also fail for multiple arguments,
# but give incorrect results for a single argument.
parser.add_argument('--list-type', type=list)

# This will allow you to provide multiple arguments, but you will get
# a list of lists which is not desired.
parser.add_argument('--list-type-nargs', type=list, nargs='+')

# This is the correct way to handle accepting multiple arguments.
# '+' == 1 or more.
# '*' == 0 or more.
# '?' == 0 or 1.
# An int is an explicit number of arguments to accept.
parser.add_argument('--nargs', nargs='+')

# To make the input integers
parser.add_argument('--nargs-int-type', nargs='+', type=int)

# An alternate way to accept multiple inputs, but you must
# provide the flag once per input. Of course, you can use
# type=int here if you want.
parser.add_argument('--append-action', action='append')

# To show the results of the given option to screen.
for _, value in parser.parse_args()._get_kwargs():
    if value is not None:
        print(value)
</code></pre>
<p>Here is the output you can expect:</p>
<pre><code>$ python arg.py --default 1234 2345 3456 4567
...
arg.py: error: unrecognized arguments: 2345 3456 4567

$ python arg.py --list-type 1234 2345 3456 4567
...
arg.py: error: unrecognized arguments: 2345 3456 4567

$ # Quotes won't help here... 
$ python arg.py --list-type "1234 2345 3456 4567"
['1', '2', '3', '4', ' ', '2', '3', '4', '5', ' ', '3', '4', '5', '6', ' ', '4', '5', '6', '7']

$ python arg.py --list-type-nargs 1234 2345 3456 4567
[['1', '2', '3', '4'], ['2', '3', '4', '5'], ['3', '4', '5', '6'], ['4', '5', '6', '7']]

$ python arg.py --nargs 1234 2345 3456 4567
['1234', '2345', '3456', '4567']

$ python arg.py --nargs-int-type 1234 2345 3456 4567
[1234, 2345, 3456, 4567]

$ # Negative numbers are handled perfectly fine out of the box.
$ python arg.py --nargs-int-type -1234 2345 -3456 4567
[-1234, 2345, -3456, 4567]

$ python arg.py --append-action 1234 --append-action 2345 --append-action 3456 --append-action 4567
['1234', '2345', '3456', '4567']
</code></pre>
<p><em>Takeaways</em>:</p>
<ul>
<li>Use <code>nargs</code> or <code>action='append'</code>
<ul>
<li><code>nargs</code> can be more straightforward from a user perspective, but it can be unintuitive if there are positional arguments because <code>argparse</code> can't tell what should be a positional argument and what belongs to the <code>nargs</code>; if you have positional arguments then <code>action='append'</code> may end up being a better choice.</li>
<li>The above is only true if <code>nargs</code> is given <code>'*'</code>, <code>'+'</code>, or <code>'?'</code>. If you provide an integer number (such as <code>4</code>) then there will be no problem mixing options with <code>nargs</code> and positional arguments because <code>argparse</code> will know exactly how many values to expect for the option.</li>
</ul></li>
<li>Don't use quotes on the command line<sup>1</sup></li>
<li>Don't use <code>type=list</code>, as it will return a list of lists

<ul>
<li>This happens because under the hood <code>argparse</code> uses the value of <code>type</code> to coerce <em>each individual given argument</em> you your chosen <code>type</code>, not the aggregate of all arguments.</li>
<li>You can use <code>type=int</code> (or whatever) to get a list of ints (or whatever)</li>
</ul></li>
</ul>
<hr/>
<p><sup>1</sup>: I don't mean in general.. I mean using quotes to <em>pass a list to <code>argparse</code></em> is not what you want. </p>
</div>
<div class="post-text" itemprop="text">
<p>I prefer passing a delimited string which I parse later in the script. The reasons for this are; the list can be of any type <code>int</code> or <code>str</code>, and sometimes using <code>nargs</code> I run into problems if there are multiple optional arguments and positional arguments.</p>
<pre><code>parser = ArgumentParser()
parser.add_argument('-l', '--list', help='delimited list input', type=str)
args = parser.parse_args()
my_list = [int(item) for item in args.list.split(',')]
</code></pre>
<p>Then,</p>
<pre><code>python test.py -l "265340,268738,270774,270817" [other arguments]
</code></pre>
<p>or,</p>
<pre><code>python test.py -l 265340,268738,270774,270817 [other arguments]
</code></pre>
<p>will work fine. The delimiter can be a space, too, which would though enforce quotes around the argument value like in the example in the question.</p>
</div>
<div class="post-text" itemprop="text">
<p>Additionally to <a href="http://docs.python.org/2/library/argparse.html#nargs" rel="noreferrer"><code>nargs</code></a>, you might want to use <a href="http://docs.python.org/2/library/argparse.html#choices" rel="noreferrer"><code>choices</code></a> if you know the list in advance:</p>
<pre><code>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='game.py')
&gt;&gt;&gt; parser.add_argument('move', choices=['rock', 'paper', 'scissors'])
&gt;&gt;&gt; parser.parse_args(['rock'])
Namespace(move='rock')
&gt;&gt;&gt; parser.parse_args(['fire'])
usage: game.py [-h] {rock,paper,scissors}
game.py: error: argument move: invalid choice: 'fire' (choose from 'rock',
'paper', 'scissors')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are intending to make a single switch take multiple parameters, then you use <code>nargs='+'</code>. If your example '-l' is actually taking integers:</p>
<pre><code>a = argparse.ArgumentParser()
a.add_argument(
    '-l', '--list',  # either of this switches
    nargs='+',       # one or more parameters to this switch
    type=int,        # /parameters/ are ints
    dest='list',     # store in 'list'.
    default=[],      # since we're not specifying required.
)

print a.parse_args("-l 123 234 345 456".split(' '))
print a.parse_args("-l 123 -l=234 -l345 --list 456".split(' '))
</code></pre>
<p>Produces</p>
<pre><code>Namespace(list=[123, 234, 345, 456])
Namespace(list=[456])  # Attention!
</code></pre>
<p>If you specify the same argument multiple times, the default action (<code>'store'</code>) replaces the existing data.</p>
<p>The alternative is to use the <code>append</code> action:</p>
<pre><code>a = argparse.ArgumentParser()
a.add_argument(
    '-l', '--list',  # either of this switches
    type=int,        # /parameters/ are ints
    dest='list',     # store in 'list'.
    default=[],      # since we're not specifying required.
    action='append', # add to the list instead of replacing it
)

print a.parse_args("-l 123 -l=234 -l345 --list 456".split(' '))
</code></pre>
<p>Which produces</p>
<pre><code>Namespace(list=[123, 234, 345, 456])
</code></pre>
<p>Or you can write a custom handler/action to parse comma-separated values so that you could do</p>
<pre><code>-l 123,234,345 -l 456
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In <code>add_argument()</code>, <code>type</code> is just a callable object that receives string and returns option value.</p>
<pre><code>import ast

def arg_as_list(s):                                                            
    v = ast.literal_eval(s)                                                    
    if type(v) is not list:                                                    
        raise argparse.ArgumentTypeError("Argument \"%s\" is not a list" % (s))
    return v                                                                   


def foo():
    parser.add_argument("--list", type=arg_as_list, default=[],
                        help="List of values")
</code></pre>
<p>This will allow to:</p>
<pre><code>$ ./tool --list "[1,2,3,4]"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <strong>nargs parameter</strong> in argparse's add_argument method</p>
<p>I use nargs='<em>' as an add_argument parameter. I specifically used nargs='</em>' to the option to pick defaults if I am not passing any explicit arguments</p>
<p>Including a code snippet as example:</p>
<p><strong>Example: temp_args1.py</strong></p>
<p><em>Please Note:</em> The below sample code is written in python3. By changing the print statement format, can run in python2</p>
<pre><code>    #!/usr/local/bin/python3.6

    from argparse import ArgumentParser

    description = 'testing for passing multiple arguments and to get list of args'
    parser = ArgumentParser(description=description)
    parser.add_argument('-i', '--item', action='store', dest='alist',
                        type=str, nargs='*', default=['item1', 'item2', 'item3'],
                        help="Examples: -i item1 item2, -i item3")
    opts = parser.parse_args()

    print("List of items: {}".format(opts.alist))
</code></pre>
<p>Note: I am collecting multiple string arguments that gets stored in the list - opts.alist
If you want list of integers, change the type parameter on parser.add_argument to int</p>
<p><strong>Execution Result:</strong></p>
<pre><code>    python3.6 temp_agrs1.py -i item5 item6 item7
    List of items: ['item5', 'item6', 'item7']

    python3.6 temp_agrs1.py -i item10
    List of items: ['item10']

    python3.6 temp_agrs1.py
    List of items: ['item1', 'item2', 'item3']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Maybe the simplest answer</p>
<pre><code>import argparse
parser = argparse.ArgumentParser()
parser.add_argument("-l", "--tolist", help="input to list", action="store_true")
parser.add_argument("newlist", type=str, help="generate a list")
args = parser.parse_args()
if args.tolist:
    print(args.newlist.split(" "))
</code></pre>
</div>
<span class="comment-copy">What about a list of strings? This turns multiple string arguments ("wassup", "something", and "else")into a list of lists that looks like this: [['w', 'a', 's', 's', 'u', 'p'], ['s', 'o', 'm', 'e', 't', 'h', 'i', 'n', 'g'], ['e', 'l', 's', 'e']]</span>
<span class="comment-copy">@rd108 I see, I bet that you are using the <code>type=list</code> option.  Don't use that.  That turns a string into a list, and hence the lists of lists.</span>
<span class="comment-copy">@Dror All input is assumed to be strings unless you set the <code>type</code> parameter to some other object. By default this method returns a list of strings.</span>
<span class="comment-copy">I feel like I answered the same question twice in these comments...</span>
<span class="comment-copy"><code>--</code> could split options vs. positional arguments. <code>prog --opt1 par1 ... -- posp1 posp2 ...</code></span>
<span class="comment-copy">You can set the <code>type</code> argument to <code>lambda s: [int(time) for item in s.split(',')]</code> instead of post-processing <code>args.list</code>.</span>
<span class="comment-copy">@chepner,yes you're absolutely right and it would be more pythonic - just a small typo: <code>int(time)</code> should be <code>int(item)</code>. My example was a simplified version of what I typically do, where I check many other things rather than a simple processing. But to simply answer the question, I too find your way more elegant..</span>
<span class="comment-copy">this answer looks to be the most pythonic</span>
<span class="comment-copy">The comment by @chepner is some serious ninja skillz +1</span>
<span class="comment-copy">Note that if one needed to pass strings, this method would require they quote them appropriately on the command line. A user may find this unexpected. If only parsing integers this is fine.</span>
<span class="comment-copy">@Py_minion Is there a way to use a list as an argument, and have the output as list as well?  <code>temp_args1.py -i [item5 ,item6, item7]</code> and have the output come out as a list as well (instead of nested list)</span>
<span class="comment-copy">@Moondra Yes. glad you asked.  ```     parser.add_argument('-o', '--options', action='store', dest='opt_list',                         type=str, nargs='*', default=sample_list,                         help="String of databases seperated by white space. Examples: \                               -o option1 option2, -o option3") ``` Here 'sample_list' is of type list with default options. Ex: sample_list = [option4, option5]</span>
<span class="comment-copy">@Py_minion  Thank you. Going to test it out later today.</span>
<span class="comment-copy">This assumes the user quotes the input with single spaces between each argument.</span>
<span class="comment-copy">python test.py -l "265340 268738 270774 270817"                                 There are single spaces in input string</span>
<span class="comment-copy">But if a user accidentally puts two spaces then this answer would result in an erroneous empty string in the result. What I am saying is that this answer takes complexity from the programmer and pushes it onto the user by forcing them to remember to add quotes and to ensure those spacing is correct.</span>
<span class="comment-copy">"But if a user accidentally puts two spaces then this answer would result in an erroneous empty string" The script is for the input like he asked for, the cases if he do different input is not the question.</span>
