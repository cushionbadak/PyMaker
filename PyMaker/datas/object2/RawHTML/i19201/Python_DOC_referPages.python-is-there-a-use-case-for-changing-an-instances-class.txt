<div class="post-text" itemprop="text">
<p>Related: <a href="https://stackoverflow.com/questions/2153295/python-object-conversion">Python object conversion</a></p>
<p>I recently learned that Python allows you to change an instance's class like so:</p>
<pre><code>class Robe:
    pass

class Dress:
    pass

r = Robe()
r.__class__ = Dress
</code></pre>
<p>I'm trying to figure out whether there is a case where 'transmuting' an object like this can be useful. I've messed around with this in IDLE, and one thing I've noticed is that assigning a different class doesn't call the new class's <code>__init__</code> method, though this can be done explicitly if needed.</p>
<p>Virtually every use case I can think of would be better served by composition, but I'm a coding newb so what do I know. ;)</p>
</div>
<div class="post-text" itemprop="text">
<p>There is rarely a good reason to do this for unrelated classes, like <code>Robe</code> and <code>Dress</code> in your example. Without a bit of work, it's hard to ensure that the object you get in the end is in a sane state.</p>
<p>However, it can be useful when inheriting from a base class, if you want to use a non-standard factory function or constructor to build the base object. Here's an example:</p>
<pre><code>class Base(object):
    pass

def base_factory():
    return Base()  # in real code, this would probably be something opaque

def Derived(Base):
    def __new__(cls):
        self = base_factory()     # get an instance of Base
        self.__class__ = Derived  # and turn it into an instance of Derived
        return self
</code></pre>
<p>In this example, the Derived class's <code>__new__</code> method wants to construct its object using the <code>base_factory</code> method which returns an instance of the <code>Base</code> class. Often this sort of factory is in a library somewhere, and you can't know for certain how it's making the object (you can't just call <code>Base()</code> or <code>super(Derived, cls).__new__(cls)</code> yourself to get the same result).</p>
<p>The instance's <code>__class__</code> attribute is rewritten so that the result of calling <code>Derived.__new__</code> will be an instance of the <code>Derived</code> class, which ensures that it will have the <code>Derived.__init__</code> method called on it (if such a method exists).</p>
</div>
<div class="post-text" itemprop="text">
<p>I remember using this technique ages ago to “upgrade” existing objects after recognizing what kind of data they hold. It was a part of an experimental XMPP client. XMPP uses many short XML messages (“stanzas”) for communication.</p>
<p>When the application received a stanza, it was parsed into a DOM tree. Then the application needed to recognize what kind of stanza it is (a presence stanza, message, automated query etc.). If, for example, it was recognized as a message stanza, the DOM object was “upgraded” to a subclass that provided methods like “get_author”, “get_body” etc.</p>
<p>I could of course just make a new class to represent a parsed message, make new object of that class and copy the relevant data from the original XML DOM object. There were two benefits of changing object's class in-place, though. Firstly, XMPP is a very extensible standard, and it was useful to still have an easy access to the original DOM object in case some other part of the code found something useful there, or while debugging. Secondly, profiling the code told me that creating a new object and explicitly copying data is much slower than just reusing the object that would be quickly destroyed anyway—the difference was enough to matter in XMPP, which uses many short messages.</p>
<p>I don't think any of these reasons justifies the use of this technique in production code, unless maybe you really need the (not that big) speedup in CPython. It's just a hack which I found useful to make code a bit shorter and faster in the experimental application. Note also that this technique will easily break JIT engines in non-CPython implementations, making the code much slower!</p>
</div>
<span class="comment-copy">This answer seems very thorough, but I'm new to programming and hence struggling to understand it. Ignoring the <code>__new__</code>/constructor aspect, I can see that if you have a class defined in a library somewhere, and you have created your own class that inherits it, then you can create an instance of the latter by creating an instance of the former and then 'transmuting'. However, why not simply instantiate the inherited class? I admit I don't understand the concepts of constructors or the function of the <code>__new__</code> method.</span>
<span class="comment-copy">@henrebotha: I suggest reading about the <a href="http://docs.python.org/3/reference/datamodel.html#basic-customization" rel="nofollow noreferrer">Python data model</a>. A class's <code>__new__</code> method is called to construct its instances. Calling <code>Derived()</code> will trigger a call to <code>Derived.__new__</code> if it exists. Usually <code>__new__</code> returns a new object created by <code>object.__new__</code> (via <code>super</code> calls), but it doesn't have to do that. In the example above, we got the instance from a factory function, then customized it. See also <a href="http://stackoverflow.com/questions/15330755/construct-class-from-superclass-instance">this previous question</a>.</span>
<span class="comment-copy">Interesting point there about JIT compilers.</span>
