<div class="post-text" itemprop="text">
<p>I have a bunch of classes which use "special-methods":</p>
<pre><code>class Foo(object):
   "Foo docstring"

   attr1 = "Attribute!" #: first attribute
   attr2 = "Another Attribute!" #: second attribute

   def __init__(self):
       self.x = 12

   def say_hello(self):
       """
       say_hello(self) -&gt; None

       Issue a friendly greeting.
       """
       print "Hello! x is {0}".format(self.x)

   def __contains__(self,other):
       """Implement ``other in self``"""
       return other == self.x
</code></pre>
<p>now I would like to generate html documentation for this using Sphinx and autodoc.  How do I tell Sphinx to document <code>__contains__</code>?  I tried adding </p>
<pre><code>autodoc_default_flags = ['members', 'undoc-members', 'special-members']
</code></pre>
<p>to <code>conf.py</code>, but that also included <code>__dict__</code> which I definitely don't want.  </p>
<p>Currently, the relevant portions of the <code>myproject.rst</code> file look like:</p>
<pre><code>.. automodule:: myproject.foomodule
    :members:
    :undoc-members:
    :show-inheritance:
</code></pre>
<p><strong>edit</strong> adding </p>
<pre><code>.. automodule:: myproject.foomodule
    :members:
    :undoc-members:
    :show-inheritance:

.. automethod:: myproject.foomodule.Foo.__contains__
</code></pre>
<p>does add documentation of that method, but in a separate section -- Not as part of the <code>Foo</code> class documentation.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can add:</p>
<pre><code>:special-members:
:exclude-members: __dict__,__weakref__
</code></pre>
<p>To the <code>.rst</code> file in order to show special members, except <code>__dict__</code> and <code>__weakref__</code></p>
</div>
<div class="post-text" itemprop="text">
<p>What worked for me is adding the ".. automethod:: <strong>methodName</strong>"</p>
<p>directive in the docstring of the class, instead of doing it in the .rst file.</p>
<p>So, you can change "Foo docstring" to</p>
<pre><code>"""
Foo docstring

.. automethod:: __contains__
"""
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="http://sphinx-doc.org/ext/autodoc.html" rel="nofollow">special-members</a> option now takes arguments (this is a new feature in Sphinx 1.2). </p>
<p>So this should work:</p>
<pre><code>.. automodule:: myproject.foomodule
    :members:
    :undoc-members:
    :special-members: __contains__
    :show-inheritance:
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm currently not 100% thrilled with this solution, so I hope someone can come along an improve it.  However, the way I've solved this problem is to do the following:</p>
<pre><code>.. automodule:: myproject.foomodule
    :members:
    :undoc-members:
    :show-inheritance:

    .. autoclass:: myproject.foomodule.Foo
        :exclude-members: attr1,attr2

        .. autoattribute:: myproject.foomodule.Foo.attr1 

        .. autoattribute:: myproject.foomodule.Foo.attr2 

        .. automethod:: myproject.foomodule.Foo.__contains__
</code></pre>
<p>Here I actually need to tell <code>autodoc</code> to avoid documenting the class attributes (automatically) and then I need to add them back on explicitly.  The reason is because apparently when you explicitly nest commands, the <a href="http://sphinx-doc.org/ext/autodoc.html#confval-autodoc_default_flags" rel="nofollow">explicit ones come first</a>.  If I only explicitly say to add <code>__contains__</code>, then it shows up before the attributes which I didn't like.</p>
</div>
<span class="comment-copy">OTTOMH - I believe you have to be explicit and use <code>.. automethod:: __contains__</code> as I don't believe <code>special-members</code> accepts any form of filtering parameter</span>
<span class="comment-copy">The example in the question doesn't exactly present a compelling case for documenting this method. There's no point in documenting <code>__contains__</code> if it just tells you whether an object is a member of a collection. That's <a href="http://docs.python.org/3/reference/datamodel.html#object.__contains__" rel="nofollow noreferrer">already documented in Python</a>. You might mention in the docstring for the class that the <code>in</code> operator is supported.</span>
<span class="comment-copy">@JonClements -- That seems close.  I added a <code>.. automethod:: myproject.foomodule.Foo.__contains__`` after the </code>..automethod` stuff above and it added the documentation, but it's documented separately from the class.</span>
<span class="comment-copy">@GarethRees -- That doesn't really matter does it?  Having it documented shows the user that the class does in fact have a useful <code>__contains__</code> method.  If I had left it off, the user wouldn't know that they could do <code>if thing in foo:</code> and have it behave in a reasonable way.</span>
<span class="comment-copy">@GarethRees -- If you must know, my use case is that the class <code>Foo</code> is something of a poor man's ABC.  It's docstrings tell the user what the expected behavior of it's subclasses are and it raises <code>NotImplementedErrors</code>.  I want to document <code>__contains__</code> so the user knows what <code>if x in foo_subclass_instance</code> is expected to mean, but this could just as easily have been a special <code>__getitem__</code> method which doesn't behave in a completely standard way.</span>
<span class="comment-copy">Good to know.  I'm (unfortunately) no longer able to use sphinx -- So I can't test this out.  I'll be sure to give it a go if I ever get the chance though.</span>
<span class="comment-copy">Does <a href="http://stackoverflow.com/a/21449475/832230">stackoverflow.com/a/21449475/832230</a> help?</span>
