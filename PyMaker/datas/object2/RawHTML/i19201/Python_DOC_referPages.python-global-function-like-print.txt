<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/5761408/create-a-global-function-in-python">create a global function in python</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
<li>
<a dir="ltr" href="/questions/6965090/how-to-add-builtin-functions">How to add builtin functions</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>I am looking to make a global function in python 3.3 like the print function. In particular we have embedded python in our own application and we want to expose a simple 'debug(value)' global function, available to any script. It is possible for us to do this by attaching the function to a module, however, for convenience it would be easier for it to be global like 'print(value)'.</p>
<p>How do you declare a global function that becomes available to any python file without imports, or is this a black box in python? Is it possible to do from the C side binding?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is almost always a bad idea, but if you really want to do it…</p>
<p>If you print out or otherwise inspect the <code>print</code> function, you'll see it's in the module <a href="http://docs.python.org/3/library/builtins.html" rel="nofollow"><code>builtins</code></a>. That's your clue. So, you can do this:</p>
<p>debugmodule.py:</p>
<pre><code>import builtins
builtins.debug = debug
</code></pre>
<p>Now, after an <code>import debugmodule</code>, any other module can just call <code>debug</code> instead of <code>debugmodule.debug</code>.</p>
<hr/>
<blockquote>
<p>Is it possible to do from the C side binding?</p>
</blockquote>
<p>In CPython, C extension module can basically do the same thing that a pure Python module does. Or, even more simply, write a <code>_debugmodule.so</code> in C, then a <code>debugmodule.py</code> that imports it and copies <code>debug</code> into <code>builtins</code>.</p>
<p>If you're embedding CPython, you can do this just by injecting the function into the <code>builtins</code> module before starting the script/interactive shell/whatever, or at any later time.</p>
<hr/>
<p>While this definitely works, it's not entirely clear whether this is actually <em>guaranteed</em> to work. If you read <a href="http://docs.python.org/3/library/builtins.html" rel="nofollow">the docs</a>, it says:</p>
<blockquote>
<p>As an implementation detail, most modules have the name <code>__builtins__</code> made available as part of their globals. The value of <code>__builtins__</code> is normally either this module or the value of this module’s <code>__dict__</code> attribute. Since this is an implementation detail, it may not be used by alternate implementations of Python.</p>
</blockquote>
<p>And, at least in CPython, it's actually that <code>__builtins__</code> module or dict that gets searched as part of the lookup chain, not the <code>builtins</code> module. So, it might be possible that another implementation could look things up in <code>__builtins__</code> like CPython does, but at the same time not make <code>builtins</code> (or user modifications to it) automatically available in <code>__builtins__</code>, in which case this wouldn't work. (Since CPython is the only 3.x implementation available so far, it's hard to speculate…)</p>
<p>If this doesn't work on some future Python 3.x implementation, the only option I can think of is to get your function injected into each module, instead of into builtins. You could do that with a <a href="http://www.python.org/dev/peps/pep-0302/" rel="nofollow">PEP-302</a> import hook (which is a lot easier in 3.3 than it was when PEP 302 was written… read <a href="http://docs.python.org/3.3/reference/import.html" rel="nofollow">The import system</a> for details).</p>
<hr/>
<p>In 2.x, instead of a module <code>builtins</code> that automatically injects things into a magic module <code>__builtins__</code>, there's just a magic module <code>__builtin__</code> (notice the missing <code>s</code>). You may or may not have to <code>import</code> it (so you might as well, to be safe). And you may or may not be able to change it. But it works in (at least) CPython and PyPy.</p>
<hr/>
<p>So, what's the <em>right</em> way to do it? Simple: instead of <code>import debugmodule</code>, just <code>from debugmodule import debug</code> in all of your other modules. That way it ends up being a module-level global in every module that needs it.</p>
</div>
<span class="comment-copy">Is making this part of a module not working out for your situation?</span>
<span class="comment-copy">See this question    <a href="http://stackoverflow.com/questions/4698493/can-i-add-custom-methods-attributes-to-built-in-python-types" title="can i add custom methods attributes to built in python types">stackoverflow.com/questions/4698493/…</a></span>
<span class="comment-copy">@Stephane For some reason I never found that in my searches, and I've been searching on google for over an hour about 'global functions' in python. Thanks</span>
<span class="comment-copy">@Rovert, however abarnert answer is not available on the dupplicate question... so I 'm gonna try to revert my close vote, because his answer is of interest.</span>
<span class="comment-copy">That question seems to be able making a regular module-global function. And, not only that, that original question already did it properly, and the OP just didn't know how to read the error message.</span>
<span class="comment-copy">Excellent, it works.</span>
