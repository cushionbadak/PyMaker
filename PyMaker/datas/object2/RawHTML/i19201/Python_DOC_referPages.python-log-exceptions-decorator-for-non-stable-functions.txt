<div class="post-text" itemprop="text">
<p>I want to log exception in problem functions (html parsing of mutable pages), so i think best solution here some kind of decorator which log exception to file, with time, type of exception,line of exception in code and function call arguments,some thing like:</p>
<pre><code>@exception_catch(log_path='example.log')
def example(x,y):
    raise Exception('123')
</code></pre>
<p>What is the best practise to solve such kind of task or may be good python libs for this? </p>
</div>
<div class="post-text" itemprop="text">
<p>You probably want to do as unutbu suggests, since it's more flexible and ultimately just as simple. But, in case you're overwhelmed with the extra details of <code>logging</code>, here's how to do exactly what you asked:</p>
<pre><code>def exception_catch(log_path):
    def deco(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                with open(log_path, 'a') as log:
                    log.write('{} {} {} {} {}\n'.format(datetime.datetime.now(), 
                                                        type(e), e, args, kwargs))
                # This will return None on error, of course
        return wrapper
    return deco
</code></pre>
<p>You can, of course, put whatever you want into the <code>format</code>, including any local variables from any of the scopes above. The only tricky bit of what you asked for is the "line of exception in code". The details for that are slightly different for 2.x vs. 3.x (see the <a href="http://docs.python.org/3/library/traceback.html" rel="nofollow"><code>traceback</code></a> module for most of what you need to know), but here's a 3.x example that gives you exactly what you asked for:</p>
<pre><code>except Exception as e:
    filename, line, func, text = traceback.extract_stack(limit=1)[0]
    with open(log_path, 'a') as log:
        log.write('time: {} type: {} line: {} args: {}\n'.format(
            datetime.datetime.now(), 
            type(e),
            line,
            args))    
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Instead of passing a path to a file, pass a logger instead. That way, the user of the decorator can decide if he wants logging to a file or a console, or whatever. The logger will also determine the format of the logging message.</p>
<p>You might also want an <code>exception</code> parameter to define what kind of exception or exceptions you want caught. (Below, <code>exception</code> can take an <code>Exception</code> or tuple of <code>Exceptions</code>.</p>
<hr/>
<pre><code>import logging

def catch_exception(exception=Exception, logger=logging.getLogger(__name__)):
    def deco(func):
        def wrapper(*args, **kwargs):
            try:
                result = func(*args, **kwargs)
            except exception as err:
                logger.exception(err)
            else:
                return result
        return wrapper
    return deco

@catch_exception()
def example(x,y):
    raise Exception('123')

logging.basicConfig(filename='/tmp/error.log', level=logging.DEBUG,
                    datefmt='%Y-%m-%d %H:%M:%S',
                    format='%(asctime)s %(module)s %(levelname)s: %(message)s')

example(1,2)
</code></pre>
</div>
<span class="comment-copy">+1. But why do you have the <code>else</code> block? There's no way <code>return result</code> can raise anything extra.</span>
