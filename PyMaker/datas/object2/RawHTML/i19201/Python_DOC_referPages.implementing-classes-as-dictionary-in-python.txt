<div class="post-text" itemprop="text">
<p>I found below code at <a href="http://pydanny.com/python-dictionary-as-a-class.html" rel="nofollow">http://pydanny.com/python-dictionary-as-a-class.html</a>. The code works fine and I kind of understand why it does but a similar code, below it gives error.</p>
<pre><code>def newclass(**kwargs):
""" Use kwargs.update() method to handle inheritance """

def set(key, value):
    """ Sets key/value to the kwargs.
        Replicates self/this clumsily
    """
    kwargs[key] = value
kwargs['set'] = set
return kwargs
</code></pre>
<p>My trial code:</p>
<pre><code>def closing():
    x=1
    def closed():
        print(x)
        x=x+1
    return(closed)

a=closing()
a()
</code></pre>
<p>Error Message:</p>
<pre><code>Traceback (most recent call last):
File "&lt;pyshell#606&gt;", line 1, in &lt;module&gt;
a()
File "&lt;pyshell#604&gt;", line 4, in closed
print(x)
UnboundLocalError: local variable 'x' referenced before assignment
</code></pre>
<p>When I use 'nonlocal x' in the closed function it works but how come the initial code works without 'nonlocal'.
My understanding is that it's a closure and the inside function will keep reference of the outside (free) variable and whenever the inner function is called it will be able to act upon that closed variable but certainly I haven't understood some part of it properly.
Please help me clear the concept I am missing.
Thank you all the folks who answer. SO has been too helpful.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>When I use 'nonlocal x' in the closed function it works but how come the initial code works without 'nonlocal'.</p>
</blockquote>
<p>In the first snippet, you're mutating the existing <code>kwargs</code> value. You're not assigning a new value to it, or to any other name.</p>
<p>But in the second snippet, you're assigning a new value to <code>x</code>. That forces <code>x</code> to be local (unless you've said otherwise). Therefore, your <code>x+1</code> is a reference to a local variable that hasn't been assigned yet. Hence the error.</p>
<p>For a more rigorous explanation, read <a href="http://docs.python.org/3/reference/executionmodel.html#naming-and-binding" rel="nofollow">Naming and binding</a> in the documentation. The relevant bits are:</p>
<blockquote>
<p>Each occurrence of a name in the program text refers to the binding of that name established in the innermost function block containing the use…</p>
<p>When a name is used in a code block, it is resolved using the nearest enclosing scope…</p>
<p>If a name is bound in a block, it is a local variable of that block, unless declared as <code>nonlocal</code>…</p>
</blockquote>
<p>To learn how this works under the covers, you'll also need to read about functions and code objects in <a href="http://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy" rel="nofollow">The standard type hierarchy</a>. You probably don't need to know that part for understanding, but for debugging, you may want to inspect the <code>__closure__</code> and other attributes.</p>
</div>
<span class="comment-copy">It looks as though there's a whitespace error in your first snippet</span>
<span class="comment-copy">You are right. I had checked id of the variable while the execution control was in the function and after the function had died and the memory address remained the same, due to which I (incorrectly) assumed that further assignments too will use the same address. I didn't realize that assignment is different than mutation. Thank you so much for your time and the additional links.</span>
