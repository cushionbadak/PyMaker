<div class="post-text" itemprop="text">
<p>I have</p>
<pre><code>cmd = subprocess.Popen('dir',shell=True,stdout=subprocess.PIPE)
for line in cmd.stdout:
  columns = line.split(' ')
  print (columns[3])
</code></pre>
<p>have error in line 3 Type Str doesnt support the buffer API.</p>
<p>What am i doing wrong i am on Python 3.3</p>
</div>
<div class="post-text" itemprop="text">
<p>You are reading binary data, not <code>str</code>, so you need to decode the output first. If you set the <code>universal_newlines</code> argument to <code>True</code>, then <code>stdout</code> is automatically decoded using the result of the <a href="https://docs.python.org/3/library/locale.html#locale.getpreferredencoding" rel="nofollow noreferrer"><code>locale.getpreferredencoding()</code> method</a>
 (same as for opening text files):</p>
<pre><code>cmd = subprocess.Popen(
    'dir', shell=True, stdout=subprocess.PIPE, universal_newlines=True)
for line in cmd.stdout:
    columns = line.decode().split()
    if columns:
        print(columns[-1])
</code></pre>
<p>If you use Python 3.6 or newer, you can use an explicit <code>encoding</code> argument for to the <code>Popen()</code> call to specify a different codec to use, like, for example, UTF-8:</p>
<pre><code>cmd = subprocess.Popen(
    'dir', shell=True, stdout=subprocess.PIPE, encoding='utf8')
for line in cmd.stdout:
    columns = line.split()
    if columns:
        print(columns[-1])
</code></pre>
<p>If you need to use a different codec in Python 3.5 or earlier, don't use <code>universal_newlines</code>, just decode text from bytes explicitly.</p>
<p>You were trying to split a <code>bytes</code> value using a <code>str</code> argument:</p>
<pre><code>&gt;&gt;&gt; b'one two'.split(' ')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: Type str doesn't support the buffer API
</code></pre>
<p>By decoding you avoid that problem, and your <code>print()</code> call will not have to prepend the output with <code>b'..'</code> either.</p>
<p>However, you probably just want to use the <code>os</code> module instead to get filesystem information:</p>
<pre><code>import os

for filename in os.listdir('.'):
    print(filename)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A simpler solution of the first part of <a href="https://stackoverflow.com/a/15817457/1872673">Martijn Pieters's answer</a> is to pass the <code>universal_newlines=True</code> argument to the <code>Popen</code> call.</p>
<p>I would even simplify this to:</p>
<pre><code>output = subprocess.check_output('dir', universal_newlines=True)
columns = output.split()
print(columns)
</code></pre>
<p><strong>NOTE</strong>: If file or directory names contain spaces, use <code>os.listdir('.')</code> as suggested in <a href="https://stackoverflow.com/a/15817457/1872673">Martijn Pieters's answer</a> or something like the following:</p>
<pre><code>output = subprocess.check_output('dir', universal_newlines=True)
columns = []
for e in output.split():
    if len(columns) &gt; 0 and columns[-1].endswith('\\'):
        columns[-1] = columns[-1][:-1] + " " + e
    else:
        columns.append(e)
print(columns)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Better use <a href="http://docs.python.org/2/library/binascii.html" rel="nofollow">binascii.b2a_uu</a> that converts binary data to a line of ASCII characters</p>
<pre><code>from binascii import b2a_uu 
cmd = b2a_uu(subprocess.Popen('dir',shell=True,stdout=subprocess.PIPE))
</code></pre>
</div>
<span class="comment-copy">Thanks it works but any idea why i am getting list index out of range error</span>
<span class="comment-copy">@NickLoach: the line has fewer than 3 columns?</span>
<span class="comment-copy">Thanks Martijn the line has ['03-04-2013', '', '19:48', '', '', '', '&lt;DIR&gt;', '', '', '', '', '', '', '', '', '', '.ipython\r\n'] i want the feild called .ipython as output</span>
<span class="comment-copy">Why not use <code>os.listdir()</code> instead?</span>
<span class="comment-copy">I made a simple example the command i would be running will not be a os command but a binary that outputs something on the above lines</span>
<span class="comment-copy"><code>dir</code> is an internal command on Windows i.e., if there is no <code>dir.exe</code> then <code>shell=True</code> is necessary in this case.</span>
<span class="comment-copy">@J.F.Sebastian, thanks for pointing this out!</span>
<span class="comment-copy">If we assume one-column output then you could use <code>.splitlines()</code>, to handle paths with spaces</span>
<span class="comment-copy">@J.F.Sebastian, agreed. I didn't use <code>.splitlines()</code> since my version of <code>dir</code> <i>(GNU coreutils) 8.21</i> produces output in multiple columns.</span>
<span class="comment-copy"><code>dir</code> produces a single column output if stdout is redirected (as it is the case with <code>stdout=PIPE</code>). Try <code>dir | cat</code>, to see it in the terminal</span>
