<div class="post-text" itemprop="text">
<p>My question is about python 3.0 strings.</p>
<ol>
<li><p>My understanding is that for the line <code>str = "a"</code>, the charcter 'a' is encoded (using utf-8 - for example) and stored in the str object. If UTF-8 representation of 'a' is 1 byte the string is 1 byte long. Am I right?</p></li>
<li><p>if the above is true what happens when we read a binary file using read(). Suppose I have a two byte file with two bytes of binary data and I read it in a string using read command like</p>
<pre><code>open(fileName, mode='rb') 
    str= file.read()
</code></pre>
<p>now <code>str</code> will be two bytes long and each byte will be what was stored in the fileName. Am I right?</p></li>
<li><p>If I am right in the above point then the str object is not in any particual encoding format (like UTF, etc.), So what does it mean that python strings are always unicode? Also what will happen if I call str.encode(). It will make no sense?</p></li>
<li><p>As the <code>str</code> object read from file is actually a array of bytes. Is there any way to convert it to bytearray type?</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>You are confused. "Encodings" pertain to <em>byte strings</em>, not to <em>unicode strings</em>. Meaningful statements: "This byte string is utf-8 encoded.", "This byte string is 2 bytes long." Meaningless statements: "This unicode string is utf-8 encoded", "This unicode string is 2 bytes long"</p>
<ol>
<li><code>str = "a"</code> means "create a unicode string 'a' and a reference to it named <code>str</code>". Unicode strings are of course <em>stored</em> in some encoding because it needs to exist as bytes in memory, but that is not relevant. All your code treats it as if it has no encoding at all--it has been abstracted away from bytes. A unicode string is <em>a sequence of unicode code points</em> (i.e. of integers that represent characters).</li>
<li>Yes and no. <code>str</code> here (the return value of <code>read()</code>) is a <em>byte string</em>, not a <em>unicode string</em>. <code>"a" != b"a"</code>.</li>
<li>Your byte-string <code>str</code> possesses an <em>unknown encoding</em> and must be <em>decoded</em> to produce a unicode string. Byte strings don't have an <code>encode()</code> method because it is meaningless--they are either already an encoding of a unicode string, or they are not representing a unicode string at all (e.g. an image).</li>
<li>It's not an array of bytes, it's a byte-string. A <a href="http://docs.python.org/3/library/stdtypes.html#bytearray-objects" rel="nofollow"><code>bytearray</code></a> is a <em>mutable</em> list of bytes. You can produce a bytearray with <code>bytearray(byte_string)</code>, but bytearrays are intended for fairly specialized uses (e.g., to avoid copying for send-recv buffers), not casual use. Normally you just want a byte string.</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>When you read a file in binary mode, the value returned from the <code>read()</code> method is a <a href="http://docs.python.org/3/library/stdtypes.html#bytes" rel="nofollow"><code>bytes</code></a> object, not a <a href="http://docs.python.org/3/library/stdtypes.html#str" rel="nofollow"><code>str</code></a> object. The documentation covers this in depth.</p>
<pre><code>&gt;&gt;&gt; with open('foo', mode='rb') as f: s = f.read()
... 
&gt;&gt;&gt; s
b'abc\n'
&gt;&gt;&gt; len(s)
4
&gt;&gt;&gt; type(s)
&lt;class 'bytes'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python strings store <em>Unicode codepoints</em>.</p>
<p>Codepoints are not the same thing as bytes. Bytes are a computer representation of numbers (most commonly between 0 and 255), and those numbers can be translated to codepoints through the process of decoding, and in the other direction with encoding. Python 3 strings contain codepoints, one for each character in the text.</p>
<p>Python source code can define string literals using a series of bytes, that the interpreter decodes to unicode using the UTF-8 codec by default, but you can set other codecs at the top of the file. On disk, the letter <code>a</code> in UTF-8 encoding is indeed just one byte, that is the nature of the UTF-8 standard.</p>
<p>If you read a file in text mode, Python applies the decoding process for you automatically, but when you open it in binary mode, no decoding is done and you get a <code>bytes</code> object instead. The contents of that object should reflect the contents of the file exactly. Note that it is <strong>not</strong> of type <code>str</code>, it is not unicode, it is not even a Python string. To turn bytes into a string you'd need to explicitly decode with the <code>.decode()</code> method.</p>
<p>A <code>bytearray</code> is trivially created from a <code>bytes</code> value, just call <code>bytesarray()</code> on it.</p>
</div>
<span class="comment-copy">You really need to read the <a href="http://docs.python.org/3/howto/unicode.html" rel="nofollow noreferrer">Python Unicode HOWTO</a>, and <a href="http://joelonsoftware.com/articles/Unicode.html" rel="nofollow noreferrer">this article</a> for good measure.</span>
<span class="comment-copy">You really don't want to name your strings <code>str</code>. Especially since you're asking about <code>str</code> and <code>bytes</code> objects, making it even more confusing than just shadowing the built-in.</span>
