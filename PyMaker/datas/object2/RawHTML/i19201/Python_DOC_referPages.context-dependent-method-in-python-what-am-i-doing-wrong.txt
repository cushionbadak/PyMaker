<div class="post-text" itemprop="text">
<p>I would like to create a class whose f method depends on the "mode" the object of the class has been created.</p>
<p>The code below doesn't work but hope it gets you an idea of what I am trying to do. My idea is to have a dictionary in which I define the settings for each mode (in this case the function or method to assign to self.f, so that rather than using many if elif statements
in the init function I just assign the correct values using the dictionary.</p>
<pre><code>class A(object):
    _methods_dict={
            'a':A.f1,
            'b':A.f2
            }    

    def __init__(self,mode = 'a'):
        self.f = _methods_dict[mode]


    def f1(self,x):
        return x

    def f2(self,x):
        return x**2
</code></pre>
<p>I can't figure why this does not work, how would you fix it?
Also are there better (and more pythonic) approaches to get the same kind of functionalities?</p>
</div>
<div class="post-text" itemprop="text">
<p>Store the <em>name</em> of the two functions, then use <code>getattr()</code> to retrieve the bound method in <code>__init__</code>:</p>
<pre><code>class A(object):
    _methods_dict = {
        'a': 'f1',
        'b': 'f2'
    }    

    def __init__(self, mode='a'):
        self.f = getattr(self, self._methods_dict[mode])

    def f1(self, x):
        return x

    def f2(self, x):
        return x ** 2
</code></pre>
<p>Alternatively, just proxy the method:</p>
<pre><code>class A(object):
    _methods_dict = {
        'a': 'f1',
        'b': 'f2'
    }

    def __init__(self,mode = 'a'):
        self._mode = mode

    @property
    def f(self):
        return getattr(self, self._methods_dict[self._mode])

    def f1(self, x):
        return x

    def f2(self, x):
        return x ** 2
</code></pre>
<p>The <code>f</code> property just returns the correct bound method for the current mode. Using a property simplifies call signature handling, and gives users the actual method to introspect if they so wish.</p>
<p>Either method has the same end-result:</p>
<pre><code>&gt;&gt;&gt; a1 = A()
&gt;&gt;&gt; a2 = A('b')
&gt;&gt;&gt; a1.f(10)
10
&gt;&gt;&gt; a2.f(10)
100
</code></pre>
<p>The difference lies in what is stored in the instance, the first method stores bound methods:</p>
<pre><code>&gt;&gt;&gt; vars(a1)
{'f': &lt;bound method A.f1 of &lt;__main__.A object at 0x10aa1ec50&gt;&gt;}
&gt;&gt;&gt; vars(a2)
{'f': &lt;bound method A.f2 of &lt;__main__.A object at 0x10aa1ed50&gt;&gt;}
</code></pre>
<p>versus the method in the other:</p>
<pre><code>&gt;&gt;&gt; vars(a1)
{'_mode': 'a'}
&gt;&gt;&gt; vars(a2)
{'_mode': 'b'}
</code></pre>
<p>That may not seem much of a difference, but the latter method creates instances that can be pickled and deep-copied without problems.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could just make two separate classes:</p>
<pre><code>class Base(object):
    # place here all attributes shared in common among the Modes
    pass

class ModeA(Base):
    def f(self, x):
        return x

class ModeB(Base):
    def f(self, x):
        return x**2

def make_mode(mode, *args, **kwargs):
    mode_dict = {'a':ModeA, 'b':ModeB}
    return mode_dict[mode](*args, **kwargs)

a = make_mode('a')
print(a.f(10))
# 10

b = make_mode('b')
print(b.f(10))
# 100
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To answer your first question ("why this does not work"): the class object "A" is only created and bound to the module name "A" after the whole class statement (yes, "class" is an executable statement) block has ended, so you cannot refer to neither the name or the class object itself within this block. </p>
</div>
<span class="comment-copy">Hi Martin first of all thanks, what is the difference of assigning using getattr rather than directly assigning the attribute?</span>
<span class="comment-copy">thanks for the clarification. I also think I am confusing class attributes and object attributes. I don't find this so clear in the official Python Tutorial..</span>
<span class="comment-copy">See the <a href="http://docs.python.org/3/reference/compound_stmts.html#class-definitions" rel="nofollow noreferrer">class documentation</a>, the <i>Programmer's note</i> at the end.</span>
<span class="comment-copy">Thanks and sorry to have misspelled your name in the previous comment!</span>
<span class="comment-copy">Not a problem; I am used to it. At least you didn't go overboard with extra <code>j</code>s! :-P</span>
<span class="comment-copy">Or he could use the Strategy pattern... Not enough context to know which design would be the most appropriate here.</span>
