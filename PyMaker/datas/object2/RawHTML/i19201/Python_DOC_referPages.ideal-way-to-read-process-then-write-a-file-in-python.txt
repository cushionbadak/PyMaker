<div class="post-text" itemprop="text">
<p>There are a lot of files, for each of them I need to read the text content, do some processing of the text, then write the text back (replacing the old content).<br/>
I know I can first <code>open</code> the files as <code>rt</code> to read and process the content, and then close and reopen them as <code>wt</code>, but obviously this is not a good way. Can I just open a file once to read and write? How?</p>
</div>
<div class="post-text" itemprop="text">
<p>See: <a href="http://docs.python.org/2/library/functions.html#open" rel="nofollow">http://docs.python.org/2/library/functions.html#open</a></p>
<blockquote>
<p>The most commonly-used values of mode are 'r' for reading, 'w' for writing (truncating the file if it already exists), and 'a' for appending (which on some Unix systems means that all writes append to the end of the file regardless of the current seek position). If mode is omitted, it defaults to 'r'. The default is to use text mode, which may convert '\n' characters to a platform-specific representation on writing and back on reading. Thus, when opening a binary file, you should append 'b' to the mode value to open the file in binary mode, which will improve portability. (Appending 'b' is useful even on systems that don’t treat binary and text files differently, where it serves as documentation.) See below for more possible values of mode.</p>
<p>Modes 'r+', 'w+' and 'a+' open the file for updating (note that 'w+' truncates the file). Append 'b' to the mode to open the file in binary mode, on systems that differentiate between binary and text files; on systems that don’t have this distinction, adding the 'b' has no effect.</p>
</blockquote>
<p>So, you can open a file in mode <code>r+</code>, read from it, truncate, then write to the same file object.  But you shouldn't do that.</p>
<p>You should open the file in read mode, write to a temporary file, then <code>os.rename</code> the temporary file to overwrite the original file.  This way, your actions are atomic; if something goes wrong during the write step (for example, it gets interrupted), you don't end up having lost the original file, and having only partially written out your replacement text.</p>
</div>
<div class="post-text" itemprop="text">
<p>Check out the <a href="http://docs.python.org/3/library/fileinput.html" rel="nofollow">fileinput module</a>. It lets you do what others are advising: back up the input file, manipulate its contents, and then write the altered data to the same place.</p>
<blockquote>
<p>Optional in-place filtering: if the keyword argument inplace=True is passed to fileinput.input() or to the FileInput constructor, the file is moved to a backup file and standard output is directed to the input file (if a file of the same name as the backup file already exists, it will be replaced silently). This makes it possible to write a filter that rewrites its input file in place. </p>
</blockquote>
<p>Here's an example. Say I have a text file like:</p>
<pre><code>1
2
3
4
</code></pre>
<p>I can do (Python 3):</p>
<pre><code>import fileinput

file_path = r"C:\temp\fileinput_test.txt"
with fileinput.FileInput(files=[file_path], inplace=True) as input_data:
    for line in input_data:
        # Double the number on each line
        s = str(int(line.strip()) * 2)
        print(s)
</code></pre>
<p>And my file becomes:</p>
<pre><code>2
4
6
8
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="http://docs.python.org/2/tutorial/inputoutput.html#reading-and-writing-files" rel="nofollow">'r+' file mode</a> to open a file for reading and writing at the same time.</p>
<p>example:</p>
<pre><code>with open("file.txt", 'r+') as filehandle:
   # can read and write to file here
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>well, you can choose the "r+w" mode, with which you need only open the file once</p>
</div>
<span class="comment-copy">replace old content is not a good idea, especially when bug in your code may damage your valuable data; open a new folder, put all processed file there</span>
<span class="comment-copy">The usual way to do this is to simply read the file, save changes to a temporary file, and then if everything succeeds you move the temp file  overwriting the original.</span>
<span class="comment-copy"><code>r+</code> dose not <code>truncate</code> files, right? Python docs says how to truncate a file descriptor,  but not a file object in python.</span>
<span class="comment-copy"><a href="http://docs.python.org/2/library/stdtypes.html#bltin-file-objects" rel="nofollow noreferrer">docs.python.org/2/library/stdtypes.html#bltin-file-objects</a> -- <code>fileobj.seek(0); fileobj.truncate()</code>.</span>
<span class="comment-copy">Oh, you are so helpful!THanks. @Matt Anderson</span>
<span class="comment-copy">'w' is write only. It doesn't allow reading.</span>
<span class="comment-copy">then use rw mode, i edited my answer</span>
<span class="comment-copy">do you mean <code>'w+'</code>?</span>
<span class="comment-copy"><code>rw</code> does not exist either.</span>
<span class="comment-copy">it's r+w, I edited again, thanks for both of you</span>
