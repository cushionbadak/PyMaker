<div class="post-text" itemprop="text">
<p>I was wondering what the standard set up is for performing logging from within a Python app.</p>
<p>I am using the Logging class, and I've written my own logger class that instantiates the Logging class. My main then instantiates my logger wrapper class. However, my main instantiates other classes and I want those other classes to also be able to write to he log file via the logger object in the main.</p>
<p>How do I make that logger object such that it can be called by other classes? It's almost like we need some sort of static logger object to get this to work.</p>
<p>I guess the long and short of the question is: how do you implement logging within your code structure such that all classes instantiated from within main can write to the same log file? Do I just have to create a new logging object in each of the classes that points to the same file?</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't know what you mean by the <code>Logging</code> class - there's no such class in Python's built-in logging. You don't really need wrappers: here's an example of how to do logging from arbitrary classes that you write:</p>
<pre><code>import logging

# This class could be imported from a utility module
class LogMixin(object):
    @property
    def logger(self):
        name = '.'.join([__name__, self.__class__.__name__])
        return logging.getLogger(name)


# This class is just there to show that you can use a mixin like LogMixin
class Base(object):
    pass

# This could be in a module separate from B
class A(Base, LogMixin):
    def __init__(self):
        # Example of logging from a method in one of your classes
        self.logger.debug('Hello from A')

# This could be in a module separate from A
class B(Base, LogMixin):
    def __init__(self):
        # Another example of logging from a method in one of your classes
        self.logger.debug('Hello from B')

def main():
    # Do some work to exercise logging
    a = A()
    b = B()
    with open('myapp.log') as f:
        print('Log file contents:')
        print(f.read())

if __name__ == '__main__':
    # Configure only in your main program clause
    logging.basicConfig(level=logging.DEBUG,
                        filename='myapp.log', filemode='w',
                        format='%(name)s %(levelname)s %(message)s')
    main()
</code></pre>
<p>Generally it's not necessary to have loggers at class level: in Python, unlike say Java, the unit of program (de)composition is the module. However, nothing stops you from doing it, as I've shown above. The script, when run, displays:</p>
<pre><code>Log file contents:
__main__.A DEBUG Hello from A
__main__.B DEBUG Hello from B
</code></pre>
<p>Note that code from both classes logged to the same file, myapp.log. This would have worked even with A and B in different modules.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try using logging.getLogger() to get your logging object instance:</p>
<p><a href="http://docs.python.org/3/library/logging.html#logging.getLogger" rel="nofollow">http://docs.python.org/3/library/logging.html#logging.getLogger</a></p>
<blockquote>
<p>All calls to this function with a given name return the same logger instance. This means that logger instances never need to be passed between different parts of an application.</p>
</blockquote>
<p><strong>UPDATE</strong>:</p>
<p>The recommended way to do this is to use the getLogger() function and configure it (setting a handler, formatter, etc...):</p>
<pre><code># main.py
import logging
import lib


def main():
    logger = logging.getLogger('custom_logger')
    logger.setLevel(logging.INFO)
    logger.addHandler(logging.FileHandler('test.log'))
    logger.info('logged from main module')
    lib.log()

if __name__ == '__main__':
    main()

# lib.py
import logging


def log():
    logger = logging.getLogger('custom_logger')
    logger.info('logged from lib module')
</code></pre>
<p>If you <strong>really</strong> need to extend the logger class take a look at <strong>logging.setLoggerClass(klass)</strong></p>
<p><strong>UPDATE 2</strong>:</p>
<p>Example on how to add a custom logging level without changing the Logging class:</p>
<pre><code># main.py
import logging
import lib


# Extend Logger class
CUSTOM_LEVEL_NUM = 9
logging.addLevelName(CUSTOM_LEVEL_NUM, 'CUSTOM')
def custom(self, msg, *args, **kwargs):
    self._log(CUSTOM_LEVEL_NUM, msg, args, **kwargs)
logging.Logger.custom = custom

# Do global logger instance setup
logger = logging.getLogger('custom_logger')
logger.setLevel(logging.INFO)
logger.addHandler(logging.FileHandler('test.log'))


def main():
    logger = logging.getLogger('custom_logger')
    logger.custom('logged from main module')
    lib.log()

if __name__ == '__main__':
    main()
</code></pre>
<p>Note that adding custom level is not recommended: <a href="http://docs.python.org/2/howto/logging.html#custom-levels" rel="nofollow">http://docs.python.org/2/howto/logging.html#custom-levels</a></p>
<p>Defining a custom handler and maybe using more than one logger may do the trick for your other requirement: optional output to stderr.</p>
</div>
<span class="comment-copy">This is the most elegant solution I've seen for logging in Python.  Thank you for sharing :-)</span>
<span class="comment-copy"><code>__name__</code> is not correct if using the mixin class in other module.</span>
<span class="comment-copy">Sorry for being a little dense here....so then If I have a main module that instantiates my own Log class (which contains the logging class) then it is certainly easy to log things by simply calling my Log object.  However, if my main imports other modules, how do a make a call to my Log class methods to log without passing a Log handle to every method?  Can you provide an example using multiple modules?</span>
<span class="comment-copy">I have provided an example using multiple modules and the getLogger() function. It's rare to have to extend the Logger (logging.getLoggerClass()) class, if you really think creating a logger with getLogger and configuring a custom Handler, Formatter it's not enough for your needs please explain what's the rationale behind your custom Logger class.</span>
<span class="comment-copy">@GregH Did my example make sense? Let me know if that solves your issue or you need further explanation.</span>
<span class="comment-copy">I guess I could not abstract it further. One thing I have is my own custom logging levels...didn't want to use the pre-defined levels (WARNING, etc.)  In addition I am doing other things like having a custom "write" method that allows the caller to determine if they want the message to be output to stderr.  However, your writeup was helpful.  Thanks.</span>
<span class="comment-copy">@GregH: I've update my answer with an alternative solution for that.</span>
