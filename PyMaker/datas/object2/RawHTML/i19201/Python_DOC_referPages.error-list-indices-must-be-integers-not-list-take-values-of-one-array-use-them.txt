<div class="post-text" itemprop="text">
<pre><code>seen = []
dups = collections.defaultdict(list)
for i, item in enumerate(prules)
    for j, orig in enumerate(seen):
        if item == orig:
            dups[j].append(i)
            break
    else:
        seen.append(item)
deleteindex = [val for key,val in dups.iteritems() if seen[key] == '159']
for i in range(o,len(deleteindex)):
    n = deleteindex[i]
    del rulelines[n]
</code></pre>
<p>The above is my code. </p>
<p>What I want to do is to create an array <code>deleteindex</code> which takes in the indice of any item with <code>159</code> in.</p>
<p>It does get all the values I want i.e all the indices with the value <code>159</code> but when I try to delete the values from a different array with the indices, it returns the error </p>
<blockquote>
<p>list indices must be integers, not list. </p>
</blockquote>
<p><code>prules</code> is the array I want to get the index values contains strings of numbers<br/>
<code>rulelines</code> contains is a list of strings which I want to use the values taken from <code>prules</code> and use the values as indexes to delete those values in <code>rulelines</code> </p>
<p>Where have I gone wrong?<br/>
I'm guessing its something at</p>
<pre><code>deleteindex = [val for key,val in dups.iteritems() if seen[key] == '159']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are right.<br/>
The error is because, in</p>
<pre><code>deleteindex = [val for key,val in dups.iteritems() if seen[key] == '159']
</code></pre>
<p><code>key</code> is a <code>list</code>. As <code>dups</code> is <code>defaultdict(list)</code>, the value will always be a <code>list</code>.<br/>
This can be verified by:</p>
<pre><code>...
print dict(dups.iteritems())  # adding this
deleteindex = [val for key,val in dups.iteritems() if seen[key] == '159']
...
</code></pre>
<p>As for your algorithm, try this, an easier to understand version.</p>
<pre><code>import random

prules = [random.randint(150,156) for i in range(30)]

def get_indexes(li):
    retval = {}
    for i, x in enumerate(li):
        if x not in retval:
            retval[x] = []
        retval[x].append(i)
    return retval               

dups = get_indexes(prules)
indexes = dups.get('156',[])
rulelines = [rulelines[i] for i in range(len(rulelines[:])) if i not in indexes]
</code></pre>
<p>To get the indexes, just do:</p>
<pre><code>dups.get('156',[])
</code></pre>
<p>Which will return a list of indexes if <code>dups['156']</code> exists, else it returns an empty list.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your intuition is right.</p>
<pre><code>deleteindex = [val for key,val in dups.iteritems() if seen[key] == '159']
</code></pre>
<p>Here each <code>val</code> is one of the values in the <code>dups</code> dictionary you've been populating in the above loop. But what are these values? Well, <code>dups = collections.defaultdict(list)</code> would indicate that each one of these values is a <code>list</code>.</p>
<p>Therefore this code breaks due to your not keeping track of your types:</p>
<pre><code>n = deleteindex[i]  # n is a list
del rulelines[n]    # you can't index a list with a list
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From what I can tell, <code>prules</code> is a list, or a collection at least that can be enumerated, in which case, you can possibly convert it to a <a href="http://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset" rel="nofollow"><code>set</code></a> which is all you need to do to remove duplicates.</p>
<hr/>
<p>However, if this is not the case (I can not tell since you have not provided that segment of code) then you could go about the whole thing in a better way:</p>
<pre><code>seen = []
duplicate_indexes = []
for index, item in enumerate(prules):
    if item in seen:
        del rulelines[index]
    else:
        seen.append(item)
</code></pre>
<hr/>
<p>From your updated Question, I think that you are trying to do something else than what it seems your question is about. I think you are trying to delete every index in <code>rulelines</code> where the corresponding index in <code>prules</code> has a value of <code>'159'</code> if this is the case:</p>
<pre><code>for ix, pr in enumerate(prules):
    if pr == '159':
        del rulelines[ix]
</code></pre>
</div>
<span class="comment-copy">Your whole code is not visible here, what is <code>prules</code>, and what is <code>rulelines</code> ?</span>
<span class="comment-copy">I'm having a pretty tough time understanding what you're actually doing -- as evidenced by my now deleted answer that the community didn't agree with :-P ... Could you provide a minimal working example that demonstrates the problem (as well as an explanation of what you want) so we could play with it?  That would probably go a long way toward getting your solution.</span>
<span class="comment-copy">If I wanted to count the number of occurrences of a value in a list, I'd use the <code>Collections.Counter</code> built-in data structure:      from collections import Counter     has_dups = set(item for item, count in Counter(prules).items() if count &gt; 1)       and then proceed from here.</span>
<span class="comment-copy">I still get an list assignment index out of range. I've printed n and i out and it does look like n is the values I want</span>
<span class="comment-copy">Yes sorry <code>n</code> is what you want, but what is the length of <code>rulelines</code>? Is it equal to that of <code>prules</code>?? Also, we don't need the <code>enumerate</code>.</span>
<span class="comment-copy">they are both the same length yeah</span>
<span class="comment-copy">the size of <code>rulelines</code> decreases everytime <code>del rulelines[n]</code> is called, meaning the indexes at the end are no longer valid</span>
<span class="comment-copy">they are too big as indexes, but at the start they would have been ok</span>
<span class="comment-copy">Congrats on 2k rep...</span>
