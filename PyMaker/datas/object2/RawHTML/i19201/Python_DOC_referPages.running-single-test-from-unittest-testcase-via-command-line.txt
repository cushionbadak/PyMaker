<div class="post-text" itemprop="text">
<p>In our team, we define most test cases like this:</p>
<p>One "framework" class ourtcfw.py:</p>
<pre><code>import unittest

class OurTcFw(unittest.TestCase):
    def setUp:
        # something

    # other stuff that we want to use everywhere
</code></pre>
<p>and a lot of test cases like testMyCase.py:</p>
<pre><code>import localweather

class MyCase(OurTcFw):

    def testItIsSunny(self):
        self.assertTrue(localweather.sunny)

    def testItIsHot(self):
        self.assertTrue(localweather.temperature &gt; 20)

if __name__ == "__main__":
    unittest.main()
</code></pre>
<p>When I'm writing new test code and want to run it often, and save time, what I do is that I put "__" in front of all other tests.  But it's cumbersome, distracts me from the code I 'm writing and the commit noise this creates is plain annoying.</p>
<p>So e.g. when making changes to <code>testItIsHot()</code>, I want to be able to do this:</p>
<pre class="lang-none prettyprint-override"><code>$ python testMyCase.py testItIsHot
</code></pre>
<p>and have <code>unittest</code> run <em>only</em> <code>testItIsHot()</code></p>
<p>How can I achieve that?</p>
<p>I tried to rewrite the <code>if __name__ == "__main__":</code> part, but since I'm new to Python, I'm feeling lost and keep bashing into everything else than the methods.</p>
</div>
<div class="post-text" itemprop="text">
<p>This works as you suggest - you just have to specify the class name as well:</p>
<pre><code>python testMyCase.py MyCase.testItIsHot
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you organize your test cases, that is, follow the same organization like the actual code and also use relative imports for modules in the same package</p>
<p>You can also use the following command format:</p>
<pre><code>python -m unittest mypkg.tests.test_module.TestClass.test_method
# In your case, this would be:
python -m unittest testMyCase.MyCase.testItIsHot
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It can work well as you guess</p>
<pre><code>python testMyCase.py MyCase.testItIsHot
</code></pre>
<p>And there is another way to just test <code>testItIsHot</code>:</p>
<pre><code>    suite = unittest.TestSuite()
    suite.addTest(MyCase("testItIsHot"))
    runner = unittest.TextTestRunner()
    runner.run(suite)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you check out the help of the unittest module it tells you about several combinations that allow you to run test case classes from a module and test methods from a test case class.</p>
<pre><code>python3 -m unittest -h

[...]

Examples:
  python3 -m unittest test_module               - run tests from test_module
  python3 -m unittest module.TestClass          - run tests from module.TestClass
  python3 -m unittest module.Class.test_method  - run specified test method
</code></pre>
<p>It does not require you to define a <code>unittest.main()</code> as the default behaviour of your module.</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe, it will be helpful for somebody. In case you want to run only tests from specific class:</p>
<pre><code>if __name__ == "__main__":
    unittest.main(MyCase())
</code></pre>
<p>It works for me in python 3.6</p>
</div>
<div class="post-text" itemprop="text">
<p>Inspired by <a href="https://stackoverflow.com/users/748731/yarkee">@yarkee</a> I combined it with some of the code I already got. You can also call this from another script, just by calling the function <code>run_unit_tests()</code> without requiring to use the command line, or just call it from the command line with <code>python3 my_test_file.py</code>.</p>
<pre class="lang-py prettyprint-override"><code>import my_test_file
my_test_file.run_unit_tests()
</code></pre>
<p>Sadly this only works for <code>Python 3.3</code> or superior:</p>
<pre class="lang-py prettyprint-override"><code>import unittest

class LineBalancingUnitTests(unittest.TestCase):

    @classmethod
    def setUp(self):
        self.maxDiff = None

    def test_it_is_sunny(self):
        self.assertTrue("a" == "a")

    def test_it_is_hot(self):
        self.assertTrue("a" != "b")
</code></pre>
<p>Runner code:</p>
<pre class="lang-py prettyprint-override"><code>#! /usr/bin/env python3
# -*- coding: utf-8 -*-
import unittest
from .somewhere import LineBalancingUnitTests

def create_suite(classes, unit_tests_to_run):
    suite = unittest.TestSuite()
    unit_tests_to_run_count = len( unit_tests_to_run )

    for _class in classes:
        _object = _class()
        for function_name in dir( _object ):
            if function_name.lower().startswith( "test" ):
                if unit_tests_to_run_count &gt; 0 \
                        and function_name not in unit_tests_to_run:
                    continue
                suite.addTest( _class( function_name ) )
    return suite

def run_unit_tests():
    runner = unittest.TextTestRunner()
    classes =  [
        LineBalancingUnitTests,
    ]

    # Comment all the tests names on this list, to run all Unit Tests
    unit_tests_to_run =  [
        "test_it_is_sunny",
        # "test_it_is_hot",
    ]

    runner.run( create_suite( classes, unit_tests_to_run ) )

if __name__ == "__main__":
    print( "\n\n" )
    run_unit_tests()
</code></pre>
<p>Editing the code a little, you can pass an array with all unit tests you would like to call:</p>
<pre class="lang-py prettyprint-override"><code>...
def run_unit_tests(unit_tests_to_run):
    runner = unittest.TextTestRunner()

    classes = \
    [
        LineBalancingUnitTests,
    ]

    runner.run( suite( classes, unit_tests_to_run ) )
...
</code></pre>
<p>And another file:</p>
<pre class="lang-py prettyprint-override"><code>import my_test_file

# Comment all the tests names on this list, to run all Unit Tests
unit_tests_to_run = \
[
    "test_it_is_sunny",
    # "test_it_is_hot",
]

my_test_file.run_unit_tests( unit_tests_to_run )
</code></pre>
<hr/>
<p>Alternatively, you can use <a href="https://docs.python.org/3/library/unittest.html#load-tests-protocol" rel="nofollow noreferrer">https://docs.python.org/3/library/unittest.html#load-tests-protocol</a> and define the following method on your test module/file:</p>
<pre><code>def load_tests(loader, standard_tests, pattern):
    suite = unittest.TestSuite()
    suite.addTest( LineBalancingUnitTests( 'test_it_is_sunny' ) )
    return suite
</code></pre>
<p>If you want to limit the execution to one single test, you just need to set the test discovery pattern to the only file where you defined the <code>load_tests()</code> function.</p>
<pre class="lang-py prettyprint-override"><code>#! /usr/bin/env python3
# -*- coding: utf-8 -*-
import os
import sys
import unittest

test_pattern = 'mytest/module/name.py'
PACKAGE_ROOT_DIRECTORY = os.path.dirname( os.path.realpath( __file__ ) )

loader = unittest.TestLoader()
start_dir = os.path.join( PACKAGE_ROOT_DIRECTORY, 'testing' )

suite = loader.discover( start_dir, test_pattern )
runner = unittest.TextTestRunner( verbosity=2 )
results = runner.run( suite )

print( "results: %s" % results )
print( "results.wasSuccessful: %s" % results.wasSuccessful() )

sys.exit( not results.wasSuccessful() )
</code></pre>
<p>References:</p>
<ol>
<li><a href="https://stackoverflow.com/questions/2812218/problem-with-sys">Problem with sys.argv[1] when unittest module is in a script</a></li>
<li><a href="https://stackoverflow.com/questions/2597827/is-there-a-way-to-loop-through-and-execute-all-of-the-functions">Is there a way to loop through and execute all of the functions in a Python class?</a></li>
<li><a href="https://stackoverflow.com/questions/1398022/looping-over-all-member-variables-of-a-class-in-python">looping over all member variables of a class in python</a></li>
</ol>
<hr/>
<p>Alternatively to the last main program example, I came up with the following variation after reading the <code>unittest.main()</code> method implementation:</p>
<ol>
<li><a href="https://github.com/python/cpython/blob/master/Lib/unittest/main.py#L65" rel="nofollow noreferrer">https://github.com/python/cpython/blob/master/Lib/unittest/main.py#L65</a></li>
</ol>
<pre class="lang-py prettyprint-override"><code>#! /usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import sys
import unittest

PACKAGE_ROOT_DIRECTORY = os.path.dirname( os.path.realpath( __file__ ) )
start_dir = os.path.join( PACKAGE_ROOT_DIRECTORY, 'testing' )

from testing_package import main_unit_tests_module
testNames = ["TestCaseClassName.test_nameHelloWorld"]

loader = unittest.TestLoader()
suite = loader.loadTestsFromNames( testNames, main_unit_tests )

runner = unittest.TextTestRunner(verbosity=2)
results = runner.run( suite )

print( "results: %s" % results )
print( "results.wasSuccessful: %s" % results.wasSuccessful() )
sys.exit( not results.wasSuccessful() )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is another way</p>
<pre><code>testname = "testItIsHot"
testcase = MyCase(testname)
testcase.testItIsHot()
</code></pre>
</div>
<span class="comment-copy">Please consider updating the accepted <a href="https://stackoverflow.com/a/26531790/">answer</a> to the one by Ajay; it actually works.</span>
<span class="comment-copy">Oh my! Since the tests are to be run on python2.6 (99% of the time I <i>can</i> test the tests themselves with python2.7), I was looking at 2.6.8 doc and missed so much! :-)</span>
<span class="comment-copy">Just noticed that this works only if the method is called "test*", so unfortunately it cannot be used to occasionally run test that is "disabled" by rename</span>
<span class="comment-copy">Doesn't work for tests in a subdirectory - the most common case in a mature Python program.</span>
<span class="comment-copy">@TomSwirly Can't check now but I think you can do it by creatiing (empty) <code>__init__.py</code> inside that direcrory (and subdirs, if any) and calling eg. <code>python test/testMyCase.py test.MyCase.testItIsHot</code>.</span>
<span class="comment-copy">Nothing happens when I do this. I found workarounds, but I was hoping this method would work for me.</span>
<span class="comment-copy">This should be the accepted answer.</span>
<span class="comment-copy">This is so clunkily Java-esque. "long_module_name.SameLongNameAsAClass.test_long_name_beginning_with_test_as_a_convention" ...better hope you didn't modularize into suites like a sane person who tests their code.</span>
<span class="comment-copy">I found the second part of this answer extremely helpful: I am writing tests in Eclipse + PyDev and I don't want to switch to the command line!</span>
<span class="comment-copy">I found this useful when trying to run single tests from the command line.</span>
<span class="comment-copy">+1 and since terminology can be confusing if new to a language (and the <code>usage</code> is even oddly inconsistent):  running  <code>python -m unittest module_test.TestClass.test_method</code> assumes a file <code>module_test.py</code> (run from current directory; and <code>__init.py__</code> is <i>not</i> required); and <code>module_test.py</code> contains <code>class TestClass(unittest.TestCase)...</code> which contains <code>def test_method(self,...)</code> (this also works for me on python 2.7.13)</span>
<span class="comment-copy">This. This is exactly the simple answer I was looking for. Thank you ^_^</span>
<span class="comment-copy">This does not answer the question, which explicitly says "via command line".</span>
