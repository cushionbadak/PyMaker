<div class="post-text" itemprop="text">
<p>I'm working on an AI portion of a guessing game. I want the AI to select a random letter from this list. I'm doing it as a set so I can easily remove letters from the list as they are guessed in the game and are therefore no longer available to be guessed again.</p>
<p>it says <code>set</code> object isn't indexable. How can I work around this?</p>
<pre><code>import random 
aiTurn=True

while aiTurn == True:
    allLetters = set(list('abcdefghijklmnopqrstuvwxyz'))
    aiGuess=random.choice(allLetters)



    print (aiGuess) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; random.sample(set('abcdefghijklmnopqrstuvwxyz'), 1)
['f']
</code></pre>
<p>Documentation: <a href="https://docs.python.org/3/library/random.html#random.sample" rel="noreferrer">https://docs.python.org/3/library/random.html#random.sample</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You should use random.choice(tuple(myset)), because it's faster and arguably cleaner looking than random.sample.  I wrote the following to test:</p>
<pre><code>import random
import timeit

bigset = set(random.uniform(0,10000) for x in range(10000))

def choose():
    random.choice(tuple(bigset))

def sample():
    random.sample(bigset,1)[0]

print("random.choice:", timeit.timeit(choose, setup="global bigset", number=10000)) # 1.1082136780023575
print("random.sample:", timeit.timeit(sample, setup="global bigset", number=10000)) # 1.1889629259821959
</code></pre>
<p>From the numbers it seems that random.sample takes 7% longer.</p>
</div>
<span class="comment-copy">Incidentally you don't need to use set(list('string')) to get a set of letters since strings are iterable by themselves -- set('abc') will do what you want.</span>
<span class="comment-copy">For others encountering this problem, it's worth looking at this question about how to create a set-like object which allows efficient random selection.  The options given here are all O(N).  <a href="http://stackoverflow.com/q/15993447/2966723">stackoverflow.com/q/15993447/2966723</a></span>
<span class="comment-copy">Tack on a <code>[0]</code> at the end so it's basically identical to <code>random.choice</code> (which doesn't return it's values in the form of a list)</span>
<span class="comment-copy"><code>random.sample</code> does <code>tuple(population)</code> internally, so <code>random.choice(tuple(allLetters))</code> may be better.</span>
<span class="comment-copy">It should be highlighted that this process is O(N).</span>
<span class="comment-copy">@Joel Why is this process is O(N)?</span>
<span class="comment-copy">@ManuelSchneid3r 2 reasons.  1) <code>random.sample</code> converts the set into a list or tuple and then randomly selects an element from it, so to convert a set to a list takes O(N) operations. This occurs any time you call it with a set.   2) in this particular case, since this starts from a string, converting it to a set also takes O(N).</span>
<span class="comment-copy">On my machine, random.choice is 7 times faster.</span>
<span class="comment-copy">There's no way to select directly from set, without having to copy it into tuple?</span>
<span class="comment-copy">I get sample being roughly 12% (250 ms) slower than choose on a set of 5000 elements.</span>
<span class="comment-copy">On my machine, <code>random.sample</code> goes from being slower than <code>random.choice</code> to being faster than it as the set size grows (the crossover point is somewhere between set size 100k-500k). That is, the larger the set, the more likely it is for <code>random.sample</code> to be faster.</span>
