<div class="post-text" itemprop="text">
<p>My question is about coding style: When I want to apply a procedure to several variables, like:</p>
<pre><code>from pylab import vstack     # the function to apply to many variables
v1 = range(5)      # some dummy variables
v2 = range(9)
...
v20 = range(8)

# now, I want to apply a function to all variables that changes them!
v1 = vstack(v1)   # I really do not need the "old" v1 anymore
v2 = vstack(v2)
...
v20 = vstack(v20)
</code></pre>
<p>These are 20 lines of almost the same code.
Is there a way to write the conversions ( <code>vx = vstack(vx)</code> ) in fewer lines?</p>
<p>Putting them in an iterable does not work:</p>
<pre><code>all_v = [v1, v2, v3, .... , v20]
for v in all_v:
    v = vstack(v)

type (v1) # -&gt; v1: &lt;type: list&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Do you really need them to be in separate variables to begin with? That's usually a code smell. I'd keep them in a list, or a dict if the names are significant, and update that:</p>
<pre><code>my_data = {}
my_data['v1'] = range(5)
my_data['v2'] = range(9)
...etc...

my_data = {k: vstack(v) for k, v in my_data.iteritems()}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from pylab import vstack
parameters = (5, 9, ..., 8)

v = [vstack(range(p)) for p in parameters]
</code></pre>
<p>This will run a list comprehension on the <code>parameters</code> tuple, which contains your parameters to the <code>range</code> function. For each parameter in that tuple, the result of the <code>range</code> function is passed to the <code>vstack</code> function. The results are collected in a list.</p>
<p>So <code>v[0]</code> corresponds to the result for the parameter value <code>parameters[0]</code> etc.</p>
<p>In your code it didn’t work because you were locally overwriting the <code>v</code> variable within the loop. This will not change the item in the original list. If you wanted to create a (new) list from those results, you could use <code>list.append</code>:</p>
<pre><code>all_v = [v1, v2, v3, .... , v20]
new_v = []
for v in all_v:
    new_v.append(vstack(v))
</code></pre>
</div>
<span class="comment-copy">Your proposition to "bundle" the variables works of course, and I think I'll do this. However, I'd like to know (curiosity) if there is a solution for my problem?</span>
<span class="comment-copy">You can do it by updating the <code>locals()</code> dictionary. However, this really isn't recommended. <code>locals().update({k: v for k, v in locals().items() if k in ['v1', 'v2' ... ]})</code></span>
<span class="comment-copy">That's it - Thanks!</span>
<span class="comment-copy">Thanks! However, for the <i>practical</i> part, I think Daniel's solution is fine. Still, I'm interested (pure curiosity) to know if there is a solution for my original problem.</span>
<span class="comment-copy">@user2055010 Isn’t that answered in the last paragraph &amp; code extract? This is your original tried solution, just working.</span>
<span class="comment-copy">Then, I don't have the new values on the old variable names. (Daniel proposed to update the <code>locals()</code> dictionary - that was what I was looking for.)</span>
<span class="comment-copy">@user2055010 You <a href="http://docs.python.org/3/library/functions.html#locals" rel="nofollow noreferrer">should never</a> update those values directly. It’s very implementation specific and not guaranteed to work. Change the way you are storing the original values.</span>
