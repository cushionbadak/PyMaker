<div class="post-text" itemprop="text">
<p>First of all, sorry for the wording of the question, I can't express it in a more compact form.</p>
<p>Let's say I have a code like this in Python:</p>
<pre><code>something_happened = False
def main():
    # 'procs' is a list of procedures
    for proc in procs:
        try:
            # Any of these can set the 'something_happened'
            # global var to True
            proc()
        except as e:
            handle_unexpected_exception(e)
            continue
    # If some procedure found some problem,
    # print a remainder to check the logging files
    if something_happened:
        print('Check the logfile, just in case.')
</code></pre>
<p>Any of the involved procedures may encounter some problem but execution <strong>MUST</strong> continue, the problem is properly logged and that's the <strong>ONLY</strong> handling needed, really, because the problems that may arise while running the procedures shouldn't stop the program, this shouldn't involve raising an exception and stopping the execution.</p>
<p>The reason why the logfile should be checked is that some of the problems may need further human action, but the program can't do anything about them, other than logging them and keep running (long story).</p>
<p>Right now the only way of achieving this that I can think about is to make each procedure to set <code>something_happened == True</code> after logging a potential problem, but using a global variable which may be set from any of the procedures, or returning a status code from the procedures.</p>
<p>And yes, I know I can raise an exception from the procedures instead of setting a global or returning an error code, but that would only work because I'm running them in a loop, and this may change in the future (and then raising an exception will jump out the try-block), so that's my last resort.</p>
<p>Can anyone suggest a better way of dealing with this situation? Yes, I know, this is a very particular use case, but that's the reason why I'm not raising an exception in the first place, and I'm just curious because I didn't find anything after googling for hours...</p>
<p>Thanks in advance :)</p>
</div>
<div class="post-text" itemprop="text">
<p>You have a variable that may be set to <code>True</code> by any of the <code>proc</code>s. It looks like a common OOP schema:</p>
<pre><code>class A():
    """Don't do that"""
    def __init__(self, logger):
        self._logger = logger
        self._something_happened = False

    def proc1(self):
        try:
            ...
        except KeyError as e:
            self._something_happened = True
            self._logger.log(...)

    def proc2(self):
        ...

    def execute(self):
        for proc in [self.proc1, self.proc2, ...]:
            try:
                proc()
            except as e:
                self._handle_unexpected_exception(e)
                continue
        if self._something_happened:
            print('Check the logfile, just in case.')
</code></pre>
<p>But that's <strong>a very bad idea</strong>, because you're violating the <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="nofollow noreferrer">Single Responsibility Principle</a>: your classs has to know about <code>proc1</code>, <code>proc2</code>, ... You have to reverse the idea:</p>
<pre><code>class Context:
    def __init__(self):
        self.something_happened = False

def main():
    ctx = Context()
    for proc in procs:
        try:
            proc(ctx) # proc may set ctx.something_happened to True
        except as e:
            handle_unexpected_exception(e)
            continue

    if ctx.something_happened:
        print('Check the logfile, just in case.')
</code></pre>
<p>Creating a void class like that is not attracting. You can take the idea further:</p>
<pre><code>class Context:
    def __init__(self, logger):
        self._logger = logger
        self._something_happened = False

    def handle_err(self, e):
        self._something_happened = True
        self._logger.log(...)

    def handle_unexpected_exception(self, e):
        ...
        self._logger.log(...)

    def after(self):
        if self._something_happened:
            print('Check the logfile, just in case.')


def proc1(ctx):
    try:
        ...
    except KeyError as e:
        ctx.handle_err(e) # you delegate the error handling to ctx

def proc2(ctx):
    ...

def main():
    ctx = Context(logging.gerLogger("main"))
    for proc in procs:
        try:
            proc(ctx)
        except as e:
            ctx.handle_unexpected_exception(e)

    ctx.after()
</code></pre>
<p>The main benefit here is you that can use another <code>Context</code> if you want:</p>
<pre><code>def StrictContext():
    def handle_err(self, e):
        raise e

    def handle_unexpected_exception(self, e):
        raise e

    def after(self):
        pass
</code></pre>
<p>Or </p>
<pre><code>class LooseContext:
    def handle_err(self, e):
        pass

    def handle_unexpected_exception(self, e):
        pass

    def after(self):
        pass
</code></pre>
<p>Or whatever you need.</p>
</div>
<div class="post-text" itemprop="text">
<p>Looks like the cleaner solution is to raise an exception, and I will change the code accordingly. They only problem is what will happen if in the future the loop goes away, but I suppose I'll cross that bridge when I arrive to it ;) and then I'll use another solution or I'll try to change the main code miself.</p>
<p>@cglacet, @Phydeaux, thanks for your help and suggestions.</p>
</div>
<span class="comment-copy">What is the problem with raising an exception? Why would the loop have anything to do with an exception escaping the try block?</span>
<span class="comment-copy">If instead of a loop we have a try block with all the procedures inside, raising an exception would exit the try block, so the procedures below the one raising the exception wouldn't be run, unless I use a different try block for each and every procedure. I would like to avoid that, so that's why it's my last resort</span>
<span class="comment-copy">If you don't use a different try block for each procedure, then you definitely won't satisfy the "execution <b>MUST</b> continue" constraint that you mention. You realise that you are using a different block for each currently, right? Why would you like to avoid it?</span>
<span class="comment-copy">Your code looks just right to me, it does exactly what you asked for? Unless I'm missing a detail here â€¦ ps: you are missing a <code>something_happened = True</code> when an exception is captured.</span>
<span class="comment-copy">@Phydeaux, I don't want to avoid to use a different block, it may be a request later (avoiding the loop, I mean). And yes, the code works now, by using a global variable, which is what I wanted to avoid if there's a better way of doing things.</span>
<span class="comment-copy">This solution is <b>brilliant</b> and elegant. I'm going to use a variant of this because I think it can be applied to other parts of the code. I didn't ever imagined to use a context for this! Thanks a lot @jferard</span>
