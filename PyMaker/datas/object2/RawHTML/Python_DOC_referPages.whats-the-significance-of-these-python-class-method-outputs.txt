<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/1535327/how-to-print-objects-of-class-using-print">How to print objects of class using print()?</a>
<span class="question-originals-answer-count">
                    11 answers
                </span>
</li>
</ul>
</div>
<p>Imagine we have a class with three methods defined:</p>
<pre class="lang-py prettyprint-override"><code>class MyClass:

    def instance_method(self):
        return "Instance method called", self

    @classmethod
    def class_method(cls):
        return "Class method called", cls

    @staticmethod
    def static_method():
        return "Static method called"
</code></pre>
<p>We instantiate it and call the instance method:</p>
<pre><code>obj1 = MyClass()
obj1.instance_method()
# --&gt; ('Instance method called', &lt;__main__.MyClass at 0x106634588&gt;)
</code></pre>
<p>And then we call the class method:</p>
<pre><code>obj1.class_method()
# --&gt; ('Class method called', __main__.MyClass)
</code></pre>
<p>I'm having trouble understanding why the instance method is bracketed by '&lt;&gt;', and why it contains a pointer to a location in memory when the class method does not. </p>
</div>
<div class="post-text" itemprop="text">
<p>All three serve for different purposes. But let's start with this:</p>
<pre><code>class MyClass:
    def method(x):
        return "method called", x
</code></pre>
<p>when you have an instance <code>y = MyClass()</code> and call <code>y.method()</code>, what do you expect for <code>x</code> in the function?</p>
<ul>
<li>If you want <code>x</code> to be the object <code>y</code>, it is the instance method;</li>
<li>If you want that to be not <code>y</code> but the class of <code>y</code>, it is the class method (remember you cannot check anything specific to <code>y</code> any more, only the stuff generic for the whole class is allowed); and</li>
<li>If you want that to be nothing -- you do not even need to know the object <code>y</code> inside the function, nor the class of <code>y</code>, and hence <code>x</code> should not even exist -- that will be a best fit for static method. We usually use static method for things normally a function can do but try to wrap it under a class so it does not pollute the global name space.</li>
</ul>
</div>
<span class="comment-copy">Because the default <code>repr</code> of an instance is different to the default <code>repr</code> of a class. See e.g. <a href="https://stackoverflow.com/q/1535327/3001761">stackoverflow.com/q/1535327/3001761</a></span>
<span class="comment-copy">On python3.7 these two respectively prints: <code>&lt;__main__.MyClass object at 0x7f1e9468a160&gt;</code> and <code>&lt;class '__main__.MyClass'&gt;</code>.</span>
<span class="comment-copy">Ditto for Python 2.7, whether <code>MyClass</code> is an old-style or new-style class.</span>
<span class="comment-copy">You appear to be using IPython, or a Jupyter notebook or something else backed by IPython. This is something you should always mention when asking questions, as IPython does a lot of custom handling that regular Python doesn't.</span>
<span class="comment-copy"><code>__repr__</code> isn't actually being used here. You're seeing IPython's custom printing logic.</span>
<span class="comment-copy">This is a good explanation, my question was just about why the instance and class methods had different outputs (answer: their <b>repr</b> attributes are different by default)</span>
