<div class="post-text" itemprop="text">
<p>I wrote a small Python extension that bundles, compiles and statically links with a small C library with one optional .S (assembler) file. Distutils's Extension() doesn't recognize the .S by default. Is there a good way to compile that file, or should I just shell out to <code>make</code>? Right now I compile the C code only for a slightly slower library.</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't know how new it is, but the <code>Extension</code> class has an <a href="https://docs.python.org/3/distutils/apiref.html#distutils.core.Extension" rel="nofollow noreferrer"><code>extra_objects</code></a> argument, which I found can specify assembly files. So for example, my <code>setup.py</code> looks something like this:</p>
<pre><code>example_module = Extension('_example',
    extra_compile_args = ['-Wall', '-g', '-std=c++11'],
    sources=['something.cpp'],
    extra_objects=['asm_amd64.s'])
</code></pre>
<p>I double checked, and if you inspect the generated library with <code>nm -D example.so</code>, the assembly functions are properly assembled and linked if you include it in the <code>extra_objects</code>, but they are not linked if you don't include it in that argument. So it seems to work.</p>
</div>
<div class="post-text" itemprop="text">
<p>As distributed, distutils don't know about assembly code, and I don't know of extensions to it that let it deal automatically with it.  In a similar situation I've always built the library separately (with C and assembly as needed and feasible) and only used the resulting <code>.a</code> with setup.py.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is an open feature request about this: <a href="http://bugs.python.org/issue2942" rel="nofollow">http://bugs.python.org/issue2942</a></p>
</div>
