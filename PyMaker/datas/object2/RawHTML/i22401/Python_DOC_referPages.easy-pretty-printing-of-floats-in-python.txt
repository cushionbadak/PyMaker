<div class="post-text" itemprop="text">
<p>I have a list of floats. If I simply <code>print</code> it, it shows up like this:</p>
<pre><code>[9.0, 0.052999999999999999, 0.032575399999999997, 0.010892799999999999, 0.055702500000000002, 0.079330300000000006]
</code></pre>
<p>I could use <code>print "%.2f"</code>, which would require a <code>for</code> loop to traverse the list, but then it wouldn't work for more complex data structures.
I'd like something like (I'm completely making this up)</p>
<pre><code>&gt;&gt;&gt; import print_options
&gt;&gt;&gt; print_options.set_float_precision(2)
&gt;&gt;&gt; print [9.0, 0.052999999999999999, 0.032575399999999997, 0.010892799999999999, 0.055702500000000002, 0.079330300000000006]
[9.0, 0.05, 0.03, 0.01, 0.06, 0.08]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's an old question but I'd add something potentially useful:</p>
<p>I know you wrote your example in raw Python lists, but if you decide to use <code>numpy</code> arrays instead (which would be perfectly legit in your example, because you seem to be dealing with arrays of numbers), there is (almost exactly) this command you said you made up:</p>
<pre><code>import numpy as np
np.set_printoptions(precision=2)
</code></pre>
<p>Or even better in your case if you still want to see all decimals of really precise numbers, but get rid of trailing zeros for example, use the formatting string <code>%g</code>:</p>
<pre><code>np.set_printoptions(formatter={"float_kind": lambda x: "%g" % x})
</code></pre>
<p>For just printing once and not changing global behavior, use <code>np.array2string</code> with the same arguments as above.</p>
</div>
<div class="post-text" itemprop="text">
<p>As noone has added it, it should be noted that going forward from Python 2.6+ the recommended way to do <a href="http://docs.python.org/library/string.html#string-formatting" rel="noreferrer">string formating</a> is with <a href="http://docs.python.org/library/string.html#string.Formatter.format" rel="noreferrer"><code>format</code></a>, to get ready for Python 3+.</p>
<pre><code>print ["{0:0.2f}".format(i) for i in a]
</code></pre>
<p><a href="http://www.python.org/dev/peps/pep-3101" rel="noreferrer">The new</a> <a href="http://docs.python.org/library/string.html#format-string-syntax" rel="noreferrer">string formating syntax</a> is not hard to use, and yet is quite powerfull.</p>
<p>I though that may be <a href="http://docs.python.org/library/pprint.html" rel="noreferrer"><code>pprint</code></a> could have something, but I haven't found anything.</p>
</div>
<div class="post-text" itemprop="text">
<p>A more permanent solution is to subclass <code>float</code>:</p>
<pre><code>&gt;&gt;&gt; class prettyfloat(float):
    def __repr__(self):
        return "%0.2f" % self

&gt;&gt;&gt; x
[1.290192, 3.0002, 22.119199999999999, 3.4110999999999998]
&gt;&gt;&gt; x = map(prettyfloat, x)
&gt;&gt;&gt; x
[1.29, 3.00, 22.12, 3.41]
&gt;&gt;&gt; y = x[2]
&gt;&gt;&gt; y
22.12
</code></pre>
<p>The problem with subclassing <code>float</code> is that it breaks code that's explicitly looking for a variable's type.  But so far as I can tell, that's the only problem with it.  And a simple <code>x = map(float, x)</code> undoes the conversion to <code>prettyfloat</code>.</p>
<p>Tragically, you can't just monkey-patch <code>float.__repr__</code>, because <code>float</code>'s immutable.</p>
<p>If you don't want to subclass <code>float</code>, but don't mind defining a function, <code>map(f, x)</code> is a lot more concise than <code>[f(n) for n in x]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You can do:</p>
<pre><code>a = [9.0, 0.052999999999999999, 0.032575399999999997, 0.010892799999999999, 0.055702500000000002, 0.079330300000000006]
print ["%0.2f" % i for i in a]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Note that you can also multiply a string like "%.2f" (example: "%.2f "*10).</p>
<pre><code>&gt;&gt;&gt; print "%.2f "*len(yourlist) % tuple(yourlist)
2.00 33.00 4.42 0.31 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>print "[%s]"%", ".join(map(str,yourlist))
</code></pre>
<p>This will avoid the rounding errors in the binary representation when printed, without introducing a fixed precision constraint (like formating with <code>"%.2f"</code>):</p>
<pre><code>[9.0, 0.053, 0.0325754, 0.0108928, 0.0557025, 0.0793303]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The most easy option should be to use a rounding routine:</p>
<pre><code>import numpy as np
x=[9.0, 0.052999999999999999, 0.032575399999999997, 0.010892799999999999, 0.055702500000000002, 0.079330300000000006]

print('standard:')
print(x)
print("\nhuman readable:")
print(np.around(x,decimals=2))
</code></pre>
<p>This produces the output:</p>
<pre><code>standard:
[9.0, 0.053, 0.0325754, 0.0108928, 0.0557025, 0.0793303]

human readable:
[ 9.    0.05  0.03  0.01  0.06  0.08]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I believe that Python 3.1 will print them nicer by default, without any code changing. But that is useless if you use any extensions that haven't been updated to work with Python 3.1</p>
</div>
<div class="post-text" itemprop="text">
<p>List comps are your friend.</p>
<pre><code>print ", ".join("%.2f" % f for f in list_o_numbers)
</code></pre>
<p>Try it:</p>
<pre><code>&gt;&gt;&gt; nums = [9.0, 0.052999999999999999, 0.032575399999999997, 0.010892799999999999]
&gt;&gt;&gt; print ", ".join("%.2f" % f for f in nums)
9.00, 0.05, 0.03, 0.01
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use pandas. </p>
<p>Here is an example with a list:</p>
<pre><code>In: import pandas as P
In: P.set_option('display.precision',3)
In: L = [3.4534534, 2.1232131, 6.231212, 6.3423423, 9.342342423]
In: P.Series(data=L)
Out: 
0    3.45
1    2.12
2    6.23
3    6.34
4    9.34
dtype: float64
</code></pre>
<p>If you have a dict d, and you want its keys as rows:</p>
<pre><code>In: d
Out: {1: 0.453523, 2: 2.35423234234, 3: 3.423432432, 4: 4.132312312}

In: P.DataFrame(index=d.keys(), data=d.values())
Out:  
    0
1   0.45
2   2.35
3   3.42
4   4.13
</code></pre>
<p>And another way of giving dict to a DataFrame:</p>
<pre><code>P.DataFrame.from_dict(d, orient='index')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>l = [9.0, 0.052999999999999999, 0.032575399999999997, 0.010892799999999999, 0.055702500000000002, 0.079330300000000006]
</code></pre>
<p>Python 2:</p>
<pre><code>print ', '.join('{:0.2f}'.format(i) for i in l)
</code></pre>
<p>Python 3:</p>
<pre><code>print(', '.join('{:0.2f}'.format(i) for i in l))
</code></pre>
<p>Output:</p>
<pre><code>9.00, 0.05, 0.03, 0.01, 0.06, 0.08
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First, elements inside a collection print their repr. you should learn about <code>__repr__</code> and <code>__str__</code>.</p>
<p>This is the difference between print repr(1.1) and print 1.1. Let's join all those strings instead of the representations:</p>
<pre><code>numbers = [9.0, 0.053, 0.0325754, 0.0108928, 0.0557025, 0.07933]
print "repr:", " ".join(repr(n) for n in numbers)
print "str:", " ".join(str(n) for n in numbers)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I just ran into this problem while trying to use pprint to output a list of tuples of floats.
Nested comprehensions might be a bad idea, but here's what I did:</p>
<pre><code>tups = [
        (12.0, 9.75, 23.54),
        (12.5, 2.6, 13.85),
        (14.77, 3.56, 23.23),
        (12.0, 5.5, 23.5)
       ]
pprint([['{0:0.02f}'.format(num) for num in tup] for tup in tups])
</code></pre>
<p>I used generator expressions at first, but pprint just repred the generator...</p>
</div>
<div class="post-text" itemprop="text">
<p>I had this problem, but none of the solutions here did <em>exactly</em> what I wanted (I want the printed output to be a valid python expression), so how about this:</p>
<pre><code>prettylist = lambda l : '[%s]' % ', '.join("%.2f" % f for f in l)
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; ugly = [9.0, 0.052999999999999999, 0.032575399999999997,
            0.010892799999999999, 0.055702500000000002, 0.079330300000000006]
&gt;&gt;&gt; prettylist = lambda l : '[%s]' % ', '.join("%.2f" % f for f in l)
&gt;&gt;&gt; print prettylist(ugly)
[9.00, 0.05, 0.03, 0.01, 0.06, 0.08]
</code></pre>
<p>(I know .format() is supposed to be the more standard solution, but I find this more readable)</p>
</div>
<div class="post-text" itemprop="text">
<p>The code below works nice to me.</p>
<pre><code>list = map (lambda x: float('%0.2f' % x), list)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To control the number of <strong>significant</strong> digits, use the format specifier %g.</p>
<p>Let's name Emile's solution prettylist2f. Here is the modified one:</p>
<pre><code>prettylist2g = lambda l : '[%s]' % ', '.join("%.2g" % x for x in l)
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; c_e_alpha_eps0 = [299792458., 2.718281828, 0.00729735, 8.8541878e-12]
&gt;&gt;&gt; print(prettylist2f(c_e_alpha_eps0)) # [299792458.00, 2.72, 0.01, 0.00]
&gt;&gt;&gt; print(prettylist2g(c_e_alpha_eps0)) # [3e+08, 2.7, 0.0073, 8.9e-12]
</code></pre>
<p>If you want flexibility in the number of significant digits, use <a href="https://docs.python.org/3/reference/lexical_analysis.html#formatted-string-literals" rel="nofollow noreferrer">f-string formatting</a> instead:</p>
<pre><code>prettyflexlist = lambda p, l : '[%s]' % ', '.join(f"{x:.{p}}" for x in l)
print(prettyflexlist(3,c_e_alpha_eps0)) # [3e+08, 2.72, 0.0073, 8.85e-12]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I agree with SilentGhost's comment, the for loop isn't that bad.  You can achieve what you want with:</p>
<pre><code>l = [9.0, 0.052999999999999999, 0.032575399999999997, 0.010892799999999999, 0.055702500000000002, 0.079330300000000006]
for x in l: print "%0.2f" % (x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As of Python 3.6, you can use f-strings:</p>
<pre class="lang-py prettyprint-override"><code>list_ = [9.0, 0.052999999999999999, 
         0.032575399999999997, 0.010892799999999999, 
         0.055702500000000002, 0.079330300000000006]

print(*[f"{element:.2f}" for element in list_])
#9.00 0.05 0.03 0.01 0.06 0.08
</code></pre>
<p>You can use print parameters while keeping code very readable:</p>
<pre><code>print(*[f"{element:.2f}" for element in list_], sep='|', end='&lt;--')
#9.00|0.05|0.03|0.01|0.06|0.08&lt;--
</code></pre>
</div>
<span class="comment-copy">This was the one I used but I added <code>.replace("'", "")</code> to get rid of those commas.    <code>str(["{0:0.2f}".format(i) for i in a]).replace("'", "")</code></span>
<span class="comment-copy">This will produce a list of string. In the printed output, every element has <code>''</code> around it.  For example, for <code>a=[0.2222, 0.3333]</code>, it will produce <code>['0.22', '0.33']</code>.</span>
<span class="comment-copy">To remove the apex and the commas, you should use <code>' '.join([{0:0.2f}".format(i) for i in a])</code></span>
<span class="comment-copy">I would have thought there was a simpler solution, but your answer is clearly the best, since you're about the only one to actually answer my question.</span>
<span class="comment-copy">He's the only one to actually answer your -edited- question. Not disparaging the answerer, but you can't clarify a question and then slight the rest of the answerers based on the information we were working with.</span>
<span class="comment-copy">My original question did mention that I considered a for loop was not a good solution (for me a list comprehension is the same, but I agree that wasn't clear). I'll try being clearer next time.</span>
<span class="comment-copy">[f(n) for n in x] is much more pythonic than map(f, x).</span>
<span class="comment-copy">I'm not necessarily in favor of subclassing float, but I don't think type checking is a valid argument.  When checking types, <code>isinstance</code> should be used, not equality of <code>type()</code>.  When it is done correctly, a subclass of float will still be counted as a float.</span>
<span class="comment-copy">This will print ['9.00', '0.05', '0.03', '0.01', '0.06', '0.08'] - with quote marks, which you usually don't want (I prefer to have a valid list of floats printed)</span>
<span class="comment-copy">very elegant!  I like it</span>
<span class="comment-copy">-1 terrible hack. Join formatted pieces of strings, not other way around please</span>
<span class="comment-copy">so kaizer.se, are you proposing " ".join(["%.2f" % x for x in yourlist]) .  I have having to do this kind of construction in python.</span>
<span class="comment-copy">yes, I propose <code>" ".join("%.2f" % x for x in yourlist)</code> since parting format string and interpolation values is much worse than using an ugly Python idiom.</span>
<span class="comment-copy">adds an empty space at the end...</span>
<span class="comment-copy">Python 3.1 will print the shortest decimal representation that maps to that float value.  For example: &gt;&gt;&gt;a, b = float(1.1), float(1.1000000000000001) &gt;&gt;&gt;a 1.1000000000000001 &gt;&gt;&gt;b 1.1000000000000001 &gt;&gt;&gt;print(a,b) 1.1 1.1</span>
<span class="comment-copy">A generator expression would be even better: ", ".join("%.2f" % f for f in list_o_numbers)</span>
<span class="comment-copy">@efotinis Haven't added those to my repertoire yet, but you're right -- that's pretty sexy.</span>
<span class="comment-copy">Please do not edit my answer.</span>
<span class="comment-copy">@Jed: Please read the FAQ, section "Other people can edit my stuff?!": <a href="http://stackoverflow.com/faq">stackoverflow.com/faq</a>. Not every edit is a good one, but this one was a genuine improvement. Perhaps you can list both techniques in your answer, and add a note about the difference?</span>
<span class="comment-copy">NOTE: In Python 2.7, for this example, the results of the "repr" line and the "str" line are identical.</span>
<span class="comment-copy">While for loops aren't ugly, this usage isn't terribly Pythonic.</span>
<span class="comment-copy">Could you elaborate why you downvote ?</span>
