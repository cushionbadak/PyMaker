<div class="post-text" itemprop="text">
<p>I'm new to Python and reading someone else's code:</p>
<p>should <code>urllib.urlopen()</code> be followed by <code>urllib.close()</code>? Otherwise, one would leak connections, correct?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>close</code> method must be called on the <em>result</em> of <code>urllib.urlopen</code>, <strong>not</strong> on the <code>urllib</code> module itself as you're thinking about (as you mention <code>urllib.close</code> -- which doesn't exist).</p>
<p>The best approach: instead of <code>x = urllib.urlopen(u)</code> etc, use:</p>
<pre><code>import contextlib

with contextlib.closing(urllib.urlopen(u)) as x:
   ...use x at will here...
</code></pre>
<p>The <code>with</code> statement, and the <code>closing</code> context manager, will ensure proper closure even in presence of exceptions.</p>
</div>
<div class="post-text" itemprop="text">
<p>Like @Peter says, out-of-scope opened URLs will become eligible for garbage collection.</p>
<p>However, also note that <code>urllib.py</code> defines:</p>
<pre><code> def __del__(self):
        self.close()
</code></pre>
<p>This means that <strong>when the reference count for that instance reaches zero</strong>, its <a href="http://docs.python.org/reference/datamodel.html#object.__del__" rel="noreferrer"><code>__del__</code></a> method will be called, and thus its <code>close</code> method will be called as well.  The most "normal" way for the reference count to reach zero is to simply let the instance go out of scope, but there's nothing strictly stopping you from an explicit <code>del x</code> early (however it doesnâ€™t directly call <code>__del__</code> but just decrements the reference count by one).</p>
<p>It's certainly good style to explicitly close your resources -- especially when your application runs the risk of using too much of said resources -- but Python <em>will</em> automatically clean up for you if you don't do anything funny like maintaining (circular?) references to instances that you don't need any more.</p>
</div>
<div class="post-text" itemprop="text">
<p>Strictly speaking, this is true. But in practice, once (if) <code>urllib</code> goes out of scope, the connection will be closed by the automatic garbage collector.</p>
</div>
<div class="post-text" itemprop="text">
<p>You basically <em>do</em> need to explicitly close your connection when using <strong>IronPython</strong>. The automatic closing on going out of scope relies on the garbage collection. I ran into a situation where the garbage collection did not run for so long that Windows ran out of sockets. I was polling a webserver at high frequency (i.e. as high as IronPython and the connection would allow, ~7Hz). I could see the "established connections" (i.e. sockets in use) go up and up on PerfMon. The solution was to call <code>gc.collect()</code> after every call to <code>urlopen</code>.</p>
</div>
<span class="comment-copy">what about doing something like <code>data = urllib2.urlopen('url').read()</code></span>
<span class="comment-copy">In Python 3, direct support for the with statement was added.      with urllib.urlopen(u) as x:        ...</span>
<span class="comment-copy">How come the <a href="https://docs.python.org/3/library/contextlib.html" rel="nofollow noreferrer">python3 doc</a> still mentions <code>contextlib.closing</code> in this (ahem) context?</span>
<span class="comment-copy">It's possible, however, to overrun the garbage collector -- I've had cases where I'm creating file handles faster than it closes them [but where an explicit <code>gc.collect()</code> call, or a <code>close()</code>, cleaned things up].</span>
<span class="comment-copy">This is true of some implementations of Python, but the Python language does not guarantee that the closing will happen as soon as the object goes out of scope. cf. jython</span>
<span class="comment-copy">@gnibbler The author of this answer doesn't state it will happen <i>as soon as</i> only that it will happen.</span>
<span class="comment-copy">@Piotr, but maybe the program crashes if I have a loop opening urls and the GC isn't reaping them fast enough. It's a pretty sloppy way to do things and doesn't belong in production code.</span>
<span class="comment-copy">The no-op GC (i.e., a GC that never, ever runs) is perfectly valid for Python. You have no guarantee the GC will ever run. And <code>gc.disable</code> can disable the GC in most Python implementations.</span>
<span class="comment-copy">I managed to run out of available connections before GC went and did any cleanup. So yes you should call close if you don't want a sudden hard to find loss of connectivity.</span>
