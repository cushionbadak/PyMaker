<div class="post-text" itemprop="text">
<pre><code>def __repr__(self):
  return '&lt;%s %s (%s:%s) %s&gt;' % (
    self.__class__.__name__, self.urlconf_name, self.app_name,
    self.namespace, self.regex.pattern)
</code></pre>
<p>What is the significance/purpose of this method?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>__repr__</code> should return a printable representation of the object, most likely <em>one</em> of the ways possible to create this object. See official documentation <a href="http://docs.python.org/library/functions.html#repr" rel="noreferrer">here</a>. <code>__repr__</code> is more for developers while <code>__str__</code> is for end users.</p>
<p>A simple example:</p>
<pre><code>&gt;&gt;&gt; class Point:
...   def __init__(self, x, y):
...     self.x, self.y = x, y
...   def __repr__(self):
...     return 'Point(x=%s, y=%s)' % (self.x, self.y)
&gt;&gt;&gt; p = Point(1, 2)
&gt;&gt;&gt; p
Point(x=1, y=2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is explained quite well in the <a href="http://docs.python.org/library/functions.html#repr" rel="noreferrer">Python documentation</a>:</p>
<blockquote>
<p><strong>repr(object)</strong>: Return a string containing a printable representation of an object. This is the same value yielded by conversions (reverse quotes). It is sometimes useful to be able to access this operation as an ordinary function. For many types, this function makes an attempt to return a string that would yield an object with the same value when passed to eval(), otherwise the representation is a string enclosed in angle brackets that contains the name of the type of the object together with additional information often including the name and address of the object. A class can control what this function returns for its instances by defining a __repr__() method.</p>
</blockquote>
<p>So what you're seeing here is the default implementation of <a href="http://docs.python.org/reference/datamodel.html#object.__repr__" rel="noreferrer">__repr__</a>, which is useful for serialization and debugging.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>__repr__</code> is used by the standalone Python interpreter to display a class in printable format. Example:</p>
<pre class="lang-none prettyprint-override"><code>~&gt; python3.5
Python 3.5.1 (v3.5.1:37a07cee5969, Dec  5 2015, 21:12:44) 
[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; class StackOverflowDemo:
...     def __init__(self):
...         pass
...     def __repr__(self):
...         return '&lt;StackOverflow demo object __repr__&gt;'
... 
&gt;&gt;&gt; demo = StackOverflowDemo()
&gt;&gt;&gt; demo
&lt;StackOverflow demo object __repr__&gt;
</code></pre>
<p>In cases where a <code>__str__</code> method is not defined in the class, it will call the <code>__repr__</code> function in an attempt to create a printable representation.</p>
<pre class="lang-none prettyprint-override"><code>&gt;&gt;&gt; str(demo)
'&lt;StackOverflow demo object __repr__&gt;'
</code></pre>
<p>Additionally, <code>print()</code>ing the class will call <code>__str__</code> by default.</p>
<hr/>
<p><a href="https://docs.python.org/3/library/functions.html#repr" rel="nofollow noreferrer">Documentation</a>, if you please</p>
</div>
<div class="post-text" itemprop="text">
<p>The <strong>__repr__</strong> method simply tells Python how to print objects of a class</p>
</div>
<div class="post-text" itemprop="text">
<p>An example to see the differences between them (I copied from <a href="https://www.pythonforbeginners.com/basics/__str__-vs-__repr" rel="nofollow noreferrer">this source</a>),</p>
<pre><code>&gt;&gt;&gt; x=4
&gt;&gt;&gt; repr(x)
'4'
&gt;&gt;&gt; str(x)
'4'
&gt;&gt;&gt; y='stringy'
&gt;&gt;&gt; repr(y)
"'stringy'"
&gt;&gt;&gt; str(y)
'stringy'
</code></pre>
<p>The returns of <code>repr()</code> and <code>str()</code> are identical for <code>int x</code>, but there's a difference between the return values for <code>str</code> <code>y</code> -- one is <em>formal</em> and the other is <em>informal</em>. One of the most important differences between the formal and informal representations is that the default implementation of <code>__repr__</code> for a str value can be called as an argument to eval, and the return value would be a valid string object, like this:</p>
<pre><code>&gt;&gt;&gt; repr(y)
"'a string'"
&gt;&gt;&gt; y2=eval(repr(y))
&gt;&gt;&gt; y==y2
True
</code></pre>
<p>If you try to call the return value of <code>__str__</code> as an argument to eval, the result won't be valid.</p>
</div>
<div class="post-text" itemprop="text">
<p>When we create new types by defining classes, we can take advantage of certain features of Python to make the new classes convenient to use. One of these features is "special methods", also referred to as "magic methods".</p>
<p>Special methods have names that begin and end with two underscores. We define them, but do not usually call them directly by name. Instead, they execute automatically under under specific circumstances.</p>
<p>It is convenient to be able to output the value of an instance of an object by using a print statement. When we do this, we would like the value to be represented in the output in some understandable unambiguous format. The <strong>repr</strong> special method can be used to arrange for this to happen. If we define this method, it can get called automatically when we print the value of an instance of a class for which we defined this method. It should be mentioned, though, that there is also a <strong>str</strong> special method, used for a similar, but not identical purpose, that may get precedence, if we have also defined it.</p>
<p>If we have not defined, the <strong>repr</strong> method for the Point3D class, and have instantiated my_point as an instance of Point3D, and then we do this ...</p>
<p>print my_point
... we may see this as the output ...</p>
<p>
Not very nice, eh?</p>
<p>So, we define the <strong>repr</strong> or <strong>str</strong> special method, or both, to get better output.</p>
<pre><code>**class Point3D(object):
    def __init__(self,a,b,c):
        self.x = a
        self.y = b
        self.z = c
    def __repr__(self):
        return "Point3D(%d, %d, %d)" % (self.x, self.y, self.z)
    def __str__(self):
        return "(%d, %d, %d)" % (self.x, self.y, self.z)
my_point = Point3D(1, 2, 3)
print my_point # __repr__ gets called automatically
print my_point # __str__ gets called automatically**
</code></pre>
<p>Output ...</p>
<p>(1, 2, 3)
(1, 2, 3)</p>
</div>
<div class="post-text" itemprop="text">
<p>Implement <strong>repr</strong> for every class you implement. There should be no excuse.
Implement <strong>str</strong> for classes which you think readability is more important of non-ambiguity.</p>
<p>Refer this link: <a href="https://www.pythoncentral.io/what-is-the-difference-between-__str__-and-__repr__-in-python/" rel="nofollow noreferrer">https://www.pythoncentral.io/what-is-the-difference-between-<strong>str</strong>-and-<strong>repr</strong>-in-python/</a></p>
</div>
<span class="comment-copy">@zjm1126: do you want to know why does <code>&gt;&gt;&gt; variable</code> print what <code>__repr__()</code> returns?</span>
<span class="comment-copy">That documentation puts people to sleep. Plus, it's helpful to learn from others how this is used.</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/1436703/difference-between-str-and-repr-in-python">Difference between __str__ and __repr__ in Python</a></span>
<span class="comment-copy">For Java developers who are learning Python, the best way to look at this is as toString() in Java.</span>
<span class="comment-copy">lazy1: I primarily wanted to fix the formatting (it's useful to have examples match up as close as possible with what they'll see in a sample session), but I also tweaked the output format to explicitly be different from the assignment, as that greatly improves the clarity for someone confused over this, imho. (If I've gone to far, just re-edit, and I'll owe you a beer.)</span>
<span class="comment-copy">Omitted the reference: <a href="http://docs.python.org/reference/datamodel.html#object.__repr__" rel="nofollow noreferrer">docs.python.org/reference/datamodel.html#object.__repr__</a></span>
<span class="comment-copy">This should maybe use %r instead of %s: <a href="http://stackoverflow.com/questions/6005159/when-to-use-r-instead-of-s-in-python" title="when to use r instead of s in python">stackoverflow.com/questions/6005159/…</a></span>
<span class="comment-copy">This is not really correct. <i><code>__str__</code></i> is the output that is supposed to be human readable: <code>__repr__</code> is supposed to be a representation readable for the Python interpreter (i.e. feeding the string to the interpreter should recreate the object). If an object does not have a <code>__str__</code> method, however, <code>__repr__</code> is used instead. Also as noted: this example actually prints the <code>__str__</code> method of <code>self.x</code> and <code>self.y</code>: <code>%r</code> should be used instead of <code>%s</code> in the string formatting operation (since the class does not define <code>__str__</code>, <code>__repr__</code> is actually returned anyway, but it is an anomaly).</span>
<span class="comment-copy">I think the reverse quotes (or 'backticks') method of getting the "representation" of an object is deprecated, and was removed for version 3.0</span>
<span class="comment-copy">MatrixFrog: both true, but the current 2.x documentation still says this, which is where the quote is from.</span>
<span class="comment-copy">For many objects, __repr__ and __str__ are the same function. In fact, if you only define __str__, then __repr__ defaults to just calling __str__. The most obvious case where this is not true is strings themselves: str('stackoverflow') returns <code>stackoverflow</code> but repr('stackoverflow') is <code>'stackoverflow'</code>.</span>
<span class="comment-copy">You have that backwards, __repr__ never uses __str__, but the reverse might happen. See <a href="http://docs.python.org/reference/datamodel.html#object.%5F%5Frepr%5F%5F" rel="nofollow noreferrer">docs.python.org/reference/…</a></span>
