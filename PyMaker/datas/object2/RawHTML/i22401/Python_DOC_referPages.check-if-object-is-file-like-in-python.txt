<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/library/stdtypes.html#bltin-file-objects" rel="noreferrer">File-like objects</a> are objects in Python that behave like a real file, e.g. have a read() and a write method(), but have a different implementation. It is and realization of the <a href="http://en.wikipedia.org/wiki/Duck_typing" rel="noreferrer">Duck Typing</a> concept.</p>
<p>It is considered good practice to allow a file-like object everywhere where a file is expected so that e.g. a <a href="http://docs.python.org/library/stringio.html" rel="noreferrer">StringIO</a> or a Socket object can be used instead a real file. So it is bad to perform a check like this:</p>
<pre><code>if not isinstance(fp, file):
   raise something
</code></pre>
<p>What is the best way to check if an object (e.g. a parameter of a method) is "file-like"?</p>
</div>
<div class="post-text" itemprop="text">
<p>It is generally not good practice to have checks like this in your code at all unless you have special requirements. </p>
<p>In Python the typing is dynamic, why do you feel need to check whether the object is file like, rather than just using it as if it was a file and handling the resulting error? </p>
<p>Any check you can do is going to happen at runtime anyway so doing something like <code>if not hasattr(fp, 'read')</code> and raising some exception provides little more utility than just calling <code>fp.read()</code> and handling the resulting attribute error if the method does not exist.</p>
</div>
<div class="post-text" itemprop="text">
<p>As others have said you should generally avoid such checks. One exception is when the object might legitimately be different types and you want different behaviour depending on the type. The EAFP method doesn't always work here as an object could look like more than one type of duck!</p>
<p>For example an initialiser could take a file, string or instance of its own class. You might then have code like:</p>
<pre><code>class A(object):
    def __init__(self, f):
        if isinstance(f, A):
            # Just make a copy.
        elif isinstance(f, file):
            #Â initialise from the file
        else:
            # treat f as a string
</code></pre>
<p>Using EAFP here could cause all sorts of subtle problems as each initialisation path gets partially run before throwing an exception.
Essentially this construction mimics function overloading and so isn't very Pythonic, but it can be useful if used with care.</p>
<p>As a side note, you can't do the file check in the same way in Python 3. You'll need something like <code>isinstance(f, io.IOBase)</code> instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>For 3.1+, one of the following:</p>
<pre><code>isinstance(something, io.TextIOBase)
isinstance(something, io.BufferedIOBase)
isinstance(something, io.RawIOBase)
isinstance(something, io.IOBase)
</code></pre>
<p>For 2.x, "file-like object" is too vague a thing to check for, but the documentation for whatever function(s) you're dealing with will hopefully tell you what they actually need; if not, read the code.</p>
<hr/>
<p>As other answers point out, the first thing to ask is what exactly you're checking for. Usually, EAFP is sufficient, and more idiomatic.</p>
<p><a href="https://docs.python.org/3/glossary.html#term-file-object">The glossary</a> says "file-like object" is a synonym for "file object", which ultimately means it's an instance of one of the three <a href="https://docs.python.org/3/library/abc.html">abstract base classes</a> defined in <a href="https://docs.python.org/3/library/io.html#class-hierarchy">the <code>io</code> module</a>, which are themselves all subclasses of <code>IOBase</code>. So, the way to check is exactly as shown above.</p>
<p>(However, checking <code>IOBase</code> isn't very useful. Can you imagine a case where you need to distinguish an actual file-like <code>read(size)</code> from some one-argument function named <code>read</code> that isn't file-like, without also needing to distinguish between text files and raw binary files? So, really, you almost always want to check, e.g., "is a text file object", not "is a file-like object".)</p>
<hr/>
<p>For 2.x, while the <code>io</code> module has existed since 2.6+, built-in file objects are not instances of <code>io</code> classes, neither are any of the file-like objects in the stdlib, and neither are most third-party file-like objects you're likely to encounter. There was no official definition of what "file-like object" means; it's just "something like a builtin <a href="https://docs.python.org/2.7/library/stdtypes.html#bltin-file-objects">file object</a>", and different functions mean different things by "like". Such functions should document what they mean; if they don't, you have to look at the code.</p>
<p>However, the most common meanings are "has <code>read(size)</code>", "has <code>read()</code>", or "is an iterable of strings", but some old libraries may expect <code>readline</code> instead of one of those, some libraries like to <code>close()</code> files you give them, some will expect that if <code>fileno</code> is present then other functionality is available, etc. And similarly for <code>write(buf)</code> (although there are a lot fewer options in that direction).</p>
</div>
<div class="post-text" itemprop="text">
<p>The dominant paradigm here is EAFP: easier to ask forgiveness than permission. Go ahead and use the file interface, then handle the resulting exception, or let them propagate to the caller.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's often useful to raise an error by checking a condition, when that error normally wouldn't be raised until much later on. This is especially true for the boundary between 'user-land' and 'api' code.</p>
<p>You wouldn't place a metal detector at a police station on the exit door, you would place it at the entrance!  If not checking a condition means an error might occur that could have been caught 100 lines earlier, or in a super-class instead of being raised in the subclass then I say there is nothing wrong with checking.</p>
<p>Checking for proper types also makes sense when you are accepting more than one type.
It's better to raise an exception that says "I require a subclass of basestring, OR file" than just raising an exception because some variable doesn't have a 'seek' method...</p>
<p>This doesn't mean you go crazy and do this everywhere, for the most part I agree with the concept of exceptions raising themselves, but if you can make your API drastically clear, or avoid unnecessary code execution because a simple condition has not been met do so!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can try and call the method then catch the exception:</p>
<pre><code>try:
    fp.read()
except AttributeError:
    raise something
</code></pre>
<p>If you only want a read and a write method you could do this:</p>
<pre><code>if not (hasattr(fp, 'read') and hasattr(fp, 'write')):
   raise something
</code></pre>
<p>If I were you I would go with the try/except method.</p>
</div>
<div class="post-text" itemprop="text">
<p>Under most circumstances, the best way to handle this is not to.  If a method takes a file-like object, and it turns out the object it's passed isn't, the exception that gets raised when the method tries to use the object is not any less informative than any exception you might have raised explicitly.</p>
<p>There's at least one case where you might want to do this kind of check, though, and that's when the object's not being immediately used by what you've passed it to, e.g. if it's being set in a class's constructor.  In that case, I would think that the principle of EAFP is trumped by the principle of "fail fast."  I'd check the object to make sure it implemented the methods that my class needs (and that they're methods), e.g.:</p>
<pre><code>class C():
    def __init__(self, file):
        if type(getattr(file, 'read')) != type(self.__init__):
            raise AttributeError
        self.file = file
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I ended up running into your question when I was writing an <code>open</code>-like function that could accept a file name, file descriptor or pre-opened file-like object.</p>
<p>Rather than testing for a <code>read</code> method, as the other answers suggest, I ended up checking if the object can be opened. If it can, it's a string or descriptor, and I have a valid file-like object in hand from the result. If <code>open</code> raises a <code>TypeError</code>, then the object is already a file.</p>
</div>
<span class="comment-copy"><code>why</code> what about operators like <code>__add__</code>, <code>__lshift__</code> or <code>__or__</code> in custom classes? (file object and API: <a href="http://docs.python.org/glossary.html#term-file-object" rel="nofollow noreferrer">docs.python.org/glossary.html#term-file-object</a> )</span>
<span class="comment-copy">@naxa:So what exactly about those operators?</span>
<span class="comment-copy">Often just trying it works but I don't buy the Pythonic maxim that if it's hard to do in Python then it's wrong.  Imagine you are passed an object and there are 10 different things you might do with that object depending on its type.  You're not going to try each possibility and handle the error until you finally get it right.  That would be totally inefficient.  You don't necessarily need to ask, what type is this, but you do need to be able to ask does this object implement interface X.</span>
<span class="comment-copy">The fact that the python collections library provides what might be called "interface types" (e.g., sequence) speaks to the fact that this is often useful, even in python. In general, when someone asks "how to foo", "don't foo" is not a highly satisfactory answer.</span>
<span class="comment-copy">I believe during debugging is a legitimate use for such checks when a function requiring a file-like object raises an error and I am not sure whether the argument object is the problem or the function implementation.</span>
<span class="comment-copy">This is a useful answer -- thanks!</span>
<span class="comment-copy">Finally, someone is keep it real.</span>
<span class="comment-copy"><b>The only useful answer.</b> Why StackOverflowers continue upvoting "Stop doing what you're trying to do, because I know better... and PEP 8, EAFP, and stuff!" posts is beyond my fragile sanity. (<i>Maybe Cthulhu knows?</i>)</span>
<span class="comment-copy">Because we've run into way too much code written by people who didn't think ahead, and it breaks when you pass it something that is almost, but not quite a file because they check explicitly. The whole EAFP, duck typing thing is not some bullshit purity test. It's an actual egineering decision,</span>
<span class="comment-copy">+1: If <code>x</code> isn't file-like, then <code>x.read()</code> will raise it's own exception.  Why write an extra if-statement?  Just use the object.  It will either work or break.</span>
<span class="comment-copy">Don't even handle the exception. If someone passed in something that doesn't match the API you expect, it's not your problem.</span>
<span class="comment-copy">@Aaron Gallagher: I am not sure. Is your statement true even if it is hard for me to preserve an consistent state?</span>
<span class="comment-copy">To preserve a consistent state you can use "try/finally" (but no except!) or the new "with" statement.</span>
<span class="comment-copy">This is also consistent with a "Fail fast and fail loudly" paradigm.  Unless you're meticulous, explicit hasattr(...) checks can occasionally cause a function/method to return normally without performing its intended action.</span>
<span class="comment-copy">I agree, but along the lines of not going crazy with this everywhere - a lot of these concerns should shake out during testing, and some of the "where to catch this/how to display to user" questions will be answered by usability requirements.</span>
<span class="comment-copy">I'd suggest switching the order of the examples.  <code>try</code> is always the first choice.  The <code>hasattr</code> checks are only -- for some really obscure reason -- you can't simply use <code>try</code>.</span>
<span class="comment-copy">@S.Lott Good point</span>
<span class="comment-copy">I suggest using <code>fp.read(0)</code> instead of <code>fp.read()</code> in order to avoid put all code in the <code>try</code> block if you want to process the data from <code>fp</code> subsequently.</span>
<span class="comment-copy">Note that <code>fp.read()</code> with big files will immediately increase memory usage.</span>
<span class="comment-copy">Why <code>getattr(file, 'read')</code> instead of just <code>file.read</code>? This does the exact same thing.</span>
<span class="comment-copy">More importantly, this check is wrong. It will raise when given, say, an actual <code>file</code> instance. (Methods of instances of builtin/C-extension types are of type <code>builtin_function_or_method</code>, while those of old-style classes are <code>instancemethod</code>). The fact that this is an old-style class, and that it uses <code>==</code> on types instead of <code>ininstance</code> or <code>issubclass</code>, are further problems, but if the basic idea doesn't work, that hardly matters.</span>
