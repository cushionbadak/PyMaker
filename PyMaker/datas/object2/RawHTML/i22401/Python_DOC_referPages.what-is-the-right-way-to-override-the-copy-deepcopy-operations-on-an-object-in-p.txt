<div class="post-text" itemprop="text">
<p>So just to establish, I feel like I understand the difference between <code>copy</code> vs. <code>deepcopy</code> in the copy module and I've used <code>copy.copy</code> and <code>copy.deepcopy</code> before successfully, but this is the first time I've actually gone about overloading the <code>__copy__</code> and <code>__deepcopy__</code> methods.  I've already Googled around and looked through the built-in Python modules to look for instances of the <code>__copy__</code> and <code>__deepcopy__</code> functions (e.g. <code>sets.py</code>, <code>decimal.py</code>, and <code>fractions.py</code>), but I'm still not 100% sure I've got it right.</p>
<p>Here's my scenario: </p>
<p>I have a configuration object that mostly just consists of simple properties (though it will potentially have lists of other non-primitive objects in it).  Initially I'm going to instantiate one configuration object with a default set of values.  This configuration will be handed off to multiple other objects (to ensure all objects start with the same configuration).  Once user interaction starts, however, each object will need to be able to tweak the configurations independently without affecting each other's configurations (which says to me I'll need to make deepcopys of my initial configuration to hand around).</p>
<p>Here's a sample object:</p>
<pre><code>class ChartConfig(object):

    def __init__(self):

        #Drawing properties (Booleans/strings)
        self.antialiased = None
        self.plot_style = None
        self.plot_title = None
        self.autoscale = None

        #X axis properties (strings/ints)
        self.xaxis_title = None
        self.xaxis_tick_rotation = None
        self.xaxis_tick_align = None

        #Y axis properties (strings/ints)
        self.yaxis_title = None
        self.yaxis_tick_rotation = None
        self.yaxis_tick_align = None

        #A list of non-primitive objects
        self.trace_configs = []

    def __copy__(self):
        pass

    def __deepcopy__(self, memo):
        pass 
</code></pre>
<p>What is the right way to implement the <code>copy</code> and <code>deepcopy</code> methods on this object to ensure <code>copy.copy</code> and <code>copy.deepcopy</code> give me the proper behavior?  I'm currently using Python 2.6.2.  </p>
<p>Thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>The recommendations for customizing are at the very end of the <a href="http://docs.python.org/library/copy.html" rel="noreferrer">docs page</a>:</p>
<blockquote>
<p>Classes can use the same interfaces to
  control copying that they use to
  control pickling. See the description
  of module pickle for information on
  these methods. The copy module does
  not use the copy_reg registration
  module.</p>
<p>In order for a class to define its own
  copy implementation, it can define
  special methods <code>__copy__()</code> and
  <code>__deepcopy__()</code>. The former is called to implement the shallow copy
  operation; no additional arguments are
  passed. The latter is called to
  implement the deep copy operation; it
  is passed one argument, the memo
  dictionary. If the <code>__deepcopy__()</code>
  implementation needs to make a deep
  copy of a component, it should call
  the <code>deepcopy()</code> function with the
  component as first argument and the
  memo dictionary as second argument.</p>
</blockquote>
<p>Since you appear not to care about pickling customization, defining <code>__copy__</code> and <code>__deepcopy__</code> definitely seems like the right way to go for you.</p>
<p>Specifically, <code>__copy__</code> (the shallow copy) is pretty easy in your case...:</p>
<pre><code>def __copy__(self):
  newone = type(self)()
  newone.__dict__.update(self.__dict__)
  return newone
</code></pre>
<p><code>__deepcopy__</code> would be similar (accepting a <code>memo</code> arg too) but before the return it would have to call <code>self.foo = deepcopy(self.foo, memo)</code> for any attribute <code>self.foo</code> that needs deep copying (essentially attributes that are containers -- lists, dicts, non-primitive objects which hold other stuff through their <code>__dict__</code>s).</p>
</div>
<div class="post-text" itemprop="text">
<p>Putting together Alex Martelli's answer and Rob Young's comment you get the following code:</p>
<pre><code>from copy import copy, deepcopy

class A(object):
    def __init__(self):
        print 'init'
        self.v = 10
        self.z = [2,3,4]

    def __copy__(self):
        cls = self.__class__
        result = cls.__new__(cls)
        result.__dict__.update(self.__dict__)
        return result

    def __deepcopy__(self, memo):
        cls = self.__class__
        result = cls.__new__(cls)
        memo[id(self)] = result
        for k, v in self.__dict__.items():
            setattr(result, k, deepcopy(v, memo))
        return result

a = A()
a.v = 11
b1, b2 = copy(a), deepcopy(a)
a.v = 12
a.z.append(5)
print b1.v, b1.z
print b2.v, b2.z
</code></pre>
<p>prints</p>
<pre><code>init
11 [2, 3, 4, 5]
11 [2, 3, 4]
</code></pre>
<p>here <code>__deepcopy__</code> fills in the <code>memo</code> dict to avoid excess copying in case the object itself is referenced from its member.</p>
</div>
<div class="post-text" itemprop="text">
<p>Following <a href="https://stackoverflow.com/a/24621200/150015">Peter's excellent answer</a>, to implement a custom deepcopy, with minimal alteration to the default implementation (e.g. just modifying a field like I needed) :</p>
<pre><code>class Foo(object):
    def __deepcopy__(self, memo):
        deepcopy_method = self.__deepcopy__
        self.__deepcopy__ = None
        cp = deepcopy(self, memo)
        self.__deepcopy__ = deepcopy_method

        # custom treatments
        # for instance: cp.id = None

        return cp
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I might be a bit off on the specifics, but here goes;</p>
<p>From the <a href="http://docs.python.org/library/copy.html" rel="nofollow noreferrer"><code>copy</code> docs</a>;</p>
<blockquote>
<ul>
<li>A shallow copy constructs a new compound object and then (to the extent possible) inserts references into it to the objects found in the original.</li>
<li>A deep copy constructs a new compound object and then, recursively, inserts copies into it of the objects found in the original.</li>
</ul>
</blockquote>
<p>In other words: <code>copy()</code> will copy only the top element and leave the rest as pointers into the original structure. <code>deepcopy()</code> will recursively copy over everything.</p>
<p>That is, <code>deepcopy()</code> is what you need.</p>
<p>If you need to do something really specific, you can override <code>__copy__()</code> or <code>__deepcopy__()</code>, as described in the manual. Personally, I'd probably implement a plain function (e.g. <code>config.copy_config()</code> or such) to make it plain that it isn't Python standard behaviour.</p>
</div>
<div class="post-text" itemprop="text">
<p>Its not clear from your problem why you need to override these methods, since you don't want to do any customization to the copying methods.</p>
<p>Anyhow, if you do want to customize the deep copy (e.g. by sharing some attributes and copying others), here is a solution:</p>
<pre><code>from copy import deepcopy


def deepcopy_with_sharing(obj, shared_attribute_names, memo=None):
    '''
    Deepcopy an object, except for a given list of attributes, which should
    be shared between the original object and its copy.

    obj is some object
    shared_attribute_names: A list of strings identifying the attributes that
        should be shared between the original and its copy.
    memo is the dictionary passed into __deepcopy__.  Ignore this argument if
        not calling from within __deepcopy__.
    '''
    assert isinstance(shared_attribute_names, (list, tuple))
    shared_attributes = {k: getattr(obj, k) for k in shared_attribute_names}

    if hasattr(obj, '__deepcopy__'):
        # Do hack to prevent infinite recursion in call to deepcopy
        deepcopy_method = obj.__deepcopy__
        obj.__deepcopy__ = None

    for attr in shared_attribute_names:
        del obj.__dict__[attr]

    clone = deepcopy(obj)

    for attr, val in shared_attributes.iteritems():
        setattr(obj, attr, val)
        setattr(clone, attr, val)

    if hasattr(obj, '__deepcopy__'):
        # Undo hack
        obj.__deepcopy__ = deepcopy_method
        del clone.__deepcopy__

    return clone



class A(object):

    def __init__(self):
        self.copy_me = []
        self.share_me = []

    def __deepcopy__(self, memo):
        return deepcopy_with_sharing(self, shared_attribute_names = ['share_me'], memo=memo)

a = A()
b = deepcopy(a)
assert a.copy_me is not b.copy_me
assert a.share_me is b.share_me

c = deepcopy(b)
assert c.copy_me is not b.copy_me
assert c.share_me is b.share_me
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>copy</code> module uses evantually the <a href="https://docs.python.org/3/library/pickle.html#object.__getstate__" rel="nofollow noreferrer"><code>__getstate__()</code></a>/<a href="https://docs.python.org/3/library/pickle.html#object.__setstate__" rel="nofollow noreferrer"><code>__setstate__()</code></a> <strong>pickling protocol</strong>, so these are also valid targets to override.  </p>
<p>The default implementation just returns and sets the <code>__dict__</code> of the class, so you don't have to call <code>super()</code> and worry about Eino Gourdin's clever trick, <a href="https://stackoverflow.com/a/40484215/548792">above</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Building on Antony Hatchkins' clean answer, here's my version where the class in question derives from another custom class (s.t. we need to call <code>super</code>):</p>
<pre><code>class Foo(FooBase):
    def __init__(self, param1, param2):
        self._base_params = [param1, param2]
        super(Foo, result).__init__(*self._base_params)

    def __copy__(self):
        cls = self.__class__
        result = cls.__new__(cls)
        result.__dict__.update(self.__dict__)
        super(Foo, result).__init__(*self._base_params)
        return result

    def __deepcopy__(self, memo):
        cls = self.__class__
        result = cls.__new__(cls)
        memo[id(self)] = result
        for k, v in self.__dict__.items():
            setattr(result, k, copy.deepcopy(v, memo))
        super(Foo, result).__init__(*self._base_params)
        return result
</code></pre>
</div>
<span class="comment-copy">Does it work?  Are there problems?</span>
<span class="comment-copy">I thought I was still getting problems with shared references, but it's entirely possible I messed up elsewhere.  I'll double check based on @MortenSiebuhr's post when I get a chance and update with the results.</span>
<span class="comment-copy">From my currently limited understanding I would expect copy.deepcopy(ChartConfigInstance) to return a new instance which wouldn't have any shared references with the original (without reimplementing deepcopy yourself). Is this incorrect?</span>
<span class="comment-copy">@kaizer, they're fine to customize pickling/unpickling as well as copying, but if you don't care about the pickling, it's simpler and more direct to use <code>__copy__</code>/<code>__deepcopy__</code>.</span>
<span class="comment-copy">That doesn't seem to be a direct translation of copy/deepcopy. Neither copy nor deepcopy call the constructor of the object being copied. Consider this example. class Test1(object):     def <b>init__(self):         print "%s.%s" % (self.__class</b>.__name__, "<b>init</b>")  class Test2(Test1):     def __copy__(self):         new = type(self)()         return new  t1 = Test1() copy.copy(t1) t2 = Test2() copy.copy(t2)</span>
<span class="comment-copy">I think instead of type(self)(), you should use  cls = self.__class__; cls.__new__(cls)   to be insensitive to constructors interface (especially for subclassing). It is not really important here however.</span>
<span class="comment-copy">Why <code>self.foo = deepcopy(self.foo, memo)</code>... ? Don't you really mean <code>newone.foo = ...</code>?</span>
<span class="comment-copy">@Juh_'s comment is spot on. You don't want to call <code>__init__</code>. That's not what copy does. Also there is very often a use case where pickling and copying need to be different. In fact, I don't even know why copy tries to use the pickling protocol by default. Copying is for in-memory manipulation, pickling is for cross-epoch persistence; they are completely different things that bear little relation to each other.</span>
<span class="comment-copy">I get error with above implementation <code>class Transporter has no attribute '__new__'</code> (python 2.7). I am trying to override <code>__deepcopy__</code></span>
<span class="comment-copy">@bytestorm what is <code>Transporter</code>?</span>
<span class="comment-copy">@AntonyHatchkins <code>Transporter</code> is the name of my class that I am writing. For that class I want to override the deepcopy behaviour.</span>
<span class="comment-copy">@bytestorm what is the contents of <code>Transporter</code>?</span>
<span class="comment-copy">I think <code>__deepcopy__</code> should include a test to avoid infinite recursion: &lt;!-- language: lang-python --&gt;      d = id(self)     result = memo.get(d, None)     if result is not None:         return result</span>
<span class="comment-copy"><i>In order for a class to define its own copy implementation, it can define special methods <code>__copy__(</code>) and <code>__deepcopy__()</code>.</i> <a href="http://docs.python.org/library/copy.html" rel="nofollow noreferrer">docs.python.org/library/copy.html</a></span>
<span class="comment-copy">I'll double-check my code, thanks.  I'm going to feel dumb if this was a simple bug elsewhere :-P</span>
<span class="comment-copy">@MortenSiebuhr You are correct.  I wasn't entirely clear that copy/deepcopy would do anything by default without me overriding those functions. I was looking for actual code though that I can tweak later (e.g. if I don't want to copy all attributes), so I gave you an up-vote but I'm going to go with @AlexMartinelli's answer. Thanks!</span>
<span class="comment-copy">Ah! self.RTFM()... I've fixed the response to show match.</span>
<span class="comment-copy">Doesn't the clone also need it's <code>__deepcopy__</code> method reset since it will have <code>__deepcopy__</code> = None?</span>
<span class="comment-copy">Nope.  If <code>__deepcopy__</code> method is not found (or <code>obj.__deepcopy__</code> returns None), then <code>deepcopy</code> falls back on the standard deep-copying function.  This can be seen <a href="https://github.com/python/cpython/blob/3.6/Lib/copy.py#L159" rel="nofollow noreferrer">here</a></span>
<span class="comment-copy">But then b won't have the ability to deepcopy with sharing? c = deepcopy(a) would be different from d=deepcopy(b) because d would be a default deepcopy where c would have some shared attrs with a.</span>
<span class="comment-copy">Ah, now I see what you're saying.  Good point.  I fixed it, I think, by deleting the fake <code>__deepcopy__=None</code> attribute from the clone. See new code.</span>
<span class="comment-copy">maybe clear to the python experts: if you use this code in python 3, change "    for attr, val in shared_attributes.iteritems():" with "    for attr, val in shared_attributes.items():"</span>
