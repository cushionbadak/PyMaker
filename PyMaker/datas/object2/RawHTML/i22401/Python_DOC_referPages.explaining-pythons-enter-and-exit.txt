<div class="post-text" itemprop="text">
<p>I saw this in someone's code. What does it mean?</p>
<pre><code>    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        self.stream.close()
</code></pre>
<hr/>
<pre><code>from __future__ import with_statement#for python2.5 

class a(object):
    def __enter__(self):
        print 'sss'
        return 'sss111'
    def __exit__(self ,type, value, traceback):
        print 'ok'
        return False

with a() as s:
    print s


print s
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using these magic methods (<code>__enter__</code>, <code>__exit__</code>) allows you to implement objects which can be used easily with the <code>with</code> statement. </p>
<p>The idea is that it makes it easy to build code which needs some 'cleandown' code executed (think of it as a <code>try-finally</code> block). <a href="http://effbot.org/zone/python-with-statement.htm" rel="noreferrer">Some more explanation here</a>.</p>
<p>A useful example could be a database connection object (which then automagically closes the connection once the corresponding 'with'-statement goes out of scope):</p>
<pre><code>class DatabaseConnection(object):

    def __enter__(self):
        # make a database connection and return it
        ...
        return self.dbconn

    def __exit__(self, exc_type, exc_val, exc_tb):
        # make sure the dbconnection gets closed
        self.dbconn.close()
        ...
</code></pre>
<p>As explained above, use this object with the <code>with</code> statement (you may need to do <code>from __future__ import with_statement</code> at the top of the file if you're on Python 2.5).</p>
<pre><code>with DatabaseConnection() as mydbconn:
    # do stuff
</code></pre>
<p><a href="https://www.python.org/dev/peps/pep-0343/" rel="noreferrer">PEP343 -- The 'with' statement'</a> has a nice writeup as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you know what <strong>context managers</strong> are then you need nothing more to understand <code>__enter__</code> and <code>__exit__</code> magic methods. Lets see a very simple example.</p>
<p>In this example I am opening <strong>myfile.txt</strong> with help of <strong>open</strong> function. The <strong>try/finally</strong> block ensures that even if an unexpected exception occurs <strong>myfile.txt</strong> will be closed.</p>
<pre><code>fp=open(r"C:\Users\SharpEl\Desktop\myfile.txt")
try:
    for line in fp:
        print(line)
finally:
    fp.close()
</code></pre>
<p>Now I am opening same file with <strong>with</strong> statement:</p>
<pre><code>with open(r"C:\Users\SharpEl\Desktop\myfile.txt") as fp:
    for line in fp:
        print(line) 
</code></pre>
<p>If you look at the code, I  didn't close the file &amp; there is no <strong>try/finally</strong> block. Because <strong>with</strong> statement automatically closes  <strong>myfile.txt</strong> . You can even check it by calling <code>print(fp.closed)</code> attribute -- which returns <code>True</code>.</p>
<p>This is because the file objects (fp in my example) returned by <strong>open</strong> function has two built-in methods <code>__enter__</code> and <code>__exit__</code>. It is  also known as context manager. <code>__enter__</code> method is called at the start of <strong>with</strong> block and <code>__exit__</code>  method is called at the end.  Note: <strong>with</strong> statement only works with objects that support the context mamangement protocol i.e. they have <code>__enter__</code> and <code>__exit__</code> methods. A class which implement both methods is known as context manager class.</p>
<p>Now lets define our own <strong>context manager</strong> class.</p>
<pre><code> class Log:
    def __init__(self,filename):
        self.filename=filename
        self.fp=None    
    def logging(self,text):
        self.fp.write(text+'\n')
    def __enter__(self):
        print("__enter__")
        self.fp=open(self.filename,"a+")
        return self    
    def __exit__(self, exc_type, exc_val, exc_tb):
        print("__exit__")
        self.fp.close()

with Log(r"C:\Users\SharpEl\Desktop\myfile.txt") as logfile:
    print("Main")
    logfile.logging("Test1")
    logfile.logging("Test2")
</code></pre>
<p>I hope now you have basic understanding of both <code>__enter__</code> and <code>__exit__</code> magic methods.</p>
</div>
<div class="post-text" itemprop="text">
<p>I found it strangely difficult to locate the python docs for <code>__enter__</code> and <code>__exit__</code> methods by Googling, so to help others here is the link:</p>
<p><a href="https://docs.python.org/2/reference/datamodel.html#with-statement-context-managers" rel="noreferrer">https://docs.python.org/2/reference/datamodel.html#with-statement-context-managers</a><br/>
<a href="https://docs.python.org/3/reference/datamodel.html#with-statement-context-managers" rel="noreferrer">https://docs.python.org/3/reference/datamodel.html#with-statement-context-managers</a><br/>
(detail is the same for both versions)</p>
<blockquote>
<p><code>object.__enter__(self)</code><br/>
  Enter the runtime context related to this object. The <code>with</code> statement will bind this method’s return value to the target(s) specified in the as clause of the statement, if any.</p>
<p><code>object.__exit__(self, exc_type, exc_value, traceback)</code><br/>
  Exit the runtime context related to this object. The parameters describe the exception that caused the context to be exited. If the context was exited without an exception, all three arguments will be <code>None</code>.</p>
<p>If an exception is supplied, and the method wishes to suppress the exception (i.e., prevent it from being propagated), it should return a true value. Otherwise, the exception will be processed normally upon exit from this method.</p>
<p>Note that <code>__exit__()</code> methods should not reraise the passed-in exception; this is the caller’s responsibility.</p>
</blockquote>
<p>I was hoping for a clear description of the <code>__exit__</code> method arguments. This is lacking but we can deduce them...</p>
<p>Presumably <code>exc_type</code> is the class of the exception.</p>
<p>It says you should not re-raise the passed-in exception. This suggests to us that one of the arguments might be an actual Exception instance ...or maybe you're supposed to instantiate it yourself from the type and value?</p>
<p>We can answer by looking at this article:<br/>
<a href="http://effbot.org/zone/python-with-statement.htm" rel="noreferrer">http://effbot.org/zone/python-with-statement.htm</a></p>
<blockquote>
<p>For example, the following <code>__exit__</code> method swallows any TypeError, but lets all other exceptions through:</p>
</blockquote>
<pre><code>def __exit__(self, type, value, traceback):
    return isinstance(value, TypeError)
</code></pre>
<p>...so clearly <code>value</code> is an Exception instance.</p>
<p>And presumably <code>traceback</code> is a Python <a href="https://docs.python.org/2/library/traceback.html" rel="noreferrer">traceback</a> object.</p>
</div>
<div class="post-text" itemprop="text">
<p>In addition to the above answers to exemplify invocation order, a simple run example
</p>
<pre><code>class myclass:
    def __init__(self):
        print("__init__")

    def __enter__(self): 
        print("__enter__")

    def __exit__(self, type, value, traceback):
        print("__exit__")

    def __del__(self):
        print("__del__")

with myclass(): 
    print("body")
</code></pre>
<p>Produces the output: </p>
<pre><code>__init__
__enter__
body
__exit__
__del__
</code></pre>
<p>A reminder: when using the syntax <code>with myclass() as mc</code>, variable mc gets the value returned by <code>__enter__()</code>, in the above case <code>None</code>! For such use, need to define return value, such as: </p>
<pre class="lang-py prettyprint-override"><code>def __enter__(self): 
    print('__enter__')
    return self
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>try adding my answers (my thought of learning) :</p>
<p><code>__enter__</code> and <code>[__exit__]</code> both are methods that are invoked on entry to and exit from the body of "<strong>the with statement</strong>" (<a href="https://www.python.org/dev/peps/pep-0343/" rel="nofollow noreferrer">PEP 343</a>) and implementation of both is called context manager.</p>
<p>the with statement is intend to hiding flow control of try finally clause and make the code inscrutable.</p>
<p>the syntax of the with statement is :</p>
<pre><code>with EXPR as VAR:
    BLOCK
</code></pre>
<p>which translate to (as mention in PEP 343) :</p>
<pre><code>mgr = (EXPR)
exit = type(mgr).__exit__  # Not calling it yet
value = type(mgr).__enter__(mgr)
exc = True
try:
    try:
        VAR = value  # Only if "as VAR" is present
        BLOCK
    except:
        # The exceptional case is handled here
        exc = False
        if not exit(mgr, *sys.exc_info()):
            raise
        # The exception is swallowed if exit() returns true
finally:
    # The normal and non-local-goto cases are handled here
    if exc:
        exit(mgr, None, None, None)
</code></pre>
<p>try some code:</p>
<pre><code>&gt;&gt;&gt; import logging
&gt;&gt;&gt; import socket
&gt;&gt;&gt; import sys

#server socket on another terminal / python interpreter
&gt;&gt;&gt; s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
&gt;&gt;&gt; s.listen(5)
&gt;&gt;&gt; s.bind((socket.gethostname(), 999))
&gt;&gt;&gt; while True:
&gt;&gt;&gt;    (clientsocket, addr) = s.accept()
&gt;&gt;&gt;    print('get connection from %r' % addr[0])
&gt;&gt;&gt;    msg = clientsocket.recv(1024)
&gt;&gt;&gt;    print('received %r' % msg)
&gt;&gt;&gt;    clientsocket.send(b'connected')
&gt;&gt;&gt;    continue

#the client side
&gt;&gt;&gt; class MyConnectionManager:
&gt;&gt;&gt;     def __init__(self, sock, addrs):
&gt;&gt;&gt;         logging.basicConfig(level=logging.DEBUG, format='%(asctime)s \
&gt;&gt;&gt;         : %(levelname)s --&gt; %(message)s')
&gt;&gt;&gt;         logging.info('Initiating My connection')
&gt;&gt;&gt;         self.sock = sock
&gt;&gt;&gt;         self.addrs = addrs
&gt;&gt;&gt;     def __enter__(self):
&gt;&gt;&gt;         try:
&gt;&gt;&gt;             self.sock.connect(addrs)
&gt;&gt;&gt;             logging.info('connection success')
&gt;&gt;&gt;             return self.sock
&gt;&gt;&gt;         except:
&gt;&gt;&gt;             logging.warning('Connection refused')
&gt;&gt;&gt;             raise
&gt;&gt;&gt;     def __exit__(self, type, value, tb):
&gt;&gt;&gt;             logging.info('CM suppress exception')
&gt;&gt;&gt;             return False
&gt;&gt;&gt; addrs = (socket.gethostname())
&gt;&gt;&gt; s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
&gt;&gt;&gt; with MyConnectionManager(s, addrs) as CM:
&gt;&gt;&gt;     try:
&gt;&gt;&gt;         CM.send(b'establishing connection')
&gt;&gt;&gt;         msg = CM.recv(1024)
&gt;&gt;&gt;         print(msg)
&gt;&gt;&gt;     except:
&gt;&gt;&gt;         raise
#will result (client side) :
2018-12-18 14:44:05,863         : INFO --&gt; Initiating My connection
2018-12-18 14:44:05,863         : INFO --&gt; connection success
b'connected'
2018-12-18 14:44:05,864         : INFO --&gt; CM suppress exception

#result of server side
get connection from '127.0.0.1'
received b'establishing connection'
</code></pre>
<p>and now try manually (following translate syntax):</p>
<pre><code>&gt;&gt;&gt; s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #make new socket object
&gt;&gt;&gt; mgr = MyConnection(s, addrs)
2018-12-18 14:53:19,331         : INFO --&gt; Initiating My connection
&gt;&gt;&gt; ext = mgr.__exit__
&gt;&gt;&gt; value = mgr.__enter__()
2018-12-18 14:55:55,491         : INFO --&gt; connection success
&gt;&gt;&gt; exc = True
&gt;&gt;&gt; try:
&gt;&gt;&gt;     try:
&gt;&gt;&gt;         VAR = value
&gt;&gt;&gt;         VAR.send(b'establishing connection')
&gt;&gt;&gt;         msg = VAR.recv(1024)
&gt;&gt;&gt;         print(msg)
&gt;&gt;&gt;     except:
&gt;&gt;&gt;         exc = False
&gt;&gt;&gt;         if not ext(*sys.exc_info()):
&gt;&gt;&gt;             raise
&gt;&gt;&gt; finally:
&gt;&gt;&gt;     if exc:
&gt;&gt;&gt;         ext(None, None, None)
#the result:
b'connected'
2018-12-18 15:01:54,208         : INFO --&gt; CM suppress exception
</code></pre>
<p>the result of the server side same as before</p>
<p>sorry for my bad english and my unclear explanations, thank you....</p>
</div>
<span class="comment-copy">A good explanation here : <a href="http://effbot.org/zone/python-with-statement.htm" rel="nofollow noreferrer">effbot.org/zone/python-with-statement.htm</a></span>
<span class="comment-copy">@StevenVascellaro Editing the code of a question is generally a bad idea, <b>especially</b> when there are errors in the code. This question was asked with Py2 in mind, and there's no reason to updated it to Py3.</span>
<span class="comment-copy">Probably, <code>__enter__</code> should return <code>self</code> always as then only other methods of the class can be called on the context.</span>
<span class="comment-copy">@ViFI There are 4 examples of <code>def __enter__(self)</code> in PEP 343 and no one does <code>return self</code>: <a href="https://www.python.org/dev/peps/pep-0343/" rel="nofollow noreferrer">python.org/dev/peps/pep-0343</a> . Why do you think so?</span>
<span class="comment-copy">@Grief : For 2 reasons, In my opinion,  1) i won't be able to call other methods on <code>self</code> object as explained here : <a href="http://stackoverflow.com/questions/38281853/should-the-return-value-for-enter-method-always-be-self-in-python" title="should the return value for enter method always be self in python">stackoverflow.com/questions/38281853/…</a> 2) self.XYZ is just part of self object and returning handle only to just that seems inappropriate to me from maintenance point of view. I would rather prefer to return handle to complete object and then provide public APIs to only those components <code>self</code> object,which I want to expose to user like in  <code>with open(abc.txt, 'r') as fin:          content = fin.read()</code></span>
<span class="comment-copy">File objects return <code>self</code> from <code>__enter__</code>, which is how come you can process the file as <code>f</code> inside <code>with open(...) as f</code></span>
<span class="comment-copy">One subtlety I had to understand: if the object requires parameters to initialize, those should be on <b>init</b>, not <b>self</b>.</span>
<span class="comment-copy">Agree. This url is so hard to find.</span>
<span class="comment-copy">And even if the sequence of the definitions are switched, the executing order stays the same!</span>
