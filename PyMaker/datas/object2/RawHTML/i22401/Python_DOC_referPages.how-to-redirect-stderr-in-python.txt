<div class="post-text" itemprop="text">
<p>I would like to log all the output of a Python script. I tried:</p>
<pre><code>import sys

log = []

class writer(object):
    def write(self, data):
        log.append(data)

sys.stdout = writer()
sys.stderr = writer()
</code></pre>
<p>Now, if I "print 'something' " it gets logged. But if I make for instance some syntax error, say "print 'something# ", it wont get logged - it will go into the console instead.</p>
<p>How do I capture also the errors from Python interpreter?</p>
<p>I saw a possible solution here:</p>
<p><a href="http://www.velocityreviews.com/forums/showpost.php?p=1868822&amp;postcount=3" rel="noreferrer">http://www.velocityreviews.com/forums/showpost.php?p=1868822&amp;postcount=3</a></p>
<p>but the second example logs into /dev/null - this is not what I want. I would like to log it into a list like my example above or StringIO or such...</p>
<p>Also, preferably I don't want to create a subprocess (and read its stdout and stderr in separate thread).</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't do anything in Python code that can capture errors during the compilation of that same code.  How could it?  If the compiler can't finish compiling the code, it won't run the code, so your redirection hasn't even taken effect yet.</p>
<p>That's where your (undesired) subprocess comes in.  You can write Python code that redirects the stdout, then invokes the Python interpreter to compile some other piece of code.</p>
</div>
<div class="post-text" itemprop="text">
<p>I have a piece of software I wrote for work that captures stderr to a file like so:</p>
<pre><code>import sys
sys.stderr = open('C:\\err.txt', 'w')
</code></pre>
<p>so it's definitely possible.</p>
<p>I believe your problem is that you are creating two instances of writer.</p>
<p>Maybe something more like:</p>
<pre><code>import sys

class writer(object):
    log = []

    def write(self, data):
        self.log.append(data)

logger = writer()
sys.stdout = logger
sys.stderr = logger
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I can't think of an easy way.  The python process's standard error is living on a lower level than a python file object (C vs. python).</p>
<p>You could wrap the python script in a second python script and use subprocess.Popen.  It's also possible you could pull some magic like this in a single script:</p>
<pre><code>import os
import subprocess
import sys

cat = subprocess.Popen("/bin/cat", stdin=subprocess.PIPE, stdout=subprocess.PIPE)
os.close(sys.stderr.fileno())
os.dup2(cat.stdin.fileno(), sys.stderr.fileno())
</code></pre>
<p>And then use select.poll() to check cat.stdout regularly to find output.</p>
<p>Yes, that seems to work.</p>
<p>The problem I foresee is that most of the time, something printed to stderr by python indicates it's about to exit.  The more usual way to handle this would be via exceptions.</p>
<p>---------Edit</p>
<p>Somehow I missed the os.pipe() function.  </p>
<pre><code>import os, sys
r, w = os.pipe()
os.close(sys.stderr.fileno())
os.dup2(w, sys.stderr.fileno())
</code></pre>
<p>Then read from r</p>
</div>
<div class="post-text" itemprop="text">
<p>Actually, if you're using linux/mac os, you can just use file redirect to do that. For example, if you're going to run "a.py" and record all the messages it will generate into file "a.out", it would just be</p>
<p><code>python a.py 2&gt;&amp;1 &gt; a.out</code></p>
<p>The first part redirects stderr to stdout, and the second redirects that to a file called a.out.</p>
<p>For a longer list of redirection operators in Linux/Unix, see <a href="https://askubuntu.com/questions/420981/how-do-i-save-terminal-output-to-a-file">https://askubuntu.com/questions/420981/how-do-i-save-terminal-output-to-a-file</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Since python 3.5 you can use <a href="https://docs.python.org/3/library/contextlib.html#contextlib.redirect_stderr" rel="nofollow noreferrer"><code>contextlib.redirect_stderr</code></a></p>
<pre class="lang-py prettyprint-override"><code>with open('help.txt', 'w') as f:
    with redirect_stdout(f):
        help(pow)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import sys
import tkinter

# ********************************************

def mklistenconsswitch(*printf: callable) -&gt; callable:
    def wrapper(*fcs: callable) -&gt; callable:
        def newf(data):
            [prf(data) for prf in fcs]
        return newf
    stdoutw, stderrw = sys.stdout.write, sys.stderr.write
    funcs = [(wrapper(sys.stdout.write, *printf), wrapper(sys.stderr.write, *printf)), (stdoutw, stderrw)]
    def switch():
        sys.stdout.write, sys.stderr.write = dummy = funcs[0]
        funcs[0] = funcs[1]
        funcs[1] = dummy
    return switch

# ********************************************

def datasupplier():
    i = 5.5
    while i &gt; 0:
        yield i
        i -= .5

def testloop():
    print(supplier.__next__())
    svvitch()
    root.after(500, testloop)

root = tkinter.Tk()
cons = tkinter.Text(root)
cons.pack(fill='both', expand=True)
supplier = datasupplier()
svvitch = mklistenconsswitch(lambda text: cons.insert('end', text))
testloop()
root.mainloop()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python will not execute your code if there is an error. But you can import your script in another script an catch exceptions. Example:</p>
<h2>Script.py</h2>
<pre><code>print 'something#
</code></pre>
<h2>FinalScript.py</h2>
<pre><code>from importlib.machinery import SourceFileLoader

try:
    SourceFileLoader("main", "&lt;SCRIPT PATH&gt;").load_module()
except Exception as e:
    # Handle the exception here
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To add to Ned's answer, it is difficult to capture the errors on the fly during the compilation. </p>
<p>You can write several print statements in your script and you can stdout to a file, it will stop writing to the file when the error occurs. To debug the code you could check the last logged output and check your script after that point.</p>
<p><br/>
<strong>Something like this:</strong></p>
<pre><code># Add to the beginning of the script execution(eg: if __name__ == "__main__":).
from datetime import datetime
dt = datetime.now()
script_dir = os.path.dirname(os.path.abspath(__file__))      # gets the path of the script
stdout_file = script_dir+r'\logs\log'+('').join(str(dt.date()).split("-"))+r'.log'
sys.stdout = open(stdout_file, 'w')
</code></pre>
<p>This will create a log file and stream the print statements to the file.</p>
<p><br/></p>
<p><strong>Note:</strong> Watch out for escape characters in your filepath while concatenating with script_dir in the second line from the last in the code. You might want something similar to raw string. You can check <a href="https://stackoverflow.com/a/21605790">this thread</a> for this. </p>
</div>
<span class="comment-copy">Perhaps writer should implement writelines() as well. Do not forget sys.stderr.flush()</span>
<span class="comment-copy">"print 'something#" shouldn't work as missing a single quotation mark. However, how do you check whether your print is being logged? You store stdout and stderr in a list. All your print results should go to the list. How do you print out the list content?</span>
<span class="comment-copy">You are right, of course it can't do it. Sorry for the stupid question. Another solution would be to "exec" the script inside another script.</span>
<span class="comment-copy">Not all code is compiled at once.  import statements are one example.</span>
<span class="comment-copy">Another use case (though not EcirH's): capturing stderr from a C-library called from python.</span>
<span class="comment-copy">Python code isn't compiled. It's interpreted on-the-fly.</span>
<span class="comment-copy">@EthanBierlein Python is indeed compiled, but to bytecode, not machine instructions.  The point is that there is a compilation step, which is what produces SyntaxErrors.  If a SyntaxError occurs, then the code will not run, so there is nothing you can do in the code to log syntax errors.</span>
<span class="comment-copy">I was going to say something about log variable ...</span>
<span class="comment-copy">What if other code does sys.stdout.flush()?</span>
<span class="comment-copy">In that case, just add a dummy flush method to your writer class: <code>def flush(self): pass</code></span>
<span class="comment-copy">user file handler as log handler, neat. How about multiple modules access the log list/file at the same time?</span>
