<div class="post-text" itemprop="text">
<p>Is it possible to add a documentation string to a namedtuple in an easy manner?</p>
<p>I tried</p>
<pre><code>from collections import namedtuple

Point = namedtuple("Point", ["x", "y"])
"""
A point in 2D space
"""

# Yet another test

"""
A(nother) point in 2D space
"""
Point2 = namedtuple("Point2", ["x", "y"])

print Point.__doc__ # -&gt; "Point(x, y)"
print Point2.__doc__ # -&gt; "Point2(x, y)"
</code></pre>
<p>but that doesn't cut it. Is it possible to do in some other way?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can achieve this by creating a simple, empty wrapper class around the returned value from <code>namedtuple</code>.  Contents of a file I created (<code>nt.py</code>):</p>
<pre><code>from collections import namedtuple

Point_ = namedtuple("Point", ["x", "y"])

class Point(Point_):
    """ A point in 2d space """
    pass
</code></pre>
<p>Then in the Python REPL:</p>
<pre><code>&gt;&gt;&gt; print nt.Point.__doc__
 A point in 2d space 
</code></pre>
<p>Or you could do:</p>
<pre><code>&gt;&gt;&gt; help(nt.Point)  # which outputs...
</code></pre>
<pre>
Help on class Point in module nt:

class Point(Point)
 |  A point in 2d space
 |  
 |  Method resolution order:
 |      Point
 |      Point
 |      __builtin__.tuple
 |      __builtin__.object
 ...
</pre>
<p>If you don't like doing that by hand every time, it's trivial to write a sort-of factory function to do this:</p>
<pre><code>def NamedTupleWithDocstring(docstring, *ntargs):
    nt = namedtuple(*ntargs)
    class NT(nt):
        __doc__ = docstring
    return NT

Point3D = NamedTupleWithDocstring("A point in 3d space", "Point3d", ["x", "y", "z"])

p3 = Point3D(1,2,3)

print p3.__doc__
</code></pre>
<p>which outputs:</p>
<pre><code>A point in 3d space
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Came across this old question via Google while wondering the same thing.</p>
<p>Just wanted to point out that you can tidy it up even more by calling namedtuple() right from the class declaration:</p>
<pre><code>from collections import namedtuple

class Point(namedtuple('Point', 'x y')):
    """Here is the docstring."""
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3, no wrapper is needed, as the <code>__doc__</code> attributes of types is writable.</p>
<pre><code>from collections import namedtuple

Point = namedtuple('Point', 'x y')
Point.__doc__ = '''\
A 2-dimensional coordinate

x - the abscissa
y - the ordinate'''
</code></pre>
<p>This closely corresponds to a standard class definition, where the docstring follows the header.</p>
<pre><code>class Point():
    '''A 2-dimensional coordinate

    x - the abscissa
    y - the ordinate'''
    &lt;class code&gt;
</code></pre>
<p>This does not work in Python 2.</p>
<p><code>AttributeError: attribute '__doc__' of 'type' objects is not writable</code>. </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h1>Is it possible to add a documentation string to a namedtuple in an easy manner?</h1>
</blockquote>
<h1>Python 3</h1>
<p>In Python 3, you can easily alter the doc on your namedtuple:</p>
<pre><code>NT = collections.namedtuple('NT', 'foo bar')

NT.__doc__ = """:param str foo: foo name
:param list bar: List of bars to bar"""
</code></pre>
<p>Which allows us to view the intent for them when we call help on them:</p>
<pre><code>Help on class NT in module __main__:

class NT(builtins.tuple)
 |  :param str foo: foo name
 |  :param list bar: List of bars to bar
...
</code></pre>
<p>This is really straightforward compared to the difficulties we have accomplishing the same thing in Python 2.</p>
<h1>Python 2</h1>
<p>In Python 2, you'll need to</p>
<ul>
<li>subclass the namedtuple, and </li>
<li>declare <code>__slots__ == ()</code> </li>
</ul>
<p>Declaring <code>__slots__</code> is <strong>an important part that the other answers here miss</strong> . </p>
<p>If you don't declare <code>__slots__</code> - you could add mutable ad-hoc attributes to the instances, introducing bugs.</p>
<pre><code>class Foo(namedtuple('Foo', 'bar')):
    """no __slots__ = ()!!!"""
</code></pre>
<p>And now:</p>
<pre><code>&gt;&gt;&gt; f = Foo('bar')
&gt;&gt;&gt; f.bar
'bar'
&gt;&gt;&gt; f.baz = 'what?'
&gt;&gt;&gt; f.__dict__
{'baz': 'what?'}
</code></pre>
<p>Each instance will create a separate <code>__dict__</code> when <code>__dict__</code> is accessed (the lack of <code>__slots__</code> won't otherwise impede the functionality, but the lightweightness of the tuple, immutability, and declared attributes are all important features of namedtuples). </p>
<p>You'll also want a <code>__repr__</code>, if you want what is echoed on the command line to give you an equivalent object:</p>
<pre><code>NTBase = collections.namedtuple('NTBase', 'foo bar')

class NT(NTBase):
    """
    Individual foo bar, a namedtuple

    :param str foo: foo name
    :param list bar: List of bars to bar
    """
    __slots__ = ()
</code></pre>
<p>a <code>__repr__</code> like this is needed if you create the base namedtuple with a different name (like we did above with the name string argument, <code>'NTBase'</code>):</p>
<pre><code>    def __repr__(self):
        return 'NT(foo={0}, bar={1})'.format(
                repr(self.foo), repr(self.bar))
</code></pre>
<p>To test the repr, instantiate, then test for equality of a pass to <code>eval(repr(instance))</code></p>
<pre><code>nt = NT('foo', 'bar')
assert eval(repr(nt)) == nt
</code></pre>
<h2>Example from the documentation</h2>
<p>The <a href="https://docs.python.org/library/collections.html#namedtuple-factory-function-for-tuples-with-named-fields" rel="noreferrer">docs also</a> give such an example, regarding <code>__slots__</code> - I'm adding my own docstring to it:</p>
<blockquote>
<pre><code>class Point(namedtuple('Point', 'x y')):
    """Docstring added here, not in original"""
    __slots__ = ()
    @property
    def hypot(self):
        return (self.x ** 2 + self.y ** 2) ** 0.5
    def __str__(self):
        return 'Point: x=%6.3f  y=%6.3f  hypot=%6.3f' % (self.x, self.y, self.hypot)
</code></pre>
<p>...</p>
<p>The subclass shown above sets <code>__slots__</code> to an empty tuple. This helps
  keep memory requirements low by preventing the creation of instance
  dictionaries.</p>
</blockquote>
<p>This demonstrates in-place usage (like another answer here suggests), but note that the in-place usage may become confusing when you look at the method resolution order, if you're debugging, which is why I originally suggested using <code>Base</code> as a suffix for the base namedtuple:</p>
<pre><code>&gt;&gt;&gt; Point.mro()
[&lt;class '__main__.Point'&gt;, &lt;class '__main__.Point'&gt;, &lt;type 'tuple'&gt;, &lt;type 'object'&gt;]
                # ^^^^^---------------------^^^^^-- same names!        
</code></pre>
<p>To prevent creation of a <code>__dict__</code> when subclassing from a class that uses it, you must also declare it in the subclass. See also <a href="https://stackoverflow.com/a/28059785/541136">this answer for more caveats on using <code>__slots__</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since Python 3.5, docstrings for <code>namedtuple</code> objects can be updated.</p>
<p>From the <a href="https://docs.python.org/3/whatsnew/3.5.html#collections" rel="nofollow noreferrer">whatsnew</a>:</p>
<blockquote>
<pre><code>Point = namedtuple('Point', ['x', 'y'])
Point.__doc__ += ': Cartesian coodinate'
Point.x.__doc__ = 'abscissa'
Point.y.__doc__ = 'ordinate'
</code></pre>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.6+ you can use:</p>
<pre><code>class Point(NamedTuple):
    """
    A point in 2D space
    """
    x: float
    y: float
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No need to use a wrapper class as suggested by the accepted answer. Simply literally <strong>add</strong> a docstring:</p>
<pre><code>from collections import namedtuple

Point = namedtuple("Point", ["x", "y"])
Point.__doc__="A point in 2D space"
</code></pre>
<p>This results in: (example using <code>ipython3</code>):</p>
<pre><code>In [1]: Point?
Type:       type
String Form:&lt;class '__main__.Point'&gt;
Docstring:  A point in 2D space

In [2]: 
</code></pre>
<p><em>Voilà!</em></p>
</div>
<div class="post-text" itemprop="text">
<p>You could concoct your own version of the <a href="http://code.activestate.com/recipes/500261" rel="nofollow noreferrer"><strong>namedtuple factory function</strong></a> by Raymond Hettinger and add an optional <code>docstring</code> argument.  However it would be easier -- and arguably better -- to just define your own factory function using the same basic technique as in the recipe.  Either way, you'll end up with something reusable.</p>
<pre><code>from collections import namedtuple

def my_namedtuple(typename, field_names, verbose=False,
                 rename=False, docstring=''):
    '''Returns a new subclass of namedtuple with the supplied
       docstring appended to the default one.

    &gt;&gt;&gt; Point = my_namedtuple('Point', 'x, y', docstring='A point in 2D space')
    &gt;&gt;&gt; print Point.__doc__
    Point(x, y):  A point in 2D space
    '''
    # create a base class and concatenate its docstring and the one passed
    _base = namedtuple(typename, field_names, verbose, rename)
    _docstring = ''.join([_base.__doc__, ':  ', docstring])

    # fill in template to create a no-op subclass with the combined docstring
    template = '''class subclass(_base):
        %(_docstring)r
        pass\n''' % locals()

    # execute code string in a temporary namespace
    namespace = dict(_base=_base, _docstring=_docstring)
    try:
        exec template in namespace
    except SyntaxError, e:
        raise SyntaxError(e.message + ':\n' + template)

    return namespace['subclass']  # subclass object created
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I created this function to quickly create a named tuple and document the tuple along with each of its parameters:</p>
<pre><code>from collections import namedtuple


def named_tuple(name, description='', **kwargs):
    """
    A named tuple with docstring documentation of each of its parameters
    :param str name: The named tuple's name
    :param str description: The named tuple's description
    :param kwargs: This named tuple's parameters' data with two different ways to describe said parameters. Format:
        &lt;pre&gt;{
            str: ( # The parameter's name
                str, # The parameter's type
                str # The parameter's description
            ),
            str: str, # The parameter's name: the parameter's description
            ... # Any other parameters
        }&lt;/pre&gt;
    :return: collections.namedtuple
    """
    parameter_names = list(kwargs.keys())

    result = namedtuple(name, ' '.join(parameter_names))

    # If there are any parameters provided (such that this is not an empty named tuple)
    if len(parameter_names):
        # Add line spacing before describing this named tuple's parameters
        if description is not '':
            description += "\n"

        # Go through each parameter provided and add it to the named tuple's docstring description
        for parameter_name in parameter_names:
            parameter_data = kwargs[parameter_name]

            # Determine whether parameter type is included along with the description or
            # if only a description was provided
            parameter_type = ''
            if isinstance(parameter_data, str):
                parameter_description = parameter_data
            else:
                parameter_type, parameter_description = parameter_data

            description += "\n:param {type}{name}: {description}".format(
                type=parameter_type + ' ' if parameter_type else '',
                name=parameter_name,
                description=parameter_description
            )

            # Change the docstring specific to this parameter
            getattr(result, parameter_name).__doc__ = parameter_description

    # Set the docstring description for the resulting named tuple
    result.__doc__ = description

    return result
</code></pre>
<p>You can then create a new named tuple:</p>
<pre><code>MyTuple = named_tuple(
    "MyTuple",
    "My named tuple for x,y coordinates",
    x="The x value",
    y="The y value"
)
</code></pre>
<p>Then instantiate the described named tuple with your own data, ie.</p>
<pre><code>t = MyTuple(4, 8)
print(t) # prints: MyTuple(x=4, y=8)
</code></pre>
<p>When executing <code>help(MyTuple)</code> via the python3 command line the following is shown:</p>
<pre><code>Help on class MyTuple:

class MyTuple(builtins.tuple)
 |  MyTuple(x, y)
 |
 |  My named tuple for x,y coordinates
 |
 |  :param x: The x value
 |  :param y: The y value
 |
 |  Method resolution order:
 |      MyTuple
 |      builtins.tuple
 |      builtins.object
 |
 |  Methods defined here:
 |
 |  __getnewargs__(self)
 |      Return self as a plain tuple.  Used by copy and pickle.
 |
 |  __repr__(self)
 |      Return a nicely formatted representation string
 |
 |  _asdict(self)
 |      Return a new OrderedDict which maps field names to their values.
 |
 |  _replace(_self, **kwds)
 |      Return a new MyTuple object replacing specified fields with new values
 |
 |  ----------------------------------------------------------------------
 |  Class methods defined here:
 |
 |  _make(iterable) from builtins.type
 |      Make a new MyTuple object from a sequence or iterable
 |
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |
 |  __new__(_cls, x, y)
 |      Create new instance of MyTuple(x, y)
 |
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |
 |  x
 |      The x value
 |
 |  y
 |      The y value
 |
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  _fields = ('x', 'y')
 |  
 |  _fields_defaults = {}
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from builtins.tuple:
 |  
 |  __add__(self, value, /)
 |      Return self+value.
 |  
 |  __contains__(self, key, /)
 |      Return key in self.
 |  
 |  __eq__(self, value, /)
 |      Return self==value.
 |  
 |  __ge__(self, value, /)
 |      Return self&gt;=value.
 |  
 |  __getattribute__(self, name, /)
 |      Return getattr(self, name).
 |  
 |  __getitem__(self, key, /)
 |      Return self[key].
 |  
 |  __gt__(self, value, /)
 |      Return self&gt;value.
 |  
 |  __hash__(self, /)
 |      Return hash(self).
 |  
 |  __iter__(self, /)
 |      Implement iter(self).
 |  
 |  __le__(self, value, /)
 |      Return self&lt;=value.
 |  
 |  __len__(self, /)
 |      Return len(self).
 |  
 |  __lt__(self, value, /)
 |      Return self&lt;value.
 |  
 |  __mul__(self, value, /)
 |      Return self*value.
 |  
 |  __ne__(self, value, /)
 |      Return self!=value.
 |  
 |  __rmul__(self, value, /)
 |      Return value*self.
 |  
 |  count(self, value, /)
 |      Return number of occurrences of value.
 |  
 |  index(self, value, start=0, stop=9223372036854775807, /)
 |      Return first index of value.
 |      
 |      Raises ValueError if the value is not present.
</code></pre>
<p>Alternatively, you can also specify the parameter's type via:</p>
<pre><code>MyTuple = named_tuple(
    "MyTuple",
    "My named tuple for x,y coordinates",
    x=("int", "The x value"),
    y=("int", "The y value")
)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No, you can only add doc strings to modules, classes and function (including methods)</p>
</div>
<span class="comment-copy">Won't subclassing convert the <code>namedtuple</code> into a full-fledged "object"? Thereby losing some of the performance gains from named-tuples?</span>
<span class="comment-copy">If you add <code>__slots__ = ()</code> to the derived subclass you can retain the memory and performance advantages of using <code>namedtuple</code></span>
<span class="comment-copy">Important that you include <code>__slots__ = ()</code> in the class. Otherwise you create a <code>__dict__</code> for your attrs, losing the lightweight nature of namedtuple.</span>
<span class="comment-copy">Although not as concise and clear as the other answers, this should be the accepted answer because it highlights the importance of <code>__slots__</code>. Without it, you're losing the lightweight value of a namedtuple.</span>
<span class="comment-copy">I obtain "NameError: name 'NamedTuple' is not defined"</span>
<span class="comment-copy">@nbedou <a href="https://docs.python.org/3/library/typing.html#typing.NamedTuple" rel="nofollow noreferrer">docs.python.org/3/library/typing.html#typing.NamedTuple</a></span>
<span class="comment-copy">Note: This is only valid for Python 3.  In Python 2: <code>AttributeError: attribute '__doc__' of 'type' objects is not writable</code>.</span>
