<div class="post-text" itemprop="text">
<p>my troubles with ConfigParser continue. It seems it doesn't support Unicode very well. The config file is indeed saved as UTF-8, but when ConfigParser reads it it seems to be encoded into something else. I assumed it was latin-1 and I thougt overriding <code>optionxform</code> could help:</p>
<pre><code>-- configfile.cfg -- 
[rules]
Häjsan = 3
☃ = my snowman

-- myapp.py --
# -*- coding: utf-8 -*-  
import ConfigParser

def _optionxform(s):
    try:
        newstr = s.decode('latin-1')
        newstr = newstr.encode('utf-8')
        return newstr
    except Exception, e:
        print e

cfg = ConfigParser.ConfigParser()
cfg.optionxform = _optionxform    
cfg.read("myconfig") 
</code></pre>
<p>Of course, when I read the config I get:</p>
<pre><code>'ascii' codec can't decode byte 0xc3 in position 0: ordinal not in range(128)
</code></pre>
<p>I've tried a couple of different variations of decoding 's' but the point seems moot, since it really should be a unicode object from the beginning. After all, the config file is UTF-8? I have confirmed that's something is wrong in the way ConfigParser reads the file by stubbing it out with this DummyConfig class. If I use that then everything is nice unicode, fine and dandy.</p>
<pre><code>-- config.py --
# -*- coding: utf-8 -*-                
apa = {'rules': [(u'Häjsan', 3), (u'☃', u'my snowman')]}

class DummyConfig(object):
    def sections(self):
        return apa.keys()
    def items(self, section):
       return apa[section]
    def add_section(self, apa):
        pass  
    def set(self, *args):
        pass  
</code></pre>
<p>Any ideas what could be causing this or suggestions of other config modules that supports Unicode better are most welcome. I don't want to use <code>sys.setdefaultencoding()</code>!</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>ConfigParser.readfp()</code> method can take a file object, have you tried opening the file object with the correct encoding using the codecs module before sending it to ConfigParser like below:</p>
<pre><code>cfg.readfp(codecs.open("myconfig", "r", "utf8"))
</code></pre>
<p>For Python 3.2 or above, <a href="https://docs.python.org/3/library/configparser.html#configparser.ConfigParser.readfp" rel="noreferrer"><code>readfp()</code></a> is deprecated. Use <a href="https://docs.python.org/3/library/configparser.html#configparser.ConfigParser.read_file" rel="noreferrer"><code>read_file()</code></a> instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try to overwrite the <code>write</code> function in <code>RawConfigParser()</code> like this:</p>
<pre><code>class ConfigWithCoder(RawConfigParser):
def write(self, fp):
    """Write an .ini-format representation of the configuration state."""
    if self._defaults:
        fp.write("[%s]\n" % "DEFAULT")
        for (key, value) in self._defaults.items():
            fp.write("%s = %s\n" % (key, str(value).replace('\n', '\n\t')))
        fp.write("\n")
    for section in self._sections:
        fp.write("[%s]\n" % section)
        for (key, value) in self._sections[section].items():
            if key == "__name__":
                continue
            if (value is not None) or (self._optcre == self.OPTCRE):
                if type(value) == unicode:
                    value = ''.join(value).encode('utf-8')
                else:
                    value = str(value)
                value = value.replace('\n', '\n\t')
                key = " = ".join((key, value))
            fp.write("%s\n" % (key))
        fp.write("\n")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The config module is broken when reading and writing unicode strings as values. I tried to fix it, but got caught up in the odd way the parser works.</p>
</div>
<div class="post-text" itemprop="text">
<p>Seems to be a problem with the ConfigParser version for python 2x, and version for 3x is free of this problem. In <a href="http://bugs.python.org/issue11597" rel="nofollow">this issue of the Python Bug Tracker</a>, the status is Closed + WONTFIX.</p>
<p>I've fixed it editing the ConfigParser.py file. In the write method (about the line 412), change:</p>
<pre><code>key = " = ".join((key, str(value).replace('\n', '\n\t')))
</code></pre>
<p>by</p>
<pre><code>key = " = ".join((key, str(value).decode('utf-8').replace('\n', '\n\t')))
</code></pre>
<p>I don't know if it's a real solution, but tested in Windows 7 and Ubuntu 15.04, works like a charm, and I can share and work with the same .ini file in both systems.</p>
</div>
<div class="post-text" itemprop="text">
<p>In python 3.2 <code>encoding</code> parameter was introduced to <code>read()</code>, so it can now be used as:</p>
<pre><code>cfg.read("myconfig", encoding='utf-8')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>what I did is just:</p>
<pre><code>file_name = file_name.decode("utf-8")
cfg.read(file_name)
</code></pre>
</div>
<span class="comment-copy">The snowman is not part of <code>latin-1</code></span>
<span class="comment-copy">Never ever do <code>except Exception</code>; catch the actual exception you know how to handle.</span>
<span class="comment-copy">I had the same issue AND solved it the same way to READ from the config file. But I also need to rewrite a modified version of it and that fails even if I use a codecs.open : <code>with codecs.open(filename, encoding = ENCODING, mode = 'wb') as conffile: config.write(conffile)</code></span>
<span class="comment-copy">Hi Ghislain, I have the same issue with configparser to write back unicode string. It's solved by update the it to the lastest verion by pip.</span>
<span class="comment-copy">You can also monkey-patch the RawConfigParser: <code>RawConfigParser.write = write</code></span>
<span class="comment-copy">I ran into this today, still chewing this over but at first sight it seems to me the hard cast str() for doing the replace is unwarranted and unneeded (and therefore itself a bug) in ConfigParser.py.  My reasoning being that if the "value" being transformed is a normal Python2 string, then replace will work correctly without the str() cast, while if it is a unicode string then forcing it to str() implies encoding the str buffer with the default "ascii" encoder which is impossible if the string contains Unicode characters. Moreover unicode string also implements .replace().  So, why the str()?</span>
<span class="comment-copy">Also as of this writing your proposed solution doesn't seem to work: &gt;&gt;&gt; key = u'foo' &gt;&gt;&gt; value = u'd\xeb\x02\nvK+' &gt;&gt;&gt; key = " = ".join((key, str(value).decode('utf-8').replace('\n', '\n\t'))) Traceback (most recent call last):   File "&lt;stdin&gt;", line 1, in &lt;module&gt; UnicodeEncodeError: 'ascii' codec can't encode character u'\xeb' in position 1: ordinal not in range(128)</span>
<span class="comment-copy">Finally I wonder at what ConfigParser is doing here -- inserting tabs after newlines? Is that legit?  Seems to be taking liberties with the "value" which it arguably may not?</span>
<span class="comment-copy">And to note, removing str().decode() calls does seem to work:  &gt;&gt;&gt; key = u'foo' &gt;&gt;&gt; value = u'd\xeb\x02\nvK+' &gt;&gt;&gt; key = " = ".join((key, value.replace('\n', '\n\t'))) &gt;&gt;&gt; print repr(key) u'foo = d\xeb\x02\n\tvK+'</span>
