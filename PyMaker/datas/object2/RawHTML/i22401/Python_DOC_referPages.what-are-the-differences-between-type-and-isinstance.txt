<div class="post-text" itemprop="text">
<p>What are the differences between these two code fragments?
Using <code>type()</code>:</p>
<pre><code>import types

if type(a) is types.DictType:
    do_something()
if type(b) in types.StringTypes:
    do_something_else()
</code></pre>
<p>Using <code>isinstance()</code>:</p>
<pre><code>if isinstance(a, dict):
    do_something()
if isinstance(b, str) or isinstance(b, unicode):
    do_something_else()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To summarize the contents of other (already good!) answers, <code>isinstance</code> caters for inheritance (an instance of a derived class <em>is an</em> instance of a base class, too), while checking for equality of <code>type</code> does not (it demands identity of types and rejects instances of subtypes, AKA subclasses).</p>
<p>Normally, in Python, you want your code to support inheritance, of course (since inheritance is so handy, it would be bad to stop code using yours from using it!), so <code>isinstance</code> is less bad than checking identity of <code>type</code>s because it seamlessly supports inheritance.</p>
<p>It's not that <code>isinstance</code> is <em>good</em>, mind you—it's just <em>less bad</em> than checking equality of types.  The normal, Pythonic, preferred solution is almost invariably "duck typing": try using the argument <em>as if</em> it was of a certain desired type, do it in a <code>try</code>/<code>except</code> statement catching all exceptions that could arise if the argument was not in fact of that type (or any other type nicely duck-mimicking it;-), and in the <code>except</code> clause, try something else (using the argument "as if" it was of some other type).</p>
<p><code>basestring</code> <strong>is</strong>, however, quite a special case—a builtin type that exists <strong>only</strong> to let you use <code>isinstance</code> (both <code>str</code> and <code>unicode</code> subclass <code>basestring</code>). Strings are sequences (you could loop over them, index them, slice them, ...), but you generally want to treat them as "scalar" types—it's somewhat incovenient (but a reasonably frequent use case) to treat all kinds of strings (and maybe other scalar types, i.e., ones you can't loop on) one way, all containers (lists, sets, dicts, ...) in another way, and <code>basestring</code> plus <code>isinstance</code> helps you do that—the overall structure of this idiom is something like:</p>
<pre><code>if isinstance(x, basestring)
  return treatasscalar(x)
try:
  return treatasiter(iter(x))
except TypeError:
  return treatasscalar(x)
</code></pre>
<p>You could say that <code>basestring</code> is an <em>Abstract Base Class</em> ("ABC")—it offers no concrete functionality to subclasses, but rather exists as a "marker", mainly for use with <code>isinstance</code>. The concept is obviously a growing one in Python, since <a href="http://www.python.org/dev/peps/pep-3119/" rel="noreferrer">PEP 3119</a>, which introduces a generalization of it, was accepted and has been implemented starting with Python 2.6 and 3.0.</p>
<p>The PEP makes it clear that, while ABCs can often substitute for duck typing, there is generally no big pressure to do that (see <a href="http://www.python.org/dev/peps/pep-3119/#abcs-vs-duck-typing" rel="noreferrer">here</a>). ABCs as implemented in recent Python versions do however offer extra goodies: <code>isinstance</code> (and <code>issubclass</code>) can now mean more than just "[an instance of] a derived class" (in particular, any class can be "registered" with an ABC so that it will show as a subclass, and its instances as instances of the ABC); and ABCs can also offer extra convenience to actual subclasses in a very natural way via Template Method design pattern applications (see <a href="http://en.wikipedia.org/wiki/Template_method_pattern" rel="noreferrer">here</a> and <a href="http://www.catonmat.net/blog/learning-python-design-patterns-through-video-lectures/" rel="noreferrer">here</a> [[part II]] for more on the TM DP, in general and specifically in Python, independent of ABCs).</p>
<p>For the underlying mechanics of ABC support as offered in Python 2.6, see <a href="http://docs.python.org/library/abc.html" rel="noreferrer">here</a>; for their 3.1 version, very similar, see <a href="http://docs.python.org/3.1/library/abc.html" rel="noreferrer">here</a>.  In both versions, standard library module <a href="http://docs.python.org/3.1/library/collections.html#module-collections" rel="noreferrer">collections</a> (that's the 3.1 version—for the very similar 2.6 version, see <a href="http://docs.python.org/library/collections.html#module-collections" rel="noreferrer">here</a>) offers several useful ABCs.</p>
<p>For the purpose of this answer, the key thing to retain about ABCs (beyond an arguably more natural placement for TM DP functionality, compared to the classic Python alternative of mixin classes such as <a href="http://docs.python.org/library/userdict.html?highlight=userdict#UserDict.DictMixin" rel="noreferrer">UserDict.DictMixin</a>) is that they make <code>isinstance</code> (and <code>issubclass</code>) much more attractive and pervasive (in Python 2.6 and going forward) than they used to be (in 2.5 and before), and therefore, by contrast, make checking type equality an even worse practice in recent Python versions than it already used to be.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's an example where <code>isinstance</code> achieves something that <code>type</code> cannot:</p>
<pre><code>class Vehicle:
    pass

class Truck(Vehicle):
    pass
</code></pre>
<p>in this case, a truck object is a Vehicle, but you'll get this:</p>
<pre><code>isinstance(Vehicle(), Vehicle)  # returns True
type(Vehicle()) == Vehicle      # returns True
isinstance(Truck(), Vehicle)    # returns True
type(Truck()) == Vehicle        # returns False, and this probably won't be what you want.
</code></pre>
<p>In other words, <code>isinstance</code> is true for subclasses, too.</p>
<p>Also see: <a href="https://stackoverflow.com/q/707674/1341006">How to compare type of an object in Python?</a></p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h1>Differences between <code>isinstance()</code> and <code>type()</code> in Python?</h1>
</blockquote>
<p>Type-checking with </p>
<pre><code>isinstance(obj, Base)
</code></pre>
<p>allows for instances of subclasses and multiple possible bases: </p>
<pre><code>isinstance(obj, (Base1, Base2))
</code></pre>
<p>whereas type-checking with </p>
<pre><code>type(obj) is Base
</code></pre>
<p>only supports the type referenced. </p>
<hr/>
<p>As a sidenote, <code>is</code> is likely more appropriate than</p>
<pre><code>type(obj) == Base
</code></pre>
<p>because classes are singletons.</p>
<h2>Avoid type-checking - use Polymorphism (duck-typing)</h2>
<p>In Python, usually you want to allow any type for your arguments, treat it as expected, and if the object doesn't behave as expected, it will raise an appropriate error. This is known as polymorphism, also known as duck-typing.</p>
<pre><code>def function_of_duck(duck):
    duck.quack()
    duck.swim()
</code></pre>
<p>If the code above works, we can presume our argument is a duck. Thus we can pass in other things are actual sub-types of duck:</p>
<pre><code>function_of_duck(mallard)
</code></pre>
<p>or that work like a duck:</p>
<pre><code>function_of_duck(object_that_quacks_and_swims_like_a_duck)
</code></pre>
<p>and our code still works.</p>
<p>However, there are some cases where it is desirable to explicitly type-check.
Perhaps you have sensible things to do with different object types. For example, the Pandas Dataframe object can be constructed from dicts <em>or</em> records. In such a case, your code needs to know what type of argument it is getting so that it can properly handle it. </p>
<p>So, to answer the question:</p>
<h2>Differences between <code>isinstance()</code> and <code>type()</code> in Python?</h2>
<p>Allow me to demonstrate the difference:</p>
<h3><code>type</code></h3>
<p>Say you need to ensure a certain behavior if your function gets a certain kind of argument (a common use-case for constructors). If you check for type like this:</p>
<pre><code>def foo(data):
    '''accepts a dict to construct something, string support in future'''
    if type(data) is not dict:
        # we're only going to test for dicts for now
        raise ValueError('only dicts are supported for now')
</code></pre>
<p>If we try to pass in a dict that is a subclass of <code>dict</code> (as we should be able to, if we're expecting our code to follow the principle of <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="noreferrer">Liskov Substitution</a>, that subtypes can be substituted for types) our code breaks!:</p>
<pre><code>from collections import OrderedDict

foo(OrderedDict([('foo', 'bar'), ('fizz', 'buzz')]))
</code></pre>
<p>raises an error!</p>
<pre><code>Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 3, in foo
ValueError: argument must be a dict
</code></pre>
<h3><code>isinstance</code></h3>
<p>But if we use <code>isinstance</code>, we can support Liskov Substitution!:</p>
<pre><code>def foo(a_dict):
    if not isinstance(a_dict, dict):
        raise ValueError('argument must be a dict')
    return a_dict

foo(OrderedDict([('foo', 'bar'), ('fizz', 'buzz')]))
</code></pre>
<p>returns <code>OrderedDict([('foo', 'bar'), ('fizz', 'buzz')])</code></p>
<h2>Abstract Base Classes</h2>
<p>In fact, we can do even better. <code>collections</code> provides Abstract Base Classes that enforce minimal protocols for various types. In our case, if we only expect the <code>Mapping</code> protocol, we can do the following, and our code becomes even more flexible:</p>
<pre><code>from collections import Mapping

def foo(a_dict):
    if not isinstance(a_dict, Mapping):
        raise ValueError('argument must be a dict')
    return a_dict
</code></pre>
<h2>Response to comment:</h2>
<blockquote>
<p>It should be noted that type can be used to check against multiple classes using <code>type(obj) in (A, B, C)</code></p>
</blockquote>
<p>Yes, you can test for equality of types, but instead of the above, use the multiple bases for control flow, unless you are specifically only allowing those types:</p>
<pre><code>isinstance(obj, (A, B, C))
</code></pre>
<p>The difference, again, is that <code>isinstance</code> supports subclasses that can be substituted for the parent without otherwise breaking the program, a property known as Liskov substitution. </p>
<p>Even better, though, invert your dependencies and don't check for specific types at all.</p>
<h2>Conclusion</h2>
<p>So since we want to support substituting subclasses, in most cases, we want to avoid type-checking with <code>type</code> and prefer type-checking with <code>isinstance</code> - unless you really need to know the precise class of an instance. </p>
</div>
<div class="post-text" itemprop="text">
<p>The latter is preferred, because it will handle subclasses properly. In fact, your example can be written even more easily because <code>isinstance()</code>'s second parameter may be a tuple:</p>
<pre><code>if isinstance(b, (str, unicode)):
    do_something_else()
</code></pre>
<p>or, using the <code>basestring</code> abstract class:</p>
<pre><code>if isinstance(b, basestring):
    do_something_else()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>According to python documentation here is a statement:</p>
<blockquote>
<h3><a href="http://docs.python.org/library/types.html" rel="noreferrer">8.15. types — Names for built-in types</a></h3>
<p>Starting in Python 2.2, built-in
  factory functions such as <code>int()</code> and
  <code>str()</code> are also names for the
  corresponding types.</p>
</blockquote>
<p>So <a href="http://docs.python.org/2/library/functions.html#isinstance" rel="noreferrer"><code>isinstance()</code></a> should be preferred over <a href="http://docs.python.org/2/library/functions.html#type" rel="noreferrer"><code>type()</code></a>. </p>
</div>
<div class="post-text" itemprop="text">
<p>For the real differences, we can find it in <code>code</code>, but I can't find the implement of the default behavior of the <code>isinstance()</code>. </p>
<p>However we can get the similar one <a href="https://github.com/python/cpython/blob/master/Lib/_py_abc.py#L92-L147" rel="nofollow noreferrer">abc.__instancecheck__</a> according to <a href="https://docs.python.org/3/reference/datamodel.html#customizing-instance-and-subclass-checks" rel="nofollow noreferrer">__instancecheck__</a>.</p>
<p>From above <code>abc.__instancecheck__</code>, after using test below:</p>
<pre><code># file tree
# /test/__init__.py
# /test/aaa/__init__.py
# /test/aaa/aa.py
class b():
pass

# /test/aaa/a.py
import sys
sys.path.append('/test')

from aaa.aa import b
from aa import b as c

d = b()

print(b, c, d.__class__)
for i in [b, c, object]:
    print(i, '__subclasses__',  i.__subclasses__())
    print(i, '__mro__', i.__mro__)
    print(i, '__subclasshook__', i.__subclasshook__(d.__class__))
    print(i, '__subclasshook__', i.__subclasshook__(type(d)))
print(isinstance(d, b))
print(isinstance(d, c))

&lt;class 'aaa.aa.b'&gt; &lt;class 'aa.b'&gt; &lt;class 'aaa.aa.b'&gt;
&lt;class 'aaa.aa.b'&gt; __subclasses__ []
&lt;class 'aaa.aa.b'&gt; __mro__ (&lt;class 'aaa.aa.b'&gt;, &lt;class 'object'&gt;)
&lt;class 'aaa.aa.b'&gt; __subclasshook__ NotImplemented
&lt;class 'aaa.aa.b'&gt; __subclasshook__ NotImplemented
&lt;class 'aa.b'&gt; __subclasses__ []
&lt;class 'aa.b'&gt; __mro__ (&lt;class 'aa.b'&gt;, &lt;class 'object'&gt;)
&lt;class 'aa.b'&gt; __subclasshook__ NotImplemented
&lt;class 'aa.b'&gt; __subclasshook__ NotImplemented
&lt;class 'object'&gt; __subclasses__ [..., &lt;class 'aaa.aa.b'&gt;, &lt;class 'aa.b'&gt;]
&lt;class 'object'&gt; __mro__ (&lt;class 'object'&gt;,)
&lt;class 'object'&gt; __subclasshook__ NotImplemented
&lt;class 'object'&gt; __subclasshook__ NotImplemented
True
False
</code></pre>
<p>I get this conclusion,
For <code>type</code>:</p>
<pre><code># according to `abc.__instancecheck__`, they are maybe different! I have not found negative one 
type(INSTANCE) ~= INSTANCE.__class__
type(CLASS) ~= CLASS.__class__
</code></pre>
<p>For <code>isinstance</code>:</p>
<pre><code># guess from `abc.__instancecheck__`
return any(c in cls.__mro__ or c in cls.__subclasses__ or cls.__subclasshook__(c) for c in {INSTANCE.__class__, type(INSTANCE)})
</code></pre>
<p>BTW: better not to mix use <code>relative and absolutely import</code>, use <code>absolutely import</code> from project_dir( added by <code>sys.path</code>)</p>
</div>
<span class="comment-copy">'It's not that isinstance is good, mind you—it's just less bad than checking equality of types. The normal, Pythonic, preferred solution is almost invariably "duck typing"' This is a rather limited view: there are <i>very</i> good cases for using isinstance() in, say, an interpreter where the types reflect the grammar. Being "Pythonic" isn't everything!</span>
<span class="comment-copy">because there's case where you don't want the isInstance behaviour I would argue that there is no "better". They just do something different.</span>
<span class="comment-copy">-1, because "isinstance is better than type" is a misleading comment. it is understood like "<code>type</code> is deprecated, use <code>isinstance</code> instead" at the first glance. for instance, what I wanted was exactly <code>type()</code> checking, but I was misled for a short time (and had to debug a little bit) for that reason.</span>
<span class="comment-copy">It's a good example of how they work differently, but I just ran into a case where I specifically needed <code>type()</code> and not <code>isinstance()</code>. One is not better; they are for different things.</span>
<span class="comment-copy">-1, change "isinstance is better than type" to "isinstance may be more useful that type if you want the following to work". There are many situations where type would be better than isinstance if you don't want to include parent class.</span>
<span class="comment-copy"><i>"In this instance, I prefer to type <code>isinstance</code> rather than <code>type</code>:"</i></span>
