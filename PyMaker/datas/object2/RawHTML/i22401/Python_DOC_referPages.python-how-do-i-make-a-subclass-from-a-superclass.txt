<div class="post-text" itemprop="text">
<p>In Python, how do you make a subclass from a superclass?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code># Initialize using Parent
#
class MySubClass(MySuperClass):
    def __init__(self):
        MySuperClass.__init__(self)
</code></pre>
<p>Or, even better, the use of Python's built-in function, <code>super()</code> (see the <a href="http://docs.python.org/2/library/functions.html#super" rel="noreferrer">Python 2</a>/<a href="https://docs.python.org/3/library/functions.html#super" rel="noreferrer">Python 3</a> documentation for it) may be a slightly better method of calling the parent for initialization:</p>
<pre><code># Better initialize using Parent (less redundant).
#
class MySubClassBetter(MySuperClass):
    def __init__(self):
        super(MySubClassBetter, self).__init__()
</code></pre>
<p>Or, same exact thing as just above, except using the zero argument form of <code>super()</code>, which only works inside a class definition: </p>
<pre><code>class MySubClassBetter(MySuperClass):
    def __init__(self):
        super().__init__()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A heroic little example:</p>
<pre><code>class SuperHero(object): #superclass, inherits from default object
    def getName(self):
        raise NotImplementedError #you want to override this on the child classes

class SuperMan(SuperHero): #subclass, inherits from SuperHero
    def getName(self):
        return "Clark Kent"

class SuperManII(SuperHero): #another subclass
    def getName(self):
       return "Clark Kent, Jr."

if __name__ == "__main__":
    sm = SuperMan()
    print sm.getName()
    sm2 = SuperManII()
    print sm2.getName()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>class MySubClass(MySuperClass):
    def __init__(self):
        MySuperClass.__init__(self)

        # &lt;the rest of your custom initialization code goes here&gt;
</code></pre>
<p>The <a href="http://docs.python.org/2/tutorial/classes.html" rel="noreferrer">section on inheritance</a> in the python documentation explains it in more detail</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>class Class1(object):
    pass

class Class2(Class1):
    pass
</code></pre>
<p>Class2 is a sub-class of Class1</p>
</div>
<div class="post-text" itemprop="text">
<p>In the answers above, the <code>super</code> is initialized without any (keyword) arguments. Often, however, you would like to do that, as well as pass on some 'custom' arguments of your own. Here is an example which illustrates this use case:</p>
<pre><code>class SortedList(list):
    def __init__(self, *args, reverse=False, **kwargs):
        super().__init__(*args, **kwargs)       # Initialize the super class
        self.reverse = reverse
        self.sort(reverse=self.reverse)         # Do additional things with the custom keyword arguments
</code></pre>
<p>This is a subclass of <code>list</code> which, when initialized, immediately sorts itself in the direction specified by the <code>reverse</code> keyword argument, as the following tests illustrate:</p>
<pre><code>import pytest

def test_1():
    assert SortedList([5, 2, 3]) == [2, 3, 5]

def test_2():
    SortedList([5, 2, 3], reverse=True) == [5, 3, 2]

def test_3():
    with pytest.raises(TypeError):
        sorted_list = SortedList([5, 2, 3], True)   # This doesn't work because 'reverse' must be passed as a keyword argument

if __name__ == "__main__":
    pytest.main([__file__])
</code></pre>
<p>Thanks to the passing on of <code>*args</code> to <code>super</code>, the list can be initialized and populated with items instead of only being empty. (Note that <code>reverse</code> is a keyword-only argument in accordance with <a href="https://www.python.org/dev/peps/pep-3102/" rel="noreferrer">PEP 3102</a>).</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>class Subclass (SuperClass):
      # Subclass stuff here
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is another way to make subclasses in python dynamically with a function <code>type()</code>:</p>
<pre><code>SubClass = type('SubClass', (BaseClass,), {'set_x': set_x})  # Methods can be set, including __init__()
</code></pre>
<p>You usually want to use this method when working with metaclasses. When you want to do some lower level automations, that alters way how python creates class. Most likely you will not ever need to do it in this way, but when you do, than you already will know what you are doing.</p>
</div>
<div class="post-text" itemprop="text">
<p>You use:</p>
<pre><code>class DerivedClassName(BaseClassName):
</code></pre>
<p>For details, see the <a href="https://docs.python.org/2/tutorial/classes.html#inheritance" rel="nofollow noreferrer">Python docs, section 9.5</a>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>class Mammal(object): 
#mammal stuff

class Dog(Mammal): 
#doggie stuff
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>class BankAccount:

  def __init__(self, balance=0):
    self.balance = int(balance)

  def checkBalance(self): ## Checking opening balance....
    return self.balance

  def deposit(self, deposit_amount=1000): ## takes in cash deposit amount and updates the balance accordingly.
    self.deposit_amount = deposit_amount
    self.balance += deposit_amount
    return self.balance

  def withdraw(self, withdraw_amount=500): ## takes in cash withdrawal amount and updates the balance accordingly
    if self.balance &lt; withdraw_amount: ## if amount is greater than balance return `"invalid transaction"`
        return 'invalid transaction'
    else:
      self.balance -= withdraw_amount
      return self.balance


class MinimumBalanceAccount(BankAccount): #subclass MinimumBalanceAccount of the BankAccount class

    def __init__(self,balance=0, minimum_balance=500):
        BankAccount.__init__(self, balance=0)
        self.minimum_balance = minimum_balance
        self.balance = balance - minimum_balance
        #print "Subclass MinimumBalanceAccount of the BankAccount class created!"

    def MinimumBalance(self):
        return self.minimum_balance

c = BankAccount()
print(c.deposit(50))
print(c.withdraw(10))

b = MinimumBalanceAccount(100, 50)
print(b.deposit(50))
print(b.withdraw(10))
print(b.MinimumBalance())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Subclassing in Python is done as follows:</p>
<pre><code>class WindowElement:
    def print(self):
        pass

class Button(WindowElement):
    def print(self):
        pass
</code></pre>
<p>Here is a <a href="http://www.gidnetwork.com/b-137.html" rel="nofollow noreferrer">tutorial</a> about Python that also contains classes and subclasses.</p>
</div>
<span class="comment-copy">Note that the Python changed the way you do subclassing, so there are 2 ways of doing it, and they don't mix. You will get an error if you mix. Read this post to see the difference: <a href="http://stackoverflow.com/questions/1713038/super-fails-with-error-typeerror-argument-1-must-be-type-not-classobj" title="super fails with error typeerror argument 1 must be type not classobj">stackoverflow.com/questions/1713038/â€¦</a></span>
<span class="comment-copy">OTOH, some people caution against <code>super</code>, especially for new Python programmers (e.g., Lutz). I avoid it.</span>
<span class="comment-copy">The only reason to avoid <code>super</code> is if you don't understand the differences between how <code>super</code> works in Python, and how <code>super</code>/<code>parent</code> works in other languages. Admittedly this is not obvious to people coming from other languages, but I wouldn't conclude that that qualifies it as something to "caution against". It <i>does</i> work. It just works differently. Just read about what it actually does in Python before you complain about getting results you didn't expect.</span>
<span class="comment-copy">What is the difference between the two?</span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/21639788/difference-between-super-and-calling-superclass-directly">This is the difference between the two methods to call the super class functions</a></span>
<span class="comment-copy">yeay for using specific names to make a concept more easily digestible!</span>
<span class="comment-copy">You only need to define that <code>__init__</code> method if want to add further code to it, otherwise the original init method is used anyway (although it's worth mentioning, and is perfectly valid code)</span>
<span class="comment-copy">I think the question was vague enough to assume there might be further code added. Better to provide too much info than not enough and end up with another question when the OP implements it. :)</span>
<span class="comment-copy">Cool.  This is what I was actually looking for, i.e. a sub class with no extension / overrides to the super.</span>
<span class="comment-copy">This answer would be more helpful if you included an explanation of what it does</span>
<span class="comment-copy">Although this code may help to solve the problem, it doesn't explain <i>why</i> and/or <i>how</i> it answers the question. Providing this additional context  would significantly improve its long-term educational value. Please <a href="https://stackoverflow.com/posts/38214084/edit">edit</a> your answer to add explanation, including what limitations and assumptions apply.</span>
<span class="comment-copy">While this code snippet may solve the question, <a href="http://meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers">including an explanation</a> really helps to improve the quality of your post. Remember that you are answering the question for readers in the future, and those people might not know the reasons for your code suggestion.</span>
