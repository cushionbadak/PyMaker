<div class="post-text" itemprop="text">
<p>Is it possible to determine if the current script is running inside a virtualenv environment?</p>
</div>
<div class="post-text" itemprop="text">
<p>AFAIK the most reliable way to check for this (and the way that is used internally in virtualenv and in pip) is to check for the existence of <code>sys.real_prefix</code>:</p>
<pre><code>import sys

if hasattr(sys, 'real_prefix'):
    #...
</code></pre>
<p>Inside a virtualenv, <code>sys.prefix</code> points to the virtualenv directory, and <code>sys.real_prefix</code> points to the "real" prefix of the system Python (often <code>/usr</code> or <code>/usr/local</code> or some such).</p>
<p>Outside a virtualenv, <code>sys.real_prefix</code> should not exist.</p>
<p>Using the <code>VIRTUAL_ENV</code> environment variable is not reliable. It is set by the virtualenv <code>activate</code> shell script, but a virtualenv can be used without activation by directly running an executable from the virtualenv's <code>bin/</code> (or <code>Scripts</code>) directory, in which case <code>$VIRTUAL_ENV</code> will not be set.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try using <code>pip -V</code> (notice capital V)</p>
<p>If you are running the virtual env. it'll show the path to the env.'s location.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is an improvement of the accepted answer by <a href="https://stackoverflow.com/users/3207/carl-meyer">Carl Meyer</a>. It works with <a href="https://pypi.python.org/pypi/virtualenv" rel="noreferrer">virtualenv</a> for Python 3 and 2 and also for the <a href="https://docs.python.org/3/library/venv.html" rel="noreferrer">venv</a> module in Python 3:</p>
<pre><code>import sys


def is_venv():
    return (hasattr(sys, 'real_prefix') or
            (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix))
</code></pre>
<p>The check for <code>sys.real_prefix</code> covers virtualenv, the equality of non-empty <code>sys.base_prefix</code> with <code>sys.prefix</code> covers venv.</p>
<p>Consider a script that uses the function like this:</p>
<pre><code>if is_venv():
    print('inside virtualenv or venv')
else:
    print('outside virtualenv or venv')
</code></pre>
<p>And the following invocation:</p>
<pre><code>$ python2 test.py 
outside virtualenv or venv

$ python3 test.py 
outside virtualenv or venv

$ python2 -m virtualenv virtualenv2
...
$ . virtualenv2/bin/activate
(virtualenv2) $ python test.py 
inside virtualenv or venv
(virtualenv2) $ deactivate

$ python3 -m virtualenv virtualenv3
...
$ . virtualenv3/bin/activate
(virtualenv3) $ python test.py 
inside virtualenv or venv
(virtualenv3) $ deactivate 

$ python3 -m venv venv3
$ . venv3/bin/activate
(venv3) $ python test.py 
inside virtualenv or venv
(venv3) $ deactivate 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using $VIRTUAL_ENV variable indeed will check if we are inside virtual environment, but the issue might be with deactivate function that not clear this variable when we leave virtualenv.</p>
</div>
<div class="post-text" itemprop="text">
<p>According to the virtualenv pep at <a href="http://www.python.org/dev/peps/pep-0405/#specification">http://www.python.org/dev/peps/pep-0405/#specification</a> you can just use sys.prefix instead os.environ['VIRTUAL_ENV'].</p>
<p>the sys.real_prefix does not exist in my virtualenv and same with sys.base_prefix.</p>
</div>
<div class="post-text" itemprop="text">
<p>I routinely use several Anaconda-installed virtual environments (venv).  This code snippet/examples enables you to determine whether or not you are in a venv (or your system environment), and to also require a specific venv for your script.</p>
<h3>ADD TO PYTHON SCRIPT (code snippet):</h3>
<pre><code># ----------------------------------------------------------------------------
# Want script to run in Python 3.5 (has required installed OpenCV, imutils, ... packages):
import os

# First, see if we are in a conda venv { py27: Python 2.7 | py35: Python 3.5 | tf: TensorFlow | thee : Theano }
try:
   os.environ["CONDA_DEFAULT_ENV"]
except KeyError:
   print("\tPlease set the py35 { p3 | Python 3.5 } environment!\n")
   exit()

# If we are in a conda venv, require the p3 venv:
if os.environ['CONDA_DEFAULT_ENV'] != "py35":
    print("\tPlease set the py35 { p3 | Python 3.5 } environment!\n")
    exit()

# See also:
# Python: Determine if running inside virtualenv
# http://stackoverflow.com/questions/1871549/python-determine-if-running-inside-virtualenv  
# [ ... SNIP! ... ]
</code></pre>
<h3>RUN YOUR SCRIPT (examples):</h3>
<pre><code>$ python  webcam_cv3_v2_fps_v2c.py  -n50
    Please set the py35 { p3 | Python 3.5 } environment!

$ thee
  [Theano in Anaconda Python 2.7 venv (source activate theano-env)]

(theano-env) $ python  webcam_cv3_v2_fps_v2c.py  -n50
    Please set the py35 { p3 | Python 3.5 } environment!

(theano-env) $ tf
  [TensorFlow in Anaconda Python 2.7 venv (source activate tf-env]

(tf-env) $ python  webcam_cv3_v2_fps_v2c.py  -n50
    Please set the py35 { p3 | Python 3.5 } environment!

(tf-env) $ p2
  [Anaconda Python 2.7 venv (source activate py27)]

(py27) $ python  webcam_cv3_v2_fps_v2c.py  -n50
    Please set the py35 { p3 | Python 3.5 } environment!

(py27) $ p3
  [Anaconda Python 3.5 venv (source activate py35)]

(py35) $ python  webcam_cv3_v2_fps_v2c.py  -n50

    current env: py35
    processing (live): found 2 faces and 4 eyes in this frame

    threaded OpenCV implementation
    num_frames: 50
    webcam -- approx. FPS: 18.59
    Found 2 faces and 4 eyes!

(py35) $ sd
  [Anaconda venv deactivate (source deactivate)]

$ python  webcam_cv3_v2_fps_v2c.py  -n50
    Please set the py35 { p3 | Python 3.5 } environment!

$ ## Q.E.D.  ;-)
</code></pre>
<h3>Update: use in bash scripts:</h3>
<p>You can also use this approach in bash scripts (e.g., those that must run in a specific virtual environment).  Example (added to bash script):</p>
<pre><code># ----------------------------------------------------------------------------
# Excerpt from: /mnt/Vancouver/Programming/scripts/tf_tb_del.sh      ## tf_tb_del: tf_tensorboard_delete
# [bash script run on command-line: calls TensorFlow-related commands, therefore must be run in tf-env venv]

if [ $CONDA_DEFAULT_ENV ]        ## &lt;&lt; note the spaces (important in bash)!
then
    printf  '\n\tvenv: tf-env\n'
else
    printf '\n\n\t*******************************************************************\n'
    printf '\t***  NOTE! Must run this script in tf-env virtual environment!  ***\n'
    printf '\t*******************************************************************'
    exit
fi
## [ ... snip ... ]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To check whether your inside Virtualenv:</p>
<pre><code>import os

if os.getenv('VIRTUAL_ENV'):
    print('Using Virtualenv')
else:
    print('Not using Virtualenv')
</code></pre>
<p>You can also get more data on your environment:</p>
<pre><code>import sys
import os

print(f'Python Executable: {sys.executable}')
print(f'Python Version: {sys.version}')
print(f'Virtualenv: {os.getenv("VIRTUAL_ENV")}')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>(edited) I found that way, what do you think of it ? (it also returns the venv base path and works even for <strong>readthedocs</strong> where checking the <strong>env</strong> variable does not):</p>
<pre><code>import os
import sys
from distutils.sysconfig import get_config_vars


def get_venv_basedir():
    """Returns the base directory of the virtualenv, useful to read configuration and plugins"""

    exec_prefix = get_config_vars()['exec_prefix']

    if hasattr(sys, 'real_prefix') is False or exec_prefix.startswith(sys.real_prefix):
        raise EnvironmentError('You must be in a virtual environment')

    return os.path.abspath(get_config_vars()['exec_prefix'] + '/../')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do <code>which python</code> and see if its pointing to the one in virtual env.  </p>
</div>
<div class="post-text" itemprop="text">
<p>It's not bullet-proof but for UNIX environments simple test like</p>
<pre><code>if run("which python3").find("venv") == -1:
    # something when not executed from venv
</code></pre>
<p>works great for me. It's simpler then testing existing of some attribute and, anyway, you should name your venv directory <code>venv</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>In windows OS you see something like this: </p>
<pre><code>C:\Users\yourusername\virtualEnvName\Scripts&gt;activate
(virtualEnvName) C:\Users\yourusername\virtualEnvName\Scripts&gt;
</code></pre>
<p>Parentheses mean that you are actually in the virtual environment called "virtualEnvName".</p>
</div>
<div class="post-text" itemprop="text">
<p>A <em>potential</em> solution is:</p>
<pre><code>os.access(sys.executable, os.W_OK)
</code></pre>
<p>In my case I really just wanted to detect if I could install items with pip as is. While it might not be the right solution for all cases, consider simply checking if you have write permissions for the location of the Python executable.</p>
<p><strong>Note:</strong> this works in all versions of Python, but also returns <code>True</code> if you run the system Python with <code>sudo</code>. Here's a potential use case:</p>
<pre><code>import os, sys
can_install_pip_packages = os.access(sys.executable, os.W_OK)

if can_install_pip_packages:
    import pip
    pip.main(['install', 'mypackage'])
</code></pre>
</div>
<span class="comment-copy">Out of curiosity, why would you want to know that?</span>
<span class="comment-copy">i.e. to be able to write custom script that generates prompt for your shell and you want that prompt to indicate if you are in venv or not, so you want to be able to detect that from within that code, best w/o calling external tools.</span>
<span class="comment-copy">This doesn't seem to be valid in Python 3 anymore.</span>
<span class="comment-copy">If you are using virtualenv (github.com/pypa/virtualenv), this answer is equally correct for Python 2 or Python 3. If you are using pyvenv (<a href="http://legacy.python.org/dev/peps/pep-0405/" rel="nofollow noreferrer">legacy.python.org/dev/peps/pep-0405</a>), a virtualenv-equivalent built into Python 3.3+ (but not the same thing as virtualenv), then it uses sys.base_prefix instead of sys.real_prefix, and sys.base_prefix always exists; outside a pyvenv it is equal to sys.prefix.</span>
<span class="comment-copy">I've been using this successfully in Windows 8/8.1 editions to discern whether the program runs inside a virtualenv or not but on Windows Server 2012 R2 this returns False regardless if the program runs inside a virtualenv or not! :(</span>
<span class="comment-copy">@Kounavi I don't think it's likely that the Windows version would have any impact. This answer is a core part of how virtualenv works on any platform. Is it possible you are using Python 3 pyvenv, not virtualenv, on the Windows 2012 machine? Or that something is going on with the PATH and you are not in fact running in the virtualenv when you think you are?</span>
<span class="comment-copy">@CarlMeyer I'm using Python 2.7.9 x64. The only modules I have installed are pip (7.0.3), setuptools (7.0), vboxapi (1.0), virtualenv (13.0.3) and virtualenvwrapper-powershell (12.7.8). I'm looking at it to see why this happens :)</span>
<span class="comment-copy">If you've moved your <code>virtualenv</code> around a lot, it's possible this can fail or lie to you. If it's lying, you can do <code>find /path/to/venv/ -type f -exec sed -ie "s:/old/path/to/venv:/path/to/venv:g" {} \+</code>. If it's failing (I got "bad marshal data") you'll need to wipe the .pyc files with <code>find /path/to/venv -type f -name "*.pyc" -exec rm {} \+</code> (don't worry, they'll rebuild automatically).</span>
<span class="comment-copy">I just tested this on Windows 10 with Python 3.7.  It prints the location of pip from the default install <code>...\lib\site-packages</code> in the <code>%PATH%</code>.  So it will return a false positive in that case.</span>
<span class="comment-copy">deactivate does clear this variable</span>
<span class="comment-copy">virtualenv is the standalone project that works on any Python version (<a href="https://github.com/pypa/virtualenv" rel="nofollow noreferrer">github.com/pypa/virtualenv</a>). The PEP you linked to is for pyvenv, which is based on virtualenv but is implemented differently (better) and is built-in to Python 3.3+. This question is about virtualenv, not pyvenv. You're correct that in a pyvenv there is no <code>sys.real_prefix</code>.</span>
<span class="comment-copy">A nice way to detect from bash using this answer is to run:      <code>env |grep VIRTUAL_ENV |wc -l</code>  which will return a 1 if in a venv or a 0 if not.</span>
<span class="comment-copy">If you're in a shell you can simply use <code>[[ -n $VIRTUAL_ENV ]] &amp;&amp; echo virtualenv</code> or <code>[[ -z $VIRTUAL_ENV ]] &amp;&amp; echo not virtualenv</code> depending on your needs.</span>
<span class="comment-copy">Note: the "if hasattr(sys, 'real_prefix'):" approach (accepted answer) did not work for me ... Anaconda-installed virtual environments on an Arch Linux x86_64 OS</span>
<span class="comment-copy">This is the best cross-platform (Windows/Unix) approach.</span>
<span class="comment-copy">It's better to use shell built-ins such as <code>command -v</code>.</span>
