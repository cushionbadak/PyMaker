<div class="post-text" itemprop="text">
<p>For example, my csv has columns as below:</p>
<pre class="lang-none prettyprint-override"><code>ID, ID2, Date, Job No, Code
</code></pre>
<p>I need to write the columns back in the same order. The <code>dict</code> jumbles the order immediately, so I believe it's more of a problem with the reader.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python's <code>dict</code>s do NOT maintain order prior to 3.6 (but, regardless, in that version the <code>csv.DictReader</code> class was modified to return <code>OrderedDict</code>s).</p>
<p>However, the instance of <code>csv.DictReader</code> that you're using (after you've read the first row!-) <strong>does</strong> have a <code>.fieldnames</code> list of strings, which <strong>IS</strong> in order.</p>
<p>So,</p>
<pre><code>for rowdict in myReader:
  print ['%s:%s' % (f, rowdict[f]) for f in myReader.fieldnames]
</code></pre>
<p>will show you that the order is indeed maintained (in <code>.fieldnames</code> of course, <em>NEVER</em> in the <code>dict</code> -- that's intrinsically impossible in Python!-).</p>
<p>So, suppose you want to read <code>a.csv</code> and write <code>b.csv</code> with the same column order.  Using plain reader and writer is too easy, so you want to use the Dict varieties instead;-). Well, one way is...:</p>
<pre><code>import csv

a = open('a.csv', 'r')
b = open('b.csv', 'w')
ra = csv.DictReader(a)
wb = csv.DictWriter(b, None)

for d in ra:

  if wb.fieldnames is None:
    # initialize and write b's headers
    dh = dict((h, h) for h in ra.fieldnames)
    wb.fieldnames = ra.fieldnames
    wb.writerow(dh)

  wb.writerow(d)

b.close()
a.close()
</code></pre>
<p>assuming you have headers in <code>a.csv</code> (otherewise you can't use a DictReader on it) and want just the same headers in <code>b.csv</code>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from csv import DictReader, DictWriter

with open("input.csv", 'r') as input_file:
    reader = DictReader(f=input_file)
    with open("output.csv", 'w') as output_file:
        writer = DictWriter(f=output_file, fieldnames=reader.fieldnames)
        for row in reader:
            writer.writerow(row)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Make an <code>OrderedDict</code> from each row <code>dict</code> sorted by <code>DictReader.fieldnames</code>.</p>
<pre><code>import csv
from collections import OrderedDict

reader = csv.DictReader(open("file.csv"))
for row in reader:
    sorted_row = OrderedDict(sorted(row.items(),
          key=lambda item: reader.fieldnames.index(item[0])))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I know this question is old...but if you use <code>DictReader</code>, you can pass it an ordered list with the fieldnames to the <code>fieldnames</code> param</p>
</div>
<div class="post-text" itemprop="text">
<p>Unfortunatley the default DictReader does not allow for overriding the dict class, a custom DictReader would do the trick though</p>
<pre><code>import csv

class DictReader(csv.DictReader):
    def __init__(self, *args, **kwargs):
        self.dict_class = kwargs.pop(dict_class, dict)
        super(DictReader, self).__init__(*args, **kwargs)

    def __next__(self):
        ''' copied from python source '''
        if self.line_num == 0:
            # Used only for its side effect.
            self.fieldnames
        row = next(self.reader)
        self.line_num = self.reader.line_num

        # unlike the basic reader, we prefer not to return blanks,
        # because we will typically wind up with a dict full of None
        # values
        while row == []:
            row = next(self.reader)
        # using the customized dict_class
        d = self.dict_class(zip(self.fieldnames, row))
        lf = len(self.fieldnames)
        lr = len(row)
        if lf &lt; lr:
            d[self.restkey] = row[lf:]
        elif lf &gt; lr:
            for key in self.fieldnames[lr:]:
                d[key] = self.restval
        return d
</code></pre>
<p>use it like so</p>
<pre><code>import collections

csv_reader = DictReader(f, dict_class=collections.OrderedDict)
# ...
</code></pre>
</div>
<span class="comment-copy">Thanks Alex Martelli! You've gone over and above the call of duty here :) and... it is appreciated! I didn't realise there was fieldnames, but re-reading the API docs I can see it now. Thanks for the alternative, but since my DictReader is working well now I'll stick with it.</span>
<span class="comment-copy">@RaffiKhatchadourian a is a.csv, b is b.csv ra presumably stands for read from file a, wb presumably for write to file b, d for dictionary, dh for dictionary headers.... Alex Thanks for the awesome explanation!</span>
<span class="comment-copy">any reason why you went through the whole <code>dh = dict(...</code> <code>...wb.writerow(dh)</code> when you could have done <code>wb.fieldnames = ra.fieldnames; wb.writeheader()</code>?</span>
<span class="comment-copy">Looks good, but how you can add quotes to all fileds in all lines except the header?</span>
<span class="comment-copy">would you be able to explain how the lambda function here is working? I see similar examples listed in the official <a href="https://docs.python.org/3/howto/sorting.html" rel="nofollow noreferrer">docs</a>, however its not clear to me how this is producing the correct order (e.g. what the actual output of the lambda function looks like)</span>
<span class="comment-copy">The last line serializes <code>dict row</code> into a (key,value) tuple array. Then resorts the array by the correct key order and repackages it on an OrderedDict. The lambda takes a <code>tuple item</code>, retrives it's key <code>item[0]</code> and looks for its index on <code>reader.fieldnames</code>. That index is used by <code>sorted()</code> to sort the tuples.</span>
<span class="comment-copy">Note that from Python 3.6 onwards, the rows returned from <a href="https://docs.python.org/3/library/csv.html#csv.DictReader" rel="nofollow noreferrer"><code>csv.DictReader</code></a>s are now <code>OrderedDict</code>s, not regular ones as they were previously (so doing something like this is no longer necessary). The good news, I guess, is that using this approach won't hurt, it'll only be redundant.</span>
