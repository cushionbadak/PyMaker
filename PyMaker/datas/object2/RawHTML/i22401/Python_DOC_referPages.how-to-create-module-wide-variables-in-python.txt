<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/423379/using-global-variables-in-a-function">Using global variables in a function</a>
<span class="question-originals-answer-count">
                    18 answers
                </span>
</li>
</ul>
</div>
<p>Is there a way to set up a global variable inside of a module? When I tried to do it the most obvious way as appears below, the Python interpreter said the variable <code>__DBNAME__</code> did not exist.</p>
<pre><code>...
__DBNAME__ = None

def initDB(name):
    if not __DBNAME__:
        __DBNAME__ = name
    else:
        raise RuntimeError("Database name has already been set.")
...
</code></pre>
<p>And after importing the module in a different file</p>
<pre><code>...
import mymodule
mymodule.initDB('mydb.sqlite')
...
</code></pre>
<p>And the traceback was: <code>UnboundLocalError: local variable '__DBNAME__' referenced before assignment</code></p>
<p>Any ideas? I'm trying to set up a singleton by using a module, as per <a href="https://stackoverflow.com/questions/31875/is-there-a-simple-elegant-way-to-define-singletons-in-python/31887#31887">this fellow's</a> recommendation.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is what is going on.</p>
<p>First, the only global variables Python really has are module-scoped variables.  You cannot make a variable that is truly global; all you can do is make a variable in a particular scope.  (If you make a variable inside the Python interpreter, and then import other modules, your variable is in the outermost scope and thus global within your Python session.)</p>
<p>All you have to do to make a module-global variable is just assign to a name.</p>
<p>Imagine a file called foo.py, containing this single line:</p>
<pre><code>X = 1
</code></pre>
<p>Now imagine you import it.</p>
<pre><code>import foo
print(foo.X)  # prints 1
</code></pre>
<p>However, let's suppose you want to use one of your module-scope variables as a global inside a function, as in your example.  Python's default is to assume that function variables are local.  You simply add a <code>global</code> declaration in your function, before you try to use the global.</p>
<pre><code>def initDB(name):
    global __DBNAME__  # add this line!
    if __DBNAME__ is None: # see notes below; explicit test for None
        __DBNAME__ = name
    else:
        raise RuntimeError("Database name has already been set.")
</code></pre>
<p>By the way, for this example, the simple <code>if not __DBNAME__</code> test is adequate, because any string value other than an empty string will evaluate true, so any actual database name will evaluate true.  But for variables that might contain a number value that might be 0, you can't just say <code>if not variablename</code>; in that case, you should explicitly test for <code>None</code> using the <code>is</code> operator.  I modified the example to add an explicit <code>None</code> test.  The explicit test for <code>None</code> is never wrong, so I default to using it.</p>
<p>Finally, as others have noted on this page, two leading underscores signals to Python that you want the variable to be "private" to the module.  If you ever do an <code>import * from mymodule</code>, Python will not import names with two leading underscores into your name space.  But if you just do a simple <code>import mymodule</code> and then say <code>dir(mymodule)</code> you will see the "private" variables in the list, and if you explicitly refer to <code>mymodule.__DBNAME__</code> Python won't care, it will just let you refer to it.  The double leading underscores are a major clue to users of your module that you don't want them rebinding that name to some value of their own.</p>
<p>It is considered best practice in Python not to do <code>import *</code>, but to minimize the coupling and maximize explicitness by either using <code>mymodule.something</code> or by explicitly doing an import like <code>from mymodule import something</code>.</p>
<p>EDIT: If, for some reason, you need to do something like this in a very old version of Python that doesn't have the <code>global</code> keyword, there is an easy workaround.  Instead of setting a module global variable directly, use a mutable type at the module global level, and store your values inside it.</p>
<p>In your functions, the global variable name will be read-only; you won't be able to rebind the actual global variable name.  (If you assign to that variable name inside your function it will only affect the local variable name inside the function.)  But you can use that local variable name to access the actual global object, and store data inside it.</p>
<p>You can use a <code>list</code> but your code will be ugly:</p>
<pre><code>__DBNAME__ = [None] # use length-1 list as a mutable

# later, in code:  
if __DBNAME__[0] is None:
    __DBNAME__[0] = name
</code></pre>
<p>A <code>dict</code> is better.  But the most convenient is a class instance, and you can just use a trivial class:</p>
<pre><code>class Box:
    pass

__m = Box()  # m will contain all module-level values
__m.dbname = None  # database name global in module

# later, in code:
if __m.dbname is None:
    __m.dbname = name
</code></pre>
<p>(You don't really need to capitalize the database name variable.)</p>
<p>I like the syntactic sugar of just using <code>__m.dbname</code> rather than <code>__m["DBNAME"]</code>; it seems the most convenient solution in my opinion.  But the <code>dict</code> solution works fine also.</p>
<p>With a <code>dict</code> you can use any hashable value as a key, but when you are happy with names that are valid identifiers, you can use a trivial class like <code>Box</code> in the above.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong><em>Explicit access to module level variables by accessing them explicity on the module</em></strong></p>
<hr/>
<p><strong>In short:</strong> The technique described here is the same as in <a href="https://stackoverflow.com/a/1978076/2889970">steveha's answer</a>, <strong><em>except</em></strong>, that no artificial helper object is created to explicitly scope variables. <em>Instead the module object itself is given a variable pointer, and therefore provides explicit scoping upon access from everywhere. (like assignments in local function scope)</em>.</p>
<p>Think of it like <strong><em>self</em></strong> for the <strong><em>current module</em></strong> instead of the current instance !</p>
<pre class="lang-python prettyprint-override"><code># db.py
import sys

# this is a pointer to the module object instance itself.
this = sys.modules[__name__]

# we can explicitly make assignments on it 
this.db_name = None

def initialize_db(name):
    if (this.db_name is None):
        # also in local function scope. no scope specifier like global is needed
        this.db_name = name
        # also the name remains free for local use
        db_name = "Locally scoped db_name variable. Doesn't do anything here."
    else:
        msg = "Database is already initialized to {0}."
        raise RuntimeError(msg.format(this.db_name))
</code></pre>
<p><a href="https://stackoverflow.com/a/2029528/2889970">As modules are cached and therefore import only once</a>, you can import <code>db.py</code> as often on as many clients as you want, manipulating the same, universal state:</p>
<pre class="lang-python prettyprint-override"><code># client_a.py
import db

db.initialize_db('mongo')
</code></pre>
<pre class="lang-python prettyprint-override"><code># client_b.py
import db

if (db.db_name == 'mongo'):
    db.db_name = None  # this is the preferred way of usage, as it updates the value for all clients, because they access the same reference from the same module object
</code></pre>
<pre class="lang-python prettyprint-override"><code># client_c.py
from db import db_name
# be careful when importing like this, as a new reference "db_name" will
# be created in the module namespace of client_c, which points to the value 
# that "db.db_name" has at import time of "client_c".

if (db_name == 'mongo'):  # checking is fine if "db.db_name" doesn't change
    db_name = None  # be careful, because this only assigns the reference client_c.db_name to a new value, but leaves db.db_name pointing to its current value.
</code></pre>
<hr/>
<p>As an additional bonus I find it quite pythonic overall as it nicely fits Pythons policy of <em>Explicit is better than implicit</em>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Steveha's answer was helpful to me, but omits an important point (one that I think wisty was getting at). The global keyword is not necessary if you only access but do not assign the variable in the function.</p>
<p>If you assign the variable without the global keyword then Python creates a new local var -- the module variable's value will now be hidden inside the function.  Use the global keyword to assign the module var inside a function.</p>
<p>Pylint 1.3.1 under Python 2.7 enforces NOT using global if you don't assign the var.</p>
<pre><code>module_var = '/dev/hello'

def readonly_access():
    connect(module_var)

def readwrite_access():
    global module_var
    module_var = '/dev/hello2'
    connect(module_var)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For this, you need to declare the variable as global. However, a global variable is also accessible from <em>outside</em> the module by using <code>module_name.var_name</code>. Add this as the first line of your module:</p>
<pre><code>global __DBNAME__
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are falling for a subtle quirk. You cannot re-assign module-level variables inside a python function. I think this is there to stop people re-assigning stuff inside a function by accident. </p>
<p>You can access the module namespace, you just shouldn't try to re-assign. If your function assigns something, it automatically becomes a function variable - and python won't look in the module namespace.</p>
<p>You can do:</p>
<pre><code>__DB_NAME__ = None

def func():
    if __DB_NAME__:
        connect(__DB_NAME__)
    else:
        connect(Default_value)
</code></pre>
<p>but you cannot re-assign <code>__DB_NAME__</code> inside a function. </p>
<p>One workaround:</p>
<pre><code>__DB_NAME__ = [None]

def func():
    if __DB_NAME__[0]:
        connect(__DB_NAME__[0])
    else:
        __DB_NAME__[0] = Default_value
</code></pre>
<p>Note, I'm not re-assigning <code>__DB_NAME__</code>, I'm just modifying its contents.</p>
</div>
<span class="comment-copy">Thanks to everyone for the great answers! Learned a lot more about Python than I expected to.</span>
<span class="comment-copy">The latter technique (using a class) is perfect. Thanks.</span>
<span class="comment-copy">Two leading underscores would lead to name mangling. Usually a single underscore is sufficient to indicate that a variable should be considered private. <a href="https://stackoverflow.com/questions/6930144/underscore-vs-double-underscore-with-variables-and-methods#6930223" title="underscore vs double underscore with variables and methods%236930223">stackoverflow.com/questions/6930144/…</a></span>
<span class="comment-copy">Concerning the Box class, wouldn't be better to define dbname = None in a <b>init</b> function than to to this outside, as in the example?</span>
<span class="comment-copy">Python doesn't care how the variables get set up.  There are recipes for the <code>Box</code> class or similar that define an <code>__init__()</code> function, that grabs all the values from <code>kwargs</code> and sets them up in the class dictionary.  Then you could just do <code>_m = Box(dbname="whatever")</code> and it's tidy.  Since Python 3.3, there is now <code>types.SimpleNameSpace</code> which is a full-featured implementation of the <code>Box</code> class; see: <a href="https://docs.python.org/3/library/types.html#additional-utility-classes-and-functions" rel="nofollow noreferrer">docs.python.org/3/library/…</a></span>
<span class="comment-copy">I like that you can use the more precise "from db import" in the second module, even though you have to do the larger "import db" in the main.  This seems to be true if you skip the 'sys' magic and use 'global' in initialize_db.  Can you comment on the pros/cons of global vs. your answer, since they both seem to work the same?</span>
<span class="comment-copy">The <b>pro</b> to me is that you don't need scope manipulation anymore. You  explicitly give the scope by accessing the variable db_name from an object, which happens to be the module. You don't have to declare where the object that you want to work with lives, before using it anytime. Also you can have local variables named db_name in handler functions, next to this.db_name as well.</span>
<span class="comment-copy">To me, this seems to be the cleanest way to do this, but my linters are balking at it. Am I doing something wrong or do you/others have this issue as well? Thanks a ton, Chris</span>
<span class="comment-copy">@beeb There is a slight catch with my example for <code>client_b.py</code>. On import time, it will create a new variable in the module scope of <code>client_b</code> that gets assigned the current value of <code>db_name</code> from <code>client_a</code>. You can check against it like in the example, but if the value changes via assignment in <code>client_a</code> for example by calling <code>initialize_db()</code>, that means the reference <code>client_a.db_name</code> points to a new value, other references, for example <code>client_b.db_name</code> still point to the old value assigned on import, as we didn't reassign those. That's a bit misleading, I will update the answer.</span>
<span class="comment-copy">is there any way to make it accessible to the whole module, but not available to being called by module_name.__DBNAME__?</span>
<span class="comment-copy">Yes... you can put the global statement inside your function to make it "global" within the module (within that function... you'd have to repeat the global declaration in every function that uses this global). For example (forgive the code in comments): <code>def initDB(name):\n global __DBNAME__</code></span>
<span class="comment-copy">Thanks, Jarret. Unfortunately, when I try that, and run dir(mymodule) on the console, it shows the variables as available and I can access them. Am I misunderstanding you?</span>
<span class="comment-copy">Put the whole thing in a class. That way, at least someone who wants to access the private variable has to do some work.</span>
<span class="comment-copy">It's not enforceable daveslab. The idea in Python is that we're all adults and that private and protected variables are best accomplished by contract and convention that any strict compiler-enforced mechanism.</span>
<span class="comment-copy">This isn't true.  <code>global</code> allows you to set module level names.</span>
