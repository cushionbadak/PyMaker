<div class="post-text" itemprop="text">
<p>I'm trying to learn the super() function in Python.</p>
<p>I thought I had a grasp of it until I came over this example (2.6) and found myself stuck.</p>
<p><a href="https://web.archive.org/web/20170820065901/http://www.cafepy.com/article/python_attributes_and_methods/python_attributes_and_methods.html#super-with-classmethod-example" rel="noreferrer">http://www.cafepy.com/article/python_attributes_and_methods/python_attributes_and_methods.html#super-with-classmethod-example</a></p>
<pre><code>Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "test.py", line 9, in do_something
    do_something = classmethod(do_something)
TypeError: unbound method do_something() must be called with B instance as first argument (got nothing instead)
&gt;&gt;&gt;
</code></pre>
<p>It wasn't what I expected when I read this line right before the example:</p>
<blockquote>If we're using a class method, we don't have an instance to call super with. Fortunately for us, super works even with a type as the second argument. --- The type can be passed directly to super as shown below. </blockquote>
<p>Which is exactly what Python tells me is not possible by saying that do_something() should be called with an instance of B.</p>
</div>
<div class="post-text" itemprop="text">
<p>Sometimes texts have to be read more for the flavor of the idea rather than for the details. This is one of those cases.</p>
<p>In the <a href="http://www.cafepy.com/article/python_attributes_and_methods/python_attributes_and_methods.html#a-super-solution" rel="noreferrer">linked page</a>, Examples 2.5, 2.6 and 2.7 should all use one method, <code>do_your_stuff</code>. (That is, <code>do_something</code> should be changed to <code>do_your_stuff</code>.) </p>
<p>In addition, as <a href="https://stackoverflow.com/a/1817242/190597">Ned Deily pointed out</a>, <code>A.do_your_stuff</code> has to be a class method.</p>
<pre><code>class A(object):
    @classmethod
    def do_your_stuff(cls):
        print 'This is A'

class B(A):
    @classmethod
    def do_your_stuff(cls):
        super(B, cls).do_your_stuff()

B.do_your_stuff()
</code></pre>
<p><code>super(B, cls).do_your_stuff</code>
returns a <em>bound</em> method (see <a href="http://www.cafepy.com/article/python_attributes_and_methods/python_attributes_and_methods.html#a-super-solution" rel="noreferrer">footnote 2</a>).  Since  <code>cls</code> was passed as the second argument to <code>super()</code>, it is <code>cls</code> that gets bound to the returned method. In other words, <code>cls</code> gets passed as the first argument to the method <code>do_you_stuff()</code>.</p>
<p>So <code>super(B, cls).do_your_stuff()</code> causes <code>A</code>'s <code>do_your_stuff</code> method to be
called with <code>cls</code> passed as the first argument. In order for that to work, <code>A</code>'s
<code>do_your_stuff</code> has to be a class method. The linked page doesn't mention that,
but it's true.</p>
<p>PS. <code>do_something = classmethod(do_something)</code> is the old way of making a classmethod.
The new(er) way is to use the @classmethod decorator.</p>
<hr/>
<p>Note that <code>super(B, cls)</code> can not be replaced by <code>super(cls, cls)</code>. Doing so could lead to infinite loops. For example,</p>
<pre><code>class A(object):
    @classmethod
    def do_your_stuff(cls):
        print('This is A')

class B(A):
    @classmethod
    def do_your_stuff(cls):
        print('This is B')
        # super(B, cls).do_your_stuff()  # CORRECT
        super(cls, cls).do_your_stuff()  # WRONG

class C(B):
    @classmethod
    def do_your_stuff(cls):
        print('This is C')
        # super(C, cls).do_your_stuff()  # CORRECT
        super(cls, cls).do_your_stuff()  # WRONG

C.do_your_stuff()
</code></pre>
<p>will raise <code>RuntimeError: maximum recursion depth exceeded while calling a Python object</code>. </p>
<p>If <code>cls</code> is <code>C</code>, then <code>super(cls, cls)</code> searches <code>C.mro()</code> for the class that comes after <code>C</code>.</p>
<pre><code>In [161]: C.mro()
Out[161]: [__main__.C, __main__.B, __main__.A, object]
</code></pre>
<p>Since that class is <code>B</code>, when <code>cls</code> is <code>C</code>, <code>super(cls, cls).do_your_stuff()</code> <strong>always</strong> calls <code>B.do_your_stuff</code>. Since <code>super(cls, cls).do_your_stuff()</code> is called inside <code>B.do_your_stuff</code>, you end up calling <code>B.do_your_stuff</code> in an infinite loop.</p>
<p>In Python3, the <a href="https://docs.python.org/3/library/functions.html#super" rel="noreferrer">0-argument form of <code>super</code></a> was added so <code>super(B, cls)</code> could be replaced by <code>super()</code>, and Python3 will figure out from context that <code>super()</code> in the definition of <code>class B</code> should be equivalent to <code>super(B, cls)</code>.</p>
<p>But in no circumstance is <code>super(cls, cls)</code> (or for similar reasons, <code>super(type(self), self)</code>) ever correct.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3, you can skip specifying arguments for <code>super</code>,</p>
<pre><code>class A:
    @classmethod
    def f(cls):
        return "A's f was called."

class B(A):
    @classmethod
    def f(cls):
        return super().f()

assert B.f() == "A's f was called."
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I've updated the article to make it a bit clearer: <a href="http://www.cafepy.com/article/python_attributes_and_methods/python_attributes_and_methods.html#a-super-solution" rel="nofollow noreferrer">Python Attributes and Methods # Super</a></p>
<p>Your example using classmethod above shows what a class method is - it passes the class itself instead of the instance as the first parameter. But you don't even need an instance to call the method, for e.g.:</p>
<pre><code>&gt;&gt;&gt; class A(object):
...     @classmethod
...     def foo(cls):
...         print cls
... 
&gt;&gt;&gt; A.foo() # note this is called directly on the class
&lt;class '__main__.A'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The example from the web page seems to work as published.  Did you create a <code>do_something</code> method for the superclass as well but not make it into a classmethod?  Something like this will give you that error:</p>
<pre><code>&gt;&gt;&gt; class A(object):
...     def do_something(cls):
...         print cls
... #   do_something = classmethod(do_something)
... 
&gt;&gt;&gt; class B(A):
...     def do_something(cls):
...         super(B, cls).do_something()
...     do_something = classmethod(do_something)
... 
&gt;&gt;&gt; B().do_something()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 3, in do_something
TypeError: unbound method do_something() must be called with B instance as first argument (got nothing instead)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think I've understood the point now thanks to this beatiful site and lovely community.</p>
<p>If you don't mind please correct me if I'm wrong on classmethods (which I am now trying to understand fully):</p>
<pre><code>
# EXAMPLE #1
&gt;&gt;&gt; class A(object):
...     def foo(cls):
...             print cls
...     foo = classmethod(foo)
... 
&gt;&gt;&gt; a = A()
&gt;&gt;&gt; a.foo()
# THIS IS THE CLASS ITSELF (__class__)
class '__main__.A'

# EXAMPLE #2
# SAME AS ABOVE (With new @decorator)
&gt;&gt;&gt; class A(object):
...     @classmethod
...     def foo(cls):
...             print cls
... 
&gt;&gt;&gt; a = A()
&gt;&gt;&gt; a.foo()
class '__main__.A'

# EXAMPLE #3
&gt;&gt;&gt; class B(object):
...     def foo(self):
...             print self
... 
&gt;&gt;&gt; b = B()
&gt;&gt;&gt; b.foo()
# THIS IS THE INSTANCE WITH ADDRESS (self)
__main__.B object at 0xb747a8ec
&gt;&gt;&gt;
</code></pre>
<p>I hope this illustration shows ..</p>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/1269217/calling-a-base-classs-classmethod-in-python">Calling a base class's classmethod in Python</a></span>
<span class="comment-copy">Are there pitfalls in using super(cls, cls)?</span>
<span class="comment-copy">@GeorgeMoutsopoulos: <code>super(cls, cls)</code> is almost certainly a mistake. I've edited the post above to explain why.</span>
<span class="comment-copy">This answer could be moved to another question if this particular question is dealing with Python 2 specifically (it's hard to tell since the linked website, CafePy, is no longer available).</span>
<span class="comment-copy">It's not working for me in a project of mine.  It is giving <code>RuntimeError: super(): no arguments</code></span>
<span class="comment-copy">No, my A class looks like this:  class A(object):     def do_your_stuff(self):         print "this is A"  Is it necessary to have "class A" as you posted it? (with do_something = classmethod(do_something)) ?  I feel like the document didn't tell anything about this ..</span>
<span class="comment-copy">The whole point of the <code>super</code> call in the B do_something method is to call a method of that name in one of its superclasses.  If there isn't one in A (or in Object), the B().do_something() call fails with <code>super object has no attribute do_something</code>.  ~unutbu rightly points out that the example in the document is faulty.</span>
<span class="comment-copy">For an explanation of classmethods, perhaps you'll find this helpful: <a href="http://stackoverflow.com/questions/1669445/what-is-the-difference-between-a-static-method-and-class-method-in-python/1669524#1669524" title="what is the difference between a static method and class method in python">stackoverflow.com/questions/1669445/â€¦</a></span>
