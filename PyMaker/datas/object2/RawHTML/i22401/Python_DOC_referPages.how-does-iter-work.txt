<div class="post-text" itemprop="text">
<p>Despite reading up on it, I still dont quite understand how <code>__iter__</code> works.  What would be a simple explaination?  </p>
<p>I've seen <code>def__iter__(self): return self</code>. I don't see how this works or the steps on how this works.  </p>
</div>
<div class="post-text" itemprop="text">
<p>An iterator needs to define two methods: <code>__iter__()</code> and <code>__next__()</code> (<code>next()</code> in python2). Usually, the object itself defines the <code>__next__()</code> or <code>next()</code> method, so it just returns itself as the iterator. This creates an <em>iterable</em> that is also itself an <em>iterator</em>. These methods are used by <code>for</code> and <code>in</code> statements.</p>
<ul>
<li><p>Python 3 docs: <a href="https://docs.python.org/3/library/stdtypes.html#iterator-types" rel="nofollow noreferrer">docs.python.org/3/library/stdtypes.html#iterator-types</a></p></li>
<li><p>Python 2 docs: <a href="https://docs.python.org/2/library/stdtypes.html#iterator-types" rel="nofollow noreferrer">docs.python.org/2/library/stdtypes.html#iterator-types</a></p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>As simply as I can put it:</p>
<p><code>__iter__</code> defines a method on a class which will return an iterator (an object that successively yields the next item contained by your object).</p>
<p>The iterator object that <code>__iter__()</code> returns can be pretty much any object, as long as it defines a <code>next()</code> method.</p>
<p>The <code>next</code> method will be called by statements like <code>for ... in ...</code> to yield the next item, and <code>next()</code> should raise the <code>StopIteration</code> exception when there are no more items.</p>
<p>What's great about this is it lets <em>you</em> define how your object is iterated, and <code>__iter__</code> provides a common interface that every other python function knows how to work with.</p>
</div>
<div class="post-text" itemprop="text">
<p>The specs for <code>def __iter__(self):</code> are: it returns an iterator.  So, if <code>self</code> is an iterator, <code>return self</code> is clearly appropriate.</p>
<p>"Being an iterator" means "having a <code>__next__(self)</code> method" (in Python 3; in Python 2, the name of the method in question is unfortunately plain <code>next</code> instead, clearly a name design glitch for a special method).</p>
<p>In Python 2.6 and higher, the best way to implement an iterator is generally to use the appropriate abstract base class from the <code>collections</code> standard library <a href="http://docs.python.org/library/collections.html?highlight=collections" rel="nofollow noreferrer">module</a> -- in Python 2.6, the code might be (remember to call the method <code>__next__</code> instead in Python 3):</p>
<pre><code>import collections

class infinite23s(collections.Iterator):
  def next(self): return 23
</code></pre>
<p>an instance of this class will return infinitely many copies of <code>23</code> when iterated on (like <code>itertools.repeat(23)</code>) so the loop must be terminated otherwise. The point is that subclassing <code>collections.Iterator</code> adds the right <code>__iter__</code> method on your behalf -- not a big deal here, but a good general principle (avoid repetitive, boilerplate code like iterators' standard one-line <code>__iter__</code> -- in repetition, there's no added value and a lot of subtracted value!-).</p>
</div>
<div class="post-text" itemprop="text">
<p>A class supporting the __iter__ method will return an iterator object instance: an object supporting the <em>next()</em> method.  This object will be usuable in the statements "for" and "in".</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python, an iterator is any object that supports the iterator protocol. Part of that protocol is that the object must have an <code>__iter__()</code> method that returns the iterator object. I suppose this gives you some flexibility so that an object can pass on the iterator responsibilities to an internal class, or create some special object. In any case, the <code>__iter__()</code> method usually has only one line and that line is often simply <code>return self</code></p>
<p>The other part of the protocol is the <code>next()</code> method, and this is where the real work is done. This method has to figure out or create or get the next thing, and return it. It may need to keep track of where it is so that the next time it is called, it really does return the next thing.</p>
<p>Once you have an object that returns the next thing in a sequence, you can collapse a for loop that looks like this:</p>
<pre><code>myname = "Fredericus"
x = []
for i in [1,2,3,4,5,6,7,8,9,10]:
   x.append(myname[i-1])
   i = i + 1 # get the next i
print x
</code></pre>
<p>into this:</p>
<pre><code>myname = "Fredericus"
x = [myname[i] for i in range(10)]
print x
</code></pre>
<p>Notice that there is nowhere where we have code that gets the next value of i because range(10) is an object that FOLLOWS the iterator protocol, and the list comprehension is a construct that USES the iterator protocol.</p>
<p>You can also USE the iterator protocol directly. For instance, when writing scripts to process CSV files, I often write this:</p>
<pre><code>mydata = csv.reader(open('stuff.csv')
mydata.next()
for row in mydata:
    # do something with the row.
</code></pre>
<p>I am using the iterator directly by calling <code>next()</code> to skip the header row, then using it indirectly via the builtin <code>in</code> operator in the <code>for</code> statement.</p>
</div>
<span class="comment-copy">Which chapter of which book? That will help us narrow down the source of your confusion.</span>
<span class="comment-copy">learning python chapter 24 page 493 - 495</span>
<span class="comment-copy">If you look in the standard library documentation itertools module, you will find a number of functions that require the __iter__() method to operate.</span>
<span class="comment-copy">Became <code>__next__()</code> instead of <code>next()</code> in Python 3.</span>
<span class="comment-copy">This is confusing. Especially because you say something, then immediately say it's a lie. Lol, just update it to be correct</span>
<span class="comment-copy">In 2nd paragraph, SO formatting has changed <code>__next__</code> into bold 'next'. Worth fixing for clarity.</span>
<span class="comment-copy">@Craig, but it is supposed to be <code>next</code> not <code>__next__</code></span>
<span class="comment-copy">In Python 2, it is <code>next</code>, but in Python 3 it has been renamed to <code>__next__</code>, as Alex is aiming to say.</span>
<span class="comment-copy">@Craig, tx for the spotting, fixed.  @gnibbler, yep, it has a proper special-method name in Python 3 (unfortunately not in Python 2).</span>
