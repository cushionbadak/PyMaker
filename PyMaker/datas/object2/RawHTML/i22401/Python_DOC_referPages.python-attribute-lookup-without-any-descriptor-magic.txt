<div class="post-text" itemprop="text">
<p>I've started to use the python descriptor protocol more extensively in the code I've been writing.  Typically, the default python lookup magic is what I want to happen, but sometimes I'm finding I want to get the descriptor object itself instead the results of its <code>__get__</code> method. Wanting to know the type of the descriptor, or access state stored in the descriptor, or somesuch thing.</p>
<p>I wrote the code below to walk the namespaces in what I believe is the correct ordering, and return the attribute raw regardless of whether it is a descriptor or not. I'm surprised though that I can't find a built-in function or something in the standard library to do this -- I figure it has to be there and I just haven't noticed it or googled for the right search term.</p>
<p>Is there functionality somewhere in the python distribution that already does this (or something similar)?</p>
<p>Thanks!</p>
<pre><code>from inspect import isdatadescriptor

def namespaces(obj):
    obj_dict = None
    if hasattr(obj, '__dict__'):
        obj_dict = object.__getattribute__(obj, '__dict__')

    obj_class = type(obj)
    return obj_dict, [t.__dict__ for t in obj_class.__mro__]

def getattr_raw(obj, name):
    # get an attribute in the same resolution order one would normally,
    # but do not call __get__ on the attribute even if it has one
    obj_dict, class_dicts = namespaces(obj)

    # look for a data descriptor in class hierarchy; it takes priority over
    # the obj's dict if it exists
    for d in class_dicts:
        if name in d and isdatadescriptor(d[name]):
            return d[name]

    # look for the attribute in the object's dictionary
    if obj_dict and name in obj_dict:
        return obj_dict[name]

    # look for the attribute anywhere in the class hierarchy
    for d in class_dicts:
        if name in d:
            return d[name]

    raise AttributeError
</code></pre>
<p>Edit Wed, Oct 28, 2009.</p>
<p>Denis's answer gave me a convention to use in my descriptor classes to get the descriptor objects themselves. But, I had an entire class hierarchy of descriptor classes, and I didn't want to begin <em>every</em> <code>__get__</code> function with a boilerplate</p>
<pre><code>def __get__(self, instance, instance_type):
    if instance is None: 
        return self
    ...
</code></pre>
<p>To avoid this, I made the root of the descriptor class tree inherit from the following:</p>
<pre><code>def decorate_get(original_get):
    def decorated_get(self, instance, instance_type):
        if instance is None:
            return self
        return original_get(self, instance, instance_type)
    return decorated_get

class InstanceOnlyDescriptor(object):
    """All __get__ functions are automatically wrapped with a decorator which
    causes them to only be applied to instances. If __get__ is called on a 
    class, the decorator returns the descriptor itself, and the decorated
    __get__ is not called.
    """
    class __metaclass__(type):
        def __new__(cls, name, bases, attrs):
            if '__get__' in attrs:
                attrs['__get__'] = decorate_get(attrs['__get__'])
            return type.__new__(cls, name, bases, attrs)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Most descriptors do their job when accessed as instance attribute only. So it's convenient to return itself when it's accessed for class:</p>
<pre><code>class FixedValueProperty(object):
    def __init__(self, value):
        self.value = value
    def __get__(self, inst, cls):
        if inst is None:
            return self
        return self.value
</code></pre>
<p>This allows you to get descriptor itself:</p>
<pre><code>&gt;&gt;&gt; class C(object):
...     prop = FixedValueProperty('abc')
... 
&gt;&gt;&gt; o = C()
&gt;&gt;&gt; o.prop
'abc'
&gt;&gt;&gt; C.prop
&lt;__main__.FixedValueProperty object at 0xb7eb290c&gt;
&gt;&gt;&gt; C.prop.value
'abc'
&gt;&gt;&gt; type(o).prop.value
'abc'
</code></pre>
<p>Note, that this works for (most?) built-in descriptors too:</p>
<pre><code>&gt;&gt;&gt; class C(object):
...     @property
...     def prop(self):
...         return 'abc'
... 
&gt;&gt;&gt; C.prop
&lt;property object at 0xb7eb0b6c&gt;
&gt;&gt;&gt; C.prop.fget
&lt;function prop at 0xb7ea36f4&gt;
</code></pre>
<p>Accessing descriptor could be useful when you need to extent it in subclass, but there is a <a href="https://stackoverflow.com/questions/101268/hidden-features-of-python/1631763#1631763">better way</a> to do this.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>inspect</code> library provides a function to retrieve an attribute without any descriptor magic: <code>inspect.getattr_static</code>.</p>
<p>Documentation: <a href="https://docs.python.org/3/library/inspect.html#fetching-attributes-statically" rel="nofollow noreferrer">https://docs.python.org/3/library/inspect.html#fetching-attributes-statically</a></p>
<p>(This is an old question, but I keep coming across it when trying to remember how to do this, so I'm posting this answer so I can find it again!)</p>
</div>
<div class="post-text" itemprop="text">
<p>The above method </p>
<pre><code>class FixedValueProperty(object):
    def __init__(self, value):
        self.value = value
    def __get__(self, inst, cls):
        if inst is None:
            return self
        return self.value
</code></pre>
<p>Is a great method whenever you control the code of the property, but there are some cases, such as when the property is part of a library controlled by someone else, where another approach is useful.  This alternative approach can also be useful in other situations such as implementing object mapping, walking a name-space as described in the question, or other specialised libraries.</p>
<p>Consider a class with a simple property:</p>
<pre><code>class ClassWithProp:

    @property
    def value(self):
        return 3
&gt;&gt;&gt;test=ClassWithProp()
&gt;&gt;&gt;test.value
3
&gt;&gt;&gt;test.__class__.__dict__.['value']
&lt;property object at 0x00000216A39D0778&gt;
</code></pre>
<p>When accessed from the container objects class <strong>dict</strong>, the 'descriptor magic' is bypassed.  Note also that if we assign the property to a new class variable, it behaves just like the original with 'descriptor magic', but if assigned to an instance variable, the property behaves as any normal object and also bypasses 'descriptor magic'.</p>
<pre><code>&gt;&gt;&gt; test.__class__.classvar =  test.__class__.__dict__['value']
&gt;&gt;&gt; test.classvar
3
&gt;&gt;&gt; test.instvar = test.__class__.__dict__['value']
&gt;&gt;&gt; test.instvar
&lt;property object at 0x00000216A39D0778&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let's say we want to get the descriptor for <code>obj.prop</code> where <code>type(obj) is C</code>.</p>
<p><code>C.prop</code> usually works because the descriptor usually returns itself when accessed via <code>C</code> (i.e., bound to <code>C</code>). But <code>C.prop</code> may trigger a descriptor in its metaclass. If <code>prop</code> were not present in <code>obj</code>, <code>obj.prop</code> would raise <code>AttributeError</code> while <code>C.prop</code> might not. So it's better to use  <code>inspect.getattr_static(obj, 'prop')</code>.</p>
<p>If you are not satisfied with that, here's a CPython-specific method (from <code>_PyObject_GenericGetAttrWithDict</code> in <code>Objects/object.c</code>):</p>
<pre><code>import ctypes, _ctypes

_PyType_Lookup = ctypes.pythonapi._PyType_Lookup
_PyType_Lookup.argtypes = (ctypes.py_object, ctypes.py_object)
_PyType_Lookup.restype = ctypes.c_void_p

def type_lookup(ty, name):
    """look for a name through the MRO of a type."""
    if not isinstance(ty, type):
        raise TypeError('ty must be a type')

    result = _PyType_Lookup(ty, name)
    if result is None:
        raise AttributeError(name)

    return _ctypes.PyObj_FromPtr(result)
</code></pre>
<p><code>type_lookup(type(obj), 'prop')</code> returns the descriptor in the same way when CPython uses it at <code>obj.prop</code> if <code>obj</code> is a usual object (not class, for example).</p>
</div>
<span class="comment-copy">Sometimes you want the descriptor object?  That violates the core expectation for descriptors: they're supposed to look like attributes.  Why break that fundamental expectation?  Why do this?  Why create something so complex?</span>
<span class="comment-copy">What I'm doing doesn't feel <i>that</i> complex to me, but I guess you could say I'm experimenting with the design.   In my current, particular case, I have a descriptor that returns the strength of a weapon in a game. That value is a function of the descriptor's state (strength of the weapon) and the instance (health of the ship). There are different kinds of weapon; usually I just want the value result, but in a few cases, I need to know what kind of weapon it is -- the type of the descriptor.  And what if a descriptor has methods not part of the descriptor protocol, and you want to call them?</span>
<span class="comment-copy">Didn't realize that; good to know. Functions themselves would be an exception an exception to that pattern, but maybe the only one.  Will have to poke at the built-in descriptors.</span>
<span class="comment-copy">Though it didn't answer my question as asked exactly, your answer did help me solve my underlying problem. I'll accept it.</span>
<span class="comment-copy">are functions an exception to this pattern (I assume you speak about methods)? No, <code>c.method</code> returns a bound method from a description, while <code>C.method</code> return an unbound method. It's the same pattern.</span>
<span class="comment-copy">Functions don't follow this pattern exactly, but very similar: <code>function.__get__(None, cls)</code> returns unbound method, not itself.</span>
<span class="comment-copy"><code>staticmethod</code> and <code>classmethod</code> also break this.</span>
