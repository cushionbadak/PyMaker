<div class="post-text" itemprop="text">
<pre><code>s = "[ab[cd]]fg[hi]"
</code></pre>
<p>I want to get the substring <code>[ab[cd]]</code>
The problem really is that there can be any number of open and closed brackets. For reference <a href="https://leetcode.com/problems/decode-string/" rel="nofollow noreferrer">this</a> is the problem I am trying to solve. </p>
<p>if I use <code>re.search("\[(.*)\]", s)</code>, it matches the last <code>]</code></p>
<p>If I use <code>re.search("\[(.*?)\]", s)</code>, it stops at the first <code>]</code></p>
<p>I want the regex to match <code>[ab[cd]]</code> for string <code>[ab[cd]]fg[hi]</code> and match <code>[ab[cd[ef]]]</code> for string <code>[ab[cd[ef]]]f[hi]</code></p>
<p>Any ideas?</p>
<p>Thanks </p>
</div>
<div class="post-text" itemprop="text">
<p>Unless you know in advance a limit to the possible amount of bracket nesting, it's not possible with the <code>re</code> module - but, the <code>regex</code> module can do it via recursion:</p>
<pre><code>\[(?:[a-z]|(?R))*\]
</code></pre>
<p><a href="https://regex101.com/r/Al0jny/1" rel="nofollow noreferrer">https://regex101.com/r/Al0jny/1</a></p>
<p>With <code>re</code>, you'd have to manually try to match the possible nesting levels, eg:</p>
<pre><code>\[(?:[a-z]|\[[a-z]*\])*\]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think it depends on the input. But, based on the input on your referenced links, maybe it can help.</p>
<pre><code>(\d+)|(\[[a-z]\])|(\[[a-z]+\])|([a-z]+)
</code></pre>
<p><a href="https://regex101.com/r/RRTLIU/1" rel="nofollow noreferrer">https://regex101.com/r/RRTLIU/1</a></p>
<p>Or if you want to ignore the square brackets, you can use this <code>regex</code>:</p>
<pre><code>(\d+)|\[([a-z])\]|\[([a-z]+)\]|([a-z]+)
</code></pre>
</div>
<span class="comment-copy">How about <code>\[\w+\[\w+\]\]</code>?</span>
<span class="comment-copy">I don't know how many nested open and close brackets it may contain.</span>
<span class="comment-copy">So, what's the differentiating factor between picking <code>[ab[cd]]</code> and <code>fg[hi]</code> or <code>[ab[cd]]fg[hi]</code> for that matter?</span>
<span class="comment-copy">As I walk through the string, if I encounter a '[', then I need to find its matching '] and do some processing. This is for a programming question: <a href="https://leetcode.com/problems/decode-string/" rel="nofollow noreferrer">leetcode.com/problems/decode-string</a></span>
<span class="comment-copy">My suggestion is to separate the search for the multipliers and the corresponding "strings" and then replace the occurrences using recursion. I coded a working example and it seems to work.</span>
<span class="comment-copy">This will work. Let me give this a try. Thanks!</span>
