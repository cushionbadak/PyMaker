<div class="post-text" itemprop="text">
<p>I am using Python's mock library along with unittest. I am writing unit tests for a class that uses a function of an external library in one of its methods. Depending on the case, this function returns different values.</p>
<p>So let's say I wanna test class A:</p>
<pre><code>from external_library import function_foo

class A(object):
...
</code></pre>
<p>In my test class, in order to use the values returned by the function from the external library, I create a patch, and only import class A after defining the patch. However, I need to use this function in all my test methods, and in each method it returns different values.</p>
<p>My test class is as follows:</p>
<pre><code>class TestA(TestCase):

    @patch('external_library.function_foo', side_effect=[1, 2, 3])    
    def test_1(self, *patches):

       from module import class A
       obj = A()
       ...

    @patch('external_library.function_foo', side_effect=[1, 1, 2, 2, 3, 3])    
    def test_2(self, *patches):

       from module import class A
       obj = A()
       ...

    ...
</code></pre>
<p>I have 10 tests and only 1 (the first one) passes when I run all of them together, for the rest, I get <code>StopIteration</code> error. However, <strong>if I run each one of them individually, they all pass</strong>.</p>
<p>I have tried using <code>with patch('external_library.function_foo', side_effect=[...])</code> in each method, but the outcome was the same. I also tried creating only once the patch in the <code>setUp</code> method, starting it, reassigning the side_effect within each method, and stopping in <code>tearDown</code>, but it didn't work.</p>
<p>Any ideas on what might work in this case?</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>The caveat is, the second time you import a module, <a href="https://docs.python.org/3/reference/import.html#the-module-cache" rel="nofollow noreferrer">it would not be loaded again</a>, you get the same module object as the first time you imported.</p>
<p>When you first run "test_1", <code>external_library.function_foo</code> replaced by a <code>Mock</code> object, let's name it <code>mock_a</code>. Then your "module" get imported for the first time, python will load it, means, execute code inside "module", which will bind name "function_foo" to object "mock_a" in the namespace of "module", save "module" object to <code>sys.modules</code>. This time your test will pass, and <code>side_effect</code> of <code>mock_a</code> get consumed.</p>
<p>Next is "test_2", <code>external_library.function_foo</code> replaced by a <code>Mock</code> object, name it to <code>mock_b</code>. Then import "module", this time it would not be loaded again, but populate from <code>sys.modules</code>, you get the same module object as in "test_1". In the namespace of this module object, name "function_foo" is still bound to object <code>mock_a</code>, not the newly created <code>mock_b</code>. Because <code>side_effect</code> of <code>mock_a</code> has already consumed, <code>StopIteration</code> error raised.</p>
<p>You should apply patch to where a <em>name</em> is looked up, but not where it is defined:  </p>
<pre><code>@patch('module.function_foo', side_effect=[1, 2, 3])    
def test_1(self, patch):
    ...
</code></pre>
<p>Read more detail on the <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="nofollow noreferrer">"Where to patch" section of the manual of <code>patch</code></a>.</p>
</div>
<span class="comment-copy">Thank you for your answer and for the great explanation @georgexsh, I got it working by replacing the <code>external_library.function_foo</code> by <code>package.module.function_foo</code></span>
