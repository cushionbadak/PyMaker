<div class="post-text" itemprop="text">
<p>I think my question is very easy and stupid, but I read a lot of materials and can't imagine how to do what I want.</p>
<p>So, I use <code>websockets</code> library, and I have this algorythm:</p>
<pre><code># 1. get connection and start handle it
async def main_request_handler(ws, path):
    proxy = Proxy()
    try:
        await proxy.start(ws, path)
</code></pre>
<p>2. inside start I create second websocket to pass requests from <code>ws</code> and receive answers to send them to <code>ws</code></p>
<pre><code>while True:
    request_raw = await self.ws_server.recv()
    await self.process_request_from_server(request_raw)
</code></pre>
<p>The problem is, I need to use one websocket server connection for multiply 
<code>ws</code> clients, and I need to pass to everyone the same answer from <code>ws_server</code>. Now I get only one response, due to .recv() returns value only for one of the 'subscribers'.
How to fix this? Please note, that I use <code>while True</code> and <code>async</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a very simplistic example for a pub/sub websockets server</p>
<pre><code>import asyncio
import websockets

connections = set()
n = 0


async def handler(websocket, path):
    global n

    if path == "/sub":
        n = n + 1
        i = n
        connections.add(websocket)
        print("adding subscriber #", i)
        try:
            async for msg in websocket:
                pass  # ignore
        except websockets.ConnectionClosed:
            pass
        finally:
            print("removing subscriber #", i)
            connections.remove(websocket)

    elif path == "/pub":
        async for msg in websocket:
            print("&lt;", msg)
            for ws in connections:
                asyncio.ensure_future(ws.send(msg))


start_server = websockets.serve(handler, 'localhost', 8765)

asyncio.get_event_loop().run_until_complete(start_server)
asyncio.get_event_loop().run_forever()
</code></pre>
<p>And an example subscriber client (run a few of those):</p>
<pre><code>import asyncio
import websockets


async def listen():
    async with websockets.connect('ws://localhost:8765/sub') as websocket:
        while True:
            greeting = await websocket.recv()
            print("&lt; {}".format(greeting))


asyncio.get_event_loop().run_until_complete(listen())
</code></pre>
<p>and a publisher:</p>
<pre><code>import asyncio
import websockets


async def say():
    async with websockets.connect('ws://localhost:8765/pub') as websocket:
        while True:
            msg = input("Enter message:")
            if not msg:
                break
            await websocket.send(msg)


asyncio.get_event_loop().run_until_complete(say())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>In other words, I need to run <code>.recv</code> in the same loop and thread with multiple consumers. In RxPy I could just <code>stream.emit(recv_result)</code> and consume items like <code>thatstrem.subscribe(callback_fn)</code>, but this is callback way, I need async</p>
</blockquote>
<p>Your <code>subscribe</code> method can accept coroutine functions, i.e. functions created with <code>async def</code>. Once something is emitted, they can be instantiated and their coroutines spawned using <code>create_task</code>:</p>
<pre><code>def __init__(self, ...):
    self._subscribers = []

def subsribe(self, corofn):
    self._subscribers.append(corofn)

def emit(self, obj):
    loop = asyncio.get_event_loop()
    for corofn in self._subscribers:
        coro = corofn(obj)
        loop.create_task(coro)

async def main(self):
    while True:
        request_raw = await self.ws_server.recv()
        self.emit(request_raw)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm not sure I understood correctly, but isn't <a href="https://docs.python.org/3/library/asyncio-task.html#example-parallel-execution-of-tasks" rel="nofollow noreferrer">gathering</a> multiple coroutines is what you want?</p>
<pre><code>while True:
    request_raw = await self.ws_server.recv()

    # process by multiple clients parallely:
    await asyncio.gather(
        self.process_by_client_1(request_raw),
        self.process_by_client_2(request_raw),
        self.process_by_client_3(request_raw),
    )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Thanks for suggestions, they might work. I made it through queues.</p>
<pre><code>class SWebsocket(object):

    def __init__(self, websocket: WebSocketServerProtocol):
        self.ws = websocket
        self.queues = {}
        self.subscribe()

    def subscribe(self):
        # fire and forget function
        asyncio.ensure_future(self.recv_mess())

    async def recv_mess(self):
        while True:
            try:
                data = await self.ws.recv()
            except websockets.ConnectionClosed as e:
                for _, q in self.queues.items():
                    await q.put(e)
                return
            for _, q in self.queues.items():
                await q.put(data)

    async def recv(self, id):
        # read value from queue
        if id not in self.queues:
            self.queues[id] = asyncio.Queue()
        data = await self.queues[id].get()
        if isinstance(data, websockets.ConnectionClosed):
            raise data
        return data
</code></pre>
</div>
<span class="comment-copy">Can you post a <code>minimal example</code>? So I can try your code?</span>
<span class="comment-copy">It will be a quite big example</span>
<span class="comment-copy">You will probably have to abstract the problem to the specific part you are struggling with. If it's extremely domain specific, others won't be able to comprehend the intention of the code. It can be a challenge...</span>
<span class="comment-copy">Yes, I want something like that, but I need to add <code>process_by_client_</code> dynamically. (like add callback, but I need to run it with <code>await</code> keyword.</span>
<span class="comment-copy">In other words, I need to run <code>.recv</code> in the same loop and thread with multiple consumers. In RxPy I could just <code>stream.emit(recv_result)</code> and consume items like that<code>strem.subscribe(callback_fn)</code>,  but this is callback way, I need async</span>
