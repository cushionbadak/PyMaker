<div class="post-text" itemprop="text">
<p>Consider this snippet:</p>
<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; a = {1:'1'}
&gt;&gt;&gt; json_a = json.dumps(a)
&gt;&gt;&gt; json.loads(json_a)
{'1': '1'}
</code></pre>
<p>My attempt was to pass a  Python dict to <code>json.dumps()</code>, and then use <code>json.loads()</code> to get it back. But that doesn't happen, probably because JSON alays considers keys as strings. </p>
<p>Is there any other way I can retain the original key types? </p>
</div>
<div class="post-text" itemprop="text">
<p>The conversion of integer keys in Python dicts to JSON-compliant string keys by <code>json.dumps()</code> is <em>lossy</em>: once done, there's no way to tell whether the original key was the integer <code>23</code> or the string <code>'23'</code> (unless that information is stored elsewhere).</p>
<p>That said, you <strong>can</strong> force <code>json.loads()</code> to convert keys into integers wherever possible, by passing an appropriate function as an <a href="https://docs.python.org/3/library/json.html#json.load" rel="nofollow noreferrer"><code>object_pairs_hook</code></a> argument:</p>
<pre><code> def int_keys(ordered_pairs):
    result = {}
    for key, value in ordered_pairs:
        try:
            key = int(key)
        except ValueError:
            pass
        result[key] = value
    return result
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; data = {1: '1', 2: '2', 3: '3'}
&gt;&gt;&gt; text = json.dumps(data)
&gt;&gt;&gt; text
'{"1": "1", "2": "2", "3": "3"}'
&gt;&gt;&gt; json.loads(text, object_pairs_hook=int_keys)
{1: '1', 2: '2', 3: '3'}
</code></pre>
<p>Expanding on this, it's also possible to write an <code>object_pairs_hook</code> which converts not only integers, but all the other non-string keys which <code>json.dumps()</code> might have converted to strings:</p>
<pre><code>SPECIAL = {
    "true": True,
    "false": False,
    "null": None,
}

def round_trip(ordered_pairs):
    result = {}
    for key, value in ordered_pairs:
        if key in SPECIAL:
            key = SPECIAL[key]
        else:
            for numeric in int, float:
                try:
                    key = numeric(key)
                except ValueError:
                    continue
                else:
                    break
        result[key] = value
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; print(more_text)
{
  "2": 2,
  "3.45": 3.45,
  "true": true,
  "false": false,
  "null": null,
  "Infinity": Infinity,
  "-Infinity": -Infinity,
  "NaN": NaN
}
&gt;&gt;&gt; json.loads(more_text, object_pairs_hook=round_trip)
{2: 2, 3.45: 3.45, True: True, False: False, None: None, inf: inf, -inf: -inf, nan: nan}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>We can use <code>str(value)</code> in place of <code>json.dumps(value)</code>, and <code>ast.literal_eval()</code> in place of <code>json.loads()</code></p>
<pre><code>&gt;&gt;&gt; a = {1: "1"}
&gt;&gt;&gt; a_as_string = str(a)
&gt;&gt;&gt; import ast 
&gt;&gt;&gt; ast.literal_eval(a_as_string)
{1: '1'}
</code></pre>
<p>Just posted as an initial solution, expecting a more sophisticated one.</p>
</div>
<span class="comment-copy">json considers keys as string always. Yes it does : <a href="https://json.org/object.gif" rel="nofollow noreferrer">json.org/object.gif</a></span>
<span class="comment-copy">Thanks for the answer. Loved the idea. But, this answer actually tries to convert the keys into a specific type wherever possible. I mean <code>{"1": 1}</code> always gets converted to <code>{1: 1}</code> , but we have no idea if the main key type was integer or string, we are just trying to convert them blindly. Isn't it? But, my target was to get back the exact key type before passing it to <code>json.dumps</code>.</span>
<span class="comment-copy">For example, consider this: <code>{1: 1}, {"2": 2}</code>. It will be evaluated as <code>{1: 1}, {2: 2}</code> according to this answer. But, the target was to get back the original <code>{1: 1}, {"2": 2}</code>. I hope it's clear now.</span>
<span class="comment-copy">@AhsanulHaque as mentioned at the top of my answer, that's impossible (because the conversion performed by <code>json.dumps()</code> simply discards that type information), unless you either a) store the type information somewhere else, or b) emit something that isn't actually JSON (as in your self-answer).</span>
<span class="comment-copy">@AhsanulHaque it's clear, yes. It's also impossible, though ;-) My answer is intended as a "best you can manage" workaround.</span>
<span class="comment-copy">This serialization format isn't compliant JSON.</span>
<span class="comment-copy">Yes, of course,  <code>a_as_string</code> is not a valid JSON.</span>
<span class="comment-copy">...which leaves me wondering if this is actually an answer to the question (which was whether you could make integer keys survive a round-trip through JSON). Using something other than JSON is certainly a way to <i>avoid having</i> the question, but that's not necessarily the same thing as an answer.</span>
