<div class="post-text" itemprop="text">
<p>I have a PyQt GUI which I use to start long-running computations in Python. Here's a minimal example:</p>
<pre><code>import sys
import time
from PyQt5.QtWidgets import (QApplication, QMainWindow, QLabel, QDialog,
                             QVBoxLayout, QPushButton, QDialogButtonBox)

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        button = QPushButton("Start", self)
        button.clicked.connect(self.long_task)
        self.setGeometry(300, 300, 300, 200)
        self.show()

    def long_task(self):
        dialog = QDialog(self)
        vbox = QVBoxLayout(dialog)
        label = QLabel("Running...")
        button = QDialogButtonBox(QDialogButtonBox.Cancel)
        vbox.addWidget(label)
        vbox.addWidget(button)
        dialog.open()
        time.sleep(10)  # long task, external function
        dialog.close()

app = QApplication(sys.argv)
main = MainWindow()
app.exec_()
</code></pre>
<p>From the main window, I can start a task by clicking the button. Then a modal dialog pops up and the task starts. It is okay if the GUI is blocked (I know I can prevent freezing the GUI thread by putting the task in a separate worker thread, but this is not the point). Critically, I want to be able to hit the "Cancel" button to terminate the task. Alternatively, since the long-running tasks are always Python commands, I could also live with terminating the task with Ctrl+C. </p>
<p>I cannot change the long-running Python command: i.e. I can't break it up into tiny pieces and use a state variable in combination with threading, as is sometimes suggested. The alternative (pressing Ctrl+C) also doesn't work since PyQt doesn't seem to register it (even though the Python interpreter should while it is running the task).</p>
</div>
<div class="post-text" itemprop="text">
<p>The simplest way to do this is to use <a href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing" rel="nofollow noreferrer">multiprocessing</a>. This will allow you to run a task (or group of tasks) concurrently and terminate processing at any time. However, make sure you read the <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing-programming" rel="nofollow noreferrer">programming guidelines</a> to understand how to use the module effectively. In particular, although the <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Process.terminate" rel="nofollow noreferrer">terminate</a> method works fine for self-contained tasks, it should not be used with multiple tasks that use shared resources.</p>
<p>Here is a simple demo based on your example:</p>
<pre><code>import sys
import time
from PyQt5.QtWidgets import (QApplication, QMainWindow, QLabel, QDialog,
                             QVBoxLayout, QPushButton, QDialogButtonBox)

from multiprocessing import Pool

def long_task():
    for x in range(10):
        print('long task:', x)
        time.sleep(1)
    return 'finished'

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        button = QPushButton("Start", self)
        button.clicked.connect(self.long_task)
        self.setGeometry(300, 300, 300, 200)
        self.show()

    def long_task(self):
        dialog = QDialog(self)
        vbox = QVBoxLayout(dialog)
        label = QLabel("Running...")
        button = QDialogButtonBox(QDialogButtonBox.Cancel)
        button.rejected.connect(dialog.close)
        vbox.addWidget(label)
        vbox.addWidget(button)
        def callback(msg):
            print(msg)
            dialog.accept()
        pool.apply_async(long_task, callback=callback)
        if dialog.exec_() == QDialog.Rejected:
            pool.terminate()
            print('terminated')

app = QApplication(sys.argv)
main = MainWindow()
app.exec_()
</code></pre>
</div>
<span class="comment-copy">You can not be helped if you do not indicate how heavy the task is, one possible option is to execute that task in another thread</span>
<span class="comment-copy">What do you mean by heavy? I used <code>time.sleep(10)</code> in my example, in reality it is some Python command that performs calculations that usually take much longer. That's why I want the option to cancel this job. I don't want to do anything else in the GUI except for being able to cancel the task.</span>
<span class="comment-copy">I mean if you can run without locking the GUI and stop time.sleep(10) your problem is solved, are you sure? I have seen similar problems, I have solved similar problems, but when they wanted to implement the problem it was totally different</span>
<span class="comment-copy">Yes, exactly - I want the GUI to remain responsive (e.g. no spinning ball on a Mac), but the dialog window should be modal - so the only possible user interaction is either wait until <code>time.sleep(10)</code> has finished or cancel <code>time.sleep(10)</code>.</span>
<span class="comment-copy">Thanks, this is great! Do you know if memory usage could be a problem with this approach? That is, what if my long task works on a large objects that occupies 2GB RAM - will this object be copied to the new process?</span>
<span class="comment-copy">@cbrnr. Multiprocessing just looks for the module where the function is defined, imports that module, and then runs the code in a separate process. It should be no different than explicitly running the code as a separate script. Copying is only a problem if you pass large amounts of data as arguments in the initial call, or attempt to pass data from one process to another. Having said all that, I am no expert on the inner workings of multiprocessing, so you should just try it and see what actually happens.</span>
<span class="comment-copy">After some testing I noticed that the dialog disappears only if the Cancel button is clicked (or the dialog is closed), at which point the running process is terminated. However, if the job finishes, the dialog stays visible (because its event loop is still running). How can this dialog be closed automatically once the job has finished?</span>
<span class="comment-copy">@cbrnr. I thought I made that obvious by showing how to add a simple callback. Anyway, I have altered my code example to make it explicit. (PS: please remember to re-accept my answer).</span>
<span class="comment-copy">Not obvious enough for me :-) - anyway, now this is perfect! Thanks!</span>
