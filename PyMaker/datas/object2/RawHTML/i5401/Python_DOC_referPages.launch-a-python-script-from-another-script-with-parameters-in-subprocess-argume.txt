<div class="post-text" itemprop="text">
<p>To launch a python script (it is needed for running an OLED display) from terminal, I have to use the following bash commands: <code>python demo_oled_v01.py --display ssd1351 --width 128 --height 128 --interface spi --gpio-data-command 20</code>. Those parameters after <code>.py</code> are important, otherwise, the script will run with default settings and in my case, the script will not launch with default settings. Thus, those parameters are needed.</p>
<p>The problem arises when I need to launch my script from another python script, (instead of using bash commands on terminal). To launch one of my python script from a parent script. I have used:</p>
<pre><code>import subprocess # to use subprocess 

p = subprocess.Popen(['python', 'demo_oled_v01.py --display ssd1351 --width 128 --height 128 --interface spi --gpio-data-command 20'])
</code></pre>
<p>in my parent script but I got an error stating:</p>
<p><code>python: can't open file 'demo_oled_v01.py --display ssd1351 --width 128 --height 128 --interface spi --gpio-data-command 20': [Errno 2] No such file or directory</code></p>
<p>I suspect that adding the parameters  <code>--display ssd1351 --width 128 --height 128 --interface spi --gpio-data-command 20</code> after <code>.py</code> may be causing difficulty in launching the script. As mentioned, these parameters are otherwise essential for me to include for launching with bash commands on terminal. How can I use subprocess with the required parameters to launch this script?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>subprocess</code> library is interpreting all of your arguments, including <code>demo_oled_v01.py</code> as a single argument to python. That's why python is complaining that it cannot locate a file with that name. Try running it as:</p>
<pre class="lang-py prettyprint-override"><code>p = subprocess.Popen(['python', 'demo_oled_v01.py', '--display',
'ssd1351', '--width', '128', '--height', '128', '--interface', 'spi',
'--gpio-data-command', '20'])
</code></pre>
<p>See more information on Popen <a href="https://docs.python.org/2/library/subprocess.html#popen-constructor" rel="nofollow noreferrer">here</a>. </p>
</div>
<div class="post-text" itemprop="text">
<p>Add full path to the python script &amp; separate all parameter</p>
<p>EX:</p>
<pre><code>import subprocess
p = subprocess.Popen(['python', 'FULL_PATH_TO_FILE/demo_oled_v01.py',  '--display',  'ssd1351', '--width', '128', '--height', '128', '--interface', 'spi', '--gpio-data-command', '20'])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This started as a comment thread, but got too long and complex.</p>
<p>Calling Python as a subprocess of Python is an antipattern. You can often fruitfully avoid this by refactoring your Python code so that your program can call the other program as a simple library (or module, or package, or what have you -- there is a bit of <a href="https://docs.python.org/3/tutorial/modules.html" rel="nofollow noreferrer">terminology</a> here which you'll want to understand more properly ... eventually).</p>
<p>Having said that, there <em>are</em> scenarios where the subprocess <em>needs</em> to be a subprocess (perhaps it is designed to do its own signal handling, for example) so don't apply this blindly.</p>
<p>If you have a script like <code>demo.py</code> which contains something like</p>
<pre><code>def really_demo(something, other, message='No message'):
    # .... some functionality here ...

def main():
    import argparse
    parser = argparse.ArgumentParser(description='Basic boilerplate, ignore the details.')
    parser.add_argument('--something', dest='something')  # store argument in args.something
    parser.add_argument('--other', dest='other')  # ends up in args.other
    # ... etc etc etc more options
    args = parser.parse_args()
    # This is the beef: once the arguments are parsed, pass them on
    really_demo(args.something, args.other, message=args.message)

if __name__ == '__main__':
    main()
</code></pre>
<p>Observe how when you run the script from the command line, <code>__name__</code> will be <code>'__main__'</code> and so it will plunge into the <code>main()</code> function which picks apart the command line, then calls some other function -- in this case, <code>real_demo()</code>.  Now, if you are calling this code from an already running Python, there is no need really to collect the arguments into a list and pass them to a new process. Just have your Python script load the function you want to call from the script, and call it with your arguments.</p>
<p>In other words, if you are currently doing</p>
<pre><code> subprocess.call(['demo.py', '--something', 'foo', '--other', value, '--message', 'whatever'])
</code></pre>
<p>you can replace the subprocess call with</p>
<pre><code> from demo import real_demo
 real_demo('foo', value, message='whatever')
</code></pre>
<p>Notice how you are bypassing the <code>main()</code> function and all the ugly command-line parsing, and simply calling another Python function. (Pay attention to the order and names of the arguments; they may be quite different from what the command-line parser accepts.)  The fact that it is defined in a different file is a minor detail which <code>import</code> handles for you, and the fact that the file contains other functions is something you can ignore (or perhaps exploit more fully if, for example, you want to access internal functions which are not exposed via the command-line interface in a way which is convenient for you).</p>
<p>As an optimization, Python won't <code>import</code> something twice, so you really need to make sure the functionality you need is not run when you <code>import</code> it. Commonly, you <code>import</code> once, at the beginning of your script (though technically you can do it inside the <code>def</code> which needs it, for example, if there is only one place in your code which depends on the <code>import</code>) and then you call the functions you got from the <code>import</code> as many or as few times as you need them.</p>
<p>This is a lightning recap of a very common question. If this doesn't get you started in the right direction, you should be able to find many existing questions on Stack Overflow about various aspects of this refactoring task.</p>
</div>
<span class="comment-copy">Running Python from Python is a weird antipattern. See if <code>demo_oled_v01.py</code> could be refactored to a module you can load into your main Python script (or perhaps already has this facility).</span>
<span class="comment-copy">@tripleeee: Thanks for your advice. The reason that I use subprocess instead of say, import, is that I found from experience, that closing the secondary script from the parent script to be more reliable via the subprocess method. However, I am quite new to all these so I might be wrong. How do you reckon I should go about implementing this, if subprocess is not ideal in this case?</span>
<span class="comment-copy">A common design is to have a simple <code>def main()</code> and call that <code>if __name__ == '__main__'</code> but if you <code>import</code> the library, <code>__name__</code> is something else and then you get to use the methods you <code>import</code> in the way you see fit from the calling script.  The design of <code>main()</code> should be such that it only calls other methods and handles the simple case of calling directly from the command line, and the internal functions it calls should be modular enough that you can call them in a different order or with other parameters from a script which does an <code>import</code>.</span>
<span class="comment-copy">That is probably too condensed to really help, but google for <code>python __name__ __main__</code> to see this in practice.</span>
<span class="comment-copy">@tripleee: If I were to use <code>import</code> to launch this script. How do I include those parameters as well? i.e. <code>--display ssd1351 --width 128 --height 128 --interface spi --gpio-data-command 20</code> My understanding to launch a typical python script (e.g. script1.py) would be to use: <code>import script1</code> without including <code>.py</code>.</span>
<span class="comment-copy">Thanks for the detailed explanation. I understand the import function better now though as I'm still learning, I've still need to read more about this. I've recently tried to implement this into my script with much success. There is however a limitation that I seem to encounter. That is when I need to de-import a module.</span>
<span class="comment-copy">In one of my script, I had a while loop with increment and decrement function in it, each time the increment increases by 1, it imports a python script which changed my display on a LED screen. However, when I trigger a decrement, nothing seems to happen (as if the script has already been imported by the increment I made previously, and cannot be re-imported/reloaded).</span>
<span class="comment-copy">Yeah, the <code>import</code> part can only happen once, but the function you run should run when you call it, not when you <code>import</code>. You might need to change the script you want to <code>import</code> to support this properly. That's exactly what I mean by making sure the stuff you want to call is in a <code>def</code> so you can call that function whenever you need it, and it doesn't run unless you specifically call it.</span>
<span class="comment-copy">Thanks for the clarification. The reason why I imported the script and not the specific function is that I found that one function of that script to be dependent on the main function. If I import a particular function from that script alone, terminal tells me that something is not defined.</span>
<span class="comment-copy">In this script, after the imports are written down, it starts off with: <code>def primitives(device, draw):     # First define some constants to allow easy resizing of shapes.     padding = 2     shape_width = 20     top = padding     bottom = device.height - padding - 1     # Move left to right keeping track of the current x position for drawing shapes.     x = padding      # Write text.     size = draw.textsize('World!')     x = device.width - padding - size[0]     draw.text((device.width - padding - size[0], top + 4), 'Hello', fill="cyan") fill="purple")</code></span>
