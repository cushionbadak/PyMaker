<div class="post-text" itemprop="text">
<p>I have an "unstructured" list that looks like this:</p>
<pre><code>info = [
    'Joe Schmoe',
    'W / M / 64',
    'Richard Johnson',
    'OFFICER',
    'W / M /48',
    'Adrian Stevens',
    '? / ? / 27'
    ]
</code></pre>
<p><em>Unstructured</em> in that the list consists of sets of:</p>
<ul>
<li>(<em>Name, Officer Status, Demographic Info</em>) triplets, or</li>
<li>(<em>Name, Demographic Info</em>) pairs.  </li>
</ul>
<p>In the latter case, <code>Officer=False</code> and in the former, <code>Officer=True</code>.  The Demographic Info strings represent <code>Race / Gender / Age</code>, with <code>NaN</code>s represented by literal question marks.  Here is where I'd like to get to:</p>
<pre><code>res = {
    'Joe Schmoe': {
        'race': 'W',
        'gender': 'M',
        'age': 64,
        'officer': False
        },
    'Richard Johnson': {
        'race': 'W',
        'gender': 'M',
        'age': 48,
        'officer': True
        },
    'Adrian Stevens': {
        'race': 'NaN',
        'gender': 'NaN',
        'age': 27,
        'officer': False
        }
    }
</code></pre>
<p>Right now I've built two functions to do this.  The first is below and handles the Demographic Info strings.  (I'm fine with this one; just putting it here for reference.)</p>
<pre><code>import re

def fix_demographic(info):
    # W / M / ?? --&gt; W / M / NaN
    # ?/M/?  --&gt; NaN / M / NaN
    # Keep as str NaN rather than np.nan for now
    race, gender, age = re.split('\s*/\s*', re.sub('\?+', 'NaN', info))
    return race, gender, age
</code></pre>
<p>The second function deconstructs the list and throws its values into different places in a dictionary result:</p>
<pre><code>demographic = re.compile(r'(\w+|\?+)\s*\/\s*(\w+|\?+)\s*\/\s*(\w+|\?+)')


def parse_victim_info(info: list):
    res = defaultdict(dict)
    for i in info:
        if not demographic.fullmatch(i) and i.lower() != 'officer':
            # We have a name
            previous = 'name'
            name = i
        if i.lower() == 'officer':
            res[name]['officer'] = True
            previous = 'officer'
        if demographic.fullmatch(i):
            # We have demographic info; did "OFFICER" come before it?
            if previous == 'name':
                res[name]['officer'] = False
            race, gender, age = fix_demographic(i)
            res[name]['race'] = race
            res[name]['gender'] = gender
            res[name]['age'] = int(age) if age.isnumeric() else age
            previous = None
    return res

&gt;&gt;&gt; parse_victim_info(info)
defaultdict(dict,
            {'Adrian Stevens': {'age': 27,
              'gender': 'NaN',
              'officer': False,
              'race': 'NaN'},
             'Richard Johnson': {'age': 48,
              'gender': 'M',
              'officer': True,
              # ... ...
</code></pre>
<p>This second function feels way too verbose &amp; tedious for what it's doing.</p>
<p>Is there a better way about this that is able to more smartly remember the categorization of the last value seen in the iteration?</p>
</div>
<div class="post-text" itemprop="text">
<p>This sort of thing lends itself very nicely to a <a href="https://docs.python.org/3/reference/simple_stmts.html#the-yield-statement" rel="nofollow noreferrer">generator</a>:</p>
<h3>Code:</h3>
<pre><code>def find_triplets(data):
    data = iter(data)
    while True:
        name = next(data)
        demo = next(data)
        officer = demo == 'OFFICER'
        if officer:
            demo = next(data)
        yield name, officer, demo
</code></pre>
<h3>Test Code:</h3>
<pre><code>info = [
    'Joe Schmoe',
    'W / M / 64',
    'Lillian Schmoe',
    'W / F / 60',
    'Richard Johnson',
    'OFFICER',
    'W / M /48',
    'Adrian Stevens',
    '? / ? / 27'
]

for x in find_triplets(info):
    print(x)
</code></pre>
<h3>Results:</h3>
<pre><code>('Joe Schmoe', False, 'W / M / 64')
('Lillian Schmoe', False, 'W / F / 60')
('Richard Johnson', True, 'W / M /48')
('Adrian Stevens', False, '? / ? / 27')
</code></pre>
<h3>Converting tuples triplets to <code>dict</code>:</h3>
<pre><code>import re

def fix_demographic(info):
    # W / M / ?? --&gt; W / M / NaN
    # ?/M/?  --&gt; NaN / M / NaN
    # Keep as str NaN rather than np.nan for now
    race, gender, age = re.split('\s*/\s*', re.sub('\?+', 'NaN', info))
    return dict(race=race, gender=gender, age=age)


data_dict = {name: dict(officer=officer, **fix_demographic(demo))
             for name, officer, demo in find_triplets(info)}

print(data_dict)
</code></pre>
<h3>Results:</h3>
<pre><code>{
    'Joe Schmoe': {'officer': False, 'race': 'W', 'gender': 'M', 'age': '64'}, 
    'Lillian Schmoe': {'officer': False, 'race': 'W', 'gender': 'F', 'age': '60'}, 
    'Richard Johnson': {'officer': True, 'race': 'W', 'gender': 'M', 'age': '48'}, 
    'Adrian Stevens': {'officer': False, 'race': 'NaN', 'gender': 'NaN', 'age': '27'}
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>itertools.groupby</code> in Python3:</p>
<pre><code>import itertools
import re
info = [
'Joe Schmoe',
'W / M / 64',
'Lillian Schmoe',
'W / F / 60',
'Richard Johnson',
'OFFICER',
'W / M /48',
'Adrian Stevens',
'? / ? / 27'
]
data = [list(b) for a, b in itertools.groupby(info, key=lambda x:x.count('/') &gt; 0 or x == 'OFFICER')]

final_data = {data[i][0]:{**{a:'NaN' if b == '?' else (int(b) if b.isdigit() else b) for a, b in zip(['race', 'gender', 'age'], filter(None, re.split('\s+|/', [h for h in data[i+1] if h.count('/') &gt; 0][0])))}, **{"officer":"OFFICER" in data[i+1]}} for i in range(0, len(data), 2)} 
</code></pre>
<p>Output:</p>
<pre><code>{'Joe Schmoe': {'race': 'W', 'gender': 'M', 'age': 64, 'officer': False}, 'Lillian Schmoe': {'race': 'W', 'gender': 'F', 'age': 60, 'officer': False}, 'Richard Johnson': {'race': 'W', 'gender': 'M', 'age': 48, 'officer': True}, 'Adrian Stevens': {'race': 'NaN', 'gender': 'NaN', 'age': 27, 'officer': False}}
</code></pre>
</div>
<span class="comment-copy">This is that kind of problem where you have no option but to roll your sleeves up and resign yourself to writing bad code as a result of bad design :(</span>
<span class="comment-copy">relevant to this: <a href="https://www.python.org/dev/peps/pep-0479/" rel="nofollow noreferrer">python.org/dev/peps/pep-0479</a></span>
