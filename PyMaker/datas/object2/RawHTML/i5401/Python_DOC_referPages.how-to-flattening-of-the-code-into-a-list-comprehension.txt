<div class="post-text" itemprop="text">
<p>I have this piece of code:</p>
<pre><code>for aaa_binary in groups(sources, a):

    if len(dodane_pary)!=count:

       g.add_nodes_from (aaa_binary)
       t1 = (aaa_binary[0],aaa_binary[1])
       t2 = (aaa_binary[1],aaa_binary[2])
       t3 = (aaa_binary[2],aaa_binary[3])                                                 

       added_now = []                      
       for edge in (t1,t2,t3):
           if not g.has_edge(*edge):
              g.add_edge(*edge)
              added_now.append(edge)

       dodane_pary.append(aaa_binary)  

       for j in range(len(dodane_pary)):
           if nx.shortest_path(g, aaa_binary[0], aaa_binary[3])!=aaa_binary or nx.shortest_path(g, dodane_pary[j][0], dodane_pary[j][3])!=dodane_pary[j]:
              for edge in added_now:
                  g.remove_edge(*edge)
              dodane_pary.remove(aaa_binary)
              break
    else: 
        break
</code></pre>
<p>Because of this, I probably will not be able to use multiprocessing in my program, so I would like to first test the speed of the code after flattening to comprehension as a list. </p>
<p>How to do it best? Is it better to flatten with pieces? Just for example, for <code>for/if</code> pairs? Or maybe bigger pieces?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't. You can't <em>remove</em> elements again already added to a list, yet this is what your code does. You also use <code>break</code>, and a list comprehension loop does not support breaking out. Last but not least, you are adding data to multiple data structures, while a list comprehension builds a <em>single list object</em>.</p>
<p>Besides, when your loop becomes this verbose, you really do not want to try to turn this into a list comprehension. The resulting code would be an unreadable mess.</p>
<p>A list comprehension is not <em>that</em> much faster anyway; a list comprehension removes a <em>constant time factor</em> from a regular loop-executing-repeated-list-appends, it is not a magic bullet. That's because a list comprehension avoids the <code>.append</code> attribute lookup, and a method call. Nothing more.</p>
<p>That said, your code really looks like you wanted to learn about the <a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow noreferrer"><code>any()</code> function</a> and <a href="https://docs.python.org/3/tutorial/classes.html#generator-expressions" rel="nofollow noreferrer">generator expressions</a> to test if your graph alterations still produce the shortest paths:</p>
<pre><code>aaa_binary_groups = iter(groups(sources, a))

while len(dodane_pary) &lt; count:
    aaa_binary = next(aaa_binary_groups, None)
    if aaa_binary is None:
        # no more groups to process
        break

    # add all edges to graph, then test for shortest paths
    g.add_nodes_from(aaa_binary)
    new_edges = [edge for edge in zip(aaa_binary, aaa_binary[1:]) 
                 if not g.has_edge(*edge)]
    g.add_edges_from(new_edges)

    if (nx.shortest_path(g, aaa_binary[0], aaa_binary[3]) != aaa_binary or
            any(nx.shortest_path(g, entry[0], entry[3]) != entry
                for entry in dodane_pary)):
        # not a shortest path for every existing entry, so remove again
        g.remove_edges_from(new_edges)
    else:
        # suitable match, retain addition to graph and track added node group
        dodane_pary.append(aaa_binary)
</code></pre>
<p>The <code>zip(aaa_binary, aaa_binary[1:])</code> iterable produces the same edge tuples your <code>t1</code>, <code>t2</code>, etc variables manually defined, provided there are always four elements in <code>aaa_binary</code>.</p>
<p>I'd also research if adding your nodes and edges is strictly necessary; perhaps you can avoid having to test <em>every edge added so far</em> each time you want to add a new group. If you can find such a change, <strong>then</strong> you could consider using functional approach to adding your node groups (as you can then simply filter your groups without adding them first). Once you can filter groups, you can then add them to the graph (with their edges), afterwards, in a straightforward loop.</p>
</div>
<span class="comment-copy">How would list comprehensions help with multiprocessing??</span>
<span class="comment-copy">The point is that I just have to give up multiprocessing. and I want to see how the code rebuilding on the lists will speed up the algorithm.</span>
<span class="comment-copy">Then why do you mention multiprocessing at all? Rather irrelevant and misleading then.</span>
<span class="comment-copy">I do note that you test <code>nx.stortest_path()</code> for <code>aaa_binary()</code> redundantly for every entry in <code>dodane_pary</code>, which <i>already</i> includes the <code>aaa_binary</code> group as the last entry. You didn't need to add that group to <code>dodane_pary</code> to then remove them again, <i>or</i> you do not need to explicitly test for that case.</span>
<span class="comment-copy">Also, you add all nodes from <code>aaa_binary</code> to <code>g</code>, but don't remove those nodes again if the edges were not matching your shortest path criteria. You remove added edges, why not the added nodes?</span>
<span class="comment-copy">I think both problems could be overcome. He only <i>removes</i> what he just added, which could instead be done by not including it in the first place (i.e., with an <code>if</code> in the comprehension). And I suspect I could hack breaking into it as well. But it would probably be completely asinine :-)</span>
<span class="comment-copy">@StefanPochmann: the <code>list.remove()</code> call is conditional, and I'm not sure why they don't just avoid appending <code>aaa_binary</code> in the first place. And the <code>break</code> indicates they are really just looking for <code>any(...)</code>.</span>
<span class="comment-copy">Well, looks like he's adding edges to a graph, then tests whether that was a good idea, and takes them back out if not. Might be simpler to write that way. Though I suspect since he wants speed, he should use a smarter algorithm instead. Like using union-find instead of the shortest_path searches.</span>
<span class="comment-copy">@Martijn Pieters Thanks for the different approach to this fragment. Everything works beautifully. StefanPochmann in the last sentence straightly explained what I meant. And he is right, that probably will not do without the reconstruction of the algorithm, or even looking for another one, because this one is too greedy.</span>
<span class="comment-copy">although I wonder if only in this fragment could not be used multiprocessing, because <code>groups (sources, a)</code> is just the whole list of combinations to check and find a good one. and the order of finding does not really matter.</span>
