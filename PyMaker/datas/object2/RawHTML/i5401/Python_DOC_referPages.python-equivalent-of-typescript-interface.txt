<div class="post-text" itemprop="text">
<p>Recently I have been working with Typescript a lot, it allows to express things like:</p>
<pre><code>interface Address {
    street: string;
    housenumber: number;
    housenumberPostfix?: string;
}

interface Person {
    name: string;
    adresses: Address[]
}

const person: Person = {
    name: 'Joe',
    adresses: [
        { street: 'Sesame', housenumber: 1 },
        { street: 'Baker', housenumber: 221, housenumberPostfix: 'b' }
    ]
}
</code></pre>
<p>Pretty concise and giving all the luxuries as type checking and code completion while coding with Persons.</p>
<p>How is this done in Python?</p>
<p>I have been looking at Mypy and ABC but did not yet succeed in finding the pythonic way to do something similar as the above (my attempts resulted in way too much boilerplate to my taste).</p>
</div>
<div class="post-text" itemprop="text">
<p>For the code completion and type hinting in IDEs, just add static typing for the <code>Person</code> and <code>Address</code> classes and you are already good to go. Assuming you use the latest <code>python3.6</code>, here's a rough equivalent of the typescript classes from your example:</p>
<pre><code># spam.py
from typing import Optional, Sequence


class Address:
    street: str
    housenumber: int
    housenumber_postfix: Optional[str]

    def __init__(self, street: str, housenumber: int, 
                 housenumber_postfix: Optional[str] = None) -&gt; None:
        self.street = street
        self.housenumber = housenumber
        self.housenumber_postfix = housenumber_postfix


class Person:
    name: str
    adresses: Sequence[Address]

    def __init__(self, name: str, adresses: Sequence[str]) -&gt; None:
        self.name = name
        self.adresses = adresses


person = Person('Joe', [
    Address('Sesame', 1), 
    Address('Baker', 221, housenumber_postfix='b')
])  # type: Person
</code></pre>
<p>I suppose the boilerplate you mentioned emerges when adding the class constructors. This is indeed inavoidable. I would wish default constructors were generated at runtime when not declared explicitly, like this:</p>
<pre><code>class Address:
    street: str
    housenumber: int
    housenumber_postfix: Optional[str]


class Person:
    name: str
    adresses: Sequence[Address]


if __name__ == '__main__':
    alice = Person('Alice', [Address('spam', 1, housenumber_postfix='eggs')])
    bob = Person('Bob', ())  # a tuple is also a sequence
</code></pre>
<p>but unfortunately you have to declare them manually.</p>
<hr/>
<h3>Edit</h3>
<p>As <a href="https://stackoverflow.com/users/646543/michael0x2a">Michael0x2a</a> pointed out in the <a href="https://stackoverflow.com/questions/48254562/python-equivalent-of-typescript-interface/48255117#comment83496184_48255117">comment</a>, the need for default constructors is made avoidable in <code>python3.7</code> which introduced a <code>@dataclass</code> decorator, so one can indeed declare:</p>
<pre><code>@dataclass
class Address:
    street: str
    housenumber: int
    housenumber_postfix: Optional[str]


@dataclass
class Person:
    name: str
    adresses: Sequence[Address]
</code></pre>
<p>and get the default impl of several methods, reducing the amount of boilerplate code. Check out <a href="https://www.python.org/dev/peps/pep-0557/" rel="noreferrer">PEP 557</a> for more details.</p>
<hr/>
<p>I guess you could see stub files that can be generated from your code, as some kind of interface files:</p>
<pre><code>$ stubgen spam  # stubgen tool is part of mypy package
Created out/spam.pyi
</code></pre>
<p>The generated stub file contains the typed signatures of all non-private classes and functions of the module without implementation:</p>
<pre><code># Stubs for spam (Python 3.6)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Optional, Sequence

class Address:
    street: str
    housenumber: int
    housenumber_postfix: Optional[str]
    def __init__(self, street: str, housenumber: int, housenumber_postfix: Optional[str]=...) -&gt; None: ...

class Person:
    name: str
    adresses: Sequence[Address]
    def __init__(self, name: str, adresses: Sequence[str]) -&gt; None: ...

person: Person
</code></pre>
<p>These stub files are also recognized by IDEs and if your original module is not statically typed, they will use the stub file for type hints and code completion.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python 3.6 added a new implementation of namedtuple that works with type hints, which removes some of the boilerplate required by the other answers.</p>
<pre class="lang-py prettyprint-override"><code>from typing import NamedTuple, Optional, List


class Address(NamedTuple):
    street: str
    housenumber: int
    housenumberPostfix: Optional[str] = None


class Person(NamedTuple):
    name: str
    adresses: List[Address]


person = Person(
    name='Joe',
    adresses=[
        Address(street='Sesame', housenumber=1),
        Address(street='Baker', housenumber=221, housenumberPostfix='b'),
    ],
)
</code></pre>
<p>Edit: <code>NamedTuple</code>s are immutable, so be aware that you can't use this solution if you want to modify the fields of your objects. Changing the contents of <code>lists</code> and <code>dicts</code> is still fine.</p>
</div>
<div class="post-text" itemprop="text">
<p>With Python 3.5, you can use annotations to specify the type of parameters and return types. Most of recent IDE, like PyCharm can interpret those annotations and give you good code completion. You can also use a comment to specify the signature of a function, or the type of a variable.</p>
<p>Here is an example:</p>
<pre><code>from typing import List, Optional


class Address(object):
    def __init__(self, street: str, housenumber: int, housenumber_postfix: Optional[str]=None):
        self.street = street
        self.housenumber = housenumber
        self.housenumber_postfix = housenumber_postfix


class Person(object):
    def __init__(self, name: str, addresses: List[Address]):
        self.name = name
        self.addresses = addresses


person = Person(
    name='Joe',
    addresses=[
        Address(street='Sesame', housenumber=1),
        Address(street='Baker', housenumber=221, housenumber_postfix='b')
    ])
</code></pre>
<p>Notice that Python is not a strongly typed language. So, annotations are only a guide for developers. If you really want to check your code, you need an external tools (currently, the best one is <a href="http://mypy-lang.org" rel="nofollow noreferrer">mypy</a>). It can be used like any other code checker during code quality control.</p>
</div>
<div class="post-text" itemprop="text">
<p>A simple solution I found (that doesn't require Python 3.7) is to use <a href="https://docs.python.org/3/library/types.html#additional-utility-classes-and-functions" rel="nofollow noreferrer">SimpleNamespace</a>:</p>
<pre><code>from types import SimpleNamespace as NS
from typing import Optional, List

class Address(NS):
    street: str
    housenumber: int
    housenumber_postfix: Optional[str]=None


class Person(NS):
    name: str
    addresses: List[Address]


person = Person(
    name='Joe',
    addresses=[
        Address(street='Sesame', housenumber=1),
        Address(street='Baker', housenumber=221, housenumber_postfix='b')
    ])
</code></pre>
<ul>
<li>This works in Python 3.3 and higher</li>
<li>The fields are mutable (unlike NamedTuple solution)</li>
<li>Code completion seems to work flawlessly in PyCharm but not 100% in VSCode (raised an <a href="https://github.com/Microsoft/vscode-python/issues/2662" rel="nofollow noreferrer">issue</a> for that)</li>
<li>Type checking in mypy works, but PyCharm does not complain if I e.g do <code>person.name = 1</code></li>
</ul>
<p>If anyone can point out why Python 3.7's <code>dataclass</code> decorator would be better I would love to hear.</p>
</div>
<div class="post-text" itemprop="text">
<p>Perhaps this will work well with <code>mypy</code></p>
<pre><code>from typing import List
from mypy_extensions import TypedDict

EntityAndMeta = TypedDict("EntityAndMeta", {"name": str, "count": int})

my_list: List[EntityAndMeta] = [
  {"name": "Amy", "count": 17},
  {"name": "Bob", "count": 42},
]
</code></pre>
<p>Read more about <em>TypedDict</em> from the <a href="https://mypy.readthedocs.io/en/stable/more_types.html?highlight=typeddict#typeddict" rel="nofollow noreferrer">mypy docs</a> or from the <a href="https://github.com/python/mypy/blob/master/extensions/mypy_extensions.py" rel="nofollow noreferrer">source code</a></p>
<p>I'm pretty sure you can <a href="https://github.com/python/mypy/blob/master/extensions/mypy_extensions.py" rel="nofollow noreferrer">nest these things</a>, and set some of them to <a href="https://mypy.readthedocs.io/en/latest/kinds_of_types.html?#optional-types-and-the-none-type" rel="nofollow noreferrer"><code>Optional</code></a> if you'd like.</p>
<p>I got this idea from <a href="https://stackoverflow.com/a/21014863/5017391">https://stackoverflow.com/a/21014863/5017391</a></p>
</div>
<span class="comment-copy">Class attributes are useless here.</span>
<span class="comment-copy">@LaurentLAPORTE: no they aren't - remove them and the type hints for class attributes are gone: <code>Person.name.&lt;?&gt;</code></span>
<span class="comment-copy">Regarding your second code snippet  -- you may be interested in <a href="https://www.python.org/dev/peps/pep-0557/" rel="nofollow noreferrer">PEP 557</a>, which was recently accepted (just in time for Python 3.7!) and is designed specifically to solve that exact pain point you brought up.</span>
<span class="comment-copy">Nice, thanks for the hint, @Michael0x2a!</span>
<span class="comment-copy">@LaurentLAPORTE -- interestingly, it seems like a semi-new convention is to actually use class annotations as a way of indicating what instance attributes are required. See PEP 526 (in particular, the <a href="https://www.python.org/dev/peps/pep-0526/#id9" rel="nofollow noreferrer">section about class annotations</a>) for an example. <a href="https://stackoverflow.com/q/47532472/646543">This question</a> (and the answer I left there) goes into this in a little more detail. One thing to note, however, is that this answer does NOT use any class <i>attributes</i>. It uses several class <i>annotations</i>, which are not the same thing.</span>
<span class="comment-copy">Great! And usable in py3.6 so i don't have to wait for 3.7's dataclasses. Question do you know why the optional construct is needed as the type checker could infer optionality from the default argument</span>
<span class="comment-copy">The typing documentation says "If necessary, Optional[t] is added for function and method annotations if a default value equal to None is set" so maybe it isn't required. I did read somewhere that this functionality would be deprecated in later python versions though. Something to do with this implicit optional breaking things in some edge cases. I'll add link if I can find where I read that.</span>
<span class="comment-copy">There's a big discussion here: <a href="https://github.com/python/typing/issues/275" rel="nofollow noreferrer">github.com/python/typing/issues/275</a></span>
<span class="comment-copy">Minor corrections: <code>s/Python 3/Python 3.5/</code>, also subclassing from <code>object</code> is required in <code>python2</code> only (but is still valid in <code>python3</code>, so not an error).</span>
<span class="comment-copy">Ok thanks. In your classes each instance variable is keyed in by you 3 times. Is there a way without that boilerplate?</span>
