<div class="post-text" itemprop="text">
<p>I was practicing on Leetcode, I want to ask 3 questions about the codes running time.</p>
<ol>
<li><p>I noticed that on Leetcode, even the same code will have quite
different running time if submitted multiple times. And the
difference is huge, is that normal? I have seen the difference as
first times beats 26%, but second times beats 51%. That really is
confusing me, while I am trying to figure out where I am and how
good the codes are.</p></li>
<li><p>The actual codes: Leetcode p21, remove element</p></li>
</ol>
<p>this is to remove all elements of one value from a list of int, without creating a new list, and return the length of the new list.</p>
<pre><code>def removeElement(IntList, val):
    n = 0
    while n &lt; len(IntList): 
        if IntList[n] == val:
           IntList.pop(n)   
        else:
            n += 1  
    return len(IntList)

def removeElement2(IntList, val): 
    while val in IntList:
        IntList.remove(val)
    return len(IntList)
</code></pre>
<p>You can see that I wrote two functions that will work, and the second one is so much shorter than the first one, but somehow the first one appeared to be faster. And I wonder why.</p>
<ol start="3">
<li>What is the best way to find out if one set of codes is faster than the other one without have to submitted to Leetcode?</li>
</ol>
<p>Thanks,</p>
</div>
<div class="post-text" itemprop="text">
<p>For those who is interested, I tried to use timeit to evaluate the two functions. The result is quite interesting, I found that as the list length goes longer, the efficiency of the two functions are changed:</p>
<p>When the list is short, first one is much slower than second one:</p>
<pre><code>print(timeit.Timer('removeElement(nums, val)',
                   setup='from __main__ import removeElement; '
                         'nums = [1, 2, 3, 4, 2, 3, 4, 4, 5, 6, 1, 2, 3, 4];'
                         'val = 4')
      .repeat(3, 1000000))

# &gt;&gt;&gt; [1.8547368030012876, 1.7035995290007122, 1.718884424000862]

print(timeit.Timer('removeElement2(nums, val)',
                   setup='from __main__ import removeElement2; '
                         'nums = [1, 2, 3, 4, 2, 3, 4, 4, 5, 6, 1, 2, 3, 4];'
                         'val = 4')
      .repeat(3, 1000000))
# &gt;&gt;&gt; [0.4291627630009316, 0.4323928640005761, 0.43043123800089234]
</code></pre>
<p>However, if I create a extremely long list:</p>
<pre><code>print(timeit.Timer('removeElement(nums, val)',
                   setup='from __main__ import removeElement; '
                         'nums = list(range(10)) * 10000;'
                         'val = 4')
      .repeat(3, 100))

# &gt;&gt;&gt; [1.5640779950008437, 1.5756833779996668, 1.6097137039996596]

print(timeit.Timer('removeElement2(nums, val)',
                   setup='from __main__ import removeElement2; '
                         'nums = list(range(10)) * 10000;'
                         'val = 4')
      .repeat(3, 100))
# &gt;&gt;&gt; [11.877236265998363, 11.790503606998755, 12.056773186999635]
</code></pre>
<p>The second function is much slower now.</p>
</div>
<span class="comment-copy">Use <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer">timeit</a> to find out how long something takes to run. Right now your question is too broad and isn't really a specific programming question.</span>
<span class="comment-copy">Shorter does not always mean faster.</span>
<span class="comment-copy">@MooingRawr Wow, there is a module in standard library that can do this? Thank you!! It is the 27th in the series, no wonder I have not read to it yet.....</span>
<span class="comment-copy">With the same inputs? Their system is probably running a lot of code for a lot of people. Periods of high load will see individual process performance suffer. This is true of your local machine too, it's just that you usually aren't doing several intensive processes at the same time.</span>
<span class="comment-copy">1 - yes that's normal. 2 - It is faster because it does less work. 3 - mathematical analysis tells if it will be faster on large data sets. Measurement tells if it is actually faster in the real world on the same data set. You can do measurements with profiling or datetime, if you don't want to run it on leetcode. (But they have good data lined up, with lots of inputs, which is important.)</span>
<span class="comment-copy">The <code>val in IntList</code> will scan the list from the beginning every time through the loop.</span>
<span class="comment-copy">Look up "big O" notation for some insight into this.</span>
<span class="comment-copy">@KennyOstrom Thanks!</span>
