<div class="post-text" itemprop="text">
<p>I am sending an email with an attachment, and that attachment has a long filename. Why does it get corrupted with newlines, and what part of the system is supposed to know these newlines should be removed?</p>
<pre><code>from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.application import MIMEApplication
from email.utils import formatdate

msg = MIMEMultipart()
msg['Subject'] = 'subject'
msg['To'] = 'a@example.com'
msg['From'] = 'b@example.com'
msg['Date'] = formatdate(localtime=True)
msg.attach(MIMEText('abc'))

attachment_name = 'abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz.txt'
part = MIMEApplication("sometext", Name=attachment_name)
part['Content-Disposition'] = 'attachment; filename="%s"' % attachment_name
msg.attach(part)

print msg.as_string()
</code></pre>
<p>Gives me:</p>
<pre><code>Content-Type: multipart/mixed; boundary="===============1448866158=="
MIME-Version: 1.0
Subject: subject
To: a@example.com
From: b@example.com
Date: Sat, 20 Jan 2018 13:11:42 -0500

--===============1448866158==
Content-Type: text/plain; charset="us-ascii"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit

abc
--===============1448866158==
Content-Type: application/octet-stream;
 Name="abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz
 abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz
 abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz.txt"
MIME-Version: 1.0
Content-Transfer-Encoding: base64
Content-Disposition: attachment; filename="abcdefghijklmnopqrstuvwxyz
 abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz
 abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz
 abcdefghijklmnopqrstuvwxyz.txt"

c29tZXRleHQ=
--===============1448866158==--
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Handling of long header fields is defined in <a href="https://tools.ietf.org/html/rfc2822#section-2.2.3" rel="nofollow noreferrer">section 2.2.3 of RFC 2822 "Internet Message Format"</a>. That section survives unchanged in an obsoleting <a href="https://tools.ietf.org/html/rfc5322#section-2.2.3" rel="nofollow noreferrer">RFC 5322</a>.</p>
<blockquote>
<p>2.2.3. Long Header Fields</p>
<p>Each header field is logically a single line of characters comprising
  the field name, the colon, and the field body.  For convenience
  however, and to deal with the 998/78 character limitations per line,
  the field body portion of a header field can be split into a multiple
  line representation; this is called "folding".  The general rule is
  that wherever this standard allows for folding white space (not simply
  WSP characters), a CRLF may be inserted before any WSP.  For example,
  the header field:</p>
<pre class="lang-none prettyprint-override"><code>Subject: This is a test
</code></pre>
<p>can be represented as:</p>
<pre class="lang-none prettyprint-override"><code>Subject: This
 is a test
</code></pre>
<p>Note: Though structured field bodies are defined in such a way that
  folding can take place between many of the lexical tokens (and even
  within some of the lexical tokens), folding SHOULD be limited to
  placing the CRLF at higher-level syntactic breaks.  For instance, if a
  field body is defined as comma-separated values, it is recommended
  that folding occur after the comma separating the structured items in
  preference to other places where the field could be folded, even if it
  is allowed elsewhere.</p>
<p><strong>The process of moving from this folded multiple-line representation of
  a header field to its single line representation is called
  "unfolding". Unfolding is accomplished by simply removing any CRLF
  that is immediately followed by WSP.  Each header field should be
  treated in its unfolded form for further syntactic and semantic
  evaluation.</strong></p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>As Leon's answer explains, Python is implementing the folding algorithm defined in the RFCs.</p>
<p>In Python 2, you can use an <code>email.generator.Generator</code> instance to give you control over the maximum header length; from <a href="https://docs.python.org/2.7/library/email.message.html#email.message.Message.as_string" rel="nofollow noreferrer">the docs</a>:</p>
<blockquote>
<p>For more flexibility, instantiate a Generator instance and use its flatten() method directly. For example:</p>
</blockquote>
<pre><code>from cStringIO import StringIO
from email.generator import Generator
fp = StringIO()
g = Generator(fp, mangle_from_=False, maxheaderlen=60)
g.flatten(msg)
text = fp.getvalue()
</code></pre>
<p>(setting maxheaderlen to zero will prevent folding of long header lines in almost all cases).</p>
<p>In Python 3.5, the maxheaderlen argument is exposed in <code>email.message.Message.as_string</code>'s <a href="https://docs.python.org/3.5/library/email.message.html#email.message.Message.as_string" rel="nofollow noreferrer">signature</a>, so </p>
<p><code>print(msg.as_string(maxheaderlen=256))</code></p>
<p>is possible. <code>maxheaderlen</code> is zero by default, so header lines are not wrapeed unless a value is provided.</p>
<p>In Python 3.6, <code>maxheaderlen</code> is exposed in <code>email.message.EmailMessage.as_string</code>'s <a href="https://docs.python.org/3/library/email.message.html#email.message.EmailMessage.as_string" rel="nofollow noreferrer">signature</a> (note this is a different class).  <code>maxheaderlen</code> now defaults to <code>None</code>: header lines wrap at 78 characters unless a value is specified.</p>
</div>
<span class="comment-copy">Thanks, this is a great digest on how to make the sender stop folding!</span>
