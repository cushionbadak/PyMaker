<div class="post-text" itemprop="text">
<p>Note : This is not a duplicate question as the title might say</p>
<p>If I have a list of list , I need to get all combinations from it with replacement. </p>
<pre><code>import itertools

l = [[1,2,3] ,[1,2,3],  [1,2,3]]
n = []
for i in itertools.product(*l):
    if sorted(i) not in n:
        n.append(sorted(i))
for i in n:
    print(i)

[1, 1, 1]
[1, 1, 2]
[1, 1, 3]
[1, 2, 2]
[1, 2, 3]
[1, 3, 3]
[2, 2, 2]
[2, 2, 3]
[2, 3, 3]
[3, 3, 3]
</code></pre>
<p>Thanks to @RoadRunner and @Idlehands.</p>
<p>Above code is perfect with 2 problems :</p>
<ol>
<li><p>For large list, itertools.product throws MemoryError. When l has 18 3-length sublists to give ~400mil combn.</p></li>
<li><p>Order matters and thus <code>sorted</code> would not work for my problem. This could be confusing for some and hence explaining with below example.</p>
<p><code>l = [[1,2,3], [1], [1,2,3]]</code></p></li>
</ol>
<p>Here I have 2 unique groups :</p>
<p>Group1 : elements 0, 2 which has same value [1,2,3]</p>
<p>Group 2 : element 1 which has value [1]</p>
<p>Thus, the solutions I need is :</p>
<pre><code>[1,1,1]
[1,1,2]
[1,1,3]
[2,1,2]
[2,1,3]
[3,1,3]
</code></pre>
<p>Thus location <code>1</code> was fixed to <code>1</code>.</p>
<p>Hope this example helps.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Edited Answer:</strong></p>
<p>Based on the new information, in order to handle a plethora of combination overloading the <code>itertools.product()</code>, we can try to pull the list in small batches:</p>
<pre><code>from itertools import product
l = [list(range(3))]*18
prods = product(*l)
uniques = set()
results = []
totals = 0

def run_batch(n=1000000):
    for i in range(n):
        try:
            result = next(prods)
        except StopIteration:
            break
        unique = tuple(sorted(result))
        if unique not in uniques:
            uniques.add(unique)
            results.append(result)
    global totals
    totals += i

run_batch()
print('Total iteration this batch: {0}'.format(totals))
print('Number of unique tuples: {0}'.format(len(uniques)))
print('Number of wanted combos: {0}'.format(len(results)))
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Total iteration this batch: 999999
Number of unique tuples: 103
Number of wanted combos: 103
First 10 results:
(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1)
(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2)
(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1)
(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2)
(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2)
(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1)
(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2)
(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2)
(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2)
</code></pre>
<p>Here we can control the batch size by calling <code>next(prod)</code> with the range of your choice, and continue as you see fit.  The <code>uniques</code> are sorted tuples in a set as a reference point, and the <code>results</code> are in the proper order you wanted.  Both size should be the same and are surprisingly small when I ran with the list of 3^18.  I'm not well acquainted with memory allocation but this way the program <em>shouldn't</em> store all the unwanted results in memory, so you should therefore have more wiggle room.  Otherwise, you can always opt to export the <code>results</code> to a file to make room.  Obviously this sample only show the length of the list, but you can easily display/save that for your own purpose.</p>
<p>I can't argue this is the best approach or most optimized, but It seems to work for me.  Maybe it'll work for you? This batch took approximately ~10s to run 5 times (avg ~2s each batch).  The entire set of <code>prods</code> took me 15 minutes to run:</p>
<pre><code>Total iteration: 387420102
Number of unique tuples: 190
Number of wanted combos: 190
</code></pre>
<hr/>
<p><strong>Original Answer:</strong></p>
<p><a href="https://stackoverflow.com/questions/48375270/python-get-all-unique-combinations-with-replacement-from-lists-of-list-with-un/48375446#48375527">@RoadRunner had a neat solution with <code>sort()</code> and <code>defaultdict</code></a>, but I feel the latter was not needed.  I leveraged his <code>sort()</code> suggestion and implemented a modified version here.</p>
<p>From <a href="https://stackoverflow.com/questions/798854/all-combinations-of-a-list-of-lists">this answer</a>:</p>
<pre><code>l = [[1] ,[1,2,3],  [1,2,3]]
n = []
for i in itertools.product(*l):
    if sorted(i) not in n:
        n.append(sorted(i))
for i in n:
    print(i)
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>[1, 1, 1]
[1, 1, 2]
[1, 1, 3]
[1, 2, 2]
[1, 2, 3]
[1, 3, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What about grouping sequences with the same elements in different order with a <a href="https://docs.python.org/3.6/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a>, then picking the first element from each key:</p>
<pre><code>from itertools import product
from collections import defaultdict

l = [[1] ,[1,2,3],  [1,2,3]]

d = defaultdict(list)
for x in product(*l):
    d[tuple(sorted(x))].append(x)

print([x[0] for x in d.values()])
</code></pre>
<p>Which gives:</p>
<pre><code>[(1, 1, 1), (1, 1, 2), (1, 1, 3), (1, 2, 2), (1, 2, 3), (1, 3, 3)]
</code></pre>
<p>Alternatively, this can also be done with keeping a set of what has been added:</p>
<pre><code>from itertools import product

l = [[1] ,[1,2,3],  [1,2,3]]

seen = set()
combs = []

for x in product(*l):
    curr = tuple(sorted(x))
    if curr not in seen:
        combs.append(x)
        seen.add(curr)

print(combs)
# [(1, 1, 1), (1, 1, 2), (1, 1, 3), (1, 2, 2), (1, 2, 3), (1, 3, 3)]
</code></pre>
<p>If you don't want to sort, consider using a <a href="https://docs.python.org/3/library/stdtypes.html?highlight=frozenset#frozenset" rel="nofollow noreferrer"><code>frozenset</code></a> with <a href="https://docs.python.org/3.6/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter()</code></a>:</p>
<pre><code>from collections import Counter
from itertools import product

l = [[1] ,[1,2,3],  [1,2,3]]

seen = set()
combs = []

for x in product(*l):
    curr = frozenset(Counter(x).items())

    if curr not in seen:
        seen.add(curr)
        combs.append(x)

print(combs)
# [(1, 1, 1), (1, 1, 2), (1, 1, 3), (1, 2, 2), (1, 2, 3), (1, 3, 3)]
</code></pre>
<p><strong>Note:</strong> You can also use <code>setdefault()</code> for the first approach, if you don't want to use a <code>defaultdict()</code>. </p>
</div>
<div class="post-text" itemprop="text">
<p>For short input sequences, this can be done by filtering the output of <a href="https://docs.python.org/2/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product</code></a> to just the unique values. One not optimized way is <code>set(tuple(sorted(t)) for t in itertools.product(*l))</code>, converting to a <code>list</code> if you like.</p>
<p>If you have enough of a Cartesian product fanout that this is too inefficient, and if your input example showing the sublists as sorted is something you can rely on, you could borrow a note from the docs' discussion of <a href="https://docs.python.org/2/library/itertools.html#itertools.permutations" rel="nofollow noreferrer"><code>permutations</code></a> and filter out non-sorted values:</p>
<blockquote>
<p>The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool)</p>
</blockquote>
<p>So you'd want a quick test for whether a value is sorted or not, something like this answer:
<a href="https://stackoverflow.com/a/3755410/2337736">https://stackoverflow.com/a/3755410/2337736</a></p>
<p>And then <code>list(t for t in itertools.product(*l) if is_sorted(t))</code></p>
<p>Beyond that, I think you'd have to get into recursion or a fixed length of <code>l</code>.</p>
</div>
<span class="comment-copy">I don't see how your output matches with your input <code>l</code>.</span>
<span class="comment-copy">I stared for a bit at that as well, I think it's just transposed. <code>l = [[1], [1, 2, 3], [1, 2,3]]</code> maps reasonably clearly to the example output.</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/798854/all-combinations-of-a-list-of-lists">All combinations of a list of lists</a></span>
<span class="comment-copy">@joel.wilson Would you expected <code>[(1, 1, 1), (1, 1, 2), (1, 1, 3), (1, 2, 2), (1, 2, 3), (1, 3, 3)]</code> here?</span>
<span class="comment-copy">@RoadRunner thats right. I have shown the expected o/p above</span>
<span class="comment-copy"><code>(1,1,2)</code> is same as <code>(1,2,1)</code> !</span>
<span class="comment-copy">I'm testing all the scenarios I have using all answers posted here and will accept one. Thank you very much guys !</span>
<span class="comment-copy">@Idlehands Yeah realised the <code>defaultdict</code> approach is not the best way. Simply keeping track of seen items with a set is good enough.</span>
<span class="comment-copy">When my l is of length 18 with the sublist of length 3 each, total combinations are 3^18. Itertools throws MemoryError. Any thought to do this through recursive or 'dynamic` for loops ? Even I'm thinking</span>
<span class="comment-copy">@PeterDeGlopper <code>set(sorted(i) for i in itertools.product(*l))</code> won't work here, since lists are not hashable. I think you mean <code>tuple(sorted(i))</code> instead.</span>
<span class="comment-copy">I'm testing all the scenarios I have using all answers posted here and will accept one. Thank you very much guys !</span>
<span class="comment-copy">@joel.wilson No worries.</span>
<span class="comment-copy">When my l is of length 18 with the sublist of length 3 each, total combinations are 3^18. Itertools throws MemoryError. Any thought to do this through <code>recursive</code> or 'dynamic` for loops ? Even I'm thinking</span>
<span class="comment-copy">@joel.wilson hmm, yeah it would get slow if your generating that many combinations. Using recursion is probably not a good idea, because of the recursion depth limit. Have you had a look at <a href="https://stackoverflow.com/questions/8695422/why-do-i-get-a-memoryerror-with-itertools-product">this</a> question, it seems to address a way around this.</span>
<span class="comment-copy">I was checking through the solution and saw the order gets <code>sorted</code>. Is there a way to avoid this. I have edited my question to better explain the problem.</span>
<span class="comment-copy">The last point is exactly my challenge. I ahve list of length 18, each sublist each of length 3. thus amounting to 3^18 combinations. I was wondering about recursive or dynamic for loops.</span>
<span class="comment-copy">So you have 18 total elements split between 6 3-length sublists, or you have 18 3-length sublists for 54 total? The former is trivial to generate and then filter, performance/memory wise - it's only 729 candidates. The second, well, it's about 387 million elements - possible but it might take some tuning.</span>
<span class="comment-copy">I have the 387mil case one. How can we tune them ?</span>
<span class="comment-copy">...hang on, that's 387 million 18-element tuples. About 7 billion numbers to work with. If they're really ints, as in this example...well, my system shows 28 bytes for an int. Even if tuples were free, and they're not, that's approximately 196 GB. No wonder <code>itertools.product</code> is blowing up. I withdraw the "possible but it might take some tuning" comment. "Possible but with a lot of work first" is probably more accurate. If I were in your shoes I'd try to rework the problem if at all possible.</span>
<span class="comment-copy"><code>I'd try to rework the problem if at all possible</code> thats what I'm trying</span>
