<div class="post-text" itemprop="text">
<p>I have extended the <code>Parent</code> class with the <code>Override</code> class. I have have overridden the <code>method()</code> method to fix a bug that occurs in the <code>Parent</code> class. I fixed the said bug and this fix has been tested in the <code>Override</code> class.</p>
<p>I use the <code>Override</code> class through an <code>External</code> class. By testing the <code>External</code> class to see if the previous bug is fixed, I discovered that it is not and that the traceback does not go through the <code>Override</code> class.</p>
<pre><code>class Parent():

    def method(self, param):
        # Bugged
        do_stuff()

class Override(Parent):

    def method(self, param):
        # Fixed (tested)
        param = fix_param(param)
        super(Parent, self).method(param)

class External():

    def processing():
        # Same bug as in `Parent`
        param = get_param()
        obj = Override()
        obj.method(param)
</code></pre>
<p>It seems to me that the <code>External</code> class uses the <code>Parent.method()</code> method instead of the <code>Override.method()</code> method. Any clue on how to fix it or on where this problem comes from?</p>
<p>I'm a beginner and have not been confronted inheritance a lot so, please, forgive my ignorance and my lack of experience.</p>
<p><strong>EDIT</strong></p>
<p>Test that fails in <code>External</code> :</p>
<pre><code>import os
import collections
import envtpl
from acquisition.configargparse_confparser import StepConfigFileParser
from configparser_extended import ExtendedConfigParser
from unittest import TestCase
from acquisition.utils import set_custom_environment


class ConfigFileParserTestCase(TestCase):

def test_parse_extended(self):
    # x = StepConfigFileParser("test_plugin_name", "test")
    plugin_name = "test_plugin_name"
    step_name = "test"
    set_custom_environment(plugin_name, step_name)
    config = os.environ.get('MFCONFIG', 'GENERIC')
    filename = os.path.dirname(os.path.realpath(__file__)) + "/test.ini"
    with open(filename, 'r') as stream:
        config_parser = ExtendedConfigParser(
            config=config, inheritance='im', interpolation=None)
        content = stream.read()
        config_parser.read_string(content)  # Fails here
        section = "step_%s" % step_name
        res = collections.OrderedDict()
        for key in config_parser.options(section):
            if not key.startswith('arg_'):
                continue
            res[key.replace('arg_', '', 1)] = envtpl.render_string(
                config_parser.get(section, key))
    self.assertEqual(res, {"venom": "snake", "revolver": "ocelot"})
</code></pre>
<p>Overridden method :
<code>read_string()</code> in <a href="https://github.com/thefab/configparser_extended/blob/master/configparser_extended/ecp.py" rel="nofollow noreferrer">https://github.com/thefab/configparser_extended/blob/master/configparser_extended/ecp.py</a> line 573</p>
<p>Parent method :
<code>read_string()</code> from <code>configparser</code>
(<a href="https://docs.python.org/3/library/configparser.html#configparser.ConfigParser.read_string" rel="nofollow noreferrer">https://docs.python.org/3/library/configparser.html#configparser.ConfigParser.read_string</a>)</p>
<p><code>test.ini</code></p>
<pre><code>[step_test]
arg_venom=snake
arg_revolver=ocelot
liquid=snake
</code></pre>
<p>Error :</p>
<pre><code>ERROR: test_parse_extended (tests.test_confparser.ConfigFileParserTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/florian/metwork/mfdata/src/acquisition/tests/test_confparser.py", line 39, in test_parse_extended
    config_parser.read_string(content)
  File "/opt/metwork-mfext/opt/python2/lib/python2.7/site-packages/backports/configparser/__init__.py", line 728, in read_string
    sfile = io.StringIO(string)
TypeError: initial_value must be unicode or None, not str
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your code is not a complete working example, but it should do as you suggest.</p>
<p>Here is an example you can run to prove the point:</p>
<pre><code>class Parent():
    def method(self):
        print('parent')

class Child(Parent):    
    def method(self):
        print('child')

class Other():
    def call_method(self):
        c = Child()
        c.method()

o = Other()
o.call_method()
</code></pre>
<p>That prints 'child', proving the Child class has overridden method(self).</p>
</div>
<span class="comment-copy">You need to show real code and the error you get. The code you've posted would not demonstrate the behaviour you claim.</span>
<span class="comment-copy">Please post a MCVE.</span>
<span class="comment-copy">This should be a comment not an answer.</span>
<span class="comment-copy">Yes, that's the behaviour I would expect, but it seems to use the parent method in my case and I don't understand why.</span>
