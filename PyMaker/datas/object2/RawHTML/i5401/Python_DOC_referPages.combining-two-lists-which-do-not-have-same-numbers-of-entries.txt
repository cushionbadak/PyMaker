<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/19686533/how-to-zip-two-differently-sized-lists">How to zip two differently sized lists?</a>
<span class="question-originals-answer-count">
                    8 answers
                </span>
</li>
</ul>
</div>
<p>I have following two lists to combine. I'm trying to use <code>zip()</code> but header_list runs out for obvious reason.</p>
<pre><code>header_list = ['1 mo', '3 mo', '6 mo', '1 yr', '2 yr', '3 yr', '5 yr', '7
yr', '10 yr', '20 yr', '30 yr']

data_list = [1.29, 1.44, 1.61, 1.83, 1.92, 2.01, 2.25, 2.38, 2.46,
2.64, 2.81, 1.29, 1.41, 1.59, 1.81, 1.94, 2.02, 2.25, 2.37, 2.44, 2.62, 2.78, 1.28, 1.41, 1.6, 1.82, 1.96, 2.05, 2.27, 2.38, 2.46, 2.62, 2.79]
</code></pre>
<p>The result should be a tuple in the following format:</p>
<pre><code>('1 mo', 1.29)
('3 mo', 1.44)
('6 mo', 1.61)
('1 yr', 1.83)
('2 yr', 1.92)
('3 yr', 2.01)
('5 yr', 2.25)
('7 yr', 2.38)
('10 yr', 2.46)
('20 yr', 2.64)
('30 yr', 2.81)
('1 mo', 1.29)
('3 mo', 1.41)
('6 mo', 1.59)
('1 yr', 1.81)
('2 yr', 1.94)
('3 yr', 2.02)
('5 yr', 2.25)
('7 yr', 2.37)
('10 yr', 2.44)
('20 yr', 2.62)
('30 yr', 2.78)
...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you use itertools you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.cycle" rel="noreferrer"><code>cycle</code></a> to repeat the shorter one:</p>
<pre><code>from itertools import cycle
print(zip(cycle(header_list), data_list))
</code></pre>
<p><code>zip</code> will stop once the shorter iterable ends. <code>cycle</code> returns an iterable that never ends (constantly repeats <code>header_list</code>), so <code>data_list</code> will be shorter (and it will stop zipping when <code>data_list</code> ends).</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming you want the shorter list to simply wrap, you can iterate over the indices of the longer list and mod the current index by the length of the shorter list:</p>
<pre><code>out = [(header_list[i%len(header_list)], data_list[i]) for i in range(len(data_list))]
</code></pre>
<p>Or, to be more Pythonic:</p>
<pre><code>out = [(header_list[i%len(header_list)], e) for i,e in enumerate(data_list)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>how about something like this?</p>
<pre><code>counter = 0
new_list = []
for data in data_list:
    new_list.append([header_list[counter%len(header_list)],data])
    counter+=1
</code></pre>
</div>
<span class="comment-copy">I wasn't aware of the <code>cycle</code> function, thanks for this!</span>
<span class="comment-copy">Awesome, does the job. Thx a lot</span>
<span class="comment-copy">Thanks, this work fine.</span>
<span class="comment-copy">Instead of iterating over <code>range(len(data_list))</code>, I'd contend the more python way would be to iterate over <code>enumerate(data_list)</code>. List indices are generally less pythonic.</span>
<span class="comment-copy">@BaileyParker Thanks, added as an option</span>
<span class="comment-copy">In general, using counters and <code>list.append</code> isn't very pythonic. In this instance, you'd definitely be better off constructing the list via a comprehension. If you do need to access an index, <code>enumerate</code> is your friend.</span>
<span class="comment-copy">@BaileyParker <code>list.append</code> is <i>perfectly pythonic</i>, although you are correct, here <code>enumerate</code> is what you would use instead of a counter variable. Better yet, though, it would be <code>zip</code></span>
