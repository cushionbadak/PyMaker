<div class="post-text" itemprop="text">
<p>I've been looking at the following questions for the pas hour without any luck:</p>
<p><a href="https://stackoverflow.com/questions/11025005/python-sharing-a-dictionary-between-parallel-processes">Python sharing a dictionary between parallel processes</a></p>
<p><a href="https://stackoverflow.com/questions/659865/multiprocessing-sharing-a-large-read-only-object-between-processes">multiprocessing: sharing a large read-only object between processes?</a></p>
<p><a href="https://stackoverflow.com/questions/22487296/multiprocessing-in-python-sharing-large-object-e-g-pandas-dataframe-between/22487898">multiprocessing in python - sharing large object (e.g. pandas dataframe) between multiple processes</a></p>
<p>I've written a very basic test file to illustrate what I'm trying to do:</p>
<pre><code>from collections import deque
from multiprocessing import Process
import numpy as np


class TestClass:
    def __init__(self):
        self.mem = deque(maxlen=4)
        self.process = Process(target=self.run)

    def run(self):
        while True:
            self.mem.append(np.array([0, 1, 2, 3, 4]))


def print_values(x):
    while True:
        print(x)


test = TestClass()
process = Process(target=print_values(test.mem))

test.process.start()
process.start()
</code></pre>
<p>Currently this outputs the following :</p>
<pre><code>deque([], maxlen=4)
</code></pre>
<p>How can I access the mem value's from the main code or the process that runs "print_values"?</p>
</div>
<div class="post-text" itemprop="text">
<p>Unfortunately <code>multiprocessing.Manager()</code> doesn't support <code>deque</code> but it does work with <code>list</code>, <code>dict</code>, <code>Queue</code>, <code>Value</code> and <code>Array</code>.  A <code>list</code> is fairly close so I've used it in the example below..</p>
<pre><code>from multiprocessing import Process, Manager, Lock
import numpy as np

class TestClass:
    def __init__(self):
        self.maxlen = 4
        self.manager = Manager()
        self.mem = self.manager.list()
        self.lock = self.manager.Lock()
        self.process = Process(target=self.run, args=(self.mem, self.lock))

    def run(self, mem, lock):
        while True:
            array = np.random.randint(0, high=10, size=5)
            with lock:
                if len(mem) &gt;= self.maxlen:
                    mem.pop(0)
                mem.append(array)

def print_values(mem, lock):
    while True:
        with lock:
            print mem

test = TestClass()
print_process = Process(target=print_values, args=(test.mem, test.lock))
test.process.start()
print_process.start()

test.process.join()
print_process.join()
</code></pre>
<p>You have to be a little careful using manager objects.  You can use them a lot like the objects they reference but you can't do something like... <code>mem = mem[-4:]</code> to truncate the values because you're changing the referenced object.</p>
<p>As for coding style, I might move the <code>Manager</code> objects outside the class or move the <code>print_values</code> function inside it but for an example, this works.  If you move things around, just note that you can't use <code>self.mem</code> directly in the <code>run</code> method.  You need to pass it in when you start the process or the <code>fork</code> that python does in the background will create a new instance and it won't be shared.</p>
<p>Hopefully this works for your situation, if not, we can try to adapt it a bit.</p>
</div>
<div class="post-text" itemprop="text">
<p>So by combining the code provided by @bivouac0 and the comment @Marijn Pieters posted, I came up with the following solution:</p>
<pre><code>from multiprocessing import Process, Manager, Queue


class testClass:
    def __init__(self, maxlen=4):
        self.mem = Queue(maxsize=maxlen)
        self.process = Process(target=self.run)

    def run(self):
        i = 0

        while True:
            self.mem.empty()
            while not self.mem.full():
                self.mem.put(i)
                i += 1


def print_values(queue):
    while True:
        values = queue.get()
        print(values)


if __name__ == "__main__":
    test = testClass()
    print_process = Process(target=print_values, args=(test.mem,))

    test.process.start()
    print_process.start()

    test.process.join()
    print_process.join()
</code></pre>
</div>
<span class="comment-copy">You need to read up on <a href="https://docs.python.org/3/library/multiprocessing.html#sharing-state-between-processes" rel="nofollow noreferrer"><i>exchanging objects</i></a> or <a href="https://docs.python.org/3/library/multiprocessing.html#sharing-state-between-processes" rel="nofollow noreferrer"><i>sharing state between processes</i></a>. Your child processes each get a forked copy of the deque, there is no further connection between them. You probably want a <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue" rel="nofollow noreferrer">managed <code>Queue</code></a>.</span>
<span class="comment-copy">Thanks for taking the time to answer this question. I've implemented your code but I'm getting the following error:  _pickle.PicklingError: Can't pickle &lt;class 'weakref'&gt;: attribute lookup weakref on builtins failed  I've tried moving the process outside of the class by using the following code, but without any luck:  test.process = Process(target=test.run, args=(test.mem, test.lock))</span>
<span class="comment-copy">I've solved it using part of the code you provided and the hint @Marijn Pieters gave me. I'll post my sollution below :)</span>
