<div class="post-text" itemprop="text">
<p>I defined a class that holds a list collection of objects, and defined the <code>__iter__</code> and <code>__next__</code> methods to make it for <em>loopable</em>. The collection here, is a <code>Deck</code> class that holds a list of <code>Card</code> objects.</p>
<h3>Code:</h3>
<pre><code>import random

class Card:

    @staticmethod
    def get_ranks():
        return ("A", "K", "Q", "J", "10", "9", "8", "7", "6", "5", "4", "3", "2") # A is highest, 2 is lowest

    @staticmethod
    def get_suites():
        return ("H", "D", "S", "C")

    def __init__(self, suite, rank):
        if suite not in Card.get_suites():
            raise Exception("Invalid suite")
        if rank not in Card.get_ranks():
            raise Exception("Invalid rank")
        self.suite = suite
        self.rank = rank

    def __lt__(self, card2):
        self_rank = Card.get_ranks().index(self.rank)
        card2_rank = Card.get_ranks().index(card2.rank)
        return self_rank &gt; card2_rank

    def __le__(self, card2):
        self_rank = Card.get_ranks().index(self.rank)
        card2_rank = Card.get_ranks().index(card2.rank)
        return self_rank &gt;= card2_rank

    def __gt__(self, card2):
        self_rank = Card.get_ranks().index(self.rank)
        card2_rank = Card.get_ranks().index(card2.rank)
        return self_rank &lt; card2_rank

    def __ge__(self, card2):
        self_rank = Card.get_ranks().index(self.rank)
        card2_rank = Card.get_ranks().index(card2.rank)
        return self_rank &lt;= card2_rank

    def __eq__(self, card2):
        self_rank = Card.get_ranks().index(self.rank)
        card2_rank = Card.get_ranks().index(card2.rank)
        return self_rank == card2_rank

    def __ne__(self, card2):
        self_rank = Card.get_ranks().index(self.rank)
        card2_rank = Card.get_ranks().index(card2.rank)
        return self_rank != card2_rank

    def __str__(self):
        return(self.rank + self.suite)

    def __repr__(self):
        return str(self)

class Deck:

    def __init__(self):
        self.contents = [Card(suite, rank) for suite in Card.get_suites() for rank in Card.get_ranks()]
        random.shuffle(self.contents)
        self.index = 0

    def __len__(self):
        return len(self.contents)

    def __iter__(self):
        return self

    def __next__(self):
        if self.index == len(self.contents):
            raise StopIteration
        item = self.contents[self.index]
        self.index += 1
        return item

    def pick_card(self):
        choice = random.randrange(len(self))
        card = self.contents.pop(choice)
        return card

    def return_card_and_shuffle(self, card):
        self.contents.append(card)
        random.shuffle(self.contents)

    def __str__(self):
        dstr = ''
        for card in self:
            dstr += str(card) + ", "
        return "{} cards: ".format(len(self)) + dstr[:-2]

def deal_bookends(deck):
        card1 = deck.pick_card()
        card2 = deck.pick_card()
        if card1 &gt; card2:
            temp = card1
            card1 = card2
            card2 = temp
        return (card1, card2)

if __name__ == '__main__':
    deck = Deck()
    for _ in range(3):
        c1, c2 = deal_bookends(deck)
        print("We have {} and {}".format(c1, c2))
        print(deck)
        deck.return_card_and_shuffle(c1)
        print(deck)
        print(deck.contents[-4:])
        deck.return_card_and_shuffle(c2)
        print(deck)
        print(deck.contents[-4:])
</code></pre>
<h3>On running, I get the following error:</h3>
<pre><code>We have 8H and KH
50 cards: 9H, 8C, AC, 7C, 6H, 2S, 2D, 5C, 10H, 5H, JS, 5S, KD, JH, JC, QS, 2H, 3H, 3S, 3D, 4C, 4H, AD, KS, JD, QH, 10D, 6S, 5D, 8D, 3C, 6C, 7D, AS, 7H, AH, 9S, 10C, QC, QD, 7S, 2C, KC, 8S, 4D, 4S, 6D, 10S, 9D, 9C
51 cards: QS
[7D, 5C, 10H, QS]
52 cards: 10C
[KC, 3S, 9H, 10C]
We have 2C and QD
Traceback (most recent call last):
  File "playing_cards.py", line 106, in &lt;module&gt;
    print(deck)
  File "playing_cards.py", line 88, in __str__
    for card in self:
  File "playing_cards.py", line 73, in __next__
    item = self.contents[self.index]
IndexError: list index out of range
</code></pre>
<p>It seems the thing doesn't for the second run of the for loop when I push the card object back into the list. How do I solve this while keeping the pop,push functionality.</p>
<p>Edit: The <code>self.index</code> is at 50 after the first call to <code>print()</code>. When the card is added back to list, index remains at 50, whereas the deck length is now 51 cards. So in the second (and third) call to print the last card is printed instead of the entire deck. Then subsequently error is raised.</p>
<p>I think I have read the <a href="https://docs.python.org/3/tutorial/classes.html#iterators" rel="nofollow noreferrer">documentation</a> wrong here. My question is should I reset the index at the <code>StopIteration</code> bit. Is that the correct way to do this, or is the index supposed to reset on its own?</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Note:</strong> If you are trying to learn how iterators work by implementing your own, then the above advice holds. If you just want to make your <code>Deck</code> iterable, you can just do this in <code>Deck</code>:</p>
<pre><code>def __iter__(self):
    return self.contents  # lists are already iterable
</code></pre>
<p>Even better, if you want your deck to behave like a list (iterating, indexing, slicing, removal), you can just extend <code>list</code>.</p>
<p><strong>Learning how iterators work:</strong></p>
<p>The problem you have here is you are conflating a collection with an iterator. A collection should hold a group of items. Your <code>Deck</code> is a collection. A collection is iterable, which means I can do <code>for x in collection</code> on it. When we do <code>for x in collection</code>, Python actually does <code>for x in iter(collection)</code>, which turns the collection into an iterator.</p>
<p>You want your iterator and collection to be separate. If you collection was its own iterator, then you can only have one iterator over it at a time (itself). Also note that iterators should only be used once. By doing <code>self.index = 0</code> in your <code>__iter__</code>, you are making your iterator (<code>Deck</code>) reusable.</p>
<p>Consider the following:</p>
<pre><code>nums = [1, 2, 3]

for i in nums:
    for j in nums:
        print(i, j)
</code></pre>
<p>We expect this to return:</p>
<pre><code>1 1
1 2
1 3
2 1
2 2
2 3
3 1
3 2
3 3
</code></pre>
<p>Note that each time the inner loop iterates over the whole collection. If <code>nums</code> was its own iterator, then we'd have some issues:</p>
<pre><code># Here internally nums sets the current index as 0
for i in nums:
   # Here internally nums sets the current index as 0 again
   for j in nums:
       print(i, j)

   # Once this inner loop finishes the current index is 4.
   # But that is also the index for the outer loop, so the
   # outer loop ends too
</code></pre>
<p>Unexpected output:</p>
<pre><code>1 1
1 2
1 3
</code></pre>
<p>The solution is <code>Deck.__iter__</code> should return a new object called <code>DeckIterator</code>, which keeps track of its own <code>index</code>. <code>DeckIterator.__iter__</code> should return self (as <a href="https://docs.python.org/3.3/reference/datamodel.html#object.__iter__" rel="nofollow noreferrer">required by the docs</a>), but that is just a detail. By doing this you enable multiple iterations over the deck at once that work as expected.</p>
<p>So a minimal example of this would be:</p>
<pre><code>class Deck:
    # ... snip ...

    def __iter__(self):
        return DeckIterator(self.contents)

class DeckIterator:
    def __init__(self, cards):
        self.index = 0
        self.cards = cards

    def __iter__(self):
        return self

    def __next__(self):
        if self.index &gt;= len(self.cards):
            # We've gotten the end of the deck/list
            raise StopIteration

        item = self.cards[self.index]
        self.index += 1
        return item
</code></pre>
<p>Also, if you don't believe me about this list as its own iterator, here's a list that exhibits this bad behavior:</p>
<pre><code>class BadList(list):
    def __iter__(self):
        self._current_index = 0
        return self

    def __next__(self):
        print(f'current index is {self._current_index}', end='')

        if self._current_index &gt;= len(self):
            print(' which is the end, so ending iteration')
            raise StopIteration

        item = self[self._current_index]
        print(f' so returning value {item}')
        self._current_index += 1
        return item

# Using letters instead of numbers so difference between indices
# and items is more clear
letters = BadList('abc')

for i in letters:
    for j in letters:
        print(i, j)
</code></pre>
<p>Output from it:</p>
<pre><code>current index is 0 so returning value "a"
current index is 0 so returning value "a"
a a
current index is 1 so returning value "b"
a b
current index is 2 so returning value "c"
a c
current index is 3 which is the end, so ending iteration
current index is 3 which is the end, so ending iteration
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not sure how you got there, but you are beyond the length of your list.  Suggest you compare for <code>&gt;=</code> length of the list like:</p>
<pre><code>def __next__(self):
    if self.index &gt;= len(self.contents):
        raise StopIteration
    .....
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Make the following changes,</p>
<pre><code>def __iter__(self):
    self.index = 0
    return self
</code></pre>
<p>So that each time <code>__iter__</code> is called, <code>index</code> is reset.
The reason your'e getting this error is, once you iterate through the <code>deck</code>, at the end of the iteration, <code>self.index == len(self.contents)</code>.</p>
<p>The next time you iterate, the <code>self.index</code> should be reset to <code>0</code>.</p>
<p>I made the above change and it worked for me.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your specific issue at the moment is caused by the check in your <code>__next__</code> method not being general enough to detect all situations where you've iterated past the last value in <code>self.contents</code>. Since <code>self.contents</code> can change, you need to use a greater-than-or-equal test:</p>
<pre><code>if self.index &gt;= len(self.contents):
</code></pre>
<p>This will fix the current issue, but you'll still have other problems, since your <code>Deck</code> can only be iterated once. That's because you've implemented the iterator protocol, rather than the iterable protocol.  These are easy to confuse, so don't feel bad if you don't understand the difference immediately.</p>
<p>An iterable is any object with an <code>__iter__</code> method that returns an iterator. Some iterables return different iterators each time they're called, so you can iterate on them multiple times.</p>
<p>An iterator implements a <code>__next__</code> method, which yields the next value or raises <code>StopIteration</code>. An iterator must also have an <code>__iter__</code> method, which returns itself, which allows an iterator to be used wherever an iterable is expected, though it can only be iterated on once.</p>
<p>For your <code>Deck</code>, it probably makes sense to implement the iterable protocol, and return a separate iterator each time <code>__iter__</code> is called. It's only rarely useful to implement your own iterator type, but if you want to test your knowledge of how the different protocols fit together, it can be interesting:</p>
<pre><code>class Deck:
    def __init__(self):
        self.contents = [Card(suite, rank)
                         for suite in Card.get_suites()
                         for rank in Card.get_ranks()]
        random.shuffle(self.contents)
        # no index here

    def __iter__(self):
        return DeckIterator(self)

    # other methods, but no __next__

class DeckIterator:
    def __init__(self, deck):
        self.deck = deck
        self.index = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.index &gt; len(self.deck):
            raise StopIteration

        value = self.deck.contents[self.index]
        self.index += 1
        return value
</code></pre>
<p>A more practical approach is to have <code>Deck.__iter__</code> borrow some convenient iterator type. For instance, you could do <code>return iter(self.contents)</code> and you'd get an iterator that works exactly like the custom version above. Another option is to make <code>__iter__</code> a generator function, since generator objects are iterators. This can be convenient if you need to do just a little bit of processing on each item as you iterate over it.</p>
</div>
<span class="comment-copy">Why not just <code>return iter(self.contents)</code> in <code>__iter__</code>? No need to reinvent the wheel.</span>
<span class="comment-copy">Actually even better just subclass <code>list</code>. This will give you all of the behavior you want, then you can add deck specific stuff on top.</span>
<span class="comment-copy">As you can see, I am trying to learn how to make an iterable here. I am doing something wrong in the process. reinventing the when is the point of this exercise. I know this can be done in easier ways.</span>
<span class="comment-copy">I didn't see that which is why I made that suggestion :) But in that case, I'd recommend returning a new <code>DeckIterator</code> object that maintains its own position. In the way you have it if you iterate over the Deck within an iteration of the deck you'll have issues. See: <a href="https://docs.python.org/3.3/reference/datamodel.html#object.__iter__" rel="nofollow noreferrer">docs.python.org/3.3/reference/datamodel.html#object.__iter__</a></span>
<span class="comment-copy">So in this case, I should just have <code>__iter__</code> return self.contents and not implement <code>__next__</code>?</span>
