<div class="post-text" itemprop="text">
<p>I have an nested object, <code>a</code>, and want to apply some type of filter on each of its sub-containers:</p>
<pre><code>a = [[1, 2], [3, 4, 5, 6], [7, 7, 8]]
</code></pre>
<p>A function to keep the nested structure but filter to only even elements would look like:</p>
<pre><code>def nested_filter(obj):
    res = []
    for sub_obj in obj:
        even = [i for i in sub_obj if i % 2 == 0]
        res.append(even)
    return res

nested_filter(a)
# [[2], [4, 6], [8]]
</code></pre>
<p>But I would like to create an equivalent generator that uses some form a nested <code>yield</code> to maintain the nested structure of <code>a</code>.</p>
<p>This, for illustration, is exactly what I do not want because it flattens <code>a</code>:</p>
<pre><code>def nested_yield(obj):
    """Will flatten the nested structure of obj."""
    for sub_obj in obj:
        for i in sub_obj:
            if i % 2 == 0:
                yield i

list(nested_yield(a))
# [2, 4, 6, 8]
</code></pre>
<p>My understanding was that <code>yield from</code>, <a href="https://docs.python.org/3/whatsnew/3.3.html#pep-380-syntax-for-delegating-to-a-subgenerator" rel="nofollow noreferrer">introduced in Python 3.3</a>, might allow for nesting that retains the structure of the passed object.  But apparently I am misinterpreting:</p>
<pre><code>def gen1(obj):
    for sub_obj in obj:
        yield from gen2(sub_obj)


def gen2(sub_obj):
    for i in sub_obj:
        if i % 2 == 0:
            yield i

list(gen1(a))
# [2, 4, 6, 8]
</code></pre>
<p>So, is there any way I can use two generator functions (i.e. not create intermediate lists) so that calling the generator would give me this:</p>
<pre><code>list(nested_generator(a))
# [[2], [4, 6], [8]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You want your <code>nested_generator</code> to return a list of sublists.  In this case, you cannot get around creating temporary lists at the inner level.</p>
<p>So, your best option is to yield the filtered list:</p>
<pre><code>&gt;&gt;&gt; def nested_filter(L):
    for l in L:
        yield [i for i in l if i % 2 == 0]


&gt;&gt;&gt; a = [[1, 2], [3, 4, 5, 6], [7, 7, 8]]
&gt;&gt;&gt; list(nested_filter(a))
[[2], [4, 6], [8]]
</code></pre>
<p>If you want to use a second generator to filter your sub-list, you can convert the iterator returned to a list and <code>yield</code> that as well:</p>
<pre><code>&gt;&gt;&gt; def generator_filter(L):
    for n in L:
        if n % 2 == 0:
            yield n


&gt;&gt;&gt; def nested_filter(L):
    for l in L:
        yield list(generator_filter(l))


&gt;&gt;&gt; a = [[1, 2], [3, 4, 5, 6], [7, 7, 8]]
&gt;&gt;&gt; list(nested_generator(a))
[[2], [4, 6], [8]]
</code></pre>
</div>
<span class="comment-copy">You'll still have to yield lists from <code>gen1</code></span>
<span class="comment-copy">From the <code>list(nested_generator(a))</code> statement it appears you want <code>nested_generator(a)</code> to return a list of sublists, which implies that the data from second-level lists requires creating a <code>list</code> to return (with the filtered elements removed). The items from the sublists could be obtained via a generator, but there's no way to avoid creating a temporary sub<code>list</code> to hold and return the results.</span>
<span class="comment-copy">Got it @martineau.  Sometimes "no can do" is a correct answer in itself.</span>
<span class="comment-copy">True, I guess that's what I'm saying, but see no need to also post it as a formal answer. I see you've noticed that the one answer you've gotten so far creates temporary lists to <code>yield</code>.</span>
