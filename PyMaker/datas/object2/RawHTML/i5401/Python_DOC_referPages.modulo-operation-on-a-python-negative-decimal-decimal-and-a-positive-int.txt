<div class="post-text" itemprop="text">
<p>With simple <code>int</code>s:</p>
<pre><code>&gt;&gt;&gt; -45 % 360
315
</code></pre>
<p>Whereas, using a <code>decimal.Decimal</code>:</p>
<pre><code>&gt;&gt;&gt; from decimal import Decimal
&gt;&gt;&gt; Decimal('-45') % 360
Decimal('-45')
</code></pre>
<p>I would expect to get <code>Decimal('315')</code>. </p>
<p>Is there any reason for this? Is there a way to get a consistent behaviour (without patching <code>decimal.Decimal</code>)? (I did not change the context, and cannot find how it could be changed to solve this situation).</p>
</div>
<div class="post-text" itemprop="text">
<p>Python behaves according to IBM's <a href="http://speleotrove.com/decimal/decarith.html" rel="nofollow noreferrer">General Decimal Arithmetic Specification</a>.</p>
<p>The <a href="http://speleotrove.com/decimal/daops.html#refremain" rel="nofollow noreferrer"><strong>remainder</strong></a> is defined as:</p>
<blockquote>
<p><strong>remainder</strong> takes two operands; it returns the remainder from integer division. […]</p>
<p>the result is the residue of the dividend after the operation of calculating integer division as described for <a href="http://speleotrove.com/decimal/daops.html#refdivint" rel="nofollow noreferrer"><strong>divide-integer</strong></a>, rounded to precision digits if necessary. The sign of the result, if non-zero, is the same as that of the original dividend.</p>
</blockquote>
<p>So because <code>Decimal('-45') // D('360')</code> is <code>Decimal('-0')</code>, the remainder can only be <code>Decimal('-45')</code>.</p>
<p>Though why is the quotient 0 and not -1? The <a href="http://speleotrove.com/decimal/daops.html#refdivint" rel="nofollow noreferrer">specification</a> says:</p>
<blockquote>
<p><strong>divide-integer</strong> takes two operands; it divides two numbers and returns the integer part of the result. […]</p>
<p>the result returned is defined to be that which would result from repeatedly subtracting the divisor from the dividend while the dividend is larger than or equal to the divisor. During this subtraction, the absolute values of both the dividend and the divisor are used: the sign of the final result is the same as that which would result if normal division were used.  […] </p>
<p>Notes: […]</p>
<ol start="2">
<li>The divide-integer and remainder operations are defined so that they may be calculated as a by-product of the standard <a href="http://speleotrove.com/decimal/daops.html#refdivide" rel="nofollow noreferrer">division</a> operation (described above). The division process is ended as soon as the integer result is available; the residue of the dividend is the remainder.</li>
</ol>
</blockquote>
<p>How many times can you subtract 360 from 45? 0 times. Is an integer result available? It is. Then the quotient is 0 with a minus sign because the <a href="http://speleotrove.com/decimal/daops.html#refdivide" rel="nofollow noreferrer"><strong>divide</strong></a> operation says that</p>
<blockquote>
<p>The <em>sign</em> of the result is the <em>exclusive or</em> of the signs of the operands.</p>
</blockquote>
<p>As for why the Decimal Specification goes on this route, instead of doing it like in math where the remainder is always positive, I'm <em>speculating</em> that it could be for the simplicity of the subtraction algorithm. No need to check the sign of the operands in order to compute the absolute value of the quotient. Modern implementations probably use more complicated algorithms anyway, but simplicity could be have an important factor back in the days when the standard was taking form and hardware was simpler (way fewer transistors). Fun fact: Intel switched from radix-2 integer division to radix-16 only in 2007 with the release of <a href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.217.155" rel="nofollow noreferrer">Penryn</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>After a long search (because searching on "%", "mod", "modulo" etc. gives a thousand of results), I finally found that, surprisingly, <a href="https://docs.python.org/3/library/decimal.html#decimal-objects" rel="nofollow noreferrer">this is intended</a>:</p>
<blockquote>
<p>There are some small differences between arithmetic on Decimal objects
  and arithmetic on integers and floats. When the remainder operator %
  is applied to Decimal objects, the sign of the result is the sign of
  the dividend rather than the sign of the divisor:</p>
<pre><code>&gt;&gt;&gt; (-7) % 4
1
&gt;&gt;&gt; Decimal(-7) % Decimal(4)
Decimal('-3')
</code></pre>
</blockquote>
<p>I don't know the <em>reason</em> for this, but it looks like it's not possible to change this behaviour (without patching).</p>
</div>
<span class="comment-copy">You make it sound like patching is something extreme and to be avoided, but languages like Python give you a lot of room to do this in your own code (subclasses, magic "dunder" methods, wrappers, etc.). And of course you can always do the simple but effective workaround of writing your own function to use instead of the built-in syntax.</span>
<span class="comment-copy">@JohnY Sorry about that, I didn't mean to sound like that; my intent was to let the question not be understood as "How to patch Decimal to get such behaviour?", but instead: "Is there a reason for such a behaviour?" and "Is there any already implemented mean to change this behaviour (e.g. through context settings)?". Maybe I should have mentionned I already implemented a small workaround where I needed it.</span>
<span class="comment-copy">Does <code>Decimal</code> use <code>math.fmod()</code>? They both have the same behaviour.  <a href="https://docs.python.org/3/library/math.html" rel="nofollow noreferrer">From the Python documentation</a>: "For this reason, function fmod() is generally preferred when working with floats, while Python’s x % y is preferred when working with integers."</span>
<span class="comment-copy">@Piinthesky From what I understand in the library's source code, it does <code>import math as _math</code> but then <code>_math</code> is only used to build a <code>Decimal</code> instance from a <code>float</code>. <code>__mod__</code> (as well as other methods, like <code>__truediv__</code>) calculates the quotient and the remainder from a call to <code>Decimal._divide()</code>, that relies on a <code>divmod</code> called on integers. Yet it does not produce the same result... Note that: <code>divmod(-45, 360) == (-1, 315)</code> but <code>divmod(Decimal('-45'), Decimal('360')) == (Decimal('-0'), Decimal('-45'))</code>.</span>
<span class="comment-copy">I think @Mr.T is on the right track by mentioning <code>fmod</code>. Even if the <i>implementation</i> of <code>Decimal</code> doesn't touch <code>fmod</code> at all, it seems at least plausible that the intention was to emulate the <i>behavior</i> of <code>fmod</code>.</span>
<span class="comment-copy">Sorry for the edits. I thought that adding an excerpt would clarify things enough, but then I discovered it was a bit more complicated, so I added my own answer.</span>
