<div class="post-text" itemprop="text">
<p>I have two DataFrames which I want to merge based on a column. However, due to alternate spellings, different number of spaces, absence/presence of diacritical marks, I would like to be able to merge as long as they are similar to one another.</p>
<p>Any similarity algorithm will do (soundex, Levenshtein, difflib's). </p>
<p>Say one DataFrame has the following data:</p>
<pre><code>df1 = DataFrame([[1],[2],[3],[4],[5]], index=['one','two','three','four','five'], columns=['number'])

       number
one         1
two         2
three       3
four        4
five        5

df2 = DataFrame([['a'],['b'],['c'],['d'],['e']], index=['one','too','three','fours','five'], columns=['letter'])

      letter
one        a
too        b
three      c
fours      d
five       e
</code></pre>
<p>Then I want to get the resulting DataFrame</p>
<pre><code>       number letter
one         1      a
two         2      b
three       3      c
four        4      d
five        5      e
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Similar to @locojay suggestion, you can apply <a href="http://docs.python.org/2/library/difflib.html" rel="noreferrer"><code>difflib</code></a>'s <a href="http://docs.python.org/2/library/difflib.html#difflib.get_close_matches" rel="noreferrer"><code>get_close_matches</code></a> to <code>df2</code>'s index and then apply a <a href="http://pandas.pydata.org/pandas-docs/dev/merging.html#joining-on-index" rel="noreferrer"><code>join</code></a>:</p>
<pre><code>In [23]: import difflib 

In [24]: difflib.get_close_matches
Out[24]: &lt;function difflib.get_close_matches&gt;

In [25]: df2.index = df2.index.map(lambda x: difflib.get_close_matches(x, df1.index)[0])

In [26]: df2
Out[26]: 
      letter
one        a
two        b
three      c
four       d
five       e

In [31]: df1.join(df2)
Out[31]: 
       number letter
one         1      a
two         2      b
three       3      c
four        4      d
five        5      e
</code></pre>
<p>.</p>
<p>If these were columns, in the same vein you could apply to the column then <a href="http://pandas.pydata.org/pandas-docs/dev/merging.html#database-style-dataframe-joining-merging" rel="noreferrer"><code>merge</code></a>:</p>
<pre><code>df1 = DataFrame([[1,'one'],[2,'two'],[3,'three'],[4,'four'],[5,'five']], columns=['number', 'name'])
df2 = DataFrame([['a','one'],['b','too'],['c','three'],['d','fours'],['e','five']], columns=['letter', 'name'])

df2['name'] = df2['name'].apply(lambda x: difflib.get_close_matches(x, df1['name'])[0])
df1.merge(df2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I have written a Python package which aims to solve this problem:</p>
<p><code>pip install fuzzymatcher</code></p>
<p>You can find the repo <a href="https://github.com/RobinL/fuzzymatcher" rel="noreferrer">here</a> and docs <a href="https://github.com/RobinL/fuzzymatcher/blob/master/examples.ipynb" rel="noreferrer">here</a>.</p>
<p>Basic usage:</p>
<p>Given two dataframes <code>df_left</code> and <code>df_right</code>, which you want to fuzzy join, you can write the following:</p>
<pre><code>from fuzzymatcher import link_table, left join

# Columns to match on from df_left
left_on = ["fname", "mname", "lname",  "dob"]

# Columns to match on from df_right
right_on = ["name", "middlename", "surname", "date"]

# The link table potentially contains several matches for each record
fuzzymatcher.link_table(df_left, df_right, left_on, right_on)
</code></pre>
<p>Or if you just want to link on the closest match:</p>
<pre><code>fuzzymatcher.fuzzy_left_join(df_left, df_right, left_on, right_on)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would use Jaro-Winkler, because it is one of the most performant and accurate approximate string matching algorithms currently available [<a href="http://dc-pubs.dbs.uni-leipzig.de/files/Cohen2003Acomparisonofstringdistance.pdf" rel="noreferrer">Cohen, et al.</a>], [<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.7347" rel="noreferrer">Winkler</a>].</p>
<p>This is how I would do it with Jaro-Winkler from the <a href="https://pypi.python.org/pypi/jellyfish" rel="noreferrer">jellyfish</a> package:</p>
<pre><code>def get_closest_match(x, list_strings):

  best_match = None
  highest_jw = 0

  for current_string in list_strings:
    current_score = jellyfish.jaro_winkler(x, current_string)

    if(current_score &gt; highest_jw):
      highest_jw = current_score
      best_match = current_string

  return best_match

df1 = pandas.DataFrame([[1],[2],[3],[4],[5]], index=['one','two','three','four','five'], columns=['number'])
df2 = pandas.DataFrame([['a'],['b'],['c'],['d'],['e']], index=['one','too','three','fours','five'], columns=['letter'])

df2.index = df2.index.map(lambda x: get_closest_match(x, df1.index))

df1.join(df2)
</code></pre>
<p>Output:</p>
<pre><code>    number  letter
one     1   a
two     2   b
three   3   c
four    4   d
five    5   e
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://pandas.pydata.org/pandas-docs/dev/merging.html" rel="noreferrer">http://pandas.pydata.org/pandas-docs/dev/merging.html</a> does not have a hook function to do this on the fly. Would be nice though...</p>
<p>I would just do a separate step and use difflib getclosest_matches to create a new column in  one of the 2 dataframes and the merge/join on the fuzzy matched column </p>
</div>
<div class="post-text" itemprop="text">
<p>As a heads up, this basically works, except if no match is found, or if you have NaNs in either column. Instead of directly applying <code>get_close_matches</code>, I found it easier to apply the following function. The choice of NaN replacements will depend a lot on your dataset. </p>
<pre><code>def fuzzy_match(a, b):
    left = '1' if pd.isnull(a) else a
    right = b.fillna('2')
    out = difflib.get_close_matches(left, right)
    return out[0] if out else np.NaN
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://github.com/d6t/d6tjoin" rel="nofollow noreferrer">d6tjoin</a> for that</p>
<pre><code>import d6tjoin.top1
d6tjoin.top1.MergeTop1(df1.reset_index(),df2.reset_index(),
       fuzzy_left_on=['index'],fuzzy_right_on=['index']).merge()['merged']
</code></pre>
<p><code>
   index  number index_right letter
0    one       1         one      a
1    two       2         too      b
2  three       3       three      c
3   four       4       fours      d
4   five       5        five      e
</code></p>
<p>It has a variety of additional features such as:</p>
<ul>
<li>check join quality, pre and post join</li>
<li>customize similarity function, eg edit distance vs hamming distance</li>
<li>specify max distance</li>
<li>multi-core compute</li>
</ul>
<p>For details see</p>
<ul>
<li><a href="https://github.com/d6t/d6tjoin/blob/master/examples-top1.ipynb" rel="nofollow noreferrer">MergeTop1 examples</a> - Best match join examples notebook</li>
<li><a href="https://github.com/d6t/d6tjoin/blob/master/examples-prejoin.ipynb" rel="nofollow noreferrer">PreJoin examples</a> - Examples for diagnosing join problems</li>
</ul>
</div>
<span class="comment-copy">I just merged a few hundred DataFrames yesterday using <code>.rename</code>, usually this is quite a quick solution (although I guess it depends how many misspelling there are...) - and I like to control what column names are truly similar.</span>
<span class="comment-copy">Perhaps I should have been clearer (will edit question now). I want to merge on similar values between two DataFrames</span>
<span class="comment-copy">Yes with <a href="https://github.com/d6t/d6tjoin" rel="nofollow noreferrer">d6tjoin</a> see <a href="https://github.com/d6t/d6tjoin/blob/master/examples-top1.ipynb" rel="nofollow noreferrer">MergeTop1 notebook</a></span>
<span class="comment-copy">That's great. While locojay provided the basic idea (and faster) your example implementation gets the answer accepted. Makes it all the easier to test. Upvote for providing both index and column based answers!</span>
<span class="comment-copy">Does anyone know if there is a way to do this between rows of one column? I'm trying to find duplicates that might have typos</span>
<span class="comment-copy">you can use n=1 to limit the results to 1. <a href="https://docs.python.org/3/library/difflib.html#difflib.get_close_matches" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a></span>
<span class="comment-copy">Doesn't work if there are several matches.</span>
<span class="comment-copy">How to go about it if the two dataframes have different lengths?</span>
<span class="comment-copy">how about      def get_closest_match(x, list_strings):         return sorted(list_strings, key=lambda y: jellyfish.jaro_winkler(x, y), reverse=True)[0]</span>
<span class="comment-copy">There any way to speed this up? This code doesn't scale well.</span>
<span class="comment-copy">Could you explain how to use <code>difflib.get_closest_matches</code> to create such a column and then merge on that?</span>
