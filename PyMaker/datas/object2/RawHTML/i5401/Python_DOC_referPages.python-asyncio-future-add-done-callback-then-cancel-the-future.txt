<div class="post-text" itemprop="text">
<p>I have a problem to understand how asyncio works
if I create a future <code>future = asyncio.Future()</code> then add <code>add_done_callback(done_callback)</code> and after that cancel the future
<code>future.cancel()</code> the done_callback not suppose to get fired?
I tried to use the <code>loop.run_forever()</code> but I end up with infinite loop.</p>
<p>I have a small example code:</p>
<pre><code>_future_set = asyncio.Future()


def done_callback(f):
    if f.exception():
        _future_set.set_exception(f.exception)
    elif f.cancelled():
        _future_set.cancel()
    else:
        _future_set.set_result(None)

async def check_stats(future):
    while not future.cancelled():
        print("not done")
        continue
    loop.stop()

def set(future):
    if not _future_set.done():
        future.add_done_callback(done_callback)


loop = asyncio.new_event_loop()
future = loop.create_future()

asyncio.ensure_future(check_stats(future), loop=loop)

set(future)
future.cancel()
loop.run_forever()  # infinite
print(_future_set.cancelled())
</code></pre>
<p>I know something is missing and maybe this is not the behavior but I will be happy for a little help here.</p>
<p>I am using python 3.6</p>
<p>**update
After set is fire and I bind the add_done_callback to the future
when I cancel the future and the state of the future change to cancelled and done then I expect that <code>_future_set</code> will be cancelled too.
and <code>print(_future_set.cancelled())</code> will be True</p>
</div>
<div class="post-text" itemprop="text">
<p>From the docstring (on my unix system) <code>help(loop.run_forever)</code>:</p>
<pre><code>  run_forever() method of asyncio.unix_events._UnixSelectorEventLoop instance
    Run until stop() is called.
</code></pre>
<p>When you call <code>loop.run_forever()</code> the program will not progress beyond that line until <code>stop()</code> is called on the ioloop instance, and there's nothing in your code doing so.</p>
<p><code>loop.run_forever()</code> is essentially doing:</p>
<pre><code>def run_forever(self):
    while not self.stopped:
        self.check_for_things_to_do()
</code></pre>
<p>Without knowing a little more as to what you're trying to achieve, it's hard to help you further. However it seems that you're expecting <code>loop.run_forever()</code> to be asynchronous in the execution of the python code, however this is not the case. The IOLoop will keep looping and check filevents and fire callbacks on futures, and will only return back to the point it's called if it is told to stop looping.</p>
<hr/>
<p>Ah, I realise now what you're expecting to happen. You need to register the futures with the ioloop, either by doing <code>future = loop.create_future()</code> or <code>future = asyncio.Future(loop=loop)</code>. The former is <a href="https://docs.python.org/3/library/asyncio-eventloop.html#futures" rel="nofollow noreferrer">the preferred method</a> for creating futures. <strong>N.B.</strong> the code will still run forever at the <code>loop.run_forever()</code> call unless it is stopped, so your print statement will still never be reached.</p>
<hr/>
<p>Further addendum: If you actually run the code you have in your question, there is an exception being raised at <code>f.exception()</code>, which as <a href="https://www.rinkit.com/products/argon-tableware-set-of-12-stainless-steel-18-0-teaspoons" rel="nofollow noreferrer">as per the docs</a>:</p>
<blockquote>
<p><strong>exception()</strong></p>
<p>Return the exception that was set on this future.</p>
<p>The exception (or None if no exception was set) is returned only if the future is done. If the future has been cancelled, raises CancelledError. If the future isnâ€™t done yet, raises InvalidStateError.</p>
</blockquote>
<p>This means that the invocation of <code>done_callback()</code> is being stopped at the first <code>if f.exception()</code>. So if you switch <code>done_callback()</code> around to read:</p>
<pre><code>def done_callback(f):
    if f.cancelled():
        _future_set.cancel()
    elif f.exception():
        _future_set.set_exception(f.exception)
    else:
        _future_set.set_result(None)
</code></pre>
<p>Then you get the expected output.</p>
</div>
<span class="comment-copy">I am trying to fire done_callback somehow with a random future. After I cancel it the future stats changed to done but nothing happens</span>
<span class="comment-copy">I realised the mistake you're making with the futures not being associated with the ioloop correctly and have updated my answer.</span>
<span class="comment-copy">I did what you told me I change the future to associated with the loop but still after set is done and I add the <code>add_done_callback</code> to the future. I still don't see that something happen.  I fix the run forever just add a method that will close the loop.</span>
<span class="comment-copy">I updated the quesion</span>
<span class="comment-copy">I have further updated the answer.</span>
