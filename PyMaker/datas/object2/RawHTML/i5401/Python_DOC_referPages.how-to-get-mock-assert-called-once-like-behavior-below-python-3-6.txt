<div class="post-text" itemprop="text">
<p>How to get <code>unittest.mock.Mock().assert_called_once</code> like behavior with <code>unittest.mock.Mock().assert_called_once_with</code>, as <code>assert_called_once</code> s not available below python 3.6 . </p>
<p>Basically what I want is checking if the method gets called exactly once, no matter with which argument or how many argument. </p>
<p>I tried <code>unittest.mock.ANY</code>, but seems it isn't what I want.   </p>
</div>
<div class="post-text" itemprop="text">
<p>All that <code>assert_called_once()</code> does is assert that the <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.call_count" rel="nofollow noreferrer"><code>Mock.call_count</code> attribute</a> is 1; you can trivially do the same test:</p>
<pre><code>self.assertEqual(
    mock_object.call_count, 1,
    "Expected mock to have been called once. Called {} times.".format(
        mock_object.call_count))
</code></pre>
<p>If you tried to use <code>Mock.assert_called_once_with()</code> with the <code>ANY</code> object, take into account that that object stands for the value of <strong>one of the arguments</strong>. <code>Mock.assert_called_once_with(ANY)</code> only matches if the object has been called with exactly <em>one argument</em>, and the value of that argument doesn't matter:</p>
<pre><code>&gt;&gt;&gt; from unittest.mock import Mock, ANY
&gt;&gt;&gt; m = Mock()
&gt;&gt;&gt; m(42, 81, spam='eggs')  # 2 positional arguments, one keyword argument
&lt;Mock name='mock()' id='4348527952'&gt;
&gt;&gt;&gt; m.assert_called_once_with(ANY)   # doesn't match, just one positional argument
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/Users/mjpieters/Development/Library/buildout.python/parts/opt/lib/python3.6/unittest/mock.py", line 825, in assert_called_once_with
    return self.assert_called_with(*args, **kwargs)
  File "/Users/mjpieters/Development/Library/buildout.python/parts/opt/lib/python3.6/unittest/mock.py", line 814, in assert_called_with
    raise AssertionError(_error_message()) from cause
AssertionError: Expected call: mock(&lt;ANY&gt;)
Actual call: mock(42, 81, spam='eggs')
</code></pre>
<p>You can't use the <code>ANY</code> object together with the <code>*called_with</code> assertions to mean 'any number of arguments'. Only in an assertion that takes <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.call" rel="nofollow noreferrer"><code>call()</code> objects</a> would <code>ANY</code> be interpreted as <em>any number of arguments</em>; so you could also use <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.assert_has_calls" rel="nofollow noreferrer"><code>Mock.assert_has_calls()</code></a> here, passing in a list with a single <code>ANY</code> element:</p>
<pre><code>&gt;&gt;&gt; m.assert_has_calls([ANY])  # no exception raised
</code></pre>
</div>
<span class="comment-copy">Thanks @Pieters, it worked. But I have a question, why it doesn't work with <code>stats.update_one.assert_called_once_with(ANY)</code> where the original <code>stats.update_one</code> works fine with one argument (takes a dictionary roughly). basically, Here I mocked the <code>update_one</code> method of pymongo.</span>
<span class="comment-copy"><code>assert_called_once_with()</code> only takes actual arguments. You are asserting that the method was called once with one argument, and that one argument doesn't matter. That means it will not match if there were 0 arguments, or more than one, or if there were keyword arguments.</span>
<span class="comment-copy">I see that <code>update_one()</code> takes 2 positional arguments, plus a number of optional keyword arguments. So you'd have to use, at the very least, <code>assert_called_once_with(ANY, ANY)</code>.</span>
<span class="comment-copy">Oh, I understand now. thanks.</span>
