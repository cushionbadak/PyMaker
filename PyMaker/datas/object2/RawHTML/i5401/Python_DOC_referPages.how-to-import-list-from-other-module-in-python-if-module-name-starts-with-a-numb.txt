<div class="post-text" itemprop="text">
<p>Basically there is a file called <code>8puzzle.py</code> and I want to import the file into another file (in the same folder and I cannot change the file name as the file is provided). Is there anyway to do this in Python? I tried usual way <code>from 8puzzle import *</code>, it gives me an error.</p>
<p>Error is: </p>
<pre><code>&gt;&gt;&gt; import 8puzzle
  File "&lt;input&gt;", line 1
    import 8puzzle
           ^
SyntaxError: invalid syntax
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could do</p>
<pre><code>puzzle = __import__('8puzzle')
</code></pre>
<p>Very interesting problem. I'll remember not to name anything with a number.</p>
<p>If you'd like to <code>import *</code> -- you should <a href="https://stackoverflow.com/questions/147507/how-does-one-do-the-equivalent-of-import-from-module-with-pythons-import">check out this question and answer</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The above answers are correct, but as for now, the recommended way is to use <a href="https://docs.python.org/3/library/importlib.html#importlib.import_module" rel="noreferrer"><code>import_module</code></a> function:</p>
<blockquote>
<p><strong><code>importlib.import_module(name, package=None)</code></strong><br/>
  Import a module. The name
  argument specifies what module to import in absolute or relative terms
  (e.g. either <code>pkg.mod</code> or <code>..mod</code>). If the name is specified in relative
  terms, then the package argument must be set to the name of the
  package which is to act as the anchor for resolving the package name
  (e.g. <code>import_module('..mod', 'pkg.subpkg')</code> will import <code>pkg.mod</code>).</p>
<p>The import_module() function acts as a simplifying wrapper around
  <code>importlib.__import__()</code>. This means all semantics of the function are
  derived from <code>importlib.__import__()</code>. The most important difference
  between these two functions is that <code>import_module()</code> returns the
  specified package or module (e.g. <code>pkg.mod</code>), while <code>__import__()</code> returns
  the top-level package or module (e.g. <code>pkg</code>).</p>
<p>If you are dynamically importing a module that was created since the
  interpreter began execution (e.g., created a Python source file), you
  may need to call <code>invalidate_caches()</code> in order for the new module to be
  noticed by the import system.</p>
</blockquote>
<p><a href="https://docs.python.org/3/library/importlib.html#importlib.__import__" rel="noreferrer"><code>__import__</code></a> is not recommended now.</p>
<blockquote>
<p><strong><code>importlib.__import__(name, globals=None, locals=None, fromlist=(), level=0)</code></strong><br/>
  An implementation of the built-in <code>__import__()</code> function.</p>
<p>Note Programmatic importing of modules should use <code>import_module()</code> instead of this function.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Don't use the <code>.py</code> extension in your imports.</p>
<p>Does <code>from 8puzzle import *</code> work?</p>
<p>For what it's worth, <code>from x import *</code> is not a preferred Python pattern, as it bleeds that module's namespace into your current context.</p>
<p>In general, try to import things you specifically want from that module.  Any global from the other module can be imported.</p>
<p>e.g., if you have <code>8puzzle.foo</code> you could do `from 8puzzle import </p>
<h3>Edit:</h3>
<p>While my <code>.py</code> message is correct, it isn't sufficient.</p>
<p>The other poster's <code>__import__('8puzzle')</code> suggestion is correct.  However, <strong>I highly recommend avoiding this pattern</strong>.</p>
<p>For one, it's reserved an internal, private Python method.  <em>You are basically breaking the fundamental assumptions of what it means to be able to import a module.</em>  Simply renaming the file to something else, like <code>puzzle8</code>, will remedy this.</p>
<p>This will frustrate the hell out of experienced Python programmers who are expecting to know what your imports are at the top and are expecting code to (try to) conform to <a href="http://www.python.org/dev/peps/pep-0008/" rel="nofollow">PEP8</a>.</p>
</div>
<span class="comment-copy">Why do people say "it gives me [an] error" and then not post what the error is?</span>
<span class="comment-copy">@JohnZwinck It's a syntax error. I'm guessing because "8puzzle" isn't a valid identifier (it starts with a number), and the syntax for the import statement expects a Python identifier there. Which would make the answer "No, you can't. Rename the module to something that starts with a letter or an underscore."</span>
<span class="comment-copy">John made the good point, I will keep in mind. And thanks Abhijeet add the error message for me. Thanks.</span>
<span class="comment-copy">Rename <code>8puzzle.py</code> to <code>puzzle8.py</code> and use <code>import puzzle8</code>.</span>
<span class="comment-copy">See also <a href="http://stackoverflow.com/questions/6811902/import-arbitrary-named-file-as-a-python-module-without-generating-bytecode-file" title="import arbitrary named file as a python module without generating bytecode file">stackoverflow.com/questions/6811902/â€¦</a></span>
<span class="comment-copy">works great! thanks. yeah, I would not name it start with a number, but it is a course assignment handout file, so I cannot change the name. But it seems doesn't matter though as we already got the solution for it. Thanks again.</span>
<span class="comment-copy">Help save the world, or at least your classmates. If you get handed an impossible import, bring it to the instructor's attention. Yeah, sometimes they hate being wrong, but if you are having this problem, so is everyone else and although this answer works, it is not the right solution (unless the class is "Obfuscated Python 101").</span>
<span class="comment-copy">A better way (with python 2.7 at least) is to use the 'importlib' module : puzzle = importlib.import_module('8puzzle')</span>
<span class="comment-copy">There is actually a good use case for this - as part of compiling/productionizing process, concatenating python modules together is easiest if they are named in lexigraphical form (generally it doesn't matter, but constants and imports at the top, 'if <b>name</b>' at bottom, so a few modules that start with '0' can be useful.) Also useful in debugging such an unusual directory layout, when combined with inotify or watch, something like: watch -n .1 'cat * | python', which would load your python app every tenth of a second (or at least as fast as possible), or: cat $(find . -name "*.py") | python</span>
<span class="comment-copy">This doesn't work since the module starts with a number.</span>
<span class="comment-copy">sorry about the confusing. What I did was <code>from 8puzzle import *</code> and I edited my original question. And it doesn't work as mvanveen said.</span>
<span class="comment-copy">That is my bad.  I forgot that module filenames can't start witha  number.  I've posted an edit.</span>
