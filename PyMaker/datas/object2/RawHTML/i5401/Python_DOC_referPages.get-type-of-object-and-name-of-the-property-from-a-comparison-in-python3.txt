<div class="post-text" itemprop="text">
<p>This is the definition of classes:</p>
<pre><code>class Child:
    pass
class Parent:
    child = Child()
</code></pre>
<p>where <code>Child</code> can have different <code>args</code> and <code>kwargs</code>, so please do not consider this notation: <code>child = Child(Parent, 'child')</code></p>
<p>After an assignment like:</p>
<pre><code>result = Parent.child &gt; 1
</code></pre>
<p>where <code>Parent</code> is a type (not an instance)</p>
<p><strong>result</strong> should be:</p>
<pre><code>{
    'type': Parent,
    'property': 'child',
    'action': '&gt;',
    'value': 1,
}
</code></pre>
<p>I'm not sure if it's possible at all, but is there anybody who knows a trick?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, it's possible, but you need to store the parent reference in the child object explicitly. The <code>&gt;</code> operator can be hooked into with the <a href="https://docs.python.org/3/reference/datamodel.html#object.__gt__" rel="nofollow noreferrer"><code>__gt__</code> method</a>.</p>
<p>Since you are producing output that contains <em>dynamic</em> information on the <code>child</code> attribute, you could produce a <em>dynamic</em> child object, using the <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattr__" rel="nofollow noreferrer"><code>__getattr__</code> method</a>, which is called whenever an otherwise non-existing attribute is accessed:</p>
<pre><code>class Child:
    def __init__(self, parent_type, attr_name):
        self._parent_type = parent_type
        self._parent_attr_name = attr_name

    def __gt__(self, other):
        return {
            'type': self._parent_type,
            'property': self._parent_attr_name,
            'action': '&gt;',
            'value': other,
        }

class Parent:
    def __getattr__(self, name):
        return Child(type(self), name)
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; Parent().child &gt; 1
{'type': &lt;class '__main__.Parent'&gt;, 'property': 'child', 'action': '&gt;', 'value': 1}
</code></pre>
<p>If <code>Parent</code> <em>must</em> be a class (why?) then use a fixed attribute (<code>child = Child(Parent, 'child')</code>), or use a metaclass:</p>
<pre><code>class ParentMeta(type):
    def __getattr__(cls, name):
        return Child(cls, name)

class Parent(metaclass=ParentMeta):
    pass
</code></pre>
<p>at which point you get the same effect, but without creating an instance:</p>
<pre><code>&gt;&gt;&gt; Parent.child &gt; 1
{'type': &lt;class '__main__.Parent'&gt;, 'property': 'child', 'action': '&gt;', 'value': 1}
</code></pre>
<p>As of Python 3.6 onwards, you also use the <a href="https://docs.python.org/3/reference/datamodel.html#object.__set_name__" rel="nofollow noreferrer"><code>__set_name__</code> hook</a> to capture the type of the class on which your attribute is defined:</p>
<pre><code>class Child:
    def __set_name__(self, owner, attr_name):
        self._parent_type = owner
        self._parent_attr_name = attr_name

    def __gt__(self, other):
        return {
            'type': self._parent_type,
            'property': self._parent_attr_name,
            'action': '&gt;',
            'value': other,
        }
</code></pre>
<p>Note that these attributes are not set in the <code>__init__</code>! You create the child object as an attribute on the class, at which point the <code>__set_name__</code> method is called automatically. The output is again the same:</p>
<pre><code>&gt;&gt;&gt; class Parent:
...     child = Child()
...
&gt;&gt;&gt; Parent.child &gt; 1
{'type': &lt;class '__main__.Parent'&gt;, 'property': 'child', 'action': '&gt;', 'value': 1}
</code></pre>
<p>Note that <em>subclasses</em> are not going to be reflected in the parent type; you'd have to use the <a href="https://docs.python.org/3/reference/datamodel.html#object.__get__" rel="nofollow noreferrer"><code>__get__</code> method</a> to capture the current type each time and return a wrapper object:</p>
<pre><code>class ChildWrapper:
    def __init__(self, child, parent_type):
        self._child = child
        self._parent_type = parent_type

    def __getattr__(self, name):
        return getattr(self._child, name)

    def __gt__(self, other):
        return {
            'type': self._parent_type,
            'property': self._child._parent_attr_name,
            'action': '&gt;',
            'value': other,
        }

class Child:
    def __set_name__(self, owner, attr_name):
        self._parent_attr_name = attr_name

    def __get__(self, instance, owner):
        return ChildWrapper(self, owner)
</code></pre>
<p>This creates a <code>ChildWrapper()</code> instance on each attribute access (on the class or an instance), and all further attribute access is delegated back to the original <code>Child()</code> instance (but note that special methods <a href="https://docs.python.org/3/reference/datamodel.html#special-method-lookup" rel="nofollow noreferrer">can't be proxied this way</a>):</p>
<pre><code>&gt;&gt;&gt; class Parent:
...     child = Child()
...
&gt;&gt;&gt; Parent.child
&lt;__main__.ChildWrapper object at 0x10fc564e0&gt;
&gt;&gt;&gt; Parent.child &gt; 1
{'type': &lt;class '__main__.Parent'&gt;, 'property': 'child', 'action': '&gt;', 'value': 1}
</code></pre>
<p>Because the <code>ChildWrapper</code> is created each time based on the object it was accessed on, this works with subclassing too, tracking the <em>current</em> type:</p>
<pre><code>&gt;&gt;&gt; class Subclass(Parent):
...     pass
...
&gt;&gt;&gt; Subclass.child &gt; 1
{'type': &lt;class '__main__.Subclass'&gt;, 'property': 'child', 'action': '&gt;', 'value': 1}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For future references:</p>
<pre><code>class BaseChild:
    type = None
    property = None

    def __gt__(self, other):
        return {
            'type': self.type,
            'property': self.property,
            'action': '&gt;',
            'value': other,
        }


class MetaParent(type):
    def __new__(mcs, name, bases, attrs):
        cls = super().__new__(mcs, name, bases, attrs)

        # This is the needed trick
        for name, attr in attrs.items():
            if isinstance(attr, BaseChild):
                attr.type = cls
                attr.property = name

        return cls


class SomeChild(BaseChild):
    pass


class Parent(metaclass=MetaParent):
    first_child = SomeChild()


print(Parent.first_child &gt; 1)
</code></pre>
<p>Result:</p>
<pre><code>{'type': &lt;class '__main__.Parent'&gt;, 'value': 1, 'property': 'first_child', 'action': '&gt;'}
</code></pre>
</div>
<span class="comment-copy">Yeah that is possible. Any attempt from your side?</span>
<span class="comment-copy">No, there's no trick. You have to actually code it to do that.</span>
<span class="comment-copy">@WillemVanOnsem I've made a few attempts, but none of them worked out, so I didn't publish them here</span>
<span class="comment-copy">not exactly what I'm searching for. Reasons: 1. Here you usean instance of Parent, not the type itself; 2. In the Parent.__getattr__() you hardcoded Child, while there can be different classes (but I've got the idea will make a few attempts)</span>
<span class="comment-copy">@VasylBratushka: then <b>be clearer in your question</b>. Why does it <b>have</b> to be a class object? You can always use a <i>metatype</i> to hook the <code>__getattr__</code> call, or just use <code>child = Child(Parent, 'child')</code> to hard-code the attribute.</span>
<span class="comment-copy"><code>child = Child(Parent, 'child'</code> is definitely a working option and resolves all the issue, but smells really bad. Just imagine there's 10 different <code>Child</code> (or its descendants) properties in the Parent descendant - in each of them you'll have to put those 2 properties. Other than that - <code>Child</code> can have several other arguments in the <code>__init__</code>. I was looking for a solution without the 2 extra arguments. Sorry for not being clear enough in the question, will add this right now.</span>
<span class="comment-copy">@VasylBratushka: the point is that if you want to include the information about parent (class name, attribute name) you have no choice but to pass that through.</span>
<span class="comment-copy">this is exactly the reason why I asked this here. If there's no way to solve this without passing info through - the answer to this post is "no, it's impossible". Thanks for your efforts, I appreciate it.</span>
