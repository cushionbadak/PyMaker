<div class="post-text" itemprop="text">
<p>I'd like to capture <em>n</em> times a pattern that repeats itself <em>n</em> times, with <code>n &gt;= 0</code>. I have strings that look like this:</p>
<pre><code>a = 'x="2"'
b = 'x="2,3", y="hello", z="true"'
</code></pre>
<p>I'd like to extract 'x' and its value '2,3', 'y' and its value 'hello', etc. Variables are separated by a comma followed by a space; values are inside double quotes.</p>
<p>How I can do this with the <code>re</code> library in Python?</p>
<p>I tried naively with the following:</p>
<pre><code>match = re.search(r'^((?P&lt;variable&gt;[0-9a-zA-Z_-]+)="(?P&lt;value&gt;.*)"(?:,\s)?)*', b)
</code></pre>
<p>If I print <code>match.groupdict()</code>, it'll output:</p>
<pre><code>{'variable': 'x', 'value': '2,3", y="hello", z="true'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The reason you're getting more than you bargained for is that you're matching (with group naming removed):</p>
<pre><code>".*"
</code></pre>
<p>Since regexes use greedy matching by default, it's going to grab as much text as possible as long as it can tack on a <code>"</code> at the end, even if the intervening text also contains <code>"</code>. You can either make it a non-greedy match:</p>
<pre><code>"(?P&lt;value&gt;.*?)"
</code></pre>
<p>Or greedily match non-<code>"</code> characters:</p>
<pre><code>"(?P&lt;value&gt;[^"]*)"
</code></pre>
<p>The next problem is that you'll find that this only matches the last occurrence of the pattern in the string. If you want to get all unknown number of matches, you'll want <a href="https://docs.python.org/3/library/re.html#re.findall" rel="nofollow noreferrer"><code>re.findall()</code></a>. Unfortunately, <code>findall()</code> doesn't support <code>groupdict</code>. Its cousin <a href="https://docs.python.org/3/library/re.html#re.finditer" rel="nofollow noreferrer"><code>re.finditer()</code></a>, however, returns match objects that have the method:</p>
<pre><code>for match in re.finditer(r'(?P&lt;variable&gt;[0-9a-zA-Z_-]+)="(?P&lt;value&gt;[^"]*)"', b):
    print(match.groupdict())
</code></pre>
<p>Â </p>
<pre><code>{'variable': 'x', 'value': '2,3'}
{'variable': 'y', 'value': 'hello'}
{'variable': 'z', 'value': 'true'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import re

a = 'x="2"'
b = 'x="2,3", y="hello", z="true"'

p = '(\w+)=\"([^\"]*)\"'

ms = re.findall(p, b)
print ms
ms = re.findall(p, a)
print ms
</code></pre>
<p>output:</p>
<pre><code>D:\&gt;python reg.py
[('x', '2,3'), ('y', 'hello'), ('z', 'true')]
[('x', '2')]

D:\&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try Positive Lookbehind in one line</p>
<pre><code>import re
pattern=r'(?&lt;=((\w)=))"(.*?)"'
string="""'x="2,3", y="hello", z="true"'"""

print([(i.group(2),i.group(3)) for i in re.finditer(pattern,string)])
</code></pre>
<p>output:</p>
<pre><code>[('x', '2,3'), ('y', 'hello'), ('z', 'true')]
</code></pre>
</div>
<span class="comment-copy">Split by comma, then one time split by <code>=</code>, then <code>ast.parse_literal()</code> the second item of the last split. No regular expressions needed.</span>
<span class="comment-copy">@KlausD. That fails on the example where the value contains a comma.</span>
