<div class="post-text" itemprop="text">
<p>I have a list built from a string split operation, and I wanted to input it to map() function, then strip these substrings from their trailing parenthesis and spaces.
And rebuild a list from them.  </p>
<pre><code>teststring=" (A) / (B) "
result = list(map(str.strip, teststring.split("/"), " ()"))
</code></pre>
<p>But in the end, I only strip oddly the substrings, while "all combinations are tested", as stated by docs.  </p>
<p>I  know another method is available with list comprehension:</p>
<pre><code>result = [substr.strip(' ()' for substr in teststring.split("/")]  
</code></pre>
<p>which works.. But I wonder why map doesn't work correctly.  </p>
<p>I am on python 3.6.4, with Anaconda 4.4 on windows64.  </p>
<p>Subsidiary question; the following <a href="https://stackoverflow.com/questions/1517347/about-pythons-built-in-sort-method">topic</a> gives some pointers to find source code of functions. But I could not find the code for map (and generally, for builtin functions), so I could not see if there were bugs into it...</p>
</div>
<div class="post-text" itemprop="text">
<p><code>map</code> with 3 arguments is not behaving the way you think it does. The 3rd argument for <code>map</code> is <strong>not</strong> the arguments for the function provided as the 1st argument. It is used as a 2nd iterable.</p>
<p>From the <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p>map(function, iterable, ...) Return an iterator that applies function
  to every item of iterable, yielding the results. If additional
  iterable arguments are passed, function must take that many arguments
  and is applied to the items from all iterables in parallel. With
  multiple iterables, the iterator stops when the shortest iterable is
  exhausted. For cases where the function inputs are already arranged
  into argument tuples, see itertools.starmap()</p>
</blockquote>
<p>In other words:</p>
<p><code>map(str.strip, teststring.split('/'), ' ()')</code> is <strong>not</strong> equivalent to</p>
<p><code>[substr.strip(' ()' for substr in teststring.split('/')]</code>. It is remotely equivalent to</p>
<p><code>[(substr_1.strip(), substr_2.strip()) for (substr_1, substr_2) in zip(teststring.split("/"), ' ()')]</code> </p>
<p>See the difference?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>map</code> works differently from how you are using it. When you do <code>map(f, a, b)</code>, it yields <code>f(a[0], b[0]), f(a[1], b[1]), ...</code>, while you are using it like it will yield <code>f(a[0], b), f(a[1], b), ...</code>.</p>
<p>To fix this, you can use a list comprehension, like in the question, or a lambda like <code>lambda string: string.strip(" ()")</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <code>operator.methodcaller</code>:</p>
<pre><code>list(map(operator.methodcaller('strip',' ()'),teststring.split("/")))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that you seem to be under the impression that the last argument to <code>map</code> gets passed as an argument to the function being mapped, that isn't what happens, instead, from the docs:</p>
<blockquote>
<p>map(func, *iterables) --&gt; map object</p>
<p>Make an iterator that computes the function using arguments from each
  of the iterables.  Stops when the shortest iterable is exhausted.</p>
</blockquote>
<p>In other words, <code>list(map(f, [1,2,3], 'abc'))</code> is the equivalent of:</p>
<pre><code>[f(1,'a'), f(2, 'b'), f(3, 'c')]
</code></pre>
<p>Which is not what you want. You want to <em>partially apply</em> <code>string.strip</code> using <code>" ()"</code> as the second argument, but instead, <code>" ()"</code> is being take as another <em>iterable of arguments</em>. So, straightforward solution, use a helper function:</p>
<pre><code>In [9]: def strip_stuff(s):
   ...:     return s.strip(" ()")
   ...:

In [10]: list(map(strip_stuff, teststring.split("/")))
Out[10]: ['A', 'B']
</code></pre>
<p>You could make a factor function if you will be needing to be flexible:</p>
<pre><code>In [12]: def make_strip(stuff):
    ...:     def strip(s):
    ...:         return s.strip(stuff)
    ...:     return strip
    ...:

In [13]: list(map(make_strip(" ()"), teststring.split("/")))
Out[13]: ['A', 'B']

In [14]: list(map(make_strip("()"), teststring.split("/")))
Out[14]: [' (A) ', ' (B) ']

In [15]: list(map(make_strip(" )"), teststring.split("/")))
Out[15]: ['(A', '(B']

In [16]: list(map(make_strip(" ("), teststring.split("/")))
Out[16]: ['A)', 'B)']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>lambda</code> function it can be achieved as follows:</p>
<pre><code>map(lambda s: s.strip(" ()"), teststring.split("/"))
</code></pre>
</div>
<span class="comment-copy">What do you expect <code>map(str.strip, teststring.split("/"), " ()")</code> to do? When you give <code>map</code> multiple iterables it iterates over them in parallel (like <code>zip</code> does).</span>
<span class="comment-copy">Thanks. I badly misunderstood the "*iterable" in the docs. I think if I did not want to use the list comprehension, I could achieve what I want with a zip and starmap, but indeed list comprehension is better.</span>
<span class="comment-copy">@AndoJurai no, zip+starmap would do the equivalent of what you are doing here! I.E. <code>map(f, iterable1, iterable2)</code> is equivalent to <code>starmap(f, zip(iterable1, iterable2))</code></span>
<span class="comment-copy">I meant using something like starmap(str.strip, zip(teststring.split, repeat(" ()") ) ). starmap works when data is as tuples, but if you input " ()" each time, it is ok.</span>
<span class="comment-copy">Of course, using <code>map</code> with a lambda like that is going to be slower than the equivalent list comp, since the list comp avoids that extra Python function call.</span>
<span class="comment-copy">That's not really useful here!</span>
