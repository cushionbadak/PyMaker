<div class="post-text" itemprop="text">
<p>I use heapq module in python, I find I only can the min heap, even if I use reverse=True </p>
<p>I still get the min top heap</p>
<pre><code>from heapq import *

h=[]
merge(h,key=lambda e:e[0],reverse=True)
heappush(h, (200, 1))
heappush(h, (300,2))
heappush(h, (400,3))
print(heappop(h))
</code></pre>
<p>I still get the result:</p>
<pre><code>(200, 1)
</code></pre>
<p>I want to get result:</p>
<pre><code>(400,3)
</code></pre>
<p>how to do it?</p>
<p>which is the smallest element. I want pop the largest emelment?</p>
<p>ps: this is part of question find the max and then divide into several elements and then put it back to the heap.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/heapq.html" rel="noreferrer">The documentation</a> says,</p>
<blockquote>
<p>Our pop method returns the smallest item, not the largest (called a
  “min heap” in textbooks; a “max heap” is more common in texts because
  of its suitability for in-place sorting).</p>
</blockquote>
<p>So you cannot get a max heap directly. However, one way to get it indirectly is to push the <em>negative</em> of the item on the heap, then take the negative again just after you pop the item. So instead of <code>heappush(h, (200, 1))</code> you execute <code>heappush(h, (-200, -1))</code>. And to pop and print the max item, execute</p>
<pre><code>negmaxitem = heappop(h)
maxitem = (-negmaxitem[0], -negmaxitem[1])
print(maxitem)
</code></pre>
<p>There are other ways to get the same effect, depending on what exactly you are storing in the heap.</p>
<p>Note that trying <code>h[-1]</code> in a min-heap does not work to find the max item--the heap definition does not guarantee the max item will end up at the end of the list. <code>nlargest</code> should work but has time complexity of <code>O(log(n))</code> to just examine the largest item in a min-heap, which defeats the purpose of the heap. My way has time complexity <code>O(1)</code> in the negative-heap to examine the largest item.</p>
</div>
<div class="post-text" itemprop="text">
<p>Why not use a <code>PriorityQueue</code> object? You can store <code>(priority,key)</code> tuples. One easy solution to make a max-heap would be to make <code>priority</code> be the opposite of <code>key</code>:</p>
<pre><code>from Queue import PriorityQueue
pq = PriorityQueue()
for i in range(10): # add 0-9 with priority = -key
    pq.put((-i,i))
print(pq.get()[1]) # 9
</code></pre>
</div>
<span class="comment-copy"><code>nlargest(h, 1)</code>?</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ That's just a bad way to write <code>max(h)</code>.</span>
<span class="comment-copy">I don't understand what you're saying about <code>nlargest</code>. To find the largest element of the iterable you give it, it takes O(n), not O(log(n)).</span>
<span class="comment-copy">Actually, according to the documentation, I think it's actually O(n log n):  "Equivalent to: <code>sorted(iterable, key=key, reverse=True)[:n]</code>"</span>
<span class="comment-copy">@NiemaMoshiri That means same result, not same complexity.  Btw, you just said that asking it for the largest n=1 elements takes O(0) time.</span>
<span class="comment-copy">Ah, wasn't aware it only means the output is equivalent, not the time complexity. Thanks for that! Also, not sure what you mean by O(0) time. Big-O time complexity is a description of asymptotic run-time scalability as <i>n</i> approaches infinity; you don't just plug in a value of <i>n</i></span>
<span class="comment-copy">@NiemaMoshiri I sure can plug in a value of n. Big-O complexity is a "for <b>all</b> n ≥ n₀ statement". So also for n=n₀. I can plug that. You didn't say what n₀ you had in mind, so I assumed n=1 since we're talking about finding the 1 largest value. But it doesn't really matter. Whatever your n₀ is, I can just choose n=n₀ and then O(n log n) = O(n₀ log n₀) = O(1). You're still saying it's constant time, which is wrong.</span>
<span class="comment-copy">pq do not have pop function</span>
<span class="comment-copy">Not sure what you mean. The <code>get()</code> function of a <code>PriorityQueue</code> is equivalent to a heap's <code>pop()</code>: it removes and returns the highest-priority element</span>
<span class="comment-copy">Sorry, I thought it would be delete the highest-priority element before. Thanks for that.</span>
<span class="comment-copy">I can use the index to get the second largest number easy</span>
<span class="comment-copy">How? In a max-heap, the root is the largest element (so you're sure largest element is in index 0), but the second largest element can be either child of the root (so it can be in either index 1 or index 2). If you're sure you <i>only</i> want the largest 2 elements at any given time, I agree that you can do it efficiently: <code>h[0]</code> for the largest and <code>max(h[1],h[2])</code> for the second largest.</span>
