<div class="post-text" itemprop="text">
<p>I'm trying to find duplicates in a list. I want to preserve the values and insert them into a tuple with their number of occurrences. </p>
<p>For example: </p>
<pre><code>list_of_n = [2, 3, 5, 5, 5, 6, 2]
occurance_of_n = zip(set(list_of_n), [list_of_n.count(n) for n in set(list_of_n)])
</code></pre>
<p><code>[(2, 2), (3, 1), (5, 3), (6, 1)]</code></p>
<p>This works fine with small sets. My question is: as list_of_n gets larger, will I have to worry about arg1 and arg2 in zip(arg1, arg2) not lining up correctly if they're the same set? </p>
<p>I.e. Is there a conceivable future where I call zip() and it accidentally aligns index [0] of list_of_n in arg1 with some other index of list_of_n in arg2?</p>
<p>(in case it's not clear, I'm converting the list to a set for purposes of speed in arg2, and under the pretense that zip will behave better if they're the same in arg1)</p>
</div>
<div class="post-text" itemprop="text">
<p>Since your sample output preserves the order of appearance, you might want to go with a <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>collections.OrderedDict</code></a> to gather the counts:</p>
<pre><code>list_of_n = [2, 3, 5, 5, 5, 6, 2]
d = OrderedDict()
for x in list_of_n:
    d[x] = d.get(x, 0) + 1
occurance_of_n = list(d.items())
# [(2, 2), (3, 1), (5, 3), (6, 1)]
</code></pre>
<p>If order does not matter, the appropriate approach is using a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a>:</p>
<pre><code>occurance_of_n = list(Counter(list_of_n).items())
</code></pre>
<p>Note that both approach require only one iteration of the list. Your version could be amended to sth like:</p>
<pre><code>occurance_of_n = list(set((n, list_of_n.count(n)) for n in set(list_of_n)))
# [(6, 1), (3, 1), (5, 3), (2, 2)]
</code></pre>
<p>but the repeated calls to <code>list.count</code> make an entire iteration of the initial list for each (unique) element.</p>
</div>
<span class="comment-copy">Discard all this and use <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a>, which is much more efficient and doesn't have this issue.</span>
<span class="comment-copy">You're creating two different <code>set</code> objects.  There is no guarantee that they will be iterated over in the same order.  If you define a single <code>set</code> beforehand, then there is such a guarantee.  You could do <code>[(n, list_of_n.count(n)) for n in set(list_of_n)]</code> instead, or use a <code>Counter</code></span>
<span class="comment-copy">Do not use <code>[list_of_n.count(n) for n in set(list_of_n)]</code> that is a quadratic algorithm. There are linear algorithms for counting occurrences of items in a list, already implemented for you in <code>collections.Counter</code>.</span>
<span class="comment-copy">See this: <a href="https://stackoverflow.com/questions/2161752/how-to-count-the-frequency-of-the-elements-in-a-list" title="how to count the frequency of the elements in a list">stackoverflow.com/questions/2161752/â€¦</a></span>
<span class="comment-copy">this is in 2.7, does that matter?</span>
<span class="comment-copy">The answer to my question was "no"</span>
