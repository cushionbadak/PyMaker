<div class="post-text" itemprop="text">
<p>I'm developing a set of cryptographic algorithms / protocols for educational purposes. Specifically, I am currently working on OAEP encoding.</p>
<p>OAEP involves use of cryptographic hash functions; therefore I wanted to use the <code>hashlib</code> library, provided in the standard of Python3.</p>
<p>Let's say, I have a 128-bit integer, for which I want to get the SHA256 digest of. How can I do this in Python? All I could found was how to hash strings (or b-strings) with <code>hashlib.sha256()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Hashes work on <em>bytes</em>, a sequence of integer values in the range 0-255; this is independent of the implementation language. You'd have to convert your 128-bit integer into a series of bytes representing that value. That's why the <code>hashlib</code> module only accepts <code>bytes</code> objects ("<code>b</code> values").</p>
<p>How you do this is entirely dependent on the use case; you'd need to see how the specific OAEP standard specifies how such an integer is represented.</p>
<p>For example, you could take the string representation of the decimal integer value; a sequence of ASCII digits; this is not a very efficient method as that can take up to 39 bytes:</p>
<pre><code>&gt;&gt;&gt; import hashlib
&gt;&gt;&gt; 2 ** 128 - 1  # largest 128-bit value
340282366920938463463374607431768211455
&gt;&gt;&gt; len(str(2 ** 128 - 1))
39
&gt;&gt;&gt; str(2 ** 128 - 1).encode('ASCII')  # ascii bytes
b'340282366920938463463374607431768211455'
&gt;&gt;&gt; hashlib.sha256(str(2 ** 128 - 1).encode('ASCII')).hexdigest()
'f315ff319bf588e202110ab686fb8c3dbca12b4df9fbd844615b566a2fff3e75'
</code></pre>
<p>A much more efficient method would be to take those 128 bits, divide them into 16 bytes and hash those. You then need to decide on <a href="https://en.wikipedia.org/wiki/Endianness" rel="nofollow noreferrer">byte order (little or big endian)</a>. If you need to hash multiple integer values, then the Python <a href="https://docs.python.org/3/library/struct.html" rel="nofollow noreferrer"><code>struct</code> module</a> can help with producing the bytes, but only for integer values up to 8 bytes (you'd have to split up your larger numbers first). For single values, just use the <a href="https://docs.python.org/3/library/stdtypes.html#int.to_bytes" rel="nofollow noreferrer"><code>int.to_bytes()</code> method</a>:</p>
<pre><code>&gt;&gt;&gt; (2 ** 128 - 1).to_bytes(16, 'little', signed=False)
b'\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff'
&gt;&gt;&gt; hashlib.sha256((2 ** 128 - 1).to_bytes(16, 'little', signed=False)).hexdigest()
'5ac6a5945f16500911219129984ba8b387a06f24fe383ce4e81a73294065461b'
</code></pre>
</div>
<span class="comment-copy">I understand that; however, an integer is still a series of bytes. I.e. 3 = 00000011 or 16 = 00010000 (or longer integers are just longer series of bits which can be divided into blocks of 8). What I don't understand is, how I should feed this integer into Python's hashlib.sha256() implementation. I do not understand what it expects as argument.</span>
<span class="comment-copy">@OranCan√ñren: that's what my answer tries to convey to you. You <b>represent</b> the numeric value as bytes, and how you do that depends on your use case. The standard would detail what method to use.</span>
