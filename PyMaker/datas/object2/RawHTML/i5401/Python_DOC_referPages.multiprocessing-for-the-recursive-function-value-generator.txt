<div class="post-text" itemprop="text">
<p>I have a simple recursive function and a generator of its values:</p>
<pre><code>def rec(n):
    if n == 1:
        return 1
    else:
        return n + rec(n-1)

lis=[]    
for i in range(1,1000):
    lis.append(rec(i))
</code></pre>
<p>Output: </p>
<pre><code>[1, 3, 6, 10, 15, 21, 28, 36,...]
</code></pre>
<p>Can multiprocessing be used in such a construction?</p>
</div>
<div class="post-text" itemprop="text">
<p>What you describe here is a <em>clean</em> <a href="https://docs.python.org/2/library/functions.html#map" rel="nofollow noreferrer"><strong><code>map</code></strong></a>: you map an iterable of values to a list of values such that <em>x<sub>i</sub></em> in the original list, is mapped on <em>f(x<sub>i</sub>)</em> in the result.</p>
<p>We can use it with a <code>Pool</code>:</p>
<pre><code>from multiprocessing import Pool

def rec(n):
    if n == 1:
        return 1
    else:
        return n + rec(n-1)

pool = Pool(4)

lis = pool.map(rec, range(1,1000))
</code></pre>
<p>Here <code>4</code> is the number of processes that process the request. Ususally this is the number or cores (or a multiple of the number of cores).</p>
<p>Note however that in your case, you can substitute the <code>rec</code> function with:</p>
<pre><code># fast implementation
def rec(n):
    return n*(n+1)//2
</code></pre>
</div>
<span class="comment-copy">Is there a reason why you use such recursive function?</span>
<span class="comment-copy">not exactly the same, but similar to its more complicated problem, which is not needed here because of probably intricate explanations.</span>
<span class="comment-copy">Instead of going from <code>n</code> down to <code>1</code>, would it make sense to go from <code>1</code> to <code>n</code>, yielding along the way?  Your example can be done with <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow noreferrer"><code>itertools.accumulate</code></a></span>
<span class="comment-copy">Before considering multiprocessing, I would try writing a more efficient algorithm. This problem, and their ilks may have a closed form solution or solved efficiently using <a href="https://en.wikipedia.org/wiki/Dynamic_programming" rel="nofollow noreferrer">dynamic programming</a></span>
<span class="comment-copy">thanks. I thought that with recursive functions it will be more complicated :)</span>
