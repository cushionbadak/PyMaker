<div class="post-text" itemprop="text">
<p><strong>Problem:</strong><br/>
You are given a list(1-D array) of scores(some numbers).<br/>
You are given two more lists:<br/>
lowerLimits : A list that contains lower limit value(s)<br/>
upperLimits : A list that contains upper limit value(s)  </p>
<p>Your task is to find out how many counts of scores fall within the inclusive range of each (lowerLimit[i], upperLimit[i]) pair.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Inputs:
scores = [1,3,5,6,8]
lowerLimits = [2]
upperLimits = [6]
Output:[3]
</code></pre>
<p>Explanation:
Three elements(3,5 and 6) in scores array, fall inside the inclusive range [2,6]</p>
<p><strong>Example 2:</strong></p>
<pre><code>Inputs:
scores = [4,8,7]
lowerLimits = [2,4]
upperLimits = [8,4]
Output: [3,1]
</code></pre>
<p>Explanation:
All three elements(4,8 and 7) in scores array, fall inside the first inclusive range [2,8] and only one element (4) falls within the inclusive range of [4,4]. So the answer to be returned is the counts array [3,1].</p>
<p><strong>What algorithm have I attempted so far?</strong></p>
<pre><code>1. Iterate through each lowerLimit - upperLimit pair
2. For this pair check all scores values
3. Repeat step 1 to 2 for all lowerLimit - upperLimit pairs
</code></pre>
<p><strong>Python 3 Implementation</strong></p>
<pre><code># utility function
def jobOffers(scores, lowerLimits, upperLimits):
    answer = []
    for index, item in enumerate(lowerLimits):
        dummy = []
        for score in scores:
            if score &gt;= lowerLimits[index] and score &lt;= upperLimits[index]:
                dummy.append(score)
        if dummy:
            answer.append(len(dummy))
    return answer

# dummy inputs
scores = [4,8,7]
lowerLimits = [2,4]
upperLimits = [8,4]

print(jobOffers(scores,lowerLimits,upperLimits))
</code></pre>
<p><strong>Problem:</strong><br/>
I can only pass 3 out of 15 test cases with this brute-force algorithm. In fact, the code times out for about 7 test cases and returns incorrect result for the remaining failed test cases. Unfortunately, the server doesn't provide the list of failed test cases, so I can't accommodate logic for such cases. At present, I'm unable to think of any alternate strategy to tackle this problem. Could </p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def jobOffers(scores, lowerLimits, upperLimits):
    return [
        len([
            i if i &gt;= lowerLimits[i] and i&lt;= upperLimits[i]
            for i in range(len(lowerLimits))
        ])
    ]
</code></pre>
<p>in short, dummy is not a boolean, and will probably evaluate to false when empty. I assume your script was only correct for empty arrays and arrays with 1 limit?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def jobOffers(scores, lowerLimits, upperLimits):
    pairs = list(zip(lowerLimits, upperLimits))

    result = []
    for x in range(len(pairs)):
        u = pairs[x][0]
        l = pairs[x][1]
        a = [x for x in scores if x in range(u, l + 1)]
        result.append(len(a))

    return result
</code></pre>
<p>what are the other test cases? Hope this helps.</p>
</div>
<div class="post-text" itemprop="text">
<p>If anybody is interested, I found the solution. We are supposed to do binary search for correct indices, this would save time complexity. Here's the solution:</p>
<p><a href="https://raw.githubusercontent.com/reachsumit/digital-data-scientist-hiring-test-powered-by-hackerrank/master/Question%201/confirmed%20solution%20-%20Python/1.%20solution%20(jobOffers).py" rel="nofollow noreferrer">https://raw.githubusercontent.com/reachsumit/digital-data-scientist-hiring-test-powered-by-hackerrank/master/Question%201/confirmed%20solution%20-%20Python/1.%20solution%20(jobOffers).py</a></p>
</div>
<span class="comment-copy">why the question is tagged Java? Is it the alternative language you can use?</span>
<span class="comment-copy">Server allows to submit java code solutions also. So it might help if someone from Java community have a good algorithmic approach to solve this.</span>
<span class="comment-copy">Have you considered using <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer">zip</a> to extract the bounds from the two limit lists?  You could make your conditional expression simpler by <a href="https://docs.python.org/3/reference/expressions.html#comparisons" rel="nofollow noreferrer">chaining</a> the comparisons: <code>if lower &lt;= score &lt;= upper: ...</code></span>
<span class="comment-copy">When the count is zero, <code>dummy == []</code>, are you sure that it is not included in the result?</span>
<span class="comment-copy">You've a good point. Question makes no comment on results when no item matches. If I put 0 in answer list for those cases, it might help with the "incorrect answer" test cases.  And your tip about zip might help with larger test cases that are getting timed out. Thanks.</span>
<span class="comment-copy">The purpose of using "if dummy" is to check if dummy list is empty or not. The code that I've shared in question works well for arrays with more than one members.</span>
<span class="comment-copy">Welcome to SO. Thanks for posting an answer. Please read the info about <a href="https://stackoverflow.com/help/how-to-answer">how to write a good answer</a>.  Your comment is good enough to put as info in your solution. This would have given more body, meaning and validity to it. Please edit your question accordingly. Enjoy SO ;-)</span>
<span class="comment-copy">I found a solution. We are supposed to go about in binary search fashion. Here's the solution: <a href="https://raw.githubusercontent.com/reachsumit/digital-data-scientist-hiring-test-powered-by-hackerrank/master/Question%201/confirmed%20solution%20-%20Python/1.%20solution%20(jobOffers).py" rel="nofollow noreferrer">raw.githubusercontent.com/reachsumit/…</a></span>
<span class="comment-copy">It's kinda the same to me. But correct me if I'm wrong. Is there any  significant performance improvement over my solution? and which part that is binary in ur answer?</span>
<span class="comment-copy">yes, compared to other brute force approaches(functions: jobOffers, jobOffers2) "binary search"-ish function jobOffers3 was faster and I was able to pass all test cases. I don't have the test cases right now to give you a measure. Read through jobOffers3 function to see the difference.</span>
<span class="comment-copy">I am talking about the 3 functions in this code: <a href="https://raw.githubusercontent.com/reachsumit/digital-data-scientist-hiring-test-powered-by-hackerrank/master/Question%201/confirmed%20solution%20-%20Python/1.%20solution%20(jobOffers).py" rel="nofollow noreferrer">raw.githubusercontent.com/reachsumit/…</a></span>
