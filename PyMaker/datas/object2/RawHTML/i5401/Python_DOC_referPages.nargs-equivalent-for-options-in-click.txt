<div class="post-text" itemprop="text">
<p>Is there an equivalent to <code>argparse</code>'s <code>nargs='*'</code> functionality for optional arguments in Click?</p>
<p>I am writing a command line script, and one of the options needs to be able to take an unlimited number of arguments, like:</p>
<pre><code>foo --users alice bob charlie --bar baz
</code></pre>
<p>So <code>users</code> would be <code>['alice', 'bob', 'charlie']</code> and <code>bar</code> would be <code>'baz'</code>.</p>
<p>In <a href="https://docs.python.org/3/library/argparse.html#nargs" rel="nofollow noreferrer"><code>argparse</code></a>, I can specify multiple optional arguments to collect all of the arguments that follow them by setting <code>nargs='*'</code>.</p>
<pre><code>&gt;&gt;&gt; parser = argparse.ArgumentParser()
&gt;&gt;&gt; parser.add_argument('--users', nargs='*')
&gt;&gt;&gt; parser.add_argument('--bar')
&gt;&gt;&gt; parser.parse_args('--users alice bob charlie --bar baz'.split())
Namespace(bar='baz', users=['alice', 'bob', 'charlie'])
</code></pre>
<p>I know Click allows you to specify an argument to <a href="http://click.pocoo.org/6/arguments/#variadic-arguments" rel="nofollow noreferrer">accept unlimited inputs</a> by setting <code>nargs=-1</code>, but when I try to set an optional argument's <code>nargs</code> to -1, I get:</p>
<blockquote>
<p>TypeError: Options cannot have nargs &lt; 0</p>
</blockquote>
<p>Is there a way to make Click accept an unspecified number of arguments for an option?</p>
<h3>Update:</h3>
<p>I need to be able to specify options after the option that takes unlimited arguments.</p>
</div>
<div class="post-text" itemprop="text">
<p>One way to approach what you are after is to inherit from click.Option, and customize the parser.</p>
<h3>Custom Class:</h3>
<pre><code>import click

class OptionEatAll(click.Option):

    def __init__(self, *args, **kwargs):
        self.save_other_options = kwargs.pop('save_other_options', True)
        nargs = kwargs.pop('nargs', -1)
        assert nargs == -1, 'nargs, if set, must be -1 not {}'.format(nargs)
        super(OptionEatAll, self).__init__(*args, **kwargs)
        self._previous_parser_process = None
        self._eat_all_parser = None

    def add_to_parser(self, parser, ctx):

        def parser_process(value, state):
            # method to hook to the parser.process
            done = False
            value = [value]
            if self.save_other_options:
                # grab everything up to the next option
                while state.rargs and not done:
                    for prefix in self._eat_all_parser.prefixes:
                        if state.rargs[0].startswith(prefix):
                            done = True
                    if not done:
                        value.append(state.rargs.pop(0))
            else:
                # grab everything remaining
                value += state.rargs
                state.rargs[:] = []
            value = tuple(value)

            # call the actual process
            self._previous_parser_process(value, state)

        retval = super(OptionEatAll, self).add_to_parser(parser, ctx)
        for name in self.opts:
            our_parser = parser._long_opt.get(name) or parser._short_opt.get(name)
            if our_parser:
                self._eat_all_parser = our_parser
                self._previous_parser_process = our_parser.process
                our_parser.process = parser_process
                break
        return retval
</code></pre>
<h3>Using Custom Class:</h3>
<p>To use the custom class, pass the <code>cls</code> parameter to <code>@click.option()</code> decorator like:</p>
<pre><code>@click.option("--an_option", cls=OptionEatAll)
</code></pre>
<p>or if it is desired that the option will eat the entire rest of the command line, not respecting other options:</p>
<pre><code>@click.option("--an_option", cls=OptionEatAll, save_other_options=False)
</code></pre>
<h3>How does this work?</h3>
<p>This works because click is a well designed OO framework. The <code>@click.option()</code> decorator usually instantiates a
<code>click.Option</code> object but allows this behavior to be over ridden with the cls parameter. So it is a relatively
easy matter to inherit from <code>click.Option</code> in our own class and over ride the desired methods.</p>
<p>In this case we over ride <code>click.Option.add_to_parser()</code> and the monkey patch the parser so that we can
eat more than one token if desired.</p>
<h3>Test Code:</h3>
<pre><code>@click.command()
@click.option('-g', 'greedy', cls=OptionEatAll, save_other_options=False)
@click.option('--polite', cls=OptionEatAll)
@click.option('--other')
def foo(polite, greedy, other):
    click.echo('greedy: {}'.format(greedy))
    click.echo('polite: {}'.format(polite))
    click.echo('other: {}'.format(other))


if __name__ == "__main__":
    commands = (
        '-g a b --polite x',
        '-g a --polite x y --other o',
        '--polite x y --other o',
        '--polite x -g a b c --other o',
        '--polite x --other o -g a b c',
        '-g a b c',
        '-g a',
        '-g',
        'extra',
        '--help',
    )

    import sys, time
    time.sleep(1)
    print('Click Version: {}'.format(click.__version__))
    print('Python Version: {}'.format(sys.version))
    for cmd in commands:
        try:
            time.sleep(0.1)
            print('-----------')
            print('&gt; ' + cmd)
            time.sleep(0.1)
            foo(cmd.split())

        except BaseException as exc:
            if str(exc) != '0' and \
                    not isinstance(exc, (click.ClickException, SystemExit)):
                raise
</code></pre>
<h3>Test Results:</h3>
<pre><code>Click Version: 6.7
Python Version: 3.6.3 (v3.6.3:2c5fed8, Oct  3 2017, 18:11:49) [MSC v.1900 64 bit (AMD64)]
-----------
&gt; -g a b --polite x
greedy: ('a', 'b', '--polite', 'x')
polite: None
other: None
-----------
&gt; -g a --polite x y --other o
greedy: ('a', '--polite', 'x', 'y', '--other', 'o')
polite: None
other: None
-----------
&gt; --polite x y --other o
greedy: None
polite: ('x', 'y')
other: o
-----------
&gt; --polite x -g a b c --other o
greedy: ('a', 'b', 'c', '--other', 'o')
polite: ('x',)
other: None
-----------
&gt; --polite x --other o -g a b c
greedy: ('a', 'b', 'c')
polite: ('x',)
other: o
-----------
&gt; -g a b c
greedy: ('a', 'b', 'c')
polite: None
other: None
-----------
&gt; -g a
greedy: ('a',)
polite: None
other: None
-----------
&gt; -g
Error: -g option requires an argument
-----------
&gt; extra
Usage: test.py [OPTIONS]

Error: Got unexpected extra argument (extra)
-----------
&gt; --help
Usage: test.py [OPTIONS]

Options:
  -g TEXT
  --polite TEXT
  --other TEXT
  --help         Show this message and exit.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use this trick.</p>
<pre class="lang-py prettyprint-override"><code>import click

@click.command()
@click.option('--users', nargs=0)
@click.argument('users', nargs=-1)
@click.option('--bar')
def fancy_command(users, bar):
    users_str = ', '.join(users)
    print('Users: {}. Bar: {}'.format(users_str, bar))

if __name__ == '__main__':
    fancy_command()
</code></pre>
<p>Add fake '<code>option</code>' with a needed name and none arguments <code>'nargs=0'</code>, then add 'argument' with the unlimited args <code>'nargs=-1'</code>.</p>
<pre><code>$ python foo --users alice bob charlie --bar baz
Users: alice, bob, charlie. Bar: baz
</code></pre>
<p>But be careful with the further options:</p>
<pre><code>$ python foo --users alice bob charlie --bar baz faz
Users: alice, bob, charlie, faz. Bar: baz
</code></pre>
</div>
