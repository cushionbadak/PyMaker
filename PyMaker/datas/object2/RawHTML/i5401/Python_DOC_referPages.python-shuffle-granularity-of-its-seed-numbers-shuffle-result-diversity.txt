<div class="post-text" itemprop="text">
<p>My task is that I want to specify a seed for shuffling a list of of items such that I can re-create the shuffled result using the same seed as input next time. However, I tried a few "<strong>close but different numbers</strong>" (a fairly meaningless statement in retrospect) <strong>as seeds</strong> and they all produced the same results.</p>
<p>Here is a piece of code I wrote as an attempt to examine the behavior of seed numbers in Python's random.shuffle()</p>
<pre><code>from random import shuffle

seed_list = [   0.0,    0.05,   0.1,    0.15,   0.2,    0.25,   0.3,    0.35,
                0.4,    0.45,   0.5,    0.55,   0.6,    0.65,   0.7,    0.75,
                0.8,    0.85,   0.9,    0.95
]

last_list = list(range(0, 10))

for seed in seed_list:
    num_list = list(range(0, 10))
    shuffle(num_list, lambda:seed)
    print("Seed", str(seed)+":\t", num_list, num_list==last_list)
    last_list = num_list
</code></pre>
<p>And the output looks something like this:</p>
<pre><code>:~$ python3 test_shuffle.py 
Seed 0.0:    [1, 2, 3, 4, 5, 6, 7, 8, 9, 0] False
Seed 0.05:   [1, 2, 3, 4, 5, 6, 7, 8, 9, 0] True
Seed 0.1:    [9, 2, 3, 4, 5, 6, 7, 8, 0, 1] False
Seed 0.15:   [6, 2, 3, 4, 5, 0, 7, 8, 9, 1] False
Seed 0.2:    [4, 9, 3, 0, 5, 6, 7, 8, 1, 2] False
Seed 0.25:   [3, 7, 0, 4, 5, 6, 1, 8, 9, 2] False
Seed 0.3:    [9, 6, 0, 4, 5, 1, 7, 8, 2, 3] False
Seed 0.35:   [5, 0, 8, 4, 1, 6, 7, 2, 9, 3] False
Seed 0.4:    [9, 0, 7, 1, 5, 6, 2, 8, 3, 4] False
Seed 0.45:   [8, 0, 6, 1, 5, 2, 7, 3, 9, 4] False
Seed 0.5:    [0, 9, 1, 7, 2, 6, 3, 8, 4, 5] False
Seed 0.55:   [0, 9, 1, 7, 2, 6, 3, 8, 4, 5] True
Seed 0.6:    [0, 9, 1, 2, 8, 3, 7, 4, 5, 6] False
Seed 0.65:   [0, 9, 1, 2, 7, 3, 4, 8, 5, 6] False
Seed 0.7:    [0, 1, 9, 2, 3, 8, 4, 5, 6, 7] False
Seed 0.75:   [0, 1, 2, 9, 3, 4, 5, 8, 6, 7] False
Seed 0.8:    [0, 1, 2, 3, 9, 4, 5, 6, 7, 8] False
Seed 0.85:   [0, 1, 2, 3, 4, 9, 5, 6, 7, 8] False
Seed 0.9:    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] False
Seed 0.95:   [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] True
</code></pre>
<p>According to the printout and some finer-grained seeds I tried between intervals, the seed interval which triggers <strong>"moving the first element to the last"</strong> is at least 0.05-0.0=0.05 (same as "doing nothing" for [0.9, 0.95]).</p>
<p>There are two aspects about the behavior which I find troublesome:<br/>
<strong>1)</strong> One-twentieth of the total interval is a large proportion. How are the rest of the shuffle behaviors fairly distributed in the rest of the intervals? (Doesn't "randomness" or "shuffle" conveys "Any order is possible?" How to cram the rest of the randomness in when a large interval is occupied by some behaviors.)<br/>
<strong>2)</strong> "Shift head to tail" &amp; "doing nothing" seem to be very bad/useless behaviors for a shuffling function. Is there something wrong with my implementation?</p>
<p><strong>Edit: I purposely picked seeds so I may reproduce results in my task.</strong> </p>
<p><strong>More info:</strong> I got the impression that I was using seeds from this <a href="https://stackoverflow.com/questions/19306976/python-shuffling-with-a-parameter-to-get-the-same-result">post</a>. Since <code>random.random()</code> produces some float in [0.,1.), I assumed I can pick one myself and further test the behaviors of different seeds by picking them in different same-distance interval.</p>
<p><strong>Please tell me if I made false assumption, logic error, or bad coding. Thank you.</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>You are passing in a function that returns a <em>fixed number</em>:</p>
<pre><code>shuffle(num_list, lambda: seed)
</code></pre>
<p>Here <code>seed</code> is one of your floating point values. That's very different from the default <code>random()</code> function; you are returning the same number repeatedly, forever. From the documentation:</p>
<blockquote>
<p>The optional argument <em>random</em> is a 0-argument function <strong>returning a random float in <code>[0.0, 1.0)</code></strong>; by default, this is the function <code>random()</code>.</p>
</blockquote>
<p>You produced the Dilbert accounting department random number generator here:</p>
<p><a href="https://i.stack.imgur.com/T48A6.gif" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/T48A6.gif"/></a></p>
<p>When you pass in an alternative <code>random()</code> function as the second argument, the value it returns is used to pick what preceding index to swap the 'current' index with (starting from the end); the <a href="https://github.com/python/cpython/blob/master/Lib/random.py#L278-L282" rel="nofollow noreferrer">source code that is run</a> essentially does this:</p>
<pre><code>x = list_to_shuffle
for i in reversed(range(1, len(x))):
    # pick an element in x[:i+1] with which to exchange x[i]
    j = int(random() * (i+1))
    x[i], x[j] = x[j], x[i]
</code></pre>
<p>So your fixed number would always pick the <em>same relative index to swap with</em>. For small enough differences in that fixed value the rounding down to the nearest integer would result in the exact same indices being used to swap with.</p>
<p>This is what happens for <code>0.5</code> to <code>0.55</code>, for example; in both cases the indices picked are <code>(5, 4, 4, 3, 3, 2, 2, 1, 1)</code>, not much of a 'random' shuffle. Ditto for <code>0</code> and <code>0.05</code>, when you swap everything with index <code>0</code>, and for <code>0.9</code> and <code>0.95</code>, when you swap each index with itself.</p>
<p>If you wanted to test how seeding works, create an instance of the <code>random.Random()</code> class with your seed and call <code>shuffle()</code> on that object:</p>
<pre><code>from random import Random

seed_list = [   0.0,    0.05,   0.1,    0.15,   0.2,    0.25,   0.3,    0.35,
                0.4,    0.45,   0.5,    0.55,   0.6,    0.65,   0.7,    0.75,
                0.8,    0.85,   0.9,    0.95
]

last_list = ten_digits = list(range(10))

for seed in seed_list:
    num_list = ten_digits[:]
    Random(seed).shuffle(num_list)
    print("Seed {}:\t {} {}".format(seed, num_list, num_list==last_list))
    last_list = num_list
</code></pre>
<p>which outputs</p>
<pre><code>Seed 0.0:    [7, 8, 1, 5, 3, 4, 2, 0, 9, 6] False
Seed 0.05:   [3, 8, 5, 4, 2, 1, 9, 7, 0, 6] False
Seed 0.1:    [0, 4, 8, 7, 1, 9, 5, 6, 2, 3] False
Seed 0.15:   [6, 1, 8, 7, 9, 5, 2, 4, 3, 0] False
Seed 0.2:    [9, 6, 8, 2, 7, 4, 5, 0, 1, 3] False
Seed 0.25:   [2, 8, 0, 3, 1, 6, 5, 9, 7, 4] False
Seed 0.3:    [7, 4, 5, 1, 2, 3, 8, 9, 6, 0] False
Seed 0.35:   [0, 7, 6, 2, 8, 3, 9, 5, 1, 4] False
Seed 0.4:    [3, 5, 7, 1, 9, 4, 6, 0, 8, 2] False
Seed 0.45:   [4, 3, 6, 8, 1, 7, 5, 2, 9, 0] False
Seed 0.5:    [8, 9, 3, 5, 0, 6, 1, 2, 7, 4] False
Seed 0.55:   [3, 0, 4, 6, 2, 8, 7, 1, 9, 5] False
Seed 0.6:    [3, 4, 7, 2, 9, 1, 6, 5, 8, 0] False
Seed 0.65:   [9, 1, 8, 2, 4, 0, 7, 3, 6, 5] False
Seed 0.7:    [1, 6, 2, 4, 8, 5, 7, 9, 3, 0] False
Seed 0.75:   [8, 3, 6, 1, 9, 0, 4, 5, 7, 2] False
Seed 0.8:    [4, 7, 5, 2, 0, 3, 8, 1, 9, 6] False
Seed 0.85:   [2, 4, 6, 5, 7, 8, 0, 3, 9, 1] False
Seed 0.9:    [3, 6, 5, 0, 8, 9, 1, 4, 7, 2] False
Seed 0.95:   [1, 5, 2, 6, 4, 9, 3, 8, 0, 7] False
</code></pre>
<p>Or you could just call <a href="https://docs.python.org/3/library/random.html#random.seed" rel="nofollow noreferrer"><code>random.seed()</code></a> each test, passing in the <code>seed</code> value, but this changes the global <code>Random()</code> instance affecting other modules using it too.</p>
<p>That second argument to <code>random.seed()</code> should really just be forgotten about, you never need it. It was only there in the <a href="https://github.com/python/cpython/commit/6c395ba31609eeffce2428280cc5d95e4fb8058a" rel="nofollow noreferrer">first revision of the function</a> as a performance improvement, to ensure that in a tight loop a local name was used instead of a global. But because it was added to the function signature without a leading underscore, it became part of the public API in perpetuity, <em>by accident</em>. There is no real use-case that requires it to be used.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can check what it does:</p>
<pre><code>def shuffle(self, x, random=None):
    """Shuffle list x in place, and return None.

    Optional argument random is a 0-argument function returning a
    random float in [0.0, 1.0); if it is the default None, the
    standard random.random will be used.

    """

    if random is None:
        randbelow = self._randbelow
        for i in reversed(range(1, len(x))):
            # pick an element in x[:i+1] with which to exchange x[i]
            j = randbelow(i+1)
            x[i], x[j] = x[j], x[i]
    else:
        _int = int
        for i in reversed(range(1, len(x))):
            # pick an element in x[:i+1] with which to exchange x[i]
            j = _int(random() * (i+1))
            x[i], x[j] = x[j], x[i]
</code></pre>
<p>The <code>else</code> branch applies here and the <code>j = _int(random() * (i+1))</code> line in particular. This is the classic <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle" rel="nofollow noreferrer">Fisher-Yates shuffle</a><br/>
So the 'used granularity' of the random value depends on the length of the list in general, and on index of the current element in particular.</p>
<p>Oh, and by the way: you are not supplying a <strong>seed</strong>, you are supplying the <strong>random values</strong> - which end up being a single value for each iteration.<br/>
What you could do instead is using your random values for a single shuffle:</p>
<pre><code>from random import shuffle

random_list = [ 0.0,    0.05,   0.1,    0.15,   0.2,    0.25,   0.3,    0.35,
                0.4,    0.45,   0.5,    0.55,   0.6,    0.65,   0.7,    0.75,
                0.8,    0.85,   0.9,    0.95
]

num_list = list(range(0, 10))
shuffle(num_list, lambda:random_list.pop())
print(num_list)
</code></pre>
<hr/>
<p>Or, you could use seed-s, but they are not really expected to be floating-point numbers between 0 and 1, see</p>
<pre><code>def seed(self, a=None, version=2):
    """Initialize internal state from hashable object.

    None or no argument seeds from current time or from an operating
    system specific randomness source if available.

    If *a* is an int, all bits are used.

    For version 2 (the default), all of the bits are used if *a* is a str,
    bytes, or bytearray.  For version 1 (provided for reproducing random
    sequences from older versions of Python), the algorithm for str and
    bytes generates a narrower range of seeds.

    """

    if version == 1 and isinstance(a, (str, bytes)):
        x = ord(a[0]) &lt;&lt; 7 if a else 0
        for c in a:
            x = ((1000003 * x) ^ ord(c)) &amp; 0xFFFFFFFFFFFFFFFF
        x ^= len(a)
        a = -2 if x == -1 else x

    if version == 2 and isinstance(a, (str, bytes, bytearray)):
        if isinstance(a, str):
            a = a.encode()
        a += _sha512(a).digest()
        a = int.from_bytes(a, 'big')

    super().seed(a)
    self.gauss_next = None
</code></pre>
<p>and the parent class (where <code>a</code> ends up, with or without these mangling passes) is native code:</p>
<pre><code>NUMBA_EXPORT_FUNC(PyObject *)
_numba_rnd_seed(PyObject *self, PyObject *args)
{
    unsigned int seed;
    rnd_state_t *state;

    if (!PyArg_ParseTuple(args, "O&amp;I:rnd_seed",
                          rnd_state_converter, &amp;state, &amp;seed)) {
        /* rnd_seed_*(bytes-like object) */
        Py_buffer buf;

        PyErr_Clear();
        if (!PyArg_ParseTuple(args, "O&amp;s*:rnd_seed",
                              rnd_state_converter, &amp;state, &amp;buf))
            return NULL;

        if (rnd_seed_with_bytes(state, &amp;buf))
            return NULL;
        else
            Py_RETURN_NONE;
    }
    else {
        /* rnd_seed_*(int32) */
        numba_rnd_init(state, seed);
        Py_RETURN_NONE;
    }
}
</code></pre>
<p>and it may even happen that the passing a floating-point value results in running the final branch here, which uses the uninitialized <code>seed</code> value here, resulting in consistent behaviour solely because the function calls preceding the invocation of this <code>_numba_rnd_seed</code> leave the stack in the same state.</p>
</div>
<div class="post-text" itemprop="text">
<p>A seed is supposed to <strong>initialize</strong> a random number generator. You're instead using it to <strong>be</strong> the random number generator.</p>
<p>You're doing:</p>
<pre><code>shuffle(num_list, lambda: seed)
</code></pre>
<p>A correct way is:</p>
<pre><code>shuffle(num_list, Random(seed).random)
</code></pre>
<p>A better way is:</p>
<pre><code>Random(seed).shuffle(num_list)
</code></pre>
</div>
<span class="comment-copy">Uh... the parameter is supposed to be random. A number, repeatedly, is not really random.</span>
<span class="comment-copy">Sort of, the <a href="https://xkcd.com/221/" rel="nofollow noreferrer">famous random xkcd</a>.</span>
<span class="comment-copy">In other words, the second parameter is supposed to return a <b>different</b> (independently distributed) random number each time. The probability of returning a sequence of 20 equal numbers are extremely unlikely.</span>
<span class="comment-copy">Don't assume there is <i>any</i> relation between the sequences generated by "adjacent" seeds. The only thing you can assume about the seed is that a seed will always produce the same sequence. Don't read anything into the value of the seed itself, how the set of seeds is ordered, etc.</span>
<span class="comment-copy">@Sean Please re-visit the answers. You are not using seeds. The <code>random</code> parameter has nothing to do with seeds.</span>
<span class="comment-copy">Or just <code>random.seed</code>.</span>
<span class="comment-copy">I am not familiar with a better way to do seeding, but the reason I selected a particular float is because I want to make sure I can reproduce my result. But then when I tried another number, they happened to fall in the same interval which I described above and generated the same result. Hence my confusion.</span>
<span class="comment-copy">@Sean: if you want to seed, use <code>random.seed()</code>, or create an independent <code>Random()</code> instance. Supplying a different <code>random.random()</code> function is a way more advanced option and has little to do with seeding.</span>
<span class="comment-copy">@MartijnPieters Did you mean that, even if I want to fix my seed candidates, I should do it via random.seed() instead of hand-pick?</span>
<span class="comment-copy">@Sean: that answer is <b>very wrong</b>.</span>
<span class="comment-copy">I was unaware of the component random number generator and thought my "randomly-picked" number which I understood as a seed can be submitted straight to shuffle(). Thank you.</span>
<span class="comment-copy">Is there condition for the number passed to Random()? Like an int or float in between [0,1)? Or where can I find the its documentation? The documentation I found was <a href="https://docs.python.org/2/library/random.html" rel="nofollow noreferrer">docs.python.org/2/library/random.html</a> but I didn't see it talks specifically about Random().</span>
<span class="comment-copy">@Sean Ugh. I can't find it documented there, either. Sad. But the docstring of <code>__init__</code> says <a href="https://github.com/python/cpython/blob/8ca036d4716fc86ff42474ba35d3cd32f0188a15/Lib/random.py#L94" rel="nofollow noreferrer">"Optional argument x controls seeding, as for Random.seed()"</a> and you'll find <code>seed</code> documented on that page.</span>
