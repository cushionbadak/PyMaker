<div class="post-text" itemprop="text">
<p>A colleague of mine wrote code analogous to the following today, asked me to have a look, and it took me a while to spot the mistake:</p>
<pre><code>class A():                                                                                         
    def __init__(self):                                                         
        print('A')                                                              

class B(A):                                                                     
    def __init__(self):                                                         
        super(B).__init__()                                               

b = B()
</code></pre>
<p>The problem here is that there's no <code>self</code> parameter to <code>super()</code> in <code>B</code>'s constructor. What surprised me is that absolutely nothing happens in this case, i.e. no error, nothing. What does the <code>super</code> object created by <code>super(B)</code> contain? As an object, it clearly has a constructor, so that's what gets called, but how is that object related to <code>B</code>? In particular, why is this valid code and doesn't throw an exception somewhere? Is <code>super(B)</code> an object with some actual use and what would that be?</p>
</div>
<div class="post-text" itemprop="text">
<p>The only thing that causes all these ambiguities is that "why <code>obj = super(B).__init__()</code> works?". That's because <code>super(B).__self_class__</code> returns <code>None</code> and in that case you're calling the <code>None</code> objects' <code>__init__</code> like following which returns None:</p>
<pre><code>In [40]: None.__init__()
</code></pre>
<p>Regarding the rest of the cases, you can simply check the difference by calling the <code>super</code>'s essential attributes in both cases:</p>
<pre><code>In [36]: class B(A):                                                                     
        def __init__(self):                                                         
                obj = super(B, self)
                print(obj.__class__)
                print(obj.__thisclass__)
                print(obj.__self_class__)
                print(obj.__self__)
   ....:         

In [37]: b = B()
&lt;class 'super'&gt;
&lt;class '__main__.B'&gt;
&lt;class '__main__.B'&gt;
&lt;__main__.B object at 0x7f15a813f940&gt;

In [38]: 

In [38]: class B(A):                                                                     
        def __init__(self):                                                         
                obj = super(B)
                print(obj.__class__)
                print(obj.__thisclass__)
                print(obj.__self_class__)
                print(obj.__self__)
   ....:         

In [39]: b = B()
&lt;class 'super'&gt;
&lt;class '__main__.B'&gt;
None
None
</code></pre>
<p>For the rest of the things I recommend you to read the documentation thoroughly. <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer">https://docs.python.org/3/library/functions.html#super</a> and this article by Raymond Hettinger <a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/" rel="nofollow noreferrer">https://rhettinger.wordpress.com/2011/05/26/super-considered-super/</a>.</p>
<p>Moreover, If you want to know why <code>super(B)</code> doesn't work outside of the class and generally why calling the <code>super()</code> without any argument works inside a class you can read This comprehensive answer by Martijn <a href="https://stackoverflow.com/a/19609168/2867928">https://stackoverflow.com/a/19609168/2867928</a>.</p>
<p><strong>A short description of the solution:</strong></p>
<p>As mentioned in the comments by @Nathan Vērzemnieks you need to call the initializer once to get the <code>super()</code> object work. The reason is laid behind the magic of new <code>super</code> object that is explained in aforementioned links.</p>
<pre><code>In [1]: class A:
   ...:     def __init__(self):
   ...:         print("finally!")
   ...:

In [2]: class B(A):
   ...:     def __init__(self):
   ...:         sup = super(B)
   ...:         print("Before: {}".format(sup))
   ...:         sup.__init__()
   ...:         print("After: {}".format(sup))
   ...:         sup.__init__()
   ...:

In [3]: B()
Before: &lt;super: &lt;class 'B'&gt;, NULL&gt;
After: &lt;super: &lt;class 'B'&gt;, &lt;B object&gt;&gt;
finally!
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The confusion here comes from the fact that (in a class definition context) <code>super()</code> gives a bound <code>super</code> object which then delegates <code>__init__</code> to its <code>__self_class__</code>, while <code>super(B)</code> creates an unbound <code>super</code> object which, because its <code>__self_class__</code> is <code>None</code>, does <em>not</em> delegate. </p>
<pre><code>In [41]: class Test(int):
    ...:     def __init__(self):
    ...:         print(super().__self_class__)
    ...:         print(super().__init__)
    ...:         print(super(Test).__self_class__)
    ...:         print(super(Test).__init__)
    ...:

In [42]: Test()
&lt;class '__main__.Test'&gt;
&lt;method-wrapper '__init__' of Test object at 0x10835c9c8&gt;
None
&lt;method-wrapper '__init__' of super object at 0x10835c3c8&gt;
</code></pre>
<p>So when you call <code>super(B).__init__()</code>, it creates an unbound <code>super</code> but then immediately calls <code>__init__</code> on it; that, because of the magic described in the various links <a href="https://stackoverflow.com/a/48302929/9200529">in this other answer</a>, binds that unbound <code>super</code>. There are no references to it, so it disappears, but that's what's happening under the hood.</p>
</div>
<span class="comment-copy">Are you in Python 2 or 3?</span>
<span class="comment-copy">The documentation on <a href="https://docs.python.org/2/library/functions.html#super" rel="nofollow noreferrer"><code>super</code></a> states that omitting the second argument causes it to create an unbound object</span>
<span class="comment-copy">What's even more odd is that calling <code>super(B).__init__()</code> only works inside of a method of <code>B</code> (or a subclass of <code>B</code>). Calling <code>super(B).__init__()</code> outside of a class throws <code>RuntimeError: super(): no arguments</code></span>
<span class="comment-copy"><a href="http://www.artima.com/weblogs/viewpost.jsp?thread=236278" rel="nofollow noreferrer">Here's</a> a very nice article about unbound super objects.</span>
<span class="comment-copy">@Rawing Isn't that explained in <a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/" rel="nofollow noreferrer">rhettinger.wordpress.com/2011/05/26/super-considered-super</a>?</span>
<span class="comment-copy">@Rawing That's strongly related to the magic of <code>super()</code> in python 3.X which can be called without arguments inside a class. Here is a question regard this very topic <a href="https://stackoverflow.com/questions/19608134/why-is-python-3-xs-super-magic" title="why is python 3 xs super magic">stackoverflow.com/questions/19608134/…</a> that is answered nicely by Martijn.</span>
<span class="comment-copy">As far as I can tell, that only applies to the 0-argument form of <code>super</code>. Anyway, I'll stop pestering you (sorry about that!) and post a new question about it. Let's clean up this mess, shall we?</span>
<span class="comment-copy">I don't think it's true that <code>super(B).__init__()</code> is calling <code>None.__init__()</code>. See this gist for evidence to the contrary: <a href="https://gist.github.com/njvrzm/358f96c971a2adc329bcc1d860bede2a" rel="nofollow noreferrer">gist.github.com/njvrzm/358f96c971a2adc329bcc1d860bede2a</a></span>
<span class="comment-copy">Actually I've copied the code from that gist to <a href="https://stackoverflow.com/a/48332210/9200529">my answer to this related question</a>.</span>
