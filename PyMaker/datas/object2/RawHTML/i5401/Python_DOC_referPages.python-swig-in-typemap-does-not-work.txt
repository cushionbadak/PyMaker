<div class="post-text" itemprop="text">
<p>I was learning to wrap c++ codes into a Python module, and typemap is needed for functions like <code>int foo(int argc, char **argv);</code> For example, a simple c++ code can be</p>
<pre><code>#include &lt;iostream&gt;

int foo(int argc, char** argv) {
    std::cout &lt;&lt; "Have " &lt;&lt; argc &lt;&lt; " arguments:" &lt;&lt; std::endl;
    for (int i = 0; i &lt; argc; ++i) {
        std::cout &lt;&lt; argv[i] &lt;&lt; std::endl;
    }
    return 0;
}
</code></pre>
<p>Then I followed the SWIG tutorial <a href="http://www.swig.org/Doc2.0/Python.html#Python_nn59" rel="nofollow noreferrer">here</a> (34.9.2) to write the interface file for SWIG:</p>
<pre><code>%module Args
%{
extern int foo(int argc, char **argv);
%}

%typemap(in) (int argc, char **argv) {
  /* Check if is a list */
  if (PyList_Check($input)) {
    int i;
    $1 = PyList_Size($input);
    $2 = (char **) malloc(($1+1)*sizeof(char *));
    for (i = 0; i &lt; $1; i++) {
      PyObject *o = PyList_GetItem($input,i);
      if (PyString_Check(o))
    $2[i] = PyString_AsString(PyList_GetItem($input,i));
      else {
    PyErr_SetString(PyExc_TypeError,"list must contain strings");
    free($2);
    return NULL;
      }
    }
    $2[i] = 0;
  } else {
    PyErr_SetString(PyExc_TypeError,"not a list");
    return NULL;
  }
}

%typemap(freearg) (int argc, char **argv) {
  free((char *) $2);
}

extern int foo(int argc, char **argv);
</code></pre>
<p>However, after building the module, there is always an error in Python:</p>
<pre><code>&gt;&gt;&gt; import Args
&gt;&gt;&gt; Args.foo(["foo","bar","spam","1"])
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: list must contain strings
</code></pre>
<p>In the typemap it seems <code>$input</code> was indeed received as Python list, but something went wrong with <code>PyList_GetItem($input,i)</code>. Did I do something wrong?</p>
<p>Thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<h1>Bytes vs. characters</h1>
<p>The fundamental issue is that Python 3 strings are <strong>character</strong> strings, while normal Python 2 strings and <code>char*</code> are <strong>byte</strong> strings.  (<code>char*</code> is usually also taken to be null-terminated.)  As such, <code>PyString_Check</code> has been removed in Python 3, and you have to deal with encoding in some fashion.</p>
<p>If you want to accept Python 3 <code>str</code> objects, use <code>PyUnicode</code> functions to check and encode the arguments.  Otherwise, pass <code>bytes</code> objects from Python: <a href="https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals" rel="nofollow noreferrer">bytes literals</a> for fixed ASCII strings (like <code>Args.foo([b"foo",b"bar",b"spam",b"1"])</code>), or else the result of <a href="https://docs.python.org/3/library/stdtypes.html#str.encode" rel="nofollow noreferrer"><code>str.encode</code></a>.</p>
<h1>Why the code compiles</h1>
<p>The wrapper code generated by SWIG is compatible with <a href="http://www.swig.org/Doc3.0/Python.html#Python_python3support" rel="nofollow noreferrer">Python 2 or 3</a>.
Even with <code>-py3</code>, it is written in Python 2 style supported by a number of compatibility macros (from <code>pyhead.swg</code>):</p>
<pre><code>#if PY_VERSION_HEX &gt;= 0x03000000

/* ... */
#define PyString_Check(name) PyBytes_Check(name)
/* ... */

#endif
</code></pre>
<p>In the modern, mostly-3 world, it might be preferable for SWIG to use <a href="https://docs.python.org/3/howto/cporting.html#str-unicode-unification" rel="nofollow noreferrer"><code>bytesobject.h</code></a> instead.  It defines the synonym the other way, making the byte-string obvious.</p>
</div>
<div class="post-text" itemprop="text">
<p>I found this question as a result of a google search where I received the same error</p>
<pre><code>TypeError: list must contain strings
</code></pre>
<p>As the error only appeared after upgrading to Python 3, I was able to resolve it with the following change</p>
<pre><code>Args.foo([b"foo",n"bar",b"spam",b"1"])
</code></pre>
<p>The <code>b</code> forced Python to send the strings as Python2 byte strings rather than the Python3 unicodes string in case this is helpful for anyone else.</p>
</div>
<span class="comment-copy">Crystal ball at work: is this Python 3?</span>
<span class="comment-copy">Yes. I used Python 3.6.1</span>
<span class="comment-copy">Thanks for the excellent explanation. Didn't realize the issue of Python 3. Changing <code>PyString</code> to <code>PyUnicode_AsUTF8</code> actually works!</span>
