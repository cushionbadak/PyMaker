<div class="post-text" itemprop="text">
<pre><code>import sqlite3

location = 'data'
table_name = 'table_name'
try:
    conn = sqlite3.connect(location)
    c = conn.cursor()

    sql = 'insert into ' + table_name + ' (id) values (%d)' % (1)
    c.execute(sql) # Some exception occurs here
    conn.commit() # This line is not reached, so database is locked.
except Exception as e:
    pass:
</code></pre>
<p>So if we run the above code and an exception occurs, the database is locked. So what should we do ?</p>
<p>EDIT: I am aware that this is vulnerable to sql injection. I've posted this example simply so that I can quickly ask the question.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a great use case for <code>with</code>:</p>
<pre><code>from contextlib import closing
conn = sqlite3.connect(location)

with closing(conn.cursor()) as c:
    # Do anything that may raise an exception here
</code></pre>
<p>With works on context objects. These objects define behavior for cleaning up in the event of an exception. In this case, the cursor will be released and the database will be unlocked if an exception occurs.</p>
<p>Note that we need <a href="https://docs.python.org/3/library/contextlib.html#contextlib.closing" rel="nofollow noreferrer"><code>closing</code> from contextlib</a>. This is because <code>sqlite3</code> doesn't make its cursors contexts (even though it should, and other db's like mysql and postgres do this for their db bindings). <code>closing</code> allows the <code>with</code> to know what to do with the cursor when you leave the <code>with</code>'s block.</p>
<p>A similar pattern is the correct way to handle files in Python:</p>
<pre><code>with open('my_file.txt', 'r') as f:
    # Do anything you want here, even something that may
    # raise an exception

# the with will automatically f.close() whenever control
# leaves the with statement (whether by natural flow or
# exception)
</code></pre>
<p>As @IljaEverilä mentions in the comments, the connections themselves are also context managers and you should definitely use them this way to ensure that connections are properly cleaned up:</p>
<pre><code>with sqlite3.connect(location) as conn:
    # Do whatever you need with conn
</code></pre>
</div>
<span class="comment-copy"><code>sql = '... (%d)' % (1)</code> is the road to SQL injection, if you make a habit out of it and one day pass user controllable data that way. If your variable is static, why not just write it in the SQL to begin with. Use placeholders and pass data separately, if using variables.</span>
<span class="comment-copy">@IljaEverilä Thanks I am aware of it. That is just some code I copy pasted so I could ask the above question.</span>
<span class="comment-copy">The <a href="https://docs.python.org/3/library/sqlite3.html#using-the-connection-as-a-context-manager" rel="nofollow noreferrer">connection works as a context manager</a> that commits/rollbacks, which should release locks etc.</span>
<span class="comment-copy">Yep, you should also be using the connection as a context manager to ensure it is properly disposed of. But you can get the same behavior for cursors by wrapping with <code>closing</code>.</span>
<span class="comment-copy">Will this automatically close the connection if there is NOT an exception ?</span>
<span class="comment-copy">As in, will I have to explicitly add conn.close() somewhere ?</span>
<span class="comment-copy">Yes indeed. The same thing happens with files. No matter what the file is closed (whether there is an exception or if the entire <code>with</code> block finishes). In the case of the cursor the proper commit/rollback will happen.</span>
