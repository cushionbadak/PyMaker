<div class="post-text" itemprop="text">
<p><strong>Please note this is not a duplicate of <a href="https://stackoverflow.com/questions/19686533/how-to-zip-two-differently-sized-lists">this post</a> because I want to zip more than 2 lists</strong> (or at least I cannot easily generalize that post for use here without explicit loops)</p>
<p>I want to find the best performing (in terms of speed) implementation that merges list of lists in a particular way. The input is a list of lists (or tuples), ordered such that the length of the next list is always multiples of the previous one. For example:</p>
<pre><code>a = ['A', 'B', 'C', 'D']
b = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']
input_list = [a, b]
</code></pre>
<p>The output is a merged list of:</p>
<pre><code>output = ['A', 'A', 'B', 'B', 'C', 'C', 'D', 'D', 'A', 'E', 'B', 'F', 'C', 'G', 'D', 'H']
</code></pre>
<p>That is, the shorter lists (in this case <code>a</code>) all get expanded to the longest list (in this case <code>b</code>) by cycling over itself so that lists will have equal length. Then all lists are merged in a vertical stacking fashion.</p>
<p>Currently I have an implementation that essentially does the following:</p>
<pre><code>step 1            step 2           step 3 
======            ========         ======
ABCD              ABCDABCD
ABCDEFGH -------&gt; ABCDEFGH ------&gt; AABBCCDDAEBFCGDH
</code></pre>
<p>It works but not efficient:</p>
<pre><code>def flatten_list(value):
    return sum(value, [])

def group(value):
    for idx in reversed(range(1, len(value))):
        multiplier = int(len(value[idx]) / len(value[idx - 1]))
        if multiplier &gt; 1:
            value[idx - 1] = flatten_list([value[idx - 1] for i in range(multiplier)])
    return flatten_list(list(zip(*value)))
</code></pre>
<p>Is there a faster implementation? Performance is really crucial to my application as the input can be huge. Any suggestions are appreciated!</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>cycle</code>, <code>chain</code>, <code>islice</code> from <a href="https://docs.python.org/3/library/itertools.html#itertools" rel="nofollow noreferrer"><code>itertools</code></a>:</p>
<pre><code>list(chain(*islice(
    zip(*(cycle(l) for l in input_list)), 
    0, len(max(input_list, key=len)))))
# ['A', 'A', 'B', 'B', 'C', 'C', 'D', 'D', 'A', 'E', 'B', 'F', 'C', 'G', 'D', 'H']
</code></pre>
<p>Or, in its parts:</p>
<pre><code># generator producing cycles of each list
(cycle(l) for l in input_list)  
# zip these cycles together: ('A', 'A') -&gt; ('B', 'B') -&gt; infinitely
zip(*...)  
# take a slice of this iterable of tuples with the length of the longest list
islice(..., 0, len(max(input_list, key=len)))
# chain those tuples together into one list
list(chain(*...))   
</code></pre>
<p>Or illustrated:</p>
<pre><code>lists = [
                 #        chain--┐-----┐-----┐
                 #              ┌--┐  ┌--┐  ┌--┐     
                 #        | ┌-┐ | ┌-┐ | ┌-┐ | ┌-┐  | ┌-┐     
   [1],          # cycle: | |1|,| |1|,| |1|,| |1|, | |1|, ...
   [1, 2],       # cycle: | |1|,| |2|,| |1|,| |2|, | |1|, ...
   [1, 2, 3, 4], # cycle: | |1|,| |2|,| |3|,| |4|, | |1|, ...
]                #        | └-┘ | └-┘ | └-┘ | └-┘  | └-┘  
                 #        |  └--┘  └--┘  └--┘      |
                 #        | zip   zip   zip   zip  | zip  ...
                 #        |                        |    
                 #   islice start           islice stop
                 #   --&gt;  [1,1,1,1,2,2,1,1,3,1,2,4]
</code></pre>
<p>The time complexity of this is <code>O(n)</code> where <code>n</code> is the length of the output list. In Python2 you will have to use <code>itertools.izip</code> instead of <code>zip</code> as the latter would try to build an infinite list.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>roundrobin</code> itertools recipe</a>:</p>
<p><em>Two Inputs</em></p>
<pre><code>import itertools as it


a = list("ABCD")
b = list("ABCDEFGH")

list(it.chain.from_iterable(roundrobin(zip(it.cycle(a), b))))
# ['A', 'A', 'B', 'B', 'C', 'C', 'D', 'D', 'A', 'E', 'B', 'F', 'C', 'G', 'D', 'H']
</code></pre>
<p><code>itertools.cycle()</code> infinitely extends the shorter iterable.  <code>zip()</code> stops iterating after the shorter iterable.  <code>roundrobin</code> handles the interleaving of elements between iterables.</p>
<hr/>
<p><em>Longer Inputs</em></p>
<p>To work on more than two inputs, we need to cycle all but the last iterable:</p>
<pre><code>def interleave(*inputs):
    *rest, last = inputs
    cycles = (it.cycle(x) for x in rest)
    return list(it.chain.from_iterable(mit.roundrobin(zip(*cycles, last))))
</code></pre>
<p>Now for <strong>two or more input iterables</strong>, we can apply the <code>interleave</code> function:</p>
<pre><code>p = list("ab")
q = list("abcd")
r = list("abcdef")

input_list_1 = [a, b]
input_list_2 = [p, q, r]


print(interleave(*input_list_1))
# ['A', 'A', 'B', 'B', 'C', 'C', 'D', 'D', 'A', 'E', 'B', 'F', 'C', 'G', 'D', 'H']
print(interleave(*input_list_2))
# ['a', 'a', 'a', 'b', 'b', 'b', 'a', 'c', 'c', 'b', 'd', 'd', 'a', 'a', 'e', 'b', 'b', 'f']
</code></pre>
<p>Note: you can either reimplement the <code>roundrobin</code> recipe from <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">the docs</a> or install a third-party library that implements it for you, e.g. <a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.roundrobin" rel="nofollow noreferrer"><code>more_itertools</code></a>.  <code>&gt; pip install more_itertools</code>, then in Python, <code>from more_itertools import roundrobin</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>apply <a href="https://docs.python.org/3/library/itertools.html?highlight=itertools%20cycle#itertools.cycle" rel="nofollow noreferrer"><code>itertools.cycle</code></a> to all lists shorter than the longest one and zip them all together, flattening the result.</p>
<pre><code>def special_zip(*lsts):
    max_len = max(map(len, lsts))
    cyclic = [lst if len(lst) == max_len else itertools.cycle(lst) for lst in lsts]
    return (el for grp in zip(*cyclic) for el in grp)
</code></pre>
<p>off-hand this should be O(2n) where n is the sum of the lengths of the lists. If you know the longest list and can pass it separately, this becomes O(n). Similarly if you know how much output you need (since you can just apply <code>itertools.cycle</code> to each list and pull from the infinite output)</p>
</div>
<div class="post-text" itemprop="text">
<p>will this work?</p>
<pre><code>final_result=[]
def recursive_approach(aa,bb):
    if not bb:
        return 0
    else:
        for i in zip(aa,bb):
            final_result.extend([i[0],i[1]])
    return recursive_approach(aa,bb[len(aa):])
recursive_approach(a,b)

print(final_result)
</code></pre>
<p>output:</p>
<pre><code>['A', 'A', 'B', 'B', 'C', 'C', 'D', 'D', 'A', 'E', 'B', 'F', 'C', 'G', 'D', 'H']
</code></pre>
</div>
<span class="comment-copy">To flatten list/iterator of tuples: <a href="https://stackoverflow.com/q/952914/2301450">stackoverflow.com/q/952914/2301450</a> <code>sum(..., [])</code> has quadratic complexity</span>
<span class="comment-copy">So, use <code>zip_list</code> from <a href="https://stackoverflow.com/a/19686624/2301450">this</a> answer and <code>[y for x in zip_list for y in x]</code> will be your output</span>
<span class="comment-copy">Thanks @vaultah but how about having more than 2 lists to zip?</span>
<span class="comment-copy">unless there's some sort of optimization under the hood, it should be (infinitesimally) faster to find max length with <code>max(map(len, input_list))</code> Since that operates on each list only once, while yours operates on each list once, then one list one more time to grab its length. Nice solution! I never use <code>islice</code>.</span>
<span class="comment-copy">@AdamSmith It should not make a big difference since the length of a list is retrieved in O(1). I timed both approaches and mine was even a little faster (insignificant): <code>stmt1 = 'len(max(lists, key=len))'; stmt2 = 'max(map(len, lists))'; timeit(stmt1, setup); 5.21139558899813; timeit(stmt2, setup); 5.373297284000728;</code> Btw, Mine calls <code>len</code> on each list only once, and then once more only for the longest one.</span>
<span class="comment-copy">No, it'll barely make a <i>small</i> difference! But yes that's what I said above "operates on each list once, then one list [once more]"</span>
<span class="comment-copy">Thank you @schwobaseggl and Adam for the code, illustrations and discussions. I've adopted this solution in my program. Made a huge improvement!</span>
<span class="comment-copy">That builds the wrong list.</span>
<span class="comment-copy">Fixed.  Thanks for the comment.</span>
<span class="comment-copy"><code>zip(it.cycle(a), b)</code> doesn't take into account the lengths of lists</span>
<span class="comment-copy">@vaultah: That's fine, because we're given that the length of each list is a multiple of the length of the previous. The bigger issue is that this code is specific to two lists.</span>
<span class="comment-copy">@user2357112 This code works for iterables.  It is not constrained to lists alone.  @vaultah This assumes the shorter iterable is <code>a</code>.</span>
<span class="comment-copy">Probably a better strategy is to find the length of the longest list, instead of the list itself (in case there are multiple lists with the same length). I think you also need to flatten the result of <code>zip(*cyclic)</code>.</span>
<span class="comment-copy">any list with max_len length need not be cycled, but it won't hurt if it is as long as one is bounded. However you're right about the flattening: let me do that.</span>
<span class="comment-copy">Sure, it won't hurt, but you can avoid the creation of unnecessary <code>cycle</code> objects. Also computing and comparison of lengths should be faster than element-wise comparison of large lists.</span>
<span class="comment-copy">@vaultah ah that's true, let me edit then.</span>
