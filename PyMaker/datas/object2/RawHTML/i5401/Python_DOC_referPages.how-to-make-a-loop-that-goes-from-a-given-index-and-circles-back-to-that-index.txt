<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/22122623/python-wrapping-around-on-a-list-when-list-index-is-out-of-range">Python wrapping around on a list when list index is out of range</a>
<span class="question-originals-answer-count">
                    3 answers
                </span>
</li>
</ul>
</div>
<p>Title may be confusing but I don't know how to express myself any better. What I have is a list that looks something like this:</p>
<pre><code>myList = ['a', 'b', 'c', 'd', 'e', 'f']
</code></pre>
<p>what I want to do is a for loop that, for example, starts at index 3, so 'd' and then goes to the end but at the end of the list insted of finishing goes back to the beginning, goes through 'a','b','c' and then finishes at 'd'. I tried doing it like this with a while loop:</p>
<pre><code>index = 3
while index != 2:
    if index == len(a):
        index = 0
    else:
        pass
    print(a[index])
    index += 1
</code></pre>
<p>This sorta worked but it will never print out 'c' but if I put 3 as index the loop will never even start. Is there a more elegant solution to do something like this? </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the modulus operator against the length of the string</p>
<pre><code>def offset_print(s, offset):
    for i in range(len(s)):
        print(s[(i+offset) % len(s)])
</code></pre>
<p>Example</p>
<pre><code>&gt;&gt;&gt; offset_print('hello', 2)
l
l
o
h
e
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>So, definitely like @CoryKramer's approach, but this one doesn't require you to calculate the length of the iterator:</p>
<pre><code>def run_offset(lst, fn, offset=0):
    base = []
    for item in lst:
      if offset &gt; 0:
        # append the original list until you're no longer dealing with an offset
        base.append(item)
        offset -= 1
        continue

      # just yield the current value
      yield item

    # iterate through the indexes 0... offset
    for item in base:
      yield item

&gt; list(run_offset('abcd', print, 2))
['c', 'd', 'a', 'b']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not the most efficient -- but if your list is short and you just want pure simplicity, you can shift your list; </p>
<pre><code>shifted = my_list[n:] + my_list[:n]
for item in shifted:
    # do stuff here
</code></pre>
<p>... Or use a deque; </p>
<pre><code>&gt;&gt;&gt; import collections
&gt;&gt;&gt; dq = collections.deque(['a', 'b', 'c', 'd'])
&gt;&gt;&gt; dq
deque(['a', 'b', 'c', 'd'])
&gt;&gt;&gt; dq.rotate(2)
&gt;&gt;&gt; dq
deque(['c', 'd', 'a', 'b'])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/3/library/itertools.html#itertools.cycle" rel="nofollow noreferrer"><code>itertools.cycle</code></a> also works here:</p>
<pre><code>from itertools import cycle

def offset_print(s, offset):
    it = cycle(s)

    items = [next(it) for i in range(len(s) + offset)]

    for x in items[offset:]:
        print(x)
</code></pre>
<p>Which Outputs:</p>
<pre><code>&gt;&gt;&gt; offset_print(['a', 'b', 'c', 'd', 'e', 'f'], 2)
c
d
e
f
a
b
</code></pre>
</div>
<span class="comment-copy">Look at the modulus operator</span>
