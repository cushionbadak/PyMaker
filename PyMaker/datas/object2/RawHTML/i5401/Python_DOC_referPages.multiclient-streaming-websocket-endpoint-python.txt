<div class="post-text" itemprop="text">
<p>Recently I've gotten into the "crypto mania" and have started writing my own wrappers around the API's on some exchanges.</p>
<p>Binance in particular has an a streaming websocket endpoint.</p>
<p>where you can stream data but via a websocket endpoint.
I thought I'd try this out on my own using sanic.</p>
<p>here is my websocket route</p>
<pre><code>@ws_routes.websocket("/hello")
async def hello(request, ws):
    while True:
        await ws.send("hello")
</code></pre>
<p>now I have 2 clients on 2 different machines connecting to it</p>
<pre><code>async def main():
    async with aiohttp.ClientSession() as session:

        ws  = await session.ws_connect("ws://192.168.86.31:8000/hello")
        while True:
            data = await ws.receive()
            print(data)
</code></pre>
<p>however only one of the clients will be able to connect and receive the sent data from the server. I'm assuming that because of the <code>while</code> loop its blocking and preventing the other connection from connecting because it doesn't <code>yield</code>?</p>
<p>how do we make it stream to multiple clients without blocking the other connections?</p>
<p>I looked into adding more workers and it seems to do the trick but what I don't understand is thats not a very scalable solution. because each client would be its own worker and if you have thousands or even just 10 clients that would be 10 workers 1 per client.</p>
<p>so how does Binance do their websocket streaming? or hell how does the twitter stream endpoint work?</p>
<p>how is it able to serve an infinite stream to multiple concurrent clients?
because ultimately thats what I'm trying to do</p>
</div>
<div class="post-text" itemprop="text">
<p>The way to solve this would be something like this.</p>
<p>I am using the <code>sanic</code> framework</p>
<pre><code>class Stream:
    def __init__(self):
        self._connected_clients = set()

    async def __call__(self, *args, **kwargs):
        await self.stream(*args, **kwargs)

    async def stream(self, request, ws):
        self._connected_clients.add(ws)

        while True:
            disconnected_clients = []
            for client in self._connected_clients:  # check for disconnected clients
                if client.state == 3:  # append to a list because error will be raised if removed from set while iterating over it 
                    disconnected_clients.append(client)
            for client in disconnected_clients:  # remove disconnected clients
                self._connected_clients.remove(client)

            await asyncio.wait([client.send("Hello") for client in self._connected_clients]))


ws_routes.add_websocket_route(Stream(), "/stream")
</code></pre>
<ol>
<li>keep track of each <code>websocket</code> session</li>
<li>append to a <code>list</code> or <code>set</code></li>
<li>check for invalid <code>websocket</code> sessions and remove from your <code>websocket</code> sessions container</li>
<li>do an <code>await asyncio.wait([ws_session.send() for ws_session [list of valid sessions]])</code> which is basically a broadcast.</li>
</ol>
<p>5.profit!</p>
<p>this is basically the pubsub design pattern</p>
</div>
<div class="post-text" itemprop="text">
<p>Something like this maybe?</p>
<pre><code>import aiohttp
import asyncio
loop = asyncio.get_event_loop()
async def main():
    async with aiohttp.ClientSession() as session:
        ws  = await session.ws_connect("ws://192.168.86.31:8000/hello")
        while True:
            data = await ws.receive()
            print(data)

multiple_coroutines = [main() for _ in range(10)]
loop.run_until_complete(asyncio.gather(*multiple_coroutines))
</code></pre>
</div>
<span class="comment-copy">did you try running multiple <code>main</code> coroutines with <code>asyncio.gather</code>? <a href="https://docs.python.org/3/library/asyncio-task.html" rel="nofollow noreferrer">docs.python.org/3/library/asyncio-task.html</a></span>
<span class="comment-copy">I actually never thought of testing it this way. this is way better than getting two laptops. and running the same script.</span>
<span class="comment-copy">Great, glad it helped. Also note that you can <code>await asyncio.gather(*multiple_coroutines)</code>  inside a coroutine</span>
