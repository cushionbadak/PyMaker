<div class="post-text" itemprop="text">
<p>I have a dictionary that consists of numbers and their value</p>
<pre><code>dict = {1:5, 2:5, 3:5}
</code></pre>
<p>I have an array with some numbers</p>
<pre><code>arr = [1,2]
</code></pre>
<p>What I want to do is:</p>
<p>iterate through the dict and the array
where the dictionary value is equal to the number in the array, set the dictionary value to zero
any value in the dictionary for which there isn't a value in the array matching it, add 1</p>
<p>so in the above example, I should end up with</p>
<pre><code>arr = [1,2]
dict = {1:0, 2:0, 3:6}
</code></pre>
<p>The bit I am getting stuck on is creating a variable from the array value and accessing that particular number in the dictionary - using <code>dict[i]</code> for example</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>arr = [1,2]
data = {1:0, 2:0, 3:6}  # don't call it dict because it shadow build-in class

unique = set(arr)  # speed up search in case if arr is big
# readable
for k, v in data.items():
  if k in unique:
    data[k] = 0
  else:
    data[k] += 1
# oneliner
data = {k: (0 if k in unique else v + 1) for v, k in data.items()}
</code></pre>
<p>Additional example:</p>
<pre><code>for a, b, c in [(1,2,3), (4,5,6)]:
  print('-',a,b,c)
# will print:
# - 1 2 3
# - 4 5 6
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You just need a <code>dict-comprehension</code> that will re-built your dictionary with an <code>if</code> condition for the value part.</p>
<pre><code>my_dict = {1:5, 2:5, 3:5}

arr = [1,2]

my_dict = {k: (0 if k in arr else v+1) for k, v in my_dict.items()}
print(my_dict)  # {1: 0, 2: 0, 3: 6}
</code></pre>
<p>Note that I have re-named the dictionary from <code>dict</code> to <code>my_dict</code>. That is because by using <code>dict</code> you are overwriting the Python built-in called <code>dict</code>. And you do not want to do that.</p>
</div>
<div class="post-text" itemprop="text">
<p>Theirs always the <code>dict(map())</code> approach, which rebuilds a new dictionary with new values to each of the keys:</p>
<pre><code>&gt;&gt;&gt; d = {1:5, 2:5, 3:5}
&gt;&gt;&gt; arr = {1, 2}
&gt;&gt;&gt; dict(map(lambda x: (x[0], 0) if x[0] in arr else (x[0], x[1]+1), d.items()))
{1: 0, 2: 0, 3: 6}
</code></pre>
<p>This works because wrapping <code>dict()</code> will automatically convert mapped 2-tuples to a dictionary. </p>
<p>Also you should not use <code>dict</code> as a variable name, since it shadows the builtin <code>dict</code>.  </p>
</div>
<div class="post-text" itemprop="text">
<p>Just use .update method :</p>
<pre><code>dict_1 = {1:5, 2:5, 3:5}
arr = [1,2]


for i in dict_1:
    if i in arr:
        dict_1.update({i:0})
    else:
        dict_1.update({i:dict_1.get(i)+1})

print(dict_1)
</code></pre>
<p>output:</p>
<pre><code>{1: 0, 2: 0, 3: 6}
</code></pre>
<p>P.S : don't use dict as variable</p>
</div>
<span class="comment-copy">Try not to override builtin names such as <code>dict</code>. Sooner or later you'll be debugging why you get something funny like <code>TypeError: 'list' object is not callable</code> or some such.</span>
<span class="comment-copy">the "for k, v in data" - is this a special kind of for loop? Does it have a name (too read more about)?</span>
<span class="comment-copy"><code>dict.items()</code> returns generator that yields key and value as tuple, <a href="https://docs.python.org/3/tutorial/datastructures.html#looping-techniques" rel="nofollow noreferrer">docs</a>. You can also iterate this way over simple list of tuple, I will add this to the answer</span>
<span class="comment-copy">hint : for a simple yet effective optimisation if <code>arr</code> starts getting huge, make it a <code>set</code> instead.</span>
