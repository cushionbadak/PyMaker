<div class="post-text" itemprop="text">
<p>I have used Counter class to get the iterations number, and now I want to format it as like that :</p>
<pre><code>from collections import Counter
elements = [1,6,9,4,1,2]
elements.sort()
Val=Counter(elements).keys() #Gives me all the values used : 1,2,4,6,9
Freq=Counter(elements).values() #Gives me the frequency : 2,1,1,1,1,
# I want display somethink like : 
# 1 : 2
# 2 : 1
# 4 : 1
# 6 : 1
# 9 : 1

#I have tried : but it is a dict Type : I need to convert this Val et Freq to List
for i in range(0,len(Val)):
    print(str(Val[i]) +" : "str(Freq[i]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should build the <code>Counter</code> only once.  There's no guarantee that the two separate <code>Counter</code> objects will iterate over their contents in the same order (Plus for large inputs it's just inefficent).</p>
<pre><code>from collections import Counter

elements = [1,6,9,4,1,2]

for val, freq in sorted(Counter(elements).items()):
    print(val, ' : ', freq)
</code></pre>
<p>Here <code>sorted(Counter(elements).items())</code> is a sorted list containing tuples <code>(val, freq)</code>:<br/>
<code>[(1, 2), (2, 1), (4, 1), (6, 1), (9, 1)]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You can convert them to lists and then <code>zip</code> them:</p>
<pre><code>from collections import Counter
elements = [1,6,9,4,1,2]
elements.sort()
Val=list(Counter(elements).keys()) #Gives me all the values used : 1,2,4,6,9
Freq=list(Counter(elements).values()) #Gives me the frequency : 2,1,1,1,1,

for i,j in zip(Val,Freq):
    print(str(i) + ":" + str(j))
</code></pre>
<p>Output:</p>
<pre><code>1:2
2:1
4:1
6:1
9:1
</code></pre>
</div>
<span class="comment-copy">While I would not count on two Counter objects iterating in the same order (nor would I build two wastefully when only one is needed) it is insertion order that would change the iteration order.  Considering that these Counter objects are created from the same data in the same order on the same run in the same process I would be surprised if the iteration order ever diverged.  (The "on the same run in the same process" disclaimer is to account for hash randomization.)</span>
<span class="comment-copy">@StevenRumbalski The closest thing I could find to documentation on this subject is: <a href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="nofollow noreferrer">Keys and values are iterated over in an arbitrary order which is non-random, varies across Python implementations, and depends on the dictionaryâ€™s history of insertions and deletions.</a> While that seems to imply that identical iterables should produce identical dicts/Counters, that definitely seems like the kind of implementation detail it's unsafe to build code around.</span>
<span class="comment-copy">This works, but it seems kind of roundabout to create independent iterable objects and zip them together, when the dict type already has a method whose entire purpose is to iterate through keys and values in parallel.</span>
<span class="comment-copy">Also, why convert to lists?</span>
<span class="comment-copy">Pre-Python 3.6 your results may not end up in sorted order.  And as Kevin mentioned <code>Val=list(Counter(elements).keys()); Freq=list(Counter(elements).values()); zip(Val,Freq)</code> is a very longhand way of writing <code>Counter(elements).items()</code>.  Wrap that up in <code>sorted()</code> and its all good.  But then again that's Patrick Haugh's answer.</span>
