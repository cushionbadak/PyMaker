<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/25103085/chaining-is-operators">Chaining “is” operators</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
<li>
<a dir="ltr" href="/questions/28104393/why-does-false-is-false-is-false-evaluate-to-true">Why does `False is False is False` evaluate to `True`?</a>
<span class="question-originals-answer-count">
                    5 answers
                </span>
</li>
</ul>
</div>
<pre><code>A = 314

if A == A == A:
    print('True #1')

if A == A == 271:
    print('True #2')

lie = 0
if lie is lie is lie:
    print('no matter how white, how small,')
    print('how incorporating of a smidgeon')
    print('of truth there be in it.')
</code></pre>
<p>Result:</p>
<pre><code>True #1
no matter how white, how small,
how incorporating of a smidgeon
of truth there be in it.
</code></pre>
<p>I know it is not normal to use two "="s and "is"s in the if sentence. But I would like to know how the Python interpreter intereprets the <code>if</code> statement.</p>
<p>Is the expression <code>lie is lie is lie</code> interpreted simultaneously, or short-circuit way?</p>
</div>
<div class="post-text" itemprop="text">
<p>What you've happened across is called <em>operator chaining</em>. </p>
<p>From the documentation on <a href="https://docs.python.org/3/reference/expressions.html#comparisons" rel="noreferrer">Comparisons</a>:</p>
<blockquote>
<p>Comparisons can be chained arbitrarily, e.g., <strong><code>x &lt; y &lt;= z</code> is
  equivalent to <code>x &lt; y and y &lt;= z</code></strong>, except that <code>y</code> is evaluated only once
  (but in both cases <code>z</code> is not evaluated at all when <code>x &lt; y</code> is found to be
  false).</p>
</blockquote>
<p>Emphasis mine.</p>
<p>So, this would mean <code>lie is lie is lie</code> is interpreted as <code>(lie is lie) and (lie is lie)</code>, and nothing more.</p>
<p>More generally, <code>a op b op c op d ...</code> is evaluated the same as <code>a op b and b op c and c op d ...</code> and so on. The expression is parsed according to python's <a href="https://docs.python.org/3/reference/grammar.html" rel="noreferrer">grammar rules</a>. In particular;</p>
<pre><code>comparison    ::=  or_expr ( comp_operator or_expr )*
comp_operator ::=  "&lt;" | "&gt;" | "==" | "&gt;=" | "&lt;=" | "!="
                   | "is" ["not"] | ["not"] "in"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This question has many answers already, but consider the function split into bytecode:</p>
<pre><code>def f():
    lie = 0
    if lie is lie is lie:
        print('Lie')

dis.dis(f)

  2           0 LOAD_CONST               1 (0)
              2 STORE_FAST               0 (lie)
  3           4 LOAD_FAST                0 (lie)
              6 LOAD_FAST                0 (lie)
              8 DUP_TOP
             10 ROT_THREE
             12 COMPARE_OP               8 (is)
             14 JUMP_IF_FALSE_OR_POP    22
             16 LOAD_FAST                0 (lie)
             18 COMPARE_OP               8 (is)
             20 JUMP_FORWARD             4 (to 26)
        &gt;&gt;   22 ROT_TWO
             24 POP_TOP
        &gt;&gt;   26 POP_JUMP_IF_FALSE       36
  4          28 LOAD_GLOBAL              0 (print)
             30 LOAD_CONST               2 ('Lie')
             32 CALL_FUNCTION            1
             34 POP_TOP
        &gt;&gt;   36 LOAD_CONST               0 (None)
             38 RETURN_VALUE
</code></pre>
<p>This suggests that all <code>lie</code>s are being checked to see if they match, in a linear fashion. If one fails, it should break/return.</p>
<p>To confirm, consider:</p>
<pre><code>&gt;lie is lie is lie is lie is lie 
True
&gt;lie is not lie is lie is lie is lie is lie
False
&gt;lie is lie is lie is lie is lie is not lie
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It will be interpreted as:</p>
<pre><code>lie = 0
if lie is lie and lie is lie:
    ...
</code></pre>
</div>
<span class="comment-copy">What do you mean by "simultaneously"? I'm guessing it's being interpreted like <code>0 &lt; x &lt; 3</code> just with different operators (and operands).</span>
<span class="comment-copy">Interesting question, but almost certainly a dupe, operator chaining must have been asked before on SO.</span>
<span class="comment-copy">@tripleee By non "simultaneously", I mean "lie is lie" return "True", then "True is lie", whichi may fail. According to replies, I understand that it is interpreted as "lie is lie and lie is lie".</span>
<span class="comment-copy">I haven't tried reading the bytecode before. It is useful to understand how it works.</span>
<span class="comment-copy">... except the third <code>lie</code> will not be evaluated a second time.</span>
<span class="comment-copy">Or maybe <code>lie0 = lie1 = lie2 = 0; if lie0 is lie1 and lie1 is lie2</code> to slightly clarify which is which.</span>
