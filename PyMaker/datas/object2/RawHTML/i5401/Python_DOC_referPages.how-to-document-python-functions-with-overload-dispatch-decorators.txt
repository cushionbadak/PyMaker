<div class="post-text" itemprop="text">
<h1>Applying Documentation to Multi-Dispatched Functions</h1>
<p>I am using the <a href="https://github.com/mrocklin/multipledispatch/blob/master/docs/source/design.rst" rel="nofollow noreferrer"><code>multipledispatch</code></a> package, in a fashion similar to the example code below.  I want to be able to see the <code>docstring</code> text when I ask for <code>help(my_add)</code> in the Python command line, but instead all I see is information about the decorator.</p>
<h2><code>Functools.wraps</code> must be the way to do it, but how?</h2>
<p>I have looked up <a href="https://docs.python.org/3/library/functools.html" rel="nofollow noreferrer"><code>functools.wraps</code></a>, which I'm sure is what I want to use.  I have found examples of how to use it, such as <a href="https://stackoverflow.com/questions/25829364/applying-a-decorator-to-an-imported-function">this</a> and <a href="https://stackoverflow.com/questions/1782843/python-decorator-handling-docstrings">this</a>.</p>
<p>But I still don't entirely understand two issues:</p>
<ol>
<li>How to apply the <code>functools.wraps</code> to external decorators that I don't "own".</li>
<li>How to apply it specifically to this case with multiple dispatch, since the function I want to wrap will have multiple <code>docstrings</code> associated with the same function name.</li>
</ol>
<h1>Example: Decorated Function Creation</h1>
<p>Below is an example to help explain.</p>
<pre><code>&gt;&gt;&gt; from multipledispatch import dispatch
&gt;&gt;&gt; @dispatch(str, str)
... def my_add(elem1, elem2):
...   '''A flavor of 'add' where two strings are concatenated.'''
...   return elem1 + ' ' + elem2
... 
&gt;&gt;&gt; @dispatch(int, int)
... def my_add(elem1, elem2):
...   '''A flavor of 'my_add' where two strings are concatenated.'''
...   return elem1 + elem2
... 
&gt;&gt;&gt; my_add('hey','you')
'hey you'
&gt;&gt;&gt; my_add(4, 5)
9
&gt;&gt;&gt; my_add(4.5, 6)
</code></pre>
<p>(Traceback details removed...)</p>
<pre><code>KeyError: (&lt;class 'float'&gt;, &lt;class 'int'&gt;)
During handling of the above exception, another exception occurred:
NotImplementedError: Could not find signature for my_add: &lt;float, int&gt;
</code></pre>
<p>I wanted to show that error and the different dispatches just to show that that part is working as I want it (looking for the matched dispatch and calling the associated "flavor" of the function).</p>
<h1>Example: Calling <code>help</code> on the Decorated Function Fails!</h1>
<p>But next, if I try to look at the help, instead of seeing the simple <code>docstring</code> that I have provided, I see the docstring associated with the <code>@dispatch</code> decorator.</p>
<pre><code>&gt;&gt;&gt; help(my_add)

Help on Dispatcher in module multipledispatch.dispatcher object:

my_add = class Dispatcher(builtins.object)
 |  Methods defined here:
 |  
 |  __call__(self, *args, **kwargs)
 |      Call self as a function.
 |  
 |  __getstate__(self)
 |  
</code></pre>
<p>etc.</p>
<hr/>
<p>I'm not even sure what it <strong>should</strong> show, since there are <strong><em>potentially 2 conflicting docstrings</em></strong> I'd like to push forward.  So, I tried to see if I could call help on a function that's actually run, but then of course it gives me help on the returned data type.  E.g.,</p>
<pre><code>&gt;&gt;&gt; help(my_add(3, 5))

Help on int object:

class int(object)
 |  int(x=0) -&gt; integer
 |  int(x, base=10) -&gt; integer
 |  
 |  Convert a number or string to an integer, or return 0 if no arguments
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>functools.wraps()</code> decorator would have to be part of the <em>decorator implementation</em> and you can't apply it after the fact. The issue here is that the decorator returns an instance of a custom class, and <code>help()</code> can only show documentation for the <em>class</em> of that instance.</p>
<p>The <code>Dispatcher()</code> instance the decorator returns <strong>already has a <code>__doc__</code> attribute</strong>, one which lists the doc strings of all decorated functions. From the documentation you linked:</p>
<blockquote>
<p>The <code>Dispatcher</code> creates a detailed docstring automatically. To add a description of the multimethod itself, provide it when creating the <code>Dispatcher</code>.</p>
</blockquote>
<p>The docstring is there for your example too:</p>
<pre><code>&gt;&gt;&gt; print(my_add.__doc__)
Multiply dispatched method: my_add

Inputs: &lt;str, str&gt;
-------------------
A flavor of 'add' where two strings are concatenated.

Inputs: &lt;int, int&gt;
-------------------
A flavor of 'my_add' where two strings are concatenated.
</code></pre>
<p>(note that the docstrings are reflected correctly from your example, complete with errors).</p>
<p>The real issue here is that <code>help()</code> can only print the <code>__doc__</code> string of the <em>class</em>, so <code>print(type(my_add).__doc__))</code> is used as a starting point. This is not something that can easily be changed; just stick to printing the <code>__doc__</code> attribute of the instance directly.</p>
</div>
<span class="comment-copy">Wow!  I didn't think the solution would be that easy!  Thank you very much, Martijn!  It's interesting that <code>.__doc__</code> can be changed but that <code>help</code> cannot easily point to it.  I think understand what you're saying, regarding the class.  But I don't quite understand how that works.  I always thought that <code>my_add.__doc__</code> was <b>exactly</b> the same as <code>help(my_add)</code>, just syntactic sugar.  I guess you're saying that <code>my_add.__doc__</code> can be overwritten to point to the <i>function</i> <code>my_add</code>, but that <code>help(my_add)</code> is still actually pointing to <code>help(dispatch)</code> and cannot be changed.  Is that right?</span>
<span class="comment-copy">@MikeWilliamson: What would <code>help(1)</code> produce, or <code>help('some string')</code>? <code>help()</code> gives you information on what you can do with the <i>type</i> of the argument. So yes, <code>help(my_add)</code> will give you help on the <code>Dispatch</code> class, not the specific instance of that class. By extension, that means the <code>__doc__</code> of the instance is not used.</span>
