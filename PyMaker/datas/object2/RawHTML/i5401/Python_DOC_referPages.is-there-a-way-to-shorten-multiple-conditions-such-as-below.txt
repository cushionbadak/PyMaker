<div class="post-text" itemprop="text">
<p>Sorry, don't really know how to phrase the question so it may seem ambiguous.</p>
<p>What I'd like to do is essentially I have a code that reads the input from a user and compares it to certain letters but this process should be case non-sensitive. So I use the .lower() string method.</p>
<pre><code>if (letter.lower() == "a" or letter.lower() == "b" or letter.lower() == "c"):
</code></pre>
<p>(In this case, the values "A", "B", "C", "a", "b" and "c" should be accepted and all other values assigned to the name "letter" rejected.)</p>
<p>Can this be shortened any further? Readability isn't that important unless it is truly gobbledygook that cannot be understood by human tongue haha.</p>
<p>I tried:</p>
<pre><code>if (letter.lower() == "a" or "b" or "c"):
</code></pre>
<p>which doesn't work. Neither does:</p>
<pre><code>if (letter.lower() == ("a" or "b" or "c")):
</code></pre>
<p>I appreciate any input. Thanks in advance :)</p>
</div>
<div class="post-text" itemprop="text">
<p>I think what you're looking for is the keyword <code>in</code>. The following is probably the most "pythonic" way.</p>
<pre><code>if letter.lower() in ['a','b','c']:
</code></pre>
<p>That should do it for you. Although, if you're looking for speed, it would be better to create a dictionary or set and do lookups from that.
As the complexity of the <code>in</code> operator is average <code>O(n)</code> for arrays and strings but average <code>O(1)</code> and worst case <code>O(n)</code> for sets and dictionaries.</p>
<p>For example,</p>
<pre><code>chars = set(['a','b','c'])
if letter.lower() in chars:
</code></pre>
<p>If you're interested in reading a little more about the differences in complexities, here's a <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">Python Time Complexity</a> document that's very useful to know!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can also use <a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow noreferrer">any</a> to check if <code>letter</code> is matched with any character.</p>
<p>Declare a set of letters to compare with</p>
<pre><code> &gt;&gt;&gt; letter = 'c'
 &gt;&gt;&gt; s = {'a', 'b', 'c'}
</code></pre>
<p>Compare using <code>any</code></p>
<pre><code> &gt;&gt;&gt; any(letter.lower() == k for k in s)
 &gt;&gt;&gt; True
</code></pre>
<p>Using <code>in</code> would be simpler and efficient since <code>sets</code> have fast membership tests</p>
<pre><code>&gt;&gt;&gt; letter.lower() in s
&gt;&gt;&gt; True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are two general approaches.</p>
<p>One is that you can group the things you want to compare against (the "a", "b", and "c") into a single compound value. Commonly you use a list or a tuple. A string potentially works in this case as you're only dealing with single characters, but I wouldn't consider it a great choice<sup>1</sup>. Then you need to find a comparison between your input and the collection that implies the repeated tests of your input against each individual item.</p>
<p>This particular example is a very common one; you want to check whether your input is <em>equal</em> to <em>any one</em> of a bunch of items. That's equivalent to checking whether it is <em>in</em> a collection of those items. So <code>if letter.lower() in ("a", "b", "c")</code>.</p>
<p>The other general approach when you're testing an expression like <code>letter.lower()</code> against a bunch of separate conditions and you don't want to write out the expression repeatedly (or compute it repeatedly if it's expensive) is to just save it into a variable on an earlier line. Something like:</p>
<pre><code>normalised = letter.lower()
if normalised == "a" or normalised == "b" or normalised == "c":
   ...
</code></pre>
<p>In this case the first method (using a collection) is easily applicable, so that is definitely the way to go. You may or may not want to <em>also</em> move the <code>letter.lower()</code> out of the test for other reasons<sup>2</sup>, but on its own it doesn't give you much (if any) improvement. But when the several conditions you're using aren't as easily combined into one as they are here, then this can help.</p>
<hr/>
<p><sup>1</sup> Personally I find using a string as a container of characters <em>usually</em> makes the code less intuitively obvious, and while it can be much more efficient for very large strings it isn't worth doing for any string small enough to write as a reasonable string literal. More importantly though, the <code>in</code> operator for strings tests whether the left string is a <em>substring</em> of the right one, not whether the left thing is a single element of the right one. Given your <code>letter</code> comes from user input, they might have accidentally typed <code>ab</code>, in which case <code>letter.lower() in 'abc'</code> comes out <code>True</code>, but it <em>wasn't</em> equal to any of "a", "b", or "c".</p>
<p><sup>2</sup> If you need to refer to the normalised input further down as well, if you want to label the lowercasing as a "normalisation" by giving it a name, if you consider it very important and want to highlight it on its own line rather than hide it within a line that's doing other things as well, etc.</p>
</div>
<span class="comment-copy"><code>if letter.lower() in 'abc':</code></span>
<span class="comment-copy">would that not accept "ab", "bc", "Ab", "aB", "bC", and "Bc" as well as the wanted single letters? @StephenRauch</span>
<span class="comment-copy">One assumes that the variable letter is in fact that. However, I concur that is is an assumption.</span>
<span class="comment-copy">@StephenRauch But it reads user input so I'd like to avoid that if possible. One could easily mistype it and that would lead to errors further down in the code. Otherwise I wouldn't need this in the first place and would simple assume users would just type lowercase "a", "b" and "c" :)  This might work, but still lengthy I suppose: <code>if letter.lower() in 'abc' and len(letter) = 1:</code></span>
<span class="comment-copy">That is of course fine, since it is your program.  How ever, if I were your manager, and I was code reviewing your code, and there was a chance that the variable named <code>letter</code> could contain more than that, I would complain.</span>
<span class="comment-copy">This is almost right but not the same test. Replacing <code>"abc"</code> by <code>('a', 'b', 'c')</code> would make it equivalent.</span>
<span class="comment-copy">You're right. OP updated question. I'll fix it.</span>
<span class="comment-copy">@Skam Perfect, exactly what I wanted, thanks :D</span>
<span class="comment-copy">I don't think the efficiency point is valid. If the list of conditions is small enough to be reasonable to write out manually in source code, then it almost certainly doesn't matter whether you use a list or a set. And if you're converting a list into a set every time you come to the <code>if</code> statement, then that's <i>less</i> efficient than just using a list. (Unless python precomputes <code>set(['a', 'b', 'c'])</code> during bytecode compilation, but that isn't the case according to <code>dis.dis</code> even for actual set literals like <code>{'a', 'b', 'c'}</code>, let alone for a call of the <code>set</code> function on a list)</span>
<span class="comment-copy">@Ben I agree. In this case the efficiency is not a valid point in this case. Though I thought I might touch on a best practice.</span>
<span class="comment-copy">Why would you not just use <code>letter.lower() in s</code>? You've gone to the trouble to specifically create it as a set, which have faster membership tests, and then manually written out the less-efficient "iterate over each element and test" algorithm.</span>
