<div class="post-text" itemprop="text">
<p>I have implemented a basic SMTPServer which works great but I'm encountering an issue and I don't know how I can fix it.</p>
<p>When checking the file descriptors opened for the $PID of the process running my script (<code>ls -l /proc/$PID/fd/ | grep "socket:" | wc -l</code>), the quantity of file descriptors keep increasing.</p>
<p>Since I'm filtering by "socket:", this clearly some sockets left open, certainly because some mail providers doesn't quit clearly.</p>
<p>I've tested locally some Python scripts connecting to that <code>SMTPServer</code> code, and even if I don't close the connection, when the client process stops, the client close the connection, and the file descriptor is removed.</p>
<p>I thought about implementing a timeout for waiting, or restarting the process every N connections, but these are just bad patches for a bigger problem.</p>
<p>Do you know where that would come from?</p>
<p>For information, my <code>process_message</code> wrapper is surounded by a</p>
<pre><code>try:
    # ...
except:
    return '450 Please try again later"
</code></pre>
<p>So an exception coming from my code should be well handled.</p>
<p>Here's my code (simplified):</p>
<pre><code>class MyMXServer(SMTPServer):
    def __init__(self, host='127.0.0.1', port=25):
        self.srs = SRS.new(os.getenv('SRS_KEY', 'some passwd'))
        return SMTPServer.__init__(self, (host, port), None)

    def process_message(self, greeting, peer, mailfrom, recipients, data, **kwargs):
        try:
            return self._process_message(greeting, peer, mailfrom, recipients, data, **kwargs)
        except:
            logging.getLogger('err').exception('[EXCEPTION]')
            return '450 Please try again later.'

    def _process_message(self, greeting, peer, mailfrom, recipients, data, **kwargs):
        # Various things like checking DNSBL, SPF, Spam, etc
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Hard to answer without seeing your code. However, you've already implemented the initial components of exception handling. <code>else</code> may not be necessary, but it sounds like a <code>finally</code> clause is a requirement in this situation. Finish the block to ensure the socket is closed:</p>
<pre><code>try:
    # unreliable process
except:
    return '450 Please try again later"
else:
    # successful outcome
finallY:
    socket.close()
</code></pre>
</div>
<span class="comment-copy">Do you have control over the clients or are you accepting connections from all over the big bad Internet? Some clients could leave the connection hanging just because they are sloppy, or worse.</span>
<span class="comment-copy">In other news, there will be a workshop about using <code>grep -c</code> instead of <code>grep | wc -l</code> after the regular schedule finishes.</span>
<span class="comment-copy">Will finally be called only if the except has been called? Or regardless of the outcome of the previous items?</span>
<span class="comment-copy">It's well documented in the reference. It will be called regardless.</span>
<span class="comment-copy"><code>finally</code> will always be called whether the <code>try</code> succeeds or fails.</span>
<span class="comment-copy">This won't work (just checked with the code) as the method may returns '250' if everything is fine, and will wait for the next command. Closign the socket will causes issues.</span>
<span class="comment-copy"><a href="https://docs.python.org/3/tutorial/errors.html#defining-clean-up-actions" rel="nofollow noreferrer">docs.python.org/3/tutorial/â€¦</a> &lt;- there</span>
