<div class="post-text" itemprop="text">
<p>The below block of code works however I'm not satisfied that it is very optimal due to my limited understanding of using JSON but I can't seem to figure out a more efficient method.</p>
<p>The <a href="https://api.steampowered.com/ISteamApps/GetAppList/v2/" rel="nofollow noreferrer">steam_game_db</a> is like this:</p>
<pre><code>{
    "applist": {
        "apps": [
            {
                "appid": 5,
                "name": "Dedicated Server"
            },
            {
                "appid": 7,
                "name": "Steam Client"
            },
            {
                "appid": 8,
                "name": "winui2"
            },
            {
                "appid": 10,
                "name": "Counter-Strike"
            }
        ]
    }
}
</code></pre>
<p>and my Python code so far is</p>
<pre><code>i = 0
x = 570

req_name_from_id = requests.get(steam_game_db)
j = req_name_from_id.json()

while j["applist"]["apps"][i]["appid"] != x:
    i+=1
returned_game = j["applist"]["apps"][i]["name"]
print(returned_game)
</code></pre>
<p>Instead  of looping through the entire app list is there a smarter way to perhaps search for it? Ideally the elements in the data structure with 'appid' and 'name' were numbered the same as their corresponding 'appid'</p>
<p>i.e.
appid 570 in the list is Dota2
However element 570 in the data structure in appid 5069 and Red Faction</p>
<p>Also what type of data structure is this? Perhaps it has limited my searching ability for this answer already. (I.e. seems like a dictionary of 'appid' and 'element' to me for each element?)</p>
<p>EDIT: Changed to a for loop as suggested</p>
<pre><code># returned_id string for appid from another query

req_name_from_id = requests.get(steam_game_db)
j_2 = req_name_from_id.json()

for app in j_2["applist"]["apps"]:
    if app["appid"] == int(returned_id):
        returned_game = app["name"]

print(returned_game)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The most convenient way to access things by a key (like the app ID here) is to use a dictionary. </p>
<p>You pay a little extra performance cost up-front to fill the dictionary, but after that pulling out values by ID is basically free.</p>
<p>However, it's a trade-off. If you only want to do a single look-up during the life-time of your Python program, then paying that extra performance cost to build the dictionary won't be beneficial, compared to a simple loop like you already did. But if you want to do multiple look-ups, it will be beneficial. </p>
<pre><code># build dictionary
app_by_id = {}
for app in j["applist"]["apps"]:
  app_by_id[app["appid"]] = app["name"]

# use it
print(app_by_id["570"])
</code></pre>
<p>Also think about caching the JSON file on disk. This will save time during your program's startup.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's better to have the JSON file on disk, you can directly dump it into a dictionary and start building up your <code>lookup table</code>. As an example I've tried to maintain your logic while using the dict for lookups. Don't forget to encode the <code>JSON</code> it has special characters in it.</p>
<p><strong>Setup:</strong></p>
<pre><code>import json

f = open('bigJson.json')

apps = {}
with open('bigJson.json', encoding="utf-8") as handle:
    dictdump = json.loads(handle.read())

    for item in dictdump['applist']['apps']:
        apps.setdefault(item['appid'], item['name'])
</code></pre>
<p><strong>Usage 1:</strong>
That's the way you have used it</p>
<pre><code>for appid in range(0, 570):
    if appid in apps:
        print(appid, apps[appid].encode("utf-8"))
</code></pre>
<p><strong>Usage 2</strong>: That's how you can query a key, using <code>get</code>instead of <code>[]</code> will prevent a <code>KeyError</code> exception if the <code>appid</code> isn't recorded.</p>
<pre><code>print(apps.get(570, 0))
</code></pre>
</div>
<span class="comment-copy">This is a hash structure, but  the quickest would be putting everything into a dictionary, a lookup is then instant.</span>
<span class="comment-copy">@user1767754 if they're only looking up one thing, turning the whole list into a dictionary would be slower on average than just iterating through for the thing they want, although the subsequent lookup would be fast.</span>
<span class="comment-copy">You should think about the <i>intent</i> of your code; <code>for app in j["applist"]["apps"]:</code> would be far clearer than messing about with <code>i</code>, for example, without the risk of an <code>IndexError</code> if the ID (currently named <code>x</code>, which is also unhelpful - why not <code>app_id</code>?) isn't found.</span>
<span class="comment-copy">@jonrsharpe the x was unhelpful my bad, I changed it to a bland variable name as to not cause confusion (as I'm converting my string from somewhere else to an int and it may have looked a bit random/redundant).      I have changed it to a for instead as you suggested and it does seem clearer. Will the for loop continue after finding the required value? As I assumed the while loop once it hits the right X value will not continue thus using less resources?  Also any idea why I wouldn't actually need the <code>j</code> in front of the <code>j["applist"]["apps"]</code> and it still works?</span>
<span class="comment-copy">You can <code>return</code> (if in a function) or <code>break</code> to end the loop when appropriate.</span>
<span class="comment-copy">Hi Tomalak, I will test this out.  I do expect to reuse this, the program is constantly checking a list of steam ids for what they are playing, however valve will update the api occasionally as new games are released, so perhaps querying from it is the best option, or perhaps periodically?</span>
<span class="comment-copy">Well, it takes a while to get the file over the wire. Loading it from disk will be faster. You remember in a variable when you last refreshed it and re-download it when it is getting old. Unfortunately the Steam server does not seem to support <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Conditional_requests" rel="nofollow noreferrer">conditional HTTP</a> for this file, so you have to keep track of its age manually.</span>
<span class="comment-copy">Thanks, I will certainly give that a go if only to learn something new! I suppose refreshing it even once every few hours will be more efficient given this loops per 5 seconds</span>
<span class="comment-copy">Absolutely. And you only need to re-build the dictionary after the HTTP download, too.</span>
<span class="comment-copy">P.S. instead of a variable, you can also simply look at the file's last write time to figure out if it is old enough to justify a re-download.</span>
<span class="comment-copy">Thanks for this, I'll have to play with it a little as my knowledge is quite limited. (Particularly encoding it)</span>
<span class="comment-copy">It's easier to let the JSON library handle the file loading (<a href="https://docs.python.org/3/library/json.html#json.load" rel="nofollow noreferrer">docs</a>). <code>data = json.load('bigJson.json')</code></span>
<span class="comment-copy">But <code>json.load</code> expects a <code>file</code> like object?</span>
<span class="comment-copy">A filename works, too.</span>
<span class="comment-copy">That's weird, I'm on <code>3.6.3</code> and when I do <code>data = json.load('bigJson.json')</code> I get <code>str obj has no attribute read</code></span>
