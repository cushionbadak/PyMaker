<div class="post-text" itemprop="text">
<p>On Successfully POSTing to a form endpoint I redirect back to the same endpoint with some URL params that my client side code can interact with.</p>
<pre><code>@bp.route('/submit', methods=['GET', 'POST'])
def submit():
    form = SubmissionForm()
    labels = current_app.config['TRELLO_LABELS']

    if form.validate_on_submit():

        submission = Submission().create(
            title=form.data['title'], email=form.data['email'], card_id=card.id, card_url=card.url)

        # reset form by redirecting back and setting the URL params
        return redirect(url_for('bp.submit', success=1, id=card.id))

    return render_template('submit.html', form=form)
</code></pre>
<p>But I ran into some issues trying to write a test for this code as I can't figure out how to test that those URL params are on my redirect URL. My incomplete test code is:</p>
<pre><code>import pytest

@pytest.mark.usefixtures('session')
class TestRoutes:

    def test_submit_post(self, app, mocker):
        with app.test_request_context('/submit',
            method='post',
            query_string=dict(
                email='email@example.com',
                title='foo',
                pitch='foo',
                format='IN-DEPTH',
                audience='INTERMEDIATE',
                description='foo',
                notes='foo')):
            assert resp.status_code == 200
</code></pre>
<p>I've tried a few different methods to test this. With and without the context manager and I've dug deep into the Flask and Werkzeug source on the <code>test_client</code> and <code>test_request_context</code>.</p>
<p>I just want to test that the URL params for <code>success</code> and <code>id</code> exist on redirect after a valid POST.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a super simple yet inclusive example of patching Flask's <code>url_for</code> method (can be run as-is in a Python interpreter):</p>
<pre><code>import flask
from unittest.mock import patch

@patch('flask.url_for')
def test(self):
    resp = flask.url_for('spam')
    self.assert_called_with('spam')
</code></pre>
<p><br/>
However, the above example will only work if you're importing Flask directly and not using <code>from flask import url_for</code> in your routes code. You'll have to patch the exact namespace, which would look something like this:</p>
<pre><code>@patch('application.routes.url_for')
def another_test(self, client):
    # Some code that envokes Flask's url_for, such as:
    client.post('/submit', data={}, follow_redirects=True)

    self.assert_called_once_with('bp.submit', success=1, id=1)
</code></pre>
<p>For more info, check out <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="nofollow noreferrer" title="Where To Patch">Where to Patch</a> in the mock documentation.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://pypi.python.org/pypi/mock/" rel="nofollow noreferrer">mock's</a> function <code>patch</code> function to patch <code>url_for</code> capturing the provided arguments and then test against them.</p>
</div>
<span class="comment-copy">do you have an example of how to do this? I've tried but can't trace any calls on a patched <code>url_for</code></span>
