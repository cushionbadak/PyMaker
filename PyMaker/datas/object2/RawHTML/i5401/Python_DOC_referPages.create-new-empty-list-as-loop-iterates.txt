<div class="post-text" itemprop="text">
<p>So I feel like I could make my code drastically shorted if I update the name of the empty list, but I'm not sure I how do this? Here's what it would look regularly. The purpose of the program is to sort by range.</p>
<pre><code>x=[11,12,21,34,35,36]

list_1020 = []
list_2030 = []
list_3040 = []

for i in x:
  if 10&lt;= i &lt;20:
  list_1020.append[i]
</code></pre>
<p>I would copy and paste the for loop for each list. This is fine until I get larger lists, and code is here to save that time!</p>
<p>So if I could make the list name update each time I could solve this easily. Here's what I got so far. With the same 'x' list as above</p>
<pre><code>min = 10
max = 20
list_ #min+max - THIS IS THE PART I DONT KNOW HOW TO DO = []

for i in x:

  if min&lt;= i &lt;max:
   list_#min+max.append[i]
  else:
   min+=10
   max+=10
   list_ #min+max - THIS IS THE PART I DONT KNOW HOW TO DO = []
</code></pre>
<p>Theoretically that would be all the code I need (in addition to the lines needed to update the name of the lists ofcourse). Is this possible? I'm still a little new to programming so if I messed up anywhere or if you have ways to make this even better, let me know! </p>
</div>
<div class="post-text" itemprop="text">
<p>Build a dictionary and then you can get it's values as you want</p>
<pre><code>s = {}    
for i in x:
  s.setdefault((i+9)//10*10, []).append(i),
# {40: [34, 35, 36], 20: [11, 12], 30: [21]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import collections

x=[11,12,21,34,35,36]

lists = collections.defaultdict(list)

for i in x:
    lower = (i//10) * 10
    upper = lower + 10
    lists[(lower, upper)].append[i]
</code></pre>
<p>Now your <code>lists</code> variable is a dictionary that maps (min, max) pairs to a list of values in that range:</p>
<pre><code>&gt;&gt;&gt; lists[(10, 20)]
[11, 12]
</code></pre>
<p>Of course you don't need both the lower and upper bounds in the key - you could store them just by lower bound since you know how wide the ranges are:
    import collections</p>
<pre><code>x=[11,12,21,34,35,36]

lists = collections.defaultdict(list)

for i in x:
    lower = (i//10) * 10
    lists[lower].append[i]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to use <code>dict</code> this is one of the solutions:</p>
<pre><code>x = [11, 12, 21, 35, 36]

bottom = 10
top = 10

ceiling = int(round(max(x), -1))

solution = {}

while top &lt;= ceiling:
    solution['list_{}{}'.format(bottom, top)] = [i for i in x if bottom &lt;= i &lt; top]
    bottom += 10
    top += 10
</code></pre>
<p>Now you can use <code>solution['list_1020']</code> to get data you need.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could always use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby()</code></a> to group the sorted numbers by their lower range:</p>
<pre><code>from itertools import groupby

x=[11,12,21,34,35,36]

grouped = [list(g) for _, g in groupby(x, key = lambda x: (x//10) * 10)]

print(grouped)
</code></pre>
<p>Which Outputs:</p>
<pre><code>[[11, 12], [21], [34, 35, 36]]
</code></pre>
<p>Then you could insert these lists into a dictionary:</p>
<pre><code>ranges = ['list_1020', 'list_2030', 'list_3040']
d = dict(zip(ranges, grouped))
# {'list_1020': [10, 11, 12], 'list_2030': [21], 'list_3040': [34, 35, 36]}
</code></pre>
<p>Or even a one-liner:</p>
<pre><code>grouped = dict(('list_' + str(k) + str(k+10), list(g)) for k, g in groupby(x, key = lambda x: (x//10) * 10))
# {'list_1020': [10, 11, 12], 'list_2030': [21], 'list_3040': [34, 35, 36]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Perhaps you could simply use <code>Python Dictionary</code> since you need to have named containers with names like: <code>list_1020</code>, <code>list_2030</code>, etc. Plus, this gives you some kind of space since it would be dynamically generated as <code>Dictionary Keys</code>. Here's what this idea could look like in Code:</p>
<pre><code>listDict    = {}
x           = [11,12,21,34,35,36]

for q in range(10, 40, 10):
    tKey    = (q, (q+10))
    dictKey = "list_{}{}".format(tKey[0], tKey[1])
    listDict[dictKey] = [i for i in x if i in range(tKey[0], tKey[1]+1)]


print(listDict)
print(listDict["list_1020"])
print(listDict["list_2030"])
print(listDict["list_3040"])
</code></pre>
<p>As a reusable Function:</p>
<pre><code>def groupDataValues(x, minVal=10, maxVal=40, step=10):
    listDict    = {}
    for q in range(minVal, maxVal, step):
        tKey    = (q, (q+step))
        dictKey = "list_{}{}".format(tKey[0], tKey[1])
        listDict[dictKey] = [i for i in x if i in range(tKey[0], tKey[1]+1)]
    return listDict

x           = [11,12,21,34,35,36]
listDict    = groupDataValues(x, 10, 40, 10)
</code></pre>
<p><a href="https://i.stack.imgur.com/Eq0Aa.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/Eq0Aa.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can do something like this by finding distance of int from 10,20,30</p>
<pre><code>map_dict={10:'10-20',20:'20-30',30:'30-40'}



x=[11,12,21,34,35,36]

dict_1={}

for i in x:
    for b in map_dict.keys():
        if i not in dict_1:
            dict_1[i]=[(abs(i-b),b)]
        else:
            dict_1[i].append((abs(i-b),b))

final_output={}

for key,value in dict_1.items():
    if map_dict[min(value)[1]] not in final_output:
        final_output[map_dict[min(value)[1]]]=[key]
    else:
        final_output[map_dict[min(value)[1]]].append(key)

print(final_output)
</code></pre>
<p>output:</p>
<pre><code>{'20-30': [21], '10-20': [11, 12], '30-40': [34, 35, 36]}
</code></pre>
</div>
<span class="comment-copy">What are you trying to do? Python does not support dynamic names, if that is what you have in mind.</span>
<span class="comment-copy">Use a <code>defaultdict</code> to store and access your lists. BTW, it is a very bad habit to shadow build-in names, such as <code>max</code> and <code>min</code>.</span>
<span class="comment-copy">You could use sth like this: <code>for i in x: (list_1020 if i &lt; 20 else list_2030 if i &lt; 30 else list_3040 if i &lt; 40 else None).append(i)</code>.  But maybe you want to do a proper grouping using a dictionary: <code>d = {}</code>, <code>for i in x: d.setdefault(i//10,  []).append(i)</code>.</span>
