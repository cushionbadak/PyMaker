<div class="post-text" itemprop="text">
<p>Given 4 lists, I want to get elements that are common to 3 or more lists.</p>
<pre><code>a = [1, 2, 3, 4]
b = [1, 2, 3, 4, 5]
c = [1, 3, 4, 5, 6]
d = [1, 2, 6, 7]
</code></pre>
<p>Hence, the output should be <code>[1, 2, 3, 4]</code>.</p>
<p>My current code is as follows.</p>
<pre><code>result1 = set(a) &amp; set(b) &amp; set(c)
result2 = set(b) &amp; set(c) &amp; set(d)
result3 = set(c) &amp; set(d) &amp; set(a)
result4 = set(d) &amp; set(a) &amp; set(b)

final_result = list(result1)+list(result2)+list(result3)+list(result4)
print(set(final_result))
</code></pre>
<p>It works fine, and give the desired output. However, I am interested in knowing if there is an easy way of doing this in Python, ie: are there any built in functions for this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Using a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>Counter</code></a>, you can do this like:</p>
<h3>Code:</h3>
<pre><code>a = [1, 2, 3, 4]
b = [1, 2, 3, 4, 5]
c = [1, 3, 4, 5, 6]
d = [1, 2, 6, 7]

from collections import Counter

counts = Counter(sum(([list(set(i)) for i in (a, b, c, d)]), []))
print(counts)

more_than_three = [i for i, c in counts.items() if c &gt;= 3]
print(more_than_three)
</code></pre>
<h3>Results:</h3>
<pre><code>Counter({1: 4, 2: 3, 3: 3, 4: 3, 5: 2, 6: 2, 7: 1})

[1, 2, 3, 4]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Iterate over the values in all lists to create a dict of <code>{value: number_of_lists_the_value_appears_in}</code>:</p>
<pre><code>from collections import defaultdict

counts = defaultdict(int)
for list_ in (a, b, c, d):
    for value in set(list_):  # eliminate duplicate values with `set`
        counts[value] += 1
</code></pre>
<p>Then in the second step remove all values with a <code>count &lt; 3</code>:</p>
<pre><code>result = [value for value, count in counts.items() if count &gt;= 3]

print(result)  # [1, 2, 3, 4]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The code below will solve the generalised problem (with n lists, and a requirement that a common element must be in at least k of them). It will work with non-hashable items, which is the main disadvantage of all the other answers:</p>
<pre><code>a = [1, 2, 3, 4]
b = [1, 2, 3, 4, 5]
c = [1, 2, 3, 4, 4, 5, 6]
d = [1, 2, 6, 7]


lists = [a, b, c, d]
result = []
desired_quanity = 3

for i in range(len(lists) - desired_quanity + 1):   #see point 1 below
    sublist = lists.pop(0)                          #see point 2
    for item in sublist:
        counter = 1   #1 not 0, by virute of the fact it is in sublist
        for comparisonlist in lists:
            if item in comparisonlist:
                counter += 1
                comparisonlist.remove(item)         #see point 3
        if counter &gt;= desired_quanity:   
            result.append(item)
</code></pre>
<p>This has the disadvantage that for each element in every list, we have to check in every other list to see if it is there, but we can make things more efficient in a few ways. Also look-ups are alot slower in lists than sets (which we can't use since the OP has non-hashable items in the lists), and so this may be slow for very large lists.</p>
<p>1) If we require an item to be in k lists, we don't need to check each item in the last k-1 lists, as we would have already picked it up whilst searching through the first k lists.</p>
<p>2) Once we have searched through a list, we can discard that list, since any items in the just-searched-list that might contribute to our final result, will again already have been dealt with. This means that with each iteration we have fewer lists to search through.</p>
<p>3) When we have checked if an item is in enough lists, we can remove that item from the list, which means not only is the number of lists getting shorter as we proceed, the lists themselves are getting shorter, meaning quicker lookups.</p>
<p>As an aftersort, if we the original lists happen to be sorted beforehand, this might also help this algorithm work efficiently.</p>
</div>
<div class="post-text" itemprop="text">
<p>create a dictionary of counts and filter out those with count less than 3</p>
</div>
<span class="comment-copy">I figured something could be whipped up with <code>collections.Counter</code>, nice. +1</span>
<span class="comment-copy">Thanks a lot for the great answer :) However, this does not seem to work with my real data. My real data includes a <code>list tuple</code> instead of the numbers. e.g., [['tim tam'], 0.5], ['pudding', 0.5], ...]. I get an error saying <code>TypeError: unhashable type: 'list'</code>. Can you please kindly tell me why that happens? :)</span>
<span class="comment-copy">Non uniform data types are generally going to be a problem. That error is due to the list being unhashable. That is during the set creation.  The set creation is meant to remove duplicates.  If duplicates are not an issue, you can remove the <code>set()</code>.  Alternatively, the lists would need to be deduplicated prior.</span>
<span class="comment-copy">@StephenRauch <code>Counter</code> is a <code>dict</code> subclass, and so can only count hashable objects anyway. Removing the <code>set()</code> would still result in an error. I think a different approach might be needed if the data includes lists.</span>
<span class="comment-copy">Great answer Tim.I tested it and it worked :)</span>
<span class="comment-copy">Glad to have helped :)</span>
<span class="comment-copy">as the other (+one) answer demonstrates :-)</span>
