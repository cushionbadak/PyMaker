<div class="post-text" itemprop="text">
<p>Say I got an array of <code>str</code>:</p>
<pre><code>['12.5', '7', '45', '\n', '13.7', '52', '34.3', '\n']
</code></pre>
<p>And I want to split it by value, in this case by <code>'\n'</code>, so it becomes:</p>
<pre><code>[['12.5',  '7', '45'],
 ['13.7', '52', '34.3']]
</code></pre>
<p>I don't want to enumerate every element since it's time consuming when input has a large scale. So I wonder if there are some functions or python tricks that can easily achieve this. </p>
<p>P.S.</p>
<p>I've saw <a href="https://stackoverflow.com/questions/5274243/split-array-at-value-in-numpy">this question</a> but it doesn't help much. Mainly because I don't quite understand how <code>np.where()</code> works with <code>np.split()</code>, also because I'm working on <code>str</code> type.</p>
<p>Another thing might be helpful is that my final goal is to generate a matrix of numbers (maybe <code>float</code> type), so I'll also be glad to know if there's any numpy function can do this. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> which, of course, does iterate the list, but is highly optimized:</p>
<pre><code>from itertools import groupby

l = ['12.5', '7', '45', '\n', '13.7', '52', '34.3', '\n']

[list(g) for k, g in groupby(lst, '\n'.__eq__) if not k]
# [['12.5', '7', '45'], ['13.7', '52', '34.3']]
</code></pre>
<p>Or, with float conversion:</p>
<pre><code>[list(map(float, g)) for k, g in groupby(lst, '\n'.__eq__) if not k]
# [[12.5, 7.0, 45.0], [13.7, 52.0, 34.3]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>numpy</code>:</p>
<pre><code>rows = np.split(z, np.where(arr == '\n')[0] + 1)[:-1]
mat = np.array(rows).astype(np.float)
</code></pre>
<hr/>
<p>Alternatively, if we're sure to be dealing with a <em>matrix</em>, you could simply search for the first occurrence of <code>'\n'</code>, reshape, and slice using that.</p>
<pre><code>first = np.argmax(arr == '\n')
mat = arr.reshape(-1, first + 1)[:, 0:first].astype(np.float)
</code></pre>
<p>This <strong>might</strong> be faster.</p>
</div>
<div class="post-text" itemprop="text">
<p>I made a thing for this once upon a time. A <a href="https://github.com/spyoungtech/chunking" rel="nofollow noreferrer">chunking</a> module. It's made to work similar to <code>str.split</code></p>
<pre><code>pip install chunking
</code></pre>
<p>Then</p>
<pre><code>&gt;&gt;&gt; from chunking import split
&gt;&gt;&gt; a_list = ["foo", 'bar', 'SEP', 'bacon', 'eggs']
&gt;&gt;&gt; split(a_list, 'SEP')
[['foo', 'bar'], ['bacon', 'eggs']]
</code></pre>
<p>There's also <code>chunking.iter_split</code>, which is a generator variant of that.</p>
</div>
<span class="comment-copy">Even if you don't want to use a loop to iterate through your elements and you prefer using "some functions or python tricks that can easily achieve this", these tools you are looking for <b>will</b> use a loop. So why not use one yourself for such a basic operation ?</span>
<span class="comment-copy">@IMCoins I learned from some courses that many packages are using GPU computing matrices, which is faster than implement by myself with some explicit <code>for</code> loop.</span>
<span class="comment-copy">@AmarthGûl Unfortunately, most of the packages that do that are 3rd party packages, and a loop is usually your best bet because it is implemented in C.</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ Well, when implementing matrix computations, I found <code>numpy</code> functions are way more faster than operations written by myself. So I was actually hoping <code>numpy</code> could save me again. Now seems you're right, the answers below are still using <code>for</code> loops</span>
<span class="comment-copy">Alternatively, one might also use <code>pandas</code> for similar functionality.</span>
<span class="comment-copy">Or <code>[list(g) for k, g in groupby(lst, '\n'.__eq__) if not k]</code></span>
<span class="comment-copy">@Kasramvd Very good point. Updated my answer. Mayby slightly less obvious to the beginner's eye, but definitely worth avoiding the lambda.</span>
