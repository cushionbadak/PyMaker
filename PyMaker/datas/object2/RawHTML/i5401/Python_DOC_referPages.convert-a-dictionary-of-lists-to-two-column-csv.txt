<div class="post-text" itemprop="text">
<p>I have a dictionary of lists as follows: </p>
<pre><code>{'banana': [1,2],
 'monkey': [5],
 'cow': [1,5,0],
 ...}
</code></pre>
<p>I want to write a csv that contains one number and word as follows: </p>
<pre><code>1 | banana
2 | banana
5 | monkey
1 | cow
5 | cow
0 | cow
...
</code></pre>
<p>with | as the delimiter. </p>
<p>I tried to convert it to a list of tuples, and write it as follows: </p>
<pre><code>for k, v in dic.items():
    for ID in v: 
        rv.append((ID, k))

with open(index_filename,'wb') as out:
    csv_out=csv.writer(out, delimiter='|')
    csv_out.writerow(['identifier','descriptor'])
    for row in rv:
        csv_out.writerow(row)
</code></pre>
<p>but ran this error: </p>
<pre><code>a bytes-like object is required, not 'str'
</code></pre>
<p>Is there a more efficient way of doing this than converting to a tuple, and if not, what's wrong with my code? </p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are opening the file in binary/bytes mode, which is specified by the "b" in "wb". This is something many people did in the python2 days, when "str" and "bytes" was the same thing, so many older books still teach it this way.</p>
<p>If you open a file in bytes mode, you must write bytes to it, not strings. A <code>str</code> can be converted to bytes with the <code>str.encode()</code> method:</p>
<pre><code>f.write(some_str_variable.encode()
</code></pre>
<p>However, what you probably want instead is to not open the file in bytes mode.</p>
<pre><code>with open(index_filename, 'w') as out:
    ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to make your code more efficient, it is important, that you state with respect to what you want to make it more efficient. Besides terrible solutions, there is often a trade-off between space (memory) and time (cycles, functions calls) among the reasonable solutions.</p>
<p>Aside from efficiency, you should also take readability and maintainability into account. Before doing any kind of optimizations.</p>
<p>Tuples like dicts in Python are very efficient, because they are used internally all over place. Most function calls in Python involve tuple creation (for positional arguments) under the hood.</p>
<p>As to your concrete example, you can use a generator expression to avoid the temporary list:</p>
<pre><code>entries = ((k, v) for k, l in dic.items() for v in l)
</code></pre>
<p>You still have the intermediate tuples, but they are computed on the fly, while you iterate over the dictionary items. This solution would be more memory efficient than an explicit list, especially if you have lots of entries.</p>
<p>You could also just put the nested loop directly into the with body:</p>
<pre><code>with open(index_filename,'wb') as out:
    csv_out=csv.writer(out, delimiter='|')
    csv_out.writerow(['identifier','descriptor'])
    for k, v in dic.items():
        for ID in v: 
            csv_out.writerow((k, ID))
</code></pre>
<p>To avoid the repeated function calls to <code>writerow</code>, you could also resort to <code>writerows</code>, which might be faster.</p>
<pre><code>with open(index_filename,'wb') as out:
    csv_out=csv.writer(out, delimiter='|')
    csv_out.writerow(['identifier','descriptor'])
    csv_out.writerows((k, v) for k, l in dic.items() for v in l)
</code></pre>
<p>If you are really interested in, which method is the fastest, you can use Python's <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer">timeit</a> module to make measurements.</p>
</div>
<span class="comment-copy">You are opening <code>index_filename</code> in binary mode, because you passed the letter <code>'b'</code>, therefore Python expects <code>bytes</code> instead of <code>str</code>. Omit the <code>'b'</code> to open the file in text mode instead, then you can write string data.</span>
