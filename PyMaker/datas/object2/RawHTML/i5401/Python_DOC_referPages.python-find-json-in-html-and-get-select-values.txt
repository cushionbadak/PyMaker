<div class="post-text" itemprop="text">
<p>Gah. I've spent a fair amount of time trying to find how to do this both properly and even hackishly, and I am just stumped. I have 2500+ HTML files that I've downloaded from a site, and I need only to extract a limited amount of information from any given page: the title of the talk described by the page (so I can collate this data with a giant CSV we already have), and then the event at which a given talk was given, and the date on which the talk was published. </p>
<p>The HTML for these pages is sprawling and filled with <code>&lt;script&gt;</code> elements. I want only the one that is followed by a <code>q</code>. The line that starts this block looks like this:</p>
<pre><code>&lt;script&gt;q("talkPage.init", {
</code></pre>
<p>What follows is quite a bit of data. I need only the three items that look like this:</p>
<pre><code>"event":"TEDGlobal 2005",
"filmed":1120694400,
"published":1158019860,
</code></pre>
<p>Luckily, <code>"filmed"</code> and <code>"published"</code> only occur once in this large block, but <code>"event"</code> occurs several times. It's always the same, so I don't care which of these any script grabs.</p>
<p>My thought was to use <strong>BeautifulSoup</strong> to find the <code>&lt;script&gt;q</code> element and then pass that onto the <strong>json</strong> module to parse, but I cannot figure out hot to tell <strong>soup</strong> to grab the <code>&lt;script&gt;</code> element followed by a q -- classes and ids are easy. Followed by ... not so much. </p>
<p>To begin working on the JSON portion, I've created a text file which has only the contents of the <code>&lt;script&gt;q</code> element in it, but I confess that getting the <strong>json</strong> module to load this is not working terribly well. </p>
<p>The code I have for the experiment first loads the text file with the JSON block I'm interested in, and then tries to decode it so I can do other things with it:</p>
<pre><code>import json

text = open('dawkins_script_element.txt', 'r').read()
data = json.loads(text)
</code></pre>
<p>But clearly the JSON decoder doesn't like what I have, because it throws a <code>ValueError: Expecting value: line 1 column 1 (char 0)</code>. Bah!</p>
<p>Here's what the first three lines of this script element looks like:</p>
<pre><code>&lt;script&gt;q("talkPage.init", {
"el": "[data-talk-page]",
"__INITIAL_DATA__":
</code></pre>
<p>And that is where I am at the current moment. Any light that can be shed on either the <strong>soup</strong> or the <strong>json</strong> to get this done would be much appreciated. </p>
</div>
<div class="post-text" itemprop="text">
<p>Without knowing the full context, here's a poor man's attempt:</p>
<p>Assuming your html looks something like this:</p>
<pre><code>&lt;script&gt;foo&lt;/script&gt;
&lt;script&gt;bar&lt;/script&gt;
&lt;script&gt;q("talkPage.init",{
"foo1":"bar1",
"event":"TEDGlobal 2005",
"filmed":1120694400,
"published":1158019860,
"foo2":"bar2"
})&lt;/script&gt;
&lt;script&gt;q("talkPage.init",{
"foo1":"bar1",
"event":"foobar",
"filmed":123,
"published":456,
"foo2":"bar2"
})&lt;/script&gt;
&lt;script&gt;foo&lt;/script&gt;
&lt;script&gt;bar&lt;/script&gt;
</code></pre>
<p>You can code like this:</p>
<pre><code>res = requests.get(url) # your link here
soup = bs4.BeautifulSoup(res.content)
my_list = [i.string.lstrip('q("talkPage.init", ').rstrip(')') for i in soup.select('script') if i.string and i.string.startswith('q')]

# my_list should now be filled with all the json text that is from a &lt;script&gt; tag followed by a 'q'
# note that I lstrip and rstrip on the script based no your sample (assuming there's a closing bracket), but if the convention is different you'll need to update that accordingly.

#...#
my_jsons = []
for json_string in my_list:
    my_jsons.append(json.loads(json_string))

# parse your my_jsons however you want.
</code></pre>
<p>Then you can start interpreting the jsons:</p>
<pre><code>print(my_jsons[0]['event'])
print(my_jsons[0]['filmed'])
print(my_jsons[0]['published'])

# Output:
# TEDGlobal 2005
# 1120694400
# 1158019860
</code></pre>
<p>There's a lot of assumptions here.  That's assuming all your texts within <code>&lt;script&gt;q</code> elements will always be starting with <code>q("talkPage.init",</code> and ending with a <code>)</code>.  Also it's assuming the texts returned follow the json format for your next stage of parsing.  I'm also assuming you have knowledge of how to parse the json results.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a regex expression to match the part you want.</p>
<pre><code>import re
# Filters the script-tag all the way to end ')' of q.
scipt_tag = re.findall(r'&lt;script&gt;q\((?s:.+)\)', t)
json_content = re.search(r'(?&lt;=q\()(?s:.+)\)', script_tag[0]).group()
json_content = json_content[:-1]  # Strip last ')'
</code></pre>
<p>To find the stuff you need you can either use pythons json library to parse it or match the last things with what you want. Since <code>filmed</code> and <code>published</code> are unique and <code>event</code> doesn't differ (as I understood?)</p>
<pre><code>import json
json_content = json.loads(json_content)
json_content['event']  # or whatever
</code></pre>
<p><strong>OR</strong></p>
<pre><code>def get_val(a):
re.search('r(?&lt;=' + a + r'\": )(.+)').group(0)
</code></pre>
<p>The latter needs to be filtered a bit to remove trailing <code>]"</code> and preceding <code>"[</code>, or what not you want from it.</p>
<p>I've heard beautifulsoup is also a good library for matching html-stuff, but im not so familiar with it.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's the script I ended up using, with real thanks to both @Idlehands and @Three. To reach into the weird single-quoted JSON, I took the entire JSON element and read it into a list, split on commas. It's a hack, but it mostly works. </p>
<pre><code>def get_metadata(the_file):

    # Load the modules we need
    from bs4 import BeautifulSoup
    import json
    import re
    from datetime import datetime

    # Read the file, load it into BS, then grab section we want
    text = the_file.read()
    soup = BeautifulSoup(text, "html5lib")
    my_list = [i.string.lstrip('q("talkPage.init", {\n\t"el": "[data-talk-page]",\n\t "__INITIAL_DATA__":')
               .rstrip('})')
               for i in soup.select('script') 
               if i.string and i.string.startswith('q')]

    # Read first layer of JSON and get out those elements we want
    pre_json = '{"' + "".join(my_list)
    my_json = json.loads(pre_json)
    slug = my_json['slug']
    vcount = my_json['viewed_count']
    event = my_json['event']

    # Read second layer of JSON and get out listed elements:
    properties = "filmed,published" # No spaces between terms!
    talks_listed = str(my_json['talks']).split(",")
    regex_list = [".*("+i+").*" for i in properties.split(",")]
    matches = []
    for e in regex_list:
        filtered = filter(re.compile(e).match, talks_listed)
        indexed = "".join(filtered).split(":")[1]
        matches.append(indexed)
    filmed = datetime.utcfromtimestamp(float(matches[0])).strftime('%Y-%m-%d')
    # published = datetime.utcfromtimestamp(float(matches[1])).strftime('%Y-%m-%d')
    return slug, vcount, event, filmed, #published
</code></pre>
</div>
<span class="comment-copy">I'm working with both these answers to see which one works best. I'll have more tomorrow first thing. Thanks for such a thoughtful answer!</span>
<span class="comment-copy">Working through this, I have to use <code>soup = BeautifulSoup(text, "html5lib")</code> because when I try, <code>soup = BeautifulSoup(text.content)</code>, I get <code>AttributeError: 'str' object has no attribute 'content'</code>. I then use the list comprehension, which produces a list one item long, but it has the section we want. Right now, I'm stumbling on the JSON parsing, so that's what I will spend my morning working on. Thanks!</span>
<span class="comment-copy">It depends what your original content is - if it was a <code>request</code> object (in my sample) then you'll want to get the text <code>content</code> for BeautifulSoup to parse.  In your case it seems yours is a <code>str</code> object so just passing the <code>str</code> itself is good enough.  If you're having trouble parsing the json I recommend you get a bit more info on the <a href="https://docs.python.org/3/library/json.html" rel="nofollow noreferrer"><code>json</code> module</a>.</span>
<span class="comment-copy">I've definitely learned how fussy the JSON module is. Some may find this pretty ugly, but to get the JSON module to parse the string I had to do this: <code>pre_json = '{"' + "".join(my_list)</code> and then <code>my_json = json.loads(pre_json)</code></span>
<span class="comment-copy">@JohnLaudun that sounds more like the string being passed to the <code>json</code> module isn't properly formatted.  You'll want to ensure the string result you parsed from the html can be read as a dictionary.  If it's missing the <code>{</code> then it might have been stripped from the html parsing by mistake.</span>
<span class="comment-copy">I like the idea of doing this with <code>regex</code>, which has always exceeded my grasp, but the line <code>script_tag = re.findall(r'&lt;script&gt;q\((?s:.+)\)', text)</code> throws an <code>error: unknown extension</code>. It looks like it doesn't like the closing parenthesis? <code>739                     if char == ")":     740                         break --&gt; 741                     raise error("unknown extension")</code></span>
