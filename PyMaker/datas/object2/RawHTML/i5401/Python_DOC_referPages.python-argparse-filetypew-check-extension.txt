<div class="post-text" itemprop="text">
<p>The <em>argparse</em> package does a great job when dealing with command line arguments. I'm wondering however if there is any way to ask argparse to check for file extension (e.g ".txt"). The idea would be to derived one the class related to <em>argparse.FileType</em>. I would be interested in any suggestion. </p>
<p>Keep in mind that I have more than 50 subcommands in my program all having there own CLI. Thus, I would be interest in deriving a class that could be imported in each of them more than adding some uggly tests in all my commands. </p>
<p>Thanks a lot.</p>
<pre><code># As an example one would be interested in turning this...
parser_grp.add_argument('-o', '--outputfile',
                        help="Output file.",
                        default=sys.stdout,
                        metavar="TXT",
                        type=argparse.FileType('w'))


# Into that...
from somewhere import FileTypeWithExtensionCheck 
parser_grp.add_argument('-o', '--outputfile',
                        help="Output file.",
                        default=sys.stdout,
                        metavar="TXT",
                        type=FileTypeWithExtensionCheck('w', '.[Tt][Xx][Tt]$'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could subclass the <a href="https://docs.python.org/3/library/argparse.html#argparse.FileType" rel="nofollow noreferrer"><code>argparse.FileType()</code> class</a>, and override the <code>__call__</code> method to do filename validation:</p>
<pre><code>class FileTypeWithExtensionCheck(argparse.FileType):
    def __init__(self, mode='r', valid_extensions=None, **kwargs):
        super().__init__(mode, **kwargs)
        self.valid_extensions = valid_extensions

    def __call__(self, string):
        if self.valid_extensions:
            if not string.endswith(self.valid_extensions):
                raise argparse.ArgumentTypeError(
                    'Not a valid filename extension')
        return super().__call__(string)
</code></pre>
<p>You could also support a regex if you really want to, but using <code>str.endswith()</code> is a more common and simpler test.</p>
<p>This takes either a single string, or a tuple of strings specifying valid extensions:</p>
<pre><code>parser_grp.add_argument(
    '-o', '--outputfile', help="Output file.",
    default=sys.stdout, metavar="TXT",
    type=argparse.FileTypeWithExtensionCheck('w', valid_extensions=('.txt', '.TXT', '.text'))
)
</code></pre>
<p>You need to handle this in the <code>__call__</code> method because the <code>FileType()</code> instance is essentially treated like any other <code>type=</code> argument; as a <em>callable</em>, and you can indicate that the specific argument isn't suitable by raising the <code>ArgumentTypeError</code> exception.</p>
</div>
<div class="post-text" itemprop="text">
<p>My solution is to create an closure that does the extension checking:</p>
<pre><code>import argparse

def ext_check(expected_extension, openner):
    def extension(filename):
        if not filename.lower().endswith(expected_extension):
            raise ValueError()
        return openner(filename)
    return extension

parser = argparse.ArgumentParser()
parser.add_argument('outfile', type=ext_check('.txt', argparse.FileType('w')))

# test out
args = parser.parse_args()
args.outfile.write('Hello, world\n')
</code></pre>
<h1>Notes</h1>
<ul>
<li><code>ext_check</code> basically is a wrapper for <code>argparse.FileType</code></li>
<li>It takes an expected extension to check and an openner</li>
<li>For simplicity, the expected extension is in lower case, the filename will be converted to lower case prior to validation</li>
<li><code>openner</code> in this case is an <code>argparse.FileType('w')</code> callable (most likely a function, but I don't care, as long as it is a callable).</li>
<li><p><code>ext_check</code> returns a callable, which is a function called <code>extension</code>. I name it this way, so that the error will come out as followed (note the word <em>extension</em> bellow, which is the name of the function):</p>
<pre><code>error: argument outfile: invalid extension value: 'foo.txt2'
</code></pre></li>
<li><p>Within the <code>extension</code> function, we check the file extension, if passed, we pass the file name to the <code>openner</code>.</p></li>
</ul>
<h1>What I like about this solution</h1>
<ul>
<li>Concise</li>
<li>Require almost no knowledge of how <code>argparse.FileType</code> works since it just act as a wrapper around it</li>
</ul>
<h1>What I don't like about it</h1>
<ul>
<li>Caller has to know about closure to understand how it works</li>
<li>I have no control over the error message. That is why I have to name my inner function <code>extension</code> to get a somewhat meaningful error message as seen above.</li>
</ul>
<h1>Other possible solutions</h1>
<ul>
<li>Create a custom action, see the documentation for argparse</li>
<li>Subclass <code>argparse.FileType</code> as Martijn Pieters has done</li>
</ul>
<p>Each of these solutions has its own strong points and weaknesses</p>
</div>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/15203829/python-argparse-file-extension-checking" title="python argparse file extension checking">stackoverflow.com/questions/15203829/â€¦</a> This should help</span>
<span class="comment-copy">Apparently the original <code>argparse</code> developer included <code>FileType</code> to help with small scripts that routinely take input/output files.  But I think it's most valuable as a model for writing your own <code>type</code> class.  The key thing is that <code>type</code> has to be a callable, whether that's a function or the <code>__call__</code> of a class.</span>
<span class="comment-copy">I would be angry at a program if it rejected my filename because it has the wrong extension. It should care about the file's contents instead.</span>
<span class="comment-copy">One downside to following <code>FileType</code> too closely is that it opens the file or even creates a new one.  In bigger scripts it is better to operate on a file using the <code>with</code> context.  So consider a <code>type</code> that checks <code>filename</code> format, but doesn't actually the file.</span>
<span class="comment-copy">In <a href="https://bugs.python.org/issue13824" rel="nofollow noreferrer">bugs.python.org/issue13824</a> I explore a <code>FileContext</code> class that can check for a file's existence or form, but returns an unopened file, one that can be used directly in a <code>with</code> context.  Handling stdin/out was tricky, since you don't normally want to close those.</span>
<span class="comment-copy">Thank you @Matijn. This is exactly what I was looking for. Best.</span>
<span class="comment-copy">If the <code>type</code> callable returns a <code>ValueError</code> or <code>TypeError</code>, the error message is standardized.  If it returns a <code>ArgumentTypeError</code> (as <code>FileType</code> does), its message is used.  See the <code>parser._get_value</code> method for details.</span>
<span class="comment-copy">I love it. Thank you @hpaulj</span>
<span class="comment-copy">This is a nice workaround. However Matijn solution is closer to what I was looking for. Thank a lot for helping Hai vu.</span>
