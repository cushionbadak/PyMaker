<div class="post-text" itemprop="text">
<p>I'm working on a project that requires the PC to transmit a 4-bit array with another device running Linux. This transmission happens inside a nested for loop in Python, so I hope each transmission has a low delay. I found a lot resources online suggesting transferring files by netcat. However, I'm a bit worried that opening/closing files each time introduces a long delay.</p>
<p>For simple data transmission like this, what's the most efficient way to transmit data?</p>
</div>
<div class="post-text" itemprop="text">
<p>First of all, make sure that you don't establish a new connection every time you want to send some data. If you reconnect every time you run your loop, it will certainly add lots of delay to your communication (no matter what tool you use). Moreover, you might run out of ports on your system based on how fast your loop is and your system setting for TIME_WAIT (this is the time needed for the system to get rid of the unused network connection - if you keep opening too many of them too fast, you will run into problems eventually as you will reach maximum number of open connections).</p>
<p>You can create a socket outside of your loop and write/read it in your loop - thus having the connection establishment delay only once.</p>
<p>Now depending on how time critical your application is, you might want to choose correct network protocol for your communication - 4 bits is awfully little amount of information which is wrapped in half a dozens of layers that contain all kinds of info required by network protocols: network addresses of the source and the destination, control checksums, sequence numbers etc. and so each individual packet can be quite big despite containing only 4 bits of useful info. On the other hand, if you are not running an IOT device, but a computer on ethernet network, then you probably don't need to care about that.</p>
<p>That being said, if you want to be as effective as possible, you probably will want to send the information at the lowest possible level. Take the look at <a href="https://docs.python.org/3/howto/sockets.html" rel="nofollow noreferrer">https://docs.python.org/3/howto/sockets.html</a></p>
<h2>Quick summary</h2>
<p>On the server side do:</p>
<pre><code># create an INET, STREAMing socket
serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# bind the socket to a public host, and a well-known port
serversocket.bind((socket.gethostname(), port_number))
# become a server socket
serversocket.listen(1)
# accept connection from outside
(clientsocket, address) = serversocket.accept()
# now do something with the clientsocket
# in this case, we'll pretend this is a threaded server
while True:
    # receive at most 1 byte of data
    data = clientsocket.recv(1)
    if (not data):
        break
    do_something_with( data )
</code></pre>
<p>On the client side do:</p>
<pre><code># create an INET, STREAMing socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# connect to the server on specific port
s.connect((server_ip_or_hostname, port_number))
data = get_your_for_bits_as_bytestring()
# send the data until there is no more of them or we lose the socket
while (s and data):
    s.sendall(data)
    data = get_your_for_bits_as_bytestring()
</code></pre>
</div>
<span class="comment-copy"><code>netcat</code> isn't magic.  If you're already writing in Python, just use Python's socket module; it's not going to be any slower than spawning a <code>netcat</code> process and piping data to it. Or investigate a messaging library like <a href="http://zeromq.org/" rel="nofollow noreferrer">zmq</a> if you want something higher level than raw sockets.</span>
<span class="comment-copy">Netcat uses TCP which has some inherent overhead. If you can live with the uncertainties of UDP, that's definitely going to be faster. Python (or any socket implementation really) generally supports both UDP and TCP sockets (and a bunch of other special types) so you just have to understand enough of the network stack to decide how low you can go. <i>Really</i> the fastest possible just requires enough money to have 2-3 competent network engineers develop completely your own custom protocol.</span>
