<div class="post-text" itemprop="text">
<p>I have a control box and a Raspberry Pi which communicate over Serial (Serial to RJ45), and I need the commands sent from the control box which are sent every 50ms. I am able to read the code, but here's the issue. When I start reading, the starting byte is incorrect so I am unable to parse it. </p>
<p>For example (The output I am currently getting): </p>
<pre><code>b'\0x21\0x21\0x98\0x98\0x21\0x21\0x18\0x12\0x21\0x12\0x02\0x32\0x11
</code></pre>
<p>The starting byte I need has to be 0x98, so I need it to be like this</p>
<pre><code>b'\0x98\0x98\0x21\0x21\0x18\0x12\0x21\0x12\0x02\0x32\0x11\0x‌​12\0x11
</code></pre>
<p>I need it this way so I can parse the line and say grab Byte[4]-(0x21) or something like that. </p>
<p>In terms of research, I ran into <a href="https://docs.python.org/3/library/struct.html" rel="nofollow noreferrer">Struct</a>. I have no idea how to use this though, and I have no idea if I even need to use it.</p>
<p>I currently don't have a full version of the code on me at this moment, but here is a quick example of what I currently have:</p>
<pre><code>import serial
import time

port = serial.Serial("/dev/ttyS0", baudrate=9600)

while True:
   output = port.read(13) # --- In Total there are 13 Bytes
   print(output)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since you are getting another lot of data every 50mS, you need to be able to sync with the start of the data:</p>
<pre><code>buffer = b''
header = b'\0x98'
while True:
    if port.in_waiting:
        buffer += port.read(port.in_waiting)
    while len(buffer) &gt;= 2:
        if buffer[0] == header and buffer[1] == header:
            break
        buffer=buffer[1:]
    if len(buffer) &gt;= 13:
        print(buffer[:13]) # or otherwise process latest buffer
        buffer = buffer[13:]
</code></pre>
<p>This code starts with an empty buffer and then reads whatever data arrives at the serial port. While the buffer does not start with the two header bytes, any excess at the front is discarded. Once the buffer starts with the right header and is long enough, the 13 bytes are printed here (but you might want to call another function to process a whole packet), and then that packet is thrown away, ready to start with whatever arrives next.</p>
</div>
<span class="comment-copy">You say the sequence you need starts with <code>0x98</code>, whilst what you show has 11 bytes, but your code tries to grab 13 from the serial port. Which is right?</span>
<span class="comment-copy">@quamrana My bad I messed up. The sequence is 13 bytes, so what I need it to be is <code>b'\0x98\0x98\0x21\0x21\0x18\0x12\0x21\0x12\0x02\0x32\0x11\0x12\0x11</code></span>
<span class="comment-copy">There now seems to be another issue at hand. I can't get your code to work because I have over sighted something. The data I'm receiving is either partial data or corrupted data, but I am using the right baudrate because cutecom is working fine. I seem to be having the same issue as this person <a href="https://electronics.stackexchange.com/questions/240697/pyserial-doesnt-read-entire-line">here</a>, but I don't quite understand the answer.</span>
