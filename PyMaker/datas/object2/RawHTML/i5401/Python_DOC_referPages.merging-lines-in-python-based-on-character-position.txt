<div class="post-text" itemprop="text">
<p>I've a file with alternating lines, chords followed by lyrics:</p>
<pre><code>C       G                 Am
See the stone set in your eyes,
         F                   C
see the thorn twist in your side,
  G         Am F
I wait for you
</code></pre>
<p>How could I merge subsequent lines in order to produce an output like the following, while keeping track of the character position:</p>
<pre><code>(C)See the (G)stone set in your (Am)eyes,
see the t(F)horn twist in your s(C)ide,
I (G)wait for y(Am)ou(F)
</code></pre>
<p>From <a href="https://stackoverflow.com/questions/1657299/how-do-i-read-two-lines-from-a-file-at-a-time-using-python">How do I read two lines from a file at a time using python</a> it can be seen that iterating over the file 2 lines at a time can be done with</p>
<pre><code>with open('lyrics.txt') as f:
    for line1, line2 in zip(f, f):
        ...  # process lines
</code></pre>
<p>but how can the lines be merged so that line 2 is split according to character positions (of chords) from line 1? A simple</p>
<pre><code>chords = line1.split()
</code></pre>
<p>has no position information and</p>
<pre><code>for i, c in enumerate(line1):
    ...
</code></pre>
<p>gives separate characters, not the chords.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/re.html#match-objects" rel="nofollow noreferrer">regexp match objects</a> for extracting both position and content of chords from the 1st line. Care must be taken at the edges; the same chord may continue on the next line, and a line may contain chords with no matching lyrics. Both cases can be found in the example data.</p>
<pre><code>import io
import re

# A chord is one or more consecutive non whitespace characters
CHORD = re.compile(r'\S+')

def inline_chords(lyrics):
    for chords, words in zip(lyrics, lyrics):
        # Produce a list of (position, chord) tuples
        cs = [
            # Handles chords that continue to next line.
            (0, None),
            # Unpack found chords with their positions.
            *((m.start(), m[0]) for m in CHORD.finditer(chords)),
            # Pair for the last chord. Slices rest of the words string.
            (None, None)
        ]
        # Remove newline.
        words = words[:-1]

        # Zip chords in order to get ranges for slicing lyrics.
        for (start, chord), (end, _) in zip(cs, cs[1:]):
            if start == end:
                continue

            # Extract the relevant lyrics.
            ws = words[start:end]

            if chord:
                yield f"({chord})"

            yield ws

        yield "\n"
</code></pre>
<p>The edges could be handled differently, for example by testing if the 1st chord begins at <em>0</em> or not before the loop, but I feel that the single for-loop makes for cleaner code.</p>
<p>Trying it out:</p>
<pre><code>test = """\
C       G                 Am
See the stone set in your eyes,
         F                   C
see the thorn twist in your side,
  G         Am F
I wait for you
"""

if __name__ == '__main__':
    with io.StringIO(test) as f:
        print("".join(list(inline_chords(f))))
</code></pre>
<p>produces the desired format:</p>
<pre><code>(C)See the (G)stone set in your (Am)eyes,
see the t(F)horn twist in your s(C)ide,
I (G)wait for y(Am)ou(F)
</code></pre>
</div>
<span class="comment-copy">What have you tried? Please show your code. (Read <a href="https://stackoverflow.com/help/how-to-ask">stackoverflow.com/help/how-to-ask</a>)</span>
<span class="comment-copy">Your failed attempts may seem irrelevant to you, but they can help inform potential answerers on what specifically you're stuck on. "Why isn't this working?" type questions tend to fare better than "How do I do this?" type questions.</span>
