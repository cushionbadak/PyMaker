<div class="post-text" itemprop="text">
<p>When I run a file with some tests (ex. python <strong>test_website_loads.py</strong>) the test runs perfectly and there are no issues, but when I try the testsuite (ex. python <strong>test_suite.py</strong>), the next error occurs:</p>
<pre><code>    from special_module.special_module_file import Special_Class
ModuleNotFoundError: No module named 'specialmodule'
</code></pre>
<p>My directory is as follows:</p>
<pre><code>test_suite.py
tests/
  __init__.py
  test_website_loads.py
  special_module/
    __init__.py
    special_module_file.py
</code></pre>
<p>In my special_module_file I have a class with name <strong>Special_Class</strong> and I am importing such directory in my <strong>test_website_loads.py</strong> as:</p>
<pre><code>from special_module.special_module_file import Special_Class
</code></pre>
<p>My <strong>test_suite.py</strong> code is:</p>
<pre><code>import unittest
import HtmlTestRunner
from tests.test_website_loads import Test_Website_Loads

init_tests = unittest.TestLoader().loadTestsFromTestCase(Test_Website_Loads)

test_suite = unittest.TestSuite([
    init_tests
])

runner = HtmlTestRunner.HTMLTestRunner(output='reports', report_title='Test Report')
runner.run(test_suite) 
</code></pre>
<p>And my <strong>test_website_loads.py</strong> code is:</p>
<pre><code>import unittest
import HtmlTestRunner
from special_module.special_module import Special_Class

class Test_Website_Loads(unittest.TestCase):

    def setUp(self):
        special = Special_Class()

    def ...():
        ...

    def tearDown():
        ...

if __name__ == "__main__":

    unittest.main(
        testRunner=HtmlTestRunner.HTMLTestRunner(output='init')
    )
</code></pre>
<p>In summary there are 3 files (A, B, C). A calls B, B calls C. When I run B, it correctly imports C. But when running A, B throws the ModuleNotFoundError.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is because it's located in the <code>tests</code> directory, but you're running <code>test_suite.py</code> from the parent directory of <code>tests</code>. The reason why it worked when you ran <code>test_website_loads.py</code> is because you were running it from within the <code>tests</code> directory. When resolving imports, the Python interpreter checks a series of locations for the module, starting with the current directory and then moving to other locations such as those in your PYTHONPATH environment variable, and the <code>site-packages</code> directory in your Python install location.</p>
<p>I duplicated this on my system but changed the import statement to <code>tests.special_module.special_module_file</code> and it worked. If you don't like this solution, you will need to change the location of the <code>special_module</code> directory or <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH" rel="nofollow noreferrer">add it to your PYTHONPATH</a> or something similar.</p>
<p><strong>Edit:</strong> In response to your comment below, I assume your <code>test_suite.py</code> file looks something like this:</p>
<pre><code>from tests.test_website_loads import some_function, some_class

result = some_function()
obj = some_class()
</code></pre>
<p>This still runs into the problem described above, because the Python interpreter is still being run in the top-level directory. When it searches for modules, it searches the current directory where it only finds <code>test_suite.py</code> and <code>tests/</code>. Then it checks your PYTHONPATH environment variable. If it still finds nothing, it will check then installation-dependent default location (such as the <code>site-packages</code> directory), and if no such module is found, it throws an exception. I think the best solution would be to add <code>special_module</code> to the PYTHONPATH environment variable as described in the link I included above. Otherwise, you could create a symbolic link to the module in the top-level directory with <code>ln -s tests/special_module special_module</code>, assuming that you're running on a UNIX-like system. However, this would not be considered best practice; the first method is preferred.</p>
</div>
<span class="comment-copy">You are correct indeed, I didn't write an important part, I'm not importing the special module in the test_suite.py, I'm calling it from the test_website_loads.py (In summary, test_suite.py calls test_website_loads.py and  test_website_loads calls the special module but it fails</span>
<span class="comment-copy">Okay, that does help. Could you edit your original question to include this information? Also, if you could add the code from test_suite.py that you are using to call test_website_loads.py, that could also help.</span>
<span class="comment-copy">I believe the main issue is still the one I described in my answer, because even though test_website_loads.py is located within the same directory as the special_module directory, the Python interpreter is still being run from within the parent directory, so it still doesn't know where to find the special_module directory; now it's just a matter of finding a solution.</span>
<span class="comment-copy">@ArturoAviles I edited my original answer to reflect your correction. It should solve your problems. If not, please let me know.</span>
