<div class="post-text" itemprop="text">
<p>I have a dictionary <code>dict = {1:['cup','pen'],2:['one','two'],3:['five']}</code>in which i have to iterate through the first elements of all the <code>keys</code>at first and then the second element.
I have written in below way, but the output in which it,iterates through list <code>index 0</code>first and then <code>index 1</code>.
Any one help me out to modify the code, so that it can iterate all the list's first element's at first and the second element</p>
<pre><code>dict = {1:['cup','pen'],2:['one','two'],3:['five']}
for v in dict.values():
  for i in range (len(v)):
    print v[i]
</code></pre>
<p>Output of above code:</p>
<pre><code>cup
pen
one
two
five
</code></pre>
<p>but want it in this below way :</p>
<pre><code>cup
one
five
pen
two
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using the <a href="https://stackoverflow.com/questions/6473679/transpose-list-of-lists">zipped-transpose idiom</a>, zip upto the longest list with <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer"><code>itertools.zip_longest</code></a>. Then iterate over each item in the sub-lists, filtering out <code>None</code> values.</p>
<pre><code>from itertools import zip_longest

for i in zip_longest(*data.values()):
    for j in filter(None, i):
        print(j)

cup
one
five
pen
two
</code></pre>
<p>Here, <code>data</code> is your input dictionary. Don't use <code>dict</code> to name variables, it shadows the builtin class with the same name.</p>
<p>Note that this order is not guaranteed on python versions below python-3.6, since dictionaries are not ordered in these older versions of python.</p>
<p>Final note, for python-2.x, the appropriate function to be used is <code>itertools.izip_longest</code>. </p>
<hr/>
<p>The output of <code>zip_longest</code> looks like this:</p>
<pre><code>print(list(zip_longest(*data.values())))
[('cup', 'one', 'five'), ('pen', 'two', None)]
</code></pre>
<p>These <code>None</code> values are inserted in place of missing values due to the "zip longest' behaviour of the function. These <code>None</code>s are removed with <code>filter</code>.</p>
<hr/>
<p>You can use this to get creative using <code>itertools.chain</code> and a <code>print</code> statement, accomplishing this in one line:</p>
<pre><code>from itertools import chain
print(*filter(None, chain.from_iterable(zip_longest(*data.values()))), sep='\n')

cup
one
five
pen
two
</code></pre>
<p>Re-written a little more clearly:</p>
<pre><code>print(
   *filter(                                 # `filter` out None (iterable unpacking)       
        None, 
        chain.from_iterable(                # flatten an iterable of iterables
               zip_longest(*data.values())  # zip-longest transpose
       )
    ), 
    sep='\n'                                # separate unpacked arguments with newline
)
</code></pre>
<hr/>
<p>One more option, <s>for homework submission</s> without <code>zip_longest</code>. This just cycles over the keys, popping one element at a time from each list.</p>
<pre><code>while any(bool(v) for v in data.values()):
    for k in data:
        try:
            print(data[k].pop(0))
        except IndexError:
            pass

cup
one
five
pen
two
</code></pre>
<p>This empties <code>data</code> of its contents, so you may want to make a copy of your data beforehand.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could try converting each list in your dictionary to <a href="https://docs.python.org/3.6/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>collections.deqeue()</code></a> objects, then popping off the first item in each queue until all queues are empty:</p>
<pre><code>from collections import deque

d = {1:['cup','pen'],2:['one','two'],3:['five']}

# convert to deques
lsts = [deque(x) for x in d.values()]

# while lsts still has queues to pop
while lsts:

    # go over all the queues again
    for lst in lsts:

        # if it is not empty, pop it off and print it. 
        if len(lst) &gt; 0:
            print(lst.popleft())

    # only keep queues that are not empty
    lsts = [x for x in lsts if x]
</code></pre>
<p>Which Outputs:</p>
<pre><code>cup
one
five
pen
two
</code></pre>
<p>Having shown this possible approach, it does require more work to produce what you want, whereas @cᴏʟᴅsᴘᴇᴇᴅ's answer addresses how to do this very easily. </p>
<p>Also note that you don't need to use <code>collections.deque()</code> here, you can simply pop from lists instead with <code>pop()</code>. I used it for convenience and the <code>O(1)</code> <code>popleft()</code> function. </p>
<p>The only efficiency issue you can run into here is that <code>pop(0)</code> is <code>O(n)</code> for lists. One way around this is reversing the lists beforehand, and calling <code>pop()</code> instead, which results in <code>O(1)</code> behavior. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can try this without any external library:</p>
<pre><code>dict = {1:['cup','pen'],2:['one','two'],3:['five']}



track={}

for i,ja in dict.items():
    for k,n in enumerate(ja):
        if k not in track:
            track[k]=[n]
        else:
            track[k].append(n)

for k in track.values():
    for m in k:
        print(m)
</code></pre>
<p>output:</p>
<pre><code>cup
one
five
pen
two
</code></pre>
</div>
<span class="comment-copy">Thanks, Even i can filter out the "None" values, but is there any normal way using "for loop" we can iterate ?</span>
<span class="comment-copy">@STripathy The "normal way using for loop" is the very first option I gave you.</span>
<span class="comment-copy">I mean not using "itertools.zip_longest"</span>
<span class="comment-copy">Thank you..its useful</span>
<span class="comment-copy">Yes, i tried,it works :-)</span>
<span class="comment-copy">@STripathy Well I'm glad it works :-). Let me know if you don't understand anything.</span>
<span class="comment-copy">Thank you so much.</span>
