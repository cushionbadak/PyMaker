<div class="post-text" itemprop="text">
<p>My function needs to accept an object, from which data can be extracted by index, viz. a <code>List</code> or an instance with defined <code>__getitem__</code> method.</p>
<p>Which type can I use for type hinting this argument?</p>
<p>Update:
As I understand there are presently no such type, I tried to make one myself:</p>
<pre class="lang-py prettyprint-override"><code>class IndexableContainer(Generic[int, ReturnType]):
    def __getitem__(self, key: int) -&gt; ReturnType:
        ...
</code></pre>
<p>But I get the following error:</p>
<pre class="lang-sh prettyprint-override"><code>  File "indexable_container.py", line 22, in IndexableContainer
    class IndexableContainer(Generic[int, ReturnType]):
  File ".../lib/python3.6/typing.py", line 682, in inner
    return func(*args, **kwds)
  File ".../lib/python3.6/typing.py", line 1112, in __getitem__
    "Parameters to Generic[...] must all be type variables")
TypeError: Parameters to Generic[...] must all be type variables
</code></pre>
<p>How should I do it?</p>
</div>
<div class="post-text" itemprop="text">
<p>There are several different ways you can do this.</p>
<p>If you're ok with using only custom classes (that you can write) as indexable containers, all you need to do is to adapt your code and remove that 'int' type parameter:</p>
<pre><code>class IndexableContainer(Generic[ReturnType]):
    def __getitem__(self, key: int) -&gt; ReturnType:
        ...

class MyCustomContainer(IndexableContainer[ReturnType]):
    def __getitem__(self, key: int) -&gt; ReturnType:
        # Implementation here

def requires_indexable_container(container: IndexableContainer[ReturnType]) -&gt; ReturnType:
    # Code using container here
</code></pre>
<p>The issue is, of course, that if you wanted to pass in a plain old list into the function, you wouldn't be able to do so since list doesn't subclass your custom type.</p>
<p>We could maybe special-case certain inputs via clever use of the <code>@overload</code> decorator and unions, but there's a second, albeit experimental, way of doing this known as <a href="http://mypy.readthedocs.io/en/latest/class_basics.html#simple-user-defined-protocols" rel="nofollow noreferrer">Protocols</a>.</p>
<p>Protocols basically let you express "duck typing" in a sane way using type hints: the basic idea is that we can tweak IndexableContainer to become a protocol. Now, any object that implements the <code>__getitem__</code> method with the appropriate signature is counted as a valid IndexableContainer, whether or not they subclass that type or not.</p>
<p>The only caveat is that Protocols are currently experimental and (afaik) only supported by mypy. The plan is to eventually add protocols to the general Python ecosystem -- see <a href="https://www.python.org/dev/peps/pep-0544/" rel="nofollow noreferrer">PEP 544</a> for the specific proposal -- but I haven't kept track of the discussion/don't know what the status of that is.</p>
<p>In any case, to use protocols, install the <code>typing_extensions</code> module using pip. Then, you can do the following:</p>
<pre><code>from typing_extensions import Protocol

# ...snip...


class IndexableContainer(Protocol, Generic[ReturnType]):
    def __getitem__(self, key: int) -&gt; ReturnType:
        ...

def requires_indexable_container_of_str(container: IndexableContainer[str]) -&gt; None:
    print(container[0] + "a")

a = ["a", "b", "c"]
b = {0: "foo", 2: "bar"}
c = "abc"
d = [1, 2, 3]

# Type-checks
requires_indexable_container_of_str(a)
requires_indexable_container_of_str(b)
requires_indexable_container_of_str(c)

# Doesn't type-check
requires_indexable_container_of_str(d)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It seems that the closest we can get is:</p>
<pre><code>Mapping[int, Any]
</code></pre>
<p>Although it's not quite what I wanted, it's close enough.</p>
</div>
<span class="comment-copy">If it is an iterable then you can use this typehint: <a href="https://docs.python.org/3/library/typing.html#typing.Iterable" rel="nofollow noreferrer">docs.python.org/3/library/typing.html#typing.Iterable</a> If not then you should create your own typehint class.</span>
<span class="comment-copy">Unfortunately, it has to be indexable, not iterable. How can I create my own typehinting class?</span>
<span class="comment-copy">You can find an example about this here: <a href="https://docs.python.org/3/library/typing.html#typing.Generic" rel="nofollow noreferrer">docs.python.org/3/library/typing.html#typing.Generic</a></span>
<span class="comment-copy">Sorry, that example is incomplete and I couldn't make it work. Do you have a better one?</span>
<span class="comment-copy">You only have to hint the KeyType and the ValueType. E.g. If the key can be only a string then use <code>str</code>.</span>
<span class="comment-copy">Why isn't this enough? Can you show the usage of the class?</span>
<span class="comment-copy">I guess it does work for the question stated, but I later realised I also need the type to support <code>__delitem__</code> method, which is not provided by <code>Mapping</code>. I didn't know that <code>__getitem__</code> and <code>__delitem__</code> need to be specified separately.</span>
