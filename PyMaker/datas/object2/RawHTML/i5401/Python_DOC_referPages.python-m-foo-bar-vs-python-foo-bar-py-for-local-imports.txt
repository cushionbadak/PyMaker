<div class="post-text" itemprop="text">
<p>I'm trying to run a python file interactively. The file imports other local modules. E.g., I have <code>foo/bar.py</code> and <code>foo/baz.py</code>. I want to run <code>foo/bar.py</code> interactively, and in <code>foo/bar.py</code> I have <code>from foo import baz</code>.</p>
<p>From <code>foo</code>'s parent directory, I can run <code>python -m foo.bar</code>, and the import of baz works fine. But when I want to run interactively with <code>python -i foo/bar.py</code>, the import no longer works (the same is true if I do <code>python foo/bar.py</code>).</p>
<p>Why is that? Can I invoke python differently to get this to work? Am I organizing my code in a strange way?</p>
</div>
<div class="post-text" itemprop="text">
<p>When using the <code>-m</code> option, <a href="https://docs.python.org/3/using/cmdline.html#cmdoption-m" rel="nofollow noreferrer">the current directory will be added to the start of <code>sys.path</code></a>.  In your case, that's the directory which contains <code>foo</code>.  This allows the import statement in <code>bar</code>, i.e. <code>from foo import baz</code>, to be resolved correctly.</p>
<p>When not using the <code>-m</code> option, <a href="https://docs.python.org/3/library/sys.html#sys.path" rel="nofollow noreferrer">the first item in <code>sys.path</code> is the directory containing the script that was used to invoke the Python interpreter</a>.  In your case, that's one dir deeper than before - it's the directory <code>/path/to/foo</code> itself.  This does not allow the import statement <code>from foo import baz</code> to be resolved correctly.  </p>
<blockquote>
<p>Can I invoke python differently to get this to work? </p>
</blockquote>
<p>This should work:</p>
<pre><code>PYTHONPATH=. python foo/bar.py
</code></pre>
<blockquote>
<p>Am I organizing my code in a strange way?</p>
</blockquote>
<p>Not really, but you'll need to get the parent directory of <code>foo</code> onto <code>sys.path</code> somehow.  The best way is to <a href="https://packaging.python.org/" rel="nofollow noreferrer">write a <code>setup.py</code> file</a> and then "install" your code with: </p>
<pre><code>pip install --editable .
</code></pre>
</div>
<span class="comment-copy"><code>python -m foo.bar</code> is calling <code>foo.py</code>, and its sub module <code>bar</code>. <code>python -i foo/bar.py</code> is directly calling <code>bar.py</code>. You are calling different files.</span>
<span class="comment-copy">@Sraw  that's not really what's going on.  <code>foo.py</code> doesn't even exist.</span>
<span class="comment-copy">@win I have realized that I used a wrong term, maybe it should be called <code>package</code> or <code>lib</code> or something else. Anyway, that is an unit in python's module path organization.</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/72852/how-to-do-relative-imports-in-python">How to do relative imports in Python?</a></span>
<span class="comment-copy">A frequent example of <code>-m</code> : <code>timeit</code>'s command-line interface i.e. <code>~$ python3 -m timeit 'for i in range(10): oct(i)'</code>.</span>
<span class="comment-copy">Beware that, with any of these approaches, <code>bar.py</code> can end up being executed <b>twice</b>: once as <code>__main__</code> and once as <code>foo.bar</code>.  It’s best not to pretend that a normal module is sometimes a script; make a dedicated “module” to use with <code>-m</code>.  You can call it <code>__main__.py</code> file and then use the <i>package</i> name with <code>-m</code>.</span>
<span class="comment-copy">Assuming you're doing packaging anyway, then another option is to use the setuptools' <code>entry_points</code>/<code>console_scripts</code>.   See <a href="http://setuptools.readthedocs.io/en/latest/setuptools.html#automatic-script-creation" rel="nofollow noreferrer">here</a>.  It's easier to get right than the <code>__main__.py</code> stuff.</span>
