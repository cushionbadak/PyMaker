<div class="post-text" itemprop="text">
<p>I would like to do pseudo-randomization, meaning to randomize something by respecting certain rules.</p>
<p>Imagine the following DataFrame:</p>
<pre><code>ColX 
 N
 N
 N
 N
 N
 N
 N
 N
 D
 D
 D
</code></pre>
<p>N stands for neutral and D for deviant. Before having a Deviant, I would like to at least have two Neutrals (but there can be more neutrals between deviants) and everything must be in a random order.</p>
<p>As result: ColX should look like</p>
<pre><code>ColX
 N
 N
 D
 N
 N
 N
 D
 N
 N
 N
 D
</code></pre>
<p>I was wondering what kind of function I could use in python (function in pandas or other packages) or R (any function in a library that permits this?)</p>
<p>Thank you in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is the "correct" way of doing it. Correct in the sense that every legal combination is equally likely. The downside is that it is a bit more expensive than @BradSolomon's:</p>
<pre><code>&gt;&gt;&gt; def deviant_sep(N_D, N_N):
...     Didx = np.random.choice(N_N-N_D, N_D, replace=False)
...     out = np.zeros((N_N + N_D,), bool)
...     out[Didx] = True
...     Didx = np.flatnonzero(out[:N_N-N_D])
...     out[Didx] = False
...     out[Didx + np.arange(2, 2*N_D+2, 2)] = True
...     return np.array(['N', 'D'])[out.view(np.int8)]
... 
&gt;&gt;&gt; deviant_sep(3, 8)
array(['N', 'N', 'D', 'N', 'N', 'N', 'N', 'D', 'N', 'N', 'D'],
      dtype='&lt;U1')
&gt;&gt;&gt; deviant_sep(3, 8)
array(['N', 'N', 'D', 'N', 'N', 'N', 'N', 'D', 'N', 'N', 'D'],
      dtype='&lt;U1')
&gt;&gt;&gt; deviant_sep(3, 8)
array(['N', 'N', 'D', 'N', 'N', 'N', 'D', 'N', 'N', 'D', 'N'],
      dtype='&lt;U1')
&gt;&gt;&gt;
&gt;&gt;&gt; from timeit import repeat
&gt;&gt;&gt; repeat('deviant_sep(1000, 8000)', globals=globals(), number=1000)
[0.2079479000531137, 0.20392047404311597, 0.20519483496900648]
</code></pre>
<p>Explanations: I suspect what makes this slow is numpy's <code>choice</code> without replacement function which I think generates a full permutation and then truncates it.</p>
<p>The method works as follows: we can map legal patterns with <code>nD</code> <code>D</code>s and <code>nN</code> <code>N</code>s to patterns with <code>nD</code> <code>D</code>s and <code>nN - 2 nD</code> <code>N</code>s by removing 2 <code>N</code>s before each <code>D</code> and conversely any pattern of the latter kind to a legal pattern by inserting 2 <code>N</code>s before each <code>D</code>. This map is 1-to-1. And the unconstrained patterns we know how to draw with equal probability. So we do just that and then map to legal  patterns by inserting 2 <code>N</code>s before each <code>D</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's one way you can do this with NumPy, with a tiny speedup for looping provided by <a href="https://docs.python.org/3/library/itertools.html#itertools.repeat" rel="nofollow noreferrer">itertools</a>:</p>
<pre><code>from itertools import repeat
import numpy as np


def gen_chunk(high=5):
    """Example: gen_chunk(high=6) --&gt; array(['n', 'n', 'n', 'd']"""
    return np.append(np.repeat('n', np.random.randint(low=2, high=high)), 'd')


def gen_series(chunks=3, high=5):
    return np.concatenate([gen_chunk(high=high) for _ in repeat(None, 3)])


df = pd.DataFrame(gen_series())
</code></pre>
<p>Walkthrough:</p>
<p>You can independently generate each "chunk" of 2 or more N's followed by 1 D.  That is what <code>get_chunk()</code> does above.  In this case, it generates a NumPy array of N's followed by 1 D, where the number of N's is a random integer between 2 and your <code>high</code> parameter.</p>
<p>Then in <code>gen_series()</code>, you can build individual chunks (3 of them is the default here) and concatenate them into a single 1d array.</p>
<p><strong>Update</strong></p>
<p>The above uses a constant <code>high</code> parameter in each chunk's generation.  Perhaps this doesn't meet the definition of psueorandom that you are looking for.  To use a different <code>high</code> with each chunk generation, you could do:</p>
<pre><code>def gen_series(chunks, max_high):
    """Use a randomly selected `high` value for each chunk."""
    highs = np.random.randint(low=3, high=max_high, size=chunks)
    return np.concatenate([gen_chunk(high=high) for high in highs])
</code></pre>
<p>Either construction should be fairly quick:</p>
<pre><code>%timeit gen_series(chunks=1000, high=10)
# 36.9 µs ± 1.93 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
</code></pre>
</div>
<span class="comment-copy">Please stick to one language in your questions and remove one of the tags.</span>
<span class="comment-copy">The <code>At least</code> you are looking for is <code>&gt;</code>.</span>
<span class="comment-copy">@Gregor Yes I want to rearrange the input to meet my criteria. It's not true randomisation it's called pseudo randomisation.</span>
<span class="comment-copy">I'd recommend using a while loop shuffling your vector and a function to check if your criteria are met. Psuedo code: <code>done = check(x); while(!done) {x = shuffle(x); check(x)}</code></span>
<span class="comment-copy">What would be the upper range on the number of (consecutive) N's here?</span>
<span class="comment-copy">@BradSolomon That should be <code>N_N - 2 N_D + 2</code>, I think. But for the <code>1000</code>, <code>8000</code> example it occurs with very low probability.</span>
<span class="comment-copy">Thanks it works but I had to add np.array. I don't understand how I can apply this to a list. I am still novice.</span>
<span class="comment-copy">@PierreJardinet You mean you want the output to be a list? You can simply convert using <code>.tolist()</code> for example <code>deviant_sep(3, 8).tolist()</code>. Or if you want a dataframe `pd.DataFrame(deviant_sep(3, 8), columns=('ColX',)).</span>
<span class="comment-copy">No actually I have already a list of 240 chars with D's (=48) and N's (=192) and I have to mix them up in order to to have at least two N before one D. But you could also have 6 N before one D.</span>
<span class="comment-copy">This answers the question. However how can I make the array constantly of the size of 240?</span>
<span class="comment-copy"><code>gen_series(chunks=1000, high=10)[:240]</code>?</span>
<span class="comment-copy">This doesn't work in my terminal</span>
<span class="comment-copy">Are you using the first or second version from above?  One has a <code>high</code> parameter, the other has a <code>maxhigh</code>.</span>
<span class="comment-copy">nvm us max_high = 10</span>
