<div class="post-text" itemprop="text">
<p>I am trying to determine the interfaces changes of the public parts of a python package to a previous version. This is to help with semantic versioning (MAJOR_CHANGE.MINOR_CHANGE.PATCH) The best way I can think of to do this is the following:</p>
<ol>
<li>Generate stubs files for new version of package (you can do this using <a href="https://github.com/python/mypy/blob/master/mypy/stubgen.py" rel="nofollow noreferrer">stubgen</a>. This gives you the public interface for the whole package, sub packages and modules... </li>
<li>Compare stubs for new and old version of the package.

<ul>
<li>If there are no interface changes, then the new version will just +1 to the PATCH number</li>
<li>If the original interface remains the same but entirly new functions (or attributes) are added, this will be a minor change so +1 to MINOR</li>
<li>If any part of the original interface is changed, it will be a MAJOR breaking change so +1 to MAJOR</li>
</ul></li>
</ol>
<p>So basically, the question is, what is the best way to compare 2 packages of stubs files for these changes? We could compare the AST files although these do not include type info (we could try to use this to get around that <a href="https://github.com/python/typed_ast" rel="nofollow noreferrer">https://github.com/python/typed_ast</a>)</p>
<p>Example stubs file here:</p>
<pre><code># Stubs for positioning.point (Python 3.6)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

import numpy as np
from .exceptions import UnacceptableCartesianCoordinates
from .frame import Frame
from .methods import check_frames_have_common_parent, get_coordinates_of_point_in_frame, lowest_common_parent
from typing import Any

class Point:
    def __init__(self, frame: Frame, point_coordinates: np.ndarray) -&gt; None: ...
    @classmethod
    def from_cartesian(cls: Any, frame: Frame, x: float, y: float, z: float) -&gt; Point: ...
    @classmethod
    def from_cylindrical(cls: Any, frame: Frame, r: float, phi: float, z: float) -&gt; Point: ...
    @classmethod
    def from_spherical(cls: Any, frame: Frame, r: float, theta: float, phi: float) -&gt; Point: ...
    @classmethod
    def from_old_point_in_new_frame(cls: Any, old_point: Point, new_frame: Frame) -&gt; Point: ...
    @classmethod
    def at_origin(cls: Any, frame: Frame) -&gt; Point: ...
    @property
    def frame(self): ...
    def __eq__(self, other: Any) -&gt; bool: ...
</code></pre>
<p>EDIT:</p>
<p>To be extra clear (and with fancy diagrams!) I am looking to compare the public interfaces between 2 Packages, A and B. The best way to generate the public interface with type information is to use <a href="https://github.com/python/mypy/blob/master/mypy/stubgen.py" rel="nofollow noreferrer">stubgen</a>. So, The public interface for packages will be defined by a package of <code>.pyi</code> files.</p>
<p>Then we use a new magic tool (called something snappy like, <code>interface-diff</code>) to compare both of the interfaces for A and B. At the highest level we will then have 4 potential outcomes when comparing the interfaces. </p>
<p>1) MAJOR - Things removed from A AND NOT things added to B</p>
<p><a href="https://i.stack.imgur.com/xQ9ca.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/xQ9ca.png"/></a></p>
<p>2) MAJOR - Things removed from A AND things added to B</p>
<p><a href="https://i.stack.imgur.com/OJRhB.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/OJRhB.png"/></a></p>
<p>3) MINOR - Things added to B AND NOT removed from A</p>
<p><a href="https://i.stack.imgur.com/cBQum.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/cBQum.png"/></a></p>
<p>4) PATCH - A == B</p>
<p><a href="https://i.stack.imgur.com/rbju6.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/rbju6.png"/></a></p>
<p>Happy to write this all myself if someone could put me onto the right lines :)</p>
</div>
<div class="post-text" itemprop="text">
<p>What you need are abstract syntax trees (AST's) of each stub.  No new nodes means patch, new leaf nodes probably means minor (depends on language and location of node) and new non-leaf nodes means major.  But that's not the entire solution really, because not all breaking changes show up at the interface stubs.  You also need to have functional verification that any new implementation of the existing interfaces, actually satisfy the documented behaviors (contracts) and that use of any new interfaces doesn't break the old interfaces.</p>
<p>You should be able to find good parser/AST implementations among the publicly available Python implementations.  You can use AST's of the old and new implementations to find potential breaking changes behind existing interfaces!</p>
</div>
<span class="comment-copy">This may help to compare the signature of functions in stub files <a href="https://docs.python.org/3/library/inspect.html#inspect.signature" rel="nofollow noreferrer">docs.python.org/3/library/inspect.html#inspect.signature</a></span>
<span class="comment-copy">and <a href="https://docs.python.org/3.5/library/inspect.html#inspect.getmembers" rel="nofollow noreferrer">docs.python.org/3.5/library/inspect.html#inspect.getmembers</a> will help get the overall structure of a module based on the stubs or just of the source code directly</span>
<span class="comment-copy">Take the <a href="https://stackoverflow.com/tour">tour</a>, read <a href="https://stackoverflow.com/questions/how-to-ask">How to Ask</a> and <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>.</span>
<span class="comment-copy">Yes, that's good for a per stub comparison. But how do you capture the overall structure of the package and sub packages? Is there a higher level tree(package)/branch(sub package)/leaf(module) way of capturing the structure of the whole source directory?</span>
<span class="comment-copy">Now that's a really interesting problem.  Given any arbitrary node in the file system directory structure, build one or more possibly disjoint AST's, for all parsable content therein. Identify transitive dependencies with interface or behavioral modifications and identify the highest semver bump required to cover them.  The problem is generally intractable due to linkages between parts of that tree and interfaces/implementations that are merely referenced.  If your graph is contained entirely within local storage, you definitely have a shot at it. Build systems process that graph all the time.</span>
