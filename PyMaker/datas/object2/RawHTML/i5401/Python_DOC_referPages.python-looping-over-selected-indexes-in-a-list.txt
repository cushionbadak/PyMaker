<div class="post-text" itemprop="text">
<p>Let's say I have a list of 10 numbers: <code>a = [0,1,2,3,4,5,6,7,8,9]</code></p>
<p>I want to get the 2nd digit, the 5-8th digits, and the last digit.  Something like:</p>
<pre><code>for i in (a[1], a[4:7], a[9]):
    print(i)
</code></pre>
<p>How would I do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="noreferrer">operator.itemgetter</a></p>
<pre><code>import operator
stuff = operator.itemgetter(1,4,5,6,-1)
for thing in stuff(a):
  print(thing)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import itertools

for i in itertools.chain(a[1:2], a[4:7], a[9:10]):
    print(i)
</code></pre>
<p>You need to use single-element slices because <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer"><code>itertools.chain</code></a> requires each arg to be an iterable.</p>
<p>For a dynamic list of iterables, you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain.from_iterable</code></a>:</p>
<pre><code>iterables = [a[1:2], a[4:7], a[9:10]]
for i in itertools.chain.from_iterable(iterables):  # Better than chain(*iterables)
    print(i)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>use the unpacking operator <code>*</code></p>
<pre><code>for i in (a[1], *a[4:7], a[9]):
    print(i)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could build a new list of the elements you want:</p>
<pre><code>for i in (a[1:2]+a[4:7]+a[9:10]):
    print(i)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could also do:</p>
<pre><code>for i in [1] + range(4,8) + [9]:
    print a[i]
</code></pre>
</div>
<span class="comment-copy">Simple addition: <code>for i in a[1] + a[4:7] + a[9]:</code></span>
<span class="comment-copy">Consider combining this with a function that parses human-readable ranges as strings. <code>"1, 4-6, -1" -&gt; operator.itemgetter(1, 4, 5, 6, -1)</code>.</span>
<span class="comment-copy">@AdamSmith - Are you saying use a function's return value as itemgetter's argument?  I'll have to think about that, distinguishing between the <code>-6</code> and the <code>-1</code> in that string might be tricky.</span>
<span class="comment-copy">Something like <a href="https://repl.it/repls/LeadingDistantWoodcock" rel="nofollow noreferrer">this</a>?</span>
<span class="comment-copy">@AdamSmith - the first thing that came to my mind was to use regular expressions, <a href="https://repl.it/repls/NewHandmadeBison" rel="nofollow noreferrer">like this</a>, but it is pretty much the same as yours</span>
<span class="comment-copy">ooh you're totally right about the single-element slices. I deleted my (rather duplicate) answer, but you may want to include my bit about <code>itertools.chain.from_iterable</code> if they have a list of slices already.</span>
<span class="comment-copy">Is there a way to turn the <code>itertools.chain</code> into a range?  <code>range(len(itertools.chain(a[1:2], a[4:7], a[9:10])))</code> doesn't work.</span>
<span class="comment-copy">@Valachio <code>chain</code> returns an iterable, which doesn't support <code>len</code>. To use it in the way you describe, make it a list first: <code>a = list(itertools.chain(a[1:2], a[4:7], a[9:10])); range(len(a))</code>. However, if that's your use-case, you're better off using list concatenation (see Scott Hunter's answer).</span>
<span class="comment-copy">@BrianRodriguez Perfect, thanks.  I wish I can give more than 1 checkmark for all the great answers.</span>
<span class="comment-copy">@Valachio TBH, I think wwii's answer is the best solution for this particular question since you only want the indicies from a particular list: <code>opterator.itemgetter(1, 4, 5, 6, 9)(a) == (a[1], a[4], a[5], a[6], a[9])</code>.</span>
<span class="comment-copy"><code>for i in [a[1]]+a[4:7]+[a[9]]:</code></span>
