<div class="post-text" itemprop="text">
<p>Below is my counter, how do I only print the first 3 </p>
<pre><code>Counter({'Pittsburgh': 494.51, 'Austin': 380.6, 'Fort Worth': 368.45,
         'New York': 297.8, 'Stockton': 248.18, 'Omaha': 236.63,
         'San Jose': 215.05, 'San Diego': 67.08, 'Corpus Christi': 26.38})
</code></pre>
<p>I have tried doing that however it becomes an error</p>
<pre><code>print(Counter[0,1,2])
</code></pre>
<p>I just want to print</p>
<pre><code>{'Pittsburgh': 494.51, 'Austin': 380.6, 'Fort Worth': 368.45}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A <code>Counter()</code> representation shows the contents in <em>sorted order</em> from most to least common (so highest to lowest count). Use the <a href="https://docs.python.org/3/library/collections.html#collections.Counter.most_common" rel="nofollow noreferrer"><code>Counter.most_common()</code> method</a> to get the top N key-value pairs in the same ordering:</p>
<pre><code>counts = Counter({'Pittsburgh': 494.51, 'Austin': 380.6, 'Fort Worth': 368.45, 'New York': 297.8, 'Stockton': 248.18, 'Omaha': 236.63, 'San Jose': 215.05, 'San Diego': 67.08, 'Corpus Christi': 26.38})
for city, count in counts.most_common(3):
    print(city, count, sep=': ')
</code></pre>
<p>If you wanted a regular dictionary with just those top N elements, pass the output of <code>Counter.most_common()</code> to <code>dict()</code>:</p>
<pre><code>print(dict(counts.most_common(3)))
</code></pre>
<p>Just take into account that prior to Python 3.6, dictionaries do not retain order and so the exact output order may differ, but it will contain the top 3 results.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; counts = Counter({'Pittsburgh': 494.51, 'Austin': 380.6, 'Fort Worth': 368.45, 'New York': 297.8, 'Stockton': 248.18, 'Omaha': 236.63, 'San Jose': 215.05, 'San Diego': 67.08, 'Corpus Christi': 26.38})
&gt;&gt;&gt; for city, count in counts.most_common(3):
...     print(city, count, sep=': ')
...
Pittsburgh: 494.51
Austin: 380.6
Fort Worth: 368.45
&gt;&gt;&gt; print(dict(counts.most_common(3)))
{'Pittsburgh': 494.51, 'Austin': 380.6, 'Fort Worth': 368.45}
</code></pre>
<p>The <code>Counter.__repr__</code> representation method uses the same <code>Counter.most_common()</code> method to produce the output order you see.</p>
</div>
<span class="comment-copy">Define 'first 3'; a <code>Counter</code> is a dictionary, and dictionaries have no ordering.</span>
<span class="comment-copy">I just want to print {'Pittsburgh': 494.51, 'Austin': 380.6, 'Fort Worth': 368.45} @MartijnPieters</span>
<span class="comment-copy">you want <code>.most_common()</code> ?</span>
<span class="comment-copy">Ohh i actually am able to print it out now using the above method. Thx alot for the help</span>
<span class="comment-copy">Wait, <i>confused</i>, so is <code>Counter()</code> ordered or not? Are you saying it's not but <code>print</code>/<code>repr</code> actually does the sorting but calling <code>.most_common()</code> under the hood?</span>
<span class="comment-copy">Great answer. Just out of curiosity, how would you rate the performance of your <code>most_common()</code> solution vs something like <code>sorted(counts.items(), key = itemgetter(1), reverse = True)[:3]</code>? Does <code>most_common()</code> do basically the same thing under the hood? I apologize if this is a silly question.</span>
<span class="comment-copy">@Chris_Rands: it is unordered, when you iterate over a counter it produces keys in hash table order.</span>
<span class="comment-copy">@Chris_Rands: since <code>__repr__</code> is seen as <i>debugging support</i>, the cost for calling <code>.most_common()</code> is seen as worth it because it makes the output a little more helpful, given that you usually use counters to surface that information.</span>
<span class="comment-copy">@RoadRunner: <code>most_common()</code> uses a heap queue to produce the order when N &lt; K (length of the counter), which is O(KlogN) solution. Sorting is O(NlogN). So yes, sorting would be <i>slower</i> here, because you are doing way more work than is needed (you don't need to order all K elements, only the top N).</span>
