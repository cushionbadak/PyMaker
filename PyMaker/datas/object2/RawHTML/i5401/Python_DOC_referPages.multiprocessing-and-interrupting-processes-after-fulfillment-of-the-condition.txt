<div class="post-text" itemprop="text">
<p>I have an algorithm where I divide the <code>big</code> list into two-element pieces written in a dictionary, then in the function<code>doit</code> I check if the number <code>3</code> is in the first place in the given element, if so, I return the whole element, and if not, I return <code>None</code>. Then I wanted to enter a multiprocessing in these divisions and return only the fastest found one. I have this code:</p>
<pre><code>import multiprocessing as mul

big = [[0,1],[3,0],[1,5],[0,3],[3,1],[0,6],[0,1],[3,2],[1,5],[0,3],[3,3],[0,6],[0,1],[3,4],[1,5],[0,3],[3,5],[0,6],[0,1],[3,6],[1,5],[0,3],[3,7],[0,6],[0,1],[3,8],[1,5],[0,3],[3,9],[0,6],[0,1],[3,10],[1,5],[0,3],[3,11],[0,6]]

sources={}
for x in range(int(len(big)/2)):
    sources["d{0}".format(x)] = big[2*x:2*x+2]

def doit(L):
        for i in L:
            if i[0]==3:
                return i
        return None

def foo(j):  
    return doit(sources["d{0}".format(j)])

if __name__ == '__main__':

    pool = mul.Pool(4)

    for x in pool.map(foo, range(int(len(big)/2))):
        print (x)
        if x == None:
           break

    pool.close()
    pool.join()
</code></pre>
<p>But I am doing something wrong, because I do not notice the parallelism of processes in the results, because all the time I receive:</p>
<pre><code>[3, 0]
None
</code></pre>
<p>And I expected that it will not always be a pair of <code>[3,0]</code>.</p>
<p>How to change it?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>Pool.map</code> will return you the results in order you asked for them. So, <code>pool.map(foo, 'abc')</code> will return <code>[foo('a'), foo('b'), foo('c')]</code> regardless of what order the subprocesses actually calculated the values. Additionally, because its map and not imap, it has to build up the entire result list before it is returned to you.</p>
<p>To get results as they arrive (as a generator not a list and in the order they finish), use <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.imap_unordered" rel="nofollow noreferrer"><code>Pool. imap_unordered</code></a>:</p>
<pre><code>for x in pool.imap_unordered(foo, range(int(len(big)/2))):
    # ...
</code></pre>
</div>
