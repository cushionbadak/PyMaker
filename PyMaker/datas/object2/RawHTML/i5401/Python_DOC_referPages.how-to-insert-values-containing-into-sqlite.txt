<div class="post-text" itemprop="text">
<pre><code>conn = sqlite3.connect(self.__database_name)
c = conn.cursor()
sql = 'INSERT OR IGNORE INTO ' + self.__article_url_table_name + ' (url) values (%s)' % (href)
c.execute(sql)
conn.commit()
</code></pre>
<p>I get the following error in the line where I call: c.execute(sql)</p>
<blockquote>
<p>sqlite3.OperationalError: near "/": syntax error</p>
</blockquote>
<p>The url variable is a string which contains a url like: <a href="https://www.foo.com/bar.html" rel="nofollow noreferrer">https://www.foo.com/bar.html</a></p>
<p>What is the error in my code ?</p>
</div>
<div class="post-text" itemprop="text">
<p>You should not be using string interpolation to write SQL queries. Quite apart from the problem you're having, it leaves you open to SQL injection. Use parameters instead:</p>
<pre><code>sql = 'INSERT OR IGNORE INTO ' + self.__article_url_table_name + ' (url) values (?)'
c.execute(sql, (href,))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The error is that you're not using the db-api the right way. You are building the sql query using string formatting:</p>
<pre><code>sql = "INSERT OR IGNORE INTO some_table (url) values (%s)" % href
</code></pre>
<p>This leads to two problems. </p>
<p>The first one is correct handling of quoting and escaping. In your case you could work around by adding quotes around the format sign ie:</p>
<pre><code>sql = "INSERT OR IGNORE INTO some_table (url) values ('%s')" % href
</code></pre>
<p>but this will still break if <code>href</code> contains quotes.</p>
<p>The second and much more important problem is that <a href="http://bobby-tables.com/" rel="nofollow noreferrer">your code is now opened to sql injection attacks</a>.</p>
<p>The correct use of the db-api will solve both problems: just use your dp-api module's placeholder (for sqlite it's a '?') in the sql string and pass arguments to the <code>cursor.execute()</code> call. Your db-api module will then take care of proper quoting / escaping AND will properly sanitize your arguments to prevent sql injections:</p>
<pre><code>sql = "INSERT OR IGNORE INTO some_table (url) values (?)"
c.execute(sql, (href,))
</code></pre>
<p>Note that this doesn't work for table names, only for values passed to a select, insert or delete query, so in your case you'll still have to use string formatting for the table name:</p>
<pre><code>sql = "INSERT OR IGNORE INTO {} (url) values (?)".format(self.__article_url_table_name)
c.execute(sql, (href,))
</code></pre>
<p>Totally unrelated by I noticed you use the <code>__private</code> naming convention for your class attributes. This convention triggers a name-mangling mechanism that is mainly intended to prevent <em>accidental</em> override of some attribute. Practically, this is almost never needed (eventually for some implementation detail of a base class in a framework, and even then) and can be really annoying. The convention for "implementation attributes" is to use a single leading underscore, which is understood by all python programmers as "implementation detail, don't mess with this or you're on your own". </p>
</div>
<span class="comment-copy">Just read the introduction section of <a href="https://docs.python.org/3/library/sqlite3.html" rel="nofollow noreferrer">docs.python.org/3/library/sqlite3.html</a> which already tells you why you're doing it double wrong.</span>
<span class="comment-copy">ah thanks! But if you're trying to avoid accidental override of some attribute, what are you supposed to do without being annoying ?</span>
<span class="comment-copy">Ask yourself: what are the chances someone is going to accidentally override this attribute, and what would  be the consequences ? If you look at a rather large and very widely used framework like Django, there must be less than half a dozen attributes using  <code>__private</code> names, and not even in the most important parts of the framework. If this class is part of a private project with a couple dev working on it the chances of an accidental override are rather low (and it would probably be catched immediatly by unittests).</span>
