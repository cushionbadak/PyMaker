<div class="post-text" itemprop="text">
<pre><code># df

                          date  value
0   2018-01-22 01:01:53.192824  1
1   2018-01-22 01:01:55.042070  2
2   2018-01-22 01:01:56.264234  3
3   2018-01-22 01:01:57.697656  2
4   2018-01-22 01:01:57.831543  2
5   2018-01-22 01:02:00.258684  1
6   2018-01-22 01:02:00.259691  3
7   2018-01-22 01:02:00.260698  2
8   2018-01-22 01:02:00.261683  1
9   2018-01-22 01:02:00.333109  2
</code></pre>
<p>My goal is to make a dictionary that has keys that are correspond to each minute and the result of a calcuation of the last 3 values at each time.</p>
<p>The calculation is to accumulate 1 if the series of the last 3 values at a moment does not continuously rise or fall.</p>
<p>To simply put, if the last 3 values at a moment are like either ↘↗ or ↗↘, you add 1 to its key.</p>
<p>For example, at 2018-01-22 01:01:56.264234, the last 3 values are 1, 2, 3 and they are increasing, you don't add 1. </p>
<p>But at 2018-01-22 01:01:57.697656, the last 3 values are 2, 3, 2 and they are like ↗↘ and you add 1.</p>
<p>The dataframe above will make a dictionary like:</p>
<pre><code>dic_result = { np.datetime('2018-01-22 01:01'): 1,  # [2, 3, 2]
               np.datetime('2018-01-22 01:02'): 3 } # [2, 1, 3], [1, 3, 2], [2, 1, 2]
</code></pre>
<p>This is what I programmed to do this job and it works fine, but it takes too much time if the dataframe is big. 
I hope to know how I can improve this code and get better performances, for instance, using numpy arrays or better algorithms.</p>
<pre><code># I used deque to store last 3 values
deq_3_trs = deque(maxlen=3)             
dic_result = {}

for i in range( len(df) ):
    date = df.ix[i]['date']
    date_min = np.datetime64(date, 'm')
    value = df.ix[i]['value']

    deq_3_trs.append(value)

    if (date_min not in dic_result) and (len(deq_3_trs) == 3):
        dic_result[date_min] = 0

        # check the deque if the values are like either ↘↗ or ↗↘
        if (deq_3_trs[0] &gt; deq_3_trs[1] &lt; deq_3_trs[2]) or (deq_3_trs[0] &lt; deq_3_trs[1] &gt; deq_3_trs[2]):
            dic_result[date_min] += 1

    elif (date_min in dic_result) and (len(deq_3_trs) == 3):

        # check the deque if the values are like either ↘↗ or ↗↘
        if (deq_3_trs[0] &gt; deq_3_trs[1] &lt; deq_3_trs[2]) or (deq_3_trs[0] &lt; deq_3_trs[1] &gt; deq_3_trs[2]):
            dic_result[date_min] += 1
</code></pre>
<p>FLOW CHART in cases i==0, i==2 and i==3</p>
<pre><code>0   2018-01-22 01:01:53.192824  1
1   2018-01-22 01:01:55.042070  2
2   2018-01-22 01:01:56.264234  3
3   2018-01-22 01:01:57.697656  2
4   2018-01-22 01:01:57.831543  2
5   2018-01-22 01:02:00.258684  1
6   2018-01-22 01:02:00.259691  3
7   2018-01-22 01:02:00.260698  2
8   2018-01-22 01:02:00.261683  1
9   2018-01-22 01:02:00.333109  2



If i == 0 in the FOR loop,

date == 2018-01-22 01:01:53.192824
date_min == numpy.datetime64('2018-01-22T01:01')
value == 1

deq_3_trs == deque([1], maxlen=3)

Since len(deq_3_trs) != 3, the FOR loop ends now.


If i == 2 in the FOR loop,

date == 2018-01-22 01:01:56.264234
date_min == numpy.datetime64('2018-01-22T01:01')
value == 3

deq_3_trs == deque([1, 2, 3], maxlen=3)

Since len(deq_3_trs) == 3 and the dictionary dic_result has no key as 'numpy.datetime64('2018-01-22T01:01')',
it creats the key and defaults it to 0. dic_result == { 'numpy.datetime64('2018-01-22T01:01')':0 }

The series of values in the deque is not like ↘↗ or ↗↘, the FOR loop ends now.


If i == 3 in the FOR loop,

date == 2018-01-22 01:01:57.697656
date_min == numpy.datetime64('2018-01-22T01:01')
value == 2

deq_3_trs == deque([2, 3, 2], maxlen=3)

Since len(deq_3_trs) == 3 and the dictionary dic_result has the 'numpy.datetime64('2018-01-22T01:01')' and 
the series of values in the deque is like ↗↘, it adds 1 to the key. dic_result == { 'numpy.datetime64('2018-01-22T01:01')':1 }
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This might work. Iterating rows never seems ideal, but you might benefit from <a href="https://docs.python.org/3/library/collections.html" rel="nofollow noreferrer">collections</a>.</p>
<pre><code>import pandas as pd
from collections import defaultdict

df = pd.DataFrame([['2018-01-22 01:01:53.192824', 1], ['2018-01-22 01:01:55.042070', 2],
                   ['2018-01-22 01:01:56.264234', 3], ['2018-01-22 01:01:57.697656', 2],
                   ['2018-01-22 01:01:57.831543', 2], ['2018-01-22 01:02:00.258684', 1],
                   ['2018-01-22 01:02:00.259691', 3], ['2018-01-22 01:02:00.260698', 2],
                   ['2018-01-22 01:02:00.261683', 1], ['2018-01-22 01:02:00.333109', 2]],
                  columns=['date', 'value'])

df['date'] = pd.to_datetime(df['date'])
df = df.set_index('date')
df.index = df.index.map(lambda x: x.replace(second=0).replace(microsecond=0))

result = defaultdict(list)

def not_noninc_or_nondec(L):
    return not (all(x&gt;=y for x, y in zip(L, L[1:])) or all(x&lt;=y for x, y in zip(L, L[1:])))

for i, (idx, row) in enumerate(df.iterrows()):
    if i &gt;= 2:
        result[idx].append(not_noninc_or_nondec(df['value'][i-2:i+1].tolist()))

result_count = {k: sum(v) for k, v in result.items()}

# {Timestamp('2018-01-22 01:01:00'): 1, Timestamp('2018-01-22 01:02:00'): 3}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>@jp_data_analysis Your solution looks very good. In addition, I suggest the following code for <code>not_noninc_or_nondec()</code> which is simpler to understand:</p>
<pre><code>def not_noninc_or_nondec(L):
    return (L[0]-L[1])*(L[1]-L[2]) &lt; 0
</code></pre>
</div>
<span class="comment-copy">Look at the structure of your <code>if</code> statements; there is a fair bit of redundancy there.  Don't think it will speed things up much, though; maybe you should use a compiled language?</span>
<span class="comment-copy">Can you please clearly indicate your expected output and how it is generated?</span>
<span class="comment-copy">@Scott Hunter Thank you for the answer. I thought of using C in the code, but I wonder if there are more simple ways to deal with it.</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ Thank you for your help. I added some flowchart to explain how the loop works. My expected output with the simple dataframe will be like the dictionary that has two keys the values of which are 1, 3.</span>
<span class="comment-copy">Thank you for your help! Have a good day! :)</span>
<span class="comment-copy">Noted. I will keep my code as it is for now because it's then more naturally extendable.</span>
