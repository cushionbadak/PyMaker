<div class="post-text" itemprop="text">
<p>I have list:</p>
<pre><code>print (L)
[('bar', 'one'), ('bar', 'two'), ('baz', 'one'), 
 ('baz', 'two'), ('foo', 'one'), ('qux', 'one'), 
 ('qux', 'two'), ('oof', 'two'), ('oof', 'one'), ('oof', 'three')]
</code></pre>
<p>I want grouping by first element in tuples and  filter all tuples which contains <code>one</code> and <code>two</code> as second element.</p>
<p>So need filter out <code>('oof', 'two')</code> and <code>('foo', 'one')</code> because only one element for <code>foo</code> and 3 elements for <code>oof</code>. </p>
<p>Expected output - for each first element <code>bar</code>, <code>baz</code> second is <code>one</code> and <code>two</code> and length is 2: </p>
<pre><code>print(L1)   
[('bar', 'one'), ('bar', 'two'), 
 ('baz', 'one'), ('baz', 'two'), 
 ('qux', 'one'), ('qux', 'two')]
</code></pre>
<p>I try:</p>
<pre><code>L = [b in ['one','two'] for a,b in L]
print (L)
[True, True, True, True, True, True, True, True]
</code></pre>
<p>What is nice/pythonic solution for it?</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a solution using <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="noreferrer"><code>groupby</code></a>:</p>
<pre><code>import itertools, operator

# group the tuples by the first element
result = itertools.groupby(sorted(L), key=operator.itemgetter(0))
# convert the groups to lists
result = [list(group) for _, group in result]
# filter out those lists that don't contain exactly "one" and "two"
result = [group for group in result if set(y for x, y in group) == {'one', 'two'}]
# flatten the nested list into a list of tuples
result = [x for group in result for x in group]

print(result)
</code></pre>
<hr/>
<p>Note that this doesn't care about duplicate tuples:</p>
<pre><code>L = [('bar', 'one'), ('bar', 'two'), ('bar', 'two')]
# result = [('bar', 'one'), ('bar', 'two'), ('bar', 'two')]
</code></pre>
<p>If you don't want these in your output, you can rewrite the filter condition (the 2nd list comprehension) like so:</p>
<pre><code>result = [group for group in result if
             set(y for x, y in group) == {'one', 'two'} and len(group) == 2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could have done this via pandas groupby i.e </p>
<pre><code>L = [('bar', 'one'), ('bar', 'two'), ('baz', 'one'), 
 ('baz', 'two'), ('foo', 'one'), ('qux', 'one'), 
 ('qux', 'two'), ('oof', 'two'), ('oof', 'one'), ('oof', 'three'),
 ('new','five'),('new','six')]

df  = pd.DataFrame(L)

s = df.groupby(0).size()
temp = s[s==2].index

idx = df[df[0].isin(temp)].groupby(0)[1].apply(lambda x : all(x.isin(['one','two'])))

df[df[0].isin(idx[idx].index)].apply(tuple,1).tolist()

[('bar', 'one'),
 ('bar', 'two'),
 ('baz', 'one'),
 ('baz', 'two'),
 ('qux', 'one'),
 ('qux', 'two')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What about this in one line ?</p>
<pre><code>data=[('bar', 'one'), ('bar', 'two'), ('baz', 'one'),
 ('baz', 'two'), ('foo', 'one'), ('qux', 'one'),
 ('qux', 'two'), ('oof', 'two'), ('oof', 'two')]

from itertools import groupby

print(list(filter(lambda x:len(x)==2 and sorted((x[1][1],x[0][1]))==['one','two'],[list(b) for a,b in groupby(data,key=lambda x:x[0])])))
</code></pre>
<p>output:</p>
<pre><code>[[('bar', 'one'), ('bar', 'two')], [('baz', 'one'), ('baz', 'two')], [('qux', 'one'), ('qux', 'two')]]
</code></pre>
<p>detailed :</p>
<pre><code>data=[('bar', 'one'), ('bar', 'two'), ('baz', 'one'),
 ('baz', 'two'), ('foo', 'one'), ('qux', 'one'),
 ('qux', 'two'), ('oof', 'two'), ('oof', 'one'), ('oof', 'three')]

dublicates={}

for i in data:
    if i[0] not in dublicates:
        dublicates[i[0]]=[i[1]]
    else:
        dublicates[i[0]].append(i[1])
print(dublicates)


final=[]
for j,i in dublicates.items():
    if len(i)==2:
        if 'one' and 'two' in i:
            final.extend([(j,'one'),(j, 'two')])

print(final)
</code></pre>
<p>output:</p>
<pre><code>[('baz', 'one'), ('baz', 'two'), ('qux', 'one'), ('qux', 'two'), ('bar', 'one'), ('bar', 'two')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The builtin <code>sorted</code> does this automatically. When sorting a list of tuples, it will sort by the first item, then the second and so on.</p>
<pre><code>from pprint import pprint
def is_interesting(element):
    a, b = element
    return b in ('one', 'two')

result = sorted(filter(is_interesting, some_list))
pprint(result)
</code></pre>
<p>The output would be</p>
<pre><code>[('bar', 'one'),
 ('bar', 'two'),
 ('baz', 'one'),
 ('baz', 'two'),
 ('foo', 'one'),
 ('oof', 'two'),
 ('qux', 'one'),
 ('qux', 'two')]
</code></pre>
</div>
<span class="comment-copy">I personally think, that this is already elegant for the given situation.</span>
<span class="comment-copy"><code>[item for item in L if item[1] in ["one", "two"]]</code></span>
<span class="comment-copy">What do you mean by grouping? Are the items already sorted?</span>
<span class="comment-copy">I think yes, there are sorted by first element.</span>
<span class="comment-copy"><code>sorted</code> does this automatically; it'll sort by the first item in the tuples, then the second and so on. <code>from pprint import pprint;pprint(sorted(L))</code> -- You can combine that with the builtin <code>filter</code> and a separate filter function and it may look better than a comprehension.</span>
<span class="comment-copy">Thank you for explanation!</span>
<span class="comment-copy">You are really close, maybe need flattening add to the end of your solution?</span>
<span class="comment-copy">@jezrael check now.</span>
<span class="comment-copy">Thank you, upvoted solution. If you want, you can also upvote my question ;) Thanks.</span>
<span class="comment-copy">@jezrael check one line solution and yeah i have upvoted your question :)</span>
<span class="comment-copy">Thank you very much.</span>
<span class="comment-copy">So sorry I was not so unclear, I need also filter out <code>('oof', 'two'), ('oof', 'one'), ('oof', 'three')</code> because 3 elements.</span>
<span class="comment-copy">I need exactly 2 elements and this elemenst are <code>one</code> and <code>two</code>. Maybe filter by set is necessary I guess.</span>
