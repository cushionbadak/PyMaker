<div class="post-text" itemprop="text">
<p>Can anyone explain why the following code produces a key error? Does the multiprocessor namespace Manager have an issue with dictionaries? </p>
<pre><code>import multiprocessing

def f(string, namespace):
    namespace.results_dict[string] = string

if __name__ == '__main__':
    mgr = multiprocessing.Manager()
    ns = mgr.Namespace()
    ns.results_dict = {}
    p = multiprocessing.Process(target=f, args=('burger', ns,))

    p.start()
    p.join()

    print(ns.results_dict)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you add a print after the update operation, you'll see that the update does not have any effect:</p>
<pre><code>def f(string, namespace):
    namespace.results_dict[string] = string
    print(namespace)
</code></pre>
<p>prints:</p>
<pre><code>Namespace(results_dict={})
</code></pre>
<p>That is because each time <code>namespace.results_dict</code> is accessed its value (the empty dict) is retrieved from the managed namespace. The state of that dict is not managed, only direct access to the namespace is.
To make your example work you have to explicitly update the namespace with the changed dict, e.g:</p>
<pre><code>def f(string, namespace):
    r = namespace.results_dict   # retrieves copy
    r[string] = string           # modify local copy
    namespace.results_dict = r   # write it back
</code></pre>
<p>You could instead also use a managed dict as <code>results_dict</code> with your original function:</p>
<pre><code>if __name__ == '__main__':
    mgr = multiprocessing.Manager()
    ns = mgr.Namespace()
    ns.results_dict = mgr.dict()
    p = multiprocessing.Process(target=f, args=('burger', ns,))

    p.start()
    p.join()

    print(ns.results_dict)
</code></pre>
<p>Now changes to that dictionary will be immediately visible, but changes to other mutable data structures in the namespace will still only be updated on write access.</p>
</div>
<div class="post-text" itemprop="text">
<p>not sure if this is expected or not, or if the namespaces behave like you're expecting they behave. An easy workaround here would be to create a <code>dict()</code> from the manager object</p>
<pre><code>import multiprocessing

def f(string, result_dict):
    result_dict[string] = string

if __name__ == '__main__':
    mgr = multiprocessing.Manager()
    ns = mgr.dict()
    p = multiprocessing.Process(target=f, args=('burger', ns,))

    p.start()
    p.join()

    print(ns)
</code></pre>
<p>I get</p>
<pre><code>{'burger': 'burger'}
</code></pre>
<p>assigning this <code>Manager.dict</code> object to your namespace attribute should also work.</p>
</div>
<span class="comment-copy">I think you should just use <code>mgr.dict()</code> to create a shared dict.</span>
<span class="comment-copy">Using Python 3.5 this code prints an empty dict (as expected I think).</span>
<span class="comment-copy">No there's a key error in my pycharm environment:  KeyError: 'burger'</span>
<span class="comment-copy">using Python 2.7.14 this code also print an empty dict {}</span>
<span class="comment-copy">seems that you need a license to be able to use that properly :) nice</span>
<span class="comment-copy">Well, it's not too difficult to understand if you think about it a bit... There is not really a reasonable way to track all changes to arbitrary mutable content of a shared container (think of deeply nested dicts/lists/...). It's also described in the <a href="https://docs.python.org/3/library/multiprocessing.html#proxy-objects" rel="nofollow noreferrer">documentation</a> (4th example on proxy objects)</span>
