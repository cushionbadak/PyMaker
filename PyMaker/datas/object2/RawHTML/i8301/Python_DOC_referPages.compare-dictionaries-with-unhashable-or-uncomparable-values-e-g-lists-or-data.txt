<div class="post-text" itemprop="text">
<p>TL;DR: How can you compare two python dictionaries if some of them have values which are unhashable/mutable (e.g. lists or pandas Dataframes)?</p>
<hr/>
<p>I have to compare dictionary pairs for equality. In that sense, this question is similar to these two, but their solutions only seem to work for <strong>immutable objects</strong>...</p>
<ul>
<li><a href="https://stackoverflow.com/questions/1911273/is-there-a-better-way-to-compare-dictionary-values">Is there a better way to compare dictionary values</a></li>
<li><a href="https://stackoverflow.com/questions/4527942/comparing-two-dictionaries-in-python">Comparing two dictionaries in Python</a></li>
</ul>
<p>My problem, is that I'm dealing with pairs of <strong>highly nested dictionaries</strong> where the <strong>unhashable objects could be found in different places depending on which pair of dictionaries</strong> I'm comparing. My thinking is that I'll need to iterate across the deapest values contained in the dictionary and can't just rely on the <code>dict.iteritems()</code> which only unrolls the highest key-value pairs. I'm not sure how iterate across all the possible key-value pairs contained in the dictionary and compare them either using sets/== for the hashable objects and in the cases of pandas dataframes, running <code>df1.equals(df2).</code> (Note for pandas dataframe, just running <code>df1==df2</code> does a piecewise comparison and NA's are poorly handled. <code>df1.equals(df2)</code> gets around that does the trick.)</p>
<p>So for example:</p>
<pre><code>a = {'x': 1, 'y': {'z': "George", 'w': df1}}
b = {'x': 1, 'y': {'z': "George", 'w': df1}}
c = {'x': 1, 'y': {'z': "George", 'w': df2}}
</code></pre>
<p><em>At a minimum,</em> and this would be pretty awesome already,  the solution would yield TRUE/FALSE as to whether their values are the same and would work for pandas dataframes.</p>
<pre><code>def dict_compare(d1, d2):
   if ...
      return True
   elif ...
      return False

dict_compare(a,b)
&gt;&gt;&gt; True
dict_compare(a,c)
&gt;&gt;&gt; False
</code></pre>
<p><em>Moderately better:</em> the solution would point out what key/values would be different across the dictionaries.</p>
<p><em>In the ideal case:</em> the solution could separate the values into 4 groupings:</p>
<ul>
<li>added, </li>
<li>removed,</li>
<li>modified</li>
<li>same</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Well, there's a way to make any type comparable: Simply wrap it in a class that compares like you need it:</p>
<pre><code>class DataFrameWrapper():
    def __init__(self, df):
        self.df = df

    def __eq__(self, other):
        return self.df.equals(other.df)
</code></pre>
<p>So when you wrap your "uncomparable" values you can now simply use <code>==</code>:</p>
<pre><code>&gt;&gt;&gt; import pandas as pd

&gt;&gt;&gt; df1 = pd.DataFrame({'a': [1,2,3]})
&gt;&gt;&gt; df2 = pd.DataFrame({'a': [3,2,1]})

&gt;&gt;&gt; a = {'x': 1, 'y': {'z': "George", 'w': DataFrameWrapper(df1)}}
&gt;&gt;&gt; b = {'x': 1, 'y': {'z': "George", 'w': DataFrameWrapper(df1)}}
&gt;&gt;&gt; c = {'x': 1, 'y': {'z': "George", 'w': DataFrameWrapper(df2)}}
&gt;&gt;&gt; a == b
True
&gt;&gt;&gt; a == c
False
</code></pre>
<p>Of course wrapping your values has it's disadvantages but if you only need to compare them that would be a very easy approach. All that may be needed is a recursive wrapping before doing the comparison and a recursive unwrapping afterwards:</p>
<pre><code>def recursivewrap(dict_):
    for key, value in dict_.items():
        wrapper = wrappers.get(type(value), lambda x: x)  # for other types don't wrap
        dict_[key] = wrapper(value)
    return dict_  # return dict_ so this function can be used for recursion

def recursiveunwrap(dict_):
    for key, value in dict_.items():
        unwrapper = unwrappers.get(type(value), lambda x: x)
        dict_[key] = unwrapper(value)
    return dict_

wrappers = {pd.DataFrame: DataFrameWrapper,
            dict: recursivewrap}
unwrappers = {DataFrameWrapper: lambda x: x.df,
              dict: recursiveunwrap}
</code></pre>
<p>Sample case:</p>
<pre><code>&gt;&gt;&gt; recursivewrap(a)
{'x': 1,
 'y': {'w': &lt;__main__.DataFrameWrapper at 0x2affddcc048&gt;, 'z': 'George'}}
&gt;&gt;&gt; recursiveunwrap(recursivewrap(a))
{'x': 1, 'y': {'w':    a
  0  1
  1  2
  2  3, 'z': 'George'}}
</code></pre>
<p>If you feel really adventurous you could use wrapper classes that depending on the comparison result modify some variable that holds the information what wasn't equal.</p>
<hr/>
<p>This part of the answer was based on the original question that didn't include nestings:</p>
<p>You can seperate the unhashable values from the hashable values and do a set-comparison for the hashable values and a "order-independant" list-comparison for the unhashables:</p>
<pre><code>def split_hashable_unhashable(vals):
    """Seperate hashable values from unhashable ones and returns a set (hashables) 
    and list (unhashable ones)"""
    set_ = set()
    list_ = []
    for val in vals:
        try:
            set_.add(val)
        except TypeError:  # unhashable
            list_.append(val)
    return set_, list_


def compare_lists_arbitary_order(l1, l2, cmp=pd.DataFrame.equals):
    """Compare two lists using a custom comparison function, the order of the
    elements is ignored."""
    # need to have equal lengths otherwise they can't be equal
    if len(l1) != len(l2):  
        return False

    remaining_indices = set(range(len(l2)))
    for item in l1:
        for cmpidx in remaining_indices:
            if cmp(item, l2[cmpidx]):
                remaining_indices.remove(cmpidx)
                break
        else:
            # Run through the loop without finding a match
            return False
    return True

def dict_compare(d1, d2):
    if set(d1) != set(d2):  # compare the dictionary keys
        return False
    set1, list1 = split_hashable_unhashable(d1.values())
    set2, list2 = split_hashable_unhashable(d2.values())
    if set1 != set2:  # set comparison is easy
        return False

    return compare_lists_arbitary_order(list1, list2)
</code></pre>
<p>It got a bit longer than expected. For your test-cases it definetly works:</p>
<pre><code>&gt;&gt;&gt; import pandas as pd

&gt;&gt;&gt; df1 = pd.DataFrame({'a': [1,2,3]})
&gt;&gt;&gt; df2 = pd.DataFrame({'a': [3,2,1]})

&gt;&gt;&gt; a = {'x': 1, 'y': df1}
&gt;&gt;&gt; b = {'y': 1, 'x': df1}
&gt;&gt;&gt; c = {'y': 1, 'x': df2}
&gt;&gt;&gt; dict_compare(a, b)
True
&gt;&gt;&gt; dict_compare(a, c)
False
&gt;&gt;&gt; dict_compare(b, c)
False
</code></pre>
<p>The <code>set</code>-operations can also be used to find differences (see <a href="https://docs.python.org/3/library/stdtypes.html#set.difference" rel="nofollow noreferrer"><code>set.difference</code></a>). It's a bit more complicated with the <code>list</code>s, but not really impossible. One could add the items where no match was found to a seperate list instead of instantly returning <code>False</code>.</p>
</div>
<span class="comment-copy">@MSeifert is that clearer?</span>
<span class="comment-copy">@Afflatus You already solved the problem with dataframes, what concrete issue is stopping you?</span>
<span class="comment-copy">@Goyo I'm not sure how iterate across all the possible key-value pairs contained in the dictionary -- i.e. I'm dealing with pairs of highly nested dictionaries where the unhashable objects could be found in different places depending on which pair of dictionaries I'm comparing.</span>
<span class="comment-copy">When I run it with a pair of dictionaries: dict_compare(dict1, dict2), I get an error traced back to the compare_lists_arbitary_order() function where it calls: "if cmp(item, l2[cmpidx]):"The error message is a TypeError: unbound method equals() must be called with DataFrame instance as first argument (got dict instance instead)</span>
<span class="comment-copy">@Afflatus Yeah, you changed your question while I wrote the answer (and I didn't notice at first and thought it wasn't about nested dictionaries). That's why I included a possible recursive approach that can be customized for the types at the beginning :)</span>
