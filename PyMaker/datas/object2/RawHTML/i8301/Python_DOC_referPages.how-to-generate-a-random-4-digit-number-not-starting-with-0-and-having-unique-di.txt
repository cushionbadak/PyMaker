<div class="post-text" itemprop="text">
<p>This works almost fine but the number starts with 0 sometimes:</p>
<pre><code>import random
numbers = random.sample(range(10), 4)
print(''.join(map(str, numbers)))
</code></pre>
<p>I've found a lot of examples but none of them guarantee that the sequence won't start with <code>0</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>We generate the first digit in the 1 - 9 range, then take the next 3 from the remaining digits:</p>
<pre><code>import random

# We create a set of digits: {0, 1, .... 9}
digits = set(range(10))
# We generate a random integer, 1 &lt;= first &lt;= 9
first = random.randint(1, 9)
# We remove it from our set, then take a sample of
# 3 distinct elements from the remaining values
last_3 = random.sample(digits - {first}, 3)
print(str(first) + ''.join(map(str, last_3)))
</code></pre>
<p>The generated numbers are equiprobable, and we get a valid number in one step.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just loop until you have something you like:</p>
<pre><code>import random

numbers = [0]
while numbers[0] == 0:
    numbers = random.sample(range(10), 4)

print(''.join(map(str, numbers)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is very similar to the other answers but instead of <code>sample</code> or <code>shuffle</code> you could draw a random integer in the range 1000-9999 until you get one that contains only unique digits:</p>
<pre><code>import random

val = 0  # initial value - so the while loop is entered.
while len(set(str(val))) != 4:  # check if it's duplicate free
    val = random.randint(1000, 9999)

print(val)
</code></pre>
<p>As @Claudio pointed out in the comments the range actually only needs to be 1023 - 9876 because the values outside that range contain duplicate digits.</p>
<p>Generally <code>random.randint</code> will be much faster than <code>random.shuffle</code> or <code>random.choice</code> so even if it's more likely one needs to draw multiple times (as pointed out by @karakfa) it's up to 3 times faster than any <code>shuffle</code>, <code>choice</code> approach that also needs to <code>join</code> the single digits.</p>
</div>
<div class="post-text" itemprop="text">
<p>I do not know Python well, but something like</p>
<pre><code>digits=[1,2,3,4,5,6,7,8,9] &lt;- no zero
random.shuffle(digits)
first=digits[0] &lt;- first digit, obviously will not be zero
digits[0]=0 &lt;- used digit can not occur again, zero can
random.shuffle(digits)
lastthree=digits[0:3] &lt;- last three digits, no repeats, can contain zero, thanks @Dubu
</code></pre>
<p>A more useful iteration, actually creating a number:</p>
<pre><code>digits=[1,2,3,4,5,6,7,8,9]   # no zero
random.shuffle(digits)
val=digits[0]                # value so far, not zero for sure
digits[0]=0                  # used digit can not occur again, zero becomes a valid pick
random.shuffle(digits)
for i in range(0,3):
  val=val*10+digits[i]       # update value with further digits
print(val)
</code></pre>
<p>After stealing pieces from other solutions, plus applying the tip from @DavidHammen:</p>
<pre><code>val=random.randint(1,9)
digits=[1,2,3,4,5,6,7,8,9]
digits[val-1]=0
for i in random.sample(digits,3):
  val=val*10+i
print(val)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>[Fixed] Shift all four digits on one position is not right. Swap leading zero with fixed position is not right too. But random swap of the leading zero with any of nine positions is correct and gives equal probability:</p>
<pre><code>""" Solution: randomly shuffle all numbers. If 0 is on the 0th position,
              randomly swap it with any of nine positions in the list.

  Proof
    Lets count probability for 0 to be in position 7. It is equal to probability 1/10 
  after shuffle, plus probability to be randomly swapped in the 7th position if
  0 come to be on the 0th position: (1/10 * 1/9). In total: (1/10 + 1/10 * 1/9).
    Lets count probability for 3 to be in position 7. It is equal to probability 1/10
  after shuffle, minus probability to be randomly swapped in the 0th position (1/9)
  if 0 come to be on the 0th position (1/10) and if 3 come to be on the 7th position
  when 0 is on the 0th position (1/9). In total: (1/10 - 1/9 * 1/10 * 1/9).
    Total probability of all numbers [0-9] in position 7 is:
  9 * (1/10 - 1/9 * 1/10 * 1/9) + (1/10 + 1/10 * 1/9) = 1
    Continue to prove in the same way that total probability is equal to
  1 for all other positions.
    End of proof. """

import random
l = [0,1,2,3,4,5,6,7,8,9]
random.shuffle(l)
if l[0] == 0:
    pos = random.choice(range(1, len(l)))
    l[0], l[pos] = l[pos], l[0]
print(''.join(map(str, l[0:4])))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>rejection sampling method.  Create a 4 digit random combination from 10 digits and resample if it doesn't match the criteria.</p>
<pre><code>r4=0    
while r4 &lt; 1000:
    r4=int(''.join(map(str,random.sample(range(10),4))))
</code></pre>
<p>noticed that this is essentially the same as @Austin Haskings's <a href="https://stackoverflow.com/a/43593479/1435869">answer</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You could use full range for 3 numbers, then choose the leading number among the remaining numbers:</p>
<pre><code>import random
numbers = random.sample(range(0,10), 3)
first_number = random.choice(list(set(range(1,10))-set(numbers)))
print(''.join(map(str, [first_number]+numbers)))
</code></pre>
<p>Another way if the choice needs to be repeated (and if you remain reasonable on the number of digits), is to pre-compute the list of the possible outputs using <code>itertools.permutations</code>, filtering out the ones with a leading zero, and building a list of integers from it:</p>
<pre><code>import itertools,random

l = [int(''.join(map(str,x))) for x in itertools.permutations(range(10),4) if x[0]]
</code></pre>
<p>That's some computation time, but after than you can call:</p>
<pre><code>random.choice(l)
</code></pre>
<p>as many times you want. It's very fast and provides an evenly distributed random.</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't know Python so I will post a pseudo-code-ish solution for this specific problem:</p>
<ul>
<li><p>Create a lookup variable containing a 0-based list of digits:</p>
<pre><code>lu = [1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre></li>
<li><p>Generate four 0-based random numbers as follows:</p>
<pre><code>r1 = random number between 0 and 8
r2 = random number between 0 and 8
r3 = random number between 0 and 7
r4 = random number between 0 and 6
</code></pre></li>
<li><p>Use the lookup variable to convert random numbers to digits one-by-one. After each lookup, mutate the lookup variable by removing the digit that has been used:</p>
<pre><code>d1 = lu[r1]
lu.remove(d1)
lu.insert(0)

d2 = lu[r2]
lu.remove(d2)

d3 = lu[r3]
lu.remove(d3)

d4 = lu[r4]
lu.remove(d4)
</code></pre></li>
<li><p>Print the result:</p>
<pre><code>print concatenate(d1, d2, d3, d4)
</code></pre></li>
</ul>
<p>It is possible to generalize this idea a little. For example you can create a function that accepts a list (of digits) and a number (desired length of result); the function will return the number and mutate the list by removing used-up digits. Below is a JavaScript implementation of this solution:</p>
<p><div class="snippet" data-babel="false" data-console="true" data-hide="true" data-lang="js">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>function randomCombination(list, length) {
    var i, rand, result = "";
    for (i = 0; i &lt; length; i++) {
        rand = Math.floor(Math.random() * list.length);
        result += list[rand];
        list.splice(rand, 1);
    }
    return result;
}

function desiredNumber() {
    var list = [1, 2, 3, 4, 5, 6, 7, 8, 9],
        result;
    result = randomCombination(list, 1);
    list.push(0);
    result += randomCombination(list, 3);
    return result;
}

var i;
for (i = 0; i &lt; 10; i++) {
    console.log(desiredNumber());
}</code></pre>
</div>
</div>
</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's how I'd do it</p>
<pre><code>while True:
    n = random.randrange(1000, 10000)
    if len(set(str(n))) == 4: # unique digits
        return n
</code></pre>
<p>More generally, given a generator, you can use the built-ins <a href="https://docs.python.org/3/library/functions.html#filter" rel="nofollow noreferrer"><code>filter</code></a> and <a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow noreferrer"><code>next</code></a> to take the first element that satisfies some test function.</p>
<pre><code>numbers = iter(lambda: random.randrange(1000, 10000), None) # infinite generator
test = lambda n: len(set(str(n))) == 4
return next(filter(test, numbers))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>Combine generators with <code>next</code></h1>
<p>A Pythonic way to write would be to use 2 nested generators and <code>next</code>:</p>
<pre><code>from random import randint
from itertools import count

print(next(i for i in (randint(1023, 9876) for _ in count()) if len(set(str(i))) == 4))
# 8756
</code></pre>
<p>It's basically a one-liner variant of <a href="https://stackoverflow.com/questions/43593278/how-to-generate-a-random-4-digit-number-not-starting-with-0-and-having-unique-di/43593794#43593794">@MSeifert's answer</a></p>
<h1>Preprocess all the acceptable numbers</h1>
<p>If you need many random numbers, you could invest some time and memory for preprocessing all the acceptable numbers:</p>
<pre><code>import random    
possible_numbers = [i for i in range(1023, 9877) if len(set(str(i))) == 4]
</code></pre>
<p><code>1023</code> and <code>9877</code> are used as boundaries because no int lower than 1023 or greater than 9876 can have 4 unique, distince numbers.</p>
<p>Then, you'd just need <a href="https://docs.python.org/2/library/random.html#random.choice" rel="nofollow noreferrer"><code>random.choice</code></a> for a very fast generation:</p>
<pre><code>print(random.choice(possible_numbers))
# 7234
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Disclaimer: this is a terrible anti-Python approach, strictly for the benchmarking part (see @DavidHammen's comments around, and <a href="http://ideone.com/qyopLF" rel="nofollow noreferrer">http://ideone.com/qyopLF</a>)
The idea is to generate the sequence numbers of the digits in one step, and then fix any collisions:</p>
<pre><code>rnd=random.randint(0,4535)
(rnd,d1)=divmod(rnd,9)
(rnd,d2)=divmod(rnd,9)
#(rnd,d3)=divmod(rnd,8)
#(rnd,d4)=divmod(rnd,7)
(d4,d3)=divmod(rnd,8) # miracle found: 1 divmod happens to run faster than 2
</code></pre>
<p>Now we have d1=0..8, d2=0..8, d3=0..7, d4=0..6, it can be tested via running the snippet with rnd=4535 (4535=9*9*8*7-1, by the way)</p>
<p>First, d1 has to be patched up</p>
<pre><code>d1=d1+1 # now d1 = 1..9
</code></pre>
<p>Then d2 has to "skip" d1 if necessary</p>
<pre><code>if d2&gt;=d1
  d2=d2+1 # now d2 = 0..9 "-" d1
</code></pre>
<p>Then the same has to be done with the remaining digits, getting ugly fast:</p>
<pre><code>if d3&gt;=d1:
  d3=d3+1    # now d3 = 0..8 "-" d1
  if d3&gt;=d2:
    d3=d3+1  # now d3 = 0..9 "-" {d1,d2}
elif d3&gt;=d2: # this branch prepares for the other variant
  d3=d3+1
  if d3&gt;=d1: # "&gt;=" is preserved for consistency, here "==" may occur only
    d3=d3+1
</code></pre>
<p>And the final part is the catastrophic one:</p>
<pre><code>if d4&gt;=d1:
  d4=d4+1
  if d4&gt;=d2:
    d4=d4+1
    if d4&gt;=d3:
      d4=d4+1
  elif d4&gt;=d3:
    d4=d4+1
    if d4&gt;=d2:
      d4=d4+1
elif d4&gt;=d2:
  d4=d4+1
  if d4&gt;=d1:
    d4=d4+1
    if d4&gt;=d3:
      d4=d4+1
  elif d4&gt;=d3:
    d4=d4+1
    if d4&gt;=d1:
      d4=d4+1
elif d4&gt;=d3:
  d4=d4+1
  if d4&gt;=d2:
    d4=d4+1
    if d4&gt;=d1:
      d4=d4+1
  elif d4&gt;=d1:
    d4=d4+1
    if d4&gt;=d2:
      d4=d4+1
</code></pre>
<p>For longer numbers, it might work faster with bitfields, but I do not see a trivial way.
(Checking the &gt;= relations once is not enough, because the collision can easily occur after doing an incrementation.
e.g. d1=1, d2=2, d3=1: d3 collides with d1, but it does not collide with d2 initially. However after "puching the hole" at 1, d3 becomes 2 and now it collides with d2. There is no trivial way to spot this collision in advance)</p>
<p>As the code stinks as hell, I put a verification step at the end</p>
<pre><code>val = d1*1000 + d2*100 + d3*10 + d4
#if len(set(str(val))) != 4: print(str(val)+" "+str(o1)+","+str(o2)+","+str(o3)+","+str(o4))
if len(set(str(val))) != 4: print(val)
</code></pre>
<p>It is already faster than the other really fast code (the commented verification displayed the original digits preserved after the divmod-s, for debugging purposes. This is not the kind of code which works immediately...). Commenting both verifications makes it even faster.</p>
<p>EDIT: about checking this and that</p>
<p>This is an approach maintaining an 1:1 relation between the minimal set of valid inputs (0...4535) and valid outputs (the 9*9*8*7 possible 4-digit numbers with distinct digits, not-starting-with-0). So a simple loop can and should generate all the numbers, they can be checked one-by-one and they can be collected into a set for example in order to see if they are all distinct results</p>
<p>Practically:</p>
<pre><code>collect=set()
for rnd in range(0,4536):
    (rnd,d1)=divmod(rnd,9)
    ... rest of the code, also the verification step kept active ...
    collect.add(val)
print(len(collect))
</code></pre>
<p>1) It will not print anything in the loop (all results are 4-digit numbers with distinct digits)</p>
<p>2) It will print 4536 at the end (all results are distinct)</p>
<p>One can add a verification for the first digit (d1), here and now I just assume that<br/>"(something mod 9)+1" will not be 0.</p>
</div>
<div class="post-text" itemprop="text">
<p>This will allow zeros after the first digit - </p>
<pre><code>numbers = random.sample(range(1,10),1) + random.sample(range(10),3)
</code></pre>
</div>
<span class="comment-copy">You can specify in <code>range()</code> the start value.In your case it could be 1</span>
<span class="comment-copy"><i>This works almost fine but the number starts with 0 sometimes.</i>  Probably about 10% of the time, if you run it enough times.</span>
<span class="comment-copy"><a href="https://codegolf.stackexchange.com/q/117506/34718">Related PPCG challenge</a></span>
<span class="comment-copy">A security related Q&amp;A: <a href="https://security.stackexchange.com/questions/155606/when-choosing-a-numeric-pin-does-it-help-or-hurt-to-make-each-digit-unique">When choosing a numeric PIN, does it help or hurt to make each digit unique?</a></span>
<span class="comment-copy">To the OP: Please retract your acceptance of your accepted answer. It should not be the accepted answer. It is the slowest of the top six answers, and by quite a wide margin.</span>
<span class="comment-copy">@Claudio Independence of the numbers generated is one of the fundamental properties a good  pseudo-random generator must satisfy. I suppose that Python's random is good enough that subsequent calls can be considered independent.</span>
<span class="comment-copy">Note that, while this method does indeed generate each possible output with the same probability, this fact isn't trivially obvious. The key reason why it does produce equiprobable reasons is that, after picking the first digit, the number of remaining possible digits is the same regardless of which first digit was chosen. In particular, if you tried to reverse the procedure (i.e. first pick the lowest three distinct digits, and then pick a non-zero first digit out of the remaining seven), the outputs would <i>not</i> be equiprobable. (Exercise to readers: why?)</span>
<span class="comment-copy">Downvoted because this is the slowest of the top answers. This combines set arithmetic with <code>random.sample</code>, both of which are slow.</span>
<span class="comment-copy">@DavidHammen Why is that worthy of a downvote? On my machine, this answer is less than 4 microseconds slower than Austin Hastings answer, and performance wasn't even mentioned in the question. I would hesitate to call a constructive approach alongside rejection sampling techniques "not useful".</span>
<span class="comment-copy">@Mitch - Mostly to counter what I consider to be completely invalid downvotes on the other answers due to lack of understanding of the concept of rejection sampling. An easy way to understand rejection sampling: Suppose I asked you to produce all of the four digit numbers that have no repeated digits and that start with 1. You could come up with a complex algorithm to do that, or you could use <code>[n for n in range(1000,10000) if len(set(str(n)))==4]</code>. (continued)</span>
<span class="comment-copy">@Claudio the probabilities still work out to be equal for all results so I'm not sure what you mean by not as random as it should be</span>
<span class="comment-copy">@Claudio I'm sorry but you should probably consult some kind of reference on accept-reject sampling and review conditional probability before suggesting all of the answers are incorrect.</span>
<span class="comment-copy">This could loop forever. Hardly a versatile solution.</span>
<span class="comment-copy">@BoundaryImposition, and all the other downvoters: This is a very versatile solution. It even has a name, "rejection sampling." Most implementations of a normal distribution use rejection sampling.</span>
<span class="comment-copy">@BoundaryImposition, and all the other downvoters: Of the answers by Austin Hastings, MSeifert, karakfa, andThierry Lathuille, this is the fastest in both python 2.7 and python 3.4. In fact, the accepted answer is the slowest, 40% slower than is this answer (python 2.7).</span>
<span class="comment-copy">@MSeifert Of course, that's for 4 digits. Your rejection space is going to blow up and slow you down with say, 7 digits (I know that's not the question :) ). Practically speaking though, I like this answer best.</span>
<span class="comment-copy">To make it even more perfect you can limit further the range for choices using for example <b>random.randint(1023, 9876)</b>, right?</span>
<span class="comment-copy">@MSeifert -- <a href="http://ideone.com/qyopLF" rel="nofollow noreferrer">ideone.com/qyopLF</a></span>
<span class="comment-copy">@DavidHammen Note that with python-3 the timings look very different: <a href="http://ideone.com/ous7zZ" rel="nofollow noreferrer">ideone.com/ous7zZ</a>. Am I right that it seems my solution is a bit slower on python2 but much faster in python3?</span>
<span class="comment-copy">@MSeifert - I didn't notice the python3 tag. I have experimented with both python2 and python3 and have noticed that performance is in general quite abysmal with python3. Your's is the one exception, being only 10% slower in python3 rather than python2 (other algorithms take twice as long, or longer). One thing that is common across both versions of the language is that the accepted answer is lousy.</span>
<span class="comment-copy">I don't know why this was downvoted, it's short and combinatorical.  It's exactly how I thought of doing it when reading the title.  Setting <code>first</code> to 0 after getting first digit is "clever", I would have just added zero back to the list. This looks to be identical to Claudio's, which is tl;dr and less readable. This can generate all 4536 answers, without unnecessary looping or testing.</span>
<span class="comment-copy">This is good, except that it should read <code>lastthree=digits[0:3]</code> because of Python's unusual array indexing.</span>
<span class="comment-copy">@toddkaufmann I wanted to do that first, just I did not know the syntax for appending an item, and then I realized it was not needed anyway</span>
<span class="comment-copy">@Dubu thank you, I will fix it in the next edit</span>
<span class="comment-copy">@tevemadar -- While correct, this is quite slow, with two calls to <code>random.shuffle</code> on a nine element list.</span>
<span class="comment-copy">But the not every possible value is drawn with the same probability. Because for example <code>1234</code> and <code>01234</code> produce the same result while numbers containing a not-leading zero (e.g. <code>1023</code>) have only one possibility to be drawn.</span>
<span class="comment-copy">@MSeifert Ahh you're correct.. How about swapping zero with a random location in the list should a zero-leading number be drawn? Then we redistribute evenly back across the sample space in that case.</span>
<span class="comment-copy">e.g. <code>random.shuffle(l); if l[0] == 0: pos = random.choice(range(1, 10)); l[0], l[pos] = l[pos], l[0]</code></span>
<span class="comment-copy">@MSeifert -- Lets take simpler example: list [0,1,2] and two unique digits not starting with 0. There are 3!==6 possibilities. Each possibility has probability 1/6. There are 2 leading zeros: [0,1,2] and [0,2,1]. If <b>randomly</b> swap leading 0 with the rest 2 positions, there are four combinations: [0,1,2]==&gt;([1,0,2] and [2,1,0]); [0,2,1]==&gt;([2,0,1] and [1,2,0]). Each of these four combinations have the same probability equal to 1/6 * 1/2 == 1/12. But these 4 combinations coincide with the rest 4 possibilities. So each possibility after random swap should have probability == 1/6 + 1/12.</span>
<span class="comment-copy">@MSeifert -- added mathematical proof.</span>
<span class="comment-copy">Probability of that is zero...  You'll be surprised how common this technique is used in practice.</span>
<span class="comment-copy">The probability is certainly <i>not</i> zero.</span>
<span class="comment-copy"><code>lim 10^(-n) = 0</code>; for <code>n -&gt; Infinity</code> (aka forever)</span>
<span class="comment-copy">The probability is negligible for all practical purposes.  For example, to loop 1000 times without producing a valid sample (which takes 16 msecs on my computer) is probability 10^(-1000) event.</span>
<span class="comment-copy">@BoundaryImposition - You are barking up the wrong tree here. Rejection sampling is a very widely used technique. The only problems with this answer is that Austin Hasking's wrote a very similar answer two minutes earlier (probably while karakfa was writing this answer) and that Austin Hasking's answer is a bit better.</span>
<span class="comment-copy">Except the allowable outcomes aren't equally likely then; e.g., there are two ways to get 1230, but only one way to get 1234.</span>
<span class="comment-copy">@TimPeters you're right. Added an alternate solution.</span>
<span class="comment-copy">if you get 0023, then you have the same problem</span>
<span class="comment-copy">but you cannot have <code>0023</code>. There's only one <code>0</code></span>
<span class="comment-copy">can someone shed some light on the downvotes?</span>
<span class="comment-copy"><code>return</code> outside a function is a syntaxerror in python. Also note that you can use a range from <code>1023</code> to <code>9876</code> as pointed out <a href="http://stackoverflow.com/questions/43593278/how-to-generate-a-random-4-digit-number-not-starting-with-0-and-having-unique-di/43613235#comment74241467_43593794">here</a>.</span>
<span class="comment-copy">Interesting. Did you check that the results are uniformly distributed?</span>
<span class="comment-copy">@EricDuminil the distribution over the set of valid outputs follows the distribution of randint(). What I checked is the correctness of mapping inputs to outputs, added some lines about it now</span>
<span class="comment-copy">It will also allow a single repeated digit.</span>
<span class="comment-copy">Would you need to multiply the first digit by 1000 before adding the two? Or does the plus sign just concatenate them?</span>
