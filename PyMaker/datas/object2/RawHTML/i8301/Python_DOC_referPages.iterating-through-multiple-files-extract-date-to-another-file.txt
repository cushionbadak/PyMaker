<div class="post-text" itemprop="text">
<p>Ok I have a source directory which has multiple folders. Each folder has a file named tvshow.nfo from which I want to extract data. I wrote the following -</p>
<pre><code>import sys
import os
import re
from pathlib import Path

L = []
my_dir = "./source/"
for item in Path(my_dir).glob('./*/tvshow.nfo'):
    M = str(item).splitlines()
    for i in M:
        f = open(i, "r")
        for i in f:
            for j in re.findall("&lt;title&gt;(.+)&lt;/title&gt;", i):
                L.append(j)
            for j in re.findall("&lt;year&gt;(.+)&lt;/year&gt;", i):
                L.append(j)
            for j in re.findall("&lt;status&gt;(.+)&lt;/status&gt;", i):
                L.append(j)
            for j in re.findall("&lt;studio&gt;(.+)&lt;/studio&gt;", i):
                L.append(j)
        for i in L:
            print (i)
        f.close()
</code></pre>
<p>I used glob to geth the exact paths of all nfos, then used splitlines to separate each path , iterated through file at each of those paths, then used regex to extract info. And tried to append this info to the empty List. I get the following output -</p>
<pre class="lang-none prettyprint-override"><code>APB
2017
Continuing
FOX (US)
APB
2017
Continuing
FOX (US)
Angie Tribeca
2016
Continuing
TBS
APB
2017
Continuing
FOX (US)
Angie Tribeca
2016
Continuing
TBS
Arrow
2012
Continuing
The CW
['APB', '2017', 'Continuing', 'FOX (US)', 'Angie Tribeca', '2016', 'Continuing', 'TBS', 'Arrow', '2012', 'Continuing', 'The CW']
</code></pre>
<p>I want the output exported to a new file as:</p>
<pre class="lang-none prettyprint-override"><code>APB 2017 Continuing FOX (US)
Angie Tribeca 2016 Continuing TBS
Arrow 2012 Continuing The CW
</code></pre>
<p>Can anyone help me? Also is there a better way to do this than the one I attempted?</p>
</div>
<div class="post-text" itemprop="text">
<p>Based on what you showed, you may try this.</p>
<pre><code>import sys
import os
import re
from pathlib import Path

info = []
my_dir = "./source/"
for item in Path(my_dir).glob('./*/tvshow.nfo'):
    M = str(item).splitlines()
    for i in M:
        L = []
        f = open(i, "r")
        for i in f:
            for j in re.findall("&lt;title&gt;(.+)&lt;/title&gt;", i):
                L.append(j)
            for j in re.findall("&lt;year&gt;(.+)&lt;/year&gt;", i):
                L.append(j)
            for j in re.findall("&lt;status&gt;(.+)&lt;/status&gt;", i):
                L.append(j)
            for j in re.findall("&lt;studio&gt;(.+)&lt;/studio&gt;", i):
                L.append(j)
        f.close()
        info.append(' '.join(L))
with open("new_file", "w") as w:
    for i in info:
        w.write(i + "\n")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Instead of making one list with all of the different attributes for each show, you should structure your data in a more easily readable way. One possibility is a list of lists, where the top-level list has one entry for each show and the inner lists contain the title, year, status, and studio attributes for one show. You can modify your existing code quite easily to accomplish this:</p>
<pre><code>    for i in f:
        show_attributes = []
        for j in re.findall("&lt;title&gt;(.+)&lt;/title&gt;", i):
            show_attributes.append(j)
        for j in re.findall("&lt;year&gt;(.+)&lt;/year&gt;", i):
            show_attributes.append(j)
        for j in re.findall("&lt;status&gt;(.+)&lt;/status&gt;", i):
            show_attributes.append(j)
        for j in re.findall("&lt;studio&gt;(.+)&lt;/studio&gt;", i):
            show_attributes.append(j)
        L.append(show_attributes)
    for i in L:
        for attribute in i:
            print(attribute, end=' ')
    f.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From your example it looks like all of the tags for each show are on one line. </p>
<p>If all of the tags for a show are on one line I think something like this might help:</p>
<pre><code>import sys
import os
import re
from pathlib import Path


def find_tag(tag, l):
    ''' returns result of findall on a tag on line l'''
    full_tag = "&lt;" + tag + "&gt;(.+)&lt;/" + tag + "&gt;"
    return re.findall(full_tag, l)


L = []
my_dir = "./source/"
for item in Path(my_dir).glob('./*/tvshow.nfo'):
    # changed the file variable to data_file
    M = str(item).splitlines()
    for data_file in M:
        # use with to open the file without needing to close it
        with open(data_file, "r") as f:

            for line in f:
                title = find_tag("title", line)
                year = find_tag("year", line)
                status = find_tag("status", line)
                studio = find_tag("studio", line)
                L.append(' '.join(str(d[0]) for d in [title, year, status, studio] if d))

# print the data or whatever else you're doing with it
for data in L:
    print(data)
</code></pre>
<p>This uses <code>with</code> to open the file without needing to use a try-catch and close it yourself. Information about <code>with</code> can be found here: <a href="https://docs.python.org/3/tutorial/inputoutput.html#methods-of-file-objects" rel="nofollow noreferrer">file methods</a></p>
<p><code>str(d[0])</code> is needed to change the group list item from <code>re.findall</code> into a string. The <code>if d</code> is there in case a tag is missing on that line (and it's possible I'm misunderstanding how the tags are placed within the file, sorry about that if I am) </p>
<p>It's also possible to build <code>L</code> with a list comprehension: 
<code>L = [(find_tag("title", line), find_tag("year", line), find_tag("status", line), find_tag("studio", line)) for line in f]</code> instead of appending to the list. </p>
<p>The join method could then be used when printing the list: <code>print(' '.join(str(d[0]) for d in data if d))</code>. </p>
<p>whether or not you want to do that depends on how much you like list comprehensions.</p>
<p>I also created a <code>find_tag</code> function, but that's mostly from me trying to figure out what was going on.</p>
<p>Without knowing what the file looks like it's hard to tell if you should be looking for each one on a separate line. It's also hard to tell if the order matters or if you need to do any error handling. </p>
</div>
<span class="comment-copy">sorry about the typo, it should be data in title and not date.</span>
<span class="comment-copy">Off-topic: <code>Path.glob()</code> returns a list of matches, so the <code>M = str(item).splitlines()</code> isn't necessary because <code>item</code> will always be a single <code>Path</code> subclass instanceâ€”which means the following <code>for i in M:</code> will only ever execute one iteration.</span>
<span class="comment-copy">Seems <code>XML</code> in your file, search for <code>python XML module</code></span>
<span class="comment-copy">@martineau I tried without str and splitlines and got error TypeError: invalid file: PosixPath(.....</span>
<span class="comment-copy">@martineau aah yes !!! got it!</span>
<span class="comment-copy">Thanks a lot, that worked. If it's just functions, I can usually do it, but I have trouble with list and where to define it, appending, etc etc.. Need to practice more with different types of examples.</span>
<span class="comment-copy">Thanks, I will definitely try that approach once I get more familiar with lists</span>
