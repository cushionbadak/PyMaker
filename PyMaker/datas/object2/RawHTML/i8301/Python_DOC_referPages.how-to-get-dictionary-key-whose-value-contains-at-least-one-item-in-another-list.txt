<div class="post-text" itemprop="text">
<p>I have written a simple script the scope of which is:</p>
<pre><code>list=[1,19,46,28 etc...]
dictionary={Joey:(10,2,6,19), Emily: (0,3), etc}
</code></pre>
<p>Now I need to find all the keys of the dictionary which have at least one of the list entries in the values</p>
<p>Example: 19 is in Joeys values, so Joey is the winner.</p>
<p>How I did it: (no programmer at all)</p>
<pre><code># NodesOfSet = the list

# elementsAndTheirNodes = the dictionary

# loop as many times as the number of key:value entries in the dictionary element:nodes
# simply: loop over all the elements
for i in range (0, len (elementsAndTheirNodes.keys())):

    # there is an indent here (otherwise it wouldnt work anyway)
    # loop over the tuple that serves as the value for each key for a given i-th key:value
    # simply: loop over all their nodes
    for j in range (0, len (elementsAndTheirNodes.values()[i])):

        # test: this prints out element + 1 node and so on
        # print (elementsAndTheirNodes.keys()[i], elementsAndTheirNodes.values()[i][j]  )

        for k in range (0, len (NodesOfSet)):
            if NodesOfSet[k] == (elementsAndTheirNodes.values()[i][j]):
                print ( elementsAndTheirNodes.keys()[i], " is the victim")
            else:
                print ( elementsAndTheirNodes.keys()[i], " is not the victim")
</code></pre>
<p>But this is very time consuming as it iterates over basically everything in the database. May I ask for a help optimizing this? Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>I would use a <em>list comprehension</em> and the builtin <a href="https://docs.python.org/3/library/functions.html#any" rel="noreferrer"><code>any</code></a> which shortcircuits once a shared item is found. Turning your list into a set reduces the complexity of the membership lookup from <code>O(n)</code> to <code>O(1)</code>:</p>
<pre><code>s = set(lst)
result = [k for k, v in dct.items() if any(i in s for i in v)]
</code></pre>
<p>Be careful to not assign builtins as the names for your objects (e.g. <code>list</code>) to avoid making the builtin unusable later on in your code.</p>
</div>
<div class="post-text" itemprop="text">
<p>Don't use the name <code>list</code>, <code>list</code> is the name of a library function.</p>
<pre><code>l = [1, 19, 46, 28, ...]
l_set = set(l)

d = {'Joey':(10,2,6,19), 'Emily': (0,3), ...}

winners = [k for k, v in d.items() if any(i in l_set for i in v)]
</code></pre>
<p><code>any</code> will stop iterating through <code>v</code> as soon as it "sees" a shared value, saving some time.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could also use set intersection to check if any of the elements in the dictionary value tuples have anything in common with your "list" entries:</p>
<pre><code>l = [1,19,46,28, ...]
s = set(l)
d = {Joey:(10,2,6,19), Emily: (0,3), ...}
winners = [k for k, v in d.iteritems() if s.intersection(v)]
</code></pre>
</div>
<span class="comment-copy">Just a tip : this is not very pythonic -&gt; list is a protected word so don't use it as a variable name, and variables always start with a lower case letter and "words" are usually separated by a "_". Also don't put space between a function and the "()" as in print or len or range</span>
<span class="comment-copy">Hello! Thanks for your comment. Im not aware of using the word of list anywhere. The thing with the capitals is interesting, though not very helpful. The spaces are there because my text-editor offers already used words to me when typing then.</span>
<span class="comment-copy">It is nice that somebody edited my question to make it more understandable. But was it really necessary to delete that I am no programmer and my thanks?</span>
<span class="comment-copy"><code>if s.intersection(v)</code> reads better, but then you still need to build a new set, which may or may not be faster depending on the number of positives.</span>
<span class="comment-copy">@MosesKoledoye You are right but I'm assuming readability trumps efficiency for this problem. Why be efficient when you can be pretty?</span>
<span class="comment-copy">And <code>if len(s.intersection(set(v)))</code> is <i>prettier</i> than <code>if s.intersection(v)</code>?</span>
<span class="comment-copy">Ah that's what you're getting at :) Edited</span>
<span class="comment-copy">Yep, and you don't need <code>set(v)</code> also, <code>set.intersection</code> takes any iterable :)</span>
