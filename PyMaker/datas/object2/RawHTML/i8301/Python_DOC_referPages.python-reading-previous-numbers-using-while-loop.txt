<div class="post-text" itemprop="text">
<p>So I have this question where I'am to read a set of integers until -1 is input. I need to print the length of the longest continuous sequence of numbers where a number is the sum of the 2 preceding. This does not include the first 2 numbers in the length of the sequence.</p>
<p>An example of what numbers would be input and the answer would be:
1,2,3,4,5,8,13,21,34,55,10,6,7,8,20,25,30,40,-1 =&gt; 4</p>
<p>What I have so far:</p>
<pre><code>n = int(input())  #reads the initial input
numberSkip = 0  #numberSkip allows me to skip the first 2 numbers

while n != -1:
    if numberSkip &lt; 2:
        numberSkip += 1
    elif numberSkip &gt;= 2:
        print (n)  #this is where the rest of the code would go I'm assuming 
    n = int(input())
</code></pre>
<p>So I have worked out how to end the loop when it reaches -1, how to skip the first 2 numbers and read the next number. But what I don't understand is how to read the previous numbers and work out if it is the sum or how to work out the longest sequence of numbers.</p>
</div>
<div class="post-text" itemprop="text">
<p>In addition to <code>n</code>, the current number, have two more variables:</p>
<ul>
<li><code>previous1</code>, the previous value of <code>n</code>,</li>
<li><code>previous2</code>, the value before <code>previous1</code>.</li>
</ul>
<p>It is then obvious how you compare the current value to the sum of the previous two values. When you need to input a new number, do</p>
<pre><code>previous2, previous1 = previous1, n
</code></pre>
<p>then input a new value of <code>n</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are various ways to approach this. You can process the input while you're reading it, but it makes things simpler to read the input into a list and then process the list.</p>
<p>You can read the input like this:</p>
<pre><code>a = []
while True:
    n = int(input())
    if n == -1:
        break
    a.append(n)
</code></pre>
<p>Note that this will raise <code>ValueError</code> if a non-integer is read.</p>
<p>Now that we have our numbers in a list, we can process them in the way that Rory Daulton suggests.</p>
<pre><code>a = [1, 2, 3, 4, 5, 8, 13, 21, 34, 55, 10, 6, 7, 8, 20, 25, 30, 40]

prev2, prev1, *a = a
maxlen = seqlen = 0
for n in a:
    seqlen = seqlen + 1 if n == prev1 + prev2 else 0
    maxlen = max(maxlen, seqlen)
    prev2, prev1 = prev1, n

print(maxlen)
</code></pre>
<p><strong>output</strong></p>
<pre><code>4
</code></pre>
<hr/>
<p>Just for fun, here's a "one-liner".</p>
<pre><code>from itertools import groupby

maxlen = max((len(list(g)) for k, g in groupby(u + v == w 
    for u,v,w in zip(a, a[1:], a[2:])) if k), default=0)
</code></pre>
<p>Both of these solutions cope if <code>len(a) &lt;= 2</code>.</p>
<p>That last one is a bit dense and hard to read. Here's a breakdown:</p>
<pre><code>from itertools import groupby

a = [1, 2, 3, 4, 5, 8, 13, 21, 34, 55, 10, 6, 7, 8, 20, 25, 30, 40]

print('tuples')
b = list(zip(a, a[1:], a[2:]))
print(b)

print('tests')
b = [u + v == w for u,v,w in b]
print(b)

print('group lengths')
b = [(k, len(list(g))) for k, g in groupby(b)]
print(b)

maxlen = max((l for k, l in b if k), default=0)
print(maxlen)
</code></pre>
<p><strong>output</strong></p>
<pre><code>tuples
[(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 8), (5, 8, 13), (8, 13, 21), (13, 21, 34), (21, 34, 55), (34, 55, 10), (55, 10, 6), (10, 6, 7), (6, 7, 8), (7, 8, 20), (8, 20, 25), (20, 25, 30), (25, 30, 40)]
tests
[True, False, False, False, True, True, True, True, False, False, False, False, False, False, False, False]
group lengths
[(True, 1), (False, 3), (True, 4), (False, 8)]
4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>try this :-</p>
<pre><code>cnt=0
sm=0
res=0
len_of_seq=0

while True:
   n=input()

   if cnt&lt;2:
       sm+=n
       cnt+=1

   elif cnt==2:
       if sm==n:
           if len_of_seq&lt;=2: #not increase value of count for  first two number
               res+=1
           else:
               res+=cnt+1
       sm=0
       cnt=0

   len_of_seq+=1
   if n==-1:
       break

  print(res)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could possibly do something like below. You don't need to do the list I did to return the longest run of numbers matching your criteria it was just me being sloppy with storage to demonstrate a way you could do it.</p>
<pre><code>n = int(input('Enter Value:'))
numberSkip = 0
counter = 2
counts = []
prev_num = []

while n != -1:
    if numberSkip &lt; 2:
        numberSkip += 1
    else:
        if n == sum(prev_num[-2:]):
            counter += 1
        else:
#             You don't need this to keep the record of them.
            counts.append(counter)
            counter = 0
    prev_num.append(n)
    n = int(input('Enter Value:'))
counts.append(counter)
print(max(counts))
</code></pre>
<p>Fixed up both the initial count to include the first two numbers for longer streak and made sure the last count is considered for when the loop exits.</p>
</div>
<span class="comment-copy">I hope you don't mind that I expanded the suggestions in this answer.</span>
<span class="comment-copy">Thanks that was helpful :D</span>
<span class="comment-copy">@PM2Ring: No, I don't mind. I did not have enough time to give a full answer, so it is good that you could do so. However, I would avoid storing a list of the entire sequence, since it is not needed and takes up memory.</span>
<span class="comment-copy">Fair point about not storing the entire sequence, I only did it because it makes the code slightly simpler &amp; shorter. OTOH, machines tend to have a little more RAM than they did when we started coding, and I don't think the user of this code will be keying in gigabytes of data. :) Still, I tend to process text files line by line, when it makes sense to do so.</span>
<span class="comment-copy">Thanks that was really helpful to break it all down like that although I don't really understand "prev2, prev1, *a = a" or "maxlen = seqlen = 0"</span>
<span class="comment-copy">@S.Craft <code>maxlen = seqlen = 0</code> just assigns 0 to both <code>seqlen</code> and <code>maxlen</code>. The other one's a little trickier. :) <code>prev2, prev1, *a = a</code> unpacks the list <code>a</code> into the tuple <code>( prev2, prev1, *a)</code>. So the first item in <code>a</code> gets assigned to <code>prev2</code>, the second item to <code>prev1</code>, and the remaining items get assigned to <code>a</code>. So we've effectively chopped off the first two items of <code>a</code> and put them into <code>prev2</code> &amp;  <code>prev1</code>. A simpler example of sequence unpacking is <code>a,b,c='abc'</code>.You can read more about it in <a href="https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences" rel="nofollow noreferrer">the tutorial</a>.</span>
<span class="comment-copy">BTW, older versions of Python don't support that particular use of <code>*</code>, see <a href="https://www.python.org/dev/peps/pep-3132/" rel="nofollow noreferrer">PEP 3132 - Extended Iterable Unpacking</a> for details.</span>
<span class="comment-copy">This doesn't quite work. Try it on <code>[1,2,3,5,8,1,2,3,5,8]</code></span>
<span class="comment-copy">Thanks this seems to mostly work except in the case 1,2,3,4,5,10,15,20,8,13,21,34,55,89,144,-1 =&gt; 5 it returns 1 instead of 5 and not sure as to why.</span>
<span class="comment-copy">There was some minor things I overlooked in the order of events. I've cleaned them up. But next time I'd recommend putting some print statements in the middle of some of the code when running it to try and find where those type of scenarios occur. You'll learn a lot more that way when things aren't behaving as expected.</span>
