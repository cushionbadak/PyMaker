<div class="post-text" itemprop="text">
<p>I am using warnings in object code to alert users that something has happened but not halt the code.  Below is a simple mockup based on the more complex scenarios I am encountering in my real code:</p>
<pre><code>from warnings import warn
class myClass(object):        
    def __init__(self, numberArg):

        if numberArg &gt; 1000:
            self._tmpTxt = "That's a really big number for this code." + \
                           "Code may take a while to run..."
            warn("\n%s %s" %(numberArg, self._tmpTxt))
            print("If this were real code:")
            print("Actions code takes because this is a big number would happen here.")

        print("If this were real code, it would be doing more stuff here ...")

mc1 = myClass(1001)
</code></pre>
<p>In my real code, when I instantiate the class which executes <code>__init__(self, numberArg)</code>, the warning is output at the end after all the processing that follows the warning is done.  Why does this happen?  </p>
<p>More importantly, is there a way to ensure the warning is output first and then the rest of my code runs and delivers its output?  </p>
<p>As with the example provided here, the desired effect is to alert the user what is going to happen before it happens, not afterwards, and deliver the output like a warning with warning format.</p>
<p>Note:  This problem was encountered using Python 2.7 on iPython/Jupyter on a Windows 7 environment</p>
</div>
<div class="post-text" itemprop="text">
<p>@direprobs provided the simplest answer to this question in the comments.  Add this line of code after the call to <code>warn()</code>.  </p>
<p><code>sys.stderr.flush()</code></p>
<p>Note:  Though it comes from the <code>sys</code> library, you do not need an <code>import</code> statement because <code>warnings</code> writes to <code>stderr</code> and already imports the library.</p>
<p>This code can be copied-and-pasted into Python 2.7 (Jupyter Notebooks) to quickly run it and see the effects:</p>
<p><strong>Experiment One (for comparison to code that follows it):</strong></p>
<pre><code># Note how warnings in this sample are held until after code is run and then output at the end ...

from warnings import warn
from warnings import resetwarnings

class myClass(object):        
    def __init__(self, numberArg):

        if numberArg &gt; 1000:
            self._tmpTxt = "That's a really big number for this code." + \
                           "Code may take a while to run..."
            warn("\n%s %s" %(numberArg, self._tmpTxt), stacklevel=1, category=RuntimeWarning)
                                                       # possible categories (some of them):
                                                       # UserWarning, Warning, RunTimeWarning, ResourceWarning
                                                       # stacklevel was a experiment w/ no visible effect
                                                       # in this instance

            resetwarnings()                            # tried putting this before and after the warn()
            print("If this were real code:")
            print("Actions code takes because this is a big number would happen here.")

        print("If this were real code, it would be doing more stuff here ...")

mc1 = myClass(1001)
</code></pre>
<p><strong>Experiment Two:</strong></p>
<pre><code># In this case, we want the warning to come before code execution.  This is easily fixed as shown below.
# note: removed some extraneous useless stuff, the line to look for is sys.stderr.flush()

from warnings import warn
from warnings import resetwarnings

class myClass(object):        
    def __init__(self, numberArg):

        if numberArg &gt; 1000:
            self._tmpTxt = "That's a really big number for this code." + \
                           "Code may take a while to run..."
            warn("\n%s %s" %(numberArg, self._tmpTxt), category=Warning)            
            sys.stderr.flush()                         # put this after each warn() to make it output more immediately
            print("If this were real code:")
            print("Actions code takes because this is a big number would happen here.")

        print("If this were real code, it would be doing more stuff here ...")

mc1 = myClass(1001)  
</code></pre>
<p><strong>Experiment Three:</strong></p>
<pre><code># code provided as an experiment ... may be updated later with a more useful example ...
# in theory, filterwarnings should help shake out repeat warnings if used with right arguments
#   * note how our loop causes the content to print twice, and in theory, the 3 instances of warnings
#   * occur twice each for 6 possible output warnings
#   * each new occurance (3 of them) still outputs, but when the same ones come up again, they don't
#   * we get 3 instead of 6 warnings ... this should be the effect of filterwarning("once")
#     in this instance

# help on this: https://docs.python.org/3/library/warnings.html#warning-filter
#               in this example:
#                  "once" arg = print only the first occurrence of matching warnings, regardless of location

from warnings import warn
from warnings import resetwarnings
from warnings import filterwarnings

class myClass(object):        
    def __init__(self, numberArg):

        for i in [1,2]:

            if numberArg &gt; 1000:
                print("loop count %d:" %(i))
                self._tmpTxt = "That's a really big number for this code." + \
                               "Code may take a while to run..."
                filterwarnings("once")
                warn("\n%s %s" %(numberArg, self._tmpTxt), stacklevel=1, category=RuntimeWarning)
                sys.stderr.flush() # this provides warning ahead of the output instead of after it
                # resetwarnings()  # no noticeable effect on the code
                print("If this were real code:")
                print("Actions code takes because this is a big number would happen here.")

            if numberArg &gt; 20000:
                self._tmpTxt = "That's a really really really big number for this code." + \
                               "Code may take a while to run..."                
                filterwarnings("once", "\nFW: %s %s" %(numberArg, self._tmpTxt))
                warn("\n%s %s" %(numberArg, self._tmpTxt), stacklevel=0)
                # resetwarnings()  # no noticeable effect on the code
                sys.stderr.flush() # this provides warning ahead of the output instead of after it

            print("loop count %d:" %(i))    
            print("If this were real code, it would be doing more stuff here ...")

mc1 = myClass(1001)
print("====================")
mc2 = myClass(20001)
</code></pre>
<p>Look for this code on github later.  Posted it here to help others investigating how to use <code>warnings</code>.</p>
</div>
<span class="comment-copy"><code>warn</code> was not delayed from the command line. The message goes to stderr, maybe your environment delays viewing that.</span>
<span class="comment-copy">I like the way  warn() behaves.  It outputs the offending module name, the code line number, and then your proposed warning message formatting in pink to alert the user something is wrong. Is there a way to work around the issue?  Ideas welcome.  (Just trying to make my code better). Note:  regarding the delay theory, while the code in this example is instaneous, in my real code, a calculation took 3+ minutes to complete, and the warning still appeared at the end.  If it is a delay, it seems to be "delay until after all code completes" rather than time based.</span>
<span class="comment-copy">What about flushing stderr? Would that help in anyway?</span>
<span class="comment-copy">That might be worth a try.  I'll check the warn() documentation to see if there's a way to do it on warn or one of the related warn() functions before calling in stderr directly to do it.  Working on a number of kinks in my code right now.  If you have a sample to post it could save me time.  Otherwise, my next comment on this may be a little while.</span>
<span class="comment-copy">@TMWP Place under <code>warn</code> this call: <code>sys.stderr.flush()</code>. If you check <a href="https://docs.python.org/3.1/library/warnings.html#module-warnings" rel="nofollow noreferrer"><code>warnings</code></a> module documentation, you would find: <i>"The determination whether to issue a warning message is controlled by the warning filter, which is a sequence of matching rules and actions."</i> Could be a filter issue. Try to flush <code>stderr</code> first and see what happens.</span>
