<div class="post-text" itemprop="text">
<p>I've got what I believe is a pretty straightforward issue, but haven't been able to find a satisfying answer. The short is that I want to enforce contracts on child classes of a parent without adding logic to each child class. Code example below:</p>
<pre><code>class A(object):

    @abc.abstractmethod
    def do_thing(self, input):
        raise NotImplementedError

class A1(A):

    def do_thing_decorator(self, do_thing_func):
        def checked_do_thing(input):
            check = do_thing_func(input)
            if check != 1:
                raise ValueError
            return check
        return checked_do_thing
</code></pre>
<p>So the question is how do I auto-decorate the <code>do_thing</code> function implemented by classes inheriting from <code>A1</code>? Assume that there is an <code>A2</code> class as well with a slightly different check.</p>
<p>My initial investigation implies that metaclasses are the approach to take, but having trouble finding great explanations of how they work. Ideally looking for something that functions in python 2.x, but if there's only 3.x solutions I'm happy to change my codebase.</p>
</div>
<div class="post-text" itemprop="text">
<p>First of all: you are using the <code>abc</code> module incorrectly (<a href="https://docs.python.org/3/library/abc.html#abc.abstractmethod" rel="nofollow noreferrer">see the docs</a>). Your class <code>A</code> should have <code>abc.ABCMeta</code> as meta class. So if you are already using a meta class you can extend it to your advantage.</p>
<p>A meta class that inherits from <code>abc.ABCMeta</code> to make <code>abstractmethod</code> work and decorates <code>do_thing</code>:</p>
<pre><code>from abc import ABCMeta, abstractmethod

class DecoratingMeta(ABCMeta):
    def __new__(cls, *args):
        new_class = super(DecoratingMeta, cls).__new__(cls, *args)
        # decorating do_thing manually
        new_class.do_thing = new_class.do_thing_decorator(new_class.do_thing)
        return new_class
</code></pre>
<p>Now your abstract base class with a default check decorator that does nothing:</p>
<pre><code># class Abstract(metaclass=ABCMeta): in python3
class Abstract(object):
    __metaclass__ = DecoratingMeta  # remove this line in python3
    @abstractmethod
    def do_thing(self, input):
        pass

    @classmethod
    def do_thing_decorator(cls, function):
        return function     # default decorator that does nothing
</code></pre>
<p>Note that <code>do_thing_decorator</code> must be a class method in this case.
For meta classes that work in <code>python3</code> and <code>python2</code> see <a href="https://pythonhosted.org/six/#six.with_metaclass" rel="nofollow noreferrer">six</a>.</p>
<p>Your Checker class that implements a specific checker only but is still abstract:</p>
<pre><code>class Checker(Abstract):
    @classmethod
    def do_thing_decorator(cls, function):
        def do_checked_thing(self, input):
            check = function(self, input)  # NOT self.do_thing(input) else recursion error
            if check != 1:
                raise ValueError("Check failed")
            return check
        return do_checked_thing
</code></pre>
<p>Note that the line you wrote <code>check = do_thing_func(input)</code> would result in a recursion error.</p>
<p>And your concrete class with a sample implementation of <code>do_thing</code>:</p>
<pre><code>class Concrete(Checker):
    def do_thing(self, input):
        return input    # sample implementation
</code></pre>
<p>You can verify that <code>do_thing(1)</code> succeeds and <code>do_thing(2)</code> fails</p>
<pre><code>c = Concrete()

c.do_thing(1)
try:
    c.do_thing(2)
except ValueError:
    print("check failed")
</code></pre>
<p>The disadvantage with this approach is that you can't make the <code>do_thing_decorator</code> abstract.</p>
<p>So this was already a lot of text, but if you don't want to use any meta classes at all there is a much simpler way:</p>
<p>Write a class that performs the check in the <code>do_thing</code> method by using two "abstract" methods:</p>
<pre><code>class Abstract(object):
    def do_thing_func(self, input):
        raise NotImplementedError()

    def check_do_thing(self, result):
        raise NotImplementedError()

    # don't override this method
    def do_thing(self, input):
        result = self.do_thing_func(input)
        self.check_do_thing(result)  # may raise
        return result  # if it does not raise return the result
</code></pre>
<p>Note that <code>do_thing_func</code> and <code>check_do_thing</code> are not really abstract and that you can still instanciate objects of type <code>Abstract</code>. If you need them to be abstract use a standard <code>abc.ABCMeta</code> meta class here.</p>
<p>Now create a checker class that implements <code>check_do_thing</code></p>
<pre><code>class Checker(Abstract):
    def check_do_thing(self, result):
        if result != 1:
            raise ValueError("check failed")
</code></pre>
<p>This becomes much simpler because we don't need a decorator here.</p>
<p>And finally the concrete class which implements <code>do_thing_func</code></p>
<pre><code>class Concrete(Checker):
    def do_thing_func(self, input):
        return input    # sample implementation
</code></pre>
<p>Note that <code>Concrete</code> now must implement <code>do_thing_func</code> but when you use the class you have to call <code>do_thing</code>.</p>
<p>The disadvantage here is that you could still override <code>do_thing</code> thus breaking the checking.</p>
</div>
<span class="comment-copy">Have you had a look at the <code>__new__()</code> method?</span>
<span class="comment-copy">@IgnacioVazquez-Abrams not an unreasonable solution. I was hoping for something a bit more intuitive on the method level, but will probably default to that if I can't find something better.</span>
