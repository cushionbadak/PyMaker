<div class="post-text" itemprop="text">
<p>I have the following function as part of a script <a href="https://blog.ouseful.info/2016/12/29/simple-view-controls-for-pandas-dataframes-using-ipython-widgets/" rel="nofollow noreferrer">inspired by this</a>:</p>
<pre><code>def view(a='', b='', c=''):
    if a=='All' and b=='All' and c=='All': return df 
    if a=='All' and c=='All' and b!='All': return df[(df['b']==b)]
    if a!='All' and c=='All' and b=='All': return df[(df['a']==a)]
    if a=='All' and c!='All' and b=='All': return df[(df['c']==c)]
    if a=='All' and c!='All' and b!='All': return df[(df['c']==c) &amp; (df['b']==b)]                                                        
    if a!='All' and c=='All' and b!='All': return df[(df['a']==a) &amp; (df['b']==b)]                                                                     
    if a!='All' and c!='All' and b=='All': return df[(df['a']==a) &amp; (df['c']==c)]                                                                 
    return df[(df['a']==a) &amp; (df['b']==b) &amp; (df['c']==c)]
</code></pre>
<p>Is there a nice way to write all those chained if statements with a nice pythonic expression. Bonus answer if generalized for n variables.</p>
<p><strong>Note:</strong> <a href="https://stackoverflow.com/questions/36117583/pythonic-way-to-avoid-if-x-return-x-statements">Perhaps related to this question</a>, but I still cant figure it out.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your function is basically doing this:</p>
<pre><code>if all parameters are 'All':
    return df
else:
    Take all the non-'All' parameters
    Test if each one is equal to df['name_of_parameter']
    Bitwise-AND them together
    Return df[result of previous line]
</code></pre>
<p>Let's start our rewrite by first taking a list of all non-'All' parameters:</p>
<pre><code>notall = [x for x in [a,b,c] if x != 'All']
if not notall:
    return df
else:
    ???
</code></pre>
<p>Roadblock #1: We've now lost track of which value goes with which parameter.  Why do we need to know that?  So that we can compare the parameters against the correct elements of <code>df</code>.  We can fix this by storing not just the parameters' values but also their names in <code>notall</code>:</p>
<pre><code>notall = [(x, name) for (x, name) in [(a, 'a'), (b, 'b'), (c, 'c')] if x != 'All']
if not notall:
    return df
else:
    ???
</code></pre>
<p>Writing out the name of each parameter twice is ugly, but it's either this or resorting to naughtiness with <code>locals</code> and/or <code>**kwargs</code>.</p>
<p>With that taken care of, the comparisons against the elements of <code>df</code> is easy:</p>
<pre><code> compared = [df[name] == x for (x, name) in notall]
</code></pre>
<p>Now, how do we AND them all together?  We could use <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer"><code>functools.reduce()</code></a> and <a href="https://docs.python.org/3/library/operator.html#operator.and_" rel="nofollow noreferrer"><code>operator.and_</code></a>, but (unless you've overloaded <code>==</code> to return a non-boolean, which I hope you didn't do), the elements of <code>compared</code> are all booleans, which means that combining them with bitwise AND is the same as combining them with logical AND, and Python already has a function for that: <a href="https://docs.python.org/3/library/functions.html#all" rel="nofollow noreferrer"><code>all()</code></a>.</p>
<pre><code>return df[all(compared)]
</code></pre>
<p>Putting it all together:</p>
<pre><code>def view(a='', b='', c=''):
    notall = [(x, name) for (x, name) in [(a, 'a'), (b, 'b'), (c, 'c')] if x != 'All']
    if not notall:
        return df
    else:
        compared = [df[name] == x for (x, name) in notall]
        return df[all(compared)]
</code></pre>
<p>or, even more compact:</p>
<pre><code>def view(a='', b='', c=''):
    notall = [(x, name) for (x, name) in [(a, 'a'), (b, 'b'), (c, 'c')] if x != 'All']
    if not notall:
        return df
    else:
        return df[all(df[name] == x for (x, name) in notall)]
</code></pre>
<p>Now, about that naughtiness mentioned earlier: If all of the parameters are in a <code>dict</code>, then <code>notall</code> can just contain the keys, which will allow us to look up both the parameter values and <code>df</code> values without repeating ourselves (too much).  How do we get all the parameters in a <code>dict</code>?  With <code>**kwargs</code>:</p>
<pre><code>def view(**kwargs):
    notall = [name for name in NAMES if kwargs.get(name, '') != 'All']
</code></pre>
<p>(Note the use of <code>get</code> to give the parameters their default values.)  But what should <code>NAMES</code> be?  It can't be <code>kwargs.keys()</code>, as that will only contain the parameters that the user passed in, which may not be all of them (and may even include keys we weren't expecting!).  Option 1 is to write out a list of the parameter names somewhere and use that:</p>
<pre><code>NAMES = ['a', 'b', 'c']
</code></pre>
<p>Alternatively, if the keys of <code>df</code> happen to be the same as the desired names of the function's parameters, we can just use <code>df.keys()</code>:</p>
<pre><code>    notall = [name for name in df.keys() if kwargs.get(name, '') != 'All']
</code></pre>
<p>or, slightly shorter:</p>
<pre><code>    notall = [name for name in df if kwargs.get(name, '') != 'All']
</code></pre>
<p>After this, we just need to update how the elements of <code>notall</code> are used, changing this:</p>
<pre><code>return df[all(df[name] == x for (x, name) in notall)]
</code></pre>
<p>to this:</p>
<pre><code>return df[all(df[name] == kwargs.get(name, '') for name in notall)]
</code></pre>
<p>(Note that we still need to keep using <code>get</code> to set the default values.)</p>
<p>Putting it all back together again:</p>
<pre><code>NAMES = ['a', 'b', 'c']
def view(**kwargs):
    notall = [name for name in NAMES if kwargs.get(name, '') != 'All']
    if not notall:
        return df
    else:
        return df[all(df[name] == kwargs.get(name, '') for name in notall)]
</code></pre>
<p>or, if the parameter names are the same as the keys of <code>df</code>:</p>
<pre><code>def view(**kwargs):
    notall = [name for name in df if kwargs.get(name, '') != 'All']
    if not notall:
        return df
    else:
        return df[all(df[name] == kwargs.get(name, '') for name in notall)]
</code></pre>
<p>EDIT: Based on the comments below, apparently the values of <code>df</code> are something that overrides <code>==</code> so that it doesn't return a boolean.  Fortunately, as alluded to above, this just requires changing this:</p>
<pre><code>return df[all(df[name] == kwargs.get(name, '') for name in notall)]
</code></pre>
<p>to this:</p>
<pre><code>import functools
import operator

return functools.reduce(operator.and_, [df[name] == kwargs.get(name, '') for name in notall])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This should do the trick:</p>
<pre><code>import itertools, functools
from operator import eq, ne, and_

def view(*args):
    Eq, Ne = functools.partial(eq, 'All'), functools.partial(ne, 'All')

     if all(Eq(var) for var in args):
         return df 

    for cond, ret in itertools.product((Eq, Ne), len(args)):
        if all(fun(var) for var, fun in zip(args, cond)):
            index = functools.reduce(and_, (df[var] == var for var, fun in cond if fun == Ne))
            return df[index]
</code></pre>
<p>The only problem is that there's no simple way I'm aware of to know the name of the variable you're currently using. This is why I used <code>df[var] == var</code>. </p>
<p>This is relatively easy to fix by making each variable carry its name with it, for example. So, basically, each variable'll be a tuple <code>a = (variable, "variable")</code>. </p>
</div>
<span class="comment-copy">For the first line, you could write <code>a==b==c=='All'</code> or <code>all(lambda x: x == 'All', [a, b, c])</code>. I don't see enough of a pattern to generalize the rest though.</span>
<span class="comment-copy">Also, since this is an "improve my code" request, this is really more appropriate for Code Review. Note though, that they require full, runnable chunks of code.</span>
<span class="comment-copy">For the <code>df['a']==a</code> comparisons, is the <code>df</code> index always going to be the name of the variable it's comparing against?</span>
<span class="comment-copy">@jwodder correct</span>
<span class="comment-copy">I'd like to know a little about df.</span>
<span class="comment-copy"><code>df[all(compared)]</code> and its variants will just be <code>df[False]</code> or <code>df[True]</code>.  That doesn't seem equivalent to the OP's <code>df[(df['a']==a) &amp; (df['b']==b) &amp; (df['c']==c)]</code>.</span>
<span class="comment-copy"><code>df["a"] == a</code> will be a bool Series, and bitwise anding a few of them together will give a Series which is then used as a mask.</span>
<span class="comment-copy">@DSM: Where does the OP say that <code>df["a"] == a</code> is not a <code>bool</code>?</span>
<span class="comment-copy">I'm confused about how the comparison returns a Series.  In my experience, it tends to be either True (they are equal) or False (they are not equal).  Similarly taking bitwise and of any python boolean values seems to result in a python boolean value.</span>
<span class="comment-copy">@jwodder: unfort. you need to either know the OP's questions :-) or recognize df as the standard name for an arbitrary dataframe.  The OP confirms that it's a dataframe when he writes "[...] a simple df with generic index and columns 'a', 'b' 'c'. I use this function as part of a script to filter the dataframe using a widget. 'a', 'b', 'c' are categorical variables." in the comments.</span>
