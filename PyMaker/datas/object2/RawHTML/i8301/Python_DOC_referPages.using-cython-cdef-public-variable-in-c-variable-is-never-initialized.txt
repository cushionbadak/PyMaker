<div class="post-text" itemprop="text">
<p>I'm trying to translate some simple cython to c++ : </p>
<pre><code>cdef public int G = 1
</code></pre>
<p>and then use it in my c++ code :</p>
<pre><code>#include &lt;Python.h&gt;
#include "test.h" // The file generated by the cython command
#include &lt;iostream&gt;
int main(int argc, char **argv) {
    std::cout &lt;&lt; "G : " &lt;&lt; G &lt;&lt; std::endl;
}
</code></pre>
<p>Output is :</p>
<blockquote>
<p>G : 0</p>
</blockquote>
<p>I've looked into the <code>test.cpp</code> cython-generated file, and on line 897, I have</p>
<pre><code>  G = 1;
</code></pre>
<p>So why is G evaluated to 0 in the <code>main</code> ?</p>
<p>Here are the commands used to compile : </p>
<pre><code>cython.exe test.pyx -3 --cplus
g++ test.cpp test_main.cpp -IC:\Python36-32\include -LC:\Python36-32\libs -lpython36
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you generate when you use <code>cython</code> is a python extension module. You cannot link it directly into an executable, as it needs to be dynamically imported and linked to libpython. In that process, your extension's initialization function is run, which will cause your <code>G</code> to be set to 1.</p>
<p>So you should:</p>
<ul>
<li>Build a python extension from your cython (using <code>-shared</code> and outputting a DLL).</li>
<li>Load python interpreter in your main. In your program, you don't even initialize python at the moment.</li>
<li>Import it in your main using <code>PyImport_ImportModule("mymodule")</code>.</li>
</ul>
<p>Untested, but your main should look like this:</p>
<pre><code>#include &lt;Python.h&gt;

int main(int argc, char * argv[])
{
    Py_Initialize();
    PyObject * test_module = PyImport_ImportModule("test");

    // do something with test_module

    Py_Finalize();
    return 0;
}
</code></pre>
<p>You can get G from python using <a href="https://docs.python.org/3/c-api/object.html#c.PyObject_GetAttrString" rel="nofollow noreferrer"><code>PyObject_GetAttrString()</code></a>, or since you declared it as <code>cdef</code>, you can access it directly using your OS's symbol resolution tools, such as <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms683212(v=vs.85).aspx" rel="nofollow noreferrer"><code>GetProcAddress()</code></a> for windows.</p>
<p><em>It may be possible to link dynamically at load time, yet still use importmodule to let python do its initialization magic, but I have no idea how to do that or if it's even possible.</em></p>
</div>
<span class="comment-copy">How do you compile and link your program? As given, it won't link.</span>
<span class="comment-copy">@spectras edited. I used <a href="http://stackoverflow.com/a/35901092/7486016">this answer</a> to get help with linking.</span>
<span class="comment-copy">Thanks for your answer. It feels like a lot more complicated than what I expected ... I've done the same thing for a function, and everything was just fine without importing the module, only calling <code>Py_Initialize</code> and <code>Py_Finalize</code></span>
<span class="comment-copy">The Cython documentation <a href="http://cython.readthedocs.io/en/latest/src/userguide/external_C_code.html#using-cython-declarations-from-c" rel="nofollow noreferrer">specifies a couple of different way of doing import/initialization</a> which you might find slightly simpler. The basic idea is very much the same as this answer though.</span>
<span class="comment-copy">@DavidW Just perfect. G is 1 after a call to <code>PyInit_test</code> (because i'm using python3, the documentation you provided has examples for python2)</span>
<span class="comment-copy">@B.Barbieri&gt; great! Yeah now you mention it, this is what ImportModule does: it looks for <code>PyInit_modulename</code> inside the module and calls it. So if you do it yourself it should replace the DLL + importmodule just fine.</span>
