<div class="post-text" itemprop="text">
<p>I want to define constants, e.g. <code>A = 10; B = 20</code>, with these properties:</p>
<ol>
<li>'Normal' access: e.g. <code>A.value + B.value == 30</code> (or even <code>A + B == 30</code>)</li>
<li>Allow duplicate values: e.g. <code>A = 10; B = 10</code></li>
<li>Associated string for each variable: e.g. <code>A.name == "A"</code></li>
<li>Listing: e.g. <code>[v.name for v in CONSTANTS]</code></li>
<li>IDE support: auto-complete names, re-factorizations, etc.</li>
<li>Adding a new constant requires <strong>one change</strong></li>
<li>Importable: e.g. <code>from config import CONSTANTS</code></li>
</ol>
<p>In the end, the property #6 is the problem. Something like</p>
<pre><code>A = 10
B = 20

A_NAME = "A"
B_NAME = "B"

CONSTANTS = { A_NAME: A, B_NAME: B }
</code></pre>
<p>would basically be the solution. But I would like to avoid this verbose code (if possible).</p>
<hr/>
<p>This attempt comes very close:</p>
<pre><code>import enum

class CONSTANTS(enum.IntEnum):
    A = 10
    B = 20

assert CONSTANTS.A + CONSTANTS.B == 30
assert CONSTANTS.A.name == "A"
assert CONSTANTS.__members__.keys() == ["A", "B"]
assert CONSTANTS.__members__.values() == [10, 20]
</code></pre>
<p>but fails when two constants have the same value (property #2). One could also define a sub-class of <code>Enum</code> with a constructor taking <code>value</code>. But again, <code>A = 10; B = 10</code> would be mapped to the same instance, even though the name differs. One could now also add a name (or any other unused, but distinctive parameter to the constructor) to make this problem go away. But I would consider this approach unclean. For instance, <code>A = ("A", 10); B = ("B", 10); def __init__(self, _, value): ...</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can make the CONSTANTS dict thing less verbose by using <code>globals()</code> to copy the dict contents into global variables:</p>
<pre><code>CONSTANTS = {"A": 10, "B": 20}
globals().update(CONSTANTS)

print(B)  # prints 20
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Have you considered using the <a href="https://docs.python.org/3.5/library/collections.html#collections.namedtuple" rel="nofollow noreferrer">namedtuple</a> collection?</p>
<pre><code>from collections import namedtuple

IntConst = namedtuple('IntConst', ['name', 'value'])

A = IntConst('A',10)
B = IntConst('B',20)
</code></pre>
<p>They meet your "Normal Access" by field....</p>
<pre><code>A.value + B.value
</code></pre>
<p>They won't complain when multiple <code>IntConst</code> have the same value...</p>
<pre><code>A = IntConst('A',10)
B = IntConst('B',10)
</code></pre>
<p>They will give an associated string ...</p>
<pre><code>A.name
</code></pre>
<p>They will allow listing ...</p>
<pre><code>CONSTANTS = list()
CONSTANTS.extend([A,B])
[v.name for v in CONSTANTS]
</code></pre>
<p>Your IDE probably already has support for <code>namedtuple</code>. Adding more constants simply requires you to create an instance of the <code>IntConst</code> <code>namedtuple</code>. As for importing, you'd simply create a list of those <code>IntConst</code> values in your namespace and they'd become valid targets for the <code>import</code> statement.</p>
<p>The only thing they don't give that you requested is the ability to duck type an integer value out of them. Instead, you'll get a tuple containing both <code>IntConst</code> instances.</p>
<pre><code>&gt;&gt;&gt; A+B
('A', 10, 'B', 10)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><em>Disclaimer: Accessing a hidden attribute is discouraged and should thus not be considered a 'clean' solution!</em></p>
<p>The standard Enum module can be <em>tweaked</em> to provide the desired behavior.</p>
<pre><code>import enum

class Const1(enum.Enum):
    A = 42
    B = 42

    def __init__(self, size):
        self._value_ = (self.name, size)
        self.size = size

class Const2(enum.IntEnum):
    A = 42
    B = 42

    def __init__(self, size):
        enum.IntEnum.__init__(self)
        self._value_ = (self.name, size)
</code></pre>
<p>Padding the <code>_value_</code> attribute with the name of the member, renders the <a href="https://github.com/python/cpython/blob/3.6/Lib/enum.py#L212" rel="nofollow noreferrer">alias lookup mechanism</a> unable to find other members with the same value. The only drawback is that the <code>value</code> attribute of the produced members all refer to their internal <code>_value_</code> attribute. In fact, <code>value</code> is defined as a <a href="https://docs.python.org/3/library/types.html#types.DynamicClassAttribute" rel="nofollow noreferrer"><code>DynamicClassAttribute</code></a>. Hence, without further modifications we face: <code>Const1.A.value == ('A', 42)</code>.</p>
<p>If desired, a property can be used to overwrite this behavior.</p>
<pre><code>@property
def value(self):
    return self._value_[1]
</code></pre>
</div>
<span class="comment-copy">why does your proposal need to inherit from <code>enum</code>? Why can't you just define the class with properties and override the <code>__add__</code>, etc., as necessary?</span>
<span class="comment-copy">But how would I access the element <i>name</i> for such a class? For <code>class C(): A=1; B=2</code>, how do I access <code>C.B.name</code> or something similar?</span>
<span class="comment-copy">Bleh, crazy int subclasses. They seem all nice and convenient until they propagate somewhere unexpected and your program starts printing <code>CrazyInternalEnum.WEIRD_NAME</code> instead of <code>3</code> or a duck-typing check takes the wrong code path because it wasn't expecting an integer to have a <code>name</code> attribute.</span>
<span class="comment-copy">I totally agree. Accessing the value via an attribute is totally fine for me and of course more fail-safe.</span>
<span class="comment-copy">@user2357112 To eliminate possible misunderstandings. The 'crazy int subclass' thing would be something which is nice to have, but not required. For me a 'value' attribute is sufficient.</span>
<span class="comment-copy">Yes, but then pycharm (or other IDEs) is not aware of these variables, right?</span>
<span class="comment-copy">@MichaelHoff: Probably not.</span>
<span class="comment-copy">That's an interesting solution. However, I have to create the variable <b>and</b> put it in the list if I introduce a new one.</span>
