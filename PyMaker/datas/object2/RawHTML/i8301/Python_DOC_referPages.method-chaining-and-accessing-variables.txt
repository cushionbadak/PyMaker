<div class="post-text" itemprop="text">
<p>I think it is easier for me to explain what I'm trying to achieve with a simple example. Consider the following code:</p>
<pre><code>class Person(object):
    def __init__(self):
        self._age = None
        self._gender = None

    def age(self, value):
        self._age = value
        return self

    def gender(self, value):
        self._gender = value
        return self


p = Person().age(10).gender("male")

assert p.age == 10
assert p.gender == "male"
</code></pre>
<p>Obviously the assertion fails because the attributes refers to the methods rather than the variables. 
I have tried messing with the __getattribute__ method so that it resolves "age" to "_age" but I can't seem to find a way where both cases works and I'm not entirely sure that it is possible at all but Python has surprised me before.</p>
</div>
<div class="post-text" itemprop="text">
<p>Short answer: Don't. You're going to run into problems, everyone who uses/reads your code is going to run into problems, and it's not worth the time you spend implementing it.</p>
<hr/>
<p>Long answer: If you absolutely must, you could create a class that sets the attribute's value when called, and otherwise mimics the value's behaviour. To do this, you'll have to override <em>all</em> the <a href="https://docs.python.org/3/reference/datamodel.html#basic-customization" rel="nofollow noreferrer">magic methods</a> and even then things like <code>print(type(p.age))</code> won't produce the expected output of <code>&lt;class 'int'&gt;</code>.</p>
<p>Here's a snippet to get you started (with only the <code>__eq__</code> method implemented):</p>
<pre><code>class CallableAttribute:
    def __init__(self, owner, name):
        self.owner= owner
        self.name= name

        setattr(owner, name, self)
        self(None)

    def __call__(self, value):
        setattr(self.owner, '_'+self.name, value)
        return self.owner

    @property
    def _value(self):
        return getattr(self.owner, '_'+self.name)

    def __eq__(self, other):
        return self._value==other

class Person(object):
    def __init__(self):
        CallableAttribute(self, 'age')
        CallableAttribute(self, 'gender')
</code></pre>
</div>
<span class="comment-copy">If you really want to use data hiding, here's an <a href="http://stackoverflow.com/questions/6304040/real-world-example-about-how-to-use-property-feature-in-python/42300481#42300481">example</a> of properties that should get you started.</span>
<span class="comment-copy">You're probably right and I should probably reconsider the design choices. A short follow-up question: If I add: assert p.age * 2 == 20, I get TypeError: unsupported operand type(s) for *: 'instance' and 'int' - Is there a way to circumvent this in an elegant manner?</span>
<span class="comment-copy">@MattImmer Yes, you simply override the <a href="https://docs.python.org/3/reference/datamodel.html#object.__mul__" rel="nofollow noreferrer"><code>__mul__</code></a> function.</span>
<span class="comment-copy">Thanks! I'll note that it is possible but bad practice to do so and might consider an alternative design.</span>
