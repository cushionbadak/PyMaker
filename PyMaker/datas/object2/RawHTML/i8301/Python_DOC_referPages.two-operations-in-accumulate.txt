<div class="post-text" itemprop="text">
<p>I tried to convert the following loop into a <code>accumulate()</code> call but i despicably failed:</p>
<pre><code>total = 0
for h in heat_values:
    total += h
    total -= total*0.25
</code></pre>
<p>How can I accumulate the values of h including this 0.25 decay factor?</p>
<p>Background: I wanted to do this as a just for fun exercise simulating a simultaneous heating and cooling process with functional programming style (the add operation is the heating step, and the subtraction is the cooling step). I want to get the accumulated values to plot the values of the process.</p>
</div>
<div class="post-text" itemprop="text">
<p>Unless my math or reasoning is incorrect this is how you would achieve this using <code>accumulate</code>:</p>
<pre><code>heatvalues = [20, 30, 40, 50]

list(accumulate(heatvalues, lambda x, y: (x+y)*.75))

&gt;&gt;&gt;[20, 37.5, 58.125, 81.09375]
</code></pre>
<p>Edit: If you only want the last element, aka the total then it becomes:</p>
<pre><code>list(accumulate(heatvalues, lambda x, y: (x+y)*.75))[-1]

&gt;&gt;&gt;81.09375
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In short, you don't.  <strong>accumulate</strong> operates on an existing iterable type, such as a list of daily production quantities, returning the running total thereof.  You have a recurrence relation, not a ready iterable.  The problem is that <strong>total</strong> depends on a decay operation on the previous values.</p>
<p>If you want to make this a one-liner, I suggest that you use <strong>reduce</strong>, which allows you to specify the reduction function -- i.e. a <strong>lambda</strong> function of your own design.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/functools.html#module-functools" rel="nofollow noreferrer"><code>functools.reduce(function, iterable[, initializer])</code></a> (just <code>reduce</code> in 2.x) can be made to work. The <code>function</code> takes two args, the current accumulated value and the new value from the sequence, in that order.</p>
<p>For your problem, subtracting .25 is the same as multiplying by .75.  Either is done after adding the new value.  This should work.</p>
<pre><code>from functools import reduce
def update(total, new):
    return .75 * (total + new)
total = reduce(update, heat_values, 0)
</code></pre>
<p>EDIT: I wrote the above not being aware of the addition of <code>accumulate</code> to itertools in 3.2 and of the <code>func</code> argument in 3.3.  The doc does not specify the order of the two arguments to <code>func</code>, but it is the same as for the <code>reduce</code> function: accumulated value, new_value.  This is verified by using an asymmetric update expression such as <code>.75 * running_total + new_value</code>.</p>
</div>
<span class="comment-copy"><code>total -= total*0.25</code> is <code>total *= 0.75</code>, which works fine with <code>reduce(lambda h, total: (total + h) * 0.75, heat_values, 0.0)</code>.</span>
<span class="comment-copy">@dhke The signature of your lambda expression is backwards.  It does not matter in this particular case because total and h are just added together and addition is cummutative.  It would, though, if the function were, more realistically, <code>.75 * total + h</code>.</span>
<span class="comment-copy">@TerryJanReedy Thanks for pointing that out, <code>lambda total, h:</code> is of course the proper order.</span>
<span class="comment-copy">if you want the last element, you use reduce instead of accumulate.</span>
<span class="comment-copy">I already edited to accommodate for that, and I was simply answering OPs question using the module they attempted to use.</span>
<span class="comment-copy">So to complete this: <code>reduce(lambda x, y: (x+y)*.75, heat_values)</code> returns the final total and <code>accumulate(heat_values, lambda x, y: (x+y)*.75)</code> gets the intermediate values, what i aimed for (for plotting).</span>
<span class="comment-copy">heat_values is a ready iterable, otherwise the original for loop wouldn't make sense</span>
