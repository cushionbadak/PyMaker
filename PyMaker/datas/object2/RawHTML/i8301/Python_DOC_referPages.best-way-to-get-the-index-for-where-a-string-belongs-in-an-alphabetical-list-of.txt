<div class="post-text" itemprop="text">
<p>Let's say I have a list of magical creatures from Harry Potter in alphabetical order and need to figure out where a new discovery belongs (based on index) within the list. After more thinking than I want to admit, I came up with the following:</p>
<pre><code>def find_insert_position(name, alpha_list):

    pos = 0
    end = len(alpha_list)
    for n in range(len(name)):
        for i in range(pos, end):
            if (pos != end):
                if ((name[n].lower() &gt; alpha_list[i - 1][n].lower()) and (name[n].lower() &lt;= alpha_list[i][n].lower())):
                    pos == i


                if ((name[n].lower() &lt; alpha_list[i + 1][n].lower()) and (name[n].lower() &gt;= alpha_list[i][n].lower())):
                    end == i
            elif (pos == end):
                return pos
</code></pre>
<p>I'm certain there are better methods to go about this and I'm also fairly sure the above wouldn't even work properly. Any advice?</p>
<p>let's say 
name = 'Hungarian Horntail' and 
alpha_list = ['Acromantula', 'Basilisk', 'Hippogriff', 'Merperson', 'Toad', 'Troll', 'Thestral', 'Pixie']. 
So this function would return the integer 3, representing the index name belongs in alpha_list.</p>
</div>
<div class="post-text" itemprop="text">
<p>whenever you have a list that is ordered and you want to keep it in oder, use the <a href="https://docs.python.org/3/library/bisect.html" rel="nofollow noreferrer"><code>bisect</code> module</a>. it is extremely efficient and does just what you want.</p>
<p>for your example:</p>
<pre><code>from bisect import bisect

name = 'Hungarian Horntail'
alpha_list = ['Acromantula', 'Basilisk', 'Hippogriff', 'Merperson', 'Toad',
              'Troll', 'Thestral', 'Pixie']

idx = bisect(alpha_list, name)
print(idx)  # -&gt; 3
</code></pre>
<p>which just means that you would have to insert <code>name</code> at index <code>3</code>. <code>alpha_list</code> remains unchanged.</p>
<p>if you comparison must be based on lower-case only you could do this:</p>
<pre><code>alpha_list_lower = [alpha.lower() for alpha in alpha_list]
idx = bisect(alpha_list_lower, name.lower())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's what I'd do:</p>
<pre><code>def find_insert_position(name, alpha_list):
    names = [i.lower() for i in alpha_list]
    names.append(name.lower())
    names = sorted(names)
    return names.index(name.lower())

name = 'Hungarian Horntail'
alpha_list = ['Acromantula', 'Basilisk', 'Hippogriff', 'Merperson', 'Toad', 'Troll', 'Thestral', 'Pixie']

find_insert_position(name, alpha_list)

&gt;&gt;&gt; 3
</code></pre>
</div>
<span class="comment-copy">Are you only wanting to know the position or just keep the list alphabetical?</span>
<span class="comment-copy">Know the position it belongs. This function will not actually change the list</span>
<span class="comment-copy">I follow but the key here is that I need to return the index of where the name would go in the alpha_list, not actually change alpha_list in any way. But let's say name = 'Hungarian Horntail' and alpha_list = ['Acromantula', 'Basilisk', 'Hippogriff', 'Merperson', 'Toad', 'Troll', 'Thestral', 'Pixie']. So this function would return the integer 3</span>
<span class="comment-copy">@Maccus added a small example for clarification. hope that helps.</span>
<span class="comment-copy">it seems bisect is actually a module not a function? According to my python 3 at least, I think you may be using it incorrectly but I'll try and figure it out! Thanks for the tip bud</span>
<span class="comment-copy">note the <code>from bisect import bisect</code> import statement: i import the <code>bisect</code> function from the <code>bisect</code> module. yes, there is a function of the same name as the module (just like there is e.g. for <code>datetime</code> [which is class and module]).</span>
<span class="comment-copy">This doesn't address the need to compare the strings lower case that was in the provided code by the OP!  Maybe use: <code>idx = bisect([alpha_name.lower() for alpha_name in alpha_list], name.lower)</code></span>
<span class="comment-copy">This works fine but it seems the bisector method is much cleaner but thank you! If you can't import, this is the way to go</span>
<span class="comment-copy">@Maccus what do you mean with 'If you can't import'? <code>bisect</code> is in the python standard library; i.e. it comes with the interpreter itself. and if there was no such module, a <a href="https://en.wikipedia.org/wiki/Binary_search_algorithm" rel="nofollow noreferrer">binary search</a> would still be the most efficient way to go - you'd just have to implement it yourself.</span>
<span class="comment-copy">@hiroprotagonist if you don't know the full use case of the situation you can't say what would be most efficient. If @maccus only had a small <code>alpha_list</code> it might not warrant writing a custom binary search. Bisect is obviously the way to go for cleanliness/usability/efficiency since it's part of the standard lib. Why do you want to go making false statements that can't be backed up based on an scenario that will probably never be true?</span>
<span class="comment-copy">@Jeremy yes, you are right. i do not know the full use case. i meant efficiency in the sense of complexity (not actual runtime). and in that sense i can see nothing wrong in my statement.</span>
