<div class="post-text" itemprop="text">
<p>I'm a native C++ programmer who is just beginning to learn python and I've been given the following method to write:</p>
<blockquote>
<p>Return the sum of the numbers in the array, returning 0 for an empty array. Except the number 13 is very unlucky, so it does not count and numbers that come immediately after a 13 also do not count.</p>
</blockquote>
<p>My solution is:</p>
<pre><code>def sum13(nums):
  elem_sum = 0
  index = 0

  while index &lt; len(nums):
    if nums[index] != 13:
      elem_sum += nums[index]
    else:
      index += 1 #nums[i] is 13, so skip the next element'
    index += 1

  return elem_sum
</code></pre>
<p>Those who are familiar with other C-based languages would find the loop here analogous to the (quite cleaner)</p>
<pre><code>for(int i = 0; i &lt; nums.size() /*nums.length*/; ++i) {
    if(nums[i] != 13) elem_sum += nums[i];
    else i++;
}
</code></pre>
<p>Please note that I began learning Python only a few days ago so I'm still very new to the language. I'm hoping someone can offer some advice on how to write this loop the "Python" way or perhaps offer a cleaner solution using some language features I may be unaware of. </p>
<hr/>
<p>In my previous attempt (which did not work) I had:</p>
<pre><code>for i in range(len(nums)):
    if nums[i] != 13:
      elem_sum += nums[i]
    else:
      i += 1 #nums[i] is 13, so skip the next element'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about a comprehension with <code>sum</code> and <code>zip</code>:</p>
<p><strong>Code:</strong></p>
<pre><code>data = list(range(12, 16))
print(sum(i for i, j in zip(data, [0] + data) if 13 not in (i, j)))
</code></pre>
<p><strong>Results:</strong></p>
<pre><code>27
</code></pre>
<p><strong>How does this work?</strong></p>
<p>Working from the inside out we start with <code>zip</code>.  zip takes multiple iterables, and returns the first element of each iterable on the first iteration, and then the second element of each on the second iteration, etc.</p>
<p>So we want to evaluate the current element of data, plus the previous element, so we pass data, and data offset by one element by padding data at the front (in this case a <code>0</code>)</p>
<p>These two lists are expanded, one element at a time, in to <code>i, j</code>.  Then, as a comprehension, we return <code>i</code> if <code>13</code> is not in either of <code>i, j</code>.  The comprehension is then evaluated by <code>sum</code>, which oddly enough sums all of the elements returned.</p>
</div>
<div class="post-text" itemprop="text">
<hr/>
<p>You could do this in a normal for loop:</p>
<pre><code>def sumarate(temp):
     my_sum = 0
     for index, value in enumerate(temp):
            if value == 13 or index!=0 and temp[index - 1] == 13:
                continue
            else:
                 my_sum += value
     print my_sum

&gt;&gt;&gt;temp = [13,1,1,1,13]
&gt;&gt;&gt;sumarate(temp)
2
&gt;&gt;&gt; temp = [13, 1, 1, 2]
&gt;&gt;&gt; sumarate(temp)
3
&gt;&gt;&gt; temp = [13, 1, 1, 2, 13]
&gt;&gt;&gt; sumarate(temp)
3
&gt;&gt;&gt; temp = [1, 13, 1, 1, 2]
&gt;&gt;&gt; sumarate(temp)
4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just trying to think outside the (explicit) loop...</p>
<pre><code>import re

def sum13(numbers):
    return eval(re.sub(r'(?:\+13)+(?:\+\d+)?', '', '+'.join(map(str, [0, *numbers]))))
</code></pre>
<p>If the <code>eval(...)</code> bothers you, substitute <code>sum(map(int, (...).split('+')))</code> instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the same idea as the while loop and save some bookkeeping with code like the following (I've revised it to handle multiple 13's in a row):</p>
<pre><code>elem_sum = 0
it = iter(nums)
for n in it:
    if n == 13:
        # skip any additional 13's plus the next number after them
        while next(it, 0) == 13:
            pass
    else:
        elem_sum += n
</code></pre>
<p>This one-liner should also work fine:</p>
<pre><code>elem_sum = sum(
    n for (i, n) in enumerate(nums) 
    if n != 13 and (i == 0 or nums[i-1] != 13)
)
</code></pre>
<p>The next one is fairly pedestrian and a little confusing, but workable (only left here because you commented on it):</p>
<pre><code>elem_sum = 0
was_13 = False
for n in nums:
    if n == 13:
        was_13 = True
    elif was_13:
        was_13 = False
    else:
        elem_sum += n
</code></pre>
<p>Or, finally a nice, simple, explicit version:</p>
<pre><code>elem_sum = 0
prev_num = 0
for num in nums:
    if num != 13 and prev_num != 13:
        elem_sum += num
    prev_num = num
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Below is a solution that I believe to be in the Python idiom, in a script. I added some test data.</p>
<h2>Why the for loop in the question doesn't work</h2>
<p>Modifying the index in a for loop in C or C++  is kind of OK because C in effect rewrites this:</p>
<pre><code>for(A;B;C) {D;}
</code></pre>
<p>as this:</p>
<pre><code>A; while(B) {D; C;}
</code></pre>
<p>Python doesn't do that. Python code like <code>for INDEX in LIST</code> takes a value from <code>LIST</code> every iteration and assigns it to <code>INDEX</code>. So modifying <code>INDEX</code> within the loop has no effect as soon as the top of the loop is reached. (A detail point is the <code>LIST</code> doesn't have to be a list; it can be something that produces a list, like an iterator or a generator.)</p>
<h2>Solution using zip</h2>
<p>TOTH @stephen-rauch for the zip solution, to which I made a couple of changes.</p>
<ul>
<li><code>[0] + data</code> creates a whole list on the fly, which would consume memory. 
In the code below, it's replaced with a generator.</li>
<li><code>i for i, j in ... if 13 not in (i, j)</code> unpacks the two-tuple returned by 
the zip, then repacks it into a two-tuple for the <code>in</code> test. In the code 
below, the whole tuple is assigned and in-tested without unpacking, then 
the first element is extracted at the outside of the list comprehension.</li>
</ul>
<h2>Code Extract</h2>
<p>I wrote a script with five solutions, including one that shows the same bug as the loop in the question. The zip solution is the best, so I omitted the others from the answer.</p>
<pre><code>def sum_lucky_zip(list, unlucky=13):
    """
    Zip of the list and a generator. Best approach and in the Python idiom.
    """
    def list_plus_one(list, unlucky):
        yield unlucky + 1
        for item in list:
            yield item
    return sum(items[0] for items in zip(list, list_plus_one(list, unlucky))
               if unlucky not in items)

def test_sum(summer, lists):
    print(summer.__name__)
    for list in lists:
        print(list, summer(list))
    print()

if __name__ == '__main__':
    testLists = (
        (),
        (13,),
        (1, 2, 4),
        (1, 2, 13, 4),
        (13, 1, 2),
        (13, 13),
        (1, 2, 13, 4, 13, 8),
        (13, 13, 1, 2),
        tuple(range(12, 16)))
    test_sum(sum_lucky_zip, testLists)
</code></pre>
<h2>Output</h2>
<pre><code>sum_lucky_zip
() 0
(13,) 0
(1, 2, 4) 7
(1, 2, 13, 4) 3
(13, 1, 2) 2
(13, 13) 0
(1, 2, 13, 4, 13, 8) 3
(13, 13, 1, 2) 2
(12, 13, 14, 15) 27
</code></pre>
<p>Happy coding!</p>
</div>
<span class="comment-copy">Take a look at <code>for</code> loop available in python: <a href="https://docs.python.org/3/tutorial/controlflow.html" rel="nofollow noreferrer">docs.python.org/3/tutorial/controlflow.html</a></span>
<span class="comment-copy">This is really better suited for <a href="https://codereview.stackexchange.com">Code Review</a>.</span>
<span class="comment-copy">@aryamccarthy I didn't even know that existed. I apologize.</span>
<span class="comment-copy">No need. Good luck.</span>
<span class="comment-copy">@StephenRauch Yes, this code works. The poster is looking for ways to make it more Pythonic.</span>
<span class="comment-copy">You can avoid creating the entire list by removing the brackets.</span>
<span class="comment-copy">This is a gorgeous solution. Thank you for this!</span>
<span class="comment-copy">This is a nice algorithm but your implementation is buggy -- you've got a formal parameter <code>nums</code> that should be <code>temp</code> and it should return instead of print.</span>
<span class="comment-copy">fails for sumarate([1,2,13])</span>
<span class="comment-copy">@cdlane I know that it should return but I did a print to show how it works. And the argument that <code>temp</code> should be <code>nums</code> isn't right. The name of a variable doesn't need to be equal to a parameter name in a function/method. It would be very sloppy calling in every place where you use the funtion/method the same way that you call it in the function/method.</span>
<span class="comment-copy">@Smart Manoj ou, I forgot a test of this kind. Thanks :)</span>
<span class="comment-copy">Look at your code again.  You pass <code>nums</code> but you operate on global <code>temp</code> and ignore <code>nums</code>.</span>
<span class="comment-copy">I actually do really like your first solution. Your one liner to me seems like a more complicated version of StephenRauch provided</span>
<span class="comment-copy">@AldenB, I believe this one also has problems with the [1,13, 13, 2, 1] case, possibly with the long version and the one-liner producing different results.</span>
<span class="comment-copy">This looks shockingly similar to a problem I just did before this one (horrible formatting ahead): Return the sum of the numbers in the array, except ignore sections of numbers starting with a 6 and extending to the next 7 (every 6 will be followed by at least one 7). Return 0 for no numbers.  def sum67(nums):   result = 0   count = True   for i in range(len(nums)):     if nums[i] == 6:       count = False     if count:       result += nums[i]     if nums[i] == 7:       count = True   return result</span>
<span class="comment-copy">@AldenB, this has changed a lot since you started commenting on it. Not sure you'll like the first version so much anymore, but hopefully there's still something useful in there!</span>
