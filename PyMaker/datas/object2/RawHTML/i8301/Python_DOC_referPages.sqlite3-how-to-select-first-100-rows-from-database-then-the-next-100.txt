<div class="post-text" itemprop="text">
<p>Currently I have database filled with 1000s of rows.</p>
<p>I want to SELECT the first 100 rows, and then select the next 100, then the next 100 and so on...</p>
<p>So far I have:</p>
<pre><code>c.execute('SELECT words FROM testWords')
data = c.fetchmany(100)
</code></pre>
<p>This allows me to get the first 100 rows, however, I can't find the syntax for selecting the next 100 rows after that, using another <code>SELECT</code> statement.</p>
<p>I've seen it is possible with other coding languages, but haven't found a solution with Python's SQLite3.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you are using <code>cursor.fetchmany()</code> you don't have to issue another <code>SELECT</code> statement. The cursor is keeping track of where you are in the series of results, and all you need to do is call <code>c.fetchmany(100)</code> again until that produces an empty result:</p>
<pre><code>c.execute('SELECT words FROM testWords')
while True:
    batch = c.fetchmany(100)
    if not batch:
        break
    # each batch contains up to 100 rows
</code></pre>
<p>or using the <a href="https://docs.python.org/3/library/functions.html#iter" rel="noreferrer"><code>iter()</code> function</a> (which can be used to repeatedly call a function until a sentinel result is reached):</p>
<pre><code>c.execute('SELECT words FROM testWords')
for batch in iter(lambda: c.fetchmany(100), []):
    # each batch contains up to 100 rows
</code></pre>
<p>If you can't keep hold of the cursor (say, because you are serving web requests), then using <code>cursor.fetchmany()</code> is the wrong interface. You'll instead have to tell the <code>SELECT</code> statement to return only a selected window of rows, using the <a href="https://sqlite.org/lang_select.html#limitoffset" rel="noreferrer"><code>LIMIT</code> syntax</a>. <code>LIMIT</code> has an optional <code>OFFSET</code> keyword, together these two keywords specify at what row to start and how many rows to return.</p>
<p>Note that you want to make sure that your <code>SELECT</code> statement is <em>ordered</em> so you get a stable result set you can then slice into batches.</p>
<pre><code>batchsize = 1000
offset = 0
while True:
    c.execute(
        'SELECT words FROM testWords LIMIT ? OFFSET ?',
        (batchsize, offset))
    batch = list(c)
    offset += batchsize
    if not batch:
        break
</code></pre>
<p>Pass the <code>offset</code> value to a next call to your code if you need to send these batches elsewhere and then later on resume.</p>
</div>
<div class="post-text" itemprop="text">
<p>sqlite3 is nothing to do with Python. It is a standalone database; Python just supplies an interface to it.</p>
<p>As a normal database, sqlite supports standard SQL. In SQL, you can use LIMIT and OFFSET to determine the start and end for your query. Note that if you do this, you should really use an explicit ORDER BY clause, to ensure that your results are consistently ordered between queries.</p>
<pre><code>c.execute('SELECT words FROM testWords ORDER BY ID LIMIT 100')
...
c.execute('SELECT words FROM testWords ORDER BY ID LIMIT 100 OFFSET 100')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can crate iterator and call it multiple times:</p>
<pre><code>def ResultIter(cursor, arraysize=100):
    while True:
        results = cursor.fetchmany(arraysize)
        if not results:
            break
        for result in results:
            yield result
</code></pre>
</div>
<span class="comment-copy">So what happened when you called <code>c.fetchmany(100)</code> <i>again</i>?</span>
<span class="comment-copy">finally found it! upvoted! i have the same case of fetching 100 rows every time except mine depends on data, simply stated, i am looking to fetch 100 rows where column = 'a' then 100 where column = 'b' and so on, does this same approach work, my case is slightly complicated by the fact that there may not be 100 rows exactly each time hence the column value search</span>
<span class="comment-copy">Besides, <code>c.fetchmany()</code> is meant to be called repeatedly, returning the next batch on the same cursor each time you call it..</span>
