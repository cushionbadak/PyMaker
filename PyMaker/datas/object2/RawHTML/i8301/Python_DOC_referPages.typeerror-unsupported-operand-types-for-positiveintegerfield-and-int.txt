<div class="post-text" itemprop="text">
<p>Hello I am having a problem which I guess is really simple. I have the following class:</p>
<pre><code>class Plant(models.Model):
    nominal_power = models.PositiveIntegerField()
    module_nominal_power= models.PositiveIntegerField()

    def calculation_of_components(a, b):
        return int((a*1000)/b)

    no_modules=calculation_of_components(nominal_power,module_nominal_power)
</code></pre>
<p>and I get the error: 
<code>TypeError: unsupported operand type(s) for *: 'PositiveIntegerField' and 'int'</code> </p>
<p>How can I solve this problem?</p>
</div>
<div class="post-text" itemprop="text">
<p>First: <code>calculation_of_components</code> is a static method of class.</p>
<p>In your code <code>no_modules</code> is a result of function <code>calculation_of_components</code>. Probably You need a function:</p>
<pre><code>class Plant(models.Model):
    nominal_power = models.PositiveIntegerField()
    module_nominal_power= models.PositiveIntegerField()

    @staticmethod    
    def calculation_of_components(a, b):
        return int((a*1000)/b)

    def no_modules(self):
        return self.calculation_of_components(self.nominal_power, self.module_nominal_power)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem is you're calling <code>calculation_of_components</code> at the creation time of the model class, when the fields have yet to take any value.</p>
<p>You can solve this by making <code>no_modules</code> a <strong><a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer"><code>property</code></a></strong> so <code>calculation_of_components</code> does not get called at the creation of the model class, when the fields have no value:</p>
<pre><code>class Plant(models.Model):
    nominal_power = models.PositiveIntegerField()
    module_nominal_power = models.PositiveIntegerField()

    def calculation_of_components(self, a, b):
        return int((a*1000)/b)

    @property
    def no_modules(self):
        return self.calculation_of_components(self.nominal_power, self.module_nominal_power)
</code></pre>
<p>You can then access <code>no_modules</code> like a regular model field:</p>
<pre><code>plnt = Plant(...)
plnt.no_modules 
</code></pre>
<p><sub>Pro-Tip: you can use integer division <code>//</code> in your calculation and avoid calling <code>int</code>: <code>a * 1000 // b</code> </sub></p>
</div>
<div class="post-text" itemprop="text">
<p>This error means the type of objects you're trying to multiply (*) are different objects, you cannot multiply <code>PositiveIntegerField</code> with <code>int</code>. You mixed <code>PositiveIntegerField</code> object with <code>int</code> object. You can make <code>PositiveIntegerField</code> appears in multiplication expressions by defining <code>__mul__</code> operator overloading method in your class so when an instance of <code>PositiveIntegerField</code> appears with multiplication expression Python automatically overloads <code>__mul__</code> method. In python 2.X <code>__coerce__</code> gets called when different types of objects appear in such expressions in order to coerce them to a common type. Though, the use of <code>__coerce__</code> isn't recommended. </p>
<p>Some classes that may be used in mathematical operations use <code>__int__</code> to return an integer representing their values when needed: </p>
<pre><code>class Num:
    def __int__(self):
        return self.value

int(Num()) * 20 
</code></pre>
</div>
<span class="comment-copy">one way is you could convert <code>PositiveIntegerField</code> back to <code>int</code>: <code>nominal_power = int(models.PositiveIntegerField())</code> <code>module_nominal_power= int(models.PositiveIntegerField())</code></span>
<span class="comment-copy">Just cast them to integers: <code>( int(a) * 1000 ) / int(b)</code></span>
<span class="comment-copy">I tried your solution but when I try to call no_modules in my views.py         <b>plants = Plant.objects.filter(user=request.user)</b> <b>total_no_modules = Plant.objects.filter(user=request.user).aggregate(sum=Sum('plants.no_modules'))</b> I get <b>Exception Type: FieldError</b></span>
<span class="comment-copy">@George You can use it as you would a model field. If you want to you can define it as an <code>IntegerField</code> and assign its value when you're saving the model.</span>
<span class="comment-copy">how can I do this?</span>
<span class="comment-copy">Did I get anything wrong in my answer? I see a down vote.</span>
