<div class="post-text" itemprop="text">
<p>I'm trying to learn decorators in Python and every time I think I get it I come across an issue such as this. I can't figure out why the print statement from <code>my_func</code> won't display and instead I get 'None' returned. If I include <code>func</code> in my return statement in my wrapper <code>return (func, wrapper)</code> I get an error saying tuple object not callable. What is wrong with this example?</p>
<pre><code>def my_dec(func):
    def wrapper():
        decoration = "decorated"
        print(decoration)
    return wrapper

@my_dec
def my_func():
    a = "Original"
    print (a)

print(my_func())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You're never calling the wrapped <code>func</code> in your <code>wrapper</code>. Add a call, for example:</p>
<pre><code>def my_dec(func):
    def wrapper():
        decoration = "decorated"
        print(decoration)
        # Call the decorated function and return what it returns
        return func()

    return wrapper

@my_dec
def my_func():
    a = "Original"
    print (a)

print(my_func())
</code></pre>
<p>would now produce (since <code>func()</code> <a href="https://docs.python.org/3/tutorial/controlflow.html#defining-functions" rel="nofollow noreferrer">implicitly returns <code>None</code></a>):</p>
<pre><code>decorated
Original
None
</code></pre>
<blockquote>
<p>If I include <code>func</code> in my return statement in my wrapper <code>return func, wrapper</code> I get an error saying tuple object not callable. </p>
</blockquote>
<p>The error must've come from you doing something like:</p>
<pre><code>def my_dec(func):
    def wrapper():
        decoration = "decorated"
        print(decoration)

    # Now `my_dec` returns a tuple instead of a function
    return func, wrapper
</code></pre>
<p>Remember that decorating <a href="https://docs.python.org/3/reference/compound_stmts.html#function-definitions" rel="nofollow noreferrer">is (roughly) equivalent to just doing</a>:</p>
<pre><code>def my_func():
    ...

my_func = my_dec(my_func)
</code></pre>
<p>Your <code>my_dec()</code> decorator now returned a tuple <code>(func, wrapper)</code> instead of a wrapper function, so when you try to call <code>my_func()</code>, you're actually trying to "call" the tuple that has been assigned to <code>my_func</code>.</p>
<p>As a good measure you should learn how to use <a href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="nofollow noreferrer"><code>functools.wraps</code></a>, which is a convenience function for invoking <code>update_wrapper()</code>, which updates the <em>wrapper</em> function to look like <em>func</em>:</p>
<pre><code>from functools import wraps

def my_dec(func):
    @wraps(func)
    def wrapper():
        decoration = "decorated"
        print(decoration)
        return func()

    return wrapper
</code></pre>
<p>Without it you'd get:</p>
<pre><code>In [4]: print(my_func.__name__)
wrapper
</code></pre>
<p>and with wraps:</p>
<pre><code>In [9]: print(my_func.__name__)
my_func
</code></pre>
<p>It copies over other useful attributes as well, such as <code>__doc__</code>.</p>
</div>
<span class="comment-copy">You could improve your question by including the expected and actual outputs.</span>
<span class="comment-copy">That makes sense to me now. Thank you very much. I will be exploring functools.wraps now too.</span>
