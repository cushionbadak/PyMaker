<div class="post-text" itemprop="text">
<p>I have the following Python regex:</p>
<pre><code>&gt;&gt;&gt; p = re.compile(r"(\b\w+)\s+\1")
</code></pre>
<p><code>\b</code>    :   word boundary<br/>
<code>\w+</code>  :   one or more alphanumerical characters<br/>
<code>\s+</code>  :   one or more whitespaces (can be <code></code>, <code>\t</code>, <code>\n</code>, ..)<br/>
<code>\1</code>    :   backreference to group 1 ( = the part between <code>(..)</code>)<br/></p>
<p>This regex should find all double occurences of a word - if the two occurences are next to each other with some whitespace in between.<br/>
The regex seems to work fine when using the <b>search</b> function:</p>
<pre><code>&gt;&gt;&gt; p.search("I am in the the car.")

&lt;_sre.SRE_Match object; span=(8, 15), match='the the'&gt;
</code></pre>
<p>The found match is <code>the the</code>, just as I had expected. The weird behaviour is in the <b>findall</b> function:</p>
<pre><code>&gt;&gt;&gt; p.findall("I am in the the car.")

['the']
</code></pre>
<p>The found match is now only <code>the</code>. Why the difference?</p>
</div>
<div class="post-text" itemprop="text">
<p>When using groups in a regular expression, <code>findall()</code> returns only the groups; from the <a href="https://docs.python.org/3/library/re.html#re.findall" rel="nofollow noreferrer">documentation</a>:</p>
<blockquote>
<p>If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group.</p>
</blockquote>
<p>You can't avoid using groups when using backreferences, but you <em>can</em> put a new group around the whole pattern:</p>
<pre><code>&gt;&gt;&gt; p = re.compile(r"((\b\w+)\s+\2)")
&gt;&gt;&gt; p.findall("I am in the the car.")
[('the the', 'the')]
</code></pre>
<p>The outer group is group 1, so the backreference should be pointing to group 2. You now have <em>two</em> groups, so there are two results per entry. Using a named group might make this more readable:</p>
<pre><code>&gt;&gt;&gt; p = re.compile(r"((?P&lt;word&gt;\b\w+)\s+(?P=word))")
</code></pre>
<p>You can filter that back to just the outer group result:</p>
<pre><code>&gt;&gt;&gt; [m[0] for m in p.findall("I am in the the car.")]
['the the']
</code></pre>
</div>
<span class="comment-copy">Because <code>findall</code> returns only the capturing groups if there are any (or the complete match otherwise).</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/re.html#re.findall" rel="nofollow noreferrer">docs.python.org/3/library/re.html#re.findall</a> "If one or more groups are present in the pattern, return a list of groups"</span>
<span class="comment-copy">Oh, now I see. Thank you. So I have to use a non-capturing group to solve the issue? I will try it out right now..</span>
<span class="comment-copy">I get a <code>sre_constants.error: invalid group reference 1 at position 13</code> error when changing my group <code>(...)</code> by <code>(?:...)</code> to make it non-capturing. Perhaps that's because using a backrefence to a non-capturing group is impossible?</span>
<span class="comment-copy">@K.Mulier: well, you can't do that because then you have nothing for <code>\1</code> to match against..</span>
<span class="comment-copy">Great answer! Thank you Martijn :-)</span>
