<div class="post-text" itemprop="text">
<p>Consider the following code which creates a very simple table (without using SQLAlchemy), then adds an entry to it using SQLAlchemy ORM and retrieves it:</p>
<pre><code>import sqlite3
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

DB_PATH = '/tmp/tst.db'

#create a DB
sqlite_conn = sqlite3.connect(DB_PATH)
sqlite_conn.execute('''CREATE TABLE tst (
    id INTEGER PRIMARY KEY ASC AUTOINCREMENT,
    c0 INTEGER,
    c1 INTEGER
);''')
sqlite_conn.commit()

#intialize an SA engine/session/mapped class
engine = create_engine('sqlite:///{}'.format(DB_PATH))
Base = declarative_base()
Base.metadata.reflect(bind=engine)
Session = sessionmaker(bind=engine)

class Tst(Base):
    __table_name__ = 'tst'
    __table__ = Base.metadata.tables[__table_name__]
    columns = list(__table__.columns)
    field_names = [c.name for c in columns]

#add an entry to the table
session = Session()
inst = Tst()
session.add(inst)
session.commit()

#retrieve an entry from the table
session = Session()
inst = session.query(Tst).first()
print inst.c1
</code></pre>
<p>One may expect that the code above will just print 'None', as 'c1' was not assigned a value. Instead of it, I'm getting the following error message:</p>
<pre><code>Traceback (most recent call last):
  File "...", line 39, in &lt;module&gt;
    print inst.c1
AttributeError: 'Tst' object has no attribute 'c1'
</code></pre>
<p>But if the following line will be removed/commented:</p>
<pre><code>    field_names = [c.name for c in columns]
</code></pre>
<p>the output will be as expected.</p>
<p><strong>In general, it looks like the iteration over <code>Table.columns</code> inside the class definition will cause the last column to be omitted from the class instances.</strong></p>
<p>Following <a href="https://stackoverflow.com/a/6039787">this answer</a>, I actually changed the code to use <code>Inspector</code>, and it worked fine. However, AFAIK, accessing <code>Table.columns</code> is completely legitimate, so I wanted to understand whether it's buggy behavior or something wrong on my side.</p>
<p><strong>P.S.</strong> tested with SQLAlchemy 1.1.9</p>
<p><strong>P.P.S.</strong> the issue doesn't appear to be related to a specific DB dialect - reproduced with MySQL, sqlite.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is more of a Python version issue than an SQLAlchemy issue. The root cause is the <a href="https://stackoverflow.com/questions/19848082/why-do-list-comprehensions-write-to-the-loop-variable-but-generators-dont">leaking of the name <code>c</code> from the list-comprehension</a> in Python 2. It becomes part of the namespace of the constructed class, and so SQLAlchemy sees it as if you were <a href="http://docs.sqlalchemy.org/en/latest/orm/mapping_columns.html#naming-columns-distinctly-from-attribute-names" rel="nofollow noreferrer">explicitly naming the last column in the list <code>columns</code> in your class definition</a>. Your class definition is equivalent to:</p>
<pre><code>class Tst(Base):
    __table_name__ = 'tst'
    __table__ = Base.metadata.tables[__table_name__]
    columns = list(__table__.columns)
    ...
    c = columns[-1]  # The last column of __table__
</code></pre>
<p>If you change your print statement to:</p>
<pre><code>print inst.c
</code></pre>
<p>you'll get <code>None</code> as you expected. If you must have your <code>field_names</code>, you could for example remove the name from the namespace:</p>
<pre><code>class Tst(Base):
    __table_name__ = 'tst'
    __table__ = Base.metadata.tables[__table_name__]
    columns = list(__table__.columns)
    field_names = [c.name for c in columns]
    del c
</code></pre>
<p>but this is unportable (and ugly) between Python 2 and 3, since the name would not actually exist in 3. You could also work around the issue with <a href="https://docs.python.org/3/library/operator.html#operator.attrgetter" rel="nofollow noreferrer"><code>attrgetter()</code></a>:</p>
<pre><code>from operator import attrgetter

class Tst(Base):
    __table_name__ = 'tst'
    __table__ = Base.metadata.tables[__table_name__]
    columns = list(__table__.columns)
    field_names = list(map(attrgetter('name'), columns))
</code></pre>
<p>or use a generator expression:</p>
<pre><code>    field_names = list(c.name for c in columns)
</code></pre>
</div>
