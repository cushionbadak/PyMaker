<div class="post-text" itemprop="text">
<p>I'm trying to learn some advanced decorator usage. Specifically, I'm trying to  to monkey patch a class's method via a decorator within a function.</p>
<p>This is a basic example to illustrate what I'm trying to do. I have a function <code>something</code> that does some stuff; and within that function there's an instance of a class. That instance I would like to monkey patch. </p>
<pre><code>from functools import update_wrapper

class Foobar:
    def get_something(self):
        return "apple"

class FakeFoobar:
    def get_something(self):
        return "orange"

class my_decorator:
    def __init__(self, original_function):
        self._original_function = original_function
        update_wrapper(self, original_function)

    def __call__(self, *args, **kwargs):
        # some magic here?
        return self._original_function(*args, **kwargs)

@my_decorator
def something():
    f = Foobar()
    return f.get_something()

if __name__ == '__main__':
    print(something())
</code></pre>
<p>I'm trying either trying to do a 1 to 1 replacement with <code>Foobar</code> to <code>FakeFoobar</code> or, monkey patch <code>Foobar</code>'s <code>get_something</code> method to <code>FakeFoobar</code>'s <code>get_something</code> method. </p>
<p>When I run the code above, I get the following:</p>
<pre><code>&gt;&gt;&gt; something()
'apple'
&gt;&gt;&gt;
</code></pre>
<p>I would like to find some way augment the <code>Foobar</code>'s <code>get_something</code> method so that we get the following output:</p>
<pre><code>&gt;&gt;&gt; something()
'orange'
&gt;&gt;&gt;
</code></pre>
<p>There's a <code>mock</code> module within the <code>unittests</code> library, however, it's not clear to be how I could leverage that for my use case. I'm fairly married to the idea of not passing an argument into the decorator or an extra argument into the <code>something</code> function as many of the examples of the <a href="https://docs.python.org/3/library/unittest.mock-examples.html#patch-decorators" rel="nofollow noreferrer">mock</a> library show. </p>
<p>I also notice that the <a href="https://github.com/spulec/moto" rel="nofollow noreferrer">moto library</a> is accomplishing something similar to what I'm trying to do. I tried digging into the source code, but it seems fairly complex for what I'm trying to do. </p>
</div>
<div class="post-text" itemprop="text">
<p>How about updating the global variables dict of the function?</p>
<pre><code>from functools import update_wrapper

class Foobar:
    def get_something(self):
        return "apple"

class FakeFoobar:
    def get_something(self):
        return "orange"

class my_decorator:
    def __init__(self, original_function):
        self._original_function = original_function
        update_wrapper(self, original_function)

    def __call__(self, *args, **kwargs):
        f = self._original_function
        restore_val = f.func_globals['Foobar']
        f.func_globals['Foobar'] = f.func_globals['FakeFoobar']
        # ^^^^^ This is your magic-line.
        try:
            return f(*args, **kwargs)
        except:
            raise
        finally:
            f.func_globals['Foobar'] = restore_val

@my_decorator
def something():
    f = Foobar()
    return f.get_something()

if __name__ == '__main__':
    print(something())   #Prints orange
    print(Foobar().get_something()) #Prints apple
</code></pre>
</div>
<span class="comment-copy">This is pretty close. The problem is that it updates the globals for the entire module so if I re-instantiate <code>Foobar</code> outside of the <code>something</code> function I get back <code>FakeFoobar</code> which is not desirable.</span>
<span class="comment-copy">@user5038859: You can always restore the variable as in the answer that I just updated.</span>
<span class="comment-copy">This is what I was looking for, thank you. Before I mark this as the answer, please accept my edits for python3 support.</span>
