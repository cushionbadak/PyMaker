<div class="post-text" itemprop="text">
<p>today I've played around with nested generator functions and found an interesting property / behavior which I can't explain to myself. </p>
<p>Maybe this is associated with a lack of understanding of what <code>yield from</code> does…. However, now to the problem:</p>
<pre><code>def foo():
    for iter in range(10):
        yield iter

generator = foo()

def bar():
    yield from generator

print(next(bar()), end=' ')
print(next(bar()), end=' ')
...
</code></pre>
<p>So the output I excepted would be <code>0 1 ...</code>.</p>
<p>However, after the first successfull call to <code>next</code>, I get:
    Traceback (most recent call last):
      File "", line 1, in 
    StopIteration</p>
<p>So my question is: Why has the generator already reached its end?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>generator</code> object is a global; you never create a new one. Once iterated over <strong>or closed</strong>, it is exhausted.</p>
<p>It is closed because you used <code>yield from</code> in a function. When the <code>bar</code> generator function ends, the <code>GeneratorExit</code> exception is propagated to the underlying generator (so the <code>foo()</code> instance), and it is closed too. <code>bar()</code> ends, because there are no references to the object and it is cleaned up.</p>
<p>From the <a href="https://docs.python.org/3/reference/expressions.html#yield-expressions" rel="nofollow noreferrer"><em>Yield expressions</em> section</a>:</p>
<blockquote>
<p>When <code>yield from &lt;expr&gt;</code>is used, it treats the supplied expression as a subiterator. All values produced by that subiterator are passed directly to the caller of the current generator’s methods. Any values passed in with <code>send()</code> and any exceptions passed in with <code>throw()</code> are passed to the underlying iterator if it has the appropriate methods.</p>
</blockquote>
<p>and from <a href="https://www.python.org/dev/peps/pep-0380/" rel="nofollow noreferrer">PEP-380 *Syntax for Delegating to a Subgenerator</a>:</p>
<blockquote>
<p>If a <code>GeneratorExit</code> exception is thrown into the delegating generator, or the <code>close()</code> method of the delegating generator is called, then the <code>close()</code> method of the iterator is called if it has one.</p>
</blockquote>
<p>In detail, what happens, is this:</p>
<ul>
<li><code>generator = foo()</code> creates a new generator object.</li>
<li><code>bar()</code> creates another. There are no references to this object however, other than the stack.</li>
<li><code>next()</code> takes the <code>bar()</code> generator from the stack and forwards it one step.</li>
<li><code>next()</code> returns, and there are no references left to the <code>bar()</code> generator, so it is deleted.</li>
<li>Deleting a generator object calls the <a href="https://docs.python.org/3/reference/expressions.html#generator.close" rel="nofollow noreferrer"><code>generator.close()</code> method</a>, raising <code>GeneratorExit</code> in the generator, via <a href="https://docs.python.org/3/reference/expressions.html#generator.throw" rel="nofollow noreferrer"><code>generator.throw()</code></a>.</li>
<li><code>yield from</code> propagates that exception to the <code>foo()</code> generator object by closing that too.</li>
</ul>
</div>
