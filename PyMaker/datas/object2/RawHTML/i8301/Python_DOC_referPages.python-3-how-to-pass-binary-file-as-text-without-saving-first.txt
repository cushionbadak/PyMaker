<div class="post-text" itemprop="text">
<p>Or, perhaps a better title: how to avoid unwanted extra carriage return when passing binary file to text mode write clause. </p>
<p>Python 3.6, Windows. Input file needs to undergo first a binary search/replace, and then a regex search/replace. </p>
<p>I first open the input file in binary mode, do the work, and save it in binary mode in a temporary file. Then I open that in text mode, do the regex search/replace, and save it in text mode (with a name resembling that of the input file). </p>
<pre><code>def fixbin(infile): 
    with open(infile, 'rb') as f:
        file = f.read()

    # a few bytearray operations here, then: 
    with open('bin.tmp', 'wb') as f: 
        f.write(file)

def fix4801(fname, ext): 
    outfile = '{}_OK{}'.format(fname, ext)    
    with open('bin.tmp', encoding='utf-8-sig', mode='r') as f, \
         open(outfile, encoding='utf-8-sig', mode='w') as g: 
        infile = f.read()
        x = re.sub(r'(\n4801.+\n)4801', r'\1    ', infile)
        g.write(y)

infile, fname, ext = get_infile() # function get_infile not shown for brevity
fixbin(infile)
fix4801(fname, ext)
</code></pre>
<p>It works but it's ugly. I'd rather pass outputs as files, like so:</p>
<pre><code>def fixbin(infile): 
    with open(infile, 'rb') as f:
        file = f.read()
    # a few bytearray operations here, and then
    return file.decode('utf-8')

def fix4801(infile): 
    x = re.sub(r'(\n4801.+\n)4801', r'\1    ', infile)
    return x

...
temp = fixbin(infile)
result = fix4801(temp)

outfile = '{}_OK{}'.format(fname, ext)
with open(outfile, encoding='utf-8-sig', mode='w') as g:
    g.write(result)
</code></pre>
<p>But then the output file (Windows) gets an unwanted extra carriage return. The symptoms are described <a href="https://stackoverflow.com/questions/4025760/python-file-write-creating-extra-carriage-return">here</a>, but the cause is different: I'm not using <code>os.linesep</code>, in other words there is no os.linesep in my code. (there may be in the underlying libraries, I haven't checked.)</p>
<p>What am I doing wrong? </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><strong>Python » Documentation</strong> :  <a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow noreferrer">open</a> </p>
<pre><code>open(file, mode='r', buffering=-1, encoding=None, errors=None, 
           newline=None, closefd=True, opener=None)  
</code></pre>
</blockquote>
<p><strong>Default</strong>: <code>newline=None</code>, <strong>If newline is <code>''</code> or <code>'\n'</code>, no translation takes place.</strong><br/>
Try the following if it makes any different:  </p>
<pre><code>#change
    open(outfile, encoding='utf-8-sig', mode='w') as g:
#with
    open(outfile, encoding='utf-8-sig', mode='w', newline='') as g:
</code></pre>
<blockquote>
<p><strong>Question</strong>: ... there is no os.linesep in my code.  </p>
</blockquote>
<hr/>
<blockquote>
<p><strong>Python » Documentation</strong> :  <a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow noreferrer">open</a><br/>
  When writing output to the stream, if newline is None, any '\n' characters written are translated to the system default line separator, os.linesep. If newline is '' or '\n', no translation takes place. If newline is any of the other legal values, any '\n' characters written are translated to the given string.  </p>
</blockquote>
</div>
<span class="comment-copy">How could you be Shure about <i>"I'm not using os.linesep."</i>, please explain.</span>
