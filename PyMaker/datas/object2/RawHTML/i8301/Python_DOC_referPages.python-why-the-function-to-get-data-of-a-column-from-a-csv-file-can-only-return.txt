<div class="post-text" itemprop="text">
<p>I am trying to plot weather data of a city during a whole year, such high_temp_f and low_temp_f, the data has been stored in a CSV file. I wrote a function to get the columns I need in order to plot them in a chart, but the function can only return the data for the first time I use it.</p>
<p>The CSV file structure is as below:</p>
<pre><code>date,high_temp_f,avg_temp_f,low_temp_f
2016-04-18,69,58,46
2016-04-19,59,52,46
2016-04-20,80,63,46
</code></pre>
<p>The code I wrote is as below:</p>
<pre><code>import csv

def data_to_list(data_index):
    """ save data to a list """
    results = []
    for row in data:
        results.append(int(row[data_index]))
    return results

filename = 'city.csv'
with open(filename) as f_city:
    data = csv.reader(f_city)
    header = next(data)


    high_temp_f_bj = data_to_list(1)
    low_temp_f_bj = data_to_list(3)

print(high_temp_f_bj)
print(low_temp_f_bj)
</code></pre>
<p>The output is as below:</p>
<pre><code>[69, 59, 80]
[]
</code></pre>
<p>I got the result of high_temp_f_bj, which is [69, 59, 80], but for low_temp_f_bj, I've only got []. However, if I delete the code of <code>high_temp_f_bj = data_to_list(1)</code> and <code>print(high_temp_f_bj)</code>, I can get the right output of low_temp_f_bj, which is [46, 46, 46]. I am so confused! Why can I only use the function once???</p>
</div>
<div class="post-text" itemprop="text">
<p><code>csv.reader</code> returns a <a href="https://docs.python.org/3/library/csv.html#reader-objects" rel="nofollow noreferrer">Reader object</a> which is an iterator, and as such has a <em>state</em> of where in the data you are.</p>
<p>This is why you can use <code>next(data)</code> to read the <em>next</em> (in this case first) line of the data. Calling <code>next()</code> not only gives you the line, but also advances the internal state so the next call would give you the following line. That’s why you do not have to skip the header line again in your <code>data_to_list</code> function.</p>
<p>However, this has also the effect that you can only navigate through the file once. <code>next()</code> (or iterating over <code>data</code> which just does subsequent <code>next()</code> calls) will continuously move forward that internal line pointer until the end of the file is reached. But when the end is reached, you also cannot just read again.</p>
<p>Some file based iterators allow you to <em>seek</em> back to the beginning of the file; a CSV reader does not (at least to my knowledge). So if you want to process the data multiple times, you will have to load the parsed CSV data into memory first:</p>
<pre><code>with open(filename) as f_city:
    data = csv.reader(f_city)
    header = next(data)

    # create a list from the remaining contents in the iterable
    data = list(data)
</code></pre>
<p>Alternatively, you should consider changing your <code>data_to_list</code> function to be able to process multiple columns at once, so you only need to move <em>once</em> through your file and do not have to store all the contents in memory.</p>
<hr/>
<p>If you’re having difficulties understanding this iterable thing and that internal pointer, try with an easier iterator first. You can get one from any sequence by calling <code>iter()</code> on it:</p>
<pre><code>&gt;&gt;&gt; example = [1, 2, 3, 4]
&gt;&gt;&gt; iterator = iter(example)
&gt;&gt;&gt; next(iterator)
1
&gt;&gt;&gt; next(iterator)
2
&gt;&gt;&gt; for x in iterator:
        print(x)

3
4
&gt;&gt;&gt; next(iterator)
Traceback (most recent call last):
  File "&lt;pyshell#8&gt;", line 1, in &lt;module&gt;
    next(iterator)
StopIteration
</code></pre>
<p>As you can see, calling <code>next()</code> on the iterator gives you the <em>next</em> element from the iterator. The calls move the internal pointer which is why you don’t get the same element from multiple <code>next()</code> calls. And when you iterate over the iterator using a <code>for</code> loop you also just get the remaining elements from the iterator. Once the iterator is exhausted (which causes the <code>for</code> loop to end), subsequent calls to <code>next()</code> will not yield any new results but just raise a <code>StopIteration</code> exception, which is the sign that the iterator is exhausted (this is also what causes the <code>for</code> loop to end).</p>
</div>
<div class="post-text" itemprop="text">
<p>Once you have read the file, and you are at the end, there is nothing more to read.  You could re-open it for each call to <code>data_to_list</code>, or (more efficiently) modify <code>data_to_list</code> to handle all of the columns at once.</p>
</div>
<div class="post-text" itemprop="text">
<p>This happens because the <code>csv.reader</code> returns a iterator, and your <code>data_to_list</code> function iterates it. So when you run the function a second time the iterator is finished.</p>
<p>You can load the data to a list of dicts (if it's not too large) and do the processing on it.</p>
<pre><code>with open(filename) as f_city:
    data_iterator = csv.reader(f_city)
    header = next(data_iterator)
    rows = list(data_iterator)
    high_temp_data = [row['high_temp_f'] for row in rows]
    avg_temp_data = [row['avg_temp_f'] for row in rows]
</code></pre>
</div>
