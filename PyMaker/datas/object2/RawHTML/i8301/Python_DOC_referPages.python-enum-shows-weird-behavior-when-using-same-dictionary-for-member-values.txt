<div class="post-text" itemprop="text">
<p>I don't understand why this Enum doesn't have all the members I defined, when I assign a dict as each member's value:</p>
<pre><code>from enum import Enum

class Token(Enum):
    facebook = {
    'access_period': 0,
    'plan_name': ''}

    instagram = {
    'access_period': 0,
    'plan_name': ''}

    twitter = {
    'access_period': 0,
    'plan_name': ''}

if __name__ == "__main__":
    print(list(Token))
</code></pre>
<p>The output is:</p>
<pre><code>[&lt;Token.twitter: {'plan_name': '', 'access_period': 0}&gt;]
</code></pre>
<p>â€¦ but I expected something like:</p>
<pre><code>[&lt;Token.facebook:  {'plan_name': '', 'access_period': 0}&gt;,
 &lt;Token.instagram: {'plan_name': '', 'access_period': 0}&gt;,
 &lt;Token.twitter:   {'plan_name': '', 'access_period': 0}&gt;]
</code></pre>
<p>Why aren't all the members shown?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/enum.html" rel="nofollow noreferrer">Enum</a> enforces unique values for the members. Member definitions with the same value as other definitions will be treated as aliases.</p>
<p>Demonstration:</p>
<pre><code>Token.__members__
# OrderedDict([('twitter',
#               &lt;Token.twitter: {'plan_name': '', 'access_period': 0}&gt;),
#              ('facebook',
#               &lt;Token.twitter: {'plan_name': '', 'access_period': 0}&gt;),
#              ('instagram',
#               &lt;Token.twitter: {'plan_name': '', 'access_period': 0}&gt;)])

assert Token.instagram == Token.twitter
</code></pre>
<p>The defined <strong>names</strong> do all exist, however they are all mapped to the same member.</p>
<p>Have a look at the <a href="https://github.com/python/cpython/blob/3.6/Lib/enum.py#L213" rel="nofollow noreferrer">source code</a> if you are interested:</p>
<pre><code># [...]
# If another member with the same value was already defined, the
# new member becomes an alias to the existing one.
for name, canonical_member in enum_class._member_map_.items():
    if canonical_member._value_ == enum_member._value_:
        enum_member = canonical_member
        break
else:
    # Aliases don't appear in member names (only in __members__).
    enum_class._member_names_.append(member_name)
# performance boost for any member that would not shadow
# a DynamicClassAttribute
if member_name not in base_attributes:
    setattr(enum_class, member_name, enum_member)
# now add to _member_map_
enum_class._member_map_[member_name] = enum_member
try:
    # This may fail if value is not hashable. We can't add the value
    # to the map, and by-value lookups for this value will be
    # linear.
    enum_class._value2member_map_[value] = enum_member
except TypeError:
    pass
# [...]
</code></pre>
<hr/>
<p>Further, it seems to me that you want to exploit the Enum class to modify the value (the dictionary) during run-time. This is strongly discouraged and also very unintuitive for other people reading/using your code. An enum is expected to be made of constants.</p>
</div>
<div class="post-text" itemprop="text">
<p>As <a href="https://stackoverflow.com/a/43523125/208880">@MichaelHoff noted</a>, the behavior of <code>Enum</code> is to consider names with the same values to be aliases<sup>1</sup>.</p>
<p>You can get around this by using the <a href="https://pypi.python.org/pypi/aenum" rel="nofollow noreferrer"><code>Advanced Enum</code></a><sup>2</sup> library:</p>
<pre><code>from aenum import Enum, NoAlias

class Token(Enum):
    _settings_ = NoAlias
    facebook = {
        'access_period': 0,
        'plan_name': '',
        }

    instagram = {
        'access_period': 0,
        'plan_name': '',
        }

    twitter = {
        'access_period': 0,
        'plan_name': '',
        }

if __name__ == "__main__":
    print list(Token)
</code></pre>
<p>Output is now:</p>
<pre><code>[
  &lt;Token.twitter: {'plan_name': '', 'access_period': 0}&gt;,
  &lt;Token.facebook: {'plan_name': '', 'access_period': 0}&gt;,
  &lt;Token.instagram: {'plan_name': '', 'access_period': 0}&gt;,
  ]
</code></pre>
<p>To reinforce what Michael said:  <code>Enum</code> members are meant to be constants -- you shouldn't use non-constant values unless you really know what you are doing.</p>
<hr/>
<p>A better example of using <code>NoAlias</code>:</p>
<pre><code>class CardNumber(Enum):

    _order_ = 'EIGHT NINE TEN JACK QUEEN KING ACE'  # only needed for Python 2.x
    _settings_ = NoAlias

    EIGHT    = 8
    NINE     = 9
    TEN      = 10
    JACK     = 10
    QUEEN    = 10
    KING     = 10
    ACE      = 11
</code></pre>
<hr/>
<p><sup>1</sup> See <a href="https://stackoverflow.com/a/22594360/208880">this answer</a> for the standard <code>Enum</code> usage.</p>
<p><sup>2</sup> Disclosure:  I am the author of the <a href="https://docs.python.org/3/library/enum.html" rel="nofollow noreferrer">Python stdlib <code>Enum</code></a>, the <a href="https://pypi.python.org/pypi/enum34" rel="nofollow noreferrer"><code>enum34</code> backport</a>, and the <a href="https://pypi.python.org/pypi/aenum" rel="nofollow noreferrer">Advanced Enumeration (<code>aenum</code>)</a> library.</p>
</div>
<span class="comment-copy">It's because they all have the same value. That's not how enums are supposed to work.</span>
<span class="comment-copy">I'm not sure why this question has received a down-vote. The writing could be improved -- yes. However the question shows a not necessarily intuitive behavior of the Enum module.</span>
<span class="comment-copy">@Fartash you might want to double-check your spelling and rewrite the question title.</span>
<span class="comment-copy">@MichaelHoff:  Agreed.  The question itself is well worded, shows the code to reproduce the problem, and describes the desired outcome.  I wish all questions were this good!</span>
<span class="comment-copy">Any reason you need Enum?</span>
<span class="comment-copy">The line "The members do exist" could be worded more clearly, maybe "The different names exist, but they all map to the same member" ?</span>
<span class="comment-copy">Fair point. I was not too sure about the correct terminology. As <code>len(Token.__members__) == 3</code> one could understand that there are three "members". Answer updated.</span>
<span class="comment-copy">Hah, I just had to make the same change to my answer! :/</span>
<span class="comment-copy">Is there a way to achieve the <code>NoAlias</code> behavior for the stdlib?</span>
<span class="comment-copy">@MichaelHoff: Not easily, no.  It falls into the category of "you can if you really want to, but nobody is going to enjoy reading that code!"  ;)</span>
<span class="comment-copy">How dislikable is <code>def __init__(self, *args): self._value_ = (self.name,) + args</code>? ;)</span>
<span class="comment-copy">@MichaelHoff: That will not work with mixin types, such as <code>int</code>, and would also make by-value lookups fail (instead of <code>CardNumber(8)</code> it would be <code>CardNumber(('EIGHT', 8))</code>.</span>
<span class="comment-copy">Surprisingly it does work* with <code>IntEnum</code> but yes, the lookup via constructor will fail. (*at least the use cases I tested have been just fine)</span>
