<div class="post-text" itemprop="text">
<p>I'm not sure if my title is exactly what I'm trying to do but in essence I'm getting the average of a list of lists and I want it to add not within the lists but across them:</p>
<pre><code>listoflists = [[1,2,3], [1,0,4], [0,5,1]]
#want [1, 3.5, 2.67]
final = []
for i in range(len(listoflists)):
    count = 0
    val = 0
    for j in range(len(listoflists[i])):
        if listoflists[i][j] != 0:
            count += 1
            val += listoflists[i][j]
    final.append(float(val)/count)
print final #currently returns [2.0, 2.5, 3.0]
</code></pre>
<p>instead of adding 1, 2, 3, and getting the average 6/3=2, I want it to add 1, 1, 0 (first value in each list) and get 2/2=1 (if 0, don't count it)
How do I get the loop to do that instead?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can convert the list first, using zip</p>
<pre><code>zip(*listoflists)
&gt;&gt;&gt; [(1, 1, 0), (2, 0, 5), (3, 4, 1)]
</code></pre>
<p>Here's one way to do it:</p>
<pre><code>final = []
for l in zip(*listoflists):
    final.append(float(sum(l)) / len([x for x in l if x != 0]))
print final
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use NumPy.</p>
<pre><code>arr = np.array(listoflists)
sums = arr.sum(axis=0)
final = []    
for i in range(arr.shape[1]):
    final.append(sums[i]/np.count_nonzero(arr[:,i])
</code></pre>
<p>Or better yet to avoid the loop altogether.</p>
<pre><code>arr = np.array(listoflists)
sums = arr.sum(0)
non_zeros = (arr != 0).sum(0)
final = sums / zon_zeros
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Lets reform your code to be a bit more Python like. In Python we can iterate (go through the list) and get the objects back directly, we don't really need to play with the index.</p>
<pre><code>final = []
for i in listoflists:
    count = 0
    val = 0

    for j in i:
        if j != 0:
            count += 1
            val += j 
    final.append(float(val)/count)

print final
</code></pre>
<p>This code is the exact same as yours without the indexing, <code>j</code> is the actual sub items (the numbers) that we are getting. </p>
<hr/>
<p>To do what you want, Python has a handy <a href="https://docs.python.org/3.6/library/functions.html#zip" rel="nofollow noreferrer"><code>zip()</code></a> function which transposes sub lists. For example if we have the following lists <code>[1,2] , [3,4]</code> when we <code>zip([1,2],[3,4])</code> these lists, we get <code>[(1, 3), (2, 4)]</code></p>
<p>We can use this to do what you want by unpacking the list using the <code>*</code> symbol before the list of lists, and <code>zip()</code> supports this. Going back to our previous example we can make a list of list <code>x = [[1,2],[3,4]]</code> and pass x in with the <code>*</code> into zip to get what we want. <code>zip(*x)</code> we will get <code>[(1, 3), (2, 4)]</code>. Combining these together with what you have will give you your desired results.</p>
<pre><code>final = []
for i in zip(*listoflists):
    count = 0
    val = 0

    for j in i:
        if j != 0:
            count += 1
            val += j 
    final.append(float(val)/count)
</code></pre>
<hr/>
<p>We can improve this even more by using some more built in from such as <a href="https://docs.python.org/3.6/library/functions.html#sum" rel="nofollow noreferrer"><code>sum()</code></a> which will sum up all the items in the list if possible, and you already know <code>len()</code> which can be used with <a href="https://docs.python.org/3.6/library/functions.html#filter" rel="nofollow noreferrer"><code>filter()</code></a> to filter out the <code>0</code>. From the docs:</p>
<blockquote>
<p>(item for item in iterable if item) if function is None. </p>
</blockquote>
<p>So we are checking if the list contains item's that are of value, and <code>0</code> is fails when <code>if 0:</code> </p>
<pre><code>final = []
for i in zip(*listoflists):
    if i: 
        final.append(float(sum(i))/len(filter(None, i)))
print final
</code></pre>
<hr/>
<p>We can go one step further and compression the function, by using one of the neatest thing Python has to offer, <a href="https://docs.python.org/3.6/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer"><code>list comprehensions</code></a>:</p>
<pre><code>print [float(sum(i))/len(filter(None,i)) for i in zip(*listoflists)]
</code></pre>
<p>Note some of these answers may not be as optimal as others, but my answer is focused on different ways you can do it with only built-ins. </p>
</div>
<div class="post-text" itemprop="text">
<p>This will work for you:</p>
<pre><code>listoflists = [[1,2,3], [1,0,4], [0,5,1]]
second_list = zip(*listoflists)
new_list = map(list, second_list)

final_list = []
without_zero = []
for i in new_list:
    for b in i:
       if b != 0:
          without_zero.append(b)
    final_list.append(without_zero)
    without_zero = []

average = [sum(i)/float(len(i)) for i in final_list]

print average
</code></pre>
<p>Edit:
   another way just using list comprehension and zip:</p>
<pre><code>listoflists = [[1,2,3], [1,0,4], [0,5,1]]
new_list = zip(*listoflists)
result = [sum([i for i in b if i != 0])/float(len([i for i in b if i != 0])) for b in new_list]
print result
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre class="lang-py prettyprint-override"><code>from __future__ import division
map(lambda *column: sum(column)/sum(x&gt;0 for x in column), *listoflists)
</code></pre>
<p>Another possibility (Python 3 only):</p>
<pre><code>from statistics import mean
[mean(filter(None, column)) for column in zip(*listoflists)]
</code></pre>
<p>Alternative numpy implementation (works for Python 2 as well):</p>
<pre><code>import numpy as np
a = np.array(listoflists)
np.average(a, axis=0, weights=a&gt;0)
</code></pre>
</div>
<span class="comment-copy">Use <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer">zip()</a> to transpose the list of lists then use <a href="https://docs.python.org/3/library/functions.html#sum" rel="nofollow noreferrer">sum()</a> to get the sum of the transposed lists.</span>
