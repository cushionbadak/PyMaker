<div class="post-text" itemprop="text">
<p>Using the deprecated module <code>imp</code>, I can write a custom import hook that modifies the source code of a module on the fly, prior to importation/execution by Python. Given the source code as a string named <code>source</code> below, the essential code needed to create a module is the following:</p>
<pre><code>module = imp.new_module(name)
sys.modules[name] = module
exec(source, module.__dict__)
</code></pre>
<p>Since <code>imp</code> is deprecated, I would like to do something similar with <code>importlib</code>. [EDIT: there are other <code>imp</code> methods that need to be replaced to build a custom import hook - so the answer I am looking for is not simply to replace the above code.] </p>
<p>However, I have not been able to figure out how to do this. The <a href="https://docs.python.org/3/library/importlib.html" rel="noreferrer">importlib documentation</a> has a <a href="https://docs.python.org/3/library/importlib.html#importlib.util.module_from_spec" rel="noreferrer">function to create modules from "specs"</a> which, as far as I can tell, are objects that include their own loaders with no obvious way to redefine them so as to be able to create a module from a string. </p>
<p>I have created a <a href="https://github.com/aroberge/splore/tree/master/import_hook" rel="noreferrer">minimal example</a> to demonstrates this; see the readme file for details.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>find_module</code> and <code>load_module</code> are both deprecated. You'll need to switch to <code>find_spec</code> and (<code>create_module</code> and <code>exec_module</code>) module respectively. See the <code>importlib</code> <a href="https://docs.python.org/3/library/importlib.html" rel="noreferrer">documentation</a> for details.</p>
<p>You will also need to examine if you want to use a <code>MetaPathFinder</code> or a <code>PathEntryFinder</code> as the system to invoke them is different. That is, the meta path finder goes first and can override builtin modules, whereas the path entry finder works specifically for modules found on <code>sys.path</code>.</p>
<p>The following is a very basic importer that attempts to replace the entire import machinery for. It shows how to use the functions (<code>find_spec</code>, <code>create_module</code>, and <code>exec_module</code>).</p>
<pre><code>import sys
import os.path

from importlib.abc import Loader, MetaPathFinder
from importlib.util import spec_from_file_location

class MyMetaFinder(MetaPathFinder):
    def find_spec(self, fullname, path, target=None):
        if path is None or path == "":
            path = [os.getcwd()] # top level import -- 
        if "." in fullname:
            *parents, name = fullname.split(".")
        else:
            name = fullname
        for entry in path:
            if os.path.isdir(os.path.join(entry, name)):
                # this module has child modules
                filename = os.path.join(entry, name, "__init__.py")
                submodule_locations = [os.path.join(entry, name)]
            else:
                filename = os.path.join(entry, name + ".py")
                submodule_locations = None
            if not os.path.exists(filename):
                continue

            return spec_from_file_location(fullname, filename, loader=MyLoader(filename),
                submodule_search_locations=submodule_locations)

        return None # we don't know how to import this

class MyLoader(Loader):
    def __init__(self, filename):
        self.filename = filename

    def create_module(self, spec):
        return None # use default module creation semantics

    def exec_module(self, module):
        with open(self.filename) as f:
            data = f.read()

        # manipulate data some way...

        exec(data, vars(module))

def install():
    """Inserts the finder into the import machinery"""
    sys.meta_path.insert(0, MyMetaFinder())
</code></pre>
<p>Next is a slightly more delicate version that attempts to reuse more of the import machinery. As such, you only need to define how to get the source of the module.</p>
<pre><code>import sys
from os.path import isdir
from importlib import invalidate_caches
from importlib.abc import SourceLoader
from importlib.machinery import FileFinder


class MyLoader(SourceLoader):
    def __init__(self, fullname, path):
        self.fullname = fullname
        self.path = path

    def get_filename(self, fullname):
        return self.path

    def get_data(self, filename):
        """exec_module is already defined for us, we just have to provide a way
        of getting the source code of the module"""
        with open(filename) as f:
            data = f.read()
        # do something with data ...
        # eg. ignore it... return "print('hello world')"
        return data


loader_details = MyLoader, [".py"]

def install():
    # insert the path hook ahead of other path hooks
    sys.path_hooks.insert(0, FileFinder.path_hook(loader_details))
    # clear any loaders that might already be in use by the FileFinder
    sys.path_importer_cache.clear()
    invalidate_caches()
</code></pre>
</div>
<span class="comment-copy">If you take a look at the <code>imp.new_module</code> documentation, you'll find <code>Deprecated since version 3.4: Use types.ModuleType instead.</code> Does that not solve your problem?</span>
<span class="comment-copy">I saw that imp.modules had to be replaced this way but the documentation indicates to use module_from_spec (from importlib). I am using 3 methods from imp to do a custom hook importer and need to find the equivalent for importlib.</span>
<span class="comment-copy">Excellent, thanks! Could you extend your classes for handling namespace packages too?</span>
<span class="comment-copy">Handle them how? The second example already works with namespaces.</span>
<span class="comment-copy">Yes but not the first one. That's the one that I am interested in.</span>
<span class="comment-copy">I don't know what you're trying to achieve. Namespace packages to not have source code to modify (they lack <code>__init__.py</code> files). So there would be nothing to modify. I think you need to ask a separate question and clearly set out your desired behaviour and what you have already tried.</span>
<span class="comment-copy">Sorry I should have been more specific. In the first example, you cannot modify a submodule of a namespace package, you need a regular package (that is an <code>__init__.py</code> file). For instance <code>import namespace.submodule</code> won't use the <code>MyLoader</code> class since the <code>MyMetaFinder</code> class will return <code>None</code> as the <code>if not os.path.exists(filename):</code> test will always succeed.</span>
