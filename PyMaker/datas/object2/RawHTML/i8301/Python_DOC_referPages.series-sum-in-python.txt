<div class="post-text" itemprop="text">
<p>Is there is a built-in function in python, numpy or one of its libraries can get sum of series like this one:</p>
<pre><code>list1 = [2,3,4]
list2 = [3,3,3]
</code></pre>
<p><img alt="enter image description here" src="https://i.stack.imgur.com/o5l57.png"/></p>
<p>where x and y are lists and L is the length of x or y.</p>
<p>Lastly if there is no built-in function do that, I tried another code like :</p>
<pre><code>Total = sum ((i for i in list1) * (j for j in list2))
</code></pre>
<p>Sure, it doesn't work but I need something near that or near this one:</p>
<pre><code>Total = sum (i * j for i in list1 and j in list2 )
</code></pre>
<p>Note : I can build my own function to do that but I am looking for a simple, fast or built-in one, so please don't give me your own function.</p>
<p>Edit : I want general form to do that so I can use this form when there are as an example <strong><code>Log(n)</code> or another kind of math</strong> in the series.</p>
<p><a href="https://i.stack.imgur.com/0iymc.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/0iymc.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>for build-in you can use <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer">zip</a> to group together elements in the same index position</p>
<pre><code>list1 = [2,3,4]
list2 = [3,3,3]
result = sum( x*y for x,y in zip(list1, list2) )
</code></pre>
<p><strong>About the edit</strong></p>
<p>A buil-in version would be</p>
<pre><code>from math import log
result = sum( log(i)*y for i,y in enumerate(list1,1) )
</code></pre>
<p>a more generalized version would be</p>
<p><a href="https://i.stack.imgur.com/YHR4P.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/YHR4P.png"/></a></p>
<pre><code>import operator
def dotproduct(vec1, vec2, sum=sum, map=map, mul=operator.mul):
    return sum(map(mul, vec1, vec2))    
</code></pre>
<p>where you can provide whatever function you like for any of its part, then the first one is</p>
<pre><code>result = dotproduct(list1,list2)
</code></pre>
<p>and the second is could be</p>
<pre><code>result = dotproduct(range(1,len(list1)+1),list1, mul=lambda i,x:log(i)*x )
#                        ^ the i                    ^ how to operate
</code></pre>
<p>or </p>
<pre><code>result = dotproduct(map(log,range(1,len(list1)+1) ), list1 )
#                           ^ the log i
</code></pre>
<p>the point being that you calculate the second vector accordingly </p>
<p>with numpy is more easy</p>
<pre><code>import numpy as np
logi = np.log(np.arange(1,len(list1)+1)
result = np.dot(logi,list1)
</code></pre>
<p>which again boils down to calculate the parts accordingly </p>
<hr/>
<p>you can also make such that instead of receiving 2 vectors/lists it only work with one and receive a function that work in the element and its index </p>
<p><a href="https://i.stack.imgur.com/msxqf.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/msxqf.png"/></a></p>
<pre><code>def sum_serie(vect, fun = lambda i,x:x, i_star=0): #with that fun, is like the regular sum
    return sum( fun(i,x) for i,x in enumerate(vect, i_star) )
</code></pre>
<p>and use it as</p>
<pre><code>result = sum_serie( list1, lambda i,x:log(i)*x, 1)
</code></pre>
<hr/>
<p>from the comments, if I get it right, then something like this</p>
<pre><code>from itertools import islice
def sum_serie(vect, *slice_arg, fun = lambda x:x): #with that fun, is like the regular sum
    """sum_serie(vect, [start,]stop[,step], fun = lambda x:x)"""
    if not slice_arg:
        slice_arg = (0,None,None)
    return sum( fun(x) for x in islice(vect, *slice_arg) )
</code></pre>
<p>or with enumerate as before</p>
<pre><code>from itertools import islice
def sum_serie_i(vect, *slice_arg, fun = lambda i,x:x): #with that fun, is like the regular sum
    if not slice_arg:
        slice_arg = (0,None,None)
    return sum( fun(i,x) for i,x in islice(enumerate(vect), *slice_arg) )
</code></pre>
<p>and use, for example as </p>
<pre><code>sum_serie( x, 0, 100, 2, fun=lambda xi: c*xi) #for arbitrary constant c
sum_serie_i( x, 0, 100, 2, fun=lambda i,xi: log(i)*xi)
</code></pre>
<p>Note: this way it accept the serie/iterable/whatever and at most 3 positional argument with the same meaning as those from range</p>
<p>Note 2: that is for PY3 which make fun a key-word only argument, in python 2 the same effect is accomplished with</p>
<pre><code>def sum_serie_i(vect, *slice_arg, **kargv): 
    fun = kargv.get('fun', lambda i,x:x) #with that fun, is like the regular sum
    if not slice_arg:
        slice_arg = (0,None,None)
    return sum( fun(i,x) for i,x in islice(enumerate(vect), *slice_arg) )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>That's literally just a dot product:</p>
<pre><code>result = numpy.dot(list1, list2)
</code></pre>
<p>Note that if you're using NumPy, you shouldn't be using lists to represent your matrices and vectors. NumPy arrays are much more efficient and convenient for that.</p>
</div>
<div class="post-text" itemprop="text">
<p>The mathematical operators with numpy arrays do element-wise operations, so you can use:</p>
<pre><code>import numpy as np
np.sum(np.multiply(list1, list2))
# or np.sum(list1 * list2)  if any of list1/list2 is a numpy array
</code></pre>
<p>or in the second case:</p>
<pre><code>logi = np.log(np.arange(1, len(x)))  # or np.log10, not sure which one you mean
np.sum(np.multiply(logi, x[1:]))
</code></pre>
<p>as already mentioned <code>np.sum(np.multiply())</code> is just a dotproduct, so you could also use <code>@</code> (at least with python 3.5+, otherwise use <code>np.dot</code>):</p>
<pre><code>np.asarray(list1) @ list2  # if list1/list2 are numpy arrays you don't need the np.asarray
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>These all do the same thing</p>
<p><strong><em><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.einsum.html" rel="nofollow noreferrer"><code>np.einsum</code></a></em></strong> </p>
<pre><code>np.einsum('i,i', list1, list2)
</code></pre>
<p><strong><em><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.inner.html" rel="nofollow noreferrer"><code>np.inner</code></a></em></strong> </p>
<pre><code>np.inner(list1, list2)
</code></pre>
<p><strong><em><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.dot.html" rel="nofollow noreferrer"><code>np.dot</code></a></em></strong> </p>
<pre><code>np.dot(list1, list2)
</code></pre>
<p>All yield <code>27</code></p>
<p>For bigger arrays, <code>np.einsum</code> starts to see a performance boost</p>
<p><a href="https://i.stack.imgur.com/BreOH.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/BreOH.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>*</code> operator and sum it along <code>0</code>th axis.</p>
<pre><code>In [48]: a
Out[48]: array([0, 1, 2, 3, 4])

In [49]: b
Out[49]: array([5, 6, 7, 8, 9])

In [50]: a*b
Out[50]: array([ 0,  6, 14, 24, 36])

In [51]: np.sum(a*b, axis=0)
Out[51]: 80
</code></pre>
<hr/>
<p>But, you should really be using the much cooler and ultra-fast <code>np.inner()</code></p>
<pre><code># `a, b` can also be python lists
In [65]: np.inner(a, b)
Out[65]: 80
</code></pre>
</div>
<span class="comment-copy">@cropperfield: Case one  has a different answer than case 2 . And so on if i changed the elements inside the series , increase number of them or change the series condition ,i have to adapt with it and make a private solution (function) for it. For more clarify :  There is no formula i can give it the elements of series and condition of it as parameters , like : sum_series(x[n],log(n),n,0,100,2) where x is a series or whatever , and n is the iterating number and 0 is the initial value of n  ,100 is the final value of n and 2 the increment amount of n every time .</span>
<span class="comment-copy">check update, I added that range feature</span>
<span class="comment-copy">but what if they are not lists inside the series .Let the series contains log(n)  ,can we apply your solution or any another one to do it . Is there is  a general form to do series sum ?!</span>
<span class="comment-copy">@mohammedawni: Unclear what you're asking. What do you mean by "contains log(n)", and how are you imagining this series would be represented? In general, you can perform sums with <code>numpy.sum</code> for arrays or the built-in <code>sum</code> for iterables, as long as you can represent your series as an array or iterable.</span>
<span class="comment-copy">I've edited the post to be more clearer .</span>
