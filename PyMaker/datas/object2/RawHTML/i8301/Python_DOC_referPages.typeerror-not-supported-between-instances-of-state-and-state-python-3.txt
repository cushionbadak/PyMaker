<div class="post-text" itemprop="text">
<p>I am trying to utilize a PriorityQueue from the queue class. However, i'm having issues putting custom objects into my PQ. I have implemented the <code>__cmp__</code> function below:</p>
<pre><code>def __cmp__(self, other):
    return (self.priority &gt; other.priority) - (self.priority &lt; other.priority)
</code></pre>
<p>I want the PriorityQueue to be sorted by the priority field, as assigned in my init function:</p>
<pre><code>def __init__(self, board, priority=0):
    self.priority = priority
    # Other logic
</code></pre>
<p>However, when I run the code to insert a State object into the PQ, I get this error: <code>TypeError: '&lt;' not supported between instances of 'State' and 'State'</code></p>
<p>Here is the code that runs the PQ.</p>
<pre><code>if op.precond(S):
            new_state = op.state_transf(S)
            if not (OPEN.queue.__contains__(new_state)) and not (new_state in CLOSED):
                GVALUES[Problem.hash(new_state)] = get_distance_value(op, new_state)
                HEUR_VALUES[Problem.hash(new_state)] = get_AStar_value(new_state)
                print("NEW STATE: " + str(new_state))
                OPEN.put(new_state)
                print("OPEN: " + str(OPEN.queue))
</code></pre>
<p>Where OPEN is the priorityQueue.</p>
<p>Any help would be greatly appreciated... as it should be pretty straightforward to insert a value into a PQ. </p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3 you need to define <code>__lt__</code> and <code>__eq__</code> instead of <code>__cmp__</code>.</p>
<p>See <a href="https://docs.python.org/3.1/library/stdtypes.html#comparisons" rel="noreferrer">https://docs.python.org/3.1/library/stdtypes.html#comparisons</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of <code>__cmp__</code> you need to implement one of the <code>__lt__</code>, <code>__le__</code>, <code>__gt__</code>, or <code>__ge__</code> methods and use the  <a href="https://docs.python.org/3/library/functools.html#functools.total_ordering" rel="nofollow noreferrer"><code>functools.total_ordering</code></a> decorator</p>
<blockquote>
<p><code>functools.total_ordering(cls)</code> Given a class defining one or more rich
  comparison ordering methods, this class decorator supplies the rest.
  This simplifies the effort involved in specifying all of the possible
  rich comparison operations:</p>
<p>The class must define one of <code>__lt__()</code>, <code>__le__()</code>, <code>__gt__()</code>, or
  <code>__ge__()</code>. In addition, the class should supply an <code>__eq__()</code> method.</p>
</blockquote>
<p>However, a better solution to that would be putting a tuples <code>(priority, state_object)</code> into the queue, as they suggest in docs for <a href="https://docs.python.org/3/library/queue.html#queue.PriorityQueue" rel="nofollow noreferrer"><code>PriorityQueue</code></a></p>
<blockquote>
<p>The lowest valued entries are retrieved first (the lowest valued entry
  is the one returned by <code>sorted(list(entries))[0])</code>. A typical pattern
  for entries is a tuple in the form: <code>(priority_number, data)</code>.</p>
</blockquote>
<p>The pitfall of the first approach is that you can modify priority of items that are already in queue and possibly observe unexpected behavior. </p>
<p>In the second approach this is not an issue, since tuples are immutable.</p>
</div>
<span class="comment-copy"><code>__cmp__</code> isn't a special method name in Python 3. Try defining <code>__lt__</code> instead and see if that works.</span>
