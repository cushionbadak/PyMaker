<div class="post-text" itemprop="text">
<p>I am currently working on a project, my task here right now is I need to specify whether the device is 2G or not based on the Bands given in the Bands column. For example,</p>
<pre><code>Device ID |Bands|2G(New added column)
123 |GSM 1800, GSM 700 |                                            
124 | GSM 1800, GSM 700, GSM 1, LTE TDD |                            
125 | TD-SCDMA,1 SIM |                                              
126 |GSM850 (GSM800),WCDMA FDD Band I,WCDMA FDD Band VIII,2 SIM |
</code></pre>
<p>So if the column "Bands" only contains the word "GSM" then it is 2G, else, N. </p>
<p>I have tried using the re module but I am stuck at some point.</p>
<pre><code>import re
import csv
...
two_G_only = []
...
with open('filepath.txt', "rU") as f:
    reader = csv.DictReader(f, delimiter = "|")
    for row in reader:
        ...
        ...
        if 'GSM' in row['Bands']:
        gsm_only = " ".join(re.findall("[a-zA-Z]+", row['Bands']))
        #Im stuck at here because I don't know how to test whether there is only GSM or else          
    else:
        two_G_only.append('N')
        ...
        ...
</code></pre>
<p>What do I need for the result</p>
<pre><code>Device ID | Bands | 2G
123 | GSM 1800, GSM 700 | Y
124 |GSM 1800, GSM 700, GSM 1, LTE TDD | N
125 |TD-SCDMA,1 SIM | N
126 |GSM850 (GSM800),WCDMA FDD Band I,WCDMA FDD Band VIII,2 SIM|N
</code></pre>
<p>Thank you in advance, do comment if my question is not understandable. I already searched some solutions given in the site yet I am sure the question asked is not the same problematic/concept.</p>
</div>
<div class="post-text" itemprop="text">
<p>You show data separated into columns with tabs or spaces, but your code indicates that you are using a vertical bar (<code>|</code>) as delimiter. I'm not sure which is right, but that's your problem.</p>
<p>Your condition, as I understand it, is to look at the various subfields in the second column, delimited with commas, and return one value (true) if each and every one of the subfields contains the text string 'GSM' anywhere in the subfield, but to return a different value (false) if at least one of the subfields DOES NOT contain that string. Right?</p>
<p>Let us then presume you have your csv reader in <code>reader</code>, as shown in your example. The for-row-in loop is correct, because you want to do this computation separately for every row.</p>
<pre><code>for row in reader:
</code></pre>
<p>Within that loop, you need access to the <em>Bands</em> column:</p>
<pre><code>    bands = row['Bands']
</code></pre>
<p>In order to examine the subfields, let's use the basic <code>str.split</code> function, splitting the subfields by commas:</p>
<pre><code>    subfields = bands.split(',')
</code></pre>
<p>Now, let's convert that list of strings into a list of boolean values, and use Python's built-in <a href="https://docs.python.org/3/library/functions.html?highlight=any#any" rel="nofollow noreferrer"><code>any</code></a> function to evaluate the entire list. We will do this with a <em>list comprehension</em>:</p>
<pre><code>    if any( [ ('GSM' not in band) for band in subfields ] ):
        _2g_or_not_2g = 'N'

    else:
        _2g_or_not_2g = 'Y'
</code></pre>
<p>This if-statement will do roughly what it says: it will match if any one of the bands fails to contain 'GSM'. </p>
<p>There are some other ways you could write this code. For example, you could make the negative test into a positive test by using the Python <a href="https://docs.python.org/3/library/functions.html?highlight=all#all" rel="nofollow noreferrer"><code>all</code></a> function. This would reverse the "sense" of the if statement, and switch the arms:</p>
<pre><code>    if all( [ 'GSM' in band for band in subfields ] ):
        _2g_or_not_2g = 'Y'
    else:
        _2g_or_not_2g = 'N'
</code></pre>
<p>Also, you could use the <code>... if condition</code> modifier on the list comprehension to filter the list down to a smaller list. </p>
<p>Finally, of course, you can start merging the expressions into one another - replace <code>subfields</code> with the actual split expression, etc. </p>
</div>
<div class="post-text" itemprop="text">
<p>One thing to notice that on every row, the bands are each separated by a comma.<br/>
You can take advantage of this.<br/>
The <code>split()</code> function can give you a list of strings for that row, each containing the name of a single band.  </p>
<p>Now the problem is much simpler: If any individual band is missing the substring 'GSM', then that row is disqualified: Return 'N'.<br/>
If none of the bands in that row are disqualified, (ie all contain 'GSM in the name), then return 'Y' for the row.  </p>
<p>You can use the <code>find()</code> function to see if a string contains a given substring.<br/>
For example <code>'LTE TDD'.find('GSM')</code> returns the value <code>-1</code>, because it does not.</p>
<p>Notice that you do not even need to remove the device id - it can be part of the item that includes the first band.  Keeping it simple: all you want to know is if, on any given row, all blocks of text (segregated by commas) contain the substring 'GSM' ..or not.</p>
<pre><code>def is_GSM(bands):
    for band in bands:
        if (band.find('GSM') = -1:
            return('N')
    return('Y')

for row in reader:
    bands = row.split(',')            
    two_G_only.append(is_GSM(bands))
</code></pre>
<p>```</p>
<pre><code>def is_GSM(bands):
    for band in bands:
        if (band.find('GSM') = -1:
            # "GSM" wasn't in the band name
            return('N')

    # we looked at all the bands, and did not find a disqualifier.. 
    # This row must be "GSM' only 2G bands.
    return('Y')

for row in reader:
    # not needed: first strip off the device_id in this row's string.
    # row = row[3:]

    bands = row.split(',') 
    # ie: bands = ['124    GSM 1800', ' GSM 700', ' GSM 1', ' LTE TDD'] 

    # send this list to is_GSM(), and append the result                   
    two_G_only.append(all_are_GSM(bands))
</code></pre>
<p>```</p>
</div>
<span class="comment-copy">Actually it is my fault because I wanted to make it easier to read so I change the original data from pipe delimited to tab or space delimited.Question edited.</span>
