<div class="post-text" itemprop="text">
<p>I have a string that looks something like this:</p>
<p><code>"(case when Campaign='Back to School' and VariableName='Total_FB_Spend' then VariableValue else 0 end) AS Back to School_Total_FB_Spend,(case when Campaign='Back to School' and VariableName='Total_FB_Imp' then VariableValue else 0 end) AS Back to School_Total_FB_Imp"</code></p>
<p>I would like to use Python regex to remove spaces in the column names after 'end) AS ' character. The result should become something like this</p>
<p><code>"(case when Campaign='Back to School' and VariableName='Total_FB_Spend' then VariableValue else 0 end) AS Back_to_School_Total_FB_Spend,(case when Campaign='Back to School' and VariableName='Total_FB_Imp' then VariableValue else 0 end) AS Back_to_School_Total_FB_Imp"</code></p>
<p>I am able to match those parts that I am interested using regex in Python<a href="http://pythex.org/?regex=(end%5C)%20as%20)(.*%3F(%2C%7C%24))&amp;test_string=(case%20when%20Campaign%3D%27Back%20to%20School%27%20and%20VariableName%3D%27Total_FB_Spend%27%20then%20VariableValue%20else%200%20end)%20as%20Back%20to%20School_Total_FB_Spend%2C(case%20when%20Campaign%3D%27Back%20to%20School%27%20and%20VariableName%3D%27Total_FB_Imp%27%20then%20VariableValue%20else%200%20end)%20as%20Back%20to%20School_Total_FB_Imp&amp;ignorecase=0&amp;multiline=0&amp;dotall=1&amp;verbose=0" rel="nofollow noreferrer"> [example here]</a> But I would like to know how to elegantly (e.g., one liner or in a Pythonic way) substitute space characters in groups that matches.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need a <code>re.sub</code> with a lambda expression as the replacement argument:</p>
<pre><code>import re
s = "(case when Campaign='Back to School' and VariableName='Total_FB_Spend' then VariableValue else 0 end) AS Back to School_Total_FB_Spend,(case when Campaign='Back to School' and VariableName='Total_FB_Imp' then VariableValue else 0 end) AS Back to School_Total_FB_Imp"
pat = r'(end\) as )([^,]*)'
print(re.sub(pat, lambda m: "{}{}".format(m.group(1), m.group(2).replace(" ", "_")), s))
</code></pre>
<p>See the <a href="http://ideone.com/MAZwn4" rel="nofollow noreferrer">Python demo</a></p>
<p>Note that I replaced your <code>(.*?(,|$))</code> with a more efficient <code>([^,]*)</code>, any zero or more chars other than <code>,</code>. Now, the whole regex matches:</p>
<ul>
<li><code>(end\) as )</code> - Group 1: <code>end) as </code></li>
<li><code>([^,]*)</code> - Group 2: any zero or more chars other than <code>,</code></li>
</ul>
<p>Then, with <code>lambda m: "{}{}".format(m.group(1), m.group(2).replace(" ", "_"))</code>, the contents of the first  capturing group is copied back to the result unchanged, and the second group contents are modified with <code>.replace(" ", "_")</code>. Certainly, you may run another regex on it if there may be any whitespace, <code>re.sub(r'\s+', '_', m.group(2))</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another solution inspired by @Wiktor.</p>
<pre><code>import re
s = "(case when Campaign='Back to School' and VariableName='Total_FB_Spend' then VariableValue else 0 end) AS Back to School_Total_FB_Spend,(case when Campaign='Back to School' and VariableName='Total_FB_Imp' then VariableValue else 0 end) AS Back to School_Total_FB_Imp"
pat = r'(?&lt;=end\) as )[\w\s]*(?=,)'
print(re.sub(pat, lambda m: m.group(0).replace(" ", "_"), s, flags=re.IGNORECASE))
</code></pre>
<p>Here we use the lookahead and lookbehind feature of regex to only match the substring we want to alter. The regex will match any sequence of <strong>word characters</strong> <code>[a-zA-Z0-9_]</code> and <strong>spaces</strong> preceded by <code>end ) as</code>, and followed by <code>,</code>. The main difference is that the match will only contain a single group. </p>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="https://docs.python.org/3/library/stdtypes.html?highlight=replace#bytes.replace" rel="nofollow noreferrer"><code>bytes.replace()</code></a> function.</p>
<pre><code>'Back to School'.replace(' ', '_')
</code></pre>
</div>
<span class="comment-copy">Please check my answer below. Note that while a lookbehind-based regex will be more optimal in this case, I decided to introduce as few changes to the original pattern itself as possible to show how <i>multiple</i> groups can be handled in a single lambda replacement.</span>
<span class="comment-copy">Stribizew Thank you so much for the detailed explanation of how pieces work together in your suggested solution!! It works like a charm. I ended up using <code>re.sub(r'\W+', '_', m.group(2))</code> because it's easier. I'm not very familiar with <code>lambda</code> yet, so I wonder how it is returning groups that matches the regex pattern (without us writing anything explicit like <code>re.search(pat, s)</code> within the <code>lambda</code> statement). If you don't mind explaining that further or direct me to a good resource, which explains that, I'd greatly appreciate it! :)</span>
<span class="comment-copy">Thank you so much for the detailed explanation! Your answers are very helpful and clear because of the patient/detail explanation. Today I learned that <code>re.sub</code> passes the matched objects into <code>lambda</code> (or <code>lambda</code> captures whatever matches in <code>re.sub</code>). Very powerful!</span>
<span class="comment-copy">Sorry for formatting. Reposting the comment: Actually, the <code>m</code> in the lambda stands for a match data object. When you use <code>re.sub</code>, the regex engine searches for all non-overlapping occurrences of the pattern, and when a match is found, all the capturing group form <code>.group()</code>s. So, <code>(a)|(b)</code> contains 2 capturing groups, and when used on an <code>abc</code> string, first, <code>a</code> is found (with <code>a</code> in <code>m.group(1)</code> and null/empty (depending on Python version) in <code>m.group(2)</code>). You may access any capturing group or the whole match (<code>m.group()</code>), and do whatever you please (cast to int, increment, etc.)</span>
<span class="comment-copy">Just note that a lookbehind is not that flexible as a capturing group as a lookbehind pattern should be of fixed length. You cannot use <code>\s*</code> nor <code>\w+</code> there.</span>
<span class="comment-copy">Indeed, but as we are looking for a fixed suffix and postfix this will no be a problem in this scenario.</span>
<span class="comment-copy">@Jonas Thank you for the alternative suggestion. I learned a bit about lookahead/lookbehind pattern in regex for the first time here. When I tried the code you shared above though, I received <code>IndexError: no such group</code>.</span>
<span class="comment-copy">My bad, I did some cleaning without testing. <code>group(0)</code> contains the full match, and consecutive indexes will contain the subgroups if any such exists. When I removed the parentheses around <code>[\w\s]</code> i also removed the subgroup.</span>
<span class="comment-copy">@Jonas, Thank you for the update! Now it works!! :)</span>
