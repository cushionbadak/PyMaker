<div class="post-text" itemprop="text">
<p>I recently came across a syntax I never seen before when I learned python nor in most tutorials, the <code>..</code> notation, it looks something like this:</p>
<pre><code>f = 1..__truediv__ # or 1..__div__ for python 2

print(f(8)) # prints 0.125 
</code></pre>
<p>I figured it was exactly the same as (except it's longer, of course):</p>
<pre><code>f = lambda x: (1).__truediv__(x)
print(f(8)) # prints 0.125 or 1//8
</code></pre>
<p>But my questions are: </p>
<ul>
<li>How can it do that?  </li>
<li>What does it actually mean with the two dots? </li>
<li>How can you use it in a more complex statement (if possible)? </li>
</ul>
<p>This will probably save me many lines of code in the future...:)</p>
</div>
<div class="post-text" itemprop="text">
<p>What you have is a <code>float</code> literal without the trailing zero, which you then access the <code>__truediv__</code> method of.  It's not an operator in itself; the first dot is part of the float value, and the second is the dot operator to access the objects properties and methods.</p>
<p>You can reach the same point by doing the following.</p>
<pre><code>&gt;&gt;&gt; f = 1.
&gt;&gt;&gt; f
1.0
&gt;&gt;&gt; f.__floordiv__
&lt;method-wrapper '__floordiv__' of float object at 0x7f9fb4dc1a20&gt;
</code></pre>
<p>Another example</p>
<pre><code>&gt;&gt;&gt; 1..__add__(2.)
3.0
</code></pre>
<p>Here we add 1.0 to 2.0, which obviously yields 3.0.</p>
</div>
<div class="post-text" itemprop="text">
<p>The question is already sufficiently answered (i.e. <a href="https://stackoverflow.com/a/43487884/5393381">@Paul Rooney</a>s answer) but it's also possible to verify the correctness of these answers.</p>
<p>Let me recap the existing answers: The <code>..</code> is not a single syntax element!</p>
<p>You can check how the source code is <a href="https://docs.python.org/library/tokenize.html" rel="noreferrer">"tokenized"</a>. These tokens represent how the code is interpreted:</p>
<pre><code>&gt;&gt;&gt; from tokenize import tokenize
&gt;&gt;&gt; from io import BytesIO

&gt;&gt;&gt; s = "1..__truediv__"
&gt;&gt;&gt; list(tokenize(BytesIO(s.encode('utf-8')).readline))
[...
 TokenInfo(type=2 (NUMBER), string='1.', start=(1, 0), end=(1, 2), line='1..__truediv__'),
 TokenInfo(type=53 (OP), string='.', start=(1, 2), end=(1, 3), line='1..__truediv__'),
 TokenInfo(type=1 (NAME), string='__truediv__', start=(1, 3), end=(1, 14), line='1..__truediv__'),
 ...]
</code></pre>
<p>So the string <code>1.</code> is interpreted as number, the second <code>.</code> is an OP (an operator, in this case the "get attribute" operator) and the <code>__truediv__</code> is the method name. So this is just accessing the <code>__truediv__</code> method of the float <code>1.0</code>.</p>
<p>Another way of viewing the generated bytecode is to<a href="https://docs.python.org/3/library/dis.html" rel="noreferrer"> <code>dis</code>assemble</a> it. This actually shows the instructions that are performed when some code is executed:</p>
<pre><code>&gt;&gt;&gt; import dis

&gt;&gt;&gt; def f():
...     return 1..__truediv__

&gt;&gt;&gt; dis.dis(f)
  4           0 LOAD_CONST               1 (1.0)
              3 LOAD_ATTR                0 (__truediv__)
              6 RETURN_VALUE
</code></pre>
<p>Which basically says the same. It loads the attribute <code>__truediv__</code> of the constant <code>1.0</code>.</p>
<hr/>
<p>Regarding your question</p>
<blockquote>
<p>And how can you use it in a more complex statement (if possible)?</p>
</blockquote>
<p>Even though it's possible you should never write code like that, simply because it's unclear what the code is doing. So please don't use it in more complex statements. I would even go so far that you shouldn't use it in so "simple" statements, at least you should use parenthesis to separate the instructions:</p>
<pre><code>f = (1.).__truediv__
</code></pre>
<p>this would be definetly more readable - but something along the lines of:</p>
<pre><code>from functools import partial
from operator import truediv
f = partial(truediv, 1.0)
</code></pre>
<p>would be even better!</p>
<p>The approach using <code>partial</code> also preserves <a href="https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types" rel="noreferrer">python's data model</a> (the <code>1..__truediv__</code> approach does not!) which can be demonstrated by this little snippet:</p>
<pre><code>&gt;&gt;&gt; f1 = 1..__truediv__
&gt;&gt;&gt; f2 = partial(truediv, 1.)

&gt;&gt;&gt; f2(1+2j)  # reciprocal of complex number - works
(0.2-0.4j)
&gt;&gt;&gt; f2('a')   # reciprocal of string should raise an exception
TypeError: unsupported operand type(s) for /: 'float' and 'str'

&gt;&gt;&gt; f1(1+2j)  # reciprocal of complex number - works but gives an unexpected result
NotImplemented
&gt;&gt;&gt; f1('a')   # reciprocal of string should raise an exception but it doesn't
NotImplemented
</code></pre>
<p>This is because <code>1. / (1+2j)</code> is not evaluated by <code>float.__truediv__</code> but with <code>complex.__rtruediv__</code> - <code>operator.truediv</code> makes sure the reverse operation is called when the normal operation returns <code>NotImplemented</code> but you don't have these fallbacks when you operate on <code>__truediv__</code> directly. This loss of "expected behaviour" is the main reason why you (normally) shouldn't use magic methods directly.</p>
</div>
<div class="post-text" itemprop="text">
<p>Two dots together may be a little awkward at first:</p>
<pre><code>f = 1..__truediv__ # or 1..__div__ for python 2
</code></pre>
<p>But it is the same as writing:</p>
<pre><code>f = 1.0.__truediv__ # or 1.0.__div__ for python 2
</code></pre>
<p>Because <code>float</code> literals can be written in three forms:</p>
<pre><code>normal_float = 1.0
short_float = 1.  # == 1.0
prefixed_float = .1  # == 0.1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h2>What is <code>f = 1..__truediv__</code>?</h2>
</blockquote>
<p><code>f</code> is a bound special method on a float with a value of one. Specifically,</p>
<pre><code>1.0 / x
</code></pre>
<p>in Python 3, invokes:</p>
<pre><code>(1.0).__truediv__(x)
</code></pre>
<p>Evidence:</p>
<pre><code>class Float(float):
    def __truediv__(self, other):
        print('__truediv__ called')
        return super(Float, self).__truediv__(other)
</code></pre>
<p>and:</p>
<pre><code>&gt;&gt;&gt; one = Float(1)
&gt;&gt;&gt; one/2
__truediv__ called
0.5
</code></pre>
<p>If we do:</p>
<pre><code>f = one.__truediv__
</code></pre>
<p>We retain a name bound to that bound method</p>
<pre><code>&gt;&gt;&gt; f(2)
__truediv__ called
0.5
&gt;&gt;&gt; f(3)
__truediv__ called
0.3333333333333333
</code></pre>
<p>If we were doing that dotted lookup in a tight loop, this could save a little time.</p>
<h2>Parsing the Abstract Syntax Tree (AST)</h2>
<p>We can see that parsing the AST for the expression tells us that we are getting the <code>__truediv__</code> attribute on the floating point number, <code>1.0</code>:</p>
<pre><code>&gt;&gt;&gt; import ast
&gt;&gt;&gt; ast.dump(ast.parse('1..__truediv__').body[0])
"Expr(value=Attribute(value=Num(n=1.0), attr='__truediv__', ctx=Load()))"
</code></pre>
<p>You could get the same resulting function from:</p>
<pre><code>f = float(1).__truediv__
</code></pre>
<p>Or</p>
<pre><code>f = (1.0).__truediv__
</code></pre>
<h2>Deduction</h2>
<p>We can also get there by deduction.</p>
<p>Let's build it up.</p>
<p>1 by itself is an <code>int</code>:</p>
<pre><code>&gt;&gt;&gt; 1
1
&gt;&gt;&gt; type(1)
&lt;type 'int'&gt;
</code></pre>
<p>1 with a period after it is a float:</p>
<pre><code>&gt;&gt;&gt; 1.
1.0
&gt;&gt;&gt; type(1.)
&lt;type 'float'&gt;
</code></pre>
<p>The next dot by itself would be a SyntaxError, but it begins a dotted lookup on the instance of the float:</p>
<pre><code>&gt;&gt;&gt; 1..__truediv__
&lt;method-wrapper '__truediv__' of float object at 0x0D1C7BF0&gt;
</code></pre>
<p><strong>No one else has mentioned this</strong> - This is now a <strong>"bound method"</strong> on the float, <code>1.0</code>:</p>
<pre><code>&gt;&gt;&gt; f = 1..__truediv__
&gt;&gt;&gt; f
&lt;method-wrapper '__truediv__' of float object at 0x127F3CD8&gt;
&gt;&gt;&gt; f(2)
0.5
&gt;&gt;&gt; f(3)
0.33333333333333331
</code></pre>
<p>We could accomplish the same function much more readably:</p>
<pre><code>&gt;&gt;&gt; def divide_one_by(x):
...     return 1.0/x
...     
&gt;&gt;&gt; divide_one_by(2)
0.5
&gt;&gt;&gt; divide_one_by(3)
0.33333333333333331
</code></pre>
<h2>Performance</h2>
<p>The downside of the <code>divide_one_by</code> function is that it requires another Python stack frame, making it somewhat slower than the bound method:</p>
<pre><code>&gt;&gt;&gt; def f_1():
...     for x in range(1, 11):
...         f(x)
...         
&gt;&gt;&gt; def f_2():
...     for x in range(1, 11):
...         divide_one_by(x)
...         
&gt;&gt;&gt; timeit.repeat(f_1)
[2.5495760687176485, 2.5585621018805469, 2.5411816588331888]
&gt;&gt;&gt; timeit.repeat(f_2)
[3.479687248616699, 3.46196088706062, 3.473726342237768]
</code></pre>
<p>Of course, if you can just use plain literals, that's even faster:</p>
<pre><code>&gt;&gt;&gt; def f_3():
...     for x in range(1, 11):
...         1.0/x
...         
&gt;&gt;&gt; timeit.repeat(f_3)
[2.1224895628296281, 2.1219930218637728, 2.1280188256941983]
</code></pre>
</div>
<span class="comment-copy">Note: <code>(1).__truediv__</code> is not really the same as <code>1..__truediv__</code>, as the former calls <code>int.__truediv__</code> while the latter does <code>float.__truediv__</code>. Alternatively, you can also use <code>1 .__truediv__</code> (with a space)`</span>
<span class="comment-copy">Note that <code>1//8</code> is <code>0</code>, not <code>0.125</code>, in either version of Python.</span>
<span class="comment-copy">reminds me of <code>if (x &lt;- 3) {...}</code></span>
<span class="comment-copy"><a href="https://codegolf.stackexchange.com/a/114572/56656">Here</a> is an example of this in use.</span>
<span class="comment-copy">@KeithC The high quality answers and comments show the sample code needs insight to comprehend, is surprising to many, has alternatives which are clearer, more general, and at least as efficient. My main gripe is that readability counts. Save cleverness for where it's most needed - communicating with humans.</span>
<span class="comment-copy">So what we found is a dev who sacrificed a lot of clarity for a little brevity and here we are.</span>
<span class="comment-copy">Maybe that someone is saving his source code to 5.5" floppy disk?</span>
<span class="comment-copy">@ThomasAyoub it'd be 5.25" iirc ;-)</span>
<span class="comment-copy">@jjmontes My bad, I wasn't born yet :p</span>
<span class="comment-copy">@TemporalWolf He may have found it in <a href="https://codegolf.stackexchange.com/a/114572/56183">this recent code golf submission</a>.</span>
<span class="comment-copy">This is surprising, why are these valid syntax but <code>1.__truediv__</code> is not?</span>
<span class="comment-copy">@AlexHall See <a href="http://stackoverflow.com/a/31037917/1639625">here</a>. The <code>.</code> seems to be parsed as part of the number, and then the <code>.</code> for the method accessor is missing.</span>
<span class="comment-copy">But since it is awkward and unclear syntax, it should probably be avoided.</span>
