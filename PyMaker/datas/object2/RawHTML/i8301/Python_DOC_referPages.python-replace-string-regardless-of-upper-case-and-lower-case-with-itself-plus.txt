<div class="post-text" itemprop="text">
<p>Given a string:</p>
<pre><code>s = "abc, Abc, aBc, abc-def, abca"
</code></pre>
<p>and a word:</p>
<pre><code>w = "abc"
</code></pre>
<p>I want to modify s in the following way:</p>
<p><code>!+abc+!, !+Abc+!, !+aBc+!, abc-def, abca</code></p>
<p>In other words, I want to replace any occurrence of <code>abc</code> no matter of lowercase or uppercase letters in it, by itself preceded by <code>!+</code> and followed by <code>+!</code>.</p>
<p>I already know that my question is pretty similar to this question:
<a href="https://stackoverflow.com/questions/24313407/match-string-in-python-regardless-of-upper-and-lower-case-differences">Match string in python regardless of upper and lower case differences</a></p>
<p>Though, it remains slightly different.</p>
<p>At the moment my solution is pretty dirty and does not work properly:</p>
<pre><code>s = "abc, Abc, aBc, abc-def, abca"
w = "abc"
if w in s:
    s = s.replace(w, "!+"+w+"+!")
if w.title() in s:
    s = s.replace(w.title(), "!+"+w.title()+"+!")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's pretty straight forward even without a regex.</p>
<pre><code>&gt;&gt;&gt; ', '.join('!+{}+!'.format(x) if x.lower()==w else x for x in s.split(', '))
'!+abc+!, !+Abc+!, !+aBc+!, abc-def, abca'
</code></pre>
<p>edit: using a list comprehension instead of a generator comprehension is faster, so</p>
<pre><code>', '.join(['!+{}+!'.format(x) if x.lower()==w else x for x in s.split(', ')])
</code></pre>
<p>should be preferred. Read <a href="https://stackoverflow.com/questions/9060653/list-comprehension-without-in-python">this</a> question and the answer by Raymond Hettinger in particular for the reason.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use a regular expression:</p>
<pre><code>In [16]: re.sub(r'(?: |^)(abc),',r'!+\1+!,', s, flags=re.I)
Out[16]: '!+abc+!,!+Abc+!,!+aBc+!, abc-def, abca'
</code></pre>
<p>The patter <code>(?: |^)(abc),</code> will match every <code>abc</code> that proceeds by a space or the start of the string (<code>^</code>) and followed by a comma and replaces it with the first captured group surrounded with your expected characters. Note that <code>:?</code> in the first group makes it a non-captured group so the <code>\1</code> will refer to <code>abc</code>. Also we are using <code>re.I</code> flag which is the ignore case flag.</p>
<p>If you also want to keep the spaces just use a captured-group for the first group:</p>
<pre><code>In [19]: re.sub(r'( |^)(abc),',r'\1!+\2+!,', s, flags=re.I)
Out[19]: '!+abc+!, !+Abc+!, !+aBc+!, abc-def, abca'
</code></pre>
<p>Also note that if you want to pass multiple regex as the replacing pattern you can compile the first regex using <code>re.compile()</code> and pass the other patterns within a loop:</p>
<pre><code>my_regex = re.compile(r'( |^)(abc),')
my_new_result = [my_regex.sub(pattern, s, flags=re.I) for pattern in list_of_patterns]
</code></pre>
<p>As a more flexible way to deal with <code>re.sub</code> you can also pass a function as the replacer, and so more operations on your captured strings. For example if you want to lower case the matched strings:</p>
<pre><code>s = "abc, Abc, aBc (abc) abc abc &lt;abc&gt; abc-def, abca"

In [31]: re.sub(r'(^|\W)(abc)($|\W)', lambda x: '{}!+{}+!{}'.format(*x.groups()).lower() if x.group(3) != '-' else x.group(0), s, flags=re.I)
Out[31]: '!+abc+!, !+abc+!, !+abc+! (!+abc+!) !+abc+! abc &lt;!+abc+!&gt; abc-def, abca'
</code></pre>
</div>
<span class="comment-copy">You don't need a string as pattern, you need a <a href="https://docs.python.org/3/library/re.html#re.I" rel="nofollow noreferrer">case-insensitive regex</a>.</span>
<span class="comment-copy">case-insensitive regex is the way to go here</span>
<span class="comment-copy">What if s is a long sentence, where words are not simply recognizable by splitting the sentence by <code>s.split(", ")</code>?</span>
<span class="comment-copy">@Ale then we have a different question.Depending on the complexity of the task, either a regex, multiple regex or a full parser can be considered.</span>
<span class="comment-copy">@EricDuminil Yes, updated. Thanks for note!</span>
<span class="comment-copy">Is it possible to put a variable containing the pattern inside the <code>re.sub</code> function instead of the pattern itself? I have to call this procedure several times with patterns that I do not know in advance.</span>
<span class="comment-copy">@Ale Of course. You can just pass the variable instead of the patter, but remember that your variable should be a string proceeds by <code>r</code>. You may want to do this in a list comprehension or any kind of loop.</span>
<span class="comment-copy">@Ale Check the update for more info.</span>
<span class="comment-copy">Thanks, a lot, but it seems to me to be too much specific. I mean, what happens if I have <code>s = "abc, Abc, aBc (abc) abc abc &lt;abc&gt; abc-def, abca"</code>? I want the output to be: <code>!+abc+!, !+abc+!, !+abc+! (!+abc+!) !+abc+! !+abc+! &lt;!+abc+!&gt; abc-def, abca</code>. I tried with <code>s = re.sub(r"\b"+w+r"\b", "!+"+w+"+!", s, flags=re.I)</code>, where <code>w="abc"</code>. It outputs <code>!+abc+!, !+abc+!, !+abc+! (!+abc+!) !+abc+! !+abc+! &lt;!+abc+!&gt; !+abc+!-def, abca</code> which has 2 errors: 1) It outputs any occurrence in lowercase 2) it matches "abc" in "abc-def".</span>
