<div class="post-text" itemprop="text">
<p>I have a datetime object <code>target_time</code>. I also have a list such that <code>times_list[i]['time']</code> is a datetime object. I want to iterate through this list and find the index of the item that has the smallest time distance from <code>target_time</code>. These differences will be in the order of milliseconds, and the range of times covered in the list will be in the order of minutes. My current solution is rather clunky:</p>
<pre><code>best_index = -1
best_diff = 999999999999.0
for i in range(len(times_List)):
    cur_time = times_list[i]['time']
    diff = abs((cur_time-target_time).total_seconds()))
    if diff &lt; best_diff:
        best_index = i
        best_diff = diff
if best_index &gt; -1:
    result = times_list[best_index]['time']
</code></pre>
<p>Is there a less clunky and more pythonic way of doing this?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import operator
deltas = [abs(ti['time'] - target_time) for ti in times_list]
min_index, min_delta = min(enumerate(deltas), key=operator.itemgetter(1))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/functions.html?highlight=enumerate#min" rel="nofollow noreferrer"><code>min()</code></a> to find the smallest difference. Combine that with <a href="https://docs.python.org/3/library/functions.html?highlight=enumerate#enumerate" rel="nofollow noreferrer"><code>enumerate()</code></a> to keep track of the indices:</p>
<pre><code>min_pos, min_diff = min(enumerate(times_list), key=lambda t: abs(target_time - t[1]['time']))
</code></pre>
<p>No need to generate an intermediate list of differences.</p>
</div>
<div class="post-text" itemprop="text">
<p>Alternative method:</p>
<pre><code>temp = sorted(times_list, key=lambda x: abs(abs((x-target_time).total_seconds())))
result = times_list.index(temp[0])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A function to find the closest:</p>
<pre><code>from datetime import datetime

def closest(target, dates):    
    return min(dates, key=lambda date: abs(date-target))


print(closest(target1, dates))
#2014-12-31 16:00:00

print(closest(target2, dates))
#2015-01-01 12:00:00
print(abs(target1 - target2))
</code></pre>
</div>
<span class="comment-copy">Please give us sample data structures to work with, and the desired output for these samples of course.</span>
<span class="comment-copy">pretty sure <code>t[1]</code> is an error here as <code>t[i]</code> is the loop variable.</span>
<span class="comment-copy">@HalTL no, 1 is corect. It's the second item of the tuple passed to the lambda expression. There is no loop variable.</span>
<span class="comment-copy">I like that this doesn't require an import.</span>
<span class="comment-copy">I'll never understand why one prefers lambda over a list comprehension.</span>
<span class="comment-copy">This method is less efficient than others. The <code>sort()</code> is O(n log n) <i>plus</i> the list needs to be rescanned to locate the item. Other solutions that use <code>min()</code> are O(n).</span>
<span class="comment-copy">Good point, thanks.</span>
<span class="comment-copy">OP also requires the index of the item with the smallest delta.</span>
