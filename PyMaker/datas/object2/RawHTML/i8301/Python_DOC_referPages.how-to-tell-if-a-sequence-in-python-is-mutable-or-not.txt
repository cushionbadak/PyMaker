<div class="post-text" itemprop="text">
<p>For built-in Python types, <code>list</code> is mutable but <code>tuple</code> is not. For other sequences, is there a way to tell whether they are mutable or not? Like a mutable sequence usually has <code>.pop()</code>, <code>.insert()</code>, or <code>.extend()</code> member function? Do all mutable sequences and immutable sequences inherit from separate built-in types, which then can be used to differentiate them?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can check whether the type is a subclass of the <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableSequence" rel="noreferrer"><code>collections.abc.MutableSequence</code></a> abstract base class (or <a href="https://docs.python.org/2/library/collections.html#collections-abstract-base-classes" rel="noreferrer"><code>collections.MutableSequence</code></a> in Python 2):</p>
<pre><code>&gt;&gt;&gt; issubclass(list, MutableSequence)
True
&gt;&gt;&gt; issubclass(tuple, MutableSequence)
False

&gt;&gt;&gt; isinstance([], MutableSequence)
True
&gt;&gt;&gt; isinstance((), MutableSequence)
False
</code></pre>
<p>Note that unlike some <a href="https://docs.python.org/3/library/abc.html#module-abc" rel="noreferrer">ABCs</a> (e.g., <code>Collection</code> and <code>Iterable</code>, which provide hooks for <code>issubclass</code>/<code>isinstance</code>) this one requires its subclasses to be explicitly registered, so this may not work out-of-the-box with all sequence-ish types.</p>
<p>However, you can manually register a type as a subclass using <code>MutableSequence.register(MyType)</code>, as long as the required abstract methods are implemented.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no simple solution until there is no understanding of what you are trying to achieve, so we need to understand what mutability is? </p>
<p>Let's simply define <em>mutable type</em> as type for which instances we can set item in some position (by key in dictionaries, by index in lists), i. e. they implement <code>__setitem__</code> method.</p>
<p>Most preferred way of checking something in <code>Python</code> is to ask forgiveness, not permission, so something like this will help</p>
<pre><code>def is_mutable(cls):
    try:
        cls.__setitem__
    except AttributeError:
        return False
    else:
        return True
</code></pre>
<p>but it also can be replaced with</p>
<pre><code>def is_mutable(cls):
    return hasattr(cls, '__setitem__')
</code></pre>
<p>both work similar, depends on your taste.</p>
<p>Example</p>
<pre><code>types = [tuple, str, list, dict]
for type_ in types:
    print(type_.__name__, 'is mutable:', is_mutable(type_))
</code></pre>
<p>gives us</p>
<pre><code>tuple is mutable: False
str is mutable: False
list is mutable: True
dict is mutable: True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If your sequence is named <code>seq</code>, the "duck typing" way to test immutability would be to try to assign a value to <code>seq[0]</code>, and catch the exception if it doesn't work... </p>
</div>
<div class="post-text" itemprop="text">
<p>An object is immutable if it contains only immutable-typed as sub-objects.
A type is immutable if it is a built-in immutable type: str, int, bool, float, tuple. </p>
</div>
<span class="comment-copy">In general there's no programmatic way to tell whether a type (sequence or otherwise) is mutable.  The way to tell is read the documentation for that type and see what it says.</span>
<span class="comment-copy">You could try using <code>isinstance(thing, MutableSequence)</code>, from the ABCs: <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableSequence" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a></span>
<span class="comment-copy">I think you're asking the wrong question. "Mutable" and "immutable" are just the two ends of the spectrum. One can easily write a "mutable" sequence that allows appending new elements, but not removing elements. Or a sequence that only allows appending certain values and not others. The question you should probably ask instead is <i>"Can this sequence do what I need it to do"</i>, in which case you can simply do <code>try: sequence.do_something() except: #don't do anything</code>.</span>
<span class="comment-copy">Primitive-like types are probably immutable. Container-like types are probably mutable.</span>
<span class="comment-copy">why do you need this in the first place? provide use-case example</span>
<span class="comment-copy">It seems like a shortcoming that this solution may not work with user-defined mutable sequences...although admittedly that is not a common circumstance...</span>
<span class="comment-copy">@AlexL To be fair, the idea of a class being able to declare <i>itself</i> a parent of another type, without the designer's consent, is pretty crazy.  It makes sense when the class doesn't define any additional methods, e.g., <code>Iterable</code>, which is really just an interface that stipulates that the subclass defines <code>__iter__</code>.  But for ABCs that define mixin methods (like <code>MutableSequence</code>), it would be dangerous to forcibly add these to other classes, with no opt-out.  I guess this is why it has to be an explicit design decision.</span>
<span class="comment-copy">@AlexL And remember: even if the class designer forgot to register it with an ABC, you can still do so yourself in your own code :-)</span>
<span class="comment-copy">When you implement a custom (Mutable)Sequence it makes sense to explicitly inherit the ABC anyways: it provides you with useful mixins saving some implementation time (sometimes at the cost of runtime depending on the mixin method and your implementation of the mandatory methods, but not always).</span>
<span class="comment-copy">Yes, agreed on all. Although the most likely scenario would be the case where it's not possible to know until runtime whether or not the thing is mutable...in which case registering isn't really an option...</span>
<span class="comment-copy">Note that <code>set</code> does not have <code>__setitem__</code> but it mutable. On the other hand, <code>set</code> is not a sequence type, either, but neither is <code>dict</code>.</span>
<span class="comment-copy">yeap, following this definition <code>set</code> is not mutable</span>
<span class="comment-copy"><code>set</code> <i>is</i> most definitely mutable, but it is not a "mutable sequence" -- and neither is <code>dict</code>, so the presence of <code>__setitem__</code> might not be the best indicator. Also, there could be other mutable sequences, such as (strict) stacks and queues, that do not allow random access.</span>
<span class="comment-copy">there is no way to say if random type is mutable or not, but this approach works fine for <code>tuple</code>/<code>list</code>/<code>str</code>, OP should decide if it's good for <code>dict</code>s to be considered mutable or not</span>
<span class="comment-copy">if we try to add support for <code>set</code>s, we may also want to check all types from standard library and still it will not work perfectly on all types</span>
<span class="comment-copy">The standard python definition of a mutable sequence also requires implementing <code>del seq[0]</code> and <code>seq.insert</code></span>
<span class="comment-copy">Taken at face value, this advice would also lose the existing value at that index. Otherwise this is a good approach. Can you propose a general test that doesn't actually change the seq?</span>
<span class="comment-copy">@kojiro&gt; there can be no general solution, as the value could be write-only or have side-effects, therefore once assigned you cannot undo the change. Granted, such case would be rare but it makes a general solution dubious at best.</span>
<span class="comment-copy">Assigning to <code>seq[0]</code> also works for dicts and does not work for an empty sequence.</span>
<span class="comment-copy">@kojiro actually modifying the sequence can be avoided with <code>seq[0] = seq[0]</code>, but that still does not help the empty or dict edge cases.</span>
<span class="comment-copy">This is not true.  A <code>list</code> containing only immutable values is still mutable --- you could replace any of those immutable values with other values.  (You could also add or remove values.)</span>
