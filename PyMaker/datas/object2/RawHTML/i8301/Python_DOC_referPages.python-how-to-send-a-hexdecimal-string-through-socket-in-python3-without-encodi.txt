<div class="post-text" itemprop="text">
<p>I performed socket communication in python2, it worked well and I have to make it works in python3 again. I have tired str.encode() stuff with many formats, but the other side of the network can't recognize what I send. The only thing I know is that the python3 str type is encoded as Unicode uft-8 in default, and I'm pretty sure the critical question in here is that what is the format of python2 str type. I have to send exactly the same thing as what was stored in python2 str. But the tricky thing is the socket of python3 only sends the encoded unicode bytes or other buffer interface, rather than the str type with the raw data in Python2. The example is as follow:</p>
<p>In python2:</p>
<pre><code>data = 'AA060100B155'
datasplit = [fulldata[i: i+2] for i in range(0, len(fulldata), 2)]
senddata = ''
for item in datasplit:
    itemdec = chr(int(item, 16))
    senddata += itemdec
print(senddata) 
#'\xaa\x06\x01\x00\xb1U',which is the data I need
</code></pre>
<p>In python3, seems it can only sends the encoded bytes using "senddata.encode()", but it is not the format I want. You can try:</p>
<pre><code>print(senddata.encode('latin-1'))
#b'\xaa\x06\x01\x01\xb2U'
</code></pre>
<p>to see the difference of two senddatas, and an interesting thing is that it is faulty encoded when using utf-8.</p>
<p>The data stored in Python3 str type is the thing I need, but my question is how to send the data of that string without encoding it? Or how to perform the same str type of Python2 in Python3?</p>
<p>Can anyone help me with this?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><em>I performed socket communication in python2, it worked well and I have to make it works in python3 again. I have tired str.encode() stuff with many formats, but the other side of the network can't recognize what I send.</em></p>
</blockquote>
<p>You have to make sure that whatever you send is decodable by the other side. The first step you need to take is to know what sort of encoding that network/file/socket is using. If you use UTF-8 for instance to send your encoded data and the client has ASCII encoding, this will work. But, say cp500 is the encoding scheme of your client and you send the encoded string as UTF-8, this won't work. It's better to pass the name of your desired encoding explicitly to functions, because sometimes the default encoding of your platform may not necessarily be UTF-8. You can always check the default encoding by this call <code>sys.getdefaultencoding()</code>.</p>
<blockquote>
<p><em>The only thing I know is that the python3 str type is encoded as Unicode uft-8 in default, and I'm pretty sure the critical question in here is that what is the format of python2 str type. I have to send exactly the same thing as what was stored in python2 str. But the tricky thing is the socket of python3 only sends the encoded unicode bytes or other buffer interface, rather than the str type with the raw data in Python2</em></p>
</blockquote>
<p>Yes, Python 3.X uses UTF-8 as the default encoding, but this is not guaranteed in some cases the default encoding could be changed, it's better to pass the name of the desired encoding explicitly to avoid such cases. Notice though, <code>str</code> in Python 3.X is the equivalent of <code>unicode</code> + <code>str</code> in 2.X, but <code>str</code> in 2.X supports <em>only</em> 8-bit (1-byte) (0-255) characters. </p>
<p>On one hand, your problem seems with 3.X and its type distinction between <code>str</code> and <code>bytes</code> strings. For APIs that expect <code>bytes</code> won't accept <code>str</code> in 3.X as of today. This is unlike 2.X, where you can mix <code>unicode</code> and <code>str</code> freely. This distinction in 3.X makes sense, given <code>str</code> represents <em>decoded</em> strings and used for textual data. Whereas, <code>bytes</code> represents encoded strings as raw bytes with absolute byte values.</p>
<p>On the other hand, you have problem with choosing the right encoding for your text in 3.X that you need to pass to client. First check what sort of encoding does your client use. Second, pass the encoded string with the the proper encoding scheme of your client so your client can decode it properly: <code>str.encode('same-encoding-as-client')</code>.</p>
<p>Because you pass your data as <code>str</code> in 2.X and it works, I suspect and it's most likely your client  uses 8-bit encoding for characters, something like Latin-1 might be the encoding used by your client. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can convert the whole string to an integer, then use the integer method <code>to_bytes</code> to convert it into a <code>bytes</code> object:</p>
<pre><code>fulldata = 'AA060100B155'

senddata = int(fulldata, 16).to_bytes(len(fulldata)//2, byteorder='big')
print(senddata)

# b'\xaa\x06\x01\x00\xb1U'
</code></pre>
<p>The first parameter of <code>to_bytes</code> is the number of bytes, the second (required) is the byteorder.
See <a href="https://docs.python.org/3/library/stdtypes.html#int.to_bytes" rel="nofollow noreferrer">int.to_bytes</a> in the official documentation for reference.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are various ways to do this. Here's one that works in both Python 2 and Python 3.</p>
<pre><code>from binascii import unhexlify

fulldata = 'AA060100B155'
senddata = unhexlify(fulldata)
print(repr(senddata))
</code></pre>
<p><strong>Python 2 output</strong></p>
<pre><code>'\xaa\x06\x01\x00\xb1U'
</code></pre>
<p><strong>Python 3 output</strong></p>
<pre><code>b'\xaa\x06\x01\x00\xb1U'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The following is Python 2/3 compatible. The <code>unhexlify</code> function converts hexadecimal notation to bytes.  Use a byte string and you don't have to deal with Unicode strings.  Python 2 is byte strings by default, but recognizes the <code>b''</code> syntax that Python 3 requires to use a byte string. </p>
<pre><code>from binascii import unhexlify
fulldata = b'AA060100B155'
print(repr(unhexlify(fulldata)))
</code></pre>
<p>Python 2 output:</p>
<pre><code>'\xaa\x06\x01\x00\xb1U'
</code></pre>
<p>Python 3 output:</p>
<pre><code>b'\xaa\x06\x01\x00\xb1U'
</code></pre>
</div>
<span class="comment-copy">Where does <code>'ª\x06\x01\x01²U'</code> come from? When I run your code (in Python 2.6.6) , the <code>repr</code> of <code>senddata</code> is <code>'\xaa\x06\x01\x00\xb1U'</code>.</span>
<span class="comment-copy">sorry, It is from IDE of python3. sorry to confuse you</span>
<span class="comment-copy">Thanks for your long explaination! I will have a talk with the client.</span>
<span class="comment-copy">@Iwangreen Also see: <a href="https://docs.python.org/3.3/howto/unicode.html" rel="nofollow noreferrer">Unicode HOWTO</a>.</span>
<span class="comment-copy">Ok I have one question. Is there a default encoding scheme for Python2 str? From your answer I thinks it is a no for this. We actually perform a hardware control through Python application, and there might be also no encoding scheme on the circuit board. That's probably the reason why I can do communication with Python2 str but not for Python3. Your opinion?</span>
<span class="comment-copy">There's no encoding for <code>str</code> in Python 2.X and is simply a raw bytes string: <a href="https://stackoverflow.com/questions/3547534/what-encoding-do-normal-python-strings-use">What encoding do normal python strings use?</a>.</span>
<span class="comment-copy">Your second question: the reason why your code works in 2.X when you send <code>str</code> is because <code>str</code> is raw data. But I don't see the reason why you're not able to make your data raw and send them as <code>bytes</code> objects in 3.X. Though, <code>bytes</code> does exist in 2.X for forward-compatibility and returns simple <code>str</code>. Interfacing with hardware would likely require raw data of course. Isn't <code>str</code> in 2.X raw after all? So if you would like to to have 2.X's <code>str</code> in 3.X, it's just called <code>bytes</code> with minor differences.</span>
<span class="comment-copy">Thanks for your reply, but it doesn't solve my problem. Thanks anyway</span>
<span class="comment-copy">You just have to send it, the way you sent the Python2 <code>str</code> before.</span>
<span class="comment-copy">It is not the matter about what I send, it is all about what the other side can recognize. do you know what's the difference between '\xaa\x06\x01\x00\xb1U' and a 'b' in front of it?</span>
<span class="comment-copy">@lwangreen In Python 2, there's no difference. In Python 3, <code>b'\xaa\x06\x01\x00\xb1U'</code> is a bytes string, contains <i>exactly</i> the same bytes as Python 2's <code>b'\xaa\x06\x01\x00\xb1U'</code> or <code>'\xaa\x06\x01\x00\xb1U'</code>. However, <code>'\xaa\x06\x01\x00\xb1U'</code> in Python 3 is the same as <code>u'\xaa\x06\x01\x00\xb1U'</code> (in either Python 2 or Python 3). And you can convert that to the previous bytes string using <code>u'\xaa\x06\x01\x00\xb1U'.encode('latin-1')</code>. That's because Latin-1 is a subset of Unicode.</span>
<span class="comment-copy">@lwangreen With <code>fulldata = 'AA060100B155'</code> your Python 2 code sends <code>'\xaa\x06\x01\x00\xb1U'</code>. So if your Python 3 code sends the bytes string <code>b'\xaa\x06\x01\x00\xb1U'</code> over the socket they will get <i>exactly</i> the same bytes.</span>
