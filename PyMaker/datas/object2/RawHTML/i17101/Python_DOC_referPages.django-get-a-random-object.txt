<div class="post-text" itemprop="text">
<p>I am trying to get a random object from a model A</p>
<p>For now, it is working well with this code:</p>
<pre><code>random_idx = random.randint(0, A.objects.count() - 1)
random_object = A.objects.all()[random_idx]
</code></pre>
<p>But I feel this code is better:</p>
<pre><code>random_object = A.objects.order_by('?')[0]
</code></pre>
<p>Which one is the best? Possible problem with deleted objects using the first code? Because, for example,  I can have 10 objects but the object with the number 10 as id, is not existing anymore? Did I have misunderstood something in A.objects.all()[random_idx] ?</p>
</div>
<div class="post-text" itemprop="text">
<p>Just been looking at this. The line:</p>
<pre><code>random_object = A.objects.order_by('?')[0]
</code></pre>
<p>has reportedly brought down many servers.</p>
<p>Unfortunately Erwans code caused an error on accessing non-sequential ids.</p>
<p>There is another short way to do this:</p>
<pre><code>import random

items = Product.objects.all()

# change 3 to how many random items you want
random_items = random.sample(items, 3)
# if you want only a single random item
random_item = random.choice(items)
</code></pre>
<p>The good thing about this is that it handles non-sequential ids without error.</p>
</div>
<div class="post-text" itemprop="text">
<p>The second bit of code is correct, but can be slower, because in SQL that generates an <code>ORDER BY RANDOM()</code> clause that shuffles the entire set of results, and then takes a <code>LIMIT</code> based on that.</p>
<p>The first bit of code still has to evaluate the entire set of results. E.g., what if your random_idx is near the last possible index?</p>
<p>A better approach is to pick a random ID from your database, and choose that (which is a primary key lookup, so it's fast). We can't assume that our every <code>id</code> between <code>1</code> and <code>MAX(id)</code> is available, in the case that you've deleted something. So following is an approximation that works out well:</p>
<pre><code>import random

# grab the max id in the database
max_id = A.objects.order_by('-id')[0].id

# grab a random possible id. we don't know if this id does exist in the database, though
random_id = random.randint(1, max_id + 1)

# return an object with that id, or the first object with an id greater than that one
# this is a fast lookup, because your primary key probably has a RANGE index.
random_object = A.objects.filter(id__gte=random_id)[0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yet another way:</p>
<pre><code>pks = A.objects.values_list('pk', flat=True)
random_idx = randint(0, len(pks))
random_obj = A.objects.get(pk=pks[random_idx])
</code></pre>
<p>Works even if there are larger gaps in the pks, for example if you want to filter the queryset before picking one of the remaining objects at random.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm sharing my latest test result with Django 2.1.7, PostgreSQL 10.</p>
<pre class="lang-py prettyprint-override"><code>students = Student.objects.all()
for i in range(500):
    student = random.choice(students)
    print(student)

# 0.021996498107910156 seconds

for i in range(500):
    student = Student.objects.order_by('?')[0]
    print(student)

# 0.41299867630004883 seconds
</code></pre>
<p>It seems that random fetching with random.choice() is about 2x faster.</p>
</div>
<span class="comment-copy">Why would you make 2 queries (one for count, one for actual select) instead of 1?</span>
<span class="comment-copy">I think the second one is probably better, but the first one isn't subject to the problem you describe, because it's indexing a list you've already bounded, not selecting by the database ID. Also, why not <code>random.choice(A.objects.all())</code>?</span>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/962619/how-to-pull-a-random-record-using-djangos-orm">How to pull a random record using Django's ORM?</a></span>
<span class="comment-copy">@Two-BitAlchemist blergh, that's the worst of all: getting all rows from the database in order to return just one.</span>
<span class="comment-copy">@DanielRoseman It's also plenty readable, leaves <code>A.objects.all()</code> in order (unlike solution 2) if it's used somewhere else, and concisely illustrates another potential use case. I don't see anything asking about <i>performance</i>, just what will work, and for a small number of objects, readability is more important.</span>
<span class="comment-copy">Looking at the documentation of the <code>random</code> module, <code>random.sample(items, 1)[0]</code> can be avoided by using <code>random.choice(items)</code>. See <a href="https://docs.python.org/3/library/random.html#random.choice" rel="nofollow noreferrer">random.choice</a>.</span>
<span class="comment-copy">The first code does not evaluate the entire list. Slices in Django querysets are translated into LIMIT/OFFSET calls in the SQL.</span>
<span class="comment-copy">What I meant is: LIMIT/OFFSET in SQL is notoriously slow, because it has to nearly evaluate the entire list.</span>
<span class="comment-copy">You should replace the <code>get</code> by <code>filter</code>. Now you get the following error: <code>TypeError: 'A' object does not support indexing</code></span>
<span class="comment-copy">@J.Ghyllebert, good catch with <code>get</code> vs <code>filter</code>. Can</span>
<span class="comment-copy">I would replace all "id"s with "pk"s. For more information, take a look at <a href="http://stackoverflow.com/questions/2165865/django-queries-id-vs-pk" title="django queries id vs pk">stackoverflow.com/questions/2165865/django-queries-id-vs-pk</a></span>
