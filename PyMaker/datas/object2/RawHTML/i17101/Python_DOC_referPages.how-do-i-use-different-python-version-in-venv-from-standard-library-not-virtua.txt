<div class="post-text" itemprop="text">
<p>I have installed Python 3.4.0 and created virtual environment with <code>python -m venv myenv</code>. How  can I change Python version in my virtual environment? Documentation says:</p>
<blockquote>
<p>Each virtual environment has its own Python binary (allowing creation
  of environments with various Python versions) and can have its own
  independent set of installed Python packages in its site directories.</p>
</blockquote>
<p><strong>UPDATE</strong></p>
<p>Please, note that I ask about <em>venv</em> from standard library, not about virtualenv.
Let me provide some links.</p>
<ul>
<li>This is PEP 405. <a href="http://legacy.python.org/dev/peps/pep-0405/" rel="nofollow">http://legacy.python.org/dev/peps/pep-0405/</a></li>
<li>Python venv. <a href="http://docs.python.org/3.4/library/venv.html" rel="nofollow">http://docs.python.org/3.4/library/venv.html</a></li>
<li>Virtualenv. <a href="http://www.virtualenv.org/en/latest/" rel="nofollow">http://www.virtualenv.org/en/latest/</a></li>
</ul>
<p>I don't see something like a <code>--python</code> flag in venv.</p>
<p>Are venv and virtualenv absolutely similar?
Is venv is so unpopular and no one uses it so that virtualenv remains the standard?</p>
</div>
<div class="post-text" itemprop="text">
<h1>Update 2018</h1>
<p>These days, I suggest using <a href="https://github.com/pypa/pipenv" rel="noreferrer">Pipenv</a> to create virtual environments and handle project dependencies in Python.</p>
<blockquote>
<p>Pipenv — the officially recommended Python packaging tool from Python.org, free (as in freedom).</p>
<p>Pipenv is a tool that aims to bring the best of all packaging worlds (bundler, composer, npm, cargo, yarn, etc.) to the Python world. Windows is a first–class citizen, in our world.</p>
</blockquote>
<p>To <strong>create a virtual environment</strong>, cd into the project directory and run:</p>
<pre><code>pipenv --python 3.6
</code></pre>
<p>Replace 3.6 with the version you need. (The version you choose has to be installed on your system. Here is how you <a href="https://stackoverflow.com/questions/2547554/official-multiple-python-versions-on-the-same-machine">install multiple Python versions next to each other</a>)</p>
<p><strong>Install a package</strong> in your environment:</p>
<pre><code>pipenv install my_package
</code></pre>
<p>or if the dependency is for development purposes only (testing, etc.):</p>
<pre><code>pipenv install my_packge --dev
</code></pre>
<p><strong>Run something in your environment</strong>.:</p>
<pre><code>pipenv run python my_file.py
</code></pre>
<h1>Old Answer</h1>
<p>On Linux you can easily <a href="https://stackoverflow.com/a/46258340/1612318">install multiple versions of Python</a> next to the main one and you can use the <a href="https://stackoverflow.com/a/46258340/1612318">venv</a> package from the standard library to create virtual environments from each version &gt;= 3.3.</p>
<p><strong>Create venv</strong></p>
<pre><code>$ python3.3 -m venv myvenv_foo  # Create a python3.4 venv named 'myvenv_foo'
$ python3.4 -m venv myvenv_bar  # Create a python3.4 venv named 'myvenv_bar'
$ python3.5 -m venv myvenv_baz  # Create a python3.5 venv named 'myvenv_baz'
# etc...
</code></pre>
<p><strong>Activate venv</strong></p>
<pre><code>source myvenv_foo/bin/activate  # Activates venv 'myvenv_foo'
</code></pre>
<p><strong>Deactivate venv</strong></p>
<pre><code>deactivate
</code></pre>
<p><strong>Notice: <code>python</code> vs <code>pythonX.X</code></strong></p>
<p>If you have multiple Python versions installed, you can access each one by adding the version num to the command e.g. <code>python3.5</code>, <code>python3.6</code>, etc. But keep in mind that when you activate a venv, you bind it to the clean/versionless <code>python</code> command, for as long as it's activated. E.g:</p>
<pre><code>$ python -V # Use the *clean* 'python' command to show the main version of the OS.
Python 2.7.6 
$ python3.5 -m venv myvenv_foo # Create a new venv from 'python3.5'.
$ source myvenv_foo/bin/activate # Activate venv.
$ python -V # The *clean* 'python' command is now bound to your activated venv.
Python 3.5.2 
$ deactivate  # Deactivate venv.
$ python -V  # Now the *clean* command is bound back to the main version.
Python 2.7.6 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a very good question as there are several python modules / libraries (built-in &amp; third party) with similar names and purposes. Can completely sympathise with OP's confusion.</p>
<p>There are really two different behaviours / responsibilities:</p>
<p><strong>1).</strong> The ability to switch between different versions of (System) Python Interpreter eg. <strong>2.7.10</strong> or <strong>3.5.0</strong> etc</p>
<p><strong>2).</strong> The ability to create virtual environments (which is just a local folder containing all the plumbing (binaries and libs) for a particular version of python. Can sort of think of this as a frozen local instance of a particular python version. Essentially it is a self-contained, light-weight python installation.</p>
<p>A module like <code>pyvenv</code> provides <strong>2)</strong> above. It will allow you to create a virtual environment that is set at the version of Python that was used to create it.</p>
<pre><code>$ python --version
Python 3.5.0
$ pyvenv myenv   # myenv is now a local environment using Python 3.5.0
</code></pre>
<p>For further infoormation on pyvenv, see <a href="https://docs.python.org/3/library/venv.html" rel="nofollow">library/venv</a></p>
<p>A module like <code>pyenv</code> (the names are confusing, right? Notice, pyenv, and not py<strong>v</strong>env) on the other hand, controls which VERSION of python your system is basically running. This provides <strong>1)</strong> above. So, when not running a particular virtual env via pyvenv etc, this is the "global" version in use. In fact, it is slightly more convoluted than that (as you can also setup local configuration etc), but essentially that is enough for this discussion. </p>
<p>For further information on pyenv see <a href="https://github.com/yyuu/pyenv" rel="nofollow">github.com/yyuu/pyenv</a></p>
<p>Suppose I want to run Python versions 2.7.10 and 3.5.0, then I would use pyenv to install these two versions (here, I chose as globals), and can view this using:</p>
<pre><code>$ pyenv versions
  system
* 2.7.10 (set by ~/.pyenv/version)
* 3.5.0 (set by ~/.pyenv/version)

$ python --version
Python 3.5.0

$ which python
~/.pyenv/shims/python

$ python2.7 --version
Python 2.7.10
</code></pre>
<p>Yes, there are several prominant alternatives to each of the above referenced modules / libs. Heated discussions on Reddit / SOF etc detailing and arguing which is best. Many of them do very similar things...</p>
</div>
<div class="post-text" itemprop="text">
<p>It's simply impossible. To create python venv of specific Python version, we need this specific version.</p>
<p>Obviously, Python interpreter doesn't contain all previous versions. Python 3.4.1 doesn't contain Python 2.7.8 executable anywhere inside.</p>
</div>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/1534210/use-different-python-version-with-virtualenv">Use different Python version with virtualenv</a></span>
<span class="comment-copy">@DanielRoseman There are two engines for virtual environments, Python <i>venv</i> and <i>virtualenv</i>. I as about first one: <a href="http://docs.python.org/3.4/library/venv.html" rel="nofollow noreferrer">docs.python.org/3.4/library/venv.html</a></span>
<span class="comment-copy">Have you tried to just replace the link bin/python inside the venv with one to another python version? (At creation-time, you can choose the python version by using another interpreter, i.e. <code>python3.2 -m venv myvenv</code>.)</span>
<span class="comment-copy">@Phillip Of course, it works. I tried this way first. But even if it works, I cannot use Python 2.7 in virtual environment that is created with Python 3.4 (or 3.3). Also, I have to install several Python versions in my system. Although, thanks for answer. I think that I understood how virtual environments work somewhat incorrectly. I thought that one Python system interpreter can produce virtual environments with different Python versions.</span>
<span class="comment-copy">Thanks for answer. It should be useful for those who are interested.</span>
<span class="comment-copy">This answer would be ultimate if only it explains how to setup venvs for 32/64 versions of same python version.</span>
