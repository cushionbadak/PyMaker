<div class="post-text" itemprop="text">
<p>I try to discretize some numbers, by looking if they are in a given range, and then assign a number based on the range, however the result which I get is not exactly correct.</p>
<p><code>mapp</code> is the a dictionary of which defines ranges, and the values which correspond to the given range. </p>
<p><code>lst</code> is the list of numbers that I want to match against those ranges, and assign identifiers to them</p>
<pre><code>mapp = {(0,100): 1, (100,400): 2, (400,800): 3}


lst = [3.5, 5.4, 300.12, 500.78, 600.45, 900.546]


def discretize(mapping_dict, list_of_values):
    print "\n"
    location = []
    for x in sorted(list_of_values):
        for (lower_bound,upper_bound),value in mapping_dict.items():
            if round(x) in range(lower_bound,upper_bound):
                print round(x), "yes", value

                distance = mapping_dict[(lower_bound,upper_bound)]
                location.append((distance))


        else:
            print round(x), "no"

            distance = len(mapping_dict.items())+10
            location.append((distance))

    return location
</code></pre>
<p>The result which I expect is: <code>[1, 1, 2, 3, 3, 13]</code> , however that's not what I get.</p>
<p>This is the actual result which I get, which is incorrect:</p>
<pre><code>4.0 yes 1
4.0 no         #wrong!
5.0 yes 1
5.0 no         #wrong!
300.0 yes 2
300.0 no         #wrong!
501.0 yes 3
501.0 no         #wrong!
600.0 yes 3
600.0 no         #wrong!
901.0 no         #CORRECT

[1, 13, 1, 13, 2, 13, 3, 13, 3, 13, 13]
</code></pre>
<p>I get <code>no</code> at <code>4.0</code> which is not correct, etc, etc.</p>
<p>Where is the problem?</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>mapp = {(0,100): 1, (100,400): 2, (400,800): 3}
lst = [3.5, 5.4, 300.12, 500.78, 600.45, 900.546]
result = []
for l in lst:
    for m in mapp:
        if m[0] &lt; l &lt; m[1]:
            result.append(mapp[m])

print result
</code></pre>
<p>Output:</p>
<pre><code>[1, 1, 2, 3, 3]
</code></pre>
<p>EDIT:</p>
<pre><code>result = []
for l in lst:
    flag=True
    for m in mapp:
        if m[0] &lt; l &lt; m[1]:
            result.append(mapp[m])
            flag = False
            break
    if flag:
        result.append(-1)
print result
</code></pre>
<p>Output:</p>
<pre><code>[1, 1, 2, 3, 3, -1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think I have faced a similar problem once, because I found a small <code>RangeDict</code> class:</p>
<pre><code>class RangeDict (dict):
    def __init__ (self, *args):
        super ().__init__ ()

    def __setitem__ (self, k, v):
        if not isinstance (k, slice): raise ValueError ('Indices must be slices.')
        super ().__setitem__ ( (k.start, k.stop), v)

    def __getitem__ (self, k):
        for (start, stop), v in self.items ():
            if start &lt;= k &lt; stop: return v
        raise IndexError ('{} out of bounds.'.format (k) )
</code></pre>
<p>I hope this class wraps your desired funcionality. Obviously lookup is O(N) and not O(1).</p>
<p>Sample usage:</p>
<pre><code>r = RangeDict ()
r [0:100] = 1
r [100:400] = 2
r [400:800] = 3

for x in [3.5, 5.4, 300.12, 500.78, 600.45, 900.546]:
    print (r [x] )
#Last value raises IndexError
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Putting an <code>else</code> after your <code>for</code> loop you were an the right track! When you put an <a href="http://docs.python.org/3/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops" rel="nofollow"><code>else</code> after a loop</a>, that <code>else</code> block is executed each time the loop exits normally, i.e. without using e.g. <code>break</code>. Thus, (assuming that your groups are non-overlapping) you just need to add a <code>break</code> statement to the end of your <code>if</code> block, i.e. after <code>location.append((distance))</code>. Then it works as expected.</p>
<p>Also, instead of checking whether the number is in the <code>range</code> (which creates and searches a list each time!) you should just use <code>&lt;=</code> and <code>&lt;</code>. Also, you already have the <code>value</code>, so why not use it?</p>
<pre><code>for (lower_bound, upper_bound), value in mapping_dict.items():
    if lower_bound &lt;= x &lt; upper_bound:
        location.append(value)
        break
else:
    location.append(len(mapping_dict) + 10)
</code></pre>
</div>
<span class="comment-copy">You probably just need to <code>break</code> from the loop once you find the right group, otherwise the <code>else</code> will always be executed.</span>
<span class="comment-copy">you definitely do not want to create ranges like you are. you simply need to use <code>lower_bound &lt;= val &lt; upper_bound</code> or something like that.</span>
<span class="comment-copy">thanks, but this solution still does not consider the case for <code>900.546</code> @user3</span>
<span class="comment-copy">how do you calculate the value for 900.546?</span>
<span class="comment-copy">I have edited to add -1 if range is not defined...</span>
<span class="comment-copy">@user3 That construct with the <code>flag</code> variable does exactly the same as <code>for/break/else</code> already does in Python.</span>
<span class="comment-copy">+1 Neat! Just curious: Any particular reason why you are not using <code>if start &lt;= k &lt; stop: return v</code>?</span>
<span class="comment-copy">@tobias_k In order to minimize comparisons.</span>
<span class="comment-copy">Though so, but isn't <code>x &lt; y &lt; z</code> like <code>x &lt; y and y &lt; z</code>, i.e. won't it stop early, too, if the first conditions is not met?</span>
<span class="comment-copy">@tobias_k Ahh. Good catch. Sure if it is evaluated lazily (and why should it not), it boils down to the same. Thanks for the input.</span>
<span class="comment-copy">@Hyperboreus Lazyness of comparison chaining is <a href="http://docs.python.org/2/reference/expressions.html#not-in" rel="nofollow noreferrer">documented</a>, as is the fact that the middle expression is evaluated only once.</span>
