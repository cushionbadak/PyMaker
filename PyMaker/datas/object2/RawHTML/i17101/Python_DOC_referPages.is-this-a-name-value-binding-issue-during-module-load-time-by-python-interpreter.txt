<div class="post-text" itemprop="text">
<p>I wrote a small program in sample.py file, </p>
<pre><code>a=6
def f1():
    a=3
    return f2()

#def f2(): commented intentionally
#   b = a*a
#   return b
</code></pre>
<p>and loaded as <code>__main__</code> module using command</p>
<pre><code>&gt;&gt;&gt;python -i sample.py
</code></pre>
<p>But i see that interpreter does not check the binding of f2 during loading of module.</p>
<p>Interpreter only realises that f2 name is not binded to its value when i call</p>
<pre><code>&gt;&gt;&gt;f1() 
</code></pre>
<p>Another example, where interpreter checks the binding of name <code>big1</code> , while loading the file as <code>__main__</code> module using command     <code>&gt;&gt;&gt;python -i sample.py</code> throws an error saying <code>big1 is not defined</code></p>
<pre><code>big, small =  3, -4
while big &gt; 2 or small &lt; -2:
    big, small = -small - 1, -big + 1
    print(big1)
</code></pre>
<p>My question is:</p>
<p>1)
Why python interpreter does not take an effort to check whether all names are bind during loading of sample.py file as <code>__main__</code> module and defer to using that name <code>f1()</code>?</p>
<p>2) Do you think large projects will create complexity, Because the test cases written must make sure each <code>name</code> is used for testing before it goes for production?</p>
</div>
<div class="post-text" itemprop="text">
<p>Consider this example:</p>
<pre><code>def f1():
   name = raw_input()
   exec "def {}(): print 'I am a function'".format(name)
   f2()
</code></pre>
<p>If a user enters <code>"f2"</code> when prompted, then <code>f2()</code> will execute correctly, but not otherwise.</p>
<p>This is a perfectly legal python program, and the line <code>f2()</code> may or may not execute correctly, dependent completely on user input. So python <em>cannot</em> determine at module load time whether execution of this code will result in a name error or not.</p>
<hr/>
<p>Addressing some additional confusion:</p>
<p>It might seem that python does sometimes do static name-checking. Ie, if we have <code>file1.py</code>:</p>
<pre><code>def foo():
    print x1
</code></pre>
<p>and you do <code>python file1.py</code>, no error will be printed. The function <code>foo</code> has been defined, but not run. We could also do <code>python -i file1.py</code>, which will open up an interpreter. If in the interpreter we then type <code>foo()</code>, <em>now</em> the code will run, and we'll get the lookup error for <code>x1</code>.</p>
<p>Consider a second file <code>file2.py</code>:</p>
<pre><code>print x1
</code></pre>
<p>Here, there is no function being defined. We're simply running a <code>print</code> statement at the top-level. Doing <code>python file2.py</code> will cause a lookup error for <code>x1</code>, since running <code>file2.py</code> constitutes actually running that print statement, as opposed to only defining a function that <em>would</em> run the print statement when called.</p>
<p>So it's not that python <em>sometimes</em> does static name-checking -- python will only throw a name error when code involving that name is actually run. It's just that when code gets run depends on where it is (in a function vs being top-level).</p>
</div>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/4937532/python-name-resolution-order-of-function-defs">Python: Name resolution; order of function def's</a></span>
<span class="comment-copy">dawg your existing query just telling you that python check name binding while calling it, which i already mentioned in query. But my question is why ptyhon interp does like this and impact on large projects</span>
<span class="comment-copy">Since you can bind names inside <code>if</code> blocks, Python can't know whether a particular name will be bound at some point in the code, unless it evaluates all possible combinations of every conditional beforehand. This quickly becomes intractable for programs that aren't trivially small.</span>
<span class="comment-copy">dawg i would request you to remove that heading above my query. Please let me know the reason why it is a duplicate query, here the discussion on the impact of large projects?</span>
<span class="comment-copy">@Kevin "intractable" technically undecidable even, no?</span>
<span class="comment-copy">Code like this is horrifying.</span>
<span class="comment-copy">@EricWilson Sure is, but if python wants to keep stuff like <code>exec</code> around, it means static-checking of modules in the way OP suggests is impossible. Also, I can imagine this having uses. I imagine <a href="https://docs.python.org/3/library/unittest.mock.html#the-patchers" rel="nofollow noreferrer">patching</a> might do something similar, for instance.</span>
<span class="comment-copy">@alecbenzer DO you think i need to every function like this when i write my application? as you mentioned in your proposed answer?</span>
<span class="comment-copy">@Sham Static checking would not be possible. The example in my answer might work even though there is no declaration of <code>f2</code> before its use (at least not one that python is aware of when it loads the module). So python would be incorrect in rejecting such a program.</span>
<span class="comment-copy">@Sham It won't. I think you're misunderstanding my answer. I'm not explaining how you can cause name errors to happen at module load time -- I'm giving you an example of a legal python program for which module load time name checking is <i>not possible</i>.</span>
