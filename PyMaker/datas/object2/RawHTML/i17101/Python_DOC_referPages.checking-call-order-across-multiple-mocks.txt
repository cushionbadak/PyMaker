<div class="post-text" itemprop="text">
<p>I have three functions that I'm trying to test the call order of.</p>
<p>Let's say that in module module.py I have the following</p>
<pre><code># module.py    

def a(*args):
    # do the first thing

def b(*args):
    # do a second thing

def c(*args):
    # do a third thing


def main_routine():
    a_args = ('a')
    b_args = ('b')
    c_args = ('c')

    a(*a_args)
    b(*b_args)
    c(*c_args)
</code></pre>
<p>I want to check that b is called after a, and before c. So getting a mock for each of a, b and c is easy:</p>
<pre><code># tests.py

@mock.patch('module.a')
@mock.patch('module.b')
@mock.patch('module.c')
def test_main_routine(c_mock, b_mock, a_mock):
    # test all the things here
</code></pre>
<p>Checking that each of the individial mocks are called is easy, too. How do I check the order of the calls relative to one another? </p>
<p><code>call_args_list</code> won't work as it's maintained separately for each mock.</p>
<p>I've tried using a side effect to log each of the calls:</p>
<pre><code>calls = []
def register_call(*args):
    calls.append(mock.call(*args))
    return mock.DEFAULT

a_mock.side_effect = register_call
b_mock.side_effect = register_call
c_mock.side_effect = register_call
</code></pre>
<p>But this only gives me the args that the mocks were called with, but not the actual mock that the call was made against. I can add a bit more logic:</p>
<pre><code># tests.py
from functools import partial

def register_call(*args, **kwargs):
    calls.append(kwargs.pop('caller', None), mock.call(*args, **kwargs))
    return mock.DEFAULT

a_mock.side_effect = partial(register_call, caller='a')
b_mock.side_effect = partial(register_call, caller='b')
c_mock.side_effect = partial(register_call, caller='c')
</code></pre>
<p>And that seems to get the job done... Is there a better way though? It feels like there should already be something in the API that can do this that I'm missing.</p>
</div>
<div class="post-text" itemprop="text">
<p>Define a <code>Mock</code> manager and attach mocks to it via <a href="http://www.voidspace.org.uk/python/mock/mock.html#mock.Mock.attach_mock"><code>attach_mock()</code></a>. Then check for the <code>mock_calls</code>:</p>
<pre><code>@patch('module.a')
@patch('module.b')
@patch('module.c')
def test_main_routine(c, b, a):
    manager = Mock()
    manager.attach_mock(a, 'a')
    manager.attach_mock(b, 'b')
    manager.attach_mock(c, 'c')

    module.main_routine()

    expected_calls = [call.a('a'), call.b('b'), call.c('c')]
    assert manager.mock_calls == expected_calls
</code></pre>
<p>Just to test that it works, change the order of function calls in the <code>main_routine()</code> function add see that it throws <code>AssertionError</code>.</p>
<p>See more examples at <a href="http://www.voidspace.org.uk/python/mock/examples.html#tracking-order-of-calls-and-less-verbose-call-assertions">Tracking order of calls and less verbose call assertions</a></p>
<p>Hope that helps.</p>
</div>
<div class="post-text" itemprop="text">
<p>I needed this answer today, but the example code in the question is really hard to read because the call args are the same as the names of the mocks on the manager <em>and</em> in the scope of the test. <a href="https://docs.python.org/3/library/unittest.mock.html#attaching-mocks-as-attributes" rel="nofollow noreferrer">Here's the official documentation on this concept</a>, and below is a clearer example for non-robots. All the modules I'm patching are made-up for the sake of the example:</p>
<pre><code>@patch('module.file_reader')
@patch('module.json_parser')
@patch('module.calculator')
def test_main_routine(mock_calculator, mock_json_parser, mock_file_reader):
    manager = Mock()

    # First argument is the mock to attach to the manager.
    # Second is the name for the field on the manager that holds the mock.
    manager.attach_mock(mock_file_reader, 'the_mock_file_reader')
    manager.attach_mock(mock_json_parser, 'the_mock_json_parser')
    manager.attach_mock(mock_calculator, 'the_mock_calculator')

    module.main_routine()

    expected_calls = [
        call.the_mock_file_reader('some file'),
        call.the_mock_json_parser('some json'),
        call.the_mock_calculator(1, 2)
    ]
    assert manager.mock_calls == expected_calls
</code></pre>
<p>Note that you have to use <code>attach_mock</code> in this case because your mocks were created by <code>patch</code>. Mocks with names, including those created by <code>patch</code>, must be attached via <code>attach_mock</code> for this code to work. You don't have to use <code>attach_mock</code> if you make your own <code>Mock</code> objects without names:</p>
<pre><code>def test_main_routine(mock_calculator, mock_json_parser, mock_file_reader):
    manager = Mock()

    mock_file_reader = Mock()
    mock_json_parser = Mock()
    mock_calculator = Mock()

    manager.the_mock_file_reader = mock_file_reader
    manager.the_mock_json_parser = mock_json_parser
    manager.the_mock_calculator = mock_calculator

    module.main_routine()

    expected_calls = [
        call.the_mock_file_reader('some file'),
        call.the_mock_json_parser('some json'),
        call.the_mock_calculator(1, 2)
    ]
    assert manager.mock_calls == expected_calls
</code></pre>
</div>
<span class="comment-copy">One important notice - do not set autospec=True inside patch(...). If you set autospec=True attach_mock do not wotk correctly. There are no autospec in your example but it often exists in real life test cases.</span>
<span class="comment-copy">This answer is faithful to the code in the question, but it's hard to read because there are no descriptive names. I'm adding an answer below that makes it clear how <code>attach_mocks</code> works.</span>
