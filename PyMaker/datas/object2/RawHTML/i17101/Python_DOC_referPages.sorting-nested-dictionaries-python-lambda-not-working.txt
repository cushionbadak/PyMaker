<div class="post-text" itemprop="text">
<p>I have a dictionary of dictionaries based on <code>{month:{id:value,id:value},month:{id:value,id:value}}</code> like this</p>
<pre><code>{9: {10: 1, 4113: 1, 533: 2, 4124: 2, 31: 1, 7713: 1, 12038: 1, 550: 3, 10794: 1, 15922: 1, 4671: 1, 65: 2, 4681: 1, 8789: 1, 1622: 1, 1116: 2, 605: 2, 8992: 1, 614: 2, 1639: 2, 17515: 1, 4883: 1}, 8: {4103: 1, 12298: 2, 19: 1, 4126: 1, 32: 2, 4129: 3, 6180: 1, 6192: 1, 51: 5, 52: 1, 53: 1, 58: 1}...etc
</code></pre>
<p>and I'm trying to sort the value so that I can print the highest values for each month like august(8) highest value for august... sept(9) highest value for sept.. and so on.</p>
<p>I tried using lambda like in many of the StackOverflow questions on this but it hasn't worked. I get a Key error .</p>
<pre><code>newlist9= sorted(aid2tagM.items(),key=lambda x: x[0][1], reverse=True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For the input you have given,</p>
<pre><code>[(month, sorted(data.items(), key=lambda x:-x[1])) for month, data in d.items()]
</code></pre>
<p>produces</p>
<pre><code>[(8,
  [(51, 5),
   (4129, 3),
   (12298, 2),
   (32, 2),
   (4103, 1),
   (19, 1),
   (4126, 1),
   (6180, 1),
   (6192, 1),
   (52, 1),
   (53, 1),
   (58, 1)]),
 (9,
  [(550, 3),
   (533, 2),
   (4124, 2),
   (65, 2),
   (1116, 2),
   (605, 2),
   (614, 2),
   (1639, 2),
   (12038, 1),
   (10, 1),
   (4113, 1),
   (4883, 1),
   (31, 1),
   (8992, 1),
   (7713, 1),
   (10794, 1),
   (15922, 1),
   (4671, 1),
   (4681, 1),
   (8789, 1),
   (1622, 1),
   (17515, 1)])]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It looks like you may be treating the dictionaries as lists in the lambda expression.  The term</p>
<pre><code>lambda x:x[0][1]
</code></pre>
<p>looks like a 2 dimensional list index.  However your data structure is nested dictionaries.  So unless you have a guaranteed entry for key 0 for every top level dictionary (assuming it is the month of year) and a guaranteed key 1 in every sub-level dictionary it will give you a key error.  A suggestion to try:</p>
<pre><code>for month in range(1,12+1):
    month_to_sort = aid2tagM[month]
    month_keys = month_to_sort.keys()   
    month_keys.sort(reverse=True)

    monthly_data_sorted_by_key = []
    for month_key in month_keys:
        print month,month_key,aid2tag[month][month_key]
        monthly_data_sorted_by_key.append([month_key,aid2tag[month][month_key]])
</code></pre>
<p>This will give you each month sorted by the keys of the nested dictionary.</p>
</div>
<span class="comment-copy">Why is your key function <code>lambda x: x[0][1]</code>?</span>
<span class="comment-copy">i dunno that's just what I tried from looking at other questions that had dictionaries similar to mine</span>
<span class="comment-copy">@user2601122 What is the expected output?</span>
<span class="comment-copy">Please read <a href="https://docs.python.org/2/library/functions.html#sorted" rel="nofollow noreferrer">the documentation for <code>sorted</code> in python 2</a> and <a href="https://docs.python.org/3/library/functions.html#sorted" rel="nofollow noreferrer">python 3</a> first before proceeding.</span>
<span class="comment-copy">@user2601122 Why don't you show us the expected output taking a short version of the input, just to be clear...</span>
<span class="comment-copy">ah thanks!so, why is it -x?</span>
<span class="comment-copy">@user2601122 Its a little trick ;) When you want to sort the numbers in descending order, instead of using <code>reverse=True</code>, you can simply negate the values. So, the highest number will become the smallest number, during comparison. For example, if you have <code>[2, 1, 3]</code>, during comparison the values will be considered as <code>[-2, -1, -3]</code>. Now, if you sort the values in ascending order, the values will become <code>[3, 2, 1]</code> :)</span>
<span class="comment-copy">Oh how cool! Well thank you :)</span>
