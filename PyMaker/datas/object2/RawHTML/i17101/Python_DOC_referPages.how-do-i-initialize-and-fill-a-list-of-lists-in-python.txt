<div class="post-text" itemprop="text">
<p>What I'm trying to do is sort word objects (which consist of a scanned word, its alphabetized version, and its length) into lists by their length. So, I initialized an list of length 0 and I am extending it as I'm going through my input file. What I want to do it to have a list within a list such that my results[5] contain a list of length 5. How do I do that?</p>
<p>I first initialize my list as follows:</p>
<pre><code>results = []
</code></pre>
<p>I then scan through the input file line by line creating temp objects and I want them to be be placed into their appropriate lists:</p>
<pre><code>try:    #check if there exists an array for that length
    results[lineLength]
except IndexError:  #if it doesn't, create it up to that length
    # Grow the list so that the new highest index is len(word)
    difference = len(results) - lineLength
    results.extend([] for _ in range(difference))
finally:
    results[lineLength].append(tempWordObject)  
</code></pre>
<p>I feel at least one of the following needs to be edited</p>
<p>(1) The way I initialize the results list
(2) The way I append objects to the list
(3) The way I'm extending the list (though I think that part is right) </p>
<p>I am using Python 3.4.  </p>
<p>EDIT:</p>
<pre><code>from sys import argv
main, filename = argv
file = open(filename)
for line in file:           #go through the file
    if line == '\n':        #if the line is empty (aka end of file), exit loop
        break
    lineLength = (len(line)-1)  #get the line length 
    line= line.strip('\r\n')

    if lineLength &gt; maxL:       #keeps track of length of longest word encountered
        maxL = lineLength

    #note: I've written a mergesort algorithm in a separate area in the code and it works 
    tempAZ = mergesort(line)    #mergesort the word into alphabetical order
    tempAZ = ''.join(tempAZ)    #merges the chars back together to form a string

    tempWordObject = word(line,tempAZ,lineLength) #creates a new word object

    try:    #check if there exists an array for that length
        results[lineLength]
    except IndexError:  #if it doesn't, create it up to that length
        # Grow the list so that the new highest index is len(word)
        difference = len(results) - lineLength
        results.extend([] for _ in range(difference))
        print("lineLength: ", lineLength, "    difference:", difference)
    finally:
        results[lineLength].append(tempWordObject)    
</code></pre>
<p>EDIT:</p>
<p>This is my word class:</p>
<pre><code>class word(object): #object class

    def __init__(self, originalWord=None, azWord=None, wLength=None):
        self.originalWord = originalWord
        self.azWord = azWord
        self.wLength = wLength
</code></pre>
<p>EDIT:</p>
<p>Here is a clarification of what I'm trying to achieve: As I'm iterating through a list (of unknown length) of words (also of unknown length), I am creating word objects that include the word, its alphabetized version, and its length (e.g. dog, dgo, 3). As I'm going through that list, I want all objects to go into a list that is within another list (results[]), indexed by the word's length. If results[] does not contain such an index (e.g. 3), I want to extend results[] and start a list in results[3] that contains the word object (dog, dgo, 3). At the end, results[] should contain lists of words indexed by their length. </p>
</div>
<div class="post-text" itemprop="text">
<p>Rather than a list, you could have a dictionary:</p>
<pre><code>d = {}
</code></pre>
<p>here the key would be length and the value a list of words:</p>
<pre><code>if linelength not in d:
    d[linelength] = []
d[linelength].append(tempWordObject)
</code></pre>
<p>You can simplify further with <a href="https://docs.python.org/2/library/collections.html#collections.defaultdict" rel="nofollow"><code>d = collections.defaultdict(list)</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your difference is negative. You need to subtract the other way round. You'll also need to add one extra since index starts at 0</p>
<pre><code>difference = lineLength - len(results) + 1
</code></pre>
<p>Turns out it's usually easier to use a <code>defaultdict</code> for this</p>
<p>eg:</p>
<pre><code>from collections import defaultdict
D = defaultdict(list)
for tempWordObject in the_file:
    D[len(tempWordObject)].append(tempWordObject)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Three notes on your questions.</p>
<ol>
<li><p>Nested list initialization</p>
<p>You mention it in your question title, although you might not need it in the end. One simple way to do this is to use two nested <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow">list comprehensions</a>:</p>
<pre><code>import pprint

m, n = 3, 4  # 2D: 3 rows, 4 columns
lol = [[(j, i) for i in range(n)] for j in range(m)]

pprint.pprint(lol)
# [[(0, 0), (0, 1), (0, 2), (0, 3)],
#  [(1, 0), (1, 1), (1, 2), (1, 3)],
#  [(2, 0), (2, 1), (2, 2), (2, 3)]]
</code></pre></li>
<li><p>Using some default data structure</p>
<p>As others pointed out, you could use a dictionary. In particular, a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow"><code>collections.defaultdict</code></a> will give you initialization-on-demand:</p>
<pre><code>import collections

dd = collections.defaultdict(list)

for value in range(10):
    dd[value % 3].append(value)

pprint.pprint(dd)
# defaultdict(&lt;type 'list'&gt;, {0: [0, 3, 6, 9], 1: [1, 4, 7], 2: [2, 5, 8]})
</code></pre></li>
<li><p>Comparing custom objects</p>
<p>The built-in <a href="https://docs.python.org/3/library/functions.html#sorted" rel="nofollow"><code>sorted</code></a> function takes a keyword argument <code>key</code>, that can be used to compare custom object, that do not themselves provide sorting hooks:</p>
<pre><code>import operator

class Thing:
    def __init__(self, word):
        self.word = word
        self.length = len(word)

    def __repr__(self):
        return '&lt;Word %s&gt;' % self.word

things = [Thing('the'), Thing('me'), Thing('them'), Thing('anybody')]
print(sorted(things, key=lambda obj: obj.length))
# [&lt;Word me&gt;, &lt;Word the&gt;, &lt;Word them&gt;, &lt;Word anybody&gt;] 
</code></pre></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>If you're set on using a list (which may not be the best choice), I think it would be easier and more clear to create the list as big as it needs to be from the get go.  That is to say, if the longest word is 5 characters long, you start by creating this list:</p>
<pre><code>output = [None, [], [], [], [], []]
</code></pre>
<p>This has the advantage that you won't have to worry about catching exceptions as you go but it does require that you know all your words before you start.  Since you created an object class to store all this, I'm assuming you're actually storing all this so it shouldn't be an issue.</p>
<p>You'll always need the <code>None</code> at the beginning so the indices match up.  Once you have this you can iterate through your list of words and simply append it to the appropriate list as you already do.</p>
<pre><code>for word in wordlist:
    output[len(word)].append(word)
</code></pre>
<hr/>
<p>So specifically for you, what I would do is instead of storing <code>tempWordObject</code>, I'd make a list (<code>wordObjList</code>) of these objects as you work through your file.  Once you're done with the file, close the handle, then proceed to do the rest of you processing.  </p>
<p>Generate the template list:</p>
<pre><code>output = [None]
for i in range(maxLen):
    output.append([])
</code></pre>
<p>Fill the list from your list of <code>word</code> obejcts</p>
<pre><code>for wordObj in wordObjList:
    output[wordObj.wLength].append(wordObj.originalWord)
</code></pre>
<hr/>
<p>Some other things to note:</p>
<ul>
<li><p>You don't need to handle hitting the end of the file.  When Python reaches the end of the file in the <code>for</code> loop, it will automatically stop iterating</p></li>
<li><p>Always make sure you close your files.  You can you the <code>with</code> construction to do this (<code>with open("file.txt", 'r') as f:  for line in f:</code>)</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You refused to accept answers proposed to store your objects in dictionaries. However your real problem is that you want to put your 6mil of words containing scanned images into your memory. Use indexing (or some kind of simple references) and track them into your structure, then lookup for your data based on them. Use iterators to retrieve the info you need.</p>
</div>
<span class="comment-copy">Can you give an example of your starting point? Its a little unclear what you mean</span>
<span class="comment-copy">Having a quick peek at your code, you won't handle rows of the same length. Also what is <code>tempWordObject</code>? You got broken code.</span>
<span class="comment-copy">@wnnmaw I've edited my post and it now includes the rest of the code. Does that make more sense?</span>
<span class="comment-copy">@Michi perhaps you could be clearer about exactly what your problem is, and what your constraints are. You may find <a href="http://stackoverflow.com/questions/22388866/python-list-set-value-at-index-if-index-does-not-exist/22389330#22389330">this</a> useful.</span>
<span class="comment-copy">@Michi 1. edit the question, don't just comment 2. that's fine, but <i>what's the problem</i>? Are you getting errors? Unexpected outputs? If the code works but you think it could be neater, this belongs on <a href="http://codereview.stackexchange.com">codereview.stackexchange.com</a></span>
<span class="comment-copy">I can't use a dictionary for the purposes of this assignment. Also, it leads to overflow errors when I input a file with 6mil words.</span>
<span class="comment-copy">overflow errors? really?? how much RAM do you have?</span>
<span class="comment-copy">@gnibbler Even when allocating 1GB in Eclipse it crashes. Haven't tried running it through terminal. I have 8GB overall though. Either way, I'm not allowed to use defaultdict.</span>
<span class="comment-copy">Yes, I know, but I'm not allowed to use it for this assignment. I am looking for a way to make my current code work. EDIT: also, defaultdict doesn't work for my larger input file, containing about 6mil words.</span>
<span class="comment-copy">@Michi, ok I edited my answer to help your problem.</span>
<span class="comment-copy">Thanks, I figured I was doing some bad math there - it's too early in the morning!</span>
<span class="comment-copy">The purpose of this assignment is (1) to be as efficient as possible and (2) to write my own sorting algorithms. I can't use defaultdict nor in-built sorting functions. Is it possible for me to create a list without knowing the number of words nor the longest word length in advance?</span>
<span class="comment-copy">I see. I guess <code>defaultdict</code> just saves you some time and would not be considered cheating, whereas if your task is to write a sorting algorithm, you obviously would not want to use <code>sorted</code>. However, given you problem description, I would say that a dictionary would suite your particular task, since (a) you do not know the length of the longest word in advance and (b) all you want to do is to insert (which is amortized O(1) for dicts) and iterate over all keys. Seems like a job for a dictionary to me.</span>
<span class="comment-copy">defaultdict is considered cheating, actually, I've asked and I'm not allowed to use it.</span>
<span class="comment-copy">Ok, sorry about that. If I would give the assignments I'd allow it ;) - because it really does nothing fancy; it just makes the code more concise.</span>
<span class="comment-copy">yep, sadly that's not an option for me</span>
<span class="comment-copy">This seems like the best solution. One problem though: I feel like it's inefficient to go through the entire input file first in order to get the max length for words. Is there a way to get around that? It takes a long while to scan through the 6mil word input file.</span>
<span class="comment-copy">It's obviously missing the point of this exercise. It's also sloppy - how do you know how long the longest word is in advance? Better to program defensively</span>
<span class="comment-copy">@gnibbler As I said, I could scan through the entire file first and find the longest word, but that seems like a waste of time. Do you know if it's possible to dynamically extend a list of lists?</span>
<span class="comment-copy">@Michi, it looks like you already keep track of hte longest word you've found with <code>maxLen</code></span>
<span class="comment-copy">@wnnmaw That was part of my old code for testing purposes, sorry for the confusion. I would need to go through the list twice in order to actually use that value and I'm trying to avoid that.</span>
<span class="comment-copy">Can you please explain what you mean by indexing?</span>
<span class="comment-copy">I would give 0 for the first word which came up, 1 for the second, etc. I would also manage a CSV file or a custom data file which contains the data for my words, line 1 for the first word, line 2 for the second one, etc. In fact, to make data retrieving faster, I would use <code>(word_lenght, index)</code> tuples and lenghtNN.csv files.</span>
<span class="comment-copy">I'm trying to avoid writing to a file because that would increase my running time, but I have considered it. I might do that if it leads to memory issues again. Thank you for the clarification.</span>
<span class="comment-copy">Welcome! Well, at least keep the scanned data separate. Maybe the rest can fit in your memory stored in the word objects. Those objects should only store the paths to the scanned data.</span>
<span class="comment-copy">Do you mean like with pointers? I'm not sure how to do this.</span>
