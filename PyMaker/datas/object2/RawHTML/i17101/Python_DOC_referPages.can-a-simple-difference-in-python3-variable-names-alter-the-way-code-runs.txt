<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/18058730/python-attributeerror-on-del">Python attributeError on __del__</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>This code...</p>
<pre><code>class Person:
    num_of_people = 0

    def __init__(self, name):
        self.name = name
        Person.num_of_people += 1

    def __del__(self):
        Person.num_of_people -= 1

    def __str__(self):
        return 'Hello, my name is ' + self.name

cb = Person('Corey')
kb = Person('Katie')
v = Person('Val')
</code></pre>
<p>Produces the following error...</p>
<pre><code>Exception AttributeError: "'NoneType' object has no attribute 'num_of_people'" in &lt;bound method Person.__del__ of &lt;__main__.Person object at 0x7f5593632590&gt;&gt; ignored
</code></pre>
<p>But this code does not.</p>
<pre><code>class Person:
    num_of_people = 0

    def __init__(self, name):
        self.name = name
        Person.num_of_people += 1

    def __del__(self):
        Person.num_of_people -= 1

    def __str__(self):
        return 'Hello, my name is ' + self.name

cb = Person('Corey')
kb = Person('Katie')
vb = Person('Val')
</code></pre>
<p>The only difference I see is the last variable name is "vb" vs. "v".</p>
<p>I am leaning Python and am working on the OOP stuff now.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, although it is not the so much the variable name that causes this, not directly.</p>
<p>When Python exits, all modules are deleted too. The way modules are cleaned up is by setting all globals in a module to <code>None</code> (so those references no longer refer to the original objects). Those globals are keys in a dictionary object, and as dictionaries are ordered arbitrarily, renaming one variable can change the order in which variables are cleared.</p>
<p>When you renamed <code>v</code> to <code>vb</code>, you altered the order in which variables are cleared, and now <code>Person</code> is cleared last.</p>
<p>One work-around is to use <code>type(self).num_of_people -= 1</code> in the <code>__del__</code> method instead:</p>
<pre><code>def __del__(self):
    type(self).num_of_people -= 1
</code></pre>
<p>because the instance will always have a reference to the class still, or test if <code>Person</code> is not set to <code>None</code>:</p>
<pre><code>def __del__(self):
    if Person is not None:
        Person.num_of_people -= 1
</code></pre>
<p>Two notes:</p>
<ul>
<li><p>CPython 3.4 no longer sets globals to <code>None</code> (in most cases), as per <a href="https://docs.python.org/3/whatsnew/3.4.html#whatsnew-pep-442" rel="nofollow">Safe Object Finalization</a>; see <a href="http://www.python.org/dev/peps/pep-0442/" rel="nofollow">PEP 442</a>.</p></li>
<li><p>CPython 3.3 automatically applies a <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow">randomized hash salt</a> to the <code>str</code> keys used in a <code>globals</code> dictionary; this makes the behaviour you observed even more random, merely re-running your code several times may or may not trigger the error message.</p></li>
</ul>
</div>
<span class="comment-copy">@StevenRumbalski: In short, yes. But only at interpreter exit.</span>
<span class="comment-copy">The first code does not produce that exception. Show your full traceback. (Correction: it doesn't produce that exception in Python 3.3 or higher. In 3.2 it does.)</span>
<span class="comment-copy">@Wooble Nah! That's what i was missing..</span>
<span class="comment-copy">@Wooble: That's because dictionary hashing for strings is randomized in 3.3. It'll happen in 3.3 too, when the stars align just right for the keys to collide in the right order. In other words, re-run your test several times and you'll see it happen on <b>some</b> runs.</span>
<span class="comment-copy">@Wooble: Last but not least, you certainly won't see this error in CPython 3.4, as it has a new <a href="https://docs.python.org/3/whatsnew/3.4.html#whatsnew-pep-442" rel="nofollow noreferrer">safe object finalization codepath</a> that removes the reason for this error altogether.</span>
<span class="comment-copy">Ugh.. The answer is brilliant, but I don't really understand this. What do you mean by 'on intepreter exit'? Can you please explain?</span>
<span class="comment-copy">@aIKid: When Python exits, (or if you delete the module by removing all references to it and deleting it from <code>sys.modules</code>, but that's not often done), the module <code>__del__</code> is called, which then proceeds by first clearing all globals in the module by rebinding their names to <code>None</code>.</span>
<span class="comment-copy">@aIKid: this should only happen when you exit the interpreter, <i>or</i> you delete the module explicitly.</span>
<span class="comment-copy">@Corey: there isn't really a higher level here; the bottom line is that during finalization, globals like <code>Person</code> and <code>v</code> and <code>vb</code> have <code>None</code> assigned to them, so you cannot count on <code>Person</code> being the class still in <code>__del__</code>.</span>
<span class="comment-copy">@sds: finalization is finicky; by setting globals to <code>None</code> many common circular references are broken properly without invoking (slow and entirely unneeded) resizes of the <code>globals</code> dictionaries. The finally did find a better way for Python 3.4, so this whole thing is no longer a problem with that version.</span>
