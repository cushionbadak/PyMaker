<div class="post-text" itemprop="text">
<p>I am trying to split a string on multiple characters in python just like I am doing in Java like this:</p>
<pre><code>private static final String SPECIAL_CHARACTERS_REGEX = "[ :;'?=()!\\[\\]-]+|(?&lt;=\\d)(?=\\D)";
String rawMessage = "let's meet tomorrow at 9:30p? 7-8pm? i=you go (no Go!) [to do !]";
String[] tokens = rawMessage.split(SPECIAL_CHARACTERS_REGEX);
System.out.println(Arrays.toString(tokens));
</code></pre>
<p>Here is the working demo with the correct output: <a href="http://ideone.com/BuiNRM" rel="nofollow">Working Demo</a></p>
<p>I am trying to do exactly the same in python, but when I am doing that it would not tokenize at all if I just add the 'single quotes' character in the regex. How do I create the same resultant parse results from python as from Java program above?</p>
<p>This:</p>
<pre><code>import re
tokens = re.split(' \.', line);
print tokens
</code></pre>
<p>For line:</p>
<pre><code>"let's meet tomorrow at 9:30p? 7-8pm? i=you go (no Go!) [to do !]"
</code></pre>
<p>Gives:</p>
<pre><code>["let's meet tomorrow at 9:30p? 7-8pm? i=you go (no Go!) [to do !]";]
</code></pre>
<p>When I was it to do this:</p>
<pre><code>[let, s, meet, tomorrow, at, 9, 30, p, 7, 8, pm, i, you, go, no, Go, to, do]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's an alternative that <em>finds</em> rather than splits:</p>
<pre><code>&gt;&gt;&gt; s = "let's meet tomorrow at 9:30p? 7-8pm? i=you go (no Go!) [to do !]"
&gt;&gt;&gt; re.findall(r'\d+|[A-Za-z]+', s)
['let', 's', 'meet', 'tomorrow', 'at', '9', '30', 'p', '7', '8', 'pm', 'i', 'you', 'go', 'no', 'Go', 'to', 'do']
</code></pre>
<p>If it is ok to keep letters and numbers together use <code>'[0-9A-Za-z]+'</code>.  For letters, numbers, and underscore use <code>r'\w+'</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the same regular expression you used in Java:</p>
<pre><code>line = "let's meet tomorrow at 9:30p? 7-8pm? i=you go (no Go!) [to do !]"
tokens = re.split("[ :;'?=()!\\[\\]-]+|(?&lt;=\\d)(?=\\D)", line)
tokens = [token for token in tokens if len(token) != 0] # remove empty strings!
print(tokens)
# ['let', 's', 'meet', 'tomorrow', 'at', '9', '30p', '7', '8pm', 'i', 'you', 'go', 'no', 'Go', 'to', 'do']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the following code</p>
<pre><code>&gt;&gt;&gt; chars = "[:;'?=()!\-]+&lt;" #Characters to remove
&gt;&gt;&gt; sentence = "let's meet tomorrow at 9:30p? 7-8pm? i=you go (no Go!) [to do !]" #Sentence
&gt;&gt;&gt; for k in sentence: #Loops over everything in the sentence
...     if k in chars: #Checks if the variable is one we want to remove
...             sentence = sentence.replace(k, ' ') #If it is, it replaces it
...
&gt;&gt;&gt; sentence = sentence.replace('p', ' p').replace('pm', ' pm').split() #Adds a space before the 'p' and the 'pm', and then splits it the way we want to
&gt;&gt;&gt; sentence
['let', 's', 'meet', 'tomorrow', 'at', '9', '30', 'p', '7', '8', 'pm', 'i', 'you', 'go', 'no', 'Go', 'to', 'do']
</code></pre>
<p>If you want to use <code>regex</code>:</p>
<pre><code>line = "let's meet tomorrow at 9:30p? 7-8pm? i=you go (no Go!) [to do !]"
tokens = re.split("[ :;'?=()!\\[\\]-]+|(?&lt;=\\d)(?=\\D)", line)
tokens = [token for token in tokens if len(token) != 0]
tokens = tokens.replace('p', ' p').replace('pm', ' pm').split()
print(tokens)
#['let', 's', 'meet', 'tomorrow', 'at', '9', '30', 'p', '7', '8', 'pm', 'i', 'you', 'go', 'no', 'Go', 'to', 'do']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>That split regex in Java should have worked the same in Python.<br/>
Its probably a bug. The confusion would probably be the overlap<br/>
between <code>\D</code> and <code>[ :;'?=()!\[\]-]</code>, and how it handles that (bug~).  </p>
<p>You could try to solve it by putting <code>(?&lt;=\d)(?=\D)</code> first, but it<br/>
has to be coerced to do that.  </p>
<p>This regex here forces it to do that. Is this a workaround?<br/>
I don't know, don't have python to test with. But, it works in Perl.  </p>
<p>Coerced regex -  </p>
<pre><code> #  (?&lt;=\d)(?:[ :;'?=()!\[\]-]+|(?=\D))|(?&lt;!\d|[ :;'?=()!\[\]-])[ :;'?=()!\[\]-]+

    (?&lt;= \d )
    (?:
         [ :;'?=()!\[\]-]+ 
      |  (?= \D )
    )
 |  
    (?&lt;! \d | [ :;'?=()!\[\]-] )
    [ :;'?=()!\[\]-]+ 
</code></pre>
</div>
<span class="comment-copy">why would it remove the <code>'p'</code> and the <code>'pm'</code>?</span>
<span class="comment-copy">+1 You might want to quote this from the <a href="https://docs.python.org/3/library/re.html#re.split" rel="nofollow noreferrer">docs</a>: "Note that <code>split</code> will never split a string on an empty pattern match" (hence why it is not splitting on <code>(?&lt;=\d)(?=\D)</code>).</span>
<span class="comment-copy">@Jerry:  Are you sure you meant this comment for my answer?</span>
<span class="comment-copy">Yup. Using <code>split</code> is not the ideal solution here and I believe that, with what's given, it's safe to assume that OP's only looking for alphanumeric characters.</span>
<span class="comment-copy">doesn't work, the 'p' and 'pm' are still attached to something else.</span>
<span class="comment-copy">Yes, the 8 and pm are still attached. Suggestions?</span>
<span class="comment-copy">Look at my answer</span>
<span class="comment-copy"><code>tokens = [token for token in tokens if token]</code> is slightly more idiomatic way of filtering.  (I would probably dispense with the meaningful name as well <code>tokens = [s for s in tokens if s]</code>).  Less Pythonic would be <code>tokens = filter(None, tokens)</code>.</span>
<span class="comment-copy">sure, but I thought I could use some smart regex to avoid having to iterate over a list. Besides, if "p" or "pm" is part of a word like "apt", it will turn it into "a pt" which is not correct.</span>
<span class="comment-copy">check my most recent edit</span>
<span class="comment-copy">Algorithmic complexity here is quadratic.  This has the potential to be quite inefficient.</span>
