<div class="post-text" itemprop="text">
<p>I want to get all logging output with mock. I searched, but
only found ways to mock explicitly logging.info or logging.warn.</p>
<p>I need all output, whatever logging level was set. </p>
<pre><code>def test_foo():

   def my_log(...):
      logs.append(...)

   with mock.patch('logging.???', my_log):
        ...
</code></pre>
<p>In our libraries we use this:</p>
<pre><code>import logging
logger=logging.getLogger(__name__)

def foo():
    logger.info(...)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>stdlib</h1>
<p>Since Python 3.4 the batteries' <code>unittest</code> has <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertLogs" rel="nofollow noreferrer"><code>assertLogs</code></a>. When used without <code>logger</code> and <code>level</code> arguments, it catches all logging (suppresses existing handlers). You can later access recorded entries from the context manager's <code>records</code> attribute. Text output strings are stored in <code>output</code> list.</p>
<pre><code>import logging
import unittest


class TestLogging(unittest.TestCase):

    def test(self):
        with self.assertLogs() as ctx:
            logging.getLogger('foo').info('message from foo')
            logging.getLogger('bar').info('message from bar')
        print(ctx.records)
</code></pre>
<h1>Tornado</h1>
<p>For Python 2 I usually take Tornado's <a href="http://www.tornadoweb.org/en/stable/testing.html#tornado.testing.ExpectLog" rel="nofollow noreferrer"><code>ExpectLog</code></a>. It's self-contained and works for normal Python code. It's actually more elegant solution then stdlib's, because instead of several class, <code>ExpectLog</code> is just a normal <a href="https://docs.python.org/3/library/logging.html#logging.Filter" rel="nofollow noreferrer"><code>logging.Filter</code></a> (a class, <a href="https://github.com/tornadoweb/tornado/blob/6682d58bf2/tornado/testing.py#L555" rel="nofollow noreferrer">source</a>). But it lacks a couple of features, including access to recorded entries, so usually I also extend it a bit, like:</p>
<pre><code>class ExpectLog(logging.Filter):

    def __init__(self, logger, regex, required=True, level=None):
        if isinstance(logger, basestring):
            logger = logging.getLogger(logger)
        self.logger = logger
        self.orig_level = self.logger.level
        self.level = level
        self.regex = re.compile(regex)
        self.formatter = logging.Formatter()
        self.required = required
        self.matched = []
        self.logged_stack = False

    def filter(self, record):
        if record.exc_info:
            self.logged_stack = True
        message = self.formatter.format(record)
        if self.regex.search(message):
            self.matched.append(record)
            return False
        return True

    def __enter__(self):
        self.logger.addFilter(self)
        if self.level:
            self.logger.setLevel(self.level)
        return self

    def __exit__(self, typ, value, tb):
        self.logger.removeFilter(self)
        if self.level:
            self.logger.setLevel(self.orig_level)
        if not typ and self.required and not self.matched:
            raise Exception("did not get expected log message")
</code></pre>
<p>Then you can have something like:</p>
<pre><code>class TestLogging(unittest.TestCase):

    def testTornadoself):
        logging.basicConfig(level = logging.INFO)

        with ExpectLog('foo', '.*', required = False) as ctxFoo:
            with ExpectLog('bar', '.*', required = False) as ctxBar:
                logging.getLogger('foo').info('message from foo')
                logging.getLogger('bar').info('message from bar')
        print(ctxFoo.matched)
        print(ctxBar.matched)
</code></pre>
<p>However, note that for the filter approach current logging level is important (can be overridden with <code>level</code> argument), and also you need a filter per logger of interest. You can follow the approach and make something that fits your case better.</p>
<h1>Update</h1>
<p>Alternatively there's <a href="https://pypi.python.org/pypi/unittest2" rel="nofollow noreferrer">unittest2</a> backport for Python 2 which has <code>assertLogs</code>.</p>
</div>
<div class="post-text" itemprop="text">
<h2><code>pytest</code></h2>
<p>If you are writing your tests using <code>pytest</code>, take a look at a neat fixture named <code>caplog</code> that will capture log records for you. It captures all the emitted log records which you can then access via <code>caplog.records</code> list. Each element is an instance of <code>logging.LogRecord</code>, so you can easily access any of the <a href="https://docs.python.org/3/library/logging.html#logrecord-attributes" rel="nofollow noreferrer"><code>LogRecord</code>s attributes</a>. Example:</p>
<pre class="lang-python prettyprint-override"><code># spam.py

import logging
logger=logging.getLogger(__name__)

def foo():
    logger.info('bar')


# tests.py

import logging
from spam import foo

def test_foo(caplog):
    foo()
    assert len(caplog.records) == 1
    record = next(iter(caplog.records))
    assert record.message == 'bar'
    assert record.levelno == logging.INFO
    assert record.module == 'spam'
    # etc
</code></pre>
<h3>Install</h3>
<p>The fixture was first introduced in a <code>pytest</code> plugin named <code>pytest-capturelog</code> which is now abandoned. Luckily, it got a decent fork named <code>pytest-catchlog</code>, <a href="https://docs.pytest.org/en/latest/changelog.html#pytest-3-3-0-2017-11-23" rel="nofollow noreferrer">which has been merged into <code>pytest==3.3.0</code></a> recently. So, if you use a recent version of <code>pytest</code>, you are already good to go; for older versions of <code>pytest</code>, <a href="https://pypi.python.org/pypi/pytest-catchlog/" rel="nofollow noreferrer">install <code>pytest-catchlog</code> from PyPI</a>.</p>
<h3>Docs</h3>
<p>At the moment, <code>pytest</code> doesn't provide any docs for the <code>caplog</code> fixture (or at least I couldn't find any), so you can refer to <code>pytest-catchlog</code>'s <a href="https://pypi.python.org/pypi/pytest-catchlog/" rel="nofollow noreferrer">documentation</a>.</p>
<h2>Plain <code>unittest</code></h2>
<p>If <code>pytest</code> is not an option, I wouldn't patch <code>logging</code> at all - you can simply add a custom handler instead that will record all the incoming logs. A small example:</p>
<pre><code># utils.py

import logging


class RecordsCollector(logging.Handler):

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.records = []

    def emit(self, record):
        self.records.append(record)


# tests.py

import logging
import unittest
from utils import RecordsCollector
from spam import foo


class SpamTests(unittest.TestCase):

    def setUp(self):
        self.collector = RecordsCollector()
        logging.getLogger('spam').addHandler(self.collector)

    def tearDown(self):
        logging.getLogger('spam').removeHandler(self.collector)

    def test_foo(self):
        foo()
        # same checks as in the example above
        self.assertEqual(len(self.collector.records), 1)
        record = next(iter(self.collector.records))
        self.assertEqual(record.message, 'bar')
        self.assertEqual(record.levelno, logging.INFO)
        self.assertEqual(record.module, 'spam')


if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>You can then extend the custom handler and implement any logic you need, like collecting the records in a <code>dict</code> that maps log levels to lists of records, or add a <code>contextmanager</code> implementation, so you can start and stop capturing records inside the test:</p>
<pre><code>from contextlib import contextmanager

@contextmanager
def record_logs():
    collector = RecordsCollector()
    logging.getLogger('spam').addHandler(collector)
    yield collector
    logging.getLogger('spam').removeHandler(collector)


def test_foo(self):
    with utils.record_logs() as collector:
        foo()
        self.assertEqual(len(collector.records), 1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I found this solution:</p>
<pre><code>def test_foo(self):

    logs=[]

    def my_log(self, *args, **kwargs):
        logs.append((args, kwargs))

    with mock.patch('logging.Logger._log', my_log):
        ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The module testfixtures has a class to handle this:</p>
<pre><code>&gt;&gt;&gt; import logging
&gt;&gt;&gt; from testfixtures import LogCapture
&gt;&gt;&gt; with LogCapture() as l:
...     logger = logging.getLogger()
...     logger.info('a message')
...     logger.error('an error')

&gt;&gt;&gt; l.check(
...     ('root', 'INFO', 'a message'),
...     ('root', 'ERROR', 'another error'),
...     )
Traceback (most recent call last):
 ...
AssertionError: sequence not as expected:

same:
(('root', 'INFO', 'a message'),)

expected:
(('root', 'ERROR', 'another error'),)

actual:
(('root', 'ERROR', 'an error'),)
</code></pre>
<p>Source: <a href="http://testfixtures.readthedocs.io/en/latest/logging.html" rel="nofollow noreferrer">http://testfixtures.readthedocs.io/en/latest/logging.html</a></p>
</div>
<span class="comment-copy">I like the stdlib solution the most. Up to now I am still fixed on Python 2.7 but sooner or later we will be there. Thank you for your answer.</span>
<span class="comment-copy">Updated the answer with a reference to unittest2 backport, so you use the same approach throughout.</span>
<span class="comment-copy">nice, a backport. Yes, we still use Python2.7.  I ask myself why there are so many choices in the Python world. Sometimes this is great, sometimes confusing :-) In this case: unittest2 vs pytest.</span>
<span class="comment-copy">Good news! Up to now I use an older version, but this is reason to upgrade. Thank you for this answer.</span>
<span class="comment-copy">Glad I could help! I also added a solution proposal for the <code>unittest</code>-tests, for the sake of completeness. Although the proposal mostly mimics the <code>caplog</code> fixture implementation...</span>
<span class="comment-copy">I think this solution is too complicated.</span>
