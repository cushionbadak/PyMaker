<div class="post-text" itemprop="text">
<p>I have multiple tests run by py.test that are located in multiple classes in multiple files.  </p>
<p>What is the simplest way to share a large dictionary - which I do not want to duplicate - with every method of every class in every file to be used by py.test? </p>
<p>In short, I need to make a "global variable" for every test. Outside of py.test, I have no use for this variable, so I don't want to store it in the files being tested. I made frequent use of py.test's fixtures, but this seems overkill for this need.  Maybe it's the only way?</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Update: scroll down to a better approach.</strong></p>
<p>Aside from a better pytest-specific option suggested by @flub, you can create a base <code>TestCase</code> class, define a class variable and subclass the base class in every test you have:</p>
<pre><code>import unittest


class BaseTestCase(unittest.TestCase):
    my_dict = {'hello': 'world'}


class TestCase1(BaseTestCase):
    def test_my_dict_key(self):
        self.assertTrue('hello' in self.my_dict)


class TestCase2(BaseTestCase):
    def test_my_dict_value(self):
        self.assertTrue('world' in self.my_dict.values())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Update: <a href="https://docs.pytest.org/en/latest/deprecations.html?highlight=pytest-namespace#pytest-namespace" rel="nofollow noreferrer">pytest-namespace hook is deprecated/removed</a>. Do not use.</strong> See <a href="https://github.com/pytest-dev/pytest/pull/3735/files" rel="nofollow noreferrer">#3735</a> for details.</p>
<p>You mention the obvious and least magical option: using a fixture.  You can apply it to entire modules using <code>pytestmark = pytest.mark.usefixtures('big_dict')</code> in your module, but then it won't be in your namespace so explicitly requesting it might be best.</p>
<p>Alternatively you can assign things into the pytest namespace using the hook:</p>
<pre><code># conftest.py

def pytest_namespace():
    return {'my_big_dict': {'foo': 'bar'}}
</code></pre>
<p>And now you have <code>pytest.my_big_dict</code>. The fixture is probably still nicer though.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are tons of things I love about py.test, but one thing I absolutely HATE is how poorly it plays with code intelligence tools. I disagree that an autouse fixture to <em>declare</em> a variable is the "most clear" method in this case because not only does it completely baffle my linter, but also anyone else who is not familiar with how py.test works. There is a lot of magic there, imo.</p>
<p>So, one thing you can do that doesn't make your linter explode and doesn't require TestCase boilerplate is to create a module called globals. Inside this module, stub the names of the things you want global to {} or None and import the global module into your tests. Then in your conftest.py file, use the py.test hooks to set (or reset) your global variable(s) as appropriate. This has the advantage of giving you the stub to work with when building tests and the full data for the tests at runtime.</p>
<p>For example, you can use the <code>pytest_configure()</code> hook to set your dict right when py.test starts up. Or, if you wanted to make sure the data was pristine between each test, you could autouse a fixture to assign your global variable to your known state before each test.</p>
<pre><code># globals.py
my_data = {}  # Create a stub for your variable


# test_module.py
import globals as gbl

def test_foo():
    assert gbl.my_data['foo'] == 'bar'  # The global is in the namespace when creating tests


# conftest.py
import globals as gbl
my_data = {'foo': 'bar'}  # Create the master copy in conftest

@pytest.fixture(autouse=True)
def populate_globals():
    gbl.my_data = my_data  # Assign the master value to the global before each test
</code></pre>
<p>One other advantage to this approach is you can use type hinting in your globals module to give you code completion on the global objects in your test, which probably isn't necessary for a dict but I find it handy when I am using an object (such as webdriver). :)</p>
</div>
<div class="post-text" itemprop="text">
<p>Having a big dictionary of globals that every test uses is probably a bad idea. If possible, I suggest refactoring your tests to avoid this sort of thing.</p>
<p>That said, here is how I would do it: define an <a href="https://pytest.org/latest/fixture.html#autouse-fixtures-xunit-setup-on-steroids" rel="noreferrer">autouse fixture</a> that adds a reference to the dictionary in the global namespace of every function.</p>
<p>Here is some code. It's all in the same file, but you can move the fixture out to <code>conftest.py</code> at the top level of your tests.</p>
<pre><code>import pytest

my_big_global = {'key': 'value'}

@pytest.fixture(autouse=True)
def myglobal(request):
    request.function.func_globals['foo'] = my_big_global

def test_foo():
    assert foo['key'] == 'value'

def test_bar():
    assert foo['key'] == 'bar'
</code></pre>
<p>Here is the output from when I run this code:</p>
<pre><code>$ py.test test_global.py -vv
======================================= test session starts =======================================
platform darwin -- Python 2.7.5 -- py-1.4.20 -- pytest-2.5.2 -- env/bin/python
collected 2 items

test_global.py:9: test_foo PASSED
test_global.py:12: test_bar FAILED

============================================ FAILURES =============================================
____________________________________________ test_bar _____________________________________________

    def test_bar():
&gt;       assert foo['key'] == 'bar'
E       assert 'value' == 'bar'
E         - value
E         + bar

test_global.py:13: AssertionError
=============================== 1 failed, 1 passed in 0.01 seconds ===============================
</code></pre>
<p>Note that you can't use a session-scoped fixture because then you don't have access to each function object. Because of this, I'm making sure to define my big global dictionary once and use references to it -- if I defined the dictionary in that assignment statement, a new copy would be made each time.</p>
<p>In closing, doing anything like this is probably a bad idea. Good luck though :)</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm suprised no answer mentioned caching yet: since version 2.8, <code>pytest</code> has a powerful cache mechanism.</p>
<h3>Usage example</h3>
<pre><code>@pytest.fixture(autouse=True)
def init_cache(request):
    data = request.config.cache.get('my_data', None)
    data = {'spam': 'eggs'}
    request.config.cache.set('my_data', data)
</code></pre>
<p>Access the data dict in tests via builtin <code>request</code> fixture:</p>
<pre><code>def test_spam(request):
    data = request.config.cache.get('my_data')
    assert data['spam'] == 'eggs'
</code></pre>
<h3>Sharing the data between test runs</h3>
<p>The cool thing about <code>request.cache</code> is that it is persisted on disk, so it can be even shared between test runs. This comes handy when you running tests distributed (<code>pytest-xdist</code>) or have some long-running data generation which does not change once generated:</p>
<pre><code>@pytest.fixture(autouse=True)
def generate_data(request):
    data = request.config.cache.get('my_data', None)
    if data is None:
        data = long_running_generation_function()
        request.config.cache.set('my_data', data)
</code></pre>
<p>Now the tests won't need to recalculate the value on different test runs unless you clear the cache on disk explicitly. Take a look what's currently in the cache:</p>
<pre><code>$ pytest --cache-show
...
my_data contains:
  {'spam': 'eggs'}
</code></pre>
<p>Rerun the tests with the <code>--cache-clear</code> flag to delete the cache and force the data to be recalculated. Or just remove the <code>.pytest_cache</code> directory in the project root dir.</p>
<h3>Where to go from here</h3>
<p>The related section in <code>pytest</code> docs: <a href="https://docs.pytest.org/en/latest/cache.html" rel="nofollow noreferrer">Cache: working with cross-testrun state</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can add your global variable as an option inside the <code>pytest_addoption</code> hook. 
It is possible to do it explicitly with <code>addoption</code> or use <code>set_defaults</code> method if you want your attribute be determined without any inspection of the command line, <a href="https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.set_defaults" rel="nofollow noreferrer">docs</a> </p>
<hr/>
<p>When option was defined, you can paste it inside any fixture with <code>request.config.getoption</code> and then pass it to the test explicitly or with autouse.
Alternatively, you can pass your option into almost any hook inside the <code>config</code> object.</p>
<pre><code>#conftest.py
def pytest_addoption(parser):    
    parser.addoption("--my_global_var", default="foo")
    parser.set_defaults(my_hidden_var="bar")

@pytest.fixture()
def my_hidden_var(request):
    return request.config.getoption("my_hidden_var")

#test.py
def test_my_hidden_var(my_hidden_var):
    assert my_hidden_var == "bar"
</code></pre>
</div>
<span class="comment-copy">I was hoping for some way to define a variable in conftest.py, so that every test could see it with minimal importing, but this may be the best fallback. ... Thanks!</span>
<span class="comment-copy">This isn't really using pytest at all, so it requires structuring the tests based on classes, in the older unittest style  - the answers by @Frank-T and @ user2859458 are better options and higher voted.</span>
<span class="comment-copy">@RichVel absolutely, I mentioned that explicitly; note that I cannot unaccept the answer and delete it, thanks for the downvote, appreciate it.</span>
<span class="comment-copy">@alexce - missed that, sorry... I can't upvote again until it's edited (hint)</span>
<span class="comment-copy">@alecxe  Not sure if sarcasm above, but if we can get accepted answer to negative score then it can be deleted  ;)</span>
<span class="comment-copy">I was originally leaning this way, but PyDev (Eclipse) gets confused and complains of all usages as undeclared variables. ... If you had some way that obviously added this to the namespace (so that Eclipse-PyDev would be happy) and did not require adding the fixture to every method declaration, that would be the perfect answer for me.  :)</span>
<span class="comment-copy">What if I want to define a global variable based on a config? This hook doesn't seem to accept <code>config</code> or <code>request</code> fixtures.  ``` hook 'pytest_namespace' argument 'config' not available plugin definition: pytest_namespace(config) available hookargs: <b>multicall</b> ```</span>
<span class="comment-copy">Note that <code>pytest_namespace</code> is deprecated since version 3.2 and currently <a href="https://github.com/pytest-dev/pytest/wiki/Deprecation-Roadmap" rel="nofollow noreferrer">scheduled for removal in 4.0</a>; <code>pytest</code> itself removed all its internal usages of <code>pytest_namespace</code> in version 3.3. <a href="https://stackoverflow.com/a/50611422/2650249">Its replacement is the caching mechanism</a>, introduced in version 2.8.</span>
<span class="comment-copy">This appears to be the most simple and elegant solution I have seen for sharing among the namespace.</span>
<span class="comment-copy">Notice that more recent pytest versions are deprecating the pytest_namespace hook and it may/will be removed in the future.</span>
<span class="comment-copy">Thanks for interesting possibility, Frank!  It looks as though it would work, but manipulating the function's namespace is a bit too much for me too. :) ... Thanks!</span>
<span class="comment-copy">I used a similar method and some collegues modified objects within their tests, and then other tests down the line failed. I highly recommend providing a copy, not the actual object if you can support the workload.</span>
<span class="comment-copy">for me it seems <code>request.function.func_globals</code> does not work, it should be: <code>request.function.__globals__</code>, i am under python 3.5 btw.</span>
<span class="comment-copy">This seems like too much spooky action at a distance.  Explicit is better than implicit.</span>
<span class="comment-copy">Tried this and it works (very interesting solution), but the binding is at runtime and the IDE complains about unresolved reference, which just makes it confusing.  BTW, needed to do <code>request.function.__globals__</code> like the previous commenter said (Python 3.6).</span>
<span class="comment-copy">I got this error: AttributeError: 'SubRequest' object has no attribute 'cache'</span>
<span class="comment-copy">@jdeng: replace <code>request.cache</code> with <code>request.config.cache</code> in the tests; apologies for the missed <code>config</code> attribute! I have updated the code in the answer.</span>
