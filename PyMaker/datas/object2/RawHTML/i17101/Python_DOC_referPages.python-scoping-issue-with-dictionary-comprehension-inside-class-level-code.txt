<div class="post-text" itemprop="text">
<p><strong>Minimal example</strong></p>
<pre><code>class foo:
    loadings = dict(hi=1)
    if 'hi' in loadings:
        print(loadings['hi']) 
        # works
        print({e : loadings[e] for e in loadings})
        # NameError global name 'loadings' not defined
</code></pre>
<p>I tried referencing the class namespace as well but that isn't working either</p>
<pre><code>class foo:
    loadings = dict(hi=1)
    if 'hi' in loadings:
        print(loadings['hi'])
        #works
        print({e : foo.loadings[e] for e in foo.loadings})
        #NameError: name 'foo' is not defined
</code></pre>
<p>And of course, this works as expected</p>
<pre><code>class foo:
    loadings = dict(hi=1)
    if 'hi' in loadings:
        print(loadings['hi'])

print({e : foo.loadings[e] for e in foo.loadings})
</code></pre>
<p>I want to understand why this scope issue is happening then, if I am trying to do something insane understand the best way to do it otherwise. My feeling was that the first code snip should have worked as is, but of course it does not.</p>
<p><strong>The goal</strong></p>
<p>I am creating a DataManager class/module for some csv/json files along with canned database queries, a one stop shop for my program and obtaining data. There is some static data and some dynamic data so it seemed like a great use of static and non-static data members in the same class. While I understand that these could be module level variables, I like the concept of having static class data members (possibly because of a bias from Java). Any help is much appreciated</p>
<p><strong>My solution (for now)</strong></p>
<p>I ended up unfurling the list comprehension to stay in class scope, in the above it would become something like this</p>
<pre><code>class foo:
    loadings = dict(hi=1)
    temp = dict()
    for e in loadings:
        temp[e] = loadings[e] # keep in mind this is a minimal example, I probably wouldn't do (just) this
    print(temp) # works
    del temp
</code></pre>
<p>It is not pretty but it works for now</p>
</div>
<div class="post-text" itemprop="text">
<p>Per the <a href="https://docs.python.org/3/reference/executionmodel.html#naming-and-binding" rel="nofollow noreferrer">Name and Binding docs</a>:</p>
<blockquote>
<p>The scope of names defined in a class block is limited to the class
  block; it does not extend to the code blocks of methods â€“ <strong>this
  includes comprehensions</strong> and generator expressions since they are
  implemented using a function scope. This means that the following will
  fail:</p>
<pre><code>class A:
    a = 42
    b = list(a + i for i in range(10))
</code></pre>
</blockquote>
<p>See <a href="https://stackoverflow.com/a/13913933/190597">this answer</a> for more details.</p>
<hr/>
<p>In Python2, it is possible to use list comprehensions, since they were implemented without using a function scope:</p>
<pre><code>dict([(e,loadings[e]) for e in loadings])
</code></pre>
<p>But this code would break if run in Python3. So here is an alternative workaround which would work in Python2 and Python3:</p>
<pre><code>class Foo:
    def loadings():
        load = dict(hi=1)
        if 'hi' in load:
            print(load['hi']) 
            print({e:load[e] for e in load})
        return load
    loadings = loadings()

print(Foo.loadings)
</code></pre>
</div>
<span class="comment-copy">You should do all that inside an init function....</span>
<span class="comment-copy">I think its also interesting to note that <code>print({k: v for k, v in loadings.items()})</code> does work. So <code>loadings</code> is at least kinda visible in the dict comprehension</span>
<span class="comment-copy">This was not done in the init function because this is static data for the class which is loaded once. I could have some flag like <code>runonce</code> or something but it seemed that class level code is there for a reason.</span>
<span class="comment-copy">Thank you very much, for a clear and concise explanation! I wanted to point out to you that my intention would be to replace the last two lines of your last code block with something like <code>print(Foo.loadings)</code> and use it as a static data member.</span>
