<div class="post-text" itemprop="text">
<p>Python offers <a href="http://docs.python.org/3/library/numbers.html" rel="nofollow">a set of abstract base classes</a> for types of numbers. These start with <code>Number</code>, of which <code>Complex</code> is a subclass, and so on through <code>Real</code>, <code>Rational</code> and <code>Integral</code>. Since each is a subclass of the last, each supports the special functionality of the classes that came before it in the sequence. For example, you can write <code>(1).numerator</code> to get the numerator of the Python integer <code>1</code>, created using the integer literal <code>1</code>, considered as a rational number.</p>
<p>The linked page notes: <em>There are, of course, more possible ABCs for numbers, and this would be a poor hierarchy if it precluded the possibility of adding those. You can add MyFoo between Complex and Real with:</em></p>
<pre><code>class MyFoo(Complex): ...
MyFoo.register(Real)
</code></pre>
<p>This has the effect of adding a new subclass of complex numbers such that objects of type <code>Real</code> will test as being instances of the new class - thus adding the new class "in between" <code>Complex</code> and <code>Real</code> in some sense. This doesn't address, however, the possibility that the new class might introduce functionality (such as that exemplified by the <code>numerator</code> property) not offered by its subclass.</p>
<p>For example, suppose that you want to add a class whose instances represent numbers of the form <code>a + b√2</code> where <code>a</code> and <code>b</code> are rational numbers. You would probably represent these numbers internally as a pair of <code>Fraction</code>s (instances of <code>fraction.Fraction</code> from the Python standard library). Evidently, this class of numbers is properly a subclass of <code>Real</code>, and we would want to treat <code>Rational</code> as being its subclass (because every rational number is a number of our new type in which <code>b == 0</code>). So we would do this:</p>
<pre><code>class FractionWithRoot2Part (Real): ...
FractionWithRoot2Part.register(Rational)
</code></pre>
<p>We might want to add properties to the new class that (say) return the numbers <code>a</code> and <code>b</code>. These properties might be called something like <code>RationalPart</code> and <code>CoefficientOfRoot2</code>. This is awkward, however, because existing numbers of type <code>Rational</code> will not have these properties. If we write <code>(1).RationalPart</code> then we will get an <code>AttributeError</code>. Demonstration:</p>
<pre><code>Python 3.3.1 (v3.3.1:d9893d13c628, Apr  6 2013, 20:25:12) [MSC v.1600 32 bit (In
tel)] on win32
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; from abc import *
&gt;&gt;&gt; class c1 (metaclass = ABCMeta):
...     def x (self): return 5
...
&gt;&gt;&gt; class c2: pass
...
&gt;&gt;&gt; c1.register(c2)
&lt;class '__main__.c2'&gt;
&gt;&gt;&gt; a1 = c1()
&gt;&gt;&gt; a2 = c2()
&gt;&gt;&gt; a1.x()
5
&gt;&gt;&gt; a2.x()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'c2' object has no attribute 'x'
</code></pre>
<p>Thus we have not truly introduced a new type that is "in between" the existing two types, because the type "at the bottom" of the subclass relation does not support the behaviours of the class "in the middle".</p>
<p>What is the generally accepted way to get around this? One possibility is to provide a function (not a method of any class) which can handle any kind of input and act intelligently; something like this:</p>
<pre><code>def RationalPart (number):
    if isinstance(number, FractionWithRoot2Part):
        try:
            return number.RationalPart
        except AttributeError:
            # number is presumably of type Rational
            return number
    else:
        raise TypeError('This is not supported you dummy!')
</code></pre>
<p>Is there a better way than this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't use ABCs to modify existing classes in this way (and in fact, you can't safely modify existing classes in this way at all).  ABCs are only a mechanism for customizing whether a class tests as a subclass of another (and instances of it test as instances of the other), not for actually changing subclass implementations.  When the documentation talks about defining a new class "in between", this is the sense it means; it just means in between in terms of subclass/instance checks, not actual inheritance.  This is described <a href="http://docs.python.org/3/glossary.html#term-abstract-base-class" rel="nofollow">here</a>:</p>
<blockquote>
<p>ABCs introduce virtual subclasses, which are classes that don’t inherit from a class but are still recognized by <code>isinstance()</code> and <code>issubclass()</code></p>
</blockquote>
<p>Note what it says: the virtual subclasses <em>don't actually inherit</em> from your ABC, they just test as if they do.  That's how ABCs are designed to work.  The way to use them is suggested <a href="http://docs.python.org/2/library/abc.html" rel="nofollow">here</a>:</p>
<blockquote>
<p>An ABC can be subclassed directly, and then acts as a mix-in class.</p>
</blockquote>
<p>So you can't modify the existing Rational class using ABC.  The way to do what you want is to make a new class that inherits from Rational and uses your ABC as a mixin.  Then use that class instead of the regular Rational.</p>
<p>In fact, you might not even really need to use ABCs here.  The only advantage of using ABCs is that it makes your new rational-like numbers look like Rationals if anyone explicitly tests; but as long as you inherit from Rational and from your new class that adds the behavior you want, the new classes will <em>act</em> like Rationals anyway.</p>
<p>When you say</p>
<blockquote>
<p>This is awkward, however, because existing numbers of type Rational will not have these properties.</p>
</blockquote>
<p>you have targeted the essence of the situation.  It might seem awkward, but it would also be mighty awkward if someone could come in and, with an ABC end-run, start modifying the behavior of your existing classes by sticking a new superclass above them in the inheritance hierarchy.  That's not how it works.  There is no safe way to add new behavior to <em>existing</em> instances of any class; the only safe thing is to add new behavior to your new class, and tell people to use that new class instead of the old class.</p>
</div>
