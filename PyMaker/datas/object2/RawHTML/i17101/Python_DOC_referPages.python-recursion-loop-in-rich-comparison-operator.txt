<div class="post-text" itemprop="text">
<p>I did not understand where is the logic in my bug, so I managed to find a minimal example. I defined one class <code>t</code>, and said that something happens when you use the &lt;= operator and that a&gt;=b must compute b&lt;=a.
It works fine</p>
<p>Then I derived a subclass <code>u</code> from <code>t</code>.
When I compare two values, if they are both from <code>t</code> or both from <code>u</code> it works as expected, but if one is from class <code>u</code> and another from class <code>t</code> it fails. <strong>Why</strong> ??</p>
<pre><code>class t :
    def __le__(self,other) : return True
    def __ge__(self,other) : return(other&lt;=self)
class u(t) :
    pass

a=t()
b=u()
#works
a&lt;=a
a&gt;=a
b&lt;=b
b&gt;=b
#works
a&gt;=b
b&lt;=a
#doesn't work RuntimeError: maximum recursion depth exceeded
a&lt;=b
b&gt;=a
</code></pre>
<p>EDIT : There is no problem in python 2.x (from tobias_k), but I want to use python 3.3 at least</p>
</div>
<div class="post-text" itemprop="text">
<p>When you do <code>a &lt;= b</code> and <code>b</code> is an instance of a subclass of <code>a</code>'s class, Python will first call <code>b.__ge__('a')</code> (and then try other methods if this call returns <code>NotImplemented</code>)</p>
<p>Here is how to implement it without infinite recursion:</p>
<pre><code>&gt;&gt;&gt; class t:
...     def __le__(self, other):
...         return True
...     def __ge__(self, other):
...         return NotImplemented
... 
&gt;&gt;&gt; class u(t):
...     pass
...
</code></pre>
</div>
<span class="comment-copy">which class is a and b?</span>
<span class="comment-copy">@akaRem sorry, I added the definition of <code>a</code> and <code>b</code>.</span>
<span class="comment-copy">Just FYI, in Python 2.x it 'works' as expected (returns true all the time).</span>
<span class="comment-copy">@tobias_k Thanks, I edited my question to include your remark.</span>
<span class="comment-copy">The problems seems to be with comparator substitution, as the call to <code>return(other&lt;=self)</code> seems to check <code>self &gt;= other</code> instead, leading to infinite recursion... however, I do not know <i>why</i> it does so, and why only in those last two cases...</span>
<span class="comment-copy">Is it a documented feature ?</span>
<span class="comment-copy">I'm sure I've seen that in the doc, but I can't find where</span>
<span class="comment-copy">See <a href="http://stackoverflow.com/questions/13799386/python-bug-with-le-ge" title="python bug with le ge">stackoverflow.com/questions/13799386/python-bug-with-le-ge</a> for a similar question and answer.  The documentation seems to be a combination of <a href="http://docs.python.org/3/reference/datamodel.html#emulating-numeric-types" rel="nofollow noreferrer">docs.python.org/3/reference/â€¦</a> (for subclass overriding and using NotImplemented as @ValentinLorentz suggested), and <a href="http://docs.python.org/3/reference/datamodel.html#basic-customization" rel="nofollow noreferrer">docs.python.org/3/reference/datamodel.html#basic-customization</a> for <code>"__le__"</code> and <code>"__ge__"</code> are each other's reflection. It seems like one has to piece the specification together oneself from these two sections.</span>
<span class="comment-copy">@RoryYorke Thanks for the links, especially the SE question</span>
<span class="comment-copy">@ValentinLorentz This is documented into <a href="http://docs.python.org/3/reference/datamodel.html#object.__radd__" rel="nofollow noreferrer">docs.python.org/3/reference/datamodel.html#object.__radd__</a> where it is specified the order between reflected method and subclass method in the <b>Note : ...</b></span>
