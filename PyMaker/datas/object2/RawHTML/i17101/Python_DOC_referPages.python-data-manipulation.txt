<div class="post-text" itemprop="text">
<p>I have two files as input. (they each have more columns, but I narrowed it down to important ones only)</p>
<pre><code>A   15.6            A   D
B   10.3            A   B
C   12.5            A   E
D   14.5            A   Y
E   11.4            C   A
F   23.7            C   B
                    C   R
                    D   A
                    D   R
                    D   F
</code></pre>
<p>First file is a kind of index. I want to look at the second file and compare the pairs by looking up their value in the first file and printing out the key with smaller value (if one of the keys isn't in the index file - then print out the other one by default). After that I'd like to remove all repearting entries, i.e.</p>
<pre><code>D   14.5
B   10.3
E   11.4                A   15.6
A   15.6                B   10.3
C   12.5    -------&gt;    C   12.5
B   10.3                D   14.5
C   12.5                E   11.4
D   14.5
D   14.5
D   14.5
</code></pre>
<p>So, it's essentially an index file reduction. There has to be an elegant way in Python for doing it...</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>mapping = dict()
result = set()

with open(filename1, 'r') as f1, open(filename2, 'r') as f2:
    for line in f1:
        line = line.split()
        if line:
            key, val = line
            mapping[key] = float(val)  #1

    for line in f2:
        line = line.split()        
        if line:
            key1, key2 = line
            if key1 in mapping:   #4
                result.add(min(line, key=lambda x: mapping.get(x, float('inf'))))  #2

for key in result:
    print('{k} {v}'.format(k=key, v=mapping[key]))   #3
</code></pre>
<ol>
<li>Load the data from the first file into a dict (called <code>mapping</code>).</li>
<li>Collect all the keys associated with minimal values in a set (called <code>result</code>).</li>
<li>Report the keys. Note that since <code>result</code> is a <code>set</code>, there is no
predefined order in which the keys will be reported.</li>
<li>Per the extra requirement in the comments, ignore rows where <code>key1</code>
is not in the first file.</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>You can use zip as follows:</p>
<pre><code>with open("file1.txt","r") as file1,  open("file2.txt","r") as file2:
    for l1,l2 in zip(file1.readlines(), file2.readlines()):
        l1d=l1.split()
        l2d=l2.split()
        if l1d[0]==l2d[0]:
            if float(l1d[1]) &lt; float(l2d[1]):
                print l1
            else:
                print l2
</code></pre>
<ol>
<li>Read both files </li>
<li>Use zip to iterate both files lines</li>
<li>Find minimum based on split result and show the minimum holding string</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>This could be one way:</p>
<pre><code>#1. Make a dictionary of the first file, so the look up is faster

a_dict = {}
for line in first_file:
    a, b = line.strip().split()
    a_dict[a] = b

#2. Get the second item in each line of second file and get 
#   its corresponding value from the dictionary we built.
#   op is another dict and will take care of getting rid of
#   duplicates.

op = defaultdit(list)
for line in second_file:
    a, b = line.split().strip()
    op[a].append(a_dict[b])

#3. Get the minimum value of all the candidates

res = {}
for k, v in op:
    res[k] = min(v)

print res
</code></pre>
</div>
<span class="comment-copy">You are essentially reducing the first file to only entries that have a value in the second column in the second file..</span>
<span class="comment-copy">use sets <a href="https://docs.python.org/2/library/sets.html" rel="nofollow noreferrer">docs.python.org/2/library/sets.html</a></span>
<span class="comment-copy">awesome code! thanks! quick question - if filename2 happens to be a large file with multiple columns and I only want to consider the rows where key1 matches any one of the keys in filename2 - how would one modify your code above?? (in my rudimentary bash scrips I would grep the large filename2 for each of the keys in filename1...which is quite inefficient). thanks again!</span>
<span class="comment-copy">You could use <code>if key1 in mapping</code>. I've edited the post above to show where.</span>
<span class="comment-copy">I probably learned this by seeing someone use this, though who or where I do not remember. The reason why it works is <a href="https://docs.python.org/3/library/stdtypes.html#truth-value-testing" rel="nofollow noreferrer">documented here</a>: The truth value of a empty tuple is False, and otherwise True. So <code>if line</code> (after using <code>line = line.split()</code> to split on  whitespace) is the way to test if a <code>line</code> has non-whitespace content.</span>
<span class="comment-copy">thanks again. your code inspires learning. i haven't seen the construct <b>if line:</b> much elsewhere...where can one read about it in detail?</span>
<span class="comment-copy">great info. sorry for weird editing on the previous comment...doing 3 things at the same time and run out of 5 min edit limit...</span>
<span class="comment-copy">works well and easier for a noob (like myself) to read and understand. i gave unutbu the solution checkmark though...that code is just so tight...just studying it gave me a greater understanding and feel for python. thank you.</span>
