<div class="post-text" itemprop="text">
<p>I'm using Requests to connect to a RESTful API. The server I would like to reach use ssl with self-singed certificate.</p>
<pre><code>cafile = "gateway.pem"
r = requests.get(request, auth=('admin', 'password'), verify=cafile)
</code></pre>
<p>the problem is I'm getting SSLError of hostname mismatch.
there should be a way to disable the hostname checking without disabling certificate validation, as in many java implementations, but I can't find how to do it with requests in python.</p>
<p>stacktrace:</p>
<pre><code>Traceback (most recent call last):
  File "&lt;pyshell#43&gt;", line 1, in &lt;module&gt;
    r = requests.get(request, auth=("admin", "password"), verify='gateway.pem')
  File "C:\Python27\lib\site-packages\requests-2.0.0-py2.7.egg\requests\api.py", line 55, in get
    return request('get', url, **kwargs)
  File "C:\Python27\lib\site-packages\requests-2.0.0-py2.7.egg\requests\api.py", line 44, in request
    return session.request(method=method, url=url, **kwargs)
  File "C:\Python27\lib\site-packages\requests-2.0.0-py2.7.egg\requests\sessions.py", line 357, in request
    resp = self.send(prep, **send_kwargs)
  File "C:\Python27\lib\site-packages\requests-2.0.0-py2.7.egg\requests\sessions.py", line 460, in send
    r = adapter.send(request, **kwargs)
  File "C:\Python27\lib\site-packages\requests-2.0.0-py2.7.egg\requests\adapters.py", line 358, in send
    raise SSLError(e)
SSLError: hostname '10.76.92.70' doesn't match u'lital.com'
</code></pre>
<p>How can this be done? </p>
</div>
<div class="post-text" itemprop="text">
<p>Requests doesn't allow this directly, however you can provide a custom transport adapter which  uses the features of the underlying <code>urllib3</code>. The usage of transport adapters is covered in the requests documentation.</p>
<p>This code is not tested, but should work.</p>
<pre><code>from requests.adapters import HTTPAdapter
from requests.packages.urllib3.poolmanager import PoolManager


# Never check any hostnames
class HostNameIgnoringAdapter(HTTPAdapter):
    def init_poolmanager(self, connections, maxsize, block=False):
        self.poolmanager = PoolManager(num_pools=connections,
                                       maxsize=maxsize,
                                       block=block,
                                       assert_hostname=False)


# Check a custom hostname
class CustomHostNameCheckingAdapter(HTTPAdapter):
    def cert_verify(self, conn, url, verify, cert):
        #      implement me
        host = custom_function_mapping_url_to_hostname(url)
        conn.assert_hostname = host
        return super(CustomHostNameCheckingAdapter,
                     self).cert_verify(conn, url, verify, cert)
</code></pre>
<p>In detail the <code>assert_hostname</code> param works as follows:
If <code>None</code> use the hostname from the URL, if <code>False</code> suppress hostname checking, if a custom string validate against this string.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm a little late to the party but <code>requests_toolbelt</code> looks like it might help if you install version 0.7.0 or newer (my ubuntu 16.04 only has 0.6.0): <a href="https://toolbelt.readthedocs.io/en/latest/adapters.html#hostheaderssladapter" rel="noreferrer">https://toolbelt.readthedocs.io/en/latest/adapters.html#hostheaderssladapter</a></p>
<p>From the link:</p>
<pre><code>Example usage:
&gt;&gt;&gt; s.mount('https://', HostHeaderSSLAdapter())
&gt;&gt;&gt; s.get("https://93.184.216.34", headers={"Host": "example.org"})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Did you look into the <code>SSLContext.check_hostname</code> parameter?
You should be able to set it to False, and it should not check the hostname:</p>
<pre><code>context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)
context.verify_mode = ssl.CERT_REQUIRED
context.check_hostname = True
context.load_default_certs()
</code></pre>
<p>The only limitation is that this only works in Python 3.4 and later.</p>
<p>Reference:
<a href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext.check_hostname" rel="nofollow">https://docs.python.org/3/library/ssl.html#ssl.SSLContext.check_hostname</a></p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python-requests.org/en/latest/user/advanced/#ssl-cert-verification" rel="nofollow">http://docs.python-requests.org/en/latest/user/advanced/#ssl-cert-verification</a></p>
<p><code>verify</code> keyword is a flag, not for providing certfile. You provided there non-empy string, which resolves to <code>True</code> in boolean context.</p>
<p>Use <code>cert=</code> keyword to provide path to certificate files, or disable verification with <code>verify=False</code>.</p>
<p><em>EDIT</em>: although documentation says you can actually pass CA path to <code>verify=</code>, but there are no examples. It would be helpful to see whole traceback you are receiving.</p>
</div>
<div class="post-text" itemprop="text">
<p>If this is only for testing only then just add an entry in /etc/hosts to your local system (assuming you have access).</p>
</div>
<span class="comment-copy">Thanks for that. I actually tried this as you can see below, but found out that after changing to use my costume adapter, no certificate varification is performed at all (instead of only hostname verification). I passed requests a corrupted pem file and got valid response.</span>
<span class="comment-copy">class MyAdapter(requests.adapters.HTTPAdapter):     def init_poolmanager(self, connections, maxsize, block):         self._pool_connections = connections         self._pool_maxsize = maxsize         self._pool_block = block         self.poolmanager = requests.packages.urllib3.PoolManager(num_pools=connections,                                                                  maxsize=maxsize, 								 block=block,                                                                  assert_hostname=False)</span>
<span class="comment-copy">I'm then doing this: s = requests.Session() s.mount('https://', MyAdapter()) r = s.get(request, auth=("admin", "admin"), verify=cafile)</span>
<span class="comment-copy">Any idea what is worng here and why this disables the certificate validation?</span>
<span class="comment-copy">If I use a corrupted pem file openssl blows up for me <code>requests.exceptions.SSLError: [Errno 0] _ssl.c:343: error:00000000:lib(0):func(0):reason(0)</code></span>
<span class="comment-copy">When I'm doing the same call with verify=True I'm getting different error of "certificate verify failed". So looks like it is possible to pass the pem file to verify=. when I'm doing the call with cert=cafile instead of verify=cafile, I'm getting SSLError: [Errno 336265225] _ssl.c:351: error:140B0009:SSL routines:SSL_CTX_use_PrivateKey_file:PEM lib. I added the traceback to the message.</span>
<span class="comment-copy">what is your request? Looks like CA is hooked up properly, but it is signed for 'lital.com' and you connect by IP. Hence errors.</span>
<span class="comment-copy">right, the hostname in the certificate ('lital.com') isn't really the server's hostname. That's the reason I want to disable the hostname matching/checking. In java this can be done with ALLOW_ALL_HOSTNAME_VERIFIER. I couldn't find something similar in requests.</span>
<span class="comment-copy">as docs say, use <code>verify=False</code> to disable check.</span>
<span class="comment-copy">I don't want to disable entirely the certificate validation, only the hostname checking.</span>
