<div class="post-text" itemprop="text">
<p>So I have a CSV file with the data arranged like this:</p>
<pre><code>X,a,1,b,2,c,3
Y,a,1,b,2,c,3,d,4
Z,l,2,m,3
</code></pre>
<p>I want to import the CSV to create a nested dictionary so that looks like this.</p>
<pre><code>data = {'X' : {'a' : 1, 'b' : 2, 'c' : 3}, 
        'y' : {'a' : 1, 'b' : 2, 'c' : 3, 'd' : 4},
        'Z' : {'l' : 2, 'm' :3}}
</code></pre>
<p>After updating the dictionary in the program I wrote (I got that part figured out), I want to be able to export the dictionary onto the same CSV file, overwriting/updating it. However I want it to be in the same format as the previous CSV file so that I can import it again.</p>
<p>I have been playing around with the import and have this so far</p>
<pre><code>import csv
data = {}
with open('userdata.csv', 'r') as f:    
    reader = csv.reader(f)
    for row in reader:
       data[row[0]] = {row[i] for i in range(1, len(row))}
</code></pre>
<p>But this doesn't work as things are not arranged correctly. Some numbers are subkeys to other numbers, letters are out of place, etc. I haven't even gotten to the export part yet. Any ideas? </p>
</div>
<div class="post-text" itemprop="text">
<p>Since you're not interested in preserving order, something relatively simple should work:</p>
<pre><code>import csv

# import
data = {}
with open('userdata.csv', 'r') as f:
    reader = csv.reader(f)
    for row in reader:
        a = iter(row[1:])
        data[row[0]] = dict(zip(a, a))

# export
with open('userdata_exported.csv', 'w') as f:
    writer = csv.writer(f)
    for key, values in data.items():
        row = [key] + [value for item in values.items() for value in item]
        writer.writerow(row)
</code></pre>
<p>The latter could be done a little more efficiently by making only a single call to the<code>csv.writer</code>'s <code>writerows()</code>method and passing it a <a href="https://docs.python.org/3/reference/expressions.html#generator-expressions" rel="nofollow">generator expression</a>.</p>
<pre><code># export2
with open('userdata_exported.csv', 'w') as f:
    writer = csv.writer(f)
    rows = ([key] + [value for item in values.items() for value in item]
            for key, values in data.items())
    writer.writerows(rows)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <code>grouper</code> recipe from <a href="https://docs.python.org/2/library/itertools.html#recipes" rel="nofollow"><code>itertools</code></a>:</p>
<pre><code>def grouper(iterable, n, fillvalue=None):
    "Collect data into fixed-length chunks or blocks"
    # grouper('ABCDEFG', 3, 'x') --&gt; ABC DEF Gxx
    args = [iter(iterable)] * n
    return itertools.izip_longest(fillvalue=fillvalue, *args)
</code></pre>
<p>This will group your data into the a1/b2/c3 pairs you want.  So you can do <code>data[row[0]] = {k: v for k, v in grouper(row[1:], 2)}</code> in your loop.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from collections import defaultdict

data_lines = """X,a,1,b,2,c,3
Y,a,1,b,2,c,3,d,4
Z,l,2,m,3""".splitlines()

data = defaultdict(dict)

for line in data_lines:
# you should probably add guards against invalid data, empty lines etc.
    main_key, sep, tail = line.partition(',')
    items = [item.strip() for item in tail.split(',')]
    items = zip(items[::2], map(int, items[1::2])
    # data[main_key] = {key : value for key, value in items}
    data[main_key] = dict(items)

print dict(data)
# {'Y': {'a': '1', 'c': '3', 'b': '2', 'd': '4'}, 
#  'X': {'a': '1', 'c': '3', 'b': '2'}, 
#  'Z': {'m': '3', 'l': '2'}
# }
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm lazy, so I might do something like this:</p>
<pre><code>import csv
data = {}

with open('userdata.csv', 'rb') as f:    
    reader = csv.reader(f)
    for row in reader:
        data[row[0]] = dict(zip(row[1::2], map(int,row[2::2])))
</code></pre>
<p>which works because <code>row[1::2]</code> gives every other element starting at 1, and <code>row[2::2</code> every other element starting at 2.  <code>zip</code> makes a tuple pair of those elements, and then we pass that to <code>dict</code>.  This gives</p>
<pre><code>{'Y': {'a': 1, 'c': 3, 'b': 2, 'd': 4}, 
 'X': {'a': 1, 'c': 3, 'b': 2}, 
 'Z': {'m': 3, 'l': 2}}
</code></pre>
<p>(Note that I changed your <code>open</code> to use <code>'rb'</code>, which is right for Python 2: if you're using <code>3</code>, you want <code>'r', newline=''</code> instead.)</p>
</div>
<span class="comment-copy">dicts are not ordered.  If you need order information in your <code>data</code>, you'll need to use a different structure, such as an OrderedDict.</span>
<span class="comment-copy">I didn't mean out of order like sorted sorry. As in the data isn't arranged like the dictionary I presented. Some number are keys to other numbers, etc. I edited it for clarification.</span>
<span class="comment-copy">You have to clarify your question. Please add a representative input sample and your expected output.</span>
<span class="comment-copy">This worked perfectly. I see where I was going wrong. Thanks!</span>
