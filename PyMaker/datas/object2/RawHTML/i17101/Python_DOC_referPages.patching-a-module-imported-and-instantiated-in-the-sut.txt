<div class="post-text" itemprop="text">
<p>I'm trying to run unit tests on a class that imports two other modules, and I'm trying to patch out those modules using <code>mock</code>. One of these modules is instantiated in the class I'm testing, and I have not been able to patch it out. It appears that I have managed to patch out the other one.</p>
<p>What is the best way to patch out the <code>sequence.processor</code> module in this code?</p>
<p><strong>Directory structure</strong></p>
<pre><code>logger.py
parser/
    __init__.py
    docparser.py
sequence/
    __init__.py
    processor.py
tests/
    testdocparser.py
</code></pre>
<p><strong>/parser/docparser.py</strong></p>
<pre><code>import logger
from sequence.processor import Processor

class DocParser(object):
    def __init__(self, reader_writer):
        self.processor = Processor(reader_writer)

    def write_and_parse(self, products):
        logger.log(products)
        self.processor.process(products)
</code></pre>
<p><strong>/tests/testdocparser.py</strong></p>
<pre><code>import unittest
from mock import MagicMock, patch

from parser import docparser

class DocParserTests(unittest.TestCase):
    def setUp(self):
        self.mock_writer = MagicMock()
        self.docparser = docparser.DocParser(self.mock_writer)

    @patch("parser.docparser.logger") # This seems to be patched properly
    @patch("parser.docparser.Processor") # This is not patched
    def test_write_and_parse(self, mock_logger, mock_proc):
        products = "products"
        self.docparser.write_and_parse(products)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You patch <code>Processor</code> in <code>test_write_and_parse()</code> but it's instantiated in <code>DocParser.__init__()</code> which is called from <code>setUp()</code>.</p>
<p>This should work, though I haven't tested it:</p>
<pre><code>class DocParserTests(unittest.TestCase):
    def setUp(self):
        self.mock_writer = MagicMock()
        with patch('parser.docparser.Processor'):
            self.docparser = docparser.DocParser(self.mock_writer)

    @patch("parser.docparser.logger")
    def test_write_and_parse(self, mock_logger):
        products = "products"
        self.docparser.write_and_parse(products)
</code></pre>
<p>I've used context manager instead of decorator to avoid changing <code>setUp()</code> signature (adding an argument).</p>
<p>Also the order of mock arguments for test_write_and_parse() is incorrect in your code. Here's an excerpt from <a href="https://docs.python.org/3/library/unittest.mock.html#quick-guide" rel="nofollow">mock docs</a>:</p>
<blockquote>
<p>When you nest patch decorators the mocks are passed in to the decorated function in the same order they applied (the normal python order that decorators are applied). This means from the bottom up...</p>
</blockquote>
<p>Correct order:</p>
<pre><code>@patch("parser.docparser.logger") # This seems to be patched properly
@patch("parser.docparser.Processor") # This is not patched
def test_write_and_parse(self, mock_proc, mock_logger):
   # ...
</code></pre>
<p>Of cource, it doesn't really matter in your particular case because <code>mock_proc</code> and <code>mock_logger</code> are not used later.</p>
</div>
<span class="comment-copy">Thank you! This was exactly what I was looking for.</span>
