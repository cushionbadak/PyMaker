<div class="post-text" itemprop="text">
<p>I'm struggling to make my API work, the tutorials are quite tricky about this part. I want to have a '/comments/' POST request with body {movie_id: 1, content="Some comment") and connect it to some Movie.</p>
<p>In serializer I'm getting:
<code>{'movie': [ErrorDetail(string='This field is required.', code='required')]}</code></p>
<p>How can I map movie_id to movie? By the way, I can change the name to movie if this would be easier.</p>
<p>Models.py:</p>
<pre><code>from django.db import models
from django.utils import timezone


class Movie(models.Model):
    title = models.CharField(max_length=200)
    year = models.IntegerField()


class Comment(models.Model):
    content = models.TextField(max_length=300)
    publish_date = models.DateField(default=timezone.now())
    movie = models.ForeignKey(Movie, on_delete=models.CASCADE, related_name='movie_id')
</code></pre>
<p>serializers.py:</p>
<pre><code>class MovieSerializer(serializers.HyperlinkedModelSerializer):
    class Meta:
        model = Movie
        fields = '__all__'


class CommentSerializer(serializers.HyperlinkedModelSerializer):
    movie_id = serializers.PrimaryKeyRelatedField(many=False, read_only=True)

    class Meta:
        model = Comment
        fields = '__all__'
</code></pre>
<p>views.py (for Comment, Movie works fine):</p>
<pre><code>from .models import Movie, Comment
from rest_framework import viewsets, status
from rest_framework.response import Response
from .serializers import MovieSerializer, CommentSerializer

class CommentViewSet(viewsets.ModelViewSet):
    queryset = Comment.objects.all()
    serializer_class = CommentSerializer

    def create(self, request, *args, **kwargs):
        serializer = CommentSerializer(data=request.data, context={'request': request})

        if serializer.is_valid(raise_exception=True): 
            serializer.save()
            return Response(serializer.data, status=status.HTTP_201_CREATED)  
        else:
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think you can try like this:</p>
<pre><code>class CommentSerializer(serializers.HyperlinkedModelSerializer):
    class Meta:
        model = Comment
        fields = '__all__'
</code></pre>
<p>Also, related name is used for reverse relationship. So it will work like this:</p>
<p>If <code>Comment</code> Model has related_name <code>comments</code> like this:</p>
<pre><code>class Comment(models.Model):
    movie = models.ForeignKey(Movie, on_delete=models.CASCADE, related_name='comments')
</code></pre>
<p>Then you can access comments from movie like this:</p>
<pre><code>for m in Movie.objects.all():
    m.comments.all()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Nested data works a little differently to how I expected.</p>
<p>If you want to connect a comment to a movie, you need to pass the movie object to your comment, not the primary key of the movie object.</p>
<p>Under the hood, Django automatically creates a new field 'movie_id' on your comment object in which the movie's primary key is stored - but you don't need to worry about that. So I would call the field in the comment 'movie', otherwise Django will create a new field 'movie_id_id'.</p>
<p>I got something similar to work by defining a custom create method in my serializer:</p>
<p>In your serializer:</p>
<pre><code>class CommentSerializer(serializers.HyperlinkedModelSerializer):
    class Meta:
        model = Comment
        fields = '__all__'


    def create(self, validated_data):
        themovieid = validated_data.pop('movie_id', None) # remove movie_id from the comment data
        themovie = Movie.objects.get(pk=themovieid) # find the movie object

        return Comment.objects.create(movie=themovie, **validated_data)
</code></pre>
<p>I have tried to adapt this to your code, I hope it will help you to get this working. I have removed movie_id from your serializer: your model defiines everything that is needed.</p>
<p>Edit: have you tried simply passing the movie's id as 'movie' in your comment data, with no custom create method and do not define 'movie_id' in your serializer?</p>
</div>
<span class="comment-copy">So have you tried sending the POST request with <code>{movie: 1, content="Some comment")</code>?</span>
<span class="comment-copy">Yes, I've just tried changing all "movie_id" in whole project to "movie" and applied migrations. Now I'm getting: <code>django.db.utils.IntegrityError: NOT NULL constraint failed: movies_comment.movie_id</code></span>
<span class="comment-copy">I've also tried changing read_only to False in: <code>movie = serializers.PrimaryKeyRelatedField(many=False, read_only=False)</code>  Because this makes sense, but now I'm getting: <code>AssertionError: Relational field must provide a 'queryset' argument, override 'get_queryset', or set read_only='True'.</code></span>
<span class="comment-copy">I suggest reading up on <a href="https://stackoverflow.com/q/2642613/2750819">stackoverflow.com/q/2642613/2750819</a> as the name you give to related_name doesn't really make sense.</span>
<span class="comment-copy">As @kshikama said, the <code>related_name</code> you chose makes no sense at all. Logically it should be called <code>comments</code>. When you have an object Movie, you can do <code>Movie.comments.all()</code> and retrieve all comments for a Movie. That would be very intutive for the reader.</span>
