<div class="post-text" itemprop="text">
<p>I noticed that when I use user-defined objects (that override the <code>__hash__</code> method) as keys of my dicts in Python, lookup time increases by at least a factor 5. </p>
<p>This behaviour is observed even when I use very basic hash methods such as in the following example:</p>
<pre><code>class A:
    def __init__(self, a):
        self.a = a
    def __hash__(self):
        return hash(self.a)
    def __eq__(self, other):
        if not isinstance(other, A):
            return NotImplemented
        return (self.a == other.a and self.__class__ == 
                other.__class__)

# get an instance of class A
mya = A(42)
# define dict
d1={mya:[1,2], 'foo':[3,4]}
</code></pre>
<p>If I time the access through the two different keys I observe a significant difference in performance</p>
<pre><code>%timeit d1['foo']
</code></pre>
<p>results in ~ 100 ns. Whereas</p>
<pre><code>%timeit d1[mya]
</code></pre>
<p>results in ~ 600 ns. </p>
<p>If I remove the overwriting of <code>__hash__</code> and <code>__eq__</code> methods, performance is at the same level as for a default object</p>
<p>Is there a way to avoid this loss in performance and still implement a customised hash calculation ?</p>
</div>
<div class="post-text" itemprop="text">
<p>The default CPython <code>__hash__</code> implementation for a custom class is written in C and uses the memory address of the object. Therefore, it does not have to access absolutely anthing from the object and can be done very quickly, as it is just a single integer operation in CPU, if even that.</p>
<p>The "very basic" <code>__hash__</code> from the example is not as simple as it may seem:</p>
<pre><code>def __hash__(self):
    return hash(self.a)
</code></pre>
<p>This has to read the attribute <code>a</code> of <code>self</code>, which I'd say in this case will call <code>object.__getattribute__(self, 'a')</code>, and that will look for the value of 'a' in <code>__dict__</code>. This already involves calculating <code>hash('a')</code> and looking it up. Then, the returned value will be passed to <code>hash</code>.</p>
<hr/>
<p>To answer the additional question:</p>
<blockquote>
<p>Is there a way to implement a faster <code>__hash__</code> method that returns
  predictable values, I mean that are not randomly computed at each run
  as in the case of the memory address of the object ?</p>
</blockquote>
<p>Anything accessing attributes of objects will be slower than the implementation which does not need to access attributes, but you could make attribute access faster by using <a href="https://docs.python.org/3/reference/datamodel.html#slots" rel="nofollow noreferrer"><code>__slots__</code></a>, or implementing a highly optimized C extension for the class.</p>
<p><em>There is, however, another question: is this really a problem? I cannot really believe that an application is becoming slow because of slow <code>__hash__</code>. <code>__hash__</code> should still be pretty fast unless the dictionary has trillions of entries, but then, everything else would become slow and ask for bigger changes...</em></p>
<hr/>
<p>I did some testing and have to make a correction. Using <code>__slots__</code> is not going to help in this case at all. My tests actually showed that in CPython 3.7 the above class becomes slightly <strong>slower</strong> when using <code>__slots__</code>.</p>
</div>
<span class="comment-copy">Not easily. Your <code>__hash__</code> and <code>__eq__</code> are Python functions, the corresponding methods of builtin types are written in C, therefore faster.</span>
<span class="comment-copy">Is there a way to implement a faster <code>__hash__</code> method that returns predictable values, I mean that are not randomly computed at each run as in the case of the memory address of the object ?</span>
<span class="comment-copy">@PaoloGervasoniVila See addition to my answer.</span>
<span class="comment-copy">@PaoloGervasoniVila: Compute the hash during <code>__init__</code> and store it as an attribute, so the implementation become <code>def __hash__(self): return self.precomphash</code>. Still going to be slower than hashing Python built-ins (and use more memory than before), but that's just how Python works; built-ins (and C extensions) are faster, period.</span>
