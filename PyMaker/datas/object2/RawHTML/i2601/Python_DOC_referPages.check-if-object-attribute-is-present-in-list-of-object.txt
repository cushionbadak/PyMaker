<div class="post-text" itemprop="text">
<p>I have an object with different attributes and a list that contains those objects.</p>
<p>Before adding an object to the list, I'd like to check if an attribute of this new object is present in the list. </p>
<p>This attribute is unique, so this is done to make sure that every object in the list is unique.</p>
<p>I would do something like this:</p>
<pre><code>for post in stream:
    if post.post_id not in post_list:
        post_list.append(post)
    else:
        # Find old post in the list and replace it
</code></pre>
<p>But obviously line 2 doesn't work as I'm comparing the <code>post_id</code> to the object list. </p>
</div>
<div class="post-text" itemprop="text">
<p>Keep a separate set to which you add the attribute, and against which you can then test the next value:</p>
<pre><code>ids_seen = set()
for post in stream:
    if post.post_id not in ids_seen:
        post_list.append(post)
        ids_seen.add(post.post_id)
</code></pre>
<p>Another option is to create an <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">ordered dict</a> first, with the ids as keys:</p>
<pre><code>posts = OrderedDict((post.post_id, post) for post in stream)
post_list = list(posts.values())
</code></pre>
<p>This will keep the most recently seen <code>post</code> reference for a given <code>id</code>, but you'll still unique ids <em>only</em>.</p>
<p>If ordering isn't important, just use a regular dictionary comprehension:</p>
<pre><code>posts = {post.post_id: post for post in stream}
post_list = list(posts.values())
</code></pre>
<p>If you are using Python 3.6 or newer, then the order will be preserved <em>anyway</em> as the CPython implementation was updated to retain input order, and in Python 3.7 this feature became part of the language specification.</p>
<p>Whatever you do, don't use a separate <em>list</em> to test the <code>post.id</code> against, as that takes O(N) time <em>each time you check</em> to see if the id is present, where N is the number of items in your stream in the end. Combined with O(N) such checks, that approach would take O(N**2) quadratic time, meaning that for every 10-fold increase in the number of input items, you'd also take 100 times more time to process them all.</p>
<p>But when using a set or dictionary, testing if the id is already there only takes O(1) <em>constant</em> time, so checks are cheap. That makes a full processing loop take O(N) linear time, meaning that it'll take time directly proportional to how many input items you have.</p>
</div>
<div class="post-text" itemprop="text">
<p>This should work</p>
<pre><code>for post in stream:
    if post.post_id not in [post.post_id for post in post_list]:
        post_list.append(post)
</code></pre>
</div>
<span class="comment-copy">If you have control over the <code>post</code> class, you could create a <code>__hash__</code> method and use the value of <code>post_id</code> there, then just do <code>post_list = set(stream)</code></span>
<span class="comment-copy">@Peter: take into account that that won't preserver order! <code>list(OrderedDict.fromkeys(stream))</code> would keep the inputs in order of first-seen id.</span>
<span class="comment-copy">Ah yeah, to be fair I assumed from the way he'd worded it order didn't matter, hadn't really given it much thought though :P</span>
<span class="comment-copy">This is incredibly inefficient, as <code>not in</code> has to do a full scan of the list you generated. You also <i>re-generate the <code>post_id</code> list</i> each iteration. The combination is a killer, making this a O(N**3) quadratic approach where only O(N) linear time is ever needed. For 1000 items, your approach will take approximatly 1 million times as long as a O(N) linear approach.</span>
<span class="comment-copy">So yes, it should work, if you have the patience. This rapidly sucks up time as the input sequence becomes longer (10k items, 100 million times slower, 100k items, 10 billion times slower, etc).</span>
