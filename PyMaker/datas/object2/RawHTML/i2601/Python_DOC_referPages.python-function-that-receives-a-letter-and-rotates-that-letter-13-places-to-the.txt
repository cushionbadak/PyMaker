<div class="post-text" itemprop="text">
<p>I'm trying to create a Python function that uses the Caesar cipher to encrypt a message.   </p>
<p>So far, the code I have is</p>
<pre><code>letter = input("Enter a letter: ")
def alphabet_position(letter):
alphabet_pos = {'A':0, 'a':0, 'B':1, 'b':1, 'C':2, 'c':2, 'D':3,
                'd':3, 'E':4, 'e':4, 'F':5, 'f':5, 'G':6, 'g':6,
                'H':7, 'h':7, 'I':8, 'i':8, 'J':9, 'j':9, 'K':10,
                'k':10, 'L':11, 'l':11, 'M':12, 'm':12, 'N': 13,
                'n':13, 'O':14, 'o':14, 'P':15, 'p':15, 'Q':16,
                'q':16, 'R':17, 'r':17, 'S':18, 's':18, 'T':19,
                't':19, 'U':20, 'u':20, 'V':21, 'v':21, 'W':22,
                'w':22, 'X':23, 'x':23, 'Y':24, 'y':24, 'Z':25, 'z':25 }
pos = alphabet_pos[letter]
return pos  
</code></pre>
<p>When I try to run my code, it will ask for the letter but it doesn't return anything after that </p>
<p>Please help if you have any suggestions.</p>
</div>
<div class="post-text" itemprop="text">
<p>you would need to access your dictionary in a different way:</p>
<pre><code>pos = alphabet_pos.get(letter)
return pos
</code></pre>
<p>and then you can finally call the function.</p>
<pre><code>alphabet_position(letter)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can define two dictionaries, one the reverse of the other. You need to be careful on a few aspects:</p>
<ul>
<li>Whether case is important. If it's not, use <code>str.casefold</code> as below.</li>
<li>What happens when you roll off the end of the alphabet, e.g. 13th letter <em>after</em> "z". Below we assume you start from the beginning again.</li>
<li>Don't type out the alphabet manually. You can use the <code>string</code> module.</li>
</ul>
<p>Here's a demo:</p>
<pre><code>letter = input("Enter a letter: ")

from string import ascii_lowercase

def get_next(letter, n):
    pos_alpha = dict(enumerate(ascii_lowercase))
    alpha_pos = {v: k for k, v in pos_alpha.items()}
    return pos_alpha[alpha_pos[letter.casefold()] + n % 26]

get_next(letter, 13)

Enter a letter: a
'n'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you need a entirely new encoded dict</p>
<pre><code>import string
import numpy as np, random
letters = string.ascii_uppercase
d=dict(zip(list(letters),range(0,len(letters))))
encoded_dic={}

def get_caesar_value(v, by=13):
    return(v+by)%26

for k,v in d.items():
    encoded_dic[k]=chr(65+get_caesar_value(v))
print(encoded_dic)
</code></pre>
<p>Output:</p>
<pre><code>{'A': 'N', 'C': 'P', 'B': 'O', 'E': 'R', 'D': 'Q', 'G': 'T', 'F': 'S', 'I': 'V', 'H': 'U', 'K': 'X', 'J': 'W', 'M': 'Z', 'L': 'Y', 'O': 'B', 'N': 'A', 'Q': 'D', 'P': 'C', 'S': 'F', 'R': 'E', 'U': 'H', 'T': 'G', 'W': 'J', 'V': 'I', 'Y': 'L', 'X': 'K', 'Z': 'M'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The code you have only maps letters to a position.  We'll rewrite it and make a <code>rotate</code> function.</p>
<p><strong>Code</strong></p>
<pre><code>import string
import itertools as it


LOOKUP = {
    **{x:i for i, x in enumerate(string.ascii_lowercase)},
    **{x:i for i, x in enumerate(string.ascii_uppercase)}
}


def abc_position(letter):
    """Return the alpha position of a letter."""
    return LOOKUP[letter]
</code></pre>
<p></p>
<pre><code>def rotate(letter, shift=13):
    """Return a letter shifted some positions to the right; recycle at the end."""
    iterable = it.cycle(string.ascii_lowercase)
    start = it.dropwhile(lambda x: x != letter.casefold(), iterable)

    # Advance the iterator
    for i, x in zip(range(shift+1), start):
        res = x
    if letter.isupper():
        return res.upper()
    return res
</code></pre>
<p>Tests</p>
<pre><code>func = abc_position
assert func("a") == 0
assert func("A") == 0
assert func("c") == 2
assert func("z") == 25

func = rotate
assert func("h") == "u"
assert func("a", 0) == "a"
assert func("A", 0) == "A"
assert func("a", 2) == "c"
assert func("c", 3) == "f"
assert func("A", 2) == "C"
assert func("a", 26) == "a"
# Restart after "z"
assert func("z", 1) == "a"
assert func("Z", 1) == "A"
</code></pre>
<p><strong>Demo</strong></p>
<pre><code>&gt;&gt;&gt; letter = input("Enter a letter: ")
Enter a letter: h
&gt;&gt;&gt; rot = rotate(letter, 13)
&gt;&gt;&gt; rot
'u'
&gt;&gt;&gt; abc_position(rot)
20
</code></pre>
<p>Here we rotated the letter <code>"h"</code> 13 positions, got a letter and then determined the position of this resultant letter in the normal string of abc's.</p>
<hr/>
<p><strong>Details</strong></p>
<p><code>abc_position()</code></p>
<p>This function was rewritten to lookup the position of a letter.  It merges two dictionaries:</p>
<ol>
<li>one that enumerates a lowercase ascii letters</li>
<li>one that enumerates a uppercase ascii letters</li>
</ol>
<p>The <code>string</code> module has this letters already.</p>
<p><code>rotate()</code></p>
<p>This function only rotates lowercase letters; uppercase letters are translated from the lowercase position. The string of letters is rotated by making an infinite <code>cycle</code> (an iterator) of lowercase letters.</p>
<ol>
<li>The cycle is first advanced to <code>start</code> at the desired letter.  This is done by dropping all letters that don't look like the one passed in.  </li>
<li>Then it is advanced in a loop some number of times equal to <code>shift</code>.  The loop is just one way to consume or move the iterator ahead.  We only care about the last letter, not the ones in between.  This letter is returned, either lower or uppercase.  </li>
</ol>
<p>Since a letter is returned (not a position), you can now use your <code>abc_position()</code> function to find it's normal position.</p>
<p><em>Alternatives</em></p>
<p>Other rotation functions can substitute <code>rotate()</code>:</p>
<pre><code>import codecs


def rot13(letter):
    return codecs.encode(letter, "rot13")
</code></pre>
<p></p>
<pre><code>def rot13(letter):
    table = str.maketrans( 
        "ABCDEFGHIJKLMabcdefghijklmNOPQRSTUVWXYZnopqrstuvwxyz", 
        "NOPQRSTUVWXYZnopqrstuvwxyzABCDEFGHIJKLMabcdefghijklm")
    return str.translate(letter, table)
</code></pre>
<p>However, these options are constrained to rot13, while <code>rotate()</code> can be shifted  by any number.  Note: rot26 will cycle back to the beginning, e.g. <code>rotate("a", 26) -&gt; a</code>.</p>
<p>See also <a href="https://stackoverflow.com/questions/3269686/short-rot13-function-python">this post</a> on how to make true rot13 cipher.</p>
<p>See also docs on <a href="https://docs.python.org/3/library/itertools.html#itertools.cycle" rel="nofollow noreferrer"><code>itertools.cycle</code></a> and <a href="https://docs.python.org/3/library/itertools.html#itertools.dropwhile" rel="nofollow noreferrer"><code>itertools.dropwhile</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do it with quick calculations from <code>ord</code> and <code>chr</code> functions instead:</p>
<pre><code>def encrypt(letter):
    return chr((ord(letter.lower()) - ord('a') + 13) % 26 + ord('a'))
</code></pre>
<p>so that:</p>
<pre><code>print(encrypt('a'))
print(encrypt('o'))
</code></pre>
<p>outputs:</p>
<pre><code>n
b
</code></pre>
</div>
<span class="comment-copy">Fix your indentation, currently your code has an <code>IndentationError</code></span>
<span class="comment-copy">The other problem is that all you did was define a function, you never actually call it like <code>alphabet_position(letter)</code></span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/3269686/short-rot13-function-python">Short rot13 function - Python</a></span>
<span class="comment-copy">@Cut7er the OP will access the value of the dict by key, they are not trying to access by index</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/41009009/function-that-receives-and-rotates-character-caesar-cipher">Function That Receives and Rotates Character - Caesar Cipher</a></span>
