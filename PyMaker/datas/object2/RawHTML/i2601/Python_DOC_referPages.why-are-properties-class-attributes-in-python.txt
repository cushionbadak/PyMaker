<div class="post-text" itemprop="text">
<p>I'm reading <em>Fluent Python chapter 19 &gt; A Proper Look at Properties</em>, and I'm confused about the following words:</p>
<blockquote>
<p>Properties are always class attributes, but they actually manage attribute access in the instances of the class.</p>
</blockquote>
<p>The example code is:</p>
<pre><code>class LineItem:

    def __init__(self, description, weight, price):
        self.description = description
        self.weight = weight  # &lt;1&gt;
        self.price = price

    def subtotal(self):
        return self.weight * self.price

    @property  # &lt;2&gt;
    def weight(self):  # &lt;3&gt;
        return self.__weight  # &lt;4&gt;

    @weight.setter  # &lt;5&gt;
    def weight(self, value):
        if value &gt; 0:
            self.__weight = value  # &lt;6&gt;
        else:
            raise ValueError('value must be &gt; 0')  # &lt;7&gt;
</code></pre>
<p>From my previous experiences, class attributes are belong to the class itself and shared by all the instances. But here, weight, the property, is an instance method and the value returned by it is different between instances. How is it eligible to be a class attribute? Doesn't it that all the class attributes should be the same for any instances?</p>
<p>I think I misunderstand something, so I hope to get a correct explanation. Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>A distinction is made because when you define a <code>@property</code> on a class, that <em>property object</em> becomes an attribute on the class. Whereas when you define attributes against an <em>instance</em> of your class (in your <code>__init__</code> method), that attribute only exists against that object. This might be confusing if you do:</p>
<pre><code>&gt;&gt;&gt; dir(LineItem)
['__class__', ..., '__weakref__', 'subtotal', 'weight']

&gt;&gt;&gt; item = LineItem("an item", 3, 1.12)
&gt;&gt;&gt; dir(item)
['__class__', ..., '__weakref__', 'description', 'price', 'subtotal', 'weight']
</code></pre>
<p>Notice how both <code>subtotal</code> <em>and</em> <code>weight</code> exist as attributes on your class.</p>
<p>I think it's also worth noting that when you define a class, code under that class is executed. This includes defining variables (which then become class attributes), defining functions, and anything else.</p>
<pre><code>&gt;&gt;&gt; import requests

&gt;&gt;&gt; class KindOfJustANamespace:
...     text = requests.get("https://example.com").text
...     while True:
...         break
...     for x in range(2):
...         print(x)
...
0
1
&gt;&gt;&gt; KindOfJustANamespace.text
'&lt;!doctype html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Example Domain...'
</code></pre>
<p>A <code>@decorator</code> is just "<a href="https://en.wikipedia.org/wiki/Syntactic_sugar" rel="nofollow noreferrer">syntactic sugar</a>". Meaning <code>@property</code> over a function if the same as <code>function = property(function)</code>. This applies to functions defined inside a class as well, but now the function is part of the class's namespace.</p>
<pre><code>class TestClass:
    @property
    def foo(self):
        return "foo"
    # ^ is the same as:
    def bar(self):
         return "bar"
    bar = property(bar)
</code></pre>
<p>A good explanation of <code>property</code> in Python can be found here: <a href="https://stackoverflow.com/a/17330273/7220776">https://stackoverflow.com/a/17330273/7220776</a></p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>From my previous experiences, class attributes are belong to the class itself and shared by all the instances.</p>
</blockquote>
<p>That's right.</p>
<blockquote>
<p>But here, weight, the property, is an instance method</p>
</blockquote>
<p>No, it's a <code>property</code> object. When you do:</p>
<pre><code>@decorator
def func():
    return 42
</code></pre>
<p>it's actually syntactic sugar for</p>
<pre><code>def func():
    return 42

func = decorator(func)
</code></pre>
<p>IOW the <code>def</code> statement is executed, the function object created, but instead of beeing bound to it's name, it's passed to the <code>decorator</code> callable, and the name is bound to whatever <code>decorator()</code> returned. </p>
<p>In this case the decorator is the <code>property</code> class itself, so the <code>weight</code> attribute is a <code>property</code> instance. You can check this out by yourself by inspecting <code>LineItem.weight</code> (which will return the <code>property</code> object itself).</p>
<blockquote>
<p>and the value returned by it is different between instances. </p>
</blockquote>
<p>Well yes of course, how is this surprising ? <code>LineItem.subtotal</code> is a class attribute also (like all methods), yet it returns values from the instance it's called on (which is passed to the function as the <code>self</code> param). </p>
<blockquote>
<p>How is it eligible to be a class attribute? Doesn't it that all the class attributes should be the same for any instances?</p>
</blockquote>
<p>The class attributes ARE the same for all instances of a class, yes. There's only one single <code>subtotal</code> function for all instances of <code>LineItem</code>. </p>
<p>A <code>property</code> is mainly a shortcut to make a function (or a pair of functions if you specify a setter) look like it's a plain attribute, so when you type <code>mylinitem.weight</code>, what is really executed is <code>LineItem.weight.fget(mylineitem)</code>, where <code>fget</code> is the getter function you decorated with <code>@property</code>. The mechanism behind this is known as the <a href="https://docs.python.org/3/reference/datamodel.html#implementing-descriptors" rel="nofollow noreferrer">"descriptor protocol"</a>, which is also used to turn <code>mylineitem.subtotal()</code> into <code>LineItem.subtotal(mylineitem)</code> (python functions implement the descriptor protocol to return "method" objects, which are themselves wrappers around the function and the current instance and insert the instance as first argument to the function call). </p>
<p>So it's not suprising that properties are class attributes - you only need one <code>property</code> instance to "serve" all instances of the class -, and moreover, properties - like all descriptors FWIW - MUST actually be class attributes to work as expected, since the descriptor protocol is only invoked on class attributes (there's no use case for a "per instance" computed attribute since the function in charge of the "computation" will get the instance as parameter). </p>
</div>
<div class="post-text" itemprop="text">
<p>You didn't misunderstand. Don't worry, just read on. It will become clear in the next chapter. </p>
<p>The same book explains in chapter 20 that they can be a class attributes because of the <em>descriptor protocol</em>. The documentation explains how <a href="https://docs.python.org/3/howto/descriptor.html#properties" rel="nofollow noreferrer">properties are implemented as descriptors</a>.</p>
<p>As you see from the example, properties are really class attributes (methods). When called, they get a reference to the instance, and writes/reads to its underlying <code>__dict__</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think the example is wrong, the <strong>init</strong> shoul look like this:</p>
<pre><code>def __init__(self, description, weight, price):
    self.description = description
    self.__weight = weight  # &lt;1&gt; 
    self.__price = price
</code></pre>
<p>self.__weight and self.__price are the internal attributes hidden in the class by the properties</p>
</div>
<div class="post-text" itemprop="text">
<p>I finally understand the descriptor and property concept through <a href="http://simeonfranklin.com/talk/descriptors.html#title-slide" rel="nofollow noreferrer">Simeon Franklin's excellent presentation</a>, the following contents can be seen as a summary on his lecture notes. Thanks to him!</p>
<p>To understand properties, you first need to understand descriptors, because a property is implemented by a descriptor and python's decorator syntactic sugar. Don't worry, it's not that difficult.</p>
<p>What is a descriptor: </p>
<ul>
<li>a <strong>descriptor</strong> is any object that implements at least one of methods named __get__(), __set__(), and __delete__(). </li>
</ul>
<p>Descriptor can be divided into two categories: </p>
<ul>
<li>A <strong>data descriptor</strong> implements both __get__() and __set__().</li>
<li>A <strong>non-data descriptor</strong> implements only __get__().</li>
</ul>
<p>According to <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">python's HowTo</a>:</p>
<blockquote>
<p>a descriptor is an object attribute with “binding behavior”, one whose attribute access has been overridden by methods in the descriptor protocol. </p>
</blockquote>
<p>Then what is the descriptor protocol? Basically speaking, it's just says that when Python interpreter comes across an attribute access like <code>obj.attr</code>，it will search in some order to resolve this <code>.attr</code> , and if this <code>attr</code> is a descriptor attribute, then this descriptor will take some precedence in this specific order and this attribute access will be translated into a method call on this descriptor according to the descriptor protocol, possibly shadowing a namesake instance attribute or class attribute.  More concretely, if <code>attr</code> is a data descriptor, then <code>obj.attr</code> will be translated into the calling result of this descriptor's __get__ method; if <code>attr</code> is not a data descriptor and is an instance attribute, this instance attribute will be matched; if <code>attr</code> is not in above, and it is a non-data descriptor, we get the calling result of this non-data descriptor's __get__ method. Full rules on attribute resolution can be found <a href="http://simeonfranklin.com/talk/descriptors.html#slide-42" rel="nofollow noreferrer">here</a> .</p>
<p>Now let's talk about property.  If you have looked at <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">Python' descriptor HowTo</a>, you can find a pure Python version implementation of property:</p>
<pre><code>class Property(object):
    "Emulate PyProperty_Type() in Objects/descrobject.c"

    def __init__(self, fget=None, fset=None, fdel=None, doc=None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel
        if doc is None and fget is not None:
            doc = fget.__doc__
        self.__doc__ = doc

    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        if self.fget is None:
            raise AttributeError("unreadable attribute")
        return self.fget(obj)

    def __set__(self, obj, value):
        if self.fset is None:
            raise AttributeError("can't set attribute")
        self.fset(obj, value)

    def __delete__(self, obj):
        if self.fdel is None:
            raise AttributeError("can't delete attribute")
        self.fdel(obj)

    def getter(self, fget):
        return type(self)(fget, self.fset, self.fdel, self.__doc__)

    def setter(self, fset):
        return type(self)(self.fget, fset, self.fdel, self.__doc__)

    def deleter(self, fdel):
        return type(self)(self.fget, self.fset, fdel, self.__doc__)
</code></pre>
<p>Apparently，property is a data descriptor! </p>
<p>@property just uses python's decorator syntactic sugar. </p>
<pre><code>@property
def attr(self):
    pass
</code></pre>
<p>is equivalent to:</p>
<pre><code>attr = property(attr)
</code></pre>
<p>So, <code>attr</code> is no longer an instance method as I posted in thie question, but is translated into a <strong>class attribute</strong> by the decorator syntactic sugar as the author said. It's a descriptor object attribute.  </p>
<blockquote>
<p>How is it eligible to be a class attribute?</p>
</blockquote>
<p>OK, we solved it now.</p>
<p>Then:</p>
<blockquote>
<p>Doesn't it that all the class attributes should be the same for any instances?</p>
</blockquote>
<p>No!</p>
<p>I steal an example from <a href="http://simeonfranklin.com/talk/descriptors.html#title-slide" rel="nofollow noreferrer">Simeon Franklin's excellent presentation</a> .</p>
<pre><code>&gt;&gt;&gt; class MyDescriptor(object):
...     def __get__(self, obj, type):
...         print self, obj, type
...     def __set__(self, obj, val):
...         print "Got %s" % val
...
&gt;&gt;&gt; class MyClass(object):
...     x = MyDescriptor() # Attached at class definition time!
...
&gt;&gt;&gt; obj = MyClass()
&gt;&gt;&gt; obj.x # a function call is hiding here
&lt;...MyDescriptor object ...&gt; &lt;....MyClass object ...&gt; &lt;class '__main__.MyClass'&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; MyClass.x # and here!
&lt;...MyDescriptor object ...&gt; None &lt;class '__main__.MyClass'&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; obj.x = 4 # and here
Got 4
</code></pre>
<p>Pay attention to <code>obj.x</code> and its output. The second element in its output is <code>&lt;....MyClass object ...&gt;</code> . It's the specific instance <code>obj</code> . Shortly speaking, because this attribute access has been translated into a __get__ method call, and this __get__ method get the specific instance argument as its method signature <code>descr.__get__(self, obj, type=None)</code> demands, it can return different values according to which instance it is been called by.</p>
<p><em>Note: my English explanation maybe not clear enough, so I highly recommend you to look at Simeon Franklin's notes and Python's descriptor HowTo.</em></p>
</div>
<span class="comment-copy">Note that methods, too, are defined on the class (and hence class attributes), but when called on an instance, that instance is passed as an argument and thus available to the method. Checkout descriptors in detail: <a href="https://docs.python.org/2/howto/descriptor.html" rel="nofollow noreferrer">docs.python.org/2/howto/descriptor.html</a> and <a href="https://docs.python.org/3/reference/datamodel.html#descriptors" rel="nofollow noreferrer">docs.python.org/3/reference/datamodel.html#descriptors</a></span>
