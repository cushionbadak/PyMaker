<div class="post-text" itemprop="text">
<p>I am looking for a way to create some sort of terminal "clone" in Python 3.6 using subprocess. The clone should behave just like the real terminal. The goal is to have a python script simulating a shell which behaves as much as the normal shell as possible. Including commands like <code>cd</code> or variable declarations.</p>
<p>My target system is Linux with gnome shell, but my problems are probably cross OS relate. At first I din't think that was too hard as you can easily run terminal commands using subprocess but I encountered some problems.</p>
<p><strong><em>What I don't want to do:</em></strong></p>
<pre><code>#!/usr/bin/env python
import subprocess

while True:
    command = input(" &gt;&gt;&gt; ").rstrip('\n')
    if command == 'quit':
        break
    subprocess.run(command, shell=True)
</code></pre>
<p>There would be a very easy way to run commands one after each other. The problem with that is, that this will start a new process for every command. So if I do the following commands it doesn't work as I want to:</p>
<pre><code> &gt;&gt;&gt; ls
stackoverflow_subprocess.py
 &gt;&gt;&gt; cd ..
 &gt;&gt;&gt; ls
stackoverflow_subprocess.py
</code></pre>
<p>Because we start a new process every time, commands like cd do not have any effect. That's why I want to run all commands in the same process.</p>
<p><strong>First Attempt:</strong></p>
<pre><code>#!/usr/bin/env python
from subprocess import PIPE, Popen

pipe = Popen("/bin/bash", stdin=PIPE, stdout=PIPE, stderr=PIPE)

quit_command = "quit"
while True:
    command = input(" &gt;&gt;&gt; ")
    if command == quit_command:
        break
    command = str.encode(command + "\n")
    out, err = pipe.communicate(command)
    print(out,err)
</code></pre>
<p>This was my first attempt at solving my problem. This is what i got:</p>
<pre><code> &gt;&gt;&gt; echo hi
b'hi\n' b''
 &gt;&gt;&gt; echo hello
Traceback (most recent call last):
  File "/home/user/Python/Stackoverflow/subprocess.py", line 11, in &lt;module&gt;
    out, err = pipe.communicate(command)
  File "/usr/lib/python3.6/subprocess.py", line 818, in communicate
    raise ValueError("Cannot send input after starting communication")
ValueError: Cannot send input after starting communication

Process finished with exit code 1
</code></pre>
<p>So I can't just write multiple commands like this.</p>
<p><strong>Second Attempt:</strong></p>
<pre><code>#!/usr/bin/env python
from subprocess import PIPE, Popen

fw = open("tmpout", "wb")
fr = open("tmpout", "r")

pipe = Popen("/bin/bash", stdin=PIPE, stdout=fw, stderr=fw, bufsize=1)

quit_command = "quit"
while True:
    command = input(" &gt;&gt;&gt; ")
    if command == quit_command:
        break
    command = str.encode(command + "\n")
    pipe.stdin.write(command)
    out = fr.read()
    print(out)
</code></pre>
<p>This attempt was based on another stackoverflow question which was similar to mine: <a href="https://stackoverflow.com/questions/19880190/interactive-input-output-using-python#19893052">Interactive input/output using python</a></p>
<pre><code> &gt;&gt;&gt; echo hi

 &gt;&gt;&gt; echo hello 

 &gt;&gt;&gt; quit

Process finished with exit code 0
</code></pre>
<p>However, this did not work as well. <code>out</code> was just an empty string. When I looked into it i realized, that the content of <code>tmpout</code> does not get written to the file until the program finished. Even if you close and reopen <code>fw</code> between each iteration it still just writes to <code>tmpout</code> after the program finishes.</p>
<p>Contents of <code>tmpout</code> <em>after</em> program finished:</p>
<pre><code>hi
hello
</code></pre>
<p><strong>Third Attempt:</strong></p>
<pre><code>#!/usr/bin/env python
from subprocess import PIPE, Popen

import os
import fcntl
from subprocess import Popen, PIPE


def setNonBlocking(fd):
    """
    Set the file description of the given file descriptor to non-blocking.
    """
    flags = fcntl.fcntl(fd, fcntl.F_GETFL)
    flags = flags | os.O_NONBLOCK
    fcntl.fcntl(fd, fcntl.F_SETFL, flags)


p = Popen("/bin/bash", stdin=PIPE, stdout=PIPE, stderr=PIPE, bufsize=1)
setNonBlocking(p.stdout)
setNonBlocking(p.stderr)

quit_command = "quit"
while True:
    command = input(" &gt;&gt;&gt; ")
    if command == quit_command:
        break
    command = str.encode(command + "\n")

    p.stdin.write(command)
    while True:
        try:
            out = p.stdout.read()
        except IOError:
            continue
        else:
            break
    out = p.stdout.read()
    print(out)
</code></pre>
<p>At last I tried the second solution from the Stackoverflow question mentioned above. This didn't work as well, as it just always returned <code>None</code>:</p>
<pre><code> &gt;&gt;&gt; echo hi
None
 &gt;&gt;&gt; echo hello
None
 &gt;&gt;&gt; quit

Process finished with exit code 0
</code></pre>
<p><strong>Question:</strong>
Does anyone know a way to solve any of these issues? Is it possible to communicate more commands even after communication started? Or is it possible for the file to be written before the program ends? Or does anyone know how to get the actual output instead of just <code>None</code> for the last attempt?</p>
<p>Thank you in advance :)</p>
</div>
<div class="post-text" itemprop="text">
<p>Ok, so as it turns out, it is not that easy to run multiple command in the same process in order to keep shell builtins like <code>cd</code> or variable assignment. But They can be implemented yourself in python. So here is my version of an interactive Shell in Python using subprocess:</p>
<pre><code>#!/usr/bin/env python

from subprocess import run
from os import path, curdir, chdir

home_dir = path.expanduser("~")


# Gets current directory and replaces your home directory with "~"
def current_dir():
    return path.abspath(curdir).replace(home_dir, "~")


# Escapes a string by replacing spaces " " with "\s" between quotation marks
def escape_space(string):
    out = ""
    quote = False
    for letter in string:
        quote = (quote != (letter == "\""))  # quote &lt;- quote XOR letter is "
        if quote and letter == " ":
            letter = "\s"
        out += letter
    return out


# Dictionary that holds all variables
var_dict = {}


# Handles Variables
def handle_vars(command_args):
    for i in range(len(command_args)):
        arg = command_args[i]

        # Replace variables with their value
        if arg[0] == "$":
            if arg[1:] in var_dict:
                command_args[i] = var_dict[arg[1:]]
            else:
                command_args[i] = ""

        # Add new variable
        elif "=" in arg:
            arg_split = arg.split("=")
            var_dict[arg_split[0]] = arg_split[1]


quit_flag = False

if __name__ == "__main__":
    while True:
        display_dir = "\033[34m{}\033[39m$ ".format(current_dir())  # The current directory with color
        commands = input(display_dir).rstrip('\n').split(";")

        # Repeat for all commands (multiple commands are possible with ";")
        for cmd in commands:

            cmd = escape_space(cmd)
            command_args = cmd.split(" ")

            handle_vars(command_args)

            if command_args[0] == "quit":
                quit_flag = True
                break
            elif command_args[0] == "cd":
                chdir(command_args[1])  # change execution dir
            else:
                command = " ".join(command_args).replace("\s", " ")
                run(command, shell=True)

        if quit_flag:
            break

    print("Shell Terminated.")
</code></pre>
<p>This allows me to use <code>cd</code>, variables and also strings surrounded by double quotes (").
I hope this helps anyone who has a similar problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>Are you looking simply for this?</p>
<pre><code>#!/usr/bin/env python

import subprocess

while True:
    command = input(" &gt;&gt;&gt; ").rstrip('\n')
    if command == 'quit':
        break
    subprocess.run(command, shell=True)
</code></pre>
<p>As the following brief demo shows, it has some obvious flaws; but it certainly shows how to simply get out of the way by leaving the stdout and stderr of the subprocess alone.</p>
<pre><code> &gt;&gt;&gt; echo hello
hello
 &gt;&gt;&gt; foo=bar
 &gt;&gt;&gt; echo "$foo"

 &gt;&gt;&gt; # each command runs in a separate subshell
 &gt;&gt;&gt; ^D
Traceback (most recent call last):
  File "/tmp/psh", line 6, in &lt;module&gt;
    command = input(" &gt;&gt;&gt; ").rstrip('\n')
EOFError
</code></pre>
</div>
<span class="comment-copy">In your third attempt: Have you tried printing p.stdout directly without the .read() ? For the subproccess I am using at the moment it worked that way. Btw what Version of Python are you using?</span>
<span class="comment-copy">@Sharku Without read it just returns a <code>_io.BufferReader</code> Object. I'm Using Python 3.6</span>
<span class="comment-copy">alright, I have another suggestion: I think the first time you call .read() in the While loop, you emtpy the buffer. So the second time it is empty and returns None. Here the link to the documentation <a href="https://docs.python.org/3/library/io.html#io.RawIOBase.read" rel="nofollow noreferrer">docs.python.org/3/library/io.html#io.RawIOBase.read</a> Either way you don't have to redefine out at the end.</span>
<span class="comment-copy">@Sharku good Idea, but I just tried printing <code>p.stdout</code> as well as <code>p.stdout.read()</code> inside the while loop and i get the same result. The documentations says that <code>None</code> is returned if there are no bytes available so I think that is the case.</span>
<span class="comment-copy">rather than tons of information about your failed trials, how about a simple description of what you are trying to achieve?  .. it's not very clear to me what that is.</span>
<span class="comment-copy">With a slightly larger parsing effort you can get rid of the <code>shell=True</code>, though you'll probably want to handle quoted strings properly first.</span>
<span class="comment-copy">The problem with this is, that you open a new shell every time. So when you do <code>cd ..</code> then you don't really go back in the directory since it will start a new process every time.</span>
<span class="comment-copy">Inleed; and yet, this is a fairly reasonable aporoximation of what Bash actually does. The way to proceed is to implement <code>cd</code>, variable assigments, and eventually other shell builtins in your Python shell itself.</span>
<span class="comment-copy">Ok yeah I just figured out that it's fairly easy to just change the execution path with <code>os.chdir()</code> so I can Implement the needed shell builtins myself :)</span>
<span class="comment-copy">If this answer helped you form a better understanding, please consider upvoting, if not accepting.  See also <a href="/help/someone-answers">help</a>. Thanks in advance.</span>
