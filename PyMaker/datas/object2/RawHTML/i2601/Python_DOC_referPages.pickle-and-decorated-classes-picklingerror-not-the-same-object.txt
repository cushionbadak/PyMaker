<div class="post-text" itemprop="text">
<p>The following minimal example uses a dummy decorator, that justs prints some message when an object of the decorated class is constructed.</p>
<pre><code>import pickle


def decorate(message):
    def call_decorator(func):
        def wrapper(*args, **kwargs):
            print(message)
            return func(*args, **kwargs)

        return wrapper

    return call_decorator


@decorate('hi')
class Foo:
    pass


foo = Foo()
dump = pickle.dumps(foo) # Fails already here.
foo = pickle.loads(dump)
</code></pre>
<p>Using it however makes <code>pickle</code> raise the following exception:</p>
<pre><code>_pickle.PicklingError: Can't pickle &lt;class '__main__.Foo'&gt;: it's not the same object as __main__.Foo
</code></pre>
<p>Is there anything I can do to fix this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Pickle requires that the <code>__class__</code> attribute of instances can be loaded via importing. </p>
<p>Pickling instances only stores the instance data, and the <code>__qualname__</code> and <code>__module__</code> attributes of the class are used to later on re-create the instance by importing the class again and creating a new instance for the class.</p>
<p>Pickle validates that the class can actually be imported first. The <code>__module__</code> and <code>__qualname__</code> pair are used to find the correct module and then access the  object named by <code>__qualname__</code> on that module, and if the <code>__class__</code> object and the object found on the module don't match, the error you see is raised.</p>
<p>Here, <code>foo.__class__</code> points to a class object with <code>__qualname__</code> set to <code>'Foo'</code> and <code>__module__</code> set to <code>'__main__'</code>, but <code>sys.modules['__main__'].Foo</code> doesn't point to a class, it points to a function instead, the <code>wrapper</code> nested function your decorator returned.</p>
<p>There are two possible solutions:</p>
<ul>
<li><p>Don't return a function, return the original class, and perhaps instrument the class object to do the work the wrapper does. If you are acting on the arguments for the class constructor, add or wrap a <code>__new__</code> or <code>__init__</code> method on the decorated class.</p>
<p>Take into account that unpickling usually calls <code>__new__</code> on the class to create a new empty instance, before restoring the instance state (unless pickling has been <a href="https://docs.python.org/3/library/pickle.html#pickling-class-instances" rel="nofollow noreferrer">customised</a>).</p></li>
<li><p>Store the class under a new location. Alter the <code>__qualname__</code> and perhaps the <code>__module__</code> attributes of the class to point to a location where the original class can be found by pickle. On unpickling the right type of instance will be created again, just like the original <code>Foo()</code> call would have.</p></li>
</ul>
<p>Another option is to customise pickling for the produced class. You can give the class <a href="https://docs.python.org/3/library/pickle.html#object.__reduce_ex__" rel="nofollow noreferrer">new <code>__reduce_ex__</code></a> and <a href="https://docs.python.org/3/library/pickle.html#object.__reduce__" rel="nofollow noreferrer">new <code>__reduce__</code></a> methods that point to the wrapper function or a custom reduce function, instead. This can get complex, as the class may already have customised pickling, and <code>object.__reduce_ex__</code> provides a default, <em>and</em> the return value can differ by pickle version.</p>
<p>If you don't want to alter the class, you can also use the <a href="https://docs.python.org/3/library/copyreg.html#copyreg.pickle" rel="nofollow noreferrer"><code>copyreg.pickle()</code> function</a> to register a custom <code>__reduce__</code> handler for the class.</p>
<p>Either way, the return value of the reducer should still avoid referencing the class and should reference the new constructor instead, by the name that it can be imported with. This can be problematic if you use the decorator directly with <code>new_name = decorator()(classobj)</code>. Pickle itself would not deal with such situations either (as <code>classobj.__name__</code> would not match <code>newname)</code>.</p>
</div>
<span class="comment-copy"><code>__main__.Foo</code> has been replaced by wrapper <i>function</i>, so it is no longer a class. Pickle can't handle that case, because the <code>foo.__class__</code> attribute points to a class object that pickle <i>can't load</i>. What is the goal of the decorator?</span>
<span class="comment-copy">@MartijnPieters: It's the <code>type_checked_call</code> decorator in my library: <a href="https://github.com/Dobiasd/undictify" rel="nofollow noreferrer">github.com/Dobiasd/undictify</a></span>
<span class="comment-copy">That decorator should return the class unchanged. Replace the <code>__init__</code> or <code>__new__</code> method of the class with a wrapper, instead.</span>
<span class="comment-copy">Thanks a lot. I'm now replacing the <code>__new__</code> function of the class in my <a href="https://gist.github.com/Dobiasd/c2f6dbe2aafd1210cca9c305687100c7" rel="nofollow noreferrer">updated minimal example</a>. It's OK in this use case, but a problem arises when the decorator function is not used as a decorator, but called normally instead. In that case other parts of the code should not be affected, but since we patch the whole class, it actually does (<a href="https://gist.github.com/Dobiasd/ce58c5620e8a2df321962aca44d1d8bf" rel="nofollow noreferrer">code</a>). Any idea how this could be solved?</span>
<span class="comment-copy">@TobiasHermann: yes, if you modify the class in place in multiple you can't re-use the decorator to produce multiple 'copies'. Another option is to subclass and give the subclass the same name and module, perhaps. Subclassing requires that the classes themselves behave correctly when it comes to calling overridden methods, however, as the <code>Foo.somemethod</code> reference would now pass through your shim subclass depending on if <code>super()</code> was used or  a direct reference. The   MRO of subclasses <i>may</i> be affected too.</span>
<span class="comment-copy">You mean like <a href="https://gist.github.com/Dobiasd/0fa1c5dce2e1ad47c579ced8fd3de1d8" rel="nofollow noreferrer">this</a>? (It seems to work.)</span>
<span class="comment-copy">@TobiasHermann: note that any other use of <code>newname = decorator()(classobj)</code> would also fail to work with pickle <i>anyway</i>, as pickle demands that <code>classobj.__name__</code> be available for import.</span>
<span class="comment-copy">@TobiasHermann: your example doesn't use cooperative inheritance. Try subclassing the decorated result with mixin classes or a diamond-inheritance, and <code>__init__</code> methods using <code>super().__init__()</code> to call the next initialiser in MRO order. You hardcode the next object whose <code>__init__</code> method is called by using <code>the_class.__init__</code>. And if you switched to <code>super(self, the_class).__init__(*args, **kwargs)</code> instead, you'll break code that uses <code>Foo.__init__()</code> calls in a subclass (and that code would break <i>today</i>, as <code>Foo.__init__</code> can't be reached through your wrapper).</span>
