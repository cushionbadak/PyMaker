<div class="post-text" itemprop="text">
<p>I want to have a dictionary in which the keys are tuples such as (1, 0). However, I want all keys of the form (n, 0) to identify with a similar output, and it'd be nice if I didn't have to have all the tuples from (1, 0) to (n, 0) as keys in my dictionary. Is there a simple way I can do this?</p>
<pre><code>dictionary = {(n, 1): [n, 3], (n, 2): [5, n], (n, 0): [0, n]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to make a dict with a special rule for handling keys that aren't actually stored in the dict hash table, you want to create a subclass of <code>dict</code> that implements <a href="https://docs.python.org/3/reference/datamodel.html#object.__missing__" rel="nofollow noreferrer"><code>__missing__</code></a>:</p>
<blockquote>
<p>Called by <code>dict.__getitem__()</code> to implement <code>self[key]</code> for <code>dict</code> subclasses when key is not in the dictionary.</p>
</blockquote>
<p>Like this:</p>
<pre><code>class SpecialDict(dict):
    def __missing__(self, key):
        if isinstance(key, tuple) and len(key) == 2 and key[1] == 0:
            return [0, key]
        raise KeyError(key)
</code></pre>
<p>I don't really understand how your example is supposed to work, so here's a different example to demonstrate it:</p>
<pre><code>&gt;&gt;&gt; d = SpecialDict({(1, 1): [2, 3], (1, 2): [5, 4]})
&gt;&gt;&gt; d[1, 1]
[2, 3]
&gt;&gt;&gt; d[2, 2]
KeyError: (2, 2)
&gt;&gt;&gt; d[20, 0]
[0, 20]
</code></pre>
<p>If you store a value for a <code>(n, 0)</code> key, it won't call <code>__missing__</code> for that key, allowing you to override a single <code>(n, 0)</code> while leaving the rest with their special rule:</p>
<pre><code>&gt;&gt;&gt; d[42, 0] = [23, 23]
&gt;&gt;&gt; d[42, 0]
[23, 23]
&gt;&gt;&gt; d[23, 0]
[0, 23]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just copy the value (1,0) to (n,0) and then delete the element (1,0) from dict. Like these: </p>
<pre><code>dictionary[n,0] = dictionary[1,0]
del dictionary[1,0]
</code></pre>
<p>and so on, But for identifying for similar output you have to make the value into tuple by using set() and then take the difference with the key. Like these:</p>
<pre><code> for key in dictionary:
    if set(key) - set(dictionary[key]) is set():
       print("Similar key value pair")
</code></pre>
</div>
<span class="comment-copy">rebuild your dict with "n" as key and a list of values instead?</span>
<span class="comment-copy">Are you trying to make all the <code>(n, 0)</code> keys share a single value, or are you trying to make any <code>(n, 0)</code> key map to <code>[0, n]</code> without storing an infinite number of items?</span>
<span class="comment-copy">I want them all to map to <code>[0, n]</code></span>
