<div class="post-text" itemprop="text">
<p>I'd like to modify a class method to do some things in addition to the original method call. I have a toy example posted below.</p>
<p>Example:</p>
<pre><code>class str2(str):
    def __init__(self, val):
        self.val = val

    def upper(self):
        print('conveting to upper')
        return self.upper()

x = str2('a')
print(x.upper())
</code></pre>
<p>This does what I should have expected and gives a maximum recursion depth error. Is it possible to modify the <code>upper</code> method so that it prints some text before calling the actual <code>str.upper</code> method, while ideally keeping the name the same? </p>
<p>I've been wondering if this is the situation to use a decorator, but I am not familiar enough with them to have a clear idea on how to do this.</p>
</div>
<div class="post-text" itemprop="text">
<p>The solution would be:</p>
<pre><code>class str2(str):
    def __init__(self, val):
        self.val = val

    def upper(self):
        print('conveting to upper')
        return str.upper(self.val)

x = str2('a')
print(x.upper())
</code></pre>
<h3>My point to the your code:</h3>
<ol>
<li><p>in <code>upper</code> function you just print it then go to same function again and again</p></li>
<li><p>this makes it that it will keep printing</p></li>
<li><p>it raises an error at the end because python basically has enough of this</p></li>
</ol>
<h3>My point to my code:</h3>
<ol>
<li><p>use the method-descriptor (<code>&lt;method 'upper' of 'str' objects&gt;</code>) to use it so it doesn't confuse it with <code>self</code></p></li>
<li><p>use that because it will still be calling the real <code>str</code> class (not the metaclass)</p></li>
</ol>
<p>I am also blaming myself that why i didn't think of:</p>
<pre><code>class str2(str):
    def __init__(self, val):
        self.val = val

    def upper(self):
        print('conveting to upper')
        return self.val.upper()

x = str2('a')
print(x.upper())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In the method <code>str2.upper</code> you are calling <code>str2.upper</code> which in turn calls <code>str2.upper</code> which... You see where this is going.</p>
<p>What you probably intended to so was to call <code>str.upper</code> from <code>str2.upper</code>. This is done by using <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer"><code>super</code></a>. Calling <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer"><code>super()</code></a> returns an object which delegates method calls to the parent classes.</p>
<pre><code>class str2(str):
    def upper(self):
        print('converting to upper')
        return super().upper()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Research "Mapping" and "decorators" - I think there's an easier/more pythonic way to do what you're trying to do.</p>
</div>
<div class="post-text" itemprop="text">
<p>As @Schalton stated, there is a way to do it without having to inherit from str by using decorators. Consider this snippet:</p>
<pre><code>def add_text(func):
    def wrapper(*args, **kwargs):
        print('converting to upper')
        return func(*args)
    return wrapper

class str2:
    def __init__(self, val):
        self.val = val

    @add_text
    def upper(self):
        return self.val.upper()

instance = str2('a')

print(instance.upper())
</code></pre>
<p>The great advantage of this is that the wrapper is reusable, e.g. if you have another class that you want to modify with the exact same behavior, you can just add the @decorator and don't have to redo all the work. Also, removing the additional functionality gets also easier.</p>
</div>
<span class="comment-copy">You should call <code>super().upper</code>. Otherwise you are calling the same method, which calls itself recursively forever.</span>
<span class="comment-copy">You should use <code>super</code>, otherwise any inheritance will be broken.</span>
<span class="comment-copy">@OlivierMelançon I will edit</span>
<span class="comment-copy">@OlivierMelançon sorry but i don't now <code>super</code> so maybe, you should answer it as an answer, but i did another solution</span>
<span class="comment-copy">Sure, I'll do it later and tag you in!</span>
<span class="comment-copy">@OlivierMelançon Thanks a lot for your help, i'll up-vote your answer</span>
