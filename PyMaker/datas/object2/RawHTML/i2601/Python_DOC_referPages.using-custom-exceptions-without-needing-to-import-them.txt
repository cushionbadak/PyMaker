<div class="post-text" itemprop="text">
<p>I've defined a few custom exceptions for one of my projects. Much in the way one can use a standard Python exception (e.g. ZeroDivisionError) without needing to <code>import</code> anything, is there any way I could set up my project to have my custom exceptions exposed to all of the files in one of my packages?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python puts all of the builtin exception types into the <a href="https://docs.python.org/3/library/builtins.html" rel="nofollow noreferrer"><code>builtins</code></a> module. So, no matter where you evaluate <code>ZeroDivisionError</code>, it can be found.<sup>1</sup></p>
<p>Your exceptions aren't in <code>builtins</code>, they're in whatever module you defined them in. So, they have to be accessed as <code>mymodule.MyError</code>, or imported with something like <code>from mymodule import MyError</code>.</p>
<p>Also, as N. Chauhan points out in <a href="https://stackoverflow.com/questions/52085506/using-custom-exceptions-without-needing-to-import-them/52086002#comment91121940_52085506">a comment</a>, you rarely need more than a handful of public exception types—often only one. You might have 30 different error types that matter <em>internally</em>, but your users probably only care about 1 or 2 different kinds of errors, so you can make your 30 types all subclasses of 1 or 2 base classes, and your users only have to <code>import</code> those.</p>
<hr/>
<p>Could you do the same trick? Yes, and it's actually pretty easy<sup>2</sup>—but it's almost always a bad idea.</p>
<p>It might sound like that would be handy for interactive programming at the REPL—but it isn't needed there. Just add new stuff into the current (<code>__main__</code>) module, and it's just as accessible as if it were in <code>builtins</code>, right? And Python provides syntactic sugar for doing that. In fact, that's exactly what <code>from mymodule import MyError</code> does: it adds <code>MyError</code> into the current module's globals.</p>
<p>And for non-interactive programming, putting stuff into builtins makes your code confusing and hard to read.</p>
<p>If I see <code>MyError</code> in some code, and <code>from mymodule import MyError</code> at the top, it's obvious where it came from. If I don't, then there's no way to figure out where <code>MyError</code> came from except by exhaustively searching the entire codebase and all site-packages modules imported anywhere.</p>
<p>And it's even harder for IDEs and other tools that help you write and navigate your code. If I hover over <code>MyError</code> in PyCharm, and there's a <code>from mymodule import MyError</code> at the top, PyCharm immediately knows where it came from and can show a nice tooltip with whatever information seems useful. I can right-click it and it can jump to the definition of <code>MyError</code>. If I enable static type checking, it knows what a <code>MyError</code> is and can verify that it's a subclass of <code>Exception</code>. And so on. But without that <code>import</code>, there is no way PyCharm could possibly know what <code>MyError</code> means.</p>
<hr/>
<p><sub>1. When you evaluate <code>ZeroDivisionError</code>, the oversimplified version of the way it works is that if it's not a local or free variable, Python looks for it in globals, and, if it's not there, in builtins. (For a deeper explanation, see the <a href="https://docs.python.org/3/library/functions.html#eval" rel="nofollow noreferrer"><code>eval</code> and <code>exec</code></a> docs, and for full details, see <a href="https://docs.python.org/3/reference/executionmodel.html#resolution-of-names" rel="nofollow noreferrer">Resolution of names</a>.)</sub></p>
<p><sub>2. How do you do it? You <em>can</em> substitute a different <code>builtins</code> module into globals that happens to include your extra stuff, but the really easy way is to just <code>import builtins</code> and just add new stuff into it, like <code>builtins.MyError = MyError</code>.</sub></p>
</div>
<span class="comment-copy">That is not possible, as exceptions are just regular classes in Python, with the main difference being that the built-in ones are, well, in the <code>builtins</code> module. However, it is not possible nor desirable to add custom classes to that module.</span>
<span class="comment-copy">What you can do is keep your exceptions in one place, and then just do <code>from myexceptions import *</code> at the beginning of your files.</span>
<span class="comment-copy">@FallenWarrior It definitely is <i>possible</i>; it's even <i>easy</i>. But you're right that it's not desirable.</span>
<span class="comment-copy">How many exceptions have you defined? If it's a few, then you <i>should</i> try and generalise and combine them into 1, and when raised have an error message that gives details. In fact, it is most desirable to use builtin exceptions before having to end up making new ones. E.g. <code>connectionError</code>, <code>RequestError</code> and <code>WebsiteError</code> should be combined into one error, say <code>HTTPError</code>. If you manage to define only one error, you're left to choose whether to import it into each file or to define it again in each file.</span>
<span class="comment-copy">@NChauhan when I am completely done with development, I will likely have 12-15 of them. They are mainly going to be used for hardware communication errors between a control board and my Raspberry Pi, and each different case could have different additional information. The hardware is designed to interface with MRI technology for during-scan operations, so knowing exactly what goes wrong where is important. Thank you for your feedback.</span>
<span class="comment-copy">Thanks for the insight. My current structure has a base exception class (so that way I can just catch one specific thing in most cases) with multiple subclasses. I have quite a few, because I'm using them to highlight specific hardware issues.</span>
