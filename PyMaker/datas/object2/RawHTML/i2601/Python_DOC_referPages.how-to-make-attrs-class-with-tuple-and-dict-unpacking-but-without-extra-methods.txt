<div class="post-text" itemprop="text">
<p>I just started using the <code>attrs</code> module for python which is pretty slick (or similarly we could use Python 3.7 DataClasses).  A common usage pattern that I have is for the class to be a container for parameter values.  I like the labeling when I assign the parameters, and the cleaner attribute style referencing of values, but I also like to have a couple of features that are nice when storing the values in something like an ordered dict:</p>
<ol>
<li><code>*</code> unpacking like a <code>tuple</code> or a <code>list</code> to feed into function arguments</li>
<li><code>**</code> unpacking when keyword passing is necessary or desirable.</li>
</ol>
<p>I can achieve all this by adding three methods to the class</p>
<pre class="lang-py prettyprint-override"><code>@attr.s
class DataParameters:
    A: float = attr.ib()
    alpha: float = attr.ib()
    c: float = attr.ib()
    k: float = attr.ib()
    M_s: float = attr.ib()

    def keys(self):
        return 'A', 'alpha', 'c', 'k', 'M_s'

    def __getitem__(self, key):
        return getattr(self, key)

    def __iter__(self):
        return (getattr(self, x) for x in self.keys())
</code></pre>
<p>Then I can use the classes like this:</p>
<pre><code>params = DataParameters(1, 2, 3, 4, 5)
result1 = function1(100, 200, *params, 300)
result2 = function2(x=1, y=2, **params)
</code></pre>
<p>The motivation here is that the dataclasses provide convenience and clarity.  However there are reasons why I don't what the module I'm writing to require using the data class.  It is desireable that the function calls should accept simple arguments, not complex dataclasses.</p>
<p>The above code is fine but I am wondering if I am missing something that would allow me to skip writing the functions at all since the pattern is pretty clear.  Attributes are added in the order I would like them unpacked, and can be read as key-value pairs based on the attribute name for keyword arguments.</p>
<p>Maybe this is something like:</p>
<pre><code>@addtupleanddictunpacking
@attr.s
class DataParameters:
    A: float = attr.ib()
    alpha: float = attr.ib()
    c: float = attr.ib()
    k: float = attr.ib()
    M_s: float = attr.ib()
</code></pre>
<p>but I am not sure if there is something in <code>attrs</code> itself that does this that I haven't found.  Also, I am not sure how I would keep the ordering of the attributes as they are added and translate that into the keys method as such.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's not integrated directly into the class, but <a href="http://www.attrs.org/en/stable/api.html#attr.asdict" rel="nofollow noreferrer">the <code>asdict</code></a> and <a href="http://www.attrs.org/en/stable/api.html#attr.astuple" rel="nofollow noreferrer"><code>astuple</code></a> helper functions are intended to perform this sort of conversion.</p>
<pre><code>params = DataParameters(1, 2, 3, 4, 5)
result1 = function1(100, 200, *attr.astuple(params), 300)
result2 = function2(x=1, y=2, **attr.asdict(params))
</code></pre>
<p>They're not integrated into the class itself because that would make the class behave as a sequence or mapping <em>everywhere</em>, which can cause silent misbehavior when a <code>TypeError</code>/<code>AttributeError</code> would be expected. Performance-wise, this should be fine; unpacking would convert to <code>tuple</code>/<code>dict</code> anyway (it can't pass stuff that isn't a <code>tuple</code> or <code>dict</code> in directly, as the C APIs expect to be able to use the type-specific APIs on their arguments).</p>
<p>If you really want the class to act as a sequence or mapping, you basically have to do what you've done, though you could use the helper functions to reduce custom code and repeated variable names, e.g.:</p>
<pre><code>@classmethod
def keys(cls):
    return attr.fields_dict(cls).keys()

def __getitem__(self, key):
    return getattr(self, key)

def __iter__(self):
    return iter(attr.astuple(self, recurse=False))  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Extending the ideas from @ShadowRanger, it is possible to make your own decorator that incorporates attr.s and attr.ib for a more concise solution that basically adds in extra processing.</p>
<pre><code>import attr
field = attr.ib  # alias because I like it

def parameterset(cls):
    cls = attr.s(cls)

    # we can use a local variable to store the keys in a tuple
    # for a faster keys() method
    _keys = tuple(attr.fields_dict(cls).keys())
    @classmethod
    def keys(cls):
    #     return attr.fields_dict(cls).keys()
        return (key for key in _keys)

    def __getitem__(self, key):
        return getattr(self, key)

    def __iter__(self):
        return iter(attr.astuple(self, recurse=False))

    cls.keys = keys
    cls.__getitem__ = __getitem__
    cls.__iter__ = __iter__

    return cls

@parameterset
class DataParam:
    a: float = field()
    b: float = field()

dat = DataParam(a=1, b=2)
print(dat)
print(tuple(dat))
print(dict(**dat))
</code></pre>
<p>gives the output</p>
<pre><code>DataParam(a=1, b=2)
(1, 2)
{'a': 1, 'b': 2}
</code></pre>
</div>
<span class="comment-copy">I'm not familiar with <code>attrs</code> library, but maybe you can try Python3.7's built-in dataclass</span>
<span class="comment-copy">@pkqxdd, at this time I do not want to require python 3.7.  However, an example of how that work work (if you know) would probably be helpful in using an attrs version.  AFAIK, dataclass is simpler version of attrs so if it can be done there, it can probably be done in attrs</span>
<span class="comment-copy">Note that both <code>astuple</code> and <code>asdict</code> are available for the (as of 3.7) Python <a href="https://docs.python.org/3/library/dataclasses.html" rel="nofollow noreferrer">standard <code>dataclasses</code> module</a>, so the same basic uses are possible without third party modules at this point.</span>
<span class="comment-copy">Thanks very much.  Where appropriate, it is possible to create an abstract class with these methods to use as a parent for the DataParameter, since the methods work regardless of the fields initialized.</span>
<span class="comment-copy">@VinceW.: Yeah, that is an advantage to this approach. That said, my <code>keys</code> would be (possibly significantly) slower than your <code>keys</code> (since yours would amount to loading and returning a cached <code>tuple</code> of constant <code>str</code>s, while mine involves multiple function calls constructing temporaries. My <code>keys</code> <i>could</i> be slightly optimized, at the expense of writing a tiny bit more custom code, by having it <code>return (a.name for a in attr.fields(cls))</code> (or roughly equivalently, possibly slightly faster if there are many fields, <code>return map(operator.attrgetter('name'), attr.fields(cls))</code>).</span>
<span class="comment-copy">The slowdown won't matter much if you're not performing <code>**</code>-unpacking of your dataclass in the hottest of code paths, but it's worth considering. If that becomes a problem, the subclass could always manually override <code>keys</code> with a hard-coded version.</span>
<span class="comment-copy">thanks for the many inputs.  I took some of your ideas and posted a followup answer for what is a cleaner solution of making a new decorator that extends the attr.s decorator.  There is probably a way to include a <b>post_init</b> method to incorporate some speedup options</span>
