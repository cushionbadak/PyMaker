<div class="post-text" itemprop="text">
<p>I like to generate a in-memory (temp file)  data stream in Python. One thread is filling the stream with data, and a other one consumes it.</p>
<p>After checking the <a href="https://docs.python.org/3/library/io.html" rel="nofollow noreferrer">io - Core tools for working with streams </a>, it seems to me that the <code>io</code> module is the best choice for it.</p>
<p>So I put a simple example for me:</p>
<pre><code>#!/usr/local/bin/python3
# encoding: utf-8

import io

if __name__ == '__main__':
    a = io.BytesIO()
    a.write("hello".encode())
    txt = a.read(100)
    txt = txt.decode("utf-8")
    print(txt) 
</code></pre>
<p>My example does not work. <code>"hello"</code> is not written to a and can not be read after. So were is my error? How do I have to alter my code to get a file like object in memory?</p>
</div>
<div class="post-text" itemprop="text">
<p>Actually it's written; but reading is the problem. You should be referring to <a href="https://docs.python.org/3/library/io.html#io.BytesIO" rel="nofollow noreferrer">class io.BytesIO</a>. You can get the value using <code>getvalue()</code>. Like, </p>
<pre><code>import io

a = io.BytesIO()
a.write("hello".encode())
txt = a.getvalue()
txt = txt.decode("utf-8")
print(txt) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>@dhilmathy and @ShadowRanger mentioned that <code>io.BytesIO()</code> do not have separate read and write pointer.</p>
<p>I overcome this problem with creating a simple class that implements a read pointer and remembers the amount of bytes written. When the amount of read bytes is equal the amount of written bytes the file is shrink to save memory.</p>
<p>My solution so far:</p>
<pre><code>#!/usr/local/bin/python3
# encoding: utf-8

import io

class memoryStreamIO(io.BytesIO):
    """
    memoryStreamIO

    a in memory file like stream object 
    """

    def __init__(self):
        super().__init__()
        self._wIndex = 0
        self._rIndex = 0
        self._mutex = threading.Lock()

    def write(self, d : bytearray):
        self._mutex.acquire()
        r = super().write(d)
        self._wIndex += len(d)
        self._mutex.release()
        return r

    def read(self, n : int):
        self._mutex.acquire()
        super().seek(self._rIndex)
        r = super().read(n)
        self._rIndex += len(r)
        # now we are checking if we can
        if self._rIndex == self._wIndex:
            super().truncate(0)
            super().seek(0)
            self._rIndex = 0
            self._wIndex = 0
        self._mutex.release()
        return r

    def seek(self, n):
        self._mutex.acquire()
        self._rIndex = n
        r = super().seek(n)
        self._mutex.release()
        return r


if __name__ == '__main__':
    a = streamIO()

    a.write("hello".encode())
    txt = (a.read(100)).decode()
    print(txt)

    a.write("abc".encode())
    txt = (a.read(100)).decode()
    print(txt)
</code></pre>
</div>
<span class="comment-copy">merci - I like to handle my io instance like a file - only write and read. Seems that I have to use a other io class</span>
<span class="comment-copy">@StefanJaritz: If you want to use it in a file-like way, <code>a.seek(0)</code> before the <code>a.read(100)</code> would also work; the <code>write</code> moves the file pointer, so you need to move it back to the beginning of the "file" to have <code>read</code> pick up what you just wrote.</span>
<span class="comment-copy">is there a io class having separate read &amp; write file pointers? Like a fifo?</span>
