<div class="post-text" itemprop="text">
<p>I'm encountering the following question. I've written some double-type data into binary files using C and now I want to read them using Python. When I used python function</p>
<pre><code>with open("test.dat","rb") as dfile:
    data = dfile.read()
</code></pre>
<p>It gave me </p>
<blockquote>
<p>b'\x00\x00\x00\x00\x00\x00\xf8?\x00\x00\x00\x00\x00\x00\x04@\x00\x00\x00\x00\x00\x00\n@\x00\x00\x00\x00\x00\x00\x11@'</p>
</blockquote>
<p>So I tried to decode using <code>data.decode()</code>, then it gave me decoding error. I suppose it was because I used the wrong encoding type. But I tried <code>ascii</code> and <code>utf-8</code> and they did not work. Therefore my questions is 2-fold:</p>
<ol>
<li><p>How can i read an binary file without knowing the encoding type?</p></li>
<li><p>Since i did not give an encoding type when writing the binary file in c, does c encode the data at all? If yes, what kind of encoding type would that be?</p></li>
</ol>
<p>FYI, the code i used to write binary file in the first place is</p>
<pre><code>#include &lt;stdio.h&gt;

int main(){
  double buffer[4]= {1.5, 2.5, 3.25, 4.25};
  FILE *ptr;

  ptr = fopen("test.dat", "wb");
  fwrite(buffer,sizeof(buffer),1,ptr);
  printf("%ld\n",sizeof(buffer));

  return 0;
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to convert the C types into Python types. Use <code>struct.unpack</code> in the standard library <a href="http://docs.python.org/3/library/struct.html" rel="nofollow noreferrer">here</a>.</p>
<p>The format string, in this case, is <code>dddd</code>, meaning 4 doubles.  The difficulty comes when moving C types between different compilers and machines.</p>
<pre><code>import struct

with open('test.dat', 'rb') as dfile:
    data = dfile.read()

result = struct.unpack("dddd", data)
print(result)
</code></pre>
<p>Gives a tuple:</p>
<pre><code>(1.5, 2.5, 3.25, 4.25)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use python standard <a href="https://docs.python.org/3/library/array.html" rel="nofollow noreferrer">array</a> module:</p>
<pre><code>from array import array

u = array('d')

with open('test.dat', 'rb') as f:
    data = f.read()
    u.frombytes(data)
    print(u)
    print(u.tolist())
</code></pre>
<p>Output:</p>
<pre><code>array('d', [1.5, 2.5, 3.25, 4.25])
[1.5, 2.5, 3.25, 4.25]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are open to using numpy, use <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.fromfile.html" rel="nofollow noreferrer"><code>np.fromfile</code></a>:</p>
<pre><code>with open("test.dat","rb") as dfile:
    data = np.fromfile(dfile)
</code></pre>
<p>You may find numpy arrays easier to manipulate than plain python types because of the huge ecosystem of code that's grown up around them.</p>
</div>
<span class="comment-copy">"decoding" in this sense is to convert binary data into text. However, the data you saved in your C program represents double-precision floating point numbers, not text.</span>
<span class="comment-copy">You need to convert the C types into Python types.  Use <code>struct.unpack</code> in the standard library: <a href="https://docs.python.org/3/library/struct.html" rel="nofollow noreferrer">docs.python.org/3/library/struct.html</a></span>
<span class="comment-copy">Aside, in C the buffer size printed should be with <code>printf("%zu\n",sizeof(buffer));</code></span>
<span class="comment-copy">This assumes the same endianness (which tends to be a feature of the hardware).  If you look at the documentation you will find that endianness can be specified, <a href="https://docs.python.org/3/library/struct.html#struct-format-strings" rel="nofollow noreferrer">docs.python.org/3/library/struct.html#struct-format-strings</a> in 7.1.2.1. Byte Order, Size, and Alignment</span>
<span class="comment-copy">That's why I said in my post <i>The difficulty comes when moving C types between different compilers and machines</i>.  As you know, for example, <code>sizeof(int)</code> is not specified in the language.</span>
