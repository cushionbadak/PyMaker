<div class="post-text" itemprop="text">
<p>sometimes I have a string like this</p>
<pre class="lang-py prettyprint-override"><code>string = "Hett, Agva,"
</code></pre>
<p>and sometimes I will have duplicates in it.
</p>
<pre><code>string = "Hett, Agva, Delf, Agva, Hett,"
</code></pre>
<p>how can I check if my string has duplicates and then if it does remove them?</p>
<p>UPDATE.</p>
<p>So in the second string i need to remove Agva, and Hett, because there is 2x of them in the string</p>
</div>
<div class="post-text" itemprop="text">
<p>Iterate over the parts (words) and add each part to a set of seen parts and to a list of parts if it is not already in that set. Finally. reconstruct the string:</p>
<pre><code>seen = set()
parts = []
for part in string.split(','):
    if part.strip() not in seen:
        seen.add(part.strip())
        parts.append(part)

no_dups = ','.join(parts)
</code></pre>
<p><em>(note that I had to add some calls to <code>.strip()</code> as there are spaces at the start of some of the words which this method removes)</em></p>
<p>which gives:</p>
<pre><code>'Hett, Agva, Delf,'
</code></pre>
<hr/>
<p><strong>Why use a set?</strong></p>
<p>To query whether an element is <code>in</code> a set, <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">it is <code>O(1)</code> average case</a> - since they are stored by a hash which makes lookup constant time. On the other hand, lookup in a list is <code>O(n)</code> as Python must iterate over the list until the element is found. This means that it is much more efficient for this task to use a <code>set</code> since, for each new word, you can instantly check to see if you have seen in before whereas you'd have to iterate over a <code>list</code> of seen elements otherwise which would take much longer for a large list.</p>
<hr/>
<p>Oh and to just check if there are duplicates, query whether the length of the split list is the same as the set of that list (which removes the duplicates but looses the order).</p>
<p>I.e.</p>
<pre><code>def has_dups(string):
    parts = string.split(',')
    return len(parts) != len(set(parts))
</code></pre>
<p>which works as expected:</p>
<pre><code>&gt;&gt;&gt; has_dups('Hett, Agva,')
False
&gt;&gt;&gt; has_dups('Hett, Agva, Delf, Agva, Hett,')
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://toolz.readthedocs.io/en/latest/api.html#toolz.itertoolz.unique" rel="nofollow noreferrer"><code>toolz.unique</code></a>, or equivalently the <code>unique_everseen</code> <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">recipe</a> in the <code>itertools</code> docs, or equivalently @JoeIddon's explicit solution.</p>
<p>Here's the solution using 3rd party <code>toolz</code>:</p>
<pre><code>x = "Hett, Agva, Delf, Agva, Hett,"

from toolz import unique

res = ', '.join(filter(None, unique(x.replace(' ', '').split(','))))

print(res)

'Hett, Agva, Delf'
</code></pre>
<p>I've removed whitespace and used <code>filter</code> to clean up a trailing <code>,</code> which may not be required.</p>
</div>
<div class="post-text" itemprop="text">
<p>if you will receive a string in only this format then you can do the following:</p>
<pre><code>import numpy as np

string_words=string.split(',')
uniq_words=np.unique(string_words)

string=""
for word in uniq_words:
    string+=word+", "
string=string[:-1]
</code></pre>
<p>what this code does is that it splits words into a list, finds unique items, and then merges them into a string like before</p>
</div>
<div class="post-text" itemprop="text">
<p>If order of words id important then you can make a list of words in the string and then iterate over the list to make a new list of unique words.  </p>
<pre><code>string = "Hett, Agva, Delf, Agva, Hett,"
words_list = string.split()

unique_words = []
[unique_words.append(w) for w in words_list if w not in unique_words]
new_string = ' '.join(unique_words)
print (new_String)
</code></pre>
<p>Output:</p>
<pre><code>'Hett, Agva, Delf,'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This looks a bit ugly, </p>
<pre><code>', '.join(set(filter(None, [i.strip() for i in string.split(',')])))
</code></pre>
<p>but does the job ;)</p>
<p>Hope it helps!! Please feel free to ask if anything is not clear :)</p>
</div>
<span class="comment-copy">is <code>','</code> also a duplicate? How do you define duplicates?</span>
<span class="comment-copy">if there is 2x Agva, i need one to be removed</span>
<span class="comment-copy">Do you need to maintain order after removing duplicates?</span>
<span class="comment-copy">so the <code>'Hett'</code> that appears twice does not bother you.. You have to work on your definition a bit. If it is just <code>'Agva'</code> you might as well rewrite the string.</span>
<span class="comment-copy">The OP wants <b>all</b> duplicates to be removed then be it <code>Hett</code> or <code>Agva</code> or <code>blah</code></span>
<span class="comment-copy">but Hett, is also duplicate,</span>
<span class="comment-copy">@Chaban33 My bad, needed to strip the leading spaces... Now it works :)</span>
<span class="comment-copy">Thank you for amazing explanation</span>
<span class="comment-copy">@Chaban33 Thanks.</span>
<span class="comment-copy">Once you make a list of <i>only</i> words <i>without</i> comma, just doing <code>set(list_name)</code> would do the job. For ex. <code>x = ['a', 'b', 'a']</code> and <code>set(x)</code> gives <code>{'a', 'b'}</code>. That can be further converted to a list</span>
<span class="comment-copy">@Bazingaa No because then you loose the order. My logic is necessary.</span>
<span class="comment-copy">@Bazingaa; OP has not specified if he wants to remove ','. So I left it as it is.</span>
<span class="comment-copy">This isn't as efficient as using a set though, see my answer.</span>
<span class="comment-copy">@JoeIddon: Well, unless the OP specifies that the order must be maintained, we don't know.</span>
