<div class="post-text" itemprop="text">
<p>I have a bunch of interables (whose entries represent positions on genomes) that are sorted. I would like to process them simultaneously such that all of them that have data at a particular position are processed, whereas those that do not are skipped. </p>
<p>A rather clunky solution is </p>
<pre><code>import sys
it1 = iter([0, 1, 3, 5])    
it2 = iter([0, 2, 4, 5])    
it3 = iter([3, 5, 7])    
def do_stuff(objects, values):                                              
    print("iterables [%s] have value %s"  % (objects, values[0]))           

def iterate_many(iterables):                                                
    cur_ele = [next(i) for i in iterables]                                  
    is_finished = [False for i in iterables]                                
    while not all(is_finished):                                             
        lowest_val = min(cur_ele)                                           
        lowest_obj = [e for e in cur_ele if e == lowest_val]                
        to_increment = [i for i, e in enumerate(cur_ele) if e == lowest_val 
            and not is_finished[i]]                                         
        yield do_stuff(to_increment, lowest_obj)                            
        for i in to_increment:                                              
            try:                                                            
                cur_ele[i] = next(iterables[i])                             
            except StopIteration:                                           
                is_finished[i] = True                                       
                cur_ele[i] = sys.maxsize                                    
</code></pre>
<p>which results in</p>
<pre><code>In [76]: for i in iterate_many( [it1, it2, it3]): pass
iterables [[0, 1]] have value 0                       
iterables [[0]] have value 1                          
iterables [[1]] have value 2                          
iterables [[0, 2]] have value 3                       
iterables [[1]] have value 4                          
iterables [[0, 1, 2]] have value 5                    
iterables [[2]] have value 7                          
</code></pre>
<p>Is there an easier/ more pythonic way of accomplishing this goal?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from itertools import zip_longest

for a, b, c in zip_longest(it1, it2, it3)
    print a, b, c
</code></pre>
<p><a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer">https://docs.python.org/3/library/itertools.html#itertools.zip_longest</a></p>
</div>
<span class="comment-copy">for cur_ele in <a href="https://docs.python.org/3.7/library/functions.html?highlight=zip#zip" rel="nofollow noreferrer">zip</a> (it1, it2, it3): print(cur_ele)</span>
<span class="comment-copy"><code>zip()</code> or <code>itertools.zip_longest()</code> is presumably what you're looking for</span>
<span class="comment-copy"><code>zip</code> increments all iterables simultaneously, which is not helpful in my case (added output of the program to hopefully clarify things)</span>
<span class="comment-copy">@bpeter <a href="https://ideone.com/wht7CE" rel="nofollow noreferrer">ideone.com/wht7CE</a></span>
