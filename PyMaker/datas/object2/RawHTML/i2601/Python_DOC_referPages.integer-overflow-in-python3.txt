<div class="post-text" itemprop="text">
<p>I'm new to Python, I was reading <a href="https://docs.python.org/3/library/doctest.html#module-doctest" rel="nofollow noreferrer">this</a> page where I saw a weird statement:</p>
<pre><code>if n+1 == n:  # catch a value like 1e300
    raise OverflowError("n too large")
</code></pre>
<p>x equals to a number greater than it?! I sense a disturbance in the Force.</p>
<p>I know that in Python 3, integers don't have fixed byte length. Thus, there's no integer overflow, like how C's <code>int</code> works. But of course the memory can't store infinite data.</p>
<p>I think that's why the result of <code>n+1</code> can be the same as <code>n</code>: Python can't allocate more memory to preform the summation, so it is skipped, and <code>n == n</code> is true. Is that correct?</p>
<p>If so, this could lead to incorrect result of the program. Why don't Python raise an error when operations are not possible, just like C++'s <code>std::bad_alloc</code>?</p>
<p>Even if <code>n</code> is not too large and the check evaluates to false, <code>result</code> - due to the multiplication - would need much more bytes. Could <code>result *= factor</code> fail for the same reason?</p>
<p>I found it in the offical Python documentation. Is it really the correct way to check big integers / possible integer "overflow"?</p>
</div>
<div class="post-text" itemprop="text">
<h2>Python3</h2>
<p>Only floats have
 a hard limit in python. Integers are <a href="https://docs.python.org/3/c-api/long.html#integer-objects" rel="nofollow noreferrer">are implemented as “long” integer objects of arbitrary size in python3</a> and <a href="https://docs.python.org/3/library/exceptions.html#OverflowError" rel="nofollow noreferrer">do normally not overflow</a>.</p>
<p>You can test that behavior with the following code</p>
<pre><code>import sys

i = sys.maxsize
print(i)
# 9223372036854775807
print(i == i + 1)
# False
i += 1
print(i)
# 9223372036854775808

f = sys.float_info.max
print(f)
# 1.7976931348623157e+308
print(f == f + 1)
# True
f += 1
print(f)
# 1.7976931348623157e+308
</code></pre>
<p>You may also want to take a look at <a href="https://docs.python.org/2/library/sys.html#sys.float_info" rel="nofollow noreferrer">sys.float_info</a> and <a href="https://docs.python.org/2/library/sys.html#sys.maxsize" rel="nofollow noreferrer">sys.maxsize</a></p>
<h2>Python2</h2>
<p>In python2 integers are automatically casted to long integers if too large as described in the <a href="https://docs.python.org/2/library/stdtypes.html#numeric-types-int-float-long-complex" rel="nofollow noreferrer">documentation for numeric types</a></p>
<pre><code>import sys

i = sys.maxsize
print type(i)
# &lt;type 'int'&gt;

i += 1
print type(i)
# &lt;type 'long'&gt;
</code></pre>
<blockquote>
<p>Could <code>result *= factor</code> fail for the same reason?</p>
</blockquote>
<p>Why not try it?</p>
<pre><code>import sys

i = 2
i *= sys.float_info.max
print i
# inf
</code></pre>
<p>Python has a special float value for infinity (and negative infinity too) as described in <a href="https://docs.python.org/2.7/library/functions.html#float" rel="nofollow noreferrer">the docs for float</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Integers don't work that way in Python.</p>
<p>But float does. That is also why the comment says <code>1e300</code>, which is a float in scientific notation.</p>
</div>
<span class="comment-copy">n == n is true. I assume you mean n == (n+1)</span>
<span class="comment-copy">That code doesn't actually catch large <code>int</code>s like 1e300. The int would have to be seriously huge for that to happen due to memory reasons. It does catch floats though, for the obvious reason. n must be a float.</span>
<span class="comment-copy">@E.Serra No, I don't. I meant if the summation in <code>n    (+1)</code> is skipped, it may see and work with only <code>(n) (==) (n)</code>.</span>
<span class="comment-copy">@Denziloe Indeed, my bad. We often use 'e' for integers too in math, but in Python we may use the <code>**</code> operator to get large integers.</span>
<span class="comment-copy">Well, this function in the docs catches <code>1e16</code>, but accepts <code>10 ** 5000000</code> which is bad I think, because <code>1e16 &lt; 10 ** 50</code> so that check is only for float inputs (there is no implicit conversion).</span>
<span class="comment-copy">I accepted your answer because it gives a reverence to <code>MemoryError</code> (I didn't know about it) which is raised if I'd try to work with too big integers.</span>
<span class="comment-copy">Btw my 3rd question is for big integers, not small (in bits) floats. Working with a number with more than 100k digits is not something I want to try out. :) It's enough to know how it would work in theory.</span>
<span class="comment-copy">Thanks, I am glad I could help you</span>
