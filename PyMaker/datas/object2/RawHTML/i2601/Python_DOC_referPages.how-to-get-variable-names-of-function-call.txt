<div class="post-text" itemprop="text">
<p>I am going to to write a decorator which evaluates the actual names (not their value) of the variables that are passed to the function call. </p>
<p>Below, you find a skeleton of the code which makes it a bit clearer what I want to do. </p>
<pre><code>import functools

def check_func(func):
    # how to get variable names of function call
    # s.t. a call like func(arg1, arg2, arg3)
    # returns a dictionary {'a':'arg1', 'b':'arg2', 'c':'arg3'} ?
    pass

def my_decorator(func):
    @functools.wraps(func)
    def call_func(*args, **kwargs):
        check_func(func)
        return func(*args, **kwargs)

    return call_func

@my_decorator
def my_function(a, b, c):
    pass

arg1='foo'
arg2=1
arg3=[1,2,3]
my_function(arg1,arg2,arg3)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can't really have what you are asking for.</p>
<p>There are many ways of calling a function, where you won't even get variable names for individual values. For example, what would the names when you use literal values in the call, so:</p>
<pre><code>my_function('foo', 10 - 9, [1] + [2, 3])
</code></pre>
<p>or when you use a list with values for argument expansion with <code>*</code>:</p>
<pre><code>args = ['foo', 1, [1, 2, 3]]
my_function(*args)
</code></pre>
<p>Or when you use a <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow noreferrer"><code>functools.partial()</code> object</a> to bind some argument values to a callable object:</p>
<pre><code>from functools import partial
func_partial = partial(my_function, arg1, arg2)
func_partial(arg3)
</code></pre>
<p>Functions are passed <em>objects</em> (values), not variables. Expressions consisting of just names may have been used to produce the objects, but those objects are independent of the variables.</p>
<p>Python objects can have <em>many different references</em>, so just because the call used <code>arg1</code>, doesn't mean that there won't be other references to the object elsewhere that would be more interesting to your code.</p>
<p>You could try to analyse the code that called the function (the <a href="https://docs.python.org/3/library/inspect.html" rel="nofollow noreferrer"><code>inspect</code> module</a> can give you <a href="https://docs.python.org/3/library/inspect.html#inspect.stack" rel="nofollow noreferrer">access to the call stack</a>), but then that presumes that the source code is available. The calling code could be using a C extension, or interpreter only has access to <code>.pyc</code> bytecode files, not the original source code. You still would have to trace back and analyse the call expression (not always that straightforward, functions are objects too and can be stored in containers and retrieved later to be called dynamically) and from there find the variables involved <em>if there are any at all</em>.</p>
<p>For the <em>trivial</em> case, where only direct positional argument names were used for the call and the whole call was limited to a single line of source code, you could use a combination of <code>inspect.stack()</code> and the <a href="https://docs.python.org/3/library/ast.html" rel="nofollow noreferrer"><code>ast</code> module</a> to parse the source into something useful enough to analyse:</p>
<pre><code>import inspect, ast

class CallArgumentNameFinder(ast.NodeVisitor):
    def __init__(self, functionname):
        self.name = functionname
        self.params = []
        self.kwargs = {}

    def visit_Call(self, node):
        if not isinstance(node.func, ast.Name):
            return  # not a name(...) call
        if node.func.id != self.name:
            return  # different name being called
        self.params = [n.id for n in node.args if isinstance(n, ast.Name)]
        self.kwargs = {
            kw.arg: kw.value.id for kw in node.keywords
            if isinstance(kw.value, ast.Name)
        }

def check_func(func):
    caller = inspect.stack()[2]  # caller of our caller
    try:
        tree = ast.parse(caller.code_context[0])
    except SyntaxError:
        # not a complete Python statement
        return None
    visitor = CallArgumentNameFinder(func.__name__)
    visitor.visit(tree)
    return inspect.signature(func).bind_partial(
        *visitor.params, **visitor.kwargs)
</code></pre>
<p>Again, for emphasis: this only works with the most basic of calls, where the call consists of a single line only, and the called name matches the function name. It can be expanded upon but this takes a lot of work.</p>
<p>For your specific example, this produces <code>&lt;BoundArguments (a='arg1', b='arg2', c='arg3')&gt;</code>, so an <a href="https://docs.python.org/3/library/inspect.html#inspect.BoundArguments" rel="nofollow noreferrer"><code>inspect.BoundArguments</code> instance</a>. Use <code>.arguments</code> to get an <code>OrderedDict</code> mapping with the name-value pairs, or <code>dict(....arguments)</code> to turn that into a regular dictionary.</p>
<p>You'll have to think about your specific problem differently instead. Decorators are not meant to be acting upon the code calling, they act upon the decorated object. There are many other powerful features in the language that can help you deal with the calling context, decorators are not it.</p>
</div>
<span class="comment-copy">Related/Dupe: <a href="//stackoverflow.com/q/18425225">Getting the name of a variable as a string</a></span>
<span class="comment-copy">@Aran-Fey: This is even worse: it asks for names for argument expressions that may very well have none.</span>
<span class="comment-copy">Not ture. You can get the names of a function's parameters using func.__code__.co_varnames</span>
<span class="comment-copy">@Gnoliz: no, you misunderstood the question. They are not asking for the parameter names of the function nor are they asking for the values. Note the <code>{'a':'arg1', 'b':'arg2', 'c':'arg3'}</code> part in the question, <code>arg1</code>, <code>arg2</code> and <code>arg3</code> are variables in the call expression <code>my_function(arg1,arg2,arg3)</code>.</span>
<span class="comment-copy">I see. You're right. He's asking for something outside of the function itself, which does seem impossible.</span>
<span class="comment-copy">That's sad :-( But I was already expecting an answer like that. I just wanted to be sure. Then, I'll have to think about a workarround. Thanks for your answers</span>
