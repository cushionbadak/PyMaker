<div class="post-text" itemprop="text">
<p>I am trying to implement aes encryption and decryption in python. When I execute code, it returns error. I have installed anaconda on my machine. I am running scripts in jupyter notebook.</p>
<pre><code>!pip install pycryptodome

import base64
from Crypto import Random
from Crypto.Cipher import AES

BS = 16
pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)
unpad = lambda s : s[0:-ord(s[-1])]

class AESCipher:

    def __init__( self, key ):
        self.key = key

    def encrypt( self, raw ):
        raw = pad(raw)
        iv = Random.new().read( AES.block_size )
        cipher = AES.new( self.key, AES.MODE_CBC, iv )
        return base64.b64encode( iv + cipher.encrypt( raw ) )

    def decrypt( self, enc ):
        enc = base64.b64decode(enc)
        iv = enc[:16]
        cipher = AES.new(self.key, AES.MODE_CBC, iv )
        return unpad(cipher.decrypt( enc[16:] ))

cipher = AESCipher('mysecretpassword')
encrypted = cipher.encrypt('Secret')
decrypted = cipher.decrypt(encrypted)
print(encrypted)
print(decrypted)
</code></pre>
<p>How to solve this ?</p>
</div>
<div class="post-text" itemprop="text">
<p>just update unpad to be <code>unpad = lambda s : s[0:-ord(s[-1:])]</code>
 the main issue that ord() expects string of length one if you try to print value of <strong>s[-1]</strong> it prints <strong>10</strong> which not one char but <strong>s[-1:]</strong> printed value is <strong>b'\n'</strong> which is one char</p>
<p>also encode key to be bytes <code>bytes(key, 'utf-8')</code> and pad</p>
<pre><code>pad = lambda s: bytes(s + (BS - len(s) % BS) * chr(BS - len(s) % BS), 'utf-8')
</code></pre>
<p>to make sure all inputs are bytes</p>
<pre><code>from hashlib import sha256
import base64
from Crypto import Random
from Crypto.Cipher import AES

BS = 16
pad = lambda s: bytes(s + (BS - len(s) % BS) * chr(BS - len(s) % BS), 'utf-8')
unpad = lambda s : s[0:-ord(s[-1:])]

class AESCipher:

    def __init__( self, key ):
        self.key = bytes(key, 'utf-8')

    def encrypt( self, raw ):
        raw = pad(raw)
        iv = Random.new().read( AES.block_size )
        cipher = AES.new(self.key, AES.MODE_CBC, iv )
        return base64.b64encode( iv + cipher.encrypt( raw ) )

    def decrypt( self, enc ):
        enc = base64.b64decode(enc)
        iv = enc[:16]
        cipher = AES.new(self.key, AES.MODE_CBC, iv )
        return unpad(cipher.decrypt( enc[16:] )).decode('utf8')

cipher = AESCipher('mysecretpassword')
encrypted = cipher.encrypt('Secret')
decrypted = cipher.decrypt(encrypted)

print(encrypted)
print(decrypted)
</code></pre>
</div>
<span class="comment-copy">please fix your indentation. what is the error? (which line, etc...)</span>
<span class="comment-copy">raw=pad(raw). TypeError: Object type &lt;class 'str'&gt; cannot be passed to C code</span>
<span class="comment-copy">Your code is written for Python2, in Python3 <code>str</code> and <code>bytes</code> are differend objects. You'll have to replace all your strings with bytes (see <a href="https://docs.python.org/3/library/stdtypes.html#str.encode" rel="nofollow noreferrer"><code>str.encode</code></a>).</span>
<span class="comment-copy">I made the following changes to the above code.                                                                                    pwd=b"mysecretpassword" cipher = AESCipher(pwd) msg=b"Secret" encrypted = cipher.encrypt(msg)                                               print(encrypted) print(decrypted)                                                                                                                                           It returns TypeError: can't concat str to bytes</span>
<span class="comment-copy">It again returns the same error.        TypeError: Object type &lt;class 'str'&gt; cannot be passed to C code</span>
<span class="comment-copy">@Jozf I have updated my answer I think it is working fine now I tried it on jjupyter notebook</span>
<span class="comment-copy">Thank you. But in the output, there is b before encrypted and decrypted data. Did you see that ?  b'6tx+0XpByP2w2cluCcDgYLnx3Zu65vbM8+Db2su4yKg=' b'Secret'                                                                                                                        How can we remove that ?</span>
<span class="comment-copy">@Jozf just decode the result .decode('utf8') I updated it in answer</span>
