<div class="post-text" itemprop="text">
<p>Attempting to compare two objects' data members; however, the error message has no specific details, which leaves me with little information on how to go about correcting it   </p>
<pre><code>class Person: 
  def __init__(self, name, age, id):
    self.name = name
    self.age = age
    self.id = id

  def same_person(Person lhs, Person rhs):
    return lhs.id == rhs.id

person1 = Person("David Joyner", 30, 901234567)
person2 = Person("D. Joyner", 29, 901234567)
person3 = Person("David Joyner", 30, 903987654)
# print calls provided as part of an exercise: not my implementation
print(same_person(person1, person2))
print(same_person(person1, person3))
</code></pre>
<ul>
<li>Python 3.6.5</li>
<li>Command: python person.py</li>
<li>Error message</li>
<li><a href="https://i.stack.imgur.com/kOiZ9.png" rel="nofollow noreferrer"><img alt="SyntaxError" src="https://i.stack.imgur.com/kOiZ9.png"/></a></li>
<li>If it were an indentation level the following error is displayed </li>
<li><a href="https://i.stack.imgur.com/eLXAE.png" rel="nofollow noreferrer"><img alt="IndentationError" src="https://i.stack.imgur.com/eLXAE.png"/></a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>The other answers are correct and provide the best way to do it, but I realized that you wrote:</p>
<blockquote>
<p>print calls provided as part of an exercise: not my implementation </p>
</blockquote>
<pre><code>print(same_person(person1, person2))
print(same_person(person1, person3))
</code></pre>
<p>The exercise probably wants you to define a function outside the class. You can do that by removing that function from the class and writing it un-indented outside the class (without providing class type too). For example:</p>
<pre><code>class Person: 
    def __init__(self, name, age, id):
        self.name = name
        self.age = age
        self.id = id

def same_person(lhs, rhs):
    return lhs.id == rhs.id

person1 = Person("David Joyner", 30, 901234567)
person2 = Person("D. Joyner", 29, 901234567)
person3 = Person("David Joyner", 30, 903987654)

print(same_person(person1, person2))
print(same_person(person1, person3))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>same_person is a method of the class <code>Person</code> and should take just an argument as input. It should be defined as:</p>
<pre><code>def same_person(self, other):
    return self.id == other.id
</code></pre>
<p>and called as </p>
<pre><code>person1.same_person(person2)
</code></pre>
<p>or you could override the <code>__eq__</code> method (i.e., <code>==</code>).</p>
<pre><code>def __eq__(self, other):
    return self.id == other.id
</code></pre>
<p>in order to be able to do it as <code>person1 == person2</code></p>
</div>
<div class="post-text" itemprop="text">
<pre><code>class Person: 
   def __init__(self, name, age, id):
      self.name = name
      self.age = age
      self.id = id

   def same_person(self, lhs, rhs):
      return lhs.id == rhs.id
</code></pre>
<p>you dont have to define lhs and rhs type in python unless you are using typings.</p>
</div>
<div class="post-text" itemprop="text">
<p>Quite a few mistakes:</p>
<ol>
<li>The arguments in the method cannot be preceded by the <code>Person</code> classname</li>
<li>You have not defined instances <code>person1</code>, <code>person2</code> and <code>person3</code></li>
<li>If you define an instance method (<code>same_person</code>), it should be used ON an instance.</li>
</ol>
<p>This is what I would do:</p>
<pre><code>class Person:
    def __init__(self, name, age, id):
        self.name = name
        self.age = age
        self.id = id

    def same_person(self, other):
        return self.id == other.id

person1 = Person("Bob", 25, 1)
person2 = Person("Mike", 33, 1)
person3 = Person("Maria", 28, 2)

print(person1.same_person(person2))
print(person1.same_person(person3))
</code></pre>
<p>Output:</p>
<pre><code>True
False
</code></pre>
</div>
<span class="comment-copy">Among other things, you are probably mixing tabs and spaces in your indentation somewhere.</span>
<span class="comment-copy">Much appreciated</span>
<span class="comment-copy">Glad to help :-)</span>
<span class="comment-copy">@aguilar keep in mind that the best way to compare two objects would be overriding <code>__eq__()</code> method of the class, have a look at <a href="https://docs.python.org/3/reference/datamodel.html#object.__eq__" rel="nofollow noreferrer">this</a></span>
<span class="comment-copy"><code>return self is other</code> is a bit more elegant.</span>
<span class="comment-copy">@DYZ: but then <code>Person(1, 2, 3) != Person(1, 2, 3)</code>, since they're not the same object.</span>
<span class="comment-copy">If you suggest to add  <code>self.id is other.id</code> I don't really understand why, we are checking equality not object identity.</span>
<span class="comment-copy">I suggest to replace <code>self.id == other.id</code> with <code>self is other</code> (both expressions are fully equivalent).</span>
