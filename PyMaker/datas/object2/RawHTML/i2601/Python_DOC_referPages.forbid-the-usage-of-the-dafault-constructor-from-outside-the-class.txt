<div class="post-text" itemprop="text">
<p>Consider the following dataclass.  I would like to prevent objects from being created using the <code>__init__</code> method direclty. </p>
<pre><code>from __future__ import annotations
from dataclasses import dataclass, field

@dataclass
class C:
    a: int

    @classmethod
    def create_from_f1(cls, a: int) -&gt; C:
        # do something
        return cls(a)
    @classmethod
    def create_from_f2(cls, a: int, b: int) -&gt; C:
        # do something
        return cls(a+b)

    # more constructors follow


c0 = C.create_from_f1(1) # ok

c1 = C()  # should raise an exception
c2 = C(1) # should raise an exception
</code></pre>
<p>For instance, I would like to force the usage of the the additional constructors I define and raise an exception or a warning if an object is directly created as <code>c = C(..)</code>.</p>
<p>What I've tried so far is as follows.</p>
<pre><code>@dataclass
class C:
    a : int = field(init=False)

    @classmethod
    def create_from(cls, a: int) -&gt; C:
        # do something
        c = cls()
        c.a = a
        return c
</code></pre>
<p>with <code>init=False</code> in  <code>field</code> I prevent <code>a</code> from being a parameter to the generated <code>__init__</code>, so this partially solves the problem as <code>c = C(1)</code> raises an exception.<br/>
Also, I don't like it as a solution.</p>
<p>Is there a direct way to disable the <strong>init</strong> method from being called from outside the class?</p>
</div>
<div class="post-text" itemprop="text">
<p>Trying to make a constructor private in Python is not a very pythonic thing to do. One of the philosophies of Python is "we're all consenting adults". That is, you don't try to hide the <code>__init__</code> method, but you do document that a user probably wants to use one of the convenience constructors instead. But if the user thinks they really know what they're doing then they're welcome to try.</p>
<p>You can see this philosophy in action in the standard library. With <a href="https://docs.python.org/3/library/inspect.html#inspect.Signature" rel="nofollow noreferrer"><code>inspect.Signature</code></a>. The class constructor takes a list of <code>Parameter</code>, which a fairly complicated to create. This is not the standard way a user is expected to create a Signature instance. Rather a function called <a href="https://docs.python.org/3/library/inspect.html#introspecting-callables-with-the-signature-object" rel="nofollow noreferrer"><code>signature</code></a> is provided which takes a callable as argument and does all the leg work of creating the parameter instances from the various different function types in CPython and marshalling them into the <code>Signature</code> object.</p>
<p>That is do something like:</p>
<pre><code>@dataclass
class C:
    """
    The class C represents blah. Instances of C should be created using the C.create_from_&lt;x&gt; 
    family of functions.
    """

    a: int
    b: str
    c: float

    @classmethod
    def create_from_int(cls, x: int):
        return cls(foo(x), bar(x), baz(x))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>__init__</code> method is not responsible for creating instances from a class. You should override the <code>__new__</code> method if you want to restrict the instantiation of your class. But if you override the <code>__new__</code> method if will affect any form of instanciation as well which means that your <code>classmethod</code> won't work anymore. Because of that and since it's generally not Pythonic to delegate instance creation to another function, it's better to do this within the <code>__new__</code>  method. Detailed reasons for that can be simply found in <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer">doc</a>:</p>
<blockquote>
<p>Called to create a new instance of class <code>cls. __new__()</code> is a static method (special-cased so you need not declare it as such) that takes the class of which an instance was requested as its first argument. The remaining arguments are those passed to the object constructor expression (the call to the class). The return value of <code>__new__()</code> should be the new object instance (usually an instance of cls).</p>
<p>Typical implementations create a new instance of the class by invoking the superclass’s <code>__new__()</code> method using <code>super().__new__(cls[, ...])</code> with appropriate arguments and then modifying the newly-created instance as necessary before returning it.</p>
<p>If<code>__new__()</code> returns an instance of <code>cls</code>, then the new instance’s <code>__init__()</code> method will be invoked like <code>__init__(self[, ...])</code>, where self is the new instance and the remaining arguments are the same as were passed to <code>__new__()</code>.</p>
<p>If <code>__new__()</code> does not return an instance of cls, then the new instance’s <code>__init__()</code> method will not be invoked.</p>
<p><code>__new__()</code> is intended mainly to allow subclasses of immutable types (like int, str, or tuple) to customize instance creation. It is also commonly overridden in custom metaclasses in order to customize class creation.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Since this isn't a standard restriction to impose on instance creation, an extra line or two to help other developers understand what's going on / why this is forbidden is probably worthwhile. Keeping in the spirit of "We are all consenting adults", a hidden parameter to your <code>__init__</code> may be a nice balance between ease of understanding and ease of implementation:</p>
<pre><code>class Foo:

    @classmethod
    def create_from_f1(cls, a):
        return cls(a, _is_direct=False)

    @classmethod
    def create_from_f2(cls, a, b):
        return cls(a+b, _is_direct=False)

    def __init__(self, a, _is_direct=True):
        # don't initialize me directly
        if _is_direct:
            raise TypeError("create with Foo.create_from_*")

        self.a = a
</code></pre>
<p>It's certainly still <em>possible</em> to create an instance without going through <code>create_from_*</code>, but a developer would have to knowingly work around your roadblock to do it.</p>
</div>
<div class="post-text" itemprop="text">
<p>Rather than creating two constructors and then <em>forbidding</em> one of them, and enforcing usage of a classmethod, why not simply provide only the constructor which you need?</p>
<pre><code>class C:
    def __init__(self, a: int):
        # do something
        self.a = a
</code></pre>
<p>This looks much simpler than the original code, and does what was requested.</p>
</div>
<div class="post-text" itemprop="text">
<p>As <a href="https://stackoverflow.com/a/52129036/962190">Dunes' answer</a> explained, this is not something you'd usually want to do. But since it's possible anyway, here is how:</p>
<pre><code>dataclasses import dataclass

@dataclass
class C:
    a: int

    def __post_init__(self):
        # __init__ will call this method automatically
        raise TypeError("Don't create instances of this class by hand!")

    @classmethod
    def create_from_f1(cls, a: int):
        # disable the post_init by hand ...
        tmp = cls.__post_init__
        cls.__post_init__ = lambda *args, **kwargs: None
        ret = cls(a)
        cls.__post_init__ = tmp
        # ... and restore it once we are done
        return ret

print(C.create_from_f1(1))  # works
print(C(1))                 # raises a descriptive TypeError
</code></pre>
<p>I probably don't need to say that the handle code looks absolutely heinous, and that it also makes it impossible to use <code>__post_init__</code> for anything else, which is quite unfortunate. But it is one way to answer the question in your post. </p>
</div>
<span class="comment-copy">Isn't <code>__new__</code> also called when the instance is created within <code>create_from</code>? Looks to me like this exception will be thrown any time an instance is created.</span>
<span class="comment-copy">@chris Of course, I'm gonna explain that in a minute.</span>
<span class="comment-copy">To avoid a caller passing the parameter by accident without understanding what they're doing, make it keyword-only: <code>def __init__(self, a, *, _is_direct=True):</code></span>
<span class="comment-copy">It's a minimal example, in practice there are many constructors</span>
<span class="comment-copy">@newbie The example is too minimal ;) if it does not show the problem. You should show a better example to get a better answer.</span>
<span class="comment-copy">added more constructors in the example to better describe the situation.</span>
