<div class="post-text" itemprop="text">
<p>Suppose I want to generate a list of the set of positive integers whose square is less than 100 in python.</p>
<p>My initial thinking was to do something like this</p>
<pre><code>from itertools import count
numbers = [x for x in count() if x**2&lt;100]
</code></pre>
<p>However this code won't complete, as python goes through infinitely many numbers.</p>
<p>There are two solutions to this as far as I can tell:</p>
<ol>
<li>Put in a bound on the range of integers to go over, so use range(1000) instead of count() above.</li>
<li>Use a while loop, incrementing x and stopping the loop when x squared is greater than or equal to 100.</li>
</ol>
<p>Neither of these solutions are elegant or (as far as I can tell) <em>pythonic</em>. Is there a good way to handle cases like this ,when iterating over an infinite container but you know that the loop stops at some point.</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd use <code>takewhile</code>:</p>
<pre><code>nums = itertools.takewhile(lambda x: x**2 &lt; 100, count())
</code></pre>
<p>Literally, take while the square is less than 100</p>
</div>
<div class="post-text" itemprop="text">
<p>This would be a use case for <a href="https://docs.python.org/3/library/itertools.html#itertools.takewhile" rel="nofollow noreferrer"><code>itertools.takewhile</code></a>:</p>
<pre><code>from itertools import count, takewhile

numbers = list(takewhile(lambda x: x**2 &lt; 100, count()))
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>For a slice of known bounds from a (infinite) generator (not all of those have such simple finite equivalents as <code>range</code>), use <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow noreferrer"><code>itertools.islice</code></a>:</p>
<pre><code>numbers = list(islice(count(), 4, 10, 2))
# [4, 6, 8]
</code></pre>
<p>That being said, and with a loop-based approach being perfectly legit as well, there is a hacky way of achieving it in one line without any library tools, by causing an "artificial" <a href="https://docs.python.org/3/library/exceptions.html#StopIteration" rel="nofollow noreferrer"><code>StopIteration</code></a>:</p>
<pre><code>numbers = list(x if x**2&lt;100 else next(iter([])) for x in count())
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>don't do this in serious code though - not just because <a href="https://www.python.org/dev/peps/pep-0479/#examples-of-breakage" rel="nofollow noreferrer">it will stop working in Python3.7</a> ;-)</p>
</div>
<div class="post-text" itemprop="text">
<p>If you were to use range, I would write it like this.</p>
<pre><code>import math
[x for x in range(int(math.sqrt(100))+1) if (x**2) &lt; 100]
</code></pre>
<p>You can change 100 to what you like or set it as a variable, but you know the list of numbers will end at the square root of your target number.</p>
</div>
<span class="comment-copy">You could just use a for-loop as well, and break out of it when necessary, which is perfectly Pythonic. Don't associate Pythonic with "uses list comprehensions for everything"</span>
<span class="comment-copy">Perfect, thank you.</span>
