<div class="post-text" itemprop="text">
<p>Let's say I have a class defined in python as following</p>
<pre><code>class A(object):
    def __init__(self):
        pass
    def rockabye(self):
        pass

class B(A):
    def __init__(self):
        pass
    def iamOnlyinB(self):
        pass
</code></pre>
<p>I am trying to get a list of the functions that only exist in <code>B</code> and not inherited from <code>A</code> or <code>object</code>.</p>
<pre><code>PyTypeObject* l_typeObject = &lt;a function out of scope of the question&gt;

for (int i = 0; true; i++)
    {
        PyMethodDef method_def = l_typeObject-&gt;tp_methods[i];
        if(method_def.ml_name == NULL)
            break;
        std::cout &lt;&lt; method_def.ml_name &lt;&lt;std::endl;

    }
</code></pre>
<p>I always find <code>l_typeObject-&gt;tp_methods</code> is <code>NULL</code>. Why ? and what are the possible alternative approaches ?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_methods" rel="nofollow noreferrer"><code>tp_methods</code></a> is:</p>
<blockquote>
<p>An optional pointer to a static NULL-terminated array of <code>PyMethodDef</code> structures, declaring regular methods of this type.</p>
<p>For each entry in the array, an entry is added to the type’s dictionary (see <code>tp_dict</code> below) containing a method descriptor.</p>
<p>This field is not inherited by subtypes (methods are inherited through a different mechanism).</p>
</blockquote>
<p>In other words, these are the builtin methods attached to the class by the extension module that created it.</p>
<p>For a class built in Python, there are no builtin methods, and there is no extension module that created it, so it will always be either <code>NULL</code> or empty.</p>
<hr/>
<p>What you want to do is the same thing you do in Python:</p>
<ul>
<li>Either look in the class's dict (which you can access via <a href="https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_dict" rel="nofollow noreferrer"><code>tp_dict</code></a>), or </li>
<li>Call a method like <code>dir</code> or <code>inspect.getmembers</code> (the same way you'd call any other Python code).</li>
</ul>
<p>Of course that gets you <em>all</em> attributes of the class (depending on which you do, also possibly all <em>inherited</em> attributes), so if you want just the <em>methods</em>, you need to filter it. But you do this the same way as in Python as well.</p>
<p>Since "method" is kind of an ambiguous term (Should it include classmethods and staticmethods? What about wrappers that act just like functions when bound as methods, but aren't functions? And so on…), you need to come up with exactly the rule you want to filter on, and apply it the same way you would from Python. (A few things, like <a href="https://docs.python.org/3/c-api/object.html#c.PyCallable_Check" rel="nofollow noreferrer"><code>PyCallable_Check</code></a>, have special C API support; for anything else, you'll be doing a subclass check or calling a Python function.)</p>
</div>
