<div class="post-text" itemprop="text">
<p>I have the following code. I am pulling files from a directory and trying to check if they were created in the past 24hrs but I can't seem to figure out the right time or datetime functions to use to be able to compare the create time against the from and to dates:  </p>
<pre><code>def checkdirectory(folder_paths):
    #loop through and check directories for new files
    file_list = []
    for path in folder_paths:
        from_date = datetime.datetime.now() - datetime.timedelta(days=-1)
        to_date = datetime.datetime.now()

        files = glob.glob(path['folder_path'] + path['file_filter'])

        for file in files:
            create_time = os.path.getctime(file)
            print(create_time)
            if datetime.time(create_time) &gt;= from_date and datetime.time(create_time) &lt;= to_date:
               file_list.append(file)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are two problems with this:</p>
<pre><code>datetime.time(create_time)
</code></pre>
<hr/>
<p>First, you're constructing a <a href="https://docs.python.org/3/library/datetime.html#time-objects" rel="nofollow noreferrer"><code>time</code></a> object, which represents a:</p>
<blockquote>
<p>time of day, independent of any particular day</p>
</blockquote>
<p>In other words, it represents something like "10:30:00.000", not "2018-Aug-29 10:30:00.000". So, that isn't much use if you want to find files that are "newer than yesterday". What you want is a <a href="https://docs.python.org/3/library/datetime.html#datetime-objects" rel="nofollow noreferrer"><code>datetime</code></a> object.</p>
<hr/>
<p>Second, you can't just throw some random value at the constructor and hope it's the right thing.</p>
<p>The <a href="https://docs.python.org/3/library/os.path.html#os.path.getctime" rel="nofollow noreferrer"><code>getctime</code></a> function is:</p>
<blockquote>
<p>a number giving the number of seconds since the epoch</p>
</blockquote>
<p>The <code>time</code> constructor takes:</p>
<pre><code>time(hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0)
</code></pre>
<p>And the <code>datetime</code> constructor takes:</p>
<pre><code>datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0)
</code></pre>
<p>So, you have a number of seconds, and you're trying to use that as an hour or a year.</p>
<p>The function you want to use is <a href="https://docs.python.org/3/library/datetime.html#datetime.datetime.fromtimestamp" rel="nofollow noreferrer"><code>fromtimestamp</code></a>:</p>
<blockquote>
<p>Return the local date and time corresponding to the POSIX timestamp</p>
</blockquote>
<hr/>
<p>So, what you want is:</p>
<pre><code>datetime.datetime.from_timestamp(create_time)
</code></pre>
<hr/>
<p>Also, be aware that what <a href="https://docs.python.org/3/library/os.path.html#os.path.getctime" rel="nofollow noreferrer"><code>getctime</code></a> returns is:</p>
<blockquote>
<p>the systemâ€™s ctime which, on some systems (like Unix) is the time of the last metadata change, and, on others (like Windows), is the creation time</p>
</blockquote>
<p>So, using that for something named <code>create_time</code> is at best non-portable and Windows-specific, and at worst (if you're not actually on Windows) wrong.</p>
<hr/>
<p>Also:</p>
<pre><code>from_date = datetime.datetime.now() - datetime.timedelta(days=-1)
</code></pre>
<p>You're subtracting -1 days, which is the same as adding 1 day.</p>
<p>So, instead of looking for files less than 24 hours old, you're looking for files more than 24 hours in the future. Either use <code>+</code>, or use <code>days=1</code>.</p>
<hr/>
<p>While we're at it:</p>
<pre><code>if datetime.time(create_time) &gt;= from_date and datetime.time(create_time) &lt;= to_date:
</code></pre>
<p>Instead of creating the timestamp object twice and doing two separate comparisons, why not just use a chained comparison?</p>
<pre><code>if from_date &lt;= datetime.datetime.from_timestamp(create_time) &lt;= to_date:
</code></pre>
<p>Or, maybe better, move the construction out of the test:</p>
<pre><code>create_time = datetime.datetime.from_timestamp(os.path.getctime(file))
if from_date &lt;= create_time &lt;= to_date:
</code></pre>
</div>
<span class="comment-copy">You want to use <code>datetime.datetime</code>, not <code>datetime.time</code>. And you want to use  the <code>fromtimestamp</code> class method to create them from <code>time_t</code>-style seconds-since-1970 timestamps (unless you're on an old version of Python that didn't have that method yet).</span>
<span class="comment-copy">Just to be clear, you're on Windows, right? Only on Windows does <code>getctime</code> mean "created time"; everywhere else it returns the time of the last metadata update. <code>getmtime</code> is more portable and usually the correct thing to test (since the time of last modification is the time the exact data in the current file first existed). Otherwise, you clearly need to use <code>datetime.datetime</code>s, not <code>datetime.time</code>s, because a <code>datetime.time</code> can't represent a concept of "more than 24 hours ago" in the first place.</span>
<span class="comment-copy">Also, are you expecting to find timestamps in the future? Because otherwise, testing that the creation time is before <i>now</i> is a little pointless; aside from narrow race conditions (files created between <code>to_date = datetime.datetime.now()</code> and the <code>glob.glob</code> call), nothing should be created after <i>now</i>, and in the rare cases it occurs (immediately after a clock sync that moves the clock backwards or the like), you probably still want to treat them as "created in the last 24 hours".</span>
