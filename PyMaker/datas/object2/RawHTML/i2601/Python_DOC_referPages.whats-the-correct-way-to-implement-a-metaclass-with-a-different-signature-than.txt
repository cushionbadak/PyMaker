<div class="post-text" itemprop="text">
<p>Say I want to implement a metaclass that should serve as a class factory. But unlike the <a href="https://docs.python.org/3/library/functions.html#type" rel="noreferrer"><code>type</code></a> constructor, which takes 3 arguments, my metaclass should be callable without any arguments:</p>
<pre><code>Cls1 = MyMeta()
Cls2 = MyMeta()
...
</code></pre>
<p>For this purpose I defined a custom <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="noreferrer"><code>__new__</code></a> method with no parameters:</p>
<pre><code>class MyMeta(type):
    def __new__(cls):
        return super().__new__(cls, 'MyCls', (), {})
</code></pre>
<p>But the problem is that python automatically calls the <a href="https://docs.python.org/3/reference/datamodel.html#object.__init__" rel="noreferrer"><code>__init__</code></a> method with the same arguments as the <code>__new__</code> method, so trying to call <code>MyMeta()</code> ends up throwing an exception:</p>
<pre><code>TypeError: type.__init__() takes 1 or 3 arguments
</code></pre>
<p>Which makes sense, since <code>type</code> can be called with 1 or 3 arguments. But what's the correct way to fix this? I see 3 (4?) options:</p>
<ul>
<li>I could add an empty <code>__init__</code> method to my metaclass, but since I'm not sure if <code>type.__init__</code> does anything important, this might not be a good idea.</li>
<li>I could implement an <code>__init__</code> method that calls <code>super().__init__(cls.__name__, cls.__bases__, vars(cls))</code>.</li>
<li>I could use a meta-metaclass and override its <code>__call__</code> method, rather than messing with <code>__new__</code> and <code>__init__</code>.</li>
<li>Bonus option: Maybe I shouldn't try to change the signature?</li>
</ul>
<p>So my question is: Are the 3 solutions I listed correct or are there any subtle bugs hidden in them? Which solution is best (i.e. the most correct)?</p>
</div>
<div class="post-text" itemprop="text">
<p>An interface deviating from the parent signature is a <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="nofollow noreferrer">questionable design</a> in regular classes too.  You don't need the extra complexity of metaclasses to get into this kind of mess - you can cause the same new/init jumble by subclassing a <code>datetime</code> or whatever. </p>
<blockquote>
<p>I want to have a metaclass and an easy way to create instances of that metaclass. </p>
</blockquote>
<p>The usual pattern in Python is to write a factory using a <code>from_something</code> classmethod.  To take the example of creating datetime instances from a different init signature, there is for example <a href="https://docs.python.org/3/library/datetime.html#datetime.date.fromtimestamp" rel="nofollow noreferrer"><code>datetime.fromtimestamp</code></a>, but you have many other examples too (<code>dict.fromkeys</code>, <code>int.from_bytes</code>, <code>bytes.fromhex</code>...)</p>
<p>There is nothing specific to metaclasses here, so use the same pattern:</p>
<pre><code>class MyMeta(type):
    @classmethod
    def from_no_args(cls, name=None):
        if name is None:
            name = cls.__name__ + 'Instance'
        return cls(name, (), {})
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; class A(metaclass=MyMeta):
...     pass
... 
&gt;&gt;&gt; B = MyMeta.from_no_args()
&gt;&gt;&gt; C = MyMeta.from_no_args(name='C')
&gt;&gt;&gt; A.__name__
'A'
&gt;&gt;&gt; B.__name__
'MyMetaInstance'
&gt;&gt;&gt; C.__name__
'C'
</code></pre>
</div>
<span class="comment-copy">1. Is it required that your metaclass be a subclass of <code>type</code>? 2. Could you add a bit of background about the use-case for changing the signature (many metaclass use-cases are more recently possible using other approaches such as <code>__init_subclass__</code>)</span>
<span class="comment-copy">@wim To be honest it's a rather theoretical question; I stumbled upon this problem while answering another SO question. So I don't really know how the metaclass was going to be used. But I do think there are some scenarios in which it would be useful for the class to be a subclass of <code>type</code>. So you can think of the scenario like this: I want to have a metaclass and an easy way to create instances of that metaclass (i.e. a class factory). If changing the class's signature isn't the correct way to do that, you can suggest a different solution.</span>
<span class="comment-copy">I'd say it's actually worse than just "questionable": Changing the signature prevents you from using the metaclass with the <code>class</code> statement, as <code>class Foo(metaclass=MyMeta):</code> will just throw an exception. So an alternative constructor is definitely the better solution.</span>
<span class="comment-copy">Well, it is possible, but you would need to implement the cooperative inheritance correctly. Pretty much the same issue griped over in <a href="https://fuhm.net/super-harmful/" rel="nofollow noreferrer">super harmful</a>.</span>
<span class="comment-copy">Sorry, what cooperative inheritance? There's no multiple inheritance here, is there?</span>
<span class="comment-copy">Cooperative inheritance is independent of multiple inheritance. It just means that all involved classes have to <i>cooperate</i> to ensure <code>super</code> is used correctly.</span>
<span class="comment-copy">^ this.  If you're changing signatures, you're obliged to accept <code>*args</code> and <code>**kwargs</code>.  If you accept <code>*args</code> and <code>**kwargs</code>, <i>everybody</i> has to accept <code>*args</code> and <code>**kwargs</code>.</span>
