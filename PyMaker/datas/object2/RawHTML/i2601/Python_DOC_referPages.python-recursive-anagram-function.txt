<div class="post-text" itemprop="text">
<p>I am working on a homework assignment, and am a little stuck and could use some help please.</p>
<p>I don't want the answer handed to me, but if I could get some help or tips I would greatly appreciate it.</p>
<p>I have to create a anagram generator that makes only 1 recursive function call and no for loops.</p>
<pre><code>def anagram(st): 
if len(st) == 0:
    return []
else:
    if len(st) &gt; 1:
        print(st)
        return [st] + [st[0]] + anagram(st[1:])
    else:
        print("test2",st)
        return [st[1:] + st[0]]

ana = anagram('abc') 
</code></pre>
<p>This is my results: ['abc', 'a', 'bc', 'b', 'c'] 5</p>
<p>The answer should be: ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] 6</p>
</div>
<div class="post-text" itemprop="text">
<p>Let's think without code for a bit, starting with a general case. Say you already know the permutations of <code>"bc"</code>, and they are <code>["bc", "cb"]</code>. How do you add <code>"a"</code> to the mix? I'd take each of the elements generated so far, and inserted <code>a</code> in each position. So, take <code>"bc"</code>, and inserting <code>"a"</code> in each position, you get <code>["abc", "bac", "bca"]</code>. Then do the same with <code>"cb"</code>. This leads us to the base case: since each recursion multiplies the number of results, the number of results in the base case must be 1, not 0, because when we iterate over solutions of the previous level, you would not be able to append anything, as nothing is there. So, <code>anagrams("")</code> must return <code>[""]</code> (so that inserting <code>"c"</code> later puts it into the only position it can).</p>
<p>Unfortunately, that's already two loops we're talking about (even with general recursive nature of the algorithm): one that iterates over <code>["cb", "bc"]</code>, and one that iterates over the positions to insert <code>"a"</code>. If you can use comprehensions, you can do this rather easily. If you can't, well... every loop can be rewritten into recursion, so... let me think a bit more.</p>
</div>
<span class="comment-copy">You can simply use <code>permutations</code> from <code>itertools</code>: <code>list(map(''.join, (permutations('abc'))))</code>.</span>
<span class="comment-copy">@LevZakharov Not the point - OP gave clear constraints, because it's a homework assignment, and we have to respect them.</span>
<span class="comment-copy">@LevZakharov I'm not allowed to use tools like that. I have to use 1 recursive function call to complete this assignment</span>
<span class="comment-copy">I meant that you can look at <code>permutations</code> <a href="https://docs.python.org/3/library/itertools.html#itertools.permutations" rel="nofollow noreferrer">implementation</a> from python documentation.</span>
<span class="comment-copy">Can you use comprehensions? Because doing it entirely loopless might not be trivial.</span>
<span class="comment-copy">def anagram(st):     if st == '':         return ['']     lout = [ ]     for i in range(len(st)):         st2 = st[:i]+st[i+1:]         lout2 = anagram(st2)         for w in lout2:             lout.append(st[i]+w)     return lout</span>
<span class="comment-copy">There is an anagram generator in the notes for Lecture 2. Write a different anagram generator that makes only one recursive call instead of n recursive calls as is done by the program in the notes. Set up an experiment to 2 compare the running times of the two programs. Produce a table showing your results. Carry out the calculations until you see a difference in the results or until you have exhausted the resources necessary to run the anagram generator. Describe your results, and project the future behavior of these two algorithms.</span>
<span class="comment-copy">Sorry for the messy code in the first comment. I didn't really know how to format it within the comments. And the second comment is the question he is asking us.</span>
<span class="comment-copy">Let me note that you do have loops in your given code :P The task doesn't say "don't have loops", just "don't make recursive call more than once per function invocation". My algorithm fits this restriction.</span>
<span class="comment-copy">That code in this comment is the code he wants us to transform into the 1 recursive call. Idk if that changes anything in your algorithm</span>
