<div class="post-text" itemprop="text">
<h1>Original post:</h1>
<p>If one has an executable <code>mini_program.py</code> that uses <code>argparse</code> with the following structure:</p>
<pre><code>def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-X', '--attribute_matrix', type=str, help = 'Input: Path/to/Tab-separated-value.tsv')
    parser.add_argument('-y', '--target_vector', type=str, help = 'Input: Path/to/Tab-separated-value.tsv')
    opts = parser.parse_args()

if __name__ == "__main__":
    main()
</code></pre>
<p>How can one create a controller program <code>parent_program.py</code> that uses <code>argparse</code> (I think with <code>subparser</code>?) to have a similar usage to below:</p>
<pre><code>python parent_program.py --help

blah-blah list of programs that can be used
</code></pre>
<p>then using the subprogram:</p>
<pre><code>python parent_program.py mini_program --help

-X description
-y description
etc...
</code></pre>
<p>How could all of the parameters propagate up from <code>mini_program.py</code> to the <code>parent_program.py</code>? </p>
<h2>EDIT (More specific with error message):</h2>
<h3>The program</h3>
<pre><code>import argparse
def main():
    parser = argparse.ArgumentParser()
    # Subprograms
    subprograms = parser.add_subparsers(title="subprograms")
    # ============
    # mini-program
    # ============
    parser_miniprogram = subprograms.add_parser("miniprogram")

    # Input
    parser_miniprogram.add_argument('-X', '--attribute_matrix', type=str, help = 'Input: Path/to/Tab-separated-value.tsv')
    parser_miniprogram.add_argument('-y', '--target_vector', type=str, help = 'Input: Path/to/Tab-separated-value.tsv')
    opts = parser.parse_args()
    opts_miniprogram = parser_miniprogram.parse_args()
    print(opts_miniprogram.__dict__)

if __name__ == "__main__":
    main()
</code></pre>
<h3>Checking to make sure the docs work</h3>
<pre><code># parent program
python parent_program.py --help
usage: parent_program.py [-h] {miniprogram} ...

optional arguments:
  -h, --help     show this help message and exit

subprograms:
  {miniprogram}

# miniprogram
python parent_program.py miniprogram --help
usage: parent_program.py miniprogram [-h] [-X ATTRIBUTE_MATRIX]
                                     [-y TARGET_VECTOR]

optional arguments:
  -h, --help            show this help message and exit
  -X ATTRIBUTE_MATRIX, --attribute_matrix ATTRIBUTE_MATRIX
                        Input: Path/to/Tab-separated-value.tsv
  -y TARGET_VECTOR, --target_vector TARGET_VECTOR
                        Input: Path/to/Tab-separated-value.tsv
</code></pre>
<h3>Trying to run it:</h3>
<pre><code>python parent_program.py miniprogram -X ../../Data/X_iris.noise_100.tsv.gz -y ../../Data/y_iris.tsv
usage: parent_program.py miniprogram [-h] [-X ATTRIBUTE_MATRIX]
                                     [-y TARGET_VECTOR]
parent_program.py miniprogram: error: unrecognized arguments: miniprogram
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The parent program could have code like</p>
<pre><code>import mini_program
import sys
&lt;do its own parsing&gt;
if 'use_mini':
    &lt;modify sys.argv&gt;
    mini_program.main()
</code></pre>
<p>As written, importing <code>mini_program</code> doesn't run its parser.  But calling its <code>main</code> will, but using the list it finds in <code>sys.argv</code>.</p>
<p>The parent parser should be written in a way that it accepts arguments that it needs, and doesn't choke on inputs the <code>mini</code> wants, '-X' and '-y'.  It would then puts those 'extra' values in a modified <code>sys.argv</code>, which the <code>mini</code> parser can handle.</p>
<p><code>parse_known_args</code> is one way of accepting unknown arguments, 
<a href="https://docs.python.org/3/library/argparse.html#partial-parsing" rel="nofollow noreferrer">https://docs.python.org/3/library/argparse.html#partial-parsing</a></p>
<p><code>nargs=argparse.REMAINDER</code>, <a href="https://docs.python.org/3/library/argparse.html#nargs" rel="nofollow noreferrer">https://docs.python.org/3/library/argparse.html#nargs</a>, is another way of collecting remaining arguments for passing on.</p>
<p>If <code>mini</code> <code>main</code> was written as:</p>
<pre><code>def main(argv=None):
    parser = argparse.ArgumentParser()
    parser.add_argument('-X', '--attribute_matrix', type=str, help = 'Input: Path/to/Tab-separated-value.tsv')
    parser.add_argument('-y', '--target_vector', type=str, help = 'Input: Path/to/Tab-separated-value.tsv')
    opts = parser.parse_args(argv)
</code></pre>
<p>it could be called with</p>
<pre><code>mini_program.main(['-X', 'astring','-y','another'])
</code></pre>
<p>that is, with an explicit <code>argv</code> list, instead of working through <code>sys.argv</code>.</p>
<p>Keeping the main parser from responding to a '-h' help could be tricky.  <code>subparsers</code> is probably the cleanest way of doing that.</p>
<p>You could combine subparsers with the invocation of a the <code>mini</code> <code>main</code>.  I won't try to work out those details now.</p>
<p>Another way to define the <code>main</code> is:</p>
<pre><code>def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-X', '--attribute_matrix', type=str, help = 'Input: Path/to/Tab-separated-value.tsv')
    parser.add_argument('-y', '--target_vector', type=str, help = 'Input: Path/to/Tab-separated-value.tsv')
    return parser
</code></pre>
<p>And use it as</p>
<pre><code> opts = main().parse_args()
 opts = mini_program.main().parse_args()
</code></pre>
<p>in other words, use <code>main</code> to define the parser, but delay the parsing.</p>
</div>
<div class="post-text" itemprop="text">
<p>My actual solution was an adaptation to the above:</p>
<pre><code># Controller
def main(argv=None):
    parser = argparse.ArgumentParser(prog="parent_program", add_help=True)
    parser.add_argument("subprogram")
    opts = parser.parse_args(argv)
    return opts.subprogram


# Initialize
if __name__ == "__main__":
    # Get the subprogram 
    subprogram = main([sys.argv[1]])
    module = importlib.import_module(subprogram)
    module.main(sys.argv[2:])
</code></pre>
</div>
<span class="comment-copy">Maybe something like <a href="https://chase-seibert.github.io/blog/2014/03/21/python-multilevel-argparse.html" rel="nofollow noreferrer">this</a> is useful. Or, as you mentioned, using <a href="https://stackoverflow.com/questions/10448200/how-to-parse-multiple-nested-sub-commands-using-python-argparse">subparsers</a>.</span>
<span class="comment-copy">@pazitos10 that git example is really interesting.  I've never seen argparse used int hat way.  I tried the subparser way and edited my answer.</span>
<span class="comment-copy">You don't need to call: <code>parser_miniprogram.parse_args()</code>.  The subparser mechanism in <code>parser</code> takes care of invoking the subparser with remaining arguments.</span>
<span class="comment-copy">Used this in combination with <a href="https://stackoverflow.com/questions/14071135/import-file-using-string-as-name" title="import file using string as name">stackoverflow.com/questions/14071135/â€¦</a></span>
