<div class="post-text" itemprop="text">
<p>I would like to only allow lists where the first contiguous group of elements are <code>True</code> and then all of the remaining elements are <code>False</code>. I want lists like these examples to return <code>True</code>:</p>
<ul>
<li><code>[True]</code></li>
<li><code>[False]</code></li>
<li><code>[True, False]</code></li>
<li><code>[True, False, False]</code></li>
<li><code>[True, True, True, False]</code></li>
</ul>
<p>And lists like these to return <code>False</code>:</p>
<ul>
<li><code>[False, True]</code></li>
<li><code>[True, False, True]</code></li>
</ul>
<p>I am currently using this function, but I feel like there is probably a better way of doing this:</p>
<pre><code>def my_function(x):
    n_trues = sum(x)
    should_be_true = x[:n_trues]  # get the first n items
    should_be_false = x[n_trues:len(x)]  # get the remaining items
    # return True only if all of the first n elements are True and the remaining
    # elements are all False
    return all(should_be_true) and all([not element for element in should_be_false])
</code></pre>
<p>Testing:</p>
<pre><code>test_cases = [[True], [False],
              [True, False],
              [True, False, False],
              [True, True, True, False],
              [False, True],
              [True, False, True]]
print([my_function(test_case) for test_case in test_cases])
# expected output: [True, True, True, True, True, False, False]
</code></pre>
<p>Is it possible to use a comprehension instead to make this a one/two line function? I know I could not define the two temporary lists and instead put their definitions in place of their names on the return line, but I think that would be too messy.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Method 1</strong></p>
<p>You could use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a>. This would avoid doing multiple passes over the list and would also avoid creating the temp lists in the first place:</p>
<pre><code>def check(x):
    status = list(k for k, g in groupby(x))
    return len(status) &lt;= 2 and (status[0] is True or status[-1] is False)
</code></pre>
<p>This assumes that your input is non-empty and already all boolean. If that's not always the case, adjust accordingly:</p>
<pre><code>def check(x):
    status = list(k for k, g in groupby(map(book, x)))
    return status and len(status) &lt;= 2 and (status[0] or not status[-1])
</code></pre>
<p>If you want to have empty arrays evaluate to True, either special case it, or complicate the last line a bit more:</p>
<pre><code>return not status or (len(status) &lt;= 2 and (status[0] or not status[-1]))
</code></pre>
<p><strong>Method 2</strong></p>
<p>You can also do this in one pass using an iterator directly. This relies on the fact that <code>any</code> and <code>all</code> are <a href="https://stackoverflow.com/q/14730046/2988730"><em>guaranteed</em> to short-circuit</a>:</p>
<pre><code>def check(x):
    iterator = iter(x)
    # process the true elements
    all(iterator)
    # check that there are no true elements left
    return not any(iterator)
</code></pre>
<p>Personally, I think method 1 is total overkill. Method 2 is much nicer and simpler, and achieves the same goals faster. It also stops immediately if the test fails, rather than having to process the whole group. It also doesn't allocate any temporary lists at all, even for the group aggregation. Finally, it handles empty and non-boolean inputs out of the box.</p>
<p>Since I'm writing on mobile, here's an IDEOne link for verification: <a href="https://ideone.com/4MAYYa" rel="nofollow noreferrer">https://ideone.com/4MAYYa</a></p>
</div>
<span class="comment-copy">Not any is the simpler negative of all.</span>
<span class="comment-copy">I'm voting to close this question as off-topic because it belongs in <a href="https://codereview.stackexchange.com">codereview.stackexchange.com</a></span>
<span class="comment-copy">Thanks, this started off as a question, but as I was writing it, it became more like a code review. I'll post there instead.</span>
<span class="comment-copy">I've updated my answer with what I think is objectively the simplest solution.</span>
