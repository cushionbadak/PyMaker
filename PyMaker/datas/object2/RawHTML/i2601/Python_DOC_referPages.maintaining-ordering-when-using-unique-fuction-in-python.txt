<div class="post-text" itemprop="text">
<p>I have some code, where the following, say, are the columns of my df. </p>
<pre><code>df.columns = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2', 'E1', 'E2']

list = df.columns.str[:1]
list = np.unique(list)
</code></pre>
<p>I am trying to get the unique values of the letters, and numbers, but in the correct order. </p>
<p>My code doesn't maintain the ordering and I cant figure out how to do so. </p>
<p>Thank you</p>
<p>expected output:</p>
<pre><code>letters = [A, B, C, D, E]
numbers = [1, 2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://toolz.readthedocs.io/en/latest/api.html" rel="nofollow noreferrer"><code>toolz.unique</code></a> instead. This is identical to the <code>unique_everseen</code> <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">recipe</a> found in the <code>itertools</code> docs. Internally, it iterates while maintaining a <code>set</code> of seen items.</p>
<pre><code>df = pd.DataFrame(columns=['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2', 'E1', 'E2'])

from toolz import unique

res = list(unique(df.columns.str[:1]))

['A', 'B', 'C', 'D', 'E']
</code></pre>
<p>A more Pandorable solution would be to convert the <code>Index</code> object to <code>pd.Series</code> and use <code>drop_duplicates</code>. This, again, uses hashing:</p>
<pre><code>res = df.columns.str[:1].to_series().drop_duplicates().values

array(['A', 'B', 'C', 'D', 'E'], dtype=object)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assuming your example is representative, you can use a neat little trick that I got from <a href="https://twitter.com/raymondh?lang=en" rel="nofollow noreferrer">Raymond Hettinger</a>. In python 3.6 and later, dicts are ordered so you can use their keys as efficient ordered sets.</p>
<pre><code>list(dict.fromkeys(c[0] for c in df.columns))
# --&gt; ['A', 'B', 'C', 'D', 'E']

list(dict.fromkeys(int(c[1]) for c in df.columns))
# --&gt; [1, 2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This one uses regex and would continue working in case you have multiple characters/numbers in your column names:</p>
<pre><code>import re
import pandas as pd

df = pd.DataFrame(columns=['EE2', 'A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D11', 'E1'])

split_ = [re.findall('\d+|\D+', col) for col in df.columns]

list(pd.Series([col[0] for col in split_]).drop_duplicates())
# ['EE', 'A', 'B', 'C', 'D', 'E']
list(pd.Series([col[1] for col in split_]).drop_duplicates())
# ['2', '1', '11']
</code></pre>
</div>
<span class="comment-copy">is it always one letter and one number? or it can change?</span>
<span class="comment-copy">What is <code>df</code>? Pandas DataFrame?</span>
<span class="comment-copy">went for the pandorable solution, thanks @jpp</span>
<span class="comment-copy">Thanks FHTMitchell; I need to update my python in that case as im on a 2. version.</span>
<span class="comment-copy">Im am further looking into this as indeed I have EUR3m EUR3m3m GBP6m3m as my columns, so this is indeed more helpful.  however, taking EUR3m3m as an example, regex spits the EUR just fine, but then splits 3m3m into 3 , m , 3 , m (as opposed to desired output of "3m3m"  could u explain "re.findall('\d+|\D+'" to me such that I can amend the code to take EUR and GBP in list 1,  and 3m, 3m3m, 6m3m in the second list?</span>
