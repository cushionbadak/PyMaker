<div class="post-text" itemprop="text">
<p>I want to capitalize the first letter of the string and the letter after every space.</p>
<p>This seems like it should work:</p>
<pre><code>re.sub(r'^(.) | \s(.)', lambda x: x.group(0).upper(), "hello world")
</code></pre>
<p>It returns 'hello world' every time.</p>
<p>If I just use  <code>^(.)</code>  or <code>\s(.)</code>  it works fine but combining the two with the or pipe causes issues.</p>
<p>How can I harness the sub function to allow use of or statements?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your regex <code>r'^(.) | \s(.)'</code> does not work because of the literal spaces contained within it. </p>
<p>You can delete those spaces:</p>
<pre><code>&gt;&gt;&gt; re.sub(r'^(.)|\s(.)', lambda x: x.group(0).upper(), "hello world")
'Hello World'
</code></pre>
<p>Or, you can use the <a href="https://docs.python.org/3/library/re.html#re.X" rel="nofollow noreferrer">re.X</a> flag to ignore those spaces:</p>
<pre><code>&gt;&gt;&gt; re.sub(r'^(.) | \s(.)', lambda x: x.group(0).upper(), "hello world", flags=re.X)
'Hello World'
</code></pre>
<p>In such a case, you should replace <code>(.)</code> with a <code>([a-z])</code> so you are actually capturing a word-like lower-case character rather than just any character such as the <a href="https://regex101.com/r/fhIrTD/1/" rel="nofollow noreferrer">second space</a> of multiple spaces:</p>
<pre><code>&gt;&gt;&gt; re.sub(r'^([a-z]) | \s([a-z])', lambda x: x.group(0).upper(), "hello    world", flags=re.X)
'Hello    World'
</code></pre>
<p>Or, use a <code>\b</code> <a href="https://regex101.com/r/yixsVQ/1/" rel="nofollow noreferrer">word boundary</a> zero-width assertion:</p>
<pre><code>&gt;&gt;&gt; re.sub(r'\b(\w)', lambda x: x.group(0).upper(), "hello world")
'Hello World'
</code></pre>
<p>Or, (simpler and faster) use <code>.title()</code>:</p>
<pre><code>&gt;&gt;&gt; 'hello    world'.title()
'Hello    World'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You have too many extra spaces in your regex, you can just use this:</p>
<pre><code>^(.)|\s+(.)
</code></pre>
<p>Spaces in regex matters. If you have a space, that means you want to match literal one space character</p>
<p><a href="https://regex101.com/r/UbKILE/2" rel="nofollow noreferrer">Online Demo</a></p>
<p>Depending on your situation, <a href="https://docs.python.org/3/library/stdtypes.html#str.title" rel="nofollow noreferrer"><code>str.title()</code></a> might be a better solution to your problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>You don't need regex for this if you're triggering after spaces - just use the .title() function of the string class and a list comprehension to keep it one line if you need to.  You can alternatively break this into a for loop if you're not comfortable with list comprehensions.</p>
<pre><code>newstr = ' '.join([word.title() for word in input_string.split()])
</code></pre>
<p>And the result is:</p>
<pre><code>input_string = "hello world"
newstr = ' '.join([word.title() for word in input_string.split()])

print(newstr)
</code></pre>
<p>'Hello World'</p>
<p>In a for loop it's similar:</p>
<pre><code>new_list = []
for word in input_string.split():
    new_list.append(word.title())
new_str = ' '.join(new_list)
</code></pre>
</div>
<span class="comment-copy">One quick (don't know how robust) solution: you could lose the spaces in your pattern: <code>'^(.)|\s(.)'</code>.</span>
<span class="comment-copy">Why don't you use the string method <code>title()</code>?</span>
<span class="comment-copy">CristiFati....yup, that was it.  Derped it big time. Thanks much for the assistance.</span>
<span class="comment-copy">@Aran-Fey Using a word boundary is more efficient what using an OR operator. If a better solution exists, why not propose it? +1.</span>
<span class="comment-copy">@Aran-Fey: Not directly answering the question can be fine too when the question is an XY problem.</span>
<span class="comment-copy">This site really does confuse me sometimes. I don't understand how the answer above gets five upvotes while this one only gets two. This is the correct regex. There is no point in fixing broken patterns if a better one can be provided.</span>
<span class="comment-copy">Yeah thanks for the alternative answer!  That's a much more succint regex and I added that to my toolbox in my brain.  Was just trying to figure out what I was doing wrong with the above regex and it turned out....spaces. I totally derped it. Thanks again for the alternative way. I kind of disagree no need to answer the question if a better solution can be provided.  It's a learning process and demonstrating what is incorrect with their solution is just as valuabl as providing a better solution as far as the learning process for people goes in my opinion.</span>
<span class="comment-copy">Yeah exactly!  Like no harm in answering the question then also providing a better answer.  That's actually the most ideal way! Either way you guys rock and your help is much appreciated.</span>
<span class="comment-copy">You sir are a gentleman and a scholar!  This was it!  Thank you!</span>
<span class="comment-copy">@NickKiermaier For a more efficient pattern, see dawg's answer.</span>
<span class="comment-copy">You don't need to split a string by space before applying the title method. <code>"hello world".title()</code> returns <code>"Hello World"</code></span>
<span class="comment-copy">That's a completely obvious solution that should have clicked in my brain, haha - thanks!</span>
<span class="comment-copy">Hey thanks! I was aware of this and the idea of using a split/capitalize as well, was just tinkering with regex for learning.</span>
<span class="comment-copy">This does not answer the OP's question. They explicitly asked (twice!) how to use the regex OR operator and why it doesn't work. Offering a better solution is fine and dandy, but you still need to actually answer the question the OP asked. If the question had been "How can I capitalize each word in this string?", your answer would be perfectly acceptable. But it's not.</span>
<span class="comment-copy">That's a fair critique @Aran-Fey - thanks for the feedback.</span>
