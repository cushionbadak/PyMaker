<div class="post-text" itemprop="text">
<p>I the following list I want to do slicing such that my final result is [1,1.5,2,2.5,4.5,5] . I tried to access by indices but it gives me error.</p>
<pre><code>`list = [1,1.5,2,2.5,3,3.5,4,4.5,5]
print(list)
print(list[0,1,2,3,7,8])`
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can't use a list of indexes to slice or index a list. You have to use a loopâ€”e.g., via a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">comprehension</a>, or a function with an implicit loop in it like the one returned by <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>itemgetter</code></a>:</p>
<pre><code>&gt;&gt;&gt; lst = [1,1.5,2,2.5,3,3.5,4,4.5,5]
&gt;&gt;&gt; print([lst[i] for i in [0, 1, 2, 3, 7, 8]])
[1, 1.5, 2, 2.5, 4.5, 5]
&gt;&gt;&gt; print(operator.itemgetter(0, 1, 2, 3, 7, 8)(lst))
[1, 1.5, 2, 2.5, 4.5, 5]
</code></pre>
<hr/>
<p>But you <em>can</em> do something like this with numpy arrays. You can't directly use the six indices (because that would mean multidimensional indexing), but you <em>can</em> use any array-like, such as a list, containing those six indices:</p>
<pre><code>&gt;&gt;&gt; arr = np.array(lst)
&gt;&gt;&gt; print(arr[[0, 1, 2, 3, 7, 8]])
[1.  1.5 2.  2.5 4.5 5. ]
</code></pre>
<p>This is explained in <a href="https://docs.scipy.org/doc/numpy/user/basics.indexing.html#index-arrays" rel="nofollow noreferrer">Index arrays</a> in the basic indexing tutorial.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python does not support irregular intervals. You must use a list comprehension.</p>
<pre><code>lst = [1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5]
indices = (0, 1, 2, 3, 7, 8)
slice = [lst[i] for i in indices]

print(slice) # [1, 1.5, 2, 2.5, 4.5, 5]
</code></pre>
<p>Also, do not use names such as <code>list</code> for your variables as this overshadows builtin functions.</p>
</div>
<div class="post-text" itemprop="text">
<p>Work the other way around; instead of selecting a non-contiguous range, remove the contiguous range you <em>don't</em> want. You just want to get the original <code>list</code> minus indices 4-6 (inclusive), so copy your <code>list</code>, then <code>del</code> the indices you don't need:</p>
<pre><code>mylist = [1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5]
trimmed = mylist[:]
del trimmed[4:7]
print(trimmed)
</code></pre>
<p>Alternatively, you could use <code>operator.itemgetter</code> to retrieve the specific indices you listed, e.g.:</p>
<pre><code>from operator import itemgetter

mylist = [1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5]
print(itemgetter(0, 1, 2, 3, 7, 8)(mylist))
</code></pre>
<p><code>itemgetter</code> of multiple values will output a <code>tuple</code>, so if that bothers you, you'd have to convert back to <code>list</code>, e.g. <code>print(list(itemgetter(0, 1, 2, 3, 7, 8)(mylist)))</code> (and note, the choice to change your variable name to <code>mylist</code> made it possible to access the <code>list</code> constructor, which would have been impossible if you named your variable <code>list</code>).</p>
</div>
<span class="comment-copy">You've tagged this NumPy, but you're not using any NumPy data structures or functionality.</span>
<span class="comment-copy">How is <code>numpy</code> involved? You're using plain Python <code>list</code>s here (and as a side-note, naming the variable <code>list</code> is a terrible idea, as you name shadow the <code>list</code> constructor by doing so).</span>
<span class="comment-copy">First I tried this numpy array rather than list that's why I tagged</span>
<span class="comment-copy">for a numpy array, <code>arr[[0,1,2,3,7,8]]</code>.  Pay attention to the [].  Index with a list.</span>
<span class="comment-copy">Although due to some <a href="https://github.com/numpy/numpy/blob/7ccf0e08917d27bc0eba34013c1822b00a66ca6d/numpy/core/src/multiarray/mapping.c#L200" rel="nofollow noreferrer">weird backward compatibility logic</a> in the NumPy indexing handling, indexing arrays with arbitrary arraylikes can be pretty weird. <code>a[[1, 2]]</code> is treated like <code>a[array([1, 2])]</code>, but <code>a[[[1, 2], [3, 4]]]</code> is treated like <code>a[array([1, 2]), array([3, 4])]</code> rather than <code>a[array([[1, 2], [3, 4]])]</code>.</span>
<span class="comment-copy">@user2357112 That's because a tuple is not an array-like for index array purposes. That's mentioned in the first sentence of the tutorial section, with a "I'll explain later" link to the end of the same chapter. It's not about backward compatibility; it's because tuples are already used for multidimensional indexing, so it would be ambiguous to also use them for index array indexing.</span>
<span class="comment-copy">No, you're thinking of a different effect. I'm not talking about the difference between indexing with a tuple or other arraylikes; that's documented. I'm talking about how if <code>index</code> is a list, <code>a[index]</code> is sometimes treated as <code>a[array(index)]</code> and sometimes treated as <code>a[tuple(index)]</code>.</span>
<span class="comment-copy">@user2357112 Oh, I see, yeah, the top level of a mutlidimensional list is sometimes treated like a tuple, and the docs just say (somewhere) that you should never rely on that, without saying that you also can't rely on it <i>not</i> happening (as you'd hope).</span>
