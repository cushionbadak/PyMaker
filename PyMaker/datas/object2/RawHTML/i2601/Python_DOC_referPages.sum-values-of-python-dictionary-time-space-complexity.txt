<div class="post-text" itemprop="text">
<p>I am attempting to solve the following problem:</p>
<p>Given the list of birth dates and death dates, find the year in which the most people were alive.</p>
<p>Here is my code thus far:</p>
<pre><code>b = [1791, 1796, 1691, 1907, 1999, 2001, 1907] # birth dates
d = [1800, 1803, 1692, 1907, 1852, 1980, 2006] # death dates

year_dict = {} # populates dict key as year, val as total living/dead
for birth in b:
    year_dict.setdefault(birth,0) # sets default value of key to 0 
    year_dict[birth] += 1 # will add +1 for each birth and sums duplicates
for death in d:
    year_dict.setdefault(death,0) # sets default value of key to 0
    year_dict[death] += -1 # will add -1 for each death and sums duplicates
</code></pre>
<p>The following code returns:</p>
<pre><code>{1791: 1, 1796: 1, 1691: 1, 1907: 1, 1999: 1, 2001: 1, 1800: -1, 1803: -1, 1692: -1, 1852: -1, 1980: -1, 2006: -1}
</code></pre>
<p>Now I am looking for a way to create a running sum to find which year has the most people living, example:</p>
<p><a href="https://i.stack.imgur.com/Vc8bW.jpg" rel="nofollow noreferrer">Image of desired result</a></p>
<p>As we can see, the result shows 1796 had the most people alive based on the given data sets. I am having trouble getting the running sum portion which would need to take each key value, and sum it against the previous value. I have tried several different loops and enumeration, but am now stuck. Once I find the best way of resolving this, I will create a function for efficiency.</p>
<p>If there is a more efficient way of doing this taking into account time/space complexity, please let me know. I am trying to learn efficiency with python. I really appreciate your help!!! </p>
</div>
<div class="post-text" itemprop="text">
<p>Is there a particular data structure you want to house the result in? I got the same result as the imgur link to print to the terminal. It would not be difficult to write it to a dictionary though.</p>
<pre><code>from collections import OrderedDict

b = [1791, 1796, 1691, 1907, 1999, 2001, 1907] # birth dates
d = [1800, 1803, 1692, 1907, 1852, 1980, 2006] # death dates

year_dict = {} # populates dict key as year, val as total living/dead
for birth in b:
    year_dict.setdefault(birth,0) # sets default value of key to 0 
    year_dict[birth] += 1 # will add +1 for each birth and sums duplicates
for death in d:
    year_dict.setdefault(death,0) # sets default value of key to 0
    year_dict[death] += -1 # will add -1 for each death and sums duplicates

year_dict = OrderedDict(sorted(year_dict.items(), key=lambda t: t[0]))
solution_dict = {}

total = 0
print('year net_living running_sum')
for year in year_dict:
    total += year_dict[year]
    solution_dict.update({year:{'net_living': year_dict[year],
                                'running_sum': total}
                                })
    print('{} {:4} {:10}'.format(year, year_dict[year], total))
</code></pre>
<p>Outputs:</p>
<pre><code>year net_living running_sum
1691    1          1
1692   -1          0
1791    1          1
1796    1          2
1800   -1          1
1803   -1          0
1852   -1         -1
1907    1          0
1980   -1         -1
1999    1          0
2001    1          1
2006   -1          0
</code></pre>
<p>Output of solution_dict</p>
<pre><code>{
1691: {'net_living':  1, 'running_sum':  1},
1692: {'net_living': -1, 'running_sum':  0},
1791: {'net_living':  1, 'running_sum':  1},
1796: {'net_living':  1, 'running_sum':  2},
1800: {'net_living': -1, 'running_sum':  1},
1803: {'net_living': -1, 'running_sum':  0},
1852: {'net_living': -1, 'running_sum': -1},
1907: {'net_living':  1, 'running_sum':  0},
1980: {'net_living': -1, 'running_sum': -1},
1999: {'net_living':  1, 'running_sum':  0},
2001: {'net_living':  1, 'running_sum':  1},
2006: {'net_living': -1, 'running_sum':  0}
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would use <code>pandas</code>, and make use of its <code>DataFrame</code> object:</p>
<p>Make the dataframe of people's year of birth and year of death::</p>
<pre><code>born = [1791, 1796, 1691, 1907, 1999, 2001, 1907] # birth dates
died = [1800, 1803, 1692, 1907, 1852, 1980, 2006] # death dates
people = pd.DataFrame({'born': born, 'died': died} for born, died in zip(born, died))
</code></pre>
<p>Make a dataframe that includes all years between the first listed birth, and the last listed death:</p>
<pre><code>years = pd.DataFrame(index=np.arange(people['born'].min(), people['died'].max() + 1))
</code></pre>
<p>Find the total number of people alive for each of those years:</p>
<pre><code>for year in years.index:
    num_living = ((year &gt; people['born']) &amp; (year &lt; people['died'])).sum()
    years.loc[year, 'total_living'] = num_living
</code></pre>
<p>Calling <code>years.tail()</code> yields the following:</p>
<pre><code>    total_living
2002    1.0
2003    1.0
2004    1.0
2005    1.0
2006    0.0
</code></pre>
<p>From there, you can simply do an <code>argmax</code> on the <code>'total_living'</code> column.</p>
<p>To be clear, I assumed a logical situation of people dying <em>after</em> they are born, and (therefore) that there are never negative numbers of people alive.</p>
</div>
<span class="comment-copy">What is the structure behind these years? The 6th died 21 year before being born?</span>
<span class="comment-copy">born 2001, died 1980. short live, aged backwards</span>
<span class="comment-copy">Where we're going we don't need backwards</span>
<span class="comment-copy">The sets are purposely out of order due to the fact they don't need to be in order. If you look at this big picture, to find the solution we don't care for how short or long someone lives, only thing that affects the solution is when a birth/death occurs. But yes, negative 21 is short lived :)</span>
<span class="comment-copy">Can you explain this out a bit. I think I understand what is going on, but can use some clarification so I learn. Also, the result can be returned as a dict or anything for that manner as long as it's accounting for time/space complexity. In addition, we will have to add a line to just print the year for the max with value. Example: {1796: 2} (returned as dict). We will also need to account for ties, Example: {1796: 2, 1791, 2} (if 1791 was = 2). Overall, VERY helpful!</span>
<span class="comment-copy">I'll edit the code to print the max value, and put everything in a dictionary for you.  So basically, your initial dictionary wasn't ordered which would've made the iterations a pain assuming I understand the problem correctly. As of Python 3.6.x, dictionaries are ordered. I used an <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">OrderedDict</a> to put your dictionary in order.   From there, I just initialized the total variable as zero, iterated through the years (in order), and updated total with each iteration.  Let me know if anything isn't clear.</span>
<span class="comment-copy">Definitely makes sense, thank you!</span>
<span class="comment-copy">I love Pandas and have used it for csv/excel editing. I actually had a solution like this, but wanted to make another with the standard library.</span>
<span class="comment-copy">@HackPy If you're trying to be efficient, I can tell you that the standard library is going be significantly slower than pandas at this task.</span>
