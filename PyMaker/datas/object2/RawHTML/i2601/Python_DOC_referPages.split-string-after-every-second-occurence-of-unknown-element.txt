<div class="post-text" itemprop="text">
<p>I have a string with list of coordinates which represents polygons.
In this list each polygon have starting and ending coordinates which are the same.
I need to have each polygon in separate string (or list).</p>
<p><em>'<strong>17.17165756225586 -28.102264404296875</strong>,17.184370040893555 -28.200496673583984,17.1986083984375 -28.223613739013672,<strong>17.17165756225586 -28.102264404296875</strong>,
<strong>28.865726470947266 -28.761619567871094</strong>,28.80694007873535 -28.75750160217285,28.792499542236328 -28.706947326660156, <strong>28.865726470947266 -28.761619567871094</strong>'</em></p>
<p>So from this simple example I need to have two elements:</p>
<p>One = '<strong>17.17165756225586 -28.102264404296875</strong>,17.184370040893555 -28.200496673583984,17.1986083984375 -28.223613739013672,<strong>17.17165756225586 -28.102264404296875</strong>'</p>
<p>Two = '<strong>28.865726470947266 -28.761619567871094</strong>,28.80694007873535 -28.75750160217285,28.792499542236328 -28.706947326660156, <strong>28.865726470947266 -28.761619567871094</strong>'*</p>
<p>There can be more polygons in string each needs to be separated.
I can use only standard python libraries for this</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>s='17.17165756225586 -28.102264404296875,17.184370040893555 -28.200496673583984,17.1986083984375 -28.223613739013672,17.17165756225586 -28.102264404296875, 28.865726470947266 -28.761619567871094,28.80694007873535 -28.75750160217285,28.792499542236328 -28.706947326660156, 28.865726470947266 -28.761619567871094'

#convert the input in a list of points 
coordinates = [tuple(map(float,el.split())) for el in s.split(",")]

polygons = []

#find the polygons
while coordinates:
    ind = coordinates[1:].index(coordinates[0]) 
    polygons.append(coordinates[0:ind+2])
    coordinates = coordinates[ind+2:]

#output
[(17.17165756225586, -28.102264404296875), (17.184370040893555, -28.200496673583984), (17.1986083984375, -28.223613739013672), (17.17165756225586, -28.102264404296875)]
[(28.865726470947266, -28.761619567871094), (28.80694007873535, -28.75750160217285), (28.792499542236328, -28.706947326660156), (28.865726470947266, -28.761619567871094)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a fairly ugly but working solution, just putting the obvious approach into code really.</p>
<pre><code># Note that your string has inconsistent separators -- sometimes ',', sometimes ', '.
# I'm going to separate on `,` and not worry about it -- you need to work out
# what the correct separator is.
s = '17.17165756225586 -28.102264404296875,17.184370040893555 -28.200496673583984,17.1986083984375 -28.223613739013672,17.17165756225586 -28.102264404296875, 28.865726470947266 -28.761619567871094,28.80694007873535 -28.75750160217285,28.792499542236328 -28.706947326660156, 28.865726470947266 -28.761619567871094'

coordinates = s.split(',')

polygon = []
polygons = []

new = True

for coordinate in coordinates:
    polygon.append(coordinate)

    if new:
        start = coordinate
        new = False

    elif coordinate == start:
        polygons.append(polygon)
        polygon = []
        new = True

result = [",".join(polygon) for polygon in polygons]
print(result)

Out:
['17.17165756225586 -28.102264404296875,17.184370040893555 -28.200496673583984,17.1986083984375 -28.223613739013672,17.17165756225586 -28.102264404296875', ' 28.865726470947266 -28.761619567871094,28.80694007873535 -28.75750160217285,28.792499542236328 -28.706947326660156, 28.865726470947266 -28.761619567871094']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since your input is already a string (and your expected result also?), you can try this super-lazy solution using a <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">regular expression</a> <code>(([^,]+).*\2)</code> with backreferences. Here, <code>[^,]+</code> is the first coordinate pair, <code>.*</code> the other pairs, and <code>\2</code> the first pair again.</p>
<pre><code>&gt;&gt;&gt; s = '17.17165756225586 -28.102264404296875,17.184370040893555 -28.200496673583984,17.1986083984375 -28.223613739013672,17.17165756225586 -28.102264404296875, 28.865726470947266 -28.761619567871094,28.80694007873535 -28.75750160217285,28.792499542236328 -28.706947326660156, 28.865726470947266 -28.761619567871094'
&gt;&gt;&gt; re.findall(r"(([^,]+).*\2)", s)
[('17.17165756225586 -28.102264404296875,17.184370040893555 -28.200496673583984,17.1986083984375 -28.223613739013672,17.17165756225586 -28.102264404296875',
  '17.17165756225586 -28.102264404296875'),
 (' 28.865726470947266 -28.761619567871094,28.80694007873535 -28.75750160217285,28.792499542236328 -28.706947326660156, 28.865726470947266 -28.761619567871094',
  ' 28.865726470947266 -28.761619567871094')]
</code></pre>
<p>Or use <code>finditer</code> and get the <code>group</code> to get a list of strings directly:</p>
<pre><code>&gt;&gt;&gt; [m.group() for m in re.finditer(r"(([^,]+).*\2)", s)]
['17.17165756225586 -28.102264404296875,17.184370040893555 -28.200496673583984,17.1986083984375 -28.223613739013672,17.17165756225586 -28.102264404296875',
 ' 28.865726470947266 -28.761619567871094,28.80694007873535 -28.75750160217285,28.792499542236328 -28.706947326660156, 28.865726470947266 -28.761619567871094']
</code></pre>
<p>After some post-processing, to get the actual lists of pairs of numbers (with <code>_</code> being the result of <code>findall</code>; for <code>finditer</code> drop the <code>[0]</code>):</p>
<pre><code>&gt;&gt;&gt; [[tuple(map(float, y.split())) for y in x[0].split(",")] for x in _]
[[(17.17165756225586, -28.102264404296875),
  (17.184370040893555, -28.200496673583984),
  (17.1986083984375, -28.223613739013672),
  (17.17165756225586, -28.102264404296875)],
 [(28.865726470947266, -28.761619567871094),
  (28.80694007873535, -28.75750160217285),
  (28.792499542236328, -28.706947326660156),
  (28.865726470947266, -28.761619567871094)]]
</code></pre>
<p>For longer strings, this may not be the fastest solution, I did not time it, though.</p>
</div>
<div class="post-text" itemprop="text">
<p>How about splitting your long string with every "," and puttting it into an array. Then make a for loop and do:</p>
<pre><code>intStart = 0;
if (array[intStart] == array[i]){
    for(j=0; j&lt;i; j++){
        string += array[j];
    }
    arrPolygons.push(string);
    intStart = i+1;
}
</code></pre>
<p>So when the starting coordinates match a value, add all variables between those values to a string. Then push string to another array. Then start comparing the next value to data after.</p>
<p>By the way this is just a pseudo code example.</p>
<p>Hope this helps</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>s = '17.17165756225586 -28.102264404296875,17.184370040893555 -28.200496673583984,17.1986083984375 -28.223613739013672,17.17165756225586 -28.102264404296875, 28.865726470947266 -28.761619567871094,28.80694007873535 -28.75750160217285,28.792499542236328 -28.706947326660156, 28.865726470947266 -28.761619567871094'

coord = s.split(',')

inpoly = False
poly = [[]]
start = None
for i in coord:
    poly[-1].append(i)
    if i == start:
        poly.append([])
        inpoly = False
    if not inpoly:
        start = i
        inpoly = True

print(poly)
</code></pre>
<p>Output:</p>
<pre><code>[['17.17165756225586 -28.102264404296875', '17.184370040893555 -28.200496673583984', '17.1986083984375 -28.223613739013672', '17.17165756225586 -28.102264404296875'], [' 28.865726470947266 -28.761619567871094', '28.80694007873535 -28.75750160217285', '28.792499542236328 -28.706947326660156', ' 28.865726470947266 -28.761619567871094']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I really like @newbie's solution in its conciseness. Here is a slightly more verbose/readable one:</p>
<pre><code>s = '17.17165756225586 -28.102264404296875,17.184370040893555 -28.200496673583984,17.1986083984375 -28.223613739013672,17.17165756225586 -28.102264404296875, 28.865726470947266 -28.761619567871094,28.80694007873535 -28.75750160217285,28.792499542236328 -28.706947326660156, 28.865726470947266 -28.761619567871094'
vertices = [c.strip() for c in s.split(",")] # split and clean vertex data

polygons = []           
current_polygon = None

for vertex in vertices:
    if current_polygon is None:             # start a new polygon
        current_polygon = [vertex]
    elif current_polygon[0] == vertex:      # conclude the current polygon
        current_polygon.append(vertex)
        polygons.append(current_polygon)
        current_polygon = None
    else:                                   # continue the current polygon
        current_polygon.append(vertex)

for polygon in polygons:    # print polygons
    print(",".join(polygon))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>input data...</p>
<pre><code>lst = [
    '17.17165756225586 -28.102264404296875',
    '17.184370040893555 -28.200496673583984',
    ...
    '17.1986083984375 -28.223613739013672',
    '17.17165756225586 -28.102264404296875',
    '28.865726470947266 -28.761619567871094',
    ...
    '28.80694007873535 -28.75750160217285',
    '28.792499542236328 -28.706947326660156',
    '28.865726470947266 -28.761619567871094',
]

lst1 = []
for cord in lst:
    if cord not in lst1:
        lst1.append(cord)
print(lst1)
</code></pre>
<p>output:</p>
<pre><code>[
    '17.17165756225586 -28.102264404296875',
    '17.184370040893555 -28.200496673583984',
    '17.1986083984375 -28.223613739013672',
    '28.865726470947266 -28.761619567871094',
    '28.80694007873535 -28.75750160217285',
    '28.792499542236328 -28.706947326660156',
    '28.865726470947266 -28.761619567871094',
]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A recursive approach:</p>
<pre><code>def split_polygons(s):
    if s == '':  # base case
        return []
    start, rest = s.split(',', 1)
    head, tail = map(lambda x: x.strip(', '), rest.split(start, 1))
    poly = start + ',' + head + start  # reconstruct the first polygon
    return [poly] + split_polygons(tail)
</code></pre>
<hr/>
<pre><code>&gt;&gt;&gt; p = '17.17165756225586 -28.102264404296875,17.184370040893555 -28.200496673583984,17.1986083984375 -28.223613739013672,17.17165756225586 -28.102264404296875, 28.865726470947266 -28.761619567871094,28.80694007873535 -28.75750160217285,28.792499542236328 -28.706947326660156, 28.865726470947266 -28.761619567871094'
&gt;&gt;&gt; split_polygons(p)
['17.17165756225586 -28.102264404296875,17.184370040893555 -28.200496673583984,17.1986083984375 -28.22361373901367217.17165756225586 -28.102264404296875', '28.865726470947266 -28.761619567871094,28.80694007873535 -28.75750160217285,28.792499542236328 -28.70694732666015628.865726470947266 -28.761619567871094']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>c = '17.17165756225586 -28.102264404296875,17.184370040893555 -28.200496673583984,\
    17.1986083984375 -28.223613739013672,17.17165756225586 -28.102264404296875,\
    28.865726470947266 -28.761619567871094,28.80694007873535 -28.75750160217285,\
    28.792499542236328 -28.706947326660156, 28.865726470947266 -28.761619567871094'

c = [i.strip(' ') for i in c.split(',')]
i = 0
lst = []

while i!=len(c):
    out = c[i]    
    j = i+1

    while c[i]!=c[j]:
        out = out+','+c[j]
        j = j+1

    out = out+','+c[j]
    lst.append(out)
    out=''
    i = j+1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is another way to do it, this approach applies to any string length as far as it will be based on the input format that you gave.</p>
<pre><code>strng = "17.17165756225586,-28.102264404296875,17.184370040893555,-28.200496673583984,17.1986083984375,-28.223613739013672,17.17165756225586,-28.102264404296875,28.865726470947266,-28.761619567871094,28.80694007873535,-28.75750160217285,28.792499542236328,-28.706947326660156,28.865726470947266,-28.761619567871094"
#convert to list of tuples
l_tuple = zip(*[iter(strng.split(','))]*2)
#get list of duplicate indexes
l_index=[]
for Tuple in l_tuple:
    x = [i for i,x in enumerate(l_tuple) if x == Tuple]
    if len(x)&gt;1:
        l_index.append(x)
#get separate lists
New_list = []
for IND in list(set(map(tuple,l_index))):
    print(l_tuple[IND[0]:IND[1]+1])
    New_list.append(l_tuple[IND[0]:IND[1]+1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; lst = ['17.17165756225586 -28.102264404296875','17.184370040893555 -28.200496673583984',\
... '17.1986083984375 -28.223613739013672','17.17165756225586 -28.102264404296875',' 28.865726470947266 -28.761619567871094',\
... '28.80694007873535 -28.75750160217285','28.792499542236328 -28.706947326660156', '28.865726470947266 -28.761619567871094']

&gt;&gt;&gt; lst1 =[]
&gt;&gt;&gt; for cord in lst:
...    if cord not in lst1:
...         lst1.append(cord)
... 
&gt;&gt;&gt; print(lst1)
['17.17165756225586 -28.102264404296875', '17.184370040893555 -28.200496673583984', '17.1986083984375 -28.223613739013672', ' 28.865726470947266 -28.761619567871094', '28.80694007873535 -28.75750160217285', '28.792499542236328 -28.706947326660156', '28.865726470947266 -28.761619567871094']
</code></pre>
</div>
<span class="comment-copy">Bolded ones are same points for each polygons (start/end)</span>
<span class="comment-copy">Oh someone please format it. I'm in a hurry</span>
<span class="comment-copy">I think it's formatted fine once it's explained what bold means.</span>
<span class="comment-copy">Where's the difficulty, you read the first pair and scan until it reappears ?</span>
<span class="comment-copy">Yes, each pair is separated by comma.</span>
<span class="comment-copy">I don't think we'll escape "ugly" on this one :)</span>
<span class="comment-copy">Nice, I came up with <code>r'(([\-\d\. ]+).*?\2)'</code>, 15 minutes too late. Is there any possibility to get a list of strings directly instead of a list of tuples of strings?</span>
<span class="comment-copy">Is seems to work, will have to test it on string with more polygons.</span>
<span class="comment-copy">@EricDuminil I tried with non-capturing groups, but using <code>findall</code> this seems to be the only way. You could also use <code>[m.group() for m in re.finditer(...)]</code> though to get just a list of strings.</span>
<span class="comment-copy">Why are you posting an answer in another language? If anything, this just confuses the problem</span>
<span class="comment-copy">This completely misses the mark. You haven't made pairs of coordinates or split the list, you've just filtered it in a way that isn't meaningful</span>
