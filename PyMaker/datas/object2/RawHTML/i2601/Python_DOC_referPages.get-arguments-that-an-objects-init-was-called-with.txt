<div class="post-text" itemprop="text">
<p>Is there a way to get an object's init argument values in python 2.7? I'm able to get the defaults through getargspec but i would like to access passed in values</p>
<pre><code>import inspect

class AnObject(object):
    def __init__(self, kw='', *args, **kwargs):
        print 'Hello'

anobj = AnObject(kw='a keyword arg')
print inspect.getargspec(anobj.__init__)
</code></pre>
<p>Returns</p>
<pre><code>Hello
ArgSpec(args=['self', 'kw'], varargs='args', keywords='kwargs', defaults=('',))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong><code>__init__</code> is treated no differently than any other function. So, like with any other function, its arguments are discarded once it returns</strong> -- unless you save them somewhere before that.</p>
<p>The standard approach is to save what you need later in attributes of the instance:</p>
<pre><code>class Foo:
    def __init__(self, a, b, *args, **kwargs):
        self.a = a
        self.b = b
        &lt;etc&gt;
</code></pre>
<p><a href="https://docs.python.org/3/library/dataclasses.html" rel="nofollow noreferrer">"Dataclasses" introduced in 3.7</a> streamline this process but <a href="https://stackoverflow.com/questions/49931096/how-to-add-a-dataclass-field-without-annotating-the-type">require data annotations</a>:</p>
<pre><code>import dataclasses

@dataclasses.dataclass
class Foo:
    a: int
    b: str
</code></pre>
<p>is equivalent to:</p>
<pre><code>class Foo:
    def __init__(self, a:int, b:str):
        self.a = a
        self.b = b
</code></pre>
<p>Though see <a href="https://stackoverflow.com/questions/28443527/python-decorator-to-automatically-define-init-variables/28443682#28443682">Python decorator to automatically define __init__ variables</a> why this streamlining is not very useful in practice.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can store them as attributes.</p>
<pre class="lang-python prettyprint-override"><code>class AnObject(object):
    def __init__(self, kw='', *args, **kwargs):
        self.kw = kw
        self.args = args
        self.kwargs = kwargs 
</code></pre>
<p>then just print them:</p>
<pre class="lang-python prettyprint-override"><code>anobj = AnObject(kw='a keyword arg')
print anobj.kw
print anobj.args
print anobj.kwargs
</code></pre>
<p>if you want to see them all, you could take a look into its <code>__dict__</code> attribute. </p>
</div>
<span class="comment-copy">No, that information isn’t kept around anywhere. Most classes will of course store their init arguments in attributes, or use them in some way to build whatever values they do store in attributes, but otherwise, the information is gone, just like the parameters (and other local variables) from <i>any</i> function are gone once the function completes.</span>
<span class="comment-copy">Depending on what you’re actually trying to do here, the answer is probably either “run the code in the debugger” or “modify AnObject (maybe just temporarily) to explicitly store whatever you want to loop up later”. (There’s nothing stopping you from storing <code>kw, args, kwargs</code> in an attribute, or <code>inspect.signature(type(self)).bind(kw, *args, **kwargs)</code>, or <code>locals()</code>, or even the current frame object, but most of those will usually be a bad idea.)</span>
<span class="comment-copy">@abarnert Thanks, I was curious if it was possible since I did not wish to modify the class containing the object.</span>
<span class="comment-copy">It’s very useful in practice, as long as your class is the kind of class you’d think of given the name “dataclass”, something that’s mainly about keeping a bunch of related values together, like a C pod struct, and then maybe adding behavior on top. It’s not useful for other things like parsers or active simulation objects or whatever, but data classes do some up often enough for people to misuse namedtuple, for attrs to become one of the top projects on PyPI, etc., which is why dataclass was finally added to the language.</span>
