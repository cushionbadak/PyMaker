<div class="post-text" itemprop="text">
<p>I've been fascinated by the <code>__future__</code> module - in particular, its ability to change the way statements are parsed in python. </p>
<p>What's most interesting is how doing something like </p>
<pre><code>from __future__ import print_function
</code></pre>
<p>Enables you to use <code>print</code> (and not <code>print_function</code>, like you would expect any other normal import to do).</p>
<p>I have read <a href="https://stackoverflow.com/questions/7075082/what-is-future-in-python-used-for-and-how-when-to-use-it-and-how-it-works">What is __future__ in Python used for and how/when to use it, and how it works</a> thoroughly and in particular came across a particular line:</p>
<blockquote>
<p>A future statement is a directive to the compiler that a particular
  module should be compiled using syntax or semantics that will be
  available in a specified future release of Python.</p>
</blockquote>
<p>I would love to know the intricacies of what exactly makes this possible. In particular, how something like </p>
<pre><code>from __future__ import division
</code></pre>
<p>Can enable true division on python2, while</p>
<pre><code>from __future__ import barry_as_FLUFL
</code></pre>
<p>Can enable the <code>&lt;&gt;</code> syntax on python3 (what I find most funny is that you have to import a feature from "<code>__future__</code>" for backward compatibility).</p>
<p>Anyway, to summarise, I would like to know how the directive is understood and executed by the compiler when <code>__future__</code> or its artefacts are imported. </p>
</div>
<div class="post-text" itemprop="text">
<p><code>from __future__ import print_function</code> tells the parser to <a href="https://github.com/python/cpython/blob/v2.7.13/Parser/parser.c#L142-L160" rel="noreferrer">not treat <code>print</code> as a keyword</a> (leaving it as a name instead). That way the compiler treats it as the function and not a statement.</p>
<p>To track this, the <code>compiler</code> struct has a <code>c_future</code> field that holds a <code>PyFutureFeatures</code> object that tracks which future directives have been enabled. Various parts of the parser and compiler check the flags and alter behaviour.</p>
<p>This is mostly handled in the <a href="https://github.com/python/cpython/blob/v3.6.2/Python/future.c" rel="noreferrer"><code>future.c</code> source file</a>, which has a <a href="https://github.com/python/cpython/blob/v3.6.2/Python/future.c#L60-L125" rel="noreferrer"><code>future_parse()</code> function</a> that checks for <code>import from</code> AST objects with the module parameter set to <code>__future__</code>, and sets flags based on what is found.</p>
<p>For example, for the <code>barry_as_FLUFL</code> 'feature', the parser <a href="https://github.com/python/cpython/blob/v3.6.2/Parser/parsetok.c#L239-L254" rel="noreferrer">refuses <code>!=</code> as syntax but accepts <code>&lt;&gt;</code> instead</a>:</p>
<pre class="lang-c prettyprint-override"><code>if (type == NOTEQUAL) {
    if (!(ps-&gt;p_flags &amp; CO_FUTURE_BARRY_AS_BDFL) &amp;&amp;
                    strcmp(str, "!=")) {
        PyObject_FREE(str);
        err_ret-&gt;error = E_SYNTAX;
        break;
    }
    else if ((ps-&gt;p_flags &amp; CO_FUTURE_BARRY_AS_BDFL) &amp;&amp;
                    strcmp(str, "&lt;&gt;")) {
        PyObject_FREE(str);
        err_ret-&gt;text = "with Barry as BDFL, use '&lt;&gt;' "
                        "instead of '!='";
        err_ret-&gt;error = E_SYNTAX;
        break;
    }
}
</code></pre>
<p>You can find the other examples by grepping for the <code>FUTURE_*</code> flags <a href="https://github.com/python/cpython/blob/v3.6.2/Include/compile.h#L22-L30" rel="noreferrer">listed in <code>compile.h</code></a>.</p>
<p>Note that there is a <a href="https://docs.python.org/3/library/__future__.html" rel="noreferrer"><code>__future__</code> Python module</a>, but it is not directly involved in the parsing and compilation of code; it is merely there to give Python code easy access to metadata about directives (including bitfield values to pass to the <code>flags</code> argument of the <a href="https://docs.python.org/3/library/functions.html#compile" rel="noreferrer"><code>compile()</code> function</a>), nothing more.</p>
</div>
<span class="comment-copy">Because it's <i>not</i> a normal import. See <a href="https://docs.python.org/2/reference/simple_stmts.html#future" rel="nofollow noreferrer">docs.python.org/2/reference/simple_stmts.html#future</a></span>
<span class="comment-copy">@jonrsharpe "<i>Anyway, to summarise, I would like to know how the directive is understood and executed by the compiler when <b>future</b> or its artefacts are imported.</i>" I have done my research but thanks for the downvote anyway.</span>
<span class="comment-copy">I should've probably changed the title to discourage people with short attention spans from down voting.</span>
<span class="comment-copy">I feel like there is definitely some <i>meat</i> to this question for whatever my opinion is worth.</span>
<span class="comment-copy">@Ev.Kounis Those 3 downvoters and 1 close voter would disagree, but whatever, like I said... probably my fault for the initial bad title.</span>
<span class="comment-copy">I know this already. What I wanted to know how it works under the hood... that was the purpose of this question.</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ: that's.. rather broad, but I'll see what I can fill in.</span>
<span class="comment-copy">What I find most funny about barry is that he has to come from <code>__future__</code> instead of something more sensible like <code>__past__</code>. Thanks for the great answer as always.</span>
