<div class="post-text" itemprop="text">
<p>I am trying to iterate over a numpy array and change some values inside it. Here's my code, it's literally copied from the documentation (<a href="https://docs.scipy.org/doc/numpy/reference/arrays.nditer.html" rel="nofollow noreferrer">numpy nditer docs</a>):</p>
<pre><code>import numpy as np

a = np.arange(6).reshape(2,3)
print(a)
with np.nditer(a, op_flags=['readwrite']) as it:
  for x in it:
    x[...] = 2 * x

print(a)
</code></pre>
<p>But I keep getting the following traceback:</p>
<pre><code>Traceback (most recent call last):
  File "text.py", line 5, in &lt;module&gt;
    with np.nditer(a, op_flags=['readwrite']) as it:
AttributeError: __enter__
</code></pre>
<p>Am I doing something incorrectly, or is there a mistake in the docs (is the usage of <code>nditer</code> inside <code>with</code> deprecated)?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are looking at the documentation for Numpy 1.15, and this uses a <a href="https://docs.scipy.org/doc/numpy/release.html#under-certain-conditions-nditer-must-be-used-in-a-context-manager" rel="nofollow noreferrer">new feature of <code>nditer()</code> introduced in that release</a>:</p>
<blockquote>
<p><strong>Under certain conditions, nditer must be used in a context manager</strong></p>
<p>When using an <code>numpy.nditer</code> with the <code>"writeonly"</code> or <code>"readwrite"</code> flags, there are some circumstances where <code>nditer</code> doesn’t actually give you a view of the writable array. Instead, it gives you a copy, and if you make changes to the copy, <code>nditer</code> later writes those changes back into your actual array. Currently, this writeback occurs when the array objects are garbage collected, which makes this API error-prone on CPython and entirely broken on PyPy. Therefore, <code>nditer</code> should now be used as a context manager whenever it is used with writeable arrays, e.g., <code>with np.nditer(...) as it: ...</code>. You may also explicitly call <code>it.close()</code> for cases where a context manager is unusable, for instance in generator expressions.</p>
</blockquote>
<p>The error indicates you have an earlier version of Numpy; the <code>with</code> statement only works with *context managers, which <a href="https://docs.python.org/3/reference/datamodel.html#with-statement-context-managers" rel="nofollow noreferrer">must implement <code>__exit__</code> (and <code>__enter__</code>)</a>, and the <code>AttributeError</code> exception indicates that in your Numpy version the required implementation isn’t there. </p>
<p>Either upgrade, or don't use <code>with</code>:</p>
<pre><code>for x in np.nditer(a, op_flags=['readwrite']):
    x[...] = 2 * x
</code></pre>
<p>When using CPython you <em>may</em> still run into the issues that caused the change made in the 1.15 release however. When using PyPy you <em>will</em> run into those issues, and upgrading is your only proper recourse.</p>
<p>You probably want to refer to the <a href="https://docs.scipy.org/doc/numpy-1.14.0/reference/arrays.nditer.html#modifying-array-values" rel="nofollow noreferrer">1.14 version of the same documentation entry you used</a> (or more specifically, make sure to <a href="https://docs.scipy.org/doc/" rel="nofollow noreferrer">pick the right documentation for your local version</a>.</p>
</div>
<span class="comment-copy">That probably means your numpy version is too old. <code>__enter__</code> is called by <code>with</code>, but that's not implemented in your version.</span>
<span class="comment-copy">Check comments in this other recent nditer question, <a href="https://stackoverflow.com/q/52135891/901925">stackoverflow.com/q/52135891/901925</a></span>
<span class="comment-copy">Thanks, I was using numpy from Fedora's repository, which seems to be 1.14.5.  Problem solved.</span>
