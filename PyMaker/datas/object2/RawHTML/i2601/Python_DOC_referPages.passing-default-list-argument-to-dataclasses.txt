<div class="post-text" itemprop="text">
<p>I would like to pass default argument in my class, 
but somehow I am having problem:</p>
<pre><code>from dataclasses import dataclass, field
from typing import List

@dataclass
class Pizza():
    ingredients: List = field(default_factory=['dow', 'tomatoes'])
    meat: str = field(default='chicken')


    def __repr__(self):
        return 'preparing_following_pizza {} {}'.format(self.ingredients, self.meat)
</code></pre>
<p>if I type.</p>
<pre><code>Pizza.ingredients
</code></pre>
<p>I get following error:</p>
<blockquote>
<p>--------------------------------------------------------------------------- AttributeError                            Traceback (most recent call
  last)  in ()
  ----&gt; 1 Pizza.ingredients</p>
<p>AttributeError: type object 'Pizza' has no attribute 'ingredients'</p>
</blockquote>
<p>edit:
with class instance I got following error:</p>
<pre><code>my_order = Pizza()
</code></pre>
<blockquote>
<p>--------------------------------------------------------------------------- TypeError                                 Traceback (most recent call
  last)  in ()
  ----&gt; 1 my_order = Pizza()</p>
<p> in <strong>init</strong>(self, ingredients, meat)</p>
<p>TypeError: 'list' object is not callable</p>
</blockquote>
<p>edit 2: </p>
<p>quick check with <code>dir</code> yields following:</p>
<pre><code>['__annotations__',
 '__class__',
 '__dataclass_fields__',
 '__dataclass_params__',
 '__delattr__',
 '__dict__',
 '__dir__',
 '__doc__',
 '__eq__',
 '__format__',
 '__ge__',
 '__getattribute__',
 '__gt__',
 '__hash__',
 '__init__',
 '__init_subclass__',
 '__le__',
 '__lt__',
 '__module__',
 '__ne__',
 '__new__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__sizeof__',
 '__str__',
 '__subclasshook__',
 '__weakref__',
 'meat']
</code></pre>
<p>there is <code>meat</code> but not <code>ingredients</code></p>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="https://docs.python.org/3/library/dataclasses.html#dataclasses.field" rel="nofollow noreferrer">the <code>dataclasses.field</code> docs</a>:</p>
<blockquote>
<p>The parameters to <code>field()</code> are:</p>
<ul>
<li><strong>default_factory:</strong> If provided, <strong>it must be a zero-argument callable</strong> that
  will be called when a default value is needed for this field. Among
  other purposes, this can be used to specify fields with mutable
  default values, as discussed below. It is an error to specify both
  default and default_factory.</li>
</ul>
</blockquote>
<p>Your <code>default_factory</code> is not a 0-argument callable but a list, which is the reason for the error:</p>
<pre><code>@dataclass
class Pizza():
    ingredients: List = field(default_factory=['dow', 'tomatoes'])  # &lt;- wrong!
</code></pre>
<p>Use a lambda function instead:</p>
<pre><code>@dataclass
class Pizza():
    ingredients: List = field(default_factory=lambda: ['dow', 'tomatoes'])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For complex datatypes i tend to abbreviate like so:</p>
<pre><code>from dataclasses import dataclass, field
from typing import Dict, Tuple

def default_field(obj):
    return field(default_factory=lambda: obj)

@dataclass
class C:
    complex_attribute: Dict[str, Tuple[int, str]] = default_field({"a": (1, "x"), "b": (1, "y")})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This approach doesn't use the <code>typing</code> or <code>dataclasses</code> module, but you may want to try something like the following:</p>
<pre><code>class Pizza():
    defaults = {
        'toppings': ['peppers', 'cheese'],
        'ingredients': ['dough', 'tomato'],
        'meat': 'chicken'
    }
    def __init__(self, toppings=None, meat=None, ingredients=None):
        if toppings is None:
            setattr(self, 'toppings', defaults['toppings'])

         if meat is None:
            setattr(self, 'meat', defaults['meat'])

         if ingredients is None:
            setattr(self, 'ingredients', defaults['ingredients'])
</code></pre>
<p>I could have set the arguments in <code>__init__</code> to their defaults, but I think this <em>may</em> cause conflict in referencing the same list. </p>
</div>
<span class="comment-copy">I think the problem <i>may</i> be because you haven't created an instance of your class</span>
<span class="comment-copy">even with created class instance it does not work..</span>
<span class="comment-copy">No repro. It works perfectly fine with an instance. Please post a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a> so we can see what you're doing wrong.</span>
<span class="comment-copy">@Aran-Fey did you try to write the code?  As I said it doesn't work with the an instance, see my edit</span>
<span class="comment-copy">I dont want to use <b>init</b>, the whole point of  @dataclass decorator is that you can skip init</span>
<span class="comment-copy">Ok, I see now. Thankx!</span>
<span class="comment-copy">I know this way, but I would like to use decorator @dataclass</span>
