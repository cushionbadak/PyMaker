<div class="post-text" itemprop="text">
<p>Python 2.6 introduced the <a href="https://docs.python.org/2/library/stdtypes.html#str.format" rel="noreferrer"><code>str.format()</code></a> method with a slightly different syntax from the existing <code>%</code> operator. Which is better and for what situations?</p>
<ol>
<li><p>The following uses each method and has the same outcome, so what is the difference?</p>
<pre><code>#!/usr/bin/python
sub1 = "python string!"
sub2 = "an arg"

a = "i am a %s" % sub1
b = "i am a {0}".format(sub1)

c = "with %(kwarg)s!" % {'kwarg':sub2}
d = "with {kwarg}!".format(kwarg=sub2)

print a    # "i am a python string!"
print b    # "i am a python string!"
print c    # "with an arg!"
print d    # "with an arg!"
</code></pre></li>
<li><p>Furthermore when does string formatting occur in Python? For example, if my logging level is set to HIGH will I still take a hit for performing the following <code>%</code> operation? And if so, is there a way to avoid this?</p>
<pre><code>log.debug("some debug info: %s" % some_info)
</code></pre></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>To answer your first question... <code>.format</code> just seems more sophisticated in many ways. An annoying thing about <code>%</code> is also how it can either take a variable or a tuple. You'd think the following would always work:</p>
<pre><code>"hi there %s" % name
</code></pre>
<p>yet, if <code>name</code> happens to be <code>(1, 2, 3)</code>, it will throw a <code>TypeError</code>. To guarantee that it always prints, you'd need to do</p>
<pre><code>"hi there %s" % (name,)   # supply the single argument as a single-item tuple
</code></pre>
<p>which is just ugly. <code>.format</code> doesn't have those issues. Also in the second example you gave, the <code>.format</code> example is much cleaner looking.</p>
<p>Why would you not use it? </p>
<ul>
<li>not knowing about it (me before reading this)</li>
<li>having to be compatible with Python 2.5</li>
</ul>
<hr/>
<p>To answer your second question, string formatting happens at the same time as any other operation - when the string formatting expression is evaluated. And Python, not being a lazy language, evaluates expressions before calling functions, so in your <code>log.debug</code> example, the expression <code>"some debug info: %s"%some_info</code>will first evaluate to, e.g. <code>"some debug info: roflcopters are active"</code>, then that string will be passed to <code>log.debug()</code>. </p>
</div>
<div class="post-text" itemprop="text">
<p>Something that the modulo operator ( % ) can't do, afaik:</p>
<pre><code>tu = (12,45,22222,103,6)
print '{0} {2} {1} {2} {3} {2} {4} {2}'.format(*tu)
</code></pre>
<p>result</p>
<pre><code>12 22222 45 22222 103 22222 6 22222
</code></pre>
<p>Very useful.</p>
<p>Another point: <code>format()</code>, being a function, can be used as an argument in other functions: </p>
<pre><code>li = [12,45,78,784,2,69,1254,4785,984]
print map('the number is {}'.format,li)   

print

from datetime import datetime,timedelta

once_upon_a_time = datetime(2010, 7, 1, 12, 0, 0)
delta = timedelta(days=13, hours=8,  minutes=20)

gen =(once_upon_a_time +x*delta for x in xrange(20))

print '\n'.join(map('{:%Y-%m-%d %H:%M:%S}'.format, gen))
</code></pre>
<p>Results in:</p>
<pre><code>['the number is 12', 'the number is 45', 'the number is 78', 'the number is 784', 'the number is 2', 'the number is 69', 'the number is 1254', 'the number is 4785', 'the number is 984']

2010-07-01 12:00:00
2010-07-14 20:20:00
2010-07-28 04:40:00
2010-08-10 13:00:00
2010-08-23 21:20:00
2010-09-06 05:40:00
2010-09-19 14:00:00
2010-10-02 22:20:00
2010-10-16 06:40:00
2010-10-29 15:00:00
2010-11-11 23:20:00
2010-11-25 07:40:00
2010-12-08 16:00:00
2010-12-22 00:20:00
2011-01-04 08:40:00
2011-01-17 17:00:00
2011-01-31 01:20:00
2011-02-13 09:40:00
2011-02-26 18:00:00
2011-03-12 02:20:00
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assuming you're using Python's <code>logging</code> module, you can pass the string formatting arguments as arguments to the <code>.debug()</code> method rather than doing the formatting yourself:</p>
<pre><code>log.debug("some debug info: %s", some_info)
</code></pre>
<p>which avoids doing the formatting unless the logger actually logs something.</p>
</div>
<div class="post-text" itemprop="text">
<p>As of Python 3.6 (2016) you can use <a href="https://docs.python.org/3.6/whatsnew/3.6.html#whatsnew36-pep498" rel="noreferrer"><em>f-strings</em></a> to substitute variables:</p>
<pre><code>&gt;&gt;&gt; origin = "London"
&gt;&gt;&gt; destination = "Paris"
&gt;&gt;&gt; f"from {origin} to {destination}"
'from London to Paris'
</code></pre>
<p>Note the <code>f"</code> prefix. If you try this in Python 3.5 or earlier, you'll get a <code>SyntaxError</code>.</p>
<p>See <a href="https://docs.python.org/3.6/reference/lexical_analysis.html#f-strings" rel="noreferrer">https://docs.python.org/3.6/reference/lexical_analysis.html#f-strings</a></p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://www.python.org/dev/peps/pep-3101/" rel="noreferrer">PEP 3101</a> proposes the replacement of the <code>%</code> operator with the new, advanced string formatting in Python 3, where it would be the default.</p>
</div>
<div class="post-text" itemprop="text">
<p>But please be careful, just now I've discovered one issue when trying to replace all <code>%</code> with <code>.format</code> in existing code: <strong><code>'{}'.format(unicode_string)</code> will try to encode unicode_string and will probably fail.</strong></p>
<p>Just look at this Python interactive session log:</p>
<pre><code>Python 2.7.2 (default, Aug 27 2012, 19:52:55) 
[GCC 4.1.2 20080704 (Red Hat 4.1.2-48)] on linux2
; s='й'
; u=u'й'
; s
'\xd0\xb9'
; u
u'\u0439'
</code></pre>
<p><code>s</code> is just a string (called 'byte array' in Python3) and <code>u</code> is a Unicode string (called 'string' in Python3):</p>
<pre><code>; '%s' % s
'\xd0\xb9'
; '%s' % u
u'\u0439'
</code></pre>
<p>When you give a Unicode object as a parameter to <code>%</code> operator it will produce a Unicode string even if the original string wasn't Unicode:</p>
<pre><code>; '{}'.format(s)
'\xd0\xb9'
; '{}'.format(u)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
UnicodeEncodeError: 'latin-1' codec can't encode character u'\u0439' in position 0: ordinal not in range(256)
</code></pre>
<p>but the <code>.format</code> function will raise "UnicodeEncodeError":</p>
<pre><code>; u'{}'.format(s)
u'\xd0\xb9'
; u'{}'.format(u)
u'\u0439'
</code></pre>
<p>and it will work with a Unicode argument fine only if the original string was Unicode.</p>
<pre><code>; '{}'.format(u'i')
'i'
</code></pre>
<p>or if argument string can be converted to a string (so called 'byte array')</p>
</div>
<div class="post-text" itemprop="text">
<p>Yet another advantage of <code>.format</code> (which I don't see in the answers): it can take object properties.</p>
<pre><code>In [12]: class A(object):
   ....:     def __init__(self, x, y):
   ....:         self.x = x
   ....:         self.y = y
   ....:         

In [13]: a = A(2,3)

In [14]: 'x is {0.x}, y is {0.y}'.format(a)
Out[14]: 'x is 2, y is 3'
</code></pre>
<p>Or, as a keyword argument:</p>
<pre><code>In [15]: 'x is {a.x}, y is {a.y}'.format(a=a)
Out[15]: 'x is 2, y is 3'
</code></pre>
<p>This is not possible with <code>%</code> as far as I can tell.</p>
</div>
<div class="post-text" itemprop="text">
<p>As I discovered today, the old way of formatting strings via <code>%</code> doesn't support <code>Decimal</code>, Python's module for decimal fixed point and floating point arithmetic, out of the box.</p>
<p>Example (using Python 3.3.5):</p>
<pre><code>#!/usr/bin/env python3

from decimal import *

getcontext().prec = 50
d = Decimal('3.12375239e-24') # no magic number, I rather produced it by banging my head on my keyboard

print('%.50f' % d)
print('{0:.50f}'.format(d))
</code></pre>
<p>Output:</p>
<blockquote>
<p>0.00000000000000000000000312375239000000009907464850
  0.00000000000000000000000312375239000000000000000000</p>
</blockquote>
<p>There surely might be work-arounds but you still might consider using the <code>format()</code> method right away. </p>
</div>
<div class="post-text" itemprop="text">
<p><code>%</code> gives better performance than <code>format</code> from my test.</p>
<p>Test code:</p>
<p>Python 2.7.2:</p>
<pre><code>import timeit
print 'format:', timeit.timeit("'{}{}{}'.format(1, 1.23, 'hello')")
print '%:', timeit.timeit("'%s%s%s' % (1, 1.23, 'hello')")
</code></pre>
<p>Result:</p>
<pre><code>&gt; format: 0.470329046249
&gt; %: 0.357107877731
</code></pre>
<p>Python 3.5.2</p>
<pre><code>import timeit
print('format:', timeit.timeit("'{}{}{}'.format(1, 1.23, 'hello')"))
print('%:', timeit.timeit("'%s%s%s' % (1, 1.23, 'hello')"))
</code></pre>
<p>Result</p>
<pre><code>&gt; format: 0.5864730989560485
&gt; %: 0.013593495357781649
</code></pre>
<p>It looks in Python2, the difference is small whereas in Python3, <code>%</code> is much faster than <code>format</code>.</p>
<p>Thanks @Chris Cogdon for the sample code.</p>
</div>
<div class="post-text" itemprop="text">
<p>As a side note, you don't have to take a performance hit to use new style formatting with logging.  You can pass any object to <code>logging.debug</code>, <code>logging.info</code>, etc. that implements the <code>__str__</code> magic method.  When the logging module has decided that it must emit your message object (whatever it is), it calls <code>str(message_object)</code> before doing so.  So you could do something like this:</p>
<pre><code>import logging


class NewStyleLogMessage(object):
    def __init__(self, message, *args, **kwargs):
        self.message = message
        self.args = args
        self.kwargs = kwargs

    def __str__(self):
        args = (i() if callable(i) else i for i in self.args)
        kwargs = dict((k, v() if callable(v) else v) for k, v in self.kwargs.items())

        return self.message.format(*args, **kwargs)

N = NewStyleLogMessage

# Neither one of these messages are formatted (or calculated) until they're
# needed

# Emits "Lazily formatted log entry: 123 foo" in log
logging.debug(N('Lazily formatted log entry: {0} {keyword}', 123, keyword='foo'))


def expensive_func():
    # Do something that takes a long time...
    return 'foo'

# Emits "Expensive log entry: foo" in log
logging.debug(N('Expensive log entry: {keyword}', keyword=expensive_func))
</code></pre>
<p>This is all described in the Python 3 documentation (<a href="https://docs.python.org/3/howto/logging-cookbook.html#formatting-styles" rel="noreferrer">https://docs.python.org/3/howto/logging-cookbook.html#formatting-styles</a>).  However, it will work with Python 2.6 as well (<a href="https://docs.python.org/2.6/library/logging.html#using-arbitrary-objects-as-messages" rel="noreferrer">https://docs.python.org/2.6/library/logging.html#using-arbitrary-objects-as-messages</a>).</p>
<p>One of the advantages of using this technique, other than the fact that it's formatting-style agnostic, is that it allows for lazy values e.g. the function <code>expensive_func</code> above.  This provides a more elegant alternative to the advice being given in the Python docs here: <a href="https://docs.python.org/2.6/library/logging.html#optimization" rel="noreferrer">https://docs.python.org/2.6/library/logging.html#optimization</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>One situation where <code>%</code> may help is when you are formatting regex expressions. For example, </p>
<pre><code>'{type_names} [a-z]{2}'.format(type_names='triangle|square')
</code></pre>
<p>raises <code>IndexError</code>. In this situation, you can use:</p>
<pre><code>'%(type_names)s [a-z]{2}' % {'type_names': 'triangle|square'}
</code></pre>
<p>This avoids writing the regex as <code>'{type_names} [a-z]{{2}}'</code>. This can be useful when you have two regexes, where one is used alone without format, but the concatenation of both is formatted.</p>
</div>
<div class="post-text" itemprop="text">
<p>If your python &gt;= 3.6, F-string formatted literal is your new friend.</p>
<p>It's more simple, clean, and better performance.</p>
<pre><code>In [1]: params=['Hello', 'adam', 42]

In [2]: %timeit "%s %s, the answer to everything is %d."%(params[0],params[1],params[2])
448 ns ± 1.48 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)

In [3]: %timeit "{} {}, the answer to everything is {}.".format(*params)
449 ns ± 1.42 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)

In [4]: %timeit f"{params[0]} {params[1]}, the answer to everything is {params[2]}."
12.7 ns ± 0.0129 ns per loop (mean ± std. dev. of 7 runs, 100000000 loops each)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would add that since version 3.6, we can use fstrings like the following</p>
<pre><code>foo = "john"
bar = "smith"
print(f"My name is {foo} {bar}")
</code></pre>
<p>Which give</p>
<blockquote>
<p>My name is john smith</p>
</blockquote>
<p><strong>Everything is converted to strings</strong></p>
<pre><code>mylist = ["foo", "bar"]
print(f"mylist = {mylist}")
</code></pre>
<p>Result:</p>
<blockquote>
<p>mylist = ['foo', 'bar']</p>
</blockquote>
<p><strong>you can pass function, like in others formats method</strong></p>
<pre><code>print(f'Hello, here is the date : {time.strftime("%d/%m/%Y")}')
</code></pre>
<p>Giving for example</p>
<blockquote>
<p>Hello, here is the date : 16/04/2018</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>For python version &gt;= 3.6 (see <a href="https://www.python.org/dev/peps/pep-0498/" rel="nofollow noreferrer">PEP 498</a>)</p>
<pre><code>s1='albha'
s2='beta'

f'{s1}{s2:&gt;10}'

#output
'albha      beta'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>But one thing is that also if you have nested curly-braces, won't work for format but <code>%</code> will work.</p>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; '{{0}, {1}}'.format(1,2)
Traceback (most recent call last):
  File "&lt;pyshell#3&gt;", line 1, in &lt;module&gt;
    '{{0}, {1}}'.format(1,2)
ValueError: Single '}' encountered in format string
&gt;&gt;&gt; '{%s, %s}'%(1,2)
'{1, 2}'
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python 3.6.7 comparative:</p>
<pre><code>#!/usr/bin/env python
import timeit

def time_it(fn):
    """
    Measure time of execution of a function
    """
    def wrapper(*args, **kwargs):
        t0 = timeit.default_timer()
        fn(*args, **kwargs)
        t1 = timeit.default_timer()
        print("{0:.10f} seconds".format(t1 - t0))
    return wrapper


@time_it
def new_new_format(s):
    print("new_new_format:", f"{s[0]} {s[1]} {s[2]} {s[3]} {s[4]}")


@time_it
def new_format(s):
    print("new_format:", "{0} {1} {2} {3} {4}".format(*s))


@time_it
def old_format(s):
    print("old_format:", "%s %s %s %s %s" % s)


def main():
    samples = (("uno", "dos", "tres", "cuatro", "cinco"), (1,2,3,4,5), (1.1, 2.1, 3.1, 4.1, 5.1), ("uno", 2, 3.14, "cuatro", 5.5),) 
    for s in samples:
        new_new_format(s)
        new_format(s)
        old_format(s)
        print("-----")


if __name__ == '__main__':
    main()
</code></pre>
<p>Output:</p>
<pre><code>new_new_format: uno dos tres cuatro cinco
0.0000170280 seconds
new_format: uno dos tres cuatro cinco
0.0000046750 seconds
old_format: uno dos tres cuatro cinco
0.0000034820 seconds
-----
new_new_format: 1 2 3 4 5
0.0000043980 seconds
new_format: 1 2 3 4 5
0.0000062590 seconds
old_format: 1 2 3 4 5
0.0000041730 seconds
-----
new_new_format: 1.1 2.1 3.1 4.1 5.1
0.0000092650 seconds
new_format: 1.1 2.1 3.1 4.1 5.1
0.0000055340 seconds
old_format: 1.1 2.1 3.1 4.1 5.1
0.0000052130 seconds
-----
new_new_format: uno 2 3.14 cuatro 5.5
0.0000053380 seconds
new_format: uno 2 3.14 cuatro 5.5
0.0000047570 seconds
old_format: uno 2 3.14 cuatro 5.5
0.0000045320 seconds
-----
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Strictly seen we are really getting far from the original topic, but then why not: </p>
<p>When using the gettext module to provide e.g. a localized GUI, old and new style strings are the only way; f-strings can not be used there. IMHO the new-style are the best choice for this case. There is a SO question on this <a href="https://stackoverflow.com/questions/49797658/how-to-use-gettext-with-python-3-6-f-strings">here</a>.</p>
</div>
<span class="comment-copy">similar to <a href="http://stackoverflow.com/questions/3691975/s-format-vs-0-format-vs-format" title="s format vs 0 format vs format">stackoverflow.com/questions/3691975/…</a></span>
<span class="comment-copy">@S.Lott, the point is that there is is non zero work going on, if a logging statement is not printing I want zero work done for the string formatting.</span>
<span class="comment-copy">For beginners: Here is a <a href="http://www.python-course.eu/python3_formatted_output.php" rel="nofollow noreferrer">very nice tutorial</a> that teaches both styles. I personally use the older <code>%</code> style more often, because if you do not need the improved capabilities of the <code>format()</code> style, the <code>%</code> style is often a lot more convenient.</span>
<span class="comment-copy">For reference: Python 3 documentation for the <a href="https://docs.python.org/3/library/string.html#format-string-syntax" rel="nofollow noreferrer">newer <code>format()</code> formatting style</a> and the <a href="https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting" rel="nofollow noreferrer">older <code>%</code>-based formatting style</a>.</span>
<span class="comment-copy">See also: <a href="http://stackoverflow.com/questions/13451989/pythons-many-ways-of-string-formatting-are-the-older-ones-going-to-be-deprec">Pythons many ways of string formatting</a></span>
<span class="comment-copy">what about <code>"%(a)s, %(a)s" % {'a':'test'}</code></span>
<span class="comment-copy">Note that you will waste time for <code>log.debug("something: %s" % x)</code> but not for <code>log.debug("something: %s", x)</code>  The string formatting will be handled in the method and you won't get the performance hit if it won't be logged.  As always, Python anticipates your needs =)</span>
<span class="comment-copy">ted: that’s a worse-looking hack to do the same as <code>'{0}, {0}'.format('test')</code>.</span>
<span class="comment-copy">The point is: The one recurring argument that the new syntax allows reordering of items is a moot point: You can do the same with the old syntax. Most people do not know that this is actually already defined in the Ansi C99 Std! Check out a recent copy of <code>man sprintf</code> and learn about the <code>$</code> notation inside <code>%</code> placeholders</span>
<span class="comment-copy">@cfi: If you mean something like, <code>printf("%2$d", 1, 3)</code> to print out "3", that's specified in POSIX, not C99. The very man page you referenced notes, "The C99 standard does not include the style using '$'…".</span>
<span class="comment-copy">You can use old style formatting in <code>map</code> just as easily as format. <code>map('some_format_string_%s'.__mod__, some_iterable)</code></span>
<span class="comment-copy">@cfi: please prove you are right by rewriting the example above in C99</span>
<span class="comment-copy">@MarcH: <code>printf("%2$s %1$s\n", "One", "Two");</code> compiled with <code>gcc -std=c99 test.c -o test</code>, the output is <code>Two One</code>. But I stand corrected: <a href="http://stackoverflow.com/a/6322594/923794">It is actually a POSIX extension</a> and not C. I cannot find it again in the C/C++ standard, where I thought I'd seen it. The code works even with 'c90' std flag. <a href="http://linux.die.net/man/3/sprintf" rel="nofollow noreferrer"><code>sprintf</code> man page</a>. <a href="http://www.cplusplus.com/reference/cstdio/printf/#compatibility" rel="nofollow noreferrer">This</a> does not list it, but allows libs to implement a superset. My original argument is still valid, replacing <code>C</code> with <code>Posix</code></span>
<span class="comment-copy">My first comment here, does not apply to this answer. I regret the phrasing. In Python we cannot use the modulo operator <code>%</code> for reordering placeholders. I'd still like to not delete that first comment for the sake of comment consistency here. I apologize for having vented my anger here. It is directed against the often made statement that the old syntax per se would not allow this. Instead of creating a completely new syntax we could have introduced the std Posix extensions. We could have both.</span>
<span class="comment-copy">'modulo' refers to the operator that evaluates a remainder after a division. in this case the percent sign is not a modulo operator.</span>
<span class="comment-copy">This is some useful info that I just learned now. It's a pity it doesn't have it's own question as it seems separate to the main question. Pity the OP didn't split his question in two separate questions.</span>
<span class="comment-copy">You can use dict formatting like this:  <code>log.debug("some debug info: %(this)s and %(that)s",     dict(this='Tom', that='Jerry'))</code>  However, you can't use the new style <code>.format()</code> syntax here, not even in Python 3.3, which is a shame.</span>
<span class="comment-copy">@Cito: See this: <a href="http://plumberjack.blogspot.co.uk/2010/10/supporting-alternative-formatting.html" rel="nofollow noreferrer">plumberjack.blogspot.co.uk/2010/10/…</a></span>
<span class="comment-copy">The primary benefit of this is not performance (doing the string interpolation will be quick compared to whatever you're doing with the output from logging, e.g displaying in a terminal, saving to disk) It is that if you have a logging aggregator, it can tell you "you got 12 instances of this error message", even if they all had different 'some_info' values. If the string formatting is done before passing the string to log.debug, then this is impossible. The aggregator can only say "you had 12 different log messages"</span>
<span class="comment-copy">If you're concerned about performance, use literal dict {} syntax instead of a dict() class instantiation: <a href="http://doughellmann.com/2012/11/the-performance-impact-of-using-dict-instead-of-in-cpython-2-7-2.html" rel="nofollow noreferrer">doughellmann.com/2012/11/…</a></span>
<span class="comment-copy">Untrue: "Backwards compatibility can be maintained by leaving the existing mechanisms in place."; of course, <code>.format</code> won't <i>replace</i> <code>%</code> string formatting.</span>
<span class="comment-copy">No, BrainStorms postulation is true: "intended as a replacement for the existing '%'". Tobias quote means both systems will coexist for some time. RTFPEP</span>
<span class="comment-copy">There is simply no reason to change working code unless the additional features of the new <code>format</code> method are really needed ...</span>
<span class="comment-copy">absolutely agree with you, Tobias, but sometimes it's needed when upgrading to newer versions of Python</span>
<span class="comment-copy">For instance? AFAIK, it has <i>never</i> been needed; I don't consider it likely that the <code>%</code> string interpolation would ever go away.</span>
<span class="comment-copy">I consider .format() function safer than % for strings. Often I see beginners' mistakes like this <code>"p1=%s p2=%d" % "abc", 2</code> or <code>"p1=%s p2=%s" % (tuple_p1_p2,)</code>. You might think it's the coder's fault but I think it's just weird faulty syntax that looks nice for the quicky-scriptie but is bad for production code.</span>
<span class="comment-copy">But I don't like the syntax of .format(), I'd be happier with good old <code>%s</code>, <code>%02d</code> like <code>"p1=%s p2=%02d".format("abc", 2)</code>. I blame those who invented and approved the curly braces formatting that needs you to escape them like <code>{{}}</code> and looks ugly imho.</span>
<span class="comment-copy">This looks more unreadable than necessary compared to the equivalent <code>'x is {0}, y is {1}'.format(a.x, a.y)</code>. Should only be used when the <code>a.x</code> operation is very costly.</span>
<span class="comment-copy">@dtheodor With a tweak to use a keyword argument instead of positional argument... <code>'x is {a.x}, y is {a.y}'.format(a=a)</code>. More readable than both examples.</span>
<span class="comment-copy">@CivFan Or, if you have more than one object, <code>'x is {a.x}, y is {a.y}'.format(**vars())</code></span>
<span class="comment-copy">Also note this one in the same fashion: <code>'{foo[bar]}'.format(foo={'bar': 'baz'})</code>.</span>
<span class="comment-copy">This is incredibly useful for customer-facing applications, where your application supplies a standard set of formatting options with a user-supplied format string.  I use this all the time.  The configuration file, for instance, will have some "messagestring" property, which the user can supply with <code>Your order, number {order[number]} was processed at {now:%Y-%m-%d %H:%M:%S}, will be ready at about {order[eta]:%H:%M:%S}</code> or whatever they wish.  This is far cleaner than trying to offer the same functionality with the old formatter.  It makes user-supplied format strings way more powerful.</span>
<span class="comment-copy">That's probably because new-style formatting calls <code>str(d)</code> before expanding the parameter, whereas old-style formatting probably calls <code>float(d)</code> first.</span>
<span class="comment-copy">You'd think so, but <code>str(d)</code> returns <code>"3.12375239e-24"</code>, not <code>"0.00000000000000000000000312375239000000000000000000"</code></span>
<span class="comment-copy">Instead, <code>str.format</code> gives more functionalities (especially type-specialized formatting e.g. <code>'{0:%Y-%m-%d}'.format(datetime.datetime.utcnow())</code>). Performance cannot be the absolute requirement of all jobs. Use the right tool for the job.</span>
<span class="comment-copy"><i>"Premature optimization is the root of all evil"</i> or so Donald Knuth once said...</span>
<span class="comment-copy">Sticking with a well-known formatting scheme (as long as it suits the needs, which it does in the vast majority of cases), and which is twice as fast, is no "premature optimization" but simply reasonable. BTW, the <code>%</code> operator allows to reuse <code>printf</code> knowledge; dictionary interpolation is a very simple extension of the principle.</span>
<span class="comment-copy">I've actually experienced the opposite in one situation.  New-style formatting was faster.  Can you provide the test code you used?</span>
<span class="comment-copy">Seems like a seriously wasted post without any examples or reasoning, just claims.</span>
<span class="comment-copy">I wish I could upvote this more. It allows logging with <code>format</code> without the performance hit -- does it by overriding <code>__str__</code> precisely as <code>logging</code> was designed for -- shortens the function call to a single letter (<code>N</code>) which feels very similar to some of the standard ways to define strings -- AND allows for lazy function calling. Thank you! +1</span>
<span class="comment-copy">Is this any different in outcome to using the <code>logging.Formatter(style='{')</code> parameter?</span>
<span class="comment-copy">Or just use <code>'{type_names} [a-z]{{2}}'.format(type_names='triangle|square')</code>.  It's like saying <code>.format()</code> can help when using strings which already contain a percent character.  Sure.  You have to escape them then.</span>
<span class="comment-copy">@Alfe You are right, and that is why the answer starts with <code>"One situation where % may help is when you are formatting regex expressions."</code> Specifically, assume <code>a=r"[a-z]{2}"</code> is a regex chunk that you will be used in two different final expressions (e.g. <code>c1 = b + a</code> and <code>c2 = a</code>). Assume that <code>c1</code> needs to be <code>format</code>ed (e.g. <code>b</code> needs to be formatted runtime), but <code>c2</code> does not. Then you need <code>a=r"[a-z]{2}"</code> for <code>c2</code> and <code>a=r"[a-z]{{2}}"</code> for <code>c1.format(...)</code>.</span>
<span class="comment-copy">Thanks i didnt know this</span>
<span class="comment-copy">you could do this, but I agree it's awefull '{{ {0},  {1} }}'.format(1, 2)</span>
<span class="comment-copy">You should run each example several times, a single run may be misleading e.g. the operating system may be generally busy so execution of your code gets delayed. see the docs: <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer">docs.python.org/3/library/timeit.html</a>. (nice avatar, Guybrush!)</span>
