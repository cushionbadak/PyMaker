<div class="post-text" itemprop="text">
<p>Giving following code:</p>
<pre><code>class X(Mixin, Y):
    pass
</code></pre>
<p>How can I write a unittest to ensure <code>Mixin</code> class is before <code>Y</code> in superclass declaration of <code>X</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Don't test it</strong>. Unless you're writing tests for a Python implementation itself. </p>
<p>It's not the responsibility of your library's test suite to verify that the Python interpreter is working as designed. <code>Mixin</code> appears before <code>Y</code> in the declaration is self-evident when reading the code, and the fact that Python evaluates initializers left to right in a multiple inheritance is documented <a href="https://docs.python.org/3/tutorial/classes.html#multiple-inheritance" rel="nofollow noreferrer">here</a>. </p>
<p><em>Note:</em> I'm <em>not</em> saying this behaviour should not be tested, just that such tests needn't be duplicated by user code. It should be covered in the test suite of the implementation, e.g. <a href="https://github.com/python/cpython/blob/ac20e0f98d6727ba97a9575bfa2a11b2f6247c35/Lib/test/test_descr.py#L864" rel="nofollow noreferrer">here</a> for CPython.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can parse the output of <code>X.mro()</code>, which returns the <strong>m</strong>ethod <strong>r</strong>esolution <strong>o</strong>rder and make sure that <code>Mixin</code> comes before <code>Y</code>:</p>
<pre><code>class Mixin: pass

class Y: pass

class X(Mixin, Y): pass

print(X.mro())
# [&lt;class '__main__.X'&gt;, &lt;class '__main__.Mixin'&gt;, &lt;class '__main__.Y'&gt;, &lt;class 'object'&gt;]
</code></pre>
<p>However, I'm not sure that this is not an implementation detail and how much one can (or should) count on subclasses order. If your code depends on it, there may be something wrong in the design.</p>
</div>
<span class="comment-copy">It would be better to simply write a test that only passes if <code>X.foo</code> resolves to <code>Mixin.foo</code> (for some attribute <code>foo</code>). If you can't identify such a test, then why does it mater if <code>Mixin</code> precedes <code>Y</code>?</span>
<span class="comment-copy">Indeed, it is a simple way to have test completeness. It solves my problem since my Mixin only do a single function override. The only drawback is that if I add further function overrides in the Mixin, I will probably write a new test in all subclass.</span>
<span class="comment-copy">Interesting, You are right, testing CPython interpreter behavior it out of the scope of my unittests. But, the goal of my <code>Mixin</code> is to factorise a function override from about 10 class. I don't want to duplicate the tests for this function in the child class. My reasoning was that I only need to ensure my class are subclass of the <code>Mixin</code>, but this is not sufficient since the function override is skipped when <code>Mixin</code> is after <code>Y</code>. So, for test completeness, I need to test superclass order..</span>
<span class="comment-copy">Then just call the necessary method and assert the result is as expected. You want to test whatever functionality/method(s) the Mixin provides, mocking whatever you need to along the way. Asserting on the mro is too meta, since the users of the code are presumably not interested in such implementation detail.</span>
<span class="comment-copy">Using the result of mro() is a good idea, however, it outputs list that contains all superclass of superclass. I must add code to only ensure <code>Mixin</code> is before <code>Y</code> in the resulting list. I don't want to test for all the superclass tree.</span>
<span class="comment-copy">@moppag The question is if you should test it at all. If you count my and wim's opinion, the answer is no.</span>
