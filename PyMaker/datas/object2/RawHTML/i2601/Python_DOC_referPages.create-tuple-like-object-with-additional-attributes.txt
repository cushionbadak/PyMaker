<div class="post-text" itemprop="text">
<p>Is there a Pythonic way to create a tuple-like object (that acts like a tuple) but with additional attributes? In particular with a <code>__name__</code> attribute?</p>
<p>Right now I do something like this:</p>
<pre><code>foo = ( 1, 9, (12.5, "bar"), "baz" )
foo.__name__ = 'foo'
</code></pre>
<p>But that isn't very Pythonic, I think. I can't pass <code>foo</code> (the first line with the tuple assignment) to a function, and have the function create the <code>__name__</code>.</p>
<p>What's the Pythonic way?</p>
<p>I'm looking for something like:</p>
<pre><code>bar = new_kind_of_thing(( 1, 9, (12.5, "floob"), "baz" ))
print(bar[2])
print(bar[0])
print(bar.__name__)
</code></pre>
<p>That outputs:</p>
<pre><code>(12.5, 'floob')
1
'bar'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just create new class that inherits from tuple and override <code>__new__</code> and <code>__init__</code> methods:</p>
<pre><code>class MyTuple(tuple):
    def __new__(cls, name, values):
        return super().__new__(cls, values)

    def __init__(self, name, values):
        self.__name__ = name
        self.values = values

foo = MyTuple('foo', (1, 2, 3))

print(foo)
print(foo.__name__)
</code></pre>
<p>Output:</p>
<pre><code>(1, 2, 3)
'foo'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about something as simple as this: </p>
<pre class="lang-py prettyprint-override"><code>class TupleWithName(tuple):
    pass

t = TupleWithName((1, 2, 3))
t.name = 'tuple one'

print(t)
# (1, 2, 3)

print(t.name)
# 'tuple one'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use namedtuple (<a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer">https://docs.python.org/3/library/collections.html#collections.namedtuple</a>)</p>
<pre><code>from collections import namedtuple
Foo = namedtuple('Foo', ['x', 'y', 'pair', 'title'])
foo = Foo(1, 9, (12.5, "bar"), "baz") # foo.x == 1, foo.y == 9, etc
bar = Foo(2, 10, (11., "abc"), "zzz")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, you can do this with a "mapping" -- to create a custom class with attributes of others.<p>Resource: <a href="http://www.kr41.net/2016/03-23-dont_inherit_python_builtin_dict_type.html" rel="nofollow noreferrer">http://www.kr41.net/2016/03-23-dont_inherit_python_builtin_dict_type.html</a></p>
<p>IMO, I don't think that's really what you want.</p>
<p>You're likely better off with a more complex data structure, a dictionary of tuples for instance.</p>
<pre><code>my_tuples = {
     "tuple1":(1,2,3),
     "tuple2":(3,5,6),
}
</code></pre>
<p>or (comment construction)</p>
<pre><code>my_tuples = {}
my_tuples["tuple1"] = (1, 2, 3)
my_tuples["tuple2"] = (4, 5, 6)
</code></pre>
<p>This will allow you to interact with the tuples by 'name'</p>
<pre><code>print(my_tuples["tuple1"])
(1,2,3)
</code></pre>
</p></div>
<span class="comment-copy">Are you perhaps thinking of a <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer"><code>namedtuple</code></a>?</span>
<span class="comment-copy">@zvone I don't think so. I looked at that, and it creates tuples where each element position (index) within the tuple has a name. I need a <code>__name__</code> for the tuple object itself.</span>
<span class="comment-copy">OK, so you need something very different from a tuple, but you say you want it to be <i>"tuple-like"</i>. Can you define which characteristics of a tuple do you wish to have? And perhaps also explain why are you trying to change only the <code>__name__</code>, which is a special attribute? This may in the end turn out to be an XY problem</span>
<span class="comment-copy">@zvone I've tried to clarify with an example.</span>
<span class="comment-copy">Why do you want to do this?</span>
<span class="comment-copy">It still requires redundant 'foo' in the assignment statement (once on each side of the = sign), which doesn't seem very Pythonic. Also, if I assign <code>bar = foo</code>, afterward print(bar) should print <code>bar</code> (ideally, anyway). [But, it's the closest thing to a good answer so far.]</span>
<span class="comment-copy">@nerdfever.com There has to be that "redundant" foo, because it is not really redundant. One is the name of the object and the other is the name of the variable. You could also write <code>a = b = c = MyTuple('foo', (1, 2, 3))</code>. You cannot have <code>foo.__name__</code> print <code>foo</code> by reading it from the variable name. That is not how python variables work.</span>
<span class="comment-copy">@nerdfever.com I totally agree with <i>zvone</i>'s comment.</span>
<span class="comment-copy">@LevZakharov I accepted your answer because it was the best, but I still feel silly writing code like <code>sw = nerdlib.makeCLI(switches, name="sw")</code>. It seems redundant, but maybe there's no better way in Python.</span>
<span class="comment-copy">mapping the tuple methods is the more pythonic solution, creating a 'wrapper' class that creates a tuple instance is considered less 'pythonic' though it will usually suffice.</span>
<span class="comment-copy">That seems to be equivalent to what I'm already doing in the question. I'm looking for a solution that creates the object in one step.</span>
<span class="comment-copy">This is not what the OP asked.</span>
<span class="comment-copy">@LevZakharov I understand that my answer suggests using a bit different data structure, but the question mentions "Pythonic way". And I think using special purpose <code>__name__</code> is not so Pythonic. Check <code>Foo</code> from my example; it has <code>__name__</code> attribute while <code>foo</code> and <code>bar</code> don't have it as they are instances.</span>
<span class="comment-copy">Neither my_tuples nor tuple1 "act like a tuple".</span>
<span class="comment-copy">my_tuples["tuple1"] is a tuple</span>
<span class="comment-copy">you can use dictionary construction to add the 'named' tuples. my_tuples = {}  then my_tuples[name] = tuple for instance: my_tuples["tuple1"] = (1, 2, 3)  you can add as many tuples to my_tuples as you'd like.  then interact with them by calling their name in my_tuples. ex: my_tuples["tuple1"] returns (1, 2, 3) @nerdfever.com</span>
<span class="comment-copy">Yes,<code>my_tuples["tuple1"]</code> is a tuple, but <code>my_tuples["tuple1"].__name__</code> doesn't return a name, so it's still not a tuple-like object with a <code>__name__</code> attribute.</span>
<span class="comment-copy">"tuple1" is the "name" of the tuple in this construct</span>
