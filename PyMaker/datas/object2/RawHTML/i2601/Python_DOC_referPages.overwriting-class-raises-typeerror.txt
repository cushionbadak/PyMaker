<div class="post-text" itemprop="text">
<p>I'm trying to extend functionality of a module class written in C by deriving from that class and overwriting / adding certain methods*.</p>
<p>Problem is that his module creates instances of the class I'm trying to extend at various different places. I thus need to create a casting method to cast the base class provided by the module to my own derived class with the additonal functionality.</p>
<p>Here's what I've tried:</p>
<pre><code>class Derived(Base):
    @classmethod
    def cast(cls, obj: Base):
        obj.__class__ = cls
</code></pre>
<p>This method works with class hierarchies that I've created myself - however it fails with the module I use, throwing the following exception:</p>
<blockquote>
<p>TypeError: __class__ assignment only supported for heap types or ModuleType subclasses</p>
</blockquote>
<p>I'm having a hard time finding official information about this exception. Any info helps, I'd even accept hackish solutions so long as they're clean and fully mimic the behavior I'km looking for. </p>
<p>* The class I'm trying to extend is <code>Surface</code> inside the package <code>pygame</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>__class__</code> attribute has always been restricted in what is acceptable, and Python classes can be a lot more flexible than types defined in C are.</p>
<p>For example, the <a href="https://docs.python.org/3/reference/datamodel.html#notes-on-using-slots" rel="nofollow noreferrer"><code>__slots__</code> section in the datamodel documentation</a> states:</p>
<blockquote>
<p><code>__class__</code> assignment works only if both classes have the same <code>__slots__</code>.</p>
</blockquote>
<p>and the same document calls the <a href="https://docs.python.org/3/library/stdtypes.html#special-attributes" rel="nofollow noreferrer"><code>instance.__class__</code> attribute</a> <strong>read only</strong>:</p>
<blockquote>
<p>The implementation adds a few special read-only attributes to several object types, where they are relevant.</p>
</blockquote>
<p>So <code>__class__</code> was actually not meant to be writeable, but it has been for a long time and a is very useful property.</p>
<p>Now, in your case the assignment isn't permitted because the target instances are of a type that doesn't allocate the objects on a heap (an area of process memory that grows to accommodate an arbitrary number of objects, it's where <em>most</em> Python objects are allocated). Objects not allocated on the heap are managed differently (not subject to reference counting for example), and if you changed their type they'd suddenly need to be managed differently. That's currently not supported.</p>
<p>It was <a href="https://bugs.python.org/issue22986" rel="nofollow noreferrer">briefly supported</a> in Python 3.5 release candidate builds, to allow setting <code>__class__</code> on <em>modules</em>, but that backfired once it was discovered that it was possible to alter the type of interned immutable values:</p>
<pre><code>class MyInt(int):
    # lets make ints mutable!

(1).__class__ = MyInt
</code></pre>
<p><code>1</code> is an <a href="https://stackoverflow.com/questions/306313/is-operator-behaves-unexpectedly-with-integers">interned value</a>, so now <strong>all use of the integer <code>1</code> everywhere in the Python program</strong> has been changed. Not what you want, especially if you are re-using interpreter memory across multiple processes the way the Google App Engine does! See <a href="https://bugs.python.org/issue24912" rel="nofollow noreferrer">issue #24912</a> for the low-down.</p>
<p>But this is why module instances are specifically mentioned in the exception, see <a href="https://docs.python.org/3/reference/datamodel.html#customizing-module-attribute-access" rel="nofollow noreferrer"><em>Customising module attribute access</em></a>. </p>
<p>You'll have to find a different path to solving your problem. For example, perhaps your specific problem can be solved instead by <em>wrapping</em> the instances in something that uses <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattr__" rel="nofollow noreferrer"><code>__getattr__</code></a> to proxy attributes to the wrapped instance.</p>
</div>
<span class="comment-copy">I see. Is there a workaround? Can I transfer the object onto the heap? Re-initialize it, maybe? I mean I can derive from the non-heap object just fine and change it like that.</span>
<span class="comment-copy">@Nearoo: you can't work around it. You'll have to find a different approach, perhaps by wrapping the instances or coding up a type in C to bypass these restrictions.</span>
<span class="comment-copy">I see. A wrapper class it is, then. Thank you!</span>
<span class="comment-copy">Would you mind cleaning up your answer a bit? Shorting explaination and instead linking to official sources, and also suggest a workaround. Wrapper classes seem to work nicely. I found a neat one <a href="http://code.activestate.com/recipes/577555-object-wrapper-class/" rel="nofollow noreferrer">here</a></span>
<span class="comment-copy">@Nearoo: a wrapper class is not a general solution, it won't work for all situations where you have instances of one type that you want to force to be a different type instead.</span>
