<div class="post-text" itemprop="text">
<p>I have the following python code:</p>
<pre class="lang-py prettyprint-override"><code>import networkx as nx 

def cost(i, j, d, value1, value2):
    # some operation involving all these values
    return cost


# graph is a networkx graph
# src, dst are integers
# cost is a callable that is passed 3 values automatically i.e. src, dst and d 
# d is a dictionary of edge weights
path = nx.dijkstra_path(graph, src, dst, weight=cost)
</code></pre>
<p>Now I want to pass two values <code>value1</code> and <code>value2</code> to the <code>cost</code> function.</p>
<p>The <code>networkx</code> documentation says the <code>weight</code> can be a callable that accepts exactly 3 arguments. But i need <code>value1</code> and <code>value2</code> for calculations. How can this be done?</p>
<p><strong>Edit</strong>
The solution using functools works well. However, my function is in a class as follows:</p>
<pre><code>import networkx as nx 
import functools
class Myclass:
    def cost(self, i, j, d, value2):
        # some operation involving all these values
        # also need self


    # graph is a networkx graph
    # src, dst are integers
    # cost is a callable that is passed 3 values automatically i.e. src, dst and d 
    # d is a dictionary of edge weights
    # path = nx.dijkstra_path(graph, src, dst, cost)
    cost_partial = functools.partial(cost, self=self, value2=5)
    path = nx.dijkstra_path(graph, src, dst, cost_partial)
</code></pre>
<p>Using this approach, <code>nx.dijkstra_path</code> insists upon assigning <code>src</code> to <code>self</code>. Thus the interpreter complains that <code>self</code> is assigned multiple values.
I need self for calculating the cost.</p>
</div>
<div class="post-text" itemprop="text">
<p>You just need a function that wraps <code>cost</code>. A quick way is to use <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow noreferrer"><code>functools.partial</code></a>.</p>
<pre><code>import functools

def cost(i, j, d, value1, value2):
    'Example function'
    return i, j, d, value1, value2

# This makes a new function which takes all parameters of `cost` except those 
# you've already passed. Here I'm going to set value1 and value2 to 1 and 2 
# respectively.
cost_partial = functools.partial(cost, value1=1, value2=2)

# A new function that only accepts the 3 args i, j, d
cost_partial('i', 'j', 'd')  # --&gt; ('i', 'j', 'd', 1, 2)

# use as
path = nx.dijkstra_path(graph, src, dst, weight=cost_partial)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This depends largely on the meaning on the meaning of <code>value1</code> and <code>value2</code>. I would suggest adding a wrapper callable by networkx:</p>
<pre><code>def cost_wrapper(i, j, d):
    value1 = 0  # set values as needed
    value2 = 1
    return cost(i, j, d, value1, value2)
</code></pre>
<p>And provide it to networkx:</p>
<pre><code>path = nx.dijkstra_path(graph, src, dst, weight=cost_wrapper)
</code></pre>
<p>Or simply make them global variables, not arguments.</p>
</div>
<span class="comment-copy">where would those values come from? if they are known and won't change for all of the function calls why not make them global variables?</span>
<span class="comment-copy">@AntiMatterDynamite Because global variables are frowned upon since they tend to lead to a messy code, and are (very) rarely the correct solution</span>
<span class="comment-copy">@DeepSpace frowned upon by who? the python elder gods? it all depends on how big of a script you're making ...</span>
<span class="comment-copy">@AntiMatterDynamite I'm really not going to try and "convince" you why global variables are a bad idea.</span>
<span class="comment-copy">@DeepSpace i wasn't giving advice to use global variables i was asking if the values are changing as the function is called again and again, which could invalidate some answers given here...</span>
