<div class="post-text" itemprop="text">
<p>I need to implement a command line interface in which the program accepts subcommands.</p>
<p>For example, if the program is called “foo”, the CLI would look like</p>
<pre><code>foo cmd1 &lt;cmd1-options&gt;
foo cmd2
foo cmd3 &lt;cmd3-options&gt;
</code></pre>
<p><code>cmd1</code> and <code>cmd3</code> must be used with at least one of their options and the three <code>cmd*</code> arguments are always exclusive.</p>
<p>I am trying to use subparsers in argparse, but with no success for the moment. The problem is with <code>cmd2</code>, that has no arguments:</p>
<p>if I try to add the subparser entry with no arguments, the namespace returned by <code>parse_args</code> will not contain any information telling me that this option was selected (see the example below).
if I try to add <code>cmd2</code> as an argument to the <code>parser</code> (not the subparser), then argparse will expect that the <code>cmd2</code> argument will be followed by any of the subparsers arguments.</p>
<p>Is there a simple way to achieve this with <code>argparse</code>? The use case should be quite common…</p>
<p>Here follows what I have attempted so far that is closer to what I need:</p>
<pre><code>parser = argparse.ArgumentParser()
subparsers = parser.add_subparsers(help='Functions')
parser_1 = subparsers.add_parser('cmd1', help='...')
parser_1.add_argument('cmd1_option1', type=str, help='...')

parser_2 = subparsers.add_parser(cmd2, help='...')

parser_3 = subparsers.add_parser('cmd3', help='...')
parser_3.add_argument('cmd3_options', type=int, help='...')

args = parser.parse_args()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First of all subparsers are <em>never</em> inserted in the namespace. In the example you posted if you try to run the script as:</p>
<pre><code>$python3 test_args.py cmd1 1
Namespace(cmd1_option1='1')
</code></pre>
<p>where <code>test_args.py</code> contain the code you provided (with the <code>import argparse</code> at the beginning and <code>print(args)</code> at the end).</p>
<p>Note that there is no mention to <code>cmd1</code> only to its argument. <em>This is by design</em>.</p>
<p>As pointed out in the comments you can add that information passing the <code>dest</code> argument to the <a href="https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_subparsers" rel="nofollow"><code>add_subparsers</code></a> call.</p>
<p>The usual way to handle these circumstances is to use the <a href="https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.set_defaults" rel="nofollow"><code>set_defaults</code></a> method of the subparsers:</p>
<pre><code>import argparse
parser = argparse.ArgumentParser()
subparsers = parser.add_subparsers(help='Functions')
parser_1 = subparsers.add_parser('cmd1', help='...')
parser_1.add_argument('cmd1_option1', type=str, help='...')
parser_1.set_defaults(parser1=True)

parser_2 = subparsers.add_parser('cmd2', help='...')
parser_2.set_defaults(parser2=True)

parser_3 = subparsers.add_parser('cmd3', help='...')
parser_3.add_argument('cmd3_options', type=int, help='...')
parser_3.set_defaults(parser_3=True)

args = parser.parse_args()
print(args)
</code></pre>
<p>Which results in:</p>
<pre><code>$python3 test_args.py cmd1 1
Namespace(cmd1_option1='1', parser1=True)
$python3 test_args.py cmd2
Namespace(parser2=True)
</code></pre>
<p>In general different subparser will, most of the time, handle the arguments in completely different ways. The usual pattern is to have different functions to run the different commands and use <code>set_defaults</code> to set a <code>func</code> attribute. When you parse the arguments you simply call that callable:</p>
<pre><code>subparsers = parser.add_subparsers()
parser_1 = subparsers.add_parser(...)
parser_1.set_default(func=do_command_one)

parser_k = subparsers.add_parser(...)
parser_k.set_default(func=do_command_k)

args = parser.parse_args()
if args.func:
    args.func(args)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The subparser identity can be added to the main <code>Namespace</code> if the <code>add_subparsers</code> command is given a <code>dest</code>.</p>
<p>From the documentation:</p>
<blockquote>
<p>However, if it is necessary to check the name of the subparser that was invoked, the dest keyword argument to the add_subparsers() call will work:</p>
</blockquote>
<pre><code>&gt;&gt;&gt; parser = argparse.ArgumentParser()
&gt;&gt;&gt; subparsers = parser.add_subparsers(dest='subparser_name')
&gt;&gt;&gt; subparser1 = subparsers.add_parser('1')
&gt;&gt;&gt; subparser1.add_argument('-x')
&gt;&gt;&gt; subparser2 = subparsers.add_parser('2')
&gt;&gt;&gt; subparser2.add_argument('y')
&gt;&gt;&gt; parser.parse_args(['2', 'frobble'])
Namespace(subparser_name='2', y='frobble')
</code></pre>
<p>By default the <code>dest</code> is <code>argparse.SUPPRESS</code>, which keeps <code>subparsers</code> from adding the name to the <code>namespace</code>.</p>
</div>
<span class="comment-copy">I take issue with the  'never inserted'.  Simply give the 'add_subparsers' a <code>dest</code>.</span>
<span class="comment-copy">@hpaulj You are right. However I, personally, never used that. As I said it's much more command to have different handling functions for different subparsers so using <code>set_defaults</code> is a better solution. Only for the most simple situations you want to use the <code>dest</code> parameter.</span>
