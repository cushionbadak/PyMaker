<div class="post-text" itemprop="text">
<p><strong>Summary:</strong> <em>I created a new list variable by taking a slice of an original one. When I tweak the new list,  the previous one also changes, but I'm fairly certain they are two distinct lists! Here's my general method:</em></p>
<p>1.Create initial list <code>all_info</code> by calling a function. Each list item is itself a list with 5 elements.</p>
<pre><code>all_info = CrossReference(start_info, RBS_info, promoter_info)
</code></pre>
<p>2.Create a new list <code>all_info_mod</code> by slicing the initial list to remove the first item (I need to do this for later code). Then confirm thet are distinct.</p>
<pre><code>all_info_mod = all_info[1:]

all_info #Shows original list
all_info_mod #Shows sliced list
</code></pre>
<p>3.Increment the first 3 elements of each outer list by 1. Then check.</p>
<pre><code>for i in all_info_mod:
    for j in range(0, 3):
        i[j] += 1

all_info_mod #Successfully altered
all_info #Also altered?!
</code></pre>
<p>The initial list is also altered when it shouldn't be. I have tested with simpler examples and get the same result. Perhaps it's a result of my previous code that comes before this? (Can provide more details if needed).</p>
<p>Thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>When you do this:  </p>
<pre><code>all_info = [[1,2,3], [2,3,4], [5,6,7]]
all_info_mod = all_info[1:]
</code></pre>
<p>You perform slicing on <code>all_info</code> to create a new list <code>all_info_mod</code>.
The problem is that the elements of <code>all_info</code> are (references to) lists, so <code>all_info_mod</code> will contain the copy of the references to lists. The references are copied, so at the end both lists contain references to the same lists.<br/>
This explains why when you modifies the lists referenced by the elements of <code>all_info_mod</code>, you also modify the lists referenced by the elements of <code>all_info</code>.</p>
<p>Note that if you modify directly an element of <code>all_info_mod</code> by assignment, i.e. if you replace the reference to a list with another one, then <code>all_info</code> is not changed:  </p>
<pre><code>all_info_mod[1] = [9,9,9]
print(all_info)      # [[1, 2, 3], [2, 3, 4], [5, 6, 7]]
print(all_info_mod)  # [[2, 3, 4], [9, 9, 9]]
</code></pre>
<p>If you really want to duplicate the data in another list, you have to use the method <a href="https://docs.python.org/3/library/copy.html" rel="nofollow noreferrer">copy.deepcopy()</a>, as follows:  </p>
<pre><code>import copy
all_info = ...
all_info_mod = copy.deepcopy(all_info[1:])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should import <code>copy</code> module and make a <code>deepcopy</code> if you don't want changes in original list.</p>
<pre><code>import copy

all_info_mod = copy.deepcopy(all_info[1:])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is happening because you're modifying mutable objects that both lists contain references to.  Modifying the list you sliced won't change the slice, but modifying a mutable object in that list will also be visible from the other list, because both lists contain the same object.</p>
<pre><code>list_ = [[1, 2, 3], [4, 5, 6]]
slice_ = list_[:]
list_[0] = [7, 8, 9]
print(slice_)
# [[1, 2, 3], [4, 5, 6]]

list_[1].append(0)
print(slice_[1])
# [4, 5, 6, 0]

print(list_[1] is slice_[1])  # The two lists both contain the same list object
# True
</code></pre>
</div>
<span class="comment-copy">A more approachable explanation alongside a working solution. Really useful, thanks!</span>
<span class="comment-copy">This works - thanks very much!</span>
<span class="comment-copy">Also upvoted because of very useful explanation - this is great for the future.</span>
