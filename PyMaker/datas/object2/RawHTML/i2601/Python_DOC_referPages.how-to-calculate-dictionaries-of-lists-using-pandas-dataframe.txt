<div class="post-text" itemprop="text">
<p>I have two strings in Python3.x, which are defined to be the same length:</p>
<pre><code>string1 = 'WGWFTSJKPGP'
string2 = 'DORKSRQKYJG'
</code></pre>
<p>I am also given an integer which is meant to represent the "starting index" of <code>string2</code>. In this case, <code>start_pos = 51</code>. </p>
<p>The goal is to create a dictionary based on the indices. So, <code>string1</code> begins at <code>0</code>, <code>string2</code> begins at <code>51</code>. The dictionary "converting" these coordinates is as follows:</p>
<pre><code>{0: 51, 1: 52, 2: 53, 3: 54, 4: 55, 5: 56, 6: 57, 7: 58, 8: 59, 9: 60, 10: 61}
</code></pre>
<p>which can be constructed (give the variables above) with:</p>
<pre><code>convert_dict = {i: i + start_pos for i, _ in enumerate(string1)}
</code></pre>
<p>I currently have this data in the form of a pandas DataFrame:</p>
<pre><code>import pandas as pd

dict1 = {'column1':['MXRBMVQDHF', 'LJNVTJOY', 'LJNVTJOY', 'LJNVTJOY', 'WHLAOECVQR'], 'column2':['DPBVNJYANX', 'UWRAWDOB', 'PEKUYUQR', 'WPMLFVFZ', 'CUTQVWHRIJ'], 'start':[79, 31, 52, 84, 18]}

df = pd.DataFrame(dict1)
print(df)
#       column1     column2  start
# 0  MXRBMVQDHF  DPBVNJYANX     79
# 1    LJNVTJOY    UWRAWDOB     31
# 2    LJNVTJOY    PEKUYUQR     52
# 3    LJNVTJOY    WPMLFVFZ     84
# 4  WHLAOECVQR  CUTQVWHRIJ     18
</code></pre>
<p>There are multiple entries of the same string in column <code>column1</code>. In this case, the dictionary for the coordinates with <code>LJNVTJOY</code> should be:</p>
<pre><code>{0: [31, 52, 84], 1: [32, 53, 85], 2: [33, 54, 86], 3: [34, 55, 87], 
     4: [35, 56, 88], 5: [36, 57, 89], 6: [37, 58, 90], 7: [38, 59, 91]}
</code></pre>
<p>I would like to take this DataFrame and calculate similar dictionaries of the coordinates. Such a <code>.groupby('column1')</code> statement looks like one should somehow use <code>.apply()</code>? I'm not sure how to populate dictionary lists like this...</p>
<p>Here is the correct output (keeping the DataFrame structure). Here the DataFrame <code>df2</code> has the column <code>'new_column'</code> such that it looks like the following:</p>
<pre><code>df2.new_column
0    {0: 79, 1: 80, 2: 81, 3: 82, 4: 83, 5: 84, 6: ...
1    {0: [31, 52, 84], 1: [32, 53, 85], 2: [33, 54, 86], 3: [34, 55, 87], 4: [35, 56, 88], 5: [36, 57, 89], 6: [37, 58, 90], 7: [38, 59, 91]}
2    {0: 52, 1: 53, 2: 54, 3: 55, 4: 56, 5: 57, 6: ...
Name: new, dtype: object
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use - </p>
<pre><code>def dict_op(x):
    string1 = x['column1']
    string2 = x['column2']
    start_pos = x['start']
    x['val'] = {i: i + start_pos for i, _ in enumerate(string1)}
    return x

def zip_dict(x):
    b=pd.DataFrame(x)
    return {i:b.loc[:,i].tolist() for i in b.columns }

op = df.apply(dict_op, axis=1).groupby('column1')['val'].apply(list).apply(zip_dict)
print(op)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>column1
LJNVTJOY      {0: [31, 52, 84], 1: [32, 53, 85], 2: [33, 54,...
MXRBMVQDHF    {0: [79], 1: [80], 2: [81], 3: [82], 4: [83], ...
WHLAOECVQR    {0: [18], 1: [19], 2: [20], 3: [21], 4: [22], ...
Name: val, dtype: object
</code></pre>
<p><strong>Explanation</strong></p>
<p>The <code>dict_op</code> reuses your code to create the dict for every row and then the <code>.apply(list)</code> zips the dicts together to form a list of dicts.</p>
<p>The <code>zip_dict()</code> then creates the output <code>dict</code> out of the interim output.</p>
<p>The last piece that I haven't included is the part where if the length of the list is 1 then you can include the first element only, taking the output from <code>{0: [79], 1: [80], 2: [81], 3: [82], 4: [83], ...</code> to <code>{0: 79, 1: 80, 2: 81, 3: 82, 4: 83, ...</code> </p>
</div>
<div class="post-text" itemprop="text">
<p>First apply groupby function to aggregate the "start" column as a list</p>
<pre><code>df2 = df.groupby("column1")["start"].apply(list).reset_index()
</code></pre>
<p>Now, you can write a function to create the new dictionary column</p>
<pre><code>def create_dict(row):
    new_dict = {}
    for i, j in enumerate(row["column1"]):
        if len(row["start"]) == 1:
            new_dict[i] = row["start"][0]+i
        else:
            for k in row["start"]:
                if i in new_dict:
                    new_dict[i].append(k + i)
                else:
                    new_dict[i] = [k + i]
    return new_dict
</code></pre>
<p>Finally, apply this function to all the rows of df2 </p>
<pre><code>df2["new_column"] = df2.apply(create_dict, axis = 1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a slightly different approach using a <code>lambda</code> and two <code>zips</code>. </p>
<pre><code>df2 = df.groupby('column1')['start'].agg([('s', list)]).reset_index()
df2['l'] = df.column1.str.len()

df2.apply(lambda x: dict(zip(range(x['l'] + 1), zip(*[range(s, s + x['l'] + 1) for s in x['s']]))), axis = 1)
</code></pre>
<p>The truncated output of that can be seen here (note that it returns tuples rather than lists):</p>
<pre><code>0    {0: (31, 52, 84), 1: (32, 53, 85), 2: (33, 54,...
1    {0: (79,), 1: (80,), 2: (81,), 3: (82,), 4: (8...
2    {0: (18,), 1: (19,), 2: (20,), 3: (21,), 4: (2...
</code></pre>
<p>First, to cut down on the length of the <code>apply</code> step, create a DataFrame with the <code>column1</code> values and the associated starting positions. In addition, add a column with the length of <code>column1</code> (assuming that the equal length assertion holds). </p>
<p>After that, it's a matter of combining the range of <code>column1</code> letter indices (<code>0</code> through <code>len(column1)</code>, which serves as the keys, and the same range offset by the <code>start</code> value(s). </p>
<p>Things get a little dicey with the second <code>zip</code> because <code>[range(s, s + x['l'] + 1) for s in x['s']]</code> returns something that looks like this (for 'LJNVTJOY'):</p>
<pre><code>[[31, 32, 33, 34, 35, 36, 37, 38, 39],
 [52, 53, 54, 55, 56, 57, 58, 59, 60],
 [84, 85, 86, 87, 88, 89, 90, 91, 92]]
</code></pre>
<p>When we really want to group the elements aligned vertically, so we use the 'splat' or '<a href="https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists" rel="nofollow noreferrer">unpacking</a>' operator to feed these lists into <code>zip</code>. Once we've combined those lists, we have a list of keys and a list (of tuples) of values, which can be <code>zipped</code> into a <code>dict</code>.</p>
</div>
