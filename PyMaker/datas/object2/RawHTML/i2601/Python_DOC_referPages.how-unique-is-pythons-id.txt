<div class="post-text" itemprop="text">
<p><strong>tl;dr</strong>
Does Python reuse ids? How likely it is that two objects with non overlapping lifetime will get the same id?</p>
<p><strong>Background:</strong>
I've been working on a complex project, written purely in Python 3. I've been seeing some issues in testing and spent a lot of time searching for a root cause. After some analysis, my suspicion was that when the testing is being run as a whole (it's orchestrated and being run by a dedicated dispatcher) it's reusing some mocked methods instead of instatiating new objects with their original methods. To check if the interpreter is reusing I used <code>id()</code>.</p>
<p><strong>Problem:</strong>
<code>id()</code> usually works and shows the object identifier and lets me tell when my call is creating a new instance and not reusing. But what happens when ids if two objects are the same? <a href="https://docs.python.org/3/library/functions.html#id" rel="noreferrer">The documentation</a> says:</p>
<blockquote>
<p>Return the “identity” of an object. This is an integer which is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same <code>id()</code> value.</p>
</blockquote>
<p><strong>The questions:</strong></p>
<ol>
<li><p>When can the interpreter reuse <code>id()</code> values? Is it just when it randomly selects the same memory area? If it's just random, it seems extremely unlikely but it's still not guaranteed.</p></li>
<li><p>Is there any other method to check what object I am actually referencing? I encountered a situation where I had the object, it had a mocked method. The object was no longer used, garbage collector destroyed it. After that I create a new object of the same class, it got a new <code>id()</code> but the method got the same id as when it was mocked and it actually <em>was</em> just a mock.</p></li>
<li><p>Is there a way to force Python to destroy the given object instance? From the reading I did it appears that no and that it is up to a garbage collector when it sees no references to the object but I thought it's worth asking anyway.</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Yes, CPython re-uses <code>id()</code> values. <strong>Do not count on these being unique in a Python program</strong>.</p>
<p>This is <a href="https://docs.python.org/3/library/functions.html#id" rel="noreferrer">clearly documented</a>:</p>
<blockquote>
<p>Return the “identity” of an object. This is an integer which is guaranteed to be unique and constant <strong>for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same id() value.</strong></p>
</blockquote>
<p>Bold emphasis mine. The id is unique only as long as an object is <em>alive</em>. Objects that have no references left to them are removed from memory, allowing the <code>id()</code> value to be re-used for another object, hence the <em>non-overlapping lifetimes</em> wording.</p>
<p>Note that this applies to CPython only, the standard implementation provided by python.org. There are other Python implementations, such as IronPython, Jython and PyPy, that make their own choices about how to implement <code>id()</code>, because they each can make distinct choices on how to handle memory and object lifetimes.</p>
<p>To address your specific questions:</p>
<ol>
<li><p>In CPython, <code>id()</code> is the memory address. New objects will be slotted into the next available memory space, so if a specific memory address has enough space to hold the next new object, the memory address will be reused. You can see this in the interpreter when creating new objects that are the same size:</p>
<pre><code>&gt;&gt;&gt; id(1234)
4546982768
&gt;&gt;&gt; id(4321)
4546982768
</code></pre>
<p>The <code>1234</code> literal creates a new integer object, for which <code>id()</code> produces a numeric value. As there are no further references to the <code>int</code> value, it is removed from memory again. But executing the same expression again with a different integer literal, and chances are you'll see the same <code>id()</code> value (a garbage collection run breaking cyclic references could free up more memory, so you could <em>also</em> <strong>not</strong> see the same <code>id()</code> again.</p>
<p>So it's <em>not random</em>, but in CPython it is a function of the memory allocation algorithms.</p></li>
<li><p>If you need to check specific objects, <em>keep your own reference to it</em>. That can be a <a href="https://docs.python.org/3/library/weakref.html" rel="noreferrer"><code>weakref</code> <em>weak reference</em></a> if all you need to assure is that the object is still 'alive'.</p>
<p>For example, recording an object reference first, then later checking it:</p>
<pre><code>import weakref

# record
object_ref = weakref.ref(some_object)

# check if it's the same object still
some_other_reference is object_ref()   # only true if they are the same object
</code></pre>
<p>The weak reference won't keep the object alive, but if it <em>is</em> alive then the <code>object_ref()</code> will return it (it'll return <code>None</code> otherwise).</p>
<p>You could use such a mechanism to generate really unique identifiers, see below.</p></li>
<li><p>All you have to do to 'destroy' an object is to <em>remove all references to it</em>. Variables (local and global) are references. So are attributes on other objects, and entries in containers such as lists, tuples, dictionaries, sets, etc.</p>
<p>The moment all references to an object are gone, the reference count on the object drops to 0 and it is deleted, there and then.</p>
<p>Garbage collection only is needed to break <em>cyclic references</em>, objects that reference one another only, with no further references to the cycle. Because such a cycle will never reach a reference count of 0 without help, the garbage collector periodically checks for such cycles and breaks one of the references to help clear those objects from memory.</p>
<p>So you can cause any object to be deleted from memory (freed), by removing all references to it. How you achieve that depends on how the object is referenced. You can ask the interpreter to tell you what objects are referencing a given object with the <a href="https://docs.python.org/3/library/gc.html#gc.get_referrers" rel="noreferrer"><code>gc.get_referrers()</code> function</a>, but take into account that <em>doesn't give you variable names</em>. It gives you objects, such as the dictionary object that is the <code>__dict__</code> attribute of a module that references the object as a global, etc. For code fully under your control, at most use <code>gc.get_referrers()</code> as a tool to remind yourself what places the object is referenced from as you write the code to remove those.</p></li>
</ol>
<p>If you must have unique identifiers for the lifetime of the <em>Python application</em>, you'd have to implement your own facility. If your objects are <em>hashable</em> and support weak references, then you could just use a <a href="https://docs.python.org/3/library/weakref.html#weakref.WeakKeyDictionary" rel="noreferrer"><code>WeakKeyDictionary</code> instance</a> to associate arbitrary objects with <a href="https://docs.python.org/3/library/uuid.html" rel="noreferrer">UUIDs</a>:</p>
<pre><code>from weakref import WeakKeyDictionary
from collections import defaultdict
from uuid import uuid4

class UniqueIdMap(WeakKeyDictionary):
    def __init__(self, dict=None):
        super().__init__(self)
        # replace data with a defaultdict to generate uuids
        self.data = defaultdict(uuid4)
        if dict is not None:
            self.update(dict)

uniqueidmap = UniqueIdMap()

def uniqueid(obj):
    """Produce a unique integer id for the object.

    Object must me *hashable*. Id is a UUID and should be unique
    across Python invocations.

    """
    return uniqueidmap[obj].int
</code></pre>
<p>This still produces integers, but as they are UUIDs they are not quite <em>guaranteed</em> to be unique, but the likelihood you'll <em>ever</em> encounter the same ID during <em>your</em> lifetime are smaller than being hit by a meteorite. See <a href="https://stackoverflow.com/questions/1155008/how-unique-is-uuid">How unique is UUID?</a></p>
<p>This then gives you unique ids even for objects with non-overlapping lifetimes:</p>
<pre><code>&gt;&gt;&gt; class Foo:
...     pass
...
&gt;&gt;&gt; id(Foo())
4547149104
&gt;&gt;&gt; id(Foo())  # memory address reused
4547149104
&gt;&gt;&gt; uniqueid(Foo())
151797163173960170410969562162860139237
&gt;&gt;&gt; uniqueid(Foo())  # but you still get a unique UUID
188632072566395632221804340107821543671
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The id is unique among <em>currently existing objects</em>. If an object is removed by the garbage collector, a future object can have the same id (and <em>most probably will</em>). You have to use your own unique value (eg. some <code>uuid</code>) to be sure that you are refering to a specific object. You can't do the garbage collection manually either.</p>
</div>
<div class="post-text" itemprop="text">
<ol>
<li><p>It can reuse the <a href="https://docs.python.org/3/library/functions.html#id" rel="nofollow noreferrer"><code>id</code></a> value as soon as the object which had it is no longer in any scope. It is in fact likely to reuse it if you create a similar object immediately after destroying the first. </p></li>
<li><p>If you're holding a reference (as opposed to a <a href="https://docs.python.org/3/library/weakref.html" rel="nofollow noreferrer"><em>weak</em> reference</a>), the <code>id</code> is not reused because the object is still alive. If you're just holding the <code>id</code> value, you're probably doing something wrong. </p></li>
<li><p>No, but you could delete your reference and <a href="https://docs.python.org/3/library/gc.html#gc.collect" rel="nofollow noreferrer">request the garbage collector to run</a>. It's possible for the garbage collection to fail to collect that object even if there are no really live references. </p></li>
</ol>
</div>
<span class="comment-copy">"How likely it is that two objects with non overlapping lifetime will get the same id?"-- it's actually very likely I recall, although I don't remember if this is guaranteed or merely implementation details</span>
<span class="comment-copy">"How likely it is that two objects with non overlapping lifetime will get the same id?" Whatever the answer to this question is, I strongly suspect it will be directly related to the amount of RAM your computer has.</span>
<span class="comment-copy">The bottom line is: do <b>not</b> rely on <code>id</code> for uniqueness.</span>
<span class="comment-copy">@DeepSpace yea hence my question! What to relay on for uniqueness?</span>
<span class="comment-copy">@Artur It depends how that class decided to implement <code>__hash__</code>. You cando a search, it has been discussed here on SO many many times.</span>
<span class="comment-copy">"Garbage collection only is needed to break cyclic references" Upvoting for this interesting tidbit I learned on how GC works in Python.</span>
<span class="comment-copy">Thank for this insight. I think it is the most comprehensive answer from all of provided. I wasn't aware of several things you mentioned, such as assigning the same <code>id()</code> value to two ints of the same length. Also, great tips on GC methods. Cheers!</span>
<span class="comment-copy">Could you elaborate on how to create own identifier? Do you mean something like classmethod to keep track of instances?</span>
<span class="comment-copy">@Artur: no, i just mean put an attribute on the object, eg: <code>self.id = uuid.uuid4()</code> and use that as unique identifier, instead of the <code>id</code> function</span>
<span class="comment-copy">So your answers 1 and 2 are kind of what I am trying to determine: testing orchestration is so complex that it may keep a reference to my object somewhere. That is the reason for me to check its <code>id()</code>. Since two <code>id()</code>s are identical I have virtually no way of knowing if it's just a reused object or a new object with a reused <code>id()</code>.</span>
<span class="comment-copy">If you hold a weak reference instead of an id value, you can check if the weak reference is still alive and then if it is the same object. The weak reference doesn't force the original object to stay but dies (switches to returning <code>None</code>) if the referred object is collected.</span>
<span class="comment-copy">Cool! So do I get it right - I can watch a weak ref to a method and if it's switched to <code>None</code>, I can assume that this referred method got collected, right? In that case even if I got the same <code>id()</code>, it's a new object (method) as my weak reference is <code>None</code>.</span>
<span class="comment-copy">Yes. The downside is that you must have an object that <a href="https://docs.python.org/3/extending/newtypes.html#weakref-support" rel="nofollow noreferrer">supports weak references</a>.</span>
