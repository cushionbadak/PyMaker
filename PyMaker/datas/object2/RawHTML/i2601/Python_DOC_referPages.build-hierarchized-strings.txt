<div class="post-text" itemprop="text">
<p>Suppose I have the following method:</p>
<pre><code>def _build_hierarchy(*keys):
     # ...
</code></pre>
<p>If I call <code>_build_hierarchy('a', 'b', 'c', 'd')</code>, I expect to get the following sequence of <code>str</code>:</p>
<pre><code>[
    'a',
    'a:b',
    'a:c',
    'a:d',
    'a:b:c',
    'a:b:d',
    'a:b:c:d'
]
</code></pre>
<p>Notice that hierarchy is based on the order on which I provided the arguments.</p>
<p>To be honest, I have no idea how to approach this.</p>
<p>Ideally, I would like a really simple and pythonic solution if there is such thing.</p>
<p><strong>Note</strong>: Solution needs to be compatible <code>Python 2.7</code></p>
</div>
<div class="post-text" itemprop="text">
<p><em>As for now, it is not clear by which general rule <code>a:c:d</code> does not appear in your output. Until precisions are added, this answer assumes it was simply forgotten.</em></p>
<p>The desired output is close to being the powerset of your input. We only require that the first element be always present. Thus, we can adapt the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>powerset</code> function from itertools recipes</a>.</p>
<pre><code>from itertools import chain, combinations

def _build_hierarchy (head, *tail, sep=':'):
     for el in chain.from_iterable(combinations(tail, r) for r in range(len(tail)+1)):
         yield sep.join((head,) + el)


for s in _build_hierarchy('a', 'b', 'c', 'd'):
    print (s)
</code></pre>
<h2>Output</h2>
<pre><code>a
a:b
a:c
a:d
a:b:c
a:b:d
a:c:d
a:b:c:d
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think it's "the first length-1 keys of item should be continuous, the last key can be isolated." Codes as below:</p>
<pre><code>def _build_hierarchy(*keys):
    key_len = len(keys)
    result = []

    if key_len &lt; 1:
        return result

    result.append(keys[0])
    for i in range(2, key_len + 1):
        #the first i-1 should be continuous, the last can be separate.
        pre_i = i - 1
        count = key_len - pre_i

        pre_str = ':'.join(keys[0:pre_i])
        for j in range(0, count):
            result.append(pre_str + ':' + keys[j + pre_i])

    return result


print _build_hierarchy()
print _build_hierarchy('a', 'b', 'c', 'd')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a recursive function:</p>
<pre><code>def _build_hierarchy(*keys):
  def combinations(d, current = []):
    if len(current) == len(keys):
      yield current
    else:
      if current:
        yield current
      for i in d:
        if (not current and keys[0] == i) or i not in current:
          if len(current)+1 &lt; 3 or all(c ==d for c, d in zip(keys, current[:len(current)+1])):
            for c in combinations(d, current+[i]):
              yield c
  return sorted([i for i in combinations(keys) if i[0] == keys[0]], key=len)

print [':'.join(i) for i in _build_hierarchy('a', 'b', 'c', 'd')]
</code></pre>
<p>Output:</p>
<pre><code>['a', 'a:b', 'a:c', 'a:d', 'a:b:c', 'a:b:d', 'a:b:c:d']
</code></pre>
</div>
<span class="comment-copy">why downvotes? Question is well explained.</span>
<span class="comment-copy">is the number of <code>*keys</code> variable? Some more decatils on building rules would be nice, they can be deduced, but it's still guessing.</span>
<span class="comment-copy">Why no <code>'a:c:d'</code> ?</span>
<span class="comment-copy">Also, just to give you a hard time, this includes "a:c:d" which is <i>not</i> in OP's example output</span>
<span class="comment-copy">Thanks for the corrections. As for a,c,d I dont understand by which general rule it is excluded, Ill have to wait for OP to add precision</span>
