<div class="post-text" itemprop="text">
<p>I want to make a function that is flexible with regard to unpacking the number of input variables.</p>
<p>More specifically, for example I have the following:</p>
<pre><code>def flexi_func(vars):
    func_var_a, func_var_b, func_var_c, func_var_d = vars
    #do something

my_vars = [var_a, var_b, var_c, var_d]
flexi_func(my_vars)
</code></pre>
<p>This works fine if the number of input variables is 4. But say I want to have the same function operate on just three input variables, or two. Assume the 'do something' bit is already flexible. Then to unpack the variables I can write</p>
<pre><code>def flexi_func(vars):
    if len(vars) == 4:
        func_var_a, func_var_b, func_var_c, func_var_d = vars
    elif len(vars) == 3:
        func_var_a, func_var_b, func_var_c = vars
    elif len(vars) == 2:
        func_var_a, func_var_b = vars
    #do something
</code></pre>
<p>And this works fine too. It just seems a bit clunky to me, especially if I had N&gt;4 variables. Is there a cleaner, more Pythonic way to unpack a tuple in such a way that I can use the unpacked variables?</p>
<p>I know from <a href="https://stackoverflow.com/questions/431944/python-unpack-to-unknown-number-of-variables">this question</a> I can do something like this (in Python 3):</p>
<pre><code>foo, bar, *other = func()
</code></pre>
<p>but I would need to do more work to access the stuff in <code>other</code>, so it's no better than my <code>if...elif...</code> approach.</p>
</div>
<div class="post-text" itemprop="text">
<p>Firstly, in response to the comments asking for context or a concrete example where this might be necessary, I concede that in almost all the cases I can think of it should be possible to avoid unpacking altogether. This goes for my original problem too - the <code>do something</code> part of the function can be modified to access the items through list indices.</p>
<p>However, in principle, I am sure there exist situations where unpacking is needed, even if only for clarity. Below is the best way I can find to assign a variable to each input item. More background detail is given in the answers <a href="https://stackoverflow.com/questions/4010840/generating-variable-names-on-fly-in-python">here</a> and <a href="https://stackoverflow.com/questions/8028708/dynamically-set-local-variable">here</a>.</p>
<pre><code>def flexi_func(var_list):    
    for i, var in enumerate(var_list):
        vars()['my_func_{}'.format(i)] = var

    #do something 

    return
</code></pre>
<p>This assigns each input variable to the <code>vars()</code> built-in dictionary. This is preferable to the <code>globals()</code> built-in dictionary and is writable unlike the <code>locals()</code> built-in dictionary. To access the variables in the <code>do something</code> section, you have to reference the dictionary like so: <code>print(vars()['my_func_2'])</code>.</p>
<p>Finally, if you want to use letters as variable labels instead of numbers (as I did in my problem statement) you can add <code>alphabet = [chr(i) for i in range(ord('a'),ord('z')+1)]</code> to the top of the function and call the variables <code>'my_func_{}'.format(alphabet[i])</code>.</p>
</div>
<span class="comment-copy">You'd have to do more work to determine whether <code>func_var_c</code> and <code>func_var_d</code> are even usable, so I'm not sure what you're expecting to accomplish by "simplifying" things here. I suppose you could come up with a global default like <code>None</code>, then do <code>func_var_a, func_var_b, func_var_c, func_var_d = [*vars, None, None][:4]</code> and know every local name has an assigned value, but you're still stuck with <code>is None</code> tests later.</span>
<span class="comment-copy">A list serves the exact purpose of <i>containing an arbitrary amount of things</i>, you should not be using something else, or maybe a dictionary. If you want to access items in the list, just use indexing, May we ask what is the bigger picture? What are you trying to accomplish?</span>
<span class="comment-copy">What do you actually want to <i>do</i> with these variables? Are you just looking for some kind of default values you can use? If so, you can always write, e.g., <code>a, b, c, d, *_ = vars + [None]*4</code> (in other words, pad out <code>vars</code> to be at least 4 values long by filling with <code>None</code>, then unpack the first 4 values and ignore anything left over).</span>
<span class="comment-copy">But really, if <code>d</code> either does or doesn't exist based on what was passed in, most likely your logic is going to have to switch on the same thing anyway, maybe even multiple times,, using <code>d</code> when <code>len(vars) == 4</code> but not using it otherwise. If you can turn this from an abstract toy example into one that does at least something trivial with the variables, we can probably show you a better way to do it.</span>
<span class="comment-copy">The <code>vars()</code> dictionary <a href="https://docs.python.org/3/library/functions.html#vars" rel="nofollow noreferrer"><i>is</i> the <code>locals()</code> dictionary</a>: "Without an argument, <code>vars()</code> acts like <code>locals()</code>.". If you just need a dictionary, stop messing around and make a dictionary. Call it <code>vars</code> if you feel like being perverse; <code>vars = {}</code>, then <code>vars['my_func_{}'.format(i)] = var</code> works fine, and doesn't get involved with weird and horrible attempts to mutate <code>locals()</code> that don't actually create new local variables, but just make you feel like you did.</span>
