<div class="post-text" itemprop="text">
<p>I want to be able to recycle a method from a parent class that uses a second method in that parent class. However the second method is overridden in the child class. I want the recycled parent method to use the new overridden second method when it is called from the child class. An example of how I want it to work will hopefully make this clearer:</p>
<pre><code>class Parent:
    def method1(self, num):
        return num**2
    def method2(self, list_size):
        return [self.method1(i) for i in range(list_size)] #List of squares

class Child(Parent):
    def method1(self, num): #Overrides corresponding parent method
        return num**3
    def method2(self, list_size):
        return super().method2(list_size) #Returns a list of cubes using child's method 1.
</code></pre>
<p>Is this possible in python3? Or will calling the parent's method 2 also use the parent's method 1? I'm hoping to reuse large parts of a parent class as the child class differs in only a few ways. The methods nesting like that in the parent class make it a lot more general.</p>
<p>Thanks!</p>
<p>EDIT: I forgot to test it with simple code! It does work like I wanted if anyone was wondering!</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, this works the way you want it to.</p>
<p>You can easily test this yourself. Unless you pass in nothing but 0s and 1s, it should be pretty obvious whether they're getting squared or cubed.</p>
<p>And, in cases where it's less obvious, just add a debugger breakpoint to <code>Child.method1</code> and <code>Parent.method1</code> and see which one gets hit. Or add <code>print(f'Child1.method({self}, {num})')</code> to the method and see if it gets printed out.</p>
<hr/>
<p>If you're coming from another language with C++ OO semantics instead of Smalltalk OO semantics, it may help to think of it this way: Every method is always virtual.</p>
<ul>
<li>Are <code>__init__</code> calls virtual? Yes.</li>
<li>What if you call a method during <code>__init__</code>? Yes.</li>
<li>What if you call a method inside a <code>super</code> call? Yes.</li>
<li>What about a <code>@classmethod</code>? Yes.</li>
<li>What ifâ€¦? Yes.</li>
</ul>
<p>The only exceptions are when you go out of your way to explicitly tell Python <em>not</em> to make a virtual function call:</p>
<ul>
<li>Calls on <code>super()</code> use the implementation from the next class in the MRO chain, because that's the whole point of <code>super</code>.</li>
<li>If you grab a parent's bound method and call that, like <code>Parent.method1(self, num)</code>, you obviously get <code>Parent.method1</code>, because that's the whole point of bound methods.</li>
<li>If you go digging into the class dicts and run the descriptor protocol manually, you obviously get whatever you do manually.</li>
</ul>
<hr/>
<p>If you're not trying to understand Python in terms of Java, and just want a deeper understanding of Python on its own terms, what you need to understand is what happens when you call <code>self.method1(i)</code>.</p>
<p>First, <code>self.method1</code> doesn't know or care that you're going to call it. It's an attribute lookup, just like, say, <code>self.name</code> would be.</p>
<p>The way Python resolves this is described in the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">Descriptor HOWTO</a>, but an oversimplified version looks like this:</p>
<ul>
<li>Does <code>self.__dict__</code> have anything named <code>method1</code>? No.</li>
<li>Does <code>type(self).__dict__</code> have anything named <code>method1</code>? Yes.

<ul>
<li>Return <code>type(self).__dict__['method1'].__get__(self)</code>.</li>
</ul></li>
</ul>
<p>If that second lookup failed, Python would loop over <code>type(self).mro()</code> and do the same test for each one. But here, that doesn't come up. <code>type(self)</code> is always going to be <code>Child</code> for an instance of <code>Child</code>, and <code>Child.__dict__['method1']</code> exists, so it binds <code>Child.method</code> to <code>self</code>, and the result is what <code>self.method1</code> means.</p>
</div>
<div class="post-text" itemprop="text">
<p>Short answer: yes.
Just tried a slightly modified version of your code with prints.</p>
<pre><code>class Parent:
    def method1(self):
        print("Parent method1")

    def method2(self):
        print("Parent method2")
        self.method1()


class Child(Parent):
    def method1(self):
        print("Child method1")

    def method2(self):
        print("Child method2")
        super().method2()


c = Child()
c.method2()
</code></pre>
<p>This is the output:</p>
<pre><code>Child method2

Parent method2

Child method1
</code></pre>
<p>As you can see, the method1 used is the child one.</p>
</div>
<span class="comment-copy">... have you tried it and checked?</span>
<span class="comment-copy">Lol no, I just thought up that quick example whilst typing out this question. Just tried it. It does work like I want it to. DOH! Thanks for taking the time to point that out!</span>
<span class="comment-copy">I was about to post a comment saying: Sure, <code>child().method2([1])</code> returns <code>[1]</code>, right? And then I realized that a list made up of only 1s and 0s is probably not a good way to test whether you're squaring or cubing the numbers. :)</span>
<span class="comment-copy">Thanks for taking the time to answer, I now understand a lot more! Running my example code (which I somehow didn't think to do) shows me that what you're saying is correct too! Accepted!</span>
<span class="comment-copy">Thank you , very clear example.</span>
