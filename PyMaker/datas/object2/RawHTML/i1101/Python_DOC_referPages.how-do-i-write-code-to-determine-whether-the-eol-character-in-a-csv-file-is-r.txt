<div class="post-text" itemprop="text">
<p>I'm using Python in Jupyter Notebooks to work with a CSV file. I'm writing the same code in two different versions of Jupyter Notebook--one that's running directly on my computer and another that's running off a kind of emulator within an online lesson from Dataquest. When I open the CSV file and read it into a string on my computer's Jupyter Notebook, the EOL character is <code>\r</code> but when I do the same on Dataquest's emulator, the EOL character is <code>\n</code>. I have two questions:</p>
<ol>
<li><p>Why does this happen?</p></li>
<li><p>How can I write a Python code that tests for the EOL character without opening the file to find out visually?</p></li>
</ol>
<p>This code in in a Jupyter notebook on my own Mac.</p>
<pre><code>f = open('US_births_1994-2003_CDC_NCHS.csv', 'r')
data_MyComp = f.read()
data_MyComp
</code></pre>
<p>This code is on Dataquest's Jupyter notebook browser emulator.</p>
<pre><code>f = open('US_births_1994-2003_CDC_NCHS.csv', 'r')
data_dataquest = f.read()
data_dataquest
</code></pre>
<p>This is a few lines of output from my computer when I run <code>data_MyComp</code> (note the EOL character is <code>\r</code>).</p>
<pre><code>'year,month,date_of_month,day_of_week,births\r1994,1,1,6,8096\r1994,1,2,7,7772\r1994,1,3,1,10142\r1994,1,4,2,11248\r1994,1,5,3,11053\r1994,1,6,4,11406\r1994,1,7,5,11251\r1994,1,8,6,8653\r1994,1,9,7,7910\r1994,1,10,1,10498\r1994,1,11,2,11706\r
</code></pre>
<p>This is a few lines of output from the Dataquest emulator when I run <code>data_dataquest</code> (note the EOL character is <code>\n</code>).</p>
<pre><code>'year,month,date_of_month,day_of_week,births\n1994,1,1,6,8096\n1994,1,2,7,7772\n1994,1,3,1,10142\n1994,1,4,2,11248\n1994,1,5,3,11053\n1994,1,6,4,11406\n
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Without any indication of how you downloaded or otherwise made the file available to Python and Jupyter, we can't really tell why this is happening.  Line endings are platform-specific but Python 3 should generally neutralize differences between platforms unless you specifically request opening a file as "binary".</p>
<p>You can discover the line-ending conventions by simply opening the file and reading enough of it.  What's "enough" depends on the file type.  Perhaps something like this in your case:</p>
<pre><code>with open('US_births_1994-2003_CDC_NCHS.csv', 'rb') as peek:
    buf = peek.read(1024)
    if b'\r\n' in peek:
        print("DOS CR/LF line terminator")
    elif b'\r' in peek:
        print("Plain CR seen (legacy Mac or CP/M file)?")
    elif b'\n' in peek:
        print("Plain LF seen (standard Unix text file)")
</code></pre>
<p>This doesn't attempt to do any statistical analysis, but might work well enough for your limited case.  The file will be closed again after the end of the <code>with</code> block so you can then just open it a second time with the parameters you actually need.</p>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow noreferrer">docs.python.org/3/library/functions.html#open</a>  the <code>newline</code> flag handles that for you, or am I missing something?</span>
<span class="comment-copy">I suppose "opening the file" really means "manual inspection" here. In order to process the contents of a file you <i>have</i> to <code>open()</code> it.</span>
<span class="comment-copy">Is your own computer by any chance running Windows? How exactly are you making the file available to Jupyter?</span>
<span class="comment-copy">If you just want to read the CSV file, use the <a href="https://docs.python.org/3/library/csv.html" rel="nofollow noreferrer"><code>csv</code></a> module from the standard library. It should properly handle the line endings on its own.</span>
<span class="comment-copy">@tripleee  Yes, I mean "manual inspection". Thanks for clarifying.</span>
