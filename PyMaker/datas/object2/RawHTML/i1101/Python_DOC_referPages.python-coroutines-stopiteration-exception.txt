<div class="post-text" itemprop="text">
<p>I am trying to feed a dictionary by using <code>.send()</code>. And my code snippet is below</p>
<pre><code>def coroutine(func):
    def start(*args, **kwargs):
        cr = func(*args, **kwargs)
        next(cr)
        return cr
    return start

@coroutine
def putd(di):

    print("via coroutines adding a key : value to dictionary")

    try:
        item = yield
        for key, value in item.items():
            if key in di:
                print("Key : {0} already exists".format(key))
            else:
                di[key] = value
        print(di)
    except StopIteration :
        print("yield frame got closed")


di = {}
gobj = putd(di)
gobj.send({"plan" : "shuttle"})
gobj.close()
</code></pre>
<p>And I believe I am handling the <code>exception</code> properly but still I am getting <code>StopIteration</code> exception.</p>
<pre><code>scratch.py
Traceback (most recent call last):
via coroutines adding a key : value to dictionary
{'plan': 'shuttle'}
File "scratch.py", line 39, in &lt;module&gt;
    gobj.send({"plan" : "shuttle"})
StopIteration

Process finished with exit code 1
</code></pre>
<p>Am I not handling that exception properly or am I missing something ? ANy help greatly appreciated. </p>
</div>
<div class="post-text" itemprop="text">
<p>Your coroutine exits after first send/yield. That generates a <code>StopIteration</code> and you cannot handle it in the coroutine itself, but only when invoking <code>send</code>. From the docs:</p>
<blockquote>
<p>The send() method returns the next value yielded by the generator, or
  raises StopIteration if the generator exits without yielding another
  value.</p>
</blockquote>
<pre><code>@coroutine
def putd(di):

    print("via coroutines adding a key : value to dictionary")

    try:
        item = yield
        for key, value in item.items():
            if key in di:
                print("Key : {0} already exists".format(key))
            else:
                di[key] = value
        print(di)
    except StopIteration :
        print("yield frame got closed")
    # here is an implicit  return None  which terminates the coroutine
</code></pre>
<p>I guess you want to keep the coroutine alive accepting as many sends as you want until an explicit <a href="https://docs.python.org/3/reference/expressions.html#generator.close" rel="nofollow noreferrer">close</a>:</p>
<pre><code>@coroutine
def putd(di):

    print("via coroutines adding a key : value to dictionary")

    try:
        while True:
            item = yield
            for key, value in item.items():
                if key in di: 
                    print("Key : {0} already exists".format(key))
                else:
                    di[key] = value
            print(di)
    except GeneratorExit:
        print("yield frame got closed")
</code></pre>
<p>Please note that now the <code>GeneratorExit</code> exception is caught.</p>
</div>
<span class="comment-copy">Excellent!!, Thank you.</span>
