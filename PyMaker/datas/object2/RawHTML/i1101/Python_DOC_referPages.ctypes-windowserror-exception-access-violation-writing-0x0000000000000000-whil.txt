<div class="post-text" itemprop="text">
<p>I have a program that load .so file from linux which works fine with no problem. 
Now, I'm trying to make the program cross-platform. After struggling for a while, I have managed to compile a dll file to support Windows but when I tried to load from ctypes, I get this error:</p>
<blockquote>
<p>"WindowsError: exception: access violation writing 0x0000000000000000" </p>
</blockquote>
<p>It seems it can't even properly pass the arguments to my c-function. I'm thinking I might have made some mistake while converting my c-code for Windows dll or the my python code probably need some more work for properly loading dll and utilize it in Windows. I'm familiar with python but am an novice to both ctypes and <strong>C</strong>. I tried to search what I'm missing but couldn't figure out what to do. :(</p>
<p>I've tried few more things and found where the error occurs but still don't know how to solve. So my problem occurs when the dll function tries to call another dll function inside. I've updated my code to include that part. </p>
<p>I've checked that another dll("mylib.dll") call inside my c-code works fine by calling the initfunc inside a main function(In another c-code with the same calling convention.) So my "mylib.dll" doesn't have a problem. I'm guessing I might have to do something more if I want to call a dll function from inside a dll function?</p>
<p>Below is my c-code for linux and Windows and How I call them in python. </p>
<p>I have edited my code so it would be Minimal, Complete, and Verifiable example, as Antti suggested. I'm quite new to Stack Overflow and didn't understand what it means to make "Minimal, Complete, and Verifiable example" at first. Thanks for the advice and sorry for my ignorance. Now I can reproduce the same problem with my code below. </p>
<pre><code>//header param_header.h
typedef struct MYSTRUCT MYSTRUCT;

struct MYSTRUCT
{
 double param1;
 double param2;
};

//mylib.c this was compiled as an .so(gcc mylib.c -fPIC -shared -o mylib.so) and .dll

#include "param_header.h"
#include &lt;stdio.h&gt;
#ifdef __linux__
int update_param(char *pstruct, char *paramname, double param)
#else
__declspec(dllexport) int update_param(char *pstruct, char *paramname, double param)
#endif
{
 printf("Print this if function runs");
 return 0;
}


//my_c_code.c  --&gt; this compiled again an .so &amp; .dll and called by python ctypes

#include "param_header.h"
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#ifdef __linux__
#include &lt;dlfcn.h&gt;
#else
#include &lt;windows.h&gt;
#endif

#ifdef __linux__
MYSTRUCT *initfunc(flag, number, params, paramnames)
#else
__declspec(dllexport) MYSTRUCT *initfunc(flag, number, params, paramnames)
#endif
int flag;
int number;
double params[100];
char *paramnames[100];
{
 int index;
 int check;
 MYSTRUCT *pstruct=(MYSTRUCT *)malloc(sizeof(MYSTRUCT));
 memset(pstruct,0,sizeof(MYSTRUCT));
 #ifdef __linux__
 void *pHandle;
 pHandle=dlopen("./mylib.so",RTLD_LAZY);
 int(*update_param)(char*, char*, double) = dlsym(pHandle, "update_param");
 #else
 HINSTANCE pHandle;
 pHandle=LoadLibrary("./mylib.dll");
 int(__cdecl *update_param)(char*,char*, double);
 FARPROC updateparam = GetProcAddress(pHandle, "update_param");
 if (!updateparam)
 {
  check = GetLastError();
  printf("%d\n", check);
 }
 update_param = (int(__cdecl *)(char*, char*, double))updateparam;
 #endif
 for (index=0;index &lt; number;index++) {
  (*update_param)((char*)pstruct, paramnames[index],params[index]); // &lt;--this line fails only for the windows. 
 }
 return pstruct;
}                  
</code></pre>
<p>And below is my python code to access the function.</p>
<pre><code>//mystruct.py
from ctypes import *
class MYSTRUCT(Structure):
  _fields_ = [("param1",c_double),
             ("param2",c_double)]
//mypython code
from ctypes import *
from mystruct import *
mydll=cdll.LoadLibrary("./my_c_code.so")#"./my_c_code.dll" for windows.
libhandle=mydll._handle
c_initfunc=mydll.initfunc
c_initfunc.restype=POINTER(MYSTRUCT)
c_initfunc.argtypes=[c_int,c_int,c_double*100,c_char_p*100]
import numpy as np
param_dict={"a":1,"b":2}
params=(c_double * 100)(*np.float_(param_dict.values()))
paramnames=(c_char_p * 100)(*param_dict.keys())    
flag=c_int(1)
number=c_int(len(param_dict.values()))
out=c_initfunc(flag, number, params, paramnames) &lt;-- Error here.
</code></pre>
<p>I'm not sure if this is an enough information to debug... but with the combination of above python code and Linux c-code compiled ".so" file. I don't have any problem.. but I get the error for the dll case. Any idea will be appreciated. </p>
</div>
<div class="post-text" itemprop="text">
<p>After fixing 2 errors in your (<em>Python</em>) code, I was able to successfully run it. Instead of guessing what your error might be (I still think it's a matter of <em>.dll</em> not being found, maybe due to wrong naming), I went the other way around and refactored your code. <br/>One thing that I want to point out is <em>ctypes</em> page: <a href="https://docs.python.org/3/library/ctypes.html#module-ctypes" rel="nofollow noreferrer">[Python 3]: ctypes - A foreign function library for Python</a>.</p>
<p><em>header.h</em>:</p>
<pre class="lang-c prettyprint-override"><code>#if defined(_WIN32)
#define GENERIC_API __declspec(dllexport)
#else
#define GENERIC_API
#endif

#define PRINT_MSG_0() printf("From C - [%s] (%d) - [%s]\n", __FILE__, __LINE__, __FUNCTION__)


typedef struct STRUCT_ {
    double param1;
    double param2;
} STRUCT;
</code></pre>
<p><em>dll0.c</em>:</p>
<pre class="lang-c prettyprint-override"><code>#include "header.h"
#include &lt;stdio.h&gt;

#define DLL0_API GENERIC_API


DLL0_API int updateParam(char *pstruct, char *paramname, double param) {
    PRINT_MSG_0();
    return 0;
}
</code></pre>
<p><em>dll1.c</em>:</p>
<pre class="lang-c prettyprint-override"><code>#include "header.h"
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#if defined(_WIN32)
#include &lt;windows.h&gt;
#else
#include &lt;dlfcn.h&gt;
#endif

#define DLL1_API GENERIC_API
#define UPDATE_PARAM_FUNC_NAME "updateParam"


typedef int(__cdecl *UpdateParamFuncPtr)(char*, char*, double);


DLL1_API STRUCT *initFunc(flag, number, params, paramnames)
    int flag;
    int number;
    double params[100];
    char *paramnames[100];
{
    int index = 0;
    UpdateParamFuncPtr updateParam = NULL;
    STRUCT *pStruct = (STRUCT*)malloc(sizeof(STRUCT));
    memset(pStruct, 0, sizeof(STRUCT));

#if defined(_WIN32)
    HMODULE pHandle = LoadLibrary("./dll0.dll");
    if (!pHandle) {
        printf("LoadLibrary failed: %d\n", GetLastError());
        return NULL;
    }
    updateParam = (UpdateParamFuncPtr)GetProcAddress(pHandle, UPDATE_PARAM_FUNC_NAME);
    if (!updateParam) {
        printf("GetProcAddress failed: %d\n", GetLastError());
        FreeLibrary(pHandle);
        return NULL;
    }
#else
    void *pHandle = dlopen("./dll0.so", RTLD_LAZY);
    if (!pHandle) {
        printf("dlopen failed: %s\n", dlerror());
        return NULL;
    }
    updateParam = dlsym(pHandle, UPDATE_PARAM_FUNC_NAME);
    if (!updateParam) {
        printf("dlsym failed: %s\n", dlerror());
        dlclose(pHandle);
        return NULL;
    }
#endif
    PRINT_MSG_0();
    for (index = 0; index &lt; number; index++) {
        (*updateParam)((char*)pStruct, paramnames[index], params[index]);
    }
#if defined(_WIN32)
    FreeLibrary(pHandle);
#else
    dlclose(pHandle);
#endif
    return pStruct;
}


DLL1_API void freeStruct(STRUCT *pStruct) {
    free(pStruct);
}
</code></pre>
<p><em>code.py</em>:</p>
<pre class="lang-py prettyprint-override"><code>#!/usr/bin/env python3

import sys
import traceback
from ctypes import c_int, c_double, c_char_p, \
    Structure, CDLL, POINTER


class Struct(Structure):
    _fields_ = [
        ("param1", c_double),
        ("param2", c_double),
    ]


StructPtr = POINTER(Struct)

DoubleArray100 = c_double * 100
CharPArray100 = c_char_p * 100


def main():
    dll1_dll = CDLL("./dll1.dll")
    init_func_func = dll1_dll.initFunc
    init_func_func.argtypes = [c_int, c_int, DoubleArray100, CharPArray100]
    init_func_func.restype = StructPtr
    free_struct_func = dll1_dll.freeStruct
    free_struct_func.argtypes = [StructPtr]
    param_dict = {
        b"a": 1,
        b"b": 2,
    }
    params = DoubleArray100(*param_dict.values())
    paramnames = CharPArray100(*param_dict.keys())
    flag = 1
    number = len(param_dict)
    out = init_func_func(flag, number, params, paramnames)
    print(out)
    try:
        struct_obj = out.contents
        for field_name, _ in struct_obj._fields_:
            print("    {:s}: {:}".format(field_name, getattr(struct_obj, field_name)))
    except:
        traceback.print_exc()
    finally:
        free_struct_func(out)
    print("Done.")


if __name__ == "__main__":
    print("Python {:s} on {:s}\n".format(sys.version, sys.platform))
    main()
</code></pre>
<p><strong>Notes</strong>:</p>
<ul>
<li>Did some refactoring

<ul>
<li>Renames: files, variables, ... (names that start with "<em>My</em>", scratch my brain)</li>
<li>Tried to avoid code duplication (this can be improved more) - extracted it in common areas (like files, variables, ...)</li>
<li>Other non critical stuff</li>
</ul></li>
<li>Added a <em>freeStruct</em> function that will deallocate the pointer returned by <em>initFunc</em>, otherwise there will be <em>memory leaks</em></li>
<li><em>C</em>:

<ul>
<li><strong>Didn't test</strong> on <em>Lnx</em> (didn't start the <em>VM</em>), but it should work</li>
<li>If something goes wrong (<em>GetProcAddress</em> returns <em>NULL</em>), exit <em>initFunc</em> instead of just printing message and going further. This was a good candidate for the <em>Access Violation</em></li>
<li>Unload the (inner) <em>.dll</em> before exiting <em>initFunc</em></li>
<li>Reversed the <em>Lnx</em> / <em>Win</em> conditionals logic (<strong><em>__linux__</em></strong> / <strong><em>_WIN32</em></strong> macro checking) since the <em>dlfcn</em> functions are generic for all <em>Nix</em>es (and if you for example try to build your code on <em>OSX</em> or <em>Solaris</em> (where <em>__linux__</em> is not defined), it will fall on the <em>Win</em> branch, and obviously fail)</li>
</ul></li>
<li><em>Python</em>:

<ul>
<li>Removed <em>np</em>. The code didn't compile with it, and it's absolutely not necessary</li>
<li>Changed <em>param_dict</em> keys from <em>str</em> to <em>bytes</em> to match <code>ctypes.c_char_p</code> (as I'm using <em>Python <strong>3</strong></em></li></ul></li></ul></div>
<span class="comment-copy">Please unlearn this <a href="https://stackoverflow.com/questions/8869768/defining-the-functions-argument-type-after-the-is-it-a-very-old-standard">old-style parameter garbage</a> and use prototypes in your C code.  <code>MYSTRUCT *initfunc(flag, number, params, paramnames)</code> was deprecated 29 years ago.</span>
<span class="comment-copy">Your linux code is not the same, you're using <code>double</code> as a name instead of a <code>char *</code></span>
<span class="comment-copy">In any case this totally does not have a proper <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>, because the crash happens in code or due to code that you haven't provided in the question.</span>
<span class="comment-copy">The thing with <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a> is that you construct a minimal failing example that we can verify. I don't see it yet. You need to <i>isolate the fault</i> to a piece that is not confidential. Try printing the arguments in the initfunc or writing them into a file or something</span>
<span class="comment-copy">You don't check what functions return. That's bad coding, and most likely that's what got you in this situation. <b>Always</b> check for <i>NULL</i> a value that a function returns before using it (you should do the same for <i>Lnx</i>).</span>
<span class="comment-copy">Thanks for the help! I followed your way step by step and, in the end found that the real cause was not actually in the code itself. The real casue of the error was actually due to my stupid mistake by not putting the dll1 in the the proper location. Sorry for all this messy discussion!! I will look into the problem more carefully in the future before I post anything.</span>
<span class="comment-copy">You're welcome! So, at the end it turns out that it's what I've suspected (I wrote in comments and at the beginning of my answer), not finding the (inner) <i>.dll</i> (and thus <i>LoadLibrary</i> failing), because if it was the outer <i>.dll</i> missing, <i>ctypes</i> would have thrown an exception.</span>
