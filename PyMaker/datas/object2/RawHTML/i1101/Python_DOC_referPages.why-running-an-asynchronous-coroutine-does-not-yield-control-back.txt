<div class="post-text" itemprop="text">
<p>I have a sample code:</p>
<pre><code>import asyncio

import time

async def asyncsleep(number):
    time.sleep(number)

async def do_one():
    await asyncsleep(1)
    print("one 1")
    await asyncsleep(1)
    print("one 2")
    await asyncsleep(1)
    print("one 3")

async def do_two():
    await asyncsleep(1)
    print("two 1")
    await asyncsleep(1)
    print("two 2")
    await asyncsleep(1)
    print("two 3")

loop = asyncio.get_event_loop()
loop.run_until_complete(asyncio.wait([
    do_one(),
    do_two()
]))
loop.close()
</code></pre>
<p>This code is expected to have the two functions run parallel. I mean the output of both should come at the same time. But it is not happening. The reason is that I have implemented an sleep function myself <code>asyncsleep</code>. If I use <code>asyncio.sleep</code> instead of it, everything works fine.</p>
<pre><code>import asyncio

import time

async def asyncsleep(number):
    time.sleep(number)

async def do_one():
    await asyncio.sleep(1)
    print("one 1")
    await asyncio.sleep(1)
    print("one 2")
    await asyncio.sleep(1)
    print("one 3")

async def do_two():
    await asyncio.sleep(1)
    print("two 1")
    await asyncio.sleep(1)
    print("two 2")
    await asyncio.sleep(1)
    print("two 3")

loop = asyncio.get_event_loop()
loop.run_until_complete(asyncio.wait([
    do_one(),
    do_two()
]))
loop.close()
</code></pre>
<p>I also have looked up the signature of <code>asyncio.sleep</code> function:</p>
<pre><code>@coroutine
def sleep(delay, result=None, *, loop=None):
    """Coroutine that completes after a given time (in seconds)."""
    if delay == 0:
        yield
        return result

    if loop is None:
        loop = events.get_event_loop()
    future = loop.create_future()
    h = future._loop.call_later(delay,
                                futures._set_result_unless_cancelled,
                                future, result)
    try:
        return (yield from future)
    finally:
        h.cancel()
</code></pre>
<p>What the <code>asyncio.sleep</code> function has that my implemented <code>asyncsleep</code> function does not have? They are both coroutines, Why are they behaving differently?</p>
</div>
<div class="post-text" itemprop="text">
<p>When you do asynchronous things, you do not have continiuous flow. There is an <a href="https://docs.python.org/3/library/asyncio-eventloop.html#event-loop" rel="nofollow noreferrer">event loop</a>, that has a pool of <a href="https://docs.python.org/3/library/asyncio-task.html#task-object" rel="nofollow noreferrer">tasks</a> and switches between them: when the current task <code>await</code>s, the loop passes the control to one of the other tasks in the pool. </p>
<p><a href="https://docs.python.org/3/library/asyncio-future.html#asyncio.Future" rel="nofollow noreferrer">time.sleep</a>, as gracefully stated in comments by @user2357112, is synchronous, it just blocks the execution for some time, not giving the opportunity to proceed to a different coroutine.</p>
<p>So, what <code>asyncio.sleep</code> has and your <code>asyncsleep</code> has not:</p>
<ul>
<li>It creates a new <a href="https://docs.python.org/3/library/asyncio-future.html#asyncio.Future" rel="nofollow noreferrer">Future</a> (a special object representing the result of a task that is not <em>yet</em> completed)</li>
<li>That new task does nothing, but takes specified time</li>
<li>So the new future will yield the <code>result</code> when the time comes</li>
<li>That task helps to block a flow in which the <code>asyncio.sleep</code> was awaited but does not block the other tasks.</li>
</ul>
<p>Feel the difference.</p>
</div>
<div class="post-text" itemprop="text">
<p>Async is not threads.  Async code does not give up control until it hits an await or the function completes.  Your sleep function doesn't give up control so: </p>
<p>The asyncio loop is running and do_one and do_two are scheduled.  The loop chooses to run do_one and because you don't yield or await your code doesn't return to the loop until the function completes.  </p>
</div>
<span class="comment-copy"><code>time.sleep</code> is synchronous. If <code>time.sleep</code> worked like that, <code>asyncio.sleep</code> wouldn't exist.</span>
<span class="comment-copy">@user2357112 Isn't the reason of <code>asyncio</code> to wrap synchronous into asynchronous?</span>
<span class="comment-copy">Sticking a synchronous call in an async function doesn't make it asynchronous.</span>
<span class="comment-copy">@dirn: <code>time.sleep</code> isn't CPU-bound.</span>
<span class="comment-copy">@TechJS Every function call is blocking in the technical sense (it blocks the calling thread until the function returns or raises), but in this context a distinction is made between functions like <code>list.append</code> that do their work in a small amount of time, and <code>time.sleep</code> or <code>sock.recv</code>, which can block the thread indefinitely. The solution is not to call such functions, and use their async variants instead. This is what asyncio does, with some additional magic to suspend the coroutine when the condition it is awaiting (such as asyncio.sleep) is not yet ready.</span>
