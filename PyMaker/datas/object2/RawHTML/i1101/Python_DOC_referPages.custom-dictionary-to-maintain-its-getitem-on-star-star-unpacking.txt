<div class="post-text" itemprop="text">
<p>Merry christmas everybody,</p>
<p>I'm implementing a custom dictionary that allows attribute access, e.g. <code>dct.attribute</code>. The dictionaries can be nested, so <code>dct.nested_dct.attribute</code> should also be possible. This is working pretty well already, except for the star-star-unpacking. I think I'm able to express what I'm trying to do better using code than words. So here is the class I'm writing. The tests should explain pretty clearly what it does:</p>
<pre><code>class DotDict(dict):
    def __getattr__(self, item):
        return self.__getitem__(item)

    def __getitem__(self, item):
        item = super().__getitem__(item)
        if isinstance(item, dict):
            return self.__class__(item)
        return item


class TestDotDict:
    @pytest.fixture
    def dot_dict(self):
        input_dict = dict(
            a=1,
            b=dict(
                c=2,
                d=3,
            )
        )
        return DotDict(input_dict)

    def test_can_access_by_dot(self, dot_dict):
        assert dot_dict.a == 1

    def test_returned_dicts_are_dot_dicts(self, dot_dict):
        b_dict = dot_dict["b"]
        assert isinstance(b_dict, DotDict)
        assert b_dict.c == 2

    def test_getting_item_also_returns_dot_dicts(self, dot_dict):
        b_dict = dot_dict["b"]
        assert isinstance(b_dict, DotDict)
        assert b_dict.c == 2

    def test_unpack_as_function_arguments_yields_dot_dicts_for_children(self, dot_dict):
        # this is failing
        def checker(a, b):
            assert a == 1
            assert b.c == 2
        checker(**dot_dict)
</code></pre>
<p>As stated in the comment, the last test is failing. Does anybody know how to fix it?</p>
<p>Following the answers from this question: <a href="https://stackoverflow.com/questions/37400133/star-unpacking-for-own-classes">star unpacking for own classes</a> , I figured I need to inherit from <code>collections.abc.Mapping</code> and <code>dict</code>. However, this didn't solve the issue. </p>
<p>I was thinking this might be related to a MRO that's not entirely clear to me. But no matter if I change the class definition to</p>
<pre><code>class DotDict(Mapping, item):
</code></pre>
<p>or</p>
<pre><code>class DotDict(item, Mapping):
</code></pre>
<p>my tests won't become green.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem you are facing is that yu are trying to build upon a native <code>dict</code>  - and for this class, <code>__getitem__</code> is just one of several ways its values can be retrieved. Due to the way dicts are implemented in Python, for both historic and performance reasons, there are lots of ways that will simply bypass <code>__getitem__</code> altogether, and therefore, nested dictionaries will never be "wrapped" in a DotDict. (for example: <code>.values()</code>, <code>items()</code>, and starmap will possibly bypass even these)</p>
<p>What you really want there is to subclass <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableMapping" rel="nofollow noreferrer">collections.abc.MutableMapping</a> - it is constructed in a way that ensure that any item retrieval will go through <code>__getitem__</code>, (you will have to implement the methods indicated in the documentation though, including <code>__delitem__</code>, <code>__setitem__</code> and <code>__iter__</code> - the recomendation is to keep the actual data as a plain dictioanry in a <code>.data</code> attribute created in the <code>__init__</code> method).</p>
<p>Perceive that this also gives you better control on your data, enabling you, for example, to wrap your data in your custom-class directly on setitem, and jsut don't care on attribute retrieval  - or, the other way around, store any mappings as plain dictionaries for memory-saving and efficiency and wrap it on retrieval. </p>
</div>
<div class="post-text" itemprop="text">
<p>In <code>test_star_star_mapping_maintains_child_dot_dicts</code> you are creating a <code>dict</code> not a <code>DotDict</code> so, refactoring to:</p>
<pre><code>def test_star_star_mapping_maintains_child_dot_dicts(self, dot_dict):
    obtained_via_star = DotDict(dict(**dot_dict))
    b_dict = obtained_via_star["b"]
    assert b_dict.c == 2
</code></pre>
<p>Will make the test pass because you now you are creating a <code>DotDict</code>. Maybe you want to remove the part <code>dict(**dot_dict)</code> so this version also works:</p>
<pre><code>def test_star_star_mapping_maintains_child_dot_dicts(self, dot_dict):
    obtained_via_star = DotDict(**dot_dict)
    b_dict = obtained_via_star["b"]
    assert b_dict.c == 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>wow, try to run the following code with uncommented <code>__iter__</code></p>
<pre><code>class DotDict(dict):
#    def __iter__(self):
#        return super().__iter__()

    def __getattr__(self, item):
        return self.__getitem__(item)

    def __getitem__(self, item):
        item = super().__getitem__(item)
        if isinstance(item, dict):
            return self.__class__(item)
        return item

d = DotDict({'a': {'b':'c'}})

print(type(dict(**d)['a']))
</code></pre>
<p>very, very strange</p>
</div>
<span class="comment-copy">Great, thanks for the answer. Do you know what's the difference between <code>Mapping</code> and <code>MutableMapping</code>? The documentation is a bit short on this.</span>
<span class="comment-copy">Unfortunately not. So of course it get's the tests green. But I want to do be able to do the unpacking return <code>DotDict</code> to pass it dynamically along as function arguments (like <code>**kwargs</code>). Therefore wrapping it in a <code>DotDict</code> again doesn't work. I edited the question and the tests to make it clearer.</span>
<span class="comment-copy">Didn't help for me. Does it for you?</span>
<span class="comment-copy">with <code>__iter__</code> implemented I get <code>&lt;class '__main__.DotDict'&gt;</code>, without <code>&lt;class 'dict'&gt;</code></span>
<span class="comment-copy">What python are you on? I'm using 3.6</span>
<span class="comment-copy">Apparently the <code>__iter__</code> is not called at all</span>
<span class="comment-copy">I use Python 3.6.7</span>
