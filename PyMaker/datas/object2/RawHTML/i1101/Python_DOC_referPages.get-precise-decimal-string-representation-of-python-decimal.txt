<div class="post-text" itemprop="text">
<p>If I've got a Python <code>Decimal</code>, how can I reliably get the precise decimal string (ie, not scientific notation) representation of the number without trailing zeros?</p>
<p>For example, if I have:</p>
<pre><code>&gt;&gt;&gt; d = Decimal('1e-14')
</code></pre>
<p>I would like:</p>
<pre><code>&gt;&gt;&gt; get_decimal_string(d)
'0.00000000000001'
</code></pre>
<p>However:</p>
<ol>
<li>The <code>Decimal</code> class doesn't have any <code>to_decimal_string</code> method, or even any <code>to_radix_string(radix)</code> (cf: <a href="https://docs.python.org/3/library/decimal.html#decimal.Context.to_eng_string" rel="noreferrer">https://docs.python.org/3/library/decimal.html#decimal.Context.to_eng_string</a>)</li>
<li>The <code>%f</code> formatter either defaults to rounding to 6 decimal places - <code>'%f' %(d, ) ==&gt; '0.000000'</code> - or requires a precise number of decimal places.</li>
<li>The <code>{:f}.format(...)</code> formatter <em>appears</em> to work - <code>'{:f}'.format(d)
==&gt; '0.00000000000001'</code> - <em>however</em> I'm reluctant to trust that, as this actually runs counter to <a href="https://docs.python.org/3/library/string.html#index-9" rel="noreferrer">the documentation</a>, which says "<code>'f'</code> … Displays the number as a fixed-point number. The default precision is 6"</li>
<li><code>Decimal.__repr__</code> and <code>Decimal.__str__</code> sometimes return scientific notation: <code>repr(d) ==&gt; "Decimal('1E-14')"</code></li>
</ol>
<p>So, is there any way to get a decimal string from a Python <code>Decimal</code>? Or do I need to roll my own using <code>Decimal.as_tuple()</code>?</p>
</div>
<div class="post-text" itemprop="text">
<h3>Short answer:</h3>
<pre><code>&gt;&gt;&gt; d
Decimal('1E-14')
&gt;&gt;&gt; '{:f}'.format(d)
'0.00000000000001'
</code></pre>
<h3>Long answer:</h3>
<p>As @BrandonRhodes pointed out <a href="https://www.python.org/dev/peps/pep-3101/#format-specifiers" rel="nofollow noreferrer">PEP 3101</a> (which is the string format PEP) states:</p>
<blockquote>
<p>The syntax for format specifiers is open-ended, since a class can
  override the standard format specifiers. In such cases, the
  str.format() method merely passes all of the characters between the
  first colon and the matching brace to the relevant underlying
  formatting method.</p>
</blockquote>
<p>And thus, the <code>Decimal.__format__</code> method is what python's string format will utilize to generate the <code>str</code> representation of the <code>Decimal</code> value.  Basically <code>Decimal</code> overrides the formatting to be "smart" but will default to whatever values the format string sets (ie <code>{:.4f}</code> will truncate the decimal to 4 places).</p>
<p>Here's why you can trust it (snippet from <code>decimal.py:Decimal.__format__</code>):</p>
<pre><code># PEP 3101 support.  the _localeconv keyword argument should be
# considered private: it's provided for ease of testing only.
def __format__(self, specifier, context=None, _localeconv=None):
    #
    # ...implementation snipped.
    #

    # figure out placement of the decimal point
    leftdigits = self._exp + len(self._int)
    if spec['type'] in 'eE':
        if not self and precision is not None:
            dotplace = 1 - precision
        else:
            dotplace = 1
    elif spec['type'] in 'fF%':
        dotplace = leftdigits
    elif spec['type'] in 'gG':
        if self._exp &lt;= 0 and leftdigits &gt; -6:
            dotplace = leftdigits
        else:
            dotplace = 1

    # find digits before and after decimal point, and get exponent
    if dotplace &lt; 0:
        intpart = '0'
        fracpart = '0'*(-dotplace) + self._int
    elif dotplace &gt; len(self._int):
        intpart = self._int + '0'*(dotplace-len(self._int))
        fracpart = ''
    else:
        intpart = self._int[:dotplace] or '0'
        fracpart = self._int[dotplace:]
    exp = leftdigits-dotplace

    # done with the decimal-specific stuff;  hand over the rest
    # of the formatting to the _format_number function
    return _format_number(self._sign, intpart, fracpart, exp, spec)
</code></pre>
<p>Long story short, the <code>Decimal.__format__</code> method will calculate the necessary padding to represent the number before and after the decimal based upon exponentiation provided from <code>Decimal._exp</code> (in your example, 14 significant digits).</p>
<pre><code>&gt;&gt;&gt; d._exp
-14
</code></pre>
</div>
<span class="comment-copy">The documentation you quoted only deals with the internal representation, not what <code>format</code> is going to produce.</span>
<span class="comment-copy">Right, which is why I said it wasn't clear.  It only implies through the examples that the formatting will work as expected.  There is no explicit discussion of interaction with string's .format method.  I will continue looking, and post if I find anything.  Another interesting part of those docs:  "Unlike hardware based binary floating point, the decimal module has a user alterable precision (defaulting to 28 places) which can be as large as needed for a given problem:" but this value doesn't seem to affect the string formatting.</span>
<span class="comment-copy">See my point 3, above: this <i>appears</i> to work, but it contradicts what the <code>string.format</code> documentation says about the behavior of <code>'f'</code>, so I'm reluctant to trust it.</span>
<span class="comment-copy">When in doubt: use the source, haha.  I'll update the answer, but basically you can trust it because of the <code>Decimal.__format__</code> methods implementation.</span>
<span class="comment-copy">Remember that <code>string.format</code> has no control over what format operators actually do any more — it's now deferred to <code>__format__()</code> methods.</span>
