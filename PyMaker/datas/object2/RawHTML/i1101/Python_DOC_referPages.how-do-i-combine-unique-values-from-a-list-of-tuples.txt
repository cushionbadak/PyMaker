<div class="post-text" itemprop="text">
<p>I have 2 lists (from an excel file) with one containing the names of products and the others containing numbers.</p>
<p>Example Excel File:</p>
<p><a href="https://i.stack.imgur.com/bDtAA.png" rel="nofollow noreferrer"><img alt="Example Excel Document" src="https://i.stack.imgur.com/bDtAA.png"/></a></p>
<p>Which means I have 2 lists - ripped with xlrd.col_values():</p>
<pre><code>products = ['Product1','Product1','Product1','Product2','Product2','Product2']
values = [1,-1,0,2,4,-1]
</code></pre>
<p>The end result I would like is this:</p>
<pre><code>format = [['Product1', [1,-1,0]],['Product2', [2,4,-1]]]
</code></pre>
<p>I have attempted to do this using zip():</p>
<pre><code>zip_list = list(zip(products, values))
</code></pre>
<p>However this returned:</p>
<pre><code>[('Product1', 1), ('Product1', -1), ('Product1', 0), ('Product2', 2), ('Product2', 4), ('Product2', -1)]
</code></pre>
<p>Would anyone know how to get the desired format? - I am using python3.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a dictionary (ideal: <code>collections.defaultdict</code>) to collect your data and then use the <code>dict.items()</code> to create your format:</p>
<pre><code>from collections import defaultdict

products = ['Product1','Product1','Product1','Product2','Product2','Product2']
values = [1,-1,0,2,4,-1]

d = defaultdict(list)
# accumulate your data
for prod,val in zip(products,values):
    d[prod].append(val)

print(d)   

# convert dict.items() to your wanted format    
format = [list(i) for i in d.items()] 
print(format)   
</code></pre>
<p>Output:</p>
<pre><code>defaultdict(&lt;class 'list'&gt;, {'Product1': [1, -1, 0], 'Product2': [2, 4, -1]})

[['Product1', [1, -1, 0]], ['Product2', [2, 4, -1]]]
</code></pre>
<p>Using <code>defaultdict(list)</code> is preferable over <code>dict.setdefault(key,[])</code> or using <code>try: except:</code> or testing if <code>key in dict</code> because it is overall faster (builtin optimizations) then any of the other methods.</p>
<p>Doku:</p>
<ul>
<li><a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">defaultdict</a></li>
<li><a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer">zip()</a></li>
</ul>
<hr/>
<p>You could also leverage <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">itertools.groupby()</a> wich operates on sorted data (yours <em>is</em> sorted) to get to the same results:</p>
<pre><code>from itertools import groupby

grped = groupby( zip(products,values), lambda x:x[0]) # group by 1st value

l = []
for g in grped:
    l.append([g[0],list(val for _,val in g[1])])      # extract 2nd value from grouping

print(l) # [['Product1', [1, -1, 0]], ['Product2', [2, 4, -1]]]
</code></pre>
<p>Using <code>groupby</code> on this list creates the same partitioning because it is sorted - if it was not sorted you'd get different results.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since dictionary comprehension is not good for aggregation, just use a linear time loop:</p>
<pre><code>prods = {}
for item in zip(products, values):
    prod, val = item
    try:
        prods[prod].append(val)
    except KeyError:
        prods[prod] = [val]

# Sample
&gt;&gt;&gt; prods = {}
&gt;&gt;&gt; for item in zip(products, values):
    prod, val = item
    try:
        prods[prod].append(val)
    except KeyError:
        prods[prod] = [val]     
&gt;&gt;&gt; prods
{'Product1': [1, -1, 0], 'Product2': [2, 4, -1]}
</code></pre>
<p>I understand you wanted a format of <code>[['ProductN', [ ]]</code> but I think a dictionary is a better choice.</p>
</div>
<span class="comment-copy">You got that from <code>zip()</code> because that is exactly what it does.</span>
<span class="comment-copy">@pstatix ,Yes, sorry I should've mentioned that I've never used zip before and was just posting it there in case there was a way to use the zip() function to create it....</span>
<span class="comment-copy">I think <code>itertools.groupby</code> is the canonical answer to this question, I would even consider listing it first. Also, I might change "sorted" to "grouped." The data do not need to be sorted - the only requirement is that the values in the first column are grouped (i.e. not interwoven).</span>
<span class="comment-copy">Nit, <code>l = [[g[0], [v for _, v in g[1]] for g in grped]</code> might be more concise.</span>
<span class="comment-copy">@JaredGoguen groupby needs sorted data - it will only create groups of consecutive values: <code>groupby( zip([1,1,1,2,2,2,1,1,1],[1,1,1,2,2,2,3,3,3]) ==&gt; [[1, [1, 1, 1]], [2, [2, 2, 2]], [1, [3, 3, 3]]]</code> will create 2 groups for key <code>1</code> - the defaultdict does not need pre-sorting: [[1, [1, 1, 1, 3, 3, 3]], [2, [2, 2, 2]]]</span>
<span class="comment-copy">Using <code>[2, 2, 2, 1, 1, 1, 3, 3, 3]</code> as the entries in the first list should work fine - these are not sorted</span>
<span class="comment-copy">@Jared - they do not need to be sorted - they do not share the same key That is the point - for groupby to group <i>all</i> of one key into one grouping they need to be sorted - the dict aproach does not. So if you do not want the same key in different groupings you need to sort first for groupby which adds complexity to the solution - if you are fine with having the same key in different groupings when other groups are between consecutive key-stretches you do not ... hence it depends what you want and what you need. Both approaches have value depending on what you want as result.</span>
<span class="comment-copy">Thank you very much, this works really well, if I were to have more than 2 arrays, For example getting: {Product:[[array1],[array2]]} instead.... Your answer works really well though...</span>
<span class="comment-copy">@wowcha Your original question doesnt ask for something where you would need two lists per key.</span>
<span class="comment-copy">Yes, you're right thank you for help...</span>
