<div class="post-text" itemprop="text">
<p>I need to decide on a schema for including binary elements into a message object so that it can be decoded again on the receiving end (In my situation a consumer on an Rabbit MQ / AMQP queue).</p>
<p>I decided against multipart MIME encoding over JSON mostly because it seems like using Thor's hammer to push in a thumb tack.  I decided against manually joining parts (binary and JSON concatenated together) mostly because every time a new requirement arises it is a whole re-design.  JSON with the binary encoded in one of the fields seems like an elegant solution.</p>
<p>My seemingly working (confirmed by comparing MD5-sum of sent and received data) solution is doing the following:</p>
<pre><code>def json_serialiser(byte_obj):
    if isinstance(byte_obj, (bytes, bytearray)):
        # File Bytes to Base64 Bytes then to String
        return base64.b64encode(byte_obj).decode('utf-8')
    raise ValueError('No encoding handler for data type ' + type(byte_obj))


def make_msg(filename, filedata):
    d = {"filename": filename,
         "datalen": len(filedata),
         "data": filedata}
    return json.dumps(d, default=json_serialiser)
</code></pre>
<p>On the receiving end I simply do:</p>
<pre><code>def parse_json(msg):
    d = json.loads(msg)
    data = d.pop('data')
    return base64.b64decode(data), d


def file_callback(ch, method, properties, body):
    filedata, fileinfo = parse_json(body)
    print('File Name:', fileinfo.get("filename"))
    print('Received File Size', len(filedata))
</code></pre>
<p>My google-fu left me unable to confirm whether what I am doing is in fact valid.  In particular I am concerned whether the line that produces the string from the binary data for inclusion into JSON is correct, eg the line
<code>return base64.b64encode(byte_obj).decode('utf-8')</code></p>
<p>And it seems that I am able to take a shortcut with the decoding back to binary data as the <code>base64.b64decode()</code> method handles the UTF-8 data as if it is ASCII - As one would expect it to be coming from the output of <code>base64.b64encode()</code> ... But is this a valid assumption in all cases?</p>
<p>Mostly I'm surprised at not being able to find any examples online of doing this.  Perhaps my google patience are still on holiday!</p>
</div>
<div class="post-text" itemprop="text">
<p>The docs confirm that your approach is ok.</p>
<p><code>base64.b64encode(byte_obj).decode('utf-8')</code> is correct - base64.b64encode <a href="https://docs.python.org/3/library/base64.html#base64.b64encode" rel="nofollow noreferrer">requires</a> bytes as input:</p>
<blockquote>
<p>Encode the bytes-like object s using Base64 and return the encoded bytes.</p>
</blockquote>
<p>However <code>base64.b64decode</code> <a href="https://docs.python.org/3/library/base64.html#base64.b64decode" rel="nofollow noreferrer">accepts</a> bytes or an ascii string:</p>
<blockquote>
<p>Decode the Base64 encoded bytes-like object or ASCII string s and return the decoded bytes.</p>
</blockquote>
</div>
<span class="comment-copy">Thank you.  But when I use eg <code>...decode('latin-1')</code> I still get the same result.  So assuming everything else I do is correct, the question that remains is whether using <code>decode('utf-8')</code> is the correct approach for serialising the base64 encoded bytes to "str".</span>
<span class="comment-copy">It doesn't matter whether you use 'utf-8' or <code>latin-1</code> because both encodings encode ascii characters to the same values, and base64 only uses ascii.  So either is fine.</span>
