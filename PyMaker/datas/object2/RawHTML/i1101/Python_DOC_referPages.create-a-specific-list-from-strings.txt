<div class="post-text" itemprop="text">
<p><strong>Edited according to comments:</strong></p>
<p>I would like to use the strings <code>'ABC'</code> and <code>'123'</code> to create the list </p>
<pre><code>['A1','B2','C3','A3','C1']
</code></pre>
<p>The logic would be to pair the first string with the second string in sequence and then again backwards: </p>
<p>forwards: A1, B2, C3
backwards: A3, B2, C1</p>
<p><code>B2</code> only appears once as the final list should be distinct values.</p>
<p>I should be able to expand each of the two strings(they will always match in length) and have the same result pattern.</p>
<p>I tried a couple of things but I would like to know if there is a more pythonic way to accomplish this.</p>
</div>
<div class="post-text" itemprop="text">
<p>The following solutions will work in Python 3.x,</p>
<pre><code>from collections import OrderedDict

s1 ='ABC'
s2 = '123'

result = list(OrderedDict.fromkeys(first + second for first, second in zip(s1 + s1, s2 + s2[::-1])))
print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>['A1', 'B2', 'C3', 'A3', 'C1']
</code></pre>
<p>This first solution assumes you only need to repeat the iterables once. If you have to repeat the shortest iterable more than once you could use <a href="https://docs.python.org/3/library/itertools.html#itertools.cycle" rel="nofollow noreferrer">cycle</a> to iterate several times over it:</p>
<pre><code>from itertools import cycle

s1 ='ABC'
s2 = '123'

seen = set()
result = []
for first, second in zip(cycle(s1), s2 + s2[::-1]):
    first_second = first + second
    if first_second not in seen:
        seen.add(first_second)
        result.append(first_second)

print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>['A1', 'B2', 'C3', 'A3', 'C1']
</code></pre>
<p>The idea in this second solution is to use a <a href="https://docs.python.org/3/library/stdtypes.html#set" rel="nofollow noreferrer">set</a> of seen elements and only add to the final result if not seen. Finally you could combine the solutions and use <code>cycle</code> and <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">OrderedDict</a>:</p>
<pre><code>from itertools import cycle
from collections import OrderedDict

s1 ='ABC'
s2 = '123'

result = list(OrderedDict.fromkeys(first + second for first, second in zip(cycle(s1), s2 + s2[::-1])))
print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>['A1', 'B2', 'C3', 'A3', 'C1']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If version greater than 3.6:</p>
<pre><code>print(list(map(''.join,list(dict.fromkeys(list(zip(s1,s2))+list(zip(s1,s2[::-1])))))))
</code></pre>
<p>Output:</p>
<pre><code>['A1', 'B2', 'C3', 'A3', 'C1']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I tried a couple of things but I would like to know if there is a more
  pythonic way to accomplish this.</p>
</blockquote>
<p>Without saying what you've tried, it's hard to suggest an alternative, pythonic or otherwise. Looking at what you're doing, it seems you're constructing a mapping between sets of the form:</p>
<p><a href="https://i.stack.imgur.com/azYpO.png" rel="nofollow noreferrer"><img alt="Set Mapping" src="https://i.stack.imgur.com/azYpO.png"/></a></p>
<p>This is about as atomic as it gets with respect to logical relationships; I'm not sure there's any method that would be quicker than a dumb-as-a-rock string concatenation by index:</p>
<pre><code>x = 'ABC'
y = '123'

new_list = [x[0] + y[0], x[1]+y[1], x[2]+y[2], x[0]+y[2], x[2]+y[0]]
</code></pre>
<p>Output:</p>
<pre><code>['A1', 'B2', 'C3', 'A3', 'C1']
</code></pre>
</div>
<span class="comment-copy">Which <i>two</i> lists? I see one.</span>
<span class="comment-copy">What is the logic that leads to your output???</span>
<span class="comment-copy">This explanation is insufficient to determine a solution: why and how <code>'B2'</code>is omitted?</span>
<span class="comment-copy">thank you for your reply. However, this is manual and would have to be edited if the strings change.</span>
