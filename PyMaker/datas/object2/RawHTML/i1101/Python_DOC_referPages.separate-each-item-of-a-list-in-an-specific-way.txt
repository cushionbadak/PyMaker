<div class="post-text" itemprop="text">
<p>I have an input, which is a tuple of strings, encoded in a1z26 cipher: numbers from 1 to 26 represent alphabet letters, hyphens represent same word letters and spaces represent an space between words.
For example:
8-9 20-8-5-18-5 should translate to 'hi there'</p>
<p>Let's say that the last example is a tuple in a var called string</p>
<pre><code>string = ('8-9','20-8-5-18-5')
</code></pre>
<p>The first thing I find logical is convert the tuple into a list using </p>
<blockquote>
<p>string = list(string)</p>
</blockquote>
<p>so now </p>
<pre><code>string = ['8-9','20-8-5-18-5']
</code></pre>
<p>The problem now is that when I iterate over the list to compare it with a dictionary which has the translated values, double digit numbers are treated as one, so instead of, for example, translating '20' it translate '2' and then '0', resulting in the string saying 'hi bheahe' (2 =b, 1 = a and 8 = h)</p>
<p>so I need a way to convert the list above to the following 
    list </p>
<pre><code>['8','-','9',' ','20','-','8','-','5','-','18','-','5',]
</code></pre>
<p>I've already tried various codes using</p>
<blockquote>
<p>list(),
  join() and 
  split()</p>
</blockquote>
<p>But it ends up giving me the same problem.</p>
<p>To sum up, I need to make any given list (converted from the input tuple) into a list of characters that takes into account double digit numbers, spaces and hyphens altogether</p>
<p>This is what I've got so far. (The last I wrote) The input is further up in the code (string)</p>
<pre><code>a1z26 =  {'1':'A', '2':'B', '3':'C', '4':'D', '5':'E', '6':'F', '7':'G', '8':'H', '9':'I', '10':'J', '11':'K', '12':'L',  '13':'M', '14':'N',  '15':'O', '16':'P', '17':'Q', '18':'R', '19':'S', '20':'T', '21':'U', '22':'V',  '23':'W', '24':'X', '25':'Y', '26':'Z', '-':'', ' ' : ' ', ', ' : ' '}            
    translation = ""
    code = list(string)
    numbersarray1 = code
    numbersarray2 = ', '.join(numbersarray1)            
    for char in numbersarray2:
        if char in a1z26:
            translation += a1z26[char] 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You don't really need hypens, am I right?</p>
<p>I suggest you the following approach:</p>
<pre><code>a = '- -'.join(string).split('-')
</code></pre>
<p>Now <code>a</code> is <code>['8', '9', ' ', '20', '8', '5', '18', '5']</code></p>
<p>You can then convert each number to the proper character using your dictionary</p>
<pre><code>b = ''.join([a1z26[i] for i in a])
</code></pre>
<p>Now <code>b</code> is equal to <code>HI THERE</code></p>
</div>
<div class="post-text" itemprop="text">
<p>There's no need to convert the tuple to a list. Tuples are iterable too.</p>
<p>I don't think the list you name is what you actually want. You probably want a 2d iterable (not necessarily a list, as you'll see below we can do this in one pass without generating an intermediary list), where each item corresponds to a word and is a list of the character numbers:</p>
<pre><code>[[8, 9], [20, 8, 5, 18, 5]]
</code></pre>
<p>From this, you can convert each number to a letter, join the letters together to form the words, then join the words with spaces.</p>
<p>To do this, you need to pass a parameter to split, to tell it how to split your input string. You can achieve all of this with a one liner:</p>
<pre><code>plaintext = ' '.join(''.join(num_to_letter[int(num)] for num in word.split('-'))
                     for word in ciphertext.split(' '))
</code></pre>
<p>This does exactly the splitting procedure as described above, and then for each number looks into the dict <code>num_to_letter</code> to do the conversion.</p>
<p>Note that you don't even need this dict. You can use the fact that A-Z in unicode is contiguous so to convert 1-26 to A-Z you can do <code>chr(ord('A') + num - 1)</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think, it's better to apply regular expressions there.</p>
<p>Example:</p>
<pre><code>import re
...
src = ('8-9', '20-8-5-18-5')
res = [match for tmp in src for match in re.findall(r"([0-9]+|[^0-9]+)", tmp + " ")][:-1]
print(res)
</code></pre>
<p>Result:</p>
<pre><code>['8', '-', '9', ' ', '20', '-', '8', '-', '5', '-', '18', '-', '5']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>using regex here is solution</p>
<pre><code>import re
string = '8-9 20-8-5-18-5'

exp=re.compile(r'[0-9]+|[^0-9]+')

data=  exp.findall(string)
print(data)
</code></pre>
<p>output </p>
<p><code>['8', '-', '9', ' ', '20', '-', '8', '-', '5', '-', '18', '-', '5']</code></p>
<p>if you want to get <code>hi there</code> from the input string , here is a method (i am assuming all character are in uppercase):</p>
<pre><code>import re
string = '8-9 20-8-5-18-5'
exp=re.compile(r'[0-9]+|[^0-9]+')
data=  exp.findall(string)

new_str =''
for i in range(len(data)):
    if data[i].isdigit():
        new_str+=chr(int(data[i])+64)
    else:
        new_str+=data[i]
result = new_str.replace('-','')
</code></pre>
<p>output:
    <code>HI THERE</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You could also try this itertools solution:</p>
<pre><code>from itertools import chain
from itertools import zip_longest

def separate_list(lst, delim, sep=" "):
    result = []

    for x in lst:
        chars = x.split(delim) # 1
        pairs = zip_longest(chars, [delim] * (len(chars) - 1), fillvalue=sep) # 2, 3
        result.extend(list(chain.from_iterable(pairs))) # 4

    return result[:-1] # 5

print(separate_list(["8-9", "20-8-5-18-5"], delim="-"))
</code></pre>
<p>Output:</p>
<pre><code>['8', '-', '9', ' ', '20', '-', '8', '-', '5', '-', '18', '-', '5']
</code></pre>
<p><strong>Explanation of above code:</strong></p>
<ol>
<li>Split each string by delimiter <code>'-'</code>.</li>
<li>Create interspersing delimiters.</li>
<li>Create pairs of characters and separators with <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer"><code>itertools.zip_longest</code></a>.</li>
<li>Extend flattened pairs to result list with <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain.from_iterable</code></a>.</li>
<li>Remove trailing <code>' '</code> from result list added.</li>
</ol>
<p>You could also create your own intersperse generator function and apply it twice:</p>
<pre><code>from itertools import chain

def intersperse(iterable, delim):
    it = iter(iterable)
    yield next(it)
    for x in it:
        yield delim
        yield x

def separate_list(lst, delim, sep=" "):
    return list(
        chain.from_iterable(
            intersperse(
                (intersperse(x.split(delim), delim=delim) for x in lst), delim=[sep]
            )
        )
    )

print(separate_list(["8-9", "20-8-5-18-5"], delim="-"))
# ['8', '-', '9', ' ', '20', '-', '8', '-', '5', '-', '18', '-', '5']
</code></pre>
</div>
<span class="comment-copy">You talk about spaces in the strings, but you don't seem to have any spaces. You have tuples like <code>('8-9','20-8-5-18-5')</code>. Is each item in the tuple a word? How do the spaces factor in?</span>
<span class="comment-copy">good approach if you want the direct result.</span>
<span class="comment-copy">I realize now that there is already a <code>'  ' : '  '</code> entry in the dictionary. So let me just edit the answer to avoid the unneded addition of 0 to the dict</span>
<span class="comment-copy">At this point, I'm upvoting for not mentioning the abomination of regex as a "valid" option :)</span>
<span class="comment-copy">You certainly can apply regular expressions here, but I'd argue that it's massive overkill.</span>
<span class="comment-copy">@MadPhysicist, I'm 100% agree with you that for this task it's overkill, BUT: 1) It solves problem if there would be more than 1 divider 2) It's much more flexible than list comprehensions 3) Code are simple and easier to understand 4) it's one-liner :D</span>
<span class="comment-copy">#1 agreed, #2 you're using a comprehension, #3/4 that one liner is brutal. I do that myself sometimes, but readability would be greater with a couple of lines.</span>
<span class="comment-copy">To clarify, I think applying <code>.split('-')</code> to each string would be much simpler.</span>
