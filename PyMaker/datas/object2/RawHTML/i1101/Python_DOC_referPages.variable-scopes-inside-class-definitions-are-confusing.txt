<div class="post-text" itemprop="text">
<p>For some reasons python gets variable from global namespace when situations like this occurs:</p>
<pre><code>class Cls:
    foo = foo
</code></pre>
<p>Please look at this code:</p>
<pre><code>foo = 'global'

def func0():
    foo = 'local'
    class Cls:
        bar = foo
    print('func0', Cls.bar)
 func0()
 # func0 local

def func1():
    foo = 'local'
    class Cls:
        foo = foo
    print('func1', Cls.foo)
func1()
# func1 global

def func2():
    foo = 'nonlocal'
    def internal():
        class Cls:
            foo = foo
        print('func2.internal', Cls.foo)
    internal()
func2()
# func2.internal global

def func3():
    foo = 'local'
    class Cls:
        bar = foo
        foo = foo
    print('func3', Cls.bar, Cls.foo)
func3()
# func3 global global
</code></pre>
<p>In accordance with <a href="https://www.python.org/dev/peps/pep-0227/#specification" rel="nofollow noreferrer">PEP 227</a></p>
<blockquote>
<p>A class definition is an executable statement that may contain uses and definitions of names. These references follow the normal rules for name resolution. The namespace of the class definition becomes the attribute dictionary of the class.</p>
</blockquote>
<p>but it doesn't look like "following the normal rules" at all to me. What am I missing?</p>
<p>Both Py2 and Py3 operates this way.</p>
</div>
<div class="post-text" itemprop="text">
<p>That's documented in <a href="https://docs.python.org/3/reference/executionmodel.html#resolution-of-names" rel="noreferrer">Execution model - Resolution of names</a>:</p>
<blockquote>
<p>Class definition blocks [...] are special
  in the context of name resolution. A class definition is an executable
  statement that may use and define names. These references follow the
  normal rules for name resolution with an exception that <strong>unbound local</strong>
<strong>variables are looked up in the global namespace.</strong></p>
</blockquote>
<p>(emphasis mine)</p>
</div>
<span class="comment-copy">@DeepSpace I'm expecting what evaluation of assignment's right side should be independent to left side's variable name, but this is not the case here. when inside class definition you're doing <code>a  = b</code> it gets <code>b</code> from local namespace, but then <code>a = a</code> it gets right <code>a</code> from global namespace</span>
<span class="comment-copy">Where else would it take <code>a</code> from?</span>
<span class="comment-copy">From local namespace, please take a look at <code>func0</code>.</span>
<span class="comment-copy">In my mind it should raise <code>UnboundLocalError</code> like it should in function's namespaces, but for some reasons it doesn't</span>
<span class="comment-copy">Thanks, this is what I was looking for! Maybe you could provide any insight of motivation to this behavior?</span>
