<div class="post-text" itemprop="text">
<p>I am trying to create some code that returns the positions and the values of the "peaks" (or local maxima) of a numeric array.</p>
<p>For example, the list <code>arr = [0, 1, 2, 5, 1, 0]</code> has a peak at position <code>3</code> with a value of <code>5</code> (since <code>arr[3]</code> equals <code>5</code>).</p>
<p>The first and last elements of the array will not be considered as peaks (in the context of a mathematical function, you don't know what is after and before and therefore, you don't know if it is a peak or not).</p>
<pre><code>def pick_peaks(arr):
    print(arr)
    posPeaks = {
        "pos": [],
        "peaks": [],
    }
    startFound = False
    n = 0
    while startFound == False:
        if arr[n] == arr[n+1]:
            n += 1
        else:
            startFound = True

    endFound = False
    m = len(arr) - 1
    while endFound == False:
        if arr[m] == arr[m-1]:
            m -= 1
        else:
            endFound = True

    for i in range(n+1, m):
        if arr[i] == arr[i-1]:
            None
        elif arr[i] &gt;= arr[i-1] and arr[i] &gt;= arr[i+1]:
            posPeaks["pos"].append(i)
            posPeaks["peaks"].append(arr[i])

    return posPeaks
</code></pre>
<p>My issue is with plateaus. <code>[1, 2, 2, 2, 1]</code> has a peak while <code>[1, 2, 2, 2, 3]</code> does not. When a plateau is a peak, the first position of the plateau is recorded.</p>
<p>Any help is appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>I suggest you use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">groupby</a> to group contiguous equal values, then for each group store the first position, example for <code>[1, 2, 2, 2, 1]</code> it creates the following list following list of tuples <code>[(1, 0), (2, 1), (1, 4)]</code>, putting all together:</p>
<pre><code>from itertools import groupby


def peaks(data):
    start = 0
    sequence = []
    for key, group in groupby(data):
        sequence.append((key, start))
        start += sum(1 for _ in group)

    for (b, bi), (m, mi), (a, ai) in zip(sequence, sequence[1:], sequence[2:]):
        if b &lt; m and a &lt; m:
            yield m, mi


print(list(peaks([0, 1, 2, 5, 1, 0])))
print(list(peaks([1, 2, 2, 2, 1])))
print(list(peaks([1, 2, 2, 2, 3])))
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[(5, 3)]
[(2, 1)]
[]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the same algorithm with the plateaus as well if you can preprocess the data to remove the repeating numbers and keep only 1 unique number. Thus, you can convert the example <code>[1, 2, 2, 2, 1]</code> to <code>[1, 2, 1]</code> and apply the same algorithm.</p>
<p>Edit:
The Code:</p>
<pre><code>from itertools import groupby

def process_data(data):
    return [list(val for num in group) for val, group in groupby(data)]


def peaks(arr):
    #print(arr)
    posPeaks = {
    "pos": [],
    "peaks": [],
    }
    startFound = False
    n = 0
    while startFound == False:
        if arr[n][0] == arr[n+1][0]:
            n += 1
        else:
            startFound = True

    endFound = False
    m = len(arr) - 1
    while endFound == False:
        if arr[m][0] == arr[m-1][0]:
            m -= 1
        else:
            endFound = True

    for i in range(n+1, m):
        if arr[i][0] == arr[i-1][0]:
            None
        elif arr[i][0] &gt;= arr[i-1][0] and arr[i][0] &gt;= arr[i+1][0]:
            pos = sum([len(arr[idx]) for idx in range(i)])
            posPeaks["pos"].append(pos) #.append(i)
            posPeaks["peaks"].append(arr[i][0])
    return posPeaks



print(peaks(process_data([0, 1, 2, 5, 1, 0])))
print(peaks(process_data([1, 2, 2, 2, 1])))
print(peaks(process_data([1, 2, 2, 2, 3])))
</code></pre>
<p>Output:</p>
<pre><code>{'pos': [3], 'peaks': [5]}
{'pos': [1], 'peaks': [2]}
{'pos': [], 'peaks': []}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a fairly simple generator function. Just loop and maintain the necessary state: <code>i</code> (last index of of "growth"), <code>up</code> (true if last value change was "growth")</p>
<pre><code>def peaks(ar):
    i, up = 0, False
    for j in range(1, len(ar)):
        prev, val = ar[j-1], ar[j]
        if up and val &lt; prev:
            yield prev, i
            up = False
        if val &gt; prev:
            i, up = j, True

&gt;&gt;&gt; list(peaks([0,1,2,5,1,0]))
[(5, 3)]
&gt;&gt;&gt; list(peaks([0,1,2,5,1,2,0]))
[(5, 3), (2, 5)]
&gt;&gt;&gt; list(peaks([0,1,2,5,1,2,0,3]))
[(5, 3), (2, 5)]
&gt;&gt;&gt; list(peaks([1,2,2,2,1]))
[(2, 1)]
&gt;&gt;&gt; list(peaks([1,2,2,2,3]))
[]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A shorter script could be: </p>
<pre><code>data_array = [1, 2, 5, 4, 6, 9]
# Delete the first and the last element of the data array. 
reduced_array = [ data_array[i] for i in range(1, len(data_array)-1) ]
# Find the maximum value of the modified array 
peak_value = max(reduced_array)
# Print out the maximum value and its index in the data array. 
print 'The peak value is: ' + str(peak_value)
print 'And its position is: ' + str(data_array.index(peak_value))
</code></pre>
<p><strong>Output:</strong> </p>
<pre><code>The peak value is: 6
And its position is: 4
</code></pre>
</div>
<span class="comment-copy">In your first example of a plateau, the value of the plateau is 2, but what is its position?</span>
<span class="comment-copy">@quamrana ah yes I forgot to add this, When a plateau is a peak, the first position of the plateau is used.</span>
<span class="comment-copy">some points 1. the [] creates lists, not arrays. 2. use list comprehension, maps... instead of for/while loops as much as possible 3. look for enumerat and argmax functions</span>
<span class="comment-copy">Won't this mess up finding the position of the later peaks?</span>
<span class="comment-copy">Yes, it will. In that case you can create a list of list of numbers. For example: <code>[1, 2, 2, 2, 1]</code> as <code>[[1], [2, 2, 2], [1]]</code>. Modify your code to check only the first element of each list in the list. So in this case your loop will iterate over 1,2 and 1. While returning the position you can return the index position by using the length of each list.</span>
<span class="comment-copy">See the edited post for preserving the index using the same code with little modifications.</span>
