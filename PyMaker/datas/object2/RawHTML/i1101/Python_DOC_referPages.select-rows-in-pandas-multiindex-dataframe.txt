<div class="post-text" itemprop="text">
<h3>Objective and Motivation</h3>
<p>The <code>MultiIndex</code> API has been gaining popularity over the years, however, not everything about it is fully understood in terms of the structure, working, and associated operations. </p>
<p>One important operation is <em>filtering</em>. Filtering is a common requirement, but the use cases are diverse. Accordingly, certain methods and functions will be more applicable to some use cases than others. </p>
<p>In summary, the aim of this post is to touch upon some common filtering problems and use cases, demonstrate various different methods to solve these problems, and discuss their applicability. Some of the high-level questions this post seeks to address are</p>
<ul>
<li>Slicing based on a single value/label</li>
<li>Slicing based on multiple labels from one or more levels</li>
<li>Filtering on boolean conditions and expressions</li>
<li>Which methods are applicable in what circumstances</li>
</ul>
<p>These problems have been broken down into 6 concrete questions, enumerated below. For simplicity, the example DataFrames in the setup below only have two levels, and do not have duplicate index keys. Most solutions presented to the problems can generalize to N levels. </p>
<p>This post will <em>not</em> go through how to create MultiIndexes, how to perform assignment operations on them, or any performance related discussions (these are separate topics for another time). </p>
<hr/>
<h3>Questions</h3>
<blockquote>
<p>Question 1-6 will be asked in context to the setup below.</p>
<pre><code>mux = pd.MultiIndex.from_arrays([
    list('aaaabbbbbccddddd'),
    list('tuvwtuvwtuvwtuvw')
], names=['one', 'two'])

df = pd.DataFrame({'col': np.arange(len(mux))}, mux)

         col
one two     
a   t      0
    u      1
    v      2
    w      3
b   t      4
    u      5
    v      6
    w      7
    t      8
c   u      9
    v     10
d   w     11
    t     12
    u     13
    v     14
    w     15
</code></pre>
</blockquote>
<p><strong>Question 1:</strong> Selecting a Single Item<br/>
How do I select rows having "a" in level "one"? </p>
<pre><code>         col
one two     
a   t      0
    u      1
    v      2
    w      3
</code></pre>
<p>Additionally, how would I be able to drop level "one" in the output?</p>
<pre><code>     col
two     
t      0
u      1
v      2
w      3
</code></pre>
<p><strong>Question 1b</strong><br/>
How do I slice all rows with value "t" on level "two"?</p>
<pre><code>         col
one two     
a   t      0
b   t      4
    t      8
d   t     12
</code></pre>
<p><strong>Question 2:</strong> Selecting Multiple Values in a Level<br/>
How can I select rows corresponding to items "b" and "d" in level "one"?</p>
<pre><code>         col
one two     
b   t      4
    u      5
    v      6
    w      7
    t      8
d   w     11
    t     12
    u     13
    v     14
    w     15
</code></pre>
<p><strong>Question 2b</strong><br/>
How would I get all values corresponding to "t" and "w" in level "two"?</p>
<pre><code>         col
one two     
a   t      0
    w      3
b   t      4
    w      7
    t      8
d   w     11
    t     12
    w     15
</code></pre>
<p><strong>Question 3:</strong> Slicing a Single Cross Section <code>(x, y)</code><br/>
How do I retrieve a cross section, i.e., a single row having a specific values for the index from <code>df</code>? Specifically, how do I retrieve the cross section of <code>('c', 'u')</code>, given by</p>
<pre><code>         col
one two     
c   u      9
</code></pre>
<p><strong>Question 4:</strong> Slicing Multiple Cross Sections <code>[(a, b), (c, d), ...]</code><br/>
How do I select the two rows corresponding to <code>('c', 'u')</code>, and <code>('a', 'w')</code>?</p>
<pre><code>         col
one two     
c   u      9
a   w      3
</code></pre>
<p><strong>Question 5:</strong> One Item Sliced per Level<br/>
How can I retrieve all rows corresponding to "a" in level "one" and "u" in level "two"?</p>
<pre><code>         col
one two     
a   t      0
    u      1
    v      2
    w      3
b   t      4
    t      8
d   t     12
</code></pre>
<p><strong>Question 6:</strong> Arbitrary Slicing<br/>
How can I slice specific cross sections? For "a" and "b", I would like to select all rows with sub-levels "u" and "v", and for "d", I would like to select rows with sub-level "w".</p>
<pre><code>         col
one two     
a   u      1
    v      2
b   u      5
    v      6
d   w     11
    w     15
</code></pre>
<blockquote>
<p>Question 7 will use a unique setup consisting of a numeric level:</p>
<pre><code>np.random.seed(0)
mux2 = pd.MultiIndex.from_arrays([
    list('aaaabbbbbccddddd'),
    np.random.choice(10, size=16)
], names=['one', 'two'])

df2 = pd.DataFrame({'col': np.arange(len(mux2))}, mux2)

         col
one two     
a   5      0
    0      1
    3      2
    3      3
b   7      4
    9      5
    3      6
    5      7
    2      8
c   4      9
    7     10
d   6     11
    8     12
    8     13
    1     14
    6     15
</code></pre>
</blockquote>
<p><strong>Question 7:</strong> Inequality-based filtering on Numeric Levels<br/>
How do I get all rows where values in level "two" are greater than 5?</p>
<pre><code>         col
one two     
b   7      4
    9      5
c   7     10
d   6     11
    8     12
    8     13
    6     15
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h3><a href="https://pandas.pydata.org/pandas-docs/stable/advanced.html#multiindex-advanced-indexing" rel="noreferrer">MultiIndex / Advanced Indexing</a></h3>
<blockquote>
<p><strong>Note</strong><br/>
  This post will be structured in the following manner: </p>
<ol>
<li>The questions put forth in the OP will be addressed, one by one</li>
<li>For each question, one or more methods applicable to solving this problem and getting the expected result will be demonstrated.</li>
</ol>
<p><strong>Note</strong>s (much like this one) will be included for readers interested in learning about additional functionality, implementation details,
  and other info cursory to the topic at hand. These notes have been
  compiled through scouring the docs and uncovering various obscure
  features, and from my own (admittedly limited) experience.</p>
<p>All code samples have created and tested on <strong>pandas v0.23.4, python3.7</strong>. If something is not clear, or factually incorrect, or if you did not
  find a solution applicable to your use case, please feel free to
  suggest an edit, request clarification in the comments, or open a new
  question, ....as applicable.</p>
</blockquote>
<p>Here is an introduction to some common idioms (henceforth referred to as the Four Idioms) we will be frequently re-visiting</p>
<ol>
<li><p><em><a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.loc.html" rel="noreferrer"><code>DataFrame.loc</code></a></em> - A general solution for selection by label (+ <em><a href="https://pandas.pydata.org/pandas-docs/version/0.23.4/generated/pandas.IndexSlice.html" rel="noreferrer"><code>pd.IndexSlice</code></a></em> for more complex applications involving slices) </p></li>
<li><p><em><a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.xs.html" rel="noreferrer"><code>DataFrame.xs</code></a></em> - Extract a particular cross section from a Series/DataFrame.</p></li>
<li><p><em><a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.query.html" rel="noreferrer"><code>DataFrame.query</code></a></em> - Specify slicing and/or filtering operations dynamically (i.e., as an expression that is evaluated dynamically. Is more applicable to some scenarios than others. Also see <a href="https://pandas.pydata.org/pandas-docs/stable/indexing.html#multiindex-query-syntax" rel="noreferrer">this section of the docs</a> for querying on MultiIndexes.</p></li>
<li><p>Boolean indexing with a mask generated using <em><a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.MultiIndex.get_level_values.html" rel="noreferrer"><code>MultiIndex.get_level_values</code></a></em> (often in conjunction with <em><a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Index.isin.html" rel="noreferrer"><code>Index.isin</code></a></em>, especially when filtering with multiple values). This is also quite useful in some circumstances.</p></li>
</ol>
<p>It will be beneficial to look at the various slicing and filtering problems in terms of the Four Idioms to gain a better understanding what can be applied to a given situation. It is very important to understand that not all of the idioms will work equally well (if at all) in every circumstance. If an idiom has not been listed as a potential solution to a problem below, that means that idiom cannot be applied to that problem effectively.</p>
<hr/>
<blockquote>
<h3>Question 1</h3>
<p>How do I select rows having "a" in level "one"? </p>
<pre><code>         col
one two     
a   t      0
    u      1
    v      2
    w      3
</code></pre>
</blockquote>
<p>You can use <code>loc</code>, as a general purpose solution applicable to most situations:</p>
<pre><code>df.loc[['a']]
</code></pre>
<p>At this point, if you get</p>
<pre><code>TypeError: Expected tuple, got str
</code></pre>
<p>That means you're using an older version of pandas. Consider upgrading! Otherwise, use <code>df.loc[('a', slice(None)), :]</code>.</p>
<p>Alternatively, you can use <code>xs</code> here, since we are extracting a single cross section. Note the <code>levels</code> and <code>axis</code> arguments (reasonable defaults can be assumed here). </p>
<pre><code>df.xs('a', level=0, axis=0, drop_level=False)
# df.xs('a', drop_level=False)
</code></pre>
<p>Here, the <code>drop_level=False</code> argument is needed to prevent <code>xs</code> from dropping level "one" in the result (the level we sliced on).</p>
<p>Yet another option here is using <code>query</code>:</p>
<pre><code>df.query("one == 'a'")
</code></pre>
<p>If the index did not have a name, you would need to change your query string to be <code>"ilevel_0 == 'a'"</code>.</p>
<p>Finally, using <code>get_level_values</code>:</p>
<pre><code>df[df.index.get_level_values('one') == 'a']
# If your levels are unnamed, or if you need to select by position (not label),
# df[df.index.get_level_values(0) == 'a']
</code></pre>
<blockquote>
<p>Additionally, how would I be able to drop level "one" in the output?</p>
<pre><code>     col
two     
t      0
u      1
v      2
w      3
</code></pre>
</blockquote>
<p>This can be <em>easily</em> done using either</p>
<pre><code>df.loc['a'] # Notice the single string argument instead the list.
</code></pre>
<p>Or,</p>
<pre><code>df.xs('a', level=0, axis=0, drop_level=True)
# df.xs('a')
</code></pre>
<p>Notice that we can omit the <code>drop_level</code> argument (it is assumed to be <code>True</code> by default).</p>
<blockquote>
<p><strong>Note</strong><br/>
  You may notice that a filtered DataFrame may still have all the levels, even if they do not show when printing the DataFrame out. For example,</p>
<pre><code>v = df.loc[['a']]
print(v)
         col
one two     
a   t      0
    u      1
    v      2
    w      3

print(v.index)
MultiIndex(levels=[['a', 'b', 'c', 'd'], ['t', 'u', 'v', 'w']],
           labels=[[0, 0, 0, 0], [0, 1, 2, 3]],
           names=['one', 'two'])
</code></pre>
<p>You can get rid of these levels using <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.MultiIndex.remove_unused_levels.html" rel="noreferrer"><em><code>MultiIndex.remove_unused_levels</code></em></a>:</p>
<pre><code>v.index = v.index.remove_unused_levels()

print(v.index)
MultiIndex(levels=[['a'], ['t', 'u', 'v', 'w']],
           labels=[[0, 0, 0, 0], [0, 1, 2, 3]],
           names=['one', 'two'])
</code></pre>
</blockquote>
<hr/>
<blockquote>
<h3>Question 1b</h3>
<p>How do I slice all rows with value "t" on level "two"?</p>
<pre><code>         col
one two     
a   t      0
b   t      4
    t      8
d   t     12
</code></pre>
</blockquote>
<p>Intuitively, you would want something involving <a href="https://docs.python.org/3/library/functions.html#slice" rel="noreferrer"><em><code>slice()</code></em></a>: </p>
<pre><code>df.loc[(slice(None), 't'), :]
</code></pre>
<p>It Just Works!™ But it is clunky. We can facilitate a more natural slicing syntax using the <code>pd.IndexSlice</code> API here.</p>
<pre><code>idx = pd.IndexSlice
df.loc[idx[:, 't'], :]
</code></pre>
<p>This is much, much cleaner.</p>
<blockquote>
<p><strong>Note</strong><br/>
  Why is the trailing slice <code>:</code> across the columns required? This is because, <code>loc</code> can be used to select and slice along both axes (<code>axis=0</code> or
  <code>axis=1</code>). Without explicitly making it clear which axis the slicing
  is to be done on, the operation becomes ambiguous. See the big red box in the <a href="http://pandas.pydata.org/pandas-docs/stable/advanced.html#using-slicers" rel="noreferrer">documentation on slicing</a>.</p>
<p>If you want to remove any shade of ambiguity, <code>loc</code> accepts an <code>axis</code>
  parameter:</p>
<pre><code>df.loc(axis=0)[pd.IndexSlice[:, 't']]
</code></pre>
<p>Without the <code>axis</code> parameter (i.e., just by doing <code>df.loc[pd.IndexSlice[:, 't']]</code>), slicing is assumed to be on the columns,
  and a <code>KeyError</code> will be raised in this circumstance. </p>
<p>This is documented in <a href="https://pandas.pydata.org/pandas-docs/stable/advanced.html#using-slicers" rel="noreferrer">slicers</a>. For the purpose of this post, however, we will explicitly specify all axes.    </p>
</blockquote>
<p>With <code>xs</code>, it is </p>
<pre><code>df.xs('t', axis=0, level=1, drop_level=False)
</code></pre>
<p>With <code>query</code>, it is </p>
<pre><code>df.query("two == 't'")
# Or, if the first level has no name, 
# df.query("ilevel_1 == 't'") 
</code></pre>
<p>And finally, with <code>get_level_values</code>, you may do</p>
<pre><code>df[df.index.get_level_values('two') == 't']
# Or, to perform selection by position/integer,
# df[df.index.get_level_values(1) == 't']
</code></pre>
<p>All to the same effect.</p>
<hr/>
<blockquote>
<h3>Question 2</h3>
<p>How can I select rows corresponding to items "b" and "d" in level "one"?</p>
<pre><code>         col
one two     
b   t      4
    u      5
    v      6
    w      7
    t      8
d   w     11
    t     12
    u     13
    v     14
    w     15
</code></pre>
</blockquote>
<p>Using loc, this is done in a similar fashion by specifying a list.</p>
<pre><code>df.loc[['b', 'd']]
</code></pre>
<p>To solve the above problem of selecting "b" and "d", you can also use <code>query</code>:</p>
<pre><code>items = ['b', 'd']
df.query("one in @items")
# df.query("one == @items", parser='pandas')
# df.query("one in ['b', 'd']")
# df.query("one == ['b', 'd']", parser='pandas')
</code></pre>
<blockquote>
<p><strong>Note</strong><br/>
  Yes, the default parser is <code>'pandas'</code>, but it is important to highlight this syntax isn't conventionally python. The
  Pandas parser generates a slightly different parse tree from the
  expression. This is done to make some operations more intuitive to
  specify. For more information, please read my post on
  <a href="https://stackoverflow.com/questions/53779986/dynamic-expression-evaluation-in-pandas-using-pd-eval">Dynamic Expression Evaluation in pandas using pd.eval()</a>.</p>
</blockquote>
<p>And, with <code>get_level_values</code> + <code>Index.isin</code>:</p>
<pre><code>df[df.index.get_level_values("one").isin(['b', 'd'])]
</code></pre>
<hr/>
<blockquote>
<h3>Question 2b</h3>
<p>How would I get all values corresponding to "t" and "w" in level "two"?</p>
<pre><code>         col
one two     
a   t      0
    w      3
b   t      4
    w      7
    t      8
d   w     11
    t     12
    w     15
</code></pre>
</blockquote>
<p>With <code>loc</code>, this is possible <em>only</em> in conjuction with <code>pd.IndexSlice</code>.</p>
<pre><code>df.loc[pd.IndexSlice[:, ['t', 'w']], :] 
</code></pre>
<p>The first colon <code>:</code> in <code>pd.IndexSlice[:, ['t', 'w']]</code> means to slice across the first level. As the depth of the level being queried increases, you will need to specify more slices, one per level being sliced across. You will not need to specify more levels <em>beyond</em> the one being sliced, however. </p>
<p>With <code>query</code>, this is </p>
<pre><code>items = ['t', 'w']
df.query("two in @items")
# df.query("two == @items", parser='pandas') 
# df.query("two in ['t', 'w']")
# df.query("two == ['t', 'w']", parser='pandas')
</code></pre>
<p>With <code>get_level_values</code> and <code>Index.isin</code> (similar to above):</p>
<pre><code>df[df.index.get_level_values('two').isin(['t', 'w'])]
</code></pre>
<hr/>
<blockquote>
<h3>Question 3</h3>
<p>How do I retrieve a cross section, i.e., a single row having a specific values
  for the index from <code>df</code>? Specifically, how do I retrieve the cross
  section of <code>('c', 'u')</code>, given by</p>
<pre><code>         col
one two     
c   u      9
</code></pre>
</blockquote>
<p>Use <code>loc</code> by specifying a tuple of keys:</p>
<pre><code>df.loc[('c', 'u'), :]
</code></pre>
<p>Or,</p>
<pre><code>df.loc[pd.IndexSlice[('c', 'u')]]
</code></pre>
<blockquote>
<p><strong>Note</strong><br/>
  At this point, you may run into a <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.errors.PerformanceWarning.html#pandas-errors-performancewarning" rel="noreferrer"><em><code>PerformanceWarning</code></em></a> that looks like this:</p>
<pre><code>PerformanceWarning: indexing past lexsort depth may impact performance.
</code></pre>
<p>This just means that your index is not sorted. pandas depends on the index being sorted (in this case, lexicographically, since we are dealing with string values) for optimal search and retrieval. A quick fix would be to sort your
  DataFrame in advance using <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.sort_index.html#pandas-dataframe-sort-index" rel="noreferrer"><em><code>DataFrame.sort_index</code></em></a>. This is especially desirable from a performance standpoint if you plan on doing
  multiple such queries in tandem:</p>
<pre><code>df_sort = df.sort_index()
df_sort.loc[('c', 'u')]
</code></pre>
<p>You can also use <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.MultiIndex.is_lexsorted.html" rel="noreferrer"><em><code>MultiIndex.is_lexsorted()</code></em></a> to check whether the index
  is sorted or not. This function returns <code>True</code> or <code>False</code> accordingly.
  You can call this function to determine whether an additional sorting
  step is required or not.</p>
</blockquote>
<p>With <code>xs</code>, this is again simply passing a single tuple as the first argument, with all other arguments set to their appropriate defaults:</p>
<pre><code>df.xs(('c', 'u'))
</code></pre>
<p>With <code>query</code>, things become a bit clunky:</p>
<pre><code>df.query("one == 'c' and two == 'u'")
</code></pre>
<p>You can see now that this is going to be relatively difficult to generalize. But is still OK for this particular problem.</p>
<p>With accesses spanning multiple levels, <code>get_level_values</code> can still be used, but is not recommended:</p>
<pre><code>m1 = (df.index.get_level_values('one') == 'c')
m2 = (df.index.get_level_values('two') == 'u')
df[m1 &amp; m2]
</code></pre>
<hr/>
<blockquote>
<h3>Question 4</h3>
<p>How do I select the two rows corresponding to <code>('c', 'u')</code>, and <code>('a', 'w')</code>?</p>
<pre><code>         col
one two     
c   u      9
a   w      3
</code></pre>
</blockquote>
<p>With <code>loc</code>, this is still as simple as:</p>
<pre><code>df.loc[[('c', 'u'), ('a', 'w')]]
# df.loc[pd.IndexSlice[[('c', 'u'), ('a', 'w')]]]
</code></pre>
<p>With <code>query</code>, you will need to dynamically generate a query string by iterating over your cross sections and levels:</p>
<pre><code>cses = [('c', 'u'), ('a', 'w')]
levels = ['one', 'two']
# This is a useful check to make in advance.
assert all(len(levels) == len(cs) for cs in cses) 

query = '(' + ') or ('.join([
    ' and '.join([f"({l} == {repr(c)})" for l, c in zip(levels, cs)]) 
    for cs in cses
]) + ')'

print(query)
# ((one == 'c') and (two == 'u')) or ((one == 'a') and (two == 'w'))

df.query(query)
</code></pre>
<p>100% DO NOT RECOMMEND! But it is possible. </p>
<hr/>
<blockquote>
<h3>Question 5</h3>
<p>How can I retrieve all rows corresponding to "a" in level "one" and
  "u" in level "two"?</p>
<pre><code>         col
one two     
a   t      0
    u      1
    v      2
    w      3
b   t      4
    t      8
d   t     12
</code></pre>
</blockquote>
<p>This is actually very difficult to do with <code>loc</code> while ensuring correctness <em>and</em> still maintaining code clarity. <code>df.loc[pd.IndexSlice['a', 't']]</code> is incorrect, it is interpreted as <code>df.loc[pd.IndexSlice[('a', 't')]]</code> (i.e., selecting a cross section). You may think of a solution with <code>pd.concat</code> to handle each label separately:</p>
<pre><code>pd.concat([
    df.loc[['a'],:], df.loc[pd.IndexSlice[:, 't'],:]
])

         col
one two     
a   t      0
    u      1
    v      2
    w      3
    t      0   # Does this look right to you? No, it isn't!
b   t      4
    t      8
d   t     12
</code></pre>
<p>But you'll notice one of the rows is duplicated. This is because that row satisfied both slicing conditions, and so appeared twice. You will instead need to do</p>
<pre><code>v = pd.concat([
        df.loc[['a'],:], df.loc[pd.IndexSlice[:, 't'],:]
])
v[~v.index.duplicated()]
</code></pre>
<p>But if your DataFrame inherently contains duplicate indices (that you want), then this will not retain them. <strong>Use with extreme caution</strong>.</p>
<p>With <code>query</code>, this is stupidly simple:</p>
<pre><code>df.query("one == 'a' or two == 't'")
</code></pre>
<p>With <code>get_level_values</code>, this is still simple, but not as elegant:</p>
<pre><code>m1 = (df.index.get_level_values('one') == 'c')
m2 = (df.index.get_level_values('two') == 'u')
df[m1 | m2]
</code></pre>
<hr/>
<blockquote>
<h3>Question 6</h3>
<p>How can I slice specific cross sections? For "a" and "b", I would like to select all rows with sub-levels "u" and "v", and
  for "d", I would like to select rows with sub-level "w".</p>
<pre><code>         col
one two     
a   u      1
    v      2
b   u      5
    v      6
d   w     11
    w     15
</code></pre>
</blockquote>
<p>This is a special case that I've added to help understand the applicability of the Four Idioms—this is one case where none of them will work effectively, since the slicing is <em>very</em> specific, and does not follow any real pattern. </p>
<p>Usually, slicing problems like this will require explicitly passing a list of keys to <code>loc</code>. One way of doing this is with:</p>
<pre><code>keys = [('a', 'u'), ('a', 'v'), ('b', 'u'), ('b', 'v'), ('d', 'w')]
df.loc[keys, :]
</code></pre>
<p>If you want to save some typing, you will recognise that there is a pattern to slicing "a", "b" and its sublevels, so we can separate the slicing task into two portions and <code>concat</code> the result:</p>
<pre><code>pd.concat([
     df.loc[(('a', 'b'), ('u', 'v')), :], 
     df.loc[('d', 'w'), :]
   ], axis=0)
</code></pre>
<p>Slicing specification for "a" and "b" is slightly cleaner <code>(('a', 'b'), ('u', 'v'))</code> because the same sub-levels being indexed are the same for each level.</p>
<hr/>
<blockquote>
<h3>Question 7</h3>
<p>How do I get all rows where values in level "two" are greater than 5?</p>
<pre><code>         col
one two     
b   7      4
    9      5
c   7     10
d   6     11
    8     12
    8     13
    6     15
</code></pre>
</blockquote>
<p>This can be done using <code>query</code>,</p>
<pre><code>df2.query("two &gt; 5")
</code></pre>
<p>And <code>get_level_values</code>.</p>
<pre><code>df2[df2.index.get_level_values('two') &gt; 5]
</code></pre>
<blockquote>
<p><strong>Note</strong><br/>
  Similar to this example, we can filter based on any arbitrary condition using these constructs. In general, it is useful to remember that <code>loc</code> and <code>xs</code> are specifically for label-based indexing, while <code>query</code> and
  <code>get_level_values</code> are helpful for building general conditional masks
  for filtering.</p>
</blockquote>
<hr/>
<blockquote>
<h3>Bonus Question</h3>
<p>What if I need to slice a <code>MultiIndex</code> <em>column</em>?</p>
</blockquote>
<p>Actually, most solutions here are applicable to columns as well, with minor changes. Consider:</p>
<pre><code>np.random.seed(0)
mux3 = pd.MultiIndex.from_product([
        list('ABCD'), list('efgh')
], names=['one','two'])

df3 = pd.DataFrame(np.random.choice(10, (3, len(mux))), columns=mux3)
print(df3)

one  A           B           C           D         
two  e  f  g  h  e  f  g  h  e  f  g  h  e  f  g  h
0    5  0  3  3  7  9  3  5  2  4  7  6  8  8  1  6
1    7  7  8  1  5  9  8  9  4  3  0  3  5  0  2  3
2    8  1  3  3  3  7  0  1  9  9  0  4  7  3  2  7
</code></pre>
<p>These are the following changes you will need to make to the Four Idioms to have them working with columns.</p>
<ol>
<li><p>To slice with <code>loc</code>, use </p>
<pre><code>df3.loc[:, ....] # Notice how we slice across the index with `:`. 
</code></pre>
<p>Or,</p>
<pre><code>df3.loc[:, pd.IndexSlice[...]]
</code></pre></li>
<li><p>To use <code>xs</code> as appropriate, just pass an argument <code>axis=1</code>.</p></li>
<li><p>You can access the column level values directly with <code>df.columns.get_level_values</code>. You will then need to do something like </p>
<pre><code>df.loc[:, {condition}] 
</code></pre>
<p>Where <code>{condition}</code> represents some condition built using <code>columns.get_level_values</code>.</p></li>
<li><p>To use <code>query</code>, your only option is to transpose, query on the index, and transpose again:</p>
<pre><code>df3.T.query(...).T
</code></pre>
<p>Not recommended, use one of the other 3 options.</p></li>
</ol>
</div>
