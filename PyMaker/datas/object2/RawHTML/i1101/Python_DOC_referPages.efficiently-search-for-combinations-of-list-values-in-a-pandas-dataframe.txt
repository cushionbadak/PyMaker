<div class="post-text" itemprop="text">
<p>I'm iterating over multiple pandas data frames where on each iteration I extract 2 lists.
Then, for each 2 lists combination, I need to find the row in another Data Frame where each combination of all values in the 2 lists appears. </p>
<p>Simplified example:  </p>
<p>The df looks like this (any D_val P_val may appear only once):</p>
<pre><code>D_val | P_val | D_PCode  
A     | 1     | 25  
D     | 1     | 21  
C     | 2     | 32  
B     | 4     | 35  
D     | 2     | 126  
B     | 1     | 3  
C     | 1     | 312  
</code></pre>
<p>For a single iteration with the following lists -   </p>
<pre><code>list1 = [1,2]  
list2 = [A,B,C]  
</code></pre>
<p>I expect to get the following list:<br/>
    [25, 3, 312, 32]</p>
<p>Explanation:   </p>
<pre><code>for [A,1] - 25  
for [A,2] - nothing  
For [B,1] - 3  
</code></pre>
<p>etc.  </p>
<p>I implemented it using nested loops, but with multiple iterations, large data frame and long lists it takes far too long.  </p>
<p>Any suggestions how to efficiently implement it? I'm happy to use other data structures if needed.</p>
</div>
<div class="post-text" itemprop="text">
<p>We just using <code>isin</code> twice</p>
<pre><code>df1=df.loc[df.D_val.isin(list2)&amp;df.P_val.isin(list1)]
df1
Out[211]: 
  D_val  P_val  D_PCode
0     A      1       25
2     C      2       32
5     B      1        3
6     C      1      312
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer">itertools.product</a> to generate all possible values, then use <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.isin.html" rel="nofollow noreferrer">isin</a>:</p>
<pre><code>from itertools import product

import pandas as pd

data = [['A', 1, 25],
        ['D', 1, 21],
        ['C', 2, 32],
        ['B', 4, 35],
        ['D', 2, 126],
        ['B', 1, 3],
        ['C', 1, 312]]

df = pd.DataFrame(data=data, columns=['D_val', 'P_val', 'D_PCode'])

list1 = [1, 2]
list2 = ['A', 'B', 'C']
lookup = set(product(list2, list1))

mask = df[['D_val', 'P_val']].apply(tuple, axis=1).isin(lookup)
result = df[mask].D_PCode

print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>0     25
2     32
5      3
6    312
Name: D_PCode, dtype: int64
</code></pre>
<p>Or just use isin directly on both columns, for instance:</p>
<pre><code>list1 = [1, 2]
list2 = ['A', 'B', 'C']

result = df[df.D_val.isin(list2) &amp; df.P_val.isin(list1)].D_PCode
print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>0     25
2     32
5      3
6    312
Name: D_PCode, dtype: int64
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a <code>MultiIndex</code> problem, and is best solved with <code>reindex</code>.</p>
<pre><code>df = df.set_index(['D_val', 'P_val'])
idx = pd.MultiIndex.from_product([list2, list1])

df.reindex(idx)

     D_PCode
A 1     25.0
  2      NaN
B 1      3.0
  2      NaN
C 1    312.0
  2     32.0
</code></pre>
<p>If you want a dictionary of the matches, use <code>reindex</code> + <code>Series.to_dict</code>:</p>
<pre><code>df.reindex(idx).D_PCode.to_dict()

{('A', 1): 25.0,
 ('A', 2): nan,
 ('B', 1): 3.0,
 ('B', 2): nan,
 ('C', 1): 312.0,
 ('C', 2): 32.0}
</code></pre>
<hr/>
<p>If you only want the rows that exist, use <code>intersection</code> for performantly computating the index of the intersection:</p>
<pre><code>df.loc[df.index.intersection(idx)]

     D_PCode
A 1       25
B 1        3
C 1      312
  2       32
</code></pre>
</div>
<span class="comment-copy">Since your D_P combinations are unique, you could make an index with the concatenation of D and P for that row (A1, D1, C2, etc), use <code>itertools.product</code> to get the Cartesian product of the lists, and then use that as a mask for the df. If this makes sense to you I can try expand it into an answer.</span>
