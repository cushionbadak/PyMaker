<div class="post-text" itemprop="text">
<p>I want to define a function that behaves differently depending on if it's called</p>
<pre><code>foo()
</code></pre>
<p>or assigned</p>
<pre><code>bar = foo()
</code></pre>
<p>It seems to be possible, as shown in <a href="https://stackoverflow.com/questions/813882/is-there-a-way-to-check-whether-function-output-is-assigned-to-a-variable-in-pyt">this question</a>, but the method there described throws an error:</p>
<pre><code>TypeError: ord() expected string of length 1, but int found
</code></pre>
<p>and the trivial solution to use <code>str()</code> on the <code>ord()</code> argument clearly does not work.</p>
<p>My particular reason for this is so that <code>foo()</code> creates a global variable <code>baz</code> if it's called, and does not if it's assigned.</p>
<p>After reviewing the question's answer, I decided to go with using a global "private" variable <code>_baz</code> that gets assigned anyway.</p>
</div>
<div class="post-text" itemprop="text">
<p>Ultimately, if you need two different effects for when a function's value is stored and when not, you more likely need two different functions and just document then accordingly.</p>
<p>You commented that "function is a data (file) reader. If function is called upon a filename, a global data variable is created, else it is assigned. " - no, silently creating a global variable "sometimes", is not a good design. If you want too, just create the global variable everytime. You'd be better using a global <a href="https://docs.python.org/3/library/threading.html#threading.local" rel="nofollow noreferrer">thread-local variable</a>, so that a distinct value for the variable is used in each thread. Or, if you are using async-code, a <a href="https://www.python.org/dev/peps/pep-0555/" rel="nofollow noreferrer">context-local</a> variable. Doing these would mitigate any unexpected changes to your global variable on the code expectng it to have the correct values after you call your function. And, as you can see, better yet, is just document that the function returns the read value, and leave it to the caller whether to assign that value to a global variable or not.</p>
<h1>Back to the question:</h1>
<p>Although there are far-off ways to detect if a return value is stored, it is not trivial, nor a thing expected to be done. The linked question, for example, uses advanced resources of the Python language to inspect the compiled code of the called function - this kind of resource is almost never used in code suitable for production, even in advanced library or frameworks, as its prone to be either too slow, or to break in sudden and unexpected ways. (For example, if in your production deployment, you configure some logging/traceback saving extension that would insert an a wrapper in your functions, it would mistake the callee function for the one in the framework - but just in production, not on the development machine). But more important than that, the linked code does not <em>even start</em> to check for corner cases, like, if the value is transformed prior to being stored (one might call a 'replace' method on it, or any other string method), or stored in a list or dictionary instead of in a local variable. Covering all possible use cases using that approach to the point of it being reliable is not possible at all.</p>
<p>But I am taking some time to elaborate an answer to clarify this should not be useful at all - if you understand how objects work in Python, you might find a better way to implement whatever you have in mind, without needing to know if the object is "stored" or not:</p>
<p>Any function in Python will return an object. Even if the object is "None". The fact is in Python, objects can be considered like "black boxes" until the point when they are <em>used for something</em>. When they are in fact used - not just stored in a variable, list, as a value in a dictionary, etc... when that happens, it is just a "black box" being stored, and the object can't be aware of being assigned a name or added to a list at all (maybe it is possible to code hooks in native code to check for increases in the reference counting of an object - but you'd need to do that at least in Cython if not in C - it very, very iffy, enough to say "it can't be aware").</p>
<p>But when an object is "used", that is another story. When you want to check what an object "is", even in the interactive terminal, or by printing it, the object's <code>__repr__</code> or <code>__str__</code> methods will be called. If you are making an operation with an object  - trying to add it with another object with the "+" operator, or any other operator, special methods in the object are called.</p>
<p>If you are trying to save the object state to a file, it will be serialized - that will call methods used by the pickle protocol, or even <code>__str__</code> itself, depending on the serialization used, and so on.</p>
<p>So, you can specialize a class and wrap all the desired "magic" methods, the ones defined in the <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">language Data Model</a> with names surrounded by  <code>__</code>, to perform the action you'd like to do for when the object is "not stored" for example. </p>
<p>By the way, there is even a very simple method in the object that is called if it is not stored at all after the function call: the object's <code>__del__</code> method will be called.</p>
<p>So, for simply having an effect when the object is not stored, you could dynamically create a subclass of whatever is the result of your function with a custom <code>__del__</code> method, and perform your action there. This is still code that could have some objections in a production environment, but it is much more straightforward than interpreting the opcode of the calling function. <em>But</em>, of course, if the object is stored, when it is finally deleted in a later point in the code, the <code>__del__</code> method would be triggered nonetheless. You can devise a mechanism to change an attribute in the object if <em>any other special method</em> is called before <code>__del__</code>, and if so, disable the side-effect - but as you can see, this is not trivial as well. </p>
</div>
<div class="post-text" itemprop="text">
<p>There isn't a simple way for a function to know what will be done with its result.  Writing functions that change behavior like this would be a good way to confuse people.  Better to use Python's features in a simple straightforward way.</p>
</div>
<span class="comment-copy">What is the reason of sych need?  It smells of poor design</span>
<span class="comment-copy">@Pynchia function is a data (file) reader. If function is called upon a filename, a global <code>data</code> variable is created, else it is assigned.</span>
<span class="comment-copy">I got it to work with <code>next_opcode = dis.opname[frame.f_code.co_code[frame.f_lasti + 2]]</code> -- However, given that the offset isn't constant, it seems like there could be a LOT of cases where this fails -- Consider a tuple assignment:  <code>a, b = check_status(), foo()</code>.  It also means that you'd probably need to do a little detecting to get this to work reliably across different python versions (where the bytecode may not be compatible)</span>
<span class="comment-copy">I'm interested in knowing the way there is to do it so I can decide whether to implement it in my code or not. No hard feelings.</span>
<span class="comment-copy">@mariogarcc -- If you <i>really</i> want to do something like this, I <i>think</i> you probably <i>could</i> do it via some crazy stack introspection (<a href="https://docs.python.org/3/library/inspect.html#the-interpreter-stack" rel="nofollow noreferrer">docs.python.org/3/library/inspect.html#the-interpreter-stack</a>), and then maybe some code fetching/parsing using <code>ast</code>.  It'd likely be A LOT of code that nobody would want to read or understand.  It's probably also really inefficient and as Ned points out, it makes for a really confusing API.  I wouldn't recommend trying it, but if I absolutely needed to, that's probably where I'd start looking for answers...</span>
<span class="comment-copy">@mgilson I don't know if you saw the answer I linked in my question, but somebody did something like that there. I don't know if you are referring to that, but it seems that what you are suggesting is similar to what's there described, although old (maybe the reason why it doesn't work now; I wish I could find somebody that understands that and corrects it, since correcting old code is technically easy - when there are only minor changes).</span>
