<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/49271750/is-it-possible-to-hack-pythons-print-function">Is it possible to “hack” Python's print function?</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
</ul>
</div>
<p>Before carrying on any further, I am aware that one should <em>never</em> do this. This question is purely for educational purposes; I undertook this exercise as a means of better understanding python's internals, the <code>ctypes</code>, and how they work.</p>
<p>I am aware that it is relatively easy to change the value of integers in python. Actually, there's a <a href="https://stackoverflow.com/a/49272080/4909087">whole lot you can do</a> by messing with the internals. From the <a href="https://docs.python.org/3/c-api/long.html#c.PyLong_FromLong" rel="nofollow noreferrer">C API reference</a>,</p>
<blockquote>
<p>The current implementation keeps an array of integer objects for all
  integers between -5 and 256, when you create an int in that range you
  actually just get back a reference to the existing object. So it
  should be possible to change the value of 1. I suspect the behaviour
  of Python in this case is undefined. :-)</p>
</blockquote>
<p>Considering the value of 1 is cached by CPython, it should be relatively easy (or, at least possible) to do this. After a little digging around, I found <code>ctypes</code> was the way to go. However, most of what I try results in a segfault. I got close by changing the value of 2.</p>
<pre><code>import ctypes
def deref(addr, typ):
     return ctypes.cast(addr, ctypes.POINTER(typ))

deref(id(2), ctypes.c_int)[6] = 1
</code></pre>
<p>1 + 1 now gives incorrect results (a step in the right direction), but I cannot get it to evaluate to "3":</p>
<pre><code>&gt;&gt;&gt; 1 + 1
1

&gt;&gt;&gt; 1 + 2
1

&gt;&gt;&gt; 1 + 3
[1]    61014 segmentation fault  python3.6
</code></pre>
<p>I have tried similar things ending in failure with abarnert's <a href="https://github.com/abarnert/superhackyinternals/blob/master/internals.py" rel="nofollow noreferrer"><code>internals</code></a> module. Is there any way to have <code>1 + 1</code> evaluate to <code>3</code> in python? Or is "1" so all important that there is no way of making this work without segfaulting my interpreter? </p>
</div>
<div class="post-text" itemprop="text">
<p><em>Disclaimer: this answer refers to CPython only; I might have also missed the point of the question...</em></p>
<p>I was able to (kinda) achieve this by writing a Python extension in C.</p>
<p>In <code>Objects/intobject.c</code> there is an info struct <code>PyInt_Type</code>. Its <code>tp_as_number</code> field is a table of operator functions, the <code>nb_add</code> field of which is the addition operator:</p>
<pre><code>// the function in the same file that nb_add points to
static PyObject *
int_add(PyIntObject *v, PyIntObject *w)
    ...
</code></pre>
<p><code>PyInt_Type</code> is an exposed global variable, and can be retrieved with <code>dlsym</code> in Unix / <code>GetProcAddress</code> in WinAPI:</p>
<pre><code>#include &lt;dlfcn.h&gt;

...

// symbol look-up from the Python extension
void* addr = dlsym(RTLD_DEFAULT, "PyInt_Type");

// pointer to PyInt_Type
PyTypeObject *int_type = addr;

// pointer to int_as_number (PyInt_Type.tp_as_number)
PyNumberMethods *int_funcs = int_type-&gt;tp_as_number;

// pointer to int_add (tp_as_number-&gt;nb_add)
int_add_orig = int_funcs-&gt;nb_add;

// override this with a custom function
int_funcs-&gt;nb_add = (binaryfunc)int_add_new;

...

// custom add function
PyObject *int_add_new(PyIntObject *v, PyIntObject *w)
{
    long a = PyInt_AS_LONG(v);
    long b = PyInt_AS_LONG(w);

    // 1 + 1 = 3 special case
    if (a == 1 &amp;&amp; b == 1) {
        return PyInt_FromLong(3);
    }

    // for all other cases default to the
    // original add function which was retrieved earlier
    return int_add_orig((PyObject *)v, (PyObject *)w);
}
</code></pre>
<p>By preserving all of the original code and internal variables, the new code avoids the previously experienced segfaults:</p>
<pre><code>&gt;&gt;&gt; # load the extension

&gt;&gt;&gt; import [...]

&gt;&gt;&gt; 1 + 1
2

&gt;&gt;&gt; # call the extension function which overloads the add operator

&gt;&gt;&gt; 1 + 1
3

&gt;&gt;&gt; 1 + 0
1

&gt;&gt;&gt; 1 + 2
3

&gt;&gt;&gt; 1 + 3
4
</code></pre>
</div>
<span class="comment-copy">Seems like you could have done <code>deref(id(2), ctypes.c_int)[6] = 3</code>.</span>
<span class="comment-copy">I'm voting to close this question as off-topic because once you start hacking around to this degree you can probably achieve almost anything, most of it without any purpose or use, and that's not really what we're here for.</span>
<span class="comment-copy">@LightnessRacesinOrbit Fair enough, the only purpose of this was to understand the internals is all :-)</span>
<span class="comment-copy">It's undefined behavior. Of course it's undefined behavior. How could you expect anything else when you're messing with the value of 2? The specific way the undefined behavior manifests in my tests is that a <code>write</code> call that writes 2 characters returns 2, except that the 2 object has value 3, and 3 is more characters than should have been printed.</span>
<span class="comment-copy">@Prune I understand. I recall a similar question being asked in java before which was received well, so I assumed this would be fine as long as it was treated as a pedagogic tool for understanding the internals. Happy to go with the community's vote, however</span>
<span class="comment-copy">I like the approach you've taken to answer this question! While this isn't originally what I had in mind when I posted the question, it's cool to know how to do this by actually modifying the source code.</span>
<span class="comment-copy">@coldspeed well not quite modifying Python's source code (the goal was to avoid doing so directly – because it make this problem conceptually trivial :D ) but its internal state variables at runtime (no different to your attempt with <code>deref</code>).</span>
<span class="comment-copy">Yes, I see, this uses the C API to write an extension. I am still digesting this, excuse my ignorance :)</span>
