<div class="post-text" itemprop="text">
<p>For example, say that I have a list in which the the index of the list is a particular cell number and the value for that index is the temperature of that particular cell. Let’s say that the list looks like this:</p>
<pre><code>fine_mesh = [600,625,650,675,700,725,750,775,800,825]
</code></pre>
<p>Then, let’s say that we want to create a coarser mesh, by reducing the number of cells in the mesh by a factor of 2, so we want to take the average temperature of sequential groups of two cells. The factor  that the finer mesh is reduced to a coarser mesh by could be any number though. </p>
<p>So in this example case,</p>
<pre><code>coarse_mesh = [612.5,662.5,712.5,762.5,812.5]
</code></pre>
<p>What is the fastest way to do this with python? Speed matters because there could be hundreds of thousands of cells. It is OK to use open source libraries like numpy. </p>
<p>Thanks in advance! :)</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>numpy</code> you can vectorize addition (and multiplication, etc) and you can use slices so you can do the following</p>
<pre><code>import numpy as np
# ... snip ...
fine_mesh = np.array(fine_mesh)
coarse_mesh = 0.5 * (fine_mesh[::2] + fine_mesh[1::2])
</code></pre>
<p>Since it's <code>numpy</code> it'll likely be quicker than a list comprehension. </p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehension</a>:</p>
<pre><code>fine_mesh=[600,625,650,675,700,725,750,775,800,825]
coarse_mesh = [(a + b) / 2 for a, b in  zip(fine_mesh[::2], fine_mesh[1::2])]
print(coarse_mesh)
</code></pre>
<p>Or if you prefer <code>numpy</code>, you could use <a href="https://docs.scipy.org/doc/numpy-1.15.1/reference/generated/numpy.mean.html" rel="nofollow noreferrer">numpy.mean</a>:</p>
<pre><code>import numpy as np

fine_mesh=[600,625,650,675,700,725,750,775,800,825]
coarse_mesh = np.mean(np.array(fine_mesh).reshape(-1, 2), 1)
print(coarse_mesh.tolist())
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[612.5, 662.5, 712.5, 762.5, 812.5]
</code></pre>
</div>
<span class="comment-copy">It's effectively the same as resizing an image, isn't it? Or is it purely 1-dimensional along the rows? You could maybe leverage an OpenCV SIMD-optimised function.</span>
<span class="comment-copy">It is effectively the same as resizing  an image. The cells will be 3 dimensional. The list will describe temperature information for each of the cells.</span>
<span class="comment-copy">Using the timeit function I found that your suggestion solution with numpy was faster than Daniel's suggested solution with numpy. I appreciate both of you for taking the time to answer!</span>
