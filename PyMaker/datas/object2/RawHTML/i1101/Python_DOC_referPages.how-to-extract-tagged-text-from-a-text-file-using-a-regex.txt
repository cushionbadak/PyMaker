<div class="post-text" itemprop="text">
<p>For a class, I need to extract everything that comes between the element <code>&lt;seg&gt;</code> ... <code>&lt;/seg&gt;</code> and I'm trying to do this via Python instead of wasting hours doing this by hand (it's well over 400 lines). What I have right now in ways of code is this (a code that I found online and changed a little so that it doesn't print the line number): </p>
<pre><code>import re                           
err_occur = [] 
pattern = re.compile(r"&lt;seg&gt;(.*)&lt;/seg&gt;")
try:
    with open ('corpus.txt', 'rt') as in_file:
        for linenum, line in enumerate(in_file):
            if pattern.search(line) != None:
                err_occur.append((linenum, line.rstrip('\n')))
        for linenum, line in err_occur:
            print(line, sep='')
except FileNotFoundError:
    print("Input file not found.")
</code></pre>
<p>The only problem I have with this is that it prints the <code>&lt;seg&gt;</code> and <code>&lt;/seg&gt;</code> in the results, which I don't want to happen. I've tried to create groups (which you can see in my usage of parentheses in the pattern variable) but I have no idea how to manipulate the code to return just group 1 (I've tried many different ways). </p>
</div>
<div class="post-text" itemprop="text">
<p>Here's something that will print all the tagged text in each line without the tags:</p>
<p>The important modification was changing your regex from <code>(r"&lt;seg&gt;(.*)&lt;/seg&gt;"</code> to <code>r"&lt;seg&gt;(.*?)&lt;/seg&gt;"</code>—note the added <code>?</code> after the <code>*</code>. This is called making it "non-greedy" so it <em>doesn't</em> match as much of the remaining text as possible (the default "greedy" mode). This is discussed in greater detail in the <a href="https://docs.python.org/3/howto/regex.html#greedy-versus-non-greedy" rel="nofollow noreferrer">Regular Expression HOWTO</a> section of Python's online documentation.</p>
<p>Another significant change, regex-wise, was to use <a href="https://docs.python.org/3/library/re.html#re.Pattern.findall" rel="nofollow noreferrer"><code>pattern.findall()</code></a> <em>instead</em> of <a href="https://docs.python.org/3/library/re.html#re.Pattern.search" rel="nofollow noreferrer"><code>pattern.search()</code></a>.</p>
<p>I also removed all the parts of the code dealing with line numbers since you mentioned you weren't interest in that information.</p>
<pre><code>import re

err_occur = []
pattern = re.compile(r"&lt;seg&gt;(.*?)&lt;/seg&gt;")
input_filename = 'corpus.txt'

try:
    with open(input_filename, 'rt') as in_file:
        for line in in_file:
            matches = pattern.findall(line)
            if matches:
                for match in matches:
                    err_occur.append(match)
except FileNotFoundError:
    print("Input file %r not found." % input_filename)

for tagged in err_occur:
    print(tagged)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to use <code>positive lookbehind</code> and a <code>positive lookahead</code>. The <code>&lt;seg&gt;</code> and <code>&lt;\seg&gt;</code> in your regex consumes some text so you see them in your results, but the lookahead and lookbehind just checks if <code>&lt;/seg&gt;</code> and <code>&lt;seg&gt;</code> are there respectively without consuming any characters. It only matches those strings.</p>
<p><strong>Tl;dr:</strong>  lookahead and lookbehind matches <strong>string</strong> in 
<code>&lt;seg&gt;string&lt;/seg&gt;</code> and not the tags.</p>
<p>So your regex should be like <code>(?&lt;=&lt;seg&gt;).*(?=&lt;/seg&gt;)</code>, this should be fine.</p>
<p>There is some documantation <a href="https://docs.python.org/2/library/re.html" rel="nofollow noreferrer">here</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use BeautifulSoup for this.</p>
<pre><code>soup = BeautifulSoup(your input)
print soup.findAll("seg")[0].renderContents()
</code></pre>
<p>Also the regex can be:</p>
<pre><code>import re
print re.findall("&lt;seg&gt;(.*?)&lt;/seg&gt;", your input)
</code></pre>
<p><a href="http://tpcg.io/B6h2So" rel="nofollow noreferrer">http://tpcg.io/B6h2So</a></p>
</div>
<span class="comment-copy">What is group 1?</span>
<span class="comment-copy">Can you give an example input and expected output?</span>
<span class="comment-copy">Sometime back i also asked the question on the same lines. <a href="https://stackoverflow.com/questions/44851040/python-identify-the-missing-character-and-replace-with-na" title="python identify the missing character and replace with na">stackoverflow.com/questions/44851040/…</a>. If this helps let us know, otherwise please post a sample of text file and will come up with a answer for you.</span>
<span class="comment-copy">My input would be something like "... &lt;seg&gt; Hello world. &lt;/seg&gt;" and my expected output is "Hello World" without the &lt;seg&gt; elements. I see that my question got a little messed up formatting wise, whoops!</span>
<span class="comment-copy">If you're going to be doing this a lot you could take a look at the <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/" rel="nofollow noreferrer">BeautifulSoup</a> library.</span>
<span class="comment-copy">Thank you so much, this worked perfectly!</span>
<span class="comment-copy">Arie G.: Good to hear. Note the limitation that the tagged text <i>within</i> a single line—which means that tagged text that spans multiple lines won't be detected. Fixing that requires a slightly different approach.</span>
<span class="comment-copy">I tried your suggestion and it's still showing the &lt;seg&gt; opening and closing elements, so the results are all &lt;seg&gt;string&lt;/seg&gt; instead of just the string</span>
<span class="comment-copy">can you share some of the documents you are trying to filter, ArieG</span>
<span class="comment-copy">For example, this is part of the XML/TXT document:  &lt;seg&gt;ben on attend on attend qui normalement &lt;/seg&gt; &lt;/u&gt; &lt;/annotationBlock&gt; &lt;annotationBlock end="#T2" start="#T1" who="spk2" xml:id="au1"&gt; &lt;u&gt; &lt;seg&gt;ben ¤P1¤ &lt;/seg&gt; &lt;/u&gt; &lt;/annotationBlock&gt; &lt;annotationBlock end="#T3" start="#T2" who="spk4" xml:id="au2"&gt; &lt;u&gt; &lt;seg&gt;non &lt;/seg&gt; &lt;/u&gt; &lt;/annotationBlock&gt; &lt;annotationBlock end="#T4" start="#T3" who="spk3" xml:id="au3"&gt; &lt;u&gt; &lt;seg&gt;/tu les as eu(e)s,***/ &lt;/seg&gt; &lt;/u&gt; &lt;/annotationBlock&gt; --I'm trying to get just the text in between &lt;seg&gt;</span>
