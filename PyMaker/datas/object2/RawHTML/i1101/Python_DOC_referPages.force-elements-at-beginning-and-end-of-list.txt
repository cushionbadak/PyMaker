<div class="post-text" itemprop="text">
<p>How can I modify this list so that all <code>p's</code> appear at the beginning, the <code>q's</code> at the end, and the values in between are sorted alphabetically?</p>
<pre><code>l = ['f','g','p','a','p','c','b','q','z','n','d','t','q']
</code></pre>
<p>So I would like to have:</p>
<pre><code>['p','p','a','b','c','d','f','g','n','t','z','q','q']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/howto/sorting.html" rel="noreferrer"><code>sorted</code></a> with the following <code>key</code>:</p>
<pre><code>sorted(l, key = lambda s: (s!='p', s=='q', s))
['p', 'p', 'a', 'b', 'c', 'd', 'f', 'g', 'n', 't', 'z', 'q', 'q']
</code></pre>
<hr/>
<p><b>Explanation </b></p>
<p>To get a better idea of how this is working, the following list comprehension aims to replicate what is being returned from the <code>lambda</code> function defined in the <code>key</code> argument prior to making comparisons:</p>
<pre><code>t = [(s!='p', s=='q', s) for s in pl]

print(t)
[(True, False, 'f'),
 (True, False, 'g'),
 (False, False, 'p'),
 (True, False, 'a'),
 (False, False, 'p'),
 (True, False, 'c'),
 (True, False, 'b'),
 (True, True, 'q'),
 (True, False, 'z'),
 (True, False, 'n'),
 (True, False, 'd'),
 (True, False, 't'),
 (True, True, 'q')]
</code></pre>
<p>This will then be the <code>key</code> to be used to sort the items in the list, as mentioned in the <a href="https://docs.python.org/3/howto/sorting.html" rel="noreferrer">documentation</a>:</p>
<blockquote>
<p>The value of the key parameter should be a function that takes a single argument and returns a key to use for sorting purposes. </p>
</blockquote>
<p>So taking into account that <code>False = 0</code> and <code>True = 1</code>, when this list of tuples is sorted the result will be the following:</p>
<pre><code>sorted(t)
[(False, False, 'p'),
 (False, False, 'p'),
 (True, False, 'a'),
 (True, False, 'b'),
 (True, False, 'c'),
 (True, False, 'd'),
 (True, False, 'f'),
 (True, False, 'g'),
 (True, False, 'n'),
 (True, False, 't'),
 (True, False, 'z'),
 (True, True, 'q'),
 (True, True, 'q')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One idea is to use a priority dictionary with a custom function. This is naturally extendable should you wish to include additional criteria.</p>
<pre><code>L = ['f','g','p','a','p','c','b','q','z','n','d','t','q']

def sort_func(x):
    priority = {'p': 0, 'q': 2}
    return priority.get(x, 1), x

res = sorted(L, key=sort_func)

print(res)

['p', 'p', 'a', 'b', 'c', 'd', 'f', 'g', 'n', 't', 'z', 'q', 'q']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the <code>key</code> parameter in <a href="https://docs.python.org/3/library/functions.html#sorted" rel="noreferrer">sorted</a>:</p>
<pre><code>l = ['f','g','p','a','p','c','b','q','z','n','d','t','q']

def key(c):
    if c == 'q':
        return (2, c)
    elif c == 'p':
        return (0, c)
    return (1, c)


result = sorted(l, key=key)
print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>['p', 'p', 'a', 'b', 'c', 'd', 'f', 'g', 'n', 't', 'z', 'q', 'q']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just define an appropriate key function:</p>
<pre><code>&gt;&gt;&gt; def _key(x):
...     if x == 'p':
...         return -1
...     elif x == 'q':
...         return float('inf')
...     else:
...         return ord(x)
...
&gt;&gt;&gt; l = ['f','g','p','a','p','c','b','q','z','n','d','t','q']
&gt;&gt;&gt; sorted(l, key=_key)
['p', 'p', 'a', 'b', 'c', 'd', 'f', 'g', 'n', 't', 'z', 'q', 'q']
</code></pre>
<p>Note, every character is mapped to an integer &gt;= 0, so we can just rely on <code>ord</code>, and since <code>-1</code> will always be less than anything returned by <code>ord</code>, we can use that for p, and for q, we can use infinity, so it will be alway greater than something returned by <code>ord</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can find all <code>p</code> and <code>q</code> elements, filter the original list, and then sort:</p>
<pre><code>l = ['f','g','p','a','p','c','b','q','z','n','d','t','q']
_ps, _qs = [i for i in l if i == 'p'], [i for i in l if i == 'q']
new_l = _ps+sorted(filter(lambda x:x not in {'q', 'p'}, l))+_qs
</code></pre>
<p>Output:</p>
<pre><code>['p', 'p', 'a', 'b', 'c', 'd', 'f', 'g', 'n', 't', 'z', 'q', 'q']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could also store you front, middle and ends in a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict()</code></a>, then just add all three lists at the end:</p>
<pre><code>from collections import defaultdict

l = ["f", "g", "p", "a", "p", "c", "b", "q", "z", "n", "d", "t", "q"]

keys = {"p": "front", "q": "end"}

d = defaultdict(list)
for item in l:
    d[keys.get(item, "middle")].append(item)

print(d["front"] + sorted(d["middle"]) + d["end"])
# ['p', 'p', 'a', 'b', 'c', 'd', 'f', 'g', 'n', 't', 'z', 'q', 'q']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Solution to this question is:</p>
<ol>
<li>First find all p and q elements in list.</li>
<li>Filter the original list. </li>
<li>Then, finally sort the list.</li>
</ol>
<hr/>
<pre><code>list = ['f','g','p','a','p','c','b','q','z','n','d','t','q'];
noOfPs = [i for i in l if i == 'p']; 
noOfQs = [i for i in l if i == 'q'];
resultList= noOfPs + sorted(filter(lambda x:x not in {'q', 'p'}, l))+ noOfQs 
</code></pre>
</div>
<span class="comment-copy">What have you tried that didn't work ?</span>
<span class="comment-copy">Well I though of somehow sorting those items that anen't in <code>['p','q']</code>, and then adding as many <code>p</code> and <code>q</code> as I found at the beginning and end. But thought that it could be done in a much easier way as it is clear now</span>
<span class="comment-copy">Now, this is pretty cool.  Can you explain a bit?   sorted sorts True &lt; characters  &lt; False?</span>
<span class="comment-copy">@ScottBoston no, it returns a (bool, bool, str) tuple</span>
<span class="comment-copy">So (False, False) comes first and (True,True) in the end. In between there will be (True,False)</span>
<span class="comment-copy">@nixon Ah!!! The light bulb just turned on.  Great!</span>
<span class="comment-copy">For those of you who need this <code>sorted([(s!='p', s=='q', s) for s in l])</code> is a great visual of what is going on.</span>
<span class="comment-copy"><i>If</i> you're going to do it this way, you can also just count the <code>p</code>s and <code>q</code>s: <code>['p']*l.count('p') + sorted(filter({'q', 'p'}.isdisjoint, l)) + ['q']*l.count('q')</code> which is the same time complexity. <b>Edit</b>: You can get rid of the <code>lambda</code> too.</span>
