<div class="post-text" itemprop="text">
<p>I have the following XML document:</p>
<pre><code>&lt;Item ID="288917"&gt;
  &lt;Main&gt;
    &lt;Platform&gt;iTunes&lt;/Platform&gt;
    &lt;PlatformID&gt;353736518&lt;/PlatformID&gt;
  &lt;/Main&gt;
  &lt;Genres&gt;
    &lt;Genre FacebookID="6003161475030"&gt;Comedy&lt;/Genre&gt;
    &lt;Genre FacebookID="6003172932634"&gt;TV-Show&lt;/Genre&gt;
  &lt;/Genres&gt;
  &lt;Products&gt;
    &lt;Product Country="CA"&gt;
      &lt;URL&gt;https://itunes.apple.com/ca/tv-season/id353187108?i=353736518&lt;/URL&gt;
      &lt;Offers&gt;
        &lt;Offer Type="HDBUY"&gt;
          &lt;Price&gt;3.49&lt;/Price&gt;
          &lt;Currency&gt;CAD&lt;/Currency&gt;
        &lt;/Offer&gt;
        &lt;Offer Type="SDBUY"&gt;
          &lt;Price&gt;2.49&lt;/Price&gt;
          &lt;Currency&gt;CAD&lt;/Currency&gt;
        &lt;/Offer&gt;
      &lt;/Offers&gt;
    &lt;/Product&gt;
    &lt;Product Country="FR"&gt;
      &lt;URL&gt;https://itunes.apple.com/fr/tv-season/id353187108?i=353736518&lt;/URL&gt;
      &lt;Rating&gt;Tout public&lt;/Rating&gt;
      &lt;Offers&gt;
        &lt;Offer Type="HDBUY"&gt;
          &lt;Price&gt;2.49&lt;/Price&gt;
          &lt;Currency&gt;EUR&lt;/Currency&gt;
        &lt;/Offer&gt;
        &lt;Offer Type="SDBUY"&gt;
          &lt;Price&gt;1.99&lt;/Price&gt;
          &lt;Currency&gt;EUR&lt;/Currency&gt;
        &lt;/Offer&gt;
      &lt;/Offers&gt;
    &lt;/Product&gt;
  &lt;/Products&gt;
&lt;/Item&gt;
</code></pre>
<p>Currently, to get it into json format I'm doing the following:</p>
<pre><code>parser = etree.XMLParser(recover=True)
node = etree.fromstring(s, parser=parser)
data = xmltodict.parse(etree.tostring(node))
</code></pre>
<p>Of course the <code>xmltodict</code> is doing the heavy lifting. However, it gives me a format that is not ideal for what I'm trying to accomplish. Here is what I'd like the end data to look like:</p>
<pre><code>{
    "Item[@ID]": 288917, # if no preceding element, use the root node tag
    "Main.Platform": "iTunes",
    "Main.PlatformID": "353736518",
    "Genres.Genre": ["Comedy", "TV-Show"] # list of elements if repeated
    "Genres.Genre[@FacebookID]": ["6003161475030", "6003161475030"],
    "Products.Product[@Country]": ["CA", "FR"],
    "Products.Product.URL": ["https://itunes.apple.com/ca/tv-season/id353187108?i=353736518", "https://itunes.apple.com/fr/tv-season/id353187108?i=353736518"],
    "Products.Product.Offers.Offer[@Type]": ["HDBUY", "SDBUY", "HDBUY", "SDBUY"],
    "Products.Product.Offers.Offer.Price": ["3.49", "2.49", "2.49", "1.99"],
    "Products.Product.Offers.Offer.Currency": "EUR"    
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use recursion here. One way is to store the paths progressively as your recurse the XML document, and return a result dictionary at the end, which can be serialized to JSON. </p>
<p>The below demo uses the standard library <a href="https://docs.python.org/3/library/xml.etree.elementtree.html" rel="nofollow noreferrer">xml.etree.ElementTree</a> for parsing XML documents. </p>
<p><strong>Demo:</strong></p>
<pre><code>from xml.etree.ElementTree import ElementTree
from pprint import pprint

# Setup XML tree for parsing
tree = ElementTree()
tree.parse("sample.xml")
root = tree.getroot()

def collect_xml_paths(root, path=[], result={}):
    """Collect XML paths into a dictionary"""

    # First collect root items
    if not result:
        root_id, root_value = tuple(root.attrib.items())[0]
        root_key = root.tag + "[@%s]" % root_id
        result[root_key] = root_value

    # Go through each child from root
    for child in root:

        # Extract text
        text = child.text.strip()

        # Update path
        new_path = path[:]
        new_path.append(child.tag)

        # Create dot separated key
        key = ".".join(new_path)

        # Get child attributes
        attributes = child.attrib

        # Ensure we have attributes
        if attributes:

            # Add each attribute to result
            for k, v in attributes.items():
                attrib_key = key + "[@%s]" % k
                result.setdefault(attrib_key, []).append(v)

        # Add text if it exists
        if text:
            result.setdefault(key, []).append(text)

        # Recurse through paths once done iteration
        collect_xml_paths(child, new_path)

    # Separate single values from list values
    return {k: v[0] if len(v) == 1 else v for k, v in result.items()}

pprint(collect_xml_paths(root))
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>{'Genres.Genre': ['Comedy', 'TV-Show'],
 'Genres.Genre[@FacebookID]': ['6003161475030', '6003172932634'],
 'Item[@ID]': '288917',
 'Main.Platform': 'iTunes',
 'Main.PlatformID': '353736518',
 'Products.Product.Offers.Offer.Currency': ['CAD', 'CAD', 'EUR', 'EUR'],
 'Products.Product.Offers.Offer.Price': ['3.49', '2.49', '2.49', '1.99'],
 'Products.Product.Offers.Offer[@Type]': ['HDBUY', 'SDBUY', 'HDBUY', 'SDBUY'],
 'Products.Product.Rating': 'Tout public',
 'Products.Product.URL': ['https://itunes.apple.com/ca/tv-season/id353187108?i=353736518',
                      'https://itunes.apple.com/fr/tv-season/id353187108?i=353736518'],
 'Products.Product[@Country]': ['CA', 'FR']}
</code></pre>
<p>If you want to serialize this dictionary to JSON, you can use <a href="https://docs.python.org/3/library/json.html#json.dumps" rel="nofollow noreferrer"><code>json.dumps()</code></a>:</p>
<pre><code>from json import dumps

print(dumps(collect_xml_paths(root)))
# {"Item[@ID]": "288917", "Main.Platform": "iTunes", "Main.PlatformID": "353736518", "Genres.Genre[@FacebookID]": ["6003161475030", "6003172932634"], "Genres.Genre": ["Comedy", "TV-Show"], "Products.Product[@Country]": ["CA", "FR"], "Products.Product.URL": ["https://itunes.apple.com/ca/tv-season/id353187108?i=353736518", "https://itunes.apple.com/fr/tv-season/id353187108?i=353736518"], "Products.Product.Offers.Offer[@Type]": ["HDBUY", "SDBUY", "HDBUY", "SDBUY"], "Products.Product.Offers.Offer.Price": ["3.49", "2.49", "2.49", "1.99"], "Products.Product.Offers.Offer.Currency": ["CAD", "CAD", "EUR", "EUR"], "Products.Product.Rating": "Tout public"}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a bit verbose, but it wasn't too hard to format this as a flat dict. Here is an example:</p>
<pre><code>node = etree.fromstring(file_data.encode('utf-8'), parser=parser)
data = OrderedDict()
nodes = [(node, ''),] # format is (node, prefix)

while nodes:

    for sub, prefix in nodes:

        # remove the prefix tag unless its for the first attribute
        tag_prefix = '.'.join(prefix.split('.')[1:]) if ('.' in prefix) else ''
        atr_prefix = sub.tag if (sub == node) else tag_prefix

        # tag
        if sub.text.strip():
            _prefix = tag_prefix + '.' + sub.tag
            _value = sub.text.strip()
            if data.get(_prefix): # convert it to a list if multiple values
                if not isinstance(data[_prefix], list): data[_prefix] = [data[_prefix],]
                data[_prefix].append(_value)
            else:
                data[_prefix] = _value

        # atr
        for k, v in sub.attrib.items():
            _prefix = atr_prefix + '[@%s]' % k
            _value = v
            if data.get(_prefix): # convert it to a list if multiple values
                if not isinstance(data[_prefix], list): data[_prefix] = [data[_prefix],]
                data[_prefix].append(_value)
            else:
                data[_prefix] = _value

        nodes.remove((sub, prefix))

        for s in sub.getchildren():
            _prefix = (prefix + '.' + sub.tag).strip('.')
            nodes.append((s, _prefix))

    if not nodes: break
</code></pre>
</div>
<span class="comment-copy">this is a perfect answer and I appreciate the thorough comments within the code. I've asked another similar question as well at <a href="https://stackoverflow.com/questions/53990897/convert-xml-to-nested-json-object-in-specific-format?noredirect=1&amp;lq=1" title="convert xml to nested json object in specific format">stackoverflow.com/questions/53990897/â€¦</a>.</span>
