<div class="post-text" itemprop="text">
<p>While coding in python I'm getting an error: "Object of type myObject is not JSON serializable" </p>
<p>I tried to use some solutions I saw in other questions, but I didn't find many similarities between my code and the code in those questions, so I found it difficult to adapt the solutions in my code.</p>
<p>A part of my script is as follows. The error occurs in the last line of the first block: </p>
<pre><code>import json
import os
from my_object import myObject

for a in A_set:
    if os.path.isfile(filename):
        with open(filename, 'r') as f:
            json_data = json.load(f)
        object_name = myObject.from_json(json_data)
    else:
        object_name = myObject(a)
        object_name.property_A = property_A
        object_name.property_C = []

    object_name.property_C_add_elements(var)
    with open(filename, 'w') as f:
        json.dump(object_name.to_json(), f)
</code></pre>
<p>In another python file is defined the class of 'myObject', where is also the method 'to_json()', which I'm calling in the line of code that produces the error.</p>
<pre><code>class myObject:
    def __init__(self, name):
        self.name = name
        self.property_A = property_A
        self.property_B = property_B
        self.property_C = []

    def property_C_add_elements(self, var):  
        self.property_C.append(var)

    def to_json(self):
        return {
            'Name': self.name,
            'property A': self.property_A,
            'property B': self.property_B,
            'property C': self.property_C
        }

    @classmethod
    def from_json(cls, jason_data):
        object_name = myObject(jason_data['property A'])
        property_B = myObject(jason_data['property B'])
        c_list = []
        for var in jason_data['property C']:
            c_list.append(myObject(var))

        object_name.property_B = property_B
        object_name.property_C = c_list

        return object_name
</code></pre>
<p>I would be glad if I could get a solution to that problem. Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>from the code you provided i can only speculate what types exactly your <code>property_A, property_B, property_C</code> variables/attributes are but </p>
<pre><code>@classmethod
def from_json(cls, jason_data):
    object_name = myObject(jason_data['property A'])
    property_B = myObject(jason_data['property B'])
    c_list = []
    for var in jason_data['property C']:
        c_list.append(myObject(var))

    object_name.property_B = property_B
    object_name.property_C = c_list

    return object_name
</code></pre>
<p>Let's me speculate that your properties are Classinstances which have no "definition" of how they should be serialized into JSON. This is backed up by what you said : </p>
<blockquote>
<p>"Object of type myObject is not JSON serializable" </p>
</blockquote>
<p>I guess the problem is with the <code>from_json()</code> classmethod, there you should probably do smth. like :</p>
<p><strong>EDITED</strong>:</p>
<p>Assuming that the <code>__init__()</code> method of your Class looks as follows </p>
<pre><code>def __init__(self, name, property_A, property_B, property_C):
    self.name = name
    self.property_A = property_A
    self.property_B = property_B
    self.property_C = property_C 
    # property_C should be a list, you may want to add validation method 
    # which checks for correct types if it is preocess cirtical
</code></pre>
<p>I suggest the following:</p>
<pre><code>@classmethod
def from_json(cls, jason_data):
    return cls(
               jason_data['name'],
               jason_data['property A'],
               jason_data['property B'],
               jason_data['property C']
               ) 
</code></pre>
<p>Furthermore i suggest, if it's possible, that you change your JSON Format, provided in your <code>to_json()</code> method by simply replacing the whitespaces from "property A" to "property_A" (same for other properties). In addition you can change "Name" to lowercase "name". </p>
<p>Why ? Because with this format, and my changed <code>__init__()</code> method you can convert your <code>from_json()</code> to the following utilizing unpacking operation :</p>
<pre><code>@classmethod
def from_json(cls, jason_data):
    return cls(**json_data) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a modified (and working) version of your code.</p>
<p><em>custom_object.py</em>:</p>
<pre class="lang-py prettyprint-override"><code>class CustomObject:

    @classmethod
    def from_json(cls, json_data):
        name = json_data["Name"]
        prop_a = json_data["PropertyA"]
        prop_b = json_data["PropertyB"]
        obj = cls(name, prop_a=prop_a, prop_b=prop_b)
        for var in json_data["PropertyC"]:
            obj.add_c_element(var)
        return obj

    def __init__(self, name, prop_a="", prop_b=""):
        self.name = name
        self.prop_a = prop_a
        self.prop_b = prop_a
        self.prop_c = list()

    def add_c_element(self, var):
        self.prop_c.append(var)

    def to_json(self):
        return {
            "Name": self.name,
            "PropertyA": self.prop_a,
            "PropertyB": self.prop_b,
            "PropertyC": self.prop_c,
        }
</code></pre>
<p><em>code.py</em>:</p>
<pre class="lang-py prettyprint-override"><code>#!/usr/bin/env python3

import sys
import json
import os
from custom_object import CustomObject


def main():
    filename = "./data.json"
    if os.path.isfile(filename):
        print("Attempting to load object from json file...")
        with open(filename, "r") as f:
            json_data = json.load(f)
            try:
                obj = CustomObject.from_json(json_data)
            except Exception as e:
                print(e)
                return
            print("Object: {:}\n  Class: {:s}\n  Attributes:" .format(obj, obj.__class__.__name__))
            for k, v in getattr(obj, "__dict__", dict()).items():
                print("    {:s}: {:}".format(k, v))

    else:
        print("Creating dummy object and saving to json...")
        obj = CustomObject("Object name", prop_a="object property a", prop_b="object property b")
        obj.add_c_element(1)
        obj.add_c_element("c element 2")
        with open(filename, "w") as f:
            json.dump(obj.to_json(), f)
    print("Done.")


if __name__ == "__main__":
    print("Python {:s} on {:s}\n".format(sys.version, sys.platform))
    main()
</code></pre>
<p><strong>Notes</strong>:</p>
<ul>
<li>Corrected the errors (or added data that was missing)</li>
<li>Did some renames (class, objects, attributes) for clarity</li>
<li>Assumed that <em>prop_a</em>, <em>prop_b</em> are strings (not very important)</li>
<li>The (main) problem was in <em>from_json</em> function (I'm not sure what you tried to do there: why so many <em>myObject</em> instantiations, when there should have been only one). Anyway, what it does now:

<ol>
<li>Gets <em>name</em>, <em>prop_a</em>, <em>prop_b</em> attributes from <em>json_data</em> (which is a <em>dict</em>)</li>
<li>Constructs the object out of the 3 values from <em>#1.</em></li>
<li>Read the objects for <em>prop_c</em>, and adds them one by one (if any) to the object (by calling <em>add_c_element</em>)</li>
</ol></li>
<li>Program searches for a file (with <em>json</em> contents):

<ul>
<li>If found, it tries to load the object from it and displays it</li>
<li>If not found, it creates a dummy object and dumps it in the file</li>
</ul></li>
<li>This is <strong>one</strong> (not a very nice) way of doing things. It's meant to require minimum code changes, and it's also for learning purposes. The proper (scalable, general) way would be to extend <em>JSONEncoder</em>, <em>JSONDecoder</em> (<a href="https://docs.python.org/3/library/json.html#module-json" rel="nofollow noreferrer">[Python 3]: json - JSON encoder and decoder</a>), but I feel that it would be a bit too advanced at this point</li>
</ul>
<p><strong>Output</strong>:</p>
<blockquote>
<pre class="lang-py prettyprint-override"><code>(py35x64_test) e:\Work\Dev\StackOverflow\q053914912&gt;"e:\Work\Dev\VEnvs\py35x64_test\Scripts\python.exe" code.py
Python 3.5.4 (v3.5.4:3f56838, Aug  8 2017, 02:17:05) [MSC v.1900 64 bit (AMD64)] on win32

Creating dummy object and saving to json...
Done.

(py35x64_test) e:\Work\Dev\StackOverflow\q053914912&gt;"e:\Work\Dev\VEnvs\py35x64_test\Scripts\python.exe" code.py
Python 3.5.4 (v3.5.4:3f56838, Aug  8 2017, 02:17:05) [MSC v.1900 64 bit (AMD64)] on win32

Attempting to load object from json file...
Object: &lt;custom_object.CustomObject object at 0x00000230B6182C88&gt;
  Class: CustomObject
  Attributes:
    prop_a: object property a
    prop_b: object property a
    name: Object name
    prop_c: [1, 'c element 2']
Done.
</code></pre>
</blockquote>
</div>
<span class="comment-copy">The question lacks some required data according to <a href="https://stackoverflow.com/help/mcve">[SO]: How to create a Minimal, Complete, and Verifiable example (mcve)</a>. For example, none of the files should compile: <code>for a in A_set:</code>, <code>self.property_A = property_A</code>. Please correct the question and also add the stacktrace. And edit the question, don't add comments.</span>
<span class="comment-copy">Well, it's about a long script that is reading data from an excel file and wants to convert it in json form. It's a bit difficult to produce a minimal and complete code, but I'll give a try. However the second block of code is the complete code of my second file. Thanks for responding.</span>
<span class="comment-copy">Well, yes. The type of the error made me not to search carefully for the solution in my own code. Even the error was produced in a line that it was obvious that there wasn't any mistake. However not being familiar yet with the concept of the ool, I can make such a mistake. Now the code works properly. Thank you very much for responding, and for the time you spent.</span>
<span class="comment-copy">Unfortunately, the code in the answer is even more incorrect than the one in the question.</span>
<span class="comment-copy">If completely accurate: Yes i was quite superficial and hasty in the first version of my answer. I hope i clarified everything in the edit.</span>
<span class="comment-copy">Thank you very much. The key was finally as you say in the classmethod, and my mistake was that the attributes should take their values from json_data rather than from a new object creation. Actually that was what I wanted. But as the error occurred few lines away from that point, I missed it. About the code of the script I will have a look and I will possibly use it as a part, or as a whole. Thanks again!</span>
