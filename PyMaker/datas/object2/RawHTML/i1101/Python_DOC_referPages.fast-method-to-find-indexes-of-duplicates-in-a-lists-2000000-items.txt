<div class="post-text" itemprop="text">
<p>I have a list where each item is a combination of two event ids:
(This is just a snippet of the much larger list of pairs)</p>
<blockquote>
<p>['10000381 10007121', '10000381 10008989', '10005169 10008989',
  '10008989 10023817', '10005169 10043265', '10008989 10043265',
  '10023817 10043265', '10047097 10047137', '10047097 10047265',
  '10047137 10047265', '10000381 10056453', '10047265 10056453',
  '10000381 10060557', '10007121 10060557', '10056453 10060557',
  '10000381 10066013', '10007121 10066013', '10008989 10066013',
  '10026233 10066013', '10056453 10066013', '10056453 10070153',
  '10060557 10070153', '10066013 10070153', '10000381 10083798',
  '10047265 10083798', '10056453 10083798', '10066013 10083798',
  '10000381 10099969', '10056453 10099969', '10066013 10099969',
  '10070153 10099969', '10083798 10099969', '10056453 10167029',
  '10066013 10167029', '10083798 10167029', '10099969 10167029',
  '10182073 10182085', '10182073 10182177', '10182085 10182177',
  '10000381 10187233', '10056453 10187233', '10060557 10187233',
  '10066013 10187233', '10083798 10187233', '10099969 10187233',
  '10167029 10187233', '10007121 10200685', '10099969 10200685',
  '10066013 10218005', '10223905 10224013']</p>
</blockquote>
<p>I need to find every single instance of each pair of ids and indexing it into a new list. Right now I have a few lines of code that does this for me. However, my list is more than 2,000,000 lines long and will get much bigger as I process more data. </p>
<p>At this moment, the estimated time of completion is about 2 days. </p>
<p>I really just need a much faster method for this. </p>
<p>I'm working in Jupyter Notebooks (on a Mac Laptop)</p>
<pre><code>def compiler(idlist):
    groups = []
    for i in idlist:
        groups.append([index for index, x in enumerate(idlist) if x == i])
    return(groups)
</code></pre>
<p>I have also tried:</p>
<pre><code>def compiler(idlist):
    groups = []
    for k,i in enumerate(idlist):
        position = []
        for c,j in enumerate(idlist):
            if i == j:
                position.append(c)
        groups.append(position)
    return(groups)
</code></pre>
<p><strong>What I want is something like this:</strong></p>
<p>'10000381 10007121': [0]<br/>
'10000381 10008989': [1]<br/>
'10005169 10008989': [2, 384775, 864173, 1297105, 1321798, 1555094, 1611064, 2078015]<br/>
'10008989 10023817': [3, 1321800]<br/>
'10005169 10043265': [4, 29113, 864195, 1297106, 1611081]<br/>
[5, 864196, 2078017]<br/>
'10008989 10043265': [6, 29114, 384777, 864198, 1611085, 1840733, 2078019]<br/>
'10023817 10043265': [7, 86626, 384780, 504434, 792690, 864215, 1297108, 1321801, 1489784, 1524527, 1555096, 1595763, 1611098, 1840734, 1841280, 1929457, 1943701, 1983362, 2093820, 2139917, 2168437]
etc.
etc.
etc.</p>
<p>Where each number in the brackets is an index of that pair in the idlist.</p>
<p>Essentially, I want it to look at a pair of id values ( i.e. '10000381 10007121'), and runs through the list and finds each instance of <em>that pair</em> and documents each index in the list that this pair occurs. I need something that does this for every single item in the list. In a shorter amount of time.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>collections.OrderedDict</code></a> in order to reduce the time complexity to O(n). Since it remembers the order of insertion the values resemble the various ids in order of their occurrence:</p>
<pre><code>from collections import OrderedDict

groups = OrderedDict()
for i, v in enumerate(idlist):
    try:
        groups[v].append(i)
    except KeyError:
        groups[v] = [i]
</code></pre>
<p>Then <code>list(groups.values())</code> contains your final result.</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of a list, use a dict, which makes looking up for existence <code>O(1)</code>:</p>
<pre><code>def compiler(idlist):
    groups = {}
    for idx, val in enumerate(idlist):
        if val in groups:  
            groups[val].append(idx)
        else:
            groups[val] = [idx]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you have a lot of data, i would suggest you using <code>Pypy3</code> instead of the <code>CPython</code> interpreter and you'll get <code>x5-x7</code> faster code execution.</p>
<p>Here is an implementation of a time based benchmark using <code>CPython</code> and <code>Pypy3</code> with <code>1000 iterations</code>:</p>
<p><strong>Code:</strong></p>
<pre><code>from time import time
from collections import OrderedDict, defaultdict


def timeit(func, iteration=10000):
    def wraps(*args, **kwargs):
        start = time()
        for _ in range(iteration):
            result = func(*args, **kwargs)
        end = time()
        print("func: {name} [{iteration} iterations] took: {elapsed:2.4f} sec".format(
            name=func.__name__,
            iteration=iteration,
            args=args,
            kwargs=kwargs,
            elapsed=(end - start)
        ))
        return result
    return wraps


@timeit
def op_implementation(data):
    groups = []
    for k in data:
        groups.append([index for index, x in enumerate(data) if x == k])
    return groups


@timeit
def ordreddict_implementation(data):
    groups = OrderedDict()
    for k, v in enumerate(data):
        groups.setdefault(v, []).append(k)
    return groups


@timeit
def defaultdict_implementation(data):
    groups = defaultdict(list)
    for k, v in enumerate([x for elm in data for x in elm.split()]):
        groups[v].append(k)
    return groups


@timeit
def defaultdict_implementation_2(data):
    groups = defaultdict(list)
    for k, v in enumerate(map(lambda x: tuple(x.split()), data)):
        groups[v].append(k)
    return groups


@timeit
def dict_implementation(data):
    groups = {}
    for k, v in enumerate([x for elm in data for x in elm.split()]):
        if v in groups:
            groups[v].append(k)
        else:
            groups[v] = [k]
    return groups



if __name__ == '__main__':
    data = [
        '10000381 10007121', '10000381 10008989', '10005169 10008989', '10008989 10023817', 
        '10005169 10043265', '10008989 10043265', '10023817 10043265', '10047097 10047137', 
        '10047097 10047265', '10047137 10047265', '10000381 10056453', '10047265 10056453', 
        '10000381 10060557', '10007121 10060557', '10056453 10060557', '10000381 10066013', 
        '10007121 10066013', '10008989 10066013', '10026233 10066013', '10056453 10066013', 
        '10056453 10070153', '10060557 10070153', '10066013 10070153', '10000381 10083798', 
        '10047265 10083798', '10056453 10083798', '10066013 10083798', '10000381 10099969', 
        '10056453 10099969', '10066013 10099969', '10070153 10099969', '10083798 10099969', 
        '10056453 10167029', '10066013 10167029', '10083798 10167029', '10099969 10167029', 
        '10182073 10182085', '10182073 10182177', '10182085 10182177', '10000381 10187233', 
        '10056453 10187233', '10060557 10187233', '10066013 10187233', '10083798 10187233', 
        '10099969 10187233', '10167029 10187233', '10007121 10200685', '10099969 10200685', 
        '10066013 10218005', '10223905 10224013'
    ]
    op_implementation(data)
    ordreddict_implementation(data)
    defaultdict_implementation(data)
    defaultdict_implementation_2(data)
    dict_implementation(data)
</code></pre>
<p><strong>CPython:</strong></p>
<pre><code>func: op_implementation [10000 iterations] took: 1.3096 sec
func: ordreddict_implementation [10000 iterations] took: 0.1866 sec
func: defaultdict_implementation [10000 iterations] took: 0.3311 sec
func: defaultdict_implementation_2 [10000 iterations] took: 0.3817 sec
func: dict_implementation [10000 iterations] took: 0.3231 sec
</code></pre>
<p><strong>Pypy3:</strong></p>
<pre><code>func: op_implementation [10000 iterations] took: 0.2370 sec
func: ordreddict_implementation [10000 iterations] took: 0.0243 sec
func: defaultdict_implementation [10000 iterations] took: 0.1216 sec
func: defaultdict_implementation_2 [10000 iterations] took: 0.1299 sec
func: dict_implementation [10000 iterations] took: 0.1175 sec
</code></pre>
<p><strong>Pypy3 with 2000000 iterations:</strong></p>
<pre><code>func: op_implementation [200000 iterations] took: 4.6364 sec
func: ordreddict_implementation [200000 iterations] took: 0.3201 sec
func: defaultdict_implementation [200000 iterations] took: 2.2032 sec
func: defaultdict_implementation_2 [200000 iterations] took: 2.4052 sec
func: dict_implementation [200000 iterations] took: 2.2429 sec
</code></pre>
</div>
<span class="comment-copy">You can first split them, then convert them to NumPy array and then use <code>unique</code> as shown <a href="https://stackoverflow.com/questions/30003068/get-a-list-of-all-indices-of-repeated-elements-in-a-numpy-array">here</a></span>
<span class="comment-copy">you're in need of a different datascructure for this, around a few million lines ago. Check out dictionaries if you're allowed to make changes.</span>
<span class="comment-copy">Right now you're traversing the list for each item, i.e. you have <code>O(n^2)</code> performance You can use <code>groups = collections.defaultdict(list)</code> and then do <code>for index, item in enumerate(idlist): groups[item].append(index)</code> which is <code>O(n)</code>.</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/49247506/how-to-efficiently-find-the-indices-of-matching-elements-in-two-lists">How to efficiently find the indices of matching elements in two lists</a></span>
<span class="comment-copy">Could you update your question to show sample data and "what I want" output that match? Also, are you looking for duplicate ids ('10000381' and '10007121'), or duplicate id pairs ('10000381 10007121')?</span>
<span class="comment-copy">Rather than catching <code>KeyError</code> you can just use <code>setdefault</code>: <code>groups.setdefault(v, []).append(i)</code>.</span>
<span class="comment-copy">@DanielPryden <code>try/except</code> is faster (for example for <code>idlist = np.random.randint(10_000, size=2_000_000)</code> it reaches 717 ms ± 14.2 ms vs. 997 ms ± 29.3 ms for <code>setdefault</code>).</span>
<span class="comment-copy">Change <code>groups</code> to be a <code>defaultdict(list)</code> and see how this simplifies your code (for loop body will collapse to a single statement). But you still have to create the list of lists that the OP has requested.</span>
