<div class="post-text" itemprop="text">
<p>I have the following code:</p>
<pre><code>ChangedLinks = set(NewLinkData) - set(OldLinkData)
ReplaceQueue = []
LinkUpdateTokenID = 0
for ChangedLink in ChangedLinks:
    for OldLink in OldLinkData:
        if ChangedLink[0] is OldLink[0]:
            ReplaceStrings = (OldLink[1], "&lt;&lt;LINK UPDATE TOKEN " + str(LinkUpdateTokenID) + "&gt;&gt;", ChangedLink[1])
            ReplaceQueue.append(ReplaceStrings)
    LinkUpdateTokenID += 1
</code></pre>
<p><code>ChangedLinks</code> is a set of tuples, and <code>OldLinkData</code> is a list of tuples.</p>
<p>There is a noticeable dip in the performance of the method this is in as the lengths of <code>ChangedLinks</code> and <code>OldLinkData</code> increase, because of course there is; that's just sheer math!  It goes from effectively instantaneous from the user perspective to taking a noticeable amount of time (though less than a second, at least on my machine).</p>
<p>I need to add a new element to the <code>ReplaceQueue</code> list only when I can match the first element of a tuple in <code>OldLinkData</code> as the same object as the first element of a tuple in <code>ChangedLinks</code>.  (These tuple elements are unique within their respective lists, as in, <code>OldLinkData[0][0]</code> is unique among all other members of <code>OldLinkData</code>, and the same for <code>OldLinkData[1][0]</code>, and so on.)  The only way I can think of to accomplish this is to loop through each set/list as in the code above and compare the tuple elements.</p>
<p>Is there a more efficient way to do this?  Ideally I'd like some way to quickly construct a list of only the members of <code>OldLinkData</code> which share their first element with one of the members of <code>ChangedLinks</code>, in the same order as <code>ChangedLinks</code>, so that I can just compare the lists side-by-side.  But I have no idea how to begin solving this issue.</p>
<p>Edit:  Some examples of expected input and output:</p>
<pre><code>OldLinkData:  [(&lt;Page.Page object at 0x035AF070&gt;, ']([0])'), (&lt;Page.Page object at 0x043FE4F0&gt;, ']([0, 0])'), (&lt;Page.Page object at 0x043FE590&gt;, ']([0, 0, 0])'), (&lt;Page.Page object at 0x043FE5B0&gt;, ']([0, 1])')]

NewLinkData:  [(&lt;Page.Page object at 0x035AF070&gt;, ']([0])'), (&lt;Page.Page object at 0x043FE5B0&gt;, ']([0, 0])'), (&lt;Page.Page object at 0x043FE4F0&gt;, ']([0, 1])'), (&lt;Page.Page object at 0x043FE590&gt;, ']([0, 1, 0])')]

ChangedLinks:  {(&lt;Page.Page object at 0x043FE590&gt;, ']([0, 1, 0])'), (&lt;Page.Page object at 0x043FE5B0&gt;, ']([0, 0])'), (&lt;Page.Page object at 0x043FE4F0&gt;, ']([0, 1])')}

ReplaceQueue:  [(']([0, 0, 0])', '&lt;&lt;LINK UPDATE TOKEN 0&gt;&gt;', ']([0, 1, 0])'), (']([0, 1])', '&lt;&lt;LINK UPDATE TOKEN 1&gt;&gt;', ']([0, 0])'), (']([0, 0])', '&lt;&lt;LINK UPDATE TOKEN 2&gt;&gt;', ']([0, 1])')]
</code></pre>
<p>To be clear, this is actual input and output as printed from the console in the working code.  I'm looking for a way to achieve this same result more efficiently than the current code.</p>
<p>The tuples in <code>OldLinkData</code> and <code>NewLinkData</code> are of the form:</p>
<pre><code>(Page.Page object at X, String)
</code></pre>
<p>The purpose of the code is to produce <code>ReplaceQueue</code>, a list of old and new values for replacing substrings throughout a series of strings (the page contents in a hierarchical notebook).  <code>ReplaceQueue</code>'s content has to be narrowed to cases where the same <code>Page.Page</code> object in memory has two different associated "links" (string representations of integer index paths wrapped in some markdown syntax) across <code>OldLinkData</code> and <code>NewLinkData</code>.</p>
<p>The difference between <code>OldLinkData</code> and <code>NewLinkData</code> is obtained with <code>ChangedLinks</code> as <code>set(NewLinkData) - set(OldLinkData)</code>, but then I need to associate the changed strings with each other in <code>ReplaceQueue</code>.</p>
<p>The <code>LinkUpdateTokenID</code> integer is just an intermediate step so that I can guarantee unique parameters for <code>str.replace</code> and not muck things up when two objects swap link strings.</p>
<p>Edit:  Thanks to @ParitoshSingh, the following code is noticeably faster:</p>
<pre><code>def GetLinkData(self):
    LinkData = {}
    LinkData[id(self.RootPage)] = "](" + self.JSONSerializer.SerializeDataToJSONString(self.RootPage.GetFullIndexPath(), Indent=None) + ")"
    self.AddSubPageLinkData(self.RootPage, LinkData)
    return LinkData

def AddSubPageLinkData(self, CurrentPage, LinkData):
    for SubPage in CurrentPage.SubPages:
        LinkData[id(SubPage)] = "](" + self.JSONSerializer.SerializeDataToJSONString(SubPage.GetFullIndexPath(), Indent=None) + ")"
        self.AddSubPageLinkData(SubPage, LinkData)

def UpdateLinks(self, OldLinkData, NewLinkData):
    ReplaceQueue = []
    for PageID in NewLinkData:
        if PageID in OldLinkData:
            if NewLinkData[PageID] != OldLinkData[PageID]:
                ReplaceStrings = (OldLinkData[PageID], "&lt;&lt;LINK UPDATE TOKEN" + str(PageID) + "&gt;&gt;", NewLinkData[PageID])
                ReplaceQueue.append(ReplaceStrings)
    for ReplaceStrings in ReplaceQueue:
        self.SearchWidgetInst.ReplaceAllInNotebook(SearchText=ReplaceStrings[0], ReplaceText=ReplaceStrings[1], MatchCase=True, DelayTextUpdate=True)
    for ReplaceStrings in ReplaceQueue:
        self.SearchWidgetInst.ReplaceAllInNotebook(SearchText=ReplaceStrings[1], ReplaceText=ReplaceStrings[2], MatchCase=True, DelayTextUpdate=True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>EDIT</strong>: For users looking at a similar problem to this, please refer to a more generic solution below. This edit only addresses this specific scenario for the OP.<br/>
To the OP, The lookups can be sped up by using hashable values. For this specific use case, try the <a href="https://docs.python.org/3/library/functions.html#id" rel="nofollow noreferrer">id() function</a><br/>
<em>Warning</em>: The caveats should be kept in mind. id function is guaranteed to produce unique values for objects that coexist at the same time, but is only guaranteed to be linked to memory address in CPython, other implementations may differ. </p>
<pre><code>OldLinkData = list(zip("123","abc"))
print(OldLinkData)
#[('1', 'a'), ('2', 'b'), ('3', 'c')]

NewLinkData = list(zip('1245','axyz'))
print(NewLinkData)
#[('1', 'a'), ('2', 'x'), ('4', 'y'), ('5', 'z')]


#code:

#Create a key value mapping based on the id of objects. 
OldLinkDataDict = {id(OldLink[0]): OldLink for OldLink in OldLinkData}
#{244392672200: ('1', 'a'), 244392672368: ('2', 'b'), 244420136496: ('3', 'c')}

ReplaceQueue = []
LinkUpdateTokenID = 0
for NewLink in NewLinkData:
    new_id = id(NewLink[0])
    if new_id in OldLinkDataDict: #only consider cases where NewLink exists in OldLinkData 
        if NewLink[1] != OldLinkDataDict[new_id][1]: #only when the value changes (similar to ChangedLinks)
            ReplaceStrings = (OldLinkDataDict[new_id][1],
                              "&lt;&lt;LINK UPDATE TOKEN " + str(LinkUpdateTokenID) + "&gt;&gt;",
                              NewLink[1])
            ReplaceQueue.append(ReplaceStrings)
            LinkUpdateTokenID += 1
print(ReplaceQueue)
#[('b', '&lt;&lt;LINK UPDATE TOKEN 0&gt;&gt;', 'x')]
</code></pre>
<p>If you're curious, this demonstration only works because python caches the int objects for small numbers. <a href="https://github.com/python/cpython/blob/4830f581af57dd305c02c1fd72299ecb5b090eca/Objects/longobject.c#L18-L23" rel="nofollow noreferrer">[-5 to 256]</a></p>
<hr/>
<p><strong>Generalized Solution</strong></p>
<p>You can see very good gains by changing your datatype of OldLinkData to a dictionary if your comparison objects are hashables. <a href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict" rel="nofollow noreferrer">Link to Docs</a>. Because dictionary keys are hashables, the dictonary lookups are a constant time operation <code>O(1)</code>, and do not require iteration in the dictionary. </p>
<pre><code>#Dummy data
OldLinkData = list(zip("123","abc"))
print(OldLinkData)
#[('1', 'a'), ('2', 'b'), ('3', 'c')]

NewLinkData = list(zip('1245','axyz'))
print(NewLinkData)
#[('1', 'a'), ('2', 'x'), ('4', 'y'), ('5', 'z')]


#code:
#ChangedLinks = set(NewLinkData) - set(OldLinkData) #Remove this, set creation requires an iteration anyways   
OldLinkDataDict = dict(OldLinkData)
print(OldLinkDataDict)
#{'1': 'a', '2': 'b', '3': 'c'}

ReplaceQueue = []
LinkUpdateTokenID = 0
for NewLink in NewLinkData:
    if NewLink[0] in OldLinkDataDict: #only consider cases where NewLink exists in OldLinkData 
        if NewLink[1] != OldLinkDataDict[NewLink[0]]: #only when the value changes (similar to ChangedLinks)
            ReplaceStrings = (OldLinkDataDict[NewLink[0]],
                              "&lt;&lt;LINK UPDATE TOKEN " + str(LinkUpdateTokenID) + "&gt;&gt;",
                              NewLink[1])
            ReplaceQueue.append(ReplaceStrings)
            LinkUpdateTokenID += 1
print(ReplaceQueue)
#[('b', '&lt;&lt;LINK UPDATE TOKEN 0&gt;&gt;', 'x')]
</code></pre>
<p>Some comparison. Note that ideally you should only do the dictionary creation once, but i kept it included in the time comparison in case you can't get away with changing the datatype of OldLinkData permanently. In that case, you just would want to create the dictionary for comparison as needed.</p>
<pre><code>OldLinkData = list(zip("123","abc"))
NewLinkData = list(zip('1245','axyz'))
</code></pre>
<p>BaseLine</p>
<pre><code>%%timeit
ChangedLinks = set(NewLinkData) - set(OldLinkData)
ReplaceQueue = []
LinkUpdateTokenID = 0
for ChangedLink in ChangedLinks:
    for OldLink in OldLinkData:
        if ChangedLink[0] is OldLink[0]:
            ReplaceStrings = (OldLink[1], "&lt;&lt;LINK UPDATE TOKEN " + str(LinkUpdateTokenID) + "&gt;&gt;", ChangedLink[1])
            ReplaceQueue.append(ReplaceStrings)
    LinkUpdateTokenID += 1
</code></pre>
<p>NewCode</p>
<pre><code>%%timeit
OldLinkDataDict = dict(OldLinkData)
ReplaceQueue = []
LinkUpdateTokenID = 0
for NewLink in NewLinkData:
    if NewLink[0] in OldLinkDataDict: #only consider cases where NewLink exists in OldLinkData 
        if NewLink[1] != OldLinkDataDict[NewLink[0]]: #only when the value changes (similar to ChangedLinks)
            ReplaceStrings = (OldLinkDataDict[NewLink[0]],
                              "&lt;&lt;LINK UPDATE TOKEN " + str(LinkUpdateTokenID) + "&gt;&gt;",
                              NewLink[1])
            ReplaceQueue.append(ReplaceStrings)
            LinkUpdateTokenID += 1
</code></pre>
<p>BaseLine: <code>2.16 µs ± 52.6 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
</code></p>
<p>NewCode: <code>1.62 µs ± 98.4 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)</code></p>
</div>
<span class="comment-copy">do not use <code>is</code> for comparison. use <code>==</code>. Could you paste one or two samples for oldlinkdata and changedlink with expected output? Just makes it easier to follow through for everyone.</span>
<span class="comment-copy">Oh dear. I was just about done writing a solution. Are your objects hashables?</span>
<span class="comment-copy">Do your objects have a hash method? <a href="https://stackoverflow.com/questions/14535730/what-do-you-mean-by-hashable-in-python">Link</a> And it really depends on how the hash is implemented, but ideally the hash should not be mutated during an object's lifetime, so any parts that mutate for the same object must not be in its hash logic.</span>
<span class="comment-copy">Also, i'll admit this problem became fairly tricky. Kudos for posting a really good question.</span>
<span class="comment-copy">oh, I think i got it. Dont look at user perspective. Why dont you use their <code>id</code> as the hash then? If you're using the <code>is</code> operator, and accessing the same value, then their id must match.</span>
