<div class="post-text" itemprop="text">
<p>How can I write a function "fmap", with this properties :</p>
<pre><code>&gt;&gt;&gt; l = [1, 2]; fmap(lambda x: 2*x, l)
[2, 4]
&gt;&gt;&gt; l = (1, 2); fmap(lambda x: 2*x, l)
(2, 4)
&gt;&gt;&gt; l = {1, 2}; fmap(lambda x: 2*x, l)
{2, 4}
</code></pre>
<p>(I search a kind of "fmap" in haskell, but in python3).</p>
<p>I have a very ugly solution, but there is certainly a solution more pythonic and generic ? :</p>
<pre><code>def fmap(f, container):
    t = container.__class__.__name__
    g = map(f, container)
    return eval(f"{t}(g)")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using the type of the input as a <em>converter</em> is not necessarily working in all occasions.  <code>map</code> is just using the "iterability" of its input to produce its output.  In Python3 this is why <code>map</code> returns a generator instead of a list (which is just more fitting).</p>
<p>So a cleaner and more robust version would be one which explicitly expects the various possible inputs it can handle and which raises an error in all other cases:</p>
<pre><code>def class_retaining_map(fun, iterable):
  if type(iterable) is list:  # not using isinstance(), see below for reasoning
    return [ fun(x) for x in iterable ]
  elif type(iterable) is set:
    return { fun(x) for x in iterable }
  elif type(iterable) is dict:
    return { k: fun(v) for k, v in iterable.items() }
  # ^^^ use .iteritems() in python2!
  # and depending on your usecase this might be more fitting:
  # return { fun(k): v for k, v in iterable.items() }
  else:
    raise TypeError("type %r not supported" % type(iterable))
</code></pre>
<p>You could add a case for all other iterable values in the <code>else</code> clause of cause:</p>
<pre><code>  else:
    return (fun(x) for x in iterable)
</code></pre>
<p>But that would e. g. return an iterable for a subclass of <code>set</code> which might not be what you want.</p>
<p>Mind that I'm deliberately <em>not</em> using <code>isinstance</code> because that would make a list out of a subclass of <code>list</code>, for instance.  I figure that this is explicitly not wanted in this case.</p>
<p>One could argue that anything which is a <code>list</code> (i. e. is a subclass of <code>list</code>) needs to comply to have a constructor which returns a thing of this type for an iteration of elements.  And likewise for subclasses of <code>set</code>, <code>dict</code> (which must work for an iteration of pairs), etc.  Then the code might look like this:</p>
<pre><code>def class_retaining_map(fun, iterable):
  if isinstance(iterable, (list, set)):
    return type(iterable)(fun(x) for x in iterable)
  elif isinstance(iterable, dict):
    return type(iterable)((k, fun(v)) for k, v in iterable.items())
  # ^^^ use .iteritems() in python2!
  # and depending on your usecase this might be more fitting:
  # return type(iterable)((fun(k), v) for k, v in iterable.items())
  else:
    raise TypeError("type %r not supported" % type(iterable))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h3>Instantiate directly rather than via <code>eval</code></h3>
<p><code>__class__</code> can also be used to instantiate new instances:</p>
<pre><code>def mymap(f, contener):
    t = contener.__class__
    return t(map(f, contener))
</code></pre>
<p>This removes the need for <code>eval</code>, use of which is considered <a href="https://stackoverflow.com/questions/1832940/why-is-using-eval-a-bad-practice">poor practice</a>. As per @EliKorvigo's comment, you may prefer built-in <a href="https://docs.python.org/3/library/functions.html#type" rel="nofollow noreferrer"><code>type</code></a> to a magic method:</p>
<pre><code>def mymap(f, contener):
    t = type(contener)
    return t(map(f, contener))
</code></pre>
<p>As explained <a href="https://stackoverflow.com/questions/9610993/python-type-or-class-or-is">here</a> and in <a href="https://docs.python.org/3/library/functions.html#type" rel="nofollow noreferrer">the docs</a>:</p>
<blockquote>
<p>The return value is a type object and generally the same object as returned by <code>object.__class__</code>.</p>
</blockquote>
<p>"Generally the same" should be considered "equivalent" in the case of new-style classes.</p>
<h3>Testing for an iterable</h3>
<p>You can check/test for an iterable in a couple of ways. Either use <code>try</code> / <code>except</code> to catch <code>TypeError</code>:</p>
<pre><code>def mymap(f, contener):
    try:
        mapper = map(f, contener)
    except TypeError:
        return 'Input object is not iterable'
    return type(contener)(mapper)
</code></pre>
<p>Or use <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable" rel="nofollow noreferrer"><code>collections.Iterable</code></a>:</p>
<pre><code>from collections import Iterable

def mymap(f, contener):
    if isinstance(contener, Iterable):
        return type(contener)(map(f, contener))
    return 'Input object is not iterable'
</code></pre>
<p>This works specifically because <em>built-in</em> classes commonly used as containers such as <code>list</code>, <code>set</code>, <code>tuple</code>, <code>collections.deque</code>, etc, can be used to instantiate instances via a lazy iterable. Exceptions exist: for example, <code>str(map(str.upper, 'hello'))</code> will not work as you might expect even though <code>str</code> instances are iterable.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I search a kind of "fmap" in haskell, but in python3</p>
</blockquote>
<p>First, let's discuss Haskell's <code>fmap</code> to understand, why it behaves the way it does, though I assume you are fairly familiar with Haskell considering the question. <code>fmap</code> is a generic method defined in the <a href="https://wiki.haskell.org/Functor" rel="nofollow noreferrer"><code>Functor</code> type-class</a>:</p>
<pre><code>class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b
    ...
</code></pre>
<p>Functors obey several important mathematical laws and have several methods derived from <code>fmap</code>, though the latter is sufficient for a minimal complete functor instance. In other words, in Haskell types belonging to the <code>Functor</code> type-class implement their own <code>fmap</code> functions (moreover, Haskell types can have multiple <code>Functor</code> implementations via <code>newtype</code> definitions). In Python we don't have type-classes, though we do have classes that, while less convenient in this case, allow us to simulate this behaviour. Unfortunately, with classes we can't add functionality to an already defined class without subclassing, which limits our ability to implement a generic <code>fmap</code> for all builtin types, though we can overcome it by explicitly checking for acceptable iterable types in our <code>fmap</code> implementation. It's also literally impossible to express higher-kinded types using Python's type system, but I digress.</p>
<p>To summarise, we've got several options:</p>
<ol>
<li>Support all <code>Iterable</code> types (@jpp's solution). It relies on constructors to convert an iterator returned by Python's <code>map</code> back into the original type. That is the duty of applying a function over the values inside a container is taken away from the container. This approach differs drastically from the functor interface: functors are supposed to handle the mapping themselves and handle additional metadata crucial to reconstruct the container.</li>
<li>Support a subset of readily mappable builtin iterable types (i.e. builtins that don't carry any important metadata). This solution is implemented by @Alfe, and, while less generic, it is safer.</li>
<li>Take solution #2 and add support for proper user-defined functors.</li>
</ol>
<p>This is my take on the third solution</p>
<pre><code>import abc
from typing import Generic, TypeVar, Callable, Union, \
    Dict, List, Tuple, Set, Text

A = TypeVar('A')
B = TypeVar('B')


class Functor(Generic[A], metaclass=abc.ABCMeta):

    @abc.abstractmethod
    def fmap(self, f: Callable[[A], B]) -&gt; 'Functor[B]':
        raise NotImplemented


FMappable = Union[Functor, List, Tuple, Set, Dict, Text]


def fmap(f: Callable[[A], B], fmappable: FMappable) -&gt; FMappable:
    if isinstance(fmappable, Functor):
        return fmappable.fmap(f)
    if isinstance(fmappable, (List, Tuple, Set, Text)):
        return type(fmappable)(map(f, fmappable))
    if isinstance(fmappable, Dict):
        return type(fmappable)(
            (key, f(value)) for key, value in fmappable.items()
        )
    raise TypeError('argument fmappable is not an instance of FMappable')
</code></pre>
<p>Here is a demo                                                                       </p>
<pre><code>In [20]: import pandas as pd                                                                        

In [21]: class FSeries(pd.Series, Functor): 
    ...:      
    ...:     def fmap(self, f): 
    ...:         return self.apply(f).astype(self.dtype)
    ...:                                                                                            

In [22]: fmap(lambda x: x * 2, [1, 2, 3])                                                           
Out[22]: [2, 4, 6]

In [23]: fmap(lambda x: x * 2, {'one': 1, 'two': 2, 'three': 3})                                    
Out[23]: {'one': 2, 'two': 4, 'three': 6}

In [24]: fmap(lambda x: x * 2, FSeries([1, 2, 3], index=['one', 'two', 'three']))   
Out[24]: 
one      2
two      4
three    6
dtype: int64

In [25]: fmap(lambda x: x * 2, pd.Series([1, 2, 3], index=['one', 'two', 'three']))                 
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-27-1c4524f8e4b1&gt; in &lt;module&gt;
----&gt; 1 fmap(lambda x: x * 2, pd.Series([1, 2, 3], index=['one', 'two', 'three']))

&lt;ipython-input-7-53b2d5fda1bf&gt; in fmap(f, fmappable)
     34     if isinstance(fmappable, Functor):
     35         return fmappable.fmap(f)
---&gt; 36     raise TypeError('argument fmappable is not an instance of FMappable')
     37 
     38 

TypeError: argument fmappable is not an instance of FMappable
</code></pre>
<p>This solution allows us to define multiple functors for the same type via  subclassing:</p>
<pre><code>In [26]: class FDict(dict, Functor):
   ...:     
   ...:     def fmap(self, f):
   ...:         return {f(key): value for key, value in self.items()}
   ...: 
   ...: 

In [27]: fmap(lambda x: x * 2, FDict({'one': 1, 'two': 2, 'three': 3}))     
Out[27]: {'oneone': 1, 'twotwo': 2, 'threethree': 3}
</code></pre>
</div>
<span class="comment-copy">Breaks if:  <code>fmap(lambda x: x[0], {"A":"small","Example":"that","Does":"not","Work":"!"}) </code> .. and in any other case where the function changes the type...</span>
<span class="comment-copy">Are you deliberately using <code>type(iterable) == list</code> instead of <code>isinstance</code>? I can think of very few cases were this is not a bad practice. And even then, you would use <code>is</code> instead of <code>==</code>.</span>
<span class="comment-copy">@EliKorvigo Yes, I'm using <code>type(iterable)</code> deliberately (see my last paragraph which I added late for the reason of this).  I changed the use of <code>==</code> to the use of <code>is</code> which is slightly better in this case, you are right.</span>
<span class="comment-copy">I'll adopt this solution, with another case : <code>elif type(iterable) is str: return "".join(map(fun, iterable))</code></span>
<span class="comment-copy">In case you need strings, you might want to consider to add <code>bytes</code> in Python3 or <code>unicode</code> in Python2.</span>
<span class="comment-copy">I'd say, calling <code>type(container)(map(...))</code> is a bit cleaner than accessing a magic attribute.</span>
<span class="comment-copy">@PatrickArtner, It certainly works for me.</span>
<span class="comment-copy">Yepp works. Would it be wise to put a try:except: around it in case the function transforms the iterabletype to something that does not work? or is it better to let it crash if you call it with a typechanging function? <code>mymap(lambda x: x[0], {"A":"small","Example":"that","Does":"not","Work":"!"})</code></span>
<span class="comment-copy">@PatrickArtner, Fair point, I added a couple of ways this can be done.</span>
<span class="comment-copy">Your <code>try</code>/<code>except</code> code catches <i>way</i> too many cases.  Each <code>TypeError</code> thrown in the execution of <code>f</code> within the <code>map</code> call will be caught and misinterpreted as "Input object is not iterable".</span>
