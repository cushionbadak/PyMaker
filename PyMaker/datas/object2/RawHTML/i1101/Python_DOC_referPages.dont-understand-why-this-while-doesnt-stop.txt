<div class="post-text" itemprop="text">
<p>I have a selenium bot doing actions on a social network. I would like it to stop after he does a certain number of actions (10 is for the example). I initialize variables this way:</p>
<pre><code>def __init__(self):
    self.browser = webdriver.Firefox()
    self.counter_var = int(0)
    self.max_var = int(10)
</code></pre>
<p>This is the part performing and counting actions:</p>
<pre><code>def action(self, accounts):
    for account in accounts[9:]:
        try:
            self.browser.get(account)
            time.sleep(5)
            like_button = self.browser.find_element_by_xpath(
                                u'//button[contains(@class, "Heart")]').click()
            self.count_actions()
            print(self.counter_var)
        except selenium.common.exceptions.NoSuchElementException:
            break

def count_actions(self):
    self.counter_var += 1
</code></pre>
<p>And this is the loop I've tried to make into main:</p>
<pre><code>while self.counter_var &lt; self.max_var:
    searched_category = random.choice(pool_categories)
    accounts = self.load_category(searched_category)
    self.action(accounts)
</code></pre>
<p>However the bot never stops, even when <code>counter_var</code> reaches <code>10</code>.</p>
<p>Do you know how to correct it?</p>
</div>
<div class="post-text" itemprop="text">
<p>Currently it's impossible to give a concrete answer to your question, due to the lack of code given, but it looks like the problem is because the <code>action()</code> method <em>doesn't</em> check <code>self.counter_var</code> while the <code>for</code> loop within <strong>it</strong> is executing.</p>
<p>Something like the follow might work. Adding <code>yield</code> to the <code>action()</code> method turns it into a <a href="https://docs.python.org/3/glossary.html#term-generator" rel="nofollow noreferrer">generator function</a>, which makes it iterable. When that is done it will effectively "pause" at that point each iteration of its <code>for</code> loop, and would allow the caller to inspect the current value of <code>self.counter_var</code> (or anything else it wanted to do each iteration).</p>
<p>Here's what I'm suggesting with a few explanatory comments:</p>
<pre><code>class Class:
    def action(self, accounts):
        for account in accounts[9:]:
            try:
                self.browser.get(account)
                time.sleep(5)
                like_button = self.browser.find_element_by_xpath(
                                    u'//button[contains(@class, "Heart")]').click()
                self.count_actions()
                print(self.counter_var)
                yield  # Added.
            except selenium.common.exceptions.NoSuchElementException:
                break

    def count_actions(self):
        self.counter_var += 1

    def main(self):
        while True:
            searched_category = random.choice(pool_categories)
            accounts = self.load_category(searched_category)
            for _ in self.action(accounts):  # Iterate through account checks.
                if self.counter_var &lt; self.max_var:  # Too many actions?
                    break
</code></pre>
</div>
<span class="comment-copy">you need to provide a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a></span>
<span class="comment-copy">Perhaps the exception you are silently catching is preventing your counter from incrementing.</span>
<span class="comment-copy">@khelwood: probably not, since SidGabriel prints the value and reports it reaching 10.</span>
<span class="comment-copy">Do you create any more instances of this class?</span>
<span class="comment-copy">You can go past 10 in the <code>for</code> loop in <code>action()</code>, because you don't test against the limit until <code>action()</code> returns to the <code>while</code> loop.</span>
