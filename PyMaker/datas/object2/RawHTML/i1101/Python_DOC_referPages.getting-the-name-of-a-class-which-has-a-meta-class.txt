<div class="post-text" itemprop="text">
<p>Suppose I define a class <code>A</code> with a meta class like this:</p>
<pre><code>class Meta(type):
    pass

class A(metaclass=Meta):
    pass
</code></pre>
<p>Then, when I try to access the name of class <code>A</code> I get the name of the meta class: </p>
<pre><code>A.__class__.__name__
#  'Meta'
</code></pre>
<p>However, shouldn't it give me <code>A</code>, my defined class?</p>
<p><strong>Note:</strong> I tried to use <code>A.__mro__[0].__name__</code> and it does give me <code>A</code>, but I am still confused why <code>A.__class__</code> gives me the meta class name. Does anyone has an explanation of this?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>__class__</code> dunder reports:</p>
<blockquote>
<p>the class to which a class instance belongs.</p>
</blockquote>
<p>Quote from <a href="https://docs.python.org/3/library/stdtypes.html#instance.__class__" rel="nofollow noreferrer"><code>instance.__class__</code></a></p>
<p>The <code>class A</code> belongs to the class of it's metaclass - only instances of <code>A</code> belong to the class <code>A</code> itself.</p>
<pre><code>a = A() 
print(a.__class__.__name__) # 'A' 
print(A.__class__.__name__) # 'Meta'

class P: pass 

print(P.__class__.__name__) # type 
print(P().__class__.__name__) # P
</code></pre>
<p>To get the name of the class itself simply use</p>
<pre><code>A.__name__
</code></pre>
<p>if you really need it.</p>
<hr/>
<p>I am still a way to groke all of <a href="https://stackoverflow.com/a/6581949/7505395">answer</a> to <a href="https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python">What are metaclasses in Python?</a> - maybe it helps you out.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>A</code> is already the class - its name is under <code>A.__name__</code>. 
If you try <code>A.__class__.__name__</code> you will get to the class of which <code>A</code> is instance (that is, its metaclass), name.</p>
<p><code>A.__mro__[0].__name__</code> will follow the "method resolution order" for the class A - the <code>__mro__</code> object is a tuple with all the class hyerarchy that starts in the defined class itself and ends in <code>object</code>. So, <code>A.__mro__[0]</code> will always be <code>A</code> itself - and <code>A.__mro__[0].__name__</code> is the same as <code>A.__name__</code>.</p>
<p>The <code>__name__</code> and <code>__qualname__</code> attributes are writable attributes: changing { <code>__qualname__</code> after the class is created will change the default <code>__repr__</code> for instances of that class, for example. Although they are in the language definition and "live" in slots in the class (not on it's dictionary), it is <em>possible</em> to create a <code>__name__</code> property (I mean, the built-in <code>property</code> object, or any other descriptor) on the metaclass that will dynamically change the <code>__name__</code> attribute of a class (but not <code>__qualname__</code> - this must be an attribute of the class, and must be a string)</p>
</div>
<span class="comment-copy"><code>a = A()</code> and <code>print(a.__class__.__name__)</code> ... <code>'A'</code> - <code>class P: pass</code> ... <code>print(P.__class__.__name__)</code> is <code>type</code> and <code>P</code> if you use the instance ... seems legit</span>
<span class="comment-copy">Oh, yes that works. Is there a way to get the class name without instantiating it, and without using <code>__mro__</code>?</span>
<span class="comment-copy">use <code>A.__name__</code> ?</span>
<span class="comment-copy">Ahh.. Thats exactly what I was missing. Not sure how i missed that. Feel free to write this as the answer.</span>
<span class="comment-copy">Because the <i>class of A</i> is the metaclass. So the <i>name</i> will be meta. A class object is an instance like any other, so just as if you did <code>a = A()</code> and <code>a.__class__.__name__</code> will give you <code>A</code></span>
