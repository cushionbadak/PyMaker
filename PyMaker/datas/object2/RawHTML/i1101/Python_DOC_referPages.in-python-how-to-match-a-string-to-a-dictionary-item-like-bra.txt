<div class="post-text" itemprop="text">
<p>I'm a complete novice at Python so please excuse me for asking something stupid. 
From a textfile a dictionary is made to be used as a pass/block filter.
The textfile contains addresses and either a block or allow like "002029568,allow" or "0011*,allow" (without the quotes).
The search-input is a string with a complete code like "001180000".
How can I evaluate if the search-item is in the dictionary and make it match the "0011*,allow" line?
Thank you very much for your efford!</p>
<p>The filter-dictionary is made with:</p>
<pre><code>def loadFilterDict(filename):
global filterDict
try:
    with open(filename, "r") as text_file:
        lines = text_file.readlines()
        for s in lines:
            fields = s.split(',')
            if len(fields) == 2:
                filterDict[fields[0]] = fields[1].strip()
    text_file.close()
except:
    pass
</code></pre>
<p>Check if the code (ccode) is in the dictionary:</p>
<pre><code>    if ccode in filterDict:                   
                if filterDict[ccode] in ['block']:
                    continue
            else:
                if filterstat in ['block']:
                    continue
</code></pre>
<p>The filters-file is like:</p>
<p>002029568,allow
000923993,allow
0011*, allow</p>
</div>
<div class="post-text" itemprop="text">
<p>If you can use <code>re</code>, you don't have to worry about the wildcard but let <a href="https://docs.python.org/3/library/re.html#re.match" rel="nofollow noreferrer"><code>re.match</code></a> do the hard work for you:</p>
<pre><code># Rules input (this could also be read from file)
lines = """002029568,allow
0011*,allow
001180001,block
"""

# Parse rules from string
rules = []
for line in lines.split("\n"):
    line = line.strip()
    if not line:
        continue
    identifier, ruling = line.split(",")
    rules += [(identifier, ruling)]

# Get rulings for specific number
def rule(number):
    from re import match
    rulings = []
    for identifier, ruling in rules:
        # Replace wildcard with regex .*
        identifier = identifier.replace("*", ".*")
        if match(identifier, number):
            rulings += [ruling]
    return rulings

print(rule("001180000"))
print(rule("001180001"))
</code></pre>
<p>Which prints:</p>
<pre><code>['allow']
['allow', 'block']
</code></pre>
<p>The function will return a list of rulings. Their order is the same order as they appear in your config lines. So you could easily just pick the last or first ruling whichever is the one you're interested in.</p>
<p>Or break the loop prematurely if you can assume that no two rulings will interfere.</p>
<p>Examples:</p>
<ul>
<li><code>001180000</code> is matched by <code>0011*,allow</code> only, so the only ruling which applies is <code>allow</code>.</li>
<li><code>001180001</code> is matched by <code>0011*,allow</code> at first, so you'll get <code>allow</code> as before. However, it is also matched by <code>001180001,block</code>, so a <code>block</code> will get added to the rulings, too.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>If the wildcard entries in the file have a fixed length (for example, you only need to support lines like <code>0011*,allow</code> and not <code>00110*,allow</code> or <code>0*,allow</code> or any other arbitrary number of digits followed by <code>*</code>) you can use a nested dictionary, where the outer keys are the known parts of the wildcarded entries.</p>
<pre><code>d = {'0011': {'001180000': 'value', '001180001': 'value'}}
</code></pre>
<p>Then when you parse the file and get to the line <code>0011*,allow</code> you do not need to do any matching. All you have to do is check if <code>'0011'</code> is present. Crude example:</p>
<pre><code>d = {'0011': {'001180000': 'value', '001180001': 'value'}}

line = '0011*,allow'
prefix = line.split(',')[0][:-1]
if prefix in d:
    # there is a "match", then you can deal with all the entries that match,
    # in this case the items in the inner dictionary
    # {'001180000': 'value', '001180001': 'value'}
    print('match')
else:
    print('no match')
</code></pre>
<p>If you do need to support arbitrary lengths of wildcarded entries, you will have to resort to a loop iterating over the dictionary (and therefore beating the point of using a dictionary to begin with):</p>
<pre><code>d = {'001180000': 'value', '001180001': 'value'}

line = '0011*,allow'
prefix = line.split(',')[0][:-1]
for k, v in d.items():
    if k.startswith(prefix):
        # found matching key-value pair
        print(k, v)
</code></pre>
</div>
<span class="comment-copy">You should add an exemplary excerpt of you source file</span>
<span class="comment-copy">Also, please paste the code how far you've come already. If you don't know how to properly format your code, have a look at <a href="https://stackoverflow.com/editing-help">Editing help</a> which shows how to use Markdown here on StackOverflow.</span>
<span class="comment-copy">There's really no other way to do this than to iterate over <b>all</b> key-value pairs in the dictionary. Dictionaries are implemented as hash-tables, and hashing requires the <i>entire</i> string.</span>
<span class="comment-copy">@meowgoesthedog well, if the length of the input is not arbitrary (meaning, it will always be <code>0011*</code> and never <code>00110*</code>) then a nested dict might solve this problem, ie <code>{'0011':{'00111': 'a', '00110': 'b'}, ...}</code></span>
<span class="comment-copy">@DeepSpace that's true but one would still need to iterate over the levels which overlap with wildcards.</span>
<span class="comment-copy">Thank you so much! It does all I hoped to achieve!</span>
<span class="comment-copy">Probably won't work since it's unlikely the OP only wants fixed prefixes, but still deserves an upvote for a clever trick for the special case of fixed prefix lookup.</span>
<span class="comment-copy">The entries with wildcars are variable in length. The are capcodes from a FLEX message. Some need to be ignored while others need to pass. So in my example 0011* means all messages for my county while 001180000 are testcodes and they need to be filtered out. Also 001165* need to be blocked.</span>
<span class="comment-copy">@JohnK See the edited answer which simply uses iteration and <code>.startswith</code>. There is probably no "smarter"  way for achieving this</span>
