<div class="post-text" itemprop="text">
<p>I was wondering how I can have a changing variable from a function.</p>
<p>I attempted:</p>
<pre><code>class Text():
  File=open("SomeFile.txt", "r")
  MyText=(File.read()+MoreText)
  def AddMoreText():
    MoreText=("This is some more text")
</code></pre>
<p>before realising that I needed to run the <code>MyText</code> variable again which I'm not sure how to do.</p>
<p>I intend to call this text by running something along the lines of <code>print(Text.MyText)</code> which doesn't update after running <code>Text.AddMoreText()</code></p>
<p>I then tried:</p>
<pre><code>class Text():
  global MoreText
  File=open("SomeFile.txt", "r")
  def ChangeTheText():
    return(File.read()+MoreText)
  MyText=ChangeTheText()
  def AddMoreText():
    MoreText=("This is some more text")
</code></pre>
<p>What I didn't know was that the return function preserves its value so when I ran <code>print(Text.MyText)</code> <code>Text.AddMoreText()</code>
<code>print(Text.MyText)</code> it displayed the same text twice.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you want something like:</p>
<pre><code>class Text:
    def __init__(self):
        self.parts = []
        with open('SomeFile.txt', 'r') as contents:
            self.parts.append(contents.read())
        self.parts.append('More text')

    def add_more_text(self, text):
        self.parts.append(text)

    @property
    def my_text(self):
        return ''.join(self.parts)
</code></pre>
<p>This makes <code>.my_text</code> a dynamic <em>property</em> that will be re-computed each time <code>.my_text</code> is retreived. </p>
</div>
<span class="comment-copy">Your <code>AddMoreText()</code> function needs a <code>self</code> argument added. To get it to change the global variable it also needs its own <code>global MoreText</code> statement because otherwise <code>MoreText</code> will be considered a local variable. Having  a <code>global MoreText</code> at the class level does <b>not</b> extend into the methods being defined. I also suggest you start following the <a href="https://www.python.org/dev/peps/pep-0008/#naming-conventions" rel="nofollow noreferrer">PEP 8 Naming Conventions</a>.</span>
<span class="comment-copy">@martineau Thank you, I don't really understand the self argument but I'll give it a go</span>
<span class="comment-copy">@martineau Which of the naming conventions is the right one to follow, or is it that you need to pick one and stick to it entirely?</span>
<span class="comment-copy">John: The <code>self</code> argument is automatically passed to class methods as their first argument. Methods should use it to refer to all attributes (i.e. variables and other methods) that defined by the class. This makes everything work any number of class instances because it tells the methods upon which one to act. As for naming conventions, for Python code without a doubt the best would be the ones in <a href="https://www.python.org/dev/peps/pep-0008/" rel="nofollow noreferrer">PEP 8 - Style Guide for Python Code</a>. It will make your code easier to understand—both for yourself and others.</span>
<span class="comment-copy">John: Python's online documentation has a entire section in its <a href="https://docs.python.org/3/tutorial/index.html#the-python-tutorial" rel="nofollow noreferrer">Tutorial</a> about <a href="https://docs.python.org/3/tutorial/classes.html" rel="nofollow noreferrer">Classes</a>. There's a <a href="https://docs.python.org/3/tutorial/classes.html#random-remarks" rel="nofollow noreferrer">Random Remarks</a> section within that which describes the <code>self</code> argument—although frankly I think you could find an even better explanation elsewhere...</span>
<span class="comment-copy">I'll have to look into the self argument as I'm entirely clueless as to what it does, but thank you.</span>
