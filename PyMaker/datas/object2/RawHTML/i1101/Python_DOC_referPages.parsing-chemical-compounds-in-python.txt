<div class="post-text" itemprop="text">
<p>I'm having trouble processing input from user.</p>
<p><code>Input: C6H12O6</code></p>
<p><code>Expected output: ["C",6, "H", 12, "O", 6]</code> </p>
<p>I'd like to check if the symbol corresponding to the atomic element
is valid which is already stored in my db. But I'm having trouble getting an array output as so.</p>
<pre><code>def createcompound(self, query):
    validatom = False
    query = 'C6H12O6'
    result = []

    firstcompound = query[0:query.find(" ")]        
    for char in firstcompound:
        for atom in self.atoms:
            if char == atom.symbol:
                validatom = True

    symbolcount = 0
    if validatom:
        for char in firstcompound:
           if not (char.isdigit()):
               symbolcount += 1

    print (firstcompound[0:symbolcount])
    print (firstcompound[symbolcount::])
</code></pre>
<p>More importantly, other outputs of chemical formulas need to work as well but so far only some cases are working using O(n^2)</p>
<p>How can I do so in native python 3.6 ?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can leverage <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> using <a href="https://docs.python.org/3/library/stdtypes.html#str.isdigit" rel="nofollow noreferrer"><code>str.isdigit()</code></a> as grouping criteria together with some <a href="https://stackoverflow.com/questions/47789/generator-expressions-vs-list-comprehension/47793">list comprehension / generator comprehension</a> and integer parsing to get your output:</p>
<pre><code>from itertools import groupby

def tryParseInt(x):
    """Tries to parse and return x as integer, on error returns x as is"""
    try:
        return int(x)
    except: # catches any error - you might opt to only catch ValueError
        return x

def split_groupby(text):
    """Splits a text at digit vs. character borders, returns list of characters
    and integers it detects. Uses str.isdigit to differentiate groups:
        'H2SeO4'-&gt; ['H',2,'SeO',4]"""
    groupings = groupby(text,str.isdigit)

    # return it as list or generator - I prefer generator
    # return [ tryParseInt(''.join(grp[1])) for grp in groupings ]
    yield from (tryParseInt(''.join(grp[1])) for grp in groupings ) 


text = "C6H12O6"     
print(list(split_groupby(text)))  
</code></pre>
<p>Output:</p>
<pre><code>['C', 6, 'H', 12, 'O', 6]
</code></pre>
<p>This works by grouping the string into groups of <code>str.isdigit() == True</code> and <code>str.isdigit() == False</code> - and parses the found groups to integer if possible. </p>
<p>To work properly - elements that occur one time need this specifier as well: <code>'C1H3C1H2O1H1'</code> to be seperated into "chemical" elements correctly - if not it will be split as <code>['CH',3,'CH',2,'OH']</code>.</p>
<hr/>
<p>To split off "correctly" spelled Elements from each other (f.e. "H2SeO4") you can post-process the result:</p>
<pre><code>def split_elems(formula):
    """Takes a list and splits strings inside it into title()'d pieces.
    Replaces the former string with the split stings:
        ['H',2,'SeO',4] -&gt; ['H',2,'Se','O',4]"""
    for idx, name in enumerate(formula[:]):
        if isinstance(name,str):
            if sum(c.isupper() for c in name)&gt;1:
                tmp = []
                for c in name:
                    if c.isupper():
                        tmp.append([c])
                    else:
                        tmp[-1].append(c)
                formula.pop(idx)
                for t in tmp[::-1]:
                    formula.insert(idx,"".join(t))
    return formula

text = "H2SeO4"     
print(list(split_groupby(text)))                 # ['H', 2, 'SeO', 4]
print(split_elems(list(split_groupby(text))))    # ['H', 2, 'Se', 'O', 4]
</code></pre>
<hr/>
<p>You can use regex as well - a <a href="https://docs.python.org/3/library/re.html#re.split" rel="nofollow noreferrer">solution using <code>re.split()</code></a> can be found in the question <a href="https://stackoverflow.com/questions/49992790/split-digit-and-text-by-regexp">Split digit and text by regexp</a></p>
</div>
<div class="post-text" itemprop="text">
<p>This will separate the numbers and alphabets into different elements of a list.</p>
<pre><code>import re
str1="C6H12O6"
match = re.findall(r"([A-z]+)([0-9]*)", str1)
lst=[]
for item in match:
    x,y=item
    lst.append(x)
    lst.append(y)
print([x for x in lst if x])
</code></pre>
<p>Output</p>
<pre><code>['C', '6', 'H', '12', 'O', '6']
</code></pre>
<p>But this is not perfect. For example 'CO2' will be split into <code>['CO',2 ]</code>NOT <code>['C','O','2 ]</code> </p>
</div>
<div class="post-text" itemprop="text">
<p>Here's another solution using <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> and <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>operator.itemgetter</code></a>:</p>
<pre><code>from itertools import groupby
from operator import itemgetter

def key_func(x):
    """Groups increasing digits"""
    index, digit = x
    return index - int(digit) if digit.isdigit() else x


def map_int(x):
    """Maps integers"""
    return int(x) if x.isdigit() else x


def group_chemicals(x):
    """Groups chemicals using groupby"""
    return (
        "".join(map(itemgetter(1), g)) for _, g in groupby(enumerate(x), key=key_func)
    )

s = "C6H12O6"
print(list(map(map_int, group_chemicals(s))))
# ['C', 6, 'H', 12, 'O', 6]
</code></pre>
</div>
<span class="comment-copy">what do you mean by "native python 3.6 libs" .. ?</span>
<span class="comment-copy">as in pure python lol</span>
<span class="comment-copy">very interesting. that solves my bit, but is there any way around using explicit call of 1 beside atom</span>
<span class="comment-copy">@hlovyak You could do something with a dictionary-lookup of known elements and capitalisation to split found text's further  .. but if you get <code>'SSN'</code> - and do not have capitalization it could mean <b>S</b>ulphor,<b>S</b>ulphor,<b>N</b>atrium or <b>S</b>ulfur <b>S</b>ele<b>n</b>ium. You would need to do some postprocessing</span>
<span class="comment-copy">You can take a look at <a href="https://cirpy.readthedocs.io/en/latest/" rel="nofollow noreferrer">cirpy.readthedocs.io/en/latest</a> or other python projects dealing with chemistry to get inspiration.</span>
<span class="comment-copy">the split_elems solution is very good, i can now create chemical objects based on a simple atom class, thanks !</span>
<span class="comment-copy">awesome thanks, i was hoping for regex isntead of using str.isidigit</span>
