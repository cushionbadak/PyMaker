<div class="post-text" itemprop="text">
<p>For example:</p>
<pre><code>import numpy as np
import datetime

class Test():

    def __init__(self,atti1,atti2):
        self.atti1 = atti1
        self.atti2 = atti2


l1 = [Test(i,i+1) for i in range(1000000)]
</code></pre>
<p>My solution is:</p>
<pre><code>start_time = datetime.datetime.now()
l11 = np.array([v.atti1 for v in l1])
l12 = np.array([v.atti2 for v in l1])
print(datetime.datetime.now()-start_time)
</code></pre>
<p>It costs 0:00:00.234735 in my macbookpro2017.</p>
<p>It there a more efficient method to make it in python?</p>
<p>---edit1</p>
<p>It is not's not necessary to use numpy.Here is another solution:</p>
<pre><code>l11 = []
l12 = []

start_time = datetime.datetime.now()
for v in l1:
    l11.append(v.atti1)
    l12.append(v.atti2)
print(datetime.datetime.now()-start_time)
</code></pre>
<p>It costs 0:00:00.225412</p>
<p>---edit2</p>
<p>Here is a bad solution:</p>
<pre><code>l11 = np.array([])
l12 = np.array([])
start_time = datetime.datetime.now()

for v in l1:
    l11 = np.append(l11,v.atti1)
    l12 = np.append(l12,v.atti2)
print(datetime.datetime.now()-start_time)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There's no need to use numpy here, and generally list comprehension is good enough. I.e. <code>l11 = [v.atti1 for v in lst]</code> is totally fine.</p>
<p>Conceptually, you <em>must</em> iterate over all objects and access attribute of every single one.</p>
<p>Metrics on "why you should not overengineer":</p>
<pre><code># numpy array builder
np.array([v.atti1 for v in lst])
np.array([v.atti2 for v in lst])
215 ms ± 3.69 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
</code></pre>
<p>This is slowing because you first building list with comprehension, and then re-allocate memory for np array and copy</p>
<pre><code># single list iteration with appending
l1 = []
l2 = []
for v in lst:
    l1.append(v.atti1)
    l2.append(v.atti2)
174 ms ± 384 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
</code></pre>
<p>Better, but you have a lot of function calls for <code>.append</code> and eventually you're re-allocating and copying list.</p>
<pre><code># thing that you always start with, no pre-mature optimizations
l1 = [v.atti1 for v in lst]
l2 = [v.atti2 for v in lst]
99.3 ms ± 982 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
</code></pre>
<p>This is more readable, pythonic, does exactly what it says, and its faster. Internally, its faster because of low-level optimizations of comprehension.</p>
<p>Side note, CPython (that you're most probably using) starting from 3.5 (iirc) uses <a href="https://www.python.org/dev/peps/pep-0412/" rel="nofollow noreferrer">shared-key dictionaries</a> to store object attributes, and starting from 3.6 it's merged with compact dict implementation. Both working great together — memory efficiency gives a huge boost to you raw performance.</p>
<p>Not sure if VM actually leverages shared dict when running comprehensions (probably not) but this must be left to VM optimizations in 99% of cases. High-level abstracted languages (like python) is really not about microoptimizations.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>self.__dict__</code> to return the dictionary of attributes and their values in Python.</p>
<pre><code>import numpy as np
import datetime
import pandas as pd
class Test():
    def __init__(self,atti1,atti2):
        self.atti1 = atti1
        self.atti2 = atti2

    def getAttr(self):
        return self.__dict__


l1 = [Test(i,i+1).getAttr() for i in range(1000000)]

l1 = pd.DataFrame(l1)

l11 = list(l1['atti1'])
l12 = list(l1['atti2'])
</code></pre>
</div>
<span class="comment-copy">I'm confused. What exactly are you trying to do? And if you're trying to evaluate how a bit of Python code performs, don't use <code>datetime.now()</code>, use the <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer"><code>timeit</code> module</a>, which is designed for this purpose.</span>
<span class="comment-copy">1. What are you actually trying to achieve? 2. What is the significance of using <code>numpy</code> here? 3. Why do you think that <code>0:00:00.234735</code> is slow for a list with 1 million objects?  Anyway, 1 method for improving this code is to fetch both attributes in a single pass instead of iterating twice over the entire list</span>
<span class="comment-copy">@DanielPryden Many modules' function return a list of object.I want to know what is the best way to get object's attitudes.</span>
<span class="comment-copy">@DeepSpace That's not necessary.I will edit the question.Thanks.</span>
<span class="comment-copy">@DachuanZhao: Two points of English terminology that I want to clarify. 1. You say "attitudes" but I assume you actually mean "attributes". Is that correct? If so, please clarify it in the question. 2. You ask for the "most effective method". Do you really mean "effective" (as in, able to produce the desired effect) or do you intend something like "efficient" (as in, producing the effect with the smallest amount of work expended)? Please clarify that as well, as that will affect what the answer should be.</span>
<span class="comment-copy">How does this relate to question? OP is asking for lists with raw attributes, not dicts</span>
<span class="comment-copy">The ultimate goal, as I understand, is to get two different lists for two different attributes. This method creates a list of dictionaries of object attributes. A list comprehension or a <code>map</code> or even <code>pandas.DataFrame</code> can be used to create 2 different lists later.</span>
<span class="comment-copy">Solution with pandas is slower by magnitude, literally.</span>
