<div class="post-text" itemprop="text">
<p>I am designing a deck class that has <strong>init</strong>() method with initially has an empty list. Then I append my cards to the list. I am trying to create an x instance and access the shuffled version of the deck of cards. I know there are many solutions posted already. I just want to understand with my logic I am able to print the address of the card elements and not the deck itself. While trying to debug ,I am not understanding whether print(x.cards_in_deck) is printing the location or the x.shuffle... .Any good reference for Pycharm debugging will also be highly appreciated.</p>
<pre><code>suits = ('Hearts', 'Diamonds', 'Spades', 'Clubs')
ranks = ('Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace')
values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
         'Queen':10, 'King':10, 'Ace':11}
class Card:

    def __init__(self,suit,rank):
        self.suit = suit
        self.rank = rank


    def __str__(self):
        return self.rank +' of '+self.suit
class Deck:

    def __init__(self):

        self.cards_in_deck = []
        for suit in suits:
            for rank in ranks:
                self.cards_in_deck.append(Card(suit, rank))
        #return self.cards_in_deck

    def __str__(self):
        # for card in Deck.cards_in_deck:
        #     return(card)
        return self.cards_in_deck

    def shuffle_cards(self):
        return random.shuffle(self.cards_in_deck)

x = Deck()
print(x.cards_in_deck,sep ='\n')
print(x.shuffle_cards(),sep = '\n')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The first print statement will print the value of the instance variable "cards_in_deck" on your Deck object. The type of variable is a list, so when it's printed, it'll look like:</p>
<pre><code>[Two of Hearts, Three of Hearts, &lt;more items&gt;, King of Clubs, Ace of Clubs]
</code></pre>
<p>The second print statement will call the shuffle_cards method on the Deck object, and print whatever that method returns. That method returns the result of calling random.shuffle on the list. That result is a new list, that would be the shuffled cards.</p>
<p>Now, each of these print statements is printing a list object, which is what the text above looks like. If you wanted to print each individual card, you would need to loop through the cards, similarly to how you loop through your lists when initializing the deck. So, you could do something like:</p>
<pre><code>for card in x.cards_in_deck:
    print(card)
</code></pre>
<p>This would print each card's name on a new line each.</p>
<p><strong>EDIT:</strong> I did not see you were using __str__ and not __repr__ in your Card class. When printing a list, Python uses the __repr__ method to determine what to put in the spot in the list. See: <a href="https://stackoverflow.com/questions/12448175/confused-about-str-on-list-in-python">Confused about __str__ on list in Python</a></p>
</div>
<div class="post-text" itemprop="text">
<p>If you print a <code>list</code>, any item in the <code>list</code> is printed using it's <code>repr()</code>. You can define what is used by specifying the <code>__repr(self)__</code> method of your class - you may also want to define the <code>__str__(self)</code> method of your class. If you do not specify a "special" <strong>repr</strong> and <strong>str</strong> python will create default ones for you which may not print what <em>You</em> want it to.</p>
<p>See: <a href="https://stackoverflow.com/questions/1436703/difference-between-str-and-repr">Difference between __str__ and __repr__?</a></p>
<p>Both should return a string - what you are <strong><em>not</em></strong> doing, you return a list for your <code>Deck</code> class which violates the contract of these method's:</p>
<p>Doku:</p>
<ul>
<li><a href="https://docs.python.org/3/reference/datamodel.html#object.__str__" rel="nofollow noreferrer"><code>__str__(self)</code></a></li>
<li><a href="https://docs.python.org/3/reference/datamodel.html#object.__repr__" rel="nofollow noreferrer"><code>__repr__(self)</code></a> </li>
</ul>
<p>Both descriptions say:</p>
<blockquote>
<p>The return value must be a string object.  </p>
</blockquote>
<p>and give some more informations on them.</p>
<hr/>
<p>Fix:</p>
<pre><code>suits = ('Hearts', 'Diamonds', 'Spades', 'Clubs')
ranks = ('Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace')
values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
         'Queen':10, 'King':10, 'Ace':11}

import random

class Card:
    def __init__(self,suit,rank):
        self.suit = suit
        self.rank = rank

    def __str__(self):
        return self.rank +' of '+self.suit
    def __repr__(self):
        return self.rank +' of '+self.suit

class Deck:
    def __init__(self):
        # always create shuffled decks
        self.create_new_deck()

    def __str__(self):  
        # return a string here, not a list
        # join only takes strings so you need to stringify each card beforehand
        return ', '.join(str(c) for c in self.cards_in_deck)        

    def __repr__(self):
        return ', '.join(str(c) for c in self.cards_in_deck)

    # create a new deck and shuffle it immediately
    def create_new_deck(self):
        self.cards_in_deck = [Card(s, r) for s in suits for r in ranks]
        random.shuffle(self.cards_in_deck)

x = Deck()
print(str(x)) 
</code></pre>
<p>Output:</p>
<pre><code>King of Clubs, Ace of Diamonds, Seven of Spades, Ace of Spades, Three of Hearts, 
Eight of Hearts, Five of Clubs, Four of Spades, King of Diamonds, Five of Hearts, 
Eight of Spades, Three of Diamonds, Three of Spades, Six of Diamonds, 
Eight of Diamonds, Queen of Hearts, Ace of Hearts, Ten of Clubs, Two of Diamonds, 
Six of Clubs, King of Hearts, Seven of Clubs, Queen of Clubs, King of Spades, 
Nine of Diamonds, Six of Hearts, Nine of Clubs, Queen of Diamonds, Queen of Spades,
 Ten of Diamonds, Seven of Hearts, Ten of Hearts, Eight of Clubs, Ace of Clubs,
Jack of Clubs, Nine of Spades, Four of Diamonds, Seven of Diamonds, Nine of Hearts,
 Two of Clubs, Jack of Hearts, Jack of Spades, Jack of Diamonds, Two of Spades, 
Ten of Spades, Four of Hearts, Three of Clubs, Six of Spades, Five of Spades, 
Two of Hearts, Five of Diamonds, Four of Clubs
</code></pre>
<p>Debugging:  </p>
<ul>
<li><a href="https://wiki.python.org/moin/PythonDebuggingTools" rel="nofollow noreferrer">https://wiki.python.org/moin/PythonDebuggingTools</a>    (or use an IDE with buildin supoprt for debugging ....)</li>
<li><a href="https://docs.python.org/3/library/pdb.html" rel="nofollow noreferrer">https://docs.python.org/3/library/pdb.html</a></li>
</ul>
</div>
<span class="comment-copy">Sir ,I am unable to print the list.It is just printing the list item location.</span>
<span class="comment-copy">I am getting output of something this sort...[&lt;__main__.Card object at 0x00000208C3792860&gt;, &lt;__main__.Card object at 0x00000208C37928</span>
<span class="comment-copy">Understood. See edit in original answer.</span>
<span class="comment-copy">Is there any pointer method like in c to catch that address and print the values ,since if what you are saying is true ,then I always need to add __str__() or __repr__() method to the class!!!</span>
<span class="comment-copy">Is it always necessary the __str__() and __repr__() method return string type to print?If not necessary ,then we can create our own function convert the return type and print as function(value). Why are they specially called __str__() and __repr__()? Please forgive if u find silly,I am a newbee !!!</span>
