<div class="post-text" itemprop="text">
<p>Here is an example:</p>
<pre><code>list_ = [5, 'cat', 0xDEADBEEF, 4.0]

for offset in range(len(list_)):
    result = 0
    for elem in list_[offset:]:
        result = func(result, elem)
    return result
</code></pre>
<p>where <code>func</code> is non-commutative.</p>
<p>In the code above, <code>list_[offset:]</code> will create a new list, but all I need is a view to <code>list_</code>. How can I optimize this?</p>
</div>
<div class="post-text" itemprop="text">
<p>To replicate your slicing but in O(1) time each iteration, you can use <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>collections.deque</code></a> with <code>popleft</code>:</p>
<pre><code>from collections import deque

dq = deque(list_)

for i in range(len(dq)):
    print(dq)
    dq.popleft()
</code></pre>
<p>Result:</p>
<pre><code>deque([5, 'cat', 3735928559, 4.0])
deque(['cat', 3735928559, 4.0])
deque([3735928559, 4.0])
deque([4.0])
</code></pre>
<p>This should be more efficient than list slicing: see <a href="https://stackoverflow.com/questions/32543608/deque-popleft-and-list-pop0-is-there-performance-difference">deque.popleft() and list.pop(0). Is there performance difference?</a>. Note also list slicing works in O(<em>k</em>) time where <em>k</em> is the length of the slice.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>collections.deque</code>, as suggested by @jpp's answer, is slightly faster <em>sometimes</em>. Both slice and <code>deque</code> solutions perform similarly, and better than e.g. using <code>itertools.islice</code> or just plain indexes on <code>list_</code>.</p>
<p>I've tried to make the versions more or less equivalent overall, and used a dummy <code>func</code> that counts the loops:</p>
<pre><code>from __future__ import print_function
from collections import deque
from itertools import islice
from timeit import repeat

import numpy as np


list_ = [5, 'cat', 0xDEADBEEF, 4.0]
list_3k = list_ * 3000


def func(x, y):
    return x + 1


def f1():
    """list slice"""
    result = 0
    for offset in range(len(list_)):
        for elem in list_[offset:]:
            result = func(result, elem)
    return result


def f2():
    """deque"""
    dq = deque(list_)
    result = 0
    for i in range(len(dq)):
        for elem in dq:
            result = func(result, elem)
        dq.popleft()
    return result


def f3():
    """itertools slice"""
    result = 0
    for offset in range(len(list_)):
        for elem in islice(list_, offset, None):
            result = func(result, elem)
    return result


def f4():
    """basics"""
    result = 0
    n = len(list_)
    for offset in range(n):
        j = offset
        while j &lt; n:
            result = func(result, list_[j])
            j += 1
    return result


def timeit(fn, number):
    print("{}: {} loops".format(fn.__name__, fn()))
    times = repeat(fn, repeat=3, number=number)
    print("{:.3f}s ± {:.3f}ms".format(np.mean(times), np.std(times)*1000))


if __name__ == "__main__":
    fs = [f1, f2, f3, f4]

    for f in fs:
        timeit(f, number=1000000)

    list_ = list_3k
    print()

    for f in fs:
        timeit(f, number=3)
</code></pre>
<p>Results:</p>
<pre><code>bash-3.2$ python3 foo.py 
f1: 10 loops
2.161s ± 9.333ms
f2: 10 loops
2.134s ± 5.127ms
f3: 10 loops
2.340s ± 11.928ms
f4: 10 loops
2.315s ± 4.615ms

f1: 72006000 loops
23.073s ± 109.857ms
f2: 72006000 loops
23.495s ± 596.822ms
f3: 72006000 loops
24.432s ± 553.167ms
f4: 72006000 loops
40.509s ± 128.367ms
</code></pre>
</div>
<span class="comment-copy">In most cases, slicing is the most efficient.</span>
<span class="comment-copy">@tdelaney, In this case, not so. List slicing works in O(<i>k</i>) time where <i>k</i> is the size of the slice. But O(1) is sufficient for OP's algorithm, e.g. via <code>deque</code>.</span>
<span class="comment-copy">@tdelaney, To me this seems like an <a href="https://meta.stackexchange.com/questions/66377/what-is-the-xy-problem">XY problem</a>, which is what I've answered. Do you have a reason to believe the duplicate better addresses the core problem?</span>
<span class="comment-copy">@nalzok, I expect the <code>return</code> should be aligned with the top <code>for</code>?</span>
