<div class="post-text" itemprop="text">
<p>I have 2D numpy array something like this:</p>
<pre><code>arr = np.array([[1,2,4],
                [2,1,1],
                [1,2,3]])
</code></pre>
<p>and a boolean array:</p>
<pre><code>boolarr = np.array([[True, True, False],
                    [False, False, True],
                    [True, True,True]])
</code></pre>
<p>Now, when I try to slice arr based on boolarr, it gives me</p>
<pre><code>arr[boolarr]
</code></pre>
<p>Output:</p>
<pre><code>array([1, 2, 1, 1, 2, 3])
</code></pre>
<p>But I am looking to have a 2D array output instead. The desired output is</p>
<pre><code>[[1, 2],
 [1],
 [1, 2, 3]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An option using <code>numpy</code> is to start by adding up rows in the <code>mask</code>:</p>
<pre><code>take = boolarr.sum(axis=1)
#array([2, 1, 3])
</code></pre>
<p>Then mask the array as you do:</p>
<pre><code>x = arr[boolarr]
#array([1, 2, 1, 1, 2, 3])
</code></pre>
<p>And use <a href="https://docs.scipy.org/doc/numpy-1.15.1/reference/generated/numpy.split.html" rel="nofollow noreferrer"><code>np.split</code></a> to split the flat array according to the <a href="https://docs.scipy.org/doc/numpy-1.15.0/reference/generated/numpy.cumsum.html" rel="nofollow noreferrer"><code>np.cumsum</code></a> of <code>take</code> (as the function expects the indices where to split the array):</p>
<pre><code>np.split(x, np.cumsum(take)[:-1])
[array([1, 2]), array([1]), array([1, 2, 3])]
</code></pre>
<hr/>
<p><b> General solution </b></p>
<pre><code>def mask_nd(x, m):
    '''
    Mask a 2D array and preserve the
    dimension on the resulting array
    ----------
    x: np.array
       2D array on which to apply a mask
    m: np.array
        2D boolean mask  
    Returns
    -------
    List of arrays. Each array contains the
    elements from the rows in x once masked.
    If no elements in a row are selected the 
    corresponding array will be empty
    '''
    take = m.sum(axis=1)
    return np.split(x[m], np.cumsum(take)[:-1])
</code></pre>
<hr/>
<p><b> Examples </b></p>
<p>Lets have a look at some examples:</p>
<pre><code>arr = np.array([[1,2,4],
                [2,1,1],
                [1,2,3]])

boolarr = np.array([[True, True, False],
                    [False, False, False],
                    [True, True,True]])

mask_nd(arr, boolarr)
# [array([1, 2]), array([], dtype=int32), array([1, 2, 3])]
</code></pre>
<p>Or for the following arrays:</p>
<pre><code>arr = np.array([[1,2],
                [2,1]])

boolarr = np.array([[True, True],
                    [True, False]])

mask_nd(arr, boolarr)
# [array([1, 2]), array([2])]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your desired output is not a 2D array, since each "row" has a different number of "columns". A functional non-vectorised solution is possible via <a href="https://docs.python.org/3/library/itertools.html#itertools.compress" rel="nofollow noreferrer"><code>itertools.compress</code></a>:</p>
<pre><code>from itertools import compress

res = list(map(list, map(compress, arr, boolarr)))

# [[1, 2], [1], [1, 2, 3]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's one way to do it with <code>list</code> instead:</p>
<pre><code>[[arr[row][col] for col in range(3) if boolarr[row][col]] for row in range(3)]
# [[1,2], [1], [1,2,3]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You may be looking for something as simple as a <a href="https://docs.scipy.org/doc/numpy/reference/maskedarray.html" rel="nofollow noreferrer">masked array</a>. You can use the mask to create an array that masks out the desired values, so that they are not affected by further operations and don't affect the results of calculations:</p>
<pre><code>marr = np.ma.array(arr, mask=~boolarr)
</code></pre>
<p>Notice that the mask must be flipped since it's the invalid elements that are masked. The result will look like</p>
<pre><code>masked_array(data=[
        [ 1  2 --]
        [-- --  1]
        [ 1  2  3]],
    mask=[
        [False False  True]
        [ True  True False]
        [False False False]],
    fill_value = 999999)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>In [183]: np.array([x[y] for x,y in zip(arr, boolarr)])
Out[183]: array([array([1, 2]), array([1]), array([1, 2, 3])], dtype=object)
</code></pre>
<p>should be competitive in speed.  (It's a little faster if we omit the outer <code>np.array</code> wrap, returning just a list of arrays.)</p>
<p>But realistic time tests are needed to be sure.</p>
</div>
<span class="comment-copy">Just FYI, pure Numpy arrays with varying row lengths don't exist as far as I'm aware. You could have a nested list, a Numpy array of references to lists, or a list of Numpy arrays, however.</span>
<span class="comment-copy">@Tomothy32 Second that. Depending on what you want to do with it, I would either stick with Python <code>list</code> or use something as placeholders in the non-desired positions (nan)</span>
<span class="comment-copy">@Tomothy32 they kinda exist. You get an array of list types because it's not possible to have continguous blocks of memory for such structures. But, they might as well be lists :)</span>
<span class="comment-copy">@roganjosh Yes, I just mean with OP's wanted operation you won't get something similar to the 3x3 2D array you started with.</span>
<span class="comment-copy">@Tomothy32 correct. OP, you're probably looking at an XY problem or, at the very least, creating issues for yourself here using numpy. You may be able to maintain the shape of the array if you're willing to accept something like <code>np.nan</code> at the indices you don't want (perhaps that's enough for you to carry forward to the next step of whatever calculation you're doing)</span>
<span class="comment-copy">I really like this approach, since it mainly uses numpy and the result is also mostly consisting of numpy arrays (except for the enclosing list of course).</span>
<span class="comment-copy">Pretty inefficient tho, on a numpy array.</span>
<span class="comment-copy">@U9-Forward no less efficient than on a list, and the OP's desired output doesn't really work in NumPy</span>
<span class="comment-copy">@roganjosh Okay.</span>
<span class="comment-copy">On this small example this times about the same as all the rest.  The <code>split</code> one is slowest.</span>
