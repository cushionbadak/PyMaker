<div class="post-text" itemprop="text">
<p>I'm trying to create a function that creates a dictionary, given a list that will be inputted.
I thought by using a for loop, i could take the list, create the key, and then use the loop to input the values for each item of the list.</p>
<p>Using this list as an input:</p>
<pre><code>simpsons = 'Homer', 'Bart', 'Marge', 'Lisa'

def create_dict_from_list(names):
    name_dict = {}
    for name in names:
        name_dict['name']= name
    return name_dict
</code></pre>
<p>This is only returning one key, value pair.
It looks like dictionaries don't create multiple values, and so that is why it only returns one and doesn't go through the rest of the list.</p>
<p>When I change <code>name_dict[name] = name</code>, it will create all the key, values, but key and value are both the name.</p>
<p>When I change <code>name_dict[name] = 'name'</code>, I get the key, value reversed, but it returns all 4 items in the list.</p>
</div>
<div class="post-text" itemprop="text">
<p>For the answer you want (based on my understanding of your question), I am not sure why you were using for loop. You don't need for loops in your function. Just a simple assignment will do the job. You unnecessarily complicated it.</p>
<pre><code>simpsons = ['Homer', 'Bart', 'Marge', 'Lisa']

def create_dict_from_list(names):
    name_dict = {}
    name_dict['name'] = names # &lt;--- No need of for loop
    return name_dict
create_dict_from_list(simpsons)
# {'name': ['Homer', 'Bart', 'Marge', 'Lisa']}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You may set the default value as an empty list <code>[]</code> for a key <code>'name'</code>
For the given example, it is okay not to use the <code>for</code> loop(as answered by @Bazingaa) if you want to assign all the names to the key <code>'name'</code>. On the other hand, if you want to selectively assign the names then use <code>for</code> loop.</p>
<pre><code>simpsons = 'Homer', 'Bart', 'Marge', 'Lisa'

def create_dict_from_list(names):
    name_dict = {}
    name_dict.setdefault('name',[])
    for name in names:
        name_dict['name'].append(name)
    return name_dict
create_dict_from_list(simpsons)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>{'name': ['Homer', 'Bart', 'Marge', 'Lisa']}
</code></pre>
</div>
<span class="comment-copy">What do you actually want as values?</span>
<span class="comment-copy">Read here: <a href="https://stackoverflow.com/a/53907980/7505395">stackoverflow.com/a/53907980/7505395</a>  (my answer) - similar problem. and here: <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="nofollow noreferrer">docs.python.org/3/tutorial/datastructures.html#dictionaries</a>. One key can only hold one value - that value can be a list that holds multiple values. if you use <code>d["name"]= ...</code> multiple times you overwrite the same keys value over and over...</span>
<span class="comment-copy">The behaviour you described is exactly what is expected in each case. It's unclear what you actually want though.</span>
<span class="comment-copy">ya; correct you are. The problem is that your last iteration lastly assigns the last value of your list to the 'names' key of your dictionary; and since you had only that key all the time on which you were iterating; thus that is the only key-value pair left.</span>
<span class="comment-copy">Can you explicitly state your expected output?  Should be something like: map = {'name': ['Homer', 'Bart', 'Marge', 'Lisa']} or something else?</span>
<span class="comment-copy">Ha ha I am laughing at my answer now</span>
<span class="comment-copy">@mad_: Still you got upvoted ;)</span>
<span class="comment-copy">The way you have the variable <code>simpsons</code>, listing the names without square brackets, will create a tuple (and thus a tuple in the dictionary), instead of a list. Not only is the list mutable while the tuple is immutable, but the function is expecting a list.</span>
<span class="comment-copy">I think it hardly matters here. Both are iterables and I am initalizing the dict key with default list. It will be overkill to un-necessarily convert the presented input into a list. We are not changing element of the list so it does not matter whether the data structure is a tuple or a list. we just need an iterable. A well-defined string will also do in this case.Thanks</span>
