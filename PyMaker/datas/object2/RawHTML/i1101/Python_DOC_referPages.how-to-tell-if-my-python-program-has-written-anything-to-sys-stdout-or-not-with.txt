<div class="post-text" itemprop="text">
<p>I'm making a program that has different control flows depending on whether  anything was written to <code>sys.stdout</code> or not. I made this program first in my Mac and I could do this</p>
<pre class="lang-py prettyprint-override"><code>pos = sys.stdout.tell()
exec(some_code, globals)
if pos == sys.stdout.tell():
    # ...
</code></pre>
<p>But it turns out that I could not use <code>tell()</code> method on Linux and that's a problem for me. How can I tell if <code>sys.stdout</code> has been touched or not in this case?</p>
<p>One think I can come up with is to make a wrapper class for both <code>sys.stdout</code> and <code>sys.stdout.buffer</code> to monitor all writing calls, although I'm not sure it's robust way of doing it.</p>
<p>Or I think I may can give <code>contextlib.redirect_stdout</code> a try. But I am not sure how can I make use of it..</p>
<p>EDIT:
I'm working on this utility <a href="https://github.com/bombs-kim/pythonp" rel="nofollow noreferrer">https://github.com/bombs-kim/pythonp</a>. The feature I'm trying to implement is to automatically write the last expression of <code>some_code</code> in <code>exec(some_code, globals)</code> to stdout when there was no output to stdout.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>How can I tell if sys.stdout has been touched or not in this case?</p>
</blockquote>
<p><strong>You cannot</strong>, because stdout might have been <a href="https://en.wikipedia.org/wiki/Redirection_(computing)" rel="nofollow noreferrer">redirected</a> or in a <a href="https://en.wikipedia.org/wiki/Pipeline_(Unix)" rel="nofollow noreferrer">pipeline</a> (by the command used in your shell to run your Python script). For example, your user could have redirected stdout to <a href="https://en.wikipedia.org/wiki/Null_device" rel="nofollow noreferrer"><code>/dev/null</code></a> (see <a href="http://man7.org/linux/man-pages/man4/null.4.html" rel="nofollow noreferrer">null(4)</a>) by running your <code>script.py</code> as <code>script.py &gt; /dev/null</code> for example, and then your question don't even make any sense. And your <code>stdout</code> might even be a socket, a fifo, a device, etc. Also, the <a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow noreferrer"><code>exec</code></a>-ution of <code>some_code</code> might change <code>stdout</code> (e.g. close it, redirect it using <a href="https://docs.python.org/3/library/os.html?highlight=dup2#os.dup2" rel="nofollow noreferrer"><code>os.dup2</code></a>, redefine itself the <code>stdout</code> Python object, etc...)</p>
<p>Also, your program might not even be run in a terminal (think of a <a href="http://man7.org/linux/man-pages/man5/crontab.5.html" rel="nofollow noreferrer">crontab(5)</a> job, or running your program with <code>at</code> or <code>ssh</code>). See also t<a href="http://www.linusakesson.net/programming/tty/" rel="nofollow noreferrer">he tty demystified</a> page.</p>
<p>The stdout <a href="https://en.wikipedia.org/wiki/Standard_streams" rel="nofollow noreferrer">standard stream</a> is (conventionally) set up by the invoking process (usually, but not always, some shell) which has <a href="http://man7.org/linux/man-pages/man2/fork.2.html" rel="nofollow noreferrer">fork(2)</a>-ed and <a href="http://man7.org/linux/man-pages/man2/execve.2.html" rel="nofollow noreferrer">execve(2)</a>-ed your script.</p>
<p>And that is not Linux specific, it is the <a href="https://en.wikipedia.org/wiki/Unix_philosophy" rel="nofollow noreferrer">Unix philosophy</a>. You may want to read some Unix or Linux programming book (such as <a href="http://www.makelinux.net/alp/" rel="nofollow noreferrer">ALP</a>).</p>
<p>You might detect the case when your <em>stdout</em> is a terminal, by using <a href="http://man7.org/linux/man-pages/man3/isatty.3.html" rel="nofollow noreferrer">isatty(3)</a>. But that certainly does not cover all the possible use-cases.</p>
<p>Linux has <code>/proc/</code> (see <a href="http://man7.org/linux/man-pages/man5/proc.5.html" rel="nofollow noreferrer">proc(5)</a> for more) and the stdout is also <code>/dev/stdout</code> a.k.a. <code>/proc/self/fd/1</code> on which you might do a <a href="http://man7.org/linux/man-pages/man2/stat.2.html" rel="nofollow noreferrer">stat(2)</a> (and of course you could directly do <code>fstat</code> on <code>STDOUT_FILENO</code> which is 1). But even that won't cover all the possible use-cases.</p>
<p>Have you thought of the case when your program monitors itself (e.g. <code>pythonp pythonp</code> ...) ?</p>
<p>I am not sure to understand your real goals, but they ring the <a href="https://en.wikipedia.org/wiki/Rice's_theorem" rel="nofollow noreferrer">Rice's theorem</a> in my head and your problem could be undecidable.</p>
</div>
<div class="post-text" itemprop="text">
<p>I solved it on my own by wrapping both <code>sys.stdout.write</code>, <code>sys.stdout.buffer.write</code> in python3.</p>
<pre class="lang-py prettyprint-override"><code>import sys
write = sys.stdout.write

write_called = [False]


def make_write_hook(old_writer, flag: list):
    self = old_writer.__self__

    def new_writer(value):
        self.write = old_writer
        flag[0] = True
        old_writer(value)
    return new_writer


sys.stdout.write = make_write_hook(sys.stdout.write, write_called)
sys.stdout.buffer.write = make_write_hook(
    sys.stdout.buffer.write, write_called)

history = []
history.append(write_called[0])
print("hello world")
history.append(write_called[0])
print(history)

# ### output
# hello world
# [False, True]
</code></pre>
<p>By my observation on cpython's standard library code, python's convention is that all writes to standard output should done by calling <code>sys.stdout.write</code> or <code>sys.stdout.buffer.write</code>, not directly calling something like <code>os.fdopen(1, 'w').write</code>. This is my temporary conclusion and I would like anyone who knows python better than me confirm this. Thank you everybody!</p>
</div>
<span class="comment-copy">Your solution of using a wrapper class sounds like the correct approach in this case.</span>
<span class="comment-copy">Why do you ask, and what is the use case? Please <a href="https://stackoverflow.com/posts/53994438/edit">edit</a> your question (providing some <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a> and giving the actual commands you are using) to motivate it.</span>
<span class="comment-copy">Thank you for the answer! If there is no way I can directly monitor file descriptor 1 as you said, do you think I can make a wrapper for python's <code>sys.stdout</code> object to detect every write event?</span>
<span class="comment-copy">Sorry, I don't understand that comment! What about the redirection to <code>/dev/null</code> mentioned in my answer?</span>
<span class="comment-copy">Sorry If I didn't make much sense in my comment. It's not important whether the end user redirect stdout to /dev/null or not in my case. As I previously said, I think I just need a hook for writing event to python's sys.stdout. Seems like one of the commenters on my question understood my intention.</span>
<span class="comment-copy">And I just want to detect write events within the same program that called <code>exec</code>.</span>
<span class="comment-copy">@bombs im curious now as well, it seems like you can wrap around sys.stdout and intercept any call to it</span>
