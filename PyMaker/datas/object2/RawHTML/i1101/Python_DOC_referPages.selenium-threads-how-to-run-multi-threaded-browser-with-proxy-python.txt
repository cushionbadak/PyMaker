<div class="post-text" itemprop="text">
<p>I'm writing a script to access a website using proxies with multiple threads but now I'm stuck in multiple threads, when I run the script below, it opens 5 browsers but all 5 use 1 proxy, I want 5 browsers to use different proxies, can someone help me complete it? thank you  </p>
<p>Here is my script :</p>
<pre><code>from selenium import webdriver
from selenium import webdriver
import time , random
import threading


def e():

    a = open("sock2.txt", "r")
    for line in a.readlines():

        b = line
        prox = b.split(":")
        IP = prox[0]
        PORT = int(prox[1].strip("\n"))
        print(IP)
        print(PORT)


        profile = webdriver.FirefoxProfile()
        profile.set_preference("network.proxy.type", 1)
        profile.set_preference("network.proxy.socks", IP)
        profile.set_preference("network.proxy.socks_port", PORT)
        try:

            driver = webdriver.Firefox(firefox_profile=profile)
            driver.get("http://www.whatsmyip.org/")
        except:
            print("Proxy Connection Error")
            driver.quit()
        else:
            time.sleep(random.randint(40, 70))
            driver.quit()
for i in range(5):
    t = threading.Thread(target=e)
    t.start()
</code></pre>
<p>(Wish everyone has a happy and lucky new year)</p>
</div>
<div class="post-text" itemprop="text">
<p>Dominik La≈°o captured it correctly - each threads processes the file from the beginning. Here's probably how it should look like:</p>
<pre><code>from selenium import webdriver
from selenium import webdriver
import time , random
import threading


def e(ip, port):
    profile = webdriver.FirefoxProfile()
    profile.set_preference("network.proxy.type", 1)
    profile.set_preference("network.proxy.socks", IP)
    profile.set_preference("network.proxy.socks_port", PORT)
    try:
        driver = webdriver.Firefox(firefox_profile=profile)
        driver.get("http://www.whatsmyip.org/")
    except:
        print("Proxy Connection Error")
        driver.quit()
    else:
        time.sleep(random.randint(40, 70))
        driver.quit()

my_threads = []
with open("sock2.txt", "r") as fd:
    for line in fd.readlines():
        line = line.strip()
        if not line:
           continue
        prox = line.split(":")
        ip = prox[0]
        port = int(prox[1])
        print('-&gt; {}:{}'.format(ip, port))
        t = threading.Thread(target=e, args=(ip, port,))
        t.start()
        my_threads.append(t)

for t in my_threads:
    t.join()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>( I personaly think that a problem is there that when you start a program, it will go to new thread, which will go throught the textfile from beginning, becasue you aint deleting them )</p>
<p>I have cane across the same problem, when I was doing the same thing as you do now. I know you would rather want help with your code, but I am in hurry to test it and want to help you ;) , so here is a code that works for me ... There is even task killer for a chrome ( you just have to edit it to firefox )</p>
<h3>If I were you, I would start the thread after opening the file, cuz it looks liek you are opening the same file from 1st line everytime the tread starts</h3>
<pre><code>links = [ // Link you want to go to ]

def funk(xxx , website):
    link = website
    chrome_options = webdriver.ChromeOptions()
    chrome_options.add_argument('--proxy-server=%s' % str(xxx))
    chromedriver = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'chromedriver')
    chrome = webdriver.Chrome(chromedriver, chrome_options=chrome_options)
    try :
        // Do stuff
    except:
        print('exception')
    chrome.close()

for link in links:
    f = open('proxies.txt')
    line = f.readline()
    x = 1
    xx = 0
    while line:
        if number_of_used_proxies &lt; 10:
            print(line)
            line = f.readline()
            try:
                threading.Timer(40, funk, [line, link]).start()
            except Exception as e:
                print(e)
            time.sleep(1)
            x += 1
            number_of_used_proxies += 1
        else:
            time.sleep(100)
            for x in range(1, 10):
                try:
                    xzxzx = 'os.system("taskkill /f /im chrome.exe")'
                    os.system("killall 'Google Chrome'")
                except:
                    print("NoMore")
            time.sleep(10)
            number_of_used_proxies = 0

    f.close()
</code></pre>
<blockquote>
<p>Hope it helps :)</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p><strong>vantuong</strong>: Here's how you can solve the problem with ThreadPoolExecutor.</p>
<p><strong>Reference</strong>: <a href="https://docs.python.org/3/library/concurrent.futures.html" rel="nofollow noreferrer">https://docs.python.org/3/library/concurrent.futures.html</a></p>
<pre><code>from selenium import webdriver
from selenium import webdriver
import time , random
#import threading
import concurrent.futures

MAX_WORKERS = 5

def get_proxys(data_file):
    proxys = []
    with open(data_file, "r") as fd:
        for line in fd.readlines():
            line = line.strip()
            if not line:
               continue
            prox = line.split(":")
            ip = prox[0]
            port = int(prox[1])
            proxys.append((ip, port))
    return proxys


def e(ip, port):
    profile = webdriver.FirefoxProfile()
    profile.set_preference("network.proxy.type", 1)
    profile.set_preference("network.proxy.socks", IP)
    profile.set_preference("network.proxy.socks_port", PORT)
    try:
        driver = webdriver.Firefox(firefox_profile=profile)
        driver.get("http://www.whatsmyip.org/")
    except:
        print("Proxy Connection Error")
        driver.quit()
    else:
        time.sleep(random.randint(40, 70))
        driver.quit()


with concurrent.futures.ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
    proxys = get_proxys('sock2.txt')
    tasks = {executor.submit(e, proxy[0], proxy[1]): proxy for proxy in proxys}
    for task in concurrent.futures.as_completed(tasks):
        proxy = tasks[task]
        try:
            data = task.result()
        except Exception as exc:
            print('{} generated an exception: {}'.format(proxy, exc))
        else:
            print('{} completed successfully'.format(proxy))
</code></pre>
<p><strong><em>Fun exercise: Try playing around with different values of MAX_WORKERS.</em></strong></p>
</div>
<span class="comment-copy">What's the content of sock2.txt? Do you have 5 different proxies configured and each line of input has a different value of IP and PORT?</span>
<span class="comment-copy">yes ! It is a list of socks in txt file</span>
<span class="comment-copy">Does each line of input has a different value for proxy IP and PORT?</span>
<span class="comment-copy">yes , each line has a different value and port</span>
<span class="comment-copy">I edit IP, PORT---&gt; it works !! but it runs a lot of threads, i put 50 socks in txt file and it run 50 browsers !Is there any way to run only 5 threads then run the next 5 threads?</span>
<span class="comment-copy">You can read the file and create a list of 5 IP and ports. Then in a while loop, process 5 elements in a list (5 threads). Once those 5 are over, process next 5 and so on. A more efficient implementation would be to use ThreadPoolExecutor from concurrent.futures with pool size of 5 - it will automatically take care of limiting max threads to 5, at a time.</span>
<span class="comment-copy">thanks , Sharad ! If you have a bit of time, can you help me edit the script above with ThreadPoolExecutor?</span>
<span class="comment-copy">Added another example with ThreadPoolExecutor below.</span>
<span class="comment-copy">np problem ;) can you mark it as answered please ?</span>
<span class="comment-copy">I really want but  i can't</span>
<span class="comment-copy">Because you marked different already</span>
<span class="comment-copy">It's a perfect solution !! &lt;3 ! thanks , Sharad .</span>
