<div class="post-text" itemprop="text">
<p>I'm trying to send a dictionary into a function that caculated the average, I believe my function is good but I'm having trouble with sending the dictionary</p>
<pre><code>my_dict = {"first": 100, "second": 0, "third": 200}

def avg(dict):

    sum=0
    count=0
    for k,v in dict:
        sum = sum+v
        count +=1
    return(sum/count)


result = avg(**my_dict)

print(result)
</code></pre>
<p>The output should be 100 that goes into "result"</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>my_dict = {"first": 100, "second": 0, "third": 200}
def dictavg(your_dict):
    return sum(your_dict.values())/len(your_dict)
print(dictavg(my_dict))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Drop the asterisks and use <code>.items()</code> on the dict</p>
<pre><code>my_dict = {"first": 100, "second": 0, "third": 200}

def avg(dict):

    sum=0
    count=0
    for k,v in dict.items():
        sum = sum+v
        count +=1
    return(sum/count)


result = avg(my_dict)

print(result)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Pass your dictionary directly, not via the <code>**</code> dictionary unpacking operator. Do the unpacking <em>within your function</em> instead: iterating <a href="https://docs.python.org/3/library/stdtypes.html#dict.items" rel="nofollow noreferrer"><code>dict.items</code></a> gives key-value pairs, but here you can use <a href="https://docs.python.org/3/library/stdtypes.html#dict.values" rel="nofollow noreferrer"><code>dict.values</code></a>.</p>
<p>Also, <strong>never shadow built-ins</strong>. So don't use <code>dict</code>, <code>sum</code>, etc as variable names.</p>
<p>This would work:</p>
<pre><code>def avg(d):

    val_sum = 0
    count = 0
    for v in d.values():
        val_sum += v
        count += 1
    return(val_sum/count)

result = avg(my_dict)  # 100.0
</code></pre>
<p>You can also use the built-ins <a href="https://docs.python.org/3/library/functions.html#sum" rel="nofollow noreferrer"><code>sum</code></a> and <a href="https://docs.python.org/3/library/functions.html#len" rel="nofollow noreferrer"><code>len</code></a>:</p>
<pre><code>result = sum(my_dict.values()) / len(my_dict.values())
</code></pre>
<p>Or use <a href="https://docs.python.org/3/library/statistics.html#statistics.mean" rel="nofollow noreferrer"><code>statistics.mean</code></a>:</p>
<pre><code>from statistics import mean

result = mean(my_dict.values())  # 100
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You cannot use the following statement with a dictionary:</p>
<pre><code>for k, v in dict:
</code></pre>
<p>instead there is a way to receive a list of the keys or the values of the dictionary using the methods keys() or values() respectively. these methods return a list of the dictionary keys or the dictionary values and then you can iterate over them. Also there is a method which returns a list of tuples of key and value - items().</p>
<p>So any of these should work for you:</p>
<pre><code>my_dict = {"first": 100, "second": 0, "third": 200}

def avg(dicti):

    total_sum=0
    count=0
    for key in dicti.keys():
        sum += dicti[key]
        count +=1
    return(sum/count)

result = avg(my_dict)

print(result)
</code></pre>
<p>or:</p>
<pre><code>my_dict = {"first": 100, "second": 0, "third": 200}

def avg(dicti):

    total_sum=0
    count=0
    for value in dicti.values():
        sum += value
        count +=1
    return(sum/count)

result = avg(my_dict)

print(result)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just try:</p>
<pre><code>my_dict = {'first': 100, 'second': 0, 'third': 200}
avg = sum(my_dict.values()) / len(my_dict)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Dont use keywords as variable names, such as <code>dict</code> or <code>sum</code>. You can send your whole dictionary, and iterate over the items:</p>
<pre><code>my_dict = {"first": 100, "second": 0, "third": 200}

def avg(a_dict):
    total=0
    count=0
    for k,v in a_dict.items():
        total = total+v
        count +=1
    return(total/count)


result = avg(my_dict)

print(result)
</code></pre>
<p>Note that the avg is 100.</p>
</div>
<span class="comment-copy">sum(my_dict.values()) / len(d)</span>
<span class="comment-copy">The output should be 100, right? Or do you wish to do something else?</span>
<span class="comment-copy"><code>k</code> is not being used. You can just sum the values with <code>sum(dict.values())</code>.</span>
<span class="comment-copy">Oh yeah, true.. I only changed the bits it failed on, didn't re-write it (or I would have also changed the poorly chosen variable names)</span>
<span class="comment-copy">I wonder how to rewrite this if we were to pass as unpacking operator.</span>
<span class="comment-copy">@YOLO, Unpacking doesn't help you solve your problem. So I advise you don't do it.</span>
<span class="comment-copy">@jpg actually it is solvable with unpacking, just very superfluous. <code>f = lambda **kwargs: sum(kwargs.values())/len(kwargs)</code> then <code>f(**my_dict)</code></span>
<span class="comment-copy">@YOLO see my comment above</span>
<span class="comment-copy">@DeepSpace, Yes, but that doesn't help. It's an extremely poor use of function arguments.</span>
