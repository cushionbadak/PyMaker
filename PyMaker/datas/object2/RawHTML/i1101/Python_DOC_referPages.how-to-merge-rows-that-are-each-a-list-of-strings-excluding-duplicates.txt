<div class="post-text" itemprop="text">
<p>Im working with music data and need to encode genre classifications for a regression algorithm, python 3 pandas. I would like to encode the categories to 0 or 1 if classified for a genre. The data is in a pandas data frame and contains duplicate values. I want to merge all the rows into a single list of unique values and then use get_dummies to encode for each record..</p>
<p>1st attempt: </p>
<pre><code>for i in x:
    a = genres + list(i)
    genres.append(a)
</code></pre>
<p>2nd attempt:</p>
<pre><code>x = list of genres (like below)
[j for i in x for j in i]

list(itertools.chain(x))
</code></pre>
<p>input:</p>
<p>row 1 = <code>['hip hop', 'rock','pop rock','country']</code></p>
<p>row 2 = <code>['pop', 'rock', 'pop rock' ,'alternative rock']</code></p>
<p>expected output:</p>
<pre><code>new list = ['hip hop', 'rock','country','pop','pop rock','alternative rock']
</code></pre>
<p>Final output</p>
<pre><code>      | hip hop | rock | country | pop | pop rock | alternative rock |
row 1 |   1     | 1    |  1      | 0   | 1        |  0               |
row 2 |   0     | 1    |  0      | 1   | 1        |  1               |
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If order of the elements is not important, you could consider each list as a <a href="https://docs.python.org/3/library/stdtypes.html#set" rel="nofollow noreferrer">set</a> find the <a href="https://docs.python.org/3/library/stdtypes.html#frozenset.union" rel="nofollow noreferrer">union</a> and then convert back to a list:</p>
<pre><code>def merge(r1, r2):
    return list(set().union(r1, r2))


row_1 = ['hip hop', 'rock','pop rock','country']
row_2 = ['pop', 'rock', 'pop rock' ,'alternative rock']

print(merge(row_1, row_2))
</code></pre>
<p><strong>Output</strong></p>
<pre><code>['pop rock', 'alternative rock', 'country', 'hip hop', 'rock', 'pop']
</code></pre>
<p>However, if the order (of appearance) does matter, you could do the following:</p>
<pre><code>from itertools import chain

def merge_with_order(r1, r2):

    seen = set()
    result = []
    for e in chain(r1, r2):
        if e not in seen:
            seen.add(e)
            result.append(e)

    return result


row_1 = ['hip hop', 'rock','pop rock','country']
row_2 = ['pop', 'rock', 'pop rock' ,'alternative rock']

print(merge_with_order(row_1, row_2))
</code></pre>
<p><strong>Output</strong></p>
<pre><code>['hip hop', 'rock', 'pop rock', 'country', 'pop', 'alternative rock']
</code></pre>
<p>If you prefer a one-liner consider using <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">collections.OrderedDict</a>:</p>
<pre><code>from itertools import chain
from collections import OrderedDict


def merge_with_order(r1, r2):
    return list(OrderedDict.fromkeys(chain(r1, r2)))
</code></pre>
</div>
<span class="comment-copy">Thanks for the response. This helps. I need to do this for a list of rows or rows in a data frame.</span>
