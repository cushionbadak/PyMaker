<div class="post-text" itemprop="text">
<p>If you execute the following statement in Python 3.7, it will (from my testing) print <code>b</code>:</p>
<pre><code>if None.__eq__("a"):
    print("b")
</code></pre>
<p>However, <code>None.__eq__("a")</code> evaluates to <code>NotImplemented</code>.</p>
<p>Naturally, <code>"a".__eq__("a")</code> evaluates to <code>True</code>, and <code>"b".__eq__("a")</code> evaluates to <code>False</code>.</p>
<p>I initially discovered this when testing the return value of a function, but didn't return anything in the second case -- so, the function returned <code>None</code>.</p>
<p>What's going on here?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a great example of why the <code>__dunder__</code> methods should not be used directly as they are quite often not appropriate replacements for their equivalent operators; you should use the <code>==</code> operator instead for equality comparisons, or in this special case, when checking for <code>None</code>, use <code>is</code> (skip to the bottom of the answer for more information). </p>
<p>You've done </p>
<pre><code>None.__eq__('a')
# NotImplemented
</code></pre>
<p>Which returns <code>NotImplemented</code> since the types being compared are different. Consider another example where two objects with different types are being compared in this fashion, such as <code>1</code> and <code>'a'</code>. Doing <code>(1).__eq__('a')</code> is also not correct, and will return <code>NotImplemented</code>. The right way to compare these two values for equality would be  </p>
<pre><code>1 == 'a'
# False
</code></pre>
<p>What happens here is</p>
<ol>
<li>First, <code>(1).__eq__('a')</code> is tried, which returns <code>NotImplemented</code>. This indicates that the operation is not supported, so </li>
<li><code>'a'.__eq__(1)</code> is called, which also returns the same <code>NotImplemented</code>. So, </li>
<li>The objects are treated as if they are not the same, and <code>False</code> is returned.</li>
</ol>
<p>Here's a nice little MCVE using some custom classes to illustrate how this happens:</p>
<pre><code>class A:
    def __eq__(self, other):
        print('A.__eq__')
        return NotImplemented

class B:
    def __eq__(self, other):
        print('B.__eq__')
        return NotImplemented

class C:
    def __eq__(self, other):
        print('C.__eq__')
        return True

a = A()
b = B()
c = C()

print(a == b)
# A.__eq__
# B.__eq__
# False

print(a == c)
# A.__eq__
# C.__eq__
# True

print(c == a)
# C.__eq__
# True
</code></pre>
<hr/>
<p>Of course, that doesn't explain <em>why</em> the operation returns true. This is because <code>NotImplemented</code> is actually a truthy value:</p>
<pre><code>bool(None.__eq__("a"))
# True
</code></pre>
<p>Same as,</p>
<pre><code>bool(NotImplemented)
# True
</code></pre>
<p>For more information on what values are considered truthy and falsey, see the docs section on <a href="https://docs.python.org/3/library/stdtypes.html#truth-value-testing" rel="noreferrer">Truth Value Testing</a>, as well as <a href="https://stackoverflow.com/a/39984051/4909087">this answer</a>. It is worth noting here that <code>NotImplemented</code> is truthy, but it would have been a different story had the class defined a <code>__bool__</code> or <code>__len__</code> method that returned <code>False</code> or <code>0</code> respectively.</p>
<hr/>
<p>If you want the functional equivalent of the <code>==</code> operator, use <a href="https://docs.python.org/3/library/operator.html#operator.eq" rel="noreferrer"><code>operator.eq</code></a>:</p>
<pre><code>import operator
operator.eq(1, 'a')
# False
</code></pre>
<p>However, as mentioned earlier, for <em>this specific scenario</em>, where you are checking for <code>None</code>, use <code>is</code>:</p>
<pre><code>var = 'a'
var is None
# False

var2 = None
var2 is None
# True
</code></pre>
<p>The functional equivalent of this is using <a href="https://docs.python.org/3/library/operator.html#operator.is_" rel="noreferrer"><code>operator.is_</code></a>:</p>
<pre><code>operator.is_(var2, None)
# True
</code></pre>
<p><code>None</code> is a special object, and only 1 version exists in memory at any point of time. IOW, it is the sole singleton of the <code>NoneType</code> class (but the same object may have any number of references). The <a href="https://www.python.org/dev/peps/pep-0008/#programming-recommendations" rel="noreferrer">PEP8 guidelines</a> make this explicit:</p>
<blockquote>
<p>Comparisons to singletons like <code>None</code> should always be done with <code>is</code> or
  <code>is not</code>, never the equality operators.</p>
</blockquote>
<p>In summary, for singletons like <code>None</code>, a reference check with <code>is</code> is more appropriate, although both <code>==</code> and <code>is</code> will work just fine.</p>
</div>
<div class="post-text" itemprop="text">
<p>The result you are seeing is caused by that fact that</p>
<pre><code>None.__eq__("a") # evaluates to NotImplemented
</code></pre>
<p>evaluates to <code>NotImplemented</code>, and <code>NotImplemented</code>'s truth value is documented to be <code>True</code>:</p>
<p><a href="https://docs.python.org/3/library/constants.html" rel="noreferrer">https://docs.python.org/3/library/constants.html</a></p>
<blockquote>
<p>Special value which should be returned by the binary special methods (e.g. <strong>eq</strong>(), <strong>lt</strong>(), <strong>add</strong>(), <strong>rsub</strong>(), etc.) to indicate that the operation is not implemented with respect to the other type; may be returned by the in-place binary special methods (e.g. <strong>imul</strong>(), <strong>iand</strong>(), etc.) for the same purpose. <strong>Its truth value is true.</strong></p>
</blockquote>
<p>If you call the <code>__eq()__</code> method manually rather than just using <code>==</code>, you need to be prepared to deal with the possibility it may return <code>NotImplemented</code> and that its truth value is true. </p>
</div>
<div class="post-text" itemprop="text">
<p>As you already figured <code>None.__eq__("a")</code> evaluates to <code>NotImplemented</code> however if you try something like</p>
<pre><code>if NotImplemented:
    print("Yes")
else:
    print("No")
</code></pre>
<p>the result is</p>
<blockquote>
<p>yes</p>
</blockquote>
<p>this mean that the truth value of <code>NotImplemented</code> <code>true</code></p>
<p>Therefor the outcome of the question is obvious:</p>
<p><code>None.__eq__(something)</code> yields <code>NotImplemented</code></p>
<p>And <code>bool(NotImplemented)</code> evaluates to True</p>
<p>So <code>if None.__eq__("a")</code> is always True</p>
</div>
<div class="post-text" itemprop="text">
<h1>Why?</h1>
<p>It returns a <code>NotImplemented</code>, yeah:</p>
<pre><code>&gt;&gt;&gt; None.__eq__('a')
NotImplemented
&gt;&gt;&gt; 
</code></pre>
<p>But if you look at this:</p>
<pre><code>&gt;&gt;&gt; bool(NotImplemented)
True
&gt;&gt;&gt; 
</code></pre>
<p><code>NotImplemented</code> is actually a truthy value, so that's why it returns <code>b</code>, anything that is <code>True</code> will pass, anything that is <code>False</code> wouldn't.</p>
<h1>How to solve it?</h1>
<p>You have to check if it is <code>True</code>, so be more suspicious, as you see:</p>
<pre><code>&gt;&gt;&gt; NotImplemented == True
False
&gt;&gt;&gt; 
</code></pre>
<p>So you would do:</p>
<pre><code>&gt;&gt;&gt; if None.__eq__('a') == True:
    print('b')


&gt;&gt;&gt; 
</code></pre>
<p>And as you see, it wouldn't return anything.</p>
</div>
<span class="comment-copy">The title was wrong. The result is <b>not</b> <code>True</code>, as you noted yourself. It is a "truthy value", i.e. a value <code>x</code> such that <code>bool(x) is True</code>.</span>
<span class="comment-copy">The title is fine. if [truthy value] evaluates to true.</span>
<span class="comment-copy">Besides, changing the title to `why does .. evaluate to a truthy value" implies you know what "truthy" and "falsey" means, and by extension would know the cause of the issue rendering the question moot. Let's not go down that rabbit hole :)</span>
<span class="comment-copy">Nevertheless, I think it'd be worthy to note that <code>None</code> should be checked with <code>is None</code>, not <code>==</code>, <code>operator.eq</code> or <code>.__eq__</code></span>
<span class="comment-copy">@DeepSpace Thanks for that, I have reworked the answer so as to explain why <code>==</code> is better in any general situation, and why <code>is</code> is more appropriate for this specific one, quoting PEP8 at the bottom. Thanks for the comment!</span>
<span class="comment-copy">It's worth mentioning (since it wasn't obvious to me) that <code>NotImplemented</code> belongs to the class <code>&lt;class 'NotImplementedType'&gt;</code>. Here, <code>bool(NotImplemented)</code> evaluates to <code>True</code>, because of some combination of: <code>__bool__</code> undefined (most likely) / <code>__bool__</code> explicitly defined to be <code>Tue</code> / <code>__len__</code> doesn't give <code>0</code>.</span>
<span class="comment-copy">@jpp I don't think that class defines either <code>__bool__</code> or <code>__len__</code>. I believe the spec dictates that the object is truthy unless <code>__bool__</code> or <code>__len__</code> say otherwise. You can read more <a href="https://docs.python.org/3/library/stdtypes.html#truth-value-testing" rel="nofollow noreferrer">here</a> (that link is also included in the answer :-)).</span>
<span class="comment-copy">@coldspeed, Yup, I thought so. But it's worth clarification because new users may fall into the trap that <code>'a' == 'NotImplemented'</code> should return <code>False</code> ! While the underlying reason is you aren't working with strings but a <code>NotImplementedType</code> <i>object</i>.</span>
<span class="comment-copy">most visually clear answer - v worthwhile addition - thank you</span>
<span class="comment-copy">@scharfmn Lol, happy that i posted a good answer :-)</span>
<span class="comment-copy">:) “worthwhile addition” doesn’t quite capture what I was trying to say (as you obv see) - maybe “belated excellence” is what I wanted - cheers</span>
<span class="comment-copy">@scharfmn Yeah, i was bored, so answer, lol :-) ...</span>
<span class="comment-copy">@scharfmn yes? I'm curious to know what you think this answer adds that hasn't already been covered before.</span>
