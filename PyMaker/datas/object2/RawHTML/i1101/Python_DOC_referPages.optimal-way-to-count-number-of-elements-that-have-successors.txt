<div class="post-text" itemprop="text">
<p>Given a list of n (un-ordered and possibly repeated) elements, I want to count the number of elements, i, such that their successor, i+1, is also in the list. </p>
<p>This is a problem a friend gave me that I can't find an optimal solution for large n (100,000) with element values up to 1,000,000,000. Below is my current approach with a randomly generated list, that take a long time to work.</p>
<pre><code>import random
temp = random.sample(range(1000000000),random.randint(2,100000))
total_sum = 0
for i in range(len(temp)):
    if (temp[i]+1) in temp:
        total_sum+=1
print(total_sum)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use a <a href="https://docs.python.org/3/library/stdtypes.html#set" rel="nofollow noreferrer">set</a>:</p>
<pre><code>import random
random.seed(42)

temp = random.sample(range(1000000000), random.randint(2, 100000))

s = set(temp)
total_sum = sum(e + 1 in s for e in temp)
print(total_sum)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>7
</code></pre>
<p>The lookup time in a set is <em>O(1)</em> versus a list that is <em>O(n)</em>. The approach using a set is <em>O(n)</em>, your current implementation is <em>O(n^2)</em>.</p>
</div>
