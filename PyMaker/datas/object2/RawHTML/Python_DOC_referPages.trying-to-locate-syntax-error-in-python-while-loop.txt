<div class="post-text" itemprop="text">
<p>very very new beginner here - just started learning today! stumped on what the syntax error is here:</p>
<pre><code>import random
x = random.randrange(7)
user_start = "yes"
user_start_input = str(input("type 'yes' to generate random number. "))
while user_start_input == user_input:
print("your random dice number is " + str(x))
user_start_input = input("roll again?")
if user_start_input != user_input:
break
print("done")
</code></pre>
<p>The error message is: <code>
  File "/Users/joel/Documents/Learning Python/Dice.py", line 12
    while user_start_input == user_input:
        ^
SyntaxError: invalid syntax</code></p>
<p>what am I doing wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>First, it seems like you've mixed up the two variable names <code>user_start</code> and <code>user_input</code>, so those need to be changed to the same variable name.</p>
<p>Next, Python structures code with indentation: so the content in while loops and the like would need to be indented.</p>
<p>So here, you would indent all the code inside the while loop, and further indent the code inside the if statement inside the while loop.</p>
<p>It also seems like the purpose of your code is to simulate a dice roll each time the while loop runs again. In the while loop, you call on the variable <code>x</code> for the dice roll, but <code>x</code> is never changed. You never changed <code>x</code> to be a different random number, so it will just show the same random number every time the user rolls the dice again.</p>
<p>To fix this, simply re-define <code>x</code> each time the while loop is run. So just move the definition of the variable <code>x</code> to within the while loop.</p>
<p>With all these fixes, the code works:</p>
<pre class="lang-py prettyprint-override"><code>import random
user_start = "yes"
user_start_input = str(input("type 'yes' to generate random number. "))
while user_start_input == user_start:
        x = random.randrange(7)
        print("your random dice number is " + str(x))
        user_start_input = input("roll again?")
        if user_start_input != user_start:
                break
print("done")
</code></pre>
<p>Of course the variable names could be a bit more informative, and the code could be structured better to improve performance and user friendliness, but overall, great job for a beginner!</p>
</div>
<div class="post-text" itemprop="text">
<p>First off we're (those that wish to answer) missing some information, <code>while</code> is on line <code>5</code> where as the error is being reported with <code>while</code> on line <code>12</code>, there's plenty that could be causing an error to pop on a following line; eg. missing quote. Looks like <code>G. Anderson</code> already eluded to that last point, as far as errors usually being from a preceding line. My suggestion in this case would be to find an developer friendly text editor (IDE) that'll point out minor typos through syntax-highlighting; <a href="https://flight-manual.atom.io/getting-started/sections/installing-atom/" rel="nofollow noreferrer">Atom</a> is pretty groovy, especially with a few addons, but there's plenty of other text editors to play with.</p>
<p>Second, as commented by <code>CoffeeTableEspresso</code> the tabs are non-existent in your code snip! If your source code looks identical to what has been posted, then your bug-stomping has only just begun.</p>
<p>Third, because ya had stated that Python is not your first language it might be helpful, if not now then certainly in the future, to know of <code>__doc__</code> strings, eg...</p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; print(random.randrange.__doc__)
Choose a random item from range(start, stop[, step]).

        This fixes the problem with randint() which includes the
        endpoint; in Python this is usually not what you want.
</code></pre>
<p>... many of the things within Python are documented and accessible via the <code>__doc__</code> method, which can also be accessed with <code>help()</code>, eg. <code>help(random.randrange)</code>, and it is possible to write your own with the following syntax...</p>
<pre class="lang-py prettyprint-override"><code>def test_func(arg):
    """
    This is a __doc__ string
    """
    print("arg -&gt; {0}".format(arg))
</code></pre>
<p>And finally, well for now, it's a good idea when writing in an unfamiliar language to use copious comments and split things up into smaller bits that express your intentions; for example...</p>
<pre class="lang-py prettyprint-override"><code>#!/usr/bin/env python

import random


def dice(sides = 6):
    """
    Returns random int between `1` and `sides`
    """
    return random.randrange(start = 1, stop = int(sides) + 1, step = 1)


def prompt(message, expected):
    """
    Returns `True` if user input matches `expected`
    """
    return expected == str(input("{0} ".format(message)))


def main_loop():
    """
    Returns list of `dice(...)` results, list length depends
     upon number of times `prompt(...)` returns `True`
    """
    roll_results = []
    user_start = 'yes'
    # Set message for first run of loop
    message = "Type '{0}' to roll the dice".format(user_start)
    while prompt(message = message, expected = user_start):
        # Save dice output to variable for later use and
        #  append to list of rolls that will be returned
        roll = dice(sides = 6)
        roll_results.append(roll)
        # For now just print each roll, but this is one
        #  aria to expand upon with your own edits
        print("Rolled {0}".format(roll))
        # Set new message line for following loop iterations
        message = 'Roll again?'
    return roll_results


# Do stuff if script is run directly instead of imported as a module
if __name__ == '__main__':
    main_loop()
</code></pre>
<hr/>
<p>P.S. keep at it, eventually all the learnings'll start to <em>click</em>  and the following RP related example classes will make more since...</p>
<pre class="lang-py prettyprint-override"><code>#!/usr/bin/env python

from __future__ import range

import random


class DiceBag(dict):
    """
    DiceBag is a collection of short-cuts to `random.randrange`.

    - `selection`, list of `n` sided dice, eg `[4, 20]` would _stock_ bag with d4 and d20
    """

    def __init__(self, selection = [2, 4, 20], **kwargs):
        super(DiceBag, self).__init__(**kwargs)
        self.update(selection = selection)

    def dice(self, sides = 6):
        """
        Returns random int between `1` and `sides`
        """
        return random.randrange(start = 1, stop = int(sides) + 1, step = 1)

    def handfull_of(self, dice = {}):
        """
        Returns `dict` with lists of dice rolls

        ## Example

            dice_bag = DiceBag()
            toss_results = dice_bag.handfull_of({20: 1, 4: 2})

        Should return results of one `d20` and two `d4` such as

            {
                20: [18],
                4: [1, 3]
            }
        """
        output = {}
        for sides, count in dice.items():
            if sides not in self['selection']:
                continue

            rolls = []
            for roll in range(count):
                rolls.append(self.dice(sides))

            output[sides] = rolls

        if not output:
            raise ValueError("No dice in bag matching sizes -&gt; {0}".format(dice.keys()))

        return output

    """
    Short cuts for dice of a `n` sides, expand upon it if you wish
    """

    @property
    def coin(self):
        return self.dice(sides = 1)

    @property
    def d4(self):
        return self.dice(sides = 4)

    @property
    def d6(self):
        return self.dice(sides = 6)


class Flail(DiceBag):
    def __init__(self, damage_modifier = 0, damage_dice = {'sides': 6, 'count': 2}, **kwargs):
        super(Flail, self).__init__(selection = [damage_dice['sides'], 20], **kwargs)
        self.update(damage_modifier = damage_modifier)
        self.update(damage_dice = damage_dice)

    def attack(self, attack_modifier = 0):
        """
        Returns `dict` with `hit` chance + `attack_modifier`
         and `damage` rolls + `self['damage_modifier']`
        """
        rolls = self.handfull_of(dice = {
            20: 1,
            self['damage_dice']['sides']: self['damage_dice']['count']
        })
        return {
            'hit': rolls[20][0] + attack_modifier,
            'damage': sum(rolls[self['damage_dice']['sides']]) + self['damage_modifier']
        }
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>May be something like this?</p>
<pre><code>import random

x = random.randrange(7)
user_start = "yes"
user_start_input = str(input("type 'yes' to generate random number. "))
while user_start_input == user_start:
    print("your random dice number is " + str(x))
    user_start_input = input("roll again?")
    if user_start_input != user_start:
        break
print("done")
</code></pre>
</div>
<span class="comment-copy">You have two missing closing parenthesis on the line before</span>
<span class="comment-copy">user_start_input = str(input("type 'yes' to generate random number. " You forgot to close the ( with )</span>
<span class="comment-copy">Please indent properly</span>
<span class="comment-copy">One tip I have when you're learning: If you get a syntax error, 75% of the time it's coming from something on the line above the line the traceback says.</span>
<span class="comment-copy">OP, does your code actually look like what we're seeing here? (You should be pasting it into your question, then selecting it and clicking the <code>{}</code> button or pressing Ctrl+K.) If so, the indentation that CoffeeTableEspresso mentions may well be your problem. If that's the issue you should probably take the time to go through a basic tutorial or two.</span>
<span class="comment-copy">Please explain <i>why</i>. Just providing code for people to copy and paste isn't very useful.</span>
