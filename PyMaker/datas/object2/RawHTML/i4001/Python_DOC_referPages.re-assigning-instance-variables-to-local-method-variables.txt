<div class="post-text" itemprop="text">
<p>I have seen the following many times, where the instance variables (ex. <code>obj_foo</code> and <code>obj_bar</code>) are re-assigned to be local method variables (ex. within <code>call</code>):</p>
<pre><code>class Example:
    def __init__(self, obj_foo, obj_bar):
        self.obj_foo = obj_foo
        self.obj_bar = obj_bar

    def call(self):
        obj_foo, obj_bar = self.obj_foo, self.obj_bar

        obj_foo.do_something()
        obj_bar.do_something_else()
</code></pre>
<p>I am not sure if this is convention (easy to read) or if there is a more significant purpose?</p>
<p>Is this bad practice?</p>
<p>Does this effect performance?</p>
</div>
<div class="post-text" itemprop="text">
<p>Usually, there is no reason to do that, but in some circumstances it may be:</p>
<ul>
<li>faster (because access to local variables is fast)</li>
<li>more easily readable (because it is shorter)</li>
</ul>
<p>The speed is probably the more important factor here. Accessing member variables involves various mechanisms (see <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattr__" rel="nofollow noreferrer"><code>__getattr__</code></a>, <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattribute__" rel="nofollow noreferrer"><code>__getattribute__</code></a>, <a href="https://docs.python.org/3/library/stdtypes.html#object.__dict__" rel="nofollow noreferrer"><code>__dict__</code></a>, <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptors</a>) which take some time to resolve. Additionally, the getter for the variable may do something even more expensive.</p>
<p>On the other hand, local variables are in CPython optimised at compile time, so there is actually no lookup for a variable named <code>'obj_foo'</code> in the <code>__dict__</code>, but instead the interpreter just picks the first local variable, because it knows that <code>obj_foo</code> is the first local variable without the need to search for the name.</p>
<p>So, if a member variable is used many times in the same function and profiling shows that it takes significant time to access that member variable, it may be useful to use a local variable instead.</p>
<hr/>
<p>Usually, that does not make a big difference, but here is an example to show the idea:</p>
<pre><code>class A:
    def __init__(self,x):
        self.x=x

    def f(self):
        for i in range(100):
            self.x()

class B:
    def __init__(self,x):
        self.x=x

    def f(self):
        x=self.x
        for i in range(100):
            x()
</code></pre>
<p>The timing is almost the same, but there is some difference:</p>
<pre><code>&gt;&gt;&gt; timeit.timeit('a.f()', setup='a=A(lambda:None)', globals=locals())
13.119033042000638
&gt;&gt;&gt;
&gt;&gt;&gt; timeit.timeit('b.f()', setup='b=B(lambda:None)', globals=locals())
10.219889547632562
</code></pre>
<p>IMHO, in this case, the difference is barely enough to justify adding that one line of code.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could do this just to avoid writing out <code>self</code> every time.</p>
<p>However, it could also be that there is a more important reason to do this: it could completely change the semantics. Example:</p>
<pre><code>def __init__(self, x):
  self.x = 42

def theMethod(self):
  x = self.x
  self.x = 58
  print(x)
  print(self.x)
</code></pre>
<p>In this example, <code>x</code> and <code>self.x</code> are not interchangeable, even though you have assigned <code>x = self.x</code> in the first line of <code>theMethod</code>. The first <code>print</code> will output <code>42</code>, the second <code>print</code> will output <code>58</code>. This can happen every time that some member variable is assigned to a local variable and then overridden.</p>
<p>How this impacts performance is not entirely obvious, because both lookups <code>self.x</code> and <code>x</code> will have to look for the symbol in a dictionary: in the first case, the dictionary of the member variables of <code>self</code>, in the second case, in the current scope. It could impact the performance both positively <em>and</em> negatively, depending on how many and what other variables are defined in each scope. In most non-contrived cases, it <em>could</em> have a tiny positive effect on performance.</p>
<p><strong>EDIT:</strong> As @zvone has pointed out, the last paragraph does not necessarily hold for all implementations of the python interpreter.</p>
</div>
<span class="comment-copy">probably is just to avoid using <code>self.</code> before the varaibles names, because both variables will be referencing the same objects</span>
<span class="comment-copy">As for good or bad, there may be some justification for micro-optimizations in fairly extreme cases. But if its just to make it look more like C++ or to avoid writer's cramp, its a bad idea. First, its unclear that you are referring to an instance object, and second, if it is reassigned (<code>obj_foo = other_thing</code>) its also unclear whether the writer intended this to be local only or whether its a bug. This reduces maintainability, IMHO.</span>
<span class="comment-copy">Hi Andrey. Can you please elaborate on why this may work for certain implementations of the interpreter but not others?</span>
<span class="comment-copy">In CPython, this is a common micro-optimization, because local variable namespaces are optimized to a primitive array instead instead of a <code>dict</code> and can be accessed much faster.</span>
<span class="comment-copy">@Scott zvone's answer explains it quite nicely: apparently, CPython performs some special optimizations for local variables, so no dictionary lookup is necessary when accessing the value of a local variable. This could be much faster than looking it up in the <code>__dict__</code> of the object. The paragraph about the changed semantics still holds, though.</span>
<span class="comment-copy">Note, this is the primary reason for the introduction of <code>__slots__</code>.</span>
<span class="comment-copy">Thanks Andrey. I guess I was confused as to the part about different "implementations of the python interpreter"? Not all python interpeters handle local variable access the same way?</span>
