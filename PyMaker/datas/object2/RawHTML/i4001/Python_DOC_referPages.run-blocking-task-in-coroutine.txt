<div class="post-text" itemprop="text">
<p>I have a server which reads messages from SQS queue with long polling which blocks coroutine execution. Is there a way to leave processors running while the scheduler is blocked on waiting for new messages?</p>
<pre><code>import asyncio
import time

NUM_EXEC = 10

async def processor(i):
    print (f"Starting {i}")
    for n in range(10):
        print(f"Processor {i} cycle {n}")
        await asyncio.sleep(1)

async def scheduler():
    for i in range(NUM_EXEC):
        #Blocking SQS long poll
        time.sleep(5)
        #Run processor
        await asyncio.ensure_future(processor(i))

loop = asyncio.get_event_loop()
loop.run_until_complete(scheduler())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To integrate with SQS, it is preferrable to use <code>aiobotocore</code> library - asyncio-compatible AWS driver. Here is example of SQS usage: <a href="http://aiobotocore.readthedocs.io/en/latest/examples.html#sqs" rel="nofollow noreferrer">http://aiobotocore.readthedocs.io/en/latest/examples.html#sqs</a></p>
<p>In general, if you must use an external library with blocking function calls - use <a href="https://docs.python.org/3/library/asyncio-eventloop.html#executor" rel="nofollow noreferrer">asyncio executors API</a>, which delegates blocking calls to thread pool.</p>
</div>
<span class="comment-copy">Thanks, aibotocore works fine with long polling</span>
