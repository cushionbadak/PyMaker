<div class="post-text" itemprop="text">
<p>I am trying to set a value from the dict if the condition is met. Basically I iterate over the values of my dictionary and check if they fit my condition (then I break to loop which is not the best practice but saves some iterations)</p>
<p>Here is the code I am using:</p>
<pre><code>for (key,value) in zip(mn_zone_dict.keys(), mn_zone_dict.values()):
    if cost &lt; value:
        zone = key
        break
</code></pre>
<p>I does it's job but it is relatively slow while I have to check &gt; 10k records so I am looking for some smarter (and maybe more pythonic) way of solving that task. I have seen a function any() but it only returns if there is such entry which matches the conditions without telling which.</p>
<p>I'd be happy to hear your ideas and suggestions. </p>
</div>
<div class="post-text" itemprop="text">
<p>If you have the data directly as-is, with only a dictionary structure, you will have to iterate over it every time. The best speedup you can get would be to use a comprehension instead of a loop, and <code>dict.items</code> instead of <code>zip</code>:</p>
<pre><code>zones = [k for k, v in my_zone_dict.items() if cost &lt; v]
</code></pre>
<p>On the one hand this iterates over the whole dict. On the other, it tells you immediately how many values met the criterion, if any.</p>
<p>The problem here is that no matter how much less overhead a comprehension has than an explicit loop, this is still <code>O(n)</code> for every lookup. The correct solution is to use a different, or complimentary data structure. Since you want <code>value</code> to be greater than something, I'd recommend a max-heap.</p>
<p>Python implements heaps in the <a href="https://docs.python.org/3/library/heapq.html" rel="nofollow noreferrer"><code>heapq</code></a> module. It is a bit unusual because it does not provide a heap object, just functions to heapify and maintain lists as heaps. Also, only min-heaps are supported, but that's OK because you can always just negate your values:</p>
<pre><code>my_zone_list = [(-v, k) for k, v in my_zone_dict.items()]
heapq.heapify(my_zone_list)
</code></pre>
<p>This is a one-time <code>O(n)</code> penalty, which you never have to repeat. Your whole loop now becomes an <code>O(1)</code> operation:</p>
<pre><code>if cost &lt; -my_zone_list[0][0]:
    zone = my_zone_list[0][1]
</code></pre>
<p>Inserting new elements has an <code>O(log(n))</code> cost:</p>
<pre><code>heapq.heappush(my_zone_list, (-new_value, new_key))
</code></pre>
<p>As a side note, if you can't introduce new data structures, you <em>might</em> get better performance with</p>
<pre><code>v, zone = max((v, k) for k, v in my_zone_dict.items())
if cost &lt; v: ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do it like this:</p>
<pre><code>for k in my_zon_dict.keys():
   if cost &lt; my_zon_dict[k]:
      zone = k
      break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Instead of iterating a <code>zip</code> object, you can iterate directly over <code>dict.items</code>:</p>
<pre><code>for k, v in my_zon_dict.items():
    if cost &lt; v:
        zone = k
        break
</code></pre>
<p>This will be more efficient than creating a custom zipped iterable.</p>
</div>
<span class="comment-copy">Can you provide some example data for benchmarking? [For example, you can use <code>random</code> for a sample of X integers.] 10k records is very small, so a single query should be very fast. Are you willing to transform your data structure (e.g. <code>heapq</code>, <code>numpy</code>)?</span>
<span class="comment-copy">What makes you think breaking out of a loop is not best practice, out of curiosity?</span>
<span class="comment-copy">Back at the university I was told that it makes program unclear and it it better to handle a situation like that with some flag or anyhow but not with 'break'.</span>
<span class="comment-copy">There is a Python construct, the loop <code>else</code>, built exactly around the advisability of using <code>break</code>.</span>
<span class="comment-copy">I would like to skip the part of iterating over the dict but still thanks for the idea :)</span>
<span class="comment-copy">@hikamare It is <i>impossible</i> to avoid iterating, this <i>is</i> the pythonic way, or if you want a one-liner, you could do <code>zone = next(k for k, v in my_zon_dict.items() if cost &lt; v)</code></span>
<span class="comment-copy">@hikamare, I second Chris_Rands, what you asking for is impossible.</span>
<span class="comment-copy">@Chris_Rands, In my experience generator expression iteration is <i>slower</i>, so not sure the one-liner is useful here!</span>
<span class="comment-copy">I doubt the speed will be meaninfully different but when they say "I have seen a function any() but it only returns if there is such entry which matches the conditions without telling which." it sounds like they are looking for <code>next()</code>. Nonetheless your solution is fine, I hope you don't mind my edit, and not my vote of course</span>
