<div class="post-text" itemprop="text">
<pre><code>import pandas as pd

def test_run():
    for symbol in ['nugt', 'soxs']:
        for stat in ['max', 'min', 'mean']:
            print(f"{stat} Close")
            print(symbol, get_stat(symbol, stat))

def get_stat(symbol, stat):
    df = pd.read_csv(f"{symbol}.csv")
    return getattr(df['close'], stat()) 

if __name__ == "__main__": 
    test_run()             
</code></pre>
<p>I am trying to open up an 2 excel files (soxs.csv and nugt.csv) , look at the column "close" and find the max, min, mean in the "close" column for each file.</p>
<p>The result I am getting is <code>"TypeError: 'str' object is not callable"</code>. But I am calling it with attributes that should run just trying to do it with less code by using a loop. Any suggestions on how to get around this?</p>
</div>
<div class="post-text" itemprop="text">
<p>The<code>stat</code> is a string so you can call it, you can get the <code>attr</code> by like this:</p>
<pre><code>return getattr(df['close'], stat) 
</code></pre>
<p>It returns the method, for calling that you should use <code>()</code> and send the parameters if needed, like this:</p>
<pre><code>return getattr(df['close'], stat)()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You're calling the <code>stat</code> which is a string at following line:</p>
<pre><code>return getattr(df['close'], stat()) 
</code></pre>
<p>Change it to:</p>
<pre><code>return getattr(df['close'], stat)()
</code></pre>
<p>Also, for accessing multiple attributes at once you can simple use <a href="https://docs.python.org/3/library/operator.html#operator.attrgetter" rel="nofollow noreferrer"><code>operator.attrgetter</code></a> which accepts an iterable of attribute names.</p>
<p>e.g.</p>
<pre><code>attrs = ['max', 'min', 'mean']
result = [r() for r in attrgetter(*attrs)(df['close'])]
</code></pre>
<p>But in this case since you need to call the <code>getattr</code> result again, it's not a Pythonic way to use <code>operator.attrgetter()</code>. Instead you could dimply loop over the attrs and just call the result manually in a list comprehension.</p>
<pre><code>[getattr(df['close'], attr)() for attr in attrs]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>methdcaller</code> instead of <code>attrgetter</code> for calling methods.</p>
<p><code>max</code>, <code>min</code> and <code>mean</code> are all methods of <code>pandas.Series</code>, not attributes. Since <code>methodcaller</code> only calls one method at a time, you can apply multiple methods via a comprehension.</p>
<p>Here's a complete example:</p>
<pre><code>from operator import methodcaller
import pandas as pd

def get_stat(df, stat):
    return {i: methodcaller(i)(df['close']) for i in stat}

df_input = pd.DataFrame({'close': [1, 2, 3, 4, 5]})

res = get_stat(df_input, ['max', 'min', 'mean'])

print(res)

{'max': 5, 'min': 1, 'mean': 3.0}
</code></pre>
</div>
<span class="comment-copy">Did one of the below solutions help? Feel free to accept one (tick on left), or ask for clarification.</span>
<span class="comment-copy">That worked - thank you</span>
<span class="comment-copy">@EMZ if you think this was helpful please check the accept mark(the green one) beside the answer.</span>
<span class="comment-copy">When trying either of those options, my result comes out to be: "soxs &lt;bound method Series.mean of 0         NaN, Name: close, Length: 506, dtype: float64&gt;" Do you know a way around that?</span>
<span class="comment-copy">@EMZ It seems that it's returning a bound method. You should call the result(s).</span>
