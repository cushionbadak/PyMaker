<div class="post-text" itemprop="text">
<p>I currently have a server running under this code:</p>
<pre><code>    import socket                   


port = 60000                  
s = socket.socket()             
host = socket.gethostname()    
s.bind((host, port))           
s.listen(1)                     

print ('Server listening....')

while True:
    conn, addr = s.accept()     
    print ('Got connection from', addr)
    data = conn.recv(1024)
    print('Server received', repr(data))

    filename='mytext.txt'
    f = open(filename,'rb')
    l = f.read(1024)
    while (l):
       conn.send(l)
       print('Sent ',repr(l))
       l = f.read(1024)
    f.close()

    print('Done sending')
    conn.send('Thank you for connecting')
    conn.close()
</code></pre>
<p>And a client running under this code:</p>
<pre><code>import socket

    s = socket.socket()              
host = socket.gethostname()      
port = 60000                    

    s.connect((host, port)) 
    s.send('Test')

with open('received_file', 'wb') as f:
    print ('file opened')
    while True:
        print('receiving data...')
        data = s.recv(1024)
        print('data=%s', (data))
        if not data:
            break
        # write data to a file
        f.write(data)

    f.close() 
print('Successfully get the file') 
s.close()

     print('connection closed')
</code></pre>
<p>The problem is that the when the client attempts to send the data it says that the data sent must be a byte-type object (Error code shown here: <a href="https://gyazo.com/97ef155f6809a801b02f381670895a2b" rel="nofollow noreferrer">https://gyazo.com/97ef155f6809a801b02f381670895a2b</a>.) I have searched the internet for an answer of how to create a byte type object inside of Python 3, but I have failed to find anything that has worked. </p>
</div>
<div class="post-text" itemprop="text">
<p>If you’re just sending literals, you can just use a <code>bytes</code> literal instead of a <code>str</code> literal, by prefixing it with a <code>b</code>. Instead of this:</p>
<pre><code>sock.send('Hello')
</code></pre>
<p>… just do this:</p>
<pre><code>sock.send(b'Hello')
</code></pre>
<hr/>
<p>If you’re sending string variables, you will want to <code>encode</code> them for sending, and probably <code>decode</code> them on receiving. Instead of this:</p>
<pre><code>sock.send(msg)
resp = sock.recv(4096)
</code></pre>
<p>… do:</p>
<pre><code>sock.send(msg.encode('ascii')
resp = sock.recv(4096).decode('ascii')
</code></pre>
<hr/>
<p>If you want to send non-ASCII strings, you’ll need to pick an encoding. Unless you have a good reason to do otherwise, use UTF-8.</p>
<hr/>
<p>One more thing to keep in mind: TCP sockets are just streams of bytes, not messages, and they can be split up arbitrarily into packets. When you can <code>recv(1024)</code>, you may only get part of what the other side sent with <code>send</code>. That’s probably obvious if you’re sending strings longer than 1024 bytes, but even for shorter strings, it can happen. Or, if you’re not strictly alternating sends and receives, you can get multiple sends concatenate into a single receive. And if you send <code>hello</code> and then <code>world</code> and receive them as <code>helloworld</code> you have no way to know that happened, or how to split them back up.</p>
<p>And, worse, it probably <em>won’t</em> happen when you’re testing on localhost on an idle machine, so things will look good during development, but then fail mysteriously all over the place once you deploy it somewhere.</p>
<p>So, you need some protocol that describes where one message ends and another begins. I have <a href="http://stupidpythonideas.blogspot.com/2013/05/sockets-are-byte-streams-not-message.html" rel="nofollow noreferrer">a blog post</a> that explains some options, and shows how to implement them.</p>
<p>But if you’re just sending human-readable strings as messages, and those strings will never contain newlines, the simplest protocol is just a line for every message, the same way you’d write a text file. And look at <code>socket.makefile</code>: it gives you something that acts just like a file, handles the one line for every message protocol, and also automatically handles the <code>encode</code> and <code>decode</code> parts. So, instead of this:</p>
<pre><code>sock.send(msg.encode('utf-8'))
resp = sock.recv(1024).decode('utf-8')
</code></pre>
<p>… you just do use <code>makefile</code> to get readable and writable file objects, then do:</p>
<pre><code>wf.write(msg + '\n')
resp = next(rf)
</code></pre>
<p>… and then you don’t have to worry about how to buffer up the receives and split them into messages.</p>
</div>
<div class="post-text" itemprop="text">
<p>Change the client code line:</p>
<pre><code>s.send('Test')
</code></pre>
<p>to:</p>
<pre><code>s.send(b'Test')
</code></pre>
<p>Find more details about socket.send() at <a href="https://docs.python.org/3/library/socket.html" rel="nofollow noreferrer">https://docs.python.org/3/library/socket.html</a>.</p>
</div>
<span class="comment-copy">This may be wrong but writing it like this should work s.send(b’Test’)</span>
<span class="comment-copy">Here is the documentation for <code>Bytes</code> objects: <a href="https://docs.python.org/3/library/stdtypes.html#bytes" rel="nofollow noreferrer">docs.python.org/3/library/stdtypes.html#bytes</a></span>
<span class="comment-copy">Do you have any suggestions for other ways to send data through the internet using python which would be more reliable?</span>
<span class="comment-copy">@Octopusghost TCP sockets are perfectly <i>reliable</i>. You just need to put a protocol on top of them to use them as message streams. If <code>makefile</code> isn't sufficient, other very simple protocols to implement include JSONlines (one <code>json.dump</code> object per line) and <a href="https://en.wikipedia.org/wiki/Netstring" rel="nofollow noreferrer">netstrings</a> (little more than a length, in ASCII digits, for each byte string).</span>
