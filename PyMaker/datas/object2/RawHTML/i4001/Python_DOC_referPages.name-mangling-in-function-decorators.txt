<div class="post-text" itemprop="text">
<p>I cannot use a decorator within a class declared in the same module as the decorator if the decorator name is a __double_leading_underscore type.</p>
<p>It's easier to explain with an example:</p>
<pre><code># Just a pass-through
def __decorator(fn):
  return fn

decorator = __decorator

class A(object):
  @decorator
  def test(self):
    return 1

print(A().test())
# Prints 1
</code></pre>
<p>If I change <code>@decorator</code> with <code>@__decorator</code>:</p>
<pre><code>class A(object):
  @__decorator
  def test(self):
    return 1

Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 2, in A
NameError: name '_A__decorator' is not defined
</code></pre>
<p>It tries to find <code>__decorator</code> from within the class.</p>
<p>Is there a way to keep the naming convention but refer to the module instead of the class?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is due to Python's name mangling. According <a href="https://docs.python.org/3/tutorial/classes.html#private-variables" rel="nofollow noreferrer">to the docs</a></p>
<blockquote>
<p>Any identifier of the form __spam (at least two leading underscores,
  at most one trailing underscore) is <strong>textually</strong> replaced with
  _classname__spam, where classname is the current class name with leading underscore(s) stripped. This mangling is done without regard
  to the syntactic position of the identifier, as long as it occurs
  within the definition of a class.</p>
</blockquote>
<p>Emphasis added.</p>
<p>When the interpreter sees <code>@__decorator</code> within class <code>A</code>, it ignores the binding to <code>decorator</code>, textually replaces <code>__decorator</code> with <code>_A__decorator</code> and tries to evaluate <em>that</em> identifier, which gives you a <code>NameError</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>As noted <a href="https://stackoverflow.com/a/50359165/5492820">in this post</a> it's due to attribute name mangling.</p>
<p>Code posted by OP is an interesting case that made me research how name manging is performed. It turns out that name mangling is performed during compilation to Python bytecode which can be seen by running this code (<strong>run in Python 3.7</strong>):
</p>
<pre><code>import dis

# I want the source code, not just class object.
a_def = '''
class A:
    __mangled = 'aiya!'

    def p(self):
        print(self.__mangled)
'''

print(dis.dis(a_def, depth=2))  # In Python 3.7 they added `depth` argument so nested `code object`s will be printed.
</code></pre>
<p>The bytecode is:</p>
<pre><code>  2           0 LOAD_BUILD_CLASS
              2 LOAD_CONST               0 (&lt;code object A at 0x7f4b3f6ddd20, file "&lt;dis&gt;", line 2&gt;)
              4 LOAD_CONST               1 ('A')
              6 MAKE_FUNCTION            0
              8 LOAD_CONST               1 ('A')
             10 CALL_FUNCTION            2
             12 STORE_NAME               0 (A)
             14 LOAD_CONST               2 (None)
             16 RETURN_VALUE

Disassembly of &lt;code object A at 0x7f4b3f6ddd20, file "&lt;dis&gt;", line 2&gt;:
  2           0 LOAD_NAME                0 (__name__)
              2 STORE_NAME               1 (__module__)
              4 LOAD_CONST               0 ('A')
              6 STORE_NAME               2 (__qualname__)

  3           8 LOAD_CONST               1 ('aiya!')
             10 STORE_NAME               3 (_A__mangled)

  5          12 LOAD_CONST               2 (&lt;code object p at 0x7f4b3f6dde40, file "&lt;dis&gt;", line 5&gt;)
             14 LOAD_CONST               3 ('A.p')
             16 MAKE_FUNCTION            0
             18 STORE_NAME               4 (p)
             20 LOAD_CONST               4 (None)
             22 RETURN_VALUE

Disassembly of &lt;code object p at 0x7f4b3f6dde40, file "&lt;dis&gt;", line 5&gt;:
  6           0 LOAD_GLOBAL              0 (print)
              2 LOAD_FAST                0 (self)
              4 LOAD_ATTR                1 (_A__mangled)
              6 CALL_FUNCTION            1
              8 POP_TOP
             10 LOAD_CONST               0 (None)
             12 RETURN_VALUE
</code></pre>
<p>This explains why <code>__decorator</code> in class' body triggers searching for <code>_A__decorator</code> because it's "hardcoded" in the bytecode.</p>
<p>The only way to call <code>__decorator</code> in class body is to use one of following calls:
</p>
<pre><code>import sys

__mangled = '???'

class A():    
    # All following calls look horrible.
    print(globals()['__mangled'])
    print(eval('__mangled'))
    this_module = sys.modules['__main__']
    print(getattr(this_module, '__mangled'))
</code></pre>
<p>As noted each call looks horrible and the issue lies in <code>__mangled</code> name. If your goal is to  hint that the module attribute shouldn't be used directly a single underscore is enough. But if you really want leading double underscore you can add more than 2 trailing underscores to prevent mangling as <a href="https://docs.python.org/3.7/tutorial/classes.html#private-variables" rel="nofollow noreferrer">noted in documentation</a>:</p>
<blockquote>
<p>Any identifier of the form __spam (at least two leading underscores,
  <strong>at most one trailing underscore</strong>) is textually replaced with
  _classname__spam, where classname is the current class name with leading underscore(s) stripped.</p>
</blockquote>
</div>
<span class="comment-copy">Why does your decorator name start with <code>__</code>?</span>
<span class="comment-copy">Avoid the double underscore prefix <code>__</code> unless you actually have the problem, it was added to solve.</span>
<span class="comment-copy">Not possible, assuming that you will eventually use the decorator in more than one class.  The leading double underscore expands based on the class name, so it will be looking for a different name in each class.  Why do you think you need to do this, anyway?</span>
<span class="comment-copy">I want to hide the decorator in the module. That's why I'm using double underscore. @jasonharper: I'm not that sure that it always expands based on class name, since we can have classes starting with __ inside a module and can be used within the module.</span>
<span class="comment-copy">@jasonharper: I'm sorry, you're right</span>
