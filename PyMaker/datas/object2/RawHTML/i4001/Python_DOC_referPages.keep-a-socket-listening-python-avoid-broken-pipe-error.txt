<div class="post-text" itemprop="text">
<p>I tried to find the solution but did not find any on any post.
I am trying to create a file sharing system between two sockets but as my client connects to server, on first send by server I get broken pipe error.
Is there something I have to do to keep the socket listening or any other way I can do this transfer?
I am also running a central server that makes these two of its clients a server-client pair on the same ip as one of the socket. could that cause this problem(i put it on sleep after it creates the temporary pair)
here is the server code:</p>
<pre><code> def create_server(self,ip,path ): #ip is of the server
    connection_list = []
    print(ip)
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.bind((ip, 12345))
    print("server created")
    connection_list.append(sock)
    sock.listen(1)
    #offset = 0
    file = open(path, "rb")
    print("file opened")
    while True:
        print("waiting for connection...")
        conn, addr = sock.accept()
        print ('New connection from %s:%d' % (addr[0], addr[1]))
        print("accepted connection")
        connection_list.append(conn)           
        sock.send(str("Start").encode()) # THIS CAUSES BROKEN PIPE ERROR
        chunk = file.read(4096)
        print("chunk read")
        if not chunk:
            break  # EOF
        sock.send(chunk)
        print("chunk sent")
    sock.send(str("ENDED").encode())
    print("Transfer complete")
    sock.close()
</code></pre>
<p>this is the client code:</p>
<pre><code>def create_client(self,ip,file ): #ip of server
    print(ip)
    print("going to download",str(file))
    try:
        client=socket.create_connection((ip, 12345 ))
    except:
        client=socket.create_connection((ip, 12346 ))
    print("client created")
    with open(str(file), 'wb') as f:
      socket_list = [client]
      print("file opened")
      data=client.recv(4096)
      while data.decode()!="Start":
                        data=client.recv(4096)
      while True:
           print("started")
           data=client.recv(4096)
           print("recieved data")
           if data.decode()=="ENDED":
                   break
      f.write(data)
      print("Transfer complete")
    f.close()
    time.sleep(5)
    client.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that in your server program, you're trying to send data on the wrong socket.</p>
<p><code>sock</code> is the server (or the master, if you will) socket. That is only used to listen for incoming connections.</p>
<p><a href="https://docs.python.org/3/library/socket.html#socket.socket.accept" rel="nofollow noreferrer">[Python]: socket.<strong>accept</strong>()</a> documentation states:</p>
<blockquote>
<p>Accept a connection. The socket must be bound to an address and listening for connections. The return value is a pair <code>(conn, address)</code> where <strong><em>conn</em> is a <em>new</em> socket object usable to send and receive data on the connection</strong>, and <em>address</em> is the address bound to the socket on the other end of the connection.</p>
</blockquote>
<ul>
<li><p>Change your line (and <strong>all</strong> the other lines that have <code>sock.send</code>) from:</p>
<pre><code>sock.send(str("Start").encode())
</code></pre>
<p>to:</p>
<pre><code>conn.send("Start".encode())
</code></pre></li>
<li><p>The lines:</p>
<pre><code>conn.send("ENDED".encode())
print("Transfer complete")
</code></pre>
<p>should be moved inside the <code>while</code> loop (indented), and perhaps you could add a <code>conn.close()</code> at the end of the loop.</p></li>
</ul>
<p>In your client program:</p>
<ul>
<li>The <code>try</code> / <code>except</code> clause is useless, since the server doesn't listen on port <em>12346</em></li>
<li>If the file contains an <em>"ENDED"</em> string, you won't receive the complete content. I'd suggest to make your end tag more complex (so there are as least chances as possible for it to be present in the file), or better:

<ul>
<li>Send the file size first, and then on the client, expect exactly that number of bytes (might wanna check <a href="https://stackoverflow.com/questions/30615187/multiple-send-from-server-to-client-python/30615690#30615690">[SO]: multiple send from server to client python (@CristiFati's answer)</a>)</li>
</ul></li>
</ul>
</div>
<span class="comment-copy">Thanks, I feel ashamed of making such a noob mistake. the try-except was from some previous modifications I did in the rest of the code and forgot to delete. Also, thanks for other tips.</span>
<span class="comment-copy">No need to be ashamed. This is why the community exists. Also if this answer solves your problem, don't forget to accept it.</span>
