<div class="post-text" itemprop="text">
<p>I asked my friend for assistance with a function that swaps characters in a string, and this is what he came up with:</p>
<pre><code>import re           

def function(a, b, c):
    def hfunc(y):
        z = y.group(1).lower()
        if z == c.lower():
            return b.upper()

        if z == b.lower():
            return c.upper()

        # The statements I commented out were supposed to print out if paramters 
        # 'b' or 'c' were not present in the string ('a')
        #if b not in a:         
             #print("Cannot be found: ", b)
             #return
        #if c not in a:
             #print("Cannot be found: ", c)  
             #return
        else:
            return y.group(1)

    return re.sub("(\w+)", hfunc, a) 

print(function("Neill and Nathan left the school.", "neill", "nathan"))
print(function("Neill and Nathan left the school.", "Nathan", "neILL"))
print(function("and Bob work together.", "dylan", "bob"))
# Cannot be found: "dylan" &lt;-- should be the output
print(function("Dylan and work together.", "DYLAN", "BoB"))
# Cannot be found: "BoB"  &lt;-- should be the output
</code></pre>
<p>The problem is I'm not familiar at all with the module that is being used. Is there another way to write this code (perhaps a little more beginner-friendly)? Thanks in advance.</p>
<p>EDIT: These are the outputs right now </p>
<pre><code>NATHAN and NEILL left the school. # correct
NATHAN and NEILL left the school. # correct
and DYLAN work together. # Cannot be found: "dylan" &lt;-- should be the output
BOB and work together. # Cannot be found: "BoB"  &lt;-- should be the output
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your friend is using <a href="https://regex101.com/r/uWUeGS/1" rel="nofollow noreferrer">the regular expression <code>\w+</code></a> to match all strings of "word characters". In <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer"><code>re</code></a>, "word characters" means:</p>
<blockquote>
<p>Matches Unicode word characters; this includes most characters that can be part of a word in any language, as well as numbers and the underscore.</p>
</blockquote>
<p>Really, you probably don't want to include numbers and underscores, just letters. Your friend probably did this because… well, most regular expression solutions are "quick &amp; dirty" instead of precise; it's just shorter to specify <code>\w</code> than what you actually want, and it works for your sample inputs, so that's what they did.</p>
<p>So, for your first example, it'll match:</p>
<pre><code>['Neill', 'and', 'Nathan', 'left', 'the', 'school']
</code></pre>
<p>For each one, it's calling that <code>hfunc</code>, and substituting the result in place of the original word. That's what <a href="https://docs.python.org/3/library/re.html#re.sub" rel="nofollow noreferrer"><code>re.sub</code></a> does.</p>
<hr/>
<p>If you want to do the same thing without using <code>re</code>, you can group the words in the same way, and loop over the groups manually. For example, with <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a>, to group characters by whether they're letters or not (without the hacky numbers-and-underscores bit):</p>
<pre><code>for isletters, group in itertools.groupby(sentence, key=str.isalpha):
    print(isletters, list(group))
</code></pre>
<p>If you run that and look at the output, you should be able to see what to do. First, we want to <code>join</code> each group back into a string. Then, for the ones where <code>isletters</code> is true, we want to call that <code>hfunc</code> (but let's rename it, and its parameter, to something more meaningful…). Then <code>join</code> all the results back up. So:</p>
<pre><code>def fixword(word): # was hfunc
    if word.lower() == c.lower():
        return b.upper()
    elif word.lower() == b.lower():
        return c.upper()
    else:
        return word

newsentence = []
for isletters, group in itertools.groupby(sentence, key=str.isalpha):
    word = ''.join(group)
    if isletters:
        word = fixword(word)
    newsentence.append(word)
return ''.join(newsentence)
</code></pre>
<p>If you want to keep track of whether anything was changed, you can do that, as you go along:</p>
<pre><code>foundb, foundc = False, False

def fixword(word): # was hfunc
    nonlocal foundb, foundb
    if word.lower() == c.lower():
        foundc = True
        return b.upper()
    elif word.lower() == b.lower():
        foundb = True
        return c.upper()
    else:
        return word

newsentence = []
for isletters, group in itertools.groupby(sentence, key=str.isalpha):
    word = ''.join(group)
    if isletters:
        word = fixword(word)
        if word == 
    newsentence.append(word)
if not foundb:
    return f'Cannot be found: {b}'
elif not foundc:
    return f'Cannot be found: {c}'
else:
    return ''.join(newsentence)
</code></pre>
<hr/>
<p>If you don't understand how that <code>groupby</code> works… well, the "roughly equivalent" code in the docs probably won't help you without a bit more study, but you can easily write something less flexible that gives the same output for this case. It's probably worth trying it. Here's a pseudocode framework to get your started:</p>
<pre><code>currentword, isletters = [], True
for ch in sentence:
    if ch.isalpha():
        if isletters:
            add the current word to newsentence
            start a new letters word
        else:
            current_word.append(ch)
    else:
        if not isletters:
            do the fixword logic above on the current word
            add that to newsentence
            start a new non-letters word
        else:
            current_word.append(ch)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a simple solution, that has only one flaw I found: It doesn't deal with punctuation correctly. If that is a problem, tell me.</p>
<pre><code>def function(a, b, c):
    # Give error messages
    if b.lower() not in a.lower():
        print("Cannot be found:", repr(b))
    if c.lower() not in a.lower():
        print("Cannot be found:", repr(c))

    a = a.split(" ")  # separates the words along spaces
    output = []
    for word in a:
        if word.lower() == b.lower():  # is the word b?
            output.append(c)  # add c
        elif word.lower() == c.lower():  # is the word c?
            output.append(b)  # add b
        else:  # the word is neither a nor b
            output.append(word)  # leave the word unchanged
    return " ".join(output)


print(function("Neill and Nathan left the school.", "neill", "nathan"))
print(function("Neill and Nathan left the school.", "Nathan", "neILL"))
print(function("and Bob work together.", "dylan", "bob"))
print(function("Dylan and work together.", "DYLAN", "BoB"))
</code></pre>
</div>
<span class="comment-copy">Can you please post what the program currently outputs, as well as what you expect it to output?</span>
