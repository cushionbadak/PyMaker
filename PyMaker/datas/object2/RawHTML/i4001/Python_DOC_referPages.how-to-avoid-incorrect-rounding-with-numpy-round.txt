<div class="post-text" itemprop="text">
<p>I'm working with floating point numbers. If I do:</p>
<pre><code>import numpy as np
np.round(100.045, 2)
</code></pre>
<p>I get:</p>
<pre><code>Out[15]: 100.04
</code></pre>
<p>Obviously, this should be <code>100.05</code>. I know about the existence of <a href="https://en.wikipedia.org/wiki/IEEE_754" rel="nofollow noreferrer">IEEE 754</a> and that the way that floating point numbers are stored is the cause of this rounding error.</p>
<p>My question is: how can I <em>avoid</em> this error?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are partly right, often the cause of this "incorrect rounding" is because of the way floating point numbers are stored. Some float literals can be represented exactly as floating point numbers while others cannot.</p>
<pre><code>&gt;&gt;&gt; a = 100.045
&gt;&gt;&gt; a.as_integer_ratio()  # not exact
(7040041011254395, 70368744177664)

&gt;&gt;&gt; a = 0.25
&gt;&gt;&gt; a.as_integer_ratio()  # exact
(1, 4)
</code></pre>
<p>It's also important to know that there is no way you can restore the literal you used (<code>100.045</code>) from the resulting floating point number. So the only thing you can do is to use an arbitrary precision data type instead of the literal. For example you could use <code>Fraction</code> or <code>Decimal</code> (just to mention two built-in types).</p>
<p>I mentioned that you cannot restore the literal once it is parsed as float - so you have to input it as string or something else that represents the number <em>exactly</em> and is supported by these data types:</p>
<pre><code>&gt;&gt;&gt; from fractions import Fraction
&gt;&gt;&gt; f = Fraction(100045, 100)
&gt;&gt;&gt; f
Fraction(20009, 20)

&gt;&gt;&gt; f = Fraction("100.045")
&gt;&gt;&gt; f
Fraction(20009, 20)

&gt;&gt;&gt; from decimal import Decimal
&gt;&gt;&gt; Decimal("100.045")
Decimal('100.045')
</code></pre>
<p>However these don't work well with NumPy and even if you get it to work at all - it will almost certainly be <strong>very slow</strong> compared to basic floating point operations.</p>
<pre><code>&gt;&gt;&gt; import numpy as np

&gt;&gt;&gt; a = np.array([Decimal("100.045") for _ in range(1000)])
&gt;&gt;&gt; np.round(a)
AttributeError: 'decimal.Decimal' object has no attribute 'rint'
</code></pre>
<p>In the beginning I said that you're are only partly right. There is another twist! </p>
<p>You mentioned that rounding 100.045 will <strong>obviously</strong> give 100.05. But that's not obvious at all, in your case it is even wrong (in the context of floating point math in programming - it would be true for "normal calculations"). In many programming languages a "half" value (where the number after the decimal you're rounding is 5) isn't <em>always</em> rounded up - for example Python (and NumPy) use a <a href="https://en.wikipedia.org/wiki/Rounding#Round_half_to_even" rel="noreferrer">"round half to even" approach</a> because it's less biased. For example <code>0.5</code> will be rounded to <code>0</code> while <code>1.5</code> will be rounded to <code>2</code>.</p>
<p>So even if <code>100.045</code> could be represented exactly as float - it would still round to <code>100.04</code> because of that rounding rule!</p>
<pre><code>&gt;&gt;&gt; round(Fraction("100.045"), 1)
Fraction(5002, 5)

&gt;&gt;&gt; 5002 / 5
1000.4

&gt;&gt;&gt; d = Decimal("100.045")
&gt;&gt;&gt; round(d, 2)
Decimal('100.04')
</code></pre>
<p>This is even mentioned in the NumPy docs for <a href="https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.around.html" rel="noreferrer"><code>numpy.around</code></a>:</p>
<blockquote>
<h3>Notes</h3>
<p><strong>For values exactly halfway between rounded decimal values, NumPy rounds to the nearest even value</strong>. Thus 1.5 and 2.5 round to 2.0, -0.5 and 0.5 round to 0.0, etc. Results may also be surprising due to the inexact representation of decimal fractions in the IEEE floating point standard [R1011] and errors introduced when scaling by powers of ten.</p>
</blockquote>
<p>(Emphasis mine.)</p>
<p>The only (at least that I know) numeric type in Python that allows setting the rounding rule manually is <code>Decimal</code> - via <a href="https://docs.python.org/library/decimal.html#decimal.ROUND_HALF_UP" rel="noreferrer"><code>ROUND_HALF_UP</code></a>:</p>
<pre><code>&gt;&gt;&gt; from decimal import Decimal, getcontext, ROUND_HALF_UP
&gt;&gt;&gt; dc = getcontext()
&gt;&gt;&gt; dc.rounding = ROUND_HALF_UP
&gt;&gt;&gt; d = Decimal("100.045")
&gt;&gt;&gt; round(d, 2)
Decimal('100.05')
</code></pre>
<h2>Summary</h2>
<p>So to avoid the "error" you have to:</p>
<ul>
<li>Prevent Python from parsing it as floating point value and </li>
<li>use a data type that can represent it exactly</li>
<li>then you have to manually override the default rounding mode so that you will get rounding up for "halves".</li>
<li>(abandon NumPy because it doesn't have arbitrary precision data types)</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Basically there is no general solution for this problem IMO, unless you have a general rule for all the difference cases (see <a href="https://docs.python.org/3/tutorial/floatingpoint.html#tut-fp-issues" rel="nofollow noreferrer">Floating Point Arithmetic: Issues and Limitation</a>). However, in this case you can round the decimal part separately:</p>
<pre><code>In [24]: dec, integ = np.modf(100.045)

In [25]: integ + np.round(dec, 2)
Out[25]: 100.05
</code></pre>
<p>The reason for such behavior is not because separating integer from decimal part makes any difference on <code>round()</code> logic. It's because when you use <code>fmod</code> it gives you a more realistic version of the decimal part of the number which is actually a rounded representation.</p>
<p>In this case here is what <code>dec</code> is:</p>
<pre><code>In [30]: dec
Out[30]: 0.045000000000001705
</code></pre>
<p>And you can check that round gives same result with <code>0.045</code>:</p>
<pre><code>In [31]: round(0.045, 2)
Out[31]: 0.04
</code></pre>
<p>Now if you try with another number like <code>100.0333</code>, the decimal part is a slightly smaller version which as I mentioned, the result you want depends on your rounding policies.</p>
<pre><code>In [37]: dec, i = np.modf(100.0333)

In [38]: dec
Out[38]: 0.033299999999997
</code></pre>
<p>There are also modules like <a href="https://docs.python.org/3/library/fractions.html#module-fractions" rel="nofollow noreferrer"><code>fractions</code></a> and <a href="https://docs.python.org/3/library/decimal.html#decimal.Decimal" rel="nofollow noreferrer"><code>decimal</code></a> that provide support for fast correctly-rounded decimal floating point and rational arithmetic, that you can use in situations as such.</p>
</div>
<span class="comment-copy">maybe check out the <a href="https://docs.python.org/2/library/decimal.html" rel="nofollow noreferrer">decimal module</a>?</span>
<span class="comment-copy">Is this a floating point representation issue, or a round to the nearest even issue?</span>
<span class="comment-copy">@hpaulj A bit of both, combined with the fact that NumPy's rounding algorithm introduces errors in intermediate steps. As a result of those errors, NumPy falsely detects a halfway case and ends up applying the round-ties-to-even rule even though technically it shouldn't, because the original value being rounded isn't an exact tie (thanks to the usual binary floating-point representation issues).</span>
<span class="comment-copy">@hpaulj: The annoying part is that NumPy's rounding algorithm more often gives users the result that satisfies their naive expectations (assuming that they're aware of round-ties-to-even), compared with Python's <code>round</code> operation which <i>does</i> do correct rounding in all cases, but ends up surprising users more often.</span>
<span class="comment-copy"><code>100.045</code> is really <code>100.0450000000000017053025658242404460906982421875</code> which , mathematically, should round to 2 digits to <code>100.05</code>.  To solve this problem, in general, with float64 requires higher precision.  I am unfamiliar with NumPy to help more.</span>
<span class="comment-copy">that's great, thank you so much for this thorough explanation!</span>
<span class="comment-copy">OK so basically <code>fmod</code> reduces the chance of this error occurring... or how should I interpret this? I'm actually looking to avoid these cases, not just reduce the chance of them occurring.</span>
<span class="comment-copy">@PDiracDelta Yes it can be. Something like <code>np.modf(100.0333)</code>. But in these cases it still depends on your rounding policies. There is no general solution for this problem IMHO, unless you have a general rule for all the difference cases.</span>
