<div class="post-text" itemprop="text">
<p>I have following python code:</p>
<pre><code>import subprocess
p=subprocess.Popen(["openssl","genrsa","-aes256","-out","ise.key.pem","2048"],stdin=subprocess.PIPE,stdout=subprocess.PIPE)
inputdata="123456"
p.communicate(input=inputata)
p.communicate(input=inputata)
</code></pre>
<p>output of above code is:</p>
<pre><code>    pan@pan:~/python-scripts$ Generating RSA private key, 2048 bit long modulus
........................+++
...................................+++
e is 65537 (0x10001)
Enter pass phrase for ise.key.pem:
User interface error
140617148802712:error:0906906F:PEM routines:PEM_ASN1_write_bio:read key:pem_lib.c:379:
</code></pre>
<p>I want that input should be give by python there should not be any user interaction :</p>
<p>I know certificate can be generated by python pyOpenSSL library but I want to use normal linux command</p>
<p><strong>My python version is</strong>:</p>
<pre><code>Python 2.7.12 (default, Dec  4 2017, 14:50:18) 
[GCC 5.4.0 20160609] on linux2
Type "help", "copyright", "credits" or "enter code here`license" for more information.
</code></pre>
<p>I saw following link but it didn't help</p>
<p><a href="https://stackoverflow.com/questions/10673185/python-execute-command-line-sending-input-and-reading-output">Python execute command line,sending input and reading output</a></p>
<p>If you run the command in shell it runs as below:</p>
<pre><code>pan@pan:~/python-scripts$ openssl genrsa -aes256 -out ise.key.pem 2048
Generating RSA private key, 2048 bit long modulus
..............................................................+++
..+++
e is 65537 (0x10001)
Enter pass phrase for ise.key.pem:
Verifying - Enter pass phrase for ise.key.pem:
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In his comment, Jean-François Fabre is right about this:</p>
<blockquote>
<p>But the real issue is that piping input to a password entering routine doesn't always work.</p>
</blockquote>
<p>But not about this:</p>
<blockquote>
<p>You have to generate a keyboard event at a lower level.</p>
</blockquote>
<p>Though it would be true in general, in the case at hand the command <a href="https://www.openssl.org/docs/man1.1.0/apps/genrsa.html" rel="nofollow noreferrer"><code>openssl genrsa …</code></a> offers the option <code>-passout stdin</code> to <a href="https://www.openssl.org/docs/man1.1.0/apps/openssl.html" rel="nofollow noreferrer"><em>read the password from standard input</em></a>:</p>
<pre><code>openssl genrsa -aes256 -out ise.key.pem -passout stdin 2048
</code></pre>
<p>So, this Python script works:</p>
<pre><code>import subprocess
p=subprocess.Popen(["openssl","genrsa","-aes256","-out","ise.key.pem",
                    "-passout","stdin","2048"], stdin=subprocess.PIPE,
                                                stdout=subprocess.PIPE)
inputdata="123456"
p.communicate(input=inputdata)
</code></pre>
<p>Note that one cannot call <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate" rel="nofollow noreferrer"><code>communicate()</code></a> with <em>timeout=None</em> more than once, since it waits <em>for process to terminate</em>. But it isn't necessary either, because with <code>-passout stdin</code> the command doesn't ask for verifying, thus no need to enter the pass phrase a second time.</p>
</div>
<div class="post-text" itemprop="text">
<p>I usually don't like subprocess for this kind of tasks ... I would prefer to use pexpect to emulate human behaviour (typing in data ... and so on). </p>
<p>This one is a rough example to do the job </p>
<pre><code>import pexpect

def main():
        inputdata="123456"
        c = pexpect.spawn("/usr/bin/openssl", ["genrsa","-aes256","-out","ise.key.pem","2048"])
        c.expect("Enter.*:")
        c.sendline(inputdata)
        c.expect("Verifying.*:")
        c.sendline(inputdata)
        c.expect(pexpect.EOF)
        c.close()
        c.kill(0)
        print "Done"

if __name__=='__main__':
        main()
</code></pre>
</div>
<span class="comment-copy">shell=True allows to work around the wrong entering of your process: list of arguments should be <code>["openssl","genrsa","-aes256","-out","ise.key.pem","2048"]</code>. But the real issue is that piping input to a password entering routine doesn't always work. You have to generate a keyboard event at a lower level.</span>
<span class="comment-copy">I suggest that you try the above, then <a href="https://stackoverflow.com/posts/50354231/edit">edit</a> your question to remove the useless part about shell=True which makes your question twofold.</span>
<span class="comment-copy">Have you seen this? <a href="https://stackoverflow.com/a/165662/8765205">stackoverflow.com/a/165662/8765205</a></span>
<span class="comment-copy">How to generate a keyboard event at a lower level?  I tried "openssl genrsa -aes256 -out ise.key.pem -passout stdin 2048" but it didn't work</span>
<span class="comment-copy">@Pankaj Sheoran - See the expanded answer. To <i>generate a keyboard event at a lower level</i> would be far more cumbersome and far less portable.</span>
