<div class="post-text" itemprop="text">
<p>When I execute the following code on Python console using the below statement,</p>
<pre><code>for L in permute([12, 32, 3]):
    print(L)
</code></pre>
<p>for the code below, </p>
<pre><code>def permute(L):
    if len(L) &lt;= 1:
        yield L
    else:
        for i in range(0, len(L)):
            L[0], L[i] = L[i], L[0]
            for L1 in permute(L[1:]):
                yield [L[0]] + L1
</code></pre>
<p>each result appears just once. But, if I remove <code>else</code> and remove the associated indentation of the code below it, I receive each result twice. 
Why does it happen?</p>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="https://docs.python.org/howto/functional.html#generators" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p>The big difference between <code>yield</code> and a <code>return</code> statement is that on reaching a <code>yield</code> the generator’s state of execution is suspended and local variables are preserved. On the next call to the generator’s <code>__next__()</code> method, the function will resume executing.</p>
</blockquote>
<p>So this happens because <code>if</code> body doesn't break execution, so it moves forward to the next <code>yield</code> statement and with <code>else</code> clause reaches end of function and implicitly returns.</p>
<p>Check</p>
<pre><code>def counter(step):
    assert step &gt;= 0, ('Can count only from non-negative number, but found '
                       + str(step))
    if step == 0:
        print('Reached end')
        yield step
    print('Step', step)
    for sub_step in counter(step - 1):
        yield sub_step

&gt;&gt;&gt; list(counter(1))

Step 1
Reached end
Traceback (most recent call last):
  File "&lt;input&gt;", line 13, in &lt;module&gt;
Step 0
  File "&lt;input&gt;", line 8, in counter
  File "&lt;input&gt;", line 8, in counter
  File "&lt;input&gt;", line 3, in counter
AssertionError: Can count only from non-negative number, but found -1
</code></pre>
<p>and</p>
<pre><code>def counter(step):
    assert step &gt;= 0, ('Can count only from non-negative number, but found '
                       + str(step))
    if step == 0:
        print('Reached end')
        yield step
    else:
        print('Step', step)
        for sub_step in counter(step - 1):
            yield sub_step
    # implicitly returns here

&gt;&gt;&gt; list(counter(1))
Step 1
Reached end
</code></pre>
<p>As we can see without <code>else</code> execution will continue and call <code>counter</code> with <code>step</code> equal to <code>-1</code>.</p>
<p>So you can leave <code>else</code> or refactor your <code>if</code> clause and add <code>return</code> statement into it to explicitly finish execution like</p>
<pre><code>def permute(L):
    if len(L) &lt;= 1:
        yield L
        return
    for i in range(0, len(L)):
        L[0], L[i] = L[i], L[0]
        for L1 in permute(L[1:]):
            yield [L[0]] + L1
</code></pre>
<h1>Further reading</h1>
<ul>
<li><a href="https://docs.python.org/howto/functional.html#generators" rel="nofollow noreferrer">Generators</a>.</li>
<li><a href="https://docs.python.org/3/reference/simple_stmts.html#the-return-statement" rel="nofollow noreferrer"><code>return</code></a> and <a href="https://docs.python.org/3/reference/simple_stmts.html#the-yield-statement" rel="nofollow noreferrer"><code>yield</code></a> statements.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Because you are <code>yield</code>ing twice, if there is no <code>else</code> loop. </p>
</div>
<span class="comment-copy">glad to help. :) would you like to accept the answer as well.</span>
