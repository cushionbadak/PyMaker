<div class="post-text" itemprop="text">
<p>I stumbled upon this code snippet yet I can't quite understand what it means, because I don't know how <code>sum</code>, <code>map</code> and <code>lambda</code> work together.</p>
<pre><code>radius = math.sqrt(sum(map(lambda x: x * x, map(lambda x, y: x - y, center, boundingBox[0]))))
</code></pre>
<p>Can someone please explain?</p>
</div>
<div class="post-text" itemprop="text">
<p>Let's consider the <a href="https://en.wikipedia.org/wiki/Euclidean_distance" rel="nofollow noreferrer">euclidean distance</a>, by definition you've got that in 3d-space:</p>
<pre><code>d(a,b)=sqrt((b[0]-a[0])**2+(b[1]-a[1])**2+(b[2]-a[2])**2)
</code></pre>
<p>The first part of that oneliner, math.sqrt(sum(map(lambda x: x*x, seq)) is a way to calculate the euclidean distance of a sequence (python iterable).</p>
<p>What is it seq in this case? It'd be just the vector subtraction between boundingbox[0] (which is the bounding box width) and center, which I assume is the centroid of your 3d mesh.</p>
<p>Summing up, that ugly oneliner is a nasty way to calculate the bounding sphere radius out of the center and bounding box.</p>
<p>Better than using map/lambda functions, a much clearer way to compute this, assuming you're working in 3d euclidean space, would be rewrite that oneliner like this (explicitely):</p>
<pre><code>def bounding_sphere_radius(center, boundingbox):
    v = [
        center[0]-boundingbox[0][0],
        center[1]-boundingbox[0][1],
        center[2]-boundingbox[0][2]
    ]
    return math.sqrt(v[0]**2+v[1]**2+v[2]**2)
</code></pre>
<p>Another way, if you've implemented your own 3d vector class and you've overrided the subtraction operator (-) could be something like this:</p>
<pre><code>def bounding_sphere_radius(center, boundingbox):
    v = [center[0]-boundingbox[0]]
    return math.sqrt(v[0]**2+v[1]**2+v[2]**2)
</code></pre>
<p>Or finally, if you've got a length method in your 3d vector class (euclidean distance), something even more readable would be having:</p>
<pre><code>def bounding_sphere_radius(center, boundingbox):
    return (center[0]-boundingbox[0]).length()
</code></pre>
<p>The zen of python says <code>Readability counts.</code> ;)</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/reference/expressions.html#lambda" rel="nofollow noreferrer">lambdas</a> are anonymous functions, think of them as in line functions. </p>
<p>I don't know if it's an apt comparison, but similar to how list comprehensions return a list. </p>
<p><a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer">map</a> applies a function to all the items in an iterable input_list (tuples, strings, etc) In this case it's tuples.</p>
<p>So you would break it down a little better visually by breaking on parenthesis.</p>
<pre><code>radius = math.sqrt(
                   sum(
                       map(lambda x: x * x, map(
                           lambda x, y: x - y, center, boundingBox[0]))))
</code></pre>
<p>This is one of those where you have to work from the outside of the function in, and then back out again, to fully understand what's going on.</p>
<p>You're passing the center and bounding box to the lambda x,y: x-y, with the second map. In this lambda, you're defining two params, x and y, and you're passing in center and boundingBox[0], respectively.</p>
<p>you're passing the results of the second lambda to the first lambda with the first map. You define one parameter, x, and pass in the result from the second lambda for this.</p>
<p>And then you're summing it, and taking the square root. </p>
<p>so mathematically, assuming the center and bounding box[0] are points in tuple form, what this one liner is doing is:</p>
<p>sqrt((X<sub>2</sub> - X<sub>1</sub>)<sup>2</sup> + (Y<sub>2</sub> - Y<sub>1</sub>)<sup>2</sup>)</p>
</div>
<span class="comment-copy">Try breaking the lambdas out into separate functions; that can make it easier to understand the organization.</span>
