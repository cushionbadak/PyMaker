<div class="post-text" itemprop="text">
<p>I want to list all possible words with n letters where the first letter can be a1 or a2, the second can be b1, b2 or b3, the third can be c1 or c2, ... Here's a simple example input-output for n=2 with each letter having 2 alternatives:</p>
<ul>
<li>input = [["a","b"],["c","d"]]</li>
<li>output = ["ac", "ad", "bc", "bd"]</li>
</ul>
<p>I tried doing this recursively by creating all possible words with the first 2 letters first, so something like this:</p>
<pre><code>def go(l):
    if len(l) &gt; 2:
        head = go(l[0:2])
        tail = l[2:]
        tail.insert(0, head)
        go(tail)
    elif len(l) == 2:
        res = []
        for i in l[0]:
            for j in l[1]:
                res.append(i+j)
        return res
    elif len(l) == 1:
        return l
    else:
        return None
</code></pre>
<p>However, this becomes incredibly slow for large n or many alternatives per letter. What would be a more efficient way to solve this?</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you just want <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product</code></a> here:</p>
<pre><code>&gt;&gt;&gt; from itertools import product
&gt;&gt;&gt; lst = ['ab', 'c', 'de']
&gt;&gt;&gt; words = product(*lst)
&gt;&gt;&gt; list(words)
[('a', 'c', 'd'), ('a', 'c', 'e'), ('b', 'c', 'd'), ('b', 'c', 'e')]`
</code></pre>
<p>Or, if you wanted them joined into words:</p>
<pre><code>&gt;&gt;&gt; [''.join(word) for word in product(*lst)]
['acd', 'ace', 'bcd', 'bce']
</code></pre>
<p>Or, with your example:</p>
<pre><code>&gt;&gt;&gt; lst = [["a","b"],["c","d"]]
&gt;&gt;&gt; [''.join(word) for word in product(*lst)]
['ac', 'ad', 'bc', 'bd']
</code></pre>
<hr/>
<p>Of course for very large <code>n</code> or very large sets of letters (size <code>m</code>), this <em>will</em> be slow. If you want to generate an exponentially large set of outputs (<code>O(m**n)</code>), that will take exponential time. But at least it has constant rather than exponential space (it generates one product at a time, instead of a giant list of all of them), and will be faster than what you were on your way to by a decent constant factor, and it's a whole lot simpler and harder to get wrong.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/2/library/itertools.html#itertools.permutations" rel="nofollow noreferrer"><code>permutations</code></a> from the built-in itertools module to achieve this, like so</p>
<pre><code>&gt;&gt;&gt; from itertools import permutations
&gt;&gt;&gt; [''.join(word) for word in permutations('abc', 2)]
['ab', 'ac', 'ba', 'bc', 'ca', 'cb']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>Generating all strings of some length with given alphabet :</h1>
<p>test.py :</p>
<pre><code>def generate_random_list(alphabet, length):
    if length == 0: return []
    c = [[a] for a in alphabet[:]]
    if length == 1: return c
    c = [[x,y] for x in alphabet for y in alphabet]
    if length == 2: return c
    for l in range(2, length):
        c = [[x]+y for x in alphabet for y in c]
    return c

if __name__ == "__main__":
    for p in generate_random_list(['h','i'],2):
        print p
</code></pre>
<hr/>
<h2>$ python2 test.py</h2>
<pre><code>['h', 'h']
['h', 'i']
['i', 'h']
['i', 'i']
</code></pre>
<hr/>
<h1>Next Way :</h1>
<pre><code>def generate_random_list(alphabet, length):
    c = []
    for i in range(length):
        c = [[x]+y for x in alphabet for y in c or [[]]]
    return c

if __name__ == "__main__":
    for p in generate_random_list(['h','i'],2):
        print p
</code></pre>
<h1>Next Way :</h1>
<pre><code>import itertools
if __name__ == "__main__":
    chars = "hi"
    count = 2
    for item in itertools.product(chars, repeat=count):
        print("".join(item))
</code></pre>
<hr/>
<pre><code>import itertools
print([''.join(x) for x in itertools.product('hi',repeat=2)])
</code></pre>
<h1>Next Way :</h1>
<pre><code>from itertools import product
#from string import ascii_letters, digits

#for i in product(ascii_letters + digits, repeat=2):
for i in product("hi",repeat=2):
    print(''.join(i))
</code></pre>
</div>
<span class="comment-copy">Do you mean word as in dictionary word, or just an arbitrary arrangement of letters?</span>
<span class="comment-copy">Do you need the results to be stored in a list, or is it okay just to print them?</span>
<span class="comment-copy">I don't think this answers the question.  It specifically stated that the first letter must be chosen from a specific group of letters, the second letter must be chosen from a second group, the third letter must be chosen from a third group, etc.</span>
<span class="comment-copy">Check the output carefully, this does exactly that.</span>
<span class="comment-copy">@JohnGordon The first letter is chosen from the group <code>'ab'</code>, the second from the group <code>'c'</code>, the third from the group <code>'de'</code>.</span>
<span class="comment-copy">@JohnGordon Yes, vidstige's answer does have that problem, and C Perforrmance's answer would have that problem if it didn't have a bigger one that got in the way.</span>
<span class="comment-copy">@niefpaarschoenen I don't know how many you're looking to pick and how you're looking to distribute them, but yes, filtering the groups with <code>random.sample</code> or <code>letter for letter in group if random.random() &gt; q</code> or whatever <i>before</i> the <code>product</code> will be hugely faster, even if it may (depending on what you want to do) be more complicated.</span>
<span class="comment-copy">I don't think this is what the OP wants. They want the first character to be chosen from a1 or a2; the second from b1, b2, or b3; the third from c1 or c2; etc.</span>
<span class="comment-copy">yes, you're right. Answer by @abarnert is the right one</span>
<span class="comment-copy">The OP wants to generate <i>all</i> of the products. Generating them randomly is not a good way to do that. Also, you're using the same set for each letter, instead of one set for the first, a different one for the second, etc.</span>
<span class="comment-copy">OK, I updated the answer. Thank You @abarnert</span>
