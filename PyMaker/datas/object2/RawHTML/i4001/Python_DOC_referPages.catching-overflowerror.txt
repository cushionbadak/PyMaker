<div class="post-text" itemprop="text">
<p>In Python 3 I have a class representing a range [x,y] of values and computing the length of such range.</p>
<p>If the length is too large, I'm not sure how to catch the OverflowError exception <strong>inside</strong> the class itself. It is raised only in the outer code using a class instance...</p>
<pre><code>class ValRange:
    val_min = None
    val_max = None
    range_len = 0

    def __init__(self, val_min, val_max):
        self.val_min = val_min
        self.val_max = val_max

    def __len__(self):
        if (self.val_min is not None and
             self.val_max is not None):
            length = 0
            try:
                length = int(self.val_max) - int(self.val_min) + 1
            except OverflowError as e:
                # Somehow no exception is caught here...
                print('OverflowError...')
                length = 10**5  # arbitrarily large number
            except Exception as e:
                print(e)
            if length &gt; 0:
                self.range_len = length
        return self.range_len


import traceback
import uuid
x = uuid.UUID('00000000-cb9d-4a99-994d-53a499f260b3')
y = uuid.UUID('ea205f99-0564-4aa0-84c3-1b99fcd679fd')
r = ValRange(x, y)
try:
    print(len(r))
except:
    # The exception is caught in this outer code and not in the class itself. Why?
    print(traceback.format_exc())

# The following, which is equivalent to the operations in the 
# code above, will work. 
a = int(y) - int(x) + 1
print(a)
</code></pre>
<p>This is what happens upon execution:</p>
<pre><code>Traceback (most recent call last):
  File "/home/rira/bugs/overflow.py", line 35, in &lt;module&gt;
    print(len(r))
OverflowError: cannot fit 'int' into an index-sized integer

311207443402617699746040548788952897867
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>That's because the <code>OverflowError</code> doesn't occur within your magic <code>__len__()</code> method - Python is perfectly capable of handling much bigger integers than that - but in CPython <code>len()</code> itself is implemented as <a href="https://docs.python.org/3/c-api/object.html#c.PyObject_Size" rel="nofollow noreferrer"><code>PyObject_Size()</code></a> which returns a <a href="https://www.python.org/dev/peps/pep-0353/#specification" rel="nofollow noreferrer"><code>Py_ssize_t</code></a>, which is limited to <code>2^31-1</code> (32-bit) or <code>2^63-1</code> (64-bit) and thus the overflow occurs when your <code>__len__()</code> result is <em>coerced</em> to it.</p>
<p>You can do a pre-check before returning the result to make sure you capture the overflow before it even occurs, something like:</p>
<pre><code>def __len__(self):
    if (self.val_min is not None and self.val_max is not None):
        length = int(self.val_max) - int(self.val_min) + 1
        if length &gt; sys.maxsize:
            print('OverflowError...')
            length = 10**5  # arbitrarily large number
        self.range_len = length
    return self.range_len
</code></pre>
</div>
<span class="comment-copy">Could you print us the stack trace/error message ?</span>
<span class="comment-copy">of course! done :)</span>
<span class="comment-copy">Oh I see. So <code>len(r)</code> raises the error, while <code>r.__len__()</code> won't.</span>
<span class="comment-copy">@RickyRobinson - Pretty much. Blame it on the way built-ins are implemented. If you really find it too annoying, you can always override the <code>len()</code> built-in to check if the target object has <code>__len__()</code> and call that, otherwise revert to the built-in <code>len()</code>.</span>
