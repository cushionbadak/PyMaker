<div class="post-text" itemprop="text">
<p>I have a function <code>foo</code> that takes a parameter <code>stuff</code>
Stuff can be something in a database and I'd like to create a function that takes a <code>stuff_id</code>, get the <code>stuff</code> from the db, execute <code>foo</code>.</p>
<p>Here's my attempt to solve it:
1/ Create a second function with suffix <code>from_stuff_id</code></p>
<pre><code>def foo(stuff):
    do something

def foo_from_stuff_id(stuff_id):
    stuff = get_stuff(stuff_id)
    foo(stuff)
</code></pre>
<p>2/ Modify the first function</p>
<pre><code>def foo(stuff=None, stuff_id=None):
    if stuff_id:
        stuff = get_stuff(stuff_id)
    do something
</code></pre>
<p>I don't like both ways.
What's the most pythonic way to do it ?</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming <code>foo</code> is the main component of your application, your first way. Each function should have a different purpose. The moment you combine multiple purposes into a single function, you can easily get lost in long streams of code.</p>
<p>If, however, <em>some other function can also provide stuff</em>, then go with the second.</p>
<p>The only thing I would add is make sure you add docstrings (<a href="https://www.python.org/dev/peps/pep-0257/" rel="nofollow noreferrer">PEP-257</a>) to each function to explain in words the role of the function. If necessary, you can also add comments to your code.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm not a big fan of type overloading in Python, but this is one of the cases where I might go for it if there's really a need:</p>
<pre><code>def foo(stuff):
    if isinstance(stuff, int):
        stuff = get_stuff(stuff)
    ...
</code></pre>
<p>With <a href="https://docs.python.org/3/library/typing.html" rel="nofollow noreferrer">type annotations</a> it would look like this:</p>
<pre><code>def foo(stuff: Union[int, Stuff]):
    if isinstance(stuff, int):
        stuff = get_stuff(stuff)
    ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It basically depends on how you've defined all these functions. If you're importing <code>get_stuff</code> from another module the second approach is more Pythonic, because from an OOP perspective you create functions for doing one particular purpose and in this case when you've already defined the <code>get_stuff</code> you don't need to call it within another function.</p>
<p>If <code>get_stuff</code> it's not defined in another module, then it depends on whether you are using classes or not. If you're using a class and you want to use all these modules together you can use a method for either accessing or connecting to the data base and use that method within other methods like <code>foo</code>.</p>
<p>Example:</p>
<pre><code>from some module import get_stuff

MyClass:
    def __init__(self, *args, **kwargs):
       # ...
       self.stuff_id = kwargs['stuff_id']         

    def foo(self):
        stuff = get_stuff(self.stuff_id)
        # do stuff
</code></pre>
<p>Or if the functionality of <code>foo</code> depends on the existence of <code>stuff</code> you can have a global <code>stuff</code> and simply check for its validation :</p>
<pre><code>MyClass:
    def __init__(self, *args, **kwargs):
       # ...
       _stuff_id = kwargs['stuff_id']
       self.stuff = get_stuff(_stuff_id)  # can return None          

    def foo(self):
        if self.stuff:      
            # do stuff
        else:
            # do other stuff
</code></pre>
<p>Or another neat design pattern for such situations might be using a dispatcher function (or method in class) that delegates the execution to different functions based on the state of <code>stuff</code>.</p>
<pre><code>def delegator(stff, stuff_id):
    if stuff:  # or other condition 
        foo(stuff)
    else:
        get_stuff(stuff_id)
</code></pre>
</div>
<span class="comment-copy">Can you give more context on what you are trying to do and what is the problem as you see it?</span>
<span class="comment-copy">I have a Flask API with many routes. Each route is always the same, it gets a stuff_id from the parameters used in the route and then executes a function with parameter stuff_id. When I want to test my function, the problem is that it uses an id instead of the stuff object so I want to separate the logic of getting the stuff object from the logic of executing a function on stuff.</span>
