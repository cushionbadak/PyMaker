<div class="post-text" itemprop="text">
<p>I have a class which exposes two methods. These methods are actually visual syntax sugar, they ultimately point to the same code which behaves differently, depending on the payload it receives:</p>
<pre><code>class Action:

    def on(self):
        self.action(1)

    def off(self):
        self.action(2)

    def action(self, payload):
        # a long function which does many things and uses the payload from on() and off()
        print(payload)

a = Action()
a.on()
a.off()
</code></pre>
<p>Is there a way to define <code>on()</code> and <code>off()</code> so that they point to the same code (the one in <code>action()</code>), which would <strong>behave differently depending on the name of the method which was called?</strong></p>
<p>I could of course pass the action in the call:</p>
<pre><code>class Action:

    def action(self, what):
        payload = 1 if what == 'on' else 0
        # a long function which does many things and uses the payload from on() and off()
        print(payload)


a = Action()
a.action('on')
a.action('off')
</code></pre>
<p>but I want to keep an on/off structure of the class methods.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is very similar to your first example, but are you looking for <a href="https://docs.python.org/2.7/library/functools.html#functools.partial" rel="nofollow noreferrer">functools.partial</a>?</p>
<p>You can use it to automatically set some arguments into a function, and the return value is a function object as well.  Using it, you could do this:</p>
<pre><code>import functools
class Abc(object):
  def action(self, payload):
    print(payload)
  def __init__(self):
    self.off = functools.partial(self.action, payload=1)
    self.on = functools.partial(self.action, payload=2)
</code></pre>
<p>Then, you have your <code>action</code>, <code>on</code>, and <code>off</code> function, all working as expected:</p>
<pre><code>foo = Abc()
foo.on()
&gt;&gt;&gt; 2
foo.off()
&gt;&gt;&gt; 1
foo.action(9)
&gt;&gt;&gt; 9
</code></pre>
<p>Using <code>partial</code> is a semantically stronger way to say that this is syntactic sugar for calling another function.  A function declaration such as <code>def on(self): ...</code> could be anything, while <code>self.on = functools.partial(action,...)</code> explicitly states that your tying one function to the other.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def _action_maker(payload):
    def _action(self):
        return self.action(payload)

    return _action

class Action:
    on = _action_maker(1)
    off = _action_maker(2)

    def action(self, payload):
        # a long function which does many things and uses the payload from on() and off()
        print(payload)
</code></pre>
<p>But personally I don't like this because my editor doesn't understand it and gives me false warnings.</p>
</div>
<div class="post-text" itemprop="text">
<h2>Try <code>inspect</code></h2>
<pre><code>import inspect
class Action:

    def on(self):
        self.action(1)

    def off(self):
        self.action(2)

    def action(self, payload):
        # a long function which does many things and uses the payload from on() and off()
        currentframe = inspect.currentframe()
        callername = inspect.getouterframes(currentframe, 2)[1][3]
        if callername =='on':
            print('on')
        elif callername == 'off':
            print('off')

a = Action()
a.on() #on
a.off() #off
</code></pre>
<hr/>
<h2>Or simply pass hidden argument</h2>
<pre><code>class Action:

    def on(self):
        self.action(1,'on')

    def off(self):
        self.action(2, 'off')

    def action(self, payload, callername):
        # a long function which does many things and uses the payload from on() and off()
        if callername =='on':
            print('on')
        elif callername == 'off':
            print('off')

a = Action()
a.on() #on
a.off() #off
</code></pre>
</div>
<span class="comment-copy">try the state pattern <a href="https://sourcemaking.com/design_patterns/state/python/1" rel="nofollow noreferrer">sourcemaking.com/design_patterns/state/python/1</a></span>
<span class="comment-copy">What should happen if <code>action</code> is called by something other than <code>on</code> or <code>off</code>?</span>
<span class="comment-copy">"which would behave differently depending on the name of the method which was called" - that's going to be a maintenance headache. What's wrong with what you have?</span>
<span class="comment-copy">I'm not seeing anything wrong with what you already have...especially given that the payloads are different for <code>on</code> and <code>off</code>.</span>
<span class="comment-copy">In general, <i>no</i> Python object knows anything about the name (or names) that are bound to it. What you have is the right approach.</span>
<span class="comment-copy">would you know whether the interface is stable? I am a bit worried about the various numerical indexes and parameters</span>
<span class="comment-copy">@WoJ It is not guaranteed. See <a href="https://docs.python.org/3/library/inspect.html#inspect.currentframe" rel="nofollow noreferrer">docs.python.org/3/library/inspect.html#inspect.currentframe</a> . But I may suggest a simple workaround.</span>
