<div class="post-text" itemprop="text">
<p>I'm trying to create dictionary with the count of each letter appearing in a list of words. The method <code>count_letters_v2(word_list)</code>, print the letters but does not return the dictionary. Why? And how do I fix this? Thank you.</p>
<pre><code>def count_letters_v2(word_list):
    count = {}
    for word in word_list:
        print word
        for letter in word:
            print letter
            if letter not in count:
                count[letter] = 1
            else:
                count[letter] = count[letter] + 1
    return count


def main():
    count_letters_v2(['a','short','list','of','words'])


if __name__ == '__main__':
    main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It does return the dictionary. That's what <code>return count</code> does. Do you want to print out the dictionary? Then change <code>main()</code> to </p>
<pre><code>def main():
    print count_letters_v2(['a','short','list','of','words'])
</code></pre>
<hr/>
<p>For the record, there's a <code>Counter</code> object (a subclass of <code>dict</code> so can do all the same things) in the standard library that will do this all for you.</p>
<pre><code>from collections import Counter
def count_letters_v3(word_list):
    return Counter(''.join(word_list))

print count_letters_v3(['a','short','list','of','words'])
</code></pre>
<p>Output:</p>
<pre><code>Counter({'a': 1,
         'd': 1,
         'f': 1,
         'h': 1,
         'i': 1,
         'l': 1,
         'o': 3,
         'r': 2,
         's': 3,
         't': 2,
         'w': 1})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As said, you code works but you didn't do anytinhg with the return value of the function.</p>
<p>That said, I can think of some improvements though. First, the <a href="https://docs.python.org/3/library/stdtypes.html" rel="nofollow noreferrer"><code>get</code></a> method 
of <code>dict</code> will make the case of a new letter cleaner, setting the default value to <code>0</code>:</p>
<pre><code>...
count = {}
for word in word_list:
    for letter in word:
        count[letter] = count.get(letter, 0) + 1
...
</code></pre>
<p>Otherwise, you can use a <code>Counter</code> object from collections:</p>
<pre><code>from collections import Counter

def count_letters_v2(word_list):
    count = Counter()
    for word in word_list:
       count.update(word)
    return count
</code></pre>
<p>If you have a very long list of words, you shouldn't use <code>str.join</code> since it builds new string. The <code>chain_from_iterable</code> method of <code>itertools</code> module will chain the letters for free:</p>
<pre><code>from collections import Counter
from itertools import chain

def count_letters_v2(word_list):
    return Counter(chain.from_iterable(word_list))
</code></pre>
</div>
<span class="comment-copy">It does return the dictionary. That's what <code>return count</code> does.</span>
<span class="comment-copy">Confirmation: you don't make anything with <code>count_letters_v2(['a','short','list','of','words'])</code>. Try to print it!</span>
<span class="comment-copy">there's nothing wrong with this function. assign the result of <code>count_letters_v2</code> to another variable and examine it in the shell. you'll see it contains the counts as expected.</span>
<span class="comment-copy"><code>print</code> when you call function to see what it returns.</span>
<span class="comment-copy">also you may want to check the <code>Counter</code> builtin, <a href="https://docs.python.org/2/library/collections.html#collections.Counter" rel="nofollow noreferrer">docs.python.org/2/library/collections.html#collections.Counter</a></span>
<span class="comment-copy">nothing short of fancy</span>
<span class="comment-copy">the chain method is (very slightly) slower than join though:  <code>x = ['a', 'short', 'list', 'of', 'strings'] * 10_000;</code> <code>%timeit Counter(''.join(x)); 12.4 ms ± 23.7 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</code> <code>%timeit Counter(itertools.chain.from_iterable(x)); 14.5 ms ± 44.9 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</code></span>
<span class="comment-copy">@FHTMitchell I made some tests that confirm your benchmark. Usual time-space tradeoff (small joke: it's faster until you hit the swap...) But I think one shouldn't make a copy in such a case. It's faster in Python, but will be slower in another language. My opinion is that it's a good habit to avoid copies, unless you <i>have to</i> make a copy (performance issue, iterate twice sequentially, ...).</span>
