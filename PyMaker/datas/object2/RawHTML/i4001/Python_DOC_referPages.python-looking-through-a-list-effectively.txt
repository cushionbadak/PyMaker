<div class="post-text" itemprop="text">
<p>I am currently working on an exam project in python, where I have to make a choropleth map that shows all the different countries in the world, and what their populations are. </p>
<p>I get my data from an api and store that data in 2 different lists, let's call them a and b.</p>
<p>a contains values looking like this:</p>
<pre><code>a = [['Afghanistan', 'AF'], ['Åland Islands', 'AX'], ['Albania', 'AL'], ['Algeria', 'DZ'], ['American Samoa', 'AS'], ['Andorra', 'AD'], ['Angola', 'AO']
</code></pre>
<p>and b:</p>
<pre><code>b = ['Afghanistan' 'AFRICA' 'Albania' 'Algeria' 'Angola'
</code></pre>
<p>I want to create a new list named c that contains only the values, which appears
in BOTH lists.</p>
<p>What confuses me the most, is that, "a" contains both country names and 
country codes, and "b" contains single values, listed next to each other.</p>
<p>list "c" should end up looking something like this: ['Afghanistan','Albania',Algeria','Angola']...</p>
<p>Thanks in advance</p>
</div>
<div class="post-text" itemprop="text">
<p>You can flatten the first list using <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain.from_iterable</code></a> and use <a href="https://docs.python.org/3/library/stdtypes.html#frozenset.intersection" rel="nofollow noreferrer">set intersection</a>:</p>
<pre><code>&gt;&gt;&gt; set(itertools.chain.from_iterable(a)) &amp; set(b)
set(['Afghanistan', 'Albania', 'Angola', 'Algeria'])
</code></pre>
<p>If you don't want the itertools import (at the cost of a bit of performance):</p>
<pre><code>&gt;&gt;&gt; set([i for j in a for i in j]) &amp; set(b)
set(['Afghanistan', 'Albania', 'Angola', 'Algeria'])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>i too new to python and i dont know the predefined functions and i write my logic to you. Hope this work for you ...    </p>
<pre><code>a = [['Afghanistan', 'AF'], ['Åland Islands', 'AX'], ['Albania', 'AL'], ['Algeria', 'DZ'], ['American Samoa', 'AS'], ['Andorra', 'AD'], ['Angola', 'AO']]

    b = ['Afghanistan' ,'AFRICA', 'Albania' ,'Algeria', 'Angola']

    c=[]
    for i in range(0,len(b)):
        for j in range(0,len(a)):
            if(b[i]==a[j][0]):
                c.append(b[i])
                break        
    print(c)
</code></pre>
<p>have fun in python </p>
</div>
<span class="comment-copy">A suggestion: No need for direct flattening, <code>a</code> can be turned directly and efficiently into a <code>dict</code> and then you can use <code>dict.keys()</code> as the first set.</span>
<span class="comment-copy">But what if there are intersections in the second element?</span>
<span class="comment-copy">It it shouldn't matter in this use case, at least not from what the OP is describing.</span>
<span class="comment-copy">My timings are showing that as slower than <code>chain.from_iterable</code></span>
<span class="comment-copy">This answer relies on the fact that the country names and codes never intersect.  While that's almost certainly true in practice, forming a mixed-semantic-type set feels a little clunky.</span>
