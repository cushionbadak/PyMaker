<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/1500718/what-is-the-right-way-to-override-the-copy-deepcopy-operations-on-an-object-in-p">What is the right way to override the copy/deepcopy operations on an object in Python?</a>
<span class="question-originals-answer-count">
                    7 answers
                </span>
</li>
</ul>
</div>
<p>I have object which has it's own content (i.e. list of something) and a reference to another object, with which it is linked. How can I exclude the reference to the other object from being deep-copied?</p>
<pre><code>from copy import deepcopy
class Foo:
    def __init__(self, content, linked_to):
        self.content = content
        self.linked_to = linked_to

a1 = Foo([[1,2],[3,4]], None)
a2 = Foo([[5,6],[7,8]], a1)

a3 = deepcopy(a2) # &lt;- I don't want there, that a3.linked_to will be copied
# I want that a3.linked_to will still point to a1

a3.linked_to.content.append([9,10])
print a1.content # [[1,2],[3,4]], but I want [[1,2],[3,4], [9,10]] 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your class can implement a <code>__deepcopy__</code> method to control how it is copied. From the <a href="https://docs.python.org/3/library/copy.html" rel="nofollow noreferrer"><code>copy</code> module documentation</a>:</p>
<blockquote>
<p>In order for a class to define its own copy implementation, it can define special methods <code>__copy__()</code> and <code>__deepcopy__()</code>. The former is called to implement the shallow copy operation; no additional arguments are passed. The latter is called to implement the deep copy operation; it is passed one argument, the memo dictionary. If the <code>__deepcopy__()</code> implementation needs to make a deep copy of a component, it should call the <code>deepcopy()</code> function with the component as first argument and the memo dictionary as second argument.</p>
</blockquote>
<p>Simply return a new instance of your class, with the reference you don't want to be deep-copied just taken across as-is. Use the <code>deepcopy()</code> function to copy other objects:</p>
<pre><code>from copy import deepcopy

class Foo:
    def __init__(self, content, linked_to):
        self.content = content
        self.linked_to = linked_to

    def __deepcopy__(self, memo):
        # create a copy with self.linked_to *not copied*, just referenced.
        return Foo(deepcopy(self.content, memo), self.linked_to)
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; a1 = Foo([[1, 2], [3, 4]], None)
&gt;&gt;&gt; a2 = Foo([[5, 6], [7, 8]], a1)
&gt;&gt;&gt; a3 = deepcopy(a2)
&gt;&gt;&gt; a3.linked_to.content.append([9, 10])  # still linked to a1
&gt;&gt;&gt; a1.content
[[1, 2], [3, 4], [9, 10]]
&gt;&gt;&gt; a1 is a3.linked_to
True
&gt;&gt;&gt; a2.content is a3.content  # content is no longer shared
False
</code></pre>
</div>
<span class="comment-copy">That's not a weak reference. That's just a normal reference to another object.</span>
<span class="comment-copy">You can implement it yourself by implementing <code>__deepcopy__</code> in <code>Foo</code></span>
<span class="comment-copy">That's why it's quoted, just to separate it from other type of reference in context of the question.</span>
<span class="comment-copy">@AntonOvsyannikov: then perhaps don't call it a weak reference; just say you want to exclude something in the copy?</span>
<span class="comment-copy">Ok, let's call it 'special', thanks anyway.</span>
