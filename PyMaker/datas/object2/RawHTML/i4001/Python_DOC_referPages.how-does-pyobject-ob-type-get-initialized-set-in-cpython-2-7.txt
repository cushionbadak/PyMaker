<div class="post-text" itemprop="text">
<p>I am investigating how isinstance() func works for CPython 2.7</p>
<p>Now I have an example with two Python files: lib1.py lib2.py</p>
<pre><code>In lib1.py:
from a.b import lib2
def func_h():
  ob = lib2.X()
  print(isinstance(ob, lib2.X))

In lib2.py:
class X(object):
  a = 1
</code></pre>
<p>The results print: True</p>
<p>Then I dig into CPython source code to
<a href="https://github.com/python/cpython/blob/ad65d09fd02512b2ccf500f6c11063f705c9cd28/Objects/abstract.c#L2945" rel="nofollow noreferrer">https://github.com/python/cpython/blob/ad65d09fd02512b2ccf500f6c11063f705c9cd28/Objects/abstract.c#L2945</a></p>
<p>where CPython did this check:</p>
<pre><code>if (Py_TYPE(inst) == (PyTypeObject *)cls)
        return 1;
</code></pre>
<p>where Py_TYPE() is macro</p>
<pre><code>#define Py_TYPE(ob)             (((PyObject*)(ob))-&gt;ob_type)
</code></pre>
<p>Does anyone know the clues how CPython inits or sets the <strong>ob_type</strong> during the program starting?</p>
</div>
<div class="post-text" itemprop="text">
<p>Normally, this happens in <a href="https://docs.python.org/3/c-api/allocation.html#c.PyObject_Init" rel="nofollow noreferrer"><code>PyObject_Init</code></a> (or <code>PyObject_InitVar</code>, which I won't mention again, but there are equivalent variations across the board), or the <code>PyObject_INIT</code> macro (which does the same thing in a faster way, but one that isn't guaranteed to be binary-compatible with other interpreter builds on the same platform). The docs for <code>PyObject_Init</code> say:</p>
<blockquote>
<p>Initialize a newly-allocated object op with its type and initial reference. Returns the initialized object. If type indicates that the object participates in the cyclic garbage detector, it is added to the detector’s set of observed objects. Other fields of the object are not affected.</p>
</blockquote>
<p>You can see <a href="https://github.com/python/cpython/blob/ad65d09fd02512b2ccf500f6c11063f705c9cd28/Objects/object.c#L217" rel="nofollow noreferrer">the source in <code>object.c</code></a>:</p>
<pre><code>PyObject *
PyObject_Init(PyObject *op, PyTypeObject *tp)
{
    if (op == NULL)
        return PyErr_NoMemory();
    /* Any changes should be reflected in PyObject_INIT (objimpl.h) */
    Py_TYPE(op) = tp;
    _Py_NewReference(op);
    return op;
}
</code></pre>
<p>For more details, see <a href="https://github.com/python/cpython/blob/ad65d09fd02512b2ccf500f6c11063f705c9cd28/Include/objimpl.h#L26" rel="nofollow noreferrer">the comments in <code>objimpl.h</code></a>.</p>
<hr/>
<p>When an object is constructed from Python (or via the high-level C API):</p>
<ul>
<li>The type's <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer"><code>__new__</code></a> method or <a href="https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_new" rel="nofollow noreferrer"><code>tp_new</code></a> slot gets called.

<ul>
<li>This usually inherits from or <code>super</code>s to <a href="https://github.com/python/cpython/blob/ad65d09fd02512b2ccf500f6c11063f705c9cd28/Objects/typeobject.c#L2992" rel="nofollow noreferrer"><code>object_new</code></a>, which calls <a href="https://github.com/python/cpython/blob/ad65d09fd02512b2ccf500f6c11063f705c9cd28/Objects/typeobject.c#L803" rel="nofollow noreferrer"><code>PyType_GenericNew</code></a>.</li>
<li>… or it delegates to some other constructor (which ultimately gets you back here)</li>
<li>… or returns some already existing object</li>
<li>… but if not, it must call <code>tp_alloc</code> manually.</li>
</ul></li>
<li><code>PyType_GenericNew</code> calls the type's <a href="https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_alloc" rel="nofollow noreferrer"><code>tp_alloc</code></a> slot (there's no Python special method for this).

<ul>
<li>This usually inherits from or <code>super</code>s to <a href="https://github.com/python/cpython/blob/ad65d09fd02512b2ccf500f6c11063f705c9cd28/Objects/typeobject.c#L773" rel="nofollow noreferrer"><code>PyType_GenericAlloc</code></a>, which calls the <code>PyObject_INIT</code> macro.</li>
<li>… but if not, <code>tp_alloc</code> must call one of the <code>PyObject_Init</code>-family functions or macros, or do the same thing itself.</li>
</ul></li>
</ul>
<hr/>
<p>Code in C extension modules, and internal interpreter code may:</p>
<ul>
<li>Use the same high-level API</li>
<li>… or call <code>PyObject_New</code>, which allocates the object and calls <code>PyObject_Init</code> on it, and casts the result pointer</li>
<li>… or just call <code>PyObject_Init</code> directly (when it knows the type it's constructing doesn't customize <code>tp_new</code>, <code>tp_alloc</code>, or <code>tp_init</code>)</li>
<li>… or construct objects manually, but at some point it must call one of the <code>PyObject_Init</code> family directly or indirectly, or do the same thing itself, just as with custom <code>tp_alloc</code></li>
<li>… or allocate constant objects statically rather than on the heap, like <a href="https://github.com/python/cpython/blob/ad65d09fd02512b2ccf500f6c11063f705c9cd28/Objects/object.c#L2037" rel="nofollow noreferrer"><code>PyNone</code></a> and many builtin and extension type objects, in which case the type (which also has to be a static constant, of course) is just specified in the struct initializer.</li>
</ul>
</div>
