<div class="post-text" itemprop="text">
<p>I've been digging around the source code to figure-out at which point the result is printed. For example:</p>
<pre><code>&gt;&gt;&gt; x = 1
&gt;&gt;&gt; x + 2
3
</code></pre>
<p>The above two statements are compiled to:</p>
<pre><code>  1           0 LOAD_CONST               0 (1)
              3 STORE_NAME               0 (x)
              6 LOAD_CONST               1 (None)
              9 RETURN_VALUE
</code></pre>
<p>and </p>
<pre><code>  1           0 LOAD_NAME                0 (x)
              3 LOAD_CONST               0 (2)
              6 BINARY_ADD
              7 RETURN_VALUE
</code></pre>
<p>The first statement doesn't print anything because <code>None</code> is the returned value. The second returns the result of the addition.</p>
<p>CPython's interactive loop calls <a href="https://github.com/python/cpython/blob/42aa93b8ff2f7879282b06efc73a31ec7785e602/Python/pythonrun.c#L120" rel="nofollow noreferrer"><code>PyRun_InteractiveOneObjectEx()</code></a> for each input. This <a href="https://github.com/python/cpython/blob/42aa93b8ff2f7879282b06efc73a31ec7785e602/Python/pythonrun.c#L236" rel="nofollow noreferrer">gets the AST</a> and invokes <code>run_mod()</code> to <a href="https://github.com/python/cpython/blob/42aa93b8ff2f7879282b06efc73a31ec7785e602/Python/pythonrun.c#L1032" rel="nofollow noreferrer">compile that AST to byte code</a> and then <a href="https://github.com/python/cpython/blob/42aa93b8ff2f7879282b06efc73a31ec7785e602/Python/pythonrun.c#L1035" rel="nofollow noreferrer">evaluate the result</a> in the virtual machine. The returned Python object that <code>PyRun_InteractiveOneObjectEx()</code> gets is simply the <a href="https://github.com/python/cpython/blob/3a9ccee0e5dbf7d67f5ab79f6095755969db117c/Python/ceval.c#L1631" rel="nofollow noreferrer">top of the VM's stack</a>.</p>
<p>So far all of this is what I would expect. But then the returned value seems to be <a href="https://github.com/python/cpython/blob/42aa93b8ff2f7879282b06efc73a31ec7785e602/Python/pythonrun.c#L256" rel="nofollow noreferrer">thrown away</a>! When is this printed by the REPL?</p>
<p>As an aside, I can see that interactive mode does change the tokenizer; it <a href="https://github.com/python/cpython/blob/f2ddc6ac9370a1805ab1b751437df8f96f38bfcf/Parser/tokenizer.c#L934" rel="nofollow noreferrer"><code>invokes PyOS_Readline</code></a> with the <code>sys.ps1</code> prompt (<code>"&gt;&gt;&gt; "</code> by default). I checked for a similar change in <code>pythonrun.c</code>, but no luck.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are showing disassemblies of the bytecode as generated by having the code in a function.  That isn't how interactive code is compiled: it uses a special 'single' mode (3rd parameter to <code>compile()</code>, if you were doing the equivalent in Python code).  In this mode, the <code>POP_TOP</code> opcode that discards the value of each expression gets turned into a <code>PRINT_EXPR</code> instead.  The reason why <code>x = 1</code> prints nothing is that statements leave nothing on the stack that needs to be popped, so this transformation doesn't apply.</p>
</div>
<div class="post-text" itemprop="text">
<p>Correct <a href="https://stackoverflow.com/a/50374656/478288">answer from @jasonharper</a>! For posterity, here's a deeper look of what's going on.</p>
<p>The above disassembly shows the results of <code>eval</code> mode:</p>
<pre><code>&gt;&gt;&gt; list(compile('x + 2', '&lt;stdin&gt;', 'eval').co_code)
[101, 0, 0, 100, 0, 0, 23, 83]
</code></pre>
<p>The opcodes can be viewed with:</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.opname[101]
'LOAD_NAME'
&gt;&gt;&gt; dis.opname[100]
'LOAD_CONST'
&gt;&gt;&gt; dis.opname[23]
'BINARY_ADD'
&gt;&gt;&gt; dis.opname[83]
'RETURN_VALUE'
</code></pre>
<p>The two numbers following the opcode represent a 16-bit operand, though only the first byte is what we need here. So this corresponds to:</p>
<pre><code>LOAD_NAME     0
LOAD_CONST    0
BINARY_ADD
RETURN_VALUE
</code></pre>
<p>Those operands are indices to the compiled code object's variable names and constant pool, respectively.</p>
<pre><code>&gt;&gt;&gt; c = compile('x + 2', '&lt;stdin&gt;', 'eval')
&gt;&gt;&gt; c.co_names
('x',)
&gt;&gt;&gt; c.co_consts
(2,)
</code></pre>
<p>So far, this is what we have in the question. But in reality, executing Python code results in:</p>
<pre><code>&gt;&gt;&gt; list(compile('x + 2', '&lt;stdin&gt;', 'exec').co_code)
[101, 0, 0, 100, 0, 0, 23, 1, 100, 1, 0, 83]
&gt;&gt;&gt; dis.opname[1]
'POP_TOP'
</code></pre>
<p>I.e., the result is discarded and a <code>None</code> is introduced as the return value.</p>
<p>In interactive mode, we have:</p>
<pre><code>&gt;&gt;&gt; list(compile('x + 2', '&lt;stdin&gt;', 'single').co_code)
[101, 0, 0, 100, 0, 0, 23, 70, 100, 1, 0, 83]
&gt;&gt;&gt; dis.opname[70]
'PRINT_EXPR'
</code></pre>
<p>The result is printed (via <a href="https://docs.python.org/3/library/sys.html#sys.displayhook" rel="nofollow noreferrer"><code>sys.displayhook</code></a>) and a <code>None</code> becomes the actual return value.</p>
<p>So the printing is introduced by the code generation phase, not by the VM.</p>
</div>
