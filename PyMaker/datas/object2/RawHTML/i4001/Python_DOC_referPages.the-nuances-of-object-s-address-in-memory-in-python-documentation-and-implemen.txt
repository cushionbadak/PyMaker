<div class="post-text" itemprop="text">
<p>The interface of the <code>id()</code> function in Python is clear to me:
"An object’s identity never changes once it has been created" <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">[1]</a>, and
"This is an integer which is guaranteed to be unique and constant for this object during its lifetime." <a href="https://docs.python.org/3/library/functions.html#id" rel="nofollow noreferrer">[2]</a></p>
<p>But this statement in <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">[1]</a> confuses me: "you may think of it as the object’s address in memory". </p>
<p>The issue is it's not clear what object's address in memory is and how it changes. I would think this is really an implementation detail. This <a href="https://stackoverflow.com/questions/10795682/do-python-objects-move-in-memory-during-execution">question</a> seems to suggest for this statement in the Language Reference to hold true, the virtual address of an object must never change in the implementation. </p>
<p>My questions are then:  </p>
<ol>
<li><p>Is this address being referred to the virtual memory address or the physical memory address? The physical address of any process is determined at run-time by the OS so I don't see how it can be physical.  </p></li>
<li><p>How does the implementation keep the virtual object address the same, and still avoid internal fragmentation? By contrast, in Java, the JVM routines moves objects during GC. </p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>The <code>id</code> of an object is, in fact, implementation-defined, as long as it is a) unique and constant <em>during</em> its lifetime (while not related to this question: this does mean that two objects can have the same <code>id</code> if the first's lifetime has ended).</p>
<p>The CPython-implementation does have the invariant that objects are always pinned at their original memory location and never moved around. This has huge benefits when it comes to interoperability with C, as you can freely pass pointers around that stay valid as long as the object stays alive (which is usually just an incremented reference counter away).</p>
<p>Given that, the CPython-interpreter simply uses the virtual memory address of an object as it's <code>id</code>:</p>
<ul>
<li>The virtual address is unique for every object because any two objects that <em>could</em> determine that they are not the same object have to be at different memory locations.</li>
<li>Using the virtual address of an object as it's <code>id</code> is always safe, because if one would store the <code>id</code>, drop the original object, re-use the <code>id</code> (<em>have I seen this object before?</em>) and get into confusion, he'd violate the rule that the <code>id</code> is only valid for as long as the object represented by it is alive.</li>
</ul>
<p>Also notice that reallocations do not change the virtual address of the object. For example, the <a href="https://github.com/python/cpython/blob/1a5856bf9295fa73995898d576e0bedf016aee1f/Include/listobject.h#L23" rel="nofollow noreferrer"><code>list</code> object</a> has an internal pointer to the vector of elements. The <code>id</code> of the <code>list</code>-object is the virtual address of <code>PyListObject</code> itself. When the list grows and needs to be reallocated / moved somewhere else, only the internal pointer is changed; the <code>PyListObject</code> stays where it was, hence it's <code>id</code> remains the same.</p>
<p>Here is the <a href="https://github.com/python/cpython/blob/55edd0c185ad2d895b5d73e47d67049bc156b654/Python/bltinmodule.c#L1213" rel="nofollow noreferrer">entire definition of the built-in <code>id()</code></a> function from current <code>HEAD</code>:</p>
<pre><code>static PyObject *
builtin_id(PyModuleDef *self, PyObject *v)
{
    return PyLong_FromVoidPtr(v);
}
</code></pre>
<p>No smoke, no mirrors. It's just the pointer.</p>
</div>
