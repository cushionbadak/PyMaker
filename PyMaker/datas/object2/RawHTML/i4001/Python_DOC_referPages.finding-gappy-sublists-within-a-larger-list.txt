<div class="post-text" itemprop="text">
<p>Let's say I have a list like this: </p>
<pre><code> [['she', 'is', 'a', 'student'],
 ['she', 'is', 'a', 'lawer'],
 ['she', 'is', 'a', 'great', 'student'],
 ['i', 'am', 'a', 'teacher'],
 ['she', 'is', 'a', 'very', 'very', 'exceptionally', 'good', 'student']]
</code></pre>
<p>Now I have a list like this:</p>
<pre><code>['she', 'is', 'student']
</code></pre>
<p>I want to query the larger list with this one, and return all the lists that contain the words within the query list in the same order. There might be gaps, but the order should be the same. How can I do that? I tried using the <code>in</code> operator but I don't get the desired output. </p>
</div>
<div class="post-text" itemprop="text">
<p>If all that you care about is that the words appear in order somehwere in the array, you can use a <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>collections.deque</code></a> and <a href="https://docs.python.org/3/library/collections.html#collections.deque.popleft" rel="nofollow noreferrer"><code>popleft</code></a> to iterate through the list, and if the <code>deque</code> is emptied, you have found a valid match:</p>
<pre><code>from collections import deque

def find_gappy(arr, m):
  dq = deque(m)
  for word in arr:
    if word == dq[0]:
      dq.popleft()
      if not dq:
        return True
  return False
</code></pre>
<p>By comparing each <code>word</code> in <code>arr</code> with the first element of <code>dq</code>, we know that when we find a match, it has been found in the correct order, and then we <code>popleft</code>, so we now are comparing with the next element in the <code>deque</code>.</p>
<p>To filter your initial list, you can use a simple list comprehension that filters based on the result of <code>find_gappy</code>:</p>
<pre><code>matches = ['she', 'is', 'student']
x = [i for i in x if find_gappy(i, matches)]

# [['she', 'is', 'a', 'student'], ['she', 'is', 'a', 'great', 'student'], ['she', 'is', 'a', 'very', 'very', 'exceptionally', 'good', 'student']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can compare two lists, with a function like this one. The way it works is it loops through your shorter list, and every time it finds the next word in the long list, cuts off the first part of the longer list at that point. If it can't find the word it returns false.</p>
<pre><code>def is_sub_sequence(long_list, short_list):
    for word in short_list:
        if word in long_list:
            i = long_list.index(word)
            long_list = long_list[i+1:]
        else:
            return False
    return True
</code></pre>
<p>Now you have a function to tell you if the list is the desired type, you can filter out all the lists you need from the 'list of lists' using a list comprehension like the following:</p>
<pre><code>a = [['she', 'is', 'a', 'student'],
 ['she', 'is', 'a', 'lawer'],
 ['she', 'is', 'a', 'great', 'student'],
 ['i', 'am', 'a', 'teacher'],
 ['she', 'is', 'a', 'very', 'very', 'exceptionally', 'good', 'student']]


b = ['she', 'is', 'student']

filtered = [x for x in a if is_sub_sequence(x,b)]
</code></pre>
<p>The list <code>filtered</code> will include only the lists of the desired type.</p>
</div>
<span class="comment-copy">What about if there are multiple instances that might be recognized.  How would  <code>['she', 'student', 'is', 'she', 'student']</code>, be recognized, for example?  Yes the words are present in order, but there is an overlap</span>
<span class="comment-copy">yes, as long as those words are found in the list in the same order, it is considered a match</span>
