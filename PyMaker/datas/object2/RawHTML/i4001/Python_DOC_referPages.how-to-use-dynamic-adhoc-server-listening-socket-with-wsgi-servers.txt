<div class="post-text" itemprop="text">
<p>I would like to deploy a Python app than can start an internal webserver on 127.0.0.1/::1 on whatever port is free at that time. It then should start a web browser with a URL pointing to the local adhoc web server.</p>
<p>My problem now is: are there any WSGI web servers that allow to dynamically bind them to a free port, and then make the port number choosen available to the program? Or can I create a listening socket myself and then hand it over to a WSGI server to use?</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/3/library/wsgiref.html#module-wsgiref.simple_server" rel="nofollow noreferrer"><code>wsgiref.simple_server</code></a>:</p>
<pre><code>import wsgiref.simple_server
your_app = wsgiref.simple_server.demo_app
server = wsgiref.simple_server.make_server('127.0.0.1', 0, your_app)
_, port = server.server_address
# start the browser, perhaps on a separate thread after a delay
server.serve_forever()
</code></pre>
<p>Using <a href="https://github.com/cherrypy/cheroot" rel="nofollow noreferrer">Cheroot</a>: there might be an easier way, but this kind of works:</p>
<pre><code>import threading, time, cheroot.wsgi
server = cheroot.wsgi.Server(('127.0.0.1', 0), your_app)
def get_port():
    while not server.ready:
        time.sleep(0.1)
    _, port = server.bind_addr
    # start the browser
threading.Thread(target=get_port).start()
server.start()
</code></pre>
</div>
<span class="comment-copy">So there isn't a universal API to get a webserver's port number. But for my purpose a <code>simple_server</code> should well suffice. Thank you very much for your help!</span>
<span class="comment-copy">My understanding is that it is sufficient to start the web browser just after creating the web server and before entering the server's serving loop: the listening socket has already been created, so if a web browser now connects, it won't receive a connection refused but will hold on line until (typical connect timeout &gt;30s or so) the server starts serving. I would suspect this to suffice, but only time will tell: <code>import webbrowser</code> and then <code>webbrowser.open_new_tab('http://{}:{}/'.format(webserver.server_address[0], webserver.server_address[1]))</code></span>
<span class="comment-copy">After some more field experience, sometimes the web browser comes up too quick, doesn't show any errors, but also no page. My remedy is now to start a daemon thread that tries to get a successful response from the webserver before handing off to the user's webbrowser. This ensures that the webserver is responsive. This seems to cover those rare corner cases.</span>
