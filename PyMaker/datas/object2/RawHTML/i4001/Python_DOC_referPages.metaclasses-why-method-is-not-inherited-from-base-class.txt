<div class="post-text" itemprop="text">
<p>I'm trying to understand <em>metaclass black magic</em> in Python. AFAIK, metaclasses can be used, for example, to ensure that some method is implemented in derived class, but I have a problem <em>grandchildrens</em>. It seems that I need to explicitly implement <em>all</em> required derived methods even if there is no reason(?) to do that.</p>
<p>Look at this:</p>
<pre><code>~ $ ipython
Python 3.6.5 (default, Apr 14 2018, 13:17:30) 
Type 'copyright', 'credits' or 'license' for more information
IPython 6.3.1 -- An enhanced Interactive Python. Type '?' for help.

In [1]: class Meta(type):
   ...:     def __new__(cls, name, bases, body):
   ...:         if 'some_method' not in body:
   ...:             raise AttributeError('some_method should be implemented')
   ...:         return super().__new__(cls, name, bases, body)
   ...: 
   ...: class Base(metaclass=Meta):
   ...:     def some_method(self):
   ...:         print('Yay')
   ...: 
   ...: class Derived(Base):
   ...:     pass
   ...: 
   ...: 
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
&lt;ipython-input-1-51c072cc7909&gt; in &lt;module&gt;()
      9         print('Yay')
     10 
---&gt; 11 class Derived(Base):
     12     pass

&lt;ipython-input-1-51c072cc7909&gt; in __new__(cls, name, bases, body)
      2     def __new__(cls, name, bases, body):
      3         if 'some_method' not in body:
----&gt; 4             raise AttributeError('some_method should be implemented')
      5         return super().__new__(cls, name, bases, body)
      6 

AttributeError: some_method should be implemented
</code></pre>
<p>As far I understand this should not happen, because <code>some_method</code> should be derived from <code>Base</code> class like here:</p>
<pre><code>In [3]: class Base:
   ...:     def some_method(self):
   ...:         print('Yay')
   ...: 
   ...: class Derived(Base):
   ...:     pass
   ...: 
   ...: 

In [4]: Derived().some_method()
Yay
</code></pre>
<p>This is expected? If yes, could you give me some hint how to <em>fix</em> this behaviour, so I wouldn't need to reimplement methods?</p>
</div>
<div class="post-text" itemprop="text">
<p>You seem to be trying to reinvent the wheel that is the <a href="https://docs.python.org/3/library/abc.html" rel="nofollow noreferrer"><code>abc</code></a> module and its <code>@abstractmethod</code> decorator. I'm not sure why you want to do that, but if you do, you should look at <a href="https://github.com/python/cpython/blob/3.6/Lib/abc.py#L132" rel="nofollow noreferrer">its source</a> (which is linked from the docs).</p>
<p>Your solution checks that the required name is implemented in the body of the class. That won't be true for inherited methods, but you seem to know that, so I won't explain. What you want to know is: what can you do instead? You need to check for inherited methods explicitly.</p>
<p>The way <code>abc</code> does it is pretty simple: before checking whether all abstract methods are implemented, it calls <code>getattr</code> on each <code>base</code>. (The best way to simulate what <code>getattr</code> will do on the class is to call <code>getattr</code>, after all.) Anything that's found there doesn't need to appear in the body.</p>
<p>Your use case—with a static single required method instead of a dynamic set of methods that have to be harvested from the output of a decorator—is even simpler:</p>
<pre><code>if (not any(hasattr(base, 'some_method') for base in bases)
    and 'some_method' not in body):
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>body</code> contains what is defined in the class you're defining. In your case, <code>some_method</code> isn't defined in <code>Derived</code>, it doesn't exist in it.</p>
<p>When you use <code>Derived().some_method()</code> (or even <code>Derived.some_method</code>), it will perform a lookup. It will not find it in Derived, but then it will try the parent classes, aka the bases, using the MRO (Method Resolution Order).</p>
<p>See the params in <code>def __new__(cls, name, bases, body):</code>, the bases are separate from <code>body</code> which is what you defined in your class, before MRO kicks in.</p>
</div>
<div class="post-text" itemprop="text">
<p>Inheritance isn't something that injects a definition into a class. Rather, it allows the <em>lookup</em> for an attribute to proceed beyond the immediate class if it is not defined locally.</p>
<p>In the absence of your metaclass, a call to <code>Defined().some_method()</code> proceeds roughly as follows:</p>
<ol>
<li>An instance of <code>Defined</code> is created.</li>
<li>An attribute named <code>some_method</code> is looked for that instance's <code>__dict__</code> attribute, and is not found.</li>
<li><code>some_method</code> is looked for in <code>Derived.__dict__</code> and not found.</li>
<li><code>some_method</code> is searched for in the <code>__dict__</code> attributes of the classes in <code>Derived</code>'s based classes, starting with <code>Base</code>.</li>
<li><code>Base.__dict__['some_method']</code> is found, and its value is called
  with the instance of <code>Derived</code> as its implicit first argument.</li>
</ol>
<p><em>With</em> your metaclass, <code>Derived</code> is created with the same metaclass used by its base class, meaning <code>Meta.__new__</code> (not <code>type.__new__</code>) is used to create <code>Derived</code> . Since <code>some_method</code> is not in the body of the class statement, it does not appear in the <code>dict</code> object passed to <code>Meta.__new__</code>, resulting in the <code>AttributeError</code> being raised. (Note that you should be raising <code>NotImplemented</code>, not <code>AttributeError</code>, as you aren't attempting to access any particular attribute yet.)</p>
</div>
<span class="comment-copy">It seems like you're just trying to reproduce what <a href="https://docs.python.org/3/library/abc.html" rel="nofollow noreferrer"><code>ABCMeta</code> and <code>@abstractmethod</code></a> already solve (and solve more nicely), so… why not just use them?</span>
<span class="comment-copy">You can also look at <a href="https://github.com/python/cpython/blob/3.6/Lib/abc.py#L132" rel="nofollow noreferrer">the source for <code>abc.py</code></a> even if you don't want to use it. Notice that it solves the problem of "how do I do what <code>getattr</code> does" by just calling <code>getattr</code> on the bases.</span>
<span class="comment-copy">@babygame0ver What are you talking about? <code>Derived()</code> <i>does</i> create an instance of the <code>Derived</code> class.</span>
<span class="comment-copy">The fact that <code>Meta</code> appears to duplicate <code>ABCMeta</code> is somewhat beside the point, which is why <code>Derived</code> does not appear to inherit <code>some_method</code> from its parent.</span>
<span class="comment-copy">@chepner I don't think it's beside the point at all, because it's a pretty solid hint at where you can find a good answer to the question. I wrote an answer explaining it, but I think the fact that the stdlib does this as the official solution to this problem is far more useful and authoritative than the fact that some guy on the internet (even me) says it works.</span>
<span class="comment-copy">your sample code doesn't work for grand-grand-children</span>
<span class="comment-copy">@λuser <a href="https://repl.it/repls/WorthyOtherTrust" rel="nofollow noreferrer">Yes it does.</a> The parent class is already constructed. When you call <code>getattr</code> on it, you can see its parent's attributes, including methods, and its' grandparents', and so on.</span>
<span class="comment-copy">@abarnert I didn't know about this module! It does exactly what I wanted to achieve, thank you.</span>
<span class="comment-copy">This explains why the non-metaclass example works, but it only briefly covers why the metaclass example doesn't work, and then doesn't give any hint to how to solve it, which is what the OP was (I think) actually looking for.</span>
<span class="comment-copy">That said, it does explain the non-metaclass example very nicely (concise, but still complete in all relevant details, and without cheating too much on the irrelevant ones), so I think it's still worth having as an answer.</span>
<span class="comment-copy">@chepner so what should I do to make my example work? Should I implement <code>Derived.__new__()</code>? How?</span>
<span class="comment-copy">No, you should take a look at the <code>abc</code> module to see how it is implement. That said, <code>Meta.__new__</code> should look at each class in <code>bases</code> as well to see if <i>they</i> implement <code>some_method</code>, if <code>some_method</code> is not defined locally. (And that check needs to be recursive, because none of <i>them</i> may have defined <code>some_method</code> either, but relied on an inherited definition.)</span>
