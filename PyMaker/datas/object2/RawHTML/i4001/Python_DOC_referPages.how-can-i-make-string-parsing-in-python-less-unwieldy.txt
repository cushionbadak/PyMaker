<div class="post-text" itemprop="text">
<p>Apologies if the question title is too vague - would welcome edits.</p>
<p>I'm trying to parse XML using BeautifulSoup, but because each function call could return None, I have to parse a single element over a number of lines. This gets unwieldy very quickly:</p>
<pre><code>books_count = result.books_count

if not books_count:
    return None

books_count = books_count.string

if not books_count:
    return None

books_count = int(books_count)

if not books_count:
    return None
</code></pre>
<p>Doing the same thing in Swift, a language I'm far more familiar with, it's a lot cleaner:</p>
<pre><code>guard let booksCountString = result.booksCount?.string,
    let booksCountInt = Int(booksCountString) else {
    return nil
}
</code></pre>
<p>Is there a similar way I could do this in Python? I want to avoid using try/catch as causing it to potentially have a runtime error constantly in my code doesn't feel like good practice.</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe in a for loop?</p>
<p><code>example = [result.books_count, books_count.string, int(books_count)]</code></p>
<p><code>for n in example:
 if not n : return None
</code></p>
<p>Just tested it and the for loop works fine as long as <code>result.books_count, books_count.string, int(books_count)</code> arenÂ´t raising any errors</p>
</div>
<div class="post-text" itemprop="text">
<p>If you represent your sequence of <code>None</code> checks using <strong>lambda</strong>s, like so:</p>
<pre><code>check_1 = lambda r: r.books_count
check_2 = lambda r: r.string
check_3 = lambda r: int(r)
</code></pre>
<p>Then we can generalize a solution for any number of those checks. This function is similar (in a way) to how <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer">functools.reduce</a> works:</p>
<pre><code>def my_reduce(fs, arg, stop_value=None):
    res = arg
    for f in fs:
        res = f(res)
        if res == stop_value:
            return stop_value
    return res
</code></pre>
<p>Then use it like this:</p>
<pre><code>my_reduce([check_1, check_2, check_3], good_value)
Out[1]: 42

my_reduce([check_1, check_2, check_3], bad_value) is None
Out[2]: True
</code></pre>
</div>
<span class="comment-copy">Why do you think using try/catch <i>doesn't feel like good practice</i>?</span>
<span class="comment-copy">For Python, it is "easier to ask for forgiveness than permission (EAFP)". Python EAFP coding style assumes the existence of certain attributes or elements and catches exceptions if the assumption proves false. So it is perfectly okay to use <code>try</code> ... <code>catch</code>. This is the technique contrasts with the "Look before you leap" (LBYL) style common to many other languages. If you still don't feel conformable for such practice, maybe you should provide more details of your code for better understanding the context of what you are trying to do.</span>
<span class="comment-copy"><i>causing it to potentially have a runtime error constantly</i> - you can avoid that catching only the required exceptions. For instance, <code>except (AttributeError, ValueError)</code>.</span>
<span class="comment-copy">I think you are seeking to make parsing <i>wieldier</i> (or more wieldy) although neither of those words occur much in most English dialects; I think most native speakers would ask how to make parsing <i>less unwieldy</i>.</span>
