<div class="post-text" itemprop="text">
<p>I would like to convert a singleton-object programmatically into a Python module so that I can use the methods of this singleton-object directly by importing them via the module instead of accessing them as object attributes. By "programmatically" I mean that I do not want to have to copy-paste the class methods explicitly into a module file. I need some sort of a workaround that allows me to import the object methods into to global scope of another module.</p>
<p>I would really appreciate if someone could help me on this one.</p>
<p>Here is a basic example that should illustrate my problem:</p>
<h3>mymodule.py</h3>
<pre><code>class MyClass:
"""This is my custom class"""
    def my_method(self):
        return "myValue"

singleton = MyClass()
</code></pre>
<h3>main_as_is.py</h3>
<pre><code>from mymodule import MyClass

myobject = MyClass()
print(myobject.my_method())
</code></pre>
<h3>main_to_be.py</h3>
<pre><code>from mymodule import my_method # or from mymodule.singleton import my_method

print(my_method())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the same strategy that the standard <a href="https://docs.python.org/3/library/random.html" rel="nofollow noreferrer"><code>random</code></a> module uses. All the functions in that module are actually methods of a "private" instance of the <code>Random</code> class. That's convenient for most common uses of the module, although sometimes it's useful to create your own instances of <code>Random</code> so that you can have multiple independent random streams.</p>
<p>I've adapted your code to illustrate that technique. I named the class and its instance with a single leading underscore, since that's <a href="https://docs.python.org/3/tutorial/classes.html#private-variables" rel="nofollow noreferrer">the usual convention in Python to signify a private name</a>, but bear in mind it's simply a convention, Python doesn't do anything to enforce this privacy. </p>
<h3>mymodule.py</h3>
<pre><code>class _MyClass:
    """ This is my custom class """
    def my_method(self):
        return "myValue"

_myclass = _MyClass()
my_method = _myclass.my_method
</code></pre>
<h3>main_to_be.py</h3>
<pre><code>from mymodule import my_method

print(my_method())       
</code></pre>
<p><strong>output</strong> </p>
<pre><code>myValue
</code></pre>
<p>BTW, the <code>from mymodule import method1, method2</code> syntax is ok if you only import a small number of names, or it's clear from the name which module it's from (like math module functions and constants), and you don't import from many modules. Otherwise it's better to use this sort of syntax </p>
<pre><code>import mymodule as mm
# Call a method from the module
mm.method1()
</code></pre>
<p>That way it's obvious which names are local, and which ones are imported and where they're imported from. Sure, it's a little more typing, but it makes the code a <em>whole</em> lot more readable. And it eliminates the possibility of name collisions.</p>
<p>FWIW, here's a way to automate adding all of the <code>_myclass</code> methods without explicitly listing them (but remember "explicit is better than implicit"). At the end of "mymodule.py", in place of <code>my_method = _myclass.my_method</code>, add this: </p>
<pre><code>globals().update({k: getattr(_myclass, k) for k in _MyClass.__dict__ 
    if not k.startswith('__')})
</code></pre>
<p>I'm not comfortable with recommending this, since it directly injects items into the <code>globals()</code> dict. Note that that code will add all class attributes, not just methods.</p>
<hr/>
<p>In your question you talk about singleton objects. We don't normally use singletons in Python, and many programmers in various OOP languages consider them to be an anti-pattern. See <a href="https://stackoverflow.com/q/12755539/4014959">https://stackoverflow.com/questions/12755539/why-is-singleton-considered-an-anti-pattern</a> for details. For this application there is absolutely <em>no need at all</em> to use a singleton. If you only want a single instance of <code>_MyClass</code> then simply don't create another instance of it, just use the instance that <code>mymodule</code> creates for you. But if your boss insists that you <em>must</em> use a singleton, please see the example code <a href="https://stackoverflow.com/q/17237857/4014959">here</a>.</p>
</div>
<span class="comment-copy">Give us a stripped-down example of two dozen lines or so that we know exactly what you are trying to achieve.</span>
<span class="comment-copy">Where's the benefit of doing this? Instead of writing <code>someobj.thing</code> you'd write <code>somemodule.thing</code>. Unless of course you intend to use a "star" import equivalent, but that's generally not a Good Idea. See <a href="https://stackoverflow.com/questions/2386714/why-is-import-bad">stackoverflow.com/questions/2386714/why-is-import-bad</a> and <a href="https://pythonconquerstheuniverse.wordpress.com/2011/03/28/why-import-star-is-a-bad-idea/" rel="nofollow noreferrer">pythonconquerstheuniverse.wordpress.com/2011/03/28/â€¦</a></span>
<span class="comment-copy">@PM2Ring: My boss prefers procedural style programming so he asked me to do this. In fact he would like to import the methods explicitly like "from mymodule import method1, method2" ... The benefit would be that you don't have to initialize an object and that you don't have to type "someobj" each time you use a method ;)</span>
<span class="comment-copy">You might need a new boss :P</span>
<span class="comment-copy">What does your boss mean by "procedural style programming"? If he's opposed to OOP, I doubt he'd be very happy with a Java-style Singleton Design Pattern, which is the exact kind of thing most anti-OOP people hate. Or, if he means "not functional like Scheme" (or Haskell), using the class instead of a closure is just going to look like pointless obfuscation to him.</span>
<span class="comment-copy">Many thanks. The problem with this approach is that I have to assign all the methods from the class one-by-one to some local variable and thus I would still need to copy paste everything. I would like to avoid code duplication.</span>
<span class="comment-copy">@Jerry Do you mean you want to avoid in "mymodule.py" having to do <code>my_method = _myclass.my_method</code> for each method of <code>_myclass</code>?</span>
<span class="comment-copy">@Jerry If so, there's a way to do that, but it's a bit ugly. FWIW, the random module does explicit one-by-one assignment, see the end of the module's <a href="https://github.com/python/cpython/blob/3.6/Lib/random.py" rel="nofollow noreferrer">source code</a>.</span>
<span class="comment-copy">I agree with the fact that there is not much to gain here and that things should not be overcomplicated with some controversial Design Pattern ;) I think though that there should be a simple way to include some functionalities in an exclusively procedural module or package that were initially implemented in a OOP style without forcing the use of OOP concepts.</span>
<span class="comment-copy">I guess I should not have used the term "singleton" in my problem description. In the end the only thing that this approach has in common with the Singleton Pattern is that it uses a single instance of a class to serve a specific purpose. The key difference is that this instance would not be accessed explicitly throughout the project (which I guess is what makes the Singleton Pattern a Design Pattern and which makes it prone to misuse) but it would be encapsulated inside a module.</span>
