<div class="post-text" itemprop="text">
<p>I stumbled upon a <a href="https://stackoverflow.com/questions/50382040/how-can-i-use-enumerate-to-count-backwards/" title="How can I use enumerate to count backwards?">question</a> yesterday that involved enumerating over an iterable type and yeilding descending indices accompanied by ascending items in the iterable.  </p>
<p>In:</p>
<pre><code>letters = ['a', 'b', 'c']
for i, letter in revenumerate(letters):
    print('{}, {}'.format(i, letter))
</code></pre>
<p>Out:</p>
<pre><code>2, a
1, b
0, c 
</code></pre>
<p>Instead of writing a quick and reliable answer applying built-in <code>reverse</code> twice, or simply <code>i = len(letters) - i - 1</code>, I decided to try create a child class of <code>enumerate</code> that redefines <code>__iter__</code> and <code>__next__</code> methods.</p>
<p>The code for my original working solution was as follows:</p>
<pre><code>class revenumerate(enumerate):
    def __init__(self, iterable, start=0):
        self._len = len(iterable)
        self._start = start
        if isinstance(iterable, dict):
            self._data = iterable.keys()
        else:
            self._data = iterable

    def __iter__(self):
        _i = self._len
        for _item in self._data:
            _i -= 1
            _ind = _i + self._start
            yield _ind, _item

    def __next__(self):
        _i, _item = super().__next__()
        _ind = self._len +  2 * self._start - _i - 1
        return _ind, _item
</code></pre>
<p>However, I now realize this code has redundancy as <code>enumerate.__iter__</code> appears to yield the result of <code>__next__</code>, makes sense.  After deleting the redefined <code>__iter__</code> I realized that <code>self._data</code> was not being used anywhere, so I removed the last four lines from <code>__init__</code> leaving me with the following code, which still provides the desired behavior.</p>
<pre><code>class revenumerate(enumerate):
    def __init__(self, iterable, start=0):
        self._len = len(iterable)
        self._start = start

    def __next__(self):
        _i, _item = super().__next__()
        _ind = self._len +  2 * self._start - _i - 1
        return _ind, _item
</code></pre>
<p>Now it appears that the iterable argument passed into <code>revenumerate</code> is not for anything except determining the integer <code>self._len</code>.</p>
<p><strong>My question is</strong> - <em>where is <code>iterable</code> stored and how does <code>super().__next__</code> access it?</em> </p>
<p>A quick look at <code>builtins.py</code> with the PyCharm debugger does not provide a lot of help in figuring this out (or so it seems to me at this stage), and I am not well traversed with the Python source code repository.  My guess is something to do with the <code>__new__</code> or <code>__init__</code> method of parent class <code>enumerate</code>, or it's parent <code>object</code>.  </p>
</div>
<div class="post-text" itemprop="text">
<p><code>builtins.py</code> is a lie. PyCharm made it up. If you want to look at the real source code for the <code>builtins</code> module, that's <a href="https://github.com/python/cpython/blob/v3.6.5/Python/bltinmodule.c" rel="nofollow noreferrer"><code>Python/bltinmodule.c</code></a> in the Python Git repository. <code>enumerate</code> itself is implemented in <a href="https://github.com/python/cpython/blob/v3.6.5/Objects/enumobject.c" rel="nofollow noreferrer"><code>Objects/enumobject.c</code></a>.</p>
<p><code>enumerate</code> iterators store an iterator over their underlying object in a C-level <code>en_sit</code> struct slot:</p>
<pre><code>typedef struct {
    PyObject_HEAD
    Py_ssize_t en_index;           /* current index of enumeration */
    PyObject* en_sit;          /* secondary iterator of enumeration */
    PyObject* en_result;           /* result tuple  */
    PyObject* en_longindex;        /* index for sequences &gt;= PY_SSIZE_T_MAX */
} enumobject;
</code></pre>
<p>set in <code>enumerate.__new__</code>:</p>
<pre><code>static PyObject *
enum_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    ...
    en-&gt;en_sit = PyObject_GetIter(seq);
</code></pre>
<p>The fact that it's set in <code>__new__</code> is why it still worked even though you forgot to call <code>super().__init__</code>.</p>
<hr/>
<p>Subclassing <code>enumerate</code> for this doesn't make a lot of sense. <code>enumerate</code> is only documented as a callable; the fact that it's a class and supports subclassing is an implementation detail. Also, you're not getting a lot of use out of <code>enumerate</code>, and the relationship between your iterators and <code>enumerate</code> iterators doesn't really sound like "is-a". Implementing your functionality as a generator, like zvone did, is cleaner and clearer.</p>
</div>
<div class="post-text" itemprop="text">
<p>What <code>enumerate</code> does is more-or-less* this:</p>
<pre><code>def enumerate(iterable):
    counter = 0
    for item in iterable:
        counter += 1
        yield counter, item
</code></pre>
<p>One thing you can notice is that it does not know how long the iterable is. It can even be infinitely long, but enumerate will still work.</p>
<p>The problem with <code>revenumerate</code> is that you first have to count how many items there are before being able to yield the first one, so you actually have to create a list of all enumerated items and then yield them backwards (at least if you want your <code>revenumerate</code> to work with any iterable, like <code>enumerate</code>).</p>
<p>Once you accept that limitation as inavoidable, the rest is simple:</p>
<pre><code>def revenumerate(iterable):
    all_items = list(iterable)
    counter = len(all_items)
    for item in reversed(all_items):
        counter -= 1
        yield counter, item
</code></pre>
<hr/>
<p>(*) <code>enumerate</code> is actually a class, but this is its behaviour. See <a href="https://stackoverflow.com/a/50401798/389289">my other answer</a> about how that works and what <code>__next__</code> does.</p>
</div>
<div class="post-text" itemprop="text">
<p>Others have answered your specific question about how your code works so here's another way to implement a reverse enumerator using <code>zip()</code>:</p>
<pre><code>def revenumerate(iterable, start=None):
    if start is None:
        start = len(iterable) - 1
    return zip(range(start, -1, -1), iterable)

&gt;&gt;&gt; revenumerate('abcdefg')
&lt;zip object at 0x7f9a5746ec48&gt;
&gt;&gt;&gt; list(revenumerate('abcdefg'))
[(6, 'a'), (5, 'b'), (4, 'c'), (3, 'd'), (2, 'e'), (1, 'f'), (0, 'g')]
&gt;&gt;&gt; list(revenumerate('abcdefg', 100))
[(100, 'a'), (99, 'b'), (98, 'c'), (97, 'd'), (96, 'e'), (95, 'f'), (94, 'g')]
</code></pre>
<p><code>revenumerate()</code> returns a <code>zip</code> object that is very similar to the <code>enumerate</code> object returned by <code>enumerate()</code>.</p>
<p>By default the items will be enumerated starting at the length of the iterable less one, which requires that the length be finite. You can supply a start value from which to count down which would be useful if you just wanted to start counting from an arbitrary value, or to sort of handle infinite iterables.</p>
<pre><code>&gt;&gt;&gt; from itertools import count
&gt;&gt;&gt; g = revenumerate(count(), 1000)
&gt;&gt;&gt; next(g)
(1000, 0)
&gt;&gt;&gt; next(g)
(999, 1)
&gt;&gt;&gt; next(g)
(998, 2)
&gt;&gt;&gt; next(g)
(997, 3)
&gt;&gt;&gt; next(g)
(996, 4)
</code></pre>
<p>If you tried to work on an infinite iterable without specifying the start value:</p>
<pre><code>&gt;&gt;&gt;&gt; revenumerate(count())
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 3, in revenumerate
TypeError: object of type 'itertools.count' has no len()
</code></pre>
<p>Which prevents the interpreter entering an infinite loop. You could handle the exception and raise one of your own if that suited your application.</p>
</div>
<div class="post-text" itemprop="text">
<p>In my <a href="https://stackoverflow.com/a/50401523/389289">previous answer</a> I wrote how I would do it, but here are some answers to what was actually asked about <code>__iter__</code> and <code>__next__</code>...</p>
<h2>Iterable</h2>
<p>In order for an object to be iterable, it has to implement method <code>__iter__</code>, which has to return an iterator.</p>
<p>Here are some simple examples:</p>
<pre><code>class A:
    def __iter__(self):
        return iter([1, 2, 3])

class B:
    def __iter__(self):
        yield 'a'
        yield 'b'
</code></pre>
<p>These can be iterated:</p>
<pre><code>&gt;&gt;&gt; A().__iter__()
&lt;list_iterator object at 0x00000000029EFD30&gt;

&gt;&gt;&gt; iter(A())  # calls A().__iter__()
&lt;list_iterator object at 0x00000000029EFF28&gt;

&gt;&gt;&gt; list(A())  # calls iter(A) and iterates over it
[1, 2, 3]

&gt;&gt;&gt; list(B())  # calls iter(B) and iterates over it
['a', 'b']
</code></pre>
<h2>Iterator</h2>
<p>The object returned from <code>__iter__</code> is an iterator. An iterator must implement the <code>__next__</code> method.</p>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; it = iter(B())  # iterator

&gt;&gt;&gt; it.__next__()
'a'

&gt;&gt;&gt; next(it)  # calls it.__next__()
'b'

&gt;&gt;&gt; next(it)  # raises StopIteration because there is nothing more
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration
</code></pre>
<h2>Custom iterator</h2>
<pre><code>class MyIterator:
    def __init__(self):
        self.value = 5
    def __next__(self):
        if self.value &gt; 0:
            self.value -= 1
            return self.value
        else:
            raise StopIteration()

class MyIterable:
    def __iter__(self):
        return MyIterator()

&gt;&gt;&gt; list(MyIterable())
[4, 3, 2, 1, 0]
</code></pre>
<p><strong>EDIT:</strong> As others mentioned in the comments, an iterator should always implement <code>__iter__</code> which returns <code>self</code> (as I did in the examples below). This requirement can be read in <a href="https://www.python.org/dev/peps/pep-0234/#id4" rel="nofollow noreferrer">PEP-0234</a> and in <a href="https://docs.python.org/3/library/stdtypes.html#iterator-types" rel="nofollow noreferrer">Python docs</a>:</p>
<blockquote>
<p>A class that wants to be an iterator should implement two methods: a
  <code>next()</code> method that behaves as described above, and an <code>__iter__()</code>
  method that returns <code>self</code>.</p>
</blockquote>
<h2>Iterable iterator</h2>
<p>An iterable iterator? Well if a class implements both <code>__iter__</code> and <code>__next__</code>, then it is both:</p>
<pre><code>class IterableIterator:
    def __init__(self):
        self.value = 11

    def __next__(self):
        if self.value &lt; 17:
            self.value += 1
            return self.value
        else:
            raise StopIteration()

    def __iter__(self):
        return self

&gt;&gt;&gt; list(IterableIterator())
[12, 13, 14, 15, 16, 17]
</code></pre>
<h2><code>enumerate</code></h2>
<p><code>enumerate</code> actually does something like this:</p>
<pre><code>class enumerate:
    def __init__(self, iterable, start=0):
        self.iterator = iter(iterable)
        self.n = start - 1

    def __iter__(self):
        return self

    def __next__(self):
        self.n += 1
        next_item = next(self.iterator)
        return self.n, next_item
</code></pre>
<p>So, to answer your question, in your <code>super().__next__()</code>, you are calling this <code>__next__</code> here, which uses the iterator which it stored in the constructor.</p>
</div>
<span class="comment-copy">Thank you for the concise explanation and direction.  I am not familiar with the Python source code repository on Github, so this is exactly what I was after.</span>
<span class="comment-copy">Thanks for the input!  I asked this question more because I didn't understand why my code worked and didn't know my way around the Python source code on Github, but I really appreciate seeing new and unique approaches to the problem!</span>
<span class="comment-copy">It's worth noting that all iterators are supposed to be iterables too, they should always have an <code>__iter__</code> method that returns <code>self</code>. Without that behavior, you wouldn't be able use an iterator you already had created in most places (not in a loop, nor by passing it to a function or class constructor that expects an iterable, like <code>list</code>). Those places all call <code>iter</code> on the object they're iterating on, so you need an <code>__iter__</code> method, even if it's a trivial one.</span>
<span class="comment-copy">Iterators are <a href="https://docs.python.org/3/library/stdtypes.html#iterator.__iter__" rel="nofollow noreferrer">supposed to</a> have an <code>__iter__</code> that returns <code>self</code>, and any iterator that doesn't do so is violating the iterator protocol. This usually isn't checked, which results in broken iterators that mostly work until they end up in some code that actually depends on this part of the iterator protocol.</span>
<span class="comment-copy">@user2357112 Thanks, I added that to the answer.</span>
