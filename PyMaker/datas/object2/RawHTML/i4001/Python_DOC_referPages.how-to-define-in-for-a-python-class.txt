<div class="post-text" itemprop="text">
<p>If I had a list of some python class that had a string field, is there a way to compare a string to a list of objects of that class using <code>in</code>? I was curious if there's a way to do something like this:</p>
<pre><code>class Foo:
    def __init__(self, s):
        self.s = s

bar = Foo('test')
ls = [bar]

if 'test' in ls:
    print("Yay!")
</code></pre>
<p>by modifying the <code>__eq__</code> method, or maybe even there's an <code>__in__</code> method I'm unaware of</p>
</div>
<div class="post-text" itemprop="text">
<p>You intuition about defining a custom <code>__eq__</code> was right. You can achieve the following, which seems to be your objective here:</p>
<pre><code>&gt;&gt;&gt; class Foo:
...     def __init__(self, s):
...         self.s = s
...     def __eq__(self, other):
...         if isinstance(other, Foo):
...             return self.s == other.s
...         else:
...             return self.s == other
...
&gt;&gt;&gt;
&gt;&gt;&gt; bar = Foo('bar')
&gt;&gt;&gt; l = [bar]
&gt;&gt;&gt; bar in l
True
&gt;&gt;&gt; 'bar' in l
True
&gt;&gt;&gt; Foo('baz') in l
False
&gt;&gt;&gt; 'baz' in l
False
</code></pre>
<p>I also want to point out that there is the <a href="https://docs.python.org/3/reference/datamodel.html#object.__contains__" rel="nofollow noreferrer"><code>__contains__</code></a> method, which allow you to define the membership operator's behavior (<code>in</code>). However this is a method on the container type, so here defining this method for your class <code>Foo</code> wouldn't do anything, since the <code>in</code> is applied to the list, and not its individual items.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your guess about modifying the <code>__eq__</code> is correct. It's definitely one way to do this. You just need to check the value of <code>__eq__</code>'s argument with the respective attribute of your object. So as a very simple way you can implement something like following:</p>
<pre><code>In [1]: class Foo:
   ...:     def __init__(self, s):
   ...:         self.s = s
   ...:
   ...:     def __eq__(self, value):
   ...:         return self.s == value
   ...:     

In [2]: bar = Foo('test')
   ...: ls = [bar]
   ...: 

In [3]: 'test' in ls
Out[3]: True
</code></pre>
<p>Note that this <code>__eq__</code> method doesn't have any restrictions like type checking or some other error handling. If you think that they're needed in your case you can consider using <code>try-excep</code> and or other condition checking as well.</p>
<p>Demo:</p>
<pre><code>In [9]: foo = Foo('test')

In [10]: bar = Foo('test')

In [11]: ls = ['test']

In [12]: bar in ls
Out[12]: True

In [13]: ls = [bar]

In [14]: foo in ls
Out[14]: True
</code></pre>
</div>
<span class="comment-copy">The isinstance() method is key here, I didn't know you could do that! My class works like a dream now</span>
<span class="comment-copy">Glad to help! Note that <code>isinstance(bar, Foo)</code> is more robust than <code>bar.__class__ == Foo</code>, because it also works for subclasses of <code>Foo</code>.</span>
<span class="comment-copy">I don't think if there's a need to use <code>isinstance(bar, Foo)</code> because once the equation check for one side of the equation fails Python will call the other side's <code>__eq__</code>.</span>
