<div class="post-text" itemprop="text">
<p>I've got an unusual question for python. I'm using the <code>multiprocessing</code> library to map a function <code>f((dynamic1, dynamic2), fix1, fix2)</code>. </p>
<pre><code>import multiprocessing as mp

fix1 = 4
fix2 = 6

# Numer of cores to use
N = 6

dynamic_duos = [(a, b) for a in range(5) for b in range(10)]

with mp.Pool(processes = N) as p:
    p.starmap(f, [(dyn, fix1, fix2) for dyn in dynamic_duos])
</code></pre>
<p>I would like to control dynamically the number of active processes because the function is actually pumping sometimes a LOT of RAM. The idea would be to check at every iteration (i.e. before any call of the function <code>f</code>) if the <code>sum(dyn)</code> is inferior to a threshold and if the amount of RAM is above a threshold. If the conditions are matched, then a new process can start and compute the function.</p>
<p>An additional condition would be the maximum number of processes: the number of cores on the PC.</p>
<p>Thanks for the help :)</p>
<p><strong><em>Edit: Details on the reasons.</em></strong></p>
<p>Some of the combinations of parameters will have a high RAM consumption (up to 80 Gb on 1 process). I know more or less which ones will use a lot of RAM, and when the program encounters them, I would like to wait for the other process to end, start in single process this high RAM consumption combination, and then resume the computation with more processes on the rest of the combination to map.</p>
<p><strong>Edit on my try based on the answer below:</strong></p>
<p>It doesn't work, but it doesn't raise an error. It just completes the program.</p>
<pre><code># Imports
import itertools
import concurrent.futures

# Parameters
N = int(input("Number of CPUs to use: "))
t0 = 0
tf = 200
s_step = 0.05
max_s = None
folder = "test"

possible_dynamics = [My_class(x) for x in [20, 30, 40, 50, 60]]
dynamics_to_compute = [list(x) for x in itertools.combinations_with_replacement(possible_dynamics , 2)] + [list(x) for x in itertools.combinations_with_replacement(possible_dynamics , 3)]

function_inputs = [(dyn , t0, tf, s_step, max_s, folder) for dyn in dynamics_to_compute]

# -----------
# Computation
# -----------
start = time.time()

# Pool creation and computation
futures = []
pool = concurrent.futures.ProcessPoolExecutor(max_workers = N)

for Obj, t0, tf, s_step, max_s, folder in function_inputs:
    if large_memory(Obj, s_step, max_s):
        concurrent.futures.wait(futures)  # wait for all pending tasks
        large_future = pool.submit(compute, Obj, t0, tf, 
                             s_step, max_s, folder)
        large_future.result()  # wait for large computation to finish
    else:
        future = pool.submit(compute, Obj, t0, tf, 
                             s_step, max_s, folder)
        futures.append(future)

end = time.time()
if round(end-start, 3) &lt; 60:
    print ("Complete - Elapsed time: {} s".format(round(end-start,3)))
else:
    print ("Complete - Elapsed time: {} mn and {} s".format(int((end-start)//60), round((end-start)%60,3)))

os.system("pause")
</code></pre>
<p>This is still a simplified example of my code, but the idea is here. It runs in less than 0.2 s, which means he actually never called the function <code>compute</code>.</p>
<p>N.B: <code>Obj</code> is not the actual variable name.</p>
</div>
<div class="post-text" itemprop="text">
<p>To achieve so you need to give up on the use of <code>map</code> to gain more control on the execution flow of your tasks.</p>
<p>This code implements the algorithm you described at the end of your question. I'd recommend using <code>concurrent.futures</code> library as it expose a more neat set of APIs.</p>
<pre><code>import concurrent.futures

pool = concurrent.futures.ProcessPoolExecutor(max_workers=6)

futures = []

for dyn, fix1, fix2 in dynamic_duos:
    if large_memory(dyn, fix1, fix2):
        concurrent.futures.wait(futures)  # wait for all pending tasks
        large_future = pool.submit(f, dyn, fix1, fix2)
        large_future.result()  # wait for large computation to finish
    else:
        future = pool.submit(f, dyn, fix1, fix2)
        futures.append(future)
</code></pre>
</div>
<span class="comment-copy">Thanks for the reply. I do not mind getting rid of <code>map</code> however I would just like a quick clarification on the <code>futures</code> list. What is actually future?. My function actually DO NOT return anything but creates pickle file in a directory (directly implemented at the end of the function <code>f</code>). If I get the code above correctly, <code>pool.submit()</code> will ask the pool of worker to treat one input. But I do not really get what the futures list is doing here.</span>
<span class="comment-copy">A <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future" rel="nofollow noreferrer"><code>future</code></a> is a handler representing the asynchronous execution of your function. It's a sort of <code>task</code> object and you can use it for retrieving the results of the computation or for simply waiting its conclusion. The list of <code>futures</code> allows you to wait for all the other running task to be completed (via the <code>wait</code> function) before executing the large one(s).</span>
<span class="comment-copy">Just to be clear: every time you start a small memory task, it is appended to the list <code>futures</code>. What is appended is the handler thus <code>concurrent.futures.wait(futures)</code> waits for all the handler in <code>futures</code> that are not finished yet to finish their tasks. Correct? Thus, in the end, the list <code>futures</code> will have every one of the small memory task represented as a handler? And the line <code>large_future.result()</code> waits for the large one started just before to end before going to the next iteration of the <code>for</code> loop. If that is correct, then I get it :)</span>
<span class="comment-copy">Additional question: on a PC with 8 physical core and 16 logical cores, my guess is that with multiprocessing, logical cores are poorly used because of how the OS schedules the CPU usage. i.e. with this code, the <code>max_workers</code> should be 8 right?</span>
<span class="comment-copy">And last issue, I couldn't get it to run. The function <code>f</code> is never called. See EDIT for more detail on the code... Thanks for the help :)</span>
