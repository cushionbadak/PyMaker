<div class="post-text" itemprop="text">
<p>Im trying to code the optimal version of the counting version algorithm. 
I'm having this error in line 84: int object is not iterable.</p>
<p>But I can't figure out why i'm having this issue. </p>
<p>Function mergesort: Merge a list of number in increasing order (this one works when I use it alone)</p>
<p>Function merge_and_count: Take two merged arrays in input, and count the number of elements from the left array that are bigger then the elements of the right array</p>
<p>Function sort_and_count: The function that will give the number of inversions (it also return a list because it allows me to use recursivity)</p>
<p>Here is the code:</p>
<pre><code>def mergesort(list):
    """Fonction qui classe les nombres de la liste par ordre croissant.
        Celle la fonctionne bien et renvoie une liste"""
    taille = len(list)
    liste_1_temp = []
    liste_2_temp = []


    if len(list) &gt; 1:

        for i in range(0,(taille//2)):
            liste_1_temp.append(list[i])

        for i in range((taille//2),taille):
            liste_2_temp.append(list[i])
        mergesort(liste_1_temp)
        mergesort(liste_2_temp)

        i = 0
        j = 0
        k = 0
        while i &lt; len(liste_1_temp) and j &lt; len(liste_2_temp):
            if liste_1_temp[i] &lt; liste_2_temp[j]:
                list[k] = liste_1_temp[i]
                i+=1
                k+=1
            else:
                list[k] = liste_2_temp[j]
                j += 1
                k+=1
        while (i &lt; len(liste_1_temp)):
            list[k] = liste_1_temp[i]
            i+=1
            k+=1

        while (j &lt; len(liste_2_temp)):
            list[k] = liste_2_temp[j]
            j+=1
            k+=1
    liste_finale = list
    return liste_finale



def merge_and_count(A,B):
    """Fonction qui doit renvoyer """

    i = 0
    j = 0
    count = 0
    C = []

    while (i &lt; len(A)):
        if A[i] &gt; B[j]:
            C.append(B[j])
            count += (len(A)-i)
            i = 0
            j += 1
        else:
            C.append(A[i])
            i += 1
    return count,C



def sort_and_count(L):

    i = 0
    A = []
    B = []

    if len(L) == 1:
        return 0

    else:
        size = len(L)
        size2 = len(L) // 2

        for i in range(0, size2):
            A.append(L[i])
        for i in range(size2,size-1):
            B.append(L[i])

        (rA,A) = sort_and_count(A)
        (rB,B) = sort_and_count(B)
        (r,L) = merge_and_count(mergesort(A),mergesort(B))

        return ((rA+rB+r),L)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You forgot to return a pair from sort_and_count here:</p>
<pre><code>def sort_and_count(L):

    i = 0
    A = []
    B = []

    if len(L) == 1:
        return 0  # &lt;-- You forgot to return the list as second element
    ...
    ...
</code></pre>
<p>Since these lines </p>
<pre><code>    (rA,A) = sort_and_count(A)
    (rB,B) = sort_and_count(B)
</code></pre>
<p>expect an iterable on the right hand side of the assignment operator and get only an integer, you get <strong>int object is not iterable</strong> error.</p>
</div>
<span class="comment-copy">Consider also looking at <a href="https://docs.python.org/3/library/heapq.html#heapq.merge" rel="nofollow noreferrer">heapq.merge()</a> standard library function.</span>
<span class="comment-copy">Thanks but I think that the problem is not in my merge function</span>
<span class="comment-copy">Oh youâ€™re right! So it should be return 0,L right ?</span>
