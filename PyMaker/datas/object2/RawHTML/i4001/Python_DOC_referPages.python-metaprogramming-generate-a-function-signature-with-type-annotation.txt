<div class="post-text" itemprop="text">
<p>I am working within a Python web framework that uses Python 3 type annotations for validation and dependency injection.</p>
<p>So I am looking for a way to generate functions with type annotations from a parameters given to the generating function:</p>
<pre><code>def gen_fn(args: Dict[str, Any]) -&gt; Callable:
    def new_fn(???):
        pass
    return new_fn
</code></pre>
<p>so that</p>
<pre><code>inspect.signature(gen_fn({'a': int}))
</code></pre>
<p>will return</p>
<pre><code>&lt;Signature (a:int)&gt;
</code></pre>
<p>Is there something I cam put instead of the <code>???</code> that will do the thing I need.</p>
<p>I also looked at <code>Signature.replace()</code> in the <a href="https://docs.python.org/3/library/inspect.html#inspect.Signature.replace" rel="nofollow noreferrer"><code>inspect</code></a> module, but did not find a way to attach the new signature to a new or existing function.</p>
<p>I am hesitant to use <a href="https://docs.python.org/3/library/ast.html" rel="nofollow noreferrer">ast</a> because:</p>
<blockquote>
<p>The abstract syntax itself might change with each Python release</p>
</blockquote>
<p>So my question is: <strong>What (if any) is a reasonable way to generate a function with Python 3 type annotation based on a <code>dict</code> passed to the generating function?</strong></p>
<hr/>
<p>Edit: while <a href="https://stackoverflow.com/users/1222951/">@Aran-Fey</a>'s <a href="https://stackoverflow.com/a/50385115/110488">solution</a> answer my question correctly, it appears that my assumption was wrong. Changing the signature doesn't allow calling the <code>new_fn</code> using the new signature. That is <code>gen_fn({'a': int})(a=42)</code> raises a <code>TypeError:</code> ... `got an unexpected keyword argument 'a'.</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of creating a function with annotations, it's easier to create a function and then set the annotations manually.</p>
<ul>
<li><p><a href="https://docs.python.org/3/library/inspect.html#inspect.signature" rel="nofollow noreferrer"><code>inspect.signature</code></a> looks for the existence of a <code>__signature__</code> attribute before it looks at the function's actual signature, so we can craft an appropriate <a href="https://docs.python.org/3/library/inspect.html#inspect.Signature" rel="nofollow noreferrer"><code>inspect.Signature</code></a> object and assign it there:</p>
<pre><code>params = [inspect.Parameter(param,
                            inspect.Parameter.POSITIONAL_OR_KEYWORD,
                            annotation=type_)
                        for param, type_ in args.items()]
new_fn.__signature__ = inspect.Signature(params)
</code></pre></li>
<li><p><a href="https://docs.python.org/3/library/typing.html#typing.get_type_hints" rel="nofollow noreferrer"><code>typing.get_type_hints</code></a> does <em>not</em> respect <code>__signature__</code>, so we should update the <code>__annotations__</code> attribute as well:</p>
<pre><code>new_fn.__annotations__ = args
</code></pre></li>
</ul>
<p>Putting them both together:</p>
<pre><code>def gen_fn(args: Dict[str, Any]) -&gt; Callable:
    def new_fn():
        pass

    params = [inspect.Parameter(param,
                                inspect.Parameter.POSITIONAL_OR_KEYWORD,
                                annotation=type_)
                            for param, type_ in args.items()]
    new_fn.__signature__ = inspect.Signature(params)
    new_fn.__annotations__ = args

    return new_fn

print(inspect.signature(gen_fn({'a': int})))  # (a:int)
print(get_type_hints(gen_fn({'a': int})))  # {'a': &lt;class 'int'&gt;}
</code></pre>
<hr/>
<p>Note that this doesn't make your function <em>callable</em> with these arguments; all of this is just smoke and mirrors that makes the function <em>look</em> like it has those parameters and annotations. <em>Implementing</em> the function is a separate issue.</p>
<p>You can define the function with <a href="https://stackoverflow.com/questions/36901/what-does-double-star-asterisk-and-star-asterisk-do-for-parameters">varargs</a> to aggregate all the arguments into a tuple and a dict:</p>
<pre><code>def new_fn(*args, **kwargs):
    ...
</code></pre>
<p>But that still leaves you with the problem of implementing the function body. You haven't said what the function should do when it's called, so I can't help you with that. You can look at <a href="https://stackoverflow.com/questions/11291242/python-dynamically-create-function-at-runtime">this question</a> for some pointers.</p>
</div>
<span class="comment-copy">I guess one way to achieve that is to build a string and <code>eval()</code> the whole string to get the function definition. But I don't think that's the best way to do it.</span>
<span class="comment-copy">This seems to be correct but insufficient for my needs. See <code>Edit</code> to the OP.</span>
<span class="comment-copy">@ChenLevy Yes, implementing the function is a separate issue. You can make the function accept arbitrary arguments if you define it as <code>def new_fn(*args, **kwargs):</code>, but you still have to implement the function's body. You haven't specified what the function is supposed to do when it's called, so I can't give you much advice. Depending on the circumstances, you may even have to resort the writing code at runtime and then <a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow noreferrer"><code>exec</code></a>ing it.</span>
