<div class="post-text" itemprop="text">
<p>I have a simple class that leverages an async generator to retrieve a list of URLs:</p>
<pre><code>import aiohttp
import asyncio
import logging
import sys

LOOP = asyncio.get_event_loop()
N_SEMAPHORE = 3

FORMAT = '[%(asctime)s] - %(message)s'
logging.basicConfig(stream=sys.stdout, level=logging.INFO, format=FORMAT)
logger = logging.getLogger(__name__)

class ASYNC_GENERATOR(object):
    def __init__(self, n_semaphore=N_SEMAPHORE, loop=LOOP):
        self.loop = loop
        self.semaphore = asyncio.Semaphore(n_semaphore)
        self.session = aiohttp.ClientSession(loop=self.loop)

    async def _get_url(self, url):
        """
        Sends an http GET request to an API endpoint
        """

        async with self.semaphore:
            async with self.session.get(url) as response:
                logger.info(f'Request URL: {url} [{response.status}]')
                read_response = await response.read()

                return {
                    'read': read_response,
                    'status': response.status,
                }

    def get_routes(self, urls):
        """
        Wrapper around _get_url (multiple urls asynchronously)

        This returns an async generator
        """

        # Asynchronous http GET requests
        coros = [self._get_url(url) for url in urls]
        futures = asyncio.as_completed(coros)
        for future in futures:
            yield self.loop.run_until_complete(future)

    def close(self):
        self.session._connector.close()
</code></pre>
<p>When I execute this main part of the code:</p>
<pre><code>if __name__ == '__main__':
    ag = ASYNC_GENERATOR()
    urls = [f'https://httpbin.org/get?x={i}' for i in range(10)]
    responses = ag.get_routes(urls)
    for response in responses:
        response = next(ag.get_routes(['https://httpbin.org/get']))
    ag.close()
</code></pre>
<p>The log prints out:</p>
<pre><code>[2018-05-15 12:59:49,228] - Request URL: https://httpbin.org/get?x=3 [200]
[2018-05-15 12:59:49,235] - Request URL: https://httpbin.org/get?x=2 [200]
[2018-05-15 12:59:49,242] - Request URL: https://httpbin.org/get?x=6 [200]
[2018-05-15 12:59:49,285] - Request URL: https://httpbin.org/get?x=5 [200]
[2018-05-15 12:59:49,290] - Request URL: https://httpbin.org/get?x=0 [200]
[2018-05-15 12:59:49,295] - Request URL: https://httpbin.org/get?x=7 [200]
[2018-05-15 12:59:49,335] - Request URL: https://httpbin.org/get?x=8 [200]
[2018-05-15 12:59:49,340] - Request URL: https://httpbin.org/get?x=4 [200]
[2018-05-15 12:59:49,347] - Request URL: https://httpbin.org/get?x=1 [200]
[2018-05-15 12:59:49,388] - Request URL: https://httpbin.org/get?x=9 [200]
[2018-05-15 12:59:49,394] - Request URL: https://httpbin.org/get [200]
[2018-05-15 12:59:49,444] - Request URL: https://httpbin.org/get [200]
[2018-05-15 12:59:49,503] - Request URL: https://httpbin.org/get [200]
[2018-05-15 12:59:49,553] - Request URL: https://httpbin.org/get [200]
[2018-05-15 12:59:49,603] - Request URL: https://httpbin.org/get [200]
[2018-05-15 12:59:49,650] - Request URL: https://httpbin.org/get [200]
[2018-05-15 12:59:49,700] - Request URL: https://httpbin.org/get [200]
[2018-05-15 12:59:49,825] - Request URL: https://httpbin.org/get [200]
[2018-05-15 12:59:49,875] - Request URL: https://httpbin.org/get [200]
[2018-05-15 12:59:49,922] - Request URL: https://httpbin.org/get [200]
</code></pre>
<p>Since <code>responses</code> is an async generator, I expect it to yield one response from the async generator (which should only send the request upon actually yielding), send a separate request to the endpoint with no <code>x</code> parameter, and then yield the next response from the async generator. This should flip back and forth between a request with an <code>x</code> parameter and a request with no parameters. Instead, it is yielding all responses from the async generator with an <code>x</code> parameter and then followed by all of the https requests that have no parameters.</p>
<p>Something similar happens when I do:</p>
<pre><code>ag = ASYNC_GENERATOR()
urls = [f'https://httpbin.org/get?x={i}' for i in range(10)]
responses = ag.get_routes(urls)
next(responses)
response = next(ag.get_routes(['https://httpbin.org/get']))
ag.close()
</code></pre>
<p>And the log prints:</p>
<pre><code>[2018-05-15 13:08:38,643] - Request URL: https://httpbin.org/get?x=8 [200]
[2018-05-15 13:08:38,656] - Request URL: https://httpbin.org/get?x=1 [200]
[2018-05-15 13:08:38,681] - Request URL: https://httpbin.org/get?x=3 [200]
[2018-05-15 13:08:38,695] - Request URL: https://httpbin.org/get?x=4 [200]
[2018-05-15 13:08:38,717] - Request URL: https://httpbin.org/get?x=6 [200]
[2018-05-15 13:08:38,741] - Request URL: https://httpbin.org/get?x=2 [200]
[2018-05-15 13:08:38,750] - Request URL: https://httpbin.org/get?x=0 [200]
[2018-05-15 13:08:38,773] - Request URL: https://httpbin.org/get?x=9 [200]
[2018-05-15 13:08:38,792] - Request URL: https://httpbin.org/get?x=7 [200]
[2018-05-15 13:08:38,803] - Request URL: https://httpbin.org/get?x=5 [200]
[2018-05-15 13:08:38,826] - Request URL: https://httpbin.org/get [200]
</code></pre>
<p>Instead, what I want is:</p>
<pre><code>[2018-05-15 13:08:38,643] - Request URL: https://httpbin.org/get?x=8 [200]
[2018-05-15 13:08:38,826] - Request URL: https://httpbin.org/get [200]
</code></pre>
<p>There are times when I want to retrieve all of the responses first before doing anything else. However, there are also times when I want to interject and make intermediate requests before yielding the next item from the generator (i.e., the generator returns results from paginated search results and I want to process further links from each page before moving onto the next page).</p>
<p>What do I need to change to achieve the required result?</p>
</div>
<div class="post-text" itemprop="text">
<p>Leaving aside the technical question of whether <code>responses</code> is an async generator (it's not, as Python <a href="https://www.python.org/dev/peps/pep-0525/" rel="nofollow noreferrer">uses the term</a>), your problem lies in <code>as_completed</code>. <code>as_completed</code> starts a bunch of coroutines <em>in parallel</em> and provides means to obtain their results as they complete. That the futures run in parallel is not exactly obvious from the <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.as_completed" rel="nofollow noreferrer">documentation</a>, but it makes sense if you consider that the original <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.as_completed" rel="nofollow noreferrer"><code>concurrent.futures.as_completed</code></a> works on thread-based futures which have no choice <em>but</em> to run in parallel. Conceptually, the same is true of asyncio futures.</p>
<p>Your code obtains only the first (fastest-arriving) result and then start doing something else, also using asyncio. The remaining coroutines passed to <code>as_completed</code> are not frozen up merely because no one is collecting their results - they are doing their jobs in the background, and once done are ready to be <code>await</code>ed (in your case by the code inside <code>as_completed</code>, which you access using <code>loop.run_until_complete()</code>). I would venture to guess that the URL without parameters takes longer to retrieve than the URL with just the parameter <code>x</code>, which is why it gets printed after all other coroutines.</p>
<p>In other words, those log lines being printed means that <code>asyncio</code> is doing its job and providing the parallel execution you requested! If you don't want parallel execution, then don't ask for it, execute them serially:</p>
<pre><code>def get_routes(self, urls):
    for url in urls:
        yield loop.run_until_complete(self._get_url(url))
</code></pre>
<p>But this is a poor way of using asyncio - its main loop is non-reentrant, so to ensure composability, you almost certainly want the loop to be spun just once once at top-level. This is typically done with a construct like <code>loop.run_until_complete(main())</code> or <code>loop.run_forever()</code>. As Martijn pointed out, you could achieve that, while retaining the nice generator API, by making <code>get_routes</code> an actual async generator:</p>
<pre><code>async def get_routes(self, urls):
    for url in urls:
        result = await self._get_url(url)
        yield result
</code></pre>
<p>Now you can have a <code>main()</code> coroutine that looks like this:</p>
<pre><code>async def main():
    ag = ASYNC_GENERATOR()
    urls = [f'https://httpbin.org/get?x={i}' for i in range(10)]
    responses = ag.get_routes(urls)
    async for response in responses:
        # simulate `next` with async iteration
        async for other_response in ag.get_routes(['https://httpbin.org/get']):
            break
    ag.close()

loop.run_until_complete(main())
</code></pre>
</div>
<span class="comment-copy"><code>responses</code> is not an async generator; it's a regular, normal, synchronous generator function. To be async, you'd have to use <code>async def responses(...):</code></span>
<span class="comment-copy">I don't think I follow. Would you mind providing a code snippet? Would <code>async def responses(...):</code> sit between <code>get_routes</code> and <code>_get_url</code>? Or do I use this inside <code>__main__</code>? And what would I be awaiting inside <code>async def responses(...):</code>? Thank you for your patience as I am still learning this complicated async stuff!</span>
<span class="comment-copy">@MartijnPieters The trouble is that the OP is using <code>as_completed</code>, which is itself an ordinary generator, but designed (strangely) for use with asyncio. Thus it comes naturally to wrap it using another ordinary generator. Using <code>run_until_complete</code> on coroutines yielded (synchronously) by <code>as_completed</code> is a <a href="https://stackoverflow.com/questions/41901795/create-generator-that-yields-coroutine-results-as-the-coroutines-finish/41901796#41901796">legitimate</a> way of using it, though not something I'd recommend.</span>
<span class="comment-copy">@user4815162342 I am flexible and willing to learn the best way to go about this if you don't mind offering an answer with the right solution? I cobbled this together using limited knowledge scraped from disparate examples from the web so I'd appreciate any help that I can get. Hopefully, it is clear what I am trying to achieve?</span>
<span class="comment-copy">@slaw: sorry, that was too brief a comment and I had to step away. The term <i>async generator</i> has a <a href="https://www.python.org/dev/peps/pep-0525/" rel="nofollow noreferrer">very specific meaning in Python</a>; your generator function pushes tasks into the asyncio loop but is not an async generator. You are firing off a series of tasks and then waiting for the next one to be complete; all those tasks are executing cooperatively.</span>
<span class="comment-copy">The <code>get_routes()</code> async generator could also add the plain non-query-string URL when the <code>await self._get_url(url)</code> call returns a result, perhaps after the <code>yield result</code>? That way at least <i>those</i> requests would be run in parallel to the synchronous processing of the <code>urls</code> list.</span>
<span class="comment-copy">@MartijnPieters You mean create the task <i>before</i> <code>yield result</code> (which is safe because at that point we know the URL is done and the order respected), but actually await (and yield) it afterwards. That's very clever (unless the OP wanted them not to overlap at all), but it breaks the <code>get_routes</code> abstraction, and might be a bit too advanced for an asyncio beginner.</span>
<span class="comment-copy">Sure, I'd at least change the name of the function, I'm thinking of a general refactor to get closer to what the OP was trying to do.</span>
<span class="comment-copy">Is there a reason why loop.run_until_complete can't be placed within a function? From an abstraction standpoint, I don't want the user to have to know anything about async or event loops. I've seen the main() function being used in many online examples but now the user needs to know to call the class, throw it inside a main() func, and pass it to the event loop when all the want is paginated responses. Also, as an async noob, I'd be happy to study the more clever code if you wanted to include at the bottom as an update? I'll play with this more but, nonetheless, thank you for your help!</span>
<span class="comment-copy">@slaw Sure, If you really don't want the caller to know anything about asyncio, you can place <code>run_until_complete</code> in a function. I was just pointing out that it's a suboptimal use of asyncio. Normally asyncio allows one to compose different async code by starting multiple coroutines "in parallel" or integrating them with callback-based futures. You can even have coroutines that don't know of each other, all running in the same event loop. By hiding the use of asyncio inside a function, you have a design that disables that.</span>
