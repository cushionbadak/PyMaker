<div class="post-text" itemprop="text">
<p>I'm working on project named "Faciel Actions Units Detection" 
I'm using python2.7 and opencv 2.4</p>
<p>The error: </p>
<pre><code>pickle.PicklingError: Can't pickle &lt;type 'cv2.Boost'&gt;: it's not the same object as cv2.Boost
</code></pre>
<p>A partial traceback, transcribed from <a href="https://i.stack.imgur.com/8WgTr.png" rel="nofollow noreferrer">a screenshot</a>:</p>
<pre><code>Loading classifier for action unit 27
Traceback (most recent call last):
  File "C:\Python27\audetect-master\audetect-interactive.py", line 59, in &lt;module&gt;
    main()
  File "C:\Python27\audetect-master\audetect-interactive.py", line 18, in main
    active_aus = detector.detect()
  File "C:\Python27\audetect-master\detect.py", line 67, in detect
    initial_points = self.ffdetector.locate_features(first)
  File "C:\Python27\audetect-master\detect.py", line 183, in locate_features
    thread.start()
  File "C:\Python27\lib\multiprocessing\process.py", line 130, in start
    self._popen = Popen(self)
  File "C:\Python27\lib\multiprocessing\forking.py", line 227, in __init__
    dump(process_obj, to_child, HIGHEST_PROTOCOL)
  File "C:\Python27\lib\multiprocessing\forking.py", line 199, in dump
    ForkingPickler(file, protocol).dump(obj)
  File "C:\Python27\lib\pickle.py", line 224, in dump
    self.save(obj)
  File "C:\Python27\lib\pickle.py", line 331, in save
    self.save_reduce(obj=obj, *rv)
  File "C:\Python27\lib\pickle.py", line 425, in save_reduce
    save(state)
  File "C:\Python27\lib\pickle.py", line 286, in save
    f(self, obj) # Call unbound method with explicit self
  File "C:\Python27\lib\pickle.py", line 655, in save_dict
    self._batch_setitems(obj.iteritems())
  File "C:\Python27\lib\pickle.py", line 687, in _batch_setitems
    save(v)
  File "C:\Python27\lib\pickle.py", line 286, in save
    f(self, obj) # Call unbound method with explicit self
  File "C:\Python27\lib\multiprocessing\forking.py", line 67, in dispatcher
    self.save_reduce(obj=obj, *rv)
  File "C:\Python27\lib\pickle.py", line 401, in save_reduce
    save(args)
  File "C:\Python27\lib\pickle.py", line 286, in save
    f(self, obj) # Call unbound method with explicit self
  File "C:\Python27\lib\pickle.py", line 554, in save_tuple
    save(element)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Pickle is used by the <code>multiprocessing</code> module to communicate between the different parts, and in the <a href="https://docs.python.org/3/library/multiprocessing.html#programming-guidelines" rel="nofollow noreferrer">programming guidelines</a> it explains that you must ensure that all your data that you pass between processes must be compatible with pickling:</p>
<blockquote>
<p><em>Picklability</em>: Ensure that the arguments to the methods of proxies are picklable.</p>
</blockquote>
<p>You are using data that is not picklable.</p>
<p>Specifically, what is going wrong is that the <code>cv2.Boost</code> class doesn't quite tell the truth on how you can create more copies of the class.  <code>pickle</code> stores <em>references</em> to classes and functions, not their definition, because that's way more efficient. This means that instances only need to store the data for that instance, not also all of the class hierarchy and method definitions.</p>
<p>In order to do this, <code>pickle</code> takes the module a class or function is defined in, and the name of the object, and together that's the reference to the class or function. It then <em>double-checks</em> that it can use that name to load the same class or function back again.</p>
<p>That sanity check failed for the <code>cv2.Boost</code> class. You have instances of a class is named <code>Boost</code> and that claims to have come from the <code>cv2</code> module, but when <code>pickle</code> then goes to the <code>cv2</code> module and looks up the <code>Boost</code> attribute of that module it found a <em>different object</em>. This means your data could not be unpickled.</p>
<p>There are ways to correct this; you need to teach the <code>pickle</code> module to use a different function to load the same data again, using the <a href="https://docs.python.org/3/library/copyreg.html#copyreg.pickle" rel="nofollow noreferrer"><code>copyreg.pickle()</code> function</a>; if such a registration exists for the <code>cv2.Boost</code> class then <code>pickle</code> will not make the above check:</p>
<pre><code>import copyreg
import cv2

def _pickle_boost(boost):
    return cv2.Boost, (
        boost.trainData,
        boost.tflag,
        boost.responses, 
        boost.varIdx,
        boost.sampleIdx,
        boost.varType,
        boost.missingDataMask,
        boost.paramsd,
    )

copyreg.pickle(cv2.Boost().__class__, _pickle_boost)
</code></pre>
<p><strong><em>WARNING</em></strong>: I didn't actually test if the above will work, because I don't have a 2.4.x version of <code>cv2</code> installed locally; I merely referred to the <a href="https://docs.opencv.org/2.4/modules/ml/doc/boosting.html#cv2.Boost" rel="nofollow noreferrer"><code>cv2.Boost()</code> documentation</a> to guess at what attributes such a class would have. You'll probably need to adjust it. The idea is that for the <code>cv2.Boost().__class__</code> type, the <code>_pickle_boost()</code> function is called, returning a callable (<code>cv2.Boost</code>) to create a new instance, and the arguments that you want to pass to that callable.</p>
<p>If any of the above values are themselves more <code>cv2</code> types that exhibit the same problem, then you need to register more functions.</p>
</div>
<span class="comment-copy">Please include a minimal idea of your Python code that you tried to run.</span>
<span class="comment-copy">thank you so much for your attention this is function    def detect(self):         """ Returns a tuple of active AUs """         first = self.sequence[0]         last = self.sequence[-1]          initial_points = self.ffdetector.locate_features(first)         final_points = self.ffdetector.locate_features(last)          if not initial_points or not final_points:           sys.stderr.write("Error: could not locate face in supplied sequence")           sys.stderr.write("\n")           return []          aus = self.determine_aus(initial_points, final_points)          return aus</span>
<span class="comment-copy">@ToddPalmer thank you for your attention the function above that rises the error</span>
<span class="comment-copy">Please, do not use screenshots of code and tracebacks. We can't copy those, nor can screenreaders for people with visual impairments read the text. Both error messages and code are <i>text</i>, please post them as text.</span>
<span class="comment-copy">I note that the traceback screenshot is also not <i>complete</i>.</span>
<span class="comment-copy">Is there any chance you could add a minimal complete working example? Trying to get my head round this one. Trying to understand how to cache a cv2.ORB() object (in Flask) but failing miserably.. Thanks for all help</span>
<span class="comment-copy">@jtlz2: it's already a MCVE, for the <code>cv2.Boost</code> type. As I already state in my answer, I can't test this with the specific type, but the general principle should be the same for <code>cv2.ORB()</code>. Create a function that returns the constructor and a tuple of values given an instance, then register that function for the actual class object for <code>cv2.ORB()</code> instances.</span>
<span class="comment-copy">@jtlz2: so <code>def _pickle_orb(orb): return cv2.ORB, (orb.nfeatures, orb.scaleFactor, orb.nlevels, orb.edgeThreshold, orb.firstLevel, orb.WTA_K, orb.scoreType, orb.patchSize)</code>, where I assume that <code>cv2.ORB()</code> instances have the same attributes as <a href="https://docs.opencv.org/2.4/modules/features2d/doc/feature_detection_and_description.html#orb-orb" rel="nofollow noreferrer">the constructor parameters</a>, then <code>copyreg.pickle(cv2.ORB().__class__, _pickle_orb)</code>.</span>
<span class="comment-copy">@jtlz2: Flask-Caching doesn't need to be taught anything. It just uses <code>pickle</code>, and it is <code>pickle</code> that uses the <code>copyreg</code> registry.</span>
<span class="comment-copy">@jtlz2: just call the getters then. The goal is to produce the values that you need to pass to the <code>cv2.ORB()</code> constructor to recreate the value.</span>
