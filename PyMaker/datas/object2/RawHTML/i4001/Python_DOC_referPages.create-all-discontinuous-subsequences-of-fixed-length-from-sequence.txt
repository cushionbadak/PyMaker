<div class="post-text" itemprop="text">
<p>I have a sequence like the following:</p>
<pre><code>seq = "SDLKFJSOIDHFSODIF"
</code></pre>
<p>I want to make all discontinuous subsequences of length 5 for this. Because there are 5 possible reading frames, I want a list of 5 lists like the following:</p>
<pre><code>[["SDLKF", "JSOID", "HFSOD"], ["DLKFJ", "SOIDH", FSODI"], ...]
</code></pre>
<p>All of the characters will not be present in each list, and for this example, the 5th list will only have two entries. This is okay.</p>
<p>How can I make a function that generalizes this to all possible lengths of the subsequence?</p>
<p>Thanks!
Jack</p>
</div>
<div class="post-text" itemprop="text">
<p>Through nested list comprehension:</p>
<pre><code>&gt;&gt;&gt; [[seq[i: i + 5] for i in range(j, len(seq), 5) if i + 5 &lt;= len(seq)] for j in range(5)]
[['SDLKF', 'JSOID', 'HFSOD'],
 ['DLKFJ', 'SOIDH', 'FSODI'],
 ['LKFJS', 'OIDHF', 'SODIF'],
 ['KFJSO', 'IDHFS'],
 ['FJSOI', 'DHFSO']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Although the single list comprehension is the better answer, here is a <a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>more-itertools</code></a><sup>1</sup> approach.</p>
<p><strong>Given</strong></p>
<pre><code>import itertools as it

import more_itertools as mit


seq = "SDLKFJSOIDHFSODIF"
size = 5
</code></pre>
<p><strong>Code</strong></p>
<pre><code>windows = it.islice(mit.stagger(seq, offsets=range(len(seq)), longest=True), size)
[["".join(x) for x in mit.sliced(w, size) if None not in x and len(x) == size] for w in windows]
</code></pre>
<p>Output</p>
<pre><code>[['SDLKF', 'JSOID', 'HFSOD'],
 ['DLKFJ', 'SOIDH', 'FSODI'],
 ['LKFJS', 'OIDHF', 'SODIF'],
 ['KFJSO', 'IDHFS'],
 ['FJSOI', 'DHFSO']]
</code></pre>
<hr/>
<p><strong>Details</strong></p>
<p>Goal: make several <strong>sliding windows</strong> of the sequence and split them into <strong>chunks</strong>.</p>
<p>In the first list comprehension, the results are <em>shrinking</em> <strong>sliding <code>windows</code></strong>. For demonstration, here is an example of the full cascading results:</p>
<pre><code>&gt;&gt;&gt; windows = mit.stagger(seq, offsets=range(len(seq)), longest=True)
&gt;&gt;&gt; ["".join(filter(None, w)) for w in windows]
['SDLKFJSOIDHFSODIF',
'DLKFJSOIDHFSODIF',
'LKFJSOIDHFSODIF',
'KFJSOIDHFSODIF',
'FJSOIDHFSODIF',
'JSOIDHFSODIF',
'SOIDHFSODIF',
'OIDHFSODIF',
'IDHFSODIF',
'DHFSODIF',
'HFSODIF',
'FSODIF',
'SODIF',
'ODIF',
'DIF',
'IF',
'F']
</code></pre>
<p>Notice for each window, the left side <em>slides</em>, while the right side is fixed.  In other words, the window size shrinks by 1 for each iteration.  These shrinking windowing are achieved by the <code>offsets</code> parameter in <code>more_itertools.stagger</code> (see <a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.stagger" rel="nofollow noreferrer">the docs</a> for details).  Since the process repeats, only the first windows of a given <code>size</code> are selected via <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow noreferrer"><code>itertools.isliced</code></a>.</p>
<p>The second comprehension simply <strong>chunks</strong> these windows into groups of a <code>size</code>, discarding invalid chunks (<code>&lt; size</code> or containing the fillvalue <code>None</code>, a default in <code>more_itertools.stagger</code>).</p>
<p><sub><sup>1</sup><code>more_itertools</code> is a third-party library installed via <a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>pip install more_itertools</code></a>.</sub></p>
</div>
<span class="comment-copy">Nice. I think you could replace the <code>if</code> clause with <code>range(j, len(seq)-5+1, 5)</code> also.</span>
<span class="comment-copy">Thanks, miradulo - that's a great point.</span>
