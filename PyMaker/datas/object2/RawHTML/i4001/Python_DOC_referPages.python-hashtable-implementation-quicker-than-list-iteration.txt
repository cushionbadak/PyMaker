<div class="post-text" itemprop="text">
<p>This is a <a href="https://www.hackerrank.com/challenges/ctci-ransom-note/" rel="nofollow noreferrer">problem from HackerRank</a>. My implementation as shown below passes most of the test but for the tests that it fails, it states that it is taken too long. After looking at other submissions, I found that another user's implementation (credit to <a href="https://www.hackerrank.com/profile/saikiran9194" rel="nofollow noreferrer">saikiran9194</a>) passes all tests almost immediately. I really am having trouble understanding why his solution is the most efficient at scale. </p>
<p><strong>My Implementation:</strong></p>
<pre><code>m, n = map(int, input().strip().split(' '))
magazine = input().strip().split(' ')
ransom = input().strip().split(' ')
yesNo = "Yes"
for i in ransom:
    if(ransom.count(i) &gt; magazine.count(i)):
        yesNo = "No"
print(yesNo)
</code></pre>
<p><strong>More Time Efficient Implementation</strong></p>
<pre><code>def ransom_note(magazine, ransom):
    rc = {} # dict of word: count of that word in the note
    for word in ransom:
        if word not in rc:
            rc[word] = 0
        rc[word] += 1

    for word in magazine:
        if word in rc:
            rc[word] -= 1
            if rc[word] == 0:
                del rc[word]
                if not rc:
                    return True
    return False

m, n = map(int, input().strip().split(' '))
magazine = input().strip().split(' ')
ransom = input().strip().split(' ')
answer = ransom_note(magazine, ransom)
if(answer):
    print("Yes")
else:
    print("No")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's the difference between <code>list.count</code> and <code>dict.__getitem__</code> (<code>rc[word]</code>). <code>list.count</code> is <code>O(n)</code> whereas <code>dict.__getitem__</code> is <code>O(1)</code> due to, as you mention, hashing.</p>
<p>Source: <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">https://wiki.python.org/moin/TimeComplexity</a></p>
</div>
<div class="post-text" itemprop="text">
<p><code>list.count</code> has linear complexity, so your code has quadratic complexity overall, doing linear work in each iteration of the loop. By putting the lists in a <code>dict</code> first, it only needs O(1) to get the count for a certain letter.</p>
<p>You can just wrap those lists into <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> (not tested):</p>
<pre><code>m, n = map(int, input().strip().split())
magazine = Counter(input().strip().split())
ransom = Counter(input().strip().split())
yesNo = "Yes"
for i in ransom:
    if(ransom[i] &gt; magazine[i]):
        yesNo = "No"
print(yesNo)
</code></pre>
<p>Or shorter using <code>any</code></p>
<pre><code>yesno = "No" if any(random[i] &gt; magazine[i] for i in ransom) else "Yes"
</code></pre>
</div>
<span class="comment-copy">add a break after yesNo = "No"?</span>
<span class="comment-copy">I thought of that as well. This change passes more tests, but still not all of them. Any thoughts as to why the other implementation is quicker?</span>
<span class="comment-copy"><code>count</code> is linear, so your code has quadratic complexity. By putting it in a dict first, it only needs O(1) to get the count for a certain letter.</span>
<span class="comment-copy">Ah, makes perfect sense...Thank you so much!</span>
<span class="comment-copy">Hash table iteration is not necessarily faster but hash table lookup is <code>O(1)</code> whereas each call to <code>list.count()</code> is <code>O(n)</code>.</span>
