<div class="post-text" itemprop="text">
<p>I see this was flagged as a duplicate of "What is the difference between class and instance variables?" However I don't believe I'm using any instance variables in my example, neither of my classes has a <code>__init__</code> I'm editing class variables in two different ways and trying to understand the difference between them, <strong>not</strong> the difference between a class and instance variable.</p>
<p>I'm trying to understand the difference between calling a class variable just with <code>.var</code> and with <code>.__class__.var</code>. I thought it was to do with subclassing so I wrote the following code.</p>
<pre><code>class Foo:
    foo = 0

class Bar(Foo):
    bar = 1

def print_class_vals(f, b):
    """ prints both instant.var and instant.__class__.var for foo and bar"""
    print("f.foo: {}, {} "
          "b.foo: {}, {} "
          "b.bar: {}, {} "
          "".format(f.foo, f.__class__.foo,
                    b.foo, b.__class__.foo,
                    b.bar, b.__class__.bar))

f = Foo()
b = Bar()
print_class_vals(f, b)

Foo.foo += 1
print_class_vals(f, b)

Bar.foo += 1
print_class_vals(f, b)

Bar.bar += 1
print_class_vals(f, b)
</code></pre>
<p>This outputs the following:</p>
<pre><code>f.foo: 0, 0, b.foo: 0, 0, b.bar: 1, 1 
f.foo: 1, 1, b.foo: 1, 1, b.bar: 1, 1 
f.foo: 1, 1, b.foo: 2, 2, b.bar: 1, 1 
f.foo: 1, 1, b.foo: 2, 2, b.bar: 2, 2 
</code></pre>
<p>I can't seem to find any difference between calling <code>inst.var</code> and  <code>inst.__class__.var</code>. How are they different and when should I use one over the other?</p>
</div>
<div class="post-text" itemprop="text">
<p>While <a href="https://stackoverflow.com/a/50311137/908494">Gabriel Reis's answer</a> explains this particular situation perfectly, there actually <em>is</em> a difference between <code>f.foo</code> and <code>f.__class__.foo</code> <em>even if <code>foo</code> isn't shadowed by an instance attribute</em>.</p>
<p>Compare:</p>
<pre><code>&gt;&gt;&gt; class Foo:
...     foo = 1
...     def bar(self): pass
...     baz = lambda self: None
&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; f.foo
1
&gt;&gt;&gt; f.__class__.foo
1
&gt;&gt;&gt; f.bar
&lt;bound method Foo.bar of &lt;__main__.Foo object at 0x11948cb00&gt;&gt;
&gt;&gt;&gt; f.__class__.bar
&lt;function __main__.Foo.bar(self)&gt;
&gt;&gt;&gt; f.bar()
&gt;&gt;&gt; f.__class__.bar()
TypeError: bar() missing 1 required positional argument: 'self'
</code></pre>
<p>And the same is true for <code>f.baz</code>.</p>
<p>The difference is that, by directly accessing <code>f.__class__.foo</code>, you're making an end-run around the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor protocol</a>, which is the thing that makes methods, <code>@property</code>, and similar things work.</p>
<p>If you want the full details, read the linked HOWTO, but the short version is that there's a bit more to it than Gabriel's answer says:</p>
<blockquote>
<p>Python will look up for a name (attribute) first in the instance namespace/dict. If it doesn't find there, then it will look up in the class namespace. If it still doesn't find there, then it will walk through the base classes respecting the MRO (method resolution order).</p>
</blockquote>
<p>But if it finds it in the class namespace (or any base class), and what it finds is a descriptor (a value with a <code>__get__</code> method), it does an extra step. The details depend on whether it's a data or non-data descriptor (basically, whether it <em>also</em> has a <code>__set__</code> method), but the short version is that instead of giving you the value, it calls <code>__get__</code> on the value and gives you what that value returns. Functions have a <code>__get__</code> method that returns a bound method; properties have a <code>__get__</code> method that calls the property get method; etc.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python will look up for a name (attribute) first in the instance namespace/dict. If it doesn't find there, then it will look up in the class namespace. If it still doesn't find there, then it will walk through the base classes respecting the MRO (method resolution order).</p>
<p>What you've done there, is to define the class attributes <code>Foo.foo</code> and <code>Bar.bar</code>.
You never modified any instance namespace.</p>
<p>Try this:</p>
<pre><code>class Foo:
    foo = 1

f = Foo()
f.foo = 2

print('f.foo = {!r}'.format(f.foo))
print('f.__class__.foo = {!r}'.format(f.__class__.foo))
</code></pre>
<p>And you will be able to understand the difference.</p>
</div>
<span class="comment-copy">You should pretty much never use <code>__class__</code>.</span>
<span class="comment-copy">@chepner, The top answer on the duplicate has an explanation at the end that discusses why you end up with the same value.</span>
<span class="comment-copy">There is absolutely no difference in accessing a class variable if you do not have an instance variable which shadows it.</span>
<span class="comment-copy">@MisterMiyagi Actually, that isn't true. Try it with a method (or a function-valued class attribute, which is the same thing).</span>
<span class="comment-copy">This is a bit oversimplified, but I think it explains enough for the OP, so I upvoted it but wrote another answer.</span>
