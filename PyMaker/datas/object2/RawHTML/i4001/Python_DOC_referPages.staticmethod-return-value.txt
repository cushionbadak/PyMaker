<div class="post-text" itemprop="text">
<p>In Python 3.6, I was trying to define a property in an AbstractBaseClass; my first try was something like this (later I discovered I can omit <code>@staticmethod</code>):</p>
<pre><code>class AnAbstractClass(ABC):
    @property
    @staticmethod
    @abstractmethod
    def my_property():
        pass
</code></pre>
<p>However PyCharm shows me a warning on the property decorator:
<a href="https://i.stack.imgur.com/MgppX.png" rel="nofollow noreferrer"><img alt="PyCharm warning" src="https://i.stack.imgur.com/MgppX.png"/></a></p>
<p>As far as I understand, the <code>@staticmethod</code> decorator does not return a callable but something different.
(I suspect this is also causing mypy to raise an error on the return value type in my code, however I cannot reproduce the issue in a smaller code sample).</p>
<p>What's going on here?</p>
</div>
<div class="post-text" itemprop="text">
<p>To understand why you are getting the warning you are getting, you need to understand a bit about both <a href="https://www.python.org/dev/peps/pep-0318/" rel="nofollow noreferrer">decorators</a> and <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptors</a>.</p>
<p><strong>Decorators</strong></p>
<p>A decorator is a callable that replaces the thing it is decorating, and assigns it to the same name in the namespace. Normally, decorators are used for functions and classes to add some functionality, like type checking or threading or something, but really they can return anything at all.</p>
<p>Since the output of a decorator does not have to be of the same type as the input, or perform any of the same processing, the order of decorators very much matters. Decorators are applied in order from the one closest to the function, to the one at the top of the list. In your case, <code>abstractmethod</code>, then <code>staticmethod</code>, then <code>property</code>.</p>
<p><strong>Descriptors</strong></p>
<p>Descriptors define a fairly complex protocol that allows for customization of objects using the binding behavior they provide. For your purposes, you need to know that functions are descriptors, and that placing them into a class object uses this. When you invoke any descriptor that is defined in a class on the instance of that class, the descriptor protocol binds the descriptor to the instance using the descriptor's <code>__get__</code> method. The descriptor itself doesn't even have to be a callable, and neither is the return value of <code>__get__</code>, even though in most cases it is expected to be. For a function, <code>__get__</code> returns a closure that automatically passes <code>self</code> as the first positional argument.</p>
<p>For example, given a class <code>A</code> with a method <code>def b(self, arg):</code>, and an instance of that class called <code>a</code>, doing <code>a.b(arg)</code> turns into <code>A.b.__get__(a, A)(arg)</code>. So while <code>b</code> is defined to have two positional arguments, it only needs one to be passed in explicitly when called on an instance. However, when you call <code>b</code> through the class, e.g., <code>A.b(a, arg)</code>, it is just a normal function, and you need to pass in all the parameters manually, including <code>self</code>.</p>
<p><strong>Putting it all together</strong></p>
<p><a href="https://docs.python.org/3/library/abc.html#abc.abstractmethod" rel="nofollow noreferrer"><code>abstractmethod</code></a>, <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer"><code>property</code></a> and <a href="https://docs.python.org/3/library/functions.html#staticmethod" rel="nofollow noreferrer"><code>staticmethod</code></a> are all decorators that return callable descriptor objects. However, the <code>__get__</code> method of their decriptors works a bit differently than the <code>__get__</code> of a normal function object.</p>
<p><code>abstractmethod</code> creates a fairly normal class method, but it interacts with the metaclass <a href="https://docs.python.org/3/library/abc.html#abc.ABCMeta" rel="nofollow noreferrer"><code>ABCMeta</code></a>, so that you get all kinds of useful errors when you try to instantiate a class with abstract methods. It does not modify the input parameters expected by the result in any way. In fact, the documentation hints at the fact that <em>all</em> the side-effects may be related to the metaclass, and that the original input is just passes through. The only thing to really keep in mind here is</p>
<blockquote>
<p>When <code>abstractmethod()</code> is applied in combination with other method descriptors, it should be applied as the innermost decorator, as shown in the following usage examples: ...</p>
</blockquote>
<p>Your code seems to be following that injunction. In fact <code>abstractmethod</code> has nothing to do with your warning, but it seemed like a good idea to mention it here anyway.</p>
<p><code>staticmethod</code> returns a callable that bypasses normal binding behavior to create a method that does not care what class or instance it is invoked from. In particular, a method bound using <code>staticmethod.__get__</code> will pass its arguments through to your function, instead of prepending <code>self</code> first (i.e., <code>__get__</code> basically just returns your original function). You can imagine that this would be a problem for something that expects to receive a <code>self</code> parameter, like the setter of a property.</p>
<p>Unlike <code>abstractmethod</code> and <code>staticmethod</code>, <code>property</code> creates a data descriptor. This means that it returns an object that has both a <code>__get__</code> binding and a <code>__set__</code> binding (and also a <code>__del__</code> binding). A property's <code>__get__</code> method works pretty much just like a normal function's <code>__get__</code> method, but applied specifically to the getter function. <code>property</code> cares very much what instance it is invoked from because of course you want different instances to have different values of the attribute the property wraps.</p>
<p>So what you have in your code is <code>staticmethod</code> followed by <code>property</code>. The first decorator returns a function that does not prepend <code>self</code> to its argument list when bound, while the second expects one that does. There is nothing stopping you from invoking the decorators, but the IDE warning is telling you that you are not going to succeed in calling the resulting object. If you try to access <code>my_property</code> on a concrete implementation of <code>AnyAbstractClass</code>, you will probably get a <code>TypeError</code> telling you that <code>my_property</code> does not accept any positional parameters, but one was given, because <code>property.__get__</code> will prepend <code>self</code> to the argument list of the static method, which does not accept any arguments.</p>
<p>Keep in mind that applying <code>staticmethod</code> to the result of <code>property</code> won't help you much either. A <code>property</code> instance is not callable at all. It operates entirely through its <code>__get__</code>, <code>__set__</code> and <code>__del__</code> methods, while <code>staticmethod</code> assumes that you pass in a callable.</p>
<p><strong>Solution</strong></p>
<p>As you have correctly discovered, <code>staticmethod</code> and <code>property</code> don't mix well. A property, by its very nature, should always be aware of the instance it operates on. The correct way to go about doing this is to add a <code>self</code> parameter and allow normal method binding to take place.</p>
<p>Both <code>property</code> and <code>staticmethod</code> play well with <code>abstractmethod</code> (as long as <code>abstractmethod</code> is applied first), because it makes effectively no change to your original function. In fact, the docs of <code>abstractmethod</code> mention specifically that the getter, setter or deleter of a <code>property</code> abstract makes the whole property abstract.</p>
<p><strong>TL;DR</strong></p>
<p><code>staticmethod</code> returns a descriptor that is callable, but whose <code>__get__</code> method returns an unbound version of itself. <code>property</code> creates an uncallable descriptor whose <code>__get__</code> method calls the getter of the property. Using the resulting property will attempt to pass <code>self</code> to a static method which doesn't accept it.</p>
</div>
<span class="comment-copy">How do you expect a static property to work? You might want to look at defining a property on the metaclass.</span>
<span class="comment-copy">@MadPhysicist why wouldn't it work?</span>
<span class="comment-copy">Does the ordering matter of the decorators?</span>
<span class="comment-copy">@Tobias the warning is always showed on the decorator which receive the value returned by <code>@staticmethod</code></span>
<span class="comment-copy">Right. After some thought, I think that @property:s are supposed to be added to instances rather than base classes. Would that work for you?</span>
