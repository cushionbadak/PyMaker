<div class="post-text" itemprop="text">
<p>I am confused about the slice operation.</p>
<pre><code>&gt;&gt;&gt; s = "hello world"
&gt;&gt;&gt; y = s[::]
&gt;&gt;&gt; id(s)
4507906480
&gt;&gt;&gt; id(y)
4507906480 # they are the same - no new object was created

&gt;&gt;&gt; z = s[:2]
&gt;&gt;&gt; z
'he'
&gt;&gt;&gt; id(z)
4507835488 # z is a new object
</code></pre>
<p>What allocation rule does slice operation follow?</p>
</div>
<div class="post-text" itemprop="text">
<p>For most built-in types, slicing is always a shallow copy... in the sense that modifying the copy will not modify the original. This means that for immutable types, an object counts as a copy of itself. The <a href="https://docs.python.org/3/library/copy.html" rel="nofollow noreferrer"><code>copy</code> module</a> also uses this concept of "copy":</p>
<pre><code>&gt;&gt;&gt; t = (1, 2, 3)
&gt;&gt;&gt; copy.copy(t) is t
True
</code></pre>
<p>Objects are free to use whatever allocation strategy they choose, as long as they implement the semantics they document. <code>y</code> can be the same object as <code>s</code>, but <code>z</code> cannot, because <code>s</code> and <code>z</code> store different values.</p>
</div>
<span class="comment-copy">Whatever rule the object says it should.</span>
<span class="comment-copy">Looks like a sensible optimization to me since making an exact copy of an immutable object can't have all that many use cases.</span>
<span class="comment-copy">@PaulPanzer Yeah, the compiler makes a similar optimization if you have two provably-immutable constants with the same value in the same compilation unit, and the interpreter makes a similar optimization with small strings in the same subinterpreter and small ints and the "keyword constants" like None anywhere in the process. And of course that differs between Python implementations and versions. In general, any code that relies two equal immutable values either being identical or not being identical is broken.</span>
<span class="comment-copy">I think <code>memoryview</code> is the only exception among builtin types, but it might be worth giving an example of a more common exception, like numpy arrays, even though they aren't builtin.</span>
<span class="comment-copy">Is it correct to think of this like (string) interning?</span>
<span class="comment-copy">@Chris_Rands: A little, in that it involves object reuse, but it's different in that we're not looking objects up in a central table of canonical representatives.</span>
