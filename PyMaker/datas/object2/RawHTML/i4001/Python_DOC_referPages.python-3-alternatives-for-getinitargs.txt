<div class="post-text" itemprop="text">
<p>Is there are short enough way to call the <code>__init__</code> constructor of a class during unpickling in Python 3? The usual way to do this was using <code>__getinitargs__</code> like so</p>
<pre><code>from __future__ import print_function
import pickle

class Car:

    def __init__(self, model, number):
        self.model = model
        self.number = number
        print("constructed with", model, number)
        # many other things to do

    def __getstate__(self):
        # intentionally returns None
        pass

    def __setstate__(self, state):
        pass

    def __getinitargs__(self):
        # save some information when pickling
        # (will be passed to the constructor upon unpickling)
        return self.model, self.number

c = Car("toyota", 1234)
d = pickle.loads(pickle.dumps(c))
print("reconstructed with", d.model, d.number)
</code></pre>
<p>However, the <code>__getinitargs__</code> will be ignored in new style classes and in Python 3+, all classes can only be new style classes. There is the <code>__getnewargs__</code> but it will pass the arguments only to the <code>__new__</code> class method which is not the same. A python 2 call of the above illustrative example will result in</p>
<pre><code>&gt;&gt; constructed with toyota 1234
&gt;&gt; constructed with toyota 1234
&gt;&gt; reconstructed with toyota 1234
</code></pre>
<p>while a python 3 call will error out</p>
<pre><code>&gt;&gt; constructed with toyota 1234
Traceback (most recent call last):
  File "test.py", line 26, in &lt;module&gt;
    print("reconstructed with", d.model, d.number)
AttributeError: 'Car' object has no attribute 'model'
</code></pre>
<p>and ignore the <code>__getinitargs__</code> method.</p>
<p>I don't think Python 3 will easily regress in that regard so hopefully I am missing something obvious.</p>
<p><strong>EDIT</strong>: Replacing <code>__getinitargs__</code> with <code>__getnewargs__</code> does not solve the issue.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want <code>pickle</code> to unpickle your object by calling <code>Car(self.model, self.number)</code>, going through <code>__init__</code> for initialization the same way a normal call to <code>Car</code> would, then tell it to do so in a <a href="https://docs.python.org/3/library/pickle.html#object.__reduce__" rel="nofollow noreferrer"><code>__reduce__</code> method</a>:</p>
<pre><code>def __reduce__(self):
    return (Car, (self.model, self.number))
</code></pre>
<p><a href="https://ideone.com/puvKO3" rel="nofollow noreferrer">Demo</a>.</p>
</div>
<span class="comment-copy">Why do you need to supply <code>__getinitargs__</code> in the first place? You can remove the <code>__getstate__</code> and <code>__setstate__</code> and <code>__getinitargs__</code> methods here and <i>it'll just work</i>.</span>
<span class="comment-copy">This is a simplified example of a much more complicated object. The point of the example was to illustrate the method that is usually used in python 2.</span>
<span class="comment-copy">Works splendidly - thanks! I just added similar lines to make the code testable but your demo is even more complete. I wish there was a quick mentioning of this in the python version changelog in the official docs but hopefully this answer will also be useful for others.</span>
<span class="comment-copy">@pevogam: Be aware that there are subtle dangers to deserializing objects by calling the constructor, particularly for cases with shared objects or circular references. For example, <a href="https://ideone.com/DI7XMN" rel="nofollow noreferrer">this case</a> calls <code>ThingHolder.__init__</code> 3 times, once manually and <i>twice</i> in unpickling, even though the object graph it's unpickling only has one <code>ThingHolder</code> instance. <a href="https://ideone.com/sHlKmb" rel="nofollow noreferrer">This other case</a> fails completely with a RecursionError, although it <a href="https://ideone.com/ceG42I" rel="nofollow noreferrer">succeeds</a> without <code>__reduce__</code>.</span>
<span class="comment-copy">(There are subtle dangers to serialization and deserialization in general, really, but trying to do it by calling the constructor introduces different subtle dangers than trying to do it <code>pickle</code>'s default way.)</span>
<span class="comment-copy">I agree with the added undesirable complexity. Unfortunately, the actual class wasn't created by me and contains a lot of unpicklable objects like locks and similar. Thus, having an alternative like this is sometimes useful.</span>
