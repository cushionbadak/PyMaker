<div class="post-text" itemprop="text">
<p>I have converted a python program to binary using cython. The converted python program is calling some some c-functions as well. </p>
<p>What I have noticed is that when the program is continuously running, the memory consumption is steadily increasing  and after some threshold it drops ,and  then it increases and the cycle repeats.</p>
<p>But if I am not wrong, this type of behaviour happens only with the garbage collector.How the garbage collector is coming into picture in a binary program although it is made from python ? </p>
<p>If the binary program is running outside the python interpreter, then who is invoking the garbage collector ?</p>
</div>
<div class="post-text" itemprop="text">
<p>I think this question is based on a few misunderstandings of what Cython actually does.</p>
<p>The code Cython generates is not standalone. Instead, large chunks of it work by calling functions in <code>libpython</code>. These functions are <em>exactly</em> the same functions as the Python interpreter calls when interpreting normal Python code. Therefore, you should expect that things like the garbage collector will behave in exactly the same way. The majority of variables in Cython are still <code>PyObject</code>s - <em>exactly</em> the same structures as Python uses, and these are still allocated in the same way: by calling <code>PyObject_New</code>. <a href="https://docs.python.org/3/library/gc.html" rel="nofollow noreferrer">The documentation</a> describes the garbage collector trigger as:</p>
<blockquote>
<p>When the number of allocations minus the number of deallocations exceeds threshold0, collection starts </p>
</blockquote>
<p>and since Cython uses the same allocation and deallocation mechanism for <code>PyObject</code>s as interpretted Python code, there's no reason to believe this will behave any differently.</p>
<p>In addition, you should actually expect many Python programs to be running significant amounts of interpreted Python code anyway. If you <code>import</code> a module in Cython then that module will be run in the standard way. If that module is a normal Python module this will be run in the interpreter. You really can't separate Cython from <code>libpython</code> or the Python interpreter (which is part of <code>libpython</code>).</p>
<hr/>
<p>Finally, it isn't at all clear that the behaviour you describe is the garbage collector: it could simply be the normal reference counting mechanism. It'd be pretty usual for a single object to hold references to large numbers of other objects. When that single object is destroyed (for example in each iteration of a loop) then it would end up freeing most of the other objects it holds references too. If you want to know if it's <em>actually</em> the GC running, then you can look at <code>gc.get_stats()</code> (Python 3.4 upwards)</p>
</div>
<span class="comment-copy">This is not really a programming question, but de-allocations of C data are usually handled by the python wrappers of them, just like the Python standard library. When the object wrapper goes out of scope, it de-allocates the C data structures it allocated as part of its <code>__del__</code>, or more accurately the C equivalent of the same. You then get the benefit of automatic garbage collection from the python interpreter while using native code. The standard library does the same thing - one of the best features of Python and its C-API IMO.</span>
<span class="comment-copy">@danny Cython first coverts the python code to c file and after that it converts that c file to binary. So, can you please tell, how the python interpreter is coming to picture.I mean program.pyx ---&gt; program.c ----&gt; program(binary). This is the flow in cython. So if I am not wrong, python interpreter is not coming into picture. I think Garbage is collected in some other manner or it may be taken care in the converted c code itself(I am not sure)</span>
<span class="comment-copy">Cython calls functions in libpython extensively, including for memory allocation and deallocation. Each of these calls is potentially a time when libpython can call the GC. Additionally, it only takes a call to a module written in Python and you have code running in the interpreter again.</span>
<span class="comment-copy">No, that's not how binary programs work @BusyTraveller. Cython will generate a python extension which is loaded into the interpreter. Of course the interpreter is in the picture, it is responsible for loading the binary code. The C code is what interfaces with C library. The binary is an extension to the interpreter. Have a look at the Python standard library. It is written in C. It defines Python objects in C that allocate C data structures when the python object is created by the interpreter. Those same C data structures are de-allocated when the python object is garbage collected.</span>
<span class="comment-copy">@danny actually, there is a little bit of confusion. Actually the interpreter's job is to convert the .py to binary.Once the program is already in binary, why interpreter is required.This is my thinking.I have read somewhere that cython converted binary works outside the interpreter, and that is why it gets the performance closer to C.Anyway I will have look at the Python standard library.</span>
