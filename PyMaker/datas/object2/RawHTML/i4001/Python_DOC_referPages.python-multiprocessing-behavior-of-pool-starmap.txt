<div class="post-text" itemprop="text">
<p>I've got a program using the multiprocessing library to compute some stuff. There are about 10K inputs to compute, each of them taking between 0.2 second and 10 seconds.</p>
<p>My current approach uses a Pool:</p>
<pre><code># Inputs
signals = [list(s) for s in itertools.combinations_with_replacement(possible_inputs, 3)]

# Compute
with mp.Pool(processes = N) as p:
    p.starmap(compute_solutions, [(s, t0, tf, folder) for s in signals])
    print ("    | Computation done.")
</code></pre>
<p>I've noticed that on the 300 / 400 last inputs to check, the program became a lot slower. My question is: how does the <code>Pool</code> and the <code>starmap()</code> behave?</p>
<p>Fro my observation, I believe that if I got 10K inputs and <code>N = 4</code> (4 processes), then the 2 500 first inputs are assigned to the first process, the 2 500 next to the second, ... and each process treats its inputs in a serial fashion.
Which means that if some processes have cleared the Queue before others, they do not get new tasks to perform. </p>
<p><strong><em>Is this correct?</em></strong></p>
<p>If this is correct, how can I have a smarter system which could be represented with this pseudo-code:</p>
<pre><code>workers = Initialize N workers
tasks = A list of the tasks to perform

for task in tasks:
    if a worker is free:
        submit task to this worker
    else:
        wait
</code></pre>
<p>Thanks for the help :)</p>
<p><em>N.B: What is the difference between the different map function. I believe <code>map()</code>, <code>imap_unordered()</code>, <code>imap</code>, <code>starmap</code> exists.</em></p>
<p><strong><em>What are the differences between them and when should we use one or the other?</em></strong></p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Which means that if some processes have cleared the Queue before others, they do not get new tasks to perform.</p>
<p><strong>Is this correct?</strong></p>
</blockquote>
<p>No. The main purpose of <code>multiprocess.Pool()</code> is to spread the passed workload to the pool of its workers - that's why it comes with all those mapping options - the only difference between its various methods is on how the workload is actually distributed and how the resulting returns are collected.</p>
<p>In your case, the iterable you're generating with <code>[(s, t0, tf, folder) for s in signals]</code> will have each of its elements (which ultimately depends on the <code>signals</code> size) sent to the next free worker (invoked as <code>compute_solutions(s, t0, tf, folder)</code>) in the pool, one at a time (or more if <code>chunksize</code> parameter is passed), until the whole iterable is exhausted. You do not get to control which worker executes which part, tho.</p>
<p>The workload may also not be evenly spread - one worker may process more entries than another in dependence of resource usage, execution speed, various internal events...</p>
<p>However, using <code>map</code>, <code>imap</code> and <code>starmap</code> methods of <code>multiprocessing.Pool</code> you get the illusion of even and orderly spread as they internally synchronize the returns from each of the workers to match the <em>source</em> iterable (i.e. the first element of the result will contain the resulting return from the called function with the first element of the iterable). You can try the <em>async/unordered</em> versions of these methods if you want to see what actually happens <em>underneath</em>.</p>
<p>Therefore, you get the <em>smarter system</em> by default, but you can always use <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.apply_async" rel="nofollow noreferrer"><code>multiprocessing.Pool.apply_async()</code></a> if you want a full control over your pool of workers.</p>
<p>As a side note, if you're looking on optimizing the access to your iterable itself (as the pool map options will <em>consume</em> a large part of it) you can check <a href="https://stackoverflow.com/a/44502827/7553525">this answer</a>.</p>
<p>Finally,</p>
<blockquote>
<p><strong>What are the differences between them and when should we use one or the other?</strong></p>
</blockquote>
<p>Instead of me quoting here, head over to the <a href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing.pool" rel="nofollow noreferrer">official docs</a> as there is quite a good explanation of a difference between those.</p>
</div>
<span class="comment-copy">Thanks, I'll have a more detailed look to it tomorrow.</span>
