<div class="post-text" itemprop="text">
<p>I made a pi calculator. But it just corrects first 7 decimal points and starts returning the same results. By the look of the things it is about my float values getting bigger because I use a limit. But is there a limit for decimal numbers in python? I read some documents but there are numbers with even 100 decimal points but I can just get to 11.</p>
<p>My code:</p>
<pre><code>import math
import decimal
import datetime

sqrtt=1.
sumn=0.
tryc=0
outerrepeat=1000000000
while outerrepeat&gt;0:
    tryc+=1
    repeat=10000000
    a=datetime.datetime.now()
    print "\n&gt;&gt;&gt;Processing...\n"
    while repeat&gt;0:

        sumn+=1/(sqrtt**2)
        sqrtt+=1
        repeat-=1
    b=datetime.datetime.now()
    print "&gt;&gt;&gt;Process complete.\n"
    print "&gt;&gt;&gt;Calculate time: "+str(b-a) + " Try-" + str(tryc) +" "+      str(math.sqrt(sumn*6)) + "\n"
    outerrepeat-=1


print "\nThis is all I can do."
</code></pre>
<p>May help: Running on IDLE. Calculation is done by basel problem. Always gets stuck at 3.14159264498. Also never gets further than 11 decimal points but sometimes gets lower. Should say that my limit (sqrtt) hits 8th power of 10 (Maybe lower but higher than 7th power of 10.)
Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>Also very useful will be this tutorial.
<a href="https://docs.python.org/2/tutorial/floatingpoint.html" rel="nofollow noreferrer">Floating Point Arithmetic: Issues and Limitations</a></p>
<p>The precision of python floats is bordered to 17 digits. 
"On a typical machine running Python, there are 53 bits of precision available for a Python float". Its not only python, it is a standart. So it is useful to be familiar with.</p>
</div>
<div class="post-text" itemprop="text">
<p>With a typical python implementation, floats are 64 bits, with 53 bits of precision. That's 15 to 17 significant decimal digits.</p>
<p><a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format" rel="nofollow noreferrer">https://en.wikipedia.org/wiki/Double-precision_floating-point_format</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Python uses 64 bit floats which have <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format" rel="nofollow noreferrer">15 to 17 decimal digits</a> of precision.</p>
<p>Proof can be found <a href="https://github.com/python/cpython/blob/master/Include/floatobject.h" rel="nofollow noreferrer">here</a> where we can see the python <code>float</code> value is stored as a C double (which is almost always a 64 bit floating point number).</p>
<pre><code>typedef struct {
    PyObject_HEAD
    double ob_fval;  // this is the actual float value
} PyFloatObject;
</code></pre>
<hr/>
<p>You can use the <a href="https://docs.python.org/3/library/decimal.html" rel="nofollow noreferrer">decimal.Decimal</a> object for infinite precision. </p>
<p>An example with calculating <a href="https://en.wikipedia.org/wiki/E_(mathematical_constant)" rel="nofollow noreferrer">e</a></p>
<pre><code>import decimal
import math

decimal.getcontext().prec = 100  # set the precision, can be as large as you like

e = decimal.Decimal(0)
next_e = decimal.Decimal('NaN')  # init as not a number
i = 0

while e != next_e:
    e, next_e = next_e, e + decimal.Decimal(1) / math.factorial(i)
    i += 1


e #--&gt; Decimal('2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166428')
</code></pre>
</div>
<span class="comment-copy">This famous series takes a long time to converge; there are <i>much</i> faster ways to calculate pi. But why aren't you using the <code>decimal</code> module you imported? It can calculate square roots to as many places as you want (assuming you have enough RAM).</span>
<span class="comment-copy">FWIW, <a href="https://stackoverflow.com/a/26478803/4014959">here</a> is some Python 2 code I wrote a while ago that calculates pi to high precision, using the decimal module. It can do 1000 decimal places in under a second.</span>
<span class="comment-copy">@PM2Ring Thanks for the op answer but that's more than I can take as a junior. :D</span>
<span class="comment-copy">Hey, don't worry, I don't know why that algorithm works, either. :) But the code itself shouldn't be too hard to understand if you go through it slowly.</span>
<span class="comment-copy">Not the code the algorithm, I'm just in highschool.</span>
<span class="comment-copy">Thanks and what about integers?</span>
<span class="comment-copy">Having said that the print also trim some of the precision - <code>&gt;&gt;&gt; math.sqrt(sumn*6) 3.1415925580959025 &gt;&gt;&gt; str(math.sqrt(sumn*6)) '3.1415925581'</code></span>
<span class="comment-copy">@ElvezTheElf integers have a precision of 1 by definition.</span>
<span class="comment-copy">Integers in current versions of python don't have a fixed limit of digits. Python will allocate enough bytes of memory to store your integer until you run out of ram.</span>
<span class="comment-copy">Thanks, can you give an examle? Like for my code. I'd really appreciate that.</span>
<span class="comment-copy">There's no such thing as infinite precision. Decimal have <i>fixed</i> precision. That's reason for using them.</span>
<span class="comment-copy">@HÃ¥kenLid Of course there is, from the docs: "Unlike hardware based binary floating point, the decimal module has a user alterable precision (defaulting to 28 places) which can be <b>as large as needed</b> for a given problem:"</span>
<span class="comment-copy">You have to specify a fixed precision. It can be much, much larger than 28, but you can't have "infinite" precision. That's not possible, since it would require a computer with infinite memory.</span>
<span class="comment-copy">But that's a hardware limitation, not a software limitation. It's the same way we describe python 3 ints (python 2 longs) as having infinite size. This is very common in computer science.</span>
