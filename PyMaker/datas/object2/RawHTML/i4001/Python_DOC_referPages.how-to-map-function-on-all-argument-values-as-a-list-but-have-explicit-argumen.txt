<div class="post-text" itemprop="text">
<p>I want to define a function using explicit argument names <code>ff(a,b,c)</code> in the function definition, but I also want to map a function over all arguments to get a list:</p>
<pre><code>ff(a,b,c):
    return list(map(myfunc,[a,b,c]))
</code></pre>
<p>However, I don't want to explicitly write parameter names inside function as a,b,c. I want to do it like</p>
<pre><code>ff(a,b,c):
    return list(map(myfunc,getArgValueList()))
</code></pre>
<p><code>getArgValueList()</code> will retrieve the argument values in order and form a list. How to do this? Is there a built-in function like <code>getArgValueList()</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>What you're trying to do is impossible without ugly hacks. You either take <code>*args</code> and get a sequence of parameter values that you can use as <code>args</code>:</p>
<pre><code>def ff(*args):
    return list(map(myfunc, args))
</code></pre>
<p>… or you take three explicit parameters and use them by name:</p>
<pre><code>def ff(a, b, c):
    return list(map(myfunc, (a, b, c)))
</code></pre>
<p>… but it's one or the other, not both.</p>
<p>Of course you can put those values in a sequence yourself if you want:</p>
<pre><code>def ff(a, b, c):
    args = a, b, c
    return list(map(myfunc, args))
</code></pre>
<p>… but I'm not sure what that buys you.</p>
<hr/>
<p>If you really want to know how to write a <code>getArgValueList</code> function anyway, I'll explain how to do it. However, if you're looking to make your code more readable, more efficient, more idiomatic, easier to understand, more concise, or almost anything else, it will have the exact opposite effect. The only reason I could imagine doing something like this is if you had to generate functions dynamically or something—and even then, I can't think of a reason you couldn't just use <code>*args</code>. But, if you insist:</p>
<pre><code>def getArgValueList():
    frame = inspect.currentframe().f_back
    code = frame.f_code
    vars = code.co_varnames[:code.co_argcount]
    return [frame.f_locals[var] for var in vars]
</code></pre>
<p>If you want to know how it works, most of it's in the <a href="https://docs.python.org/3/library/inspect.html" rel="nofollow noreferrer"><code>inspect</code></a> module docs:</p>
<ul>
<li><code>currentframe()</code> gets the current frame—the frame of <code>getArgValueList</code>.</li>
<li><code>f_back</code> gets the parent frame—the frame of whoever called <code>getArgValueList</code>.</li>
<li><code>f_code</code> gets the code object compiled from the function body of whoever called <code>getArgValueList</code>.</li>
<li><code>co_varnames</code> is a list of all local variables in that body, starting with the parameters.</li>
<li><code>co_argcount</code> is a count of explicit positional-or-keyword parameters.</li>
<li><code>f_locals</code> is a dict with a copy of the <code>locals()</code> environment of the frame.</li>
</ul>
<p>This of course only works for a function that takes no <code>*args</code>, keyword-only args, or <code>**kwargs</code>, but you can extend it to work for them as well with a bit of work. (See <code>co_kwonlyargcount</code>, <code>co_flags</code>, <code>CO_VARARGS</code>, and <code>CO_VARKEYWORDS</code> for details.)</p>
<p>Also, this only works for CPython, not most other interpreters. and it could break in some future version, because it's pretty blatantly relying on implementation details of the interpreter.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/tutorial/controlflow.html#arbitrary-argument-lists" rel="nofollow noreferrer"><code>*args</code> construction</a> will give you the arguments as a list:</p>
<pre><code>&gt;&gt;&gt; def f(*args): return list(map(lambda x:x+1, args))
&gt;&gt;&gt; f(1,2,3)
[2, 3, 4]
</code></pre>
<p>If you are bound with the signature of <code>f</code>, you'll have to use the <code>inspect</code> module:</p>
<pre><code>import inspect

def f(a, b,c):
    f_locals = locals()
    values = [f_locals[name] for name in inspect.signature(f).parameters]
    return list(map(lambda x:x+1, values))
</code></pre>
<p><code>inspect.signature(f).parameters</code> gives you the list of arguments in the correct order. The values are in <code>locals()</code>.</p>
</div>
<span class="comment-copy">Use <code>*args</code> as the parameter.</span>
<span class="comment-copy">@Code-Apprentice The OP said "I want to argument interface to be explict. That is explict write argument names as <code>ff(a,b,c)</code> when making function definition", and even edited the question to put that in bold after you made your comments on the answer, so… I think, even if maybe that's what the OP <i>should</i> want, it's not what the OP <i>does</i> want.</span>
<span class="comment-copy">@smci I don't think it is a duplicate. What the OP wants to do is to define a function with explicit parameters, but then get the args list anyway. That's an unusual thing to do, so it's not going to match the obvious dups involving varargs or splats, even if it looks like it at first glance.</span>
<span class="comment-copy">@PM2Ring This is even less idiomatic Java than Python. It's… maybe (pre-ES5) JavaScript, but really it feels more Perl than anything else.</span>
<span class="comment-copy">@abarnert Ok. I was just taking a guess at it being a Java thing, mostly from the camelCase function name (I don't write Java).</span>
<span class="comment-copy">Hi, @abarnert. Thank you so much for taking so much time answering. I learned a lot. But it seems that <code>getArgValueList</code> is not working properly. <code>getArgValueList(1,2,3)</code> gives <code>()</code> if I defined it as <code>def getArgValueList(a,b,c):</code></span>
<span class="comment-copy">@user15964 Why did you define it as <code>getArgValueList(a,b,c)</code>. You wanted a function that you can call as <code>getArgValueList()</code> from any function. That's what I gave you. And <a href="https://repl.it/repls/SnowHideousCarriers" rel="nofollow noreferrer">it works</a>. If randomly changing it into something different without understanding it doesn't work, that's not surprising.</span>
<span class="comment-copy">Oh, I am so sorry. My brain must ran into chaos previously. It indeed works. Thank you so much, and I decide to accept your answer, because you provide explicit <code>getArgValueList</code>. Though jferard's solution also works, it seems that it is not easy to construct <code>getArgValueList</code> via his approach.</span>
<span class="comment-copy">@user15964 Yes, Python makes it <i>possible</i> to do all kinds of clever things, but the ones that are usually too clever to be a good idea, it usually makes a bit unpleasant.</span>
<span class="comment-copy">Shouldn't it be <code>print(f(1, 2, 3))</code>?</span>
<span class="comment-copy">@Code-Apprentice @jferard Thank you so much. But actually I want the argument interface be explicit. So I must write <code>ff(a,b,c)</code></span>
<span class="comment-copy">@Code-Apprentice If should be <code>f(1,2,3)</code>, but also the function should be <code>list(map(lambda x:x+1, args))</code>.</span>
<span class="comment-copy">As written, this function doesn't take 3 arguments, it takes one argument that's a list of 3 elements. If you want to do that, you don't need splat at all—just <code>def f(lst): return list(map(lambda x: x+1, lst))</code>.</span>
<span class="comment-copy">@user15964 You have to write <code>ff(a,b,c)</code> when you call the function or when you define it?</span>
