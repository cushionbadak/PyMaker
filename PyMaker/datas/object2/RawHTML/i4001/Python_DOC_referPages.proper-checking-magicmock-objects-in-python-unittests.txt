<div class="post-text" itemprop="text">
<p>I have this code under test:</p>
<pre><code>def to_be_tested(x):
  return round((x.a + x.b).c())
</code></pre>
<p>In my unittest I want to assert that exactly this is done with the passed <code>x</code> and the result returned, so I pass a <code>MagicMock</code> object as <code>x</code>:</p>
<pre><code>class Test_X(unittest.TestCase):
  def test_x(self):
    m = unittest.mock.MagicMock()
    r = to_be_tested(m)
</code></pre>
<p>Then I check the result for being what I expect:</p>
<pre><code>    self.assertEqual(r._mock_new_name, '()')  # created by calling
    round_call = r._mock_new_parent
    self.assertEqual(round_call._mock_new_name, '__round__')
    c_result = round_call._mock_new_parent
    self.assertEqual(c_result._mock_new_name, '()')  # created by calling
    c_call = c_result._mock_new_parent
    self.assertEqual(c_call._mock_new_name, 'c')
    add_result = c_call._mock_new_parent
    self.assertEqual(add_result._mock_new_name, '()')  # created by calling
    add_call = add_result._mock_new_parent
    self.assertEqual(add_call._mock_new_name, '__add__')
    a_attribute = add_call._mock_new_parent
    b_attribute = add_call.call_args[0][0]
    self.assertEqual(a_attribute._mock_new_name, 'a')
    self.assertEqual(b_attribute._mock_new_name, 'b')
    self.assertIs(a_attribute._mock_new_parent, m)
    self.assertIs(b_attribute._mock_new_parent, m)
</code></pre>
<p>After importing <code>unittest.mock</code> I need to patch the internal structure of the <code>mock</code> module in order to be able to properly magic-mock the <code>round()</code> function (see <a href="https://stackoverflow.com/a/50329607/1281485">https://stackoverflow.com/a/50329607/1281485</a> for details on that):</p>
<pre><code>unittest.mock._all_magics.add('__round__')
unittest.mock._magics.add('__round__')
</code></pre>
<p>So, now, as I said, this works.  But I find it extremely unreadable.  Furthermore I needed to play around a lot to find the things like <code>_mock_new_parent</code> etc.  The underscore also indicates that this is a "private" attribute and shouldn't be used.  The documentation doesn't mention it.  It also does not mention another way of achieving what I try to.</p>
<p>Is there a nicer way to test returned <code>MagicMock</code> objects for being created the way they should have been?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are going overboard. You are testing the implementation, not the result. Moreover, you are reaching into internals of the mock implementation that you do not need to touch.</p>
<p>Test that you get the right result, and test that the result is based on the inputs you want to be used. You can set up the mock such that <code>round()</code> is passed an actual numeric value to round:</p>
<ul>
<li><code>x.a + x.b</code> results in a call to <code>m.a.__add__</code>, passing in <code>m.b</code>.</li>
<li><code>m.a.__add__().c()</code> is called, so we can test that it was called if that's needed.</li>
<li>Just set the result of <code>c()</code> to a number for <code>round()</code> to round off. Getting the correct <code>round(number)</code> result from the function means <code>.c()</code> was called.</li>
</ul>
<p>Passing in a number to <code>round()</code> is sufficient here, because you are <em>not testing the <code>round()</code> function</em>. You can rely on the Python maintainers to test that function, focus on testing your own code.</p>
<p>This is what I'd test:</p>
<pre><code>m = unittest.mock.MagicMock()

# set a return value for (x.a + *something*).c()
mock_c = m.a.__add__.return_value.c
mock_c.return_value = 42.4

r = to_be_tested(m)

mock_c.assert_called_once()
self.assertEqual(r, 42)
</code></pre>
<p>If you <em>must</em> assert that <code>m.a + m.b</code> took place, then you can add</p>
<pre><code>m.a.__add__.assert_called_once(m.b)
</code></pre>
<p>but the <code>mock_c</code> call assert passing is already proof that at least a <code>(m.a + &lt;whatever&gt;)</code> expression took place and that <code>c</code> was accessed on the result.</p>
<p>If you <em>must</em> validate that <code>round()</code> was used on an actual mock instance, you'll have to stick to patching the <code>MagicMock</code> class to include <code>__round__</code> as a special method and remove the <code>mock_c.return_value</code> assignment, after which you can assert that the return value is the correct object with</p>
<pre><code># assert that the result of the `.c()` call has been passed to the
# round() function (which returns the result of `.__round__()`).
self.assertIs(r, mock_c.return_value.__round__.return_value)
</code></pre>
<p>Some further notes:</p>
<ul>
<li>There is no point in trying to make everything a mock object. If the code under test is supposed to work on standard Python types, just have your mocks produce those types. E.g. if some call is expected to produce a string, have your mock return a test string, especially when you are then passing stuff to other standard-library APIs.</li>
<li>Mocks are singletons. You do not need to work back from a given mock to test that they have the right parent, because you can reach the same object by traversing the parent attributes and then use <code>is</code>. E.g. if a function returns the a mock object somewhere, you can assert that the <em>right</em> mock object was returned by testing <code>assertIs(mock_object.some.access.return_value.path, returned_object)</code>.</li>
<li>When a mock is called, that fact is recorded. You can assert this with the <code>assert_called*</code> methods, the <code>.called</code> and <code>.call_count</code> attributes, and traverse the result of calls with the <code>.return_value</code> attributes</li>
<li><p>When in doubt, inspect the <code>.mock_calls</code> attribute to see what the code-under-test has accessed. Or do so in an interactive session. For example, it's easier to see what <code>m.a + m.b</code> does in a quick test with:</p>
<pre><code>&gt;&gt;&gt; from unittest import mock
&gt;&gt;&gt; m = mock.MagicMock()
&gt;&gt;&gt; m.a + m.b
&lt;MagicMock name='mock.a.__add__()' id='4495452648'&gt;
&gt;&gt;&gt; m.mock_calls
[call.a.__add__(&lt;MagicMock name='mock.b' id='4495427568'&gt;)]
</code></pre></li>
</ul>
</div>
<span class="comment-copy">Right, but your proposition is that it doesn't make sense to test the implementation.  That's not true in all cases.  If you happen to have to refactor some code which does things nobody clearly understands (anymore) but which must not change due to the refactoring, just testing that the things done effectively (without understanding why) might make sense.  I'd love to be able to use the <code>MagicMocks</code> in this case.  Of course, in normal situations it makes perfect sense to understand what the code does and test it on a higher level (check the meaning of the results).</span>
<span class="comment-copy">@Alfe: if your <code>.c()</code> result is really a custom object <a href="https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types" rel="nofollow noreferrer">emulates a numeric type</a>, you'd have separate tests for the numeric type hooks. I'd still stick to the above test; this is not the place to test if <code>round()</code> will work on your custom type.</span>
<span class="comment-copy">Actually I only want to make sure that it gets <i>called</i> with my "something" as parameter (and don't want to figure out what that something is, actually, just to be able to write the test case).  Sure, testing <code>round()</code> is not the issue here.</span>
<span class="comment-copy">@Alfe: so above, the 'something' is whatever <code>mock_c.return_value</code> is set to.</span>
<span class="comment-copy">I want e. g. to have a unittest which shows that a refactorer replaced the call of <code>round()</code> by <code>trunc(x+0.5)</code> or similar.  Of course, these examples here make only limited sense.  I think in my actual (not so mcve-like) case this would be a useful use of a <code>MagicMock</code>.</span>
