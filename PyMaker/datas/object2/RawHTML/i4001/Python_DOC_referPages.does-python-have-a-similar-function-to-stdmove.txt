<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; cache = {}
&gt;&gt;&gt; cache['1'] = 'long string'
&gt;&gt;&gt; cache['2'] = 'very long string'
&gt;&gt;&gt; buffer = {}
&gt;&gt;&gt; buffer['1'] = cache['1']
&gt;&gt;&gt; del cache['1']
&gt;&gt;&gt; buffer['2'] = cache['2']
&gt;&gt;&gt; del cache['2']
&gt;&gt;&gt; cache
{}
&gt;&gt;&gt; buffer
{'1': 'long string', '2': 'very long string'}
</code></pre>
<p>I have two large dictionaries(i.e. cache and buffer). Periodically, I need to move the content from <code>cache</code> to <code>buffer</code> and delete the copied item from <code>cache</code>.</p>
<p>Does Python offer similar function to C++11 std::move so that I don't have to make an extra copy of the item which will be removed later?</p>
<p>Updated based on comments from @JETM</p>
<pre><code>&gt;&gt;&gt; cache = {}
&gt;&gt;&gt; cache['1'] = 'long string2'
&gt;&gt;&gt; buffer['1'] = cache['1']
&gt;&gt;&gt; id(buffer['1'])
139639957636576
&gt;&gt;&gt; id(cache['1'])
139639957636576
&gt;&gt;&gt; del cache['1']
&gt;&gt;&gt; id(buffer['1'])
139639957636576
</code></pre>
<p>It looks like the value of cache['1'] is NOT copied into buffer['1'].</p>
</div>
<div class="post-text" itemprop="text">
<p>In this particular case, you could use <a href="https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types" rel="nofollow noreferrer"><code>dict.pop</code></a>:</p>
<pre><code>buffer['1'] = cache.pop('1')
</code></pre>
<p>It's worth noting, though, that in Python objects are more synonymous with pointers; that is, when you perform this copy, no data gets duplicated, you're just adding a reference to the object in <code>buffer</code> and removing a reference to it from <code>cache</code>. That is, only the <em>pointer</em> is getting copied.</p>
</div>
<span class="comment-copy">Can't you use pop for that? <a href="https://www.tutorialspoint.com/python/list_pop.htm" rel="nofollow noreferrer">tutorialspoint.com/python/list_pop.htm</a></span>
<span class="comment-copy"><code>cache['1']</code> and <code>cache['2']</code> are not copied.</span>
<span class="comment-copy">You're only copying the references; you're not actually copying the string contents. It is not expensive to copy a reference to a long string.</span>
<span class="comment-copy">@q0987 In most cases, the contents of a file are a string (or a <code>bytes</code>, which behaves similarly), unless you're talking about the file object (what gets returned from <code>open(...)</code>). In either case, no data gets copied, since Python has no implicit way to refer to the underlying object; you only have references, so you can only copy/make more references. The exception to that rule is the <code>copy</code> module, which allows you to explicitly duplicate underlying objects into a new location in memory.</span>
<span class="comment-copy">@q0987 same thing. In case you were confused by the python <code>del</code>/C++ <code>delete</code> similarity - their functions are not the same. Python uses GC and has no explicit memory control and the created objects are deleted only then GC decides that no one uses them. It's not unique to Python and same behavior can be found in a variety of languages.</span>
