<div class="post-text" itemprop="text">
<p>Suppose I have a list:</p>
<pre><code>l=['a','b','c']
</code></pre>
<p>And its suffix list:</p>
<pre><code>l2 = ['a_1', 'b_1', 'c_1']
</code></pre>
<p>I'd like the desired output to be:</p>
<pre><code>out_l = ['a','a_1','b','b_2','c','c_3']
</code></pre>
<p>The result is the interleaved version of the two lists above.</p>
<p>I can write regular <code>for</code> loop to get this done, but I'm wondering if there's a more Pythonic way (e.g., using list comprehension or lambda) to get it done.</p>
<p>I've tried something like this:</p>
<pre><code>list(map(lambda x: x[1]+'_'+str(x[0]+1), enumerate(a)))
# this only returns ['a_1', 'b_2', 'c_3']
</code></pre>
<p>Furthermore, what changes would need to be made for the general case i.e., for 2 or more lists where <code>l2</code> is not necessarily a derivative of <code>l</code>?</p>
</div>
<div class="post-text" itemprop="text">
<h3><a href="https://docs.python.org/3/reference/expressions.html#yield-expressions" rel="noreferrer"><code>yield</code></a></h3>
<p>You can use a generator for an elegant solution. At each iteration, yield <em>twice</em>—once with the original element, and once with the element with the added suffix.</p>
<p>The generator will need to be exhausted; that can be done by tacking on a <code>list</code> call at the end.</p>
<pre><code>def transform(l):
    for i, x in enumerate(l, 1):
        yield x
        yield f'{x}_{i}'  # {}_{}'.format(x, i)
</code></pre>
<p>You can also re-write this using the <code>yield from</code> syntax for generator delegation:</p>
<pre><code>def transform(l):
    for i, x in enumerate(l, 1):
        yield from (x, f'{x}_{i}') # (x, {}_{}'.format(x, i))
</code></pre>
<p></p>
<pre><code>out_l = list(transform(l))
print(out_l)
['a', 'a_1', 'b', 'b_2', 'c', 'c_3']
</code></pre>
<p>If you're on versions older than python-3.6, replace <code>f'{x}_{i}'</code> with <code>'{}_{}'.format(x, i)</code>.</p>
<p><strong>Generalising</strong><br/>
Consider a general scenario where you have N lists of the form:</p>
<pre><code>l1 = [v11, v12, ...]
l2 = [v21, v22, ...]
l3 = [v31, v32, ...]
...
</code></pre>
<p>Which you would like to interleave. These lists are not necessarily derived from each other.</p>
<p>To handle interleaving operations with these N lists, you'll need to iterate over pairs:</p>
<pre><code>def transformN(*args):
    for vals in zip(*args):
        yield from vals

out_l = transformN(l1, l2, l3, ...)
</code></pre>
<hr/>
<h3>Sliced <code>list.__setitem__</code></h3>
<p>I'd recommend this from the perspective of performance. First allocate space for an empty list, and then assign list items to their appropriate positions using sliced list assignment. <code>l</code> goes into even indexes, and <code>l'</code> (<code>l</code> modified) goes into odd indexes. </p>
<pre><code>out_l = [None] * (len(l) * 2)
out_l[::2] = l
out_l[1::2] = [f'{x}_{i}' for i, x in enumerate(l, 1)]  # [{}_{}'.format(x, i) ...]
</code></pre>
<p></p>
<pre><code>print(out_l)
['a', 'a_1', 'b', 'b_2', 'c', 'c_3']
</code></pre>
<p>This is consistently the fastest from my timings (below).</p>
<p><strong>Generalising</strong><br/>
To handle N lists, iteratively assign to slices. </p>
<pre><code>list_of_lists = [l1, l2, ...]

out_l = [None] * len(list_of_lists[0]) * len(list_of_lists)
for i, l in enumerate(list_of_lists):
    out_l[i::2] = l
</code></pre>
<hr/>
<h3><a href="https://docs.python.org/3/library/functions.html#zip" rel="noreferrer"><code>zip</code></a> + <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="noreferrer"><code>chain.from_iterable</code></a></h3>
<p>A functional approach, similar to @chrisz' solution. Construct pairs using <code>zip</code> and then flatten it using <code>itertools.chain</code>.</p>
<pre><code>from itertools import chain
# [{}_{}'.format(x, i) ...]
out_l = list(chain.from_iterable(zip(l, [f'{x}_{i}' for i, x in enumerate(l, 1)]))) 
</code></pre>
<p></p>
<pre><code>print(out_l)
['a', 'a_1', 'b', 'b_2', 'c', 'c_3']
</code></pre>
<p><code>iterools.chain</code> is widely regarded as the pythonic list flattening approach.</p>
<p><strong>Generalising</strong><br/>
This is the simplest solution to generalise, and I suspect the most efficient for multiple lists when N is large.</p>
<pre><code>list_of_lists = [l1, l2, ...]
out_l = list(chain.from_iterable(zip(*list_of_lists)))
</code></pre>
<hr/>
<h3><strong>Performance</strong></h3>
<p>Let's take a look at some perf-tests for the simple case of two lists (one list with its suffix). General cases will not be tested since the results widely vary with by data.</p>
<pre><code>from timeit import timeit

import pandas as pd
import matplotlib.pyplot as plt

res = pd.DataFrame(
       index=['ajax1234', 'cs0', 'cs1', 'cs2', 'cs3', 'chrisz', 'sruthiV'],
       columns=[10, 50, 100, 500, 1000, 5000, 10000, 50000, 100000],
       dtype=float
)

for f in res.index: 
    for c in res.columns:
        l = ['a', 'b', 'c', 'd'] * c
        stmt = '{}(l)'.format(f)
        setp = 'from __main__ import l, {}'.format(f)
        res.at[f, c] = timeit(stmt, setp, number=50)

ax = res.div(res.min()).T.plot(loglog=True) 
ax.set_xlabel("N"); 
ax.set_ylabel("time (relative)");

plt.show()
</code></pre>
<p><a href="https://i.stack.imgur.com/PZO8w.png" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/PZO8w.png"/></a></p>
<h3><strong>Functions</strong></h3>
<pre><code>def ajax1234(l):
    return [
        i for b in [[a, '{}_{}'.format(a, i)] 
        for i, a in enumerate(l, start=1)] 
        for i in b
    ]

def cs0(l):
    # this is in Ajax1234's answer, but it is my suggestion
    return [j for i, a in enumerate(l, 1) for j in [a, '{}_{}'.format(a, i)]]

def cs1(l):
    def _cs1(l):
        for i, x in enumerate(l, 1):
            yield x
            yield f'{x}_{i}'

    return list(_cs1(l))

def cs2(l):
    out_l = [None] * (len(l) * 2)
    out_l[::2] = l
    out_l[1::2] = [f'{x}_{i}' for i, x in enumerate(l, 1)]

    return out_l

def cs3(l):
    return list(chain.from_iterable(
        zip(l, [f'{x}_{i}' for i, x in enumerate(l, 1)]))
    )

def chrisz(l):
    return [
        val 
        for pair in zip(l, [f'{k}_{j+1}' for j, k in enumerate(l)]) 
        for val in pair
    ]

def sruthiV(l):
    return [ 
        l[int(i / 2)] + "_" + str(int(i / 2) + 1) if i % 2 != 0 else l[int(i/2)] 
        for i in range(0,2*len(l))
    ]
</code></pre>
<h3><strong>Software</strong></h3>
<p>System—Mac OS X High Sierra—2.4 GHz Intel Core i7<br/>
Python—3.6.0<br/>
IPython—6.2.1    </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a list comprehension like so:</p>
<pre><code>l=['a','b','c']
new_l = [i for b in [[a, '{}_{}'.format(a, i)] for i, a in enumerate(l, start=1)] for i in b]
</code></pre>
<p>Output:</p>
<pre><code>['a', 'a_1', 'b', 'b_2', 'c', 'c_3']
</code></pre>
<p>Optional, shorter method:</p>
<pre><code>[j for i, a in enumerate(l, 1) for j in [a, '{}_{}'.format(a, i)]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a>:</p>
<pre><code>[val for pair in zip(l, [f'{k}_{j+1}' for j, k in enumerate(l)]) for val in pair]
</code></pre>
<p>Output:</p>
<pre><code>['a', 'a_1', 'b', 'b_2', 'c', 'c_3']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's my simple implementation</p>
<pre><code>l=['a','b','c']
# generate new list with the indices of the original list
new_list=l + ['{0}_{1}'.format(i, (l.index(i) + 1)) for i in l]
# sort the new list in ascending order
new_list.sort()
print new_list
# Should display ['a', 'a_1', 'b', 'b_2', 'c', 'c_3']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you wanted to return <code>[["a","a_1"],["b","b_2"],["c","c_3"]]</code> you could write </p>
<pre><code>new_l=[[x,"{}_{}".format(x,i+1)] for i,x in enumerate(l)]
</code></pre>
<p>This isn't what you want, instead you want <code>["a","a_1"]+["b","b_2"]+["c","c_3"]</code>. This can be made from the result of the operation above using <code>sum()</code>; since you're summing lists you need to add the empty list as an argument to avoid an error. So that gives</p>
<pre><code>new_l=sum(([x,"{}_{}".format(x,i+1)] for i,x in enumerate(l)),[])
</code></pre>
<p>I don't know how this compares speed-wise (probably not well), but I find it easier to understand what's going on than the other list-comprehension based answers.</p>
</div>
<div class="post-text" itemprop="text">
<p>A very simple solution:</p>
<pre><code>out_l=[]
for i,x in enumerate(l,1):
    out_l.extend([x,f"{x}_{i}"])
</code></pre>
</div>
<span class="comment-copy">related: <a href="https://stackoverflow.com/q/7946798/4279">Interleaving two lists in Python</a> and <a href="https://stackoverflow.com/q/34756145/4279">Most pythonic way to interleave two strings</a></span>
<span class="comment-copy">I'd recommend the <code>yield</code> from the perspective of readability, simplicity, and maintenance, as it's unlikely this is going to be a major bottleneck. (Probably not high enough volume of data, probably not a performance critical app.) The generator is <i>extraordinarily</i> straightforward to understand. OP can go back and optimize if it turns out to be a problem. +1</span>
<span class="comment-copy">The answer is good, but the <code>f'{variable}'</code> syntax is legit amazing and new to me.  Thanks!</span>
<span class="comment-copy">@user1717828 I'm happy you learned something from this! They are called f-strings and are introduced for python-3.6+. Do take a look at <a href="https://docs.python.org/3/reference/lexical_analysis.html#formatted-string-literals" rel="nofollow noreferrer">this section of the docs</a> for more info. Happy learning!</span>
<span class="comment-copy">I don't understand the why <code>yield from</code>. Could you add more explanation for that please?</span>
<span class="comment-copy"><code>yield from</code> provides a slightly more compact syntax to do the same thing that two <code>yield</code> statements do - it <i>delegates</i> the yield process, so you don't need to write a loop over an iterable (or two yield statements as in this case).</span>
<span class="comment-copy">You could use a list comprehension instead of zip. Not sure which is faster though...</span>
<span class="comment-copy">If you look at the timings, this is faster than using a list comprehension.  Much faster.</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ How is it not what was asked? If <code>l==['a','b','c']</code> the result is <code>['a', 'a_1', 'b', 'b_2', 'c', 'c_3']</code> as required, and it avoids the use of a <code>for</code> loop.</span>
<span class="comment-copy">Eh sorry, didn't read past the first line. HOWEVER, calling sum() on a list is generally frowned upon, it's worse than a loop.</span>
