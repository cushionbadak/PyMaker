<div class="post-text" itemprop="text">
<p>Currently I am playing with Python performance, trying to speed up my programs (usually those which compute heuristics). I always used lists, trying not to get into <code>numpy</code> arrays.</p>
<p>But recently I've heard that Python has <a href="https://docs.python.org/3/library/array.html" rel="nofollow noreferrer"><strong><code>8.7. array — Efficient arrays of numeric values</code></strong></a> so I thought I would try that one.</p>
<p>I wrote a piece of code to measure an <code>array.count()</code> vs. a <code>list.count()</code>, as I use it in many places in my code:</p>
<pre><code>from timeit import timeit
import array

a = array.array('i', range(10000))
l = [range(10000)]


def lst():
    return l.count(0)


def arr():
    return a.count(0)


print(timeit('lst()', "from __main__ import lst", number=100000))
print(timeit('arr()', "from __main__ import arr", number=100000))
</code></pre>
<p>I was expecting a slight performance improvement when using <code>array</code>. Well, this is what happened:</p>
<pre><code>&gt; python main.py
0.03699162653848456
74.46420751473268
</code></pre>
<p>So, according to <code>timeit</code> the <code>list.count()</code> is 2013x faster than the <code>array.count()</code>. I definitely didn't expect that. So I've searched through SO, python docs etc. and the only thing I found was that the objects in array have to be first wrapped into <code>int</code>-s, so this could slow things down, but I was expecting this to happen when creating an <code>array.array</code>-instance, not when random accessing it (which I believe is what <code>.count()</code> does).</p>
<p>So where's the catch?</p>
<p>Am I doing something wrong?</p>
<p>Or maybe I shouldn't use standard arrays and go straight to <code>numpy.array</code>s?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><em>where's the catch?</em></p>
</blockquote>
<h2>The initial test, as proposed above does not compare apples to apples:</h2>
<p>not mentioning the <a class="post-tag" href="/questions/tagged/python-2.7" rel="tag" title="show questions tagged 'python-2.7'">python-2.7</a>, where <strong><code>range()</code></strong> creates indeed a RAM-allocated data-structure, whereas <strong><code>xrange()</code></strong> resembles a <a class="post-tag" href="/questions/tagged/python-3" rel="tag" title="show questions tagged 'python-3'">python-3</a> re-formulated object ( as seen below ) a <em>generator</em>-will never be comparable to whatever smart RAM-allocated data-structure.</p>
<pre><code>&gt;&gt;&gt; L_above_InCACHE_computing = [ range( int( 1E24 ) ) ]    # list is created
&gt;&gt;&gt; L_above_InCACHE_computing.count( 0 )                    # list has no 0 in
0
&gt;&gt;&gt; L_above_InCACHE_computing.count( range( int( 1E24 ) )  )# list has this in
1
</code></pre>
<hr/>
<p>The generator's object intrinsic <strong><code>.__len__()</code></strong> spits out the length, where still no counting takes place, does it?<sub> ( glad it did not, <strong>it would not fit into even <code>~ 10^20 [TB]</code> of RAM ...</strong>, yet it can "live" in py3+ as an object ) </sub></p>
<pre><code>&gt;&gt;&gt; print( L[0].__doc__ )
range(stop) -&gt; range object
range(start, stop[, step]) -&gt; range object

Return an object that produces a sequence of integers from start (inclusive)
to stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.
start defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.
These are exactly the valid indices for a list of 4 elements.
When step is given, it specifies the increment (or decrement).
</code></pre>
<hr/>
<h2>Quantitatively fair testing? Better test engineering details are needed:</h2>
<p>Go well above a few tens of MB, so as to avoid false expectations from InCACHE-computing artifacts, that will never scale-out to real-world problem sizes:</p>
<pre><code>&gt;&gt;&gt; L_above_InCACHE_computing = [ range( int( 1E24 ) ) ]
&gt;&gt;&gt; L_above_InCACHE_computing[0]
range(0, 999999999999999983222784)

&gt;&gt;&gt; print( L_above_InCACHE_computing[0].__len__() )
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
OverflowError: Python int too large to convert to C ssize_t
</code></pre>
<p>Go into RAM-feasible, yet above InCACHE-horizon sizings:</p>
<pre><code># L_aRunABLE_above_InCACHE_computing = [ range( int( 1E9 ) ) ] # ~8+GB -&gt;array
# would have no sense to test 
# a benchmark on an array.array().count( something ) within an InCACHE horizon
</code></pre>
<hr/>
<blockquote>
<p><em>go straight to <strong><code>numpy</code></strong> arrays ?</em></p>
</blockquote>
<p>Definitely a wise step to test either. Vectorised internalities may surprise, and often do a lot :o)</p>
<p>Depends a lot on your other code, if numpy-strengths may even boost some other parts of your code-base. Last but not least, beware of premature optimisations and scaling. Some <strong><code>[TIME]</code></strong>-domain traps could be coped with if can spend more in <strong><code>[SPACE]</code></strong>-domain, yet most dangerous are lost InCACHE-locality, where no tradeoffs may help. So, better do not prematurely lock on promising detail, at a cost of loosing a global scale performance target.</p>
</div>
<span class="comment-copy">Is that <code>array</code> from <code>import array</code> same as NumPy arrays?</span>
<span class="comment-copy">list vs array: <a href="https://stackoverflow.com/questions/176011/python-list-vs-array-when-to-use" title="python list vs array when to use">stackoverflow.com/questions/176011/…</a></span>
<span class="comment-copy">It also states, at the end of article, that arrays scale much better. On small test-cases, list can outperform array (like your case -10000). For the benchmark test on 10^7, array is the winner.</span>
<span class="comment-copy">You don't create the list correct. The list just ontains one element, <code>range(10000)</code></span>
<span class="comment-copy">But then the list is still two times as fast as the array</span>
<span class="comment-copy">Jesus Christ, you're right. I did create it with list comprehension now, and you're right again, array still like 2x slower than the list: <code>29.802288375514255 53.67833035401182</code></span>
<span class="comment-copy">@Frynio Once I fix your list comprehension bug (<code>lst = list(range(10000))</code>) I also see arrays being ~2.5x slower. But as @ user3666197 points out whether or not that is a problem in your situation depends on a lot of other factors. So I'll just quote Prof. Donald Knuth: "premature optimization is the root of all evil".</span>
