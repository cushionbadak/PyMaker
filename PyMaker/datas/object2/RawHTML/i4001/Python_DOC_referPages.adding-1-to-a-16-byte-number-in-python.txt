<div class="post-text" itemprop="text">
<p>A program I am trying to improve has the following code to add 1 to a 16-byte number in a <code>byterray</code>:</p>
<pre><code>for k in range(15, -1, -1):
    payload[k] = (payload[k] + 1) &amp; 0x0ff
    if payload[k]:
        break
</code></pre>
<p>So, it adds 1 to the last byte, handling overflow, and if the result is falseish (0x00), it proceeds and adds 1 to the byte before it, and otherwise it stops.</p>
<p>This seems like a kludge to me, and I'm trying to come up with something better, if not for performance or reliability, then at least for how it looks.</p>
<p>So far, I've got this, which yields the same results in my tests:</p>
<pre><code>hi,lo = struct.unpack('&gt;QQ', payload)
payload = struct.pack('&gt;QQ', hi, lo + 1)
</code></pre>
<p>I know that my code will fail after running at most 2^64 times, but I'm quite sure the code won't have to run more than a few hundred times for a single number, so the chance of anything more than the last couple of bytes changing is small.</p>
<p>Any suggestions about my intended improvement, of other/better ways to get the same result? Of course, if there is an easy fix for the 2^64 limitation, I'd love to see it!</p>
<p>Thank you.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can convert a <code>bytearray</code> directly to an integer with the <a href="https://docs.python.org/3/library/stdtypes.html#int.from_bytes" rel="nofollow noreferrer"><code>int.from_bytes()</code> method</a>, and back to a <code>bytes</code> object with <a href="https://docs.python.org/3/library/stdtypes.html#int.to_bytes" rel="nofollow noreferrer"><code>int.to_bytes()</code></a>:</p>
<pre><code>incremented = int.from_bytes(payload, 'big') + 1
try:
    payload = bytearray(incremented.to_bytes(len(payload), 'big'))
except OverflowError:
    # value won't fit into the payload, wrap round to 0
    payload = bytearray(len(payload))
</code></pre>
<p>I'm not sure what should happen when you hit the upper limit; you could revert to <code>0</code> (<code>bytearray(len(payload))</code>), sticking to the old <code>(2 ** 128) - 1</code> value, or doing something else.</p>
</div>
<span class="comment-copy">I would say it's relatively safe to assume that you won't be limited by <code>2^64</code> haha</span>
<span class="comment-copy">16 bytes is 16 * 8 is 128 bits, so the upper limit is 2^128, not 2^64.</span>
<span class="comment-copy">@MartijnPieters My code only handles the bottom 8 bytes, 64 bits, because that is the biggest chunk struct.unpack can handle. At some point, the addition (lo + 1) will yield a 9 byte result and the call to struct.pack will fail.</span>
<span class="comment-copy">@TinuzZ: right, you could work around that by testing <code>lo</code>: <code>struct.pack('&gt;QQ', hi + (lo == (2**64) - 1), lo + (lo &lt; (2**64) - 1))</code>. Not that you need to use that at all, not with <code>int.from_bytes()</code> and <code>int.to_bytes()</code>.</span>
<span class="comment-copy">Thanks. Wrapping to 0 would probably the sanest thing to do, but this will never happen in practice.</span>
<span class="comment-copy">I tested this, and it seems to work. It's just that my bytearray is big endian (hence the <code>range(15, -1, -1)</code> in the original code), so I changed that.</span>
<span class="comment-copy">@TinuzZ: oops, of course it is! Sorry about that, corrected.</span>
<span class="comment-copy">Great. The biggest thing I learned here is that Python ints are not bound in size. I knew about <code>int.from_bytes()</code> before, but I incorrectly assumed that it wouldn't work on 128 bit values. Thank you!</span>
