<div class="post-text" itemprop="text">
<p>I'm working on a C extension and am at the point where I want to track down memory leaks.  From reading Python's documentation it's hard to understand when to increment / decrement reference count of Python objects.  Also, after couple days spending trying to embed Python interpreter (in order to compile the extension as a standalone program), I had to give up this endeavor.  So, tools like Valgrind are helpless here.</p>
<p>So far, by trial and error I learned that, for example, <code>Py_DECREF(Py_None)</code> is a bad thing... but is this true of any constant?  I don't know.</p>
<p>My major confusions so far can be listed like this:</p>
<ol>
<li>Do I have to decrement refcount on anything created by <code>PyWhatever_New()</code> if it doesn't outlive the procedure that created it?</li>
<li>Does every <code>Py_INCREF</code> need to be matched by <code>Py_DECREF</code>, or should there be one more of one / the other?</li>
<li>If a call to Python procedure resulted in a <code>PyObject*</code>, do I need to increment it to ensure that I can still use it (forever), or decrement it to ensure that eventually it will be garbage-collected, or neither?</li>
<li>Are Python objects created through C API on the stack allocated on stack or on heap?  (It is possible that <code>Py_INCREF</code> reallocates them on heap for example).</li>
<li>Do I need to do anything special to Python objects created in C code before passing them to Python code?  What if Python code outlives C code that created Python objects?</li>
<li>Finally, I understand that Python has both reference counting and garbage collector: if that's the case, how critical is it if I mess up the reference count (i.e. not decrement enough), will GC eventually figure out what to do with those objects?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Most of this is covered in <a href="https://docs.python.org/3/c-api/intro.html#reference-count-details" rel="nofollow noreferrer">Reference Count Details</a>, and the rest is covered in the docs on the specific questions you're asking about. But, to get it all in one place:</p>
<blockquote>
<p><code>Py_DECREF(Py_None)</code> is a bad thing... but is this true of any constant? </p>
</blockquote>
<p>The more general rule is that calling <code>Py_DECREF</code> on anything you didn't get a new/stolen reference to, and didn't call <code>Py_INCREF</code> on, is a bad thing. Since you never call <code>Py_INCREF</code> on anything accessible as a constant, this means you never call <code>Py_DECREF</code> on them.</p>
<blockquote>
<p>Do I have to decrement refcount on anything created by <code>PyWhatever_New()</code></p>
</blockquote>
<p>Yes. Anything that returns a "new reference" has to be decremented. By convention, anything that ends in <code>_New</code> should return a new reference, but it should be documented anyway (e.g., see <a href="https://docs.python.org/3/c-api/list.html#c.PyList_New" rel="nofollow noreferrer"><code>PyList_New</code></a>).</p>
<blockquote>
<p>Does every <code>Py_INCREF</code> need to be matched by <code>Py_DECREF</code>, or should there be one more of one / the other?</p>
</blockquote>
<p>The number in your own code may not necessarily balance. The <em>total</em> number has to balance, but there are increments and decrements happening inside Python itself. For example, anything that returns a "new reference" has already done an inc, while anything that "steals" a reference will do the dec on it.</p>
<blockquote>
<p>Are Python objects created through C API on the stack allocated on stack or on heap? (It is possible that Py_INCREF reallocates them on heap for example).</p>
</blockquote>
<p>There's no way to create objects through C API on the stack. The C API only has functions that return pointers to objects.</p>
<p>Most of these objects are allocated on the heap. Some are actually in static memory. </p>
<p>But your code should not care anyway. You never allocate or delete them; they get allocated in the <code>PySpam_New</code> and similar functions, and deallocate themselves when you <code>Py_DECREF</code> them to 0, so it doesn't matter to you where they are.</p>
<p>(The except is constants that you can access via their global names, like <code>Py_None</code>. Those, you obviously know are in static storage.)</p>
<blockquote>
<p>Do I need to do anything special to Python objects created in C code before passing them to Python code?</p>
</blockquote>
<p>No.</p>
<blockquote>
<p>What if Python code outlives C code that created Python objects?</p>
</blockquote>
<p>I'm not sure what you mean by "outlives" here. Your extension module is not going to get unloaded while any objects depend on its code. (In fact, until at least 3.8, your module probably never going to get unloaded until shutdown.)</p>
<p>If you just mean the function that <code>_New</code>'d up an object returning, that's not an issue. You have to go very far out of your way to allocate any Python objects on the stack. And there's no way to pass things like a C array of objects, or a C string, into Python code without converting them to a Python tuple of objects, or a Python bytes or str. There are a few cases where, e.g., you could stash a pointer to something on the stack in a <code>PyCapsule</code> and pass that—but that's the same as in any C program, and… just don't do it.</p>
<blockquote>
<p>Finally, I understand that Python has both reference counting and garbage collector</p>
</blockquote>
<p>The garbage collector is just a cycle breaker. If you have objects that are keeping each other alive with a reference cycle, you can rely on the GC. But if you've leaked references to an object, the GC will never clean it up.</p>
</div>
<span class="comment-copy">Every time you see "borrowed" in the documentation and need the object to live longer than a few microseconds.</span>
<span class="comment-copy">You may find it a whole lot easier to use <a href="http://cxx.sourceforge.net/PyCXX-Python3.html#h2_no_pointers" rel="nofollow noreferrer">a C++ library like PyCXX</a> than the raw C API.</span>
<span class="comment-copy">Anyway, have you read <a href="https://docs.python.org/3/c-api/intro.html#reference-count-details" rel="nofollow noreferrer">Reference Count Details</a> in the docs? Because some of what you're asking is directly answered there. And, while I love learning by segfault, it's usually easier to read the docs too.</span>
<span class="comment-copy">@abarnert I remember these examples, but not sure if I seen them in this article. I'll re-read it tomorrow. The major problem is the bogus terminology it uses. For instance "borrowed" says nothing to anyone who's not Python maintainer.  If they wanted to make it legible to other developers they had to phrase it in terms of "must increment / decrement".</span>
<span class="comment-copy">@abarnert I passionately hate C++, so using PyCXX is not an option. I'd rather kill myself by writing it in Assembly or Fortran than live in C++ induced pain.</span>
<span class="comment-copy"><i>Since you never call Py_INCREF on anything accessible as a constant</i> - what about numbers? <code>PyLong_FromLong()</code> for example? It may return a constant, or may return a transient object.  How do I know when it's the one or the other?</span>
<span class="comment-copy"><i>I'm not sure what you mean by "outlives"</i> It is the situation when C code created a Python object. Called Python function, then Python function stored the reference to the object elsewhere (perhaps class field), then Python function exited, then C function exited (but the class instance that has the reference to previously passed value still exists.</span>
<span class="comment-copy">@wvxvw Honestly, it’s starting to feel like you’re more interested in arguing that it’s impossible even though every other C extension in the world does it. It’s as simple as it looks, no hidden gotchas, just a lot of manual refcounting that we all sometimes get wrong for the same stupid reasons we get malloc and free wrong, and debugging it isn’t significantly different. Honestly, if you can’t use Cython, it really is a lot easier to use C++ or Rust or some other language with helpers to do all this crap for you, but if you hate that idea, the only other choice is to buckle down and write it.</span>
<span class="comment-copy">@wvxvw Stop focusing on “Python code gets GC’ed”. The GC (cycle detector) almost never enters into it. Python does an incref every time a value is stored in a namespace or an explicit collection, it does a decref every time a value is removed from one, and the object only gets deleted if the decref drops it to 0. If you called incref an extra time and held onto a pointer somewhere, it’s not going to drop to 0 until you decref if. And yes, if you decref it to 0 before passing it to Python, it’s already been destroyed in that decref call, so you’re passing a pointer to garbage.</span>
<span class="comment-copy">@wvxvw Maybe this will make it clearer: the only way an object ever gets destroyed is someone (you, the interpreter loop handling a <code>del</code>, some other object being destroyed that holds a reference, the shutdown logic, etc.) calls decref and that brings the refcounts to 0.  There is no other way to call the destructor besides decref. It’s the same as every other ref counting system.</span>
