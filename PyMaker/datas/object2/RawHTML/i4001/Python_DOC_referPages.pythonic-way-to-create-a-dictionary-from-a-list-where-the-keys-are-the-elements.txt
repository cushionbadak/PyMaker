<div class="post-text" itemprop="text">
<p>Considering that I have two lists like:</p>
<pre><code>l1 = ['a', 'c', 'b', 'e', 'f', 'd']
l2 = [
    'x','q','we','da','po',
    'a', 'el1', 'el2', 'el3', 'el4',
    'b', 'some_other_el_1', 'some_other_el_2',
    'c', 'another_element_1', 'another_element_2',
    'd', '', '', 'another_element_3', 'd4'
]
</code></pre>
<p>and I need to create a dictionary where the keys are those element from second list that are found in the first and values are lists of elements found between "keys" like:</p>
<pre><code>result = {
    'a': ['el1', 'el2', 'el3', 'el4'],
    'b': ['some_other_el_1', 'some_other_el_2'],
    'c': ['another_element_1', 'another_element_2'],
    'd': ['', '', 'another_element_3', 'd4']
}
</code></pre>
<p>What's a more pythonic way to do this?</p>
<p>Currently I'm doing this :</p>
<pre><code># I'm not sure that the first element in the second list
# will also be in the first so I have to create a key
k = ''
d[k] = []
for x in l2:
    if x in l1:
        k = x
        d[k] = []
    else:
        d[k].append(x)
</code></pre>
<p>But I'm quite positive that this is not the best way to do it and it also doesn't looks nice :) </p>
<p>Edit:
I also have to mention that no list is necessary ordered and neither the second list must start with an element from the first one.</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't think you'll do much better if this is the most specific statement of the problem. I mean I'd do it this way, but it's not much better.</p>
<pre><code>import collections

d = collections.defaultdict(list)
k = ''

for x in l2:
    if x in l1:
        k = x
    else:
        d[k].append(x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For fun, you can also do this with <code>itertools</code> and 3rd party <code>numpy</code>:</p>
<pre><code>import numpy as np
from itertools import zip_longest, islice

arr = np.where(np.in1d(l2, l1))[0]
res = {l2[i]: l2[i+1: j] for i, j in zip_longest(arr, islice(arr, 1, None))}

print(res)

{'a': ['el1', 'el2', 'el3', 'el4'],
 'b': ['some_other_el_1', 'some_other_el_2'],
 'c': ['another_element_1', 'another_element_2'],
 'd': ['', '', 'another_element_3', 'd4']}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a version using <code>itertools.groupby</code>. It may or may not be more efficient than the plain version from your post, depending on how <code>groupby</code> is implemented, because the <code>for</code> loop has fewer iterations.</p>
<pre><code>from itertools import groupby
from collections import defaultdict, deque

def group_by_keys(keys, values):
    """
    &gt;&gt;&gt; sorted(group_by_keys('abcdef', [
    ...          1, 2, 3,
    ...     'b', 4, 5,
    ...     'd',
    ...     'a', 6, 7,
    ...     'c', 8, 9,
    ...     'a', 10, 11, 12
    ... ]).items())
    [('a', [6, 7, 10, 11, 12]), ('b', [4, 5]), ('c', [8, 9])]
    """
    keys = set(keys)
    result = defaultdict(list)
    current_key = None
    for is_key, items in groupby(values, key=lambda x: x in keys):
        if is_key:
            current_key = deque(items, maxlen=1).pop()  # last of items
        elif current_key is not None:
            result[current_key].extend(items)
    return result
</code></pre>
<p>This doesn't distinguish between keys that don't occur in <code>values</code> at all (like <code>e</code> and <code>f</code>), and keys for which there are no corresponding values (like <code>d</code>). If this information is needed, one of the other solutions might be better suited.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Updated ... Again</strong></p>
<p>I misinterpreted the question. If you are using large lists then list comprehensions are the way to go and they are fairly simple once you learn how to use them.</p>
<p>I am going to use two list comprehensions.</p>
<pre><code>idxs = [i for i, val in enumerate(l2) if val in l1] + [len(l2)+1]
res = {l2[idxs[i]]: list(l2[idxs[i]+1: idxs[i+1]]) for i in range(len(idxs)-1)}
print(res)
</code></pre>
<p>Results:</p>
<pre><code>{'a': ['el1', 'el2', 'el3', 'el4'],
 'b': ['some_other_el_1', 'some_other_el_2'],
 'c': ['another_element_1', 'another_element_2'],
 'd': ['', '', 'another_element_3', 'd4']}
</code></pre>
<p>Speed Testing for large lists:</p>
<pre><code>import collections


l1 = ['a', 'c', 'b', 'e', 'f', 'd']
l2 = [
    'x','q','we','da','po',
    'a', 'el1', 'el2', 'el3', 'el4', *(str(i) for i in range(300)),
    'b', 'some_other_el_1', 'some_other_el_2', *(str(i) for i in range(100)),
    'c', 'another_element_1', 'another_element_2', *(str(i) for i in range(200)),
    'd', '', '', 'another_element_3', 'd4'
]


def run_comp():
    idxs = [i for i, val in enumerate(l2) if val in l1] + [len(l2)+1]
    res = {l2[idxs[i]]: list(l2[idxs[i]+1: idxs[i+1]]) for i in range(len(idxs)-1)}


def run_other():
    d = collections.defaultdict(list)
    k = ''

    for x in l2:
        if x in l1:
            k = x
        else:
            d[k].append(x)


import timeit
print('For Loop:', timeit.timeit(run_other, number=1000))
print("List Comprehension:", timeit.timeit(run_comp, number=1000))
</code></pre>
<p>Results:</p>
<pre><code>For Loop: 0.1327093063242541
List Comprehension: 0.09343156142774986
</code></pre>
<p><strong><em>old stuff below</em></strong></p>
<p>This is rather simple with list comprehensions.</p>
<pre><code>{key: [val for val in l2 if key in val] for key in l1}
</code></pre>
<p>Results:</p>
<pre><code>{'a': ['a', 'a1', 'a2', 'a3', 'a4'],
 'b': ['b', 'b1', 'b2', 'b3', 'b4'],
 'c': ['c', 'c1', 'c2', 'c3', 'c4'],
 'd': ['d', 'd1', 'd2', 'd3', 'd4'],
 'e': [],
 'f': []}
</code></pre>
<p>The code below shows what is happening above.</p>
<pre><code>d = {}
for key in l1:
    d[key] = []
    for val in l2:
        if key in val:
            d[key].append(val)
</code></pre>
<p>The list comprehension / dictionary comprehension (First piece of code) is actually way faster. List comprehensions are creating the list in place which is much faster than walking through and appending to the list. Appending makes the program walk the list, allocate more memory, and add the data to the list which can be very slow for large lists.</p>
<p>References:</p>
<ul>
<li><a href="http://www.pythonforbeginners.com/basics/list-comprehensions-in-python" rel="nofollow noreferrer">http://www.pythonforbeginners.com/basics/list-comprehensions-in-python</a></li>
<li><a href="https://docs.python.org/3.6/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">https://docs.python.org/3.6/tutorial/datastructures.html#list-comprehensions</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>itertools.groupby</code>:</p>
<pre><code>import itertools
l1 = ['a', 'c', 'b', 'e', 'f', 'd']
l2 = ['x', 'q', 'we', 'da', 'po', 'a', 'el1', 'el2', 'el3', 'el4', 'b', 'some_other_el_1', 'some_other_el_2', 'c', 'another_element_1', 'another_element_2', 'd', '', '', 'another_element_3', 'd4']
groups = [[a, list(b)] for a, b in itertools.groupby(l2, key=lambda x:x in l1)]
final_dict = {groups[i][-1][-1]:groups[i+1][-1] for i in range(len(groups)-1) if groups[i][0]}
</code></pre>
<p>Output:</p>
<pre><code>{'a': ['el1', 'el2', 'el3', 'el4'], 'b': ['some_other_el_1', 'some_other_el_2'], 'c': ['another_element_1', 'another_element_2'], 'd': ['', '', 'another_element_3', 'd4']}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your code is readable, does the job and is reasonably efficient. There's no need to change much!</p>
<p>You could use more descriptive variable names and replace <code>l1</code> with a <a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow noreferrer">set</a> for faster lookup:</p>
<pre><code>keys = ('a', 'c', 'b', 'e', 'f', 'd')
keys_and_values = [
    'x','q','we','da','po',
    'a', 'el1', 'el2', 'el3', 'el4',
    'b', 'some_other_el_1', 'some_other_el_2',
    'c', 'another_element_1', 'another_element_2',
    'd', '', '', 'another_element_3', 'd4'
]

current_key = None
result = {}
for x in keys_and_values:
    if x in keys:
        current_key = x
        result[current_key] = []
    elif current_key:
        result[current_key].append(x)

print(result)
# {'a': ['el1', 'el2', 'el3', 'el4'],
#  'c': ['another_element_1', 'another_element_2'],
#  'b': ['some_other_el_1', 'some_other_el_2'],
#  'd': ['', '', 'another_element_3', 'd4']}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code> def find_index():
    idxs = [l2.index(i) for i in set(l1).intersection(set(l2))]
    idxs.sort()
    idxs+= [len(l2)+1]
    res = {l2[idxs[i]]: list(l2[idxs[i]+1: idxs[i+1]]) for i in range(len(idxs)-1)}
    return(res)
</code></pre>
<p>Comparison of methods, using justengel's test:<br/>
<strong>justengel</strong><br/>
     run_comp:     .455<br/>
     run_other:    .244<br/>
<strong>mkrieger1</strong><br/>
    group_by_keys: .160<br/>
<strong>me</strong><br/>
    find_index:    .068<br/></p>
<p>Note that my method ignores keys that don't appear <code>l2</code>, and doesn't handle cases where keys appear more than once in <code>l2</code>. Adding in empty lists for keys that don't appear in <code>l2</code> can be done by <code>{**res, **{key: [] for key in set(l1).difference(set(l2))}}</code>, which raises the time to .105.</p>
</div>
<div class="post-text" itemprop="text">
<p>Even cleaner than turning <code>l1</code> into a <code>set</code>, use the keys of the dictionary you're building. Like this</p>
<pre><code>d = {x: [] for x in l1}
k = None

for x in l2:
    if x in d:
        k = x
    elif k is not None:
        d[k].append(x)
</code></pre>
<p>This is because (in the worst case) your code would be iterating over all the values in <code>l1</code> for every value in <code>l2</code> on the <code>if x in l1:</code> line, because <a href="https://wiki.python.org/moin/TimeComplexity#list" rel="nofollow noreferrer">checking if a value is <code>in</code> a list takes linear time</a>. Checking if a value is <code>in</code> a dictionary's keys is constant time in the average case (<a href="https://wiki.python.org/moin/TimeComplexity#set" rel="nofollow noreferrer">same with <code>set</code>s</a>, as already <a href="https://stackoverflow.com/a/50356484/3064538">suggested by Eric Duminil</a>).</p>
<p>I set <code>k</code> to <code>None</code> and check for it because your code would've returned <code>d</code> with <code>'': ['x','q','we','da','po']</code>, which is presumably not what you want. This assumes <code>l1</code> can't contain <code>None</code>.</p>
<p>My solution also assumes it's okay for the resulting dictionary to contain keys with empty lists if there are items in <code>l1</code> that never appear in <code>l2</code>. If that's not okay, you can remove them at the end with</p>
<pre><code>final_d = {k: v for k, v in d.items() if v}
</code></pre>
</div>
<span class="comment-copy">Is <code>l2</code> always sorted?</span>
<span class="comment-copy">And will the other elements of <code>l2</code> always begin with the one in <code>l1</code> (so <code>a</code> in <code>a1</code>.)</span>
<span class="comment-copy">@zwer ... no. It is a list where I just append some elements so it isn't sorted.</span>
<span class="comment-copy">@CristianHarangus - So what happens with the elements <b>if</b> <code>l2</code> doesn't start with an element from <code>l1</code>?</span>
<span class="comment-copy">is the order in the values of the resulting dictionary of importance?</span>
<span class="comment-copy">There is a bug in this solution: if you have a sequence of more than one element appearing in <code>l1</code> then only the first element appears in the result and the other elements are discarded. I'd expect instead to find all these elements as separate keys, but, possibly, with empty lists as values. To do that you could have a <code>nonlocal</code> counter, the <code>key</code> function then becomes something like <code>counter += x in keys; return counter</code>.</span>
<span class="comment-copy">@Bakuriu I'm not sure I understand what you mean. Can you show an example?</span>
<span class="comment-copy">Try your function on something like <code>group_by_keys('abcdef', ['a', 'b', 1, 2, 3])</code>. The result is <code>{'a': [1,2,3]}</code> instead of the expected <code>{'a': [], 'b': [1,2,3]}</code></span>
<span class="comment-copy">@Bakuriu I see. Thanks for pointing it out.</span>
<span class="comment-copy">this is not what OP wants to do though.. It just looks like that because he is using a bad example. <i>"the keys are those element from second list that are found in the first and values are lists of elements found between "keys""</i></span>
<span class="comment-copy"><b>Except</b> this is not much faster, in fact it will be slower than OPs solution as you've replaced an <code>O(n)</code> problem with an <code>O(n²)</code> one. Not to mention that it doesn't perform what the OP is asking for.</span>
<span class="comment-copy">@Ev.Kounis ... yep ... due to fact that I'm a newbie here I posted a bad example. Edited later. Hope to be more clear now</span>
<span class="comment-copy">@Christian post an example where the correct keys do not <i>accidentaly coincide with the first letter of all of their values all of the time..</i></span>
<span class="comment-copy">@Ev.Kounis sorry for misinterpreting the question. I have updated my answer by using 2 list comprehensions.</span>
<span class="comment-copy">Even if it works fine, which code would you rather maintain? Yours or OP's?</span>
<span class="comment-copy">Downvoter: I'd be happy to hear constructive criticism!</span>
