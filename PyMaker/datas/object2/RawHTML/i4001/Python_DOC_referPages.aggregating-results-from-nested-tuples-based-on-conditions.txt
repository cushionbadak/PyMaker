<div class="post-text" itemprop="text">
<p>i have a nested tuple and i want to get a table with results, i'm trying to use comprehension on this but i'm not getting the best results.</p>
<pre><code>team = ((35, 'Team1'),(8, 'Team2'),(55, 'Team1'),(65, 'Team2'),(90, 'Team1'))
</code></pre>
<p>output example:</p>
<pre><code>       first  second totalgoals
team1    1      2        3
team2    1      1        2
</code></pre>
<p>Can anyone give me some help?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a dictionary comprehension:</p>
<pre><code>team = ((35, 'Team1'),(8, 'Team2'),(55, 'Team1'),(65, 'Team2'),(90, 'Team1'))
results = {a:[sum(c &lt; 45 and d == a for c, d in team), sum(c &gt;= 45 and d == a for c, d in team)] for a in set(d for _, d in team)} 
print('\tfirst  second totalgoals')
for a, [first, second] in results.items():
  print(f'{a}\t{first}\t{second}\t{first+second}')
</code></pre>
<p>Output:</p>
<pre><code>    first  second totalgoals
Team1   1   2   3
Team2   1   1   2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a pure Python dictionary-based solution:</p>
<pre><code>from operator import itemgetter

lst = ((35, 'Team1'),(8, 'Team2'),(55, 'Team1'),(65, 'Team2'),(90, 'Team1'))

teams = map(itemgetter(1), lst)
d = {team: dict.fromkeys(('first', 'second', 'total'), 0) for team in teams}

for minutes, team in lst:
    if minutes &lt;= 45:
        d[team]['first'] += 1
    else:
        d[team]['second'] += 1
    d[team]['total'] += 1
</code></pre>
<p>Result:</p>
<pre><code>print(d)  

{'Team1': {'first': 1, 'second': 2, 'total': 3},
 'Team2': {'first': 1, 'second': 1, 'total': 2}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can easily invert your flat goals list into a dictionary indexed by the team name and bracket the first and second half immediately so you don't have to do multiple iterations over your data, something like:</p>
<pre><code>import collections

team = ((35, 'Team1'), (8, 'Team2'), (55, 'Team1'), (65, 'Team2'), (90, 'Team1'))

team_goals = collections.defaultdict(lambda: [0, 0])  # save some time with a dict factory
for entry in team:
    team_goals[entry[1]][entry[0] &gt; 45] += 1
</code></pre>
<p>As to how this works - the <code>collections.defaultdict()</code> will call the passed factory (<code>lambda: [0, 0]</code>) to create a new key whenever a non-existent key is encountered so each team will start with a <code>[0, 0]</code> list as its value. Then, as we iterate over the data, all we need is a simple <code>entry[0] &gt; 45</code> check as an index selector - <a href="https://docs.python.org/3/library/stdtypes.html#boolean-values" rel="nofollow noreferrer">in this context</a>, it will be treated as an <code>int</code> producing <code>0</code> for <code>False</code> (hence the first half) and <code>1</code> for <code>True</code> (hence the second half) thus enabling us to select the proper index for increment.</p>
<p>This results with a nice dictionary whose keys are holding the team name while its value is essentially just a two-element list counting the goals in the first and the second half.</p>
<p>If you want to print the data, just use <a href="https://docs.python.org/3/library/stdtypes.html#str.format" rel="nofollow noreferrer"><code>str.format()</code></a> to get to your desired table look, something like:</p>
<pre><code>line_format = "{:&lt;8} {:^5} {:^6} {:^10}"
print(line_format.format("", "first", "second", "totalgoals"))
for t, g in team_goals.items():
    print(line_format.format(t, g[0], g[1], sum(g)))
</code></pre>
<p>Which will give you:</p>
<pre>         first second totalgoals
Team1      1     2        3     
Team2      1     1        2   </pre>
<p>As a bonus, for extra neatness, you can get the biggest string length of the <code>team_goals</code> keys and dynamically pad the left-hand side based on your team data.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're ok using third party libraries (pandas), which has the distinct advantage of actually displaying a table (which you could export to a variety of formats such as CSV, HTML, etc):</p>
<pre><code>In [1]:
df =  pd.DataFrame(list(team), columns=['Value', 'Team'])
df['Goal'] = np.where(df['Value'] &lt;= 45, 'first', 'second')
df = df.groupby('Goal')['Team'].value_counts().unstack(0)
df['totalgoals'] = df.sum(axis=1)
df

Out[1]:
Goal   first  second  totalgoals
Team                            
Team1      1       2           3
Team2      1       1           2
</code></pre>
</div>
<span class="comment-copy">How are your getting from you input to output? I don't see those numbers in your original tuples.</span>
<span class="comment-copy">What are the first and second column here?</span>
<span class="comment-copy">It's like a football match. First half (1 - 45th minute), second half (46th - 90th minute)</span>
<span class="comment-copy">Please decribe how you want the table be converted from the tuples. What does mean the first number in the tuple?</span>
<span class="comment-copy">Did one of the below solutions help? Feel free to accept one (tick on left), or ask for clarification.</span>
<span class="comment-copy">Can you please explain your <code>entry[0] &gt; 45</code> indexing trick?</span>
<span class="comment-copy">@jpp - Good suggestion, updated.</span>
<span class="comment-copy">Thanks - I haven't confirmed, but I think technically the reason it works is <code>Boolean</code> is a subclass of <code>int</code> (so no conversion required).</span>
<span class="comment-copy">@jpp - <code>bool</code> <b>is</b> <code>int</code> underneath but Python doesn't strictly prescribe it - it's perfectly possible to create a Python interpreter that has them as separate types. That being said, as per <a href="https://www.python.org/dev/peps/pep-0285/" rel="nofollow noreferrer">PEP 285</a>, Guido gives a good rationale why it should inherit from <code>int</code>. For the sake of clarity, they should be treated as different types, tho - that was the rationale of adding <code>bool</code> in the first place.</span>
