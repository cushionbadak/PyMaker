<div class="post-text" itemprop="text">
<p>I want to determine the imports of each python module in a library for use in a custom configuration management framework.  I've seen tools like <a href="http://furius.ca/snakefood/" rel="noreferrer">snakefood</a>, but I'd prefer to compute a dependency graph during normal program execution, instead of as a ~compilation step.</p>
<p>So far I've tried writing a custom <a href="https://docs.python.org/3/reference/import.html#finders-and-loaders" rel="noreferrer">Finder and Loader</a>.  Both approaches work as expected the first time a module is imported, but don't trigger on subsequent imports thanks to the <code>sys.modules</code> cache.</p>
<p>I can override <code>__built__.__import__</code> for notifications every time a module is imported, but it seems like this approach is ill-advised since <a href="https://www.python.org/dev/peps/pep-0302/" rel="noreferrer">PEP 302</a>.</p>
<p>Is there an import hook I can place in front of <code>sys.modules</code> cache lookups?  Or another way to quickly compute dependencies on the fly?</p>
</div>
<div class="post-text" itemprop="text">
<p>It's possible (if hacky) to reassign to <code>sys.modules</code>:</p>
<pre><code>import sys
import inspect

old_sys_modules = sys.modules

class NewSysModules():
  def __getitem__(self, mod_name):
    frame = inspect.currentframe().f_back
    while frame.f_globals["__name__"].startswith("importlib"):
      frame = frame.f_back # go back until we're not in a importlib frame
    importer = frame.f_globals["__name__"]
    print(f"importing {mod_name} from {importer}")

    return old_sys_modules[mod_name]

  def __setitem__(self, mod_name, module):
    old_sys_modules[mod_name] = module

sys.modules = NewSysModules()
</code></pre>
<p>However, this might require some maintenance if the import system changes.</p>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/4160746/creating-dependency-graphs-in-python">Creating Dependency Graphs in Python</a></span>
<span class="comment-copy">This is not a duplicate of the above. That question is looking for a call flow visualisation rather than a dependency graph and its accepted answer reflects that.</span>
<span class="comment-copy">Thanks!  I tweaked this approach slightly (e.g. extended <code>collections.MutableMapping</code>) and it seems to work for Python 3.  Unfortunately we're on Python 2 until Apache Beam upgrades.  If I try to override sys.modules in Python 2, I get notified when <code>multiprocessing</code> is imported by <code>logging</code>, but I don't get other notifications I would expect.  I'll investigate further and report back.</span>
