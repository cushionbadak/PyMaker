<div class="post-text" itemprop="text">
<p>Is there a way to write a replacement rule for a function f with an arbitrary number of arguments that makes it linear in all its arguments?
An example for when f has three arguments:</p>
<ol>
<li>f( x1+x4 , x2 , x3 ) = f(x4,x2,x3) + f(x1,x2,x3)</li>
<li>f( x1 , x2+x4 , x3 ) = f(x1,x2,x3) + f(x1,x4,x3)</li>
<li>f( x1 , x2 , x3+x4 ) = f(x1,x2,x3) + f(x1,x2,x4)</li>
</ol>
<p>Using "Wild" works partially:</p>
<pre><code>from sympy import *
f=Function('f')
var("x1:5")
a=Wild("a")
b=Wild("b")
A=Wild('A', exclude=[0])
B=Wild('B', exclude=[0])
expr=f(x1,x2+x4,x3);
print("This one works")
print expr , '-&gt;' , expr.replace(f(a,Add(A,B),b),f(a,A,b)+f(a,B,b))
# f(x1, x2 + x4, x3) -&gt; f(x1, x2, x3) + f(x1, x4, x3)
print("This one doesn't on the last entry")
expr=f(x1,x2,x3+x4);
print f(x1,x2,x3+x4) , '-&gt;' , expr.replace(f(a,Add(A,B),b),f(a,A,b)+f(a,B,b))
# f(x1, x2, x3 + x4) -&gt; f(x1, x2, x3 + x4)
</code></pre>
<p>I know I could iterate in a variety of ways over the arguments of the function while altering the replacement, but I was hoping the functionality was built into "Wild" or "replace" already. Mathematica, for example, has "wildcards" like "a___,b___,A___,B___" which mean that "a___" could be an empty sequence, or  a single argument, or a sequence of multiple arguments. For example, in Mathematica,</p>
<pre><code>expr /. f[a__,A_Plus,b__] :&gt; f[a,A[[1]],b]+f[a,A[[2;;]],b]
</code></pre>
<p>would correctly simplify both test cases, and for <code>f</code>'s with any number of arguments.</p>
<p>Is there something similar, or is this is close as sympy gets?</p>
<p>Alternatively, might this be possible to do with argument unpacking on a recursive definition starting from something like <code>def f(*args):</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of Wild matching, I would detect which arguments of f are Add and expand those using <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product</code></a></p>
<pre><code>import itertools
term_groups = [term.args if term.func is Add else (term,) for term in expr.args]
expanded = Add(*[expr.func(*args) for args in itertools.product(*term_groups)])
</code></pre>
<p>For example, if <code>expr</code> is <code>f(x1+x2+x4, x2+x4, x3*x1)</code>, then <code>term_groups</code> is <code>[(x1, x2, x4), (x2, x4), (x1*x3,)]</code> where the last argument yields a 1-element tuple since it's not an Add. And <code>expanded</code> is </p>
<pre><code>f(x1, x2, x1*x3) + f(x1, x4, x1*x3) + f(x2, x2, x1*x3) + f(x2, x4, x1*x3) + f(x4, x2, x1*x3) + f(x4, x4, x1*x3)
</code></pre>
</div>
