<div class="post-text" itemprop="text">
<pre><code>your_data = {'rose': 'red',
         'sun': 'orange',
         'sky': 'blue'}

with open('save.txt','w') as f:
while True:
    print(your_data, file=f)
</code></pre>
<p>This is an sample program. here the dictionaries are copied to the file named save.txt. Actually I am running this program in raspberry pi and if the power suddenly gets off, the datas stored completely gets erased. I want my program to start again from the previous end of the program or I should have an backup from where I can restart my program. </p>
</div>
<div class="post-text" itemprop="text">
<p>If your program terminates abruptly, buffered output might not make it from your program to the operating system. If power is cut, buffered output might not make it from the operating system to disk.</p>
<p>The first is handled with <a href="https://docs.python.org/3/library/io.html#io.IOBase.flush" rel="nofollow noreferrer">flush</a> on the file object, and the second by <a href="https://docs.python.org/3/library/os.html#os.fsync" rel="nofollow noreferrer">fsync</a> in the io module.</p>
<pre><code>f.flush()
os.fsync(f.fileno())
</code></pre>
<p>This is somewhat slow, of course. You can also use <code>open('file.txt', 'w', buffering=0)</code> to eliminate buffered IO and skip the need to flush (but you will still need to fsync).</p>
<p>(Even so, there are still no guarantees: Hard drives are known to report that a write has completed when it is actually on volatile storage inside the hard drive.)</p>
<p>How your program recovers after being interrupted is an entirely different matter. Perhaps it can read the output file to determine where it left off. (When resuming your writes, remember to use append <code>'a'</code> mode so as not to truncate your output file.)</p>
<p>Also try the <a href="https://docs.python.org/3/library/sqlite3.html" rel="nofollow noreferrer">sqlite3</a> module: The underlying SQLite database is robust against power failures.</p>
</div>
<span class="comment-copy">I'm thinking that this is impossible <code>if the power suddenly gets off</code>. I would love to be proved wrong.</span>
<span class="comment-copy">@quamrana surely it's not impossible? They could just store checkpoints into files whenever needed, then check that file for a specific checkpoint and run from there. Although i'm really not sure what they're asking so I may have misunderstood.</span>
<span class="comment-copy">@Jaxi: That would be my guess for a solution too, but just because python executes code which appends data to a file, how do you know it has been stored in the face of a power failure?</span>
<span class="comment-copy">@quamrana Raspberry Pi's operate on very low power which allows them to be powered by rather 'sketchy' power sources. Since it is such a small device it is highly portable and is often not used in stationary cases... this means that the power can quite often be disconnected.</span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/7127075/what-exactly-the-pythons-file-flush-is-doing" title="what exactly the pythons file flush is doing">stackoverflow.com/questions/7127075/…</a> <a href="https://stackoverflow.com/questions/3167494/how-often-does-python-flush-to-a-file" title="how often does python flush to a file">stackoverflow.com/questions/3167494/…</a></span>
<span class="comment-copy">Is there any documentation on SQLite which details this robustness against power failures?</span>
<span class="comment-copy">Not sure, I'd start browsing at <a href="https://sqlite.org/testing.html#crash_testing" rel="nofollow noreferrer">sqlite.org/testing.html#crash_testing</a></span>
<span class="comment-copy">Can you give me an example using my above example with f.flush() os.fsync(f.fileno()) because I could not Identify how I could use this method for dict.</span>
<span class="comment-copy"><code>f</code> is the file returned from <code>open()</code> as in your question.</span>
