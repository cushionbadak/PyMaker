<div class="post-text" itemprop="text">
<p>a follow-up question on <a href="https://stackoverflow.com/questions/50375793/elegant-way-to-have-an-almost-copy-constructor-that-allows-to-update-some-member">this question</a>: i ran the code below on python 3.5 and python 3.6 - with very different results:</p>
<pre><code>class Container:

    KEYS = ('a', 'b', 'c')

    def __init__(self, a=None, b=None, c=None):
        self.a = a
        self.b = b
        self.c = c

    def keys(self):
        return Container.KEYS

    def __getitem__(self, key):
        if key not in Container.KEYS:
            raise KeyError(key)
        return getattr(self, key)

    def __str__(self):
        # python 3.6
        # return f'{self.__class__.__name__}(a={self.a}, b={self.b}, c={self.c})'
        # python 3.5    
        return ('{self.__class__.__name__}(a={self.a}, b={self.b}, '
                'c={self.c})').format(self=self)

data0 = Container(a=1, b=2, c=3)
print(data0)

data3 = Container(**data0, b=7)
print(data3)
</code></pre>
<p>as stated in the previous question this raises</p>
<blockquote>
<p>TypeError: type object got multiple values for keyword argument 'b'</p>
</blockquote>
<p>on python 3.6. but on python 3.5 i get the exception:</p>
<blockquote>
<p>KeyError: 0</p>
</blockquote>
<p>moreover if i do not raise <code>KeyError</code> but just print out the <code>key</code> and <code>return</code> in <code>__getitem__</code>:</p>
<pre><code>def __getitem__(self, key):
    if key not in Container.KEYS:
        # raise KeyError(key)
        print(key)
        return
    return getattr(self, key)
</code></pre>
<p>this will print out the <code>int</code> sequence <code>0, 1, 2, 3, 4, ...</code>. (python 3.5)</p>
<p>so my questions are:</p>
<ul>
<li><p>what has changed between the releases that makes this behave so differently? </p></li>
<li><p>where are these integers coming from?</p></li>
</ul>
<hr/>
<p><strong>UPDATE</strong> : as mentioned in the comment by <a href="https://stackoverflow.com/users/6541288/%ce%bbuser">λuser</a>: implementing <code>__iter__</code> will change the behavior on python 3.5 to match what python 3.6 does:</p>
<pre><code>def __iter__(self):
    return iter(Container.KEYS)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is actually a complicated conflict between multiple internal operations during unpacking a custom mapping object and creating the caller's arguments. Therefore, if you wan to understand the underlying reasons thoroughly I'd suggest you to look into the source code. However, here are some hints and starting points that you can look into for greater details.</p>
<p>Internally, when you unpack at a caller level, the byte code <a href="https://docs.python.org/3/library/dis.html#opcode-BUILD_MAP_UNPACK_WITH_CALL" rel="nofollow noreferrer"><code>BUILD_MAP_UNPACK_WITH_CALL(count)</code></a> pops <em>count</em> mappings from the stack, merges them into a single dictionary and pushes the result. In other hand, the stack effect of this opcode with argument <code>oparg</code> <a href="https://github.com/python/cpython/blob/64fddc423fcbe90b8088446c63385ec0aaf3077c/Python/compile.c#L1003" rel="nofollow noreferrer"><em>is defined as following</em></a>:</p>
<pre><code>case BUILD_MAP_UNPACK_WITH_CALL:
    return 1 - oparg;
</code></pre>
<p>With that being said lets look at the byte codes of an example (in Python-3.5) to see this in action: </p>
<pre><code>&gt;&gt;&gt; def bar(data0):foo(**data0, b=4)
... 
&gt;&gt;&gt; 
&gt;&gt;&gt; dis.dis(bar)
  1           0 LOAD_GLOBAL              0 (foo)
              3 LOAD_FAST                0 (data0)
              6 LOAD_CONST               1 ('b')
              9 LOAD_CONST               2 (4)
             12 BUILD_MAP                1
             15 BUILD_MAP_UNPACK_WITH_CALL   258
             18 CALL_FUNCTION_KW         0 (0 positional, 0 keyword pair)
             21 POP_TOP
             22 LOAD_CONST               0 (None)
             25 RETURN_VALUE
&gt;&gt;&gt; 
</code></pre>
<p>As you can see, at offset 15 we have <code>BUILD_MAP_UNPACK_WITH_CALL</code> byte code which is responsible for the unpacking.</p>
<p>Now what happens that it returns 0 as the <code>key</code> argument to the <code>__getitem__</code> method?</p>
<p>Whenever the interpreter encounters an exception during unpacking, which in this case is a <code>KeyError</code>, It stops continuing the push/pop flow and instead of returning the real value of your variable it returns the stack effect which is why the key is 0 at first and if you don't handle the exception each time you get an incremented result (due to the stack size).</p>
<p>Now if you do the same disassembly in Python-3.6 you'll get the following result:</p>
<pre><code>&gt;&gt;&gt; dis.dis(bar)
  1           0 LOAD_GLOBAL              0 (foo)
              2 BUILD_TUPLE              0
              4 LOAD_FAST                0 (data0)
              6 LOAD_CONST               1 ('b')
              8 LOAD_CONST               2 (4)
             10 BUILD_MAP                1
             12 BUILD_MAP_UNPACK_WITH_CALL     2
             14 CALL_FUNCTION_EX         1
             16 POP_TOP
             18 LOAD_CONST               0 (None)
             20 RETURN_VALUE
</code></pre>
<p>Before creating the local variables (<code>LOAD_FAST</code>) and after <code>LOAD_GLOBAL</code> there is a <a href="https://docs.python.org/3/library/dis.html#opcode-BUILD_TUPLE" rel="nofollow noreferrer"><code>BUILD_TUPLE</code></a> which is responsible for creating a tuple and consuming count items from the stack.</p>
<blockquote>
<p>BUILD_TUPLE(count)</p>
<p>Creates a tuple consuming count items from the stack, and pushes the &gt;resulting tuple onto the stack.</p>
</blockquote>
<p>And this is, IMO, why you don't get a key error and instead you get <code>TypeError</code>. Because during the creation of a tuple of arguments it encounters a duplicate name and therefore, properly, returns the <code>TypeError</code>.</p>
</div>
<span class="comment-copy">i think your implementation is missing methods <code>__iter__</code> (returning keys) and <code>__len__</code>, then inherit from <a href="https://docs.python.org/3.5/library/collections.abc.html" rel="nofollow noreferrer"><code>collections.abc.Mapping</code></a> and you should be set. I guess Python doesn't know what are are the keys because you don't implement <code>__iter__</code>, so it tries some numbers in python 3.5.</span>
<span class="comment-copy">@λuser : you are correct! just implementing <code>__iter__</code> is enough in that case. the questions remain...</span>
