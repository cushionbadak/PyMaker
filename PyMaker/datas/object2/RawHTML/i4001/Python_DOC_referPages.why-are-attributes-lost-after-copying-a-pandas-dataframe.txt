<div class="post-text" itemprop="text">
<p>Why is it not possible to pass attributes of an instance through a copy? I want to pass the <code>name</code> attribute to another dataframe.</p>
<pre><code>import copy
df = pd.DataFrame([1,2,3])
df.name = 'sheet1'
df2 = copy.deepcopy(df)

print(f'df.name: {df.name}')
&gt;&gt; df.name: sheet1

print(f'df2.name: {df2.name}')
&gt;&gt;    AttributeError    
        ...      
      'DataFrame' object has no attribute 'name'
</code></pre>
<p>Similarly, why does this also not work, when creating a class and inheriting from it?</p>
<pre><code>class DfWithName(pd.DataFrame):

    def __init__(self, *args, **kwargs):
        self.__init__ = super().__init__(*args, **kwargs)
        print('lol')

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        self._name = value
</code></pre>
<p>and using the same code:</p>
<pre><code>import copy
df = DfWithName([1,2,3])
df.name = 'sheet1'
df2 = copy.deepcopy(df) 
print(f'df.name: {df2.name}')
&gt;&gt;    AttributeError    
        ...      
      'DataFrame' object has no attribute 'name'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As noted elsewhere, the <code>DataFrame</code> class has a custom <a href="https://github.com/pandas-dev/pandas/blob/587a0ddf99d71d3fa3643ab3c53249f2998a798b/pandas/core/generic.py#L5116" rel="nofollow noreferrer"><code>__deepcopy__</code></a> method which does not necessarily copy arbitrary attributes assigned to an instance, as with a normal object.</p>
<p>Interestingly, there is an internal <code>_metadata</code> attribute that seems intended to be able to list additional attributes of an <code>NDFrame</code> that should be kept when copying/serializing it.  This is discussed some here: <a href="https://github.com/pandas-dev/pandas/issues/9317" rel="nofollow noreferrer">https://github.com/pandas-dev/pandas/issues/9317</a></p>
<p>Unfortunately this is still considered an undocumented internal detail, so it probably shouldn't be used.  From looking at the code you can in principle do:</p>
<pre><code>mydf = pd.DataFrame(...)
mydf.name = 'foo'
mydf._metadata += ['name']
</code></pre>
<p>and when you copy it it should take the name with it.</p>
<p>You could subclass <code>DataFrame</code> to make this the default:</p>
<pre><code>import functools

class NamedDataFrame(pd.DataFrame):
    _metadata = pd.DataFrame._metadata + ['name']

    def __init__(self, name, *args, **kwargs):
        self.name = name
        super().__init__(*args, **kwargs)

    @property
    def _constructor(self):
        return functools.partial(self.__class__, self.name)
</code></pre>
<p>You could also do this without relying on this internal <code>_metadata</code> attribute if you provide your own wrapper to the existing <code>copy</code> method, and possibly also <code>__getstate__</code> and <code>__setstate__</code>.</p>
<p><strong>Update:</strong> It seems actually use of the <code>_metadata</code> attribute for extending Pandas classes is now <a href="https://github.com/pandas-dev/pandas/blob/3f3e92f08e0a1a13234acac6a9d8239968dcff0d/doc/source/extending.rst#define-original-properties" rel="nofollow noreferrer">documented</a>.  So the above example should more or less work. These docs are more for development of Pandas itself so it might still be a bit volatile. But this is how Pandas itself extends subclasses of <code>NDFrame</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/copy.html#copy.deepcopy" rel="nofollow noreferrer"><code>copy.deepcopy</code></a> will use a custom <code>__deepcopy__</code> method if it is found in the MRO, which may return whatever it likes (including completely bogus results).  Indeed dataframes implement a <code>__deepcopy__</code> method:</p>
<pre><code>def __deepcopy__(self, memo=None):
    if memo is None:
        memo = {}
    return self.copy(deep=True)
</code></pre>
<p>It delegates to <code>self.copy</code>, where you will find <a href="https://github.com/pandas-dev/pandas/blob/501f0418c00064f5041ef156ed5a2289a9064da3/pandas/core/generic.py#L5030-L5035" rel="nofollow noreferrer">this note in the docstring</a>:</p>
<pre><code>Notes
-----
When ``deep=True``, data is copied but actual Python objects
will not be copied recursively, only the reference to the object.
This is in contrast to `copy.deepcopy` in the Standard Library,
which recursively copies object data (see examples below).
</code></pre>
<p>And you will find in the <a href="https://github.com/pandas-dev/pandas/blob/3ff7541761cd95757e847fd304c0311c0471b8f1/doc/source/release.rst#pandas-0130" rel="nofollow noreferrer">v0.13 release notes</a> (merged in <a href="https://github.com/pandas-dev/pandas/pull/4039/files" rel="nofollow noreferrer">PR 4039</a>):</p>
<blockquote>
<p><code>__deepcopy__</code> now returns a shallow copy (currently: a view) of the data - allowing metadata changes.</p>
</blockquote>
<p>Related issue: <a href="https://github.com/pandas-dev/pandas/issues/17406" rel="nofollow noreferrer">17406</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Attaching custom metadata to DataFrames seems to be unsupported for pandas. See <a href="https://stackoverflow.com/q/14688306/6506482">this answer</a> (possible duplicate?) and <a href="https://github.com/pydata/pandas/issues/2485" rel="nofollow noreferrer">this github issue</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>This code is worked:</p>
<pre><code>&gt;&gt;&gt; class test():
...     @property
...     def name(self):
...         return self._name
...     @name.setter
...     def name(self, value):
...         self._name = value
...
&gt;&gt;&gt;
&gt;&gt;&gt; a = test()
&gt;&gt;&gt; a.name = 'Test123'
&gt;&gt;&gt; import copy
&gt;&gt;&gt; a2 = copy.deepcopy(a)
&gt;&gt;&gt; print(a2.name)
Test123
</code></pre>
<p>so I think that behavior is defined by <code>pd.DataFrame</code></p>
<p>I found that pandas define the function <code>__deepcopy__</code>, but I cannot totally understand the reason.</p>
<p><a href="https://github.com/pandas-dev/pandas/blob/a5c02d5c4225a90cda8ed7f328306bd9754d0f93/pandas/core/indexes/base.py#L960" rel="nofollow noreferrer">pandas/core/indexes/base.py#L960</a></p>
</div>
<span class="comment-copy">Perhaps I found a wrong dupe... The point is your new attribute only belongs to this specific instance, it's not recorded in the class level. Thus <code>copy</code> couldn't find it. <a href="https://docs.python.org/3.6/library/copy.html" rel="nofollow noreferrer">docs.python.org/3.6/library/copy.html</a></span>
<span class="comment-copy">@liliscent that's not exactly accurate.  For most instances <code>copy.deepcopy()</code> will copy its <code>__dict__</code> members, so if you assign some attribute to an instance, and then copy that instance, its attributes <i>will</i> be copied.  More likely, <code>DataFrame</code>, being a rather non-trivial class, probably has some custom serialization/deep-copy implementation that doesn't know about arbitrary attributes attached to it.</span>
<span class="comment-copy">Indeed, <code>NDFrame</code> (which is the base class of <code>DataFrame</code>) has this custom <code>__deepcopy__</code>: <a href="https://github.com/pandas-dev/pandas/blob/master/pandas/core/generic.py#L5005" rel="nofollow noreferrer">github.com/pandas-dev/pandas/blob/master/pandas/core/â€¦</a></span>
<span class="comment-copy">Yes, that's more accurate. You can override <code>__deepcopy__</code>, it's not surprising that it only records class related information.</span>
<span class="comment-copy">Using <code>df.copy(deep=True)</code>  doesn't alleviate the issue either. I now understand that the metadata copy is not implemented, but I would want to know what python mechanics are at play that is causing this.</span>
<span class="comment-copy">Yep, using the <code>_metadata</code> attribute hack works perfectly for my usecase.</span>
<span class="comment-copy">Please note my update to the example code.  I haven't tested it but I think you'll probably need something like the above <code>_constructor</code>.</span>
<span class="comment-copy">It seems you haven't linked an answer in the first link, it's the same github issue you link afterwards. If you can, edit your answer to include the related, and possibly duplicate, answer.</span>
<span class="comment-copy">@JimFasarakisHilliard thanks, updated. although i'm pretty sure this isn't a duplicate, OP's question is more specific</span>
