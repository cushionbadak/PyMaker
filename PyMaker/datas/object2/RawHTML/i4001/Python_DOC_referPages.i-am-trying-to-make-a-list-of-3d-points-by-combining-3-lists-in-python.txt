<div class="post-text" itemprop="text">
<p>When you run the script below in Python, you get the results shown.   </p>
<p>1) I don't understand why it's able to print c just fine, but when I say z = shuffle(c) z returns zero. Shouldn't it just give me a mixed up c?</p>
<pre><code>import random 
a = list(range(1,99))   
b = list(range(1,99))   
c =list(range(1,99))   
print(c)   
x=random.shuffle(a)     
y=random.shuffle(b)  
z=random.shuffle(c)   
print(x)   
q=(x,y,z)   
print(q)    

[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,
54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,
71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,
88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98]   
None   
(None, None, None)
</code></pre>
<p>2) Ideally, I want make lots of q points each of which is given an x, y and z so q1=(x1,y1,z1) and q2=(x2,y2,z2) etc. So I thought I could iterate over it, but I'm not sure how to write it in less mathematical terms and more of a python way.<br/>
I tried</p>
<pre><code>for i in range(len(x,y,z)):   
    q=(x[i],y[i],z[i])
</code></pre>
<p>But I don't think that's how Python works.</p>
</div>
<div class="post-text" itemprop="text">
<p>First, <code>random.shuffle</code> is an in-place operation. Second, you can use <code>zip</code> to combine your shuffled lists into points.</p>
<pre><code>import random

x = list(range(1, 99))
y = list(range(1, 99))
z = list(range(1, 99))

random.shuffle(x)
random.shuffle(y)
random.shuffle(z)

points = list(zip(x, y, z))
</code></pre>
<p>If you are using Python 2.X, you can omit all of the <code>list</code> casts because <code>range</code> and <code>zip</code> will already be returning lists.</p>
</div>
<div class="post-text" itemprop="text">
<p>Look at the <a href="https://docs.python.org/3/library/random.html" rel="nofollow noreferrer">Docs</a>.</p>
<p><code>random.shuffle</code> modifies your list in place and returns nothing. Thus, you want</p>
<pre><code>&gt;&gt;&gt; a = list(range(1,99))  
print(a)
&gt;&gt;&gt; random.shuffle(a)
print(a)
</code></pre>
<p>To get a random sample of your 3 lists, use <code>random.sample</code></p>
<pre><code>&gt;&gt;&gt; n = 10 # for example
&gt;&gt;&gt; list(zip(random.sample(a, n),random.sample(b, n),random.sample(c, n)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<ol>
<li><code>z=random.shuffle(c)</code> returns NoneType because, it simply modifies an array in-place! If you want a shuffled version, you need only do </li>
</ol>
<p><code>random.shuffle(c)</code></p>
<p><code>print(c)</code></p>
<p><code>c</code> will now be shuffled in place! You can then maybe create a deep copy of c.</p>
<p>This is sort of similar to how the sort function works! </p>
<p><code>a = [1, 4, 5, 9, 28, 1]</code></p>
<p><code>a.sort()</code></p>
<p><code>a</code> is sorted in-place, doing something like <code>b = a.sort()</code>, would've led to storing <code>NoneType</code> in <code>b</code></p>
</div>
<div class="post-text" itemprop="text">
<p>As said in the comments, random.shuffle works on the list object and doesn't return anything. To get your code to shuffle and create a list of 3D points can be done easily</p>
<pre><code>import random 
x = list(range(1,99))   
y = list(range(1,99))   
z = list(range(1,99))
random.shuffle(x)     
random.shuffle(y)  
random.shuffle(z)    

points = []
for i in range(len(x)):
    points.append((x[i], y[i], z[i]))

print(points)
</code></pre>
<p>Note this requires x, y and z to be the same length</p>
</div>
<div class="post-text" itemprop="text">
<p>To answer q1: Shuffle is an in-place operation. Just shuffle(a) etc, to get random lists.<br/>
q2. You're looking for the builtin zip(), which will return a list of tuples, stopping at the end of the shortest input iterator.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using numpy you could do something in the lines of:</p>
<pre><code>import numpy as np

n = 3
ar = np.array([np.arange(100) for _ in range(3)])
for i in range(n):
    np.random.shuffle(ar[i])

list(map(tuple, np.dstack(ar)[0]))
</code></pre>
</div>
<span class="comment-copy">Please fix your code format</span>
<span class="comment-copy">Do you want all <code>99 * 99 * 99</code> permutations of these?  If so, try <code>itertools</code></span>
<span class="comment-copy">not every possible combination, just 99 q's</span>
<span class="comment-copy"><code>random.shuffle</code> operates in place and returns <code>None</code>. There are a billion dupes about this (also for <code>list.sort</code>), hopefully somebody will find one.</span>
<span class="comment-copy">Just use <code>zip(a, b, c)</code> after calling <code>random.shuffle</code>, and don't bother assigning the result of <code>random.shuffle</code> to a variable, as it is an in-place operation.</span>
<span class="comment-copy">A minor comment, I think <code>list()</code> over a range is redundant.</span>
<span class="comment-copy">@Rafael Not in python3 :)</span>
<span class="comment-copy">@Rafael It depends on the version of Python</span>
<span class="comment-copy">Correct! I was not sure, I tested it in Python 2, I should had tested in Python 3 as well :)</span>
