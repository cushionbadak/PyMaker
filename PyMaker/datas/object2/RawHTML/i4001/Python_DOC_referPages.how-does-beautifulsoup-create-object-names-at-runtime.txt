<div class="post-text" itemprop="text">
<p>How does BeautifulSoup create object names at runtime?
Take the following code for example</p>
<pre><code>from bs4 import BeautifulSoup
html = """&lt;html&gt;
&lt;head&gt;
&lt;sid&gt;&lt;b&gt;Custom Tag&lt;/b&gt;&lt;/sid&gt;
&lt;sid&gt;&lt;b&gt;Custom Tag&lt;/b&gt;&lt;/sid&gt;
&lt;sid&gt;&lt;b&gt;Custom Tag&lt;/b&gt;&lt;/sid&gt;
&lt;/head&gt;
&lt;/html&gt;"""
soup = BeautifulSoup(html)
print(soup.html.head.sid)
</code></pre>
<p>How is the object of name 'sid' created. Earlier I thought standard html tags are pre-created, but the appearance of a custom tag as an object name means my understanding was wrong.
My limited understanding is that bs4 first creates and object of type <code>&lt;class 'bs4.BeautifulSoup'&gt;</code> which the recursively creates objects of type <code>&lt;class 'bs4.element.Tag'&gt;</code> My question is how does bs4 dynamically name these <code>&lt;class 'bs4.element.Tag'&gt;</code> objects to the actual tags found in the html?</p>
<p>How can I replicate this?</p>
</div>
<div class="post-text" itemprop="text">
<p>The key is <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattr__" rel="nofollow noreferrer"><code>__getattr__</code></a>, a special method that allows classes to dynamically create attributes on demand.</p>
<p>Oversimplifying slightly:<sup>1</sup> when you write <code>spam.eggs</code>, Python does something like this pseudocode:</p>
<pre><code>for obj in [spam] + type(spam).__mro__:
    try:
        return obj.__dict__['eggs']
    except KeyError:
        pass
return spam.__getattr__('eggs')
</code></pre>
<p>The default <code>object.__getattr__</code> just raises an <code>AttributeError</code>, but you can override it to do anything you want.</p>
<hr/>
<p>Here's the code from <a href="https://bazaar.launchpad.net/~leonardr/beautifulsoup/bs4/view/head:/bs4/element.py#L1043" rel="nofollow noreferrer"><code>Tag.__getattr__</code></a>:</p>
<pre><code>def __getattr__(self, tag):
    #print "Getattr %s.%s" % (self.__class__, tag)
    if len(tag) &gt; 3 and tag.endswith('Tag'):
        # BS3: soup.aTag -&gt; "soup.find("a")
        tag_name = tag[:-3]
        warnings.warn(
            '.%sTag is deprecated, use .find("%s") instead.' % (
                tag_name, tag_name))
        return self.find(tag_name)
    # We special case contents to avoid recursion.
    elif not tag.startswith("__") and not tag=="contents":
        return self.find(tag)
    raise AttributeError(
        "'%s' object has no attribute '%s'" % (self.__class__, tag))
</code></pre>
<p>There's a bunch of special-case code to handle things like BS3-style legacy access, but other than that, it's dead simple: <code>tag.spam</code> just returns <code>tag.find('spam')</code>.</p>
<hr/>
<p>If you're considering doing this yourself, keep in mind that Python also offers "semi-dynamic" attributes, which you can create by name (using <a href="https://docs.python.org/3/library/functions.html#setattr" rel="nofollow noreferrer"><code>setattr</code></a> at some point after construction, rather than each time they're looked up. For many projects, this is a better solution (more efficient, attributes show up in <code>dir</code> and other reflective calls, etc.). It would probably be a bad idea for BS4's mutable trees,<sup>2</sup> but if it didn't allow mutation, it might make more sense to do something like this pseudocode:</p>
<pre><code>for node in walk(tree):
    for ancestor in node.ancestor_chain():
        if not hasattr(ancestor, node.name):
            setattr(ancestor, node.name, node)
</code></pre>
<hr/>
<p><sub>1. Most notably, this behavior is implemented in <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattribute__" rel="nofollow noreferrer"><code>object.__getattribute__</code></a>, so if you want to completely skip the default functionality, you can even override that method. Also, I've ignored <a href="https://docs.python.org/3/reference/datamodel.html#slots" rel="nofollow noreferrer"><code>__slots__</code></a>, <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptors</a>, <a href="https://docs.python.org/3/reference/datamodel.html#special-lookup" rel="nofollow noreferrer">special method lookup</a>, how builtin/C-extension types work, etc.</sub></p>
<p><sub>2. Imagine your rename that <code>sid</code> node to <code>pid</code>. It can't just walk the ancestor chain and delete <code>sid</code> and add <code>pid</code> attributes on each oneâ€”there could be another <code>sid</code> descendant that should now take over the <code>sid</code> attribute, and for <code>pid</code>, it even depends on whether such a descendant comes before or after the current node.</sub></p>
</div>
<span class="comment-copy">@SiddharthChabra Right. And the second footnote explains (my guess at) why they chose to do it that way.</span>
