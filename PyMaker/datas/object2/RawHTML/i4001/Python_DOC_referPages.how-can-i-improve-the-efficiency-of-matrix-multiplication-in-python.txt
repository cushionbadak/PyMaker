<div class="post-text" itemprop="text">
<p>I have written a code to do matrix multiplication of different range but it takes a lot of time to exexcute the code,</p>
<p>code:</p>
<h1>Program to multiply two matrices using nested loops</h1>
<pre><code>import time

print("Enter the size of matrix A")
m = int(input())
n = int(input())
print("Enter the size of matrix A")
p = int(input())
q = int(input())
if(n==p):
     print('enter matrix A')
else:
    print("invalid entry")
    exit()
our_list1 = []
A = []
i = 0
int(i)

for i in range(m):
    for i in range(n):
            number = int(input('Please enter a element '))
            our_list1.append(number)
    A.append(our_list1)
    our_list1= []
print(A)
print('enter matrix B')
our_list1 = []
B = []

for i in range(p):
    for i in range(q):
            number = int(input('Please enter a element '))
            our_list1.append(number)
    B.append(our_list1)
    our_list1= []
print(B)
start_time = time.time()

#
our_list1 = []
R = []

for i in range(m):
    for i in range(q):
            number = 0
            our_list1.append(number)
    R.append(our_list1)
    our_list1= []
print(R)
for i in range(len(A)):

    # iterating by coloum by B
    for j in range(len(B[0])):

        # iterating by rows of B
        for k in range(len(B)):
            R[i][j] += A[i][k] * B[k][j]
print(R)
print("--- %s seconds ---" % (time.time() - start_time))
</code></pre>
<p>It takes more time to execute this method of matrix multiplication, how can I choose the efficient way of matrix multiplication of huge dimension range? So higher dimension array can be executed smoothly and quickly.
Sample output:</p>
<pre><code>Matrix A[[3, 3, 3], [3, 3, 3], [3, 3, 3]]
Matrix B[[3, 3, 3], [3, 3, 3], [3, 3, 3]]
[[0, 0, 0], [0, 0, 0], [0, 0, 0]]
[[27, 27, 27], [27, 27, 27], [27, 27, 27]]
--- 0.00014400482177734375 seconds ---
</code></pre>
<p>it takes 0.00014400482177734375 seconds can I improve this timmings  when I do for  higher dimension multiplication?</p>
</div>
<div class="post-text" itemprop="text">
<p>This timings in your comments have some significant drawbacks:</p>
<ol>
<li><code>print()</code> is comparatively expensive and has nothing to do with the calculation. Including it in the timings could take up a big chunk of the overall time.</li>
<li>Using wallclock (<code>time.time()</code>) is not a good way of getting stable timings; you get one run and anything could be happening on your system.</li>
</ol>
<p>This should give a better test case for comparison:</p>
<pre><code>import numpy as np

def python_lists():
    A = [[3, 3, 3], [3, 3, 3], [3, 3, 3]]
    B = [[3, 3, 3], [3, 3, 3], [3, 3, 3]]
    our_list1 = []
    R = []

    for i in range(3):
        for i in range(3):
                number = 0
                our_list1.append(number)
        R.append(our_list1)
        our_list1= []

    for i in range(len(A)):

        # iterating by coloum by B
        for j in range(len(B[0])):

            # iterating by rows of B
            for k in range(len(B)):
                R[i][j] += A[i][k] * B[k][j]


def numpy_array():
    A = np.full((3, 3), 3)
    B = np.full((3, 3), 3)
    result = np.dot(A, B)
</code></pre>
<p>And the timings:</p>
<pre><code>%timeit python_lists()
15 µs ± 45.6 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)

%timeit numpy_array()
5.57 µs ± 44.7 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
</code></pre>
<p>So, NumPy is ~3 times faster for this example. But this would be more significant if you had bigger arrays.</p>
<p>EDIT:
And actually, you could argue that creating <code>A</code> and <code>B</code> inside the function is not helpful for timing the actual matrix multiplication, so if I instead create the lists/arrays first and pass them, the new timings are:</p>
<pre><code>%timeit python_lists(A, B)
14.4 µs ± 98.4 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)

%timeit numpy_array(A, B)
1.2 µs ± 13.3 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)
</code></pre>
<p>And, for the sake of completeness, for an array with shape (200, 200):</p>
<pre><code>%timeit python_lists()
6.99 s ± 128 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

%timeit numpy_array()
5.77 ms ± 43.4 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</code></pre>
</div>
<span class="comment-copy">Just use specialized module to do this, namely <code>numpy</code>.</span>
<span class="comment-copy">I don't think 0.0001 seconds is "a lot of time" but you should use numpy if you need to do stuff with big matrices</span>
<span class="comment-copy">Okay, I never used numpy before, can I do higher order matrix multiplication with that?</span>
<span class="comment-copy">You can, this module was designed to handle this kind of problem efficiently.</span>
<span class="comment-copy">okay, I'll do with nympy and check the time difference</span>
<span class="comment-copy">thank you for detail analysis, now I'm figuring out to create a function where I can just pass the A and B</span>
<span class="comment-copy">how did you calculate the timing of function %timeit python_lists(A, B)?, if I use that in a code or terminal I get a syntax error</span>
<span class="comment-copy">@NikhilR I use Spyder as my IDE, so it gives me access to iPython magic methods - <a href="http://ipython.readthedocs.io/en/stable/interactive/magics.html#magic-timeit" rel="nofollow noreferrer"><code>%timeit</code> is one of those</a>. If you're using regular Python then you will have to jump through some more hoops with the <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer"><code>timeit</code> module</a></span>
