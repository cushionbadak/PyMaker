<div class="post-text" itemprop="text">
<p>I've checked other problems and I've read their solutions, they do not work. I've tested the regular expression it works on non-locale characters. Code is simply to find any capital letters in a string and doing some procedure on them. Such as <code>minikŞeker bir kedi</code> would return <code>kŞe</code> however my code do not recognize <code>Ş</code> as a letter within <code>[A-Z]</code>. When I try <code>re.LOCALE</code> as some people request I get error <code>ValueError: cannot use LOCALE flag with a str pattern</code> when I use <code>re.UNICODE</code></p>
<pre><code>import re
corp = "minikŞeker bir kedi"
pattern = re.compile(r"([\w]{1})()([A-Z]{1})", re.U)
corp = re.sub(pattern, r"\1 \3", corp)
print(corp)
</code></pre>
<p>Works for <code>minikSeker bir kedi</code> doesn't work for <code>minikŞeker bir kedi</code> and throws error for <code>re.L</code>. The Error I'm getting is <code>ValueError: cannot use LOCALE flag with a str pattern</code> Searching for it yielded some git discussions but nothing useful.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that <code>Ş</code> is not in the range <code>[A-Z]</code>. That range is the class of all characters whose codepoints lie U+0040 and U+005A (inclusive). (If you were using bytes-mode, it would be all bytes between 0x40 and 0x5A.) And <code>Ş</code> is U+0153 (or, e.g., 0xAA in bytes, assuming latin2). Which isn't in that range.</p>
<p>And using a locale won't change that. As <a href="https://docs.python.org/3/library/re.html#re.LOCALE" rel="nofollow noreferrer"><code>re.LOCALE</code></a> explains, all it does is:</p>
<blockquote>
<p>Make \w, \W, \b, \B and case-insensitive matching dependent on the current locale.</p>
</blockquote>
<p>Also, you almost never want to use <code>re.LOCALE</code>. As the docs say:</p>
<blockquote>
<p>The use of this flag is discouraged as the locale mechanism is very unreliable, it only handles one “culture” at a time, and it only works with 8-bit locales.</p>
</blockquote>
<p>If you only care about a single script, you can build a class of the appropriate ranges for that script.</p>
<p>If you want to work with <em>all</em> scripts, you need to build a class out of a Unicode character class like <code>Lu</code> for "all uppercase letters". Unfortunately, Python's <code>re</code> doesn't have a mechanism for doing this directly. You can build a giant class out of the information in <code>unicodedata</code>, but that's pretty annoying:</p>
<pre><code>Lu = '[' + ''.join(chr(c) for c in range(0, 0x10ffff) 
                   if unicodedata.category(chr(c)) == 'Lu') + ']'
</code></pre>
<p>And then:</p>
<pre><code>pattern = re.compile(r"([\w]{1})()(" + Lu + r"{1})", re.U)
</code></pre>
<p>… or maybe:</p>
<pre><code>pattern = re.compile(rf"([\w]{{1}})()({Lu}{{1}})", re.U)
</code></pre>
<hr/>
<p>But the good news is that part of the reason <code>re</code> doesn't have any way to specify Unicode classes is that for a long time, the plan was to replace <code>re</code> with a new module, so many suggested new features for <code>re</code> were rejected. But the good news is that the intended new module is available as a third-party library, <a href="https://pypi.org/project/regex/" rel="nofollow noreferrer"><code>regex</code></a>. It works just fine, and is a near drop-in replacement for <code>re</code>; it was just improving too quickly to lock it down to the slower Python release schedule. If you install it, then you can write your code this way:</p>
<pre><code>import regex
corp = "minikŞeker bir kedi"
pattern = regex.compile(r"([\w]{1})()(\p{Lu}{1})", re.U)
corp = regex.sub(pattern, r"\1 \3", corp)
print(corp)
</code></pre>
<p>The only change I made was to replace <code>re</code> with <code>regex</code>, and then use <code>\p{Lu}</code> instead of <code>[A-Z]</code>.</p>
<p>There are, of course, lots of other regex engines out there, and many of them also support Unicode character classes. Most of those that do follow some variation on the same <code>\p</code> syntax. (They all copied it from Perl, but the details differ—e.g., <code>regex</code>'s idea of Unicode classes comes from the <code>unicodedata</code> module, while <code>PCRE</code> and <code>PCRE2</code> attempt to be as close to Perl as possible, and so on.)</p>
</div>
<div class="post-text" itemprop="text">
<p>abarnet's answer is great, but if all you want to do is find upper case characters, <code>str.isupper()</code> works without the need for an extra module.</p>
<pre><code>&gt;&gt;&gt; foo = "minikŞeker bir kedi"
&gt;&gt;&gt; for i, c in enumerate(foo):
...     if c.isupper():
...         print(foo[i-1:i+2])
...         break
... 
kŞe
</code></pre>
<p>or perhaps</p>
<pre><code>&gt;&gt;&gt; foo = "minikŞeker bir kedi"
&gt;&gt;&gt; ''.join((' ' if c.isupper() else '') + c for c in foo)
'minik Şeker bir kedi'
</code></pre>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/150033/regular-expression-to-match-non-english-characters">Regular expression to match non-English characters?</a></span>
<span class="comment-copy">I've added the error the the main body of the text. I've read that question before. \u escape did not work. Unlike the question holder of that link I'm not interested in locale characters at all, I want to be able to perform tasks I normally perform by having them included in my charset of [A-Z]</span>
<span class="comment-copy">As far as I understand you want for the input "minikSeker bir kedi" (without special characters) the output "kSe", right? But it does not work.</span>
<span class="comment-copy">I'd like to be able to use "minikŞeker kedi" and get output "minik Şeker kedi". Since Ş is not recognized by [A-Z] I can't unless I build my pattern like [A-ZŞÇĞİÜ], however doing this every time I encounter a UTF-8 problem would be absurd, there should be a way to point regex to UTF-8 charset.</span>
<span class="comment-copy">You usually don't want to "point regex to UTF-8 charset", you just want to use a Unicode <code>str</code> (or <code>unicode</code>, for Python 2) for your pattern and your search string, and then you have access to all of Unicode. In fact, if you're using Python 3, you're already doing that. But that doesn't solve your problem on its own.</span>
<span class="comment-copy">Thanks a lot! This solves all of my problems! I probably be using regex a lot in my future projects therefore this solves a lot of future problems all in once and I'm no stranger to adding modules I conda it, read docs and start right away!</span>
