<div class="post-text" itemprop="text">
<p>I want to find a unique ID in a string:</p>
<p><code>text = "Hello World, aaaa_dddd_bbbb_cccc"</code></p>
<p>The only defining feature of the unique ID is that it is a single word that contains three underscores. However, for the life of me I can't even start of figure out the regex for matching words with N non-consecutive instances of a certain character.</p>
<p>The best I can do is a hacky use of <code>.split()</code>:</p>
<pre><code>unique_id = None

for word in text.split(' '):
    if len(word.split("_")) &gt; 2:
        unique_id = word
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; text = "Hello World, aaaa_dddd_bbbb_cccc"

&gt;&gt;&gt; re.search(r'(\w+_\w+){3}', text)
&lt;_sre.SRE_Match object; span=(13, 32), match='aaaa_dddd_bbbb_cccc'&gt;
</code></pre>
<p>The pattern matches one or more word characters followed by an underscore follwed by one or more word characters, three times.</p>
<p>From the <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p>{m}</p>
<p>Specifies that exactly m copies of the previous RE should be matched; fewer matches cause the entire RE not to match. For example, a{6} will match exactly six 'a' characters, but not five.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>You can use regex <code>findall</code> to get a list of all items that match eg:</p>
<pre><code>text = "Hello World, aaaa_dddd_bbbb_cccc, 1_2_3_4"

import re
found = re.findall(r'[^_ ]*_[^_ ]+_[^_ ]+_[^_ ]*',text)

print(found)
# -&gt; ['aaaa_dddd_bbbb_cccc,', '1_2_3_4']
</code></pre>
<p>This allows strings starting and ending with a <code>_</code> eg <code>_1_2_3</code> if you don't want that you can change the first and last <code>*</code> to a <code>+</code></p>
</div>
<div class="post-text" itemprop="text">
<p>With straightforward regex pattern:</p>
<pre><code>import re

s = "Hello World, aaaa_dddd_bbbb_cccc"
m = re.search(r'\b([^_\s]+_){3}[^_\s]+\b', s)
result = m.group() if m else m

print(result)
</code></pre>
<p>The output:</p>
<pre><code>aaaa_dddd_bbbb_cccc
</code></pre>
<hr/>
<p>The pattern could be more strict (depends on what characters are allowed) like:</p>
<pre><code>...
m = re.search(r'\b([a-z0-9]+_){3}[a-z0-9]+\b', s, re.I)
...
</code></pre>
</div>
<span class="comment-copy"><code>The only defining feature of the unique ID is that it is a single word that contains three underscores</code> This is a problem. Also, what do you mean by this statement <code>matching words with N non-consecutive instances of a certain character</code> ? If it's like all a's <code>aaaa</code> then all d's <code>dddd</code>, then that would be something like <code>\b([^\W_])\1+_([^\W_])\2+_([^\W_])\3+_([^\W_])\4+\b</code></span>
<span class="comment-copy">Woah, I've never seen that <code>{3}</code> usage before. Thanks!</span>
<span class="comment-copy">Nothing proves that characters are not consecutive.</span>
<span class="comment-copy">@CasimiretHippolyte edited, thanks</span>
<span class="comment-copy">@CasimiretHippolyte Good to see SO isn't toxic.</span>
