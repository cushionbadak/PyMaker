<div class="post-text" itemprop="text">
<p>I have a simple task at hand...handling exception so the code does not throw IncompleteRead when using urllib/urllib2 between python2.x/3.x</p>
<p><strong>for python2</strong></p>
<pre><code>try:
    page = urllib2.urlopen(urls).read()
except httplib.IncompleteRead, e:
    page = e.partial
</code></pre>
<p><strong>for python3</strong></p>
<pre><code>try:
    page = request.urlopen(urls).read()
except (http.client.IncompleteRead) as e:
    page = e.partial
</code></pre>
<p>now since the module itself are different, how to do a try-except when i have no idea which python version will my users be running? </p>
<p>I cannot check for python version within my try-except as well...or can I?</p>
<p>is there a way to catch its super class so it becomes same for both python version? if yes, how?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can:</p>
<pre><code>try:
    from httplib import IncompleteRead
    import urllib2 as httpclient
except ImportError:
    from http.client import IncompleteRead
    import request as httpclient
</code></pre>
<p>Then use:</p>
<pre><code>try:
    page = httpclient.urlopen(urls).read()
except IncompleteRead as e:
    page = e.partial
</code></pre>
<p>in both python2 and python3.</p>
</div>
<div class="post-text" itemprop="text">
<p>Unless you need Python 2.5, you can use new-style except: statements in 2.x.</p>
<p>So, the only difference is the module names. You can <code>try</code> both manually, as in <a href="https://stackoverflow.com/a/50361518/908494">Sraw's answer</a>. But you should probably be using <code>six</code>, <code>futurize</code>, or <code>modernize</code>, as <a href="https://docs.python.org/3/howto/pyporting.html" rel="nofollow noreferrer">the official porting docs</a> and most other dual-versioning and porting guides recommend, and this is exactly the kind of thing that they're good for.</p>
<hr/>
<p>With <a href="https://pythonhosted.org/six/#module-six.moves" rel="nofollow noreferrer"><code>six.moves</code></a>:</p>
<pre><code>from six.moves import http_client
from six.moves import urllib_request

try:
    page = urllib_request.urlopen(urls).read()
except http_client.IncompleteRead as e:
    page = e.partial
</code></pre>
<hr/>
<p>Or, with <a href="http://python-future.org/automatic_conversion.html" rel="nofollow noreferrer"><code>future</code></a>:</p>
<pre><code>from future import standard_library
standard_library.install_aliases()
import http.client
import urllib.request, urllib.error, urllib.parse

try:
    page = urllib.request.urlopen(urls).read()
except http.client.IncompleteRead as e:
    page = e.partial
</code></pre>
<p>Or, even better, just write the 2.7 code:</p>
<pre><code>import httplib
import urllib2

try:
    page = urllib2.urlopen(urls).read()
except httplib.IncompleteRead as e:
    page = e.partial
</code></pre>
<p>â€¦ then run <code>futurize</code> on it, and it automatically gives you the <code>future</code> code above.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could do a try ... except on the import in an <strong>init</strong> module and then split your code into python2 and python3 modules:</p>
<pre><code>try:
    import urllib2
    pyver2()
except ModuleNotFoundError:
    import requests
    pyver3()
</code></pre>
<p>Oh request doesn't do what you want, perhaps you mean 'requests' and requests doesn't have a 'urlopen' method you need to use 'get()'.</p>
</div>
<span class="comment-copy">Might be a better way, but you can check which version of python is running your script using <code>sys.version</code></span>
<span class="comment-copy">okay...but once i get the version, how do i handle the exception? i just have a try-except block in my code...</span>
<span class="comment-copy">Unless you need Python 2.5, you can use new-style <code>except:</code> statements in 2.x.</span>
<span class="comment-copy">Thanks for the link to the porting docs, interesting distinction between version/feature detection.  Seems like my answer is bad practice, and has been deleted.</span>
<span class="comment-copy">@chrisz Well, it's the right answer for some things, but I think in general Sraw's version is considered more pythonic. (Just like EAFP usually beats LBYL.)</span>
<span class="comment-copy">I've only ever used it to tell people that my stuff <i>can't</i> be run with Python 2, which seems fine, but here I completely agree.</span>
<span class="comment-copy">@chrisz For anything I'm not packaging for PyPI, I just <code>assert.version_info &gt;= (3,6)</code> or whatever. That's good enough that if anyone complains "it doesn't work" and gives me any part of the error, I can tell them "Yeah, that's because Python 2.3 is not &gt;= 3.6" instead of "That set comprehension looks perfectly valid, I don't know what to tell you without more information."</span>
<span class="comment-copy">I'm pretty sure the OP does mean the <a href="https://docs.python.org/3/library/urllib.request.html" rel="nofollow noreferrer"><code>request</code></a> module in the <code>urllib</code> package that comes with the 3.x stdlib, which does have a <code>urlopen</code> function.</span>
<span class="comment-copy">Also, this doesn't split the code into two modules, just into two functions in the same module. (Which means it won't help if you want to, e.g., use 3.x-only syntax in the 3.x module.) And maintaining two modules in parallel like this usually isn't worth it. It was the recommended solution back in 3.0-3.1 (especially if you could run <code>2to3</code> to generate the 3.x version if needed at install time), but if you look around PyPI, almost nobody's been doing it since around 3.3, and somewhere on Nick Coghlan's site there's a good blog post explaining why.</span>
