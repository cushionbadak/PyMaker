<div class="post-text" itemprop="text">
<p>When you want to iterate sequentially over a list of numbers you will write:</p>
<pre><code>for i in range(1000):
  # do something with i
</code></pre>
<p>But what if you want to iterate over the list of numbers from the range (0..999) randomly? There is a need (in every iteration) to choose randomly the number that wasn't chosen in any previous iteration and there is a need to iterate over all of the numbers from the range (0..999).</p>
<p>Do you know how to do that (smart)?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="http://docs.python.org/library/random.html#random.shuffle" rel="noreferrer"><code>random.shuffle()</code></a> to, well, shuffle a list:</p>
<pre><code>import random

r = list(range(1000))
random.shuffle(r)
for i in r:
  # do something with i
</code></pre>
<p>By the way, in many cases where you'd use a <code>for</code> loop over a range of integers in other programming languages, you can directly describe the "thing" you want to iterate in Python.<br/>
For example, if you want to use the values of <code>i</code> to access elements of a list, you should better shuffle the list directly:</p>
<pre><code>lst = [1970, 1991, 2012]
random.shuffle(lst)
for x in lst:
  print x
</code></pre>
<p><strong>NOTE:</strong> You should bear the following warning in mind when using <code>random.shuffle()</code> (taken from the <a href="http://docs.python.org/library/random.html#random.shuffle" rel="noreferrer">docs</a>:</p>
<blockquote>
<p>Note that for even rather small len(x), the total number of
  permutations of x is larger than the period of most random number
  generators; this implies that most permutations of a long sequence can
  never be generated.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>People often miss opportunities for modularization.  You can define a function to encapsulate the idea of "iterate randomly":</p>
<pre><code>def randomly(seq):
    shuffled = list(seq)
    random.shuffle(shuffled)
    return iter(shuffled)
</code></pre>
<p>then:</p>
<pre><code>for i in randomly(range(1000)):
    #.. we're good to go ..
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Demonstrating Python generators and the <a href="http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle" rel="noreferrer">Fisherâ€“Yates shuffle</a>.</p>
<pre><code>import random

def shuffled(sequence):
    deck = list(sequence)
    while len(deck):
        i = random.randint(0, len(deck) - 1) # choose random card
        card = deck[i]                       # take the card
        deck[i] = deck[-1]                   # put top card in its place
        deck.pop()                           # remove top card
        yield card
</code></pre>
<p>You only generate as many random numbers as you use. But honestly, it's probably not saving much, so you should usually use <a href="https://docs.python.org/3/library/random.html#random.shuffle" rel="noreferrer"><code>random.shuffle</code></a>.</p>
<p>Note: If the top card is chosen, <code>deck[i] = deck.pop()</code> would not be safe, so removing the top is done in two steps.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a function <a href="http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.random.permutation.html" rel="noreferrer"><code>random.permutation()</code></a> in <code>numpy</code> that does exactly that for you.
Your code would look like</p>
<pre><code>from numpy.random import permutation

for i in permutation(1000):
    # do something with i
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the random.shuffle method:</p>
<pre><code>itrange = list(range(100))
random.shuffle(itrange)
for i in itrange:
    print i
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a different approach to iterating a list in random order. This doesn't modify the original list unlike the solutions that use shuffle()</p>
<pre><code>lst=['a','b','c','d','e','f']
for value in sorted(lst,key=lambda _: random.random()):
    print value
</code></pre>
<p>or:</p>
<pre><code>for value in random.sample(lst,len(lst)):
    print value
</code></pre>
</div>
<span class="comment-copy">@Greg: Actually I noticed that random.shuffle modifies the operand in place, so I cant't even use it as an expression :/ Thanks for the hint, though, I changed it.</span>
<span class="comment-copy">No worries, I deleted my comment because it no longer applied once you changed that. :)</span>
<span class="comment-copy">Also, Python automatically seeds its random number generator so a call to <code>random.seed()</code> is not required.</span>
<span class="comment-copy">@Greg: Good call!</span>
<span class="comment-copy">Thanks, this is the way to go. +1 for readability!</span>
<span class="comment-copy">Curious: Why return the iter instead of the list?</span>
<span class="comment-copy">Not sure why I returned the iter.  Returning a list should be fine too.</span>
<span class="comment-copy">This is probably a most underrated answer. The other ones (including the accepted one) all turn the iterable into a list and shuffle that. This works in most (simple) cases, but is memory inefficient and kills your program if your iterator is (very) large. Working with cartesian products of long lists, for example, is impossible with the other solutions.</span>
<span class="comment-copy">@Fred: Huh? This solution's first line is <code>deck = list(sequence)</code>. You might be able to get away with lazily building the list, but it's the same asymptotic time and memory as the others. This solution just lets you generate only as many random numbers as you need, and random numbers are cheap.</span>
<span class="comment-copy">@Fred: If your iterable is very large, you should consider stepping back a few levels. For example, to get a small subset of a cartesian product of long (known-sized) lists, you can pretend the product is a flattened list, then generate a random list of distinct indices into that list in one way or another, which you convert to indices into each component list. You'd be using the fact that the source is a product of lists.</span>
<span class="comment-copy">Yes, you are obviously completely right. I don't know what got into me when I wrote that answer.  Good hint on using the flattened list!</span>
<span class="comment-copy">@Fred To be clear, it wouldn't be an actual list, but a "pretend" flattened list, which creates elements as they're requested. You would not need to store any elements.</span>
<span class="comment-copy">Don't mistake it with itertools.permutations() though :)</span>
<span class="comment-copy">To future-proof this answer, you would need to use <code>list(range(100))</code> in Python 3 since <code>range</code> returns an iterator in 3.x.</span>
<span class="comment-copy">Thanks, it's correct now. Please note, that for long arrays not all permutations are possible: <a href="http://docs.python.org/library/random.html#random.shuffle" rel="nofollow noreferrer">docs.python.org/library/random.html#random.shuffle</a></span>
