<div class="post-text" itemprop="text">
<p>I have a list of approx. 10000 items. The current situation is that every item has an associated weight (priority or importance). Now the smallest weight is <code>-100</code> (negative and zero values can be removed) and the highest weight is <code>1500</code>. Weight is determined by intuition by people (how somebody thinks the item is important to community). Because it's not easy to determine the most important item, I'd like to use some random factor, so that items with lower weight will have less chance to be chosen and their weight will be adjusted in the future (some mix of common sense and randomness).</p>
<p>Do you know how to code a function <code>getItem</code>?</p>
<pre><code>def getItem(dict):
  # this function should return random item from 
  # the dictionary of item-weight pairs (or list of tuples)
  # Normally I would return only random item from the dictionary,
  # but now I'd like to have this: The item with weight 1500 should
  # have much more chance to be returned than the item with weight 10.
  # What's my idea is to sum up the weights of all items and then compute
  # some ratios. But maybe you have better idea.
  return randomItem
</code></pre>
<p>Thank you</p>
</div>
<div class="post-text" itemprop="text">
<p>Have a look at this, i think it's what you need with some nice comparision between different methods <a href="http://eli.thegreenplace.net/2010/01/22/weighted-random-generation-in-python/" rel="noreferrer">Weighted random generation in Python</a></p>
<p>The simplest approach suggested is:</p>
<pre><code>import random

def weighted_choice(weights):
    totals = []
    running_total = 0

    for w in weights:
        running_total += w
        totals.append(running_total)

    rnd = random.random() * running_total
    for i, total in enumerate(totals):
        if rnd &lt; total:
            return i
</code></pre>
<p>You can find more details and possible improvements as well as some different approaches in the link above.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python 3.6 introduced <a href="https://docs.python.org/3/library/random.html#random.choices" rel="nofollow noreferrer">random.choices()</a></p>
<pre><code>def get_item(items, items_weights):
    return random.choices(items, weights=items_weights)[0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should extract a random number between 0 and the sum of weights (positive by definition). Then you get the item from a list by using bisect: <a href="http://docs.python.org/library/bisect.html" rel="nofollow">http://docs.python.org/library/bisect.html</a> (the bisect standard moduke).  </p>
<pre><code>import random 
import bisect
weight = {'a':0.3,'b':3.2,'c':2.4}
items = weight.keys()
mysum = 0
breakpoints = [] 
for i in items:
    mysum += weight[i]
    breakpoints.append(mysum)

def getitem(breakpoints,items):
    score = random.random() * breakpoints[-1]
    i = bisect.bisect(breakpoints, score)
    return items[i] 

print getitem(breakpoints,items)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's easier to do if the weights are not negative. If you have to have negative weights, you'll have to offset the weights by the lowest possible weight. In your case, <code>offsetted_weight = itemweight + 100</code></p>
<p>In pseudocode, it goes like this:</p>
<pre><code>Calculate the sum of all the weights.
Do a random from 0 to the sum of the weights
Set i to 0
While the random number &gt; 0
    Subtract the weight of the item at index i  from random
    If the random number is &lt; 0 return item[i]
    Add 1 to i
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're storing your data in a database, you can use SQL:</p>
<pre><code>SELECT * FROM table ORDER BY weight*random() DESC LIMIT 1
</code></pre>
</div>
<span class="comment-copy">hi, I have recently answered a question like that: <a href="http://stackoverflow.com/a/9073313/862629">stackoverflow.com/a/9073313/862629</a></span>
<span class="comment-copy"><a href="http://meta.stackexchange.com/questions/18669/should-posts-be-self-contained">Answers on SO should be self-contained</a>, so please consider incorporating the essence of the linked article in your answer.</span>
<span class="comment-copy">This does exactly what the OP wanted, using one line of standard Python library code.  Thanks!</span>
<span class="comment-copy">Negative weights came into existence at the beginning when every item had weight 1. But it's not necessary to have negative weights, I can remove negative.</span>
<span class="comment-copy">Who said anything about SQL?</span>
<span class="comment-copy">Neat, but it's SQL and the question is marked with python tag. Anyway, I like the idea.</span>
<span class="comment-copy">How i said, 'IF USING A DATABASE' ...</span>
<span class="comment-copy">@copperttim Actually I like it because I use <code>sql</code> and your solution looks quite good and usable at the first sight.</span>
<span class="comment-copy">By Your description i thought that You're using sql. Hope it works as u need.</span>
