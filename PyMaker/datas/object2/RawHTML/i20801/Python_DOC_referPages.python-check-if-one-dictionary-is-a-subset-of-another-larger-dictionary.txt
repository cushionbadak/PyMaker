<div class="post-text" itemprop="text">
<p>I'm trying to write a custom filter method that takes an arbitrary number of <em>kwargs</em> and returns a list containing the elements of a database-like list that contain those <em>kwargs</em>.</p>
<p>For example, suppose <code>d1 = {'a':'2', 'b':'3'}</code> and <code>d2</code> = the same thing. <code>d1 == d2</code> results in True. But suppose <code>d2</code> = the same thing plus a bunch of other things. My method needs to be able to tell if <strong>d1 in d2</strong>, but Python can't do that with dictionaries.</p>
<p>Context:</p>
<p>I have a Word class, and each object has properties like <code>word</code>, <code>definition</code>, <code>part_of_speech</code>, and so on. I want to be able to call a filter method on the main list of these words, like <code>Word.objects.filter(word='jump', part_of_speech='verb-intransitive')</code>. I can't figure out how to manage these keys and values at the same time. But this could have larger functionality outside this context for other people.</p>
</div>
<div class="post-text" itemprop="text">
<p>Convert to item pairs and check for containment.</p>
<pre><code>all(item in superset.items() for item in subset.items())
</code></pre>
<p>Optimization is left as an exercise for the reader.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3, you can use <code>dict.items()</code> to get a set-like view of the dict items.  You can then use the <code>&lt;=</code> operator to test if one view is a "subset" of the other:</p>
<pre><code>d1.items() &lt;= d2.items()
</code></pre>
<p>In Python 2.7, use the <code>dict.viewitems()</code> to do the same:</p>
<pre><code>d1.viewitems() &lt;= d2.viewitems()
</code></pre>
<p>In Python 2.6 and below you will need a different solution, such as using <code>all()</code>:</p>
<pre><code>all(key in d2 and d2[key] == d1[key] for key in d1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Note for people that need this for unit testing: there's also an <code>assertDictContainsSubset()</code> method in Python's <code>TestCase</code> class.</p>
<p><a href="http://docs.python.org/2/library/unittest.html?highlight=assertdictcontainssubset#unittest.TestCase.assertDictContainsSubset" rel="noreferrer">http://docs.python.org/2/library/unittest.html?highlight=assertdictcontainssubset#unittest.TestCase.assertDictContainsSubset</a></p>
<p>It's however deprecated in 3.2, not sure why, maybe there's a replacement for it.</p>
</div>
<div class="post-text" itemprop="text">
<p>for keys and values check use: 
<code>set(d1.items()).issubset(set(d2.items()))</code></p>
<p>if you need to check only keys:
        <code>set(d1).issubset(set(d2))</code></p>
</div>
<div class="post-text" itemprop="text">
<p>For completeness, you can also do this:</p>
<pre><code>def is_subdict(small, big):
    return dict(big, **small) == big
</code></pre>
<p>However, I make no claims whatsoever concerning speed (or lack thereof) or readability (or lack thereof).</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; d1 = {'a':'2', 'b':'3'}
&gt;&gt;&gt; d2 = {'a':'2', 'b':'3','c':'4'}
&gt;&gt;&gt; all((k in d2 and d2[k]==v) for k,v in d1.iteritems())
True
</code></pre>
<p>context:</p>
<pre><code>&gt;&gt;&gt; d1 = {'a':'2', 'b':'3'}
&gt;&gt;&gt; d2 = {'a':'2', 'b':'3','c':'4'}
&gt;&gt;&gt; list(d1.iteritems())
[('a', '2'), ('b', '3')]
&gt;&gt;&gt; [(k,v) for k,v in d1.iteritems()]
[('a', '2'), ('b', '3')]
&gt;&gt;&gt; k,v = ('a','2')
&gt;&gt;&gt; k
'a'
&gt;&gt;&gt; v
'2'
&gt;&gt;&gt; k in d2
True
&gt;&gt;&gt; d2[k]
'2'
&gt;&gt;&gt; k in d2 and d2[k]==v
True
&gt;&gt;&gt; [(k in d2 and d2[k]==v) for k,v in d1.iteritems()]
[True, True]
&gt;&gt;&gt; ((k in d2 and d2[k]==v) for k,v in d1.iteritems())
&lt;generator object &lt;genexpr&gt; at 0x02A9D2B0&gt;
&gt;&gt;&gt; ((k in d2 and d2[k]==v) for k,v in d1.iteritems()).next()
True
&gt;&gt;&gt; all((k in d2 and d2[k]==v) for k,v in d1.iteritems())
True
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My function for the same purpose, doing this recursively:</p>
<pre><code>def dictMatch(patn, real):
    """does real dict match pattern?"""
    try:
        for pkey, pvalue in patn.iteritems():
            if type(pvalue) is dict:
                result = dictMatch(pvalue, real[pkey])
                assert result
            else:
                assert real[pkey] == pvalue
                result = True
    except (AssertionError, KeyError):
        result = False
    return result
</code></pre>
<p>In your example, <code>dictMatch(d1, d2)</code> should return True even if d2 has other stuff in it, plus it applies also to lower levels:</p>
<pre><code>d1 = {'a':'2', 'b':{3: 'iii'}}
d2 = {'a':'2', 'b':{3: 'iii', 4: 'iv'},'c':'4'}

dictMatch(d1, d2)   # True
</code></pre>
<p>Notes:  There could be even better solution which avoids the <code>if type(pvalue) is dict</code> clause and applies to even wider range of cases (like lists of hashes etc).  Also recursion is not limited here so use at your own risk. ;)</p>
</div>
<div class="post-text" itemprop="text">
<p>This seemingly straightforward issue costs me a couple hours in research to find a 100% reliable solution, so I documented what I've found in this answer.</p>
<ol>
<li><p>"Pythonic-ally" speaking, <code>small_dict &lt;= big_dict</code> would be the most intuitive way, but too bad that it <strong>won't work</strong>. <code>{'a': 1} &lt; {'a': 1, 'b': 2}</code> seemingly works in Python 2, but it is not reliable because the official documention explicitly calls it out. Go search "Outcomes other than equality are resolved consistently, but are not otherwise defined." in <a href="https://docs.python.org/2/reference/expressions.html#value-comparisons" rel="nofollow noreferrer">this section</a>. Not to mention, comparing 2 dicts in Python 3 results in a TypeError exception.</p></li>
<li><p>The second most-intuitive thing is <code>small.viewitems() &lt;= big.viewitems()</code> for Python 2.7 only, and <code>small.items() &lt;= big.items()</code> for Python 3. But there is one caveat: it is <strong>potentially buggy</strong>. If your program could potentially be used on Python &lt;=2.6, its <code>d1.items() &lt;= d2.items()</code> are actually comparing 2 lists of tuples, without particular order, so the final result will be unreliable and it becomes a nasty bug in your program. I am not keen to write yet another implementation for Python&lt;=2.6, but I still don't feel comfortable that my code comes with a known bug (even if it is on an unsupported platform). So I abandon this approach.</p></li>
<li><p>I settle down with <a href="https://stackoverflow.com/a/35416899/728675">@blubberdiblub 's answer</a> (Credit goes to him):</p>
<p><code>def is_subdict(small, big):
       return dict(big, **small) == big</code></p>
<p>It is worth pointing out that, this answer relies on the <code>==</code> behavior between dicts, which is clearly defined in official document, hence <strong>should work in every Python version</strong>. Go search:</p>
<ul>
<li>"Dictionaries compare equal if and only if they have the same (key, value) pairs." is the last sentence in <a href="https://docs.python.org/2/library/stdtypes.html#mapping-types-dict" rel="nofollow noreferrer">this page</a></li>
<li>"Mappings (instances of dict) compare equal if and only if they have equal (key, value) pairs. Equality comparison of the keys and elements enforces reflexivity." in <a href="https://docs.python.org/2/reference/expressions.html#value-comparisons" rel="nofollow noreferrer">this page</a></li>
</ul></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Here's a general recursive solution for the problem given:</p>
<pre><code>import traceback
import unittest

def is_subset(superset, subset):
    for key, value in subset.items():
        if key not in superset:
            return False

        if isinstance(value, dict):
            if not is_subset(superset[key], value):
                return False

        elif isinstance(value, str):
            if value not in superset[key]:
                return False

        elif isinstance(value, list):
            if not set(value) &lt;= set(superset[key]):
                return False
        elif isinstance(value, set):
            if not value &lt;= superset[key]:
                return False

        else:
            if not value == superset[key]:
                return False

    return True


class Foo(unittest.TestCase):

    def setUp(self):
        self.dct = {
            'a': 'hello world',
            'b': 12345,
            'c': 1.2345,
            'd': [1, 2, 3, 4, 5],
            'e': {1, 2, 3, 4, 5},
            'f': {
                'a': 'hello world',
                'b': 12345,
                'c': 1.2345,
                'd': [1, 2, 3, 4, 5],
                'e': {1, 2, 3, 4, 5},
                'g': False,
                'h': None
            },
            'g': False,
            'h': None,
            'question': 'mcve',
            'metadata': {}
        }

    def tearDown(self):
        pass

    def check_true(self, superset, subset):
        return self.assertEqual(is_subset(superset, subset), True)

    def check_false(self, superset, subset):
        return self.assertEqual(is_subset(superset, subset), False)

    def test_simple_cases(self):
        self.check_true(self.dct, {'a': 'hello world'})
        self.check_true(self.dct, {'b': 12345})
        self.check_true(self.dct, {'c': 1.2345})
        self.check_true(self.dct, {'d': [1, 2, 3, 4, 5]})
        self.check_true(self.dct, {'e': {1, 2, 3, 4, 5}})
        self.check_true(self.dct, {'f': {
            'a': 'hello world',
            'b': 12345,
            'c': 1.2345,
            'd': [1, 2, 3, 4, 5],
            'e': {1, 2, 3, 4, 5},
        }})
        self.check_true(self.dct, {'g': False})
        self.check_true(self.dct, {'h': None})

    def test_tricky_cases(self):
        self.check_true(self.dct, {'a': 'hello'})
        self.check_true(self.dct, {'d': [1, 2, 3]})
        self.check_true(self.dct, {'e': {3, 4}})
        self.check_true(self.dct, {'f': {
            'a': 'hello world',
            'h': None
        }})
        self.check_false(
            self.dct, {'question': 'mcve', 'metadata': {'author': 'BPL'}})
        self.check_true(
            self.dct, {'question': 'mcve', 'metadata': {}})
        self.check_false(
            self.dct, {'question1': 'mcve', 'metadata': {}})

if __name__ == "__main__":
    unittest.main()
</code></pre>
<p>NOTE: The original code would fail in certain cases, credits for the <a href="https://stackoverflow.com/a/49419880/3809375">fixing</a> goes to <a href="https://stackoverflow.com/users/5079316/olivier-melan%C3%A7on">@olivier-melançon</a></p>
</div>
<div class="post-text" itemprop="text">
<p>This function works for non-hashable values. I also think that it is clear and easy to read.</p>
<pre><code>def isSubDict(subDict,dictionary):
    for key in subDict.keys():
        if (not key in dictionary) or (not subDict[key] == dictionary[key]):
            return False
    return True

In [126]: isSubDict({1:2},{3:4})
Out[126]: False

In [127]: isSubDict({1:2},{1:2,3:4})
Out[127]: True

In [128]: isSubDict({1:{2:3}},{1:{2:3},3:4})
Out[128]: True

In [129]: isSubDict({1:{2:3}},{1:{2:4},3:4})
Out[129]: False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I know this question is old, but here is my solution for checking if one nested dictionary is a part of another nested dictionary. The solution is recursive.</p>
<pre><code>def compare_dicts(a, b):
    for key, value in a.items():
        if key in b:
            if isinstance(a[key], dict):
                if not compare_dicts(a[key], b[key]):
                    return False
            elif value != b[key]:
                return False
        else:
            return False
    return True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you don't mind using pydash  there is is_match there which does exactly that:</p>
<pre><code>import pydash

a = {1:2, 3:4, 5:{6:7}}
b = {3:4.0, 5:{6:8}}
c = {3:4.0, 5:{6:7}}

pydash.predicates.is_match(a, b) # False
pydash.predicates.is_match(a, c) # True






</code></pre>
</div>
<span class="comment-copy">If the dict values are hashable, using viewitems() is the most optimizied way I can think of: <code>d1.viewitems() &lt;= d2.viewitems()</code>.  Timeit runs showed over a 3x performance improvement.  If not hashable, even using <code>iteritems()</code> instead of <code>items()</code> leads to about a 1.2x improvement.  This was done using Python 2.7.</span>
<span class="comment-copy">i don't think optimisation should be left to the reader - i'm worried people will actually use this without realising it's going to build a copy of superset.items() and iterate through it for every item in subset.</span>
<span class="comment-copy">@Chad This is a much better answer, and does not actually require the items being hashable.  I have converted this to a <a href="http://stackoverflow.com/a/41579450">community wiki answer</a>.</span>
<span class="comment-copy">With Python 3 <code>items()</code> will return lightweight views instead of copies. No further optimization is necessary.</span>
<span class="comment-copy">What about nested directories?</span>
<span class="comment-copy">for python3 this becomes <code>d1.items() &lt;= d2.items()</code></span>
<span class="comment-copy">Caveat: if your program could potentially be used on Python 2.6 (or even below), the <code>d1.items() &lt;= d2.items()</code> are actually comparing 2 lists of tuples, without particular order, so the final result will probably not reliable. For this reason, I switch to @blubberdiblub 's answer.</span>
<span class="comment-copy">@RayLuo Yes, viewitems is not the same as items.  Edited to clarify.</span>
<span class="comment-copy"><code>d1.items() &lt;= d2.items()</code> is undefined behavior. It is not documented in the official docs and, most important, this is not tested: <a href="https://github.com/python/cpython/blob/2e576f5aec1f8f23f07001e2eb3db9276851a4fc/Lib/test/test_dictviews.py#L146" rel="nofollow noreferrer">github.com/python/cpython/blob/…</a>  So this is implementation dependent.</span>
<span class="comment-copy">@RodrigoMartins If you're worried about future maintainers, wrap the operation in a clearly-named function or add a code comment.  Lowering your code standards to the level of incompetent developers is a terrible idea.</span>
<span class="comment-copy">was curious, found this in <a href="http://docs.python.org/3/whatsnew/3.2.html" rel="nofollow noreferrer">what's new in 3.2</a>:  <i>The assertDictContainsSubset() method was deprecated because it was misimplemented with the arguments in the wrong order. This created hard-to-debug optical illusions where tests like TestCase().assertDictContainsSubset({'a':1, 'b':2}, {'a':1}) would fail.</i> <i>(Contributed by Raymond Hettinger.)</i></span>
<span class="comment-copy">Wait, the left side is expected and the right side is actual... Shouldn't that fail? The only thing wrong with the function is that which one goes in which place is confusing?</span>
<span class="comment-copy">There is no replacement for it...</span>
<span class="comment-copy">The first expression won't work if any value in either of the dictionaries is not hashable.</span>
<span class="comment-copy">The second example can be shortened slightly by removing the set(d2), as "issubset accepts any iterable". <a href="http://docs.python.org/2/library/stdtypes.html#set" rel="nofollow noreferrer">docs.python.org/2/library/stdtypes.html#set</a></span>
<span class="comment-copy">A side note: Other answers mentioning <code>small.viewitems() &lt;= big.viewitems()</code> was promising, but with one caveat: if your program could also be used on Python 2.6 (or even below), the <code>d1.items() &lt;= d2.items()</code> are actually comparing 2 lists of tuples, without particular order, so the final result will probably not reliable. For that reason, I switch to @blubberdiblub 's answer. Upvoted.</span>
<span class="comment-copy">This is very cool. I wish I could upvote more than once!</span>
<span class="comment-copy">code fails with a superset that has a dict nested inside a list, in the line <code>if not set(value) &lt;= set(superset[key])</code></span>
