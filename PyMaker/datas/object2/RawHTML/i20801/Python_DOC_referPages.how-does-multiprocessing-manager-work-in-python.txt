<div class="post-text" itemprop="text">
<p>I have a concern about multiprocessing.Manager() in python, here is the example,</p>
<pre><code>import multiprocessing 

def f(ns):

    ns.x *=10
    ns.y *= 10

if __name__ == '__main__':
    manager = multiprocessing.Manager()
    ns = manager.Namespace()
    ns.x = 1
    ns.y = 2

    print 'before', ns
    p = multiprocessing.Process(target=f, args=(ns,))
    p.start()
    p.join()
    print 'after', ns
</code></pre>
<p>and the output is,</p>
<pre><code>before Namespace(x=1, y=2)
after Namespace(x=10, y=20)
</code></pre>
<p>Till now, it worked as my expected, then I modified the code like this,</p>
<pre><code>import multiprocessing 

def f(ns):

    ns.x.append(10)
    ns.y.append(10)

if __name__ == '__main__':
    manager = multiprocessing.Manager()
    ns = manager.Namespace()
    ns.x = []
    ns.y = []

    print 'before', ns
    p = multiprocessing.Process(target=f, args=(ns,))
    p.start()
    p.join()
    print 'after', ns
</code></pre>
<p>now, the output is,</p>
<pre><code>before Namespace(x=[], y=[])
after Namespace(x=[], y=[])
</code></pre>
<p>It confused me why the list was not changed as my expected? anybody can help me to figure out what happened? Thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>Manager proxy objects are unable to propagate changes made to (unmanaged) mutable objects inside a container. So in other words, if you have a <code>manager.list()</code> object, any changes to the managed list itself are propagated to all the other processes. But if you have a normal Python list <em>inside</em> that list, any changes to the inner list are not propagated, because the manager has no way of detecting the change. </p>
<p>In order to propagate the changes, you have to use <code>manager.list()</code> objects for the nested lists too (requires <a href="https://docs.python.org/3/whatsnew/3.6.html#multiprocessing" rel="nofollow noreferrer">Python 3.6 or newer</a>), or you need to modify the <code>manager.list()</code> object directly (see the note <a href="http://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.managers.SyncManager.list" rel="nofollow noreferrer">on <code>manager.list</code> in Python 3.5 or older</a>).</p>
<p>For example, consider the following code and its output:</p>
<pre><code>import multiprocessing
import time

def f(ns, ls, di):
    ns.x += 1
    ns.y[0] += 1
    ns_z = ns.z
    ns_z[0] += 1
    ns.z = ns_z

    ls[0] += 1
    ls[1][0] += 1 # unmanaged, not assigned back
    ls_2 = ls[2]  # unmanaged...
    ls_2[0] += 1
    ls[2] = ls_2  # ... but assigned back
    ls[3][0] += 1 # managed, direct manipulation

    di[0] += 1
    di[1][0] += 1 # unmanaged, not assigned back
    di_2 = di[2]  # unmanaged...
    di_2[0] += 1
    di[2] = di_2  # ... but assigned back
    di[3][0] += 1 # managed, direct manipulation

if __name__ == '__main__':
    manager = multiprocessing.Manager()
    ns = manager.Namespace()
    ns.x = 1
    ns.y = [1]
    ns.z = [1]
    ls = manager.list([1, [1], [1], manager.list([1])])
    di = manager.dict({0: 1, 1: [1], 2: [1], 3: manager.list([1])})

    print('before', ns, ls, ls[2], di, di[2], sep='\n')
    p = multiprocessing.Process(target=f, args=(ns, ls, di))
    p.start()
    p.join()
    print('after', ns, ls, ls[2], di, di[2], sep='\n')
</code></pre>
<p>Output:</p>
<pre><code>before
Namespace(x=1, y=[1], z=[1])
[1, [1], [1], &lt;ListProxy object, typeid 'list' at 0x10b8c4630&gt;]
[1]
{0: 1, 1: [1], 2: [1], 3: &lt;ListProxy object, typeid 'list' at 0x10b8c4978&gt;}
[1]
after
Namespace(x=2, y=[1], z=[2])
[2, [1], [2], &lt;ListProxy object, typeid 'list' at 0x10b8c4630&gt;]
[2]
{0: 2, 1: [1], 2: [2], 3: &lt;ListProxy object, typeid 'list' at 0x10b8c4978&gt;}
[2]
</code></pre>
<p>As you can see, when a new value is assigned directly to the managed container, it changes; when it is assigned to a mutable container within the managed container, it doesn't change; but if the mutable container is then <em>reassigned</em> to the managed container, it changes again. Using a nested managed container also works, detecting changes directly without having to assign back to the parent container.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>ns</code> is a NamespaceProxy instance. These objects have special <code>__getattr__</code>, <code>__setattr__</code>, and <code>__delattr__</code> methods that allow values to be shared across processes.
In order to take advantage of this mechanism when changing a value, you must trigger <code>__setattr__</code>.</p>
<pre><code>ns.x.append(10)
</code></pre>
<p>causes <code>ns.__getattr__</code> to be called to retrieve <code>ns.x</code>, but it does not cause <code>ns.__setattr__</code> to be called.</p>
<p>To fix this, you must use <code>ns.x = ...</code>.</p>
<pre><code>def f(ns):   
    tmp = ns.x     # retrieve the shared value
    tmp.append(10)
    ns.x = tmp     # set the shared value
</code></pre>
</div>
<span class="comment-copy">Starting with 3.6, changes to nested objects propagate automatically.</span>
<span class="comment-copy">I have ran into some issues using nested dictionaries within a NameSpace with the Manager on Python 3.6.4. Make sure that your nested objects are being updated properly before moving forward assuming they are. The solution for me was to explicitly define each object to be shared as a Manager object.</span>
<span class="comment-copy">@max: Provided that those nested objects are <i>also</i> proxy objects. The code in this answer nests regular, non-proxy lists. The nested lists in <code>ls</code> and <code>di</code> need to be wrapped in <code>manager.list()</code> calls.</span>
<span class="comment-copy">@MartijnPieters, thanks for clarifying! I see I did not understand that comment at all.</span>
