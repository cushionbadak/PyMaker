<div class="post-text" itemprop="text">
<p>I would like to play around in the python interpreter but with a bunch of imports and object setup completed. Right now I'm launching the interpreter on the command line and doing the setup work every time.  Is there any way to launch the command line interpreter with all the initialization work done?</p>
<p>Ex:</p>
<pre><code># Done automatically.
import foo
import baz
l = [1,2,3,4]
# Launch the interpreter.
launch_interpreter()
&gt;&gt; print l
&gt;&gt; [1,2,3,4]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can create a script with the code you wish to run automatically, then use <a href="http://docs.python.org/using/cmdline.html#cmdoption-i"><code>python -i</code></a> to run it. For example, create a script (let's call it script.py) with this:</p>
<pre><code>import foo
import baz
l = [1,2,3,4]
</code></pre>
<p>Then run the script</p>
<pre><code>$ python -i script.py
&gt;&gt;&gt; print l
[1, 2, 3, 4]
</code></pre>
<p>After the script has completed running, python leaves you in an interactive session with the results of the script still around.</p>
<p>If you really want some things done <em>every</em> time you run python, you can set the environment variable <code>PYTHONSTARTUP</code> to a script which will be run every time you start python. See the documentation on the <a href="http://docs.python.org/tutorial/interpreter.html#the-interactive-startup-file">interactive startup file</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I came across this question when trying to configure a new <a href="https://github.com/jamesob/desk" rel="nofollow">desk</a> for my research and found that the answers above didn't quite suit my desire: to contain the entire desk configuration within one file (meaning I wouldn't create a separate <code>script.py</code> as suggested by @srgerg).</p>
<p>This is how I ended up achieving my goal:</p>
<pre><code>export PYTHONPATH=$READ_GEN_PATH:$PYTHONPATH

alias prepy="python3 -i -c \"
from naive_short_read_gen import ReadGen
from neblue import neblue\""
</code></pre>
<p>In this case <code>neblue</code> is in the CWD (so no path extension is required there), whereas <code>naive_short_read_gen</code> is in an arbitrary directory on my system, which is specified via <code>$READ_GEN_PATH</code>.</p>
<p>You could do this in a single line if necessary: <code>alias prepy=PYTHONPATH=$EXTRA_PATH:$PYTHONPATH python3 -i -c ...</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I use <code>PYTHONSTARTUP</code>.</p>
<p>My <code>.bash_profile</code> has a path to my home folder <code>.pyrc</code>, which as the import statements in it.</p>
<p><a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONSTARTUP" rel="nofollow noreferrer">https://docs.python.org/3/using/cmdline.html#envvar-PYTHONSTARTUP</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the -s option while starting the command line. The details are given in the documentation <a href="http://docs.python.org/library/idle.html#startup" rel="nofollow">here</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I think I know what you want to do. You might want to check IPython, because you cannot start the python interpreter without giving the <code>-i</code> option (at least not directly).
This is what I did in my project:</p>
<pre><code>def ipShell():
    '''Starts the interactive IPython shell'''
    import IPython
    from IPython.config.loader import Config
    cfg = Config()
    cfg.TerminalInteractiveShell.confirm_exit = False
    IPython.embed(config=cfg, display_banner=False)
# Then add the following line to start the shell
ipShell()
</code></pre>
<p>You need to be careful, though, because the shell will have the namespace of the module that the function <code>ipShell()</code> is defined. If you put the definition  in the file you run, then you will be able to access the <code>globals()</code> you want. There could be other workarounds to inject the namespace you want, b̶u̶t̶ ̶y̶o̶u̶ ̶w̶o̶u̶l̶d̶ ̶h̶a̶v̶e̶ ̶t̶o̶ ̶g̶i̶v̶e̶ ̶a̶r̶g̶u̶m̶e̶n̶t̶s̶ ̶t̶o̶ ̶t̶h̶e̶ ̶f̶u̶n̶c̶t̶i̶o̶n̶ ̶i̶n̶ ̶t̶h̶a̶t̶ ̶c̶a̶s̶e̶.</p>
<p><strong>EDIT</strong></p>
<p>The following function defaults to caller's namespace (<code>__main__.__dict__</code>).</p>
<pre><code>def ipShell():
    '''Starts the interactive IPython shell
    with the namespace __main__.__dict__'''
    import IPython
    from __main__ import __dict__ as ns
    from IPython.config.loader import Config
    cfg = Config()
    cfg.TerminalInteractiveShell.confirm_exit = False
    IPython.embed(config=cfg, user_ns=ns, display_banner=False)
</code></pre>
<p>without any extra arguments.</p>
</div>
<span class="comment-copy">Docs for the interactive startup file are now here: <a href="https://docs.python.org/3/tutorial/appendix.html#the-interactive-startup-file" rel="nofollow noreferrer">docs.python.org/3/tutorial/…</a></span>
<span class="comment-copy">This is for IDLE, not for a plain console session, isn't it?</span>
<span class="comment-copy">Yes, that's right. This is for IDLE.</span>
