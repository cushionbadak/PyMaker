<div class="post-text" itemprop="text">
<p>I'm writing a Django App, where I am expecting to use many management.py commands.  I like the idea of python functions having parameters with default values, where you define the param as:</p>
<pre><code>def function(param1=value1)
</code></pre>
<p>So I'm writing my management commands such that you input as follows:</p>
<pre><code>python manage.py createdb user=some_user db_name=some_name
</code></pre>
<p>So far as I can tell, management.py commands don't accept this type of argument list, so I've created a helper to do the following:</p>
<pre><code>def process_args(args=None):
    kwargs = {}
    if not args:
        return kwargs
    for i in args:
        try:
            k,v = i.split('=')
            kwargs[k] = v
        except ValueError, ve:
            raise CommandError("Please Enter All Arguments as key=value.  e.g. user=admin")
    return kwargs
</code></pre>
<p>Is there a better way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of rolling your own, you could use typical parameter style, and use something like <a href="http://docs.python.org/library/argparse.html"><code>argparse</code></a> to parse it:</p>
<pre><code>python manage.py createdb --user=some_user --db_name=some_name
</code></pre>
<p>You'd just define your argument parser and then pass the <code>args</code> argument to its <code>parse_args()</code> method.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Updated:</strong>
Per @rix, later versions of Django now use <a href="http://docs.python.org/library/argparse.html" rel="nofollow">argparse</a>, which should be preferred.</p>
<p><strong>Original Answer:</strong></p>
<p>I believe the standard approach here is to use <a href="http://docs.python.org/library/optparse.html" rel="nofollow">optparse</a>, which can hook into the existing option parsing Django uses already. The example <a href="https://docs.djangoproject.com/en/1.6/howto/custom-management-commands/" rel="nofollow">from the 1.6 docs</a>:</p>
<pre><code>from optparse import make_option

class Command(BaseCommand):
    option_list = BaseCommand.option_list + (
        make_option('--delete',
            action='store_true',
            dest='delete',
            default=False,
            help='Delete poll instead of closing it'),
        )
    # ...
</code></pre>
<p>Now you have your command line arguments available in the <code>options</code> dictionary. The Python docs say <code>optparse</code> is deprecated, but I assume that the Django docs recommend it because it's what Django uses for its own management commands.     </p>
</div>
<div class="post-text" itemprop="text">
<p>Docs over @ Python <a href="https://docs.python.org/3/library/argparse.html" rel="nofollow">argparse</a> are great, but for a quick copy paste answer to solve the original question (post Django 1.8) - here you go:</p>
<pre><code>class Command(BaseCommand):

    def add_arguments(self, parser):
        parser.add_argument(
            '-something',
            action='store',
            dest='something',
            default=None,
            help="something",
        )

    def handle(self, *args, **options):
        print(options['something'])

python manage.py your_command -something='something'
</code></pre>
</div>
<span class="comment-copy">I am having trouble getting this to work.  The BaseCommand class needs to have the options added to its option_list in order for it to recognize the option.  But according to the post below, using make_option has been deprecated.  Hence I'd like to use argparse, but how do I add the arguments to the BaseCommand class?</span>
<span class="comment-copy">Honestly, I'd go with what @nrabinowitz suggested - use Django's built-in functionality when working with Django.</span>
<span class="comment-copy">Really, you're going to give me -1 for citing the Django manual on a question about Django best practices, even though I noted that the Django recommendation was deprecated? Come on.</span>
<span class="comment-copy">Yes, sorry.  Don't recommend deprecated code.  It doesn't matter if django uses it or not.  <a href="http://blog.zacharyvoase.com/2009/12/09/django-boss/" rel="nofollow noreferrer">Related</a></span>
<span class="comment-copy">In general, I would agree.  But the OP's question isn't about generic Python arg parsing, it's about the recommended way to do this <i>for Django management commands</i>. And there <i>is</i> a recommended way, using optparse, in the Django manual - recommended in part because that way you play well with Django's own parsing. It does matter whether Django uses it, if you're building code to work with Django.</span>
<span class="comment-copy">+1 for being rational. it's all fine and good to be hard-line about not using deprecated code, but if your app has a dependency on a specific version of Django and a specific version of Python, it only makes sense to use the framework as it was designed. I'm sure a future Django version will switch over to argparse, and then we can all win our way back into @wim's good graces</span>
<span class="comment-copy">In hindsight I actually disagree with my 2012 self now, too.  After having written a few management commands since, it became clear there is some functionality that you get through inheriting <code>BaseCommand</code> that you can't get easily by trying to avoid the deprecated module.  Practicality beats purity here.</span>
