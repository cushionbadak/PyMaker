<div class="post-text" itemprop="text">
<p>In the book that I am reading on Python, it keeps using the code <code>eval(input('blah'))</code> </p>
<p>I read the documentation, and I understand it, but I still do not see how it changes the <code>input()</code> function. </p>
<p>What does it do? Can someone explain?</p>
</div>
<div class="post-text" itemprop="text">
<p>The eval function lets a Python program run Python code within itself.</p>
<p>eval example (interactive shell):</p>
<pre><code>&gt;&gt;&gt; x = 1
&gt;&gt;&gt; eval('x + 1')
2
&gt;&gt;&gt; eval('x')
1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>eval()</code> interprets a string as code. The reason why so many people have warned you about using this is because a user can use this as an option to run code on the computer. If you have <code>eval(input())</code> and <code>os</code> imported, a person could type into <code>input()</code> <code>os.system('rm -R *')</code> which would delete all your files in your home directory. (Assuming you have a unix system). Using <code>eval()</code> is a security hole. If you need to convert strings to other formats, try to use things that do that, like <code>int()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Lots of good answers here, but none describe the use of <code>eval()</code> in the context of its <code>globals</code> and <code>locals</code> kwargs, i.e. <code>eval(expression, globals=None, locals=None)</code> (see docs for <code>eval</code> <a href="https://docs.python.org/3/library/functions.html#eval" rel="noreferrer">here</a>).</p>
<p>These can be used to limit the methods that are available through the <code>eval</code> method. For example if you load up a fresh python interpreter the <code>locals()</code> and <code>globals()</code> will be the same and look something like this:</p>
<pre><code>&gt;&gt;&gt; globals()
{'__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__doc__': None,
 '__spec__': None, '__builtins__': &lt;module 'builtins' (built-in)&gt;,
 '__package__': None, '__name__': '__main__'}
</code></pre>
<p>There are certainly methods within the <code>builtins</code> module that can do significant damage to a system. But it is possible to block anything and everything we don't want available. Let's take an example. Say we want to construct a list to represent a domain of the available cores on a system. For me I have 8 cores so I would want a list <code>[1, 8]</code>.</p>
<pre><code>&gt;&gt;&gt;from os import cpu_count()
&gt;&gt;&gt;eval('[1, cpu_count()]')
[1, 8]
</code></pre>
<p>Likewise all of <code>__builtins__</code> is available.</p>
<pre><code>&gt;&gt;&gt;eval('abs(-1)')
1
</code></pre>
<p>Ok. So there we see one method we want exposed and an example of one (of many that can be much more complex) method that we do not want exposed. So lets block everything.</p>
<pre><code>&gt;&gt;&gt;eval('[1, cpu_count()]', {'__builtins__':None}, {})
TypeError: 'NoneType' object is not subscriptable
</code></pre>
<p>We have effectively blocked all of the <code>__builtins__</code> methods and as such brought a level of protection into our system. At this point we can start to add back in methods that we do want exposed.</p>
<pre><code>&gt;&gt;&gt;from os import cpu_count
&gt;&gt;&gt;exposed_methods = {'cpu_count': cpu_count}
&gt;&gt;&gt;eval('cpu_count()', {'__builtins__':None}, exposed_methods)
8
&gt;&gt;&gt;eval('abs(cpu_count())', {'__builtins__':None}, exposed_methods)
TypeError: 'NoneType' object is not subscriptable
</code></pre>
<p>Now we have the cpu_count method available while still blocking everything we do not want. In my opinion this is super powerful and clearly from the scope of the other answers not a common implementation. There are numerous uses for something like this and as long as it is handled correctly I personally feel <code>eval</code> can be safely used to great value.</p>
<p><strong>N.B.</strong> </p>
<p>Something else that is cool about these <code>kwargs</code> is that you can start to use shorthand for your code. Let's say you use eval as part of a pipeline to execute some imported text. The text doesn't need to have exact code, it can follow some template file format, and still execute anything you'd like. For example:</p>
<pre><code>&gt;&gt;&gt;from os import cpu_count
&gt;&gt;&gt;eval('[1,cores]', {'__builtins__': None}, {'cores': cpu_count()})
[1, 8]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 2.x <code>input(...)</code> is equivalent to <code>eval(raw_input(...))</code>, in Python 3.x <code>raw_input</code> was renamed <code>input</code>, which I suspect lead to your confusion (you were probably looking at the documentation for <code>input</code> in Python 2.x). Additionally, <code>eval(input(...))</code> would work fine in Python 3.x, but would raise a <code>TypeError</code> in Python 2.</p>
<p>In this case <code>eval</code> is used to coerce the string returned from <code>input</code> into an expression and interpreted. Generally this is considered bad practice.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>eval()</code> evaluates the passed string as a Python expression and returns the result. For example, <code>eval("1 + 1")</code> interprets and executes the expression <code>"1 + 1"</code> and returns the result (2). </p>
<p>One reason you might be confused is because the code you cited involves a level of indirection. The inner function call (input) gets executed first so the user sees the "blah" prompt. Let's imagine they respond with "1 + 1" (quotes added for clarity, don't type them when running your program), the input function returns that string, which is then passed to the outer function (eval) which interprets the string and returns the result (2).</p>
<p>Read more about eval <a href="http://docs.python.org/library/functions.html#eval" rel="nofollow noreferrer">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>eval()</code>, as the name suggests, evaluates the passed argument.</p>
<p><code>raw_input()</code> is now <code>input()</code> in python 3.x versions. So the most commonly found example for the use of <code>eval()</code> is its use to provide the functionality that <code>input()</code> provided in 2.x version of python. 
raw_input returned the user-entered data as a string, while input evaluated the value of data entered and returned it. </p>
<p><code>eval(input("bla bla"))</code> thus replicates the functionality of <code>input()</code> in 2.x, i.e., of evaluating the user-entered data. </p>
<p>In short: <code>eval()</code> evaluates the arguments passed to it and hence <code>eval('1 + 1')</code> returned 2.</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe a misleading example of reading a line and interpreting it.</p>
<p>Try <code>eval(input())</code> and type <code>"1+1"</code> - this should print <code>2</code>. Eval evaluates expressions.</p>
</div>
<div class="post-text" itemprop="text">
<p>One of useful applications of <code>eval()</code> is to evaluate python expressions from string. For example load from file string representation of dictionary:</p>
<pre><code>running_params = {"Greeting":"Hello "}
fout = open("params.dat",'w')
fout.write(repr(running_params))
fout.close()
</code></pre>
<p>Read it out as a variable and edit it:</p>
<pre><code>fin = open("params.dat",'r')
diction=eval(fin.read())
diction["Greeting"]+="world"
fin.close()
print diction
</code></pre>
<p>Output:</p>
<pre><code>{'Greeting': 'Hello world'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm late to answer this question but, no one seems to give clear answer to the question.</p>
<p>If an user enters a numeric value, <code>input()</code> will return a string.</p>
<pre><code>&gt;&gt;&gt; input('Enter a number: ')
Enter a number: 3
&gt;&gt;&gt; '3'
&gt;&gt;&gt; input('Enter a number: ')
Enter a number: 1+1
'1+1'
</code></pre>
<p>So, <code>eval()</code> will evaluate returned value (or expression) which is a string and return integer/float.</p>
<pre><code>&gt;&gt;&gt; eval(input('Enter a number: '))
Enter a number: 1+1
2
&gt;&gt;&gt; 
&gt;&gt;&gt; eval(input('Enter a number: '))
Enter a number: 3.14
3.14
</code></pre>
<p>Of cource this is a bad practice. <code>int()</code> or <code>float()</code> should be used instead of <code>eval()</code> in this case.</p>
<pre><code>&gt;&gt;&gt; float(input('Enter a number: '))
Enter a number: 3.14
3.14
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another option if you want to limit the evaluation string to simple expressions is to use <code>ast.literal_eval()</code>:</p>
<pre><code>import ast

# print(ast.literal_eval(''))          # SyntaxError: unexpected EOF while parsing
# print(ast.literal_eval('a'))         # ValueError: malformed node or string
# print(ast.literal_eval('import os')) # SyntaxError: invalid syntax
print(ast.literal_eval('1+1'))         # 2
</code></pre>
<p>See the docs <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer">here</a>.</p>
</div>
<span class="comment-copy">Is that a Python 3.x book or a 2.x one? Either way, such liberal use of <code>eval</code> suggests it's an awful book.</span>
<span class="comment-copy">erm, just wondering...why did this get thumbs down? not complaining, just want to improve my questions..</span>
<span class="comment-copy">Your book sounds terrible. You should find a better book, perhaps <a href="http://www.greenteapress.com/thinkpython/html/index.html" rel="nofollow noreferrer">greenteapress.com/thinkpython/html/index.html</a></span>
<span class="comment-copy">@SolomonWise I'll thumb it up. I don't think it's a bad question.</span>
<span class="comment-copy">Saying the book is terrible without saying why is quite useless and improductive. The question is interesting and deserve thumbs up.</span>
<span class="comment-copy">haha, that was a trivial example, but you could let the user type in an arbitrary command and have python execute it. So you could have the user type in a command string and then have python run it as code. So for example: eval("__import__('os').remove('file')").</span>
<span class="comment-copy">It will seem useless until you find a need for it. It is used on sites like codepad.org to allow you to execute scripts in a test environment. <code>eval()</code> can also be used to execute highly-dynamic code, but you should make yourself fully aware of the security and performance risks before using it.</span>
<span class="comment-copy">@GeorgeCummins, codepad.org does not use <code>eval</code>, nor could it do what it does with <code>eval</code>.</span>
<span class="comment-copy">@GeorgeCummins: codepag.org runs everything in a sandbox: a chroot jail with ptrace checks in a virtual machine to prevent malicious code from doing anything bad. Far more complicated than a simple eval. Also, eval is Python-specific. codepad supports a bunch of languages.</span>
<span class="comment-copy">@GeorgeCummins, codepad runs a very complex system to safely run arbitrary programs. <code>eval</code>, other than being insecure, cannot run whole programs like codepad does because it can only evaluate a single expression.</span>
<span class="comment-copy">You mean using <code>eval</code> with <code>input()</code> is a security hole. Don't put <code>input()</code> inside an eval statement and you'll be fine.</span>
<span class="comment-copy">@Rohmer, unsafe data can come from everywhere: web requests, form input fields, file reads, ... not just from the console input. Even if you write the files yourself, it can still contain input that originally came from an untrusted source.  So <code>eval</code> is a security issue in many cases.</span>
<span class="comment-copy">since <code>input</code> usually takes its data from the console the user could just exit the program and type <code>rm -R *</code> anyway...</span>
<span class="comment-copy">Or it's a Python 3.x book, where <code>input</code> means what <code>raw_input</code> did in 2.x.</span>
<span class="comment-copy">Yeah that occurred to me after I wrote my initial answer, and that is clearly the case.</span>
<span class="comment-copy">Why should I type it between quotes? Input is getting a string, and passing it to eval, not executing the code, so I'd should be fine if I simply typed 1+1...  ¿?</span>
<span class="comment-copy">The thing is that you are mixing P2.x and 3.x. In Python 2 your code works, but it does not make sense to eval twice. In python 3 it does not, and returns a string.</span>
<span class="comment-copy">How does this answer the question which asks what <code>eval</code> does?</span>
