<div class="post-text" itemprop="text">
<p>How do I restrict a class member variable to be a specific type in Python?</p>
<hr/>
<p>Longer version:</p>
<p>I have a class that has several member variables which are set externally to the class. Due to the way they're used, they must be of specific types, either int or list. If this was C++, I would simply make them private and do type-checking in the 'set' function. Given that that isn't possible, is there any way to restrict the type of the variables so that an error/exception occurs at runtime if they're assigned a value of incorrect type? Or do I need to check their type within every function that uses them?</p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a property like the other answers put it -
so, if you want to constraina single attribute, say "bar",
and constrain it to an integer, you could write code like this:</p>
<pre><code>class Foo(object):
    def _get_bar(self):
        return self.__bar
    def _set_bar(self, value):
        if not isinstance(value, int):
            raise TypeError("bar must be set to an integer")
        self.__bar = value
    bar = property(_get_bar, _set_bar)
</code></pre>
<p>And this works:</p>
<pre><code>&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; f.bar = 3
&gt;&gt;&gt; f.bar
3
&gt;&gt;&gt; f.bar = "three"
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 6, in _set_bar
TypeError: bar must be set to an integer
&gt;&gt;&gt; 
</code></pre>
<p>(There is also a new way of writing properties, using the "property" built-in as a decorator to the getter method - but I prefer the old way, like I put it above).</p>
<p>Of course, if you have lots of attributes on your classes, and want to protect all of them in this way, it starts to get verbose. Nothing to worry about - Python's introspection abilities allow one to create a class decorator that could automate this with a minimum of lines.</p>
<pre><code>def getter_setter_gen(name, type_):
    def getter(self):
        return getattr(self, "__" + name)
    def setter(self, value):
        if not isinstance(value, type_):
            raise TypeError("%s attribute must be set to an instance of %s" % (name, type_))
        setattr(self, "__" + name, value)
    return property(getter, setter)

def auto_attr_check(cls):
    new_dct = {}
    for key, value in cls.__dict__.items():
        if isinstance(value, type):
            value = getter_setter_gen(key, value)
        new_dct[key] = value
    # Creates a new class, using the modified dictionary as the class dict:
    return type(cls)(cls.__name__, cls.__bases__, new_dct)
</code></pre>
<p>And you just use <code>auto_attr_check</code>as a class decorator, and declar the
attributes you want in the class body to be equal to the types the attributes need to constrain too:</p>
<pre><code>...     
... @auto_attr_check
... class Foo(object):
...     bar = int
...     baz = str
...     bam = float
... 
&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; f.bar = 5; f.baz = "hello"; f.bam = 5.0
&gt;&gt;&gt; f.bar = "hello"
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 6, in setter
TypeError: bar attribute must be set to an instance of &lt;type 'int'&gt;
&gt;&gt;&gt; f.baz = 5
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 6, in setter
TypeError: baz attribute must be set to an instance of &lt;type 'str'&gt;
&gt;&gt;&gt; f.bam = 3 + 2j
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 6, in setter
TypeError: bam attribute must be set to an instance of &lt;type 'float'&gt;
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In general, this is not a good idea for the reasons that @yak mentioned in his comment. You are basically preventing the user from supplying valid arguments that have the correct attributes/behavior but are not in the inheritance tree you hard-coded in.</p>
<p>Disclaimer aside, there are a few of options available for what you are trying to do. The main issue is that there are no private attributes in Python. So if you just have a plain old object reference, say <code>self._a</code>, you can not guarantee that the user won't set it directly even though you have provided a setter that does type checking for it. The options below demonstrate how to really enforce the type checking.</p>
<h1>Override __setattr__</h1>
<p>This method will only be convenient for a (very) small number of attributes that you do this to. The <code>__setattr__</code> method is what gets called when you use dot notation to assign a regular attribute. For example,</p>
<pre><code>class A:
    def __init__(self, a0):
        self.a = a0
</code></pre>
<p>If we now do <code>A().a = 32</code>, it would call <code>A().__setattr__('a', 32)</code> <a href="https://docs.python.org/3.5/reference/datamodel.html#customizing-attribute-access" rel="nofollow noreferrer">under the hood</a>. In fact, <code>self.a = a0</code> in <code>__init__</code> uses <code>self.__setattr__</code> as well. You can use this to enforce the type check:</p>
<pre><code> class A:
    def __init__(self, a0):
        self.a = a0
    def __setattr__(self, name, value):
        if name == 'a' and not isinstance(value, int):
            raise TypeError('A.a must be an int')
        super().__setattr__(name, value)
</code></pre>
<p>The disadvantage of this method is that you have to have a separate <code>if name == ...</code> for each type you want to check (or <code>if name in ...</code> to check multiple names for a given type). The advantage is that it is the most straightforward way to make it nearly impossible for the user to circumvent the type check.</p>
<h1>Make a property</h1>
<p>Properties are objects that replace your normal attribute with a descriptor object (usually by using a decorator). Descriptors can have <code>__get__</code> and <code>__set__</code> methods that customize how the underlying attribute is accessed. This is sort of like taking the corresponding <code>if</code> branch in <code>__setattr__</code> and putting it into a method that will run just for that attribute. Here is an example:</p>
<pre><code>class A:
    def __init__(self, a0):
        self.a = a0
    @property
    def a(self):
        return self._a
    @a.setter
    def a(self, value):
        if not isinstance(value, int):
            raise TypeError('A.a must be an int')
        self._a = value
</code></pre>
<p>A slightly different way of doing the same thing can be found in @jsbueno's answer.</p>
<p>While using a property this way is nifty and mostly solves the problem, it does present a couple of issues. The first is that you have a "private" <code>_a</code> attribute that the user can modify directly, bypassing your type check. This is almost the same problem as using a plain getter and setter, except that now <code>a</code> is accessible as the "correct" attribute that redirects to the setter behind the scenes, making it less likely that the user will mess with <code>_a</code>. The second issue is that you have a superfluous getter to make the property work as read-write. These issues are the subject of <a href="https://stackoverflow.com/q/17576009/2988730">this</a> question.</p>
<h1>Create a True Setter-Only Descriptor</h1>
<p>This solution is probably the most robust overall. It is suggested in the <a href="https://stackoverflow.com/a/17576095/2988730">accepted answer</a> to the question mentioned above. Basically, instead of using a property, which has a bunch of frills and conveniences that you can not get rid of, create your own descriptor (and decorator) and use that for any attributes that require type checking:</p>
<pre><code>class SetterProperty:
    def __init__(self, func, doc=None):
        self.func = func
        self.__doc__ = doc if doc is not None else func.__doc__
    def __set__(self, obj, value):
        return self.func(obj, value)

class A:
    def __init__(self, a0):
        self.a = a0
    @SetterProperty
    def a(self, value):
        if not isinstance(value, int):
            raise TypeError('A.a must be an int')
        self.__dict__['a'] = value
</code></pre>
<p>The setter stashes the actual value directly into the <code>__dict__</code> of the instance to avoid recursing into itself indefinitely. This makes it possible to get the attribute's value without supplying an explicit getter. Since the descriptor <code>a</code> does not have the <code>__get__</code> method, the search will continue until it finds the attribute in <code>__dict__</code>. This ensures that all sets go through the descriptor/setter while gets allow direct access to the attribute value.</p>
<p>If you have a large number of attributes that require a check like this, you can move the line <code>self.__dict__['a'] = value</code> into the descriptor's <code>__set__</code> method:</p>
<pre><code>class ValidatedSetterProperty:
    def __init__(self, func, name=None, doc=None):
        self.func = func
        self.__name__ = name if name is not None else func.__name__
        self.__doc__ = doc if doc is not None else func.__doc__
    def __set__(self, obj, value):
        ret = self.func(obj, value)
        obj.__dict__[self.__name__] = value

class A:
    def __init__(self, a0):
        self.a = a0
    @ValidatedSetterProperty
    def a(self, value):
        if not isinstance(value, int):
            raise TypeError('A.a must be an int')
</code></pre>
<p><strong>Update</strong></p>
<p>Python3.6 does this for you almost out-of the box: <a href="https://docs.python.org/3.6/whatsnew/3.6.html#pep-487-descriptor-protocol-enhancements" rel="nofollow noreferrer">https://docs.python.org/3.6/whatsnew/3.6.html#pep-487-descriptor-protocol-enhancements</a></p>
<h1>TL;DR</h1>
<p>For a very small number of attributes that need type-checking, override <code>__setattr__</code> directly. For a larger number of attributes, use the setter-only descriptor as shown above. Using properties directly for this sort of application introduces more problems than it solves.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since Python 3.5, you can use <a href="https://docs.python.org/3/library/typing.html" rel="nofollow noreferrer">type-hints</a> to indicate that a class attribute should be of a particular type. Then, you could include something like <a href="http://mypy.readthedocs.io/" rel="nofollow noreferrer">MyPy</a> as part of your continuous integration process to check that all the type contracts are respected.</p>
<p>For example, for the following Python script:</p>
<pre><code>class Foo:
    x: int
    y: int

foo = Foo()
foo.x = "hello"
</code></pre>
<p>MyPy would give the following error:</p>
<pre><code>6: error: Incompatible types in assignment (expression has type "str", variable has type "int")
</code></pre>
<p>If you want types to be enforced at runtime, you could use the <a href="https://github.com/RussBaz/enforce" rel="nofollow noreferrer">enforce</a> package.
From the README:</p>
<pre><code>&gt;&gt;&gt; import enforce
&gt;&gt;&gt;
&gt;&gt;&gt; @enforce.runtime_validation
... def foo(text: str) -&gt; None:
...     print(text)
&gt;&gt;&gt;
&gt;&gt;&gt; foo('Hello World')
Hello World
&gt;&gt;&gt;
&gt;&gt;&gt; foo(5)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/home/william/.local/lib/python3.5/site-packages/enforce/decorators.py", line 106, in universal
    _args, _kwargs = enforcer.validate_inputs(parameters)
  File "/home/william/.local/lib/python3.5/site-packages/enforce/enforcers.py", line 69, in validate_inputs
    raise RuntimeTypeError(exception_text)
enforce.exceptions.RuntimeTypeError: 
  The following runtime type errors were encountered:
       Argument 'text' was not of type &lt;class 'str'&gt;. Actual type was &lt;class 'int'&gt;.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Note 1: @Blckknght thank you for your fair comment. I missed recursion issue in my much too simple test suite.</p>
<p>Note 2: I wrote this answer when I was at the very beginning of learning Python. Right now I would rather use Python's descriptors, see e.g <a href="https://dev.to/dawranliou/writing-descriptors-in-python-36" rel="nofollow noreferrer">link1</a>, <a href="https://www.ibm.com/developerworks/library/os-pythondescriptors/index.html" rel="nofollow noreferrer">link2</a>.</p>
<p>Thanks to the previous posts and some thinking, I believe I have figured out a much more user-friendly way of how to restrict a class attribute to be of specific type.</p>
<p>First of all, we create a function, which universally tests for type:</p>
<pre><code>def ensure_type(value, types):
    if isinstance(value, types):
        return value
    else:
        raise TypeError('Value {value} is {value_type}, but should be {types}!'.format(
            value=value, value_type=type(value), types=types))
</code></pre>
<p>Then we simply use and apply it in our classes via setter. I think this is relatively simple and follow DRY, especially once you export it to a separate module to feed your whole project. See the example below:</p>
<pre><code>class Product:
    def __init__(self, name, quantity):
        self.name = name
        self.quantity = quantity

    @property
    def name(self):
        return self.__dict__['name']

    @name.setter
    def name(self, value):
        self.__dict__['name'] = ensure_type(value, str)

    @property
    def quantity(self):
        return self.quantity

    @quantity.setter
    def quantity(self, value):
        self.__dict__['quantity'] = ensure_type(value, int)
</code></pre>
<p>The tests produce reasonable results. See first the tests:</p>
<pre><code>if __name__ == '__main__':
    from traceback import format_exc

    try:
        p1 = Product(667, 5)
    except TypeError as err:
        print(format_exc(1))

    try:
        p2 = Product('Knight who say...', '5')
    except TypeError as err:
        print(format_exc(1))

    p1 = Product('SPAM', 2)
    p2 = Product('...and Love', 7)
    print('Objects p1 and p2 created successfully!')

    try:
        p1.name = -191581
    except TypeError as err:
        print(format_exc(1))

    try:
        p2.quantity = 'EGGS'
    except TypeError as err:
        print(format_exc(1))
</code></pre>
<p>And the tests result:</p>
<pre><code>Traceback (most recent call last):
  File "/Users/BadPhoenix/Desktop/Coding/Coders-Lab/Week-2/WAR_PYT_S_05_OOP/2_Praca_domowa/day-1/stackoverflow.py", line 35, in &lt;module&gt;
    p1 = Product(667, 5)
TypeError: Value 667 is &lt;class 'int'&gt;, but should be &lt;class 'str'&gt;!

Traceback (most recent call last):
  File "/Users/BadPhoenix/Desktop/Coding/Coders-Lab/Week-2/WAR_PYT_S_05_OOP/2_Praca_domowa/day-1/stackoverflow.py", line 40, in &lt;module&gt;
    p2 = Product('Knights who say...', '5')
TypeError: Value 5 is &lt;class 'str'&gt;, but should be &lt;class 'int'&gt;!

Objects p1 and p2 created successfully!

Traceback (most recent call last):
  File "/Users/BadPhoenix/Desktop/Coding/Coders-Lab/Week-2/WAR_PYT_S_05_OOP/2_Praca_domowa/day-1/stackoverflow.py", line 49, in &lt;module&gt;
    p1.name = -191581
TypeError: Value -191581 is &lt;class 'int'&gt;, but should be &lt;class 'str'&gt;!

Traceback (most recent call last):
  File "/Users/BadPhoenix/Desktop/Coding/Coders-Lab/Week-2/WAR_PYT_S_05_OOP/2_Praca_domowa/day-1/stackoverflow.py", line 54, in &lt;module&gt;
    p2.quantity = 'EGGS'
TypeError: Value EGGS is &lt;class 'str'&gt;, but should be &lt;class 'int'&gt;!
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use same type of <code>property</code> as you mention in C++. You will get help for property from <a href="http://adam.gomaa.us/blog/2008/aug/11/the-python-property-builtin/" rel="nofollow">http://adam.gomaa.us/blog/2008/aug/11/the-python-property-builtin/</a>. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can do it exactly as you say you said you would do it in C++; make assignment to them go through a setter method, and have the setter method check the type. The concepts of "private state" and "public interfaces" in Python are done with documentation and convention, and it's pretty much impossible to <strong>force</strong> anyone to use your setter rather than directly assign the variable. But if you give the attributes names beginning with an underscore and document the setters as the way to use your class, that should do it (don't use <code>__names</code> with two underscores; it's almost always more trouble than it's worth unless you're <strong>actually</strong> in the situation they're designed for, which is clashing attribute names in an inheritance hierarchy). Only particularly obtuse developers will avoid the easy way of using the class the way it's documented to work in favour of figuring out what the internal names are and using them directly; <strong>or</strong> developers who are frustrated by your class behaving unusually (for Python) and not allowing them to use a custom list-like class in place of a list.</p>
<p>You can use properties, as other answers have described, to do this while still making it look like you're assigning to attributes directly.</p>
<hr/>
<p>Personally, I find attempts to enforce type safety in Python to be pretty useless. Not because I think static type checking is always inferior, but because even if you could add type requirements on your Python variables that worked 100% of the time, they just won't be effective in maintaining the assurance that your program is free of type errors because <strong>they will only raise exceptions at runtime</strong>.</p>
<p>Think about it; when your statically compiled program successfully compiles with no errors, you know that it is completely free of all the bugs that the compiler can detect (in the case of languages like Haskell or Mercury that's a pretty good guarantee, though still not complete; in the case of languages like C++ or Java... meh).</p>
<p>But in Python, the type error will only be noticed if it is ever executed. This means, even if you could get full static type enforcement <em>everywhere</em> in your program, you need to be regularly executing test suites with 100% code coverage to actually know your program is free of type errors. But if you had regularly executed tests with full coverage you'd <strong>know</strong> if you had any type errors, even without attempting to enforce types! So the benefit just really doesn't seem worth it to me. You're throwing away Python's strength (flexibility) without gaining more than a trifle in one of its weaknesses (static error detection).</p>
</div>
<div class="post-text" itemprop="text">
<p>I know this discussion has been settled, but a much simpler solution is to use the Python Structure module show below.  This would require you to make a container for your data before you assign a value to it, but it is very effective at keeping the data type static.  <a href="https://pypi.python.org/pypi/structures" rel="nofollow noreferrer">https://pypi.python.org/pypi/structures</a></p>
</div>
<span class="comment-copy">The Pythonic way is to document the class appropriately. If wrong object type is set, the code will fail anyway. On the other hand the user may use a type that wouldn't pass your <code>isinstance</code> checks but otherwise is fine (duck typing).</span>
<span class="comment-copy">Is there a simple way to have multiple type checks, e.g. bar = int or float?</span>
<span class="comment-copy">Isinstance accepts a tuple of instances - since it is called on this code, you can simply use a tuple of types  there - it should just work: ` bar = int, float`</span>
<span class="comment-copy">The getter functions for your properties will recurse forever. You can't do <code>return self.name</code>, because that just invokes the getter again! You probably should be explicitly looking up your value in <code>self.__dict__</code>, since that's where you're setting it. Another option would be to use a different attribute name (like <code>_name</code> instead of <code>name</code>) for the value.</span>
<span class="comment-copy">Wouldn't help much. To have a property work that way, you would still need some storage within the instance, which the user could use to bypass the property. The only advantage is that you could make the internal value "private" with the leading underscore convention and not document it. But you could do that with a regular setter just as well.</span>
<span class="comment-copy">Link only answer are bad, and indeed the link is broken.</span>
<span class="comment-copy">Usually, type is more a guide for the developper when they actually use an object. It helps to pass the good type and inform the dev how to use the object's method properly. Also, it is a lot easier to debug with a "TypeError, wrong value passed to fonction x, need a 'list'" rather than "type int does not have 'append' function".  Why would you accept an integer in your function when you really need a list?</span>
<span class="comment-copy">@Nico It's not about accepting an integer when you really need a list. It's about accepting anything that has (suitably well-behaved) <code>append</code> method. Why would you reject my <code>Rope</code> class (specialised list of strings) when the code you've written works perfectly well on it? In one real world project I actually have a module with 5 different variations of dict-like class (with no superclass common to all of them except <code>object</code>). They would be useless if all the library code I'm using explicitly required instances of <code>dict</code>.</span>
<span class="comment-copy">"and it's pretty much impossible to force anyone to use your setter rather than directly assign the variable" actually - that is not true n Python. If you make use of descriptors (which are easily materialized with the <code>property</code> helper callable), it would require some ugly hacking around to not use the setter function at all.</span>
<span class="comment-copy">@jsbueno My point was that the ugly hacking is always possible (and generally not very difficult), if you've set your mind to it. So it won't stop people playing by the rules declared in your documentation, who aren't trying to access the private variable directly anyway, and it won't stop people who have decided (for wherever reason) that they need to get around the rules.</span>
<span class="comment-copy">OO encapsulation <b>is not</b> about preventing willing access to variables as a matter of security. You are controling a full system, in the same process - in Java you can access then with the reflection tools, and C++ gives you raw memory access. In that aspect Python is arguably even better because it does not give one a false sensation of security.</span>
