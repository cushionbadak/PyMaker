<div class="post-text" itemprop="text">
<p>Is output buffering enabled by default in Python's interpreter for <code>sys.stdout</code>?</p>
<p>If the answer is positive, what are all the ways to disable it?</p>
<p>Suggestions so far:</p>
<ol>
<li>Use the <code>-u</code> command line switch</li>
<li>Wrap <code>sys.stdout</code> in an object that flushes after every write</li>
<li>Set <code>PYTHONUNBUFFERED</code> env var</li>
<li><code>sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)</code></li>
</ol>
<p>Is there any other way to set some global flag in <code>sys</code>/<code>sys.stdout</code> programmatically during execution?</p>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="http://mail.python.org/pipermail/tutor/2003-November/026645.html" rel="noreferrer">Magnus Lycka answer on a mailing list</a>:</p>
<blockquote>
<p>You can skip buffering for a whole
  python process using "python -u" 
  (or#!/usr/bin/env python -u etc) or by
  setting the environment variable
  PYTHONUNBUFFERED.</p>
<p>You could also replace sys.stdout with
  some other stream like wrapper which
  does a flush after every call.</p>
<pre><code>class Unbuffered(object):
   def __init__(self, stream):
       self.stream = stream
   def write(self, data):
       self.stream.write(data)
       self.stream.flush()
   def writelines(self, datas):
       self.stream.writelines(datas)
       self.stream.flush()
   def __getattr__(self, attr):
       return getattr(self.stream, attr)

import sys
sys.stdout = Unbuffered(sys.stdout)
print 'Hello'
</code></pre>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I would rather put my answer in <a href="https://stackoverflow.com/questions/230751/how-to-flush-output-of-python-print">How to flush output of Python print?</a> or in <a href="https://stackoverflow.com/questions/3895481/pythons-print-function-that-flushes-the-buffer-when-its-called">Python's print function that flushes the buffer when it's called?</a>, but since they were marked as duplicates of this one (what I do not agree), I'll answer it here.</p>
<p>Since Python 3.3 print() supports the keyword argument "flush" (<a href="http://docs.python.org/3/library/functions.html?highlight=print#print" rel="noreferrer">see documentation</a>):</p>
<pre><code>print('Hello World!', flush=True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code># reopen stdout file descriptor with write mode
# and 0 as the buffer size (unbuffered)
sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)
</code></pre>
<p>Credits: "Sebastian", somewhere on the Python mailing list.</p>
<p><strong>3rd Party EDIT</strong></p>
<p><strong>Unsupported in recent versions of Python 3</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, it is.</p>
<p>You can disable it on the commandline with the "-u" switch.</p>
<p>Alternatively, you could call .flush() on sys.stdout on every write (or wrap it with an object that does this automatically)</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def disable_stdout_buffering():
    # Appending to gc.garbage is a way to stop an object from being
    # destroyed.  If the old sys.stdout is ever collected, it will
    # close() stdout, which is not good.
    gc.garbage.append(sys.stdout)
    sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)

# Then this will give output in the correct order:
disable_stdout_buffering()
print "hello"
subprocess.call(["echo", "bye"])
</code></pre>
<p>Without saving the old sys.stdout, disable_stdout_buffering() isn't idempotent, and multiple calls will result in an error like this:</p>
<pre><code>Traceback (most recent call last):
  File "test/buffering.py", line 17, in &lt;module&gt;
    print "hello"
IOError: [Errno 9] Bad file descriptor
close failed: [Errno 9] Bad file descriptor
</code></pre>
<p>Another possibility is:</p>
<pre><code>def disable_stdout_buffering():
    fileno = sys.stdout.fileno()
    temp_fd = os.dup(fileno)
    sys.stdout.close()
    os.dup2(temp_fd, fileno)
    os.close(temp_fd)
    sys.stdout = os.fdopen(fileno, "w", 0)
</code></pre>
<p>(Appending to gc.garbage is not such a good idea because it's where unfreeable cycles get put, and you might want to check for those.)</p>
</div>
<div class="post-text" itemprop="text">
<p>This relates to  Cristóvão D. Sousa's answer, but I couldn't comment yet.</p>
<p>A straight-forward way of using the <code>flush</code> keyword argument of <em>Python 3</em> in order to <strong>always</strong> have unbuffered output is:</p>
<pre><code>import functools
print = functools.partial(print, flush=True)
</code></pre>
<p>afterwards, print will always flush the output directly (except <code>flush=False</code> is given).</p>
<p>Note, (a) that this answers the question only partially as it doesn't redirect all the output. But I guess <code>print</code> is the most common way for creating output to <code>stdout</code>/<code>stderr</code> in python, so these 2 lines cover probably most of the use cases.</p>
<p>Note (b) that it only works in the module/script where you defined it. This can be good when writing a module as it doesn't mess with the <code>sys.stdout</code>.</p>
<p><em>Python 2</em> doesn't provide the <code>flush</code> argument, but you could emulate a Python 3-type <code>print</code> function as described here <a href="https://stackoverflow.com/a/27991478/3734258">https://stackoverflow.com/a/27991478/3734258</a> .</p>
</div>
<div class="post-text" itemprop="text">
<p>The following works in Python 2.6, 2.7, and 3.2:</p>
<pre><code>import os
import sys
buf_arg = 0
if sys.version_info[0] == 3:
    os.environ['PYTHONUNBUFFERED'] = '1'
    buf_arg = 1
sys.stdout = os.fdopen(sys.stdout.fileno(), 'a+', buf_arg)
sys.stderr = os.fdopen(sys.stderr.fileno(), 'a+', buf_arg)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, it is enabled by default. You can disable it by using the -u option on the command line when calling python.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can also run Python with <a href="https://www.gnu.org/software/coreutils/manual/html_node/stdbuf-invocation.html" rel="noreferrer" title="stdbuf">stdbuf</a> utility:</p>
<p><code>stdbuf -oL python &lt;script&gt;</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You can also use fcntl to change the file flags in-fly.</p>
<pre><code>fl = fcntl.fcntl(fd.fileno(), fcntl.F_GETFL)
fl |= os.O_SYNC # or os.O_DSYNC (if you don't care the file timestamp updates)
fcntl.fcntl(fd.fileno(), fcntl.F_SETFL, fl)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Variant that works without crashing (at least on win32; python 2.7, ipython 0.12) then called subsequently (multiple times):</p>
<pre><code>def DisOutBuffering():
    if sys.stdout.name == '&lt;stdout&gt;':
        sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)

    if sys.stderr.name == '&lt;stderr&gt;':
        sys.stderr = os.fdopen(sys.stderr.fileno(), 'w', 0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>(I've posted a comment, but it got lost somehow. So, again:)</p>
<ol>
<li><p>As I noticed, CPython (at least on Linux) behaves differently depending on where the output goes. If it goes to a tty, then the output is flushed after each '<code>\n'</code>
<br/>If it goes to a pipe/process, then it is buffered and you can use the <code>flush()</code> based solutions or the <strong>-u</strong> option recommended above.</p></li>
<li><p>Slightly related to output buffering:<br/>
If you iterate over the lines in the input with</p>
<p><code>for line in sys.stdin:</code>
<br/>...</p></li>
</ol>
<p>then the <strong>for</strong> implementation in <strong>CPython</strong> will collect the input for a while and then execute the loop body for a bunch of input lines. If your script is about to write output for each input line, this might look like output buffering but it's actually batching, and therefore, none of the <code>flush()</code>, etc. techniques will help that.
Interestingly, you don't have this behaviour in <strong>pypy</strong>.
To avoid this, you can use</p>
<p><code>while True:
   line=sys.stdin.readline()</code>
<br/>...</p>
</div>
<div class="post-text" itemprop="text">
<p>It is possible to override <em>only</em> <code>write</code> method of <code>sys.stdout</code> with one that calls <code>flush</code>. Suggested method implementation is below.</p>
<pre><code>def write_flush(args, w=stdout.write):
    w(args)
    stdout.flush()
</code></pre>
<p>Default value of <code>w</code> argument will keep original <code>write</code> method reference. <em>After</em> <code>write_flush</code> is defined, the original <code>write</code> might be overridden.</p>
<pre><code>stdout.write = write_flush
</code></pre>
<p>The code assumes that <code>stdout</code> is imported this way <code>from sys import stdout</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can create an unbuffered file and assign this file to sys.stdout.</p>
<pre><code>import sys 
myFile= open( "a.log", "w", 0 ) 
sys.stdout= myFile
</code></pre>
<p>You can't magically change the system-supplied stdout; since it's supplied to your python program by the OS.</p>
</div>
<div class="post-text" itemprop="text">
<p>One way to get unbuffered output would be to use <code>sys.stderr</code> instead of <code>sys.stdout</code> or to simply call <code>sys.stdout.flush()</code> to explicitly force a write to occur.</p>
<p>You could easily redirect everything printed by doing:</p>
<pre><code>import sys; sys.stdout = sys.stderr
print "Hello World!"
</code></pre>
<p>Or to redirect just for a particular <code>print</code> statement:</p>
<pre><code>print &gt;&gt;sys.stderr, "Hello World!"
</code></pre>
<p>To reset stdout you can just do:</p>
<pre><code>sys.stdout = sys.__stdout__
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3, you can monkey-patch the print function, to always send flush=True:</p>
<pre><code>_orig_print = print

def print(*args, **kwargs):
    _orig_print(*args, flush=True, **kwargs)
</code></pre>
</div>
<span class="comment-copy">For `print' in Python 3, see <a href="http://stackoverflow.com/a/14729823/918959">this answer</a>.</span>
<span class="comment-copy">I think a drawback of <code>-u</code> is that it won't work for compiled bytecode or for apps with a <code>__main__.py</code> file as entry point.</span>
<span class="comment-copy">Original sys.stdout is still available as sys.__stdout__. Just in case you need it =)</span>
<span class="comment-copy"><code>#!/usr/bin/env python -u</code> doesn't work!! see <a href="http://stackoverflow.com/q/3306518/674039">here</a></span>
<span class="comment-copy"><code>__getattr__</code> just to avoid inheritance?!</span>
<span class="comment-copy">Some notes to save some headaches: As I noticed, output buffering works differently depending on if the output goes to a tty or another process/pipe. If it goes to a tty, then it is flushed after each <i>\n</i>, but in a pipe it is buffered. In the latter case you can make use of these flushing solutions. In Cpython (not in pypy!!!): If you iterate over the input with <b>for line in sys.stdin:</b> ... then the for loop will collect a number of lines before the body of the loop is run. This will behave like buffering, though it's rather batching. Instead, do <b>while true: line = sys.stdin.readline()</b></span>
<span class="comment-copy">@tzp: you could use <code>iter()</code> instead of the <code>while</code> loop: <code>for line in iter(pipe.readline, ''):</code>. You don't need it on Python 3 where <code>for line in pipe:</code> yields as soon as possible.</span>
<span class="comment-copy">This doesn't work anymore in Python 3, see PEP 3116.</span>
<span class="comment-copy">@sorin: Yes it does. Please explain your claim.</span>
<span class="comment-copy">On Python 3 the above line will throw an exception: <code>ValueError: can't have unbuffered text I/O</code>.</span>
<span class="comment-copy">@sorin: I see your point. I was testing with the intent to output binary.</span>
<span class="comment-copy">@meawoppl: you could pass<code>flush=True</code> parameter to <code>print()</code> function since Python 3.3.</span>
<span class="comment-copy">If the old <code>stdout</code> still lives on <code>sys.__stdout__</code> as some have suggested, the garbage thing won't be necessary, right? It's a cool trick though.</span>
<span class="comment-copy">As with @Federico's answer, this will not work with Python 3, as it will throw the exception <code>ValueError: can't have unbuffered text I/O</code> when calling <code>print()</code>.</span>
<span class="comment-copy">Your "another possibility" seems at first like the most robust solution, but unfortunately it suffers a race condition in the case that another thread calls open() after your sys.stdout.close() and before your os.dup2(temp_fd, fileno).  I found this out when I tried using your technique under ThreadSanitizer, which does exactly that.  The failure is made louder by the fact that dup2() fails with EBUSY when it races with open() like that; see <a href="https://stackoverflow.com/questions/23440216/race-condition-when-using-dup2" title="race condition when using dup2">stackoverflow.com/questions/23440216/…</a></span>
<span class="comment-copy">Except that there is no <code>flush</code> kwarg in python2.</span>
<span class="comment-copy">@o11c , yes you're right. I was sure I tested it but somehow I was seemingly confused (: I modified my answer, hope it's fine now. Thanks!</span>
<span class="comment-copy">This is the cleanest and most portable way.</span>
<span class="comment-copy">Run that twice and it crashes on windows :-)</span>
<span class="comment-copy">@MichaelClerx Mmm hmm, always remember to close your files xD.</span>
<span class="comment-copy">isn't this *nix only?</span>
<span class="comment-copy">ah... that's probably right.</span>
<span class="comment-copy">There's a windows equivalent: <a href="http://stackoverflow.com/questions/881696/unbuffered-stdout-in-python-as-in-python-u-from-within-the-program/881751#881751" title="unbuffered stdout in python as in python u from within the program">stackoverflow.com/questions/881696/…</a></span>
<span class="comment-copy">O_SYNC has nothing at all to do with userspace-level buffering that this question is asking about.</span>
<span class="comment-copy">Are you sure this is not buffered?</span>
<span class="comment-copy">Should you check for <code>sys.stdout is sys.__stdout__</code> instead of relying on the replacement object having a name attribute?</span>
<span class="comment-copy">this works great if gunicorn isn't respecting PYTHONUNBUFFERED for some reason.</span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/107705/python-output-buffering/107717#comment24604506_107717">here's your comment</a>. It might be a bug on older Python versions. Could you provide example code? Something like <a href="http://ideone.com/TzHwlX" rel="nofollow noreferrer"><code>for line in sys.stdin</code></a> vs. <a href="http://ideone.com/mMxn09" rel="nofollow noreferrer"><code>for line in iter(sys.stdin.readline, "")</code></a></span>
<span class="comment-copy">for line in sys.stdin:         print("Line: " +line);         sys.stdout.flush()</span>
<span class="comment-copy">it looks like <a href="https://bugs.python.org/issue3907" rel="nofollow noreferrer">the read-ahead bug</a>. It should only happen on Python 2 and if stdin is a pipe. The code in my previous comment demonstrates the issue (<code>for line in sys.stdin</code> provides a delayed response)</span>
<span class="comment-copy">This might get very confusing when you then later try to capture the output using standard redirection, and find you are capturing nothing!  p.s. your <b>stdout</b> is being bolded and stuff.</span>
<span class="comment-copy">One big caution about selectively printing to stderr is that this causes the lines to appear out of place, so unless you also have timestamp this could get very confusing.</span>
