<div class="post-text" itemprop="text">
<p>Does anyone know why these two return different ratios.</p>
<pre><code>&gt;&gt;&gt; import difflib
&gt;&gt;&gt; difflib.SequenceMatcher(None, '10101789', '11426089').ratio()
0.5
&gt;&gt;&gt; difflib.SequenceMatcher(None, '11426089', '10101789').ratio()
0.625
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://epydoc.sourceforge.net/stdlib/difflib.SequenceMatcher-class.html" rel="nofollow">This</a> gives some ideas of how matching works.</p>
<pre><code>&gt;&gt;&gt; import difflib
&gt;&gt;&gt; 
&gt;&gt;&gt; def print_matches(a, b):
...     s =  difflib.SequenceMatcher(None, a, b)
...     for block in s.get_matching_blocks():
...         print "a[%d] and b[%d] match for %d elements" % block
...     print s.ratio()
... 
&gt;&gt;&gt; print_matches('01017', '14260')
a[0] and b[4] match for 1 elements
a[5] and b[5] match for 0 elements
0.2
&gt;&gt;&gt; print_matches('14260', '01017')
a[0] and b[1] match for 1 elements
a[4] and b[2] match for 1 elements
a[5] and b[5] match for 0 elements
0.4
</code></pre>
<p>It looks as if it matches as much as it can on the first sequence against the second and continues from the matches. In this case ('01017', '14260'), the righthand match is on the 0, the last character, so no further matches on the right are possible. In this case ('14260', '01017'), the 1s match and the 0 still is available to match on the right, so two matches are found.</p>
<p>I think the matching algorithm is commutative against sorted sequences.</p>
</div>
<div class="post-text" itemprop="text">
<p>I was working with <code>difflib</code> lately, and though this answer is late, I thought it might add a little spice to the answer provided by <a href="https://stackoverflow.com/questions/9321669/difflib-returns-different-ratio-depending-on-order-of-sequences/9322135#9322135">hughdbrown</a> as it shows what's happening visually.</p>
<p>Before I go to the code snippet, let me quote the <a href="https://docs.python.org/3.5/library/difflib.html#difflib.SequenceMatcher" rel="nofollow noreferrer">documentation</a></p>
<blockquote>
<p>The idea is to find the longest contiguous matching subsequence that
  contains no "junk" elements; these "junk" elements are ones that are
  uninteresting in some sense, such as blank lines or whitespace.
  (Handling junk is an extension to the Ratcliff and Obershelp
  algorithm.) The same idea is then applied recursively to the pieces of
  the sequences to the left and to the right of the matching
  subsequence. <strong>This does not yield minimal edit sequences, but does tend
  to yield matches that “look right” to people.</strong></p>
</blockquote>
<p>I think comparing the first string <strong>against</strong> the second one and then finding matches <strong>looks right</strong> <em>enough</em> to people. This is explained nicely in the answer by <a href="https://stackoverflow.com/questions/9321669/difflib-returns-different-ratio-depending-on-order-of-sequences/9322135#9322135">hughdbrown</a>.</p>
<p>Now try and run this code snippet:</p>
<pre><code>def show_matching_blocks(a, b):
    s = SequenceMatcher(None, a, b)
    m = s.get_matching_blocks()
    seqs = [a, b]

    new_seqs = []
    for select, seq in enumerate(seqs):
        i, n = 0, 0
        new_seq = ''
        while i &lt; len(seq):
            if i == m[n][select]:
                new_seq += '{' + seq[m[n][select]:m[n][select] + m[n].size] + '}'
                i += m[n].size
                n += 1
            elif i &lt; m[n][select]:
                new_seq += seq[i:m[n][select]]
                i = m[n][select]
        new_seqs.append(new_seq)
    for seq, n in zip(seqs, new_seqs):
        print('{} --&gt; {}'.format(seq, n))
    print('')

a, b = '10101789', '11426089'
show_matching_blocks(a, b)
show_matching_blocks(b, a)
</code></pre>
<p>Output:</p>
<pre><code>10101789 --&gt; {1}{0}1017{89}
11426089 --&gt; {1}1426{0}{89}

11426089 --&gt; {1}{1}426{0}{89}
10101789 --&gt; {1}0{1}{0}17{89}
</code></pre>
<p>The parts inside braces (<code>{}</code>) are the matching parts. I just used <a href="https://docs.python.org/3/library/difflib.html#difflib.SequenceMatcher.get_matching_blocks" rel="nofollow noreferrer"><code>SequenceMatcher.get_matching_blocks()</code></a> to put the matching blocks within braces for better visibility. You can clearly see the difference when the order is reversed. With the first order, there are 4 matches, so the ratio is <code>2*4/16=0.5</code>. But when the order is reversed, there are now 5 matches, so the ratio becomes <code>2*5/16=0.625</code>. The ratio is calculated as given <a href="http://docs.python.org/3/library/difflib.html#difflib.SequenceMatcher.ratio" rel="nofollow noreferrer">here in the documentation</a></p>
</div>
<span class="comment-copy">Well is there anywhere that it says <code>SequenceMatcher</code> should be commutative?</span>
<span class="comment-copy">Hey is there any way to get the number of matches?</span>
