<div class="post-text" itemprop="text">
<p>Yesterday I was doing some testing to identify the type of an element from a list. </p>
<pre><code>types={"float":float, "int":int, "str":str}   
try:    
    sql_type = next (k for k,v in types.iteritems() if isinstance (uniqLst[0],v))    
except TypeError as Typeerr:    
    print "Type not right: " + str(Typeerr)    
</code></pre>
<p>Well, of course the element turns out to always be a string as the data the list holds derives from a text file. I was wondering what might be a good way to check the true nature of the element. Should you really go for a <code>try/except</code> solution, like:</p>
<pre><code>def check_type(element):
    try:
        int(element)
        return 'int'
    except:
       pass
    try:
       float(element)
       return 'float'
    except:
        pass
    try:
        str(element)
        return 'str'
    except:
        return 'error type'
</code></pre>
<p>What about <code>re.compile</code>? (And then something like <code>('[0-9]+')</code>) Doesn't seem very practical to me. Any advice is very much appreciated!  </p>
<p>Cheers, LarsVegas</p>
</div>
<div class="post-text" itemprop="text">
<p>Based on your comment to ikanobori's answer, you might be looking for the following <a href="http://docs.python.org/release/3.2/library/stdtypes.html#string-methods" rel="nofollow">string methods</a>:</p>
<pre><code>str.isalnum()
</code></pre>
<p>Return true if all characters in the string are alphanumeric and there is at least one character, false otherwise. A character c is alphanumeric if one of the following returns True: c.isalpha(), c.isdecimal(), c.isdigit(), or c.isnumeric().</p>
<pre><code>str.isalpha()
</code></pre>
<p>Return true if all characters in the string are alphabetic and there is at least one character, false otherwise. Alphabetic characters are those characters defined in the Unicode character database as “Letter”, i.e., those with general category property being one of “Lm”, “Lt”, “Lu”, “Ll”, or “Lo”. Note that this is different from the “Alphabetic” property defined in the Unicode Standard.</p>
<pre><code>str.isdecimal()
</code></pre>
<p>Return true if all characters in the string are decimal characters and there is at least one character, false otherwise. Decimal characters are those from general category “Nd”. This category includes digit characters, and all characters that that can be used to form decimal-radix numbers, e.g. U+0660, ARABIC-INDIC DIGIT ZERO.</p>
<pre><code>str.isdigit()
</code></pre>
<p>Return true if all characters in the string are digits and there is at least one character, false otherwise. Digits include decimal characters and digits that need special handling, such as the compatibility superscript digits. Formally, a digit is a character that has the property value Numeric_Type=Digit or Numeric_Type=Decimal.</p>
<pre><code>str.isidentifier()
</code></pre>
<p>Return true if the string is a valid identifier according to the language definition, section Identifiers and keywords.</p>
<pre><code>str.islower()
</code></pre>
<p>Return true if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. Cased characters are those with general category property being one of “Lu”, “Ll”, or “Lt” and lowercase characters are those with general category property “Ll”.</p>
<pre><code>str.isnumeric()
</code></pre>
<p>Return true if all characters in the string are numeric characters, and there is at least one character, false otherwise. Numeric characters include digit characters, and all characters that have the Unicode numeric value property, e.g. U+2155, VULGAR FRACTION ONE FIFTH. Formally, numeric characters are those with the property value Numeric_Type=Digit, Numeric_Type=Decimal or Numeric_Type=Numeric.</p>
<pre><code>str.isprintable()
</code></pre>
<p>Return true if all characters in the string are printable or the string is empty, false otherwise. Nonprintable characters are those characters defined in the Unicode character database as “Other” or “Separator”, excepting the ASCII space (0x20) which is considered printable. (Note that printable characters in this context are those which should not be escaped when repr() is invoked on a string. It has no bearing on the handling of strings written to sys.stdout or sys.stderr.)</p>
<pre><code>str.isspace()
</code></pre>
<p>Return true if there are only whitespace characters in the string and there is at least one character, false otherwise. Whitespace characters are those characters defined in the Unicode character database as “Other” or “Separator” and those with bidirectional property being one of “WS”, “B”, or “S”.</p>
<pre><code>str.istitle()
</code></pre>
<p>Return true if the string is a titlecased string and there is at least one character, for example uppercase characters may only follow uncased characters and lowercase characters only cased ones. Return false otherwise.</p>
<pre><code>str.isupper()
</code></pre>
<p>Return true if all cased characters in the string are uppercase and there is at least one cased character, false otherwise. Cased characters are those with general category property being one of “Lu”, “Ll”, or “Lt” and uppercase characters are those with general category property “Lu”.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is strongly discouraged to use type-checking in Python. Why do you need to know the types?</p>
<p>Python employs duck-typing, meaning I can create my own subclass of the Integer object which behaves the exact same way only it is not an instance of 'type int' which would defeat your type checking adventure.</p>
<p>The idea is to use an object in the way you want to use it and if that fails raise an exception, that way you give both yourself and eventual other coders who work with your code that much more freedom :-)</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/a/9480703/596361">@Weetu's answer</a> is a great overview of how Python <a href="https://docs.python.org/2/library/stdtypes.html#string-methods" rel="nofollow noreferrer">string predicates</a> correspond to <a href="http://www.unicode.org/versions/Unicode5.0.0/ch04.pdf" rel="nofollow noreferrer">Unicode general category properties</a>.</p>
<p>As an exercise I tried to write a program to figure out myself, which string predicate (e.g. <code>isdigit</code>) correspond to which character properties. So I opened <a href="http://www.fileformat.info/info/unicode/category/index.htm" rel="nofollow noreferrer">Unicode Character Categories</a> and filled a dictionary with keys being 2-letter categories (<code>'Lt'</code>) and value being example Unicode characters (<code>u'ǅ'</code>), then wrote a program to get correspondence between string predicates and character properties. I used Python 3, because Python 2 had some mysterious Unicode bug <em>(I'll be glad, if you point out, why code below works incorrectly in Python 2)</em>.</p>
<pre><code>d = {
    'Cc': u'',   'LC': None,  'Pc': u'_',  'Sc': u'$', 
    'Cf': u'𑂽', 'Ll': u'a',  'Pd': u'-',  'Sk': u'^',
    'Cn': None,  'Lm': u'ʰ',  'Pe': u')',  'Sm': u'+',
    'Co': u'',  'Lo': u'ª',  'Pf': u'»',  'So': u'¦',
    'Cs': u'⠀',  'Lt': u'ǅ', 'Pi': u'«',
                 'Lu': u'A',  'Po': u'!',
                              'Ps': u'(',
    'Mc': u'ः', 'Nd': u'0',  'Zl': u' ',
    'Me': u'҈',  'Nl': u'ᛮ',  'Zp': u' ',
    'Mn': u'̀',   'No': u'²',  'Zs': u' '                                    
} # Zl and Zp have invisible characters that break Markdown's code blocks</code></pre>
<pre><code>methods = ['isalnum', 'isalpha', 'isdigit', 'islower', 'isspace',
           'istitle', 'isupper', 'isnumeric', 'isdecimal']

dl = {method: [code
               for code, character
               in d.items()
               if character and getattr(character, method)()]
      for method in methods}
</code></pre>
<p>Result is below. E.g. <code>ch.isdigit()</code> will return <code>True</code> if <code>ch</code> has either <code>No</code> or <code>Nd</code> Unicode property.</p>
<pre><code>&gt;&gt;&gt; from pprint import pprint # pretty printing
&gt;&gt;&gt; pprint(dl)
{'isalnum': ['No', 'Nd', 'Nl', 'Lu', 'Lt', 'Lo', 'Lm', 'Ll'],
 'isalpha': ['Lu', 'Lt', 'Lo', 'Lm', 'Ll'],
 'isdecimal': ['Nd'],
 'isdigit': ['No', 'Nd'],
 'islower': ['Lo', 'Lm', 'Ll'],
 'isnumeric': ['No', 'Nd', 'Nl'],
 'isspace': ['Zp', 'Zs', 'Zl'],
 'istitle': ['Lu', 'Lt'],
 'isupper': ['Lu']}
</code></pre>
<p>For more intelligent operations with Unicode Character Database, see Python library <a href="https://docs.python.org/3/library/unicodedata.html" rel="nofollow noreferrer">unicodedata</a>.</p>
<p><strong>References:</strong></p>
<ul>
<li><a href="https://docs.python.org/3/tutorial/datastructures.html#tut-listcomps" rel="nofollow noreferrer">List comprehensions</a></li>
<li><a href="https://stackoverflow.com/a/1747827/596361">Dict comprehensions</a></li>
<li><a href="https://docs.python.org/3/library/stdtypes.html#dict.items" rel="nofollow noreferrer"><code>dict.items()</code></a></li>
<li><a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow noreferrer"><code>getattr</code></a></li>
<li><a href="https://docs.python.org/3/library/pprint.html" rel="nofollow noreferrer"><code>pprint</code> library</a></li>
</ul>
</div>
<span class="comment-copy">thanks for this nice overview! It will be of great help.</span>
<span class="comment-copy">Well, I read the data from a txt file and want to execute a sql statement based on it. The thing is: in the txt file could be anything - integers, floats, strings. That's why I need to check their type before putting together the statement.</span>
<span class="comment-copy">No, in the text file everything is a string so you would already be converting from string to your types meaning you already <i>have</i> the information on what types they are, why the need to check again? Also if you are using a Python DB-API compliant database module (most of them are) your bound parameters would solve the need for manual typechecking and handle the coercion for you?</span>
<span class="comment-copy">I know that everything in the text file is a string, that is what I said in the introduction to my question. But they could 'actually' be something else, so yes, there would be need for a conversion. Technically I can solve the problem, I was just curious what would be a good way to go about. I get the point that it's not recommended to do type checking. But the string methods mentioned by @Weetu show that there apparently is the need to find out more about the nature of your string(s). However, thanks for your reply and your insight on this topic. Cheers, LarsVegas</span>
<span class="comment-copy">No problem I probably just focused too much on the type checking part of your question :-)</span>
