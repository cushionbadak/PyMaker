<div class="post-text" itemprop="text">
<p>I have come across this:</p>
<pre><code>item = someSortOfSelection()
if item in myList:
    doMySpecialFunction(item)
</code></pre>
<p>but sometimes it does not work with all my items, as if they weren't recognized in the list (when it's a list of string).</p>
<p>Is this the most 'pythonic' way of finding an item in a list: <code>if x in l:</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>As for your first question: that code is perfectly fine and should work if <code>item</code> equals one of the elements inside <code>myList</code>. Maybe you try to find a string that does not <em>exactly</em> match one of the items or maybe you are using a float value which suffers from inaccuracy.</p>
<p>As for your second question: There's actually several possible ways if "finding" things in lists.</p>
<h3>Checking if something is inside</h3>
<p>This is the use case you describe: Checking whether something is inside a list or not. As you know, you can use the <code>in</code> operator for that:</p>
<pre><code>3 in [1, 2, 3] # =&gt; True
</code></pre>
<h3>Filtering a collection</h3>
<p>That is, finding all elements in a sequence that meet a certain condition. You can use list comprehension or generator expressions for that:</p>
<pre><code>matches = [x for x in lst if fulfills_some_condition(x)]
matches = (x for x in lst if x &gt; 6)
</code></pre>
<p>The latter will return a <em>generator</em> which you can imagine as a sort of lazy list that will only be built as soon as you iterate through it. By the way, the first one is exactly equivalent to</p>
<pre><code>matches = filter(fulfills_some_condition, lst)
</code></pre>
<p>in Python 2. Here you can see higher-order functions at work. In Python 3, <code>filter</code> doesn't return a list, but a generator-like object.</p>
<h3>Finding the first occurrence</h3>
<p>If you only want the first thing that matches a condition (but you don't know what it is yet), it's fine to use a for loop (possibly using the <code>else</code> clause as well, which is not really well-known). You can also use</p>
<pre><code>next(x for x in lst if ...)
</code></pre>
<p>which will return the first match or raise a <code>StopIteration</code> if none is found. Alternatively, you can use</p>
<pre><code>next((x for x in lst if ...), [default value])
</code></pre>
<h3>Finding the location of an item</h3>
<p>For lists, there's also the <code>index</code> method that can sometimes be useful if you want to know <em>where</em> a certain element is in the list:</p>
<pre><code>[1,2,3].index(2) # =&gt; 1
[1,2,3].index(4) # =&gt; ValueError
</code></pre>
<p>However, note that if you have duplicates, <code>.index</code> always returns the lowest index:......</p>
<pre><code>[1,2,3,2].index(2) # =&gt; 1
</code></pre>
<p>If there are duplicates and you want all the indexes then you can use <code>enumerate()</code> instead:</p>
<pre><code>[i for i,x in enumerate([1,2,3,2]) if x==2] # =&gt; [1, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to find one element or <code>None</code> use default in <code>next</code>, it won't raise <code>StopIteration</code> if the item was not found in the list:</p>
<pre><code>first_or_default = next((x for x in lst if ...), None)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>While the answer from Niklas B. is pretty comprehensive, when we want to find an item in a list it is sometimes useful to get its index:</p>
<pre><code>next((i for i, x in enumerate(lst) if [condition on x]), [default value])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Finding the first occurrence</strong></p>
<p>There's a recipe for that in <code>itertools</code>:</p>
<pre><code>def first_true(iterable, default=False, pred=None):
    """Returns the first true value in the iterable.

    If no true value is found, returns *default*

    If *pred* is not None, returns the first item
    for which pred(item) is true.

    """
    # first_true([a,b,c], x) --&gt; a or b or c or x
    # first_true([a,b], x, f) --&gt; a if f(a) else b if f(b) else x
    return next(filter(pred, iterable), default)
</code></pre>
<p>For example, the following code finds the first odd number in a list:</p>
<pre><code>&gt;&gt;&gt; first_true([2,3,4,5], None, lambda x: x%2==1)
3  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another alternative: you can check if an item is in a list with <code>if item in list:</code>, but this is order O(n). If you are dealing with big lists of items and all you need to know is whether something is a member of your list, you can convert the list to a set first and take advantage of <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">constant time set lookup</a>:</p>
<pre><code>my_set = set(my_list)
if item in my_set:  # much faster on average than using a list
    # do something
</code></pre>
<p>Not going to be the correct solution in every case, but for some cases this might give you better performance.</p>
<p>Note that creating the set with <code>set(my_list)</code> is also O(n), so if you only need to do this once then it isn't any faster to do it this way. If you need to repeatedly check membership though, then this will be O(1) for every lookup after that initial set creation.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>list = [10, 20, 30, 40, 50]
n = int(input("\nEnter a Number to search from the list : "))

if n in list :
    print("\nMatch found")  
else :
    print("\nMatch not found")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Check there are no additional/unwanted whites space in the items of the list of strings.
That's a reason that can be interfering explaining the items cannot be found.</p>
</div>
<div class="post-text" itemprop="text">
<p>You may want to use one of two possible searches while working with list of strings:</p>
<ol>
<li><p>if list element is <strong>equal</strong> to an item ('example' is in
['one','example','two']):</p>
<p><code>if item in your_list: some_function_on_true()</code></p>
<p>'ex'   in ['one','ex','two'] =&gt; True</p>
<p>'ex_1' in ['one','ex','two'] =&gt; False</p></li>
<li><p>if list element is <strong>like</strong> an item ('ex' is in
['one,'example','two'] or 'example_1' is in
['one','example','two']):</p>
<p><code>matches = [el for el in your_list if item in el]</code></p>
<p>or</p>
<p><code>matches = [el for el in your_list if el in item]</code></p>
<p>then just check <code>len(matches)</code> or read them if needed.  </p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Instead of using <code>list.index(x)</code> which returns the index of x if it is found in list or returns a <code>#ValueError</code> message if x is not found, you could use <code>list.count(x)</code> which returns the number of occurrences of x in list (validation that x is indeed in the list) or it returns 0 otherwise (in the absence of x). The cool thing about <code>count()</code> is that it doesn't break your code or require you to throw an exception for when x is not found</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Definition and Usage</strong></p>
<p>the <code>count()</code> method returns the number of elements with the specified value.</p>
<p><strong>Syntax</strong></p>
<pre><code>list.count(value)
</code></pre>
<p><strong>example:</strong></p>
<pre><code>fruits = ['apple', 'banana', 'cherry']

x = fruits.count("cherry")
</code></pre>
<p><strong>Question's example:</strong></p>
<pre><code>item = someSortOfSelection()

if myList.count(item) &gt;= 1 :

    doMySpecialFunction(item)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For example, if you want to find the index of all elements bigger than 30:</p>
<pre><code>your_list = [11,22,23,44,55]
filter(lambda x:your_list[x]&gt;30,range(len(your_list)))

#result: [3,4]
</code></pre>
</div>
<span class="comment-copy">Do you have a code sample? What exactly is not being recognized?</span>
<span class="comment-copy">That's perfectly fine and should work if item equals one of the elements inside <code>myList</code>.</span>
<span class="comment-copy">do you mean it was the good way to do things ? in my several trials, maybe there was whitespaces, and line feeds intereferring... i just wanted to be sure it is the good way to implement "find in list" (in general)</span>
<span class="comment-copy">Stephane: Let me rephrase it: <code>if x in list</code> is <i>not</i> the thing that people complain not being a built-in function. They complain about the fact that there is not explicit way to find the first occurrence of something in a list that matches a certain condition. But as stated in my answer, <code>next()</code> can be (ab)used for that.</span>
<span class="comment-copy">@Stephane: The second one does not generate a tuple, but a generator (which is a not-yet-built list, basically). If you want to use the result only once, a generator is usually preferrable. However, if you want to use the created collection several times afterwards, it's advisable to create an explicit list in the first place. Have a look at my update, it's now a bit better structured :)</span>
<span class="comment-copy">Your "finding first occurrence" example is golden.  Feels more pythonic than the <code>[list comprehension...][0]</code> approach</span>
<span class="comment-copy">I am more and more dissiapointed with python 'functional' capabilities. In haskell there is find function in Data.List module that doing exactly that. But in python it's not and it's to small to make it a library so you have to reimplement the same logic over and over again. What a waste...</span>
<span class="comment-copy">It would be nice if there was a kwarg to <code>index()</code> called <code>key</code> that worked like the <code>key</code> accepted by <code>max()</code>; for example: <code>index(list, key=is_prime)</code>.</span>
<span class="comment-copy">The most concise solution for me. This one matches the question the best.</span>
<span class="comment-copy"><code>next</code> takes an iterator as the first parameter and a list/tuple is NOT an iterator. So it should be <code>first_or_default = next(iter([x for x in lst if ...]), None)</code> see <a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow noreferrer">docs.python.org/3/library/functions.html#next</a></span>
<span class="comment-copy">@Devy: that's right, but <code>(x for x in lst if ...)</code> is a generator over the list <code>lst</code> (which <i>is</i> an iterator). If you do <code>next(iter([x for x in lst if ...]), None)</code>, you have to construct the list <code>[x for x in lst if ...]</code>, which will be a much more expensive operation.</span>
<span class="comment-copy">There is an abstraction in here to define a find function. Just encapsulate the the boolean expession of the <code>if</code> in a lambda &amp; you can write <code>find(fn,list)</code> usually instead of obfuscating generator code.</span>
<span class="comment-copy">This is the first time I saw this function called 'next()', its beautifully used here!</span>
<span class="comment-copy">Please make an attempt to format your code when posting answers, thanks</span>
