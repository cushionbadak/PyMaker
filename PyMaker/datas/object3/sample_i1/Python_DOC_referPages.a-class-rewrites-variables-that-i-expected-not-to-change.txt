Natural Text
What are the options to clone or copy a list in Python?While using new_list = my_list, any modifications to new_list changes my_list everytime.Why is this?
With new_list = my_list, you don't actually have two lists. The assignment just copies the reference to the list, not the actual list, so both new_list and my_list refer to the same list after the assignment.To actually copy the list, you have various possibilities:You can use the builtin list.copy() method (available since python 3.3):You can slice it: Alex Martelli's opinion (at least back in 2007) about this is, that it is a weird syntax and it does not make sense to use it ever. ;) (In his opinion, the next one is more readable).You can use the built in list() function:You can use generic copy.copy():This is a little slower than list() because it has to find out the datatype of old_list first.If the list contains objects and you want to copy them as well, use generic copy.deepcopy():Obviously the slowest and most memory-needing method, but sometimes unavoidable.Example:Result:
Felix already provided an excellent answer, but I thought I'd do a speed comparison of the various methods:10.59 sec (105.9us/itn) -  copy.deepcopy(old_list)10.16 sec (101.6us/itn) - pure python Copy() method copying classes with deepcopy1.488 sec (14.88us/itn) - pure python Copy() method not copying classes (only dicts/lists/tuples)0.325 sec (3.25us/itn) - for item in old_list: new_list.append(item)0.217 sec (2.17us/itn) - [i for i in old_list] (a list comprehension)0.186 sec (1.86us/itn) - copy.copy(old_list)0.075 sec (0.75us/itn) - list(old_list)0.053 sec (0.53us/itn) - new_list = []; new_list.extend(old_list)0.039 sec (0.39us/itn) - old_list[:] (list slicing)So the fastest is list slicing. But be aware that copy.copy(), list[:] and list(list), unlike copy.deepcopy() and the python version don't copy any lists, dictionaries and class instances in the list, so if the originals change, they will change in the copied list too and vice versa.(Here's the script if anyone's interested or wants to raise any issues:)EDIT: Added new-style, old-style classes and dicts to the benchmarks, and made the python version much faster and added some more methods including list expressions and extend().
I've been told that Python 3.3+ adds list.copy() method, which should be as fast as slicing:newlist = old_list.copy()
What are the options to clone or copy a list in Python?In Python 3, a shallow copy can be made with:In Python 2 and 3, you can get a shallow copy with a full slice of the original:ExplanationThere are two semantic ways to copy a list. A shallow copy creates a new list of the same objects, a deep copy creates a new list containing new equivalent objects.Shallow list copyA shallow copy only copies the list itself, which is a container of references to the objects in the list. If the objects contained themselves are mutable and one is changed, the change will be reflected in both lists. There are different ways to do this in Python 2 and 3. The Python 2 ways will also work in Python 3.Python 2In Python 2, the idiomatic way of making a shallow copy of a list is with a complete slice of the original:You can also accomplish the same thing by passing the list through the list constructor, but using the constructor is less efficient:Python 3In Python 3, lists get the list.copy method:In Python 3.5:Making another pointer does not make a copyUsing new_list = my_list then modifies new_list every time my_list changes. Why is this?my_list is just a name that points to the actual list in memory. When you say new_list = my_list you're not making a copy, you're just adding another name that points at that original list in memory. We can have similar issues when we make copies of lists. The list is just an array of pointers to the contents, so a shallow copy just copies the pointers, and so you have two different lists, but they have the same contents. To make copies of the contents, you need a deep copy.Deep copiesTo make a deep copy of a list, in Python 2 or 3, use deepcopy in the copy module:To demonstrate how this allows us to make new sub-lists:And so we see that the deep copied list is an entirely different list from the original. You could roll your own function - but don't. You're likely to create bugs you otherwise wouldn't have by using the standard library's deepcopy function.Don't use evalYou may see this used as a way to deepcopy, but don't do it:It's dangerous, particularly if you're evaluating something from a source you don't trust.It's not reliable, if a subelement you're copying doesn't have a representation that can be eval'd to reproduce an equivalent element.It's also less performant. In 64 bit Python 2.7:on 64 bit Python 3.5:
There are many answers already that tell you how to make a proper copy, but none of them say why your original 'copy' failed. Python doesn't store values in variables; it binds names to objects. Your original assignment took the object referred to by my_list and bound it to new_list as well. No matter which name you use there is still only one list, so changes made when referring to it as my_list will persist when referring to it as new_list. Each of the other answers to this question give you different ways of creating a new object to bind to new_list. Each element of a list acts like a name, in that each element binds non-exclusively to an object. A shallow copy creates a new list whose elements bind to the same objects as before.To take your list copy one step further, copy each object that your list refers to, and bind those element copies to a new list. This is not yet a deep copy, because each element of a list may refer to other objects, just like the list is bound to its elements. To recursively copy every element in the list, and then each other object referred to by each element, and so on: perform a deep copy. See the documentation for more information about corner cases in copying.
new_list = list(old_list)
Use thing[:]
Python's idiom for doing this is newList = oldList[:]
All of the other contributors gave great answers, which work when you have a single dimension (leveled) list, however of the methods mentioned so far, only copy.deepcopy() works to clone/copy a list and not have it point to the nested list objects when you are working with multidimensional, nested lists (list of lists). While Felix Kling refers to it in his answer, there is a little bit more to the issue and possibly a workaround using built-ins that might prove a faster alternative to deepcopy.While new_list = old_list[:], copy.copy(old_list)' and for Py3k old_list.copy() work for single-leveled lists, they revert to pointing at the list objects nested within the old_list and the new_list, and changes to one of the list objects are perpetuated in the other. Edit: New information brought to lightAs was pointed out by both Aaron Hall and PM 2Ring using eval() is not only a bad idea, it is also much slower than copy.deepcopy(). This means that for multidimensional lists, the only option is copy.deepcopy(). With that being said, it really isn't an option as the performance goes way south when you try to use it on a moderately sized multidimensional array.  I tried to timeit using a 42x42 array, not unheard of or even that large for bioinformatics applications, and I gave up on waiting for a response and just started typing my edit to this post.It would seem that the only real option then is to initialize multiple lists and work on them independently. If anyone has any other suggestions, for how to handle multidimensional list copying, it would be appreciated.As others have stated, there can be are significant performance issues using the copy module and copy.deepcopy for multidimensional lists.  Trying to work out a different way of copying the multidimensional list without using deepcopy, (I was working on a problem for a course that only allows 5 seconds for the entire algorithm to run in order to receive credit), I came up with a way of using built-in functions to make a copy of the nested list without having them point at one another or at the list objects nested within them. I used eval() and repr() in the assignment to make the copy of the old list into the new list without creating a link to the old list. It takes the form of:Basically what this does is make a representation of old_list as a string and then evaluates the string as if it were the object that the string represents. By doing this, no link to the original list object is made. A new list object is created and each variable points to its own independent object. Here is an example using a 2 dimensional nested list.If you then check the contents of each list, for example a 4 by 3 list, Python will return While this probably isn't the canonical or syntactically correct way to do it, it seems to work well. I haven't tested performance, but I am going to guess that eval() and rep() will have less overhead to run than deepcopy will. 
Unlike other languages that have variable and value, Python has name and object.This statement:means to give the list (object) a name a, and, this:just gives the same object a a new name b, so whenever you do something with a, the object changes and therefore b changes.The only way to make a really copy of a is to create a new object like other answers already have said.You can see more about this here.
Let's start from the beginning and explorer it a little deep :So Suppose you have two list :And we have to copy both list , now starting from the first list:So first let's try by general method of copy:Now if you are thinking copy copied the list_1 then you can be wrong, let's check it:output:Surprised ? Ok let's explore it:So as we know python doesn't store anything in a variable, Variables are just referencing to the object and object store the value. Here object is list but we created two references to that same object by two different variable names. So both variables are pointing to the same object :so when you do copy=list_1 what actually its doing :Here in the image list_1 and copy are two variable names but the object is same for both variable which is listSo if you try to modify copied list then it will modify the original list too because the list is only one there, you will modify that list no matter you do from the copied list or from the original list:output:So it modified the original list :What is the solution then?Solution :Now let's move to a second pythonic method of copying list:Now this method fix the thing what we were facing in first issue let's check it :So as we can see our both list having different id and it means both variables are pointing to different objects so what actually going on here is :Now let's try to modify the list and let's see if we still face the previous problem :Output:So as you can see it is not modifying the original list, it only modified the copied list, So we are ok with it. So now i think we are done? wait we have to copy the second nested list too so let's try pythonic way :So list_2 should reference to another object which is copy of list_2 let's check:we get the output:Now we can assume both lists are pointing different object so now let's try to modify it and let's see it is giving what we want :So when we try:it gives us output:Now, this is little confusing we used the pythonic way and still, we are facing the same issue.let's understand it:So when we do :we are actually copying the outer list only, not the nested list, so nested list is same object for both list, let's check:output:So actually when we do copy_2=list_2[:]  this is what happens:It creates the copy of list but only outer list copy, not the nested list copy, nested list is same for both variable so if you try to modify the nested list then it will modify the original list too because nested list object is same for both nested list.So what is the solution?Solution is deep copySo now let's check it :output:both id are different  , now let's check nested list id:output:As you can see both id are different so we can assume that both nested list are pointing different object now.So when you do deep=deepcopy(list_2) what actually happens :So both nested list are pointing different object and they have seprate copy of nested list now.Now let's try to modify the nested list and let's see if it solved the previous issue or not:so if we do :output:So as you can see it didn't modify the original nested list , it only modified the copied list. If you like my detailed answer , let me know by upvoting it ,  if you have any doubt realted this answer , comment down :)
Python 3.6.0 TimingsHere are the timing results using Python 3.6.0. Keep in mind these times are relative to one another, not absolute.I stuck to only doing shallow copies, and also added some new methods that weren't possible in Python2, such as list.copy() (the Python3 slice equivalent) and list unpacking (*new_list, = list):We can see the old winner still comes out on top, but not really by a huge amount, considering the increased readability of the Python3 list.copy() approach.Note that these methods do not output equivalent results for any input other than lists. They all work for sliceable objects, a few work for any iterable, but only copy.copy() works for any Python object.Here is the testing code for interested parties (Template from here):
It surprises me that this hasn't been mentioned yet, so for the sake of completeness...You can perform list unpacking with the "splat operator": *, which will also copy elements of your list.The obvious downside to this method is that it is only available in Python 3.5+.Timing wise though, this appears to perform better than other common methods.
Not sure if this is still actual, but the same behavior holds for dictionaries as well. Look at this example.
A very simple approach independent of python version was missing in already given answers which you can use most of the time (at least I do):However, If my_list contains other containers (for eg. nested lists) you must use deepcopy as others suggested in the answers above from the copy library. For example:.Bonus: If you don't want to copy elements use (aka shallow copy):Let's understand difference between Solution#1 and Solution #2As you can see Solution #1 worked perfectly when we were not using the nested lists. Let's check what will happen when we apply solution #1 to nested lists.
you can use bulit in list() function:i think this code will help you.
Note that there are some cases where if you have defined your own custom class and you want to keep the attributes then you should use copy.copy() or copy.deepcopy() rather than the alternatives, for example in Python 3:Outputs:
new_list = my_listTry to understand this. Let's say that my_list is in the heap memory at location X i.e. my_list is pointing to the X. Now by assigning new_list = my_list you're Letting new_list pointing to the X. This is known as shallow Copy.                                                              Now if you assign new_list = my_list[:] You're simply copying each object of my_list to new_list. This is known as Deep copy.The Other way you can do this are :new_list = list(old_list)import copynew_list = copy.deepcopy(old_list)
You will like to use deepcopy from the python standard library.In python, when you copy a data type, the original and the copied data types share the same memory locations. Consequently, any changes made to a copy of object gets reflected in the original object. For example consider this:As you had noticed before, and as you notice again in the above example, change in any element of the copied list my_list_cp changes the original list my_list. The reason for this is that is that there has been no new assignment to my_list_cp.You can counteract the above by using deepcopy from the python standard library. In deep copy, a copy of object is copied in other object.In the above example you see that my_lst hasn't changed after copying. 
You can use the builtin list.copy() method (python 3.3+): https://docs.python.org/3/library/copy.html    new_list = old_list.copy()


Answer URL
https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types
https://docs.python.org/3/library/copy.html
https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types
