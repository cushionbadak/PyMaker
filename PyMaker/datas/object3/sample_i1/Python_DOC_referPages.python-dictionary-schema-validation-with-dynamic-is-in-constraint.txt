Natural Text
I am looking for a solution for the validation of a dictionary with one constraint being an is in constraint where the values considered valid stem from the dictionary being validated itself.For instance, imagine the following pseudo-schemaTo be totally clear, I also express the constraints of this pseudo-schema verbally. These are the constraints I want to validate, be d the dictionary to validate:set(d.keys()) == {"notions", "categories"}isinstance(d["notions"], list)isinstance(notion, str) for notion in d["notions"]isinstance(d["category"], list)element is in d["notion"] for element in d["category"]Don't ask, whether this specific data structure makes any sense. It does not. I just made it up, to create a minimum example for my problem. My actual dictionary schema is much more complex and would have multiple references to values from the dict. That is why I would like to avoid to define and validate the constraints manually, and would prefer a schema-based solution.I have looked into some schema validation libraries, but I haven't found this feature included anywhere. Is there a solution based on some libraries, maybe with a small tweak? I would rather prefer not to invent the wheel a second time.
In general, schema validators try to avoid pulling in data into the validator. The JSON-schema standard, for example, is debating adding $data access in schemas but hasn't (yet) implemented the idea (even though they have several use cases for it).The general objection is that making the validation schema dependent on the data it is validating makes it hard to keep validation context-free (which makes implementation easier, and makes validation in parallel a lot easier), and it makes static analysis of schemas much harder (as the schema changes with the data at runtime).That said, the Colander project can do what you want, as it allows you to trivially define validators in Python code.For example:Note that the validator is defined at the level where both notions and category are defined in, as a validator only has access to the 'local' section of the data being validated (with all child node validations already haven taken place). If you defined the validator only for category then you couldn't access the notions list, and you can count on the notions list already having been validated. The validator raises an Invalid exception, and the first argument is the category schema node to lay the blame squarely on the values in that list.A Colander schema validates as it de-serializes; you can see the input of the Schema.deserialize() method as unvalidated data (a colander serialization) and the output as application-ready data (appdata), validated and cleaned up. That's because Colander will also put default values in place if missing, can produce tuples, sets, datetime values, and more, and also supports data preparation (cleaning up HTML, etc.) as you process it with the schema.With some demo input the above schema validates and returns the validated structure if successful:
Your dictionary is that complex then you're doing this all wrong. Consider creating classes and store an object of that class in the dictionary. Those classes can also hold other objects of other classes. This way you'll avoid the nesting of dictionaries. Create functions within classes to validate its data. 


Answer URL
https://docs.python.org/3/library/typing.html
