Natural Text
I have a dictionary of values read from two fields in a database: a string field and a numeric field. The string field is unique, so that is the key of the dictionary.I can sort on the keys, but how can I sort based on the values?Note: I have read Stack Overflow question here How do I sort a list of dictionaries by a value of the dictionary? and probably could change my code to have a list of dictionaries, but since I do not really need a list of dictionaries I wanted to know if there is a simpler solution to sort either in ascending or descending order.
It is not possible to sort a dictionary, only to get a representation of a dictionary that is sorted. Dictionaries are inherently orderless, but other types, such as lists and tuples, are not. So you need an ordered data type to represent sorted values, which will be a listâ€”probably a list of tuples.For instance,sorted_x will be a list of tuples sorted by the second element in each tuple. dict(sorted_x) == x.And for those wishing to sort on keys instead of values:In Python3 since unpacking is not allowed [1] we can use If you want the output as a dict, you can use collections.OrderedDict:
As simple as: sorted(dict1, key=dict1.get)Well, it is actually possible to do a "sort by dictionary values". Recently I had to do that in a Code Golf (Stack Overflow question Code golf: Word frequency chart). Abridged, the problem was of the kind: given a text, count how often each word is encountered and display a list of the top words, sorted by decreasing frequency. If you construct a dictionary with the words as keys and the number of occurrences of each word as value, simplified here as:then you can get a list of the words, ordered by frequency of use with sorted(d, key=d.get) - the sort iterates over the dictionary keys, using the number of word occurrences as a sort key . I am writing this detailed explanation to illustrate what people often mean by "I can easily sort a dictionary by key, but how do I sort by value" - and I think the OP was trying to address such an issue. And the solution is to do sort of list of the keys, based on the values, as shown above.
You could use:sorted(d.items(), key=lambda x: x[1])This will sort the dictionary by the values of each entry within the dictionary from smallest to largest.
Dicts can't be sorted, but you can build a sorted list from them.A sorted list of dict values:A list of (key, value) pairs, sorted by value:
In recent Python 2.7, we have the new OrderedDict type, which remembers the order in which the items were added.To make a new ordered dictionary from the original, sorting by the values:The OrderedDict behaves like a normal dict:
UPDATE: 5 DECEMBER 2015 using Python 3.5Whilst I found the accepted answer useful, I was also surprised that it hasn't been updated to reference OrderedDict from the standard library collections module as a viable, modern alternative - designed to solve exactly this type of problem.The official OrderedDict documentation offers a very similar example too, but using a lambda for the sort function:
It can often be very handy to use namedtuple. For example, you have a dictionary of 'name' as keys and 'score' as values and you want to sort on 'score':sorting with lowest score first:sorting with highest score first:Now you can get the name and score of, let's say the second-best player (index=1) very Pythonically like this:
Pretty much the same as Hank Gay's answer:Or optimized slightly as suggested by John Fouhy:
As of Python 3.6 the built-in dict will be orderedGood news, so the OP's original use case of mapping pairs retrieved from a database with unique string ids as keys and numeric values as values into a built-in Python v3.6+ dict, should now respect the insert order.If say the resulting two column table expressions from a database query like:would be stored in two Python tuples, k_seq and v_seq (aligned by numerical index and with the same length of course), then:Allow to output later as:yielding in this case (for the new Python 3.6+ built-in dict!):in the same ordering per value of v.Where in the Python 3.5 install on my machine it currently yields:Details:As proposed in 2012 by Raymond Hettinger (cf. mail on python-dev with subject "More compact dictionaries with faster iteration") and now (in 2016) announced in a mail by Victor Stinner to python-dev with subject "Python 3.6 dict becomes compact and gets a private version; and keywords become ordered" due to the fix/implementation of issue 27350 "Compact and ordered dict" in Python 3.6 we will now be able, to use a built-in dict to maintain insert order!!Hopefully this will lead to a thin layer OrderedDict implementation as a first step. As @JimFasarakis-Hilliard indicated, some see use cases for the OrderedDict type also in the future. I think the Python community at large will carefully inspect, if this will stand the test of time, and what the next steps will be.Time to rethink our coding habits to not miss the possibilities opened by stable ordering of:Keyword arguments and(intermediate) dict storageThe first because it eases dispatch in the implementation of functions and methods in some cases.The second as it encourages to more easily use dicts as intermediate storage in processing pipelines.Raymond Hettinger kindly provided documentation explaining "The Tech Behind Python 3.6 Dictionaries" - from his San Francisco Python Meetup Group presentation 2016-DEC-08.And maybe quite some Stack Overflow high decorated question and answer pages will receive variants of this information and many high quality answers will require a per version update too.Caveat Emptor (but also see below update 2017-12-15):As @ajcr rightfully notes: "The order-preserving aspect of this new implementation is considered an implementation detail and should not be relied upon." (from the whatsnew36) not nit picking, but the citation was cut a bit pessimistic ;-). It continues as " (this may change in the future, but it is desired to have this new dict implementation in the language for a few releases before changing the language spec to mandate order-preserving semantics for all current and future Python implementations; this also helps preserve backwards-compatibility with older versions of the language where random iteration order is still in effect, e.g. Python 3.5)."So as in some human languages (e.g. German), usage shapes the language, and the will now has been declared ... in whatsnew36.Update 2017-12-15:In a mail to the python-dev list, Guido van Rossum declared:Make it so. "Dict keeps insertion order" is the ruling. Thanks! So, the version 3.6 CPython side-effect of dict insertion ordering is now becoming part of the language spec (and not anymore only an implementation detail). That mail thread also surfaced some distinguishing design goals for collections.OrderedDict as reminded by Raymond Hettinger during discussion.
Given dictionarySortingResult You can use a lambda function to sort things up by value and store them processed inside a variable, in this case sred with e the original dictionary.Hope that helps!
I had the same problem, and I solved it like this:(People who answer "It is not possible to sort a dict" did not read the question! In fact, "I can sort on the keys, but how can I sort based on the values?" clearly means that he wants a list of the keys sorted according to the value of their values.)Please notice that the order is not well defined (keys with the same value will be in an arbitrary order in the output list).
In Python 2.7, simply do:copy-paste from : http://docs.python.org/dev/library/collections.html#ordereddict-examples-and-recipesEnjoy ;-)
Technically, dictionaries aren't sequences, and therefore can't be sorted. You can do something likeassuming performance isn't a huge deal.
This is the code:Here are the results:OriginalRoflRank 
If values are numeric you may also use Counter from collections
Try the following approach. Let us define a dictionary called mydict with the following data:If one wanted to sort the dictionary by keys, one could do something like:This should return the following output:On the other hand, if one wanted to sort a dictionary by value (as is asked in the question), one could do the following:The result of this command (sorting the dictionary by value) should return the following:
You can create an "inverted index", alsoNow your inverse has the values; each value has a list of applicable keys.
You can use the collections.Counter. Note, this will work for both numeric and non-numeric values.
This returns the list of key-value pairs in the dictionary, sorted by value from highest to lowest:For the dictionary sorted by key, use the following:The return is a list of tuples because dictionaries themselves can't be sorted.This can be both printed or sent into further computation.
You can use a skip dict which is a dictionary that's permanently sorted by value.If you use keys(), values() or items() then you'll iterate in sorted order by value.It's implemented using the skip list datastructure.

Starting from Python 3.6, dict objects are now ordered by insertion order. It's officially in the specs of Python 3.7.Before that, you had to use OrderedDict.Python 3.7 documentation says:Changed in version 3.7: Dictionary order is guaranteed to be insertion  order. This behavior was implementation detail of CPython from 3.6. 
You can also use custom function that can be passed to key.One more way to do is to use labmda function
As pointed out by Dilettant, Python 3.6 will now keep the order! I thought I'd share a function I wrote that eases the sorting of an iterable (tuple, list, dict). In the latter case, you can sort either on keys or values, and it can take numeric comparison into account. Only for >= 3.6!When you try using sorted on an iterable that holds e.g. strings as well as ints, sorted() will fail. Of course you can force string comparison with str(). However, in some cases you want to do actual numeric comparison where 12 is smaller than 20 (which is not the case in string comparison). So I came up with the following. When you want explicit numeric comparison you can use the flag num_as_num which will try to do explicit numeric sorting by trying to convert all values to floats. If that succeeds, it will do numeric sorting, otherwise it'll resort to string comparison.Comments for improvement or push requests welcome.
Here is a solution using zip on d.values() and d.keys().  A few lines down this link (on Dictionary view objects) is:This allows the creation of (value, key) pairs using zip(): pairs = zip(d.values(), d.keys()).So we can do the following:
Use ValueSortedDict from dicts:
Iterate through a dict and sort it by its values in descending order:
If your values are integers, and you use Python 2.7 or newer, you can use collections.Counter instead of dict. The most_common method will give you all items, sorted by the value.
I came up with this one, For Python 3.x: x.items() replacing iteritems().Or try with collections.OrderedDict!
You can use the sorted function of Pythonsorted(iterable[, cmp[, key[, reverse]]])Thus you can use:sorted(dictionary.items(),key = lambda x :x[1])Visit this link for more information on sorted function: https://docs.python.org/2/library/functions.html#sorted


Answer URL
https://docs.python.org/3/library/collections.html#collections.OrderedDict
https://docs.python.org/3/library/collections.html#collections.OrderedDict
https://docs.python.org/3/library/collections.html#collections.OrderedDict
https://docs.python.org/3/library/collections.html#collections.OrderedDict
