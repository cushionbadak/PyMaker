Natural Text
I have a python program than may be called several times at any time by some scheduler.It generates a string following some pattern and I want to make sure that this string hasn't been generated by another process running at the same time (lock string). If so, it has to generate a new string following the same pattern and check again that if doesn't exists. If a process ends, the related string can be reused by a new one (unlock string).Example:Any ideas how to achieve this "sort of" system-wide mutex based on strings?
You could coordinate processes using some global resource, such as the filesystem.Create a file named /tmp/string_1 to claim that string, or append string_1 to /tmp/log or something.Use filesystem locking if desired, or a coordinating mutex.But it would be simpler to just append a uuid to each string.High entropy unique IDs are easy to generate.Depending on request rates, you may be able to get away with using truncated IDs.If you really do need a counter, consider having a single producer maintain it, and hand out unique IDs.Simplest way would be via a queue.Producer writes to the queue, and consumers read IDs from it.
Let's put this code as an example of what I want using fcntl:The problem here is that when my_function() finishes the locking is gone, and if I call this script at that time (before main() ends), it will select the same string. Is there a way to keep that lock until the full script has ended execution?


Answer URL
https://docs.python.org/3/library/threading.html#threading.Lock
https://docs.python.org/3/library/uuid.html
https://docs.python.org/3/library/queue.html#queue.Queue
