Natural Text
What's the recommended way to flatten nested lists since the deprecation of the compiler package?  I know that there are a few stack overflow answers for list flattening, but I'm hoping for the pythonic, standard package, "one, and preferably only one, obvious way" to do this.
Your stated function takes a nested list and flattens that into a new list.To flatten an arbitrarily nested list into a new list, this works on Python 3 as you expect:Prints:If you want a generator that does the same thing:For Python 3.3 and later, use yield from instead of the loop:
itertools.chain is the best solution for flattening any nested iterable one level - it's highly efficient compared to any pure-python solution.That said, it will work on all iterables, so some checking is required if you want to avoid it flattening out strings, for example.Likewise, it won't magically flatten out to an arbitrary depth. That said, generally, such a generic solution isn't required - instead it's best to keep your data structured so that it doesn't require flattening in that way.Edit: I would argue that if one had to do arbitrary flattening, this is the best way:Remember to use basestring in 2.x over str, and for subel in flatten(el): yield el instead of yield from flatten(el) pre-3.3.As noted in the comments, I would argue this is the nuclear option, and is likely to cause more problems than it solves. Instead, the best idea is to make your output more regular (output that contains one item still give it as a one item tuple, for example), and do regular flattening by one level where it is introduced, rather than all at the end.This will produce more logical, readable, and easier to work with code. Naturally, there are cases where you need to do this kind of flattening (if the data is coming from somewhere you can't mess with, so you have no option but to take it in the poorly-structured format), in which case, this kind of solution might be needed, but in general, it's probably a bad idea.
You can use flatten function from funcy library:You can also explicitly specify which values to follow:Take a peek at its implementation if you want an algorythm.
My ugly while-chain solution, just for fun:
There's no built-in method for an list with arbitrary nesting, but something like this......will work for lists and tuples. If you want to support any object which you could use in a for item in object expression, then it's probably best to using duck-typing like this......which is slightly more robust than checking isinstance(el, Iterable), since it won't cope with some cases, such as this...
Built for recursion:  Python 3.6Define your types in a list and use the any builtin to check 


Answer URL
https://docs.python.org/3/whatsnew/3.3.html#pep-380
