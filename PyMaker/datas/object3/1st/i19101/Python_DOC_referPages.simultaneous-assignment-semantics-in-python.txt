Natural Text
Consider the following Python 3 code:And now consider the following two versions of a simultaneous assignment over both a and i:Assignment version 1:Assignment version 2:I would expect these two versions of simultaneous assignments to be semantically equivalent. However, if you check the values of a and i after each one of the simultaneous assignments, you get different states:Output for print(a,i) after assignment version 1:Output for print(a,i) after assignment version 2:I am not an expert on Python's semantics, but this behaviour seems weird. I would expect both assignments to behave as assignment version 1. Moreover, if you check the following link, one would expect both assignment versions to lead to the same state:Link to book excerpt in Google BooksIs there something I am missing regarding Python semantics for simultaneous assignments? Note: This weird behaviour does not seem to be reproducible, for instance, when the variable a has integer type; it seems to require a to be of type list (maybe this is the case for any mutable type?).
In this case:The righthand side evaluates to a tuple (1, 0). This tuple is then unpacked to i and then a[i]. a[i] is evaluated during the unpacking, not before, so corresponds to a[1].Since the righthand side is evaluated before any unpacking takes place, referring to a[i] on the righthand side would always be a[0] regardless of the final value of iHere is another useless fun example for you to work out


Answer URL
https://docs.python.org/3/reference/simple_stmts.html
