Natural Text
Lets say I have a lot of key-pair data. I would like to have this data in a package so that it can be imported. Is there a way to make modules work like dicts, for performance and extendibility reasons?Example: Note: The desired result can be archived by putting declaring BUILDINGS in __init__.py but they will all be compiled every time, its not drag and undroppable, and it seems ugly.Is there a way to achieve this well? Is there a way to achieve it at all? 
Not that I recommend it, but you can assign the dict into sys.modules. Python doesn't care that what's there is actually a module object.
Modules are already dicts with their atributes stored in BUILDINGS.__dict__. Just make an utility fonction to write directly to it.
If I understand you correctly, I think what you want is the pickle packageie,
If you want to store key-value data that you want to reference later, you should try  the shelve moduleExample from the above linked page
If you really want a module that you can use as a dict, you have to make it implement the mapping protocol.In particular, you need to make sure that type(BUILDINGS).__getitem__(BUILDINGS, key) is defined (as, e.g., getattr(BUILDINGS, key). And likewise for __setitem__, __delitem__, and anything else you want to implement. (You can get most of what you want through collections.abc.MutableMapping, or collections.MutableMapping if you're on 2.x. See the docs for exactly what you have to implement to get everything else for free.)The problem is that (at least in CPython, which is probably what you care about) module is a builtin type whose attributes cannot be modified. So, you need to cause BUILDINGS to be an instance of a different type, which you can then add __getitem__ to. For example:Now you've got a BUILDINGS that acts just like the real module, except that it also provides dict-like access instead of just namespace-like access.You can wrap this up in a variety of different ways.The simplest way is to take effectively that code (but using __import__ or imp so you don't pollute globals and sys.modules with the intermediate value) and put it in a function, so instead of import BUILDINGS you'd write helper_mod.dict_import(BUILDINGS).The most powerful way is to create and install an import hook that just returns a DictModuleType instead of ModuleType (you may need to implement __new__ and/or __init__ to make this work) for, say, all modules whose names are in all caps (just check if fullname.split('.')[-1].isupper(), and, if not, don't wrap it). Then, you can just write a module named BUILDINGS.py, and import BUILDINGS, and BUILDINGS will act like a dict.


Answer URL
