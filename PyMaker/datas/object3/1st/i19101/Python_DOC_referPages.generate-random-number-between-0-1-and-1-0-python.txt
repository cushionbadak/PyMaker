Natural Text
I'm trying to generate a random number between 0.1 and 1.0.We can't use rand.randint because it returns integers.We have also tried random.uniform(0.1,1.0), but it returns a value >= 0.1 and < 1.0, we can't use this, because our search includes also 1.0.Does somebody else have an idea for this problem?
How "accurate" do you want your random numbers? If you're happy with, say, 10 decimal digits, you can just round random.uniform(0.1, 1.0) to 10 digits. That way you will include both 0.1 and 1.0:To be precise, 0.1 and 1.0 will have only half of the probability compared to any other number in between and, of course, you loose all random numbers that differ only after 10 digits.
Random.uniform()is just:where self.random() returns a random number in the range [0.0, 1.0).Python (as well as many other languages) uses floatingpoint to represent realnumbers. How 0.1 is represented is described in detail in thedocs:It allows to find a random number in [0.1, 1] (inclusive) usingrandint() without losing precision:randint(n, m) returns a random integer in [n, m] (inclusive)therefore the above method can potentially return all floating pointsnumbers in [0.1, 1].An alternative is to find the smallest x such that x > 1 and use:x should be the smallest value to avoid losing precision and toreduce number of calls to uniform() e.g.:Both solutions preserve uniformness of the random distribution (no skew).
You could do this:or, use numpy's uniform:nextafter will produce the platform specific next representable floating pointing number towards a direction. Using numpy's random.uniform is advantageous because it is unambiguous that it does not include the upper bound. Edit It does appear that Mark Dickinson's comments is correct: Numpy's documentation is incorrect regarding the upper bound to random.uniform being inclusive or not. The Numpy documentation states All values generated will be less than high.This is easily disproved:Nor is the result uniform over this limited range:However, combining  J.F. Sebastian and Mark Dickinson's comments, I think this works:If run with the minimal spread of values in Mark's comment such that there are very few discrete floating point values:It produces the desired uniform distribution inclusive of end points:On the values requested by the OP, it also produces a uniform distribution:Output
With the information you've given (including comments thus far), I still fail to see how the university is going to test your program such that it will make a difference if 1.0 appears or not.  (I mean, if you're required to generate random floats, how can they require that any particular value appears?)OK, so putting the craziness of your requirements aside:The fact that the lower bound for your random floats is higher than 0 gives you a disturbingly elegant way to use random.random, which guarantees return values in the interval [0.0, 1.0):  Simply keep calling random.random, throwing away any values less than 0.1, except 0.0.  If you actually get 0.0, return 1.0 instead.So something like
You can use random.randint simply by doing this trick:if you want more decimals, just change the interval to:(1000,10000) 4 digits(10000,100000) 5 digitsetc
Are you unable to use random.random()? This gives a number between 0.0 and 1.0, though you could easily set up a way to get around this.This code would give you a number that is between 0.1 and 1.0, inclusive (0.1 and 1.0 are both possible solutions). Hope this helps.*I assumed you only wanted numbers to the tenths place. If you want it different, where I typed round(number, 1) change 1 to 2 for hundredths, 3 for thousandths, and so on.
The standard way would be random.random() * 0.9 + 0.1 (random.uniform() internally does just this).  This will return numbers between 0.1 and 1.0 without the upper border.But wait!  0.1 (aka ¹/₁₀) has no clear binary representation (as ⅓ in decimal)!  So You won't get a true 0.1 anyway, simply because the computer cannot represent it internally.  Sorry ;-)
According to the Python 3.0 documentation:random.uniform(a, b) Return a random floating point number N such that a <= N <= b for a <= b and b <= N <= a for b < a.Thus, random.uniform() does, in fact, include the upper limit, at least on Python 3.0.EDIT: As pointed out by @Blender, the documentation for Python 3.0 seems to be inconsistent with the source code on this point.EDIT 2: As pointed out by @MarkDickinson, I had unintentionally linked to the Python 3.0 documentation instead of the latest Python 3 documentation here which reads as follows:random.uniform(a, b)  Return a random floating point number N such  that a <= N <= b for a <= b and b <= N <= a for b < a. The end-point  value b may or may not be included in the range depending on  floating-point rounding in the equation a + (b-a) * random().
Try     random.randint(1, 10)/100.0
In numpy, you can do the following:


Answer URL
