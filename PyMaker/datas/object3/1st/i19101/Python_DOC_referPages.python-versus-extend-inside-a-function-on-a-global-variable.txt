Natural Text
I've read a few other SO (PythonScope and globals don't need global) but nothing seems to explain as explicitly as I would like and I'm having trouble mentally sifting through whether or not PyDocs tells me the answer to my question:Now, understandably, andbut thenI thought, however, that things like += implicitly called the method operators, in this case extend(), but the error implies that for some reason it does not actually treat += as extends(). Is this consistent with how Python parsing ought to work?I would have thought that calling functions that are equivalent to method-operators, they would be equivalent in all cases. Instead it seems that it treats += as an actual assignment operator. Except, this isn't completely true, because if I do something (admittedly contrived):all of which is expected, if += actually just calls extend(). Is there some finer distinction (or very obvious point...) that I'm missing that makes it clear that myList in baz() needs to be treated as a local variable, and that therefore the += cannot be implicitly converted to an extend() such that it recognizes the global variable?
+= doesn't implicitly call extend(). Firstly, it is an augmented assignment operator.If you look at the section on assignment it says:Assignment of an object to a single target is recursively defined as follows.If the target is an identifier (name):If the name does not occur in a global statement in the current code block: the name is bound to the object in the current local namespace.  Otherwise: the name is bound to the object in the current global namespace.Since an augmented assignment is:Augmented assignment is the combination, in a single statement, of a binary operation and an assignment statement:It plays by the same rules. As you can see:An augmented assignment evaluates the target (which, unlike normal assignment statements, cannot be an unpacking) and the expression list, performs the binary operation specific to the type of assignment on the two operands, and assigns the result to the original target. The target is only evaluated once..The first call trys to evaluate myList, this results in LOAD_FAST since there was no global statement it is assumed to be a local variable:LOAD_FAST(var_num)Pushes a reference to the local co_varnames[var_num] onto the stack.It can't be found so the error is raised. If it was found, then we get to the oppcode INPLACE_ADD which calls the method myList.__iadd__ which does the job of extend, once this operation completes the result will be assigned back to the variable but we never get this far.You shouldn't really be manipulating globals anyway, return the new result from your function or pass it as a parameter.
When you mutate the list, you should say global myList. By mutate I mean change the reference. The first example and the 3rd one is basically same, you just use += for shorthand


Answer URL
