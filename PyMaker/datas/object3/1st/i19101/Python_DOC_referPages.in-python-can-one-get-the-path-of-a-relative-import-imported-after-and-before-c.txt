Natural Text
I'm looking to get the path of a module after os.chdir has been called.In this example:..the foo.__file__ variable will be 'foo.py', as will inspect.stack()[0][1] -- yet, there's no way to know where 'foo.py' is located now, right?What could I use, outside (or inside, without storing it as a variable at import time) of 'foo', which would allow me to discover the location of foo?I'm attempting to build a definitive method to determine which file a module is executing from.  Since I use IPython as a shell, this is something I could actually run into.  Example usage:I have two versions of a project I'm working on, and I'm comparing their behavior during the process of debugging them.  ..let's say they're in the directories 'proj1' and 'proj2'.  ..which foo do I have loaded in the IPython interpreter again?The ideal:** As abarnert noted, that is not possible, as python does not record the base directory location of relative imports.  This will, however, work with normal (non-relative) imports.** Also, regular python (as opposed to IPython) does not allow imports from the current directory, but rather only from the module directory.
The information isn't available anymore, period. Tracebacks, the debugger, ipython magic, etc. can't get at it. For example:So:the foo.__file__ variable will be 'foo.py', as will inspect.stack()[0][1] -- yet, there's no way to know where 'foo.py' is located now, right?Right. As you can see, Python treats it as a relative path, and (incorrectly) resolves it according to the current working directory whenever it needs an absolute path.What could I use, outside (or inside, without storing it as a variable at import time) of 'foo', which would allow me to discover the location of foo?Nothing. You have to store it somewhere.The obvious thing to do is to store os.path.abspath(foo.__file__) from outside, or os.path.abspath(__file__) from inside, at import time. Not what you were hoping for, but I can't think of anything better.If you want to get tricky, you can build an import hook that modifies modules as they're imported, adding a new __abspath__ attribute or, more simply, changing __file__ to always been an abspath. This is easier with the importlib module Python 3.1+.As a quick proof of concept, I slapped together abspathimporter. After doing an import imppath, every further import you do that finds a normal .py file or package will absify its __file__.I don't know whether it works for .so/.pyd modules, or .pyc modules without source. It definitely doesn't work for modules inside zipfiles, frozen modules, or anything else that doesn't use the stock FileFinder. It won't retroactively affect the paths of anything imported before it. It requires 3.3+, and is horribly fragile (most seriously, the FileFinder class or its hook function has to be the last thing in sys.path_hooksâ€”which it is by default in CPython 3.3.0-3.3.1 on four Mac and linux boxes I tested, but certainly isn't guaranteed).But it shows what you can do if you want to. And honestly, for playing around in iPython for the past 20 minutes or so, it's kind of handy.
foodir now has original directory stored in it...


Answer URL
