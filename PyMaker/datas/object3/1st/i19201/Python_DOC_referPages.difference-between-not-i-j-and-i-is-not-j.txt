Natural Text
My Google-fu has failed me.In Python, are the following two tests for equality equivalent?Does this hold true for objects where you would be comparing instances (a list say)?Okay, so this kind of answers my question:So == tests value where is tests to see if they are the same object?
is will return True if two variables point to the same object, == if the objects referred to by the variables are equal.In your case, the second test only works because Python caches small integer objects, which is an implementation detail. For larger integers, this does not work:The same holds true for string literals:Please see this question as well.
There is a simple rule of thumb to tell you when to use == or is.== is for value equality. Use it when you would like to know if two objects have the same value.is is for reference equality. Use it when you would like to know if two references refer to the same object.In general, when you are comparing something to a simple type, you are usually checking for value equality, so you should use ==. For example, the intention of your example is probably to check whether x has a value equal to 2 (==), not whether x is literally referring to the same object as 2.Something else to note: because of the way the CPython reference implementation works, you'll get unexpected and inconsistent results if you mistakenly use is to compare for reference equality on integers:That's pretty much what we expected: a and b have the same value, but are distinct entities. But what about this?This is inconsistent with the earlier result. What's going on here? It turns out the reference implementation of Python caches integer objects in the range -5..256 as singleton instances for performance reasons. Here's an example demonstrating this:This is another obvious reason not to use is: the behavior is left up to implementations when you're erroneously using it for value equality.
== determines if the values are equal, while is determines if they are the exact same object and equal. 
Is there a difference between == and is in Python?Yes, they have a very important difference.==: check for equality - the semantics are that equivalent objects (that aren't necessarily the same object) will test as equal. As the documentation says:The operators <, >, ==, >=, <=, and != compare the values of two objects.is: check for identity - the semantics are that the object (as held in memory) is the object. Again, the documentation says:The operators is and is not test for object identity: x is y is true  if and only if x and y are the same object. Object identity is  determined using the id() function. x is not y yields the inverse  truth value.Thus, the check for identity is the same as checking for the equality of the IDs of the objects. That is,is the same as:where id is the builtin function that returns an integer that "is guaranteed to be unique among simultaneously existing objects" (see help(id)) and where a and b are any arbitrary objects.Other Usage DirectionsYou should use these comparisons for their semantics. Use is to check identity and == to check equality.PEP 8, the official Python style guide for the standard library also mentions two use-cases for is:Comparisons to singletons like None should always be done with is or  is not, never the equality operators.Also, beware of writing if x when you really mean if x is not None --  e.g. when testing whether a variable or argument that defaults to None  was set to some other value. The other value might have a type (such  as a container) that could be false in a boolean context!Inferring equality from identityIf is is true, equality can usually be inferred - logically, if an object is itself, then it should test as equivalent to itself. In most cases this logic is true, but it relies on the implementation of the __eq__ special method. As the docs say, The default behavior for equality comparison (== and !=) is based on  the identity of the objects. Hence, equality comparison of instances  with the same identity results in equality, and equality comparison of  instances with different identities results in inequality. A  motivation for this default behavior is the desire that all objects  should be reflexive (i.e. x is y implies x == y).and in the interests of consistency, recommends:Equality comparison should be reflexive. In other words, identical  objects should compare equal:x is y implies x == yWe can see that this is the default behavior for custom objects:The contrapositive is also usually true - if somethings test as not equal, you can usually infer that they are not the same object. Since tests for equality can be customized, this inference does not always hold true for all types.An exceptionA notable exception is nan - it always tests as not equal to itself:Checking for identity can be much a much quicker check than checking for equality (which might require recursively checking members). But it cannot be substituted for equality where you may find more than one object as equivalent.Note that comparing equality of lists and tuples will assume that identity of objects are equal (because this is a fast check). This can create contradictions if the logic is inconsistent - as it is for nan:A Cautionary Tale:The question is attempting to use is to compare integers. You shouldn't assume that an instance of an integer is the same instance as one obtained by another reference. This story explains why.A commenter had code that relied on the fact that small integers (-5 to 256 inclusive) are singletons in Python, instead of checking for equality.Wow, this can lead to some insidious bugs. I had some code that checked if a is b, which worked as I wanted because a and b are typically small numbers. The bug only happened today, after six months in production, because a and b were finally large enough to not be cached. – gwgIt worked in development. It may have passed some unittests. And it worked in production - until the code checked for an integer larger than 256, at which point it failed in production. This is a production failure that could have been caught in code review or possibly with a style-checker.Let me emphasize: do not use is to compare integers.
What's the difference between is and ==?== and is are different comparison! As others already said:== compares the values of the objects.is compares the references of the objects.In Python names refer to objects, for example in this case value1 and value2 refer to an int instance storing the value 1000:Because value2 refers to the same object is and == will give True:In the following example the names value1 and value2 refer to different int instances, even if both store the same integer:Because the same value (integer) is stored == will be True, that's why it's often called "value comparison". However is will return False because these are different objects:When to use which?Generally is is a much faster comparison. That's why CPython caches (or maybe reuses would be the better term) certain objects like small integers, some strings, etc. But this should be treated as implementation detail that could (even if unlikely) change at any point without warning.You should only use is if you:want to check if two objects are really the same object (not just the same "value"). One example can be if you use a singleton object as constant.want to compare a value to a Python constant. The constants in Python are:NoneTrue1False1NotImplementedEllipsis__debug__classes (for example int is int or int is float)there could be additional constants in built-in modules or 3rd party modules. For example np.ma.masked from the NumPy module)In every other case you should use == to check for equality.Can I customize the behavior?There is some aspect to == that hasn't been mentioned already in the other answers: It's part of Pythons "Data model". That means its behavior can be customized using the __eq__ method. For example:This is just an artificial example to illustrate that the method is really called:Note that by default (if no other implementation of __eq__ can be found in the class or the superclasses) __eq__ uses is:So it's actually important to implement __eq__ if you want "more" than just reference-comparison for custom classes!On the other hand you cannot customize is checks. It will always compare just if you have the same reference.Will these comparisons always return a boolean?Because __eq__ can be re-implemented or overridden, it's not limited to return True or False. It could return anything (but in most cases it should return a boolean!). For example with NumPy arrays the == will return an array:But is checks will always return True or False!1 As Aaron Hall mentioned in the comments: Generally you shouldn't do any is True or is False checks because one normally uses these "checks" in a context that implicitly converts the condition to a boolean (for example in an if statement). So doing the is True comparison and the implicit boolean cast is doing more work than just doing the boolean cast - and you limit yourself to booleans (which isn't considered pythonic).Like PEP8 mentions:Don't compare boolean values to True or False using ==.
They are completely different.  is checks for object identity, while == checks for equality (a notion that depends on the two operands' types).It is only a lucky coincidence that "is" seems to work correctly with small integers (e.g. 5 == 4+1).  That is because CPython optimizes the storage of integers in the range (-5 to 256) by making them singletons. This behavior is totally implementation-dependent and not guaranteed to be preserved under all manner of minor transformative operations.For example, Python 3.5 also makes short strings singletons, but slicing them disrupts this behavior:
https://docs.python.org/library/stdtypes.html#comparisonsis tests for identity== tests for equalityEach (small) integer value is mapped to a single value, so every 3 is identical and equal. This is an implementation detail, not part of the language spec though
Your answer is correct. The is operator compares the identity of two objects.  The == operator compares the values of two objects.An object's identity never changes once it has been created; you may think of it as the object's address in memory.You can control comparison behaviour of object values by defining a __cmp__ method or a rich comparison method like __eq__.
Have a look at Stack Overflow question Python's “is” operator behaves unexpectedly with integers.What it mostly boils down to is that "is" checks to see if they are the same object, not just equal to each other (the numbers below 256 are a special case).
The == operator compares the values of both the operands and checks for value equality. Whereas is operator checks whether both the operands refer to the same object or not.But if we doBasically, is can be thought of as shorthand for id(a) == id(b). However, Beyond this, there are quirks of the run-time environment that further complicate things. Short strings and small integers will return True when compared with is, due to the Python machine attempting to use less memory for identical objects.
As John Feminella said, most of the time you will use == and != because your objective is to  compare values. I'd just like to categorise what you would do the rest of the time:There is one and only one instance of NoneType i.e. None is a singleton. Consequently foo == None and foo is None mean the same. However the is test is faster and the Pythonic convention is to use foo is None.If you are doing some introspection or mucking about with garbage collection or checking whether your custom-built string interning gadget is working or suchlike, then you probably have a use-case for foo is bar.True and False are also (now) singletons, but there is no use-case for foo == True and no use case for foo is True. 
Most of them already answered to the point. Just as an additional note (based on my understanding and experimenting but not from a documented source), the statement == if the objects referred to by the variables are equalfrom above answers should be read as == if the objects referred to by the variables are equal and objects belonging to the same type/class. I arrived at this conclusion based on the below test:Here the contents of the list and tuple are same but the type/class are different. 
In a nutshell, is checks whether two references point to the same object or not.== checks whether two objects have the same value or not.
Actually I wanted to add this as a comment but could not beautify it easily hence adding as an answer, please do not consider this as an answer. This is what I did to understand --execute following one by one and understand output on every step
As the other people in this post answer the question in details, I would emphasize mainly the comparison between is and == for strings which can give different results and I would urge programmers to carefully use them.For string comparison, make sure to use == instead of is:Out:But in the below example == and is will get different results:Out:Conclusion:Use is carefully to compare between strings 
Python difference between is and equals(==)The is operator may seem like the same as the equality operator but  they are not same.The is checks if both the variables point to the same object whereas  the == sign checks if the values for the two variables are the same.So if the is operator returns True then the equality is definitely  True, but the opposite may or may not be True.Here is an example to demonstrate the similarity and the difference.
"==" compares values"is" compares underlying objects
o1 is o2 => compares if o1 and o2 both points to same physical location in memory (in other words if they are same object)o1 == o2 => here python call the o1's __cmp __(o2) method, which ideally should compares the value and return True or False. (In other words it compares value)For JAVA people: In Java, to determine whether two string variables reference the samephysical memory location by using str1 == str2. (called objectidentity, and it is written in Python as str1 is str2). To compare string values in Java, usestr1.equals(str2); in Python,use str1 == str2.Example:Python Shell output: o = A(2)  o1 = oo == o1   2   2   Trueo is o1  Trueo1 = A(2)o is o1  False
While all these answers that rely on the implementation of objection pointer comparison vs value comparison are likely correct, there is a deeper syntactical reason for using is to determine if a variable value is None (in boolean logic often represented as NULL).  In relational database and other logic systems, NULL implies that the actual value is "unknown".  Thus the logical expression xx == NULL must always evaluate to NULL itself, as it is impossible to ever know if xx, whatever value it may have, is the same as the unknown value.  In programming languages that adhere more strictly to the rules of boolean logic, xx == NULL (or Pythonically xx == None) correctly evaluates to NULL, and alternative means must be provided to determine if a variable value is NULL.  Python is an outlier in this regard, due to the unitary nature of the object reference to None.  But for clarity and logical correctness, using the Python is comparison operator seems to me much sounder practice.
Yes, there is difference between both.  '==' : compares object by value.  'in' : compares object by reference.Now let's consider this case:


Answer URL
https://docs.python.org/3/reference/expressions.html#value-comparisons
https://docs.python.org/3/reference/expressions.html#is-not
https://docs.python.org/3/reference/expressions.html#value-comparisons
https://docs.python.org/3/reference/datamodel.html#data-model
