Natural Text
I would like to create a class whose f method depends on the "mode" the object of the class has been created.The code below doesn't work but hope it gets you an idea of what I am trying to do. My idea is to have a dictionary in which I define the settings for each mode (in this case the function or method to assign to self.f, so that rather than using many if elif statementsin the init function I just assign the correct values using the dictionary.I can't figure why this does not work, how would you fix it?Also are there better (and more pythonic) approaches to get the same kind of functionalities?
Store the name of the two functions, then use getattr() to retrieve the bound method in __init__:Alternatively, just proxy the method:The f property just returns the correct bound method for the current mode. Using a property simplifies call signature handling, and gives users the actual method to introspect if they so wish.Either method has the same end-result:The difference lies in what is stored in the instance, the first method stores bound methods:versus the method in the other:That may not seem much of a difference, but the latter method creates instances that can be pickled and deep-copied without problems.
You could just make two separate classes:
To answer your first question ("why this does not work"): the class object "A" is only created and bound to the module name "A" after the whole class statement (yes, "class" is an executable statement) block has ended, so you cannot refer to neither the name or the class object itself within this block. 


Answer URL
