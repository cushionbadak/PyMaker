Natural Text
In my attempt to learn TDD, trying to learn unit testing and using mock with python.  Slowly getting the hang of it, but unsure if I'm doing this correctly.  Forewarned: I'm stucking using python 2.4 because the vendor API's come as pre-compiled 2.4 pyc files, so I'm using mock 0.8.0 and unittest ( not unittest2 )Given this example code in 'mymodule.py'Now in my test case file 'test_myclass.py', I want to mock the ldap object out.  ldap.initialize returns the ldap.ldapobject.SimpleLDAPObject, so I figured that'd be the method I'd have to mock out.Leads me to a couple of questions:Does that look right? :)Is that the proper way to try and mock an object that gets instantiated within the class I'm testing?Is it ok to be calling the @patch decorator on setUp or is this going to cause weird side effects?Is there anyway to get mock to raise the ldap.INVALID_CREDENTIALS exception without having to import the exception into my testcase file?Should I be using patch.object() instead and if so, how?Thanks.
You can use patch() as a class decorator, not just as a function decorator. You can then pass in the mocked function as before:See: 26.5.3.4. Applying the same patch to every test method (which also lists alternatives)It makes more sense to set up the patcher this way on setUp if you want the patching to be done for all the test methods.
If you have many patches to apply and you want them to apply to things initialised in the setUp methods too try this:
I'll start by answering your questions, and then I'll give a detailed example of how patch() and setUp() interact.I don't think it looks right, see my answer to question #3 in this list for details.Yes, the actual call to patch looks like it should mock the object you want.No, you almost never want to use the @patch() decorator on setUp(). You got lucky, because the object is created in setUp() and never gets created during the test method.I don't know of any way to make a mock object raise an exception without importing that exception into your test case file.I don't see any need for patch.object() here. It just lets you patch attributes of an object instead of specifying the target as a string.To expand on my answer to question #3, the problem is that the patch() decorator only applies while the decorated function is running. As soon as setUp() returns, the patch is removed. In your case, that works, but I bet it would confuse someone looking at this test. If you really only want the patch to happen during setUp(), I would suggest using the with statement to make it obvious that the patch is going to be removed.The following example has two test cases. TestPatchAsDecorator shows that decorating the class will apply the patch during the test method, but not during setUp(). TestPatchInSetUp shows how you can apply the patch so that it's in place during both setUp() and the test method. Calling self.addCleanUp() makes sure that the patch will be removed during tearDown().
I'd like to point out a variation of the accepted answer in which a new argument is passed to the patch() decorator:Note that in this case, it is no longer necessary to add the second argument, MockSomeClass, to every test method, which can save a lot of code repetition.An explanation of this can be found at https://docs.python.org/3/library/unittest.mock.html#patch:If patch() is used as a decorator and new is omitted, the created mock is passed in as an extra argument to the decorated function. The answers above all omit new, but it can be convenient to include it.
You can create a patched inner function and call it from setUp.If your original setUp function is:Then you can patch it by changing it to:


Answer URL
https://docs.python.org/3/library/unittest.mock.html#patch
