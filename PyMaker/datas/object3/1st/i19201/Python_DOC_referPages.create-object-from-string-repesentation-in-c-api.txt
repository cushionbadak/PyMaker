Natural Text
I am working on a system which is embedding a Python interpreter, and I need to construct a PyObject* given a string from the C API.I have a const char* representing a dictionary, in the proper format for eval() to work properly from within Python, ie: "{'bar': 42, 'baz': 50}".  Currently, this is being passed into Python as a PyObject* using the Py_Unicode_ api (representing a string), so in my python interpreter, I can successfully write:I would like to change this to automatically "eval" the const char* on the C side, and return a PyObject* representing a completed dictionary.  How do I go about converting this string into a dictionary in the C API?
There are two basic ways to do this.The first is to simply call eval the same way you do in Python. The only trick is that you need a handle to the builtins module, because you don't get that for free in the C API. There are a number of ways to do this, but one really easy way is to just import it:(This is untested code, and it at least leaks references, and doesn't check for NULL return if you want to handle exceptions on the C sideâ€¦ But it should be enough to get the idea across.)One nice thing about this is that you can use ast.literal_eval in exactly the same way as eval (which means you get some free validation); just change "builtins" to "ast", and "eval" to "literal_eval". But the real win is that you're doing exactly what eval does in Python, which you already know is exactly what you wanted.The alternative is to use the compilation APIs. At the really high level, you can just build  a Python statement out of "foo = eval(%s)" and PyRun_SimpleString it. Below that, use Py_CompileString to parse and compile the expression (you can also parse and compile in separate steps, but that isn't useful here), then PyEval_EvalCode to evaluate it in the appropriate globals and locals. (If you're not tracking globals yourself, use the interpreter-reflection APIs PyEval_GetLocals and PyEval_GetGlobals.) Note that I'm giving the super-simplified version of each function; often you want to use one of the sibling functions. But you can find them easily in the docs.


Answer URL
