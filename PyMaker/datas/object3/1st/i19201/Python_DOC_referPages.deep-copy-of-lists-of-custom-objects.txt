Natural Text
Say I have a list of applications, described as a custom object.  I decided to do a deepcopy of the original application list, so that I could have one list that acts like a pool of available applications.  To assign applications, I randomly select a subset of the pool, and then find those applications in the original list, so that I can update their info. Then, assigned applications are removed from the pool.  But, for some reason, the applications can never be found in the original list:The above code will actually return a ValueError that a item in selected_apps can't be found.  Is the error due to the fact that I'm making deep copies of lists that contain objects that aren't native to Python, or something else?
When using list.index it uses comparison operator (==) to check whether the items are the same, which in turn uses __eq__ method, from documentation:User-defined classes have __eq__() and __hash__() methods by default; with them, all objects compare unequal (except with themselves) and x.__hash__() returns an appropriate value such that x == y implies both that x is y and hash(x) == hash(y).You can demonstrate this by:In CPython id() returns memory address of an object, so __eq__ returns true if ids match:So you just need to implement __eq__ method and __ne__:There are no implied relationships among the comparison operators. The truth of x==y does not imply that x!=y is false. Accordingly, when defining __eq__(), one should also define __ne__() so that the operators will behave as expected.Also notice this:If a class does not define an __eq__() method it should not define a __hash__() operation either; if it defines __eq__() but not __hash__(), its instances will not be usable as items in hashable collections. 


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__eq__
https://docs.python.org/3/reference/datamodel.html#object.__hash__
