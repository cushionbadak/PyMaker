Natural Text
I have a folder full of files that need to be modified in order to extract the true file in it's real format. I need to remove a certain number of bytes from BOTH the beginning and end of the file in order to extract the data I am looking for. How can I do this in python? I need this to work recursively on an entire folder onlyI also need this to output (or modify the exisiting) file with the bytes removed.I would greatly appreciate any help or guidance you can provide.
Recursive iteration over files os.walkChange position in file: f.seekGet file size: os.statRemove data from current position to end of file: f.truncateSo, base logic:Iterate over filesGet file size.Open file ('rb+' i suppouse )Seek to position from wich you want read fileRead until bytes you want to drop ( f.read(file_size - top_dropped - bottom_dropped ) )Seek(0)Write read text to fileTruncate file
Your question is pretty badly constructed, but as this is somewhat advanced stuff I'll provide you with a code.You can now use os.walk() to recursively traverse directory you want and apply my slicefile() function.This code does the following:After checking validity of start and end arguments it creates a memory map on top of an opened file.mmap() creates a memory map object that mapps, in this case, portion of a file system over which the file is written. The object exposes both a string-like and file-like interface with some additional methods like move(). So you can treat memory map either as a string or as a file or use size(), move(), resize() or whatever additional methods you need.We calculate what is a distance between our start and end, i.e. this is how much bytes we will have in the end.We move stream of bytes, end-start long, starting from our start position to the 0 position i.e. we move them backwards for number of bytes indicated by starting point.We discard the rest of file. I.e. we resize it to end-start bytes. So, what is left is our new string.The operation will be longer as the file is bigger. Unfortunately there is nothing much you can do about it. If a file is big, this is your best bet. The procedure is the same as when removing items from a start/middle of an  in-memory array, except this has to be buffered (in chunks) not to fill RAM too much.If your file is smaller than a third of your free RAM space, you can load it whole into a string with f.read(), then perform string slicing on the loaded content ( s = s[start:end] ) and then write it back into file by opening it again and just doing f.write(s).If you have enough disk space, you can open another file, seek to the starting point you want in the original file and then read it in chunks and write these into the new file. Perhaps even using shutil.copyfileobj(). After that, you remove the original file and use os.rename() to put the new one in its place. These are your only 3 options.Whole file into RAM; move by buffering backward and then resizing; and, copying into another file, then renaming it. The second option is most universal and won't fail you for small or big files. Therefore I used it.OK, Not only 3 options. There is a fourth option. It could be possible to cut off N number of bytes from beginning of the file by manipulating the file system itself using low-level operations. To write a kind of truncate() function that truncates the beginning instead of the end. But this would be pretty suicidal. In the end memory fragmentation would occur and whole mess will arise. You don't need such speed anyway. You will be patient until your script finishes. :DWhy did i use mmap()?Because it uses memory maps implemented in OS rather than completely new code. This reduces number of system calls needed to deal with the opened file. Half of the work is thrust upon operating system, leaving Python to breathe easily.Because it is mostly written in C which makes it a touch faster than its pure Python implementation would be.Because it implements move() which wee need. The buffering and everything is already written, so no needs for bulky while loop which would be the alternative (manual) solution.And so on...


Answer URL
https://docs.python.org/3/library/os.html#os.walk
https://docs.python.org/3/tutorial/inputoutput.html?highlight=seek
https://docs.python.org/3/library/os.html#os.stat
https://docs.python.org/3/tutorial/inputoutput.html?highlight=truncate
