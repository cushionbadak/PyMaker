Natural Text
I got the following function to test:my_package.db_engine.db_functions.py: This function takes the name of a database, then builds a command string from it and executes this command as subprocess with the execute_cmd method. I want to test this function without actually executing the subprocess. I only want to check if the command is built correctly and correctly passed to execute_cmd. Therefore I need to mock the execute_cmd method which is imported from module utils.My folder structure is the following:So for my test I tried the following in test_db_engine.py:The execution of the actual command yields 1.6 for Last Checkpoint. So to verify if the mock return value is used, I set it to 1.7.But the mock for the function is not used, as the execution of the test case still yields 1.6 because it is executing the actual function that should have been patched with the mock.Any idea what I got wrong here?
You are patching the wrong location. From the Where to patch section:patch() works by (temporarily) changing the object that a name points to with another one. There can be many names pointing to any individual object, so for patching to work you must ensure that you patch the name used by the system under test.The basic principle is that you patch where an object is looked up, which is not necessarily the same place as where it is defined. Your code-under-test finds execute_cmd as a global in their own module, but you didn't patch that reference:The my_package.utils.execute_cmd reference is patched, but that execute_cmd reference in my_package.db_engine.db_functions will still point to the original, unpatched function.Patch the imported global instead:Now the execute_cmd lookup inside dbinfo will use the patched mock object rather than the original global bound by the from ... import ... statement.


Answer URL
https://docs.python.org/3/library/unittest.mock.html#where-to-patch
