Natural Text
I have an empty dictionary that I want to add to by using a while loop, and a string that I want to iterate over using the same loop. What I want to do is add to the dictionary by using a character, at, as the key, and at+1 as the value. While reading from the string, if the loop comes across a key already in the dictionary, it would add the value at at to the value already in the dictionary. It stops once it reaches the length of the string - 1.Suppose I was given the string, "Hello" to make the dictionary with. My loop would ideally read 'H' as the first letter, then create a entry using 'H' as a key and 'e' as the value. When it comes to 'l', it creates an entry with 'l' as the key and 'l' as the value. Then, an entry with 'l' as the key, and 'o' as the value.Here is my function so far. Instead of starting at the 0th index, it starts at the first:What is the correct syntax for the line:
Strings can be used as dictionary keys, so you should just be able to do __follow[word[at]] += word[at + 1]. However, you also need to provide a default value using a defaultdict (docs):If you don't do this, the first time you try to append to __follow on a key that doesn't exist will fail with a KeyError. With a defaultdict, if you access a key that doesn't exist yet, you'll get (in this case) an empty string.Incidentally, it looks like you're in a class method. If so, it seems like __first and __follow should be probably be instance attributes if you want them to be persistent.
You could also construct __follow with the dictionary constructor in a single line:I will walk through this for the example string "Hello".word[:-1] will give you a string up to but not including the last letter. word[1:] will give you a string starting at the second letter and going to the end. This gives you two strings 'Hell' and 'ello'.zip is a python built-in function that takes two iterable items and returns a list of tuples pairing each consecutive element, so zip(word[:-1], word[1:]) gives:Calling the dictionary constructor directly using dict allows you to pass in a list of tuples like the one provided by zip, and yields a dictionary with the first element of each tuple as a key, and the second element as the value.Putting that all together, dict(zip(word[:-1], word[1:])) will give you a dictionary that looks likeNote this isn't exactly what you want because "Hello" has two 'l' characters but keys in a dictionary have to be unique. You can't have two 'l' keys pointing to different values. This means that whatever implementation you choose, setting __follow['l']='o' will overwrite the previous occurrence of __follow['l']='l' when word is "Hello".


Answer URL
https://docs.python.org/3/library/collections.html#collections.defaultdict
https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables
