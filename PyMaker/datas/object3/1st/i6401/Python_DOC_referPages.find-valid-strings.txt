Natural Text
A string is valid if and only if it has only two characters a and b in it (not necessary that a should be present) and it must have three b's in it in succession in order to be valid. For example for string of length n=4 [bbbb,bbba,abbb] are valid strings that are totally valid strings are 3 and for n=3 there is only one valid string [bbb]. n can be any integer up to 10**4. My approach to this problem can be naive as I am new to programming but this is how I started:Now I am looking for a pattern for n=5,6,7 and then implement it for the general but I want to eliminate all the invalid strings from list y that doesn't satisfy above conditions.I need to print count of all valid strings for a a particular integer n which corresponds to length of the string .
We can easily produce valid strings using itertools.product to produce tuples of 'a' and 'b' of the required length, join the tuples into strings, and then filter out strings that don't contain 'bbb'.We don't need to store all the strings in a list. Instead, we produce them using a generator function.To count the number of valid strings of a given length we still don't need to make a list. We can easily count the strings yielded by the generator using the built-in sum function and a generator expression.Here's a short demo.outputThis strategy is ok for small n, but we need a formula to calculate those counts for larger n. Fortunately, this sequence can be found in the OEIS as sequence A050231, which lists a couple of useful formulae. It even has some Python code, although we can make a more efficient function using a different formula. Using this formula we can easily calculate the counts for large n, although for n > 1000 we may need to increase the recursion limit (depending on what's in the cache dictionary).outputAdirio mentions in the comments that we don't need to initialise the cache with 4: 3, and that we can make this version a little more efficient by using a list instead of a dict for the cache. This works because the recursion guarantees that any new item added to the cache will always have an index 1 greater than that of the current last item in the cache.Here's the improved version:Thanks, Adirio!
You could use this to generate all possible combinations for a given length n and then filter the invalid ones.A faster method that uses comprehension (prefer for smaller n values):A RAM efficient method that uses generators (prefer for bigger n values):
A simple approach for this would be generating all the possible combinatios of strings of a certain length with only chars 'a' and 'b' and then testing if there is the 'bbb' pattern inside them.The function appends to every str inside the parameter seed the options in chars. So if seed = ['var'] and chars = "12" => result = ['var1', 'var2']. Before doing that we are creating a list with an empty str if we do not provide it. After it we are checking if we have reached the desired length or calling to ourselves but reducing n by 1.This generates a list of length equal to the length of the chars variable to the power of n: len(chars)**n. This means that you will get soon out of memory n=100 is giving me memory issues, depends on your mahcine, setup, ...Then we filter it and convert it back to a list using a lambda function that checks if it has the substring 'bbb'.Another solution would be using itertools:I gave some alternatives to each step as sugested by @DanielTrugman and @PM2Ring, any combination of them should work. The key point in this new approach is that they are never creating a list, which was the one giving memory problems before, they are creating generators. A generator can be used to generate the next element and can be used in for loops but doesn't store the full content in memory (this also means that once I iterate over the generator, I would need to create it again if I want to use it in another for loop). By using enumerate each element is transormed into a tuple of the form (i, element) being i an auto-incremented integer starting at 0 so when the loop ends i equals the number of elements minus 1. An alternative to this last part would be to do it manually.Remember that you can't use both as the second time the generator would be empty, either you recreate it re executing both the unfiltered and filtered part or you just use one of the methods.NOTE: THIS WILL TAKE AGES FOR N=10^5A further answer by @PM2Ring gives information on how you could calculate the result with a numeric formula that will be mroe effficient that iterating over the possibilities, even if they are using generators.
This can be done by using simple regex matching. First check whether the string contains only a's and b's. Then, create all the combinations using itertools and filter the ones you need using regex.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.product
