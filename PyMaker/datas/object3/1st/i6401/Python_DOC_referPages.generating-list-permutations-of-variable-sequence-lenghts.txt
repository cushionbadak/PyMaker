Natural Text
Suppose I have a list that looks like this:beast = ['E', 'O', 'R', 'E', 'O', 'S', 'P', 'E', 'P', 'P', 'O', 'R', 'S', 'P', 'O', 'E']Now, here are the basic patterns that I want to extract:The problem is, if I extract only ['P', 'O', 'R', 'S', 'P', 'O'] out of beast, I miss out on the previous P before that pattern occurs.(Better example - There can also be ['O', 'O', 'R', 'O', 'O', 'O'])Therefore, every letter in those basic patterns can be expanded in a sense of:Os can occur together thrice. Ps can occur together twice. Rs can occur together twice.Ss can occur only once.I want to generate a list of all possible permutations but have no idea where to start.I wrote a naive python code that replaces every occurrence of O with three Os and etc. But that results in -['O', 'O', 'O', 'R' 'O', 'O', 'O']Which won't work when I need to find:['O', 'R', 'O', 'O']Any help is appreciated. Thank you.
This sounds like a job for regexes. If you join your beast list into a string with ''.join(beast), you can build regexes to search it for substrings matching specific patterns. For example, using the {m,n} quantifier to search for a certain number of repetitions of a subpattern, you can useto search for a pattern consisting of 1 to 3 Os, 1 to 2 Rs, and 1 to 3 more Os.See the re module documentation for more information on Python's regex syntax and functions, and see any number of online tutorials for help getting used to writing regexes.


Answer URL
https://docs.python.org/3/library/re.html
