Natural Text
Consider this small example:which prints Why is the self parameter (which should be the Test obj instance) not passed as first argument to the decorated function decorated?If I do it manually, like :it works as expected. But if I must know in advance if a function is decorated or not, it defeats the whole purpose of decorators. What is the pattern to go here, or do I misunderstood something?
tl;drYou can fix this problem by making the Timed class a descriptor and returning a partially applied function from __get__ which applies the Test object as one of the arguments, like thisThe actual problemQuoting Python documentation for decorator,The decorator syntax is merely syntactic sugar, the following two function definitions are semantically equivalent:So, when you say,it is actually only the function object is passed to the Timed, the object to which it is actually bound is not passed on along with it. So, when you invoke it like thisself.func will refer to the unbound function object and it is invoked with Hello as the first argument. That is why self prints as Hello.How can I fix this?Since you have no reference to the Test instance in the Timed, the only way to do this would be to convert Timed as a descriptor class. Quoting the documentation, Invoking descriptors section,In general, a descriptor is an object attribute with “binding behavior”, one whose attribute access has been overridden by methods in the descriptor protocol: __get__(), __set__(), and __delete__(). If any of those methods are defined for an object, it is said to be a descriptor.The default behavior for attribute access is to get, set, or delete the attribute from an object’s dictionary. For instance, a.x has a lookup chain starting with a.__dict__['x'], then type(a).__dict__['x'], and continuing through the base classes of type(a) excluding metaclasses.However, if the looked-up value is an object defining one of the descriptor methods, then Python may override the default behavior and invoke the descriptor method instead.We can make Timed a descriptor, by simply defining a method like thisHere, self refers to the Timed object itself, instance refers to the actual object on which the attribute lookup is happening and owner refers to the class corresponding to the instance.Now, when __call__ is invoked on Timed, the __get__ method will be invoked. Now, somehow, we need to pass the first argument as the instance of Test class (even before Hello). So, we create another partially applied function, whose first parameter will be the Test instance, like thisNow, self.__call__ is a bound method (bound to Timed instance) and the second parameter to partial is the first argument to the self.__call__ call.So, all these effectively translate like thisNow self.decorated is actually Timed(decorated) (this will be referred as TimedObject from now on) object. Whenever we access it, the __get__ method defined in it will be invoked and it returns a partial function. You can confirm that like thiswould printSo,gets translated toSince we return a partial function,which is actuallySo, <Test obj> also becomes a part of *args, and when self.func is invoked, the first argument will be the <Test obj>.
You first have to understand how function become methods and how self is "automagically" injected.Once you know that, the "problem" is obvious: you are decorating the decorated function with a Timed instance - IOW, Test.decorated is a Timed instance, not a function instance - and your Timed class does not mimick the function type's implementation of the descriptor protocol. What you want looks like this:
I use decorators in the following way:


Answer URL
https://docs.python.org/3/glossary.html#term-descriptor
https://docs.python.org/3/glossary.html#term-decorator
