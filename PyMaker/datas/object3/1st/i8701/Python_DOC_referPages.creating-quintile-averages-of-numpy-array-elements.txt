Natural Text
I am trying to replace each element of a numpy array with the average value of the elements that fall in its quintile. Here is my long-winded way of doing this: Create scalars that store the value of different quintile boundaries (20, 40, 60, 80 and 100 percentile values naming them q1 through q5). Then, create averages of all the elements within each quintile and name them m1 through m5. Next, go through each element of the numpy array and check which quintile it falls in, and replace it with the mean value corresponding to that quintile. I believe that there is a Pythonic way to do this using boolean masking but don't know where to begin. Please advise.
Here is an argsorting solution which calculates the quantiles and means in one go. I'm not sure the rounding will in all cases be 100% as in your implementation, though. The quintile sums are computed using the reduceat method of the np.add ufunc.UPDATE: Actually, argsort can be replaced with argpartition which should be faster on large arrays.Step-by-stepBoundaries will be [0, 2, 4, 6, 8, 10] we throw away 0 and 10 so argpartition will split at elements (by rank order) 2, 4, 6, 8. This produces 5 partitions at referenced by inds[:2], inds[2:4], inds[4:6], inds[6:8] and inds[8:] and we are guaranteed aray[inds[:2]] <= aray[inds[2]] <= aray[inds[2:4]] <= aray[inds[4]] etc.np.add.reduceat returns the sums of slices aray[inds][0:2], aray[inds][2:4], ..., aray[inds][8:], np.diff calculates the appropriate denominator.The np.repeat creates copies of the means for each individual element in each quintile.
I am not sure if this is the most pythonic way to do it, but here is a neater wayYou can avoid the copy of course...


Answer URL
