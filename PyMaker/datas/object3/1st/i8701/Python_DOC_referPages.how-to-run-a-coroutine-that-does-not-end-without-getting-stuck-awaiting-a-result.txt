Natural Text
I have this piece of code where I want to connect to a websocket and keep the connection alive by sending heartbeats. While doing this, I also want to be able to send payloads to the websocket, however I keep getting stuck awaiting the result of my keepAlive coroutineWith this piece of code however, print statement after awaiting keepAlive is never printed. How can I make it so that the code does not wait for the result of keepAlive?
Although keepAlive(socket) would return immediatly, since keepAlive is a couroutine, await keepAlive(socket) would never return since keepAlive() includes an infinite loop.Instead of using await, try asyncio.ensure_future(keepAlive(socket)).If you do want to use await keepAlive(socket), try sending your payloads from somewhere else (maybe use asyncio.ensure_future(send_payload(socket)) beforehand).
This is a case where you are conceptually having two separate conversations over the same socket. One conversation is your heartbeat and reply messages. Another is the other packets of data you are sending.I would keep 3 separate top-level (i.e. they report directly to the event loop) tasks going for this. I would have them all keep a reference to some coordinator so any of them can cancel all of the others when it becomes time to do so.The heartbeat task, basically your keepAlive function.The task handling the other conversation you're having over the websocket.The task that multiplexes reads from the websocket.The multiplexing task's job is to route messages to the appropriate task. The heartbeat task should only get heartbeat responses and the other task should get all the other messages.Since websockets already frame messages and so you can only send or recv a whole message, the other job it could have isn't relevant.Here is one way you could write this.There are some problems here. If an exception is thrown, the heartbeat and router tasks might not end up being canceled. They also have no really good way to report problems back to the main beginSocket task. This is basically a sort of quick and dirty one-off to demonstrate how to do what you want to do.In my opinion, asyncio.ensure_future is misnamed. What it does is tell the event loop that there is a new thing that it needs to keep running. It's basically launching the coroutine equivalent of a thread.


Answer URL
https://docs.python.org/3/library/asyncio-task.html
