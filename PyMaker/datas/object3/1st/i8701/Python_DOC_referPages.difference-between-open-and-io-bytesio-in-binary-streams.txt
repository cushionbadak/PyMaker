Natural Text
I'm learning about working with streams in Python and I noticed that the IO docs say the following:The easiest way to create a binary stream is with open() with 'b' in the mode string:f = open("myfile.jpg", "rb")In-memory binary streams are also available as BytesIO objects:f = io.BytesIO(b"some initial binary data: \x00\x01")What is the difference between f as defined by open and f as defined by BytesIO. In other words, what makes a "In-memory binary stream" and how is that different from what open does?
For simplicity's sake, let's consider writing instead of reading for now.So when you use open() like say:After executing that a file called test.dat will be created, containing Hello World. The data wont be kept in memory after it's written to the file (unless being kept by a name).Now when you consider io.BytesIO() instead:Which instead of writing the contents to a file, it's written to an in memory buffer. In other words a chunk of RAM. Essentially writing the following would be the equivalent:In relation to the example with the with statement, then at the end there would also be a del buffer.The key difference here is optimization and performance. io.BytesIO is able to do some optimizations that makes it faster than simply concatenating all the b"Hello World" one by one.Just to prove it here's a small benchmark:Concat:  1.3529 secondsBytesIO: 0.0090 secondsBesides the performance gain, using BytesIO instead of concatenating has the advantage that BytesIO can be used in place of a file object. So say you have a function that expects a file object to write to. Then you can give it that in-memory buffer instead of a file.The difference is that open("myfile.jpg", "rb") simply loads and returns the contents of myfile.jpg; whereas, BytesIO again is just a buffer containing some data.Since BytesIO is just a buffer - if you wanted to write the contents to a file later - you'd have to do:Also, you didn't mention a version; I'm using Python 3. Related to the examples: I'm using the with statement instead of calling f.close()
Using open opens a file on your hard drive. Depending on what mode you use, you can read or write (or both) from the disk.A BytesIO object isn't associated with any real file on the disk. It's just a chunk of memory that behaves like a file does. It has the same API as a file object returned from open (with mode r+b, allowing reading and writing of binary data).BytesIO (and it's close sibling StringIO which is always in text mode) can be useful when you need to pass data to or from an API that expect to be given a file object, but where you'd prefer to pass the data directly. You can load your input data you have into the BytesIO before giving it to the library. After it returns, you can get any data the library wrote to the file from the BytesIO using the getvalue() method. (Usually you'd only need to do one of those, of course.)
read bytes from file from disk disk and assign such value to object referenced as 'f' which is kept by Python in memory.assign bytes stream value to object referenced as 'f' which is kept by Python in memory. 


Answer URL
https://docs.python.org/3/library/io.html
