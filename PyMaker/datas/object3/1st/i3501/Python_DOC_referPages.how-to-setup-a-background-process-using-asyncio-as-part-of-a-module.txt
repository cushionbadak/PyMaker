Natural Text
I'm writing a python module (experimental use case) which gives users the ability to send messages to another computer. The computer we want to send the message to has an unknown address which changes at arbitrary times. There is another computer (intermediary) which provides the address and time until the address expires. For simplicity sake, let's call the one sending the message computer-A, the one receiving computer-B and computer-C is the intermediary we need to contact for computer-B's address. What I'm trying to accomplish:I want to be able to defer the process of waiting for the expiration time to be over to asyncio.sleep(). When the time expires, I would expect the process to get back control of the event loop and run a function to update the address.The problem i'm struggling with is how do i implement this within a class where I cannot invoke run_until_complete/run_forever (or am i blatantly incorrect). How do you implement such a thing using the asyncio framework?Example hypothetical code?:
A way to accomplish this is to have your class schedule a task on the event loop using create_task.This can be done before or after the event loop has been started.As you want to have a separate timer for each address, it would be simplest to have 1 task per address;we can keep these in a dictionary alongside the addresses:Naturally, if the event loop is never started, then the updating will never happen.Finally, something that you'll want to do is to control the lifetime of these updater tasks.I didn't implement this in the above example to keep it short.The standard approach is to make your class into a context manager, and get __exit__to cancel all the updaters.
The general flow of an asyncio program is something like this.There are other ways to actually wait on the coroutine returned by the function call long_io_bound_operation() depending on what you want, but this is the main form of it.  Read up on the asyncio module for the gritty details, but the gist of it is that every time you use the await keyword, the python runtime can elect to do a non-blocking wait for the result rather than blocking and spinning waiting on some work to be done.It's a little unclear to me from your code exactly what protocol you plan to invoke for this communication, but it's a really good bet that there is already an asyncio-compliant wrapper around that protocol written for you to leverage.  aiohttp is an async wrapper for http request, for example.If you give more details about the protocol you're using, then you'll probably get more specific advice for your problem.  Hope this general summary is useful, though.


Answer URL
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.create_task
