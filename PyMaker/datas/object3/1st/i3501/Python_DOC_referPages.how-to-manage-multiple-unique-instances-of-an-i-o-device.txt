Natural Text
I have a I/O serial device (a class, calling it here SerialPort) that other parts of my program will read/write to. SerialPort handles the connection to the port (pyserial), threading of the I/O, and is implemented as a pub/sub design, other classes in my program get called back if there is a new message, or can write new messages. The device has >100 supported messages and responses, hence the pub/sub design (not the center of this question but just wanted to clarify choice). Now I need to add 2 (or more) of the same device. What I would like to do is have any observer call something like:Where in Observer() an instance (or an interface) of SerialPort is kept, so Observer can write, and register callbacks to SerialPort. The part I am stuck on is how to handle that every call to SerialPort("UniqueName1") should just return the already connected SerialPort object (assuming its been connected/initialized earlier). Observer should just be able to say "I want to talk to a device with UniqueName1 (or 2)"  In this fashion I could then have an observer of both SerialPort objects by keeping two (or more) SerialPort references in Observer. I dont need to do this, but this design does not restrict me if I need to in the future.Any advice on how to do this in python (2.7)? I am new to python, googling as I go. I just need help on where I should put the python/pseudo code below. I tried to put this in the class Serialport but the SerialPort.__init__(name) did not let me return an already created SerialPort device
While it is possible to intercept the SerialPort constructor so that SerialPort("UniqueName1") returns the existing value (if any) instead of creating a new one,1 that's usually not what you want to do.The simplest solution is to just store a dict of serial ports, but this requires manually looking things up each time:So, you might want to make the dict private and wrap up the access in a function:And now you just call that function:You can just put this function in the same module as your SerialPort or Observer class.If you might have multiple different name-to-ports mappings, you'd probably want to instead wrap this in a SerialPortManager class whose instances have a self._ports and a getport method, but otherwise you don't need that. 1. If you really do want to intercept the constructor, the way to do that is with a __new__ method. The default implementation just returns a new empty object of your type, and if you return that, your __init__ method gets called. But you can return anything else you want instead. Which includes not calling the super() version and instead looking up a value in some private dict.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__new__
