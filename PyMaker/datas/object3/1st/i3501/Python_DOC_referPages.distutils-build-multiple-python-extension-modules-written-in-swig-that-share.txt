Natural Text
I have four C++ files: A.h, A.cpp, B.h, B.cpp, and A.h is included in B.cppA.h:A.cpp:B.h:B.cpp:Now I wrote two SWIG inerface files A.i and B.iA.i:B.i:The setup.py file is:If I type the command below, it will show 'A'.If I type the command below, the segmentation fault appears:How could I do to get this command run correctly? Since I don't want to compile B.cpp many times, is there any way except the one below?
I changed your files a bit, for clarity.a.h:a.cpp:a.i:b.h:b.cpp:b.i:setup.py:What happens (simplified) when calling b.funcB() (only the stacktrace, imports left aside). Each step invokes the next:funcB from module b (b.py)funcB from module _b (_b.so, or _b.cpython-35m-x86_64-linux-gnu.so)Everything from here happens in C (or C++)Current funcB is different than the one from b.cpp: it's generated by swig and its name is _wrap_funcBPrevious bullet also applies to funcA and a.cppfuncB from b.cppfuncA from a.cppThe problem is that the code from step #4. is not in the module _b, and it will fail at runtime. But things are a little bit stranger: the failure (core dump) doesn't appear when funcB is called but at module (b -> _b) import time (I think this happens because of swig's behind the scene magic), as seen below.Output:In order to solve it, either:As you pointed out include funcA in module _b (by adding a.cpp in ext_b's source files list). This way, both modules will be self contained (from funcA's PoV), each will work independently,  but also funcA will be duplicated in both of themMake _b depend on _a (after all, they're shared objects). But that's not how Python extension modules are to be used, and it won't work on Win (and also on some Ux flavors). So, this is more like a (lame) workaround (gainarie)Build a.cpp into a different shared library (an .so, but not a Python extension module) to be used by both modules. Needless to say that at runtime each of them will require the .so to be presentObviously, to option #3. is the perfect candidate. But distutils ([Python 3]: API Reference) doesn't provide the needed functionality OOTB (apparently building an extension module and an external shared library that it depends on, is not a scenario that distutils aims for), or at least, I couldn't find any. There is a build_clib module, which offers the functionality of building a static lib (to be used by the extension modules), but that would be same as option #1..setup.py:Notes:build_clib_dyn extends build_clib as its functionality had to be modified. 2 methods overridden but only small parts of them actually changed (comments were not copied from the base class methods (Python3.5.4


Answer URL
https://docs.python.org/3/distutils/apiref.html#api-reference
