Natural Text
I encountered a bit weird (to me) behavior upon running the following script.As you can see it seems as though write is called multiple times and I wonder why this is, as I have explicitly overridden the file=sys.stdout behavior.How exactly does print pipe streams under the hood, does it pipe to all channels? Does it have some default behavior, the docs are not very specific except for the following:The file argument must be an object with a write(string) method; if it  is not present or None, sys.stdout will be used.Test scriptOutput:What I expected:What I tried:I tried to use inspect module to get the caller, maybe see who does the actual call to write but I get module, idk why :( is this obvious?Further questions:Is there any way to debug a function beyond Python and go into the underlying C call? Because well the main Python distribution, is CPython, and if my understanding is correct, Python is just an api for the underlying C code. A call in Python gets translated to a C call under the hood eventually. So for instance I found out that the print is defined as follows in C, but it's tough for me to understand what's going on there (because, erm, I don't know C) but maybe by going with a debugger I could print stuff out, see what is what and figure out maybe at least the flow if not everything. I'd very much like to understand what's going on under the hood in general instead of taking stuff for granted.Thx in advance for your time!
You're looking for something really complicated when the answer is dead simple.I don't even know what "pipe to all channels" would mean, but print does nothing of the sort. All it does is call write on the file object you passed it.However, it calls write once for each argument, once for each sep, and once for the end.So, this line:… is roughly equivalent to:… which of course means you get your extra print message twice.By the way, for debugging or understanding things like this in the future: If you changed the extra print to include, say, repr(obj), what's happening would have been obvious:The output is then:Not very mysterious anymore, right?And of course stdout and stderr are separate streams, with their own buffers. (By default, when talking to a TTY, stdout is line-buffered, and stderr is unbuffered.) So the ordering isn't what you'd naively expect, but it makes sense. If you just add in flushes, the output turns into:(with a blank line at the end).For your bonus questions:I tried to use inspect module to get the caller, maybe see who does the actual call to write but I get module, idk why :( is this obvious?I'm assuming you did something like inspect.stack()[1].function? If so, the code you're inspecting is the top-level code in the module, so inspect shows it as a fake function named <module>.Is there any way to debug a function beyond Python and go into the underlying C call?Sure. Just run CPython itself under lldb, gdb, Microsoft's debugger, or whatever else you usually use for debugging binary programs. You can put breakpoints in the ceval loop or in a particular C API function or wherever you want. You may want to make a debug build of CPython (do ./configure --help to see the options) to make this even better.Because well the main Python distribution, is CPython, and if my understanding is correct, Python is just an api for the underlying C code.Well, not quite. It's a compiler and a bytecode interpreter. That bytecode interpreter largely uses the same C API that's exposed for the extending/embedding interface, but the overlap isn't 100%; there are places where it deals with the structures below the C API level.A call in Python gets translated to a C call under the hood eventually. So for instance I found out that the print is defined as follows in C, but it's tough for me to understand what's going on there (because, erm, I don't know C) but maybe by going with a debugger I could print stuff out, see what is what and figure out maybe at least the flow if not everything. I'd very much like to understand what's going on under the hood in general instead of taking stuff for granted.Yes, you can do that, but you will need to understand both C and the CPython API (e.g., things like how to find the C slot equivalent to __call__) to figure out where to put your breakpoints and start tracing.And for cases like these, it's a lot easier to just write wrappers in Python and debug them in Python. For example:Or, if you're worried about print being called in other modules, not just in yours, you can even shadow it in builtins:Now you can just use pdb to break on every call to print at the Python level, without worrying about the C.And of course you can even debug this code in PyPy or Jython or whatever to see if it's any different from CPython above the "builtin" level.
You get the result you see because builtin_print() calls PyFile_Write*() twice, once in order to print the argument, and again to print the EOL. They are out of order because by default stderr is unbuffered and stdout is line-buffered.


Answer URL
https://docs.python.org/3/library/functions.html#print
