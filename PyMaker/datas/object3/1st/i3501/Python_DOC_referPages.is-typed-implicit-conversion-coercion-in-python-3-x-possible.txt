Natural Text
Is it possible to implement custom automatic/implicit conversion (aka coercion) in Python 3.6+ that won't make mypy and other static analyzers sad? An example would be a def(foo: A), and given def b_to_a(b: B) -> A, is there a way I could potentially write foo(some_b) (where some_b: B ) instead of foo(b_to_a(some_b))? I think there are definitely some good ways to do this in the dynamics of Python (tacking on members to classes that include converters, for instance), or even tacking on such converters to the function object itself so that it can handle conversion for selected types, but my current understanding of Python types makes me thing it would not satisfy mypy and the like.For comparison, see Scala's implicit conversions.
Here's an implementation of this feature I came up with.  We keep a dictionary of single-dispatch converters for types we know the "implicit" conversions for.  We add converters to this using the @implicit decorator.We then have a @coerce decorator that can inspect the function annotations at runtime, get the appropriate converters and apply the conversions.  Below is the framework: And an example:
It sounds like you may be looking for something like the Protocol types proposed in PEP 544. That PEP isn't approved yet (and may not have a complete implementation yet either), so it may be a while before you get the feature you need (Python 3.8 at the earliest).Anyway, according to the PEP, Protocols would let you describe a kind of abstract type based on what methods and attributes it has, without the concrete types needing to know about the Protocol or do anything in particular (it doesn't need to inherit from an abstract base class, just have the required methods). It's similar to how you can customize how isinstance and issubclass work using metaclasses, but it works with static type checking, not only at runtime.For instance, iterators in Python are an existing protocol that many unrelated classes implement. If the PEP is approved and implemented, you won't need to declare a custom iterator type as inheriting from typing.Iterator any more, it would figure it out automatically, just because the class has __iter__ and __next__ methods.In your example, you could make an A_Like protocol that requires a to_A method:Then you'd implement A.to_A with a simple return self, while B.to_A does the appropriate conversion. Both classes will be seen as matching the A_Like protocol type, so def foo(a: A_Like) would satisfy type checkers (with the body of the class needing to do a = a.to_A() before calling any A specific methods).You can do this now with inheritance from a common abstract base class (which can be a simple mixin), but it's definitely not as elegant as it will be with Protocols. Another option if you don't have many classes you need to convert is to just use Union types declarations: def foo(a: Union[A, B])
I don't think this is a conversion problem. But it looks like a annotation problem.First, if foo can only handle A, how could it accept B? And if foo can handle B too, why it should only accpet A?Second, if you want to annotate that foo accept A or B, you can use def(foo: Union[A, B]).Finally, if you mean B should have some methods that make it can be handled by function which can only handle A. It is still an instance of B. Without right annotation, your static analyzers will still warn you.


Answer URL
https://docs.python.org/3/library/functools.html#functools.singledispatch
https://docs.python.org/3/library/functools.html#functools.singledispatch
https://docs.python.org/3/library/abc.html#abc.ABCMeta.__subclasshook__
