Natural Text
I'm working on the following problem, I have a class, an asynchronous  method of which I want to mock patch:I want to patch specifically only calls likeNormally I'd use where mocker is the pytest-mock plugin fixture and AsyncMock has the formwhich would give me a Mock object that behaves like a coroutine on call. The problem is, that I want to have access to the self attribute that is passed to the method. self is only passed to the mock object if you set autospec=True though (see also Python Doc on patching unbound methods), which you can't use together with new_callable.Does anyone have an idea how to resolve this?
Indeed, you can't mix autospeccing and a new callable. Instead, autospec the method, but then replace the side_effect attribute, giving it an AsyncMock() instance:Because the AsyncMock() is a callable object, it'll be called every time mock_asy_method is called, and the arguments are passed on to the object. The result of that call is then used to return from mock_asy_method():As you can see, the self argument and the parameter are recorded in the call, because mock_asy_method is a properly specced function.Of course, only if the returned AsyncMock() call result is actually awaited will we see that call recorded too:


Answer URL
https://docs.python.org/3/library/unittest.mock-examples.html#mocking-unbound-methods
