Natural Text
I have written a npy file in my C++ program using cnpy:following the example here.But when I try to load the file using numpy I get an errorValueError: descr is not a valid dtype descriptor: '<?24'Below I paste the result of hexdump -C for a npy file containing a vector<double> of length 2 (should contain 46.950, 43.94):This issue has been posted to cnpy github site as well. Just wondering if there is something I can do on the numpy side? Thanks.
If you want to fix this from the numpy side… Well, you probably don't want to modify numpy to understand non-standard descr strings, and I suspect that even if you treat that descr string as what it seems to be claiming you'd get garbage anyway.  But you can do a hacky workaround.If you open the binary file, it should start with something like this:… followed by some whitespace ending in a newline before the raw bytes.You can edit this carefully in a hex editor or text editor, or with Python code that opens the file in binary mode, reads it, does some normal string operations on the bytes, and writes it back out.In particular, the bit that looks like a Python dict repr really is exactly that, and the values mean exactly what you think they mean. Loading the file ends up trying to create an np.dtype('<?24'), and that's where the error comes from.If you just edit the descr and shape values, and make sure to keep the dict repr the same length (by padding with whitespace), that will give you something you can load.So, what does <?24 mean? Well, it's not a valid format as specified by  PEP 3118 and struct, but it does fit the pattern of numpy's extensions to that format. For example, in numpy, you can specify f8, meaning "same as f but 8 bytes". So, presumably, this means a 24-byte little-endian version of ?, which means _Bool if compiled with C99, char if not, and is meant to be interpreted as bool in Python.So, if numpy allowed this descr to specify a dtype, what it would mean is that every cell is 24 bytes, interpreted as a little-endian integer interpreted as a bool. Of course numpy doesn't know how to handle integers of any length but 1, 2, 4, or 8 bytes, and it expects bools to be 1 byte, so it isn't allowed. But you could read the same thing as 24 separate bools.How do you do that? Just change the descr string to '?', and the shape to (30, 20, 24), and now you've got a 30x20x24 boolean array, and if you slice [..., 0], you get a 30x20 boolean array. Or, possibly, '24?' would do that without needing to change the shape.The problem is, your C++ values are doubles, not bools.Hopefully, it's just written the doubles in little-endian format with 16 extra 0 bytes after each one. If so, just change the descr to '<f8', change the shape to (30, 20, 3), and see what you get. If the first (30, 20) is your desired array, and the other two are all zeros, you're done; just slice it. (And maybe ascontiguous it if you want to cut the memory use.)
You have a bug as per the format of npy_save() arguments on the example you provided.Instead of,You want,


Answer URL
https://docs.python.org/3/library/struct.html#format-characters
