Natural Text
I am looking to see if there is a good way to create a wrapping object.  I am looking for a solution I can write in Wrapper class (or potentially a metaclass of Wrapper) so the following code is accurate. I don't have ability to change Thing_A or Thing_B classes in my real world scenario.I tried looking at __new__, metaclasses and type class creation but I am not getting the result I want. If there is a better way to go at this without directly subclassing Thing_A or Thing_B please let me know. I also found that __instancecheck__ but because I can't change Thing_A class or Thing_B class, I can't use it.Thanks,Jason
I'm not sure what you mean by this:I also found that __instancecheck__ is possible to use for the last two isinstance checks but not the first two.For the last two, you don't need to do anything. The default type.__instancecheck__ is already going to return True, because your objects really are Wrapper instances.For the first two, it certainly is possible. Obviously it depends on how you implement the __instancecheck__, but any option you pick will work here, as long as you make it look at something on the instance.Rather than hardcode something that looks at self.thing, let's write something more general: a protocol where any object can declare, dynamically, that it wants to be an instance of Thing_A or Thing_B by just adding it to some iterable called self._fakebases. So, isinstance(thing, Thing_B) will be true if Thing_B is in type(thing).__bases__ (the usual rule) or in thing._fakebases (the rule you want to add):Now, wrapper can support that protocol by setting _fake_bases:â€¦ or, maybe even better, use a property:Notice that Wrapper doesn't have to use the Fakey metaclass, because the default __instancecheck__ rules work fine with Wrapper as the class; it's Thing_A and Thing_B where you want different behavior.And here's that different behavior:
Do your best to look for other solutions. This kind of thing is prone to a lot of weird bugs, and it's going to be even more of an arcane mess to debug than it will be to write.That said, if you really want to give yourself this maintenance nightmare, then the way to do it is to lie about __class__:Ideone demo.This only handles isinstance; if you want to forward attribute lookup to self.thing, you'll need to implement a forwarding __getattr__ or __getattribute__, and if you want magic methods to work, you're going to have to separately define forwarding implementations of every magic method you want to forward to self.thing.


Answer URL
https://docs.python.org/3/reference/datamodel.html#class.__instancecheck__
