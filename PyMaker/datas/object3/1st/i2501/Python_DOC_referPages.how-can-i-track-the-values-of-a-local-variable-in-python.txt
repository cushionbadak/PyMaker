Natural Text
My algorithm loops over seconds of data. For each second-worth-of-data, I return a value, that is the result of a fairly involved computation involving multiple submodules and subclasses. Some of these classes are re-initialized each second.For debugging purposes, a few times I have been in the situation that I have wanted to plot the value of a certain local variable in one of these classes over time. Something external would have to serialize and log the values, because the class exists for only a second. It has been a different local variable each time. How can I do achieve my aim properly in terms of software design, without it taking me hours every time and without writing more than a line or two of new code each time I want to do this?Ideally, one solution I have considered would be to have something like a global IO stream, or something like that, that I would "just be around" without having to initialize each class with it, so I could just insert some sort of MySerializer << [mylocalvariable, timestamp] command at any point in the code, and then when the run finished I could check if MySerializer is empty and if not I could plot what  what is in it... or something like that. Better still if I could do this for multiple local variables in different classes. Would this solution be good? How could I do this?Or to be able to do this in an aspect-oriented way, with some outside object "looking at the code" without changing it, building a buffer of values of that local variable, and spitting them out to a plot in the end. How might I do this?Is there a better solution that either of these? Which design patterns suit this situation?What I have done is in the past is to return that local variable to whoever holds the function, who then in turn has to return that value it has received, and so on and so forth, all the way up to the top. This is a huge mess and has to be written and deleted each time.
I had in mind something really simple like this:In short, write a simple decorator that logs the result of your function somewhere (above I only write it out to the terminal, but this could be extended to use a log file or similar). Then you decorate whatever function you want to track and will get its return value whenever the function is called. In the code above I show what it does for a simple function and a class method. The result of the example code looks like this:EDIT 2:I edited the code below to use the actual function instead of just its __name__ to store the intermediate values. This should make it somewhat less error prone.EDIT:For storing values in memory, I would again go as simple as possible and just store the values in a list. For the simple example outlined above, possibly a global list object would be enough. However, as you most likely want to look at more than one function at a time, I'd rather suggest to design the decorator as a class and store one list per function in a class attribute. More about this in the example code.The real problem is the storing of local variables. In order to do this you have to change the actual code of your function. Naturally, you don't want to do this 'by hand', but want your decorator to take care of this. Here it becomes tricky. After looking around for a while, I found a package called bytecode (which works at least for Python 3.6). There are most likely other options, but I decided to go with this one. bytecode allows you to translate the python bytecode into human-readable form, modify it, and translate it back to python bytecode. I have to admit that I'm a bit out of my depth here, but what I did was to write a few small functions, look at the translated code and design a piece of code that does what I want.So, in this example the objective is to decorate the function to be tested, such that the decorator takes a list of strings as argument, where each string is the name of a variable that should be tracked. It then adds code to the function body that packs the final values of all listed variables in a tuple and returns the tuple together with the real return value. The 'wrapper' function then collects the tracked values and appends them to a function-specific list of values which can be read at any point in the code. So here it goes. Put the actual decorator in its own file, I call it here debug_function.py:Then, let's generate again some functions to be checked, which we decorate with this decorator. Put these, for instance, in functions.pyFinally, call the functions and look at the output. debug_function has a static method called get(), which takes the function you want information on as argument and returns a list of tuples. Each of these tuples contains the final values of all the local variables you wanted to track after one call to that function. The values are in the same order in which they were listed in the decorator statement. With an 'inverse' zip, you can easily separate these tuples.  The output of the calls looks like this:I probably should explain a bit better how this works, please ask if anything stayed unclear. As said before, this decorator only stores the final value of each variable (i.e. the value that variable has after the function code has been executed). If you have a more complex function, you may be interested what the value is at, e.g., each variable assignment -- in this case you'll have to do a bit more work, but it should be doable. Hope this helps


Answer URL
https://docs.python.org/3/howto/logging.html
