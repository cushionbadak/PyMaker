Natural Text
I'm using Python 2.7 and have the following:my_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]I'd like create a 1-d list where the elements are ordered by position in sublist and then order of sublist.  So the correct output for the above list is:[1, 4, 7, 2, 5, 8, 3, 6, 9]Here's my (incorrect) attempt:This flattens my 2-d list and gives me: The first half of this list is correct but the second isn't.I'd also like my function to be able to handle only 2 sublists.  For instance, if given:[[1, 2, 3], [], [7, 8, 9]the correct output is:[1, 7, 2, 8, 3, 9]Any thoughts?Thanks!
You're attempting to flatten, and then reorder, which makes things a lot harder than reordering and then flattening.First, for your initial problem, that's just "unzip", as explained in the docs for zip:(In Python 2.7, you could just write zip(…) here instead of list(zip(…)), but this way, the same demonstration works identically in both 2.x and 3.x.)And then, you already know how to flatten that:But things get a bit more complicated for your second case, where some of the lists may be empty (or maybe just shorter?).There's no function that's like zip but skips over missing values. You can write one pretty easily. But instead… there is a function that's like zip but fills in missing values with None (or anything else you prefer), izip_longest. So, we can just use that, then filter out the None values as we flatten:(In Python 3, the function izip_longest is renamed zip_longest.)It's worth noting that the roundrobin recipe, as covered by ShadowRanger's answer, is an even nicer solution to this problem, and even easier to use (just copy and paste it from the docs, or pip install more_itertools and use it from there). It is a bit harder to understand—but it's worth taking the time to understand it (and asking for help if you get stuck).
i.e.
The itertools module's recipes section provides a roundrobin recipe that would do exactly what you want. It produces a generator, but your expected behavior would be seen with:Your original code's main issue is that it looped over for i in range(len(my_list)):, extending with my_list[i::3]. Problem is, this ends up duplicating elements from index 3 onwards (index 3 was already selected as the second element of the index 0 slice). There are lots of other small logic errors here, so it's much easier to reuse a recipe.This will be fairly performant, and generalize better than most hand-rolled solutions (it will round robin correctly even if the sublists are of uneven length, and it doesn't require second pass filtering or special handling of any kind to allow None as a value like zip_longest does).
If you are happy to use a 3rd party library, you can use NumPy and np.ndarray.ravel:For the case where you have one or more empty lists, you can use filter to remove empty lists:Both solutions require non-empty sublists to contain the same number of items. If list conversion is necessary you can use, for example, res_a.tolist().While these "black box" methods won't teach you much, they will be faster for large arrays than list-based operations. See also What are the advantages of NumPy over regular Python lists?


Answer URL
https://docs.python.org/3/library/functions.html#zip
