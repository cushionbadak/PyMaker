Natural Text
I cannot figure out this behavior. I'm using Python 3.6.4.In here, I have 4 async functions. In test1, I call asyncio.ensure_future(TestAsync()) and turn the coroutine into a task. On the others (test2, test3, test4) I didn't call ensure_future(), I just created the coroutine and passed them into a list and then passed the list into the event loop.I left test1 out of the list I passed into the event loop. So I was under the impression test1 would not run, but in my output, it clearly did. Can someone explain to me why test1 still outputed when it wasn't inside the event loop?Output
As others pointed out, ensure_future will add the task to the default event loop, to run at the next opportunity. ensure_future converts an arbitrary awaitable into an asyncio.Future, which in case of a coroutine object is accomplished by wrapping it into a Task (a subclass of Future) with a call to create_task. The task will run the next time the event loop spins regardless of whether the code that calls ensure_future stores a reference to the returned future.The other important thing to notice is that run_until_complete(x) means "submit x to the event loop and run the loop until x completes", it does nothing to prevent tasks added before the call to run_until_complete from running.In Python 3.7, there is a new function asyncio.run that creates a new event loop and submits the given coroutine to it. Replacing asyncio.run_until_complete with asyncio.run would produce the behavior you expect.
From the docs for ensure_future:Schedule the execution of a coroutine objectWhen you call ensure_future, the coroutine is schedule and will be eligible to run whenever the event loop is running.
From the docs:Calling a coroutine does not start its code running – the coroutine object returned by the call doesn’t do anything until you schedule its execution. There are two basic ways to start it running: call await coroutine or yield from coroutine from another coroutine (assuming the other coroutine is already running!), or schedule its execution using the ensure_future() function or the AbstractEventLoop.create_task() method.As @dirn's answer implies, ensure_future by itself does not start the task unless there is an event loop already running. However, the subsequent loop kickoff with run_until_complete does start the task.


Answer URL
https://docs.python.org/3/library/asyncio-task.html#asyncio.ensure_future
https://docs.python.org/3/library/asyncio-task.html#asyncio.Future
https://docs.python.org/3/library/asyncio-task.html#asyncio.Task
https://docs.python.org/3/library/asyncio-task.html#asyncio.run
https://docs.python.org/3/library/asyncio-task.html#asyncio.ensure_future
