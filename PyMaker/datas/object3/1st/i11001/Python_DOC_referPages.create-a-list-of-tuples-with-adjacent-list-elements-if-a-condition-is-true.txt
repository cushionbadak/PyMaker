Natural Text
I am trying to create a list of tuples where the tuple contents are the number 9 and the number before it in the list.  Input List:Desired Output:Code:Current Result:
Cleaner Pythonic approach:What is the code above doing:zip(some_list, some_list[1:]) would generate a list of pairs of adjacent elements.Now with that tuple, filter on the condition that the second element is equal to 9. You're done :)
Part of your issue is that myList[i:i] will always return an empty list. The end of a slice is exclusive, so when you do a_list[0:0] you're trying to take the elements of a_list that exist between index 0 and index 0.You're on the right track, but you want to zip the list with itself.
You were pretty close, I'll show you an alternative way that might be more intuitive if you're just starting out:Get the index in the range of the list lenght, and if the value at the position i is equal to 9, grab the adjacent elements.The result is:This is less efficient than the other approaches but I decided to un-delete it to show you a different way of doing it. You can make it go a bit faster by using enumerate() instead:Take note that in the edge case where myList[0] = 9 the behavior of the comprehension without zip and the behavior of the comprehension with zip is different.Specifically, if myList = [9, 1, 8, 9, 2, 4, 9, 6, 7, 9, 8] then:while:It is up to you to decide which of these fits your criteria, I'm just pointing out that they don't behave the same in all cases.
You can also do it without slicing by creating iterators:Or use the pairwise recipe to create your pairsIf using python3, just import tee and use the regular zip.
It is really surprising that no one has added a functional approach. Another alternative answer is using a filter. This builtin function returns an iterator (list in Python2) consisting of all the elements present in the list that return True for a particular function It is to be noted that the list call is needed only in python3+. The difference between the functional approach and list comprehensions is discussed in detail in this post. 
My solution is similar to one of Jim's advanced with zero-index check


Answer URL
https://docs.python.org/3/library/functions.html#filter
