Natural Text
Consider this list:How can I identify those dates that are out of sequence. I don't care if they repeat, or skip, I just need the ones way out of line. Ie, I should get back:Namex is less obvious, but it's not in the general order of the list.My simplistic start (which I have deleted to simplify the question) is obviously woefully incomplete.Update: Based on the comments, it seems an implementation of the Longest Increase Subsequence (LIS) will get me started, a python implementation found here: https://stackoverflow.com/a/9832414/1061836How to determine the longest increasing subsequence using dynamic programming?https://rosettacode.org/wiki/Longest_increasing_subsequence#Pythonhttps://codereview.stackexchange.com/questions/10230/python-implementation-of-the-longest-increasing-subsequenceSeems once I get the LIS, I can compare it to the original list and see where the gaps are... Fascinating. SO is the hive-mind of awesomeness.
Short answer, general solutionUsing my answer to the "Longest increasing subsequence" question, this could be implemented simply as:Longer answer, specific solutionBased on the question at Code Review and a question about non-decreasing sequences (since that's what you're after), here's a solution to your problem:Outputs:The key parameter (inspired by sorted builtin) specifies a function of one argument that is used to extract a comparison key from each list element. The default value is None so the caller has a convenient way of saying "I want to compare the elements directly". If it is set to None we use lambda x: x as an identity function, so the elements are not changed in any way before the comparison.In your case, you want to use the dates as keys for comparison, so we use itemgetter(0) as key. And itemgetter(1) would use the names as key, see:Using itemgetter(k) is equivalent to lambda x: x[k]:Using it with map is equivalent to a generator expression:But if we used a similar list comprehension to pass the sequence to out_of_sequence we would get a different result from expected:Likewise, if we compare the date-name pairs directly we get wrong results (because 'nameg' compares greater to 'name5'):Because we want to return dates and names, and we want to order by dates only, we need to pass a function that extracts dates using the key parameter.An alternative would be to get rid of key and just write:But since this is stackoverflow, maybe one day another person will come by this answer and will need some other key extraction, therefore I decided to post the more general solution here.
This will establish a new anchor_date for you if the current date is greater than the last good date.  


Answer URL
https://docs.python.org/3/library/operator.html#operator.itemgetter
