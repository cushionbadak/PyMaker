Natural Text
In Perl I can do:And it will work whether or not the string contains the pattern.In Python, however this won't work:What's the canonical way to prevent errors in such cases?
If you're splitting into just two parts (like in your example) you can use str.partition() to get a guaranteed argument unpacking size of 3: str.partition() always returns a 3-tuple, whether the separator is found or not.Another alternative for Python 3.x is to use extended iterable unpacking:This assigns the first split item to a and the list of remaining items (if any) to b.
Since you are on Python 3, it is easy.  PEP 3132 introduced a welcome simplification of the syntax when assigning to tuples - Extended iterable unpacking.  In the past, if assigning to variables in a tuple, the number of items on the left of the assignment must be exactly equal to that on the right.  In Python 3 we can designate any variable on the left as a list by prefixing with an asterisk *.  That will grab as many values as it can, while still populating the variables to its right (so it need not be the rightmost item).  This avoids many nasty slices when we don't know the length of a tuple.Gives:EDIT following comments and discussion:In comparison to the Perl version, this is considerably different, but it is the Python (3) way.  In comparison with the Perl version, re.split() would be more similar, however invoking the RE engine for splitting around a single character is an unnecessary overhead.With multiple elements in Python:gives:However in Perl:gives:It can be seen that additional elements are ignored, or lost, in Perl.  That is fairly easy to replicate in Python if required:So, a, *b = s.split(":") equivalent in Perl would be NB:  we shouldn't use $a and $b in general Perl since they have a special meaning when used with sort.  I have used them here for consistency with the Python example.Python does have an extra trick up its sleeve, we can unpack to any element in the tuple on the left:Gives:Whereas in the Perl equivalent, the array (@b) is greedy, and the scalar $c is undef:Gives:
You are always free to catch the exception.For example:If assigning the whole original string to a and an empty string to b is the desired behaviour, I would probably use str.partition() as eugene y suggests. However, this solution gives you more control over exactly what happens when there is no separator in the string, which might be useful in some cases.
split will always return a list. a, b = ... will always expect list length to be two. You can use something like l = string.split(':'); a = l[0]; .... Here is a one liner: a, b = (string.split(':') + [None]*2)[:2]
How about using Regular Expressions:in 3.X:in 2.X:This way you can also use regular expressions to split(i. e. \d)


Answer URL
https://docs.python.org/3/library/stdtypes.html#str.partition
