Natural Text
I'd like to create an Python class that superficially appears to be a subclass of another class, but doesn't actually inherit its attributes.For instance, if my class is named B, I'd like isinstance(B(), A) to return True, as well as issubclass(B, A), but I don't want B to have the attributes defined for A. Is this possible?Note: I don't control the implementation of A.Why I care: The module I'm working with checks that a passed object is a subclass of A. I want to define the necessary attributes in B without inheriting the superfluous attributes defined in A (whose implementation I do not control) because I'm using __getattr__ to pass some attribute calls onto a wrapped class, and if these attributes are defined by inheritance from A, __getattr__ won't be called.
In Python3, override the special method __getattribute__.  This gives you almost complete control over attribute lookups.  There are a few corner cases so check the docs carefully (it's section 3.3.2 of the Language Reference Manual).
Use abstract base classes to make a semingly unrelated class B a subclass of A without inheriting from it:Then used, it gives the desired results and appears as a subtype without actually having any of the base type’s members:I'm using __getattr__ to pass some attribute calls onto a wrapped class, and if these attributes are defined by inheritance from A, __getattr__ won't be called.__getattr__ is not invoked for members which are found using the normal attribute resolution. You can use __getattribute__ then instead.However, if what you are doing is overwriting the behavior of the base class A, then I don’t see why simply overwriting the methods is not an option:
You could implement __getattribute__ to raise AttributeErrors for the attributes that are not in B:I'm curious, why would you do this?
I hope this satisfies you (I think it's a bit dirty hack):Now let's test it:Unfortunately class B itself inherited attributes so this happens:I hope it doesn't matters, if it does you need to use metaclasses (which can get quite nasty).
As long as you're defining attributes in the __init__ method and you override that method, B will not run the code from A's __init__ and will thus not define attributes et al. Removing methods would be harder, but seem beyond the scope of the question.


Answer URL
https://docs.python.org/3/library/abc.html
