Natural Text
I would like to stop a Python thread when the main program stops. It is for a class that connects to a server. The connection is maintained by the background thread, the foreground thread answers to callbacks. The following is a minimal example. When the program ends, I would naively expect __del__() to be called so that the background thread can be informed to stop, but i is not called untill after the background thread stops. Explicitly calling some function is not an option since the class is used by other people, whom I do not want to force to use some extra lines of code.
__del__ is not called as long as there are references to self, and you have one such reference in the background thread itself: in the self argument of def startThread(self):.You need to move the function that runs the background thread outside of the class.  And rather than a __del__ I would recommend for example using a weakref, as follows.  This code should work without the __del__() method and without using a self.running attribute.
I was facing the same problem and finally found the answer to this question in the answer to another question.Use the daemon = True flag. Documentation for 3.x and 2.xSo your code would be this:Remark: this is propably not cleanly ending your thread, but it stops it when you exit your program, I guess this is what you were looking for.
As per gnibbler's comment, it may be better to use a context manager for explicit resource deallocation.  Opinions appear to vary on whether __del__ should be used for resource deallocation.  A couple of good posts on the subject are here and here.If you're used to a language like C++ where RAII is used, it's sometimes a bit difficult to get accustomed to the idea that destructors in Python may not be called when you expect, if at all, usually because of how reference counting and garbage collection works.So, the usual approach in Python is to use a context manager which can be used to provide explicit deallocation of resource.A simple threading example might look like this (untested):The test() class is then used like this in a context manager:or, use the Python contextlib.closing helper function which will ensure that close is called on exit.
You forgot to change the "running" variable of your current test() instance, in your del function. It should beThat should do the trick.


Answer URL
https://docs.python.org/3/library/threading.html#threading.Thread.daemon
