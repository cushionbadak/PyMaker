Natural Text
Please, how can I get all these binary permutations, but without repetition in Python?It would be great if it would be roughly efficient since I'll have to do that with a list of even 30 elements like this.
As @Antti said in a comment, this is equivalent to looking for combinations of positions of the input list which determine which bits in the output are 1.Output:
Here's the algorithm from the accepted answer to the generic algorithm question, adapted into Python 3 (should work in Python 2.7+). The function generate(start, n_bits) will generate all n-bit integers starting from start lexicographically.PrintsIf list output is generated, this can then be decorated:printsWhat is nice about this algorithm is that you can resume it at any point. If you find a way to calculate good starting points, it is possible to parallelize too. And the numbers should be more compact than lists, so you could use them if possible.
What you are trying to do is choose two positions at which the element will be 1.CodeOutputAlternativeA fun alternative is to see the desired output as the binary representations which have only two ones. We can use this definition to get the output you want.
Here is a recursive solution:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.permutations
