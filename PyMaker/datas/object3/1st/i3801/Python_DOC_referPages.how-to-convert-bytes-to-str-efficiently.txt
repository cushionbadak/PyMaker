Natural Text
I'm using this code to get standard output from an external program:The communicate() method returns an array of bytes:However, I'd like to work with the output as a normal Python string. So that I could print it like this:I thought that's what the binascii.b2a_qp() method is for, but when I tried it, I got the same byte array again:Does anybody know how to convert the bytes value back to string? I mean, using the "batteries" instead of doing it manually. And I'd like it to be ok with Python 3.
You need to decode the bytes object to produce a string:
I think this way is easy:
You need to decode the byte string and turn it in to a character (unicode) string. or on Python 3
If you don't know the encoding, then to read binary input into string in Python 3 and Python 2 compatible way, use ancient MS-DOS cp437 encoding:Because encoding is unknown, expect non-English symbols to translate to characters of cp437 (English chars are not translated, because they match in most single byte encodings and UTF-8).Decoding arbitrary binary input to UTF-8 is unsafe, because you may get this:The same applies to latin-1, which was popular (default?) for Python 2. See the missing points in Codepage Layout - it is where Python chokes with infamous ordinal not in range.UPDATE 20150604: There are rumors that Python 3 has surrogateescape error strategy for encoding stuff into binary data without data loss and crashes, but it needs conversion tests [binary] -> [str] -> [binary] to validate both performance and reliability.UPDATE 20170116: Thanks to comment by Nearoo - there is also a possibility to slash escape all unknown bytes with backslashreplace error handler. That works only for Python 3, so even with this workaround you will still get inconsistent output from different Python versions:See https://docs.python.org/3/howto/unicode.html#python-s-unicode-support for details.UPDATE 20170119: I decided to implement slash escaping decode that works for both Python 2 and Python 3. It should be slower that cp437 solution, but it should produce identical results on every Python version.
In Python 3, the default encoding is "utf-8", so you can use directly:which is equivalent toOn the other hand, in Python 2, encoding defaults to the default string encoding. Thus, you should use:where encoding is the encoding you want.Note: support for keyword arguments was added in Python 2.7.
I think what you actually want is this:Aaron's answer was correct, except that you need to know WHICH encoding to use. And I believe that Windows uses 'windows-1252'. It will only matter if you have some unusual (non-ascii) characters in your content, but then it will make a difference.By the way, the fact that it DOES matter is the reason that Python moved to using two different types for binary and text data: it can't convert magically between them because it doesn't know the encoding unless you tell it! The only way YOU would know is to read the Windows documentation (or read it here).
Set universal_newlines to True, i.e.
While @Aaron Maenpaa's answer just works, a user recently askedIs there any more simply way? 'fhand.read().decode("ASCII")' [...] It's so long!You can usedecode() has a standard argumentcodecs.decode(obj, encoding='utf-8', errors='strict')
To interpret a byte sequence as a text, you have to know thecorresponding character encoding:Example:ls command may produce output that can't be interpreted as text. File nameson Unix may be any sequence of bytes except slash b'/' and zerob'\0':Trying to decode such byte soup using utf-8 encoding raises UnicodeDecodeError.It can be worse. The decoding may fail silently and produce mojibakeif you use a wrong incompatible encoding:The data is corrupted but your program remains unaware that a failurehas occurred.In general, what character encoding to use is not embedded in the byte sequence itself. You have to communicate this info out-of-band. Some outcomes are more likely than others and therefore chardet module exists that can guess the character encoding. A single Python script may use multiple character encodings in different places.ls output can be converted to a Python string using os.fsdecode()function that succeeds even for undecodablefilenames (it usessys.getfilesystemencoding() and surrogateescape error handler onUnix):To get the original bytes, you could use os.fsencode().If you pass universal_newlines=True parameter then subprocess useslocale.getpreferredencoding(False) to decode bytes e.g., it can becp1252 on Windows.To decode the byte stream on-the-fly,io.TextIOWrapper()could be used: example.Different commands may use different character encodings for theiroutput e.g., dir internal command (cmd) may use cp437. To decode itsoutput, you could pass the encoding explicitly (Python 3.6+):The filenames may differ from os.listdir() (which uses WindowsUnicode API) e.g., '\xb6' can be substituted with '\x14'—Python'scp437 codec maps b'\x14' to control character U+0014 instead ofU+00B6 (¶). To support filenames with arbitrary Unicode characters, see  Decode poweshell output possibly containing non-ascii unicode characters into a python string
Since this question is actually asking about subprocess output, you have a more direct approach available since Popen accepts an encoding keyword (in Python 3.6+):The general answer for other users is to decode bytes to text:With no argument, sys.getdefaultencoding() will be used.  If your data is not sys.getdefaultencoding(), then you must specify the encoding explicitly in the decode call:
If you should get the following by trying decode():AttributeError: 'str' object has no attribute 'decode'You can also specify the encoding type straight in a cast:
I made a function to clean a list
When working with data from Windows systems (with \r\n line endings), my answer isWhy? Try this with a multiline Input.txt:All your line endings will be doubled (to \r\r\n), leading to extra empty lines. Python's text-read functions usually normalize line endings so that strings use only \n. If you receive binary data from a Windows system, Python does not have a chance to do that. Thus,will replicate your original file.
For Python 3,this is a much safer and Pythonic approach to convert from byte to string:Output:

From http://docs.python.org/3/library/sys.html,To write or read binary data from/to the standard streams, use the underlying binary buffer. For example, to write bytes to stdout, use sys.stdout.buffer.write(b'abc').


Answer URL
https://docs.python.org/3/howto/unicode.html#python-s-unicode-support
https://docs.python.org/3/library/stdtypes.html#bytes.decode
https://docs.python.org/3/library/stdtypes.html#bytes-and-bytearray-operations
https://docs.python.org/3/library/io.html#io.TextIOWrapper
https://docs.python.org/3/library/subprocess.html#frequently-used-arguments
https://docs.python.org/3/library/sys.html#sys.getdefaultencoding
https://docs.python.org/3/library/stdtypes.html#bytes.decode
https://docs.python.org/3/howto/unicode.html#python-s-unicode-support
https://docs.python.org/3/whatsnew/3.7.html#subprocess
https://docs.python.org/3/library/subprocess.html#subprocess.Popen
