Natural Text
I am attempting to create a basic module that adds the execfile function from Python 2.* to Python3 (using the function execf(a)). The module takes advantage of imports to run a .py file using something like this:I take advantage of this by using the exec function in multiple instances to read the filename and insert it into those functions and strings.Here is what the module (called execfile) looks like:And the fibonacci.py file:Now, this is the main.py file (the executed file):What I want to happen is that the a variable from the fibonacci.py be usable in the main.py file so I can print it, and this should be usable for all variables in the script. However, I want to do all of this in the execf() function and not use Pickle or any other module like that, because my goal is to not have to add anything to the Fibonacci project.I thought about adding something in a comment that could be scanned for and would detect the variables that need to be added. Something like:But I could not find anything on how to make Python "look" for those variables. Please let me know if you have any questions, thanks!
What you've done is not at all the same thing as execfile. So, it shouldn't be that surprising that it doesn't have the same effect as execfile.exec (and execfile) executes some code directly in the current scope.import checks whether the module has already been loaded, executing its code in a brand new scope if not, and then gives you a variable holding that module object in the current scope.For example, let's say we had a file named mod.py that looks like this:Now, let's import it:Compare what happens when you execfile it:On top of that, your execf doesn't even work, for multiple reasons:a.replace(".py", "") doesn't mutate a, it just returns a new string that you ignore.Your fibonacci.py module doesn't have a function named main.You can't "proceed to rest of code after a sys.exit", because sys.exit exits the program. You can handle this with except SystemExit:, but you shouldn't. At any rate, you definitely can't handle it with except AttributeError:; that will only fire because of, e.g., the fact that the module exists but doesn't have a .main attribute.At any rate, as What's New in Python 3.0 explains, the right way to do execfile in Python 3 is to open the file, read its contents, and exec them. In other words:If you want to wrap this in a function, notice that it will execute the code inside that function's local environment. If you want to execute it in globals no matter what, or in the environment of its caller, or anything else, you need to specify that. See the exec docs for details, but for a simple example:As a side note, in the rare case where you really do need to do an import dynamically, you should not exec an import statement, you should use importlib.import_module:


Answer URL
https://docs.python.org/3/library/functions.html#exec
https://docs.python.org/3/library/importlib.html#importlib.import_module
