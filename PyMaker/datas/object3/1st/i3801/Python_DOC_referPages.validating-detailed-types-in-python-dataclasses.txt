Natural Text
Python 3.7 is around the corner, and I wanted to test some of the fancy new dataclass+typing features. Getting hints to work right is easy enough, with both native types and those from the typing module:But one other thing that I wanted to try was forcing the type hints as conditions during runtime, i.e. it should not be possible for a dataclass with incorrect types to exist. It can be implemented nicely with __post_init__:This kind of validate function works for native types and custom classes, but not those specified by the typing module:Is there a better approach to validate an untyped list with a typing-typed one? Preferably one that doesn't include checking the types of all elements in any list, dict, tuple, or set that is a dataclass' attribute.
Instead of checking for type equality, you should use isinstance. But you cannot use a parametrized generic type (typing.List[int]) to do so, you must use the "generic" version (typing.List). So you will be able to check for the container type but not the contained types. Parametrized generic types define an __origin__ attribute that you can use for that.Contrary to Python 3.6, in Python 3.7 most type hints have a useful __origin__ attribute. Compare:andNotable exceptions being typing.Any, typing.Union and typing.ClassVarâ€¦ Well, anything that is a typing._SpecialForm does not define __origin__. Fortunately:But parametrized types define an __args__ attribute that store their parameters as a tuple:So we can improve type checking a bit:This is not perfect as it won't account for typing.ClassVar[typing.Union[int, str]] or typing.Optional[typing.List[int]] for instance, but it should get things started.Next is the way to apply this check.Instead of using __post_init__, I would go the decorator route: this could be used on anything with type hints, not only dataclasses:Usage being:Appart from validating some type hints as suggested in the previous section, this approach still have some drawbacks:type hints using strings (class Foo: def __init__(self: 'Foo'): pass) are not taken into account by inspect.getfullargspec: you may want to use typing.get_type_hints and inspect.signature instead;a default value which is not the appropriate type is not validated:does not raise any TypeError. You may want to use inspect.Signature.bind in conjuction with inspect.BoundArguments.apply_defaults if you want to account for that (and thus forcing you to define def foo(bar: typing.Optional[int] = None));variable number of arguments can't be validated as you would have to define something like def foo(*args: typing.Sequence, **kwargs: typing.Mapping) and, as said at the beginning, we can only validate containers and not contained objects.Thanks to @Aran-Fey that helped me improve this answer.


Answer URL
https://docs.python.org/3/library/typing.html#typing.get_type_hints
https://docs.python.org/3/library/inspect.html#inspect.signature
https://docs.python.org/3/library/inspect.html#inspect.Signature.bind
https://docs.python.org/3/library/inspect.html#inspect.BoundArguments.apply_defaults
