Natural Text
I have a difficulty implementing properties and __getattr__ so thatwhen an error happens, it is reported correctly. This is my MWE (python 3.6):The output is as follows:But the error that should be raised is:I know that properties and attributes in the __dict__ are attempted before __getattr__ is called in an error-free scenario.It seems incorrect to me that when a property exists but fails, __getattr__ is still attempted instead of letting the error from the property to go through. How can this be avoided?The initial error message that was generated about failing to get attribute 'foo' has been lost. The final error message 'A' object has no attribute 'G' is particularly misleading and annoying. How to implement __getattr__ in order to see the initial error?(EDIT) A related problem is simultaneously to achieve thathasattr(a, 'moo') returns False while hasattr(a, 'G') returns True or raises an exception of the missing 'moo' attribute. Does that make sense?
What is happening?First, a little heads up as to why this happens. From the doc on __getattr__:Called when the default attribute access fails with an AttributeError [...] or __get__() of a name property raises AttributeError.In this case, since you are using @property, we are looking at an AttributeError raised from the __get__ method of the property F when trying to recover self.moo. This is what your call stack looks like at that moment.The attribute getter protocol sees an error being raised from inside a.F.__get__, it thus fallback on calling a.__getattr__('F') and that despite the fact the error had been raised because of 'moo'. The same then happens for a.G.__get__This behaviour is considered normal in Python, since the top-most property that failed to return a value is indeed a.G.SolutionNow what you want is for an AttributeError raised by a __get__ method to bubble up instead of being caught. To do that you need not to have a __getattr__ method.Thus, in this particular case, what you want to use is __getattribute__ instead.Of course, with this solution you have to make sure yourself not to override an existing attribute.ExampleOutput
Here's a hacky solution, replacing the AttributeError with another exception type:This results in the following output:As an addendum, to make it explicit why Python does what it does, here's an excerpt from the documentation:[__getattr__ is called] when the default attribute access fails with an AttributeError (either __getattribute__() raises an AttributeError because name is not an instance attribute or an attribute in the class tree for self; or __get__() of a name property raises AttributeError). This method should either return the (computed) attribute value or raise an AttributeError exception.(It looks like you know this but I think it's good to have it written out for other people running into the same issue.)So that means when self.moo raises an AttributeError, it results in A.__getattr__(a, 'F') being called, which results into another AttributeError
Given the answers above, I have tried the following solution for the case when __getattr__ is already defined by the base class P that we cannot change.It replicates what python does when looking for attributes: the order of calls and semantics are kept. It only changes the final error message toAttributeError: 'A' object has no attribute 'moo' -> Cannot recover attribute 'moo' -> Cannot recover attribute 'F' -> Cannot recover attribute 'G'However, it might be causing more problems in the derived code than it is solving, so I don't know.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__getattr__
https://docs.python.org/3/reference/datamodel.html#object.__getattribute__
https://docs.python.org/3/reference/datamodel.html#object.__getattr__
