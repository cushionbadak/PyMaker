Natural Text
When embedding Python in my application, and writing an extension type, I can add a signature to the method by using a properly crafted .tp_doc string.When help(Answer) is executed, the following is returned (abbreviated):This is good, but I'm using Python3.6, which has support for annotations.  I'd like to annotate question to be a string, and the function to return an int.  I've tried:but this reverts to the (...) notation, and the documentation becomes:and asking for inspect.signature(Answer.ultimate) results in an exception.I've tried to add the annotations after the fact with Python code:But the builtin method descriptors can't have annotations added this way.Is there a way to add annotations to extension methods, using the C-API?Argument Clinic looked promising and may still be very useful, but as of 3.6.5, it doesn't support annotations.annotation  The annotation value for this parameter. Not currently supported, because PEP 8 mandates that the Python library may not use annotations.
TL;DR There is currently no way to do this.How do signatures and C extensions work together?In theory it works like this (for Python C extension objects):If the C function has the "correct docstring" the signature is stored in the __text_signature__ attribute.If you call help or inspect.signature on such an object it parses the __text_signature__ and tries to construct a signature from that.If you use the argument clinic you don't need to write the "correct docstring" yourself. The signature line is generated based on comments in the code. However the 2 steps mentioned before still happen. They just happen to the automatically generated signature line.That's why built-in Python functions like sum have a __text-signature__s:The signature in this case is generated through the argument clinic based on the comments around the sum implementation.What are the problems with annotations?There are several problems with annotations:Return annotations break the contract of a "correct docstring". So the __text_signature__ will be empty when you add a return annotation. That's a major problem because a workaround would necessarily involve re-writing the part of the CPython C code that is responsible for the docstring -> __text_signature__ translation! That's not only complicated but you would also have to provide the changed CPython version so that it works for the people using your functions.Just as example, if you use this "signature":You get:But if you remove the return annotation:It gives you a __text_signature__:If you don't have the return annotation it still won't work because annotations are explicitly not supported (currently).Assuming you have this signature:It doesn't work with inspect.signature (the exception message actually says it all):The function that is responsible for the parsing of __text_signature__ is inspect._signature_fromstr. In theory it could be possible that you maybe could make it work by monkey-patching it (return annotations still wouldn't work!). But maybe not, there are several places that make assumptions about the __text_signature__ that may not work with annotations.Would PyFunction_SetAnnotations work?In the comments this C API function was mentioned. However that deliberately doesn't work with C extension functions. If you try to call it on a C extension function it will raise a SystemError: bad argument to internal function call. I tested this with a small Cython Jupyter "script":So that also doesn't work with C extension functions.SummarySo return annotations are completely out of the question currently (at least without distributing your own CPython with the program). Parameter annotations could work if you monkey-patch a private function in the inspect module. It's a Python module so it could be feasible, but I haven't made a proof-of-concept so treat this as a maybe possible, but probably very complicated and almost certainly not worth the trouble.However you can always just wrap the C extension function with a Python function (just a very thing wrapper). This Python wrapper can have function annotations. It's more maintenance and a tiny bit slower but saves you all the hassle with signatures and C extensions. I'm not exactly sure but if you use Cython to wrap your C or C++ code it might even have some automated tooling (writing the Python wrappers automatically).


Answer URL
https://docs.python.org/3/howto/clinic.html#using-real-argument-clinic-converters-instead-of-legacy-converters
https://docs.python.org/3/howto/clinic.html
