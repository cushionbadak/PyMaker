Natural Text
Are there any sources or guidelines for safe, bug-free numerical programming with numpy?I'm asking because I've painfully learned that numpy does many things that seem to really ask for bugs to happen, such as...Adding matrices of different sizes ("broadcasting") without complaining:Returning different data types depending on the input:Or simply not performing a desired operation (again, depending on the data type) without raising any warnings:These are all very hard to discover bugs, since they do not raise any exceptions or warnings and often return results of the valid data types / shapes. Therefore my question: Are there any general guidelines for improving the safety and preventing bugs in mathematical programming with numpy?[Note that I don't believe that this answer will attract "opinionated answers and discussions" since it is not about personal recommendations, but rather asking whether there are any existing guidelines or sources on the subject at all - of which I could not find any.]
Frequently I ask SO questioners, what's the shape? the dtype? even the type.  Keeping tracking of those properties is a big part of good numpy programming.  Even in MATLAB I found that getting the size right was 80% of debugging.typeThe squeeze example revolves around type, the ndarray class versus the np.matrix subclass:np.matrix object is, by definition, always 2d.  That's the core of how it redefines ndarray operations.Many numpy functions delegate their work to methods.  The code fornp.squeeze` is:So In [161] is really:np.matrix.squeeze has its own documentation.As a general rule we discourage the use of np.matrix.  It was a created years ago to make things easier for wayward MATLAB programmers.  Back in those days MATLAB only had 2d matrices (even now MATLAB 'scalars' are 2d).dtypenp.array is a powerful function.  Usually its behavior is intuitive, but sometimes it makes too many assumptions.  Usually it takes clues from the input, whether integer, float, string, and/or lists:But it provides a number of parameters.  Use those if you need more control:Look at it's docs, and also at the https://docs.scipy.org/doc/numpy/reference/routines.array-creation.html page which lists many other array creation functions.  Look at some their code as well.For example np.atleast_2d does a lot of shape checking:Functions like this are good examples of defensive programming.We get a lot SO questions about 1d arrays with dtype=object.  np.array tries to create a multidimensional array with a uniform dtype.  But if the elements differ in size or can't be cast to the same dtype, it will fall back on object dtype.  This is one of those situations where we need to pay attention to shape and dtype.broadcastingBroadcasting has been a part of numpy forever, and there's no way of turning it off.  Octave and MATLAB have added it later, and do enable warning switches.The first defensive step is to understand the broadcasting principles, namelyit can expand the beginning dimensions to matchit coerce unitary dimensions to match.So a basic example is:The first term is (3,) expanded to (3,1).  The second is (4,) which, by broadcasting expands to (1,4).  Together (3,1) and (1,4) broadcast to (3,4).Many numpy functions have parameters that make keeping track of dimensions easier.  For example sum (and others) has a keepdims parameter:In this case the keepdims isn't essential since (3,4)/(4,) works.  But with axis=1 sum the shape becomes (3,) which can't broadcast with (3,4).  But (3,1) can:To manage shapes I like to:display shape while debuggingtest snippets interactivelytest with diagnostic shapes, e.g. np.arange(24).reshape(2,3,4)assertion statements in functions can be useful assert(arr.ndim==1)typingRecent Python 3 versions have added a typing modulehttps://docs.python.org/3/library/typing.htmlEven for built-in Python types it's provisional.  I'm not sure much has been added for numpy.  
In some ways, an answer to this question is no different than general guidelines for safe programming:Check and sanitise code early, for every functionMaintain relevant unit tests.Yes, this may sound like extra overhead, but the reality is you're probably already doing such checks and tests by hand anyway, so it's good practice to put it down on paper and formalise / automate the process. E.g., while you may have never expected a matrix output specifically, any unit test that checked your output is the expected array would have failed reliably. You might also want to have a look at specialised testing tools that are specific to scientific code, e.g. the Hypothesis packageOne thing that is specific to numpy is the handling of Floating Errors; the default simply 'prints' a warning statement to stdout, which can be missed easily (and does not cater for proper exception handling workflows). You can convert this functionality to throw proper warnings / exceptions that you can capture, via the numpy.seterr method -- e.g. numpy.seterr(all='raise').
If you want to use numpy in a "safer" way, you'll probably have to create your own safety net. One way to do so would be to define wrappers that enforce the rules you want your code to obey. You can come up with your own wrappers and tests as you go along and/or stumble upon behaviour that you consider problematic.Some toy examples:Always have float arrays:Disable broadcasting:Warn when using np.matrix:


Answer URL
https://docs.python.org/3/library/typing.html
