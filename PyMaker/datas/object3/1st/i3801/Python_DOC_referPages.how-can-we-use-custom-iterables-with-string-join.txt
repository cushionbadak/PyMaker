Natural Text
How would one create an iterative function (or iterator object) in python?
Iterator objects in python conform to the iterator protocol, which basically means they provide two methods: __iter__()  and  next().  The __iter__ returns the iterator object and is implicitly called at the start of loops.  The next() method returns the next value and is implicitly called at each loop increment.  next() raises a StopIteration exception when there are no more value to return, which is implicitly captured by looping constructs to stop iterating.Here's a simple example of a counter:This will print:This is easier to write using a generator, as covered in a previous answer:The printed output will be the same.  Under the hood, the generator object supports the iterator protocol and does something roughly similar to the class Counter.David Mertz's article, Iterators and Simple Generators, is a pretty good introduction. 
There are four ways to build an iterative function:create a generator (uses the yield keyword)use a generator expression (genexp)create an iterator (defines __iter__ and __next__ (or next in Python 2.x))create a class that Python can iterate over on its own (defines __getitem__)Examples:To see all four methods in action:Which results in:Note:The two generator types (uc_gen and uc_genexp) cannot be reversed(); the plain iterator (uc_iter) would need the __reversed__ magic method (which must return a new iterator that goes backwards); and the getitem iteratable (uc_getitem) must have the __len__ magic method:To answer Colonel Panic's secondary question about an infinite lazily evaluated iterator, here are those examples, using each of the four methods above:Which results in (at least for my sample run):
First of all the itertools module is incredibly useful for all sorts of cases in which an iterator would be useful, but here is all you need to create an iterator in python:yieldIsn't that cool?  Yield can be used to replace a normal return in a function.  It returns the object just the same, but instead of destroying state and exiting, it saves state for when you want to execute the next iteration.  Here is an example of it in action pulled directly from the itertools function list:As stated in the functions description (it's the count() function from the itertools module...) , it produces an iterator that returns consecutive integers starting with n.Generator expressions are a whole other can of worms (awesome worms!).  They may be used in place of a List Comprehension to save memory (list comprehensions create a list in memory that is destroyed after use if not assigned to a variable, but generator expressions can create a Generator Object... which is a fancy way of saying Iterator). Here is an example of a generator expression definition:This is very similar to our iterator definition above except the full range is predetermined to be between 0 and 10.I just found xrange() (suprised I hadn't seen it before...) and added it to the above example.  xrange() is an iterable version of range() which has the advantage of not prebuilding the list.  It would be  very useful if you had a giant corpus of data to iterate over and only had so much memory to do it in.
I see some of you doing return self in __iter__. I just wanted to note that __iter__ itself can be a generator (thus removing the need for __next__ and raising StopIteration exceptions)Of course here one might as well directly make a generator, but for more complex classes it can be useful.
This question is about iterable objects, not about iterators. In Python, sequences are iterable too so one way to make an iterable class is to  make it behave like a sequence, i.e. give it __getitem__ and __len__ methods. I have tested this on Python 2 and 3.
This is an iterable function without yield. It make use of the iter function and a closure which keeps it's state in a mutable (list) in the enclosing scope for python 2.  For Python 3, closure state is kept in an immutable in the enclosing scope and nonlocal is used in local scope to update the state variable.  Test;
All answers on this page are really great for a complex object. But for those containing builtin iterable types as attributes, like str, list, set or dict, or any implementation of collections.Iterable, you can omit certain things in your class.It can  be used like:
If you looking for something short and simple, maybe it will be enough for you:example of usage:
Inspired by Matt Gregory's answer here is a bit more complicated iterator that will return a,b,...,z,aa,ab,...,zz,aaa,aab,...,zzy,zzz


Answer URL
https://docs.python.org/3/library/itertools.html
