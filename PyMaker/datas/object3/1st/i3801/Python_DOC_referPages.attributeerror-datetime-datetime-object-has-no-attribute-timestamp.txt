Natural Text
Please Help - I keep receiving the following Traceback Error:Currently Running Python 2.0 I'm attempting to utilize Python's Plotly library to display an infographic illustrating bitcoin prices. I've tried importing datetime at the top of my code but this doesn't appear to solve the problem. My Code Starts Here
The timestamp method was added in Python 3.3. So if you're using Python 2.0, or even 2.7, you don't have it. There are backports of current datetime to older Python versions on PyPI, but none of them seems to be official, or up-to-date; you might want to try searching for yourself.There are also a number of third-party replacement libraries that add functionality that isn't in (2.x) datetime, including the ability to convert to Unix timestamps.You can just copy the function out of the source code from 3.3 or later:… but you will have to modify things a bit to get them to work, because:_EPOCH is deleted at the end of the module.The 3.x _EPOCH is a tz-aware object built with a proper UTC timezone, which you don't have in 2.x unless you're using a third-party library like pytz.The _mktime method and _tzinfo attribute don't exist on 2.x datetime, so you need to simulate what they do as well.If you don't need the same function to work equally well for naive, GMT, and tz-aware datetimes, it won't be that hard, but it's still not quite trivial—and if you do need the full functionality, it's going to be more painful.Or it may be easier to port the equivalent code given in the docs.For aware datetime instances:Of course you still don't have that timezone.utc, but for this purpose, you don't need a full timezone object; you can use an instance of the example UTC class in the 2.x tzinfo docs.… for naive:… or:Since you don't have aware datetimes, that last one is all you need.If your Python is old enough, timedelta may not have a __div__ method. In that case (if you haven't found a backport), you have to do division manually as well, by calling total_seconds on each one, making sure at least one of them is a float, and dividing the numbers:But in this particular case, it should be pretty obvious that the divisor is just going to be 1.0, and dividing by 1.0 is the same as doing nothing, so:
As the other answers state, datetime.timestamp() was added on Python 3.3.To get a similar behavior on Python < 3.3, you need to use time.mktime():And then, instead of calling start_date.timestamp(), you just call to_seconds(start_date)
The .timestamp() method was added in python version 3.3 [source], so you can't use .timestamp() in Python 2.
All you need in Python 2.x is to use the method time() from the time module, like this:It will give you the same than the timestamp() method from a datetime object from Python 3.x:But this is only valid when you need the current timestamp, not any timestamp.Official doc: https://docs.python.org/2/library/time.html#time.time


Answer URL
https://docs.python.org/3/library/datetime.html#datetime.datetime.timestamp
https://docs.python.org/3/library/datetime.html#datetime.datetime.timestamp
https://docs.python.org/3/library/datetime.html#datetime.datetime.timestamp
https://docs.python.org/3/library/datetime.html#datetime.datetime.timestamp
