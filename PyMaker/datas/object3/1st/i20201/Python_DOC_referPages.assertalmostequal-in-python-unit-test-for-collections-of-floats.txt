Natural Text
The assertAlmostEqual(x, y) method in Python's unit testing framework tests whether x and y are approximately equal assuming they are floats.The problem with assertAlmostEqual() is that it only works on floats. I'm looking for a method like assertAlmostEqual() which works on lists of floats, sets of floats, dictionaries of floats, tuples of floats, lists of tuples of floats, sets of lists of floats, etc.For instance, let x = 0.1234567890, y = 0.1234567891. x and y are almost equal because they agree on each and every digit except for the last one. Therefore self.assertAlmostEqual(x, y) is True because assertAlmostEqual() works for floats.I'm looking for a more generic assertAlmostEquals() which also evaluates the following calls to True:self.assertAlmostEqual_generic([x, x, x], [y, y, y]).self.assertAlmostEqual_generic({1: x, 2: x, 3: x}, {1: y, 2: y, 3: y}).self.assertAlmostEqual_generic([(x,x)], [(y,y)]).Is there such a method or do I have to implement it myself?Clarifications:assertAlmostEquals() has an optional parameter named places and the numbers are compared by computing the difference rounded to number of decimal places. By default places=7, hence self.assertAlmostEqual(0.5, 0.4) is False while self.assertAlmostEqual(0.12345678, 0.12345679) is True. My speculative assertAlmostEqual_generic() should have the same functionality.Two lists are considered almost equal if they have almost equal numbers in exactly the same order. formally, for i in range(n): self.assertAlmostEqual(list1[i], list2[i]).Similarly, two sets are considered almost equal if they can be converted to almost equal lists (by assigning an order to each set).Similarly, two dictionaries are considered almost equal if the key set of each dictionary is almost equal to the key set of the other dictionary, and for each such almost equal key pair there's a corresponding almost equal value.In general: I consider two collections almost equal if they're equal except for some corresponding floats which are just almost equal to each other. In other words, I would like to really compare objects but with a low (customized) precision when comparing floats along the way.
if you don't mind using NumPy (which comes with your Python(x,y)), you may want to look at the np.testing module which defines, among others, a assert_almost_equal function.The signature is np.testing.assert_almost_equal(actual, desired, decimal=7, err_msg='', verbose=True)
Here's how I've implemented a generic is_almost_equal(first, second) function:First, duplicate the objects you need to compare (first and second), but don't make an exact copy: cut the insignificant decimal digits of any float you encounter inside the object.Now that you have copies of first and second for which the insignificant decimal digits are gone, just compare first and second using the == operator.Let's assume we have a cut_insignificant_digits_recursively(obj, places) function which duplicates obj but leaves only the places most significant decimal digits of each float in the original obj. Here's a working implementation of is_almost_equals(first, second, places):And here's a working implementation of cut_insignificant_digits_recursively(obj, places):The code and its unit tests are available here: https://github.com/snakile/approximate_comparator. I welcome any improvement and bug fix.
As of python 3.5 you may compare usingAs described in pep-0485.The implementation should be equivalent to 
There is no such method, you'd have to do it yourself.For lists and tuples the definition is obvious, but note that the other cases you mention aren't obvious, so it's no wonder such a function isn't provided.  For instance, is {1.00001: 1.00002} almost equal to {1.00002: 1.00001}?  Handling such cases requires making a choice about whether closeness depends on keys or values or both.  For sets you are unlikely to find a meaningful definition, since sets are unordered, so there is no notion of "corresponding" elements.
If you don't mind using the numpy package then numpy.testing has the assert_array_almost_equal method. This works for array_like objects, so it is fine for arrays, lists and tuples of floats, but does it not work for sets and dictionaries.The documentation is here.
You may have to implement it yourself, while its true that list and sets can be iterated the same way, dictionaries are a different story, you iterate their keys not values, and the third example seems a bit ambiguous to me, do you mean to compare each value within the set, or each value from each set.heres a simple code snippet.
An alternative approach is to convert your data into a comparable form by e.g turning each float into a string with fixed precision.Then you can:
None of these answers work for me. The following code should work for python collections, classes, dataclasses, and namedtuples. I might have forgotten something, but so far this works for me.


Answer URL
https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertAlmostEqual
