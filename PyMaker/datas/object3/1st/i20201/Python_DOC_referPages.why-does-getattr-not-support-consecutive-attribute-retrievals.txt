Natural Text
It seemed very natural to me to assume the latter. I'm sure there is a good reason for this. What is it? 
You can't put a period in the getattr function because getattr is like accessing the dictionary lookup of the object (but is a little bit more complex than that, due to subclassing and other Python implementation details).If you use the 'dir' function on a, you'll see the dictionary keys that correspond to your object's attributes. In this case, the string "b.c" isn't in the set of dictionary keys.The only way to do this with getattr is to nest calls:Luckily, the standard library has a better solution!
Python's built-in reduce function enables the functionality you're looking for. Here's a simple little helper function that will get the job done:Test proof;
I think your confusion arises from the fact that straight dot notation (ex a.b.c) accesses the same parameters as getattr(), but the parsing logic is different.  While they both essentially key in to an object's __dict__ attribute, getattr() is not bound to the more stringent requirements on dot-accessible attributes.  For instanceIs valid, since that string just becomes a hash key in foo.__dict__, butandare syntax errors because now you are asking the interpreter to parse these things as raw code, and that doesn't work.The flip side of this is that while foo.b.c is equivalent to foo.__dict__['b'].__dict__['c'], getattr(foo, 'b.c') is equivalent to foo.__dict__['b.c'].  That's why getattr doesn't work as you are expecting.
Because getattr doesn't work that way. getattr gets attribute of a given object (first argument) with a given name (second argument). So your code:means: Access "b.c" attribute of object referenced by "a". Obviously your object doesn't have attribute called "b.c".To get "c" attribute you must use two getattr calls:Let's unwrap it for better understanding:
I think the most straight forward way to achieve what you want is to use operator.attrgetter.If the attribute doesn't exist then you'll get an AttributeError
What should return getattr('a.b', {'a': None}, 'default-value'}? Should it raise AttributeError or just return 'default-value'? That's why complex keys if introduced in getattr would make it obscure to use.So, it's more natural to view getattr(..) function as get method of dictionary of object attributes.
You can call the multiple getattr without calling a function within function by splitting the dot operators and performing a getattr() for each dot operatorIf suppose you wish to call a.b.c.d you can do it via a.multi_getattr('b.c.d'). This will generalise the operation without worrying about the count of dot operation one has in the string.


Answer URL
https://docs.python.org/3/howto/descriptor.html
