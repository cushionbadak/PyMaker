Natural Text
I'm asking this question because of a discussion on the comment thread of this answer. I'm 90% of the way to getting my head round it.f1 exists in three different forms:What is the difference between the bound method, unbound method and function objects, all of which are described by f1? How does one call these three objects? How can they be transformed into each other? The documentation on this stuff is quite hard to understand.
A function is created by the def statement, or by lambda.  Under Python 2, when a function appears within the body of a class statement (or is passed to a type class construction call), it is transformed into an unbound method.  (Python 3 doesn't have unbound methods; see below.)  When a function is accessed on a class instance, it is transformed into a bound method, that automatically supplies the instance to the method as the first self parameter.Here f1 is a function.Now C.f1 is an unbound method.We can also use the type class constructor:We can convert f1 to an unbound method manually:Unbound methods are bound by access on a class instance:Access is translated into calling through the descriptor protocol:Combining these:Or directly:The main difference between a function and an unbound method is that the latter knows which class it is bound to; calling or binding an unbound method requires an instance of its class type:Since the difference between a function and an unbound method is pretty minimal, Python 3 gets rid of the distinction; under Python 3 accessing a function on a class instance just gives you the function itself:In both Python 2 and Python 3, then, these three are equivalent:Binding a function to an instance has the effect of fixing its first parameter (conventionally called self) to the instance.  Thus the bound method C().f1 is equivalent to either of:
is quite hard to understandWell, it is quite a hard topic, and it has to do with descriptors.Lets start with function.  Everything is clear here - you just call it, all supplied arguments are passed while executing it:Regular TypeError is raised in case of any problem with number of parameters:Now, methods.  Methods are functions with a bit of spices.  Descriptors come in game here.  As described in Data Model, A.f1 and A().f1 are translated into A.__dict__['f1'].__get__(None, A) and type(a).__dict__['f1'].__get__(a, type(a)) respectively.  And results of these __get__'s differ from the raw f1 function.  These objects are wrappers around the original f1 and contain some additional logic.In case of unbound method this logic includes a check whether first argument is an instance of A:If this check succeeds, it executes original f1 with that instance as first argument:Note, that im_self attribute is None:In case of bound method this logic immediately supplies original f1 with an instance of A it was created of (this instance is actually stored in im_self attribute):So, bound mean that underlying function is bound to some instance. unbound mean that it is still bound, but only to a class.
Function object is a callable object created by a function definition. Both bound and unbound methods are callable objects created by a Descriptor called by the dot binary operator. Bound and unbound method objects have 3 main properties: im_func is the function object defined in the class, im_class is the class, and im_self is the class instance. For unbound methods, im_self is None. When a bound method is called, it calls im_func with im_self as the first parameter followed its calling parameters. unbound methods calls the underlying function with just its calling parameters.
One interesting thing I saw today is that, when I assign a function to a class member, it becomes an unbound method. Such as:
Please refer to the Python 2 and Python 3 documentation for more details.My interpretation is the following.Class Function snippets:  Python 3:Python 2:  If a function is called without class or instance, it is a plain function.If a function is called from a class or an instance, its __get__ is called to retrieve wrapped function:a. B.x is same as B.__dict__['x'].__get__(None, B).In Python 3, this returns plain function.In Python 2, this returns an unbound function.b. b.x is same as type(b).__dict__['x'].__get__(b, type(b). This will return a bound method in both Python 2 and Python 3, which means self will be implicitly passed as first argument.


Answer URL
https://docs.python.org/3/howto/descriptor.html
