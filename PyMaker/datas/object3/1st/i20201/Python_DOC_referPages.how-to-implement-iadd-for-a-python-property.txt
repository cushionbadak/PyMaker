Natural Text
I'm trying to create a Python property where in-place adding is handled by a different method than retrieving the value, adding another value and reassigning. So, for a property x on an object o,should work differently thanThe value of o.x should be the same in the end, so as not to confuse people's expectations, but I want to make the in-place add more efficient. (In reality the operation takes a lot more time than simple addition.)My first idea was to define, in the class,But this raises an AttributeError, presumably because property implements __slots__?My next attempt uses a descriptor object:As you can see, the special __iadd__ method is not called. I'm having trouble understanding why this is, although I surmise that the object's __getattr__ is somehow bypassing it.How can I do this? Am I not getting the point of descriptors? Do I need a metaclass?
__iadd__ will only be looked for on the value returned from __get__.  You need to make __get__ (or the property getter) return an object (or a proxy object) with __iadd__.
The += operator in the lineis translated toThe attribute lookup on the right-hand side is translated toAs you can see, __iadd__() is called on the return value of the attribute lookup, so you need to implement __iadd__() on the returned object.
To inspire you, here's a less-than-ideal solution which is the best I've managed to come up with so far:The big disadvantage being, that you have to implement the full complement of numerical magic methods on IAddObj if you want the property to behave anything like a number. Having IAddObj inherit from int doesn't seem to let it inherit the operators, either.
Why not something like the following example. Basically the idea is to let the Bar class ensure the stored value for property x is always a Foo object.EDIT: Extended example to show how to use it as a property. I first misunderstood the problem slightly. 


Answer URL
