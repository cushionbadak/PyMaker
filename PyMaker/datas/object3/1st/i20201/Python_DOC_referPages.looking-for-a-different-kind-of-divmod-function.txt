Natural Text
Python's divmod function works properly, and it is almost what I want. However, its behavior with non-integer numbers needs to be slightly different for an operation that needs to be performed. When running the following code, you might see what it is that is trying to be done.How can function be defined above such that the final expression evaluates to True, not False? If anyone can figure out how to get (pi, 0) instead of (3.0, 0.4448...), that would be the answer.Edit 1: Now for a more complicated example, the following code should yield [3, 2, 1, 3, 2, 1].Edit 2: The following shows code that works fine except that it has unexpected but valid output.The following function can be used to reverse the operation and check the results.The following code does not raise an AssertionError, so it is evident that everything is working fine.So then this brings me to the following example. The output can be converted back without a problem, but one would expect something slightly different.The string should have been 100 base π + 0.0 base 10. The output is accurate but not "proper" at this point.Edit 3: The following example may provide some extra insight into what I am after. After running a loop with different powers of π, I would expect all outputs to be 10... base π + 0.0 base 10 in their form. The results are different from this as shown below.Also shown is how the last two strings are equivalent, yet the output should have been in the form of the second string. I find it fascinating that the difference between 10000000000000000000 base π and 2312130133123211021 base π is 0.4390387422112354 base 10, but that difference has a large influence over the representation. The output should have been as shown below.Is there something that I am missing, is there a solution to this problem, or should this be considered a fool's errand?
You're looking for an algorithm to determine a non-integer base representation of a floating-point number.Wikipedia describes a greedy algorithm due to Rényi and Frougny; here's an attempt at an implementation:This gives the lexicographically initial expansion; you can get the lexicographically terminal expansion with a little fiddling:Unfortunately this still won't quite work, as OP's expansion is non-greedy in the first digit but greedy in the last digit.
Recognize that floating point arithmetic is by definition imprecise.  Operations like pi*pi are not guaranteed to equal the mathematical constant π^2 (for that matter math.pi is only as accurate as "available precision" - meaning it's not the right value either).  Therefore it's not actually possible to do operations on floating point numbers that treat them like real numbers.The general solution is to check for a distance from some epsilon value, but this has obvious limitations.  You'll do better to re-examine your underlying requirements (why do you need real-number precision?) and try to solve the problem from a different direction.For the example you describe, why do you need to actually use a value for π?  Could you just leave the actual calculation of π off til the very end, and do your operations only on the coefficients?For instance, store the list [3, 2, 1, 3, 2, 1] directly, and do your operations and transformations with the implicit contract that they are coefficients, then define something like:as the very last step before printing.  Even better, you could wrap this behavior up in a class (and I'd be willing to bet someone has done this before) and make __str__() do toFloat()'s behavior, so that displaying your object gives you the most precise value you can get.
This one is pretty simple and seems to work better than OPs. I think the flaws in the results are precision related:UPDATEI got the first thousand digits of pi off the internet, and used that and decimal.Decimal and got a few less errors, but there was still a couple. Therefore, I'm confident difference is related to precision. Also,  amount of time the computation takes increases dramatically as the precision increases.


Answer URL
https://docs.python.org/3/library/functions.html#divmod
