Natural Text
I'm trying to divide a nested list into two nested lists using list comprehensions. I am unable to do so without converting the inner lists to strings, which in turn ruins my ability to access/print/control the values later on.  I tried this::What happens is that the whole of paragraphs3 = [] ends up in therest = [], unless i do something like this:If I then feed paragraphs4 to the list comprehension, I get two lists, just like I want. But they are not nested lists anymore since this: Writes each !character! in therest = [] in a separate line:Thus I'm looking for a better way to split paragraphs3 ... Or maybe the solution lies elsewhere? The end result/output I'm looking for is: 
This code separates the sublists based on whether they contain a string that starts with 'Derived:'. outputThe most important part of this code isThis iterates over the individual strings in para (the current paragraph), and returns True as soon as it finds a string that starts with 'Derived:'.  FWIW, that for loop can be condensed down to:because False and True evaluate to 0 and 1 respectively, so they can be used to index the (therest, derived) tuple. However, many people would consider that verging on unreadable. :) 
The code you've written is almost correct. You need to check if 'Derived:' is present in the 3rd element of the list. k basically contains the first element of paragraphs3So all you have to do is change the condition to if 'Derived:' in k[2].
SolutionDetailed explanationCopying the entire list:Copying list with condition:Function sublist_contains is not implemented yet, so let's implement it.Retrieve only items which match the condition_check:Since condition_check can be expressed as a lambda function:Converting result to boolean (will be True if at least one item is found matching the condition):And replacing sublist_contains with resulting inline code:
It seems like your inner list has structure; the list itself is one value, not just a list of unrelated values. With that in mind, you could write a class to represent that data.You can then use the partition recipe from itertools to split that one list into two iterators.
This seems to me like the most straight-forward way of doing it: However, if you'd like, you can get a lot fancier, and pull this off in a single line (though it will be more complicated than necessary). This produces a dict with 'derived' and 'therest' as keys. Now you can do this: 


Answer URL
https://docs.python.org/3/library/itertools.html
