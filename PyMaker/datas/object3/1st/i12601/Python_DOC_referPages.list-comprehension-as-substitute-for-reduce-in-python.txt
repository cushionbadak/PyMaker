Natural Text
The following python tutorial says that:List comprehension is a complete substitute for the lambda function as well as the functions map(), filter() and reduce().http://python-course.eu/python3_list_comprehension.phpHowever, it does not mention an example how a list comprehension can substitute a reduce() and I can't think of an example how it should be possible.Can please someone explain how to achieve a reduce-like functionality with list comprehension or confirm that it isn't possible?
Ideally, list comprehension is to create a new list. Quoting official documentation,List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition.whereas reduce is used to reduce an iterable to a single value. Quoting functools.reduce,Apply function of two arguments cumulatively to the items of sequence, from left to right, so as to reduce the sequence to a single value.So, list comprehension cannot be used as a drop-in replacement for reduce.
I was surprised at first to find that Guido van Rossum, creator of Python, was against reduce. His reasoning was that beyond summing, multiplying, and-ing, and or-ing, using reduce yields an unreadable solution that is better suited by a function which iterates through and updates an accumulator. His article on the matter is here. So no, there isn't a list comprehension alternative to reduce, instead the "pythonic" way is to implement an accumulating function the old fashioned way: Instead of: out = reduce((lambda x,y: x*y),[1,2,3])Use:Of course nothing stops you from continuing to use reduce (python 2) or functools.reduce (python 3)
List comprehensions are supposed to return lists. If your reduce is supposed to return a list, then yes, you can replace it with a list comprehension.But this is no obstacle to providing "reduce-like functionality". Python lists can contain any object. If you'll accept your result contained in a single-item list, then there is a [...][0] list comprehension form that can replace any reduce() whatsoever.This should be obvious, but that form isfor some binary function and and some iterable sequence and some initial value. Or, if you want the initial from the first of the iterable,Arguably, the above is cheating, and also pointless, since you could just use reduce without the comprehension. So let's try it without reduce.This produces a list of all the intermediate values, and we want the last one. [-1] is just as easy as [0]. We need an accumulator to reduce, but can't use assignment statements in a comprehension, hence the stack (which is just a list), but we could have used many other data structures here. The .append() always returns None, so we use or stack[0] to put the value so far in the resulting list.It's a little more difficult without initial,Really, you might as well use a for statement at this point.But this takes up memory for the list of intermediate values. For a very long sequence, that might be a problem. But we can avoid that too by using generator expressions.Doing this is tricky, so let's start with an easier example and work up to it.It computes the answer, but also creates a useless list of Nones. We can avoid that by converting it to a generator expression inside a list comprehension.The list comprehension exhausts the generator that updates the stack, but returns an empty list itself. This is possible because the inner loop always has zero iterations, because _s is always an empty tuple.We can move the stack.pop() inside if the last _s has one element. It doesn't matter what that element is though. So we chain on a [None] as the final _s.Again, we have a single-item list comprehension. We can also implement chain as a generator expression. And you've already seen how to move the stack variable inside using a single-item list.And we can also get the initial from the sequence for the two-argument reduce.This is insane. But it works. So yes, it's possible to get "reduce-like functionality" with comprehensions. That doesn't mean you should. Seven fors is too hard!
You could accomplish something like a reduce with a comprehension by using a couple of helper functions that I've named last and cofold:This is functionally equivalent toNote that unlike reduce() the comprehension didn't use a lambda.The trick is to use a generator with a callback to "return" the result of the operator. cofold is the corecursive dual of the reduce (or fold) function.Here's cofold in a list comprehension.The elements represent each step in the dual reduction. The last one is our answer. The last function is trivial.Unlike reduce, cofold is a lazy generator, so it can safely act on infinite iterables when used in a generator expression.


Answer URL
https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions
https://docs.python.org/3/library/functools.html#functools.reduce
