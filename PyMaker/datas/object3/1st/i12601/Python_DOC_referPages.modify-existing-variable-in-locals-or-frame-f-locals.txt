Natural Text
I have found some vaguely related questions to this question, but not any clean and specific solution for CPython. And I assume that a "valid" solution is interpreter specific.First the things I think I understand:locals() gives a non-modifiable dictionary.A function may (and indeed does) use some kind of optimization to access its local variablesframe.f_locals gives a locals() like dictionary, but less prone to hackish things through exec. Or at least I have been less able to do hackish undocumented things like the locals()['var'] = value ; exec ""exec is capable to do weird things to the local variables, but it is not reliable --e.g. I read somewhere that it doesn't work in Python 3. Haven't tested.So I understand that, given those limitations, it will never be safe to add extra variables to the locals, because it breaks the interpreter structure.However, it should be possible to change a variable already existing, isn't it?Things that I consideredIn a function f, one can access the f.func_code.co_nlocals and f.func_code.co_varnames.In a frame, the variables can be accessed / checked / read through the frame.f_locals. This is in the use case of setting a tracer through sys.settrace.One can easily access the function in which a frame is --cosidering the use case of setting a trace and using it to "do things" in with the local variables given a certain trigger or whatever.The variables should be somewhere, preferably writeable... but I am not capable of finding it. Even if it is an array (for interpreter efficient access), or I need some extra C-specific wiring, I am ready to commit to it.How can I achieve that modification of variables from a tracer function or from a decorated wrapped function or something like that?A full solution will be of course appreciated, but even some pointers will help me greatly, because I'm stuck here with lots of non writeable dictionaries :-/Edit: Hackish exec is doing things like this or this
It exists an undocumented C-API call for doing thigs like that:PyFrame_LocalsToFastThere is some more discussion in this PyDev blog post. The basic idea seems to be:I have yet to test if this works as expected.Note that there might be some way to access the Fast directly, to avoid an indirection if the requirements is only modification of existing variable. But, as this seems to be mostly non-documented API, source code is the documentation resource.
Based on the notes from MariusSiuram, I wrote a recipe that show the behavior.The conclusions are:we can modify an existing variablewe can delete an existing variablewe can NOT add a new variable.So, here is the code:The output would be like:


Answer URL
https://docs.python.org/3/library/functions.html?highlight=locals#locals
