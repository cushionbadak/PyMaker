Natural Text
I'm having difficulty figuring out at what point I can pass the BNG_FFIArray returned by my Rust program back to it, in order to free the memory that it's allocated.My ctypes setup is as follows:This is all working correctly, but I'm not sure at what point I'm supposed to return the data initially allocated by my call to lib.convert_to_bng back across the FFI boundary in order to free its associated memory, by calling drop_array.Here's my Rust struct and function.
There are two ways to manage resources in Python, both of which involve creating an object that either:has a finalizer, the __del__ methodor acts as a context manager for the with statementBoth of these involve having a manager object that controls/provides access to the resource, which will run any clean-up code necessary when the object is no longer needed. For this case, I think the first one works best, but I'll demonstrate both.For my examples, I'll use this Rust code,, where Data is a stand-in for any resource that needs managing (e.g. your Array type):Which can be compiled with, say, rustc ffi_example.rs to create libffi_example.so (or similar, depending on platform). This is the start of the Python code I'm using for the two cases (the CDLL call may need to be adjusted):(Note that by interfacing via pointers, I don't have to tell Python any info about the internals of RawData.)You can check everything's working by adding the following, for instance, to the end:which prints something like(The flush is to ensure the prints from the two languages appear in the right order, since they have different buffers.) __del__To use __del__ just make an Python object (not a ctypes.Structure) that serves as the interface to the Rust one, likeThis can then be used as a normal object:This will print:That is, Python can tell when object definitely no longer have any references (e.g. when the two handles obj and obj2 are both overwritten for 123, or when the program ends, for 456).Context managersIf the resource is heavily scoped (which it probably isn't, in this case), it may make sense to instead use a context manager, which will allow something like:This is somewhat error-prone because a handle to an object can be kept outside the with statement, so it has to check for this or else it may access deallocated memory. For instance,Anyway, implementation:The first example above gives output like:And the second gives:This approach does have the advantage of makes the region of code where the resource is valid/allocated clearer, effectively a manual form of the RAII/scope-based resource management of Rust.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__del__
https://docs.python.org/3/library/stdtypes.html#typecontextmanager
