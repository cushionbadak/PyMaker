Natural Text
My data structures are as follows:This causes units to output I want to be able to create a copy of units, but to not have the KEY be a string inside one of its own lists. So I want 'A1' removed from the first 3 lists. 'A2' removed from the next 3 lists, etc.I can import copy and do units2 = copy.deepcopy(units) then units2['A1'][0].remove('A1') to do it one list at a time. So that led me to try making a loop to do it all at once.I would think that this would do it flawlessly by running Unfortunately, after running this loop, I end up with:So somehow, this loop is deleting all of the data inside of the lists instead of just the current [s] in the current [x] list.I have tried structuring the list in different ways and even made 81 versions of But I still end up with empty lists as all of my dictionary values.*What I'm trying to do is build a sudoku solver to then use to generate sudokus for a game in PyGame. I plan on using the lists in units2 to check and see if only 1 cell in any given list is still eligible for a specific number. If that is the case, I know that that cell must have that number as its value because it is the only one in the column, row, or 9x9 block that can legally hold it based on the rules.
Using nested list comprehension change units to be:
If you look at what is happening here and step back for a moment, the answer becomes obvious.You are no doubt aware what causes this:That's why you have copy.deepcopy. But when you look at what's happening, if you use Occam's Razor, the obvious answer is that you have multiple references to the same list, and when you delete from another list that ends out emptying all of the lists in your structure. Here's an easy way to check that:Which outputs (unsurprisingly):Obviously your ids will be different, but the counts will all be 9. You also could've used pdb or pudb to inspect the variables as you looped through.If you replace units2 with units you'll get the same counts. So the real question here is why doesn't copy.deepcopy behave the way you thought it did? And why do you have multiple copies of the same list in your list of lists?Let's try a few experiments:I would expect two different id's here, and indeed they are. But what about their contents?Yep. Those are different. What if we put these in a dictionary?We still get different ids. Everything seems to be behaving as expected so obviously we're missing something. Oh, yes - we're comparing between our copied lists and our original lists.If you replace units2 with units you'll get the same counts.There is a hint. Also, if you read the deepcopy documentation:Two problems often exist with deep copy operations that don’t exist with shallow copy operations:Recursive objects (compound objects that, directly or indirectly, contain a reference to themselves) may cause a recursive loop.Because deep copy copies everything it may copy too much, e.g., administrative data structures that should be shared even between copies.The deepcopy() function avoids these problems by:keeping a “memo” dictionary of objects already copied during the current copying pass; andletting user-defined classes override the copying operation or the set of components copied.deepcopy pays attention to objects that it has already seen.Voilá! We have our culprit!In your original dictionary units you have multiple copies to the same lists in different keys. An that's because of this line:This section in particular:You are repeating references to lists from unitlist throughout your dictionary. Luckily this is a trivial fix:Will make a copy of that list each time, and the rest of your code will work just fine.Outputs:


Answer URL
https://docs.python.org/3/library/pdb.html
https://docs.python.org/3/library/copy.html
