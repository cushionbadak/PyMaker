Natural Text
This question is an extension of a previous question: rebuild python array based on common elements - but different enough to warrant a new question:I've been struggling with this for a bit now.  My data is an array of dictionaries from an sql query.  Each element in the array represents a shipment, and there are common values based on the keys.The output I want is grouped according to specific keysI can get the grouping with a single level using defaultdict and list comprehension as provided by the previous question and modified slightlyBut I can't seem to get the second level in the output array - the grouping b the PartNum key.  Through some research, I think what I need to do is use defaultdict as the type of the outer `defaultdict' like so:which throws errors because defaultdict returns a function, so I need to use lambda (yes?)My question is how to "access" the second level array in the loop and tell the "inner" defaultdict what to group on (PartNum)?  The data comes to me from the database programmer and the project keeps evolving to add more and more data (keys), so I'd like this solution to be as general as possible in case more data gets thrown my way.  I was hoping to be able to "chain" the defaultdicts depending on how many levels I need to go.  I'm learning as I'm going, so I'm struggling trying to understand the lambda and the basics of the defaultdict type and where to go from here.
Using groupby as suggested by @Pynchia and using sorted for unordered data as suggested by @hege_hegedus:If you look at the second for loop, this will hopefully answer your question about accessing the second level array in the loop.
You could use a tree-like data structure based on an OrderedDefaultdict instead of a defaultdict(list). (The definition's from an unrelated answer of mine.)So, for the data shown in your question, d would end up containing:Which could just simply be printed out since it's now grouped the way you want.
Sort by "CustName", "PartNum", "delKey". Iterate over the delivery items for each part, for each customer and accumulate to match your output spec.I like to use operator.itemgetter - for me it makes things clearer.This clearly iterates over the items in the original data multiple times which may be a performance hit -- but I don't see a way around multiple iteration for what you need to do. 
This is the prettiest way I could do it. It uses the same defaultdict idea to implement proper grouping, as python's builtin groupby function only works on ordered data.Note that this version will mutate the items in the input dataset, so the leaf items in the result are the same dict instances as the input, but with "CustName" and "PartNum" entries deleted.EDIT:Just in the case somebody needs it in the future, here is a version that does not mutate the original data:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.groupby
