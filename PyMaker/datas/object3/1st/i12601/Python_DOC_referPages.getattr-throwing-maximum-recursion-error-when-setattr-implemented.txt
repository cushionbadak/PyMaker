Natural Text
I'm trying to create a circle class using the magic methods __getattr__ and __setattr__, and I seem to have my __getattr__ working, but when I implement __setattr__ (which should only allow the values for x and y to be set if the value is an int, and raise an AttributeError when the user tries to set the attributes area, circumference, and distance to circle), my __getattr__ throws the maximum recursion error. When I comment it out, the __getattr__ then works just fine. With __setattr__ commented out, the testing code:prints out:
Improved solutionBased on the discussion here, this is a shorter and improved version. Achieves the same as the original solution:SolutionAvoiding __getattr__() all together and using a flag self._intialized to signal if the __init__() was already run would work:The output looks good:VariationThis would allow setting an attribute with any other name:But it would not be there:This implementation of __setattr__ would avoid this:When to use __getattr__()?When you access an attribute that does not exist, Python raises an AttributeError:Python calls __getattr__()  only if an attribute does not exist.One use case is a wrapper around another object instead of using inheritance.For example, we can define a ListWrapper that uses an list but allows only white-listed attributes:We can use it just like list:Append elements:But we cannot use any other attribute except the ones defined in _allowed_attrs:What the docs says:Called when an attribute lookup has not found the attribute in the usual places (i.e. it is not an instance attribute nor is it found in the class tree for self). name is the attribute name. This method should return the (computed) attribute value or raise an AttributeError exception.Note that if the attribute is found through the normal mechanism, __getattr__() is not called. (This is an intentional asymmetry between __getattr__() and __setattr__().) This is done both for efficiency reasons and because otherwise __getattr__() would have no way to access other attributes of the instance. Note that at least for instance variables, you can fake total control by not inserting any values in the instance attribute dictionary (but instead inserting them in another object). See the __getattribute__() method below for a way to actually get total control over attribute access.
You may be interested in the couple of problems you had in your code that were causing the problem.You cannot set the following directly in __init__() because the assignments trigger a call to __setattr__(), which sets only x and y. Because of this, these attributes were never set.You are not checking for r in __setattr__(). This caused r to be ignored silently, and then when r was accessed to set area in __init__(), __getattr__() called getattr() called __getattr__() called getattr() and so on (because r was not set), which caused the recursion.Here is fixed code. Changes have been marked below with mod in comments.


Answer URL
https://docs.python.org/3/reference/datamodel.html?highlight=__getattr__#object.__getattr__
