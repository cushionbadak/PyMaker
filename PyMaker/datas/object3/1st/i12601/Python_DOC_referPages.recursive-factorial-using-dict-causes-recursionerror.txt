Natural Text
A simple recursive factorial method works perfectly:But I wanted to experiment a little and use a dict instead. Logically, this should work, but a bunch of print statements tell me that n, instead of stopping at 0, glides down across the negative numbers until the maximum recursion depth is reached:Why is that?
Python doesn't lazily evaluate parameters.The default value passed to dict.get call will also be evaluated before calling the dict.get.So, in your case, the default value has a recursive call and since your condition is never met, it does infinite recursion.You can confirm this, with this programEven though the key 0 exists in the dictionary, since all parameters passed to functions in Python will be evaluated, getter is also invoked, before the actual dict.get is made.If all you want to do is to avoid multiple recursive evaluations when the values are already evaluated, then you use functools.lru_cache, if you are using Python 3.2+This decorator simply caches the results for the parameters passed and if the same call is made again, it will simply return the value from the cache.If you want to fix your custom caching function to work, then you need to define the look_up outside the function, so that it will not be created whenever the function is called.Otherwise you can use the default parameter, like this


Answer URL
https://docs.python.org/3/library/functools.html#functools.lru_cache
