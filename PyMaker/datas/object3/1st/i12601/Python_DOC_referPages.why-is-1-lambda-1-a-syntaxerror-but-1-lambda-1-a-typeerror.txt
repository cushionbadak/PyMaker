Natural Text
In the interactive interpeter the following two expressions raise different errors depending on the addition of parenthesis:1 + lambda: 1 results in a SyntaxError 1 + (lambda: 1) results in a TypeErrorI understand the differences SyntaxError and TypeError, that is, what they essentially mean, but I don't really understand why exactly this happens. I have tried reading the Grammar, but it really is all Greek to me. The expr (which I would of though denotes expressions) is defined as:While lambdas:These did not help much. The same applies for Python 2.x and for 3.x. So, why do parenthesis do that alters the exception result in this context?
Why does 1 + lambda: 1 raise a SyntaxError ?The syntax error is raised because the grammar doesn't support it. From the Full Grammar Specification we can see that the test rule, which is the basic expression element and not the ill-named expr, has the form of:where the vertical bar | is used to seperate alternative substitutions for this rule. As a result, each expression must either begin with an or_test or a lambdadef. If a lambdadef is not found in the beginning of an expression a SyntaxError is appropriately raised during parsing:[Note: From the or_test member of test we can generate practically every other expression in Python by substitutions]Why does 1 + (lambda: 1) raise a TypeError ?Because parenthesis are used as enclosures:where parenth_form is:The parenthesis here will isolate the lambda: 1 from the rest of the expression and confine it in an expression (test) of its own. Since the new expression is (lambda: 1) it is syntactically valid (since lambdadef is an element at the beginning of the expression). As such, there is no rule which can trigger a SyntaxError. (if you did 1 + (1 + lambda: 1) the same SyntaxError is triggered).Additionally, we can actually verify the fact that (lambda: 1) is a new test rule by looking at (the relevant section) of the list-based parse tree and cross-referencing it with the numbers contained in Include/graminit.h. We can generate the parse tree from:and by viewing the definition for test we can see that 304 defines a new test.As a result, the expression will be parsed and consequently compiled with no issues:It is during execution were the evaluation will happen and Python will discover that addition is unsupported for the objects of int and function. When it discovers it, a TypeError is raised: 


Answer URL
https://docs.python.org/3/reference/expressions.html
https://docs.python.org/3/reference/grammar.html
https://docs.python.org/3/reference/introduction.html#notation
https://docs.python.org/3/reference/expressions.html#boolean-operations
https://docs.python.org/3/reference/expressions.html#lambda
https://docs.python.org/3/reference/expressions.html#atoms
https://docs.python.org/3/reference/expressions.html#grammar-token-parenth_form
