Natural Text
Update on 7/19/2017Found the solution here: https://stackoverflow.com/a/10021912/5729266A quick conclusion if you don't want to read to the end.The inconsistency of random numbers in my previous code was caused by thread-unsafe, because random module is considered as a global variable even each thread deals with one individual instance containing the random module.To solve the problem, you have to use either thread-lock or generate an independent random instance as described in the link above. See test code below.Old post:In my Python program I need to run N subprocesses using multiprocessing.pool. Every subprocess spawns M threads, each of which needs to generate hashcode for IDs in column 'ID' of a dataframe.The hash codes need to follow the distribution of uniform(0,1). To do this, I used ID as seed (random.seed(ID)) to set random state and then produced a random key from random.uniform(0, 1). But there were about 0.01% chance that an ID has different random numbers. For example, an ID ’200300’ appears 10000 times among all these threads/subprocesses, but 9999 times it has one random key and 1 time it has another random key. So, my question is: Does random.seed(seed) generate same sequence in parallel programs all the time? If not, how can I fix the random state to ensure random.uniform(0, 1) to pop the same number given the same ID? I am also open for other methods that can hash ID into a random variable with uniform(0,1) distribution.Just note, that I want to use Process and threads for my work and cannot concatenate these dataframes during the program to generate random keys all in once. I tried using multiprocessing.Manager to share the random state or import random in parent process or pass random_generator() as instance or object from parent process to child environment. But it seems that things do not work as expected. Here is a simple version of my code:                       Note: I use Python 3.6
SummaryQ.  Does random.seed(seed) generate same sequence in parallel programs all the time? A.  Yes.The random number generator is guaranteed reproduce the same series of random values given the same starting seed.One other thought:  Use random.random() instead of random.uniform(0, 1).  Both give the same range of random variables, but the former is both faster and more idiomatic.ExampleDemonstration of separate processes running different generators starting with the same seed:Output:Note that all the processes generated the same values.
It sounds that what you really want is not a random number, but a hash of the ID.  Check out Hashing strings with Python.With a hash, you get hash keys that are evenly distributed and identical witdth, but the same ID will always translate to the same hash key.  Hashe keys will look random.  It will be difficult to deduce the original ID from the hash key.  If security is an issue (if it needs to be really difficult to figure out the IDs from the keys), avoid MD5, but otherwise MD5 should be fine.


Answer URL
https://docs.python.org/3/library/uuid.html#module-uuid
