Natural Text
Mark Lutz in his book "Learning Python" gives an example:a bit later he remarks that 'a map and filter equivalent' of this is possible though complex and nested.The closest one I ended up with is the following:The order of tuples is different and nested list had to be introduced. I'm curious what would be the equivalent.
One important point that you have to notice is that your nested list comprehension is of O(n2) order. Meaning that it's looping over a product of two ranges. If you want to use map and filter you have to create all the combinations. You can do that after or before filtering but what ever you do you can't have all those combinations with those two functions, unless you change the ranges and/or modify something else.One completely functional approach is to use itertools.product() and filter as following:Also note that using a nested list comprehension with two iterations is basically more readable than multiple map/filter functions. And regarding the performance using built-in funcitons is faster than list comprehension when your function are merely built-in so that you can assure all of them are performing at C level. When you break teh chain with something like a lambda function which is Python/higher lever operation your code won't be faster than a list comprehension.
A note to append to @Kasramvd's explanation.Readability is important in Python. It's one of the features of the language. Many will consider the list comprehension the only readable way.Sometimes, however, especially when you are working with multiple iterations of conditions, it is clearer to separate your criteria from logic. In this case, using the functional method may be preferable.
I think the only confusing part in the expression [(x, y) for x in range(5) if x % 2 == 0 for y in range(5) if y % 2 == 1] is that there an implicit flatten operation is hidden.Let's consider the simplified version of the expression first:However, we need pretty the same but flattened list [(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]. From the official python docs we can grab the example of flatten function:Which is basically an equivalent for the following list comprehension expression:
Range support step argument, so I come up with this solution using itertools.chain.from_iterable to flatten inner list:Output:    


Answer URL
https://docs.python.org/3/library/itertools.html#itertools-recipes
