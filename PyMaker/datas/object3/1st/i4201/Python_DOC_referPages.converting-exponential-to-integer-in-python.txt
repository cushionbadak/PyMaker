Natural Text
When I execute this python code:The output I receive is: 18243150071292140668971909120 which does not equal to  integer.Why does this happen and how can I make the output equal to integer? 
That result can be achieved in Python3 (or Python2 with true division imported from future), but not Python2 in stock mode.The operator / always generate "true" quotient (with fractional part), but first it converts both arguments to its float (which is the same as double in C). And this conversion is where precision is lost because this float has only 53 significant binary digits (guessing your platform is IEEE754 based, as >99% are). The argument divided by 1 is already rounded in that way and gets equal to 18243150071292140668971909120.(It seems Python language documentation is not precise here in operatorʼs effects. It notes that "The numeric arguments are first converted to a common type" but forgets that, to get a float result, the simplest way is utilized - to rely on platformʼs floating division.)Then, conversion back to int (that is exact and essentially unlimited) gives the same value and you see it printed.To get what you expect, use // instead of /: the "floor division" (//) doesn't convert its arguments to float. (OTOH, if some of them is already float, it can convert another one to perform floating division and them truncate result to flooring integer value.)This is essentially the same you are told by @PM2Ring but formed as answer.If you want to make calculations with not-only-integer numbers with precision more than a usual float provides, you should get out of intrinsic types and consider using decimal from the standard library, GMP library wrapper or a similar solution.


Answer URL
https://docs.python.org/3/reference/expressions.html#binary-arithmetic-operations
