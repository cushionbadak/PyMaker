Natural Text
I was trying to process old, potentially non-compliant emails with Python. I could read in the message without problem:But subsequently converting it to string gave a UnicodeEncodeError: 'gb2312' codec can't encode character '\ufffd' in position 1238: illegal multibyte sequence. The (multi-)part of this problematic message has "Content-Type: text/plain; charset="gb2312" and "Content-Transfer-Encoding: 8bit".I'm not really familiar with the idiosyncrasies of email internals, and searching online for this type of errors turned up mostly problems while scraping the web, and basically suggested somewhat the obvious: the raw bytes read in contains Unicode characters that are not possible to encode with the target codec.My question is: what's the correct way to reliably handle (potentially non-compliant) emails?EDITIt is interesting that m.get_payload(i=0).as_string() would trigger the same exception, but m.get_payload(i=0).get_payload(decode=False) gave a str that displayed correctly on my terminal, while m.get_payload(i=0).get_payload(decode=True) gave a bytes (b'\xd7\xaa...') that I can't decode. However, the error happens on a different character:or
The short answer is usually error handlers in your bytes.decode calls. But the details depend on a lot of things.First, what are you trying to do with the data? Often you need something that is absolutely reversible, so you can guarantee that worst-case you can re-generate what you took in, in which case you probably want surrogate-escape. In other cases, you want to generate something human-readable, and it's better to just skip over impossible mojibake than try to present it, so ignore may be the right answer. And so on.Second, is this a case of the vast majority of messages being fine, but a few being wrong, or of many messages being mostly fine but having a few errors?Finally, in some cases (and this is particularly true with legacy Chinese encodings), the actual problem is just that someone specified a closely-related charset instead of the one they actually used. If that's what you're seeing, you may want to try writing explicit fallback code: if you get an exception, look up the encoding in a dict of common mistakes and try the alternative encoding(s). If none of them work, then go back to using the specific encoding with an error handler.
Apparently, if Content-Transfer-Encoding is 8bit, message.get_payload(decode=False) will still try to decode it to recover the original bytes. On the other hand, message.get_payload(decode=True) always produces bytes, although actual decoding happens only if Content-Transfer-Encoding exists and is quoted-printable or base64.I ended up with the following code. Not sure if this is the correct way of handling emails.


Answer URL
https://docs.python.org/3/library/codecs.html#error-handlers
