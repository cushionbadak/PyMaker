Natural Text
I think my question is related to this, but not exactly similar. Consider this code:The output of this code is:Is it guaranteed that the line "In the finally block" is going to be printed before "Finished counting"? Or is this because of cPython implementation detail that an object will be garbage collected when the reference count reaches 0.Also I am curious on how finally block of the countdown generator is executed? e.g. if I change the code of main tothen I do see Finished counting printed before In the finally block. How does the garbage collector directly go to the finally block? I think I have always taken try/except/finally on its face value, but thinking in the context of generators is making me think twice about it. 
You are, as you expected, relying on implementation-specific behavior of CPython reference counting.1In fact, if you run this code in, say, PyPy, the output will usually be:And if you run it in an interactive PyPy session, that last line may come many lines later, or even only when you finally exit.If you look at how generators are implemented, they have methods roughly like this:CPython deletes objects immediately when the reference count becomes zero (it also has a garbage collector to break up cyclic references, but that isn't relevant here). As soon as the generator goes out of scope, it gets deleted, so it gets closed, so it raises a GeneratorExit into the generator frame and resumes it. And of course there's no handler for the GeneratorExit, so the finally clause gets executed and control passes up the stack, where the exception is swallowed.In PyPy, which uses a hybrid garbage collector, the generator doesn't get deleted until the next time the GC decides to scan. And in an interactive session, with low memory pressure, that could be as late as exit time. But once it does, the same thing happens.You can see this by handling the GeneratorExit explicitly:(If you leave the raise off, you'll get the same results for only slightly different reasons.)You can explicitly close a generatorâ€”and, unlike the stuff above, this is part of the public interface of the generator type:Or, of course, you can use a with statement:1. As Tim Peters' answer points out, you're also relying of implementation-specific behavior of the CPython compiler in the second test.
I endorse @abarnert's answer, but since I already typed this ...Yes, the behavior in your first example is an artifact of CPython's referencing counting.  When you break out of the loop, the anonymous generator-iterator object countdown(10) returned loses its last reference, and so is garbage-collected at once.  That in turn triggers the generator's finally: suite.In your second example, the generator-iterator remains bound to c until your main() exits, so as far as CPython knows you may resume c at any time.   It's not "garbage" until main() exits.  A fancier compiler could notice that c is never referenced after the loop ends, and decide to effectively del c before then, but CPython makes no attempt to predict the future.  All local names remain bound until you explicitly unbind them yourself, or the scope in which they're local ends.


Answer URL
https://docs.python.org/3/library/gc.html
