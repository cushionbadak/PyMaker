Natural Text
Python methods to convert ISO 8601 time format to UNIX timestamp (epoch) and back again without losing fractional seconds?I found several examples, but all the examples seem to drop the fractional seconds at some point in the conversion.  Example below...The issue seems to be the initial conversion to UNIX timestamp (epoch).  Code below.This results as...Original Time 2018-04-27T04:19:51.050937Time 1524802791Original Time 2018-04-27T04:19:51Is there a way to get timetuple to not hack the fractional seconds?
The problem here is that you're converting a datetime—which understands microseconds—into a timetuple—which doesn't.1The obvious fix is just to not do that.If you want to convert a datetime object to a timestamp, just use the timestamp method, the same way you already use the fromtimestamp classmethod to go the other way.1. You might be able to trick a timetuple into holding a float instead of an int for seconds. But then you'd be breaking the invariants of the type. And, more importantly, defeating the entire purpose of the type, which is to be identical to a 1980s-style C struct tm. And likely also breaking the timegm function, which probably just calls the C function of the same name. (Most of the time module is a thin wrapper around C's <time.h>, as opposed to datetime, which is a friendly module designed for Python.) And then timegm is documented to return an integral type, so even if you got that far, it would all be for nothing.
I think this is correct... but if not I am sure someone will point out what I missed.It is not a perfect conversion given the number of fractional digits of the resulting timestamp but close enough for my need.  I am sure the ISO format is a point of debate, but the format matches the typical format I expect to encounter, this is of course the lack of the 'Z' qualifier.


Answer URL
https://docs.python.org/3/library/datetime.html#datetime.datetime.timestamp
