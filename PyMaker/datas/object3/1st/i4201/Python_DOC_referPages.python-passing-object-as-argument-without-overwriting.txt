Natural Text
Consider this code:This returns:I would expect this code to behave in the same way as this one:However the latter returns:I understand this is due to Python's way of passing arguments by assignment, as explained in this post, or this post.However, I can't figure out a way to work around the behavior exhibited in the first code, which is unwanted in the project I am working on. How can I pass an object as an argument to a function, return a madified object, and keep the original one untouched?
The simple solution is, just create or pass a copy. To do that you have to possibiltys. Either you create a .copy() method on the class or use the copy module.A copy method could look like this:The copy module works like this:You can use either way to create a function that simply returns a new copy of the argument:Edit: As many other answers say, my approach shown above doesn't work if you have mutable objects in mutable objects (as example an object of your class, that has another object of your class in its args attribute). In that case use the copy.deepcopy function instead:
You're explicitly modifying your object. Python supports this behavior by default, but if you want to prevent modification of your object you may want to update the __setattr__ to manage attribute modification.If you want to prevent the original object from modifying and you want to modify the object sent to the function you can add a __copy__ method to your object to be copyable in a way you like, then pass a copy of your object to the function using copy.copy().Demo: 
I would recommend deepcopy over copy since you want to make sure that all references to the original object are cut.


Answer URL
https://docs.python.org/3/library/copy.html
