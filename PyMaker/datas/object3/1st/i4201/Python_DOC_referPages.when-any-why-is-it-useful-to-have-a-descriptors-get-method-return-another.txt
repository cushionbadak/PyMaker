Natural Text
I had a container holding an object's methods, and possibly some descriptors. I wanted to test whether the descriptors had already been unwrapped or not by checking whether they had had a 'get' method. To my surprise, the __get__ method of a class-method returns an object which also has a __get__ method. Do you know when this behavior is useful? Does it have something to do with overriding class methods in a derived class?The Output Is:
The specific behavior you're seeing used to make sense because of unbound method objects. Back in Python 2, if you didFoo.useful_method would evaluate to an unbound method object, something similar to but slightly different from a function. Unbound method objects needed a __get__ so Bar().useful_method would auto-bind self, just like if Foo.useful_method had evaluated to a function instead of an unbound method during the definition of Bar.Unbound method objects and bound method objects were implemented with the same type, so bound methods shared the same __get__ method unbound methods had. For bound method objects, though, __get__ would just return the bound method object, as if no descriptor logic was involved.Now that unbound methods no longer exist, the __get__ method of method objects is superfluous, but it hasn't been removed.
For the specific question of why bound methods are descriptors (it should be obvious why classmethod objects are, right?), see user's answer.For the general question of why non-data descriptors need to be allowed: it would be more painful to write them. After all, the most obvious way to write a non-data descriptor is often to just return a function. And functions have to be non-data descriptors, or methods wouldn't work, defeating the whole reason descriptors were added to the language.For example, consider the "pure-Python classmethod" example in the HOWTO:Or, more simply, consider staticmethod, which even in the builtin implementation just returns the function itself when bound.Of course you could also implement any of these by building an object with a custom __call__ method, and sometimes that's worth doing (e.g., you could implement classmethod with partial, or with something that acts like partial, in which case there'd be no reason to add __get__)—but when a function just works, why not use a function?For the more abstract question of whether you could possibly find a use for this feature… Well, sure. Among the things you can do are:Create explicit 2.x-style unbound methods—that are then inspectable as methods, rather than as functions.Create "rebindable" methods as part of building a prototype object system. (Normal method objects just ignore their arguments in __get__, except for checking that either the second one is a type, or the second is None and the first is a type…)Create an object that mimics a function (rather than just a callable, the way methods, partials, etc. do), including being able to act as an unbound method, the result of a staticmethod, etc.None of these are things you're going to want to do very often, but they're also not things Python has any reason to prevent you from doing.


Answer URL
https://docs.python.org/3/howto/descriptor.html#static-methods-and-class-methods
