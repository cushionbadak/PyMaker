Natural Text
I'm trying to replicate (and if possible improve on) Python 2.x's sorting behaviour in 3.x, so that mutually orderable types like int, float etc. are sorted as expected, and mutually unorderable types are grouped within the output.Here's an example of what I'm talking about:My previous attempt at this, using a class for the key parameter to sorted() (see Why does this key class for sorting heterogeneous sequences behave oddly?) is fundamentally broken, because its approach ofTrying to compare values, andIf that fails, falling back to comparing the string representation of their typescan lead to intransitive ordering, as explained by BrenBarn's excellent answer.A naïve approach, which I initially rejected without even trying to code it, would be to use a key function that returns a (type, value) tuple:However, this doesn't do what I want. In the first place, it breaks the natural ordering of mutually orderable types:Secondly, it raises an exception when the input contains two objects of the same intrinsically unorderable type:... which admittedly is the standard behaviour in both Python 2.x and 3.x – but ideally I'd like such types to be grouped together (I don't especially care about their ordering, but it would seem in keeping with Python's guarantee of stable sorting that they retain their original order).I can work around the first of these problems for numeric types by special-casing them:... which works as far as it goes:... but doesn't account for the fact that there may be other distinct (possibly user-defined) types which are mutually orderable, and of course still fails with intrinsically unorderable types:Is there another approach which solves both the problem of arbitrary, distinct-but-mutually-orderable types and that of intrinsically unorderable types?
Stupid idea: make a first pass to divide all the different items in groups that can be compared between each other, sort the individual groups and finally concatenate them. I assume that an item is comparable to all members of a group, if it is comparable with the first member of a group. Something like this (Python3):This will have quadratic running time in the pathetic case that none of the items are comparable, but I guess the only way to know that for sure is to check all possible combinations. See the quadratic behavior as a deserved punishment for anyone trying to sort a long list of unsortable items, like complex numbers. In a more common case of a mix of some strings and some integers, the speed should be similar to the speed of a normal sort. Quick test:It seems to be a 'stable sort' as well, since the groups are formed in the order the incomparable items are encountered.
This answer aims to faithfully re-create the Python 2 sort order, in Python 3, in every detail.The actual Python 2 implementation is quite involved, but object.c's default_3way_compare does the final fallback after instances have been given a chance to implement normal comparison rules. This is after individual types have been given a chance to compare (via the __cmp__ or __lt__ hooks).Implementing that function as pure Python in a wrapper, plus emulating the exceptions to the rules (dict and complex numbers specifically) gives us the same Python 2 sorting semantics in Python 3:I incorporated handling dictionary sorting as implemented in Python 2, since that'd be supported by the type itself via a __cmp__ hook. I've stuck to the Python 2 ordering for the keys and values as well, naturally.I've also added special casing for complex numbers, as Python 2 raises an exception when you try sort to these:You may have to add more special cases if you want to emulate Python 2 behaviour exactly.If you wanted to sort complex numbers anyway you'll need to consistently put them with the non-numbers group; e.g.:Some test cases:
Not running Python 3 here, but maybe something like this would work.  Test to see if doing a "less than" compare on "value" creates an exception and then do "something" to handle that case, like convert it to a string.Of course you'd still need more special handling if there are other types in your list that are not the same type but are mutually orderable.
To avoid the use of exceptions and going for a type based solution, i came up with this:Note that an additional dictionary to hold the different types in list and a type holding variable (notImpl) is needed. Further note, that floats and ints aren't mixed here.Output:
One way for Python 3.2+ is to use functools.cmp_to_key().With this you can quickly implement a solution that tries to compare the values and then falls back on comparing the string representation of the types. You can also avoid an error being raised when comparing unordered types and leave the order as in the original case:Examples (input lists taken from Martijn Pieters's answer):This has the disadvantage that the three-way compare is always conducted, increasing the time complexity. However, the solution is low overhead, short, clean and I think cmp_to_key() was developed for this kind of Python 2 emulation use case.
We can solve this problem in the following way.Group by type.Find which types are comparable by attempting to compare a single representative of each type.Merge groups of comparable types.Sort merged groups, if possible.yield from (sorted) merged groupsWe can get a deterministic and orderable key function from types by using repr(type(x)). Note that the 'type hierarchy' here is determined by the repr of the types themselves. A flaw in this method is that if two types have identical __repr__ (the types themselves, not the instances), you will 'confuse' types. This can be solved by using a key function that returns a tuple (repr(type), id(type)), but I have not implemented that in this solution.The advantage of my method over Bas Swinkel's is a cleaner handling of a group of un-orderable elements. We do not have quadratic behavior; instead, the function gives up after the first attempted ordering during sorted()).My method functions worst in the scenario where there are an extremely large number of different types in the iterable. This is a rare scenario, but I suppose it could come up.
I'd like to recommend starting this sort of task (like imitation of another system's behaviour very close to this one) with detailed clarifying of the target system. How should it work with different corner cases. One of the best ways to do it - write a bunch of tests to ensure correct behaviour. Having such tests gives:Better understandind which elements should precede whichBasic documentingMakes system robust against some refactoring and adding functionality. For example if one more rule is added - how to get sure previous are not gets broken?One can write such test cases:sort2_test.pyNext one may have such sorting function:sort2.pyUsage is quite simple and is documented in tests:
Here is one method of accomplishing this:
I tried to implement the Python 2 sorting c code in python 3 as faithfully as possible.Use it like so: mydata.sort(key=py2key()) or mydata.sort(key=py2key(lambda x: mykeyfunc))
@martijn-pieters I don't know if list in python2 also has a __cmp__ to handle comparing list objects or how it was handled in python2.Anyway, in addition to the @martijn-pieters's answer, I used the following list comparator, so at least it doesn't give different sorted output based on different order of elements in the same input set.@per_type_cmp(list)def list_cmp(a, b):    for a_item, b_item in zip(a, b):        if a_item == b_item:            continue        return python2_sort_key(a_item) < python2_sort_key(b_item)    return len(a) < len(b)So, joining it with original answer by Martijn: PS: It makes more sense to create it as an comment but I didn't have enough reputation to make a comment. So, I'm creating it as an answer instead.


Answer URL
https://docs.python.org/3/library/functools.html#functools.cmp_to_key
