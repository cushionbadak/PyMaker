Natural Text
I want to know how to automate this part:In this code:Meaning perform specified amount of n + list1[index] == list2[index] checks automatically, instead of manually hard-coding those 3 comparing statements in there. And not loose any performance?I tried to replace this hard-coded if statement with this code down below, but it's a few times slower than the hardcoded way:So is there a way to:make it not hard-coded (use a variable's value to generate specified amount of check)retain performanceUpdate:The first list is always the same, the second list always has random values, so I want it to go through the specified range of numbers n (100, 101, 102, ...) and find the first n that would satisfy ALL the checks (find the 2nd list that has the same values as the first list) I want it to work with all the operations, like +,-,*,/,% etc
I think you are missing a key point here. You do not need to guess the size of your delta. You can rearrange n + list1[x] == list2[x] to read n == list2[x] - list1[x]. This way, there is only one or no values of n which make all the elements you want to compare equal to each other. You can do something like:This is a very simplified approach. One improvement that might help with performance would be to use itertools.islice instead of the index [1:amount_of_checks] since that would avoid allocating a new pair of lists.Your original code only allows n within a certain range. If this is something you want and not just an artifact, you can add that test as well:Update in response to your updateYou should be able to write all the operations besides modulo in the same way:For n - list1[x] == list2[x], use deltas = set(a + b ...For n * list1[x] == list2[x], use deltas = set(b / a ...For n / list1[x] == list2[x], use deltas = set(b * a ...For n**list1[x] == list2[x], use deltas = set(b ** (1 / a) ...etc.The problem with modulo is that it does not have a unique inverse operation. I do not remember enough number theory at this point to say if there will be a faster solution than just using @Steven's answer using a direct application of all, islice and zip, but I suspect not.
Use the builtin all function
This code is slow because the slices list1[:amount_of_checks] and list2[:amount_of_checks] iterate amount_of_checks times to create sublists that get thrown away.  It's particularly unfortunate when (n % a == b) evaluates to False on an early iteration because all is happy to shorcut evaluation in these situations, but you've already paid the performance penalty in the sublist creation.Use itertools.islice to avoid the performance penalty of creating the sublists:This can be streamlined by switching the order or zip and islicePut it all together and you get
Just change start and end according to your rangeHowever, of course this isn't quite as fast as writing out all the conditions by hand. If we measure execution time using timeit with some sample values, it becomes obvious:so keep that in mind (since I don't know how high your performance needs are)


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.islice
https://docs.python.org/3/library/itertools.html#itertools.islice
https://docs.python.org/3/library/itertools.html#itertools.islice
