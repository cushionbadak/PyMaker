Natural Text
Below is an example of decorator in python. I don't quite get how it actually works for the doubly decorated decorator.It seems that the flow should be (I am not sure about it):decorator is decorated, so it returns lambda fn: update_wrapper(decorator(fn),fn).n_ary=decorator(n_ary), then n_ary is now updated due to the function of update_wrapper(decorator(n_ary),n_ary)The third part should be the update of seq, but I don't understand when is the update_wrapper function used.
Decoration is just syntactic sugar for calling another function, and replacing the current function object with the result. The decorator dance you are trying to understand is over-using that fact. Even though it tries to make it easier to produce decorators, I find it doesn't actually add anything and is only creating confusion by not following standard practice.To understand what is going on, you can substitute the function calls (including decorators being applied) with their return values, and tracking the d references by imagining saved references to the original decorated function object:decorator=decorator(decorator) replaces the original decorator function with a call to itself. We'll just ignore the print() call here to make substitution easier. The decorator(decorator) call returns lambda fn:update_wrapper(d(fn),fn), where d is bound to the originaldecorator, so now we haveso update_wrapper() is not actually called yet. It'll only be called when this new decorator lambda is called.@decorator then calls the above lambda (the one calling _saved_reference_to_decorator(fr) and passing the result to update_wrapper()) and applies that lambda to the def n_ary(f) function:which expands to:which is:Now, update_wrapper() just copies metadata from the second argument to the first returning the first argument, so that then leaves:with the right __name__ and such set on the lambda function object.@n_ary is again a decorator being applied, this time to def seq(x, y), so we get:which can be expanded to:which if we take the return value of update_wrapper() iswith the metadata copied over from the original seq to whatever the original n_ary function returns.So in the end, all this dance gets you is update_wrapper() being applied to the return value from a decorator, which is the contained wrapper function.This is all way, way too complicated. The update_wrapper() function has a far more readable helper decorator already provided: @functools.wraps(). Your piece of code could be rewritten to:I simply replaced the @decorator decorator on the n_ary() function definition with a @functools.wraps() decorator on the contained wrapper function that is returned.


Answer URL
https://docs.python.org/3/library/functools.html#functools.update_wrapper
https://docs.python.org/3/library/functools.html#functools.wraps
