Natural Text
Basically, in the example below, why do the lambdas in f2 capture a reference to the list comprehension loop variable, but those in f3 "capture" (really, they just accept an argument) "the way we expect" lambda capture to work?The three lines outputted are:
Python closures always capture variables, not objects.In f2,all lambdas in the list capture the f variable, not the object the variable refers to at the time the lambda is defined. At the end of the comprehension, f refers to the last function in f1, so all lambdas in f2 find that function when they look up f.In f3each call to (lambda ff: lambda x: ff(x) + 1) creates a new local ff variable, and each lambda x: ff(x) + 1 captures a different ff variable. Unlike f, the ff variables are never reassigned, so the lambda x: ff(x) + 1 functions each see a different value of ff.
f is the same variable throughout the list comprehension. A simpler example:One common hack to work around this without the extra lambda wrapper is to use a default (as defaults are evaluated when the function is), but that can be confusing to those new to the idiom and you should generally split it out into a new function instead.
In the second example, f is a free variable in the lambdas in f2 which is bound into their enclosing scope (the list comprehension). The functions take f's value at the time they are called.    The functions in f2 are called in the following print statement, at which point f is already the third lambda from f1.Note that f is never in the scope in which f1, f2 and f3 are defined (presumably global or some broader function scope), but the lambdas always reference their enclosing scope which contains f.In contrast, ff is a parameter in the outer lambdas f3, but it is bound in the call to those outer lambdas, which happens in the list comprehension that defines f3.


Answer URL
https://docs.python.org/3/reference/executionmodel.html
