Natural Text
I have arbitrarily nested container object (e.g. lists and dicts).I would like to test if after calling a function, if the container object was mutated.I would like to also check for object identites.Here is a example of what I mean by check of object idenitites:The list [1,2] from a[0] was replaced by another list [1,2] but the lists are different objects. So it counts as mutated.Note:Previously, for a non-nested list, I could do something like this:Also, it is possible for the original container to be a dict instead of a list.Is this possible for nested containers? And if so, how do I do so?
The tricky bit is the "same instance" check. You could recursively create a hash code for the entire structure, or create a deep-copy and compare the two, but both will fail the "same instance" check.You could create a copy of the original list, as a reference for later, but more than that: You have to pair each element in the structure with its original id:Then, you can recursively check the structure and compare all the IDs and recursively compare the content of any sub-structures:Here's an example, along with some example modifications:Of course, both those methods are not complete and have to be extended for other structures, e.g. dict, set, tuple, etc. For set and dict, you might want to compare the sorted entries, but otherwise those should be very similar in nature.Note that technically it does not guarantee that the list is not modified, e.g. IDs could be reused after the original object with that ID has been garbage collected, but in the general case, the above should work.
There are two broad approaches: Verifying after the fact, or preventing mutating operations as they happen. Here's a sketch of a proxy class that prevents __setitem__ and similar methods from being accessed.In short, the mutating operations raise TypeError, and the getter operations ensure that the returned values are proxied (or are types that cannot contain other values).It's probably brittle in the face of non-standard containers such as defaultdict. It also needs to be comprehensive to work -- I forgot to include __delitem__ and __reversed__, for example, and list.extend; set arithmetic also acts as an escape hatch (but list slicing does not!). See Python Data Model. It may be more robust to list the allowed methods rather than the disallowed methods, but the code would be longer.


Answer URL
https://docs.python.org/3/reference/datamodel.html
