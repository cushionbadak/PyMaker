Natural Text
I know there are tons of resources out there about pointers and references (or rather: names, and bindings!) in Python, but I am struggling to understand one last point:I get that if a = 1 and if b = 1 than they both are 'bound' to the same exact 1 and will have the same id() (and therefore, I think memory address). I also get that if you set:because a and b are bound to the same list (object), and changes in one result in changes to another. Similarly, a[0] and b[0] are the same object. The list contains other objects with different ids - aka list identity is not bound to its contents.Okay. So far so good. I can accept that there are 'unborn' lists and numbers floating around waiting to initialized (only once though!), and that Python takes care of assigning a memory space for them once we want them. Why then, if I do:Shouldn't there only be a single 2-element list in Python's existence? This would be consistent to me (and then there is only a single 1, a single 2, a single 145...etc). Any explanation would appreciated - and that includes ones that relate it back to pointers (since I am also somewhat mystified about the decisions that are made at a memory management level, but I suppose that's the concern of Python's execution model and not me!)
You are being misled by an optimization present in CPython for ints, namely, int-caching. See this famous question. This is documented here:The current implementation keeps an array of integer objects for all  integers between -5 and 256, when you create an int in that range you  actually just get back a reference to the existing object.In almost every other instance, using a literal creates a new object. Indeed, use ints outside that range, and you'll see the normal behavior:And I need to repeat this almost every single day, but assignment in Python never copies.
= is an assignment.[1, 2, 3] and 10 are objects.if you write 10 or [1, 2, 3] python creates an objects. if you don't use an assignment, garbage collector will remove it. but if you do, python will assign a pointer to the newly created object to a given name/variable, ie:next, when you assign a variable to another variable, python will copy a pointer from the first variable, ie:b now contains pointer to the same object as a. but any newly created object, even if the content is the same, is a different object. so:now, depending on implementation (so it can change at any time and you should not depend on it) there might be a "shortcut" for speed efficiency, and objects representing some common values might be created by default. and that's why on some implementations id(1) == id(1), but what's confusing id(5555) != id(5555).


Answer URL
https://docs.python.org/3/c-api/long.html#c.PyLong_FromLong
