Natural Text
The new Python 3.6 f-strings seem like a huge jump in string usability to me, and I would love to jump in and adopt them whole heartedly on new projects which might be running on older interpreters. 2.7, 3.3-3.5 support would be great but at the very least I would like to use these in Python 3.5 code bases. How can I import 3.6's formatted string literals for use by older interpreters?I understand that formatted string literals like f"Foo is {age} {units} old" are not breaking changes, so would not be included in a from __future__ import ... call. But the change is not back-ported (AFAIK) I would need to be sure that whatever new code I write with f-strings is only ran on Python 3.6+ which is a deal breaker for a lot of projects.
Unfortunatly if you want to use it you must require Python 3.6+, same with the matrix multiplication operator @ and Python 3.5+ or yield from (Python 3.4+ I think)These made changes to how the code is interpreted and thus throw SyntaxErrors when imported in older versions. That means you need to put them somewhere where these aren't imported in older Pythons or guarded by an eval or exec (I wouldn't recommend the latter two!).So yes, you are right, if you want to support multiple python versions you can't use them easily.
future-fstrings brings f-strings to Python 2.7 scripts. (And I assume 3.3-3.5 based on the documentation.)Once you pip install it via pip install future-fstrings, you have to place a special line at the top of your code. That line is:Then you can use formatted string literals (f-strings) within your code:
here's what I use:it unpacks (**) the dict returned by locals() which has all your local variables as a dict {variable_name: value}Note this will not work for variables declared in an outer scope, unless you import it to the local scope with nonlocal (Python 3.0+).you can also useto include global variables in your string.
The f-strings are created by the interpreter upon tokening the f prefix - that feature alone will kill any compatibility chances.Your closest shot is to use the keyword formatting, like which can be more easily refactored upon the termination of requirement for compatibility. 
I just wrote a back-port compiler for f-string, called f2format. Just as you requests, you may write f-string literals in Python 3.6 flavour, and compile to a compatible version for end-users to run, just like Babel for JavaScript.f2format provides an intelligent, yet imperfect, solution of a back-port compiler. It shall replace f-string literals with str.format methods, whilst maintaining the original layout of source code. You can simply usef2format /path/to/the/file_or_directorywhich will rewrite all Python files in place. For instance,var = f'foo{(1+2)*3:>5}bar{"a", "b"!r}boo'will be converted tovar = ('foo{:>5}bar{!r}boo').format(((1+2)*3), ("a", "b"))String concatenation, conversion, format specification, multi-lines and unicodes are all treated right. Also, f2format will archive original files in case there're any syntax breaches.


Answer URL
https://docs.python.org/3/library/stdtypes.html?highlight=format_map#str.format_map
