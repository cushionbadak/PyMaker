Natural Text
I just tried an augmented assignment on a frozenset, and the result surprised me:This isn't supposed to happen, is it?  Aren't frozensets immutable?
Why are you surprised? You knew the term "augmented assignment" so there is no problem finding the "Python Data Model on augmented arithmetic assignments" (emphasis mine):These [__i***__] methods should attempt to do the operation in-place (modifying self) and return the result (which could be, but does not have to be, self). If a specific method is not defined, the augmented assignment falls back to the normal methods. For instance, if x is an instance of a class with an __iadd__() method, x += y is equivalent to x = x.__iadd__(y) . Otherwise, x.__add__(y) and y.__radd__(x) are considered, [...]So it has no __iand__ method so the code you perform is:The __and__ method however is defined by frozenset:However you lost your reference to the original frozenset: x:But that just follows the "Principle of least astonishment". You wanted the __and__ and you made it clear that you didn't want to keep your original x - an in-place operation also would have altered it!So again: Why did that surprise you?
Frozensets are immutable, except your assignment isn't mutating the original frozenset - you are just reassigning the variable x to the result of your binary operator &. As noted by user2357112 in the comments, x &= {'baz', 'qux', 'quux'} falls back on x = x  & {'baz', 'qux', 'quux'} after an __iand__ method is not found, leaving you with a non-mutating operation. This behavior can be seen for other augmented operations on immutable types that don't supply __iand__, e.g. 


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__iand__
