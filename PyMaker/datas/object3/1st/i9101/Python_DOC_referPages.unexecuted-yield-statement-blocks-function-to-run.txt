Natural Text
In the below simplified code, I would like to reuse a loop to do a preparation first and yield the result.However, the preparation (bar()) function is never executed.Is yield statement changing the flow of the function?
Because the foo definition contains a yield, it won't run like a normal function even if you call it like one (e.g. foo(prepare=True) ).Running foo() with whatever arguments will return a generator object, suitable to be iterated through. The body of the definition won't be run until you try and iterate that generator object.The new coroutine syntax puts a keyword at the start of the definition, so that the change in nature isn't hidden inside the body of the function.
The problem is that having a yield statement changes the function to returning a generator and alters the behavior of the function.Basically this means that on the call of the .next function of the generator the function executes to the yield or termination of the function (in which case it raises StopIteration exception). Consequently what you should have done is to ensure that you iterate over it even if the yield statement won't be reached. Like:In this case the loop will terminate immediately as no yield statement is being reached.
In my opinion, the actual explanation here is that:Python evaluates if condition lazily!And I'll explain:When you call to just like that, nothing happens, although you might expected that bar(x) will be executed 10 times. But what really happen is that 'no-one' demanding the return value of foo(prepare=True) call, so the if is not evaluated, but it might if you use the return value from foo.In the second call to foo, iterating the return value r, python has to evaluate the return value,and it does, and I'll show that:Case 1The output here is 'ENTER bar' 9 times. This means that bar is executed 9 times.Case 2In this case no 'ENTER bar' is printed, as expected.To sum everything up, I'll say that:There are some cases where Python perform Lazy Evaluation, one of them is the if statement.Not everything is evaluated lazily in Python, for example:vs.About lazy and eager evaluation in python, continue read here.


Answer URL
https://docs.python.org/3/library/asyncio-task.html
https://docs.python.org/3/library/asyncio-task.html
