Natural Text
I have a method in my Enemy class called huntPlayer.  It takes a player object p. Here it is:The enemies are randomly placed around a 2d top down plain, they randomly roam this plain.  I have calculated the hypotenuse which is shortest distance to the player = Enemy.dist2p -- When the dist2p value < 200. The enemy will move towards player, p.x and p.y respectively. My solution above is crude so therefore my problem is the enemy equally moves 1 place on the x or y axis resulting in a diagonal movement to each axis, then sliding along the axis until it reaches the player.  (The player is in a fixed position near the centre screen.)Can you help me fix the huntPlayer method/algorithm so the enemy follows the hypotenuse path to the player, rather than quickest path to x/y axis?EDIT: If you need any further info I may have left out, let me know. 
Moving on the hypotenuse will most likely require your object to move less than one pixel each frame in either the y or x-axis, and since rects only can hold integers you'd need a new attribute position which contains the position of the sprite in float precision. You can use pygame.math.Vector2 to create a vector with useful methods such as normalize() and adding, subtracting, multiplying with other vectors etc.Assuming you've created an attribute self.position = pygame.math.Vector2(0, 0) (or whatever position you want it to start on) you could do something like this: By subtracting the player's position with the enemy's position, you'll get a vector that points from the enemy to the player. If we would to add the direction vector to our position we would teleport to the player immediately. Instead we normalize the vector (making it to length 1 pixel) and multiply our speed attribute. The newly created vector will be an vector pointing towards the player with the length of our speed.Full exampleResult
Since we want to move along the hypotenuse we can use Pythagoras theorem. Here's a brief snippet the should give you the general idea.I'll use p.x, p.y for the player's position and e.x, e.y for the enemy's position. You need to add some extra code to this to make sure that d isn't zero, or you'll get a division by zero error, but that only happens when the enemy reaches the player, so I assume you want to do something special when that happens anyway. :)I should mention that this technique works best if the positions are floats, not integer pixel coordinates.
Just calculating the distance based on the hypotenuse is not enough. You must pass the coordinates of the enemy into the function and calculate the slope or pass the slope also into the function by value. Then you should move to one of 8 pixels around about your current position where the one you move to is most representative of the path of direction to the enemy. Essentially you move diagonally if the tan of the angle is less than 2 or great that 1/2 otherwise you move in a vertical or horizontal direction. You need to draw a 3x3 set of pixels to see what is actually going on if you can't visualise it.


Answer URL
https://docs.python.org/3/library/math.html#math.hypot
