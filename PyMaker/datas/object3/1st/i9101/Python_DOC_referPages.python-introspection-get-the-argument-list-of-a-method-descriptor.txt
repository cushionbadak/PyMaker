Natural Text
A code illustration as an intro to my questions:It seems that the only way for me to find the signature of datetime.datetime.replace while I code is to look it up in the doc: date.replace(year, month, day).The only introspection part that seems to work:I've examined how the Jupyter function arglist tool-tip works, they have the exact same problem, i.e. no arglist available for datetime.datetime.replace.So here are the questions:Is it still possible to get the argument list somehow? Maybe I could install the C sources for datetime and connect them via the __file__ attribute?Is it possible to annotate a <type 'method_descriptor'> with the arglist information? In that case, I could parse the linked doc's markdown definition and automatically annotate the built-in module functions.
No, you can't get more information; installing the C sources would not give you easy access to the same. That's because most methods defined in C code do not actually expose this information; you'd have to parse out a rather cryptic piece of C code:The re.findall() function is a pure Python function, so is introspectable.I said most methods defined in C, because as of Python 3.4 and up, methods that use the new Argument Clinic preprocessor will include a new __text_signature__ attribute, which the internal inspect._signature_fromstr() function can parse. This means that even for such C-defined methods, you can introspect the arguments:Also see What are __signature__ and __text_signature__ used for in Python 3.4The datetime module has not yet received much Argument Clinic love. We'll have to be patient, or if you really care a lot about this, supply patches that convert the module to using Argument Clinic.If you want to see what modules do have support already, look at the Modules/clinic subdirectory which contains the generated clinic output; for the datetime module, only datetime.datetime.now() is currently included. That method defines a clinic block:making the method introspectable:There is no way to directly attach information to those C functions and methods that are not introspectable; they don't support attributes either.Most autocomplete solutions that want to support such objects use separate data structures where the information is maintained independently (with all the inherent risks of the data getting out of sync). Some of these are available for your own purposes:The Komodo IDE code intelligence library (open source, used other editors too) uses the CIX format to encode this data; you could download the Python 3 catalog. Unfortunately for your specific example, the datetime.replace() function signature has not been fleshed out either:The new Python 3.5 type hinting syntax also needs to know what types of arguments objects expect, and to this end stub files need to be provided for objects that can't be introspected. The Python typeshed project provides these. This includes all argument names for the datetime module:You'd have to parse such a file yourself; they can't always be imported as the stubs reference types not yet defined, rather than use forward references:You may be able to work around that by using a pre-defined module object and globals, then iterating on name errors until it imports though. I'll leave that as an exercise for the reader. Mypy and other type checkers don't try to execute the code, they merely build an AST. 
The issue you are having is caused by the fact that C-coded functions do not expose their signature. You'll find more information on this answer to "How to find out the arity of a method in Python".In your case, re.findall is defined in Python (see def findall(pattern, string, flags=0):) while datetime.datetime.replace is written in C (see datetime_replace(PyDateTime_DateTime *self, PyObject *args, PyObject *kw)).You can see see using the different attributes available (and the __code__ attribute in particular) on the function with the dir builtin :Usually, the help gives you what you need (based on the __doc__ attribute) but in your case, it doesn't seem to help much:Also, an idea could be to try to set the __code__ attribute to something corresponding to your needs but you can't tweak much on builtin types without subclassing.


Answer URL
https://docs.python.org/3/howto/clinic.html
