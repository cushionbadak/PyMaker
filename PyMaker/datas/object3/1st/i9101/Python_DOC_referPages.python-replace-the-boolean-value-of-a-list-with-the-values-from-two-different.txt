Natural Text
This question already has an answer here:Merge two or more lists with given order of merging                    2 answers                I have one list with boolean values likeand two different lists for example like:I just want to replace True with the values from car and False with the values from a.or make a new list with the sequence from lyst and values from car and a.The result should be my code so far:but this creates a list match longer than 5.How can i do this?
Ok, I couldn't help myself:This makes use of some boolean expression features:a boolean and expression will NOT evaluate the second operand if the first operand is Falsea boolean and expression will return the second operand (the actual object) if both operands evaluate to Truea boolean or expression will return the first object that evaluates to TrueA potential problem would be if any items in car or a evaluate to False.  Also this isn't as readable as the ternary in the first solution.But it was fun.I guess I'll add that after looking at this again, I probably shouldn't have reassigned the original list names - I should have chosen something different for the iterator names.  Once exhausted, the iterators cannot be reset and since the list names were reassigned, the original list information is lost.
Assuming that there are the correct number of True and False entries in lyst, you can do this efficiently by creating iterators of the other two lists. This is more efficient than poping from the front of the lists.outputThe selector[b] construction works because False has a numeric value of 0, and True has a numeric value of 1, so we can use the boolean values of lyst to index into the selector list.TimingsI decided to write a timeit script to compare the speeds of the various algorithms posted here, as well as vaultah's code from the dupe target question.To test these algorithms I've put them all into functions. To get accurate timing data timeit runs the function multiple times. The algorithms that use .pop consume the lists they pop from, so I had to add code to those functions to create copies of those lists. Obviously, that copying process slows those functions down, and in some applications it may not matter that the input data lists get destroyed, but I feel that the copying time needs to be included to fairly compare the speeds of these functions for more general use.timeit measures wall clock time not CPU time, so the timings will be affected by the other processes running on the system. So when running timeit code it's a good idea to reduce the system load as much as possible. Ideally, you should shut down Net access, or at least avoid using your browser while the tests are running. And definitely don't listen to music or watch videos. :)The code below runs on Python 2.6+ as well as Python 3. I tested it on Python 2.6.6 and Python 3.6.0.Python 3 outputPython 2 outputThese results are from my rather ancient 32 bit single-core 2GHZ machine with 2GB of RAM running a Debian derivative of Linux.

My first idea is to use a dict to choose between the True values (car) and the False values (a).Since, the values are in order, you can make an iteration.Here is a solution which use iter() and next() functions which are efficient:You can generalize this solution if you have more complex choices than True/False.
Code by @Alex is a great one, but complexity is a little bad due to that pop(0) operation. To avoid that-`As for other answers, I am a bit surprised to see the use of all those complex syntax and data structures for such a simple task.
Just another option much like the one from @AlexL but with the if statements replaced by a dictionary look-up.


Answer URL
https://docs.python.org/3/library/timeit.html
