Natural Text
The following code converts values to functions:However the following snippet fails:Is this aberration a parameter name binding artifact?
This is about scope. Functions define new scope; iterations of a list comprehension, like for loops and other block statements, do not.The Python Programming FAQ question Why do lambdas defined in a loop with different values all return the same result? explains this at a high level. I'll try a different explanation, skimming over the high level and then diving deeper.You first version is calling a function that returns lambda: x for each element. Because functions define new scopes, each such returned function has its own separate x.Your second version is just defining a lambda: x for each element. Because you're doing this all in the same scope, each such defined function has the same x. In fact, because x is found at global scope, it's the global x that each one has, as you can see by doing this:You can fix this by defining and calling a function, making the second version equivalent to the first, or work around it in the usual ways, such as the "default parameter hack":It's worth looking at what's stored in the function objects to see the difference:So, here, each function is a closure with a single cell, each named x, but each holding a reference to a different int objects (the value x was bound to each time through the loop).So these aren't closures at all, just functions that reference a global variable.Here, no closure, and no globals; we've got a local variable bound to the first parameter whose default value is 1 or 2, respectively. Since you're calling func with no arguments, you get the default value.Alternatively, you can look at the disassembly:But I doubt there are too many people who know Python bytecode, but don't know the inspectable values of functions, so… this probably doesn't help too much.Finally, this is all probably a lot easier to think about—and maybe to read—if you move the function-defining functions out-of-line, and use def instead of lambda.Now both a and b are doing the same thing—calling a function that returns a function—and there's nothing to get confused about.


Answer URL
