Natural Text
Python 3.4 introduces a new module enum, which adds an enumerated type to the language. The documentation for enum.Enum provides an example to demonstrate how it can be extended:This example also demonstrates a problem with Enum: in the surface_gravity() property method, a constant G is defined which would normally be defined at class level - but attempting to do so inside an Enum would simply add it as one of the members of the enum, so instead it's been defined inside the method.If the class wanted to use this constant in other methods, it'd have to be defined there as well, which obviously isn't ideal.Is there any way to define a class constant inside an Enum, or some workaround to achieve the same effect?
This is advanced behavior which will not be needed in 90+% of the enumerations created.According to the docs:The rules for what is allowed are as follows: _sunder_ names (starting and ending with a single underscore) are reserved by enum and cannot be used; all other attributes defined within an enumeration will become members of this enumeration, with the exception of __dunder__ names and descriptors (methods are also descriptors).So if you want a class constant you have several choices:create it in __init__add it after the class has been createduse a mixincreate your own descriptorCreating the constant in __init__ and adding it after the class has been created both suffer from not having all the class info gathered in one place.Mixins can certainly be used when appropriate (see dnozay's answer for a good example), but that case can also be simplified by having a base Enum class with the actual constants built in.First, the constant that will be used in the examples below:And the single-use Enum example:And, finally, the multi-use Enum example:Note:The Constant G really isn't.  One could rebind G to something else:If you really need it to be constant (aka not rebindable), then use the new aenum library [1] which will block attempts to reassign constants as well as Enum members.1 Disclosure:  I am the author of the Python stdlib Enum, the enum34 backport, and the Advanced Enumeration (aenum)  library.
The most elegant solution (IMHO) is to use mixins / base class to provide the correct behavior.base class to provide the behavior that's needed for all implementation that's common to e.g. Satellite and Planet.mixins are interesting if you decide to provide optional behavior (e.g. Satellite and Planet may have to provide a different behavior)Here is an example, where you first define your behavior:Then create your Enum with the correct base classes / mixins.
The reason why @property does NOT work and classconstant DOES work is quite simple, and explained in the answer hereThe reason that the actual property object is returned when you access  it via a class Hello.foo lies in how the property implements the  __get__(self, instance, owner) special method. If a descriptor is accessed on an instance, then that instance is passed as the  appropriate argument, and owner is the class of that instance.On the other hand, if it is accessed through the class, then instance  is None and only owner is passed. The property object recognizes this  and returns self.Thus, the code in classproperty is actually a generalization of property, lacking the if instance is None part.
A property can be used to provide most of the behaviour of a class constant:This would be a little unwieldy if you wanted to define a large number of constants, so you could define a helper function outside the class:... and use it as follows:One limitation of this approach is that it will only work for instances of the class, and not the class itself:
TLDR; NO, it can not be done inside an Enum class. This said, as the other answers showed, there are ways to get such class owned values associated to an Enum (i.e. via class inheritance / mixins) but such values are not "defined .. inside an Enum".    


Answer URL
https://docs.python.org/3/library/enum.html
