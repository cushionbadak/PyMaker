Natural Text
I have an abstract base class Bicycle:and a subclass MountainBike:The following code will cause a recursion error, but if I remove self from the super().__init__(self), the call to __str__(self): works.Question:I only discovered this error when I implemented the __str__(self): In Python 3.x when calling the parent constructor from the child with no arguments, is passing self, necessary?Suppose MountainBike now sets the cadence, gear, speed this means in my subclass the constructor will look like this:notice, self isn't being passed in the super because to my knowledge, it can throw the variable assignments off. Is this assumption correct?
self is passed implicitly to the super call, so adding it explicitly sends it twice:That ends up calling Bicycle(self, self), which is the same as Bicycle(self, cadence=self).Later on, you have probably tried convert your instance to str (e.g. to print it), so this was called:That code tried to convert self._cadence to a string and self._cadence is self because of the previous error, so it continues in an endless recursion (until the recursion exception).Note that super() takes two forms: with arguments and without arguments, so there are two correct ways to fix the code.The Python 3 way (without arguments):The old Python 2 way, which is more explicit:Both do the same, i.e. they give you the bound __init__ method which already has the implicit self.See also here: https://docs.python.org/3/library/functions.html#super


Answer URL
https://docs.python.org/3/library/functions.html#super
https://docs.python.org/3/reference/datamodel.html#object.__init__
