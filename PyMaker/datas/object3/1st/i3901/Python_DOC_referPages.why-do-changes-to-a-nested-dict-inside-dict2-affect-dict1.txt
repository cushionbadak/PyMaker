Natural Text
This question already has an answer here:assigning value in python dict (copy vs reference)                    2 answers                I don't understand these cases:In the case above the content of d1 is changed after the variable content is updated.However in this case d1 is not altered even if the variable content was changed. I don't understand why... any idea?
see shallow vs deep copy.The copy here is a shallow copy so the first level entries are copies but the nested structures are references.A shallow copy constructs a new compound object and then (to the    extent possible) inserts references into it to the objects  found in    the original. A deep copy constructs a new compound object and then,    recursively, inserts copies into it of the objects found in the  original.
The key difference between your two snippets is that content['a']['v'] = 3 is a completely different operation than content['a'] = 3. In the first case, you're modifying the inner dictionary by changing its v key. In the latter case, you're replacing the value in the dictionary without modifying it.It's confusing when everything's a dictionary, so let's replace the dictionaries with variables and instances of a class:The key points to note here are thatk1_a = a doesn't make a copy of the Person; similar to how d1['k1'].update(content) doesn't make a copy of the {'v': 1} dict.a.name = 'Aaron' modifies the Person; similar to how content['a']['v'] = 3 modifies the inner dict.The equivalent of your 2nd snippet looks like this:This time, no object is ever modified. All we're doing is overwriting the value of the a variable, exactly how content['a'] = 3 overwrites the value of the a key in your dict.If you don't want the changes in the inner dicts to be reflected in other dicts, you have to copy them with copy.deepcopy:
If we replace the update() with a simple assignment:We get:(Which is different from what update does in your example.) This is because update accepts an iterable (e.g. a dictionary) and copies the key value pairs inside. It's equivalent to doing:And of course, the int values are immutables and so their reassignment does not affect the original.


Answer URL
https://docs.python.org/3/library/copy.html
https://docs.python.org/3/library/copy.html#copy.deepcopy
