Natural Text
I would like to see what is the best way to determine the current script directory in python?I discovered that, due to the many ways of calling python code, it is hard to find a good solution.Here are some problems:__file__ is not defined if the script is executed with exec, execfile__module__ is defined only in modulesUse cases: ./myfile.pypython myfile.py./somedir/myfile.pypython somedir/myfile.pyexecfile('myfile.py') (from another script, that can be located in another directory and that can have another current directory.I know that there is no perfect solution, but I'm looking for the best approach that solves most of the cases.The most used approach is os.path.dirname(os.path.abspath(__file__)) but this really doesn't work if you execute the script from another one with exec().WarningAny solution that uses current directory will fail, this can be different based on the way the script is called or it can be changed inside the running script.
is indeed the best you're going to get.It's unusual to be executing a script with exec/execfile; normally you should be using the module infrastructure to load scripts. If you must use these methods, I suggest setting __file__ in the globals you pass to the script so it can read that filename.There's no other way to get the filename in execed code: as you note, the CWD may be in a completely different place.
If you really want to cover the case that a script is called via execfile(...), you can use the inspect module to deduce the filename (including the path).  As far as I am aware, this will work for all cases you listed:
It works on CPython, Jython, Pypy. It works if the script is executed using execfile() (sys.argv[0] and __file__ -based solutions would fail here). It works if the script is inside an executable zip file (/an egg). It works if the script is "imported" (PYTHONPATH=/path/to/library.zip python -mscript_to_run) from a zip file; it returns the archive path in this case. It works if the script is compiled into a standalone executable (sys.frozen). It works for symlinks (realpath eliminates symbolic links). It works in an interactive interpreter; it returns the current working directory in this case.
In Python 3.4+ you can use the simpler pathlib module:
Just use os.path.dirname(os.path.abspath(__file__)) and examine very carefully whether there is a real need for the case where exec is used.  It could be a sign of troubled design if you are not able to use your script as a module.  Keep in mind Zen of Python #8, and if you believe there is a good argument for a use-case where it must work for exec, then please let us know some more details about the background of the problem.
The os.path... approach was the 'done thing' in Python 2.In Python 3, you can find directory of script as follows:
First.. a couple missing use-cases here if we're talking about ways to inject anonymous code..But, the real question is, what is your goal - are you trying to enforce some sort of security? Or are you just interested in whats being loaded.If you're interested in security, the filename that is being imported via exec/execfile is inconsequential - you should use rexec, which offers the following:This module contains the RExec class,  which supports r_eval(), r_execfile(),  r_exec(), and r_import() methods, which   are restricted versions of the standard  Python functions eval(), execfile() and   the exec and import statements. Code   executed in this restricted environment  will only have access to modules and   functions that are deemed safe; you can   subclass RExec add or remove capabilities as  desired.However, if this is more of an academic pursuit.. here are a couple goofy approaches that youmight be able to dig a little deeper into.. Example scripts:./deep.py./deeper.py/tmp/deepest.py./codespy.pyOutputOf course, this is a resource-intensive way to do it, you'd be tracingall your code.. Not very efficient. But, I think it's a novel approachsince it continues to work even as you get deeper into the nest.You can't override 'eval'. Although you can override execfile().Note, this approach only coveres exec/execfile, not 'import'.For higher level 'module' load hooking you might be able to use usesys.path_hooks (Write-up courtesy of PyMOTW).Thats all I have off the top of my head. 
Here is a partial solution, still better than all published ones so far.Now this works will all calls but if someone use chdir() to change the current directory, this will also fail.Notes: sys.argv[0] is not going to work, will return -c if you execute the script with python -c "execfile('path-tester.py')"I published a complete test at https://gist.github.com/1385555 and you are welcome to improve it.
This should work in most cases:
This gives you the directory of the script at the top of the stack (i.e. the one being executed - not Python's, which is usually the first executed, returning C:/)
Woulddo what you want?  I'm not sure what exactly you mean by the "current script directory".  What would the expected output be for the use cases you gave?
Hopefully this helps:- If you run a script/module from anywhere you'll be able to access the __file__ variable which is a module variable representing the location of the script. On the other hand, if you're using the interpreter you don't have access to that variable, where you'll get a name NameError and os.getcwd() will give you the incorrect directory if you're running the file from somewhere else. This solution should give you what you're looking for in all cases:I haven't thoroughly tested it but it solved my problem.
just pwdat jupyter notebook : pwd + shift + enterat spyder : pwd + F9


Answer URL
https://docs.python.org/3/library/pathlib.html
https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.joinpath
