Natural Text
To give a little background, I am coding a genetic algorithm to solve the Traveling Salesman Problem (TSP). In my population, I have an ordered list of paths from shortest to longest (fittest to least fit), and their respective distances, like this:After the population is ordered by their fitness, I need to kill half of them randomly, but in such a fashion that the fitter the member, the better their chance of surviving.I've tried using random.choices() and passing a list with chances of probability (bias) into the weights parameter, and my desired size of half the original population as k like this:The problem with the code above is that it produces duplicates in my list, and it's very messy to get rid of them and keep the population size at 50%.I've also tried using the np.random.choices() from the numpy library, but it requires the list that I am passing to be 1D, and the list of weights and biases to add up to 1.Is there any other way to do this?
I would still use np.random.choice(). Solve the first problem by asking np.random.choice() to choose the index of the path rather than the path itself. Solve the second problem by scaling the weights so they sum to 1.
Choose one element at a time, put it into a set to guarantee it's unique, and continue until you have enough elements:
EDIT: Actually, I would recommend to just use the following:
For no duplicates you have to use random shuffle. Algorithm is called weighted random shuffle, and is solved in http://nicky.vanforeest.com/probability/weightedRandomShuffling/weighted.htmlC++ version is right hereC++. Weighted std::shuffleUPDATE: Fast weighted random shuffle copied from first link verbatim


Answer URL
https://docs.python.org/3/library/random.html#random.choices
