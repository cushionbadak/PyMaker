Natural Text
This question already has an answer here:Two methods inherited from one method in class are different in instances, aren't they?                    1 answer                If I have a this evaluates to True:but this evaluates to False:as doesWhy?I found that getattr(a, 'foo') and a.foo both are represented by So no hint there....
At least in CPython, bound methods are implemented as an instance of a class method. Every time you ask for the value of a bound function, you get a new instance of this class.All this class does is store a reference to the instance and the unbound function, and when you call the class it calls the unbound function with the stored instance (along with your other arguments).Unbound functions, like A.foo, are just regular old functions - no new instances of proxy classes are being constructed, so identity works as you expect.The reason for this difference is that the semantic meaning of a.foo depends on two things, the value of a and the value of A.foo. In order to be able to get this meaning at any point in time later, both of these values need to be stored. This is what the method class does.Conversely, the meaning of A.foo depends only on a single value: A.foo. So no additional work is required to store anything, and the value itself is used.You might consider the idea of pre-allocating bound method instances, so that a.foo always returns the same immutable object - but given the dynamic nature of Python, it is simpler and cheaper to just construct a new one each time, even if they could be the same.
To add to @GManNickG answer:will return True.
Some objects stored in classes are descriptors, which don't follow normal rules for object lookups. The foo method you're dealing with in your example is one (function objects are descriptors).A descriptor is an instance of a class that defines a __get__ (and optionally __set__ and __delete__) method(s). Those methods control what happens when you look up the desciptor on an instance of the class it's stored in.I think an example will make this more clear:A __get__ method doesn't need to return the same thing every time it's called. In fact, it usually won't. In the specific case of functions being used as descriptors (i.e. methods), a new "bound method" object will be created each time you look the function up. Thus the is operator will not see multiple bound methods as the same object, even though they may be binding the same function to the same instance.


Answer URL
https://docs.python.org/3/howto/descriptor.html
https://docs.python.org/3/howto/descriptor.html#functions-and-methods
