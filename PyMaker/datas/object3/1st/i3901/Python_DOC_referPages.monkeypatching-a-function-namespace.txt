Natural Text
Inspired by "Define @property on function", I tried to override a function's namespace:Why can f.k1 resolve, but f.k2 can't?
Short version: Because CPython's PyDict_GetItem function isn't subclass friendly (it's not intended to be, to be clear; PyDict_* functions are all specialized to PyDict_Object itself, not generalized mappings).Long version: Retrieving an attribute invokes PyObject_GetAttr. For classes which don't explicitly define a custom tp_getattro or tp_getattr (and PyFunction_Type does not), this ends up calling PyObject_GenericGetAttr. Assuming nothing is found on the class itself, PyObject_GenericGetAttr (well, the private API function that implements it) retrieves __dict__ as normal, then calls PyDict_GetItem to retrieve the value. PyDict_GetItem explicitly uses dict's C-level internals to perform the access, bypassing any custom __getitem__ you might have defined. So your custom __getitem__ is never invoked; for all practical purposes, your dict subclass is just a dict.I originally hoped that you might be able to make this particular case work via the officially supported __missing__ hook, but it turns out that's only invoked when the equivalent of __getitem__ (dict_subscript) is invoked, not through the C level direct access APIs like PyDict_GetItem (which don't go through dict_subscript at all).Basically, CPython seems to have made a choice to prioritize performance over complete flexibility here. Any dict subclass used as __dict__ will be accessed as if it were a plain dict (which might get a little screwy if the subclass is doing some magic to store one value while pretending it stores a different value, since the magic is bypassed), and all mappings that aren't dict subclasses are rejected at time of assignment (you get a TypeError when you try to assign them to f.__dict__).
The first sentence in the documentation for __getitem__ reads:  "Called to implement evaluation of self[key]."  You are assuming (hoping) that the evaluation of f.k1 performs the explicit operation f.__dict__["k1"], but it doesn't.  If you put a print statement in the first line of __getitem__ you will see that this function never gets called by your code.I'm not sure why this is, but I suspect that it's for performance reasons.  In any case, I can't think of a good use case for replacing a function's __dict__.  There are way too many ways that can fail.


Answer URL
https://docs.python.org/3/reference/datamodel.html?highlight=__missing__#object.__missing__
