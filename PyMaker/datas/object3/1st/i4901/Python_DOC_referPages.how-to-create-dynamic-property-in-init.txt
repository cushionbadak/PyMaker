Natural Text
The goal is to create a mock class which behaves like a db resultset.So for example, if a database query returns, using a dict expression, {'ab':100, 'cd':200}, then I would like to see: At first I thought maybe I could do it this way:but c.ab returns a property object instead.Replacing the setattr line with k = property(lambda x: vs[i]) is of no use at all.So what is the right way to create an instance property at runtime?P.S. I am aware of an alternative presented in How is the __getattribute__ method used?
I suppose I should expand this answer, now that I'm older and wiser and know what's going on.  Better late than never.You can add a property to a class dynamically.  But that's the catch: you have to add it to the class.A property is actually a simple implementation of a thing called a descriptor.  It's an object that provides custom handling for a given attribute, on a given class.  Kinda like a way to factor a huge if tree out of __getattribute__.When I ask for foo.b in the example above, Python sees that the b defined on the class implements the descriptor protocolâ€”which just means it's an object with a __get__, __set__, or __delete__ method.  The descriptor claims responsibility for handling that attribute, so Python calls Foo.b.__get__(foo, Foo), and the return value is passed back to you as the value of the attribute.  In the case of property, each of these methods just calls the fget, fset, or fdel you passed to the property constructor.Descriptors are really Python's way of exposing the plumbing of its entire OO implementation.  In fact, there's another type of descriptor even more common than property.The humble method is just another kind of descriptor.  Its __get__ tacks on the calling instance as the first argument; in effect, it does this:Anyway, I suspect this is why descriptors only work on classes: they're a formalization of the stuff that powers classes in the first place.  They're even the exception to the rule: you can obviously assign descriptors to a class, and classes are themselves instances of type!  In fact, trying to read Foo.b still calls property.__get__; it's just idiomatic for descriptors to return themselves when accessed as class attributes.I think it's pretty cool that virtually all of Python's OO system can be expressed in Python.  :)Oh, and I wrote a wordy blog post about descriptors a while back if you're interested.
The goal is to create a mock class which behaves like a db resultset.So what you want is a dictionary where you can spell a['b'] as a.b?That's easy:
It seems you could solve this problem much more simply with a namedtuple, since you know the entire list of fields ahead of time.If you absolutely need to write your own setter, you'll have to do the metaprogramming at the class level; property() doesn't work on instances.
You don't need to use a property for that. Just override __setattr__ to make them read only.Tada.
I asked a similary question on this Stack Overflow post to create a class factory which created simple types. The outcome was this answer which had a working version of the class factory.Here is a snippet of the answer:You could use some variation of this to create default values which is your goal (there is also an answer in that question which deals with this).
How to add property to a python class dynamically?Say you have an object that you want to add a property to. Typically, I want to use properties when I need to begin managing access to an attribute in code that has downstream usage, so that I can maintain a consistent API. Now I will typically add them to the source code where the object is defined, but let's assume you don't have that access, or you need to truly dynamically choose your functions programmatically.Create a classUsing an example based on the documentation for property, let's create a class of object with a "hidden" attribute and create an instance of it:In Python, we expect there to be one obvious way of doing things. However, in this case, I'm going to show two ways: with decorator notation, and without.  First, without decorator notation. This may be more useful for the dynamic assignment of getters, setters, or deleters.Dynamic (a.k.a. Monkey Patching)Let's create some for our class:And now we assign these to the property. Note that we could choose our functions programmatically here, answering the dynamic question:And usage:DecoratorsWe could do the same as we did above with decorator notation, but in this case, we must name the methods all the same name (and I'd recommend keeping it the same as the attribute), so programmatic assignment is not so trivial as it is using the above method:And assign the property object with its provisioned setters and deleters to the class:And usage:
You cannot add a new property() to an instance at runtime, because properties are data descriptors.  Instead you must dynamically create a new class, or overload __getattribute__ in order to process data descriptors on instances.
Not sure if I completely understand the question, but you can modify instance properties at runtime with the built-in __dict__ of your class:
For those coming from search engines, here are the two things I was looking for when talking about dynamic properties:__dict__ is good if you want to put dynamically created properties. __getattr__ is good to only do something when the value is needed, like query a database. The set/get combo is good to simplify the access to data stored in the class (like in the example above).If you only want one dynamic property, have a look at the property() built-in function.
The best way to achieve is by defining __slots__. That way your instances can't have new attributes.That prints 12That gives: AttributeError: 'C' object has no attribute 'ab'
Just another example how to achieve desired effectSo now we can do stuff like:
This seems to work(but see below):If you need more complex behavior, feel free to edit your answer.editThe following would probably be more memory-efficient for large datasets:
To answer the main thrust of your question, you want a read-only attribute from a dict as an immutable datasource:The goal is to create a mock class which behaves like a db resultset.So for example, if a database query returns, using a dict expression,  {'ab':100, 'cd':200}, then I would to seeI'll demonstrate how to use a namedtuple from the collections module to accomplish just this:returns 100
And the output is:
You can use the following code to update class attributes using a dictionary object:
Extending the idea from kjfletchOutput:
Although many answers are given, I couldn't find one I am happy with. I figured out my own solution which makes property work for the dynamic case. The source to answer the original question:
Only way to dynamically attach a property is to create a new class and its instance with your new property.  
I recently ran into a similar problem, the solution that I came up with uses __getattr__ and __setattr__ for the properties that I want it to handle, everything else gets passed on to the originals.
A lot of the supplied answers require so many lines per property, ie / and / or - what I'd consider an ugly or tedious implementation because of repetitiveness required for multiple properties, etc. I prefer keeping boiling things down / simplifying them until they can't be simplified anymore or until it doesn't serve much purpose to do so.In short: in completed works, if I repeat 2 lines of code, I typically convert it into a single line helper function, and so on... I simplify math or odd arguments such as ( start_x, start_y, end_x, end_y ) to ( x, y, w, h ) ie x, y, x + w, y + h ( sometimes requiring min / max or if w / h are negative and the implementation doesn't like it, I'll subtract from x / y and abs w / h. etc.. ).Overriding the internal getters / setters is an ok way to go, but the problem is you need to do that for every class, or parent the class to that base... This doesn't work for me as I'd prefer to be free to choose the children / parents for inheritance, child nodes, etc.I have created a solution which answers the question without using a Dict data-type to supply the data as I find that to be tedious to enter the data, etc...My solution requires you to add 2 extra lines above your class to create a base class for the class you want to add the properties to, then 1 line per and you have the option to add callbacks to control the data, inform you when data changes, restrict the data which can be set based on value and / or data-type, and much more.You also have the option to use _object.x, _object.x = value, _object.GetX( ), _object.SetX( value ) and they are handled equivalently.Additionally, the values are the only non-static data which are assigned to the class instance, but the actual property is assigned to the class meaning the things you don't want to repeat, don't need to be repeated... You can assign a default value so the getter doesn't need it each time, although there is an option to override the default default value, and there is another option so the getter returns the raw stored value by overriding default returns ( note: this method means the raw value is only assigned when a value is assigned, otherwise it is None - when the value is Reset, then it assigns None, etc.. )There are many helper functions too - the first property which gets added adds 2 or so helpers to the class for referencing the instance values... They are ResetAccessors( _key, .. ) varargs repeated ( all can be repeated using the first named args ) and SetAccessors( _key, _value ) with the option of more being added to the main class to aide in efficiency - the ones planned are: a way to group accessors together, so if you tend to reset a few at a time, every time, you can assign them to a group and reset the group instead of repeating the named keys each time, and more.The instance / raw stored value is stored at class., the __class. references the Accessor Class which holds static vars / values / functions for the property. _class. is the property itself which is called when accessed via the instance class during setting / getting, etc.The Accessor _class.__ points to the class, but because it is internal it needs to be assigned in the class which is why I opted to use __Name = AccessorFunc( ... ) to assign it, a single line per property with many optional arguments to use ( using keyed varargs because they're easier and more efficient to identify and maintain )...I also create a lot of functions, as mentioned, some of which use  accessor function information so it doesn't need to be called ( as it is a bit inconvenient at the moment - right now you need to use _class..FunctionName( _class_instance, args ) - I got around using the stack / trace to grab the instance reference to grab the value by adding the functions which either run this bit marathon, or by adding the accessors to the object and using self ( named this to point out they're for the instance and to retain access to self, the AccessorFunc class reference, and other information from within the function definitions ).It isn't quite done, but it is a fantastic foot-hold. Note: If you do not use __Name = AccessorFunc( ... ) to create the properties, you won't have access to the __ key even though I define it within the init function. If you do, then there are no issues.Also: Note that Name and Key are different... Name is 'formal', used in Function Name Creation, and the key is for data storage and access. ie _class.x where lowercase x is key, the name would be uppercase X so that GetX( ) is the function instead of Getx( ) which looks a little odd. this allows self.x to work and look appropriate, but also allow GetX( ) and look appropriate.I have an example class set up with key / name identical, and different to show. a lot of helper functions created in order to output the data ( Note: Not all of this is complete ) so you can see what is going on.The current list of functions using key: x, name: X outputs as:This is by no means a comprehensive list - there are a few which haven't made it on this at the time of posting...Some of the data being output is:This is for a brand new class created using the Demo class without any data assigned other than the name ( so it can be output ) which is _foo, the variable name I used...And this is after assigning all of _foo properties ( except the name ) the following values in the same order: 'string ', 1.0, True, 9, 10, FalseNote that because of restricted data-types or value restrictions, some data wasn't assigned - this is by design. The setter prohibits bad data-types or values from being assigned, even from being assigned as a default value  ( unless you override the default value protection behavior )The code hasn't been posted here because I didn't have room after the examples and explanations... Also because it will change.Please Note: at the time of this posting, the file is messy - this will change. But, if you run it in Sublime Text and compile it, or run it from Python, it will compile and spit out a ton of information - the AccessorDB portion isn't done ( which will be used to update the Print Getters and GetKeyOutput helper functions along with being changed to an Instance function, probably put into a single function and renamed - look for it.. )Next: Not everything is required for it to run - a lot of the commented stuff at the bottom is for more information used for debugging - it may not be there when you download it. If it is, you should be able to uncomment and recompile to get more information.I am looking for a work-around to needing MyClassBase: pass, MyClass( MyClassBase ): ... - if you know of a solution - post it.The only thing necessary in the class are the __ lines - the str is for debugging as is the init - they can be removed from the Demo Class but you will need to comment out or remove some of the lines below ( _foo / 2 / 3 )..The String, Dict, and Util classes at the top are a part of my Python library - they are not complete. I copied over a few things I needed from the library, and I created a few new ones. The full code will link to the complete library and will include it along with providing updated calls and removing the code ( actually, the only code left will be the Demo Class and the print statements - the AccessorFunc system will be moved to the library )...Part of file:This beauty makes it incredibly easy to create new classes with dynamically added properties with AccessorFuncs / callbacks / data-type / value enforcement, etc.For now, the link is at ( This link should reflect changes to the document. ): https://www.dropbox.com/s/6gzi44i7dh58v61/dynamic_properties_accessorfuncs_and_more.py?dl=0Also: If you don't use Sublime Text, I recommend it over Notepad++, Atom, Visual Code, and others because of proper threading implementations making it much, much faster to use... I am also working on an IDE-like code mapping system for it - take a look at: https://bitbucket.org/Acecool/acecoolcodemappingsystem/src/master/ ( Add Repo in Package Manager first, then Install Plugin - when version 1.0.0 is ready, I'll add it to the main plugin list... )I hope this solution helps... and, as always:Just because it works, doesn't make it right - Josh 'Acecool' Moser


Answer URL
https://docs.python.org/3/library/functions.html#property
