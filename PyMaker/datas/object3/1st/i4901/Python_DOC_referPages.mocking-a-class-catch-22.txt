Natural Text
brief summaryMyClass.my_method has a call to instance = SomeLibrary()  I want to create a mock so instance is a mocked object that I can control.  In the spirit of isolated testing, I don't actually want to call into SomeLibrary.what argument to pass to @mock.patch()I'm trying to mock the class constructor, but I haven't figured out what to pass to the @mock.patch() decorator.  The docs say that the argument must be fully dotted (pyftdi.ftdi.Ftdi), but the where to patch docs say that the argument must match the name by which the code being tested knows it (Ftdi).  I don't see how to satisfy both.To make it concrete, here's the file being tested:... and the test fileWhat I observe is that, despite my attempt to patch Ftdi(), the call to ftdi_instance.open_from_url() calls the library code, not my mocked object.What am I missing?
Where to patch states:The basic principle is that you patch where an object is looked up, which is not necessarily the same place as where it is defined.It means that to mock a class Ftdi you have to provide a path to the place in your code where Ftdi is actually instantiated.To do so you you need to replace @mock.patch('pyftdi.ftdi.Ftdi') with @mock.patch('ftdi_interface.Ftdi'):Line import pyftdi.ftdi doesn't make anything useful for test and can be dropped. 


Answer URL
https://docs.python.org/3/library/unittest.mock.html?#where-to-patch
