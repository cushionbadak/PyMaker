Natural Text
I'm writing a class overloading the list type.I just wrote this and I'm wondering if there exists any other way less redundant to do it :  As you can see, every overloaded method is a copy/paste of the previous with just small changes.
What you want to do here is dynamically generate the methods. There are multiple ways to do this, from going super-dynamic and creating them on the fly in a metaclass's __getattribute__ (although that doesn't work for some special methods—see the docs)to generating source text to save in a .py file that you can then import. But the simplest solution is to create them in the class definition, something like this:You can get fancier and set _op.__doc__ to an appropriate docstring that you generate (see functools.wraps in the stdlib for some relevant code), and build __rmul__ and __imul__ the same way you build __mul__, and so on. And you can write a metaclass, class decorator, or function generator that wraps up some of the details if you're going to be doing many variations of the same thing. But this is the basic idea.In fact, moving it outside the class makes it easier to eliminate even more repetition. Just define that _op(self, other, op) method in the class instead of locally inside _make_op and decorate the class with @numeric_ops, which you can define like this:If you look at, e.g., functions.total_ordering, it does something similar to generate any missing ordering ops out of the ones that are there.The operator.mul, etc., come from the operator module in the stdlib—they're just trivial functions where operator.__mul__(x, y) basically just calls x * y, and so on, made for when you need to pass around an operator expression as a function.There are some examples of this kind of code in the stdlib—although far more examples of the related but much simpler __rmul__ = __mul__.The key here is that there's no difference between names you create with def and names you create by assigning with =. Either way, __mul__ becomes an attribute of the class, and its value is a function that does what you want. (And, similarly, there’s almost no difference between names you create during class definition and names you inject afterward.)So, should you be doing this?Well, DRY is important. If you copy-paste-edit a dozen times it’s not unlikely that you’ll screw up one of the edits and end up with a mod method that actually multiples and that (and a unit test that doesn’t catch it). And then, if you later discover a flaw in the implementation you copied and pasted a dozen times (as between the original and edited version of the question), you have to fix the same flaw in a dozen places, which is yet another potential bug magnet.On the other hand, readability counts. If you don't understand how that works, you probably shouldn't be doing this, and should settle for Ramazan Polat's answer. (It's not quite as compact, or as efficient, but it's surely easier to understand.) After all, if the code isn’t obvious to you, the fact that you only have to fix a bug once instead of a dozen times is swamped by the fact that you don’t know how to fix it. And even if you do understand it, the cost of cleverness can often outweigh the benefits of DRY.I think total_ordering shows about where you’d want to draw the line. If you’re doing this one time, you’re better off with the repetition, but if you’re doing it for multiple classes or in multiple projects, you’re probably better off abstracting the cleverness into a library that you can write once, exhaustive test with a variety of different classes, and then use over and over.
Factorize code using decorator design pattern and lambda function:
Your code could be as compact as below (juanpa.arrivillaga suggested to return NotImplemented instead of raising an exception): 
The Strategy pattern is your friend here. I'll also touch on a couple of other ways you can clean up code.You can read about the strategy pattern here: https://en.wikipedia.org/wiki/Strategy_patternYou said "As you can see, every overloaded method is a copy/paste of the previous with just small changes." This is your hint to use this pattern. If you can make the small change into a function, then you can write the boilerplate code once and focus on the interesting parts.We can clean this up a little more with a list comprehensionWe can improve the type checkWe can use operators instead of writing lambdas:So we end up with something like this:There are other ways you might dynamically generate these, but for a small set of functions like this, readability counts.If you need to generate these dynamically, try something like this:If you find this dynamic example does not work, check out make operators overloading less redundant in python?, which handles the case of dynamically creating dunder_methods in most python implementations.


Answer URL
https://docs.python.org/3/reference/datamodel.html#special-method-lookup
https://docs.python.org/3/library/functools.html
https://docs.python.org/3/library/operator.html
https://docs.python.org/3/library/constants.html#NotImplemented
