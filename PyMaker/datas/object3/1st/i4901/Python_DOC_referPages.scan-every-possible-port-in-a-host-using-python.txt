Natural Text
I'm writing a program which needs to scan all 65535 ports in a host searching for the ones which are open. This is what I have so far, and it works, but it produces different results every time I execute the script, why is this happening?For example, in a host with ports 22, 80, and 443 open, sometimes I get this response:[22, 80]and sometimes I get:[22, 80, 443]or even:[22]Hosts with more open ports produce more combinations.I have played with max_workers and settimeout() values, but I can't get it to work well. The only time it worked was without using threads, but obviously it took ages to complete, I need to use them.Am I missing something? Is there another way to implement this?
2 questions here:Am I missing somethingIs there another way to implement this?Am I missing somethingI think it’s worth checking error codes here:given that you’re trying to run a pool of ! 10K threads all kind of errors might follow here - i.e. reach some system/your user limits (check out ulimit -a) and you would treat such errors as a closed port without a notice. It might explain unstable results you experience.BTW on my MacBook the results are consistent (checking against my live server on a VPS hosting)I’d also pick fewer number of threads - 10K is an overkill. For example, here are the default values suggested in the python docs:Changed in version 3.5: If max_workers is None or not given, it will  default to the number of processors on the machine, multiplied by 5,  assuming that ThreadPoolExecutor is often used to overlap I/O instead  of CPU work and the number of workers should be higher than the number  of workers for ProcessPoolExecutorIs there another way to implement this?First of all, there’s no need to use threads/processes - non-blocking sockets + event multiplexors like epoll are around for years so you’d be able to get away without having additional threads/processed whatsoever.The method to connect/close is also suboptimal, because you just need to check if a port is open or not - you don’t need a full-on TCP connection here.In the simplest case, you just need to send a SYN segment and check what the server would respond. Here’s a good article with a dozen of methods using scapyScapy is a powerful interactive packet manipulation program. It is  able to forge or decode packets of a wide number of protocols, send  them on the wire, capture them, match requests and replies, and much  more. It can easily handle most classical tasks like scanning,  tracerouting, probing, unit tests, attacks or network discovery (it  can replace hping, 85% of nmap, arpspoof, arp-sk, arping, tcpdump,  tethereal, p0f, etc.).Here’s one of the methods description (“TCP connect scan”):The client sends the first handshake using the SYN flag and port to  connect to the server in a TCP packet. If the server responds with a  RST instead of a SYN-ACK, then that particular port is closed on the  serverAnd one more method (“TCP stealth scan”):This technique is similar to the TCP connect scan. The client sends a  TCP packet with the SYN flag set and the port number to connect to. If  the port is open, the server responds with the SYN and ACK flags  inside a TCP packet. But this time the client sends a RST flag in a  TCP packet and not RST+ACK, which was the case in the TCP connect  scan. This technique is used to avoid port scanning detection by  firewallsOf course if just want to play with sockets/threads your approach would also be fine even without pcap/scapy
I tried your code on jupyter notebook and I always get the same set of ports:Output:[133, 200, 144...60700]Could it be possible that a different number of ports are open at a particular time for the host being queried?To verify for a small set of ports, I reduced max_port to 10000 and I still get the same set of ports every time:Output: [150, 900, 1035, 7789]Note: I've changed the port numbers for security sake.EDIT:EDIT 2: A more reliable solutionAs suggested by @Tarun, Python's python-nmap library does a better job at scanning hosts.The below solution gives an accurate result, however, I observed a significant compromise on performance as the range of port discovery increases. Perhaps, threading could be incorporated into the code to improve performance. I've also imported the time library to get the program execution time in the end. This can be used for comparison purposes when testing for performance.To convert output to csv, use:As a result of this investigation, Nmap was now installed on my computer. Just for fun, I also ran a scan on the command prompt using the below command. This scan ran for range '1-1000' and took more than 15 minutes(I didn't sit through the whole session!).
I've come across this port scanner in my time working with sockets in python...It works fairly well and can be adapted easily :)


Answer URL
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor
https://docs.python.org/3/library/select.html
https://docs.python.org/3/library/select.html#select.epoll
