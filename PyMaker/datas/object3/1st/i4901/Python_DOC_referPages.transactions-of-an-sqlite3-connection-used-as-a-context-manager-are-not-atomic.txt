Natural Text
According to the documentation,Connection objects can be used as context managers that automatically commit or rollback transactions. In the event of an exception, the transaction is rolled back; otherwise, the transaction is committed:I understand that everything within a with statement should be an atomic transaction. Now consider this codewhich returnsOn one hand, the transaction failed, due to the duplicated value. On the other hand, table foo exists, even though it is empty, which means that the first insert has been rolled back. Shouldn't the table creation be rolled back as well?Doing the transaction "by hand" produces the expected result:returns Why the discrepency?
As of Python 3.6, DDL, or Data Defitinion Language statements, like CREATE TABLE, do not start a transaction. This means that any such statement is automatically committed the moment you execute one.See the Controlling transactions section:By default, the sqlite3 module opens transactions implicitly before a Data Modification Language (DML) statement (i.e. INSERT/UPDATE/DELETE/REPLACE).[...]Changed in version 3.6: sqlite3 used to implicitly commit an open transaction before DDL statements. This is no longer the case.This means that you'll have to start a transaction explicitly if you want DDL statements to be part of a transaction.Using the connection as a context manager still only issues a commit or rollback when exiting, it does not start a transaction; instead the first DML statement encountered will start one. If you want DDL to be part of a transaction, add a begin statement at the top:


Answer URL
https://docs.python.org/3/library/sqlite3.html#using-the-connection-as-a-context-manager
https://docs.python.org/3/library/sqlite3.html#controlling-transactions
