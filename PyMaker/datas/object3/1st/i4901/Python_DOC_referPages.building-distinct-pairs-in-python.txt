Natural Text
productcode contains over a thousand data items: Expected output:The nested for loops only iterate over half the items in the list (productcode) and therefore I end up with much lesser number of pairs than I expect. Could anyone help explain what I've done wrong, or what is actually happening? 
itertools.combinations is a natural choice for this. To avoid duplicates, just convert your list to a set first. There are 2 similar solutions, depending on whether you need ordered results.OrderedI'm not sure what order you require, so I've sorted both within and across sublists, alphabetically in each case.UnorderedIf order is unimportant anywhere, then you need to use a set of frozenset items:This is because set items must be immutable; frozenset is an immutable version of set. This is one natural way to test whether a pair is in the set. For example:Another way is to use a set of alphabetically sorted tuples.
You modify a collection while iterating it. Bad idea.There is this cool datastructure that gets rid of duplicates:Create plenty of duplicate data:Output:Make data unique:Output:If you need all combinations of something, stuff the somethings into a set beforehand to eleminate all dupes and create your combinations via itertools.combinations from the set. If you use combinations on a list with dupes, you create unneeded many combinations - so set first, then combinations from it.Drawback/catch for sets (and dicts) is that they need immutable keys - so tuples are fine, lists are not but strings work well. You can tuple(alist) if you need to. 


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.combinations
