Natural Text
I am reading Hackers and Painters and am confused by a problem mentioned by the author to illustrate the power of different programming languages.The problem is:We want to write a function that generates accumulators—a function that takes a number n, and returns a function that takes another number i and returns n incremented by i. (That’s incremented by, not plus. An accumulator has to accumulate.)The author mentions several solutions with different programming languages. For example, Common Lisp:and JavaScript:However, when it comes to Python, the following codes do not work:A simple modification will make it work:I am new to Python. Why doesn the first solution not work while the second one does? The author mentions lexical variables but I still don't get it.
s += i is just sugar for s = s + i.*This means you assign a new value to the variable s (instead of mutating it in place). When you assign to a variable, Python assumes it is local to the function. However, before assigning it needs to evaluate s + i, but s is local and still unassigned -> Error.In the second case s[0] += i you never assign to s directly, but only ever access an item from s. So Python can clearly see that it is not a local variable and goes looking for it in the outer scope.Finally, a nicer alternative (in Python 3) is to explicitly tell it that s is not a local variable:(There is actually no need for s - you could simply use n instead inside bar.)*The situation is slightly more complex, but the important issue is that computation and assignment are performed in two separate steps.
An infinite generator is one implementation. You can call __next__ on a generator instance to extract successive results iteratively.If you need a flexible incrementer, one possibility is an object-oriented approach:
The following will work:The inner function bar looks to find s locally inside its scope, and if it fails to find it, it goes to look one level up in the enclosing scope where it finds s which is a local variable of foo. But if you say s = s + 1, you declare s as a new local variable in the scope of the bar ("the assignment statement creates variables in the local scope"), which leads to an error because you haven't assigned a value to s before adding something to it (referencing to it). On the other example, saying s[0] = s[0] + 1 is different because you do not declare a new local variable inside the bar, you access the first element of s which is found in the enclosing scope of bar.
In Python if we use a variable and pass it to a function then it will be Call by Value whatever changes you make to the variable it will not be reflected to the original variable.But when you use a list instead of a variable then the changes that you make to the list in the functions are reflected in the original List outside the function so this is called call by reference.And this is the reason for the second option does work and the first option doesn't.


Answer URL
https://docs.python.org/3/library/operator.html#inplace-operators
