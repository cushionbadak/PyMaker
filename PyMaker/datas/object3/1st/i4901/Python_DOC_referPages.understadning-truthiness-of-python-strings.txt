Natural Text
I understand that Python built-in types have a "truthiness" value, and the empty string is considered False, while any non-empty string is considered True.This makes senseI can check this using the built-in function bool.I can also make use of these truthiness values when using conditionals. For example:This is confusingThis doesn't work with the == operator though:Can anyone explain why == seems to act differently than a conditional?
See the truth value testing and comparisons sections of the documentation, excerpted below.In a nutshell, most things are truthy by default, which is why bool("dog") is true.  The == operator compares two objects for equality, as opposed to comparing their truthinesses, as I assume you had expected.4.1. Truth Value Testing Any object can be tested for truth value, for use in an if or while condition or as operand of the Boolean operations below.By default, an object is considered true unless its class defines  either a __bool__() method that returns False or a __len__() method  that returns zero, when called with the object. Here are most of the built-in objects considered false:constants defined to be false: None and Falsezero of any numeric type: 0, 0.0, 0j, Decimal(0), Fraction(0, 1)empty sequences and collections: '', (), [], {}, set(), range(0)Operations and built-in functions that have a Boolean result always   return 0 or False for false and 1 or True for true, unless otherwise  stated. (Important exception: the Boolean operations or and and  always return one of their operands.)4.3. ComparisonsObjects of different types, except different numeric types, never  compare equal....Non-identical instances of a class normally compare as non-equal  unless the class defines the __eq__() method.
The basicsI believe your confusion might come from comparing Python to languages such as JavaScript where there is a == and a === operator. Python does not work this way.In Python the only way to compare for equality is with == and this compares both value and type.Thus if you compare True == "dog", then the expression is immediately False because the types bool and str are not types that can be compared.Although, note that it does not mean that there are no types that are comparable between themselves. Examples are set and frozenset:Or simply int and floatThis is the behaviour for most built-in types.The classy partIn the case where you define your own types, i.e. when you define classes, you can write the __eq__ which is called when you compare a class object to another value.By example you could do this (which by the way was pointed out as a terrible idea in the comments, you should not inherit built-in types).In the case where you do not define __eq__, then Python fall back on comparing whether the objects are the same object with is.
When you compare "dog" == True, you are also comparing the type of these objects and not just their boolean value.Now as True has a type bool and "dog" has a type str, they are not equivalent according to the == operator, irrespective of their boolean values being equal.Note: Both the object's type,boolean values are being checked here.


Answer URL
https://docs.python.org/3/library/stdtypes.html#truth-value-testing
https://docs.python.org/3/library/stdtypes.html#comparisons
https://docs.python.org/3/library/stdtypes.html#memoryview.__eq__
