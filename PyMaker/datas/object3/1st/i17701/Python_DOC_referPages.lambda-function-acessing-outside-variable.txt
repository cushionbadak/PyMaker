Natural Text
This question already has an answer here:What do (lambda) function closures capture?                    6 answers                I wanted to play around with anonymous functions so I decided to make a simple prime finder. Here it is:What I find however, is that the i in the lambda x:x%i==0 is accessed each time, while i want it to be a literal number. how can I get it to become lambda x:x%3==0 instead?
You can "capture" the i when creating the lambdaThis will set the i in the lambda's context equal to whatever i was when it was created.  you could also say lambda x, n=i: x%n==0 if you wanted, it's not exactly capture, but it gets you what you need.Without this, as you've seen, it's going to look for an i in the enclosing scopeIt's an issue of lookup that's analogous to the following with defined functions:
The problem is that each of those functions in tests is referring to the variable i.More commonly, you do this inside a function, in which case you have a local-to-the-defining-scope variable i, which gets stored in a closure, as nicely explained in These Nasty Closures.But here, it's even simpler: i is a global variable, so there is no closure. The functions are compiled to look up i as a global variable when run. Since i has changed, the functions will see the changed value when they run. Simple as that.The traditional way around this (which works for both closures and globals) is fondly known as "the default-value hack", even though it's not really a hack. (See the explanation in the FAQ.) Ryan Haining's answer explains how to do this:This creates a parameter named i, with a default value equal to the value of i at the time the function is created. Then, inside the function, when you access parameter i, and you get that value.A different way around this, which may seem more familiar if you're using to languages like JavaScript, is to create a function-creating function, and pass the value of i as an argument to that function-creating function, as in user2864740's answer:This avoids "polluting" the signature of the function with an extra parameter (that someone could accidentally pass an argument to), but at the cost of creating and calling a function for no good reason.A third way around this is to use partial. In cases where all you're trying to do is partially apply a function, using partial instead of defining a wrapper function as a lambda can be cleaner.Unfortunately, in this case, the function is hidden inside an operator, and the function operator.mod that exposes it doesn't take keyword arguments, so you can't usefully partial its second operand. So, this is a bad solution in this case. If you really wanted to, you could just write a wrapper that behaves better and partial that:In this case, I think you're better off with the other solutions; just keep this one in your head for cases where it is appropriate.
Create a new function that returns the lambda. Then call that, passing in i as an argument. This will create a new binding scope.


Answer URL
https://docs.python.org/3/faq/programming.html#why-are-default-values-shared-between-objects
https://docs.python.org/3/faq/programming.html#why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result
