Natural Text
Assignment:Reference:What is the difference between above both?Why assignment results False?Why reference results True?
Your first snippet creates two unique list objects, which are not the same. Hence a is b returns false because a and b are pointing to distinct objects:Your second snippet creates a single list object, and points both c and d to that objects, hence c is d return true:Note the following, from http://docs.python.org/3/reference/datamodel.html:Every object has an identity, a type and a value. An object’s identity never changes once it has been created; you may think of it as the object’s address in memory. The is operator compares the identity of two objects; the id() function returns an integer representing its identity.So is and == are very different; while the former compares object identity, the latter compares object values. Indeed, == tests in your snippets would return true.Given the explanation above, it may come as a surprise that that the story is slightly different with strings:This is due to string interning, which occurs in CPython (i.e. it's implementation specific). Therefore, if the same string literal shows up in two different places, the same string object will be used for both (with restrictions).This is explained in greater detail in "Python string interning".
when compare with is, like a is b, it's the same as id(a) == id(b), the code xx=['spam'] creates a new list each time and assigns it to xx, it's id changes each time, so  a is b gives False
This has nothing to do with some (inexistant) "assignment vs reference" question.creates a list with the string 'spam' in it, and binds it to names 'a' in the current scope.creates another list with the string 'spam' in it, and binds it to names 'b' in the current scope.You create two lists, you have two lists. Plain simple.creates yet another list with the string 'spam' in it, and binds it to names 'c' in the current scope.binds name 'd' to whatever 'c' is bound to at that time in the current scope.Here you create one list and bind 2 names to it. Both name points to the same object.The point is: Python's "variables" are not named memory adresses, just names pointing to objects. At a given time, one object can be bound to (pointed to by) any number of names (and even by no name at all).
Let me just add a few function calls to what you were originally doing. I think you will pick it up.


Answer URL
