Natural Text
I was just very confused by some code that I wrote. I was surprised to discover that:and produce different results. The first one produces a list of whatever type f returns, the second produces a list of concurrent.futures.Future objects that then need to be evaluated with their result() method in order to get the value that f returned. My main concern is that this means that executor.map can't take advantage of concurrent.futures.as_completed, which seems like an extremely convenient way to evaluate the results of some long-running calls to a database that I'm making as they become available. I'm not at all clear on how concurrent.futures.ThreadPoolExecutor objects work -- naively, I would prefer the (somewhat more verbose):over the more concise executor.map in order to take advantage of a possible gain in performance. Am I wrong to do so?
The problem is that you transform the result of ThreadPoolExecutor.map to a list. If you don't do this and instead iterate over the resulting generator directly, the results are still yielded in the right order but the loop continues before all results are ready. You can test this with this example:That the order is kept may be because it's sometimes important that you get results in the same order you give them to map. And results are probably not wrapped in future objects because in some situations it may take just too long to do another map over the list to get all results if you need them. And after all in most cases it's very likely that the next value is ready before the loop processed the first value. This is demonstrated in this example:In this example it may be likely that do_some_stuff takes longer than crunch_number and if this is really the case it's really not a big loss of performace while you still keep the easy usage of map.Also since the worker threads(/processes) start processing at the beginning of the list and work their way to the end to the list you submitted the results should be finished in the order they're already yielded by the iterator. Which means in most cases executor.map is just fine, but in some cases, for example if it doesn't matter in which order you process the values and the function you passed to map takes very different times to run, the future.as_completed may be faster.
Below is an example of submit vs. map.  They both accept the jobs immediately (submitted|mapped - start).  They take the same time to complete, 11 seconds (last result time - start).  However, submit gives results as soon as any thread in the ThreadPoolExecutor maxThreads=2 completes.  map gives results in the order they are submitted.Output:
In addition to the explanation in the answers here, it can be helpful to go right to the source.  It reaffirms the statement from another answer here that:.map() gives results in the order they are submitted, whileiterating over a list of Future objects with concurrent.futures.as_completed() won't guarantee this ordering, because this is the nature of as_completed().map() is defined in the base class, concurrent.futures._base.Executor:As you mention, there is also .submit(), which left to be defined in the child classes, namely ProcessPoolExecutor and ThreadPoolExecutor, and returns a _base.Future instance that you need to call .result() on to actually make do anything.The important lines from .map() boil down to:The .reverse() plus .pop() is a means to get the first-submitted result (from iterables) to be yielded first, the second-submitted result to be yielded second, and so on.  The elements of the resulting iterator are not Futures; they're the actual results themselves.


Answer URL
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.as_completed
