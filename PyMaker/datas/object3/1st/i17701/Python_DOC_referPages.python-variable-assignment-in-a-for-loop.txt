Natural Text
I understand that in Python regular c++ style variable assignment is replaced by references to stuff iebut I'm still confused why an analogous situation with basic types eg. integers works differently?But wait, it gets even more confusing when we consider loops!Which is what I expected, but what happens if we do:Maybe my question should be how to loop over a list of integers and change them without map() as i need a if statement in there. The only thing I can come up short of usingis packaging the integers in one element list. But there must be a better way.
Here you are modifying the list. The list content changes, but the list identity remains.This, however, is a reassignment. You assign a different object to a.Note that if you did a += [4] in the 1st example, you would have seen the same result. This comes from the fact that a += something is the same as a = a.__iadd__(something), with a fallback to a = a.__add__(something) if __iadd__() doesn't exist.The difference is that __iadd__() tries to do its job "inplace", by modifying the object it works on and returning it. So a refers to the same as before. This only works with mutable objects such as lists.On immutable objects such as ints __add__() is called. It returns a different object, which leads to a pointing to another object than before. There is no other choice, as ints are immutable.Here x += 1 means the same as x = x + 1. It changes where x refers to, but not the list contents.Maybe my question should be how to loop over a list of integers and change them without >map() as i need a if statement in there.assigns to every list position the old value + 1.
Well, you need to think of mutable and immutable type.For a list, it's mutable.For a integer, it's immutable, which means you will refer to a new object if you change it. When a+=1 is executed, a will be assigned a new object, but b is still refer to the same one.
The important thing here are the variable names. They really are just keys to a dictionary. They are resolved at runtime, depending on the current scope.Let's have a look what names you access in your code. The locals function helps us: It shows the names in the local scope (and their value). Here's your code, with some debugging output:(Note I expanded x += 3 to x = x + 3 to increase visibility for the name accesses - read and write.)First, you bind the list [1, 2, 3]to the name a. Then, you iterate over the list. During each iteration, the value is bound to the name x in the current scope. Your assignment then assigns another value to x.Here's the outputAt no point you're accessing a, the list, and thus will never modify it.To fix your problem, I'd use the enumerate function to get the index along with the value and then access the list using the name a to change it.Output:Note you might want to wrap those examples in a function, to avoid the cluttered global namespace.For more about scopes, read the chapter in the Python tutorial. To further investigate that, use the globals function to see the names of the global namespace. (Not to be confused with the global keyword, note the missing 's'.)Have fun!
For a C++-head it easiest tho think that every Python object is a pointer. When you write a = [1, 2, 3] you essentially write List * a = new List(1, 2, 3). When you write a = b, you essentially write List * b = a.But when you take out actual items from the lists, these items happen to be numbers. Numbers are immutable; holding a pointer to an immutable object is about as good as holding this object by value.So your for x in a: x += 1 is essentially which obviously has no effect.If list elements were mutable objects you could mutate them exactly the way you wrote. See:But unless you have a compelling reason (e.g. a list of millions of objects under heavy memory load) you are better off making a copy of the list, applying a transformation and optionally a filter. This is easily done with a list comprehension: Either that, or you can write an explicit loop that creates another list:
Your question has multiple parts, so it's going to be hard for one answer to cover all of them. glglgl has done a great job on most of it, but your final question is still unexplained:Maybe my question should be how to loop over a list of integers and change them without map() as i need a if statement in there"I need an if statement in there" doesn't mean you can't use map.First, if you want the if to select which values you want to keep, map has a good friend named filter that does exactly that. For example, to keep only the odd numbers, but add one to each of them, you could do this:Or just this:If, on the other hand, you want the if to control the expression itselfâ€”e.g., to add 1 to the odd numbers but leave the even ones alone, you can use an if expression the same way you'd use an if statement:Second, comprehensions are basically equivalent to map and filter, but with expressions instead of functions. If your expression would just be "call this function", then use map or filter. If your function would just be a lambda to "evaluate this expression", then use a comprehension. The above two examples get more readable this way:
You can do something like this: li = [x+1 for x in li]


Answer URL
