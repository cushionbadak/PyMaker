Natural Text
I've a text file(test.txt) which has 6-7 lines. 3-4 of them has the word "exception" in them. Also among these 3-4 lines, 2 of them also has the word "abc" in them. My task is to write a program by whose output I will be able to separate the lines containing any word the user inputs(word1) but not those lines which have both (word1) and (word2-e.g "abc": this will also be an input from the user) in it and write it in a new file(test_mod.txt). I have to do this from command line argument. So this is my command from the command prompt:"fileinput4.py test.txt test_mod.txt abc exception"Here the lines containing both "abc" and "exception" will be excluded and the lines containing only the word "exception" will be included and copied in test_mod.txt.So far I've exception handled the following things:1. Showing error message if two words are same.2.Showing error message if less than 5 parameters.3.Showing error message if the first filename is misspelled4. Showing error message if input filename and output filename are same.I also want to exception handle if somebody enters some words which are not at all in the text file. But some bug is there in my code and this thing is not happening. Please help.Whenever I am typing any word that is not in the file, nothing is getting printed and a new file is getting created without any error message which I want to prevent.Here's my code:
An elaboration on my comment:The code if user_input2 or user_input1 in line doesn't mean what you think it does. You think it means "if user_input1 is in line or user_input2 is in line". However, this isn't correct.Let's look at a simple example:The line if True or False in [0, 1, 2, 3, 4] doesn't mean "if True is in [0, 1, 2, 3, 4] or False is in [0, 1, 2, 3, 4]." It means ifTrue, or alternatively ifFalsein[0, 1, 2, 3, 4]`".In other words, the code means - if (True) or (False in [0, 1, 2, 3, 4]). True is always true, so during execution of the code, the intepreter never bothers to check if False in [0, 1, 2, 3, 4]. It just sees the True, and proceeds to the body of the if statement.The same thing happens in your code. However, it is less obvious. What you need to know is that Python inteprets all sorts of values as True or False in certain contexts, not just the Booleans True and False, which are what an expression like a == b or c in d evaluates to.For the builtin types, such as lists, integers, floats and strings, every value evaluates to a True when a Boolean is needed (you can do this explicitly by calling the function bool an object), except for "empty" values. So bool(1) == bool(2) == bool("asdlkjhwar") == bool([1, 2, 3]) == True, and bool(0) == bool([]) == bool("") == False. In your code, user_input2 is almost always a non-empty string (or at least you haven't tested the program with it as an empty string and user_input1 not in line. This shows the importance of thorough testing.To fix this, you could replace that line with if (user_input2 in line) or (user_input1 in line) (parentheses added for readability). But better (IMHO) would be to do this - if any(thing in line for thing in (user_input1, user_input2)). This worth knowing as it is much quicker if you are doing similar tests but with larger amounts of variables (e.g. a user_input3, 4, 5 and 6).Also, as mentioned in the comments, you should take a look at the argparse module. This would make what you want much more simple to achieve.Edit:Try this:Although you should really rewrite your code so you don't open the file for each line in the first file.Example file handling:Example file:Example code:Here is a tutorial for file-handling, and here is a tutorial for argparse.


Answer URL
