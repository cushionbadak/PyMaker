Natural Text
I was trying to build this bytes object in Python 3:b'3\r\n'so I tried the obvious (for me), and found a weird behaviour:Apparently:I've been unable to see any pointers on why the bytes conversion works this way reading the documentation. However, I did find some surprise messages in this Python issue about adding format to bytes (see also Python 3 bytes formatting):http://bugs.python.org/issue3982This interacts even more poorly with oddities like bytes(int) returning zeroes nowand:It would be much more convenient for me if bytes(int) returned the ASCIIfication of that int; but honestly, even an error would be better than this behavior.  (If I wanted this behavior - which I never have - I'd rather it be a classmethod, invoked like "bytes.zeroes(n)".)Can someone explain me where this behaviour comes from?
That's the way it was designed - and it makes sense because usually, you would call bytes on an iterable instead of a single integer:The docs state this, as well as the docstring for bytes:
From python 3.2 you can dohttps://docs.python.org/3/library/stdtypes.html#int.to_bytesAccordingly, x == int_from_bytes(int_to_bytes(x)).
You can use the struct's pack:The ">" is the byte-order (big-endian) and the "I" is the format character. So you can be specific if you want to do something else:This works the same on both python 2 and python 3.Note: the inverse operation (bytes to int) can be done with unpack.
Python 3.5+ introduces %-interpolation (printf-style formatting) for bytes:See PEP 0461 -- Adding % formatting to bytes and bytearray.On earlier versions, you could use str and .encode('ascii') the result:Note: It is different from what int.to_bytes produces:
The documentation says:The sequence:It is the character '3' (decimal 51) the character '\r' (13) and '\n' (10).Therefore, the way would treat it as such, for example:Tested on IPython 1.1.0 & Python 3.2.3
The ASCIIfication of 3 is "\x33" not "\x03"!That is what python does for str(3) but it would be totally wrong for bytes, as they should be considered arrays of binary data and not be abused as strings.The most easy way to achieve what you want is bytes((3,)), which is better than bytes([3]) because initializing a list is much more expensive, so never use lists when you can use tuples. You can convert bigger integers by using int.to_bytes(3, "little").Initializing bytes with a given length makes sense and is the most useful, as they are often used to create some type of buffer for which you need some memory of given size allocated. I often use this when initializing arrays or expanding some file by writing zeros to it.
int (including Python2's long) can be converted to bytes using following function:The reverse conversion can be done by another one:Both functions work on both Python2 and Python3.
The behaviour comes from the fact that in Python prior to version 3 bytes was just an alias for str. In Python3.x bytes is an immutable version of bytearray - completely new type, not backwards compatible.
From bytes docs:Accordingly, constructor arguments are interpreted as for bytearray().Then, from bytearray docs:The optional source parameter can be used to initialize the array in a few different ways:If it is an integer, the array will have that size and will be initialized with null bytes.Note, that differs from 2.x (where x >= 6) behavior, where bytes is simply str:PEP 3112:The 2.6 str differs from 3.0â€™s bytes type in various ways; most notably, the constructor is completely different. 
I was curious about performance of various methods for a single int in the range [0, 255], so I decided to do some timing tests.Based on the timings below, and from the general trend I observed from trying many different values and configurations, struct.pack seems to be the fastest, followed by int.to_bytes, bytes, and with str.encode (unsurprisingly) being the slowest. Note that the results show some more variation than is represented, and int.to_bytes and bytes sometimes switched speed ranking during testing, but struct.pack is clearly the fastest.Results in CPython 3.7 on Windows:Test module (named int_to_byte.py):
Although the prior answer by brunsgaard is an efficient encoding, it works only for unsigned integers. This one builds upon it to work for both signed and unsigned integers.
If you don't care about the performance, you can convert an int to str first.


Answer URL
https://docs.python.org/3/library/stdtypes.html#int.to_bytes
https://docs.python.org/3/library/struct.html
