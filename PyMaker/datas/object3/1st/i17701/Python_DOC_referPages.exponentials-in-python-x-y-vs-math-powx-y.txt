Natural Text
Which one is more efficient using math.pow or the ** operator? When should I use one over the other?So far I know that x**y can return an int or a float if you use a decimalthe function pow will return a float
Using the power operator ** will be faster as it won’t have the overhead of a function call. You can see this if you disassemble the Python code:Note that I’m using a variable i as the exponent here because constant expressions like 7. ** 5 are actually evaluated at compile time.Now, in practice, this difference does not matter that much, as you can see when timing it:So, while pow and math.pow are about twice as slow, they are still fast enough to not care much. Unless you can actually identify the exponentiation as a bottleneck, there won’t be a reason to choose one method over the other if clarity decreases. This especially applies since pow offers an integrated modulo operation for example.Alfe asked a good question in the comments above:timeit shows that math.pow is slower than ** in all cases. What is math.pow() good for anyway? Has anybody an idea where it can be of any advantage then?The big difference of math.pow to both the builtin pow and the power operator ** is that it always uses float semantics. So if you, for some reason, want to make sure you get a float as a result back, then math.pow will ensure this property.Let’s think of an example: We have two numbers, i and j, and have no idea if they are floats or integers. But we want to have a float result of i^j. So what options do we have?We can convert at least one of the arguments to a float and then do i ** j.We can do i ** j and convert the result to a float (float exponentation is automatically used when either i or j are floats, so the result is the same).We can use math.pow.So, let’s test this:As you can see, math.pow is actually faster! And if you think about it, the overhead from the function call is also gone now, because in all the other alternatives we have to call float().In addition, it might be worth to note that the behavior of ** and pow can be overridden by implementing the special __pow__ (and __rpow__) method for custom types. So if you don’t want that (for whatever reason), using math.pow won’t do that.
Just for the protocol: The ** operator calls the built-in pow function which accepts an optional third argument (modulus) if the first two arguments are integer types.So, if you intend to calculate remainders from powers, use the built-in function. The math.pow may give you false results:When I ran this, I got 0.0 in the first case which obviously cannot be true, because 13 is odd (and therefore all of it's integral powers). The math.pow version uses limited accuracy which causes an error. For sake of fairness, we must say, math.pow can be much faster:Here is what I'm getting as output:Some online exampleshttp://ideone.com/qaDWRd (wrong remainder with math.pow)http://ideone.com/g7J9Un (lower performance with pow on int values)http://ideone.com/KnEtXj (slightly lower performance with pow on float values)
Well, they are for different tasks, really.  Use pow (equivalent to x ** y with two arguments) when you want integer arithmetic.  And use math.pow if either argument is float, and you want float output.  For a discussion on the differences between pow and math.pow, see this question.
** is indeed faster then math.pow(), but if you want a simple quadratic function like in your example it is even faster to use a product.will be faster then The difference is not big and not noticable with one operation (using timeit), but with a large number of operations it can be significant.


Answer URL
