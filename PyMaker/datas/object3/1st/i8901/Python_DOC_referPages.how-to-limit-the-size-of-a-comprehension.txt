Natural Text
I have a list and want to build (via a comprehension) another list. I would like this new list to be limited in size, via a conditionThe following code will fail:withbecause b is not defined yet at the time the comprehension is built.Is there a way to limit the size of the new list at build time?Note: I could break the comprehension into a for loop with the proper break when a counter is reached but I would like to know if there is a mechanism which uses a comprehension.
You can use a generator expression to do the filtering, then use islice() to limit the number of iterations:This ensures you don't do more work than you have to to produce those 3 elements.Note that there is no point anymore in using a list comprehension here; a list comprehension can't be broken out of, you are locked into iterating to the end.
@Martijn Pieters is completly right that itertools.islice is the best way to solve this. However if you don't mind an additional (external) library you can use iteration_utilities which wraps a lot of these itertools and their applications (and some additional ones). It could make this a bit easier, at least if you like functional programming:The iteration_utilities.Iterable class uses generators internally so it will only process as many items as neccessary until you call any of the as_* (or get_*) -methods.Disclaimer: I'm the author of the iteration_utilities library.
You could use itertools.count to generate a counter and itertools.takewhile to stop the iterating over a generator when the counter reaches the desired integer (3 in this case):Or a similar idea building a construct to raise StopIteration to terminate the generator. That is the closest you'll get to your original idea of breaking the list comprehension, but I would not recommend it as best practice:Examples:
itertools.slice is the natural way to extract n items from a generator.But you can also implement this yourself using a helper function. Just like the itertools.slice pseudo-code, we catch StopIteration to limit the number of items yielded.This is more adaptable because it allows you to specify logic if n is greater than the number of items in your generator.
use enumerate:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.islice
https://docs.python.org/3/library/itertools.html#itertools.islice
