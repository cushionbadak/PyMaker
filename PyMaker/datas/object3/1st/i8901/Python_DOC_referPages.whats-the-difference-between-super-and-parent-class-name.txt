Natural Text
Is there a difference between using super() and using the parent class name directly? For example:Is there internally a difference between super().__init__() and Parent.__init__(self)?
Not in this case. But in general, and especially when you use multiple inheritance, super() delegates to the next object in the Method Resolution Order (MRO) as is specified in the documentation:super([type[, object-or-type]])Return a proxy object that delegates method calls to a parent or  sibling class of type. This is useful for accessing inherited methods  that have been overridden in a class. The search order is same as that  used by getattr() except that the type itself is skipped.The __mro__ attribute of the type lists the method resolution search order used by both getattr() and super(). The attribute  is dynamic and can change whenever the inheritance hierarchy is  updated.(...)(copied, boldface added)Say for instance you define classes like (borrowed from this question, where the MRO is discussed in more detail):Then the __mro__ of A is:Now if we call A(), it prints:so it means that in the context of A and when trying to obtain __init__ that:super().__init__ of A is D.__init__;super().__init__ of D is B.__init__;super().__init__ of B is C.__init__;super().__init__ of C is E.__init__;super().__init__ of E is G.__init__;super().__init__ of G is H.__init__;super().__init__ of H is F.__init__; andsuper().__init__ of F is object.__init__.Note thus that super() does not per se delegates to a parent. For instance the super() of D is B and B is not a superclass of D, so it really depends on the type of the object (not on the class).Now in case of D, the __mro__ is:If we construct a D however we get:So in the context of D it holds that:super().__init__ of D is E.__init__;super().__init__ of E is G.__init__;super().__init__ of G is H.__init__;super().__init__ of H is F.__init__; andsuper().__init__ of F is object.__init__.So here the super() of D leads to E (for __init__) which is not the same in the context of A.
Perceive you don't pass the "self" - it is inserted automatically.super() was first designed in Python 2 to allow classes to be reused as mixins in a class hierarchy in a way that their immediate superclass may change:Let's supose at some point in time your code is like:At this point, correct OOP code should execute C.__init__   which should chain the call to B.__init__: but when the superclass name is hardcoded that does not happen - A's __init__ would always come next. And if you hardcode B.__init__ in C, you would prevent C from working without B, defeating the purpose of multiple inheritance. When you use super() instead, Python's perform the method search for the next parent class looking on the class's __mro__ attribute (mro = method resolution order. __mro__ is a concrete attribute attached to each Python class).  - So, if at some point in time class D above no longer inherits from B, the calls to super().__init__  in C will be automatically re-routed straight to A.It is also worth noting that in Python 3 the parameterless form of super was introduced to ease its use - prior to that, one had to hardcode a reference to the own class and also insert self in the parameters. This form is one of the few exceptions in Python that is hardcoded in the compiler itself - it do change things internally on methods when super (or __class__) is seen inside a method body (namely, it creates a __class__ variable pointing to the class itself which the super call uses)


Answer URL
https://docs.python.org/3/library/functions.html#super
