Natural Text
This could be an easy question; I'd like to use a custom equality operator in a Python unittest test case. So for instance, supposing I want to test a "number-to-string" function, and I want to perform a case-insensitive string comparison. Here's what I'd like to write:The problem is that assertCheck isn't a thing.Some obvious workarounds:use assertTrue; the problem is that then a test case failure becomes opaqueand unhelpful; "expected True, got False". Bleah.dig into unittest and extend it myself; well, I'm hoping to avoid that :)I hope I'm missing something obvious?Many thanks in advance!EDIT: some have suggested that I override __eq__. This is not what I want. Specifically, the __eq__ method is used by clients of my code, to determinewhether two objects should be considered "the same" (cf. "extensional equality").For the purposes of testing, though, I want to test using a different predicate.So overriding __eq__ does not solve my problem.
The good news is that there isn't any complicated wiring to make a custom assertion with your own rules. Just do the comparison, gather any helpful information, then call fail(msg) if needed. That will take care of any reporting you need.Of course, I'm so lazy that I don't even like to gather the helpful information. What I often find useful is to strip out the irrelevant stuff from both the expected and the actual data, then use the regular assertEquals(expected, actual).Here's an example of both techniques, plus a bonus one that uses longMessage to include context:That generates the following output, including context and reports of pass and failure counts.If the custom comparison applies to a specific class, then you can add a custom equality operator for that class. If you do that in your setUp() method, then all the test methods can just call assertEquals() with that class, and your custom comparison will be called.
The built in unittest module has a specific method for this called addTypeEqualityFunc. You can read about it here.You just have to write your equality function and pass it and simply use the assertEqual method as usual.
Here's the full list of supported assertions in Python 3.6's unittest module.As you can see, there is no assertion that takes a custom predicate to evaluate, but you can get a more helpful error message by passing a custom error message to your assertion method through the msg argument.For instance:If that is not enough for you, you don't really need to go around digging into unittest: You could define a class that extends unittest's TestCase with the methods you need, i.e.:And then you would define your tests as:
You can override __eq__ method of return value class without convoluting the original unit by subclassing it.


Answer URL
https://docs.python.org/3/library/unittest.html#unittest.TestCase.addTypeEqualityFunc
https://docs.python.org/3/library/unittest.html#assert-methods
