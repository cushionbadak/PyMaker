Natural Text
I'm trying to write a simple Python function that sums all values that have the key as likes. I'm working with functional programming for this assignment. Thus, I am required to use either a list-comprehension, map, filter, or reduce. In this case, I see reduce as a reasonable option. The issue comes to when I actually run the code. I seem to receive something along the lines of: TypeError: 'int' object is not subscriptable. To me, this error makes no sense. If reduce is truly iterating through the given parameter, then each item passed into the lambda-function should be a dictionary - and each of them definitely has a likes key in them. What is the issue, and what exactly does this Python error mean?
To me, this error makes no sense. If reduce is truly iterating through the given parameter, then each item passed into the lambda-function should be a dictionaryNo, the first parameter passed to the lambda (for all calls except the first) is the return value from the previous call to the lambda. Your function returns a number, so it will be called with x being a number, not a dictionary.There are two ways to deal with this. The probably more straightforward one is:The 0 is the "initializer" argument to reduce, which provides the first value for x. Now in each call, x is the running sum and y is the next dictionary.Another way, just to show that it can be done, is:which makes the return value of the lambda be a dict with a likes key, just like its arguments, so we're working with the same type the whole way through. In this case it's unnecessary and wasteful, but if you were aggregating more than one key, it might be an interesting approach.
Depending on how exactly reduce is implemented, on your second iteration of reduce one operand passed to your lambda will not be a dict but the sum computed so far. Which gives you the error you are seeing.To avoid this you could first do a list or generator comprehension to extract all the values at "likes" from the various dicts and then reduce operator.add on those. Or just use sum.
In your code snippet reduce(lambda x, y: x["likes"] + y["likes"], msgs), x variable at first is the first element of list msgs (dict), but at the second iteration it'll be a sum of "likes" (int). So, to sum the likes use the initializer argument of reduce function doc.But I believe, using sum is a more pythonic way:
Consider how reduce is working. x is the accumulator variable that is set to the return value of the previous function.1st iteration2nd iteration
After reading Paul's response, I realized that to make sure that consistent data-types were always being summed up, I had to initiate reduce to use an int for 'x' and a dictionary for 'y'. Thus,


Answer URL
https://docs.python.org/3/library/functools.html#functools.reduce
