Natural Text
As per my understanding Python user defined class instances are by default immutable. Immutable objects does not change their hash value and they can be used as dictionary keys and set elements.I have below code snippet.Now, I will instantiate Person class and create an object and print its hash value.Now, I will mutate jane object and print its hash value.My question is even if jane object is mutable why its hash value is not changing? Also, I can use mutable jane object as dict key and set element.
To define a class with immutable instances, you can do something like this:A test:
The object remains the same, even if you are changing properties of the object.And no, there are only very few immutable objects in python - frozenset for instance. But classes are not immutable.If you want immutable objects, you have to make them so. E.g. forbid assigning new values to properties are turning new objects in that case.To achieve this, you can use the underscore convention: Prepend your fields with a "_" - this indicates to other developers that the value is private and should not be changed from the outside.If you want a class with an unchangeable "name" field you could use this syntax:Of course, _name CAN be changed by an dev, but that breaks the visible contract.
That is not the contract Python goes by  From the docs- emphasis added by me on the bolded parts:object.__hash__(self) Called by built-in function hash() and for  operations on members of hashed collections including set, frozenset,  and dict. __hash__() should return an integer. The only required  property is that objects which compare equal have the same hash value;  it is advised to mix together the hash values of the components of the  object that also play a part in comparison of objects by packing them  into a tuple and hashing the tuple. Example:And some more relevant information:If a class does not define an __eq__() method it should not define a __hash__() operation  either; if it defines __eq__() but not __hash__(), its instances will  not be usable as items in hashable collections. If a class defines  mutable objects and implements an __eq__() method, it should not  implement __hash__(), since the implementation of hashable collections  requires that a key’s hash value is immutable (if the object’s hash  value changes, it will be in the wrong hash bucket).And, to the core of your question:User-defined classes have __eq__() and __hash__() methods by default;  with them, all objects compare unequal (except with themselves) and  x.__hash__() returns an appropriate value such that x == y implies  both that x is y and hash(x) == hash(y).A class that overrides __eq__() and does not define __hash__() will  have its __hash__() implicitly set to None. When the __hash__() method  of a class is None, instances of the class will raise an appropriate  TypeError when a program attempts to retrieve their hash value, and  will also be correctly identified as unhashable when checking  isinstance(obj, collections.Hashable).
I will fill in the knowledge gaps in Christian's answer. From Python's official website (https://docs.python.org/2/reference/datamodel.html):The value of an immutable container object that contains a reference  to a mutable object can change when the latter’s value is changed;  however the container is still considered immutable, because the  collection of objects it contains cannot be changed. So, immutability  is not strictly the same as having an unchangeable value, it is more  subtle.When I look at an object A whose byte data never change, that is truly immutable. The byte data may contains pointer to other mutable objects, but that doesn't mean the object A is mutable. In your case, the object resides at a memory location. Python's hash generation is opaque. But if you are looking at things using the same reference, most likely the hash won't change, even when the bytes stored are different.In a strict sense, mutable objects aren't even hashable, so you shouldn't try to interpret the hash in the first place.To your question, just use a collections.namedtuple instead.
The reason is that to make this object hashable, despite the fact that it IS mutable, Python's default __hash__() method calculate the hash value from it's reference ID. This means that if you change it's content or copy the reference to another name, the hash value won't change, But if you copy it to another place or create another object with the same content, then it's value will be different.You can change that behaviour by redefining the __hash__() method, but you need to ensure that the object is  not mutable or you will break your « named collections » (dictionnaries, sets & their subclasses).


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__hash__
