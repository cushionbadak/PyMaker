Natural Text
I implemented the method __richcmp__ for a Cython extension type (cdef class). Some comparison cases are undefined (for example <), so I used to raise an Exception for them, as follows.I want to pprint containers of instances of this Cython class. pprint attempts to compare them, except for a TypeError. My understanding is that as TypeError, pprint anticipates the case of undefined __lt__, or the case of different types of objects (see also Python docs).However, __richcmp__ is implemented, so Python doesn't raise a TypeError. It calls __richcmp__, I raise an Exception, and that isn't ignored by pprint. Cython requires that __richcmp__ be implemented, so I don't have the option of defining only __eq__ and __ne__.I changed my code to raising a TypeError. It seems that if Python communicates the lack of __lt__ with a TypeError, then I should do the same, in order to signify that __lt__ is absent, despite the presence of an entire __richcmp__, which was a byproduct of using Cython, not the design intent.Does this reasoning make sense? Should I raise another kind of exception? Did I properly interpret the meaning of TypeError in this context?
Yes. Cython is using your implementation as the C API tp_richcompare. The documentation for that tells youIf you want to implement a type for which only a limited set of comparisons makes sense (e.g. == and !=, but not < and friends), directly raise TypeError in the rich comparison function.That gives you a fairly strong hint that it's the right thing to do.
@DavidW provided a very precise and helpful answer, thank you. It points at how to approach similar future questions: by looking at the generated C code. I'm posting this answer as complimentary information for posterity.Searching within the generated cudd.c file, we find the class signature:(The dots abbreviate lines irrelevant to our discussion.) The PyTypeObject is defined by the CPython C API. The function __pyx_pw_2dd is defined laterThe way to find the first excerpt is by first searching the C file for the Python line of interest (here the signature of Function.__richcmp__), and then search for callers of the C function (though guided by this discussion, I found them by searching for tp_richcompare).To confirm, I believe that Cython generates the first excerpt from Cython/Compiler/TypeSlots.py:Interestingly, the comment there perhaps suggests that in the future users will be able to implement separate comparator methods, thus not encountering themselves directly this question.


Answer URL
https://docs.python.org/3/reference/datamodel.html#special-method-names
https://docs.python.org/3/c-api/type.html#c.PyTypeObject
