Natural Text
So, I solved my code issue where the one below didn't work originally ,but I would like a explanation as to why my original code didn't work as expected. If I specified the variable 'grade' once in the if/elif/else section and set the 'and' operator to the parameters I need for it to work shouldn't grade be compared against both without having to use it twice?This is the code that didn't workThis was my fix
Computer language is not English. Humans are great at guessing what subject is repeated in a compound sentence, computers are not. You always explicitly state what you are testing against on both sides of a logical operator.That's because in the expression structure <left> and <right>, both left and right are always independent expressions. Expressions can build on expressions on expressions, but a computer programming language will not just re-use (a part of) the left expression in the right expression.So yes, you have to explicitly name grade again.Or you could use a different expression form. You could use a chained comparison expression; Python lets you collapse any expression of the form <foo> <comparison1> <shared> and <shared> <comparison2> <bar> into <foo> <comparison1> <shared> <comparison2> <bar>, and the shared expression will be executed just once. So if you turnedintoyou can replace that withHowever, note that the preceding test already handled the grade > 89 case, you can safely drop the upper bound tests:Last but not least, you can use a Computer Science trick. Rather than test each grade band separately, one by one, you could use bisection; this always works when your options are sorted.Instead of starting at the highest value, start in the middle; that divides the possibilities in 2. From there, you keep halving the possibilities until you have the right grade band. This means you only have to do, at most, Log(N) tests for N possibilities, while starting at the top grade will require up to N tests. For 5 tests that's not much of a difference (1.6 steps on average, vs 5), but when N becomes really large, then you'll quickly notice a difference; if you had 1 million options, you could find the matching option in less than 14 steps, guaranteed.The Python library includes an optimised implementation in the bisect module:
as you have noted you cannot do something likepython cannot understand that the and applies to a. It's invalid syntax because and and >= are both operators.You could do that simply with chained comparisons:(or in your case, with a division and a conversion)
Although the following line might sound intelligible as an English sentence if read aloud, it is  simply not correct python syntax:The reason is that and is a binary operator which takes two complete expressions, one to the left and one to the right. And <= 89 is not a complete expression.So your corrected version works:But actually Python also allows the following syntax:


Answer URL
https://docs.python.org/3/reference/expressions.html#comparisons
https://docs.python.org/3/library/bisect.html
