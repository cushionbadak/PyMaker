Natural Text
This question already has an answer here:Is floating point math broken?                    28 answers                For simple calculation, like 1-0.92*0.9My ipython3 gives the result0.17199999999999993instead of 0.172  ??
iPython uses 64-bit floating-point arithmetic. However, floating-point arithmetic is really binary, internally expressed in terms of ones and zeroes.Floating-point arithmetic cannot determine something as simple as 0.9 or 0.92 exactly, meaning you still have roundoff errors. That is the binary equivalent of repeating/recurring decimals. The only workaround is to express these decimals as exact fractions or use an arbitrary precision or fixed-point library: https://docs.python.org/3/library/fractions.htmlIn fact, floating-point arithmetic can only exactly express some non-integer numbers x which can be expressed in the form x = a/b where a,b are in lowest terms, a, b are integers, and b is either 1 or a power of two. It cannot exactly express tenths, or anything where the denominator b is a multiple of five, or any number other than 1 or 2. This is much like how lowest-term fractions a/b cannt be exactly represented as a decimal if b contains any factors other than 2 and 5.And furthermore, you have to keep in mind of the most and least significant values: they cannot be too far apart: 1.000000000000000000000001 as a double would drop the rightmost (least significant) 1.Here are some examples:100 = 100/1. b is 1, meaning 100 is integral. 100 is exactly represented.0.5 = 1/2. b is 2. 0.5 is exactly represented.0.125 = 1/8. b is a power of 2. 0.125 is exactly represented.0.9 = 9/10. b is 10, a multiple of 5. 0.9 cannot be exactly represented.0.92 = 41/50. b is 50, a multiple of 5. 0.92 also cannot be exactly represented.See Is Floating Point Math broken? for more information.


Answer URL
https://docs.python.org/3/library/fractions.html
