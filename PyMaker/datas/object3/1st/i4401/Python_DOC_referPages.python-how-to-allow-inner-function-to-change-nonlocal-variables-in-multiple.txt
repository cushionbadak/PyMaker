Natural Text
Suppose I have a function, which has a large section of code repeated in various places within the function, I can do the following:I can ‘read’ the variables that are in the scope of foo whilst inside bar, furthermore if I need to edit them, I can do this:The ProblemNow suppose I have several functions, foo_1, foo_2, foo_3… etc, all of which have the same lines of code from bar repeated in them. It would be monotonous (not to mention a nightmare every time I wanted to change bar) to define bar inside each foo_i, however doing the following does not work, since it appears nonlocal works on the scope in which a function is defined, not in which it is called:A potential solutionOne way round this problem it to pass in all of the variables that you need to change, and then return them afterwards. Something like this:My QuestionThe solution above has a few problems:It is considerably more verbose than simply bar() (especially when there are more variables)It isn't actually that much of an improvement on defining bar inside every foo_i since suppose a variable I previously just accessed within bar I now decide to edit. Not only do I need to change the function, but I need to change everywhere it is called (since now I must return an extra variable).Is there a better way of achieving the above?(This feels like the sort of problem that aught to have an answer, so I apologise if it’s a repeated question. I haven’t been able to find anything as yet though.)
[...] it appears nonlocal works on the scope in which a function is defined, not in which it is called [...].You are correct. nonlocal only applies to the namespace in which said function is defined. From the documentation for nonlocal:The nonlocal statement causes the listed identifiers to refer to previously bound variables in the nearest enclosing scope excluding globals. (emphasis mine)As @Aran mentioned, a potential solution to avoid unnecessary verbosity is to wrap the variables you want to pass into certain functions in a class. namedtuple would be a attractive choice since you don't need a full-fledge class, but as has been stated, it is immutable. You can use a types.SimpleNamespace object instead, as they are also lightweight:
You can declare those variables as global before modifying them inside each function, but they need to be declared before any function that uses them, also keep in mind that this will modify the variables for the scopes of ANY function in which they are declared as global:


Answer URL
https://docs.python.org/3/reference/simple_stmts.html#the-nonlocal-statement
https://docs.python.org/3/library/types.html#types.SimpleNamespace
