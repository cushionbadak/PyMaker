Natural Text
I understand why the first for loop works; that loop is essentially looping through a list, as per the readlines() method.The second for loop doesn't make sense to me. The loop is opening the file, but since the default for an open statement is read, shouldn't the output be the whole file in one big string upon each iteration, instead of a single line?Here's the code:
You misunderstood the 'default' here. The default you found talks about the file mode; the default is to open the file for reading. The file won't be read at that point, it tells the OS that you want to access a file that already has to exist and is readable by your process.open() returns a file object, always. And file objects are iterables, so you can loop over one, provided it is opened for reading (so the mode is 'r', or 'w+' or 'a+').From the open() documentation:Open file and return a corresponding file object.andmode is an optional string that specifies the mode in which the file is opened. It defaults to 'r' which means open for reading in text mode. Other common values are 'w' for writing (truncating the file if it already exists), 'x' for exclusive creation and 'a' for appending[.]open() always returns an object that inherits from io.IOBase, and it says this about iteration:IOBase (and its subclasses) supports the iterator protocol, meaning that an IOBase object can be iterated over yielding the lines in a stream. Lines are defined slightly differently depending on whether the stream is a binary stream (yielding bytes), or a text stream (yielding character strings).You should always use iteration over the file over iteration over .readlines(); the latter reads all lines into memory in one step, puts all those lines into a list, then returns that list. This will certainly cause issues when the file you opened is large. If all you need is access to the individual lines, one by one, iteration over the file itself will only create lines as needed, and buffering takes care of making this efficient (the OS is asked to give data in convenient chunks for Python to process into lines).Note that even if open() returned a single string containing all of the file contents, iteration would then take place on a sequence of characters; you would not see the file contents repeated. You could try this out with the file.read() command:Another reason that the file data wouldn't repeat is that files are a lot like classical magnetic tape: files have a file position, which moves forward along the file as you read data from it, and this position doesn't automatically go back to the start once you reach the end. Without re-opening a file, or using the file.seek() method to set the file position to the start again, you only get to read the data once:
A loopis basically a shorthand forSo the for loop extracts values from an iterator constructed from the iterable one by one and automatically recognizes when that iterator is exhausted and stops.It just happens that the return value of open is an iterator that gives you one line for each call to its __next__ method.Bonus:In your case, open('test.txt') returns an iterator, so calling __iter__ on it returns the iterator itself.
Check python documentation:https://docs.python.org/3/library/functions.html#openThe default mode is 'r' (open for reading text, synonym of 'rt'). For binary read-write access, the mode 'w+b' opens and truncates the file to 0 bytes. 'r+b' opens the file without truncation.As mentioned in the Overview, Python distinguishes between binary and text I/O. Files opened in binary mode (including 'b' in the mode argument) return contents as bytes objects without any decoding. In text mode (the default, or when 't' is included in the mode argument), the contents of the file are returned as str, the bytes having been first decoded using a platform-dependent encoding or using the specified encoding if given.It's because of default setting of open() function


Answer URL
https://docs.python.org/3/library/functions.html#open
https://docs.python.org/3/glossary.html#term-file-object
https://docs.python.org/3/library/io.html#io.IOBase
https://docs.python.org/3/library/functions.html#open
