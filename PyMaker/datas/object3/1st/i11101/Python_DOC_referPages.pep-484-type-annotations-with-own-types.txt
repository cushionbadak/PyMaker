Natural Text
PEP-484 provides semantics for type annotations.These are geared very much towards a) documentation and b) help for IDEs. They are less geared towards code optimization.For example, it is unfortunately not possible to use PEP 484 annotations either with Cythonhttps://groups.google.com/d/msg/cython-users/DHcbk78rDec/6-b5XtCRGBEJor with Numba, the latter using its own annotation format in the form of strings like "float64(int32, int32)"http://numba.pydata.org/numba-doc/0.24.0/reference/types.htmlHow do I work within the framework of PEP 484 with my own types?I explicitly do not want to break PEP-484 semantics, but augment the existing types with additional informationvisible to my own type checker, but invisible to any PEP-484 conforming type checker or IDE.Will the following be interpreted within the PEP-484 semantics as List[int]?How about a more fancy type like this?Any recommendations for libraries to work with type-hinting, both for type parsing and type checking?
Since Python 3.5, we not only have the PEP 483, PEP 484, but also typing module that implements it.For complete understanding, you might want to read through those 3 documents. But for your specific case, the short answer is that in PEP484 realm you can work with own types in 4 ways:just annotate using own types,create type aliases,use NewType, oruse own generic typesIf what you seek is above all else:additional information visible to my own type checker, but invisible to any PEP-484 conforming type checkerthen the 2nd approach gives you just that. If you do:Then Int32 and Int64 would be the same in PEP484 realm, but you could add some additional checks by looking into the AST (Abstract Syntax Tree) of your code using community-maintained typed-ast module. That module parses type comments in addition to code, so you can read the exact annotation used, and thus get some additional type information for x and y.And, if being invisible is not the number one priority, then:instead of class Int32(int): pass I would rather do typing.NewType('Int32', int), andinstead of combine(Int32, Metre) I would use typing.Union[Int32, Metre].i.e.On the above code, you can run community-maintained static type-checker mypy.Both typed-ast and mypy are now (year 2016) under very active development. Not everything works as expected, but as far as I can see they are good enough for many use cases already, and also there seem to be no alternatives.


Answer URL
https://docs.python.org/3/library/typing.html
https://docs.python.org/3/library/typing.html#type-aliases
https://docs.python.org/3/library/typing.html#newtype
https://docs.python.org/3/library/typing.html#user-defined-generic-types
