Natural Text
I have an app that currently allows a user to upload a file and it saves the file on the web server. My client has now decided to use a third party cloud hosting service for their file storage needs. The company has their own API for doing CRUD operations on their server, so I wrote a script to test their API and it sends a file as a base64 encoded JSON payload to the API. The script works fine but now I'm stuck on how exactly how I should implement this functionality into Django.json_testing.pymodels.pySo to reiterate, when a user uploads a file, instead of storing the file somewhere on the web server, I want to base64 encode the file so I can send the file as a JSON payload. Any ideas on what would be the best way to approach this? 
The simplest way I can put this is that I want to avoid saving the  file to the web server entirely. I just want to encode the file, send  it as a payload, and discard it, if that's possible.From the django docs:Upload HandlersWhen a user uploads a file, Django passes off the file data to an  upload handler – a small class that handles file data as it gets  uploaded. Upload handlers are initially defined in the  FILE_UPLOAD_HANDLERS setting, which defaults to:["django.core.files.uploadhandler.MemoryFileUploadHandler",   "django.core.files.uploadhandler.TemporaryFileUploadHandler"]   Together  MemoryFileUploadHandler and TemporaryFileUploadHandler provide  Django’s default file upload behavior of reading small files into  memory and large ones onto disk.You can write custom handlers that customize how Django handles files.  You could, for example, use custom handlers to enforce user-level  quotas, compress data on the fly, render progress bars, and even send  data to another storage location directly without storing it locally.  See Writing custom upload handlers for details on how you can  customize or completely replace upload behavior.Contrary thoughts:I think you should consider sticking with the default file upload handlers because they keep someone from uploading a file that will overwhelm the server's memory.Where uploaded data is storedBefore you save uploaded files, the data needs to be stored somewhere.By default, if an uploaded file is smaller than 2.5 megabytes, Django  will hold the entire contents of the upload in memory. This means that  saving the file involves only a read from memory and a write to disk  and thus is very fast.However, if an uploaded file is too large, Django will write the  uploaded file to a temporary file stored in your system’s temporary  directory. On a Unix-like platform this means you can expect Django to  generate a file called something like /tmp/tmpzfp6I6.upload. If an  upload is large enough, you can watch this file grow in size as Django  streams the data onto disk.These specifics – 2.5 megabytes; /tmp; etc. – are simply “reasonable  defaults” which can be customized as described in the next section.  request.FILES info:A view handling this form will receive the file data in request.FILES,  which is a dictionary containing a key for each FileField (or  ImageField, or other FileField subclass) in the form. So the data from  the above form would be accessible as request.FILES[‘json_file’].Note that request.FILES will only contain data if the request method  was POST and the <form> that posted the request has the attribute  enctype="multipart/form-data". Otherwise, request.FILES will be empty.HttpRequest.FILESA dictionary-like object containing all uploaded files. Each key in  FILES is the name from the <input type="file" name="" />. Each value  in FILES is an UploadedFile.Upload HandlersWhen a user uploads a file, Django passes off the file data to an  upload handler – a small class that handles file data as it gets  uploaded. Upload handlers are initially defined in the  FILE_UPLOAD_HANDLERS setting, which defaults to:["django.core.files.uploadhandler.MemoryFileUploadHandler",   "django.core.files.uploadhandler.TemporaryFileUploadHandler"]The source code for TemporaryFileUploadHandler contains this:And the source code for TemporaryUploadedFile contains this:And the python tempfile docs say this:tempfile.NamedTemporaryFile(...., delete=True)  ...  If delete is true (the default), the file is deleted as soon as it is closed.Similarly, the other of the two default file upload handlers, MemoryFileUploadHandler, creates a file of type BytesIO:A stream implementation using an in-memory bytes buffer. It inherits  BufferedIOBase. The buffer is discarded when the close() method is  called.Therefore, all you have to do is close request.FILES[“field_name”] to erase the file (whether the file contents are stored in memory or on disk in the /tmp file directory), e.g.:If for some reason you don't want django to write to the server's /tmp directory at all, then you'll need to write a custom file upload handler to reject uploaded files that are too large.


Answer URL
https://docs.python.org/3/library/tempfile.html#tempfile.NamedTemporaryFile
https://docs.python.org/3/library/io.html#io.BytesIO
