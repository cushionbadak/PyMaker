Natural Text
I am working through a tutorial on sets in Python 2.7, and I have run into a behavior using a for loop that I do not understand, and I am trying to find out what the reason for the difference in outputs might be.The object of the exercise is to produce a set, cities, from a dictionary that contains keys made up of city pairs of frozen sets using a for loop. The data comes from the following dictionary:There is also a test list that will create the intended set as a check:When the code is written in the following form, the loop produces the intended result.Output:However, if I attempt as a comprehension, with either of the following, I get a different result.orOutput for both:I cannot figure out why the for loop in the first example unpacks the pairs as intended so that it produces a set with one instance of each city, while trying to write the loop as a comprehension pulls out the frozenset([city1, city2]) pairs and places them in the set instead. I do not understand why pair would give the city strings in the first instance but passes the frozenset in the second instance.Can someone explain the different behavior?Note: As explained by Holt and donkopotamus, the issue of why this was behaving differently was that using the comprehension evaluated the entire dictionary completely before making a single assignment to the cities variable, thus creating a set of frozensets, where as the standard for loop unpacked the pairs one at a time and evaluated each individual one separately, assigning them to cities one at a time with each pass of the for loop and allowing the union function to evaluate each instance of the pairs being passed to it.They further explained that using the *-operator unpacks the dictionary in the comprehension to produce the desired behavior.
In the first version, pair is a frozenset at each loop, so you can do a union with it, while in your version, you try do a union with a set of frozenset.The first case comes down to (union with a frozenset at each iteration):So you have (mathematically):In your (last) case, you are doing the following (one union with a sequence of frozenset):So you have:Since no two pairs are identical, you get a set of all the pairs in your initial dictionary, because you are passing a set of set (pair) of cities, not a set of cities to .union().On a more abstract point of view, you are trying to obtain:With:
The expression:will take the union of the empty set {} with another setleaving you with a set of sets. In contrast, the following will give you all of the cities flown to:Here we transform each of the frozen set keys into a plain set and find the union.


Answer URL
https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists
https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists
