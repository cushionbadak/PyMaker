Natural Text
I want to use annotations to have better auto-completion in IDEs, and maybe later type testing in automated tests. But how can you add type annotations to many methods without introducing a lot of extra code?For example, imagine that you have a big code base which uses the Django framework, including about 200 methods with a request argument; adding the type annotations 200 times would bloat the code. My current idea is to include type annotations at the package level: in setup.py (or somewhere else). I define a rule that says "every time the variable request gets used, it is of type django.http.HttpRequest". For edge cases where the variable with the name request points to a different type, explicit annotations should be done, but there are very few of these.How can this be implemented? Are there other ways to achieve the overall goal?
If my understanding is correct, this sounds like a use-case for stub files which, as described in PEP 484: Stub files are files containing type hints that are only for use by the type checker, not at runtime.Stub files pretty much fulfill your requirement of separating code from type annotations thereby avoiding the bloating and obfuscating effect of complex type hints. They have a prefix of .pyi and, if a type checker implemented by an IDE that wants to conform to PEP 484, must always be examined by the type checker if they exist. They essentially consist of the annotated function signatures with a body containing a single ellipsis ...One way you could go about this is using a helper function to write out your .pyi, or, at least, the bulk of it. There's probably many ways to do this and which is the best is probably another question altogether. As an example of a way to do this, I'll write out a way to annotate every function in the inspect module that has a parameter named object and doesn't start with an underscore. I'm typing this specific module since I'll also be using it for identifying functions and grabbing their signatures.  From the inspect module, I'll be using the getmembers, isfunction and signature functions.This logic could be extended to methods, other parameter types and so on. Also, an important note, the .pyi file should have the same name as the module you're annotating, so in this case it should be inspect.pyi.For now, this simply prints out all functions which have a parameter named object with the 'annotation' (object) we supplied:most production ready checkers will read this .pyi file and provide the functionality you need.
You could use a custom middleware (untested):By default, this middleware would affect all URLs. For the few URLs for which you do not want to check the type of request, add a parameter in the corresponding lines of urls.py:and put the specific annotations in the definition of my_view().


Answer URL
https://docs.python.org/3/library/inspect.html#inspect.getmembers
https://docs.python.org/3/library/inspect.html#inspect.isfunction
https://docs.python.org/3/library/inspect.html#introspecting-callables-with-the-signature-object
