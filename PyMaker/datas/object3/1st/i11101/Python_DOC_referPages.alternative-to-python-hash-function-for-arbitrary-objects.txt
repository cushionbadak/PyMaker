Natural Text
In python2.7, I'm successfully using hash() to place objects into buckets stored persistently on disk. A mockup code looks like this:In python3, hash() uses a random or fixed salt, which makes it unusable/suboptimal for this [1]. Apparently, it's not possible to use a fixed salt for specific invocations. So, I need an alternative:Must be stable across interpreter invocationsMay require parameters supplied at execution time, e.g. setting a salt in the callMust support arbitrary objects (anything supported by dict/set)I've already tried using hash functions from hashlib (slow!) and checksums from zlib (apparently not ideal for hashing, but meh) which work fine with strings/bytes. However, they work only on bytes-like objects, whereas hash() works with almost everything.[1] Using hash() to identify buckets is either:Not reliable across interpreter invocations, if salts are randomPrevents applications from using the random salting feature, if salts are fixedUnusable if two PersistentDicts were created with different salts
I've had success using a combination of hash and zlib.adler32. The most straightforward implementation is this:With Python 3.4.3, this is a lot slower than calling plain hash, which takes roughly 0.07 usec. For a regular object, hashkey takes ~1.0 usec instead. 0.8 usec for bytes and 0.7 for str.Overhead is roughly as follows:0.1 usec for the function call (hash(obj) vs def pyhash(obj): return hash(obj))0.2 usec to 0.5 usec for selecting the hash function via isinstance0.75 usec for zlib.adler32 or zlib.crc32 vs hash: ~0.160 usec vs ~Â 0.75 usec (adler and crc are +/- 4 usec)0.15 usec for obj.encode() of str objects ("foobar")1.5 usec for str(obj).encode() of datetime.datetime objectsThe most optimization comes from ordering of the if statements. If one mostly expects plain objects, the following is the fastest I could come up with:Total time: ~0.7 usec for str and bytes, abysmal for datetime, 0.35 usec for objects, ints, etc. Using a dict to map type to hash comparable, if one uses an explicit check on the dict keys (aka types) separately (i.e. not obj.__class__ in hashkey.dict_types but obj.__class__ in hashkey.explicit_dict_types).Some additional notes:hash is not stable across interpreter starts for any object using the default __hash__ implementation, including NoneIt does not work properly for immutable containers (which define __hash__) containing a salted type, e.g. (1, 2, 'three')


Answer URL
https://docs.python.org/3/library/hashlib.html
https://docs.python.org/3/library/zlib.html#zlib.adler32
