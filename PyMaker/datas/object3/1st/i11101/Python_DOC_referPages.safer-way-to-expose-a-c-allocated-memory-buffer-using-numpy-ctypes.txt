Natural Text
I'm writing Python bindings for a C library that uses shared memory buffers to store its internal state. The allocation and freeing of these buffers is done outside of Python by the library itself, but I can indirectly control when this happens by calling wrapped constructor/destructor functions from within Python. I'd like to expose some of the buffers to Python so that I can read from them, and in some cases push values to them. Performance and memory use are important concerns, so I would like to avoid copying data wherever possible.My current approach is to create a numpy array that provides a direct view onto a ctypes pointer:As well as avoiding copies, this also means I can use numpy's indexing and assignment syntax and pass it directly to other numpy functions:However, it's also inherently dangerous:To make this safer, I need to be able to check whether the underlying C pointer has been freed before I try to read/write to the array contents. I have a few thoughts on how to do this:One way would be to generate a subclass of np.ndarray that holds a reference to the _cbuf attribute of MyWrapper, checks whether it is None before doing any reading/writing to its underlying memory, and raises an exception if this is the case.I could easily generate multiple views onto the same buffer, e.g. by .view casting or slicing, so each of these would need to inherit the reference to _cbuf and the method that performs the check. I suspect that this could be achieved by overriding __array_finalize__, but I'm not sure exactly how.The "pointer-checking" method would also need to be called before any operation that would read and/or write to the contents of the array. I don't know enough about numpy's internals to have an exhaustive list of methods to override.How could I implement a subclass of np.ndarray that performs this check? Can anyone suggest a better approach?Update: This class does most of what I want:For example:I'm sure there are other edge cases I've missed.Update 2: I've had a play around with weakref.proxy, as suggested by @ivan_pozdeev. It's a nice idea, but unfortunately I can't see how it would work with numpy arrays. I could try to create a weakref to the numpy array returned by .buffer:I think the problem here is that the np.ndarray instance returned by wrap.buffer immediately goes out of scope. A workaround would be for the class to instantiate the array on initialization, hold a strong reference to it, and have the .buffer() getter return a weakref.proxy to the array:However, this breaks if I create a second view onto the same array whilst the buffer is still allocated:This is seriously broken - after calling wrap2.__del__() not only can I read and write to buf2 which was a numpy array view onto wrap2._cbuf, but I can even read and write to buf, which should not be possible given that wrap2.__del__() sets wrap2._buffer to None.
You have to keep a reference to your Wrapper while any numpy array exists. Easiest way to achieve this, is to save this reference in a attribute of the ctype-buffer:This way you're wrapper is automatically freed, when the last reference, e.g the last numpy array, is garbage collected.
It's a proprietary library written by a third party and distributed as a binary. I could call the same library functions from C rather than Python, but that wouldn't help much since I still don't have any access to the code that actually allocates and frees the buffers. I can't, for example, allocate the buffers myself and then pass them to the library as pointers.You could, however, wrap the buffer in a Python extension type. That way you can expose only the interface you want to be available, and let the extension type automatically handle the freeing of the buffer. That way it's not possible for the Python API to do a free memory read/write.mybuffer.ctest.pyExample
weakref is a built-in mechanism for the functionality you are proposing.Specifically, weakref.proxy is an object with the same interface as the referred one. After the referenced object's disposal, any operation on the proxy raises weakref.ReferenceError. You don't even need numpy:As you can see, in any case, you need a normal Python object over the C buffer. If an external library owns the memory, the object must be deleted before the buffer is freed on the C level. If you own the memory yourself, you just create a ctypes object the normal way, then it will be freed when it's deleted.So, if your external library owns the memory and can free at any time (your specification is vague about this), it must tell you somehow it's about to do so - otherwise, you have no way to know about that to take necessary action.
You just need a wrapper with additional __del__ function before passing it to the numpy.ctypeslib.as_array method.To testIn fact a more easier solution is to overwrite __del__ function
I liked @Vikas's approach, but when I tried it, I only got a Numpy object-array of a single FreeOnDel object. The following is much simpler and works:where ptr is a pointer to the data as an integer (e.g. ctypesptr.addressof(...)).This __array_interface__ attribute is sufficient to tell Numpy how to cast a region of memory as an array, and then the FreeOnDel object becomes that array's base. When the array is deleted, the deletion is propagated to the FreeOnDel object, where you can call libc.free.I might even call this FreeOnDel class "BufferOwner", because that's its role: to track ownership.
If you can completely control the C buffer's lifetime from Python, what you essentially have is a Python "buffer" object that an ndarray should use.Thus,there are 2 fundamental ways to connect them:buffer -> ndarrayndarray -> bufferthere's also a question how to implement the buffer itselfbuffer -> ndarrayIs unsafe: there's nothing automatically holding a reference to buffer for the lifetime of ndarray. Introducing a 3rd object to hold references to both isn't any better: then you just have to keep track of the 3rd object instead of the buffer.ndarray -> buffer"Now you're talking!" Since the very task at hand is "buffer that an ndarray should use"? this is the natural way to go.In fact, numpy has a built-in mechanism: any ndarray that doesn't own its memory holds a reference to the object that does in its base attribute (thus preventing the latter from being garbage collected). For views, the attribute is automatically assigned accordingly (to the parent object if its base is None or to the parent's base).The catch is you cannot just place any old object there. Instead, the attribute is filled by a constructor and the suggested object is first put through its scrunity.So, if only we could construct some custom object that numpy.array accepts and considers eligible for memory reuse (numpy.ctypeslib.as_array is actually a wrapper for numpy.array(copy=False) with a few sanity checks)...<...>


Answer URL
