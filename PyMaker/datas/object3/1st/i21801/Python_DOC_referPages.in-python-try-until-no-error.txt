Natural Text
I have a piece of code in Python that seems to cause an error probabilistically because it is accessing a server and sometimes that server has a 500 internal server error. I want to keep trying until I do not get the error. My solution was:This seems like a hack to me. Is there a more Pythonic way to do this?
It won't get much cleaner. This is not a very clean thing to do. At best (which would be more readable anyway, since the condition for the break is up there with the while), you could create a variable result = None and loop while it is None. You should also adjust the variables and you can replace continue with the semantically perhaps correct pass (you don't care if an error occurs, you just want to ignore it) and drop the break - this also gets the rest of the code, which only executes once, out of the loop. Also note that bare except: clauses are evil for reasons given in the documentation.Example incorporating all of the above:
Maybe something like this:
Here is one that hard fails after 4 attempts, and waits 2 seconds between attempts. Change as you wish to get what you want form this one:Here is an example with backoff:
The itertools.iter_except recipes encapsulates this idea of "calling a function repeatedly until an exception is raised".  It is similar to the accepted answer, but the recipe gives an iterator instead.From the recipes:You can certainly implement the latter code directly.  For convenience, I use a separate library, more_itertools, that implements this recipe for us (optional).  CodeDetailsHere the pop method (or given function) is called for every iteration of the list object until an IndexError is raised.For your case, given some connect_function and expected error, you can make an iterator that calls the function repeatedly until an exception is raised, e.g.At this point, treat it as any other iterator by looping over it or calling next().
Here's an utility function that I wrote to wrap the retry until success into a neater package. It uses the same basic structure, but prevents repetition. It could be modified to catch and rethrow the exception on the final try relatively easily.Can then be called like thisIf you need to pass arguments to my_function, you can either do this by having try_until forward the arguments, or by wrapping it in a no argument lambda:
Maybe decorator based?You can pass as decorator arguments list of exceptions on which we want to retry and/or number of tries.of course the 'try' part should be moved to another funcion becouse we using it in both loops but it's just example;)
Like most of the others, I'd recommend trying a finite number of times and sleeping between attempts. This way, you don't find yourself in an infinite loop in case something were to actually happen to the remote server.I'd also recommend continuing only when you get the specific exception you're expecting. This way, you can still handle exceptions you might not expect.Also, you don't need an else block. Because of the continue in the except block, you skip the rest of the loop until the try block works, the while condition gets satisfied, or an exception other than HTTPError comes up.
This should work. It sets e to '' and the while loop checks to see if it is still ''. If there is an error caught be the try statement, it prints that the connection was refused, waits 1 second and then starts over. It will keep going until there is no error in try, which then sets e to ' ', which kills the while loop. 
Here is a short piece of code I use to capture the error as a string. Will retry till it succeeds. This catches all exceptions but you can change this as you wish.WARNING: This code will be stuck in a forever loop until no exception occurs.  This is just a simple example and MIGHT require you to break out of the loop sooner or sleep between retries.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools-recipes
