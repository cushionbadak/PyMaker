Natural Text
I'd like something that has the same effect as this:But that will work with Windows paths too. I know that there is an os.path.split() but that doesn't do what I want, and I didn't see anything that does.
The OP specified "will work with Windows paths too". There are a few wrinkles with Windows paths.Firstly, Windows has the concept of multiple drives, each with its own current working directory, and 'c:foo' and 'c:\\foo' are often not the same. Consequently it is a very good idea to separate out any drive designator first, using os.path.splitdrive(). Then reassembling the path (if required) can be done correctly bydrive + os.path.join(*other_pieces)Secondly, Windows paths can contain slashes or backslashes or a mixture. Consequently, using os.sep when parsing an unnormalised path is not useful.More generally:The results produced for 'foo' and 'foo/' should not be identical.The loop termination condition seems to be best expressed as "os.path.split() treated its input as unsplittable".Here's a suggested solution, with tests, including a comparison with @Spacedman's solutionand here's the output (Python 2.7.1, Windows 7 Pro):
Python 3.4 introduced a new module pathlib.  pathlib.Path provides file system related methods, while pathlib.PurePath operates completely independent of the file system:You can use PosixPath and WindowsPath explicitly when desired:And of course, it works with Windows paths as well:Huzzah for Python devs constantly improving the language!
Someone said "use os.path.split". This got deleted unfortunately, but it is the right answer.os.path.split(path)Split the pathname path into a pair, (head, tail) where tail is the last pathname component and head is everything leading up to that. The tail part will never contain a slash; if path ends in a slash, tail will be empty. If there is no slash in path, head will be empty. If path is empty, both head and tail are empty. Trailing slashes are stripped from head unless it is the root (one or more slashes only). In all cases, join(head, tail) returns a path to the same location as path (but the strings may differ).So it's not just splitting the dirname and filename. You can apply it several times to get the full path in a portable and correct way. Code sample:Please credit the original author if that answer gets undeleted.
Use the functionality provided in os.path, e.g.Like written elsewhere you can call it multiple times to split longer paths.
Use the functionality provided in os.path, e.g.(This answer was by someone else and was mysteriously and incorrectly deleted, since it's a working answer; if you want to split each part of the path apart, you can call it multiple times, and each call will pull a component off of the end.)
Here's an explicit implementation of the approach that just iterativelyuses os.path.split; uses a slightly different loop termination condition than the accepted answer.This should satisfy os.path.join( *splitpath(path) ) is path in the sense that they both indicate the same file/directory. Tested in linux:I hand checked a few of the DOS paths, using the by replacing os.path with ntpath module, look OK to me, but I'm not too familiar with the ins and outs of DOS paths.
One more try with maxplit option, which is a replacement for os.path.split()
So keep using os.path.split until you get to what you want. Here's an ugly implementation using an infinite loop:Stick that in parts.py, import parts, and voila:Probably a nicer implementation using generators or recursion out there...


Answer URL
https://docs.python.org/3/library/pathlib.html#module-pathlib
https://docs.python.org/3/library/pathlib.html#concrete-paths
https://docs.python.org/3/library/pathlib.html#pathlib.PurePath
