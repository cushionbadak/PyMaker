Natural Text
I have this Python code to do this:This takes approximately 174 usec to convert 2**9700 - 1 to a string of bytes on my machine.  If I'm willing to use the Python 2.7 and Python 3.x specific bit_length method, I can shorten that to 159 usecs by pre-allocating the l array to be the exact right size at the very beginning and using l[something] = syntax instead of l.append.Is there anything I can do that will make this faster?  This will be used to convert large prime numbers used in cryptography as well as some (but not many) smaller numbers.EditThis is currently the fastest option in Python < 3.2, it takes about half the time either direction as the accepted answer:In Python 3.2 the int class has to_bytes and from_bytes functions that can accomplish this much more quickly that the method given above.
For completeness and for future readers of this question:Starting in Python 3.2, there are functions int.from_bytes() and int.to_bytes() that perform the conversion between bytes and int objects in a choice of byte orders.
Here is a solution calling the Python/C API via ctypes.  Currently, it uses NumPy, but if NumPy is not an option, it could be done purely with ctypes.On my machine, this is 15 times faster than your  approach.Edit: Here is the same code using ctypes only and returning a string instead of a NumPy array:This is another two times faster, totalling to a speed-up factor of 30 on my machine.
I suppose you really should just be using numpy, which I'm sure has something or other built in for this. It might also be faster to hack around with the array module. But I'll take a stab at it anyway.IMX, creating a generator and using a list comprehension and/or built-in summation is faster than a loop that appends to a list, because the appending can be done internally. Oh, and 'lstrip' on a large string has got to be costly.Also, some style points: special cases aren't special enough; and you appear not to have gotten the memo about the new x if y else z construct. :) Although we don't need it anyway. ;)
Just wanted to post a follow-up to Sven's answer (which works great). The opposite operation - going from arbitrarily long bytes object to Python Integer object requires the following (because there is no PyLong_FromByteArray() C API function that I can find):


Answer URL
https://docs.python.org/3/library/stdtypes.html#int.from_bytes
https://docs.python.org/3/library/stdtypes.html#int.to_bytes
