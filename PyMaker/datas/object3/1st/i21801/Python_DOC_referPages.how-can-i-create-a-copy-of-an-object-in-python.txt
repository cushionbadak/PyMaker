Natural Text
I would like to create a copy of an object. I want the new object to possess all properties of the old object (values of the fields). But I want to have independent objects. So, if I change values of the fields of the new object, the old object should not be affected by that.
To get a fully independent copy of an object you can use the copy.deepcopy() function.For more details about shallow and deep copying please refer to the other answers to this question and the nice explanation in this answer to a related question.
How can I create a copy of an object in Python?So, if I change values of the fields of the new object, the old object should not be affected by that.You mean a mutable object then.In Python 3, lists get a copy method (in 2, you'd use a slice to make a copy):Shallow CopiesShallow copies are just copies of the outermost container.list.copy is a shallow copy:You don't get a copy of the interior objects. They're the same object - so when they're mutated, the change shows up in both containers.Deep copiesDeep copies are recursive copies of each interior object.Changes are not reflected in the original, only in the copy.Immutable objectsImmutable objects do not usually need to be copied. In fact, if you try to, Python will just give you the original object:Tuples don't even have a copy method, so let's try it with a slice:But we see it's the same object:Similarly for strings: and for frozensets, even though they have a copy method:When to copy immutable objectsImmutable objects should be copied if you need a mutable interior object copied.As we can see, when the interior object of the copy is mutated, the original does not change.Custom ObjectsCustom objects usually store data in a __dict__ attribute or in __slots__ (a tuple-like memory structure.)To make a copyable object, define __copy__ (for shallow copies) and/or __deepcopy__ (for deep copies).Note that deepcopy keeps a memoization dictionary of id(original) (or identity numbers) to copies. To enjoy good behavior with recursive data structures, make sure you haven't already made a copy, and if you have, return that.So let's make an object:And copy makes a shallow copy:And deepcopy now makes a deep copy:
Shallow copy with copy.copy()Deep copy with copy.deepcopy()Documentation: https://docs.python.org/3/library/copy.htmlTested on Python 3.6.5.
I believe the following should work with many well-behaved classed in Python:(Of course, I am not talking here about "deep copies," which is a different story, and which may be not a very clear concept -- how deep is deep enough?)According to my tests with Python 3, for immutable objects, like tuples or strings, it returns the same object (because there is no need to make a shallow copy of an immutable object), but for lists or dictionaries it creates an independent shallow copy.Of course this method only works for classes whose constructors behave accordingly. Possible use cases: making a shallow copy of a standard Python container class.


Answer URL
https://docs.python.org/3/library/copy.html
