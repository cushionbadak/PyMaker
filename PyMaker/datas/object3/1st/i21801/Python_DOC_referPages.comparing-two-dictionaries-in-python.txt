Natural Text
I have two dictionaries, but for simplification, I will take these two:Now, I want to compare whether each key, value pair in x has the same corresponding value in y. So I wrote this:And it works since a tuple is returned and then compared for equality.My questions:Is this correct? Is there a better way to do this? Better not in speed, I am talking about code elegance.UPDATE: I forgot to mention that I have to check how many key, value pairs are equal. 
If you want to know how many values match in both the dictionaries, you should have said that :) Maybe something like this:
What you want to do is simply x==y What you do is not a good idea, because the items in a dictionary are not supposed to have any order. You might be comparing [('a',1),('b',1)] with [('b',1), ('a',1)] (same dictionaries, different order).For example, see this:The difference is only one item, but your algorithm will see that all items are different

dic1 == dic2From python docs:  To illustrate, the following examples all return a dictionary equal  to  {"one": 1, "two": 2, "three": 3}:Valid for py2 and py3.
I'm new to python but I ended up doing something similar to @mouadThe XOR operator (^) should eliminate all elements of the dict when they are the same in both dicts.
Just use:
Since it seems nobody mentioned deepdiff, I will add it here just for the completeness.I find it very convenient for getting diff of (nested) objects in general.Output:NOTE:deepdiff package needs to be installed as this is not a standard packagesome effort will have to be put for parsing the resultHowever, for taking the diff of dictionaries, I find dictdiffer to be very handy.
@mouad 's answer is nice if you assume both dictionaries just contain simple values. However if you have dictionaries that contain dictionaries you'll get an exception as dictionaries are not hashable.Off the top of my head, something like this might work:
Yet another possibility, up to the last note of the OP, is to compare the hashes (SHA or MD) of the dicts dumped as JSON. The way hashes are constructed guarantee that if they are equal, the source strings are equal as well. This is very fast and mathematically sound. 
To test if two dicts are equal in keys and values:If you want to return the values which differ, write it differently:You would have to call it twice i.e 
CodeTest
The function is fine IMO, clear and intuitive. But just to give you (another) answer, here is my go:Can be useful for you or for anyone else..
I am using this solution that works perfectly for me in Python 3It compares dict, list and any other types that implements the "==" operator by themselves.If you need to compare something else different, you need to add a new branch in the "if tree".Hope that helps.
Here's another option:So as you see the two id's are different. But the rich comparison operators seem to do the trick:
In PyUnit there's a method which compares dictionaries beautifully. I tested it using the following two dictionaries, and it does exactly what you're looking for.I'm not recommending importing unittest into your production code. My thought is the source in PyUnit could be re-tooled to run in production. It uses pprint which "pretty prints" the dictionaries. Seems pretty easy to adapt this code to be "production ready".
In Python 3.6, It can be done as:-ret variable will be true if all the items of dict_1 in present in dict_2
see dictionary view objects:https://docs.python.org/2/library/stdtypes.html#dictThis way you can subtract dictView2 from dictView1 and it will return a set of key/value pairs that are different in dictView2:You can intersect, union, difference (shown above), symmetric difference these dictionary view objects.Better? Faster? - not sure, but part of the standard library - which makes it a big plus for portability
Here is my answer, use a recursize way:Hope that helps!
Below code will help you to compare list of dict in python 
Being late in my response is better than never!Compare Not_Equal is more efficient than comparing Equal. As such two dicts are not equal if any key values in one dict is not found in the other dict. The code below takes into consideration that you maybe comparing default dict and thus uses get instead of getitem []. Using a kind of random value as default in the get call equal to the key being retrieved - just in case the dicts has a None as value in one dict and that key does not exist in the other. Also the get != condition is checked before the not in condition for efficiency because you are doing the check on the keys and values from both sides at the same time.




Answer URL
https://docs.python.org/3/library/stdtypes.html#mapping-types-dict
