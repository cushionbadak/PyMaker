Natural Text
I have a dictionary of dictionaries, and I'm trying to output the information within them in a certain way so that it will be usable for downstream analysis. Note: All the keys in "dict" are in also in "list".This is the closest I've gotten to what I want, but it's still a long way off. Ideally what I want is:Is this even possible??
First, if I understand your structure, the list is just a way of ordering the keys for the outer dictionary, and a lot of your complexity is trying to use these two together to simulate an ordered dictionary. If so, there's a much easier way to do that: use collections.OrderedDict. I'll come back to that at the end.First, you need to get all of the keys of your sub-dictionaries, because those are the rows of your output.From comments, it sounds like all of the sub-dictionaries in dct have the same keys, so you can just pull the keys out of any arbitrary one of them:If each sub-dictionary can have a different subset of keys, you'll need to instead do a first pass over dct to get all the keys:Some people find reduce hard to understand, even when you're really just using it as "sum with a different operator". For them, here's how to do the same thing explicitly:Now, for each key's row, we need to get a column for each sub-dictionary (that is, each value in the outer dictionary), in the order specified by using the elements of the list as keys into the outer dictionary.So, for each column item, we want to get the outer-dictionary value corresponding to the key in item, and then in the resulting sub-dictionary, get the value corresponding to the row's key. That's hard to say in English, but in Python, it's just:If you don't actually have all the same keys in all of the sub-dictionaries, it's only slightly more complicated:So, if you didn't want any headers, it would look like this:To add a header column, just prepend the header (in this case, key) to each of those rows:Notice that I turned the genexp into a list comprehension so I could use list concatenation to prepend the key. It's conceptually cleaner to leave it as an iterator, and prepend with itertools.chain, but in trivial cases like this with tiny iterables, I think that's just making the code harder to read:You also want a header row. That's even easier; it's just the items in the list, with a blank column prepended for the header column:However, there are two ways to make things even simpler.First, you can use an OrderedDict, so you don't need the separate key list. If you're stuck with the separate list and dict, you can still build an OrderedDict on the fly to make your code easier to read. For example:And now:Second, you could just build the transposed structure:And then iterate over it in the obvious order (or use a DictWriter to handle the ordering of the columns for you, and use its writerows method to deal with the rows, so the whole thing becomes a one-liner).
To store objects in Python so that you can re-use them later, you can you use the shelve module. This a module that lets you write objects to a shelf file and re-open it and retrieve the objects later, but it's operating system-dependent, so it won't work if say you made it on a Mac and later you want to open it on a Windows machine.To read objects from a shelf:
It may be a matter of opinion, but I think one of the best (and by far easieset) ways to serialize a (nested) dictionnary is using the JSON format:The best is that this can be done (either for encoding your values or decoding them) in a single line using the builtin json module !Let's consider your dictionnary is the dico variable:Et voil√† :-) !
If the data is guaranteed to be loaded back into Python, I'd suggest simply using pickle instead of worrying about the format. If it's going to be loaded into another standard language, then consider using json instead - there are libraries for most languages to parse JSON format data.That said if you really need to invent your own format, you could do something like this to store all keys from all sub-dictionaries in CSV format:


Answer URL
