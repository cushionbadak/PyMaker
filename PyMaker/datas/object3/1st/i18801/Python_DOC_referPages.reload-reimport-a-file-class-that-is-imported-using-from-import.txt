Natural Text
well, as the title say, i got a group of import, all import a class, all in the same folder as the script running it:python3 doesn't have reload iirc but there is imp.reload() but it doesn't seem to work,it just throw a error saying it not a module (it a class so it doesn't work)after every little edit in those class that are imported, i would need to restart the scriptisn't there a way to reload/reimport the class to show the effect of the edit without needing to start the script or rewriting most of the script so that imp.reload() works?python3, linux (but prefer if it also work on window)edit1:example: if i use:it return:if i change it to show °F and reload it using imp.reloadit return:so, it works BUT if i useit return:then i change it to show °F and reload it using imp.reloadit still returnBUT again, if i call it this way:it returnidk why it that but it is cause it happen in a while loop?edit2:file name: system.py:before changing for test:after changing for test:
You can only reload a module:The argument must be a module object, so it must have been successfully imported before.In your case, you don't have any reference to the module object. You will have to import it, even if you don't want to use it for anything else, just for the sake of calling reload later.Also, after the reload, you have re-import the names:Other references to the old objects (such as names external to the module) are not rebound to refer to the new objects and must be updated in each namespace where they occur if that is desired.When you do from foo import bar, that bar is a "name external to the module", so you have to rebind it explicitly.If you think about it, it has to work this way. There's no way reload can enumerate all objects whose definition is dependent on the previous version of the module to update them. Even if it could, there could be infinite cycles. And what would happen if the new version didn't even have a definition for a class that was in the old one? Or if the class were defined dynamically?Looking at it another way, from foo import bar is very similar to import foo; bar = foo.bar. bar is a name in your namespace, not foo's namespace, so reload(foo) will not touch it; you need to copy the new foo.bar over again.The easy way to solve all of these problems is to just repeat all of your from foo import bar lines after the reload.For simple cases:However, most of your examples have an obvious naming conflict: once you from video import video, you can no longer reload(video). So, you need another reference to the video module object.Python keeps one around for you, which you can use:Or, alternatively, you can use an as clause, or just an = assignment, to give it whatever name you want.From your comments and your edited question, it sounds like you have a further problem. Let's use one of the simple non-colliding cases to discuss it.I believe you're actually doing something like this:The first line will successfully reload the video module, and the second will copy its MLStripper class into your globals, so any new MLStripper instances you created will be of the new type.But that doesn't affect any existing MLStripper instances, like stripper. Just like MLStripper was, stripper is one of those "names external to the module". But it's actually even worse. In order to adjust it, reload would have to figure out what its state would have been, had the new version of the code been in effect from the time it was created. It should be obvious that this is an unsolvable problem.If you know the instances you want to patch up, you can deal with them in effectively the same way you dealt with the classes: just create them again:If that's not good enough, there are three hacky possibilities that may be what you want:Monkeypatch the methods, attributes, etc. into the instance(s) and their __class__(es).Patch the instances' __class__ attribute directly, so anything that was inherited from the class will now be inherited from the new class.Serialize the instances with pickle before the reload, then deserialize after.For very simple cases, all three of these will work. For more complex cases, you will have to understand what you're doing.Note that you can wrap a lot of this stuff up in a function, but you have to understand how locals and globals work (and how import and reload work) or you're going to end up confusing yourself.A simpler solution is to just create "dump all state" and "load all state" functions. Then you can dump everything, quit, relaunch, and restore. The Python tutorial and the ipython docs both describe a few different ways to do this in place of using reload; it's probably worth going back and rereading those.
Access the module through sys.modules, reload that, then reassign the imported names:etc.All the from something import name syntax does is import something then bind name to the same object something.name refers to.By using sys.modules you don't have to explicitly import the module again, and can reach the new definitions of the objects for rebinding after reloading.


Answer URL
