Natural Text
Here is the code I am usingWhich is giving me the following error:I am hoping to 1) understand why this is happening, and 2) find a solution that allows me to pickle the object (without removing the memoization). Ideally the solution would not change the call to pickle. Running python 3.6 with funcy==1.10Thanks in advance!
The problem is that you've applied a decorator designed for functions to a class. The result is not a class, but a function that wraps up a call to the class. This causes a number of problems (e.g., as pointed out by Aran-Fey in the comments, you can't isinstance(feat, mystery), because mystery). But the particular problem you care about is that you can't pickle instances of inaccessible classes.In fact, that's basically what the error message is telling you:Your feat thinks its type is __main__.mystery, but that isn't a type at all, it's the function returned by the decorator that wraps that type.The easy way to fix this would be to find a class decorator meant that does what you want. It might be called something like flyweight instead of memoize, but I'm sure plenty of examples exist.But you can build a flyweight class by just memoizing the constructor, instead of memoizing the class:… although you probably want to move the initialization into the constructor in that case. Otherwise, calling mystery(1) and then mystery(1) will return the same object as before, but also reinitialize it with self.num = 1, which is at best wasteful, and at worst incorrect. So:And now:And, because the type of feat is now a class that's accessible under the module-global name mystery, pickle will have no problem with it at all:You do still want to think about how this class should play with pickling. In particular, do you want unpickling to go through the cache? By default, it doesn't:What's happening is that it's using the default __reduce_ex__ for pickling, which defaults to doing the equivalent of (only slightly oversimplified):If you want it to go through the cache, the simplest solution is this:If you plan to do this a lot, you might think of writing your own class decorator:But this:… is kind of ugly,… only works with classes that don't need to pass constructor arguments to a base class,… only works with classes that don't have an __init__ (or, at least, that have an idempotent and fast __init__ that's harmless to call repeatedly),… doesn't provide an easy way to hook pickling, and… doesn't document or test any of those restrictions.So, I think you're better off being explicit and just memoizing the __new__ method, or writing (or finding) something a lot fancier that does the introspection needed to make memoizing a class this way fully general. (Or, alternatively, maybe write one that only works with some restricted set of classes—e.g., a @memodataclass that's just like @dataclass but with a memoized constructor would be a lot easier than a fully general @memoclass.)
Another approach is


Answer URL
https://docs.python.org/3/library/pickle.html#object.__reduce_ex__
