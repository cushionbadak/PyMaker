Natural Text
I'm trying to count the number of times a duplicate letter shows up in the list element.For example, givenI out put a list and I get ['1','0','1']But my code would output [1,0,2]I'm not sure why I am over counting.Can anyone help me resolve this, thank you in advance.
A more efficient solution using a regular expression:This function will find the number of substrings of length 2 or more containing the same letter. Thus 'aaa' in your example will only be counted once.For a string like the output will be 4 , since there are 4 maximal substrings of the same letter occuring at least twice : 'hhh' , 'ss', 'gg', 'aa'
You aren't accounting for situations where you have greater than 2 identical characters in succession. To do this, you can look back as well as forward:The ternary statement helps for the first iteration of the loop, to avoid comparing the last letter of a string with the first.Another solution is to use itertools.groupby and count the number of instances where a group has a length greater than 1:The sum(1 for _ in j) part is used to count the number items in a generator. It's also possible to use len(list(j)), though this requires list construction.
Well, your code counts the number of duplications, so what you observe is quite logical:  your input is arr = ['capps','hat','haaah']in 'capps', the letter p is duplicated 1 time => myfunc() returns 1in 'hat', there is no duplicated letter => myfunc() returns 0in 'haaah', the letter a is duplicated 2 times => myfunc() returns 2So finally you get [1,0,2].For your purpose, I suggest you to use a regex to match and count the number of groups of duplicated letters in each word. I also replaced the usage of map() with a list comprehension that I find more readable:  
You need to keep track of a little more state, specifically if you're looking at duplicates now.This gives you the following outputAs others have pointed out, you could use a regular expression and trade clarity for performance. They key is to find a regular expression that means "two or more repeated characters" and may depend on what you consider to be characters (e.g. how do you treat duplicate punctuation?)Note: the "regex" used for this is technically an extension on regular expressions because it requires memory.The form will be len(re.findall(regex, words))
I would break this kind of problem into smaller chunks. Starting by grouping duplicates.The documentation for itertools has groupby and recipes for this kind of things.A slightly edited version of unique_justseen would look like this:and yields values: 1, 3, 1. As soon as any of these values are greater than 1 you have a duplicate. So just count them:
Use re.findall for matches of 2 or more letters


Answer URL
https://docs.python.org/3/library/itertools.html
