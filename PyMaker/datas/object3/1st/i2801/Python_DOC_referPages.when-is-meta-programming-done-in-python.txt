Natural Text
I have read a paper that seems to say that meta-programming of Lisp, Scheme, and Lisp-like macros happens at compile time: http://tratt.net/laurie/research/pubs/html/tratt__compile-time_meta-programming_in_a_dynamically_typed_oo_language/. It also seems to state that dynamic languages such as Python do not use much of compile-time metaprogramming. I know that in a way Java can do compile-time metaprogramming using class loaders. In Python metaprogramming with Metaclasses and decorators as well as reflection using methods such as type(), isInstance(), etc...is this all metaprogramming at runtime or is there more behind it?
The short version is: yes, decorators, metaclasses, etc. are mainly something that happens at runtime.This also means that SmallTalk is in general a better reference point than Lisp for understanding metaprogramming in Python.1The long version is a bit involved."Compile time" in Python is about compiling the bodies of function definitions, class definitions, and modules themselves to bytecode. "Runtime" involves interpreting those bodies.2In particular, things like def and class statements are (compiled to) runtime code that gets executed like any other.For example, consider this module:The print(3) body gets compiled into some bytecode that, when executed, looks up print and calls it with the argument 3. That bytecode can then be treated as a constant.Then the module body gets compiled into something kind of like this pseudocode:And when you import the module (or run it as a script), that compiled code gets executed at runtime. So, that's when the decorator is called.And similarly, consider this:First, that pass is compiled into bytecode that does nothing but return None, which can be treated as a constant.Next, that class body is compiled into bytecode. Since the class body just has the def statement, the bytecode does the equivalent of this:Next, that class statement is compiled into bytecode that does something like this:Then, when you import the module (or run it as a script), that bytecode gets executed. So, that's when the metaclass is called, creating the class object.What this means is that you can almost ignore the issue of what happens at compile time.3It you want to call type (or a custom metaclass) directly, you get the exact same effect as a class statement. You can even construct function objects out of bytecode objects manually, and you get the exact same effect as a def statement or lambda expression. And you can modify a function or class after it was created—e.g., adding new methods to a class via Spam.cheese = cheese ends up no different than if you'd defined them directly in the class statement.4This also means that reflection is nothing magical in Python. Objects carry their type information around with them in public attributes, and the stuff the inspect module does is pretty much the same stuff the interpreter is doing with the same attributes.But, on the other hand, it means that some things that are easy to do with Lisp macros—like taking the AST of an expression rather than the expression's value as an argument—are not possible with Python metaprogramming.Well, I say it's not possible, but… if you want to do Lisp-style metaprogramming in Python, you actually can do that as well. It just means writing and installing import hooks.5Normally, in Python, an import finds the source file, decodes it as text with bytes.decode, tokenizes it with the tokenize module, parses the tokens with ast.parse, and compiles the result with compile. All of these pieces are exposed to Python code, and (in 3.4+) the entire import system is itself written in Python using the same modules you can use yourself. So, an import hook can install a custom loader that will, e.g., decode, tokenize, and parse like the default loader, then modify the AST the same way a Lisp-style macro would, then compile and return the result like the default loader.If you're at all interested in doing this, you should look at MacroPy.1. In fact, IIRC, the first edition of Forman and Danforth's SmallTalk book Putting Metaclasses to Work and another paper by Danforth were the main influences on Python's metaprogramming design.2. In interactive mode, Python compiles and then executes one statement at a time, mixing things up a bit, but the ideas aren't that much different.3. In fact, different implementations can choose to do more or less at compile time than CPython, as long as the semantics end up the same.4. Except for some subtle issues with, e.g., the way the def statements are executed inside that _namespace above vs. inside globals(), which can affect things like super().5. The original PEP does a good job covering the history and rationale, but not covering the way to write and install hooks in modern Python. For that, read the reference docs on the import system and follow the links to the importlib package.


Answer URL
https://docs.python.org/3/library/inspect.html
https://docs.python.org/3/reference/import.html
