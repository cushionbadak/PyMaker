Natural Text
Knowing this will most likely end with a failure, I want to know how Python will treat such a scenario and whether or not my code actually "makes sense", at least in principle.So here's my attempt, I'm pretty new to python (a few days ago), so I'm sure my code seems funny to those of you with more experience, but please bear with me.      This is the error I got in my DOS window trying to run the above: Thank you in advance.
Languages with "infinite" data structures are actually producing objects that produce their values lazily, or "on-demand". Rather than creating the entire list up front, they create an object that, when asked for a value, can create it at that time.In Python, this is most easily managed using a generator.
There's basically two things which will stop the infinite list from being printed (which seems like the final goal of your code):The computer will run out of memory.The creation of the list will take infinite time, meaning it will never finish and the actual printing will never start.If you imagine an imaginary computer with infinite memory and infinite calculation speed, the list can be printed.However, some languages support infinite lists by being "lazy", meaning they will only calculate the part of the list which they need at that certain point. Then you could define an infinite list and ask it to print out e.g. the first 100 values in it.More about lazy computing: https://en.m.wikipedia.org/wiki/Lazy_evaluation
It cannot be infinite in the sense you immediately get access to all members in the universe. That would be impossible - infinite length means infinite memory needed. As you can see from the error you got, you do not have infinite memory. As the others note, you can trade speed for length:Here I combine both a regular list with on the fly extension if needed. I did not have to start with an empty list, I could have pre-made the first N elements if I preferred.You could of course overload operators (+,- whatever). The point is everything is done one the fly. Working this way you can even add and subtract infinite lists.You could even improve this using memory management, and deleting the start of the list if not viewed in a while, but that's out of scope I think. The more functional approach would be something holding the current number and the way to continue (I added a prev to be similar to the builtin __next__:Again, operators (not just the representation), or jumping more than one can easily be implemented.
Your computer runs out of memory at some point while building the list, that's what causes the error you are seeing. It is not possible to have an infinite list, because memory is a limited resource.Alternatively you may use an infinite iterator. The standard library provides a few infinite iterators. Based on your example, I think will be the most suitable for your situation is itertools.count.Sample usage:You can also specify a custom starting point:And a custom step:
Infinite data structures do make sense, but they always have to be lazily evaluated. That means that your data structure can't build all of its elements straight away, and then move itself around (like we would normally do with a list that fits in memory). Instead, your data structure needs to give you values as you demand them.In Python, you can't have an infinite list because list is eager, not lazy (just like most things in Python, eager is the default). To be clear, I'm talking about the list type here w.r.t. Python terminology, not the abstract concept of some sequence (which some people might call a list).The way that you can have lazy evaluation is by using something called a generator. If you want to generate the sequence 1,2,3,4,..., you can do it with the following code:this outputs:Obviously, you don't have to stop at 3. You don't have to stop anywhere (except for when the int you've created doesn't actually fit into memory). If you keep calling next, the generator will keep returning values to you.As you go along, the garbage collector can delete values from memory that no longer contain references. This is another topic entirely, but it should be noted that as long as you don't keep the references around forever, your program won't run out of memory when using generators either.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.count
