Natural Text
I've a list of integers that I want to subtract from each other in consecutive order. I want to be able to use the code for any size list of integers, even if I don't know the number of integers.What I've so far:My expected answer is -7 because:10 - 9 = 1Then 1 - 8 = -710 and 9 are the first and second element of the list a, respectively. I subtract them to get 1. I then take 1 and deduct 8 -- the third element of the list -- from it to get -7.Instead, I get an error that the list index is out of range. I know why I'm getting this: because when i hits 2, i+1 becomes 3, and there is no a[3] element in the list.Yet for something so simple, I can't seem to figure out how to obtain consecutive indices like this, especially for a list where I wouldn't know the number of elements.How can I fix this? Should I just use a try-except clause and break out of the loop when I get the IndexError?
Based on your expected output of -7, you need to be subtracting from the running difference prior to the element you're currently on, rather than a[i] - a[i+1]. In terms of the index issue, you can resolve it by adding in a logical check to make sure that you have remaining elements in the array by bounding the end point to be len(a) - 1
Simpler and faster solution than explicit loops or reduce: Realizing that a - b - c - ... - n is equivalent to a - (b + c + ... + n), so you can use the sum function (which is optimized at the C layer for sums that fit in a C long, only falling back to more expensive Python level ints if it overflows a C long).Note: This makes a shallow copy of most of a, and requires a sequence type (to support indexing/slicing), not any iterable. You can fix both issues with the slightly longer code:This will be ever-so-slightly slower for small input lists (fixed overhead from iter/next being slightly greater than fixed overhead of indexing/slicing, though slicing has growing overhead of copy that iter/next lacks), but the savings on longer inputs would more than make up for it.
You can use functools.reduce along with operator.subThis is roughly equivalent to 


Answer URL
https://docs.python.org/3/library/functools.html#functools.reduce
https://docs.python.org/3/library/operator.html#operator.sub
