Natural Text
If I define an abstract class with an abstract method:I can't instantiate it (as expected):But I can call its abstract method with no errors.Is this behavior documented somewhere ?Tested on Python 3.6 and 3.7.
Nothing is explicit about that.Simply the documentation of a the abstractmethod decorator says:A class that has a metaclass derived from ABCMeta cannot be instantiated unless all of its abstract methods and properties are overridden.And PEP 3119 says:A class containing at least one method declared with this decorator that hasn't been overridden yet cannot be instantiated.and laterImplementation: The @abstractmethod decorator sets the function attribute __isabstractmethod__ to the value True. The ABCMeta.__new__ method computes the type attribute __abstractmethods__ as the set of all method names that have an __isabstractmethod__ attribute whose value is true. It does this by combining the __abstractmethods__ attributes of the base classes, adding the names of all methods in the new class dict that have a true __isabstractmethod__ attribute, and removing the names of all methods in the new class dict that don't have a true __isabstractmethod__ attribute. If the resulting __abstractmethods__ set is non-empty, the class is considered abstract, and attempts to instantiate it will raise TypeError.My interpretation of the implementation part is that @abstractmethod never prevents the method to be called but only say that that class cannot be instantiated and that a subclass will still be abstract unless it overrides all of its abstract methods.So I would not say that it is by design, but it is at least an assumed side effect.
foo is a classmethod and by property a class method can be called directly by the class itself.By doing   you are not instantiating the class A, rather you are just calling the function foo on class A.
Subclassing abc.ABC indicates that class A cannot be instantiated directly.The @abc.abstractmethod decorator forces a check on any subclass of A during type/name resolution. If class subofA(A): does not implement the decorated method, then an exception is raised.Once type/name resolution is passed, the abstractmethod decorator does not prevent you from calling the method. After all, you aren't able to call the method without an instance, unless it is a class method.By decorating foo with both @classmethod and @abstractmethod you, the developer, specify that A.foo() is safe to call without instantiating the class, but that anyone who subclasses A must implement an overriding method to preserve that behaviour.


Answer URL
https://docs.python.org/3/library/functions.html#classmethod
