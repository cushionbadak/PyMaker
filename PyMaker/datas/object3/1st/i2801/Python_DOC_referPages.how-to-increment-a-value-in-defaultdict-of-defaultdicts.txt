Natural Text
How to increment d['a']['b']['c'][1][2][3] if d is defaultdict of defaultdict without code dublication?Here we can see that we duplicated (in the code) a chain of keys 3 times.Question: Is it possible to write a function inc that will take nested_dict['a']['b']...[6] and do the same job as above? So:Update (20 Aug 2018):There is still no answer to the question. It's clear that there are options "how to do what I want", but the question is straightforward: there is "value", we pass it to a function, function modifies it. It looks that it's not possible.Just a value, without any "additional keys", etc.If it is so, can we make an answer more generic?Notes:What is defaultdict of defaultdicts - SO.This question is not about "storing of integers in a defaultdict", so I'm not looking for a hierarchy of defaultdicts with an int type at the leaves.Assume that type (int in the examples) is known in advance / can be even parametrized (including the ability to perform += operator) - the question is how to dereference the object, pass it for modification and store back in the context of defaultdict of defaultdicts.Is the answer to this question related to the mutability? See example below:Example:Where Int is:
It's not exactly abut mutability, more about how assignment performs name binding.When you do x = 0 in your inc function you bind a new object to the name x, and any connection between that name and the previous object bound to that name is lost. That doesn't depend on whether or not x is mutable.But since x is an item in a mutable object we can achieve what you want by passing the parent mutable object to inc along with the key needed to access the desired item.outputNow we aren't binding a new object, we're merely mutating an existing one, so the original d object gets updated correctly.BTW, that deeply nested dict is a bit painful to work with. Maybe there's a better way to organize your data... But anyway, one thing that can be handy when working with deep nesting is to use lists or tuples of keys. Eg,q now refers to nested_dict['a']['b']['c']['d'][1][2][3][4][5]
You can't have multiple default types with defaultdict. You have the following options:Nested defaultdict of defaultdict objects indefinitely;defaultdict of int objects, which likely won't suit your needs;defaultdict of defaultdict down to a specific level with int defined for the last level, e.g. d = defaultdict(lambda: defaultdict(int)) for a single nesting;Similar to (3), but for counting you can use collections.Counter instead, i.e. d = defaultdict(Counter).I recommend the 3rd or 4th options if you are always going to go down to a set level. In other words, a scalar value will only be supplied at the nth level, where n is constant.Otherwise, one manual option is to have a function perform the type-testing. In this case, try / except may be a good alternative. Here we also define a recursive algorithm to allow you to feed a list of keys rather than defining manual __getitem__ calls.


Answer URL
https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference
