Natural Text
I've been delving into operator overloading and special methods within Python classes, and I noticed that many built-in functions have their equivalent special method names:int(x) calls x.__int__()next(x) calls x.__next__() or x.next() in Python 2However, a couple functions, namely tuple() and dict(), do not have any equivalent. I am aware that the need has not arised yet for such special methods, but in some cases, a method for dict() conversion called on a class may be useful. How might I implement this? Or, what would you remark on someone attempting to use this kind of logic?
Option 1: __iter__Casting to tuple or dict, or any type that takes an iterable, relies on the __iter__ method.The same will work for tuples.Option 2: keys and __getitem__Alternatively, to cast to a dict, you can implement both keys and __getitem__.Option 3: Both for supporting multiple typesFinally, if you want your class to have different behaviour for casting to a dict and a tuple, the following example demonstrates that dict will prioritize the keys and __getitem__ solution.
In it's simplest form, I could try and retrieve obj.__dict__. I've also created a method, called obj.__dictionary__ that returns a dict, but can customise what values are returned and how. I implemented a small function that tries to call obj.__dictionary__ and other successive attempts at other methods:For demonstration, a little class which encapsulates a 'Person':Now consider calling my custom dct function on a few objects to test it out:As you can see, it seems to work in a decent way. I know that for my simple Person class demonstration, I could have simply returned p.__dict__, but I added an extra p.title attribute which only exists in dict form to show that this enables extra customisation. In addition, if I defined the Person class with __slots__, then the dct(p) call would fail withObviously, I could extend the try/except blocks to attempt to access __slots__ as well, but this is not the point I am trying to get across: If I defined the following in the custom __dictionary__ method, the code wouldwork as expected:


Answer URL
https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers
