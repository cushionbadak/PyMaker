Natural Text
I've read some blogs and docs that when access an instance attribute obj.a:try accessing data descriptor (named a) in current class __dict__ and base class __dict__find a in obj.__dict__find non-data descriptor (named a) in current class __dict__ and base class __dict__find attribute (named a) in current class __dict__ and base class __dict__call __getattr__ if anyraise AttributeErrorBut I found that this searching rule does not match the behavior of below codes:I think the last print(b.dd_1) will invoke the __get__ in ADesc, because according to the 1st rule, __dict__ of base class A contains the attribute dd_1 that we're accessing, so that data descriptor should be called. So is the above access rule wrong or any other magic involved here ?
You misunderstood how descriptors are found in classes. Python will use the first such name in the class hierarchy. Once found, the search stops. B.dd_1 exists, so A.dd_1 is not considered.The documentation tells you about base classes for the case where B does not define dd_1; in that case B is searched, then A. But when B has an attribute dd_1, any further search is stopped.Note that the search order is set by the class MRO (method resolution order). Rather than distinguish between a search in the class __dict__, and separately, the __dict__ attributes of the base classes, you should see the search as:The MRO (as embodied by the cls.__mro__ attribute) includes the current class object:The relevant documentation is found in the datamodel reference; where Custom Classes states:Class attribute references are translated to lookups in this dictionary, e.g., C.x is translated to C.__dict__["x"] (although there are a number of hooks which allow for other means of locating attributes). When the attribute name is not found there, the attribute search continues in the base classes.The actual implementation for instance attributes works like this:The class is located (type(instance))The class __getattribute__ method is called (type(instance).__getattribute__(instance, name))__getattribute__ scans the MRO to see if the name exists on the class and its base classes (find_class_attribute(self, name))if there is such an object, and it is a data descriptor (has a __set__ or __delete__ method), this object is used, and the search stops.if there is such an object but it is not a data descriptor, a reference is kept for later.__getattribute__ looks for the name in instance.__dict__if there is such an object, the search stops. The instance attribute is used.There was no data descriptor found, and no attribute in the instance dict. But the search through the MRO may have located a non-data-descriptor objectif there is a reference to an object found in the MRO, it is used and the search stops.If there is a __getattr__ method defined on the class (or a base class), it is called, and the result is used. Search stops.an AttributeError is raised.
There aren't three separate searches through the class and the base class. (Also, it's not just the class and its base; it's the entire MRO.) There's one search through the MRO, and it stops as soon as it finds something, regardless of what parts of the descriptor protocol the found object may or may not support.When the search for b.dd_1 finds 'dd_1 in B', it stops the MRO search. It doesn't keep looking just because 'dd_1 in B' isn't a descriptor.Here's the correct version of the standard attribute resolution logic, implemented in object.__getattribute__. (This is only object.__getattribute__; it doesn't cover classes with their own __getattribute__ or __getattr__.)Search the object's MRO for a dict entry matching the attribute name.If the MRO search finds a data descriptor with a __get__ method, stop searching and use the descriptor.Otherwise, we check the instance dict. If there's an entry matching the attribute name, stop and use that. If there is no matching entry (or if there is no instance dict), continue.If the step 2 search found a non-data-descriptor or a non-descriptor, use that.Otherwise, lookup fails. Raise an AttributeError.


Answer URL
https://docs.python.org/3/reference/datamodel.html
https://docs.python.org/3/reference/datamodel.html
