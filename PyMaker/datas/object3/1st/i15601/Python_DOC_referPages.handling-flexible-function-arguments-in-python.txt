Natural Text
TL;TR Looking for idioms and patterns to unpack positional and keyword arguments into ordered sequence of positional arguments, based on simple specification, e.g. a list of names. The idea seems similar to scanf-like parsing.I'm wrapping functions of a Python module, called someapi.Functions of someapi only expect positional arguments, which are in pain numbers in most cases.I'd like to enable callers with flexibility of how they can pass arguments to my wrappers.Here are examples of the wrappers invocations I'd like to allow:I don't see any need to support convoluted case of mixed positional and keyword arguments:Here is my first stab at implementing such arguments handling for the foo wrapper calling someapi.foo:It does the job as expected, as far as I can tell, but it there are two issues:Can I do it better in more Python idiomatic fashion?I have dozen(s) of someapi functions to wrap, so how to avoid copying and adjusting the whole block between BEGIN/END marks in every wrapper?I don't know the answer for the question 1, yet.Here, however, is my attempt to address the issue 2.So, I defined a generic handler for arguments based on the simple specification of names.The names specify a couple of things, depending on the actual wrapper invocation:How many arguments to unpack from *args? (see len(names) test below)What keyword arguments are expected in **kwargs? (see generator expression returning tuple below)Here is new version:This allows me to implement the wrapper functions in the following way:I think I have achieved all the advantages over the foo version above that I was looking for:Enable callers with the requested flexibility.Compact form, cut down on copy-and-paste.Flexible protocol for positional arguments: bar can be called with 7, 8 and more positional arguments or a long list of numbers, but only first 6 are taken into account. For example, it would allow iterations processing long list of numbers (e.g. think of geometry coordinates):Flexible protocol for keyword arguments: more keywords may be specified than actually used or dictionary can have more items than used.Getting back to the question 1 above, can I do better and make it more Pythonic?Also, I'd like to ask for review of my solution: you see any bugs? have I overlooked anything? how to improve it?
Python is a very powerful language that allows you manipulate code in any way you want, but understanding what you're doing is hard.  For this you can use the inspect module.  So an example of how to wrap a function in someapi.  I'll only consider positional arguments in this example, you can intuit how to extend this further.  You can do it like this:This will detect if the number of arguments given to foo is too many and if so, it will get rid of the excess arguments.  On the other hand, if there are too few arguments then it will just do nothing and let foo handle the errors.Now to make it more pythonic.  The ideal way to wrap many functions using the same template is to use decorator syntax (familiarity with this subject is assumed, if you want to learn more then see the docs at http://www.python.org/doc).  Although since decorator syntax is mostly used on functions that are in development rather than wrapping another API, we'll make a decorator but just use it as a factory (the factory pattern) for our API.  To make this factory we'll make use of the functools module to help us out (so the wrapped function looks as it should).  So we can turn our example into:Finally, if someapi has a relatively large API that could change between versions (or we just want to make our source file more modular so it can wrap any API) then we can automate the application of my_wrapper_maker to everything exported by the module someapi.  We'll do this like so:This probably considered the most pythonic way to implement this, it makes full use of Python's meta-programming resources and allows the programmer to use this API everywhere they want without depending on a specific someapi.Note: Whether this is most idiomatic way to do this is really up to opinion.  I personally believe that this follows the philosophy set out in "The Zen of Python" quite well and so to me it is very idiomatic.


Answer URL
https://docs.python.org/3/reference/expressions.html#generator-expressions
