Natural Text
How to create N "random" strings of length K using the probability table? K would be some even number.Let's say K = 6, there would be a higher probability of 'acacab' than 'aaaaaa'.This is sub-problem of a larger problem that I’m using to generate synthetic sequences based on a probability table.  I’m not sure how to use the probability table to generate “random” strings? What I have so far:
There are some good approaches to making weighted random choices described at the end of the documentation for the builtin random module:A common task is to make a random.choice() with weighted probabilities.If the weights are small integer ratios, a simple technique is to build a sample population with repeats:A more general approach is to arrange the weights in a cumulative distribution with itertools.accumulate(), and then locate the random value with bisect.bisect():To adapt that latter approach to your specific problem, I'd do:This assumes that the key strings in your probability table are all the same length If they have multiple different lengths, this code will sometimes (perhaps most of the time!) give answers that are longer than K characters. I suppose it also assumes that K is an exact multiple of the key length, though it will actually work if that's not true (it just will give result strings that are all longer than K characters, since there's no way to get K exactly).
You could use random.random:This can be no doubt be improved upon but the  random.random is useful when dealing with probability. 
I'm sure there is a cleaner/better way, but here is one easy way to do this.Here we're filling pick_list with the 100 separate character-pair values, the number of values determined by the probability.  In this case, there are 20 'aa', 30 'ab' and 50 'ac' entries within pick_list.  Then random.choice(pick_list) uniformly pulls a random entry from the list.With results:
If your tables or sequences are large, using numpy may be helpful as it will probably be significantly faster.  Also, numpy is built for this sort of problem, and the approach is easy to understand and just 3 or 4 lines.The idea would be to convert the probabilities into cumulative probabilities, ie, mapping (.2, .5, .3) to (.2, .7, 1.), and then random numbers generated along the flat distribution from 0 to 1 will fall within the bins of the cumulative sum with a frequency corresponding to the weights.  Numpy's searchsorted can be used to quickly find which bin the random values lie within.  That is,Here I used k as the number of strings you would need, rather than K as the number of characters, since the problem statement is ambiguous about strings/characters.


Answer URL
https://docs.python.org/3/library/random.html#examples-and-recipes
