Natural Text
I'm trying to build a system that collects data from some sources using I/O (HDD, network...)For this, I have a class (controller) that launch the collectors.Each collector is an infinite loop with a classic ETL process (extract, transform and load).I want send some commands to the collectors (stop, reload settings...) from an interface (CLI, web...) and I'm not sure about how to do it.For example, this is the skeleton for a collector:And this is the skeleton for the controller:Is there a classic design pattern that solves this problem (Publishâ€“subscribe, event loop, reactor...)? What is the best way to solve this problem?PD: Obviously, this will be a multiprocess application and will run on a single machine. 
There are multiple choices here, but they boil down to two major kinds: cooperative (event loop/reactor/coroutine/explicit greenlet), or preemptive (implicit greenlet/thread/multiprocess).The first requires a lot more restructuring of your collectors. It can be a nice way to make the nondeterminism explicit, or to achieve massive concurrency, but neither of those seems relevant here. The second just requires sticking the collectors on threads, and using some synchronization mechanism for both communication and shared data. It seems like you have no shared data, and your communication is trivial and not highly time-sensitive. So, I'd go with threads.Assuming you want to go with threads in the general sense, assuming your collectors are I/O-bound and you don't have dozens of them, I'd go with actual threads.So, here's one way you can write it:(Although I'd call the Controller.run method stop, because it fits in better with the naming used not only by Thread, but also by the stdlib server classes and other similar things.)
I'd look at the possibility of adapting your case to socket-based client-server architecture where Controller would instantiate required number of Collectors each listening on its own port and handling received data in more elegant way through handle() method of the server. The fact that data comes from various I/O sources speaks even more for this solution - you could use Client part of this architecture to standarize the DataSource -> Collector protocolhttps://docs.python.org/2/library/socketserver.html


Answer URL
https://docs.python.org/3/library/threading.html#lock-objects
