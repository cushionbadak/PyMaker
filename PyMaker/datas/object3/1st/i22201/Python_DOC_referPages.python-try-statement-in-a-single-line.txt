Natural Text
Is there a way in python to turn a try/except into a single line?something like...Where b is a declared variable and c is not... so c would throw an error and a would become b...
There is no way to compress a try/except block onto a single line in Python.Also, it is a bad thing not to know whether a variable exists in Python, like you would in some other dynamic languages. The safer way (and the prevailing style) is to set all variables to something. If they might not get set, set them to None first (or 0 or '' or something if it is more applicable.)If you do assign all the names you are interested in first, you do have options. The best option is an if statement.The one-liner option is a conditional expression. Some people abuse the short-circuiting behavior of or to do this. This is error prone, so I never use it.Consider the following case:In this case, a probably should be [], but it is [1, 2] because [] is false in a boolean context. Because there are lots of values that can be false, I don't use the or trick. (This is the same problem people run into when they say if foo: when they mean if foo is not None:.)
This is terribly hackish, but I've used it at the prompt when I wanted to write up a sequence of actions for debugging:For the most part, I'm not at all bothered by the no-single-line-try-except restriction, but when I'm just experimenting and I want readline to recall a whole chunk of code at once in the interactive interpreter so that I can adjust it somehow, this little trick comes in handy.For the actual purpose you are trying to accomplish, you might try locals().get('c', b); ideally it would be better to use a real dictionary instead of the local context, or just assign c to None before running whatever may-or-may-not set it.
Another way is to define a context manager:Then use the with statement to ignore errors in one single line:No exception will be raised in case of a runtime error. It's like a try: without the except:.
You can do it by accessing the namespace dict using vars(), locals(), or globals(), whichever is most appropriate for your situation.
There is always a solution.
You mentioned that you're using django. If it makes sense for what you're doing you might want to use:created will be True or False. Maybe this will help you.
The problem is that its actually a django model.objects.get query i am trying to test. the .get returns an error if no data is found... it doesn't return None (which annoys me)Use something like this:Where try_or is an utility function defined by you:Optionally you can restrict the accepted exception types to NameError, AttributeError, etc.
In python3 you can use contextlib.suppress:
if you need to actually manage exceptions:(modified from poke53280's answer)note that if the exception is not supported, it will raise as expected:also if Exception is given, it will match anything below.(BaseException is higher, so it will not match)


Answer URL
https://docs.python.org/3/library/contextlib.html#contextlib.suppress
