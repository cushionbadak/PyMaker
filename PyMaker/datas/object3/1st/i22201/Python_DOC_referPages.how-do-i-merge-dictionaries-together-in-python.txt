Natural Text
I understand that this merges the dictionary. But, is it unique? What if d1 has the same key as d2 but different value?  I would like d1 and d2 to be merged, but d1 has priority if there is duplicate key.
You can use the .update() method if you don't need the original d2 any more:Update the dictionary with the key/value pairs from other, overwriting existing keys. Return None.E.g.:Update:Of course you can copy the dictionary first in order to create a new merged one. This might or might not be necessary. In case you have compound objects (objects that contain other objects, like lists or class instances) in your dictionary, copy.deepcopy should also be considered.
In Python2,d1 overrides d2: d2 overrides d1:This behavior is not just a fluke of implementation; it is guaranteed in the documentation:If a key is specified both in the  positional argument and as a keyword  argument, the value associated with  the keyword is retained in the  dictionary.
If you want d1 to have priority in the conflicts, do:Otherwise, reverse d2 and d1.
My solution is to define a merge function. It's not sophisticated and just cost one line. Here's the code in Python 3.TestsIt works for arbitrary number of dictionary arguments. Were there any duplicate keys in those dictionary, the key from the rightmost dictionary in the argument list wins.
Trey Hunner has a nice blog post outlining several options for merging multiple dictionaries, including (for python3.3+) ChainMap and dictionary unpacking.
I believe that, as stated above, using d2.update(d1) is the best approach and that you can also copy d2 first if you still need it.Although, I want to point out that dict(d1, **d2) is actually a bad way to merge dictionnaries in general since keyword arguments need to be strings, thus it will fail if you have a dict such as:


Answer URL
https://docs.python.org/3/library/collections.html#collections.ChainMap
