Natural Text
Why I have problem creating a class inheriting from str (or also from int)tha same happens if I try to use int instead of str, but it works with custom classes. I need to use __new__ instead of __init__? why?
Since __init__ is called after the object is constructed, it is too late to modify the value   for immutable types. Note that __new__ is a classmethod, so I have called the first parameter clsSee here for more information
Inheriting built-in types is very seldom worth while. You have to deal with several issues and you don't really get much benefit. It is almost always better to use composition. Instead of inheriting str, you would keep a str object as an attribute.you can defer any methods you want to work on the underlying str self.s manually or automatically using __getattr__.That being said, needing your own string type is something that should give you pause. There are many classes that should store a string as their main data, but you generally want to use str or unicode (the latter if you're representing text) for general representation of strings. (One common exception is if you have need to use a UI toolkit's string type.) If you want to add functionality to your strings, try if you can to use functions that operate on strings rather than new objects to serve as strings, which keeps your code simpler and more compatible with everyone else's programs.
When you instantiate a class, the arguments that you pass in, are passed to both the __new__ (constructor) and then to the __init__ (initializer) methods of the class. So if you inherit from a class that has restrictions on number of arguments that may be supplied during instantiation, you must guarantee that neither its __new__, nor its __init__ would get more arguments than they expect to get. So that is the problem that you have. You instantiate your class with C("a", "B"). The interpreter looks for __new__ method in C. C doesn't have it, so python peeps into its base class str. And as it has one, that one is used and supplied with the both arguments. But str.__new__ expects to get only one argument (besides its class object as the first argument). So TypeError is raised. That is why you must extend it in your child class similarly to what you do with __init__. But bear in mind that it must return class instance and that it is a static method (irrespective of whether it is defined with @staticmethod decorator or not) that counts if you use super function.
Use __new__ in case of immutable types:print returns hello.Python strings are immutable types. The function __new__ is called to create a new instance of object C. The python __new__ function is basically exists to allow inheritance from immutable types.
After carefully reading this, here is another attempt at subclassing str. The change from other answers is creating the instance in the correct class using super(TitleText, cls).__new__ . This one seems to behave like a str whenever it's used, but has allowed me to override a method:This lets you do slicing and subscripting correctly. What's this for? For renaming the Django application in the admin index page.


Answer URL
https://docs.python.org/3/library/collections.html#collections.UserString
