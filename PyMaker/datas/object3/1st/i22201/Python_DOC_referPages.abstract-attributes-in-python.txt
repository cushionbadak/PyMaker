Natural Text
What is the shortest / most elegant way to implement the following Scala code with an abstract attribute in Python?A subclass of Controller is enforced to define "path" by the Scala compiler. A subclass would look like this:
Python has a built-in exception for this, though you won't encounter the exception until runtime.
Python 3.3+Failure to declare a or b in the derived class B will raise a TypeError such as:TypeError: Can't instantiate abstract class B with abstract methods aPython 2.7There is an @abstractproperty decorator for this:
You could create an attribute in the abc.ABC abstract base class with a value such as NotImplemented so that if the attribute is not overriden and then used, an error is shown at run time.The following code uses a PEP 484 type hint to help PyCharm correctly statically analyze the type of the path attribute as well.
Since this question was originally asked, python has changed how abstract classes are implemented. I have used a slightly different approach using the abc.ABC formalism in python 3.6.  Here I define the constant as a property which must be defined in each subclass.This forces the derived class to define the constant, or else a TypeError exception will be raised when you try to instantiate the subclass. When you want to use the constant for any functionality implemented in the abstract class, you must access the subclass constant by type(self).CONSTANT instead of just CONSTANT, since the value is undefined in the base class. There are other ways to implement this, but I like this syntax as it seems to me the most plain and obvious for the reader.   The previous answers all touched useful points, but I feel the accepted answer does not directly answer the question becauseThe question asks for implementation in an abstract class, but the accepted answer does not follow the abstract formalism.The question asks that implementation is enforced.  I would argue that enforcement is stricter in this answer because it causes a runtime error when the subclass is instantiated if CONSTANT is not defined. The accepted answer allows the object to be instantiated and only throws an error when CONSTANT is accessed, making the enforcement less strict.  This is not to fault the original answers.  Major changes to the abstract class syntax have occurred since they were posted, which in this case allow a neater and more functional implementation. 
Have a look at the abc (Abtract Base Class) module: http://docs.python.org/library/abc.htmlHowever, in my opinion the simplest and most common solution is to raise an exception when an instance of the base class is created, or when its property is accessed.
Your base class could implement a __new__ method that check for class attribute:This way the error raise at instantiation
Python3.6 implementation might looks like this:
In Python 3.6+, you can annotate an attribute of an abstract class (or any variable) without providing a value for that attribute.This makes for very clean code where it is obvious that the attribute is abstract. Code that tries to access the attribute when if has not been overwritten will raise an AttributeError.
Bastien LÃ©onard's answer mentions the abstract base class module and Brendan Abel's answer deals with non-implemented attributes raising errors. To ensure that the class is not implemented outside of the module, you could prefix the base name with an underscore which denotes it as private to the module (i.e. it is not imported). i.e.
As of 3.3 abc.abstractproperty is deprecated, I think.
As of Python 3.6 you can use __init_subclass__ to check for the class variables of the child class upon initialisation:


Answer URL
https://docs.python.org/3/library/abc.html#abc.ABC
