Natural Text
I want to create a dynamic object (inside another object) in Python and then add attributes to it.I tried:but this didn't work.Any ideas?edit:I am setting the attributes from a for loop which loops through a list of values, e.g.In the above example I would get obj.a.attr1, obj.a.attr2, obj.a.attr3.  I used the setattr function because I didn't know how to do obj.a.NAME from a for loop.How would I set the attribute based on the value of p in the example above?
You could use my ancient Bunch recipe, but if you don't want to make a "bunch class", a very simple one already exists in Python -- all functions can have arbitrary attributes (including lambda functions).  So, the following works:Whether the loss of clarity compared to the venerable Bunch recipe is OK, is a style decision I will of course leave up to you.
The built-in object can be instantiated but can't have any attributes set on it.  (I wish it could, for this exact purpose.)  It doesn't have a __dict__ to hold the attributes.I generally just do this:When I can, I give the Object class a more meaningful name, depending on what kind of data I'm putting in it.Some people do a different thing, where they use a sub-class of dict that allows attribute access to get at the keys. (d.key instead of d['key'])Edit: For the addition to your question, using setattr is fine.  You just can't use setattr on object() instances.
There is types.SimpleNamespace class in Python 3.3+:collections.namedtuple, typing.NamedTuple could be used for immutable objects. PEP 557 -- Data Classes  suggests a mutable alternative.For a richer functionality, you could try attrs package. See an example usage.
There are a few ways to reach this goal.Basically you need an object which is extendable.
Now you can do (not sure if it's the same answer as evilpie):
The mock module is basically made for that.
Try the code below:
You can also use a class object directly; it creates a namespace:
as docs say:Note: object does not have a __dict__, so you canâ€™t assign arbitrary attributes to an instance of the object class.You could just use dummy-class instance.
These solutions are very helpful during testing. Building on everyone else's answers I do this in Python 2.7.9 (without staticmethod I get a TypeError (unbound method...):
Which objects are you using? Just tried that with a sample class and it worked fine:And I got 123 as the answer.The only situation where I see this failing is if you're trying a setattr on a builtin object.Update: From the comment this is a repetition of: Why can't you add attributes to object in python?
Coming to this late in the day but here is my pennyworth with an object that just happens to hold some useful paths in an app but you can adapt it for anything where you want a sorta dict of information that you can access with getattr and dot notation (which is what I think this question is really about):This is cool because now:So this uses the function object like the above answers but uses the function to get the values (you can still use (getattr, x_path, 'repository') rather than x_path('repository') if you prefer).
If we can determine and aggregate all the attributes and values together before creating the nested object, then we could create a new class that takes a dictionary argument on creation.We can also allow keyword arguments. See this post. 

Other way i see, this way:


Answer URL
https://docs.python.org/3/library/types.html#types.SimpleNamespace
https://docs.python.org/3/library/collections.html#collections.namedtuple
https://docs.python.org/3/library/typing.html#typing.NamedTuple
https://docs.python.org/3/library/unittest.mock.html
