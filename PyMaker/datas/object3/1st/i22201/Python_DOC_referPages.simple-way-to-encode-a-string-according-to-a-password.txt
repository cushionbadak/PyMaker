Natural Text
Does Python have a built-in, simple way of encoding/decoding strings using a password?Something like this:So the string "John Doe" gets encrypted as 'sjkl28cn2sx0'. To get the original string, I would "unlock" that string with the key 'mypass', which is a password in my source code. I'd like this to be the way I can encrypt/decrypt a Word document with a password.I would like to use these encrypted strings as URL parameters. My goal is obfuscation, not strong security; nothing mission critical is being encoded. I realize I could use a database table to store keys and values, but am trying to be minimalist.
Assuming you are only looking for simple obfuscation that will obscure things from the very casual observer, and you aren't looking to use third party libraries. I'd recommend something like the Vigenere cipher. It is one of the strongest of the simple ancient ciphers.Vigenère cipherIt's quick and easy to implement. Something like:Decode is pretty much the same, except you subtract the key.It is much harder to break if the strings you are encoding are short, and/or if it is hard to guess the length of the passphrase used. If you are looking for something cryptographic, PyCrypto is probably your best bet, though previous answers overlook some details: ECB mode in PyCrypto requires your message to be a multiple of 16 characters in length. So, you must pad. Also, if you want to use them as URL parameters, use base64.urlsafe_b64_encode(), rather than the standard one. This replaces a few of the characters in the base64 alphabet with URL-safe characters (as it's name suggests).However, you should be ABSOLUTELY certain that this very thin layer of obfuscation suffices for your needs before using this. The Wikipedia article I linked to provides detailed instructions for breaking the cipher, so anyone with a moderate amount of determination could easily break it.
As you explicitly state that you want obscurity not security, we'll avoid reprimanding you for the weakness of what you suggest :)So, using PyCrypto:If someone gets a hold of your database and your code base, they will be able to decode the encrypted data. Keep your secret_key safe!
The "encoded_c" mentioned in the @smehmood's Vigenere cipher answer should be "key_c".Here are working encode/decode functions.
Here's a Python 3 version of the functions from @qneill 's answer:The extra encode/decodes are needed because Python 3 has split strings/byte arrays into two different concepts, and updated their APIs to reflect that..
Disclaimer: As mentioned in the comments, this should not be used to protect data in a real application.What's wrong with XOR encryption?https://crypto.stackexchange.com/questions/56281/breaking-a-xor-cipher-of-known-key-lengthhttps://github.com/hellman/xortoolAs has been mentioned the PyCrypto library contains a suite of ciphers. The XOR "cipher" can be used to do the dirty work if you don't want to do it yourself:The cipher works as follows without having to pad the plaintext:Credit to https://stackoverflow.com/a/2490376/241294 for the base64 encode/decode functions (I'm a python newbie).
Python has no built-in encryption schemes, no. You also should take encrypted data storage serious; trivial encryption schemes that one developer understands to be insecure and a toy scheme may well be mistaken for a secure scheme by a less experienced developer. If you encrypt, encrypt properly. You don’t need to do much work to implement a proper encryption scheme however. First of all, don’t re-invent the cryptography wheel, use a trusted cryptography library to handle this for you. For Python 3, that trusted library is cryptography.I also recommend that encryption and decryption applies to bytes; encode text messages to bytes first; stringvalue.encode() encodes to UTF8, easily reverted again using bytesvalue.decode().Last but not least, when encrypting and decrypting, we talk about keys, not passwords. A key should not be human memorable, it is something you store in a secret location but machine readable, whereas a password often can be human-readable and memorised. You can derive a key from a password, with a little care. But for a web application or process running in a cluster without human attention to keep running it, you want to use a key. Passwords are for when only an end-user needs access to the specific information. Even then, you usually secure the application with a password, then exchange encrypted information using a key, perhaps one attached to the user account.Symmetric key encryptionFernet – AES CBC + HMAC, strongly recommendedThe cryptography library includes the Fernet recipe, a best-practices recipe for using cryptography. Fernet is an open standard,  with ready implementations in a wide range of programming languages and it packages AES CBC encryption for you with version information, a timestamp and an HMAC signature to prevent message tampering. Fernet makes it very easy to encrypt and decrypt messages and keep you secure. It is the ideal method for encrypting data with a secret.I recommend you use Fernet.generate_key() to generate a secure key. You can use a password too (next section), but a full 32-byte secret key (16 bytes to encrypt with, plus another 16 for the signature) is going to be more secure than most passwords you could think of.The key that Fernet generates is a bytes object with URL and file safe base64 characters, so printable:To encrypt or decrypt messages, create a Fernet() instance with the given key, and call the Fernet.encrypt() or Fernet.decrypt(), both the plaintext message to encrypt and the encrypted token are bytes objects.encrypt() and decrypt() functions would look like:Demo:Fernet with password – key derived from password, weakens the security somewhatYou can use a password instead of a secret key, provided you use a strong key derivation method. You do then have to include the salt and the HMAC iteration count in the message, so the encrypted value is not Fernet-compatible anymore without first separating salt, count and Fernet token:Demo:Including the salt in the output makes it possible to use a random salt value, which in turn ensures the encrypted output is guaranteed to be fully random regardless of password reuse or message repetition. Including the iteration count ensures that you can adjust for CPU performance increases over time without losing the ability to decrypt older messages. A password alone can be as safe as a Fernet 32-byte random key, provided you generate a properly random password from a similar size pool. 32 bytes gives you 256 ^ 32 number of keys, so if you use an alphabet of 74 characters (26 upper, 26 lower, 10 digits and 12 possible symbols), then your password should be at least math.ceil(math.log(256 ** 32, 74)) == 42 characters long. However, a well-selected larger number of HMAC iterations can mitigate the lack of entropy somewhat as this makes it much more expensive for an attacker to brute force their way in.Just know that choosing a shorter but still reasonably secure password won’t cripple this scheme, it just reduces the number of possible values a brute-force attacker would have to search through; make sure to pick a strong enough password for your security requirements.AlternativesObscuringAn alternative is not to encrypt. Don't be tempted to just use a low-security cipher, or a home-spun implementation of, say Vignere. There is no security in these approaches, but may give an inexperienced developer that is given the task to maintain your code in future the illusion of security, which is worse than no security at all.If all you need is obscurity, just base64 the data; for URL-safe requirements, the base64.urlsafe_b64encode() function is fine. Don't use a password here, just encode and you are done. At most, add some compression (like zlib):This turns b'Hello world!' into b'eNrzSM3JyVcozy_KSVEEAB0JBF4='.Integrity onlyIf all you need is a way to make sure that the data can be trusted to be unaltered after having been sent to an untrusted client and received back, then you want to sign the data, you can use the hmac library for this with SHA1 (still considered secure for HMAC signing) or better:Use this to sign data, then attach the signature with the data and send that to the client. When you receive the data back, split data and signature and verify.  I've set the default algorithm to SHA256, so you'll need a 32-byte key:You may want to look at the itsdangerous library, which packages this all up with serialisation and de-serialisation in various formats.Using AES-GCM encryption to provide encryption and integrityFernet builds on AEC-CBC with a HMAC signature to ensure integrity of the encrypted data; a malicious attacker can't feed your system nonsense data to keep your service busy running in circles with bad input, because the ciphertext is signed.The Galois / Counter mode block cipher produces ciphertext and a tag to serve the same purpose, so can be used to serve the same purposes. The downside is that unlike Fernet there is no easy-to-use one-size-fits-all recipe to reuse on other platforms. AES-GCM also doesn't use padding, so this encryption ciphertext matches the length of the input message (whereas Fernet / AES-CBC encrypts messages to blocks of fixed length, obscuring the message length somewhat).AES256-GCM takes the usual 32 byte secret as a key:then useI've included a timestamp to support the same time-to-live use-cases that Fernet supports.Other approaches on this page, in Python 3AES CFB - like CBC but without the need to padThis is the approach that All Іѕ Vаиітy follows, albeit incorrectly. This is the cryptography version, but note that I include the IV in the ciphertext, it should not be stored as a global (reusing an IV weakens the security of the key, and storing it as a module global means it'll be re-generated the next Python invocation, rendering all ciphertext undecryptable):This lacks the added armoring of an HMAC signature and there is no timestamp; you’d have to add those yourself.The above also illustrates how easy it is to combine basic cryptography building blocks incorrectly; All Іѕ Vаиітy‘s incorrect handling of the IV value can lead to a data breach or all encrypted messages being unreadable because the IV is lost. Using Fernet instead protects you from such mistakes. AES ECB – not secureIf you previously implemented AES ECB encryption and need to still support this in Python 3, you can do so still with cryptography too. The same caveats apply, ECB is not secure enough for real-life applications. Re-implementing that answer for Python 3, adding automatic handling of padding:Again, this lacks the HMAC signature, and you shouldn’t use ECB anyway. The above is there merely to illustrate that cryptography can handle the common cryptographic building blocks, even the ones you shouldn’t actually use. 
Here's an implementation of URL Safe encryption and Decryption using AES(PyCrypto) and base64. If you face some issue like this https://bugs.python.org/issue4329 ( TypeError: character mapping must return integer, None or unicode )        use str(cipher) while decoding as followsreturn obj2.decrypt(base64.urlsafe_b64decode(str(cipher)))
Working encode/decode functions in python3 (adapted very little from qneill's answer):
Thanks for some great answers. Nothing original to add, but here are some progressive rewrites of qneill's answer using some useful Python facilities. I hope you agree they simplify and clarify the code.enumerate()-- pair the items in a list with their indexiterate over the characters in a stringbuild lists using a list comprehensionOften in Python there's no need for list indexes at all. Eliminate loop index variables entirely using zip and cycle:and some tests...
If you want to be safe, you can use Fernet, which is cryptographically sound. You can use a static "salt" if you don't want to store it separately - you will only lose dictionary and rainbow attack prevention. I chose it because I can pick long or short passwords´, which is not so easy with AES.If that's too complicated, someone suggested simplecrypt 
Note: I had problems using Windows + Python 3.6 + all the answers involving pycrypto (not able to pip install pycrypto on Windows) or pycryptodome (the answers here with from Crypto.Cipher import XOR failed because XOR is not supported by this pycrypto fork ; and the solutions using ... AES failed too with TypeError: Object type <class 'str'> cannot be passed to C code). Also, the library simple-crypt has pycrypto as dependency, so it's not an option.Here is a solution using the package cryptography, that you can install as usual with pip install cryptography:Usage:Note: you can adapt with your own salt, iteration count, etc.not very far from @HCLivess's answer but the goal is here to have ready-to-use encrypt and decrypt functionsSource: https://cryptography.io/en/latest/fernet/#using-passwords-with-fernet
This works but password length should be exactly 8. This is simple and requires pyDes.OUTPUT:
An other implementation of @qneill code which include CRC checksum of the original message, it throw an exception if the check fail:
You can use AES to encrypt your string with a password. Though, you'll want to chose a strong enough password so people can't easily guess what it is (sorry I can't help it. I'm a wannabe security weenie).AES is strong with a good key size, but it's also easy to use with PyCrypto.
External libraries provide secret-key encryption algorithms.For example, the Cypher module in PyCrypto offers a selection of many encryption algorithms:Crypto.Cipher.AESCrypto.Cipher.ARC2Crypto.Cipher.ARC4Crypto.Cipher.BlowfishCrypto.Cipher.CASTCrypto.Cipher.DESCrypto.Cipher.DES3Crypto.Cipher.IDEACrypto.Cipher.RC5Crypto.Cipher.XORMeTooCrypto is a Python wrapper for OpenSSL, and provides (among other functions) a full-strength general purpose cryptography library. Included are symmetric ciphers (like AES).
Whoever came here (and the bountier) seemed to be looking for one-liners with not much setup, which other answers don't provide. So I'm putting forward base64.Now, keep in mind that this is basic obfuscation only, and is in **NO WAY OK FOR SECURITY**, but here are some one-liners:A few things to note:you will want to deal with more/less byte-to-string encoding/decoding on your own, depending on your I/O. Look into bytes() and bytes::decode()base64 is easily recognizable by the types of characters used, and often ending with = characters. People like me absolutely go around decoding them in the javascript console when we see them on websites. It's as easy as btoa(string) (js)the order is key+data, as in b64, what characters appear at the end depends on what characters are at the beginning (because of byte offsets. Wikipedia has some nice explanations). In this scenario, the beginning of the encoded string will be the same for everything encoded with that key. The plus is that the data will be more obfuscated. Doing it the other way around will result on the data part being exactly the same for everyone, regardless of key.Now, if what you wanted didn't even need a key of any kind, but just some obfuscation, you can yet again just use base64, without any kinds of key:
if you want secure encryption:for python 2, you should use keyczar http://www.keyczar.org/for python 3, until keyczar is available, i have written simple-crypt http://pypi.python.org/pypi/simple-cryptboth these will use key strengthening which makes them more secure than most other answers here.  and since they're so easy to use you might want to use them even when security is not critical...
So, as nothing mission critical is being encoded, and you just want to encrypt for obsfuscation.Let me present caeser's cipher Caesar's cipher or Caesar shift, is one of the simplest and most widely known encryption techniques. It is a type of substitution cipher in which each letter in the plaintext is replaced by a letter some fixed number of positions down the alphabet. For example, with a left shift of 3, D would be replaced by A, E would become B, and so on.Sample code for your reference : Advantages : it meets your requirements and is simple and does the encoding thing'y'.Disadvantage : can be cracked by simple brute force algorithms (highly unlikely anyone would attempt to go through all extra results).


Answer URL
https://docs.python.org/3/library/base64.html#base64.urlsafe_b64encode
https://docs.python.org/3/library/hmac.html
https://docs.python.org/3/library/stdtypes.html#bytes.decode
