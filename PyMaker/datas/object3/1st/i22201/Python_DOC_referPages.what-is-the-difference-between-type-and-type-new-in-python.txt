Natural Text
I was writing a metaclass and accidentally did it like this:...instead of like this:What exactly is the difference between these two metaclasses?  And more specifically, what caused the first one to not work properly (some classes weren't called into by the metaclass)?
In the first example you're creating a whole new class:while in the second case you're calling parent's __new__:
The first thing you need to figure out is how object.__new__() works.Here it is from the documentation:object.__new__(cls[, ...])Called to create a new instance of class cls. __new__() is a static  method (special-cased so you need not declare it as such) that takes  the class of which an instance was requested as its first argument.  The remaining arguments are those passed to the object constructor  expression (the call to the class). The return value of __new__()  should be the new object instance (usually an instance of cls).Typical implementations create a new instance of the class by invoking  the superclass’s __new__() method using super(currentclass, cls).__new__(cls[, ...]) with appropriate arguments and then modifying  the newly-created instance as necessary before returning it.If __new__() returns an instance of cls, then the new instance’s __init__() method will be invoked like __init__(self[, ...]), where self is the new instance and the remaining arguments are the same as  were passed to __new__().If __new__() does not return an instance of cls, then the new instance’s __init__() method will not be invoked.__new__() is intended mainly to allow subclasses of immutable types (like int, str, or tuple) to customize instance creation. It is also  commonly overridden in custom metaclasses in order to customize class  creation.So in mg.'s answer, the former doesn't call function __init__ while the latter calls function __init__ after calling __new__.
Please refer to the annotation below, hope this helpful.
What you get back from this is a new type, and not a MetaCls instance at all. Consequently, your methods defined in MetaCls (including __init__) can't ever be called.type.__new__ will be called as part of creating that new type, yes, but the value of cls going into that function is going to be type and not MetaCls.
Another way to achieve the same result:MyMeta is a callable so Python will use the special method __call__.Python will look for __call__ in the MyMeta's type (which is type in our case)"For new-style classes, implicit invocations of special methods are  only guaranteed to work correctly if defined on an object’s type, not  in the object’s instance dictionary"MyClass = MyMeta(...) is interpreted as:Inside the type.__call__() I imagine something like this:MyMeta.__new__() will decide how the MyClass is built:type.__new__(meta, cls, bases, attributes) will set the correct metaclass (which is MyMeta) for MyClasstype(cls, bases, attributes) will set the default metaclass (which is type) for MyClass
It's all described pretty well here.If you don't return the right type of object, there's no point to defining a custom metaclass. 


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__new__
