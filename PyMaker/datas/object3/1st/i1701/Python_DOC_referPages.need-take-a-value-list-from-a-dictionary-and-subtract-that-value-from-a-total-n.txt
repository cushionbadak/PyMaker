Natural Text
I realize that title may be confusing, so allow me to explain.I take input from a list that looks like  L = [21.123, 22.123, 23.123, 21.123]I remove the decimals, and sort the list high to low. I also change it to a dictionary with occurrences, which looks like newlist = {23: 1, 22: 1, 21: 2} What I need to do is to make a list of keys and values, which I can do. This gives me two lists, of [23, 22, 21] and [1, 1, 2] one for values and one for occurrences. I need to turn my occurrence list into the number of occurrences that are the same as, or lower than it's corresponding key.I would like my list to look like [23, 22, 21] (which is easy to do) and [4, 3, 2] because 4 of the times are 23 seconds or less, 3 of the times are 22 seconds or less, and 2 of the times are 21 seconds or less. I'm pretty sure I need a for loop to iterate through every frequency value, and change that value to be the total number of times entered into the list, and subtract any value more than it. I'm not sure how to go about this, so any help would be greatly appreciated.
You want a dictionary where, for each item in your data, the key is the rounded value (int(item)) and the value is the number of of items that are smaller than or equal to this rounded value.A dictionary comprehension (combined with a list comprehension) can do this:which is the single-statement form of writing such a loop:Using set() makes the list unique. This way the loop only runs as often as necessary.
Here's a functional solution. The marginally tricky part is the backwards cumulative sum, which is possible feeding a reversed tuple to itertools.accumulate and then reversing the result.Your desired result is stored in keys and cumsum:
Assuming you get the counts correctly from [21.123, 22.123, 23.123, 21.123], a simple nested loop with a running sum can do the rest:You could also use itertools.product() to condense the double loops into one:The above stores the counts in a collections.Counter(), you can get [4, 3, 2] by calling list(counts.values()). 
I found my own solution which seems relatively simple. Code looks likeIt takes my values, goes to the first one, adds the occurrences to counter, subtracts counter from solves, and adds 1 to even it out


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.accumulate
https://docs.python.org/3/library/itertools.html#itertools.product
https://docs.python.org/3/library/collections.html#collections.Counter
