Natural Text
Not so long ago, I began to learn asyncio. And I ran into a problem. My code is not terminating. I can't figure it out. Help me please! Result:  I tried to accomplish something, but the result was not stable.  Result (1 tasks instead of 3):  I solved my question in this way:  Added by:AT:And:But when the code is completed, I get the message:  I don't understand why this is happening.  But when I try to execute "for key" about 60 or more times, I get an error:  ...  aiohttp.client_exceptions.ClientOSError: [WinError 10054] Remote host forcibly terminated an existing connection
The answer lies in your code. Here's the clue loop.run_forever(). So you will need to call loop.stop(). I would use a condition such as an if clause or using a while loop. orThe first will stop your code when the condition is met. The latter will keep going until the condition is met.[UPDATE]We can also use;(Python Docs)Run until the future (an instance of Future) has completed.If the argument is a coroutine object it is implicitly scheduled to  run as a asyncio.Task.Return the Futureâ€™s result or raise its exception.Run the event loop until stop() is called.
Here are a few suggested changes, with context in the comments.Unless you really have a unique use-case, or are just experimenting for learning's sake, there probably shouldn't be a reason to use signal -- asyncio has top-level functions that let you decide when to close and terminate the event loop.Output:Edit: from your question:But when the code is completed, I get the message: Unclosed client sessionThis is because you need to .close() the client object, just as you would a file object.  You can do that two ways:Call it explicitly: client.close().  It is safer to wrap this in a try/finally block to make sure that it's closed no matter whatOr (easier way), use the client as an async context manager, as in this answer.  This means that, after the async with block is over, the session is automatically closed via its .__aexit__() method.The connector is the underlying TCPConnector, which is an attribute of the session.  It handles the connection pooling, and it's what ultimately is left open in your code.
I solved the problem in this way:


Answer URL
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.stop
