Natural Text
*EDIT: Title is incorrect, Big-Endian should be Little-Endian. Didn't want to change due to solutions provided.I am trying to convert a string (ex b'\x01\x00\x00\x00' <- 32 bit intger) back to an integer in my C program.Client (in Python):Server (in C):In C, I want to 'unpack' into a array/structThanks!
Assuming the title of your question is correct, and the values are actually in big-endian order, you want the ntohl (network to host long) function. Call this function for each of the 32-bit integers to convert them into the host byte order.Based on the value b'\x01\x00\x00\x00' it seems more likely that you're encoding the values in little-endian order, and that is in fact what the struct.pack call you showed will produce if you run it on a little-endian machine. Your client and server probably are both running on little-endian hardware (although you don't specify that, so it's impossible to be 100% certain).In any case, whatever form you use, you need to use the same endianness on both sides. It's probably best to not make your wire protocol endianness-dependent, so you should probably ensure that both the client and the server convert bytes into and out of a common endianness. Internet standards specify big-endian as the standard for network protocols.If you decide to standardize on big-endian, here's what you need to do:Change your struct.pack call to select big-endian encoding of integers. You can do this by adding a '>' prefix to the struct definition.Change your C code to read each integer one a time (four bytes for a 32-bit value), and then pass the values through ntohl to get a uint32_t.Re-assemble the integers into your struct on the server side.


Answer URL
https://docs.python.org/3/library/struct.html#byte-order-size-and-alignment
