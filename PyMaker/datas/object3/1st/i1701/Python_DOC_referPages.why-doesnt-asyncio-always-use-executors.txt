Natural Text
I have to send a lot of HTTP requests, once all of them have returned, the program can continue. Sounds like a perfect match for asyncio. A bit naively, I wrapped my calls to requests in an async function and gave them to asyncio. This doesn't work. After searching online, I found two solutions:use a library like aiohttp, which is made to work with asynciowrap the blocking code in a call to run_in_executorTo understand this better, I wrote a small benchmark. The server-side is a flask program that waits 0.1 seconds before answering a request.The client is my benchmarkSo, an intuitive implementation with asyncio doesn't deal with blocking io code. But if you use asyncio correctly, it is just as fast as the special aiohttp framework. The docs for coroutines and tasks don't really mention this. Only if you read up on the loop.run_in_executor(), it says:I was surprised by this behaviour. The purpose of asyncio is to speed up blocking io calls. Why is an additional wrapper, run_in_executor, necessary to do this? The whole selling point of aiohttp seems to be support for asyncio. But as far as I can see, the requests module works perfectly - as long as you wrap it in an executor. Is there a reason to avoid wrapping something in an executor ?
But as far as I can see, the requests module works perfectly - as long  as you wrap it in an executor. Is there a reason to avoid wrapping  something in an executor ?Running code in executor means to run it in OS threads.aiohttp and similar libraries allow to run non-blocking code without OS threads, using coroutines only.If you don't have much work, difference between OS threads and coroutines is not significant especially comparing to bottleneck - I/O operations. But once you have much work you can notice that OS threads perform relatively worse due to expensively context switching.For example, when I change your code to time.sleep(0.001) and range(100), my machine shows:And this difference will only increase according to number of requests.The purpose of asyncio is to speed up blocking io calls.Nope, purpose of asyncio is to provide convenient way to control execution flow. asyncio allows you to choose how flow works - based on coroutines and OS threads (when you use executor) or on pure coroutines (like aiohttp does).It's aiohttp's purpose to speed up things and it copes with the task as shown above :)


Answer URL
https://docs.python.org/3/library/asyncio-task.html
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.run_in_executor
