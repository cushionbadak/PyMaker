Natural Text
I have a sqlalchemy table defined like soI am trying to inspect this instance to get the module where it was created. I have tried using sqlalchemy.inspect(my_table).__module__, my_table.__module__, and inspect.getmodule(my_table) however, all three return sqlalchemy.sql.schema which is the module where Table is defined rather than where my_table is defined.How can I retrieve the name of the module where I have instantiated my_table?
You could add the functionality by subclassing Table. In SQLAlchemy, Table specifically overrides Table.__init__() to make it a no-op:The key being that it does not invoke super().__init__(), so that sqlalchemy can take command of instantiation and whatever you do, that needs to be maintained.In this case, MyTable.__init__() is still blocking the superclass constructor, but it also adds an attribute to the instance which will be the name of the module that the class is instantiated within. I specifically chose an obscure attribute name (_where_am_i) that is unlikely to be overwritten by sqlalchemy and using __file__ returns the path of the module (but you can make that anything you want).I tested that inserts and selects still work:And instantiation location:External module:And:Note how it returned the relative file path in the first test and the absolute file path in the external module test. You can read about that here: Python __file__ attribute absolute or relative? but you can make that _where_am_i attribute return whatever you need to suit your application.EDITThe above solution requires subclassing the Table class inside the module where instances are formed, otherwise it will peg the module where the Class is instantiated, not the instances. If you only want to subclass Table once in your project you'd need to pass the location to the constructor.This works:...but you get a warning upon instantiation:SAWarning: Can't validate argument '_where_am_i'; can't locate any SQLAlchemy dialect named '_where'.To avoid that, you'd have to override sqlalchemy's alternate constructor, Table._init(), strip out the location parameter and then delegate back up the chain:Import from external module:All above tests still pass.
You can't.  If you refer to the Python documentation index, you see that there are three entries for __module__: one for a class attribute, one for a function attribute, and one for a method attribute.  Only those types of objects have the module in which they were declared recorded.  my_table is none of these; it's just an instance of the Table class, so the only __module__ you can find on it is Table.__module__.


Answer URL
https://docs.python.org/3/genindex-_.html
https://docs.python.org/3/reference/datamodel.html#index-48
https://docs.python.org/3/reference/datamodel.html#index-34
https://docs.python.org/3/reference/datamodel.html#index-36
