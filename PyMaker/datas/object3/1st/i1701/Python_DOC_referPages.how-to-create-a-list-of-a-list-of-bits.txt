Natural Text
Say I have a list of strings. For example, this is a list of two strings.["Hello, W", "orld!---"].I already have a function char2bin that converts separate string characters characters into a list of binary. Note, this does not work for multiple character strings.Ex. How would I convert a list of multiple strings into a list of a list of binaries?For example, ["Hello, W", "orld!---"]would result in [[[0, 1, 0, 0, 1, 0, 0, 0], [0, 1, 1, 0, 0, 1, 0, 1], [0,1,1,0,1, 1, 0, 0], [0, 1, 1, 0, 1, 1, 0, 0], [0,1,1,0,1,1,1,1], [0, 0, 1, 0, 1, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0], [0,1,1,1,0,1,1, 1]], [[0, 1, 1, 0, 1, 1, 1, 1], [0,1,1,1,0,0,1,0], [0,1, 1, 0, 1, 1, 0, 0], [0, 1, 1, 0, 0, 1, 0, 0], [0,0,1,0,0,0,0,1], [0, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1,1,1,1,0], [0, 1, 1, 1,1, 1, 1, 0]]]As you can see, each string character has converted into a list of binaries, but since there are two separate strings, there are also two separate lists of binary lists.
you can iterate over the characters in a string, and iterate over the words in a word_list.   So you can do the following :using my own interpretation of char2bin:gives the result:which i believe is the format you are looking for.
There are three basic approaches here, comprehension, functional, and procedural. The comprehension form is considered idiomatic Python (or "pythonic").ComprehensionList comprehensions can build the list elements from any Python expression, including other list comprehensions--you can nest them.[[char2bin(c) for c in word] for word in ["Hello, W", "orld!---"]]The Python comprehension syntax has equivalents of map() loops and element filter()s without requiring an explicit lambda like those builtin functions would. We don't need filters for this task. But because you already have a function char2bin() declared, you can already use map() without the lambda, like so.[[*map(char2bin, word)] for word in ["Hello, W", "orld!---"]]The above version mixes a little functional style into the comprehension, and is probably the most Pythonic.In Python 2 you wouldn't need to put it in the [*] part to make it a list, but in Python 3 map() makes a lazy generator instead of a list.FunctionalYou can always rewrite comprehensions in terms of maps and filters by using lambda (anonymous functions). You usually don't use a lambda in Python when a comprehension would do.[*map(lambda word: [*map(char2bin, word)], ["Hello, W", "orld!---"])]And the newer unpack-into-list syntax [*foo] can still be done with the list constructor.list(map(lambda word: list(map(char2bin, word), ["Hello, W", "orld!---"]))The above is a more functional style, although it could be taken a bit further to point-free style with a functional library using currying and function composition. But even pure-functional languages like Haskell have comprehensions, which is where Python got them from in the first place.ProceduralList comprehensions can always be converted to a procedural-style by using explicit for loops and accumulators (and if-statements when there are filters). This is much more verbose, but would be more familiar to those coming from a procedural language like C, so you still see it pretty often in Python.Compare the above to my recommendation:


Answer URL
https://docs.python.org/3/reference/expressions.html#displays-for-lists-sets-and-dictionaries
