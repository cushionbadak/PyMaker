Natural Text
If it were just checking whether letters in a test_string are also in a control_string, I would not have had this problem.I will simply use the code below.But I also face a rather convoluted task of discerning whether the overlapping letters in the control_string are in the same sequential order as those in test_string.For example,I thought of using the for iterator to compare the indices of the alphabets, but it is quite hard to think of the appropriate algorithm.My plan is to compare the primary index factor to the next factor, and if primary index factor turns out to be larger than the other, the function returns False. I am stuck on how to compare those index_factors in a for loop.How should I approach this problem?
You can use find(letter, last_index) to find occurence of desired letter after processed letters.If test string have duplicate letters like:With commented line same_order_in(test_string, control_string) == Trueand with uncommented line same_order_in(test_string, control_string) == False
You could just join the characters in your test string to a regular expression, allowing for any other characters .* in between, and then re.search that pattern in the control string.Without using regular expressions, you can create an iter from the control string and use two nested loops,1) breaking from the inner loop and else returning False until all the characters in test are found in control. It is important to create the iter, even though control is already iterable, so that the inner loop will continue where it last stopped.You could even do this in one (well, two) lines using all and any:Complexity for both approaches should be O(n), with n being the max number of characters.1) This is conceptually similar to what @jpp does, but IMHO a bit clearer.
Here's one solution. The idea is to iterate through the control string first and yield a value if it matches the next test character. If the total number of matches equals the length of test, then your condition is satisfied.@tobias_k's answer has cleaner version of this. If you want some additional information, e.g. how many letters align before there's a break found, you can trivially adjust the checker function to return sum(1 for _ in zip(x, yield_in_order(...))).
Recursion is the best way to solve such problems. Here's one that checks for sequential ordering.Outputs:and False for Here's an Iterative approach that does the same thing,
An elegant solution using a generator:First check if all the letters in the test_string are contained in the control_string. Then check if the order is similar to the test_string order.
A simple way is making use of the key argument in sorted, which serves as a key for the sort comparison:Thus this is computing the intersection of the two sets and sorting it according to the longer string. Having done so you only need to compare the result with the shorter string to see if they are the same.The function returns True or False accordingly. Using your examples:


Answer URL
https://docs.python.org/3/library/re.html
