Natural Text
Let's say I've got a simple class in pythonI can cast it to an integer very easilyWhich is great! But, now I want to cast it to a dict in a similar fashionWhat do I need to define for this to work? I tried substituting both __dict__ and dict for __what_goes_here__, but dict(w) resulted in a TypeError: Wharrgarbl object is not iterable in both cases. I don't think simply making the class iterable will solve the problem. I also attempted many googles with as many different wordings of "python cast object to dict" as I could think of but couldn't find anything relevant :{Also! Notice how calling w.__dict__ won't do what I want because it's going to contain w.version and w.sum. I want to customize the cast to dict in the same way that I can customize the cast to int by using def int(self).I know that I could just do something like thisBut I am assuming there is a pythonic way to make dict(w) work since it is the same type of thing as int(w) or str(w). If there isn't a more pythonic way, that's fine too, just figured I'd ask. Oh! I guess since it matters, this is for python 2.7, but super bonus points for a 2.4 old and busted solution as well.There is another question Overloading __dict__() on python class that is similar to this one but may be different enough to warrant this not being a duplicate. I believe that OP is asking how to cast all the data in his class objects as dictionaries. I'm looking for a more customized approach in that I don't want everything in __dict__ included in the dictionary returned by dict(). Something like public vs private variables may suffice to explain what I'm looking for. The objects will be storing some values used in calculations and such that I don't need/want to show up in the resulting dictionaries.UPDATE:I've chosen to go with the asdict route suggested but it was a tough choice selecting what I wanted to be the answer to the question. Both @RickTeachey and @jpmc26 provided the answer I'm going to roll with but the former had more info and options and landed on the same result as well and was upvoted more so I went with it. Upvotes all around though and thanks for the help. I've lurked long and hard on stackoverflow and I'm trying to get my toes in the water more.
There are at least five ways. The preferred way depends on what your use case is.Option 1: Simply add an asdict() method.Based on the problem description I would very much consider the asdict way of doing things suggested by other answers. This is because it does not appear that your object is really much of a collection:Using the other options below could be confusing for others unless it is very obvious exactly which object members would and would not be iterated or specified as key-value pairs.Option 2: Override ' __iter__'.Like this, for example:Now you can just do: This works because the dict() constructor accepts an iterable of (key, value) pairs to construct a dictionary. Before doing this, ask yourself the question whether iterating the object as a series of key,value pairs in this manner- while convenient for creating a dict- might actually be surprising behavior in other contexts. E.g., ask yourself the question "what should the behavior of list(my_object) be...?"Additionally, note that accessing values directly using the get item obj["a"] syntax will not work, and keyword argument unpacking won't work. For those, you'd need to implement the mapping protocol.Option 3: Implement the mapping protocol. This allows access-by-key behavior, casting to a dict without using __iter__, and also provides keyword unpacking behavior.The mapping protocol requires that you provide (at minimum) two methods together: keys() and __getitem__.Now you can do things like:Note that the mapping protocol takes precedence over the __iter__ method when casting an object to a dict directly (without using kwarg unpacking, i.e. dict(m)). So it is possible- and sometimes convenient- to cause the object to have different behavior when used as an iterable (e.g., list(m)) vs. when cast to a dict (dict(m)).EMPHASIZED: Just because you CAN use the mapping protocol, does NOT mean that you SHOULD do so. Does it actually make sense for your object to be passed around as a set of keyword arguments? Does accessing it by key- just like a dictionary- really make sense?If the answer to these questions is yes, it's probably a good idea to consider the next option.Option 4: Look into using the 'collections.abc' module.Inheriting your class from 'collections.abc.Mapping or 'collections.abc.MutableMapping signals to other users that, for all intents and purposes, your class is a mapping * and can be expected to behave that way.You can still cast your object to a dict just as you require, but there would probably be little reason to do so. Because of duck typing, bothering to cast your mapping object to a dict would just be an additional unnecessary step the majority of the time.This answer might also be helpful.As noted in the comments below: it's worth mentioning that doing this the abc way essentially turns your object class into a dict-like class (assuming you use MutableMapping and not the read-only Mapping base class). Everything you would be able to do with dict, you could do with your own class object. This may be, or may not be, desirable.Also consider looking at the numerical abcs in the numbers module:https://docs.python.org/3/library/numbers.htmlSince you're also casting your object to an int, it might make more sense to essentially turn your class into a full fledged int so that casting isn't necessary. Option 5: Look into using the dataclasses module (Python 3.7 only).Now you can do this:* "Mapping" has become the standard "name" of the dict-like duck type
There is no magic method that will do what you want. The answer is simply name it appropriately. asdict is a reasonable choice for a plain conversion to dict, inspired primarily by namedtuple. However, your method will obviously contain special logic that might not be immediately obvious from that name; you are returning only a subset of the class' state. If you can come up with with a slightly more verbose name that communicates the concepts clearly, all the better.Other answers suggest using __iter__, but unless your object is truly iterable (represents a series of elements), this really makes little sense and constitutes an awkward abuse of the method. The fact that you want to filter out some of the class' state makes this approach even more dubious.
something like this would probably work
I think this will work for you.  Output{'a': 1, 'c': 3, 'b': 2, 'sum': 6, 'version': 5}
It's hard to say without knowing the whole context of the problem, but I would not override __iter__.I would implement __what_goes_here__ on the class.
Like many others, I would suggest implementing a to_dict() function rather than (or in addition to) allowing casting to a dictionary. I think it makes it more obvious that the class supports that kind of functionality. You could easily implement such a method like this:


Answer URL
https://docs.python.org/3/c-api/mapping.html
https://docs.python.org/3/library/collections.abc.html
https://docs.python.org/3/library/numbers.html
https://docs.python.org/3/library/dataclasses.html
https://docs.python.org/3/reference/datamodel.html?emulating-container-types#emulating-container-types
https://docs.python.org/3/library/collections.abc.html#collections.abc.Mapping
