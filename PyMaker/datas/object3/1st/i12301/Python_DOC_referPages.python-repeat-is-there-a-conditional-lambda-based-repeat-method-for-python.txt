Natural Text
I have the following functionand I want to run it repetively feeding the value returned from handle(x) into itself until it returns 1i.e. handle(...handle(handle(handle(x)))...) until one of them in the chain returns a 1I want to write something like this:well basically I want to store the output of handle until I get 1.Is there a generator expression equivalent of this? or a functools.repeat method I could use for this?Just to be clear, I would like to avoid directly using a for loop with a yield or recursion. I would like to use python in built features to solve this excluding the for loop/recursion.
You could use itertools.accumulate and itertools.takewhile, I guess:which givesbut I share the common view that I don't see the point here.  Even the official documentation lists a lot of recipes which are handy for working with iterables which aren't built-in; I don't see why you couldn't just define something likeand get on with your day.  I know you've said you don't want to use yield explicitly for some reason, but just because you say you want something doesn't mean that what you want makes any sense. :-)
You do not need no magical methods for working with Collatz Conjecture, just write a regular loopin particular you can make it a generatorand obviously you can parametrize it throughand you can call it with lambda expression as handle/end.
First of all, here's what I think is the canonical approach using a generator and a while loop.Demo:The other option which comes close to what you are looking for is to use recursion and the yield from syntax, if your Python version supports it:There's a problem with this approach, though, which is blowing up the stack:
You can use while loop :


Answer URL
https://docs.python.org/3/library/itertools.html#itertools-recipes
