Natural Text
Here's a scenario which simulates running an older version of a Python program against a shelve database written by a newer version. Ideally, the User object would still be parsed and read in; the favouritePet attribute would be ignored. Understandably, it throws an error complaining that the tuple doesn't match.Is there a good way of making this scenario work with namedtuples, or better to switch to storing a dictionary or class if this sort of flexibility is required?Edit: For completeness here's the same idea using a class:
I would advise to use a dict or custom class.A named tuple needs exactly as many arguments as it has fields, so to make this work with a named tuple directly yout'd have to change the class' __new__ method to use *args and **kwargs instead of a fixed list of arguments. If you have a look at the definition of your User class (by adding the verbose=True argument), you'll see how the class is defined:__new__ would have to become __new__(_cls, *args, **kwargs), and then correctly parse args and kwargs (you'll still want to be able to use User('a', 'b', 'c', ...) as well as User('a', password='b', firstname='c', ...) but not User('a', username='A', ...) to remain consistent with namedtuple), and then use the resulting sequence with tuple.__new__. It's probably better to use a dedicated class instead of modifying the behaviour of a namedtuple in such a way.It would be easier to change the way the User namedtuple is pickled by using the __reduce__ protocol (or copyreg.pickle()) by using a custom constructor function, e.g:This will work as long as the construct_user function is available in all compatible versions, but as said initially, I would still recommend to use a different data structure.


Answer URL
https://docs.python.org/3/library/pickle.html#object.__reduce__
https://docs.python.org/3/library/copyreg.html#copyreg.pickle
