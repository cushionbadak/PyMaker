Natural Text
So I am trying to make a program that prints out the number of ways a message can be decoded.The mapping can be easily understood in the code itself. Right now it is working for most numbers, but for some it is not calculating it correctly. For example the number 1111, it solves it like there are 2 ways of decoding it but in reality there is 4 different ways of doing so.This is my code:Using this method I have not found a way to be able to successfully calculate it correctly. Is there a better way of achieving this? Thanks in advance!NOTE - Mapping is a representation of the alphabet giving each letter the value of their position in the alphabet.
I can think of a recursive approach:decodeNumer checks if the test input starts with an entry in mapping. For all entries that do it calls itself. The new parameter is test[len(i):] which means test with the entry removed from the begining.For example let test = "918": the if statement evaluates to true for the first time when i == "9" and the new parameter is test[len("9"):] which is equal to "18".The total count is computed as the total number of paths which consume the complete input.
Here's a clean dynamic programming approach which runs in worst-case time O(nk) where k is the length of the mapping and n is the length of the string. In particular, unlike the naive recursive approach, it will never take exponential time on an input.This works on Python 3.2+.Note that mapping should be a tuple in this implementation (you can also just omit the mapping parameter from the function declaration to use a global mapping variable).Memoization saves us from having to repeatedly compute the same values. Without memoization, the algorithm must do at least res recursive calls (since every counted decoding must end in a recursive call to the return 1 case eventually). With memoization, we can skip over recursive calls that have already been handled.You can see the difference if you try to run decodeNumber("1" * 256, ("1", "11")) with and without memoization. Without memoization it will never finish. With memoization, the result is instant.
Here's an iterative solution with O(n) time complexity (one pass) and O(1) space complexity:It's a dynamic programming approach. In each iteration add another digit and calculate the number of ways a message can be decoded up to this digit. If the previous and current digits are greater than 26 put together then the current is the same as the previous, because the current digit must be on its own. Otherwise, the ways to encode the message equals the ways to encode the message without the two (prevprev) plus the ways to encode the message without the current digit (prev).Also, there are 5 ways to decode 1111 (1-1-1-1, 1-1-11, 1-11-1, 11-1-1, 11-11)


Answer URL
https://docs.python.org/3/library/functools.html
