Natural Text
I'm working on one of those classic student problems in Python, finding the maximum and minimum values in a series of entries. Normally, I would want to do this by putting all the valid user entries in a list, but instead we're supposed to be evaluating each entry one by one as it comes from the user. (In this class, we're covering loops before lists.)Since I'm not using a list, I am balking at declaring a variable to be None and then evaluating "largest is None or largest < new" since the former case will only happen once. Instead, I mucked around with min() and max() until I fell upon the following solution, which seems to me to be elegant but my peers have dismissed as an abomination. So here's the question: Is this a valid use of try/except? Is it less pythonic than the commented alternative? (Granted, the most pythonic way would be min([list]) but here I am.)
No, that's a pretty ridiculous use of try/except.Declare it upfront and define it as None, and then update it asAlternatively, you could initialize it as smallest = [], and then update it asthen finish it off with
While trying and handling exception is, in general, a fundamental principle of Python—EAFP, or Easier to Ask Forgiveness than Permission—it isn't always appropriate.At the very least, a NameError is the kind of thing that's generally more of a logic error in your code that needs to be fixed than an exceptional situation to be handled, so there's a pretty bad "code smell" here.Also, consider what should happen if the user never enters any numbers. If you've initialized smallest = None, it'll print out Minimum is None, which is not too unreasonable. If you've left it uninitialized, it'll print out a stack trace from an unhandled NameError, which is a lot less user-friendly.But there's a simple alternative: just pick a start value that's larger than any valid input, and then you don't need the check (whether via EAFP or LBYL): smallest = min(num, smallest) will always be the right answer.What value can you use for that? Well, infinity is obviously bigger than any integer, so you can just start with float('inf').(I'm not sure whether Minimum is inf is better or worse than Minimum is None for the no-values case, but it's definitely better than the traceback.)Meanwhile, it's worth noting that there's a much cleaner design for this that avoids the problem in the first place. Just factor out your code to generate a stream of integers, and then you can do whatever you want with the resulting iterable. For example:This has all the advantages of building a list (you can just call min on it) without the disadvantages (you don't have to actually build a list up in memory).You can simplify this even further by using the two-argument iter around raw_input to yield a generator of strings, then transforming that in two steps to a generator of integers, then just passing that to min. But I think it's easier for a novice to understand this way.


Answer URL
https://docs.python.org/3/glossary.html#term-eafp
