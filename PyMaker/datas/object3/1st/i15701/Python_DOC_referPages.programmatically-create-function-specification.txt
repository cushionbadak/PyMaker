Natural Text
UPDATE: I'm not asking about a variable number of arguments. The end result (if possible) should be a function defined exactly as per  my example below, or at least behaving exactly in that way - I've  added some examples to the question to try and clarify this.(It may be the case that the only way to achieve this is to use func(*args, **kwargs) and then manually process those and raise the appropriate exceptions if the inputs don't exactly match expectations, in which case that would be a valid answer)For my own entertainment, I was wondering how to achieve the following:equivalent toThis means the following behaviour is required:The focus of the question is on the variable argspec - I comfortable creating the function body using the usual decorator techniques.For those that are interested, I was playing around with trying to programmatically create classes like the following. Again the difficulty is in generating the __init__ method with programmatic parameters - the rest of the class appears straightforward using a decorator or maybe a metaclass.
You can use exec to construct the function object from a string containing Python code:Example:If you want more functionality (e.g., default argument values), it's a matter of adapting the string that contains the code and having it represent the desired function signature.Disclaimer: as pointed out below it's important that you verify the contents of parameters and that the resulting Python code string is safe to pass to exec. You should construct parameters yourself or put restrictions in place to prevent the user from constructing a malicious value for parameters.
One of the possible solutions using a class:
Here's another way to do it using functools.wrap, which preserves signature and docstring, at least in python 3.  The trick is to create the signature and documentation in dummy functions which never get called.  Here are a couple of examples.Basic exampleAnd the result is:Calling inspect.signature(exposed_func_1).parameters returns the desired signature.  Using inspect.getfullargspec(exposed_func_1), however, still returns the signature of template.  At least if you put any arguments common to all functions you want to make in the definition of template, those will appear.If this is a bad idea for some reason, please let me know!More complicated exampleAnd you can get much more complicated than this, by layering in more wrappers and defining more distinct behaviors in an inner function:It's a bit verbose, but the point is that there is a lot of flexibility in where the dynamic inputs from you (the programmer) come in when using this to create functions, and so with where the exposed inputs (from user of the function) get used.


Answer URL
https://docs.python.org/3/library/functions.html#exec
