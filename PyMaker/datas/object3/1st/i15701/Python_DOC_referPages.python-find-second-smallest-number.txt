Natural Text
I found this code on this site to find the second largest number:Source: Get the second largest number in a list in linear timeIs it possible to modify this code to find the second smallest number? So for example
The function can indeed be modified to find the second smallest:The old version relied on a Python 2 implementation detail that None is always sorted before anything else (so it tests as 'smaller'); I replaced that with using float('inf') as the sentinel, as infinity always tests as larger than any other number. Ideally the original function should have used float('-inf') instead of None there, to not be tied to an implementation detail other Python implementations may not share.Demo:Outside of the function you found, it's almost just as efficient to use the heapq.nsmallest() function to return the two smallest values from an iterable, and from those two pick the second (or last) value:Like the above implementation, this is a O(N) solution; keeping the heap variant each step takes logK time, but K is a constant here (2)! Whatever you do, do not use sorting; that takes O(NlogN) time.

Or just use heapq
As per the Python in-built function sortedgives back the smallest number, and sorted(my_list)[1] does accordingly for the second smallest, and so on and so forth.
You can use in built function 'sorted'
It's slightly faster than the sort method, and it modifies the list.
Yes, except that code relies on a small quirk (that raises an exception in Python 3): the fact that None compares as smaller than a number.Another value that works is float("-inf"), which is a number that is smaller than any other number.If you use that instead of None, and just change -inf to +inf and > to <, there's no reason it wouldn't work.Edit: another possibility would be to simply write -x in all the comparisons on x, e.g. do if -x <= m1: et cetera.
Here we want to keep an invariant while we scan the list of numbers, for every sublist it must bem1<=m2<={all other elements}the minimum length of a list for which the question (2nd smallest) is sensible is 2, so we establish the invariant examining the first and the second element of the list (no need for magic numbers), next we iterate on all the remaining numbers, maintaining our invariant.AddendumBTW, the same reasoning should be applied to the second_largest function mentioned by the OP
I am writing the code which is using recursion to find the second smallest element in a list.You can test it with various input integers.
There is a easy way to do . First sort the list and get the second item from the list.




Answer URL
https://docs.python.org/3/library/heapq.html#heapq.nsmallest
