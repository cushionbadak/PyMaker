Natural Text
I come from a solid Java (and Matlab) background, and have been trying to teach myself Python (3.4) recently. In the Java API docs (http://docs.oracle.com/javase/7/docs/api/), the documentation for a particular class always shows a nice overview of the ancestors of that class (see e.g. this screenshot).Now I'm wondering if there is any way of viewing a similar ancestor hierarchy for Python classes. I am working from the assumption that, since Python is an object-oriented language, all non-primitive types will be objects (please correct me if I'm wrong). Understanding the ancestry for different types should probably greatly aid my understanding of iterables, sequences, views, and lists.I've tried several things, as suggested in answers to similar questions (such as here); but inspect.mro(cls) does not always seem to work; for instance, the following gives an error:inspect.getmro(dict_keys)even though dict_keys is a type:In[30]: type({}.keys())Out[30]: dict_keysI was also highly surprised to learn that list does not inherit from iterable:In[34]: inspect.getmro(list)Out[34]: (list, object)So, although my question is mainly about how to view (and, ideally, browse) the hierarchy of the standard Python library, any other comments on how to understand the default types' hierarchy, mainly how lists/sequences/views/iterables relate formally, would also be very welcome. The (otherwise excellent) Python tutorial does not really cover this stuff, it seems.
Just because something is a type doesn't mean you have a reference to that type in the global namespace.  This is the case with dict_keys.  e.g.So it does have an MRO, and it is inspectable -- You just didn't have a handle on the dict_keys type before now.Note that the MRO can be a bit deceiving:so we see that list at least thinks that it is a subclass of collections.Iterable even though you won't find it in the MRO.  This is because collections.Iterable actually registers itself using the abc module.I think that this is one of the basic differences between python and java.  In python, you typically care more about the interface the object provides rather than the actual type and inheritance tree.  At some level this statement may seem a bit pedantic -- After all, you need to know the inheritance tree to know the interface an object provides.  But the fact that we work in interfaces is exactly why tuple, list and generator objects can be iterated over despite not having a real common base class (collections.Iterable doesn't count as it is a virtual base class) above object (which can't be iterated over).


Answer URL
https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy
