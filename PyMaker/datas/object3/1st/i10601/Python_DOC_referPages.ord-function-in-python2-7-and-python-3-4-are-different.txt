Natural Text
I have been running a script where I use the ord() function and for whatever the reason in python 2.7, it accepts the unicode string character just as it requires and outputs an integer.In python 3.4, this is not so much the case. This is the output of error that is being produced : When I look in both documentations, the ord function is explained to be doing the same exact thing. This is the code that I am using for both python versions:Can anyone explain why python3.4 it says that c is an integer, rather than in Python 2.7 where it is actually a string, just as the ord() function requires?
I think the difference is that in Python 3 the sock.recvfrom(...) call returns bytes while Python 2.7 recvfrom returns a string. So ord did not change but what is being passed to ord has changed. Python 2.7 recvfromPython 3.5 recvfrom
You are passing in an integer to ord() in Python 3. That's because you are iterating over a bytes object in Python 3 (the first element in the tuple return value from socket.recvfrom()):From the bytes type documentation:While bytes literals and representations are based on ASCII text, bytes objects actually behave like immutable sequences of integers[.]andSince bytes objects are sequences of integers (akin to a tuple), for a bytes object b, b[0] will be an integer [...].In Python 2, socket.recvfrom() produces a str object instead, and iteration over such an object gives new one-character string objects, which indeed need to be passed to ord() to be converted to an integer.You could instead use a bytearray() here to get the same integer sequence in both Python 2 and 3:You don't need to use ord() at all in that case.


Answer URL
https://docs.python.org/3/library/socket.html#socket.socket.recvfrom
https://docs.python.org/3/library/stdtypes.html#bytes
