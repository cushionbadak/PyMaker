Natural Text
Which is "more correct (logically)"? Specific to Leap Year, not in general.With ParenthesesWithoutAdditional InfoParentheses change the order in which the booleans are evaluated (and goes before or w/o parenthesis).Given that all larger numbers are divisible by smaller numbers in this problem, it returns the correct result either way but I'm still curious.Observe the effects of parentheses:Without parentheses, there are scenarios where even though year is not divisible by 4 (first bool) it still returns True (I know that's impossible in this problem)! Isn't being divisible by 4 a MUST and therefore it's more correct to include parenthesis? Anything else I should be paying attention to here? Can someone explain the theoretical logic of not/including parentheses?
The parens affect what order your booleans take. ands are grouped together and resolved before ors are, so:becomes:if either BOTH a and b are truthy, OR if c is truthy, we get True.With the parentheses you get:Now you get True if both a is truthy and either b OR c is truthy.As far as "correctness," as long as your code derives the correct result then "more correct" is only a matter of opinion. I would include parens where you feel like it makes the result more clear. For instance:is more clear thanHowever it is NOT more clear (in my opinion) than:Your guide when writing Python code should be PEP8. PEP8 is quiet on when you should include stylistic parentheses (read: parens that follow the natural order of operations), so use your best judgement.For leap years specifically, the logic is:If the year is evenly divisible by 4, go to step 2. ...If the year is evenly divisible by 100, go to step 3. ...If the year is evenly divisible by 400, go to step 4. ...The year is a leap year (it has 366 days).The year is not a leap year (it has 365 days).In other words: all years divisible by 4 are leap years, unless they're divisible by 100 and NOT divisible by 400, which translates to:
Include the parentheses. In English, the rule is:Year must be divisible by 4.Year must not be visible by 100, unless it's divisible by 400.The version with parentheses matches this two-pronged rule best.As it happens, removing the parentheses does not break the code, but it leads to an unnatural version of the rules:Year must be divisible by 4, but not by 100; orYear must be divisible by 400.That's not the way I think of the leap year rule.
Which answer is "more correct" and why?It's not a matter of what is 'more correct', rather; what logic do you wish to implement? Parenthesis' in boolean expressions change order of operations. This allows you to force precedence in its execution.As for the logic in the leap year formula, the rules go as follows:Leap Years are any year that can be evenly divided by 4 (such as 2012, 2016, etc)Except if it can be evenly divided by 100, then it isn't (such as 2100, 2200, etc)Except if it can be evenly divided by 400, then it is (such as 2000, 2400)Thus the exception rules must take precedence, which is why the parenthesis around the or is necessary to adhere to the formula's rules. Other wise the two arguments to and would be evaluated first.
Which answer is "more correct" and why? (Specific to Leap Year Logic, not in general)With Parenthesesreturn year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)Withoutreturn year % 4 == 0 and year % 100 != 0 or year % 400 == 0Depends on your definition of "more correct". As you know, both return correct. Now speculating the "more correctness" - if you are referring to performance benefits, I cannot think of any, considering the current smart compilers.If you are discussing the human readability point of view, I would go with,return year % 4 == 0 and year % 100 != 0 or year % 400 == 0It naturally narrows down the scope, opposed to your other alternative, which seemed to include visually two disjoint elements.I would suggest, include parentheses, but as below:return (year % 4 == 0 and year % 100 != 0) or year % 400 == 0 
As you noted, in operation, there is no difference, since the number being divisible by 400 implies that it is also divisible by 100, which implies that it is also divisible by 4.  Operationally, whether the parentheses have any effect depends on the lexical order (order of evaluation) of the language.  Most languages today follow the conventions of c, which means a specified precedence of operators, and left-to-right otherwise.  When in doubt, I always put parentheses for readability.Stylistically, this sort of thing is hard to read when put in a long expression like that.  If it must be one expression, I would prefer to have the logical "sum of products" to the "product of sums"  So I would goOr evenAn optimizing compiler will make efficient code, anyway, and this sort of thing really helps poor humans like me to read it.
Answer: Include ParenthesesJohn Kugelman explains why they are 2 separate logical tests as opposed to 3, -> the last 2 should be grouped together:Year must be divisible by 4.(2) Year must not be visible by 100, (3) unless it's divisible by 400.The version with parentheses matches this two-pronged rule best.As it happens, removing the parentheses does not break the code, but it leads to an unnatural version of the rules:Year must be divisible by 4, but not by 100; orYear must be divisible by 400.That's not the way I think of the leap year rule.Inspired by mrdomoboto, 100/400 are the exception!:Year must be divisible by 4, 100 is an exception and 400 is an exception of the exception but they are still one exception in total (see above). This means that if year is not divisible by 4 then the whole thing must be False. The only way to ensure this is to put parens around the exception because False and bool will always return False.See below examples of this from JBallinAdam Smith translated the english into code:All years divisible by 4 are leap years, unless they're divisible by 100 and NOT divisible by 400, which translates to:JBallin cited De Morgan's Laws:To convert above into the desired answer:
Here's the other difference: SPEED AND EFFICIENCY.Aside from order of evaluation (already mentioned in other answers)...Let's simplify the original expressionyear % 4 == 0 and (year % 100 != 0 or year % 400 == 0) to this:A and (B or C)If A is false, there is no reason to test B or C because and requires BOTH sides to be true.SHORT-CIRCUIT OPERATORSLogical operators and and or have a "short-circuit" effect in many languages, including Python, where only the left side is evaluated (See https://docs.python.org/2/library/stdtypes.html#boolean-operations-and-or-not):and short-circuits when the left side is false (because the right side cannot make the result be true)or short-circuits when the left side is true (because the right side cannot make the result be false)WITH PARENTHESIS:A and (B or C)When A is false, the right side (B or C) doesn't get evaluated, saving CPU resources.When A is true, B gets evaluated, but C only gets evaluated if B is false.WITHOUT PARENTHESIS:A and B or CWhen A is false, B doesn't get evaluated, but C gets (needlessly) evaluated.When A is true, B gets evaluated. If B is false, C also gets evaluated.CONCLUSION:Without parenthesis, C (the year % 400 test) gets needlessly evaluated when A is false (the year % 4 test). This is 75% of the time that the CPU could stop at A, but continues to do more math needlessly.MOST-EFFICIENT EXPRESSION:Use this instead:((year & 3) == 0 && ((year % 25) != 0 || (year & 15) == 0))This expression replaces modulo (slow division) with bitwise-AND (fast!) in two cases.More details at: https://stackoverflow.com/a/11595914/733805


Answer URL
https://docs.python.org/3/reference/expressions.html#evaluation-order
