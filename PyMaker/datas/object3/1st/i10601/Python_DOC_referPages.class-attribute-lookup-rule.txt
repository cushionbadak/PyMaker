Natural Text
Why does D.__class__ return the name of the class, while D().__class__ returns the defined attribute in class D? And from where do builtin attributes such as __class__ and __name__ come from? I suspected __name__ or __class__ to be simple descriptors that live either in object class or somewhere, but this can't be seen.In my understanding, the attribute lookup rule as follows in Python, omitting the conditions for descriptors etc..: Instance --> Class --> Class.__bases__ and the bases of the other classes as wellGiven the fact that a class is an instance of a metaclass, type in this case, why D.__class__ doesn't look for __class__ in D.__dict__?
The names __class__ and __name__ are special. Both are data descriptors. __name__ is defined on the type object, __class__ is defined on object (a base-class of all new-style classes):Because they are data descriptors, the type.__getattribute__ method (used for attribute access on a class) will ignore any attributes set in the class __dict__ and only use the descriptors themselves:Fun fact: type derives from object (everything in Python is an object) which is why __class__ is found on type when checking for data descriptors:(type.__getattribute__(D, ...) is used directly as an unbound method, not D.__getattribute__(), because all special method access goes to the type).See the Descriptor Howto an what constitutes a data descriptor and why that matters:If an object defines both __get__() and __set__(), it is considered a data descriptor. Descriptors that only define __get__() are called non-data descriptors (they are typically used for methods but other uses are possible).Data and non-data descriptors differ in how overrides are calculated with respect to entries in an instance’s dictionary. If an instance’s dictionary has an entry with the same name as a data descriptor, the data descriptor takes precedence. If an instance’s dictionary has an entry with the same name as a non-data descriptor, the dictionary entry takes precedence.For data descriptors on type, a class is just another instance.So when looking up the __class__ or __name__ attributes, it doesn't matter what is defined in the D.__dict__ namespace, because for either a data descriptor is found in the namespace formed by type and it's MRO.These descriptors are defined in the typeobject.c C code:On instances, object.__getattribute__ is used, and it'll find the __name__ and __class__ entries in the D.__dict__ mapping before it'll find the data descriptors on object or type.If you omit either, however, then looking up the names on D() will only __class__ as a data descriptor in the MRO of D (so, on object). __name__ is not found as the metatypes are not considered when resolving instance attributes.As such you can set __name__ on an instance, but not __class__:


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__getattribute__
https://docs.python.org/3/reference/datamodel.html#special-lookup
https://docs.python.org/3/howto/descriptor.html
