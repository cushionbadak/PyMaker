Natural Text
I'd like to slice a list of strings based on substrings possibly contained into its elements:so that I'd get:My main problem being that the beginning and end conditions used to get indexes are different and should be variable (basic substring containment as above-mentioned, regexes or other methods possible).First and last elements might need to be stripped out but I guess this is a matter of adjusting indexes by 1.My code works in the ideal cases but will often fail as structure and contents of l are not very predictable. Absence of one or both elements matching conditions should end up with the final string being None.Are comprehensions relevant, or mapping a lambda function to apply both conditions?
Try:

Or with next():Similar as list comprehension, execpt it doesn't return a list but the first element it found. if it doesn't found anything, it return an optional element (here '0')This way, if there is no 'begins' or no 'ends' in your list, you don't have to print anything. Therefore, this allows you to check either if the 'ends' comes before the 'begins'. I also love list comprehension but sometimes what you need isn't a list.SOLUTION FOR ADVANCE USER:The problem with the use of two comprehension list, is that you check twice your list from start and it will fail when ends comes before start:To avoid this, you might use a generator with send() to only iterate once on your list.Here, the yield allows you to get the index without exiting the function.This is better, but if there is no begins or endsin the list, there will be a StopIteration exception. To avoid this, you can just do a infinite loop on yield 0 instead. Now the complete solution will be:


Answer URL
https://docs.python.org/3/reference/expressions.html#examples
