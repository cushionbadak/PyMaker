Natural Text
I currently have 6 separate for loops which iterate over a list of numbers looking to match specific sequences of numbers within larger sequences, and replace them like this:And their inverse:My existing code is like this:In total I'm iterating over the same output_array 6 times, using brute force checking. Is there a faster method?

While this question related to the questions Here and Here, the question from OP relates to fast searching of multiple sequences at once. While the accepted answer works well, we may not want to loop through all the search sequences for every sub-iteration of the base sequence.Below is an algo which checks for a sequence of i ints only if the sequence of (i-1) ints is present in the base sequenceYou can test the above code with this snippet:The proposed solution represents the sequences to be searched as a decision tree. Due to skipping the many of the search points, we should be able to do better than O(m*n) with this method (where m is number of search sequences and n is length of base sequence.EDIT: Changed answer based on more clarity in edited question.


Answer URL
https://docs.python.org/3/library/profile.html
