Natural Text
I hope someone can answer this that has a good deep understanding of Python :)Consider the following code:Notice how repr(a) does not yield the expected result of "A" ?I want to know why this is the case and if there is a way to achieve this...I contrast, the following example works however (Maybe because we're not trying to override a special method?):
Python doesn't call the special methods, those with name surrounded by __ on the instance, but only on the class, apparently to improve performance. So there's no way to override __repr__() directly on an instance and make it work. Instead, you need to do something like so:Now you can override __repr__() on an instance by substituting _repr().
As explained in Special Method Lookup:For custom classes, implicit invocations of special methods are only guaranteed to work correctly if defined on an object’s type, not in the object’s instance dictionary … In addition to bypassing any instance attributes in the interest of correctness, implicit special method lookup generally also bypasses the __getattribute__() method even of the object’s metaclass(The part I've snipped out explains the rationale behind this, if you're interested in that.)Python doesn't document exactly when an implementation should or shouldn't look up the method on the type; all it documents is, in effect, that implementations may or may not look at the instance for special method lookups, so you shouldn't count on either.As you can guess from your test results, in the CPython implementation, __repr__ is one of the functions looked up on the type.Things are slightly different in 2.x, mostly because of the presence of classic classes, but as long as you're only creating new-style classes you can think of them as the same.The most common reason people want to do this is to monkey-patch different instances of an object to do different things. You can't do that with special methods, so… what can you do? There's a clean solution, and a hacky solution.The clean solution is to implement a special method on the class that just calls a regular method on the instance. Then you can monkey patch that regular method on each instance. For example:The hacky solution is to build a new subclass on the fly and re-class the object. I suspect anyone who really has a situation where this is a good idea will know how to implement it from that sentence, and anyone who doesn't know how to do so shouldn't be trying, so I'll leave it at that.
The reason for this is special methods (__x__()) are defined for the class, not the instance.This makes sense when you think about __new__() - it would be impossible to call this on an instance as the instance doesn't exist when it's called.So you can do this on the class  as a whole if you want to:Or on an individual instance, as in kindall's answer. (Note there is a lot of similarity here, but I thought my examples added enough to post this as well).
For new style classes, Python uses a special method lookup that bypasses instances.  Here an excerpt from the source: You can either change to an old-style class (don't inherit from object) or you can add dispatcher methods to the class (methods that forward lookups back to the instance).  For an example of instance dispatcher methods, see the recipe at http://code.activestate.com/recipes/578091


Answer URL
https://docs.python.org/3/reference/datamodel.html#special-method-lookup
