Natural Text
This question already has an answer here:Python generator that groups another iterable into groups of N [duplicate]                    9 answers                Can you think of a nice way (maybe with itertools) to split an iterator into chunks of given size?Therefore l=[1,2,3,4,5,6,7] with chunks(l,3) becomes an iterator [1,2,3], [4,5,6], [7]I can think of a small program to do that but not a nice way with maybe itertools.
The grouper()  recipe from the itertools documentation's recipes comes close to what you want:It will fill up the last chunk with a fill value, though.A less general solution that only works on sequences but does handle the last chunk as desired isFinally, a solution that works on general iterators an behaves as desired is
Although OP asks function to return chunks as list or tuple, in case you need to return iterators, then Sven Marnach's solution can be modified:Some benchmarks: http://pastebin.com/YkKFvm8bIt will be slightly more efficient only if your function iterates through elements in every chunk. 
This will work on any iterable. It returns generator of generators (for full flexibility). I now realize that it's basically the same as @reclosedevs solution, but without the fluff. No need for try...except as the StopIteration propagates up, which is what we want.  The next(iterable) call is needed to raise the StopIteration when the iterable is empty, since islice will continue spawning empty generators forever if you let it.It's better because it's only two lines long, yet easy to comprehend. Note that next(iterable) is put into a tuple. Otherwise, if next(iterable) itself were iterable, then itertools.chain would flatten it out. Thanks to Jeremy Brown for pointing out this issue.
I was working on something today and came up with what I think is a simple solution. It is similar to jsbueno's answer, but I believe his would yield empty groups when the length of iterable is divisible by n. My answer does a simple check when the iterable is exhausted.
Here's one that returns lazy chunks; use map(list, chunks(...)) if you want lists.
A succinct implementation is:This works because [iter(iterable)]*n is a list containing the same iterator n times; zipping over that takes one item from each iterator in the list, which is the same iterator, with the result that each zip-element contains a group of n items. izip_longest is needed to fully consume the underlying iterable, rather than iteration stopping when the first exhausted iterator is reached, which chops off any remainder from iterable. This results in the need to filter out the fill-value. A slightly more robust implementation would therefore be:This guarantees that the fill value is never an item in the underlying iterable. Using the definition above:This implementation almost does what you want, but it has issues:(The difference is that because islice does not raise StopIteration or anything else on calls that go beyond the end of it this will yield forever; there is also the slightly tricky issue that the islice results must be consumed before this generator is iterated).To generate the moving window functionally:So this becomes:But, that still creates an infinite iterator. So, you need takewhile (or perhaps something else might be better) to limit it:
"Simpler is better than complex" -a straightforward generator a few lines long can do the job. Just place it in some utilities module or so:
I forget where I found the inspiration for this.  I've modified it a little to work with MSI GUID's in the Windows Registry:reverse doesn't apply to your question, but it's something I use extensively with this function.
Here you go.Examples:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools-recipes
