Natural Text
I use boost.python for calling script. Each python script has 3 functions:Initialize - that have to be called at startUninitialize - that have to be called at finish for closing every object.Process - that have to be called multiple times between Initialize and Uninitialize.This class don't need in explanation:This class creates PyInit object instance, then initialize all Python objects and makes call to "Initialize()" python function at constructor.And calls "Uninitialize()" at destructor.And this class has function "Process" to call it outside of class multiple times. As only "Process" fails with "boost::python::error_already_set" exception, current instance of PyGuard is deleted and then created new one. To avoid hidden dependencies that could be as hidden exception result. So, after exception, all python stuff is removed (even calls Py_Finalize()), and then created again.Still, after 4-10 such exceptions, whole c++ process falls.Falls, avoiding even catchers:So, my question is, why can it falls and being uncatchable?I just found that it falls at line:call, so I feel it is Python raise exception that can't be catched. Why? And how to prevent it?
It's possible that your use of Py_Finalize() is the problem. According to the Boost 1.55 documentation, you shouldn't use Py_Finalize() with Boost.Python. It doesn't look like your program really needs finalization, so you might try just removing the call from ~PyInit().If you really do need finalization for some reason, you might look at Py_NewInterpreter().As for your "uncatchable exceptions" problem, that's often an effect of having two active exceptions at once. When that happens, C++ will simply abort. That may (or may not) be what's happening with your code. 


Answer URL
https://docs.python.org/3/c-api/init.html#c.Py_NewInterpreter
