Natural Text
Using python3.4. Here I want use singledispatch to dispatch different type in __mul__ method . The code like this :As you can see the code , I want support Vector*Vertor , This has Name errorThe question may be How Can I use class Name a Type in the class's method ? I know c++ have  font class statement . How python solve my problem ? And it is strange to see result = Vector(len(self)) where the Vector can be used in method body .update . After have A look at http://lukasz.langa.pl/8/single-dispatch-generic-functions/I can choose this way to implement :The ans is strange :v.__mul__(3)  can work but v*3 can't work. This is strange From my option v*3 is just the same as v.__mul__(3) .Update after @Martijn Pieters's comment, I still want implement v*3 in class. So I try thisThis time . I implemet like I implement v.__mul__(3). But the error is For me static methond should act like the instance methond.
You cannot use functools.singledispatch on methods at all, not as a decorator at least.It doesn't matter that Vector isn't defined here yet; the first argument to any method is always going to be self, while you'd use single dispatch for the second argument here.Because decorators apply to the function objects before the class object is created, you could just as well register your 'methods' as functions instead, outside of the class body, so you have access to the Vector name:For non-supported types, you need to return the NotImplemented singleton, not raise an exception. This way Python will try the inverse operation too.However, since the dispatch is going to key on the wrong argument (self) here anyway, you'll have to come up with your own single dispatch mechanism.If you really want to use @functools.singledispatch you'd have to delegate to a regular function, with the arguments inversed:As for your updates using __init__mul__: v * 3 is not translated to v.__mul__(3). It is instead translated to type(v).__mul__(v, 3), see Special method lookup in the Python datamodel reference. This always bypasses any methods set directly on the instance.Here type(v) is Vector; Python looks up the function, it won't use a bound method here. Again, because functools.singledispatch dispatches on the first argument, always, you cannot use single dispatch directly on the methods of Vector, because that first argument is always going to be a Vector instance.In other words, Python will not use the methods you set on self in __init__mul__; special methods are never looked up on the instance, see Special method lookup in the datamodel documentation.
This is a little ugly, as you need to defer binding the implementation of Vector/Vector multiplication until after Vector is actually defined. But the idea is that the single-dispatch function needs the first argument to be of arbitrary type, so Vector.__mul__ will call that function with self as the second argument.


Answer URL
https://docs.python.org/3/reference/datamodel.html#special-method-lookup
https://docs.python.org/3/reference/datamodel.html#special-lookup
https://docs.python.org/3/reference/datamodel.html#special-method-lookup
https://docs.python.org/3/howto/descriptor.html
