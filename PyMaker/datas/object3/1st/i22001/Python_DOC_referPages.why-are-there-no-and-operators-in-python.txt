Natural Text
Why are there no ++ and -- operators in Python?
It's not because it doesn't make sense; it makes perfect sense to define "x++" as "x += 1, evaluating to the previous binding of x".If you want to know the original reason, you'll have to either wade through old Python mailing lists or ask somebody who was there (eg. Guido), but it's easy enough to justify after the fact:Simple increment and decrement aren't needed as much as in other languages.  You don't write things like for(int i = 0; i < 10; ++i) in Python very often; instead you do things like for i in range(0, 10).Since it's not needed nearly as often, there's much less reason to give it its own special syntax; when you do need to increment, += is usually just fine.It's not a decision of whether it makes sense, or whether it can be done--it does, and it can.  It's a question of whether the benefit is worth adding to the core syntax of the language.  Remember, this is four operators--postinc, postdec, preinc, predec, and each of these would need to have its own class overloads; they all need to be specified, and tested; it would add opcodes to the language (implying a larger, and therefore slower, VM engine); every class that supports a logical increment would need to implement them (on top of += and -=).This is all redundant with += and -=, so it would become a net loss.
This original answer I wrote is a myth from the folklore of computing: debunked by Dennis Ritchie as "historically impossible" as noted in the letters to the editors of Communications of the ACM July 2012 doi:10.1145/2209249.2209251The C increment/decrement operators were invented at a time when the C compiler wasn't very smart and the authors wanted to be able to specify the direct intent that a machine language operator should be used which saved a handful of cycles for a compiler which might do a instead of and the PDP-11 even supported "autoincrement" and "autoincrement deferred" instructions corresponding to *++p and *p++, respectively. See section 5.3 of the manual if horribly curious.As compilers are smart enough to handle the high-level optimization tricks built into the syntax of C, they are just a syntactic convenience now. Python doesn't have tricks to convey intentions to the assembler because it doesn't use one.
I always assumed it had to do with this line of the zen of python:There should be one — and preferably only one — obvious way to do it.x++ and x+=1 do the exact same thing, so there is no reason to have both. 
Of course, we could say "Guido just decided that way", but I think the question is really about the reasons for that decision. I think there are several reasons:It mixes together statements and expressions, which is not good practice. See http://norvig.com/python-iaq.htmlIt generally encourages people to write less readable codeExtra complexity in the language implementation, which is unnecessary in Python, as already mentioned
Because, in Python, integers are immutable (int's += actually returns a different object).Also, with ++/-- you need to worry about pre- versus post- increment/decrement, and it takes only one more keystroke to write x+=1.  In other words, it avoids potential confusion at the expense of very little gain.
Clarity!Python is a lot about clarity and no programmer is likely to correctly guess the meaning of --a unless s/he's learned a language having that construct.Python is also a lot about avoiding constructs that invite mistakes and the ++ operators are known to be rich sources of defects.These two reasons are enough not to have those operators in Python.The decision that Python uses indentation to mark blocks ratherthan syntactical means such as some form of begin/end bracketing or mandatory end marking is based largely on the same considerations.For illustration, have a look at the discussion around introducing a conditional operator (in C: cond ? resultif : resultelse) into Python in 2005.Read at least the first message and the decision message of that discussion (which had several precursors on the same topic previously).Trivia:The PEP frequently mentioned therein is the "Python Extension Proposal" PEP 308. LC means list comprehension, GE means generator expression (and don't worry if those confuse you, they are none of the few complicated spots of Python).
It was just designed that way.  Increment and decrement operators are just shortcuts for x = x + 1.  Python has typically adopted a design strategy which reduces the number of alternative means of performing an operation.  Augmented assignment is the closest thing to increment/decrement operators in Python, and they weren't even added until Python 2.0.
I'm very new to python but I suspect the reason is because of the emphasis between mutable and immutable objects within the language.  Now, I know that x++ can easily be interpreted as x = x + 1, but it LOOKS like you're incrementing in-place an object which could be immutable.Just my guess/feeling/hunch.
My understanding of why python does not have ++ operator is following: When you write this in python a=b=c=1 you will get three variables (labels) pointing at same object (which value is 1). You can verify this by using id function which will return an object memory address:All three variables (labels) point to the same object. Now increment one of variable and see how it affects memory addresses:You can see that variable a now points to another object as variables b and c. Because you've used a = a + 1 it is explicitly clear. In other words you assign completely another object to label a. Imagine that you can write a++ it would suggest that you did not assign to variable a new object but ratter increment the old one. All this stuff is IMHO for minimization of confusion. For better understanding see how python variables works:In Python, why can a function modify some arguments as perceived by the caller, but not others?Is Python call-by-value or call-by-reference? Neither.Does Python pass by value, or by reference?Is Python pass-by-reference or pass-by-value?Python: How do I pass a variable by reference?Understanding Python variables and Memory ManagementEmulating pass-by-value behaviour in pythonPython functions call by referenceCode Like a Pythonista: Idiomatic Python
I believe it stems from the Python creed that "explicit is better than implicit".
First, Python is only indirectly influenced by C; it is heavily influenced by ABC, which apparently does not have these operators, so it should not be any great surprise not to find them in Python either.Secondly, as others have said, increment and decrement are supported by += and -= already.Third, full support for a ++ and -- operator set usually includes supporting both the prefix and postfix versions of them.  In C and C++, this can lead to all kinds of "lovely" constructs that seem (to me) to be against the spirit of simplicity and straight-forwardness that Python embraces.For example, while the C statement while(*t++ = *s++); may seem simple and elegant to an experienced programmer, to someone learning it, it is anything but simple.  Throw in a mixture of prefix and postfix increments and decrements, and even many pros will have to stop and think a bit.
This may be because @GlennMaynard is looking at the matter as in comparison with other languages, but in Python, you do things the python way. It's not a 'why' question. It's there and you can do things to the same effect with x+=. In The Zen of Python, it is given: "there should only be one way to solve a problem." Multiple choices are great in art (freedom of expression) but lousy in engineering.
as i understood it so you won't think the value in memory is changed.in c when you do x++ the value of x in memory changes.but in python all numbers are immutable hence the address that x pointed as still has x not x+1. when you write x++ you would think that x change what really happens is that x refrence is changed to a location in memory where x+1 is stored or recreate this location if doe's not exists.  
The ++ class of operators are expressions with side effects. This is something generally not found in Python.For the same reason an assignment is not an expression in Python, thus preventing the common if (a = f(...)) { /* using a here */ } idiom.Lastly I suspect that there operator are not very consistent with Pythons reference semantics. Remember, Python does not have variables (or pointers) with the semantics known from C/C++.
Maybe a better question would be to ask why do these operators exist in C. K&R calls increment and decrement operators 'unusual' (Section 2.8page 46). The Introduction calls them 'more concise and often more efficient'. I suspect that the fact that these operations always come up in pointer manipulation also has played a part in their introduction.In Python it has been probably decided that it made no sense to try to optimise increments (in fact I just did a test in C, and it seems that the gcc-generated assembly uses addl instead of incl in both cases) and there is no pointer arithmetic; so it would have been just One More Way to Do It and we know Python loathes that.
To complete already good answers on that page:Let's suppose we decide to do this, prefix (++i) that would break the unary + and - operators.Today, prefixing by ++ or -- does nothing, because it enables unary plus operator twice (does nothing) or unary minus twice (twice: cancels itself)So that would potentially break that logic.
I think this relates to the concepts of mutability and immutability of objects. 2,3,4,5 are immutable in python. Refer to the image below. 2 has fixed id until this python process. x++ would essentially mean an in-place increment like C. In C, x++ performs in-place increments. So, x=3, and x++ would increment 3 in the memory to 4, unlike python where 3 would still exist in memory. Thus in python, you don't need to recreate a value in memory. This may lead to performance optimizations. This is a hunch based answer.
++ operator is not exactly same the += operator.In fact result of both is same but uses have some difference.For example, You can use ++ operator in ternary conditional, for loop, etc but can't use +=.At bottom, We feel the need ++ and --, for this reason.


Answer URL
https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions
https://docs.python.org/3/reference/expressions.html#generator-expressions
