Natural Text
This question already has an answer here:How to get Python to gracefully format None and non-existing fields [duplicate]                    3 answers                Is there a way to use python string.format such that no exception is thrown when an index is missing, instead an empty string is inserted.here,result should be :Right now, python throws a keyerror and stops formatting. Is it possible to change this behavior ?ThanksEdit: There exists Template.safe_substitute (even that leaves the pattern intact instead of inserting an empty string) , but couldn't something similar for string.formatThe desired behavior would be similar to string substitution in php.This seems to provide the desired behavior.
str.format() doesn't expect a mapping object. Try this:You make a defaultdict with a str() factory that returns "". Then you make one key for the defaultdict. In the format string, you access keys of the first object passed. This has the advantage of allowing you to pass other keys and values, as long as your defaultdict is the first argument to format().Also, see http://bugs.python.org/issue6081
The official solution (Python 3 Docs) for strings in format mappings is to subclass the dict class and to define the magic-method __missing__(). This method is called whenever a key is missing, and what it returns is used for the string formatting instead:Edit: the second print() works in Python 3.5.3, but it does not in e.g. 3.7.2: KeyError: 'bar' is raised and I couldn't find a way to catch it.After some experiments, I found a difference in Python's behavior. In v3.5.3, the calls are __getitem__(self, "foo") which succeeds and __getitem__(self, "bar") which can not find the key "bar", therefore it calls __missing__(self, "bar") to handle the missing key without throwing a KeyError. In v3.7.2, __getattribute__(self, "keys") is called internally. The built-in keys() method is used to return an iterator over the keys, which yields "foo", __getitem__("foo") succeeds, then the iterator is exhausted. For {bar} from the format string there is no key "bar". __getitem__() and hence __missing_() are not called to handle the situation. Instead, the KeyError is thrown. I don't know how one could catch it, if at all.In Python 3.2+ you should use format_map() instead (also see Python Bug Tracker - Issue 6081):If you want to keep the placeholders, you can do:As you can see, format_map() does call __missing__().The following appears to be the most compatible solution as it also works in older Python versions including 2.x (I tested v2.7.15):
Unfortunately, no, there is no such way to do by default. However you can provide it defaultdict or object with overridden __getattr__, and use like this:
I made a version that does work similarly to Daniel's method but without the {0.x} attribute access.prints out


Answer URL
