Natural Text
Say I want to make a decorator for methods defined in a class. I want that decorator, when invoked, to be able to set an attribute on the class defining the method (in order to register it in a list of methods that serve a particular purpose).In Python 2, the im_class method accomplishes this nicely:However, in Python 3, no such attribute (or a  replacement for it) seems to exist. I suppose the idea was that you could call type(method.__self__) to get the class, but this does not work for unbound methods, since __self__ == None in that case.NOTE: This question is actually a bit irrelevant for my case, since I've chosen instead to set an attribute on the method itself and then have the instance scan through all of its methods looking for that attribute at the appropriate time. I am also (currently) using Python 2.6. However, I am curious if there is any replacement for the version 2 functionality, and if not, what the rationale was for removing it completely.EDIT: I just found this question. This makes it seem like the best solution is just to avoid it like I have. I'm still wondering why it was removed though.
The point you appear to be missing is, in Python 3 the "unbound method" type has entirely disappeared -- a method, until and unless it's bound, is just a function, without the weird "type-checking" unbound methods used to perform.  This makes the language simpler!To wit...:and voila -- one less subtle concept and distinction to worry about.  Such simplifications are the core advantage of Python 3 wrt Python 2, which (over the years) had been accumulating so many subtleties that it was in danger (if features kept being added to it) of really losing its status as a simple language.  With Python 3, simplicity is back!-)
I thought it would be worthwhile writing something that does it best at guessing the defining class. For completeness' sake this answer also addresses bound methods.At worst, guessing should fail altogether, with the function returning None. However, under any circumstances, it shouldn't raise an exception or return an incorrect class.TL;DRThe final version of our function successfully overcomes most simple cases, and a few pitfalls as well.In a nutshell, its implementation differentiates between bound methods and “unbound methods“ (functions) since in Python 3 there is no reliable way to extract the enclosing class from an “unbound method".For a bound method, it simply traverses the MRO, in a similar manner to that done in the accepted answer to an equivalent question for Python 2.For an “unbound method“, it relies on parsing its qualified name, which is available only from Python 3.3 and is quite reckless (if this feature is unnecessary it's probably best to remove this block of code and just return None instead).There is also partial handling for methods defined via descriptors, that aren't classified as ordinary methods or functions (for example, set.union, int.__add__ and int().__add__ but not set().union).The resulting function is:A small requestIf you decide to use this implementation, and encounter any caveats, please comment and describe what happened.The Full Version“Unbound methods” are regular functionsFirst of all, it's worth noting the following change made in Python 3 (see Guido's motivation here):The concept of “unbound methods” has been removed from the language. When referencing a method as a class attribute, you now get a plain function object.This makes it practically impossible to reliably extract the class in which a certain “unbound method“ was defined unless it's bound to an object of that class (or of one of its subclasses).Handling bound methodsSo, let us first handle the “easier case“ in which we have a bound method. Note that the bound method must be written in Python, as described in inspect.ismethod's documentation.However, this solution is not perfect and has its perils, as methods can be assigned in runtime, rendering their name possibly different than that of the attribute that they are assigned to (see example below). This problem exists also in Python 2. A possible workaround would be to iterate over all of the class's attributes, looking for one whose identity is that of the specified method.Handling “unbound methods“Now that we got that out of the way, we can suggest a hack that tries to handle “unbound methods”. The hack, its rationale, and some discouragement words can be found in this answer. It relies on manually parsing the __qualname__ attribute, available only from Python 3.3, is highly unrecommended, but should work for simple cases:Combining both approachesSince inspect.isfunction and inspect.ismethod are mutually exclusive, combining both approaches into a single solution gives us the following (with added logging facilities for the upcoming examples):Execution exampleSo far, so good, but...Final touchesThe outcome generated by Z.y can be partially fixed (to return None) by verifying that the returned value is a class, before actually returning it.The outcome generated by Z().z can be fixed by falling back to parsing the function's __qualname__ attribute (the function can be extracted via meth.__func__).The outcome generated by Z.class_meth and Z().class_meth is incorrect because accessing a class method always returns a bound method, whose __self__ attribute is the class itself, rather than its object. Thus, further accessing the __class__ attribute on top of that __self__ attribute doesn't work as expected:This can be fixed by checking whether the method's __self__ attribute returns an instance of type. However, this might be confusing when our function is invoked against methods of a metaclass, so we'll leave it as is for now.Here is the final version:Surprisingly, this also fixes the outcome of Z.class_meth and Z().class_meth which now correctly return Z. This is because the __func__ attribute of a class method returns a regular function whose __qualname__ attribute may be parsed:EDIT:As per the issue raised by Bryce, it's possible to handle method_descriptor objects, like set.union, and wrapper_descriptor objects, like int.__add__, merely by returning their __objclass__ attribute (introduced by PEP-252), if such exists:However, inspect.ismethoddescriptor returns False for the respective instance method objects, i.e. for set().union and for int().__add__:Since int().__add__.__objclass__ returns int, the above if clause may be relinquished in order to solve the problem for int().__add__. Unfortunately, this doesn't address the matter of set().union, for which no __objclass__ attribute is defined. In order to avoid an AttributeError exception in such a case, the __objclass__ attribute isn't accessed directly, but rather via the getattr function.
Since python 3.6 you could accomplish what you are describing using a decorator that defines a __set_name__ method. The documentation states that object.__set_name__ is called when the class is being created.Here is an example that decorates a method "in order to register it in a list of methods that serve a particular purpose":Note that this question is very similar to Can a Python decorator of an instance method access the class? and therefore my answer as well to the answer I provided there.
A small extension for python 3.6 (python 2.7 worked fine) to the great answer of https://stackoverflow.com/a/25959545/4013571I found the following adjustment was required for doctestAs for some reason, when using nose the inspect.getmodule(meth) didn't contain the defining class


Answer URL
https://docs.python.org/3/library/inspect.html#inspect.ismethod
https://docs.python.org/3/reference/datamodel.html#implementing-descriptors
https://docs.python.org/3/reference/datamodel.html#object.__set_name__
