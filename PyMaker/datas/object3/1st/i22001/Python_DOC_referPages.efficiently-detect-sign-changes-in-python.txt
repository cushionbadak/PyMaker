Natural Text
I want to do exactly what this guy did:Python - count sign changesHowever I need to optimize it to run super fast. In brief I want to take a time series and tell every time it crosses crosses zero (changes sign). I want to record the time in between zero crossings. Since this is real data (32 bit float) I doubt I'll every have a number which is exactly zero, so that is not important. I currently have a timing program in place so I'll time your results to see who wins.My solution gives (micro seconds):As you can see the zero-crossing detector is the slow part. Here's my code.
What about:Output:i.e. zero_crossings will contain the indices of elements after which a zero crossing occurs. If you want the elements before, just add 1 to that array.
As remarked by Jay Borseth the accepted answer does not handle arrays containing 0 correctly. I propose using:Since a) using numpy.signbit() is a little bit quicker than numpy.sign(), since it's implementation is simpler, I guess and b) it deals correctly with zeros in the input array. However there is one drawback, maybe: If your input array starts and stops with zeros, it will find a zero crossing at the beginning, but not at the end...
Another way to count zero crossings and squeeze just a few more milliseconds out of the code is to use nonzero and compute the signs directly. Assuming you have a one-dimensional array of data:Alternatively, if you just want to count the zero crossings for a particular direction of crossing zero (e.g., from positive to negative), this is even faster:On my machine these are a bit faster than the where(diff(sign)) method (timings for an array of 10000 sine samples containing 20 cycles, 40 crossings in all):
Jim Brissom's answer fails if a contains the value 0:Output:The number of zero crossing should be 7, but because sign() returns 0 if 0 is passed, 1 for positive, and -1 for negative values, diff() will count the transition containing zero twice.An alternative might be:which give the correct answer of:
Do you want to time it? Or do you want to make it as fast as possible?Timing is easy. Run it a zillion times, stopwatch it, and divide by a zillion.To make it as fast as possible, what you need to do is find out what's taking time and that you could do in a better way. I use either 1) the random-pause technique, or 2) the single-step technique.
I see people using diff a lot in their solutions, but xor seems to be much faster and the result is the same for bools (a good pointer to that might also be the fact that using diff gives a deprecated warning.... :) )Here is an example:Time it measures it to be around one and a half faster to diff for me:)If you  do not care about edge cases it might be better to use but positive = a2 >0 seems faster (and cleaner) than signbit AND checking for 0s (e.g. positive = np.bitwise_or(np.signbit(a2),np.logical_not(a2)) is slower...)
Another way that might suit certain applications is to extend the evaluation of the expression np.diff(np.sign(a)). If we compare how this expression reacts to certain cases:Rising crossing without zero: np.diff(np.sign([-10, 10])) returns array([2])Rising crossing with zero: np.diff(np.sign([-10, 0, 10])) returns array([1, 1])Falling crossing without zero: np.diff(np.sign([10, -10])) returns array([-2])Falling crossing with zero: np.diff(np.sign([10, 0, -10])) returns array([-1, -1])So we have to evaluate np.diff(...) for the returned patterns in 1. and 2:and for the cases 3. and 4.:After this we can easily find the indices with This approach should be reasonable fast because it can manage without using a "slow" loop.This combines the approach of several other answers.


Answer URL
https://docs.python.org/3/library/collections.html#collections.deque
