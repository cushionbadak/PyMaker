Natural Text
Earlier today, I read the question "Raise error if python dict comprehension overwrites a key" and decided to try my hand at an answer.  The method that naturally occurred to me was to subclass dict for this.  However, I got stuck on my answer, and now I'm obsessed with getting this worked out for myself.  Notes:No - I do not plan on turning in the answer to this question as an answer to the other question.This is purely an intellectual exercise for me at this point.  As a practical matter, I would almost certainly use a namedtuple or a regular dictionary wherever I have a requirement for something like this.My (not quite working) Solution:My Tests and Expected ResultsI'm certain the issue is in my update() method, but I'm not able to determine just what I'm doing wrong.Below is the original version of my update() method.  This version fails as expected on duplicates when calling my_dict.update({k: v}) for a key/value pair already in the dict, but does not fail when including a duplicate key while creating the original dict, due to the fact that converting the args to a dict results in default behavior for a dictionary, i.e., overwriting the duplicate key.
Note that, per the documentation:dict.update takes a single other parameter, "either another dictionary object or an iterable of key/value pairs" (I've used collections.Mapping to test for this) and "If keyword arguments are specified, the dictionary is then updated with those key/value pairs"; anddict() takes a single Mapping or Iterable along with optional **kwargs (the same as update accepts...).This is not quite the interface you have implemented, which is leading to some issues. I would have implemented this as follows:In use:and:If you ever end up using this, I'd be inclined to give it a different __repr__ to avoid confusion!
It's interesting that simply overriding __setitem__ is not enough to change the behavior of update in dict. I would have expected that dict would use its __setitem__ method when it's being updated using update. In all cases, I think it's better to implement collections.MutableMapping to achieve the desired result without touching update:Edit: included dict as base class to satisfy the isinstance(x, dict) check.
I am not sure this is the problem but I just noticed that you are treating your args in the update method as a list of pairs:while you are actually supplying a dictionary:Have you tried this:EDIT: Probably this error went unnoticed because you are excepting a ValueError, which is what treating a dictionary as a list of pairs will raise.
I was able to achieve the goal with the following code:
Why not do something along the lines inspired by MultiKeyDict using setdefault? This leaves the update method as a way to override the currently stored values, breaking, I know, the intent that d[k] = v == d.update({k, v}). In my application the override was useful. So before flagging this as not answering the OP question, please consider this answer might be useful for someone else.Rather new to python so flame on, probably deserve it... 


Answer URL
https://docs.python.org/3/library/stdtypes.html#dict.update
https://docs.python.org/3/library/stdtypes.html#dict
https://docs.python.org/3/library/abc.html
