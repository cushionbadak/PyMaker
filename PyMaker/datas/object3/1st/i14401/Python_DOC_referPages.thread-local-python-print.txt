Natural Text
Are there any built-in ways to have different threads have different destinations for print() and similar?I'm exploring the creation of an interactive Python environment, so I can't just use print() from module spamegg. It has to be the globally available one with no arguments.
You can replace sys.stdout with an object that checks the current thread and writes to the appropriate file:
It is possible to do what you're asking, although it's complicated and clunky and possibly not portable, and I don't think it's what you want to do.Your objection to just using spamegg.print is:I'm exploring the creation of an interactive Python environment, so I can't just use print() from module spamegg. It has to be the globally available one with no arguments.But the solution to that is easy: Just use print from module spamegg in your code, and from spamegg import print in the interactive interpreter. That's all there is to it.For that matter, there's no good reason this even needs to be called print in the first place. If all of your code used some other output function with a different name, you could do the same thing in the interactive interpreter.But how does that let each thread have a different destination?The easy way to do that is to just look up the destination in a threading.local().But if you really want to do both parts of this the hard way, you can.To do the global print the hard way, you can either have spamegg replace the builtin print instead of just giving you a way to shadow it, or have it replace sys.stdout, so the builtin print with default arguments will print somewhere else.That still requires having MyStdOut use a thread-local target.Alternatively, you can compile or wrap each thread function in its own custom globals environment that replaces __builtins__ and/or sys from the default, allowing you to give a different one to each thread from the start. For example:
I might have solution for you, but it's quite more complicated than just print. Using this, you can create log handler for each thread and configure them to store logs to different locations.Keep in mind that this is developed with slightly different goal in mind (see comments) but you can adapt it by taking handler juggling feature of ClusteredLogging as a start.And some test code:


Answer URL
https://docs.python.org/3/library/threading.html#thread-local-data
