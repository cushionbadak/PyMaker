Natural Text
I made a little generator function for character ranges:And then I can do this:Yay! But this doesn't work:And this works, but is O(n), unlike range's O(1):That means it takes about 0.35 seconds to search for character number 109,999 out of the maximum of 110,000. 109999 in range(110000) is, of course, fast.At that point, my first thought was to simply subclass range. Unfortunately:So I guess I would have to mimic it in some way that allows me to pass characters as arguments, works like range internally, and produces characters. Unfortunately, I'm not sure how to proceed. I tried a dir():which lets me see what functions are in there, but I'm not sure what they're doing, or how range uses them. I looked for the source for range, but it's in C, and I don't know where to find its Python wrapper (it does have one, right?).Where do I go from here, and should I even go there?
To add to Martin Konecny's answer. You probably want to use an internal range for everything and convert between chr and ord.In other words: if we can't subclass it we can use object composition.
At that point, my first thought was to simply subclass range. range was a function in Python2 and a "final" class in Python3 (more info here) - in both cases not something you can sub-class. You will need to create a class crange that extends from an object as the base type. And this works, but is O(n), unlike range's O(1)In Python 3, there is a __contains__ method that you will define for your object.For objects that donâ€™t define __contains__(), the membership test first tries iteration via __iter__(), then the old sequence iteration protocol via __getitem__(), see this section in the language reference.This allows Python to determine if the value is in your range without actually enumerating the range.For a simple example, if your range is 1 to 1,000,000, it is trivial to determine whether 23546 is in that range (1 < 23546 < 1000000). Of course the actual implementation is a bit more complex and adds ability to handle step increments etc. Regarding:Yay! But this doesn't work: >>> crange('a','e')[::2]In this case you need to define __getitem__ on your object. Here's an example of some of the methods required:


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__contains__
https://docs.python.org/3/reference/datamodel.html
