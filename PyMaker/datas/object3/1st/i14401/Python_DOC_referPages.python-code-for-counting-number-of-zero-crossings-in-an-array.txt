Natural Text
I am looking to count the number of times the values in an array change in polarity (EDIT: Number of times the values in an array cross zero). Suppose I have an array:I want the count to be 8. One solution is to run a loop and check for greater than or less than 0, and keep a history of the previous polarity. Can we do this faster?EDIT: My purpose is really to find something faster, because I have these arrays of length around 68554308, and I have to do these calculations on 100+ such arrays. 
This produces the same result:gives:and seems to be the fastest solution:Compared to the fastest so far:Also for larger arrays:this:vs:
Here's a numpy solution. Numpy's methods are generally pretty fast and well-optimized, but if you're not already working with numpy there's probably some overhead from converting the list to a numpy array:
Based on Scott's answerThe generator expression proposed by Scott uses enumerate which returns tuples containing index and list item. List item are not used in the expression at all and discarded later. So better solution in terms of time would beIf your list a is really huge, range may throw an exception. You can replace it with itertools.islice and itertools.count.In Python version 2.x, use xrange instead of Python 3's range.In Python 3, xrange is no longer available.
I think a loop is a straight forward way to go:You could use a generator expression but it gets ugly:EDIT:@Alik pointed out that for huge lists the best option in space and time (at least out of the solutions we have considered) is not to call change_sign in the generator expression but to simply do:
Seems like, you want to group numbers by their sign. This could be done using built-in method groupby:Then you should use function len which returns the number of groups:Obviously, there will be at least one group (for a non-empty list), but if you want to count the number of points, where a sequence changes its polarity, you could just subtract one group. Do not forget about the empty-list case.You should also take care about zero elements: shouldn't they be extracted into another group? If so, you could just change the key argument (lambda function) of groupby function. 
You can achieve it using list comprehension:


Answer URL
https://docs.python.org/3/library/functions.html#func-range
