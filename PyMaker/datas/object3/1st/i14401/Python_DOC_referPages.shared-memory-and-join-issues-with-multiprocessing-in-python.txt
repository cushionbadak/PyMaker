Natural Text
I have written some codes as below, through which I wanted to test some specific problems with multiprocessing:However, when I ran this file, I found some weird phenomena. One particular output is as below:First of all, when passing data[i] to subprocess, id(data[i]) does not change at all, but AFAIK python fork() is copy-on-accessing because of ref-count changing. Secondly, suppose it is copy-on-write in python, when obj is modified in subprocess, int/File type object does change its id but this is not true with type list as we can see its id never changes even compared with the original id. Last but not least, I use join to wait for all subprocesses to complete, but output of parent process seems to always be messed up with subprocess ones, why? Thanks if any one could explain these for me.
None of this has anything to do with multiprocessing. You can run the exact same test just calling the same function in-process and you'll get the same results.First of all, when passing data[i] to subprocess, id(data[i]) does not change at allThat's because you don't change data[i] anywhere.When you pass data[i] as an argument, the obj parameter doesn't become a reference to the variable data[i], it becomes a reference to the same value that's in that variable.When you later do obj = …, that doesn't affect the value in any way; it just makes obj refer to a different value instead.If you want to mutate data, you have to pass data itself (and, presumably, i); then the function can do data[i] =.Secondly, suppose it is copy-on-write in python, when obj is modified in subprocess, int/File type object does change its id but this is not true with type listNope. The difference has nothing to do with the types, or with copy-on-write. obj = … never affects the original object. It doesn't matter whether it's an int or a list.The reason you see different behavior isn't that the type is different, it's that you have different code. You don't do obj = …, you do obj.append(…). That's a method on the object, which mutates it in-place.(If you're curious about obj += 3, that one is a bit trickier. Augmented assignment may mutate the value in-place as well as assigning a new value to the variable, or it may just assign a new value to the variable. It's up to the value's type. Generally, mutable types like list will mutate in-place and assign self back to the variable; immutable types like int will of course never mutate in-place, they'll always assign a new value.)My guess is that you're coming from a language like C++, where variables are actually memory locations where the values live, assignment is a mutating method (which normally copies values), and explicit references are references to variables, not to values. If so, it may help to think of every variable in Python a std::shared_ptr<boost::any>, not a boost::any&.Last but not least, I use join to wait for all subprocesses to complete, but output of parent process seems to always be messed up with subprocess ones, why?Because you don't actually wait for all subprocesses to complete. This line:… iterates over range(5, 4), which is empty, so you don't join anything.This is one of the many reasons it's better to iterate directly over collections:If you do it that way, there's no place to insert a hard-to-debug counting error.Meanwhile, even though it turns out to be completely irrelevant to your actual code, if you're interested in what does and doesn't get inherited and how, read about start methods and the related programming recommendations. But briefly: if you're using the fork method (the default on non-Windows systems), your globals are shared directly; if you're using spawn (the default on Windows), they're re-constructed from the source. But if you really need to share variables (which you really don't want to do anyway in most cases), you should almost never rely on the fork behavior, even if you're only going to run on Unix; use explicit shared memory. (Also, if you really need to share anything that can be mutated by more than one process, you really need a Lock or other synchronization object.)


Answer URL
https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods
https://docs.python.org/3/library/multiprocessing.html#the-spawn-and-forkserver-start-methods
https://docs.python.org/3/library/multiprocessing.html#sharing-state-between-processes
