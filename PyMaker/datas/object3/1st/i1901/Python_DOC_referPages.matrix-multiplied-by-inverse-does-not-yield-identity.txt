Natural Text
I am trying to find the inverse matrix of a given matrix using the np.linalg.inv() function. inv yields a matrix which looks alright, but then when trying to multiply the original matrix by inverse the output is not the identity as supposed by the inverse matrix definition.Which is clearly not the identity (gives a slightly different answer when running multiple times)
Try rounding it first before converting to int.Creating a random matrix:Taking inverse:Now, multiplying M and Mi should produce identity.But this is clearly not identity. But if you look closely, the diagonal values are pretty close to 1, and all other values are really small numbers (almost zeros), like -16 or -17 in the exponent.This error is, because float values are never the exact values, they always have some error in them. Have a look at the article 15. Floating Point Arithmetic: Issues and Limitations and Is floating point math broken?.Now, if we just convert it to int, the chances are, that it will still not be an identity. Because a value which is really close to 1, it can actually be a little smaller than 1, resulting in 0 when casted to int.But if you round it first before converting to int, you'll get an identity.
When you print out I, it looks like this:However, the 1.00 entries are not exact. When you print 1 - I, you can see this:The positive diagonal entries represent values in I that are slightly less than one. When you do integer truncation (which is what astype(int) does), you will set those elements to zero. Instead, round the values to the nearest integer instead of truncating:However, you will not always have integer inputs like this, in which case rounding will be misleading. Numpy provides the allclose funcion for comparing values within a tolerance:You can also do an element-wise check using isclose:I set the relative tolerance to zero since it is multiplied by the elements of the second matrix, making it useless in this situation.
The issue is that the astype function does not round, it simply truncates. So, the reason you do not see the identity matrix is that the other values that should be 1 were somewhere around 0.99999. You can use this:If you want to simply round (high tolerance == 0.5) use this instead:Additionally, it is likely best practice to use the full np.linalg.inv function.
The question is, is the matrix close to np.eye(4) or not.This is how you should check:r will indicate if the two matrices (I and the identity) are close up to 1e-8.
What is your goal here?It seems like you just want to know how to get the identity matrix and compare if the results of your matrix multiplication are close to it.If so, this is what you should do:


Answer URL
https://docs.python.org/3/tutorial/floatingpoint.html
