Natural Text
Why does printing an exception instance print the value of exc.args instead of representing exc directly? The docs call it a convenience but it's actually an inconvenience in practice.Can't tell the difference between *args and a tuple:Can't reliably discern type:And the lovely "invisible" exception:Which you'll inherit unless you specifically ask not to:This can be a real problem if you forget to log error instances specifically with repr - a default string representation in a log file has irreversibly lost information.What's the rationale for such strange implementation of Exception.__str__?  Presumably if a user wanted to print exc.args then they should just print exc.args?
BaseException.__str__ could have been fixed in a backwards-incompatible manner with Python 3 to include at least the type of the exception, but perhaps no one noticed that it is a thing that should be fixed. The current implementation dates back to PEP 0352 which provides rationale:No restriction is placed upon what may be passed in for args for backwards-compatibility reasons. In practice, though, only a single string argument should be used. This keeps the string representation of the exception to be a useful message about the exception that is human-readable; this is why the __str__ method special-cases on length-1 args value. Including programmatic information (e.g., an error code number) should be stored as a separate attribute in a subclass.Of course Python itself breaks this principle of useful human-readable messages in many cases - for example stringification of a KeyError is the key that was not found, which leads to debug messages likeThe reason why str(e) is essentially str(e.args) or str(e.args[0]) was originally backwards-compatibility with Python 1.0. In Python 1.0, the syntax for raising an exception, such as ValueError would have been:Python retained backwards-compatibility with 1.0 up to 2.7, so that you can run most Python 1.0 programs unchanged in Python 2.7 (like you never would):Likewise, in Python 1.0 you would catch the ValueError with which worked unchanged in Python 2.7.But the mechanism of how this worked internally had changed: In Python 1.0.1, ValueError was a string with value... 'ValueError'There were no exception classes at all, and you could only raise a single argument, or a tuple, with a string as a discriminator:It would also be possible to give a tuple as an argument:And if you catch this "exception" in Python 1.0, what you get in e is:A tuple!Let's try the code in Python 2.7:The output looks identical, except for the type of the value; which was a tuple before and now an exception... Not only does the Exception delegate __str__ to the args member, but it also supports indexing like a tuple does - and unpacking, iteration and so on:Python 2.7All these hacks for the purpose of keeping backwards-compatibility.The Python 2.7 behaviour comes from the BaseException class that was introduced in PEP 0352; PEP 0352 was originally implemented in Python 2.5.In Python 3, the old syntax was removed - you could not raise exceptions with raise discriminator, (arg, um, ents); and the except could only use the Exception as e syntax. PEP 0352 discussed about dropping support for multiple arguments to BaseException:It was decided that it would be better to deprecate the message attribute in Python 2.6 (and remove it in Python 2.7 and Python 3.0) and consider a more long-term transition strategy in Python 3.0 to remove multiple-argument support in BaseException in preference of accepting only a single argument. Thus the introduction of message and the original deprecation of args has been retracted.Seemingly this deprecation of args was forgotten, as it still does exist in Python 3.7 and is the only way to access the arguments given to many built-in exceptions. Likewise __str__ no longer needs to delegate to the args, and could actually alias the BaseException.__repr__ which gives nicer, unambiguous representation:but no one considered it.P.S. The repr of an exception is useful - next time try printing your exception with !r format:which results inbeing output.


Answer URL
https://docs.python.org/3/tutorial/errors.html#handling-exceptions
