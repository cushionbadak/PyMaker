Natural Text
I'm writing a program in python, and would like to be able to write to specific bytes in a binary file. I tried to do this in the shell with a small binary file containing the numbers 0 through 15, but I can't figure out how to do so. Below is the code I just entered into the shell with comments to demonstrate what I am trying to do:My desired output is as shown, but "wb" seems to erase all the data in the file, while "ab" can't seek backwards.How would I achieve my desired output without rewriting the whole file?
When you open a file for writing with w, the file is truncated, all contents removed. You need to open the file for reading and writing with r+ instead. From the open() function documentation:'w'     open for writing, truncating the file firstandFor binary read-write access, the mode 'w+b' opens and truncates the file to 0 bytes. 'r+b' opens the file without truncation.Because the file was truncated first, seeking to position 3 then writing \x01 has the first few bytes filled in with \x00 for you.Opening a file in append mode usually restricts access to the new portion of the file only, so anything past the first 16 bytes. Again, from the documentation:Other common values are [...] and 'a' for appending (which on some Unix systems, means that all writes append to the end of the file regardless of the current seek position).(bold emphasis in quoted sections mine). This is why your \x01 byte ends up right at the end in spite of the File.seek(3) call.r does not truncate a file and gives you full range of the contents with seek(); r+ adds write access to that mode. Demo with 'r+b':
The solution is another mode: "r+b". (as shown by other answers.)Here is the solution in the shell from where the file left off:
If I remember properly, you have to open the file in "Append mode" or it will simply erase everything and start from scratch, and then when you use seek(3) you just create those 3 0's and then you write the 1. I'll investigate further on how to write directly to a position but you may have to read the whole file, modify, write the whole file again.You can actually read about this behaviour in the documentation: 'w' for only writing (an existing file with the same name will be erased)


Answer URL
https://docs.python.org/3/tutorial/inputoutput.html
