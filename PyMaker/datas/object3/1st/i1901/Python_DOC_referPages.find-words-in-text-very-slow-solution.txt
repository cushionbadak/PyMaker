Natural Text
I have to make a function that given a text of concatenated words without spaces and a list that both contains words that appear and do not appear in said text. I have to create a tuple that contains a new list that only includes the words that are in the text in order of appearance and the word that appears the most in the text. If there are two words that appear the most number of times, the function will chose one on an alphabetical order (if the words appear like "b"=3,"c"=3,"a"=1, then it will chose "b")  Also I have to modify the original list so that it only includes the words that are not in the text without modifying its order. For example if I have a then the tuple will beand list will becomeNow I have done this function but it's incredibly slow, can someone help?
In python strings are immutable - if you modify them you create new objects. Object creation is time/memory inefficient - almost all of the times it is better to use lists instead.By creating a list of all possible k-lenght parts of text - k being the (unique) lenghts of the words you look for ( 3 and 4 in your list) you create all splits that you could count and filter out that are not in your word-set:Using a set for "is A in B" checks makes the coder faster as well - sets have O(1) lookup - list take the longer the more lements are in it (worst case: n). So you eliminate all words from the k-lenght parts list that do not match any of the words you look for (i.e. 'eter'):For counting iterables I use collections.Counter - a specialiced dictionary .. that counts things. It's most_common() method returns sorted tuples (key,count) sorted by most occured first which I format to a return-value that matches your OP.One version to solve it respection overlapping results:Output:


Answer URL
https://docs.python.org/3/library/collections.html#collections.Counter
