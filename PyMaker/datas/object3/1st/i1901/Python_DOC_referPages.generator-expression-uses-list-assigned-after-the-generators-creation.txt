Natural Text
I found this example and I can't understand why it works unpredictably?I supposed it must output [1, 8, 15] or [2, 8, 22].
The reason is that, at creation time, the generator (a for b in c if d) only evaluates c (which sometimes makes b predictable as well). But a, b, d are evaluated at consumption time (at each iteration). Here, it uses the current binding of array from the enclosing scope when evaluating d (array.count(x) > 0).You can for instance do:Without having declared a in advance. But, you have to make sure a exists when the generator is consumed.But you cannot do similarly:Upon request:You can observe similar (however not identical) patterns with a common generator function:The generator function does not execute any of its body ahead of consumption. Hence, even the array in the for-loop header is bound late. An even more disturbing example occurs where we "switch out" array during iteration:
From the docs on Generator expressions:Variables used in the generator expression are evaluated lazily when  the __next__() method is called for the generator object (in the same  fashion as normal generators). However, the iterable expression in the  leftmost for clause is immediately evaluated, so that an error  produced by it will be emitted at the point where the generator  expression is defined, rather than at the point where the first value  is retrieved.So when you runonly the first array in the generator expression is evaluated. x and array.count(x) will only be evaluated when you call next(g). Since you make array point to another list [2, 8, 22] before consuming the generator you get the 'unexpected' result.
when you first create the array and assign the elements in it, elements of the array points to some memory location and generator keeps that location (not the array's) for its execution.but when you modify its elements of the array it gets changed but as '8' is common for both of them python does not reassign it and points to the same element after modification.Look the below example for better understandingOutput
Actually, it is not really crazy if you look more carefully.look at it will create a generator that looks through the array and will search if the count of already existing values is more than zero. so your generator only looks for 1, 8 and 15, and when you change the values to another, the generator just looks for the previous values again not new ones. because it(generator) creates when array had them.so if you put thousands of values in the array it only looks for those three only.
The confusion, and so is the answer, lies in the line:g = (x for x in array if array.count(x) > 0)If we simplify this line then it will become: g = (x for x in array1 if array2.count(x) > 0)Now, when generator is created then it keeps the reference of array1 object. So even if I will change the value of array1 to any other value (i.e. set it to a new array object), it will not affect the generator's copy of array1. Because only array1 is changing it's object reference. But array2 is checked dynamically. So if we change its value it will be reflected.You can see outputy from following code to understand it batter. See it working online here: Output: 


Answer URL
https://docs.python.org/3/reference/expressions.html#generator-expressions
https://docs.python.org/3/reference/expressions.html#generator.__next__
https://docs.python.org/3/reference/compound_stmts.html#for
