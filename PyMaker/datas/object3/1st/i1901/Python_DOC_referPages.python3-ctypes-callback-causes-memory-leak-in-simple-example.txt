Natural Text
While working on a complex program combining Python 3 code and C++ code using ctypes,  I found a memory leak that can easily be reproduced with the stripped down example below.My C++ code creates a Python object using a callback function. Next, it calls another callback on the Python object, that simply returns its argument.  The second callback causes the object's reference count to increase.  As a result,  the object never gets garbage-collected.This is the Python code (file bug.py):This is the C++ code (file bug.cpp):And here are the commands I use to compile and run:The output is:In other words,  the call to the noop function incorrectly increases the reference count, and the Foo object is not garbage collected.  Without the call to the noop function, the Foo object is garbage collected.  The expected output is:Is this a known issue?  Does anyone know a work-around or solution? Is this caused by a bug in ctypes?
You're passing around Python objects.  One of your objects is passed into your C code, and not passed out, so you are responsible for that reference count.  Here's something that works, but I've changed void* to PyObject* since that is what they are:Here's the Python script I used.  You can use the prototypes as decorators for the callback functions.  This really matters if the callback needs to live longer than the function it was passed into.  When you call the function as you did directly with the callback wrapper, the callback wrapper is destroyed after the function returns because there is no more reference.I also change to ctypes.PyDLL.  This doesn't release the GIL when calling into the C code.  Since you're passing around Python objects that seems a good idea.Output:


Answer URL
https://docs.python.org/3/c-api/intro.html#objects-types-and-reference-counts
