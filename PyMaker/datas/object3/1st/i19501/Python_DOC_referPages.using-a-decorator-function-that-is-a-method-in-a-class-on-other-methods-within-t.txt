Natural Text
I have been trying to learn more about decorators using a tweaked version as below from: hereWith results with run of:Notice the filled dictionaryI like to keep my code contained, so was trying to move the case function into the switch class like so:But I end up getting an empty self.__case_map dictionary resulting in this error:Notice the blank dictionary at the beginning. It fails atbefore that return function is invoked with the second () which is a function of the dictionary being blank tripping the exception but there is no _default key to the function value to return.On the first set of code above, running this in a console gives:But on the second set of code above, running Despite the fact that @switch.case is being run as tests on that showed. There is some untoward side effect from invoking it within a class. What is the side effect?How can I move the case function into the switch class and use it as a method successfully to decorate the functions in class b?
First, if you're trying to call self.case, there has to be a self parameter to the case method. It doesn't matter whether you're using case as a decorator or a normal function; it's still called the same way.But more importantly, at the time you're defining the b class, there is no self. If you think about it, there's no way there could be one, because self refers to each instance of b, and there aren't any instances yet—there isn't even a class yet. Looked at from another angle, the only way you ever get a self is by taking one as a parameter; there's no self in scope at the point where you're defining b. (Many people new to Python think there's a whole lot of magic to self, but there isn't anything beyond the fact that foo.bar(baz) is looked up in foo and then called as bar(foo, baz).)If you just want to move a function into a class for encapsulation purposes, but not make it an instance method, the way to do that is with staticmethod:It's actually not that common that you want staticmethod; usually you want classmethod, because you want access to the class object (so you can call other classmethods, access class attributes, and/or create instances of the class). But in this case, you don't even have a b class yet, and you wouldn't have anything useful to do with it even if you did, so staticmethod is exactly what you want. (PS, it's a good thing you don't want access to b here, because otherwise, you'd need to learn about metaclasses… and I'd wait until you get the hang of decorators first.)Finally, while we're tossing decorators into your decorator definition (which is a very common thing to do), you almost always want to use functools.wraps in any decorator:Anyway, with all that out of the way, how do you call case if you don't have a self? Well, a staticmethod can be called on the class it's in, any subclass, or any instance of either, but normally it's called on the class:
I found the answer the the problem. It has to do with the renaming of attributes in class-private variables. This can be seen for python 3 here under Private Variables  and for python 2 here section 9.6 Private Variables and Class-local References.In the code with the function as a method (the second listing above), the f.__case was renamed to f._switch__case. If every instance of __case is replaced with _switch__case except for the @staticmethod function, the code works as it should. I'm not 100% sure why Python is designed this way, but I'm guessing it has something to do with preserving namespace, but I'm not sure why it is necessary as class has its own namespace.Below is the corrected code:


Answer URL
