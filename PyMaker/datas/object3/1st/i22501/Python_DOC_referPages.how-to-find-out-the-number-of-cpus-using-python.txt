Natural Text
I want to know the number of CPUs on the local machine using Python. The result should be user/real as output by time(1) when called with an optimally scaling userspace-only program.
If you have python with a version >= 2.6 you can simply usehttp://docs.python.org/library/multiprocessing.html#multiprocessing.cpu_count
If you're interested into the number of processors available to your current process, you have to check cpuset first. Otherwise (or if cpuset is not in use), multiprocessing.cpu_count() is the way to go in Python 2.6 and newer. The following method falls back to a couple of alternative methods in older versions of Python:
Another option is to use the psutil library, which always turn out useful in these situations:This should work on any platform supported by psutil(Unix and Windows).Note that in some occasions multiprocessing.cpu_count may raise a NotImplementedError while psutil will be able to obtain the number of CPUs. This is simply because psutil first tries to use the same techniques used by multiprocessing and, if those fail, it also uses other techniques.
In Python 3.4+: os.cpu_count().multiprocessing.cpu_count() is implemented in terms of this function but raises NotImplementedError if os.cpu_count() returns None ("can't determine number of CPUs").
platform independent:psutil.cpu_count(logical=False)https://github.com/giampaolo/psutil/blob/master/INSTALL.rst

multiprocessing.cpu_count() will return the number of logical CPUs, so if you have a quad-core CPU with hyperthreading, it will return 8.  If you want the number of physical CPUs, use the python bindings to hwloc:hwloc is designed to be portable across OSes and architectures.
Can't figure out how to add to the code or reply to the message but here's support for jython that you can tack in before you give up:
You can also use "joblib" for this purpose. This method will give you the number of cpus in the system. joblib needs to be installed though. More information on joblib can be found here       https://pythonhosted.org/joblib/parallel.htmlAlternatively you can use numexpr package of python. It has lot of simple functions helpful for getting information about the system cpu.
len(os.sched_getaffinity(0)) is what you usually wantos.sched_getaffinity(0) (added in Python 3) returns the set of CPUs available considering the sched_setaffinity Linux system call, which limits which CPUs a process and its children can run on.multiprocessing.cpu_count() on the other hand just returns the total number of physical CPUs.We can see the difference by restricting the affinity with the taskset utility.For example, if I restrict Python to just 1 core (core 0) in my 16 core system:with the test script:main.pythen the output is:This is especially important because certain cluster management systems such as Platform LSF limit job CPU usage with sched_getaffinity.Therefore, if you use multiprocessing.cpu_count(), your script might try to use way more cores than it has available, which may lead to individual tasks timing out.nproc respects affinity by default:outputs:and man nproc makes that quite explicit:print the number of processing units availablenproc has the --all flag for the less common case that you want to get the physical CPU count:Tested in Ubuntu 16.04, Python 3.5.2.
This is the function cpu_count from multiprocessing:}
Another option if you don't have Python 2.6:
Since I cannot comment yet:These give you the "physical" CPU countmultiprocessing.cpu_count()os.cpu_count()These give you the virtual machine CPU countpsutil.cpu_count()numexpr.detect_number_of_cores()Only matters if you works on VMs.


Answer URL
https://docs.python.org/3/library/os.html#os.cpu_count
