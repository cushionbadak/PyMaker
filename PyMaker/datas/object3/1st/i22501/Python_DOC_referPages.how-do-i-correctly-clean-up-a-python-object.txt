Natural Text
__del__(self) above fails with an AttributeError exception.  I understand Python doesn't guarantee the existence of "global variables" (member data in this context?) when __del__() is invoked.  If that is the case and this is the reason for the exception, how do I make sure the object destructs properly?
I'd recommend using Python's with statement for managing resources that need to be cleaned up.  The problem with using an explicit close() statement is that you have to worry about people forgetting to call it at all or forgetting to place it in a finally block to prevent a resource leak when an exception occurs.To use the with statement, create a class with the following methods:In your example above, you'd use Then, when someone wanted to use your class, they'd do the following:The variable package_obj will be an instance of type Package (it's the value returned by the __enter__ method).  Its __exit__ method will automatically be called, regardless of whether or not an exception occurs.You could even take this approach a step further.  In the example above, someone could still instantiate Package using its constructor without using the with clause.  You don't want that to happen.  You can fix this by creating a PackageResource class that defines the __enter__ and __exit__ methods.  Then, the Package class would be defined strictly inside the __enter__ method and returned.  That way, the caller never could instantiate the Package class without using a with statement:You'd use this as follows:
The standard way is to use atexit.register:But you should keep in mind that this will persist all created instances of Package until Python is terminated.Demo using the code above saved as package.py:
As an appendix to Clint's answer, you can simplify PackageResource using contextlib.contextmanager:Alternatively, though probably not as Pythonic, you can override Package.__new__:and simply use with Package(...) as package.To get things shorter, name your cleanup function close and use contextlib.closing, in which case you can either use the unmodified Package class via with contextlib.closing(Package(...)) or override its __new__ to the simplerAnd this constructor is inherited, so you can simply inherit, e.g.
I don't think that it's possible for instance members to be removed before __del__ is called. My guess would be that the reason for your particular AttributeError is somewhere else (maybe you mistakenly remove self.file elsewhere).However, as the others pointed out, you should avoid using __del__. The main reason for this is that instances with __del__ will not be garbage collected (they will only be freed when their refcount reaches 0). Therefore, if your instances are involved in circular references, they will live in memory for as long as the application run. (I may be mistaken about all this though, I'd have to read the gc docs again, but I'm rather sure it works like this).
I think the problem could be in __init__ if there is more code than shown?__del__ will be called even when __init__ has not been executed properly or threw an exception.Source
A better alternative is to use weakref.finalize. See the examples at Finalizer Objects and Comparing finalizers with __del__() methods.
Just wrap your destructor with a try/except statement and it will not throw an exception if your globals are already disposed of.EditTry this:It will stuff the file list in the del function that is guaranteed to exist at the time of call. The weakref proxy is to prevent Python, or yourself from deleting the self.files variable somehow (if it is deleted, then it will not affect the original file list). If it is not the case that this is being deleted even though there are more references to the variable, then you can remove the proxy encapsulation.
It seems that the idiomatic way to do this is to provide a close() method (or similar), and call it explicitely.
Here is a minimal working skeleton:Important: return selfIf you're like me, and overlook the return self part (of Clint Miller's correct answer), you will be staring at this nonsense:I spent half a day on this. Hope it helps the next person.


Answer URL
https://docs.python.org/3/library/atexit.html#atexit.register
https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager
https://docs.python.org/3/library/contextlib.html#contextlib.closing
