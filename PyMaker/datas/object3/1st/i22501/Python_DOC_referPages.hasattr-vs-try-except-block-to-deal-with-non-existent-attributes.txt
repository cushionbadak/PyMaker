Natural Text
vsWhich should be preferred and why?
hasattr internally and rapidly performs the same task as the try/except block: it's a very specific, optimized, one-task tool and thus should be preferred, when applicable, to the very general-purpose alternative.
Any benches that illustrate difference in performance?timeit it's your friend
I almost always use hasattr: it's the correct choice for most cases.The problematic case is when a class overrides __getattr__: hasattr will catch all exceptions instead of catching just AttributeError like you expect. In other words, the code below will print b: False even though it would be more appropriate to see a ValueError exception:The important error has thus disappeared. This has been fixed in Python 3.2 (issue9666) where hasattr now only catches AttributeError.An easy workaround is to write a utility function like this:This let's getattr deal with the situation and it can then raise the appropriate exception.
There is a third, and often better, alternative:Advantages:getattr does not have the bad exception-swallowing behavior pointed out by Martin Geiser - in old Pythons, hasattr will even swallow a KeyboardInterrupt.The normal reason you're checking if the object has an attribute is so that you can use the attribute, and this naturally leads in to it.The attribute is read off atomically, and is safe from other threads changing the object.  (Though, if this is a major concern you might want to consider locking the object before accessing it.)It's shorter than try/finally and often shorter than hasattr.A broad except AttributeError block can catch other AttributeErrors than the one you're expecting, which can lead to confusing behaviour.Accessing an attribute is slower than accessing a local variable (especially if it's not a plain instance attribute).  (Though, to be honest, micro-optimization in Python is often a fool's errand.)One thing to be careful of is if you care about the case where obj.attribute is set to None, you'll need to use a different sentinel value.
I would say it depends on whether your function may accept objects without the attribute by design, e.g. if you have two callers to the function, one providing an object with the attribute and the other providing an object without it. If the only case where you'll get an object without the attribute is due to some error, I would recommend using the exceptions mechanism even though it may be slower, because I believe it is a cleaner design. Bottom line: I think it's a design and readability issue rather than an efficiency issue. 
If it's just one attribute you're testing, I'd say use hasattr.  However, if you're doing several accesses to attributes which may or may not exist then using a try block may save you some typing.
If not having the attribute is not an error condition, the exception handling variant has a problem: it would catch also AttributeErrors that might come internally when accessing obj.attribute (for instance because attribute is a property so that accessing it calls some code).
I'd suggest option 2. Option 1 has a race condition if some other thread is adding or removing the attribute.Also python has an Idiom, that EAFP ('easier to ask forgiveness than permission') is better than LBYL ('look before you leap').
From a practical point of view, in most languages using a conditional will always be consderably faster than handling an exception.If you're wanting to handle the case of an attribute not existing somewhere outside of the current function, the exception is the better way to go. An indicator that you may want to be using an exception instead of a conditional is that the conditional merely sets a flag and aborts the current operation, and something elsewhere checks this flag and takes action based on that.That said, as Rax Olgud points out, communication with others is one important attribute of code, and what you want to say by saying "this is an exceptional situation" rather than "this is is something I expect to happen" may be more important.
This subject was covered in the EuroPython 2016 talk Writing faster Python by Sebastian Witowski. Here's a reproduction of his slide with the performance summary. He also uses the terminology look before you leap in this discussion, worth mentioning here to tag that keyword.If the attribute is actually missing then begging for forgiveness will  be slower than asking for permissions. So as a rule of thumb you can  use the ask for permission way if know that it is very likely that the  attribute will be missing or other problems that you can predict.  Otherwise if you expect code will result in most of the times readable  code3 PERMISSIONS OR FORGIVENESS?
The first.Shorter is better. Exceptions should be exceptional.
At least when it is up to just what's going on in the program, leaving out the human part of readability, etc. (which is actually most of the time more imortant than performance (at least in this case - with that performance span), as Roee Adler and others pointed out).Nevertheless looking at it from that perspective,it then becomes a matter of choosing betweenandsince hasattr just uses the first case to determine the result.Food for thought ;-)


Answer URL
