Natural Text
I have a class MyClass, which contains two member variables foo and bar:I have two instances of this class, each of which has identical values for foo and bar:However, when I compare them for equality, Python returns False:How can I make python consider these two objects equal?
You should implement the method __eq__:Now it outputs:Note that implementing __eq__ will automatically make instances of your class unhashable, which means they can't be stored in sets and dicts. If you're not modelling an immutable type (i.e. if the attributes foo and bar may change value within the lifetime of your object), then it's recommend to just leave your instances as unhashable.If you are modelling an immutable type, you should also implement the datamodel hook __hash__:A general solution, like the idea of looping through __dict__ and comparing values, is not advisable - it can never be truly general because the __dict__ may have uncomparable or unhashable types contained within.N.B.: be aware that before Python 3, you may need to use __cmp__ instead of __eq__.  Python 2 users may also want to implement __ne__, since a sensible default behaviour for inequality (i.e. inverting the equality result) will not be automatically created in Python 2.
You override the rich comparison operators in your object.Like this:
Implement the __eq__ method in your class; something like this:Edit: if you want your objects to compare equal if and only if they have equal instance dictionaries:
As a summary : It's advised to implement __eq__ rather than __cmp__, except if you run python <= 2.0 (__eq__ has been added in 2.1)Don't forget to also implement __ne__ (should be something like return not self.__eq__(other) or return not self == other except very special case)Don`t forget that the operator must be implemented in each custom class you want to compare (see example below).If you want to compare with object that can be None, you must implement it. The interpreter cannot guess it ... (see example below)
When comparing instances of objects, the __cmp__ function is called.If the == operator is not working for you by default, you can always redefine the __cmp__ function for the object.Edit:As has been pointed out, the __cmp__ function is deprecated since 3.0.Instead you should use the “rich comparison” methods.
If you want to get an attribute-by-attribute comparison, and see if and where it fails, you can use the following list comprehension:The extra advantage here is that you can squeeze it one line and enter in the "Evaluate Expression" window when debugging in PyCharm.
I tried the initial example (see 7 above) and it did not work in ipython. Note that cmp(obj1,obj2) returns a "1" when implemented using two identical object instances. Oddly enough when I modify one of the attribute values and recompare, using  cmp(obj1,obj2) the object continues to return a "1".  (sigh...)Ok, so what you need to do is iterate two objects and compare each attribute using the == sign.
Instance of a class when compared with == comes to non-equal. The best way is to ass the cmp function to your class which will do the stuff. If you want to do comparison by the content you can simply use cmp(obj1,obj2)In your case cmp(doc1,doc2) It will return -1 if the content wise they are same.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__eq__
https://docs.python.org/3/reference/datamodel.html#object.__hash__
https://docs.python.org/3/library/functools.html#functools.total_ordering
