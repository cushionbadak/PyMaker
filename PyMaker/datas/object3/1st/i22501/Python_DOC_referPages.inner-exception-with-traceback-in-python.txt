Natural Text
My background is in C# and I've just recently started programming in Python. When an exception is thrown I typically want to wrap it in another exception that adds more information, while still showing the full stack trace. It's quite easy in C#, but how do I do it in Python?Eg. in C# I would do something like this:In Python I can do something similar:...but this loses the traceback of the inner exception!Edit: I'd like to see both exception messages and both stack traces and correlate the two. That is, I want to see in the output that exception X occurred here and then exception Y there - same as I would in C#. Is this possible in Python 2.6? Looks like the best I can do so far (based on Glenn Maynard's answer) is:This includes both the messages and both the tracebacks, but it doesn't show which exception occurred where in the traceback.
Python 2It's simple; pass the traceback as the third argument to raise.Always do this when catching one exception and re-raising another.
Python 3In python 3 you can do the following:This will produce something like this:
Python 3 has the raise ... from clause to chain exceptions. Glenn's answer is great for Python 2.7, but it only uses the original exception's traceback and throws away the error message and other details. Here are some examples in Python 2.7 that add context information from the current scope into the original exception's error message, but keep other details intact.Known Exception TypeThat flavour of raise statement takes the exception type as the first expression, the exception class constructor arguments in a tuple as the second expression, and the traceback as the third expression. If you're running earlier than Python 2.2, see the warnings on sys.exc_info().Any Exception TypeHere's another example that's more general purpose if you don't know what kind of exceptions your code might have to catch. The downside is that it loses the exception type and just raises a RuntimeError. You have to import the traceback module.Modify the MessageHere's another option if the exception type will let you add context to it. You can modify the exception's message and then reraise it.That generates the following stack trace:You can see that it shows the line where check_output() was called, but the exception message now includes the command line.
In Python 3.x:or simply which will propagate MyException but print both exceptions if it will not be handled.In Python 2.x:You can prevent printing both exceptions by killing the __context__ attribute. Here I write a context manager using that to catch and change your exception on the fly:(see http://docs.python.org/3.1/library/stdtypes.html for expanation of how they work)    
I don't think you can do this in Python 2.x, but something similar to this functionality is part of Python 3. From PEP 3134:In today's Python implementation, exceptions are composed of three      parts: the type, the value, and the traceback.  The 'sys' module,      exposes the current exception in three parallel variables, exc_type,      exc_value, and exc_traceback, the sys.exc_info() function returns a      tuple of these three parts, and the 'raise' statement has a      three-argument form accepting these three parts.  Manipulating      exceptions often requires passing these three things in parallel,      which can be tedious and error-prone.  Additionally, the 'except'      statement can only provide access to the value, not the traceback.      Adding the 'traceback' attribute to exception values makes all      the exception information accessible from a single place.Comparison to C#:Exceptions in C# contain a read-only 'InnerException' property that      may point to another exception.  Its documentation [10] says that      "When an exception X is thrown as a direct result of a previous      exception Y, the InnerException property of X should contain a      reference to Y."  This property is not set by the VM automatically;      rather, all exception constructors take an optional 'innerException'      argument to set it explicitly.  The 'cause' attribute fulfills      the same purpose as InnerException, but this PEP proposes a new form      of 'raise' rather than extending the constructors of all exceptions.      C# also provides a GetBaseException method that jumps directly to      the end of the InnerException chain; this PEP proposes no analog.Note also that Java, Ruby and Perl 5 don't support this type of thing either. Quoting again:As for other languages, Java and Ruby both discard the original      exception when another exception occurs in a 'catch'/'rescue' or      'finally'/'ensure' clause.  Perl 5 lacks built-in structured      exception handling.  For Perl 6, RFC number 88 [9] proposes an exception      mechanism that implicitly retains chained exceptions in an array      named @@.
You could use my CausedException class to chain exceptions in Python 2.x (and even in Python 3 it can be useful in case you want to give more than one caught exception as cause to a newly raised exception).  Maybe it can help you.
Maybe you could grab the relevant information and pass it up?  I'm thinking something like:
Assuming:you need a solution, which works for Python 2 (for pure Python 3 see raise ... from solution)just want to enrich the error message, e.g. providing some additional contextneed the full stack traceyou can use a simple solution from the the docs https://docs.python.org/3/tutorial/errors.html#raising-exceptions:The output:It looks like the key piece is the simplified 'raise' keyword that stands alone. That will re-raise the Exception in the except block.
For maximum compatibility between Python 2 and 3, you can use raise_from in the six library.  https://six.readthedocs.io/#six.raise_from .  Here is your example (slightly modified for clarity):


Answer URL
https://docs.python.org/3/reference/simple_stmts.html#raise
https://docs.python.org/3/tutorial/errors.html#raising-exceptions
