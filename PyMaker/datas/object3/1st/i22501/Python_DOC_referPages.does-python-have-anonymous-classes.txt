Natural Text
I'm wondering if Python has anything like the C# anonymous classes feature. To clarify, here's a sample C# snippet:In Python, I would imagine something like this:The specific requirement is being able to create an object with specified fields in expression context (e.g. usable in lambdas and other places where statements aren't allowed), with no additional external declarations, and ability to access individual components by name via the normal member access syntax foo.bar. The created object should also implement structural comparison by component names  (not by position, as tuples do).In particular: tuples isn't it because their components are not named; classes isn't it because they require a declaration; dicts isn't it because they have undesired foo["bar"] syntax to access components.namedtuple isn't it, because it still requires a name even if you define the type inline, and the comparison is position-based, not name-based. In particular:I know how to write such a thing in Python if needed. But I would like to know if there's anything like that in the Python standard library, or any popular third-party libraries.[EDIT]Just for the sake of it, here's a single-expression solution that combines two very informative answers by Ken and alanlcode, yielding structural equality without any extra outside declarations:Technically, it satisfies all the requirements of the question, but I sincerely hope that no-one ever uses it (I definitely won't).
The pythonic way would be to use a dict:Meets all your requirements except that you still have to do foo['x'] instead of foo.x. If that's a problem, you could easily define a class such as:Or, a nice and short one(but note that this second one has problems as Alex points out in his comment!)
1) See http://uszla.me.uk/space/blog/2008/11/06.  You can create an anonymous object with slightly ugly syntax by using the type built-in function:where the 3rd parameter is the dict that will contain the fields of your object.2) Another variation is proposed by Peter Norvig at http://norvig.com/python-iaq.html.  It is also similar to the answer posted by Ken.The benefit of this method is that you can implement equality by contents of the dict, which the first option doesn't have.
Looks like Python 3.3 has added exactly this thing in the form of types.SimpleNamespace class.
The type(...) form will fail the structural comparison requirement (without getting really ugly).  The dict(...) form doesn't meet the attribute accessor requirement.The attrdict seems to fall in the middle somewhere:But it means defining a special class.OK, I just noticed the update to the question.  I'll just note that you can specify dict for the bases parameter and only need to specify the constructor then (in the icky type expression).  I prefer attrdict. :-)
I don't remember offhand if there's a built-in but writing it yourself is shorter than typing your question.  :-)
If you want the instance to be anonymous as well (using the object directly in an expression), then you're bound to use the type-expression. However in many cases the instance will not be anonymous, but assigned to a variable. This case can be handled in a reasonable way in python by using metaclasses or decorators. An example using decorator:The decorator in this case causes the class foo to be instantiated an put into the variable foo instead of the class itself. The class itself will not be accessible from any namespace although it has a name:Another feature in python that accomodates for many use cases is that it's legal to define classes locally, which means that they would become a symbol local to that function, which in turns gives it some degree of anonymity.
Quoted from this page:
As show above, I get a good intellisense from pycharm for this and I love this solution...


Answer URL
