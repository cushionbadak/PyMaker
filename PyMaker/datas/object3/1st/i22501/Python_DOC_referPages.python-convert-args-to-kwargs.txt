Natural Text
I am writing a decorator that needs to call other functions prior to call of the function that it is decorating.  The decorated function may have positional arguments, but the functions the decorator will call can only accept keyword arguments.  Does anyone have a handy way of converting positional arguments into keyword arguments?I know that I can get a list of the variable names of the decorated function:But I can't figure out how to tell what was passed in positionally and what was as keyword.My decorator looks like this:Is there a way other than just comparing kwargs and co_varnames, adding to kwargs anything not in there, and hoping for the best?
Note - co_varnames will include local variables as well as keywords.  This probably won't matter, as zip truncates the shorter sequence, but may result in confusing error messages if you pass the wrong number of args.You can avoid this with func_code.co_varnames[:func_code.co_argcount], but better is to use the inspect module.  ie:You may also want to handle the case where the function defines **kwargs or *args (even if just to raise an exception when used with the decorator).  If these are set, the second and third result from getargspec will return their variable name, otherwise they will be None.
Any arg that was passed positionally will be passed to *args. And any arg passed as a keyword will be passed to **kwargs.If you have positional args values and names then you can do:to convert them all into keyword args.
If you're using Python >= 2.7 inspect.getcallargs() does this for you out of the box. You'd just pass it the decorated function as the first argument, and then the rest of the arguments exactly as you plan to call it. Example:I'm planning to do f('p1', 'p2', 'p3', k2='k2', extra='kx1') (note that k1 is being passed positionally as p3), so...If you know the decorated function won't use **kwargs, then that key won't appear in the dict, and you're done (and I'm assuming there's no *args, since that would break the requirement that everything have a name). If you do have **kwargs, as I have in this example, and want to include them with the rest of the named arguments, it takes one more line:Update: for Python >= 3.3, see inspect.Signature.bind() and the related inspect.signature function for functionality similar to (but more robust than) inspect.getcallargs().
Well, this may be overkill.  I wrote it for the dectools package (on PyPi), so you can get updates there.  It returns the dictionary taking into account positional, keyword, and default arguments.  There is a test suite in the package (test_dict_as_called.py):
Here's a newer method to solve this using inspect.signature (for Python 3.3+). I'll give an example that can be run / tested yourself first and then show how to modify the original code with it.Here's a test function which just sums up any args/kwargs given to it; at least one argument is required (a) and there's one keyword-only argument with a default value (b), just to test different aspects of function signatures.Now let's make a wrapper for silly_sum which can be called in the same way as silly_sum (with an exception which we'll get to) but that only passes in kwargs to the wrapped silly_sum.sig.bind returns a BoundArguments object, but this doesn't take defaults into account unless you call apply_defaults explicitly. Doing so will also generate an empty tuple for args and an empty dict for kwargs if no *args/**kwargs were given.Then we just get the dictionary of arguments and add any **kwargs in. The exception to using this wrapper is that *args can't be passed to the function. This is because there are no names for these, so we can't convert them into kwargs. If passing them through as a kwarg named args is acceptable, that could be done instead.Here is how this can be applied to the original code:


Answer URL
https://docs.python.org/3/library/inspect.html#inspect.Signature.bind
https://docs.python.org/3/library/inspect.html#inspect.signature
