Natural Text
Let's say I have the following:I want to test the spam function without going through the hassle of setting up a connection (or whatever the decorator is doing).Given spam, how do I strip the decorator from it and get the underlying "undecorated" function?
In the general case, you can't, becauseis equivalent towhich means that the "original" spam might not even exist anymore. A (not too pretty) hack would be this:
balpha's solution can be made more generalizable with this meta-decorator:Then you can decorate your decorators with @include_original, and every one will have a testable (undecorated) version tucked away inside it.
There's been a bit of an update for this question. If you're using Python 3, you can use __wrapped__ property for decorators from stdlib.Here's an example from Python Cookbook, 3rd edition, section 9.3 Unwrapping decoratorsIf you are trying to unwrap a function from custom decorator, the decorator function needs to use wraps function from functools See discussion in Python Cookbook, 3rd edition, section 9.2 Preserving function metadata when writing decorators
Behold, FuglyHackThatWillWorkForYourExampleButICantPromiseAnythingElse:Edit: For functions/methods decorated more than once and with more complicated decorators you can try using the following code. It relies on the fact, that decorated functions are __name__d differently than the original function.It's not fool proof though. It will fail if the name of the function returned from a decorator is the same as the decorated one. The order of hasattr() checks is also a heuristic,  there are decoration chains that return wrong results in any case.
You can now use the undecorated package:It goes through the hassle of digging through all the layers of different decorators until it reaches the bottom function and doesn't require changing the original decorators. It works on both Python 2 and Python 3.
Instead of doing...You could just do......which is all the @decorator syntax does - you can then obviously access the original spam_f normally.
The usual approach to testing such functions is to make any dependencies, such as get_connection, configurable. Then you can override it with a mock while testing. Basically the same as dependency injection in the Java world but a lot simpler thanks to Pythons dynamic nature.Code for it might look something like this:Depending on your code you could find a better object than the decorator to stick the factory function on. The issue with having it on the decorator is that you'd have to remember to restore it to the old value in the teardown method.
It's good practice to decorate decorators with functools.wraps like so:As of Python 3.2, this will automatically add a __wrapped__ attribute that lets you retrieve the original, undecorated function:However, instead of manually accessing the __wrapped__ attribute, it's better to use inspect.unwrap:
the original function is stored in spam.__closure__[0].cell_contents.Decorator uses closure to bind original function with extra layer of functionality. The original function must be stored in a closure cell kept by one of the functions in the nested structure of decorator.Example:this is the core principle of undecorated, you could refer to the source code for more details.
Add a do-nothing decorator:After defining or importing with_connection but before you get to the methods that use it as a decorator, add:Then if you set the global TESTING to True, you will have replaced with_connection with a do-nothing decorator.


Answer URL
https://docs.python.org/3/library/functools.html#functools.wraps
https://docs.python.org/3/library/inspect.html#inspect.unwrap
https://docs.python.org/3/library/functools.html#functools.wraps
