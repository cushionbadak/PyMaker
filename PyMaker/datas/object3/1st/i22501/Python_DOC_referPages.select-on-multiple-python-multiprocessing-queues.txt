Natural Text
What's the best way to wait (without spinning) until something is available in either one of two (multiprocessing) Queues, where both reside on the same system?
It doesn't look like there's an official way to handle this yet.  Or at least, not based on this:http://bugs.python.org/issue3831You could try something like what this post is doing -- accessing the underlying pipe filehandles:http://haltcondition.net/?p=2319and then use select.
Actually you can use multiprocessing.Queue objects in select.select. i.e. would select que only if it is ready to be read from. No documentation about it though. I was reading the source code of the multiprocessing.queue library (at linux it's usually sth like /usr/lib/python2.6/multiprocessing/queue.py) to find it out.With Queue.Queue I didn't have found any smart way to do this (and I would really love to).
Seems like using threads which forward incoming items to a single Queue which you then wait on is a practical choice when using multiprocessing in a platform independent manner.Avoiding the threads requires either handling low-level pipes/FDs which is both platform specific and not easy to handle consistently with the higher-level API.  Or you would need Queues with the ability to set callbacks which i think are the proper higher level interface to go for.  I.e. you would write something like:Maybe the multiprocessing package could grow this API but it's not there yet. The concept works well with py.execnet which uses the term "channel" instead of "queues", see here http://tinyurl.com/nmtr4w 
You could use something like the Observer pattern, wherein Queue subscribers are notified of state changes.In this case, you could have your worker thread designated as a listener on each queue, and whenever it receives a ready signal, it can work on the new item, otherwise sleep.
Not sure how well the select on a multiprocessing queue works on windows.  As select on windows listens for sockets and not file handles, I suspect there could be problems.My answer is to make a thread to listen to each queue in a blocking fashion, and to put the results all into a single queue listened to by the main thread, essentially multiplexing the individual queues into a single one.My code for doing this is:The following test routine shows how to use it:Hope this helps.Tony Wallace
New version of above code...Not sure how well the select on a multiprocessing queue works on windows. As select on windows listens for sockets and not file handles, I suspect there could be problems.My answer is to make a thread to listen to each queue in a blocking fashion, and to put the results all into a single queue listened to by the main thread, essentially multiplexing the individual queues into a single one.My code for doing this is:The follow code is my test routine to show how it works:
As of Python 3.3 you can use multiprocessing.connection.wait to wait on multiple Queue._reader objects at once.
Don't do it.Put a header on the messages and send them to a common queue. This simplifies the code and will be cleaner overall. 


Answer URL
https://docs.python.org/3/library/multiprocessing.html#multiprocessing.connection.wait
