Natural Text
Could someone provide me with a good way of importing a whole directory of modules?I have a structure like this:I tried just converting it to a package by adding __init__.py and doing from Foo import * but it didn't work the way I had hoped.
List all python (.py) files in the current folder and put them as __all__ variable in __init__.py
Add the __all__ Variable to __init__.py containing:See also http://docs.python.org/tutorial/modules.html
Update: Today you probably want to use importlib instead.Make the Foo directory a package by adding an __init__.py. In that __init__.py add:Since you want it dynamic (which may or may not be a good idea), list all py-files with list dir and import them with something like this:Then, from your code do this:You can now access the modules withetc. from Foo import * is not a good idea for several reasons, including name clashes and making it hard to analyze the code.
Expanding on Mihail's answer, I believe the non-hackish way (as in, not handling the file paths directly) is the following:create an empty __init__.py file under Foo/ExecuteYou'll get:
Python, include all files under a directory:For newbies who just can't get it to work who need their hands held.Make a folder /home/el/foo and make a file main.py under /home/el/foo  Put this code in there:Make a directory /home/el/foo/hellokittyMake a file __init__.py under /home/el/foo/hellokitty and put this code in there:Make two python files: spam.py and ham.py under /home/el/foo/hellokittyDefine a function inside spam.py:Define a function inside ham.py:Run it:
I got tired of this problem myself, so I wrote a package called automodinit to fix it. You can get it from http://pypi.python.org/pypi/automodinit/. Usage is like this:Include the automodinit package into your setup.py dependencies.Replace all __init__.py files like this:That's it! From now on importing a module will set __all__ toa list of .py[co] files in the module and will also import eachof those files as though you had typed:Therefore the effect of "from M import *" matches exactly "import M".automodinit is happy running from inside ZIP archives and is therefore ZIP safe.Niall
I know I'm updating a quite old post, and I tried using automodinit, but found out it's setup process is broken for python3. So, based on Luca's answer, I came up with a simpler answer - which might not work with .zip - to this issue, so I figured I should share it here:within the __init__.py module from yourpackage:and within another package below yourpackage:Then you'll have all the modules that are placed within the package loaded, and if you write a new module, it'll be automagically imported as well. Of course, use that kind of things with care, with great powers comes great responsibilities.
I have also encountered this problem and this was my solution:This function creates a file (in the provided folder) named __init__.py, which contains an __all__ variable that holds every module in the folder. For example, I have a folder named Testwhich contains:So in the script I want the modules to be imported into I will write:This will import everything from Test and the __init__.py file in Test will now contain:
Anurag's example with a couple of corrections:
Anurag Uniyal answer with suggested improvements!

See that your __init__.py defines __all__. The modules - packages doc says The __init__.py files are required to make Python treat the directories as containing packages; this is done to prevent directories with a common name, such as string, from unintentionally hiding valid modules that occur later on the module search path. In the simplest case, __init__.py can just be an empty file, but it can also execute initialization code for the package or set the __all__ variable, described later....The only solution is for the package author to provide an explicit index of the package. The import statement uses the following convention: if a package’s __init__.py code defines a list named __all__, it is taken to be the list of module names that should be imported when from package import * is encountered. It is up to the package author to keep this list up-to-date when a new version of the package is released. Package authors may also decide not to support it, if they don’t see a use for importing * from their package. For example, the file sounds/effects/__init__.py could contain the following code:__all__ = ["echo", "surround", "reverse"]This would mean that from sound.effects import * would import the three named submodules of the sound package.
This is the best way i've found so far:
Look at the pkgutil module from the standard library. It will let you do exactly what you want as long as you have an __init__.py file in the directory. The __init__.py file can be empty.
I've created a module for that, which doesn't rely on __init__.py (or any other auxiliary file) and makes me type only the following two lines:Feel free to re-use or contribute: http://gitlab.com/aurelien-lourot/importdir
Just import them by importlib and add them to __all__ (add action is optional) in recurse in the __init__.py of package.


Answer URL
https://docs.python.org/3/library/importlib.html#importlib.import_module
