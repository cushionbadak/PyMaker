Natural Text
Is saying:The same as saying:I would rather not use the types module if I can avoid it.
No, they are not the same.callable(output.write) just checks whether output.write is callable. Things that are callable include:Bound method objects (whose type is types.MethodType).Plain-old functions (whose type is types.FunctionType)partial instances wrapping bound method objects (whose type is functools.partial)Instances of you own custom callable class with a __call__ method that are designed to be indistinguishable from bound method objects (whose type is your class).Instances of a subclass of the bound method type (whose type is that subclass).…type(output.write) == types.MethodType accepts only the first of these. Nothing else, not even subclasses of MethodType, will pass. (If you want to allow subclasses, use isinstance(output.write, types.MethodType).)The former is almost certainly what you want. If I've monkeypatched an object to replace the write method with something that acts just like a write method when called, but isn't implemented as a bound method, why would your code want to reject my object?As for your side question in the comments:I do want to know if the exceptions.ValueError is necessaryNo, it's not.In Python 2.7, the builtin exceptions are also available in the exceptions module:In Python 3, they were moved to builtins along with all the other builtins:But either way, the only reason you'd ever need to refer to its module is if you hid ValueError with a global of the same name in your own module.One last thing:As user2357112 points out in a comment, your solution doesn't really ensures anything useful.The most common problem is almost certainly going to be output.write not existing at all. In which case you're going to get an AttributeError rather than the ValueError you wanted. (If this is acceptable, you don't need to check anything—just call the method and you'll get an AttributeError if it doesn't exist, and a TypeError if it does but isn't callable.) You could solve that by using getattr(output, 'write', None) instead of output.write, because None is not callable.The next most common problem is probably going to be output.write existing, and being callable, but with the wrong signature. Which means you'll still get the same TypeError you were trying to avoid when you try to call it. You could solve that by, e.g., using the inspect module.But if you really want to do all of this, you should probably be factoring it all out into an ABC. ABCs only have built-in support for checking that abstract methods exist as attributes; it doesn't check whether they're callable, or callable with the right signature. But it's not that hard to extend that support. (Or, maybe better, just grabbing one of the interface/protocol modules off PyPI.) And I think something like isinstance(output, StringWriteable) would declare your intention a lot better than a bunch of lines involving getattr or hasattr, type checking, and inspect grubbing.


Answer URL
https://docs.python.org/3/library/functions.html#callable
https://docs.python.org/3/library/abc.html
