Natural Text
So I have this class with the repr method implementedWhat are the differences between the various implementations of the repr method?They all have the same output.Code used on all implementations:Edit:The first implementation (join method) will produce the items without brackets.Disregard that if you like. My focus is what are differences among the last three and which is the better implementation among all four implementation.Edit:This is clearly not about the differences between the repr and str methods.It's about which implementation should I consistently adopt when implementing the repr method (or the str method for that matter). 
First, what I would write:This preserves the primary purpose of a repr: to tell both the class and the important parts of the value. You could replace __qualname__ with __name__, or add __module__, but I find this is the best balance.Sometimes, for more complicated cases (mostly, whenever parts of the repr should only appear conditionally), I wrote something like:All of your answers are missing the class, so I won't mention it again below.This is bad for a lot of reasons, although it can be fixed:Missing brackets. To fix, use '[%s]' % ...Missing commas. To fix, use ', '.join(...)Pointless use of a generator comprehension. Generators are very slow compared to list comprehensions, so whenever you're consuming the whole value immediately, always use a list comprehension.Calls str instead of repr. This will produce confusing output for things like ['1', '2', '3']This will truncate the list after some number of elements. Honestly, I find this more annoying than anything else.The only function I ever use from that module is the reprlib.recursive_repr decorator, and even that only in the rare case that I can't just call builtin repr that is already recursion-aware. Notably, list is, so you don't need it here.This is as correct as any of your answers get. May cause problems for exceptionally-long lists. However, since reprs need more information than this, it often ends up being worth using '%r' % ... or {!r}.format(...)This happens to produce the same output for list, but is semantically incorrect.As an aside, instead of:use:
My undestanding of __repr__ is that in the best possibility it should allow replicating the instance (perhaps even with eval()), and second-best is giving precise information about how to do that. My preference for a mature __repr__ would be: The drawback of this approach is that you have to change __repr__ each time you introduce changes to __init__. Also __repr__has a tendency to fail silentlyin IDE without any exceptions, so explicit testing of it is necessary.
It depends on what you plan on doing with the class's repr. If you are planning on doing custom formatting or the my_list attribute can be any iterable (though remember to avoid losing the data to the repr) instead of just a list, you should do something like the str.join method.If you want to consider size and trim for that (making a large list display like Test([x, y, z, ...]) or something), consider using reprlib since it has functionality for that.If you don't have any specific requirements, stick to whichever is simplest (namely repr, str and sometimes str.join)


Answer URL
https://docs.python.org/3/library/reprlib.html
