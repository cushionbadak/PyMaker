Natural Text
For some reasons, in this example consumer seems to be blocked (because it's waiting for EOF?). But the writing end of the pipe should have been closed.
The problem here is that all processes inherit all open file descriptors, and that there will only be an EOF on the read end of the pipe when the write end has been closed in all processes. Because the cat process itself keeps the write end open calling os.close(w) in your main process is not enough.For this case Popen() has the close_fds argument, which when set to True will cause all open file descriptors except those used for stdin, stderr and stout to be closed immediately after creating the subprocess. If you do that the your example should work as expected.On python2 close_fds=False is the default, in python3 this was changed to close_fds=True, and additionally since python3.4 file desciptors that should be inherited need to be marked as inheritable explicitly using os.set_inheritable(). That reduces this kind of problem.
The reason your program never exits is that you're waiting on cat, except cat is waiting for an EOF that never comes.when you call subprocess.Popen(['cat'], stdin=r).wait(), it reads from the file descriptor and prints it to stdout because you didn't redirect stdout.This is why you still see '123' on the screen.Consider either of these options instead:Use a queue:or use os.pipe but use read and write instead


Answer URL
https://docs.python.org/3/library/os.html#inheritance-of-file-descriptors
