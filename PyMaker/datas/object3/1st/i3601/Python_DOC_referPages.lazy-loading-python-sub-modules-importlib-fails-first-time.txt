Natural Text
I'm experimenting with the idea of lazy-loading of symbols in a package's __init__.py by subclassing ModuleType and defining properties for each of the submodules. Accessing the symbol in the package namespace would trigger the import. I've got it working, but for some reason, my call to import_module fails on the first attempt and I don't understand why.I have a minimal example. Assume a package like this:this is the __init__.pyThe import_module call always fails with an AttributeError: module 'my_package' has no attribute 'm1'. However, the second call always succeeds. In other words, when I do my_package.m1 I always get m1, but it always prints 'second try ...'.Note, the behavior is dependent on python version. The call to import_lib works fine the first time on python2.7.
Here is the difference between python2 vs python3.In python3, the importlib.import_module call ultimately ends upherewhich is a call to setattr. Since you didn't define a .setter foryour property, you get the AttributeError.In python2, the importlib.import_module call ends upherewhich is a call to the builtin __import__ which presumably operatesdirectly on the module __dict__.The only question is how in the world it ever works in python3. Iwould have thought it would always resulted in a AttributeError.Your code works fine as long as you make a .setter:It actually turns out that the .setter can do anything at all,including pass since you are unconditionally making the call toimport_module.I would consider using the .setattr above and changing the getter to:


Answer URL
https://docs.python.org/3/library/logging.html#logging.Logger.exception
