Natural Text
Is there any reason for a class declaration to inherit from object?I just found some code that does this and I can't find a good reason why.
Is there any reason for a class declaration to inherit from object?tl;dr: In Python 3, apart from compatibility between Python 2 and 3, no reason. In Python 2, many reasons. Python 2.x story:In Python 2.x (from 2.2 onwards) there's two styles of classes depending on the presence or absence of object as a base-class:"classic" style classes: they don't have object as a base class:"new" style classes: they have, directly or indirectly (e.g inherit from a built-in type), object as a base class:Without a doubt, when writing a class you'll always want to go for new-style classes. The perks of doing so are numerous, to list some of them:Support for descriptors. Specifically, the following constructs are made possible with descriptors: classmethod: A method that receives the class as an implicit argument instead of the instance.staticmethod: A method that does not receive the implicit argument self as a first argument.properties with property: Create functions for managing the getting, setting and deleting of an attribute. __slots__: Saves memory consumptions of a class and also results in faster attribute access. Of course, it does impose limitations.The __new__ static method: lets you customize how new class instances are created. Method resolution order (MRO): in what order the base classes of a class will be searched when trying to resolve which method to call. Related to MRO, super calls. Also see, super() considered super.If you don't inherit from object, forget these. A more exhaustive description of the previous bullet points along with other perks of "new" style classes can be found here.One of the downsides of new-style classes is that the class itself is more memory demanding. Unless you're creating many class objects, though, I doubt this would be an issue and it's a negative sinking in a sea of positives.Python 3.x story:In Python 3, things are simplified. Only new-style classes exist (referred to plainly as classes) so, the only difference in adding object is requiring you to type in 8 more characters. This:is completely equivalent (apart from their name :-) to this:and to this:All have object in their __bases__.So, what should you do?In Python 2: always inherit from object explicitly. Get the perks.In Python 3: inherit from object if you are writing code that tries to be Python agnostic, that is, it needs to work both in Python 2 and in Python 3. Otherwise don't, it really makes no difference since Python inserts it for you behind the scenes.
Python 3.x:class MyClass(object): = new-style classclass MyClass: = new-style class (implicitly inherits from object)Python 2.x:class MyClass(object): = new-style classclass MyClass: = OLD-STYLE CLASSExplanation:When defining base classes in Python 3.x, you’re allowed to drop the object from the definition. However, this can open the door for a seriously hard to track problem…Python introduced new-style classes back in Python 2.2, and by now old-style classes are really quite old. Discussion of old-style classes is buried in the 2.x docs, and non-existent in the 3.x docs.The problem is, the syntax for old-style classes in Python 2.x is the same as the alternative syntax for new-style classes in Python 3.x. Python 2.x is still very widely used (e.g. GAE, Web2Py), and any code (or coder) unwittingly bringing 3.x-style class definitions into 2.x code is going to end up with some seriously outdated base objects. And because old-style classes aren’t on anyone’s radar, they likely won’t know what hit them.So just spell it out the long way and save some 2.x developer the tears.
Yes, this is a 'new style' object. It was a feature introduced in python2.2.New style objects have a different object model to classic objects, and some things won't work properly with old style objects, for instance, super(), @property and descriptors. See this article for a good description of what a new style class is.SO link for a description of the differences: What is the difference between old style and new style classes in Python?
History from Learn Python the Hard Way:Python's original rendition of a class was broken in many serious  ways. By the time this fault was recognized it was already too late,  and they had to support it. In order to fix the problem, they needed  some "new class" style so that the "old classes" would keep working  but you can use the new more correct version.They decided that they would use a word "object", lowercased, to be  the "class" that you inherit from to make a class. It is confusing,  but a class inherits from the class named "object" to make a class but  it's not an object really its a class, but don't forget to inherit  from object.Also just to let you know what the difference between new-style classes and old-style classes is, it's that new-style classes always inherit from  object class or from another class that inherited from object:Another example is:While an old-style base class looks like this:And an old-style child class looks like this:You can see that an Old Style base class doesn't inherit from any other class, however, Old Style classes can, of course, inherit from one another. Inheriting from object guarantees that certain functionality is available in every Python class. New style classes were introduced in Python 2.2 
Yes, it's historical. Without it, it creates an old-style class.If you use type() on an old-style object, you just get "instance". On a new-style object you get its class.
The syntax of the class creation statement:In the absence of any other superclasses that you specifically want to inherit from, the superclass should always be object, which is the root of all classes in Python.object is technically the root of "new-style" classes in Python. But the new-style classes today are as good as being the only style of classes.But, if you don't explicitly use the word object when creating classes, then as others mentioned, Python 3.x implicitly inherits from the object superclass. But I guess explicit is always better than implicit (hell)Reference


Answer URL
https://docs.python.org/3/library/stdtypes.html
https://docs.python.org/3/howto/descriptor.html
https://docs.python.org/3/library/functions.html#classmethod
https://docs.python.org/3/library/functions.html#staticmethod
https://docs.python.org/3/library/functions.html#property
https://docs.python.org/3/reference/datamodel.html#slots
https://docs.python.org/3/reference/datamodel.html#notes-on-using-slots
https://docs.python.org/3/reference/datamodel.html#object.__new__
https://docs.python.org/3/library/functions.html#super
