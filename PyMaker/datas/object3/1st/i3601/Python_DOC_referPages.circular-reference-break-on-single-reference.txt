Natural Text
TL;DR Is there any way to create a weak reference that will call a callback upon having 1 strong reference left instead of 0?For those who think it's an X Y problem, here's the long explanation:I have quite a challenging issue that I'm trying to solve with my code.Suppose we have an instance of some class Foo, and a different class Bar which references the instance as it uses it:Now here's the tricky part: You can solve this issue using a circular reference, where foo references bar and bar references foo, but hey, what's the fun part in that? It will take longer to clean up, will not work in case Foo defines __slots__ and generally will be a poor solution.Is there any way, I can create a foo_to_bar mapping that cleans upon a single reference to both foo and bar? In essence:This way it can work perfectly as having foo outside the function makes sure bar is still there (I might require __slots__ on Foo to support __weakref__) and having bar outside the function results in foo still being there (because of the strong reference in Bar).WeakKeyDictionary does not work beacuse {weakref.ref(inst): bar.inst} will cause circular reference.Alternatively, is there any way to hook into the reference counting mechanism (in order to clean when both objects get to 1 reference each) without incurring significant overhead?
You are overthinking this. You don't need to track if there is just one reference  left. Your mistake is to create a circular reference in the first place.Store _BarInner objects in your cache, that have no reference to Foo instances. Upon access to the mapping, return a lightweight Bar instance that contains both the _BarInner and Foo references:Translating this to the bdict project linked in the comments, you can simplify things drastically:Don't worry about lack of support for weak references in projects. Document that your project will only support per-instance data on types that have a __weakref__ attribute. That's enough.Don't distinguish between slots and no-slots types. Always store per-instance data away from the instances. This lets you simplify your code.The same goes for the 'strong' and 'autocache' flags. The flyweight should always keep a strong reference. Per-instance data should always be stored. Use a single class for the descriptor return value. The ClassBoundDict type is all you need. Store the instance and owner data passed to __get__ in that object, and vary behaviour in __setitem__ accordingly.Look at collections.ChainMap() to encapsulate access to the class and instance mappings for read access.


Answer URL
https://docs.python.org/3/library/collections.html#collections.ChainMap
