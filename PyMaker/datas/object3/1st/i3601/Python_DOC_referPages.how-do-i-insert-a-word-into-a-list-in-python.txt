Natural Text
I have a list.I need to add a word into the list but im not sure how to do so.For example, I have a list = ['Alice', 'Amy', 'Andy', 'Betty', 'Eric', 'Peter', 'Richard', 'Tony'] 
You can use a specialist library such as sortedcontainers, which is more efficient than a naive list.sort after each insertion. Complexity of SortedList.add is ~O(log n).
If you're certain you have a sorted list, you could implement a naive insertion sortOr you can, less-naively, use the stdlib bisect module to insert for you.
Try this:
First, to "check matching letters" between two strings, all you really need is <. Strings compare lexicographically: 'abc' < 'abd' < 'acd' < 'acdd'.With a linked list, you have to search nodes from the head to find the location. Keep track of a prev and next node as you go, and as soon as you find a next.head > value, insert the new node after prev. (If you're using a bare-node implementation, make sure your function returns the headâ€”otherwise, there's no way to insert before the head.)Of course this automatically means linear time to find the right position (and, if you're using immutable nodes, also linear time to build the new nodes back up to the head).Given your implementation, that could look like these methods on SingleLinkedList:With a random-access data structure like an array (a Python list), you can bisect to find the right location in log time. But with an array, you still need linear time to do the insert, because all of the subsequent values have to be shifted up. (Although this is usually linear with a much faster constant than the linked-list search.)One last thing: If you're doing a ton of inserts in a row, it's often more efficient to batch them up. In fact, just calling extend and then sort may actually be faster than insorting each one, if the number of elements being added is a sizable fraction of the list.If you want to get the best of both worlds, you need a more complex data structure:A balanced binary search tree of some kind (red-black, AVL, etc.) is the traditional answer, although it tends to be pretty slow in practice.A wider search tree, like any of the B-tree variants, avoids most of the performance costs of binary trees (and lets you search with a higher log base, to boot).A skiplist is a linked list with log N "higher-level" linked lists threaded through it (or stacked above it), so you can bisect it. And there are other variations on this "indexed list" concept.There are multiple Python implementations of complicated hybrids, like a deque/rope structure with an optional B-tree-variant stacked on top.Popular implementations include blist.sortedlist, sortedcontainers.SortedList, pybst.AVLTree, etc.But really, almost any implementation of any such structure you find in Python is going to have this behavior built in. So the right answer will probably just be something like this:
The  bisect  module provides support for maintaining a list in sorted order without  having to sort the list after each insertion.The bisect.insort_left() method will "insert the item in the list in sorted order":
In raw python, you could do:Why does this work?Strings can be compared just like numbers in python! A < B, C > B, etc.To be fair: It's not the most efficient option, and bisect.insort is better, but if you want your own code you can control, there you are.Timing code:Timing results:
Using a binary tree, insertion can be performed in O(height_of_tree):Output:With a linked-list, you can perform the add and insert operations in a single method, applying additional logic:
Try using the bisect library:


Answer URL
https://docs.python.org/3/library/bisect.html
https://docs.python.org/3/library/bisect.html#searching-sorted-lists
https://docs.python.org/3/library/bisect.html#module-bisect
https://docs.python.org/3/library/bisect.html#bisect.insort_left
