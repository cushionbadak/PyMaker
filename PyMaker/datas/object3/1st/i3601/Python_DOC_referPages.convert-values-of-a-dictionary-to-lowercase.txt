Natural Text
I have a dictionary in python that has a dictionary within it and some values are placed in an array or list. I want to print the dictionary to be all lowercase without changing anything else but the only code I have only iterates through values of a plain dict, it doesn't deal with arrays or lists. Any suggestions for how to fix this? Here's the code I have so far: And this is the nested dictionary:
Nick A pointed out an interesting shortcut in the comments: Your dict looks like it's JSON-compatible. If so, can we just convert to JSON, lowercase that string, then convert back? There are a number of slightly different JSON standards: json.org, ECMA 404, and RFCs 4627, 7158, 7159, and 8259. And then there's the way JSON is actually used in practice. And the way it's implemented by Python's json module. But I'll summarize here:â€¦Â will work as long as:Your values are all of type dict, list, str, float, int, bool, and NoneType.Your dict values only have str keys.Your list and dict values aren't circular (e.g., lst = []; lst.append(lst)).Your float values will never include math.inf or math.nan.You're using a recent-ish Python (3.6 is fine), or will never have any non-BMP letters like ðž¤€.You're using a recent-ish Python (3.6 is fine), or will never have any int values outside range(-(2**53)+1, (2**53)).Notice the ensure_ascii=False. This is necessary if you might have any non-ASCII letters, because 'Ã‰'.lower() is 'Ã©', but r'\u00c9'.lower() does nothing.For JSON that you receive over the wire or in a file, instead of creating it yourself with dumps, of course you can't trust strings to not be escaped.  But you can always loads it first, then dumps it to lowercase and loads again. (For this case, you might want to add allow_nan=False to catch inf and nan values early, where they're easier to debug.)Using the third-party library simplejson (which the stdlib json is based on) will probably eliminate the requirements for recent Python, and may provide workarounds for some other possible issues, but I haven't tried it.If this hack isn't acceptable for whatever reason, the cleaner way to do it is to recurse through the structure. A simple version looks like this:Of course the reason you're not using JSON is presumably that your types don't all map directly to JSON, which means they probably won't work with the above. But you can easily extend it as needed. For example:To handle non-string keys, replace the dict clause:To handle tuples and other sequences that aren't lists, replace the list clause (make sure this comes after the str check, because str is a Sequence typeâ€¦):To handle bytes (as pure ASCII strings), change the str part:To duck-type anything with a lower method (str, bytes, bytearray, various third-party types), change the str part:And so on.


Answer URL
https://docs.python.org/3/library/json.html
