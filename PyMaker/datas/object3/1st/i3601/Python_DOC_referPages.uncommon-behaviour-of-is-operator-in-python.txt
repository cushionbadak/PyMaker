Natural Text
From some of the answers on Stackoverflow, I came to know that from -5 to 256 same memory location is referenced thus we get true for:Now comes the twist (see this line before marking duplicate):This is completely understood, but now if I do:Why?
What you're seeing is an optimization in the compiler in CPython (which compiles your source code into the bytecode that the interpreter runs). Whenever the same immutable constant value is used in several different places within the a chunk of code that is being compiled in one step, the compiler will try to use a reference to same object for each place.So if you do multiple assignments on the same line in an interactive session, you'll get two references to the same object, but you won't if you use two separate lines:Another place this optimization comes up is in the body of a function. The whole function body will be compiled together, so any constants used anywhere in the function can be combined, even if they're on separate lines:While it's interesting to investigate optimizations like this one, you should never rely upon this behavior in your normal code. Different Python interpreters, and even different versions of CPython may do these optimizations differently or not at all. If your code depends on a specific optimization, it may be completely broken for somebody else who tries to run it on their own system.As an example, the two assignments on the same line I show in my first code block above doesn't result in two references to the same object when I do it in the interactive shell inside Spyder (my preferred IDE). I have no idea why that specific situation doesn't work the same way it does in a conventional interactive shell, but the different behavior is my fault, since my code relies upon implementation-specific behavior.
From python2 docs:The operators is and is not test for object identity: x is y is true  if and only if x and y are the same object. x is not y yields the  inverse truth value. [6]From python3 docs:The operators is and is not test for object identity: x is y is true  if and only if x and y are the same object. Object identity is  determined using the id() function. x is not y yields the inverse  truth value. [4]So basically the key to understand those tests you've run on the repl console is by usingaccordingly the id() function, here's an example that will show you what's going on behind the curtains:That said, usually a good way to understand what's going on behind the curtains with these type of snippets is by using either dis.dis or dis.disco, let's take a look for instance what this snippet would look like:the output would be:As we can see in this case the asm output doesn't tell us very much, we can see than lines 3-4 are basically the "same" instructions than line 5. So my recommendation would be once again to use id() smartly so you'll know what's is will compare. In case you want to know exactly the type of optimizations cpython is doing I'm afraid you'd need to dig out in its source code
After discussion and testing in various versions, the final conclusions can be drawn.Python will interpret and compile instructions in blocks. Depending on the syntax used, Python version, Operating System, distribution, different results may be achieved depending on what instructions Python takes in one block.The general rules are:(from official documentation)The current implementation keeps an array of integer objects for all  integers between -5 and 256Therefore:The part below returns False in Python 3.6.3 |Anaconda custom (64-bit)| (default, Oct 17 2017, 23:26:12) [MSC v.1900 64 bit (AMD64)]ButAs it is evident, whatever Python takes in "one block" is non deterministic and can be swayed depending on how it is written, single line or not, as well as the version, operating system and distribution used.
Generally speaking, numbers outside the range -5 to 256 will not necessarily have the optimization applied to numbers within that range. However, Python is free to apply other optimizations as appropriate. In your cause, you're seeing that the same literal value used multiple times on one line is stored in a single memory location no matter how many times it's used on that line. Here are some other examples of this behavior:


Answer URL
https://docs.python.org/3/library/dis.html#dis.dis
https://docs.python.org/3/library/dis.html#dis.dis
