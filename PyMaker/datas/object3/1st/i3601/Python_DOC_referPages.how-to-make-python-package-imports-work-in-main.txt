Natural Text
I have a simple app organized like this:and server.py looks like this:Running this as python app/server.py doesn't work of course, because server.py is not "in" app when run from the command line. Its package name is __main__. I know running it as python -m app.server works, but for various reasons I can't do that (among them, I'm using a reloader, and python -m<foo> "helpfully" rewrites argv with the full module name).I think I understand the extremely byzantine Python package/module import stuff, at least I've read up a lot. I think the standard (?) way to address this is to add the app dir to sys.path, something like sys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), '..')). But that seems weird to me, and it's nontrivial to do correctly (see other similar SO questions on this topic). It seems like there should be some way to just tell python "this is app.server", by setting __name__ and/or __package__ or __path__ or something else more hidden.Is there any way to "fool" the package import system like that?
Don't go there, there is no need to start mucking about with the Python package structure. The best method is to not put scripts in packages. Have a separate server.py file outside of the package, and have it import app.server or other modules to do its job. That can be as simple as:Aside from that, python -m may have updated sys.argv[0] to point to the full filename (it is basically equal to __file__ in the module being executed), but the __spec__ module spec object contains the original package name. Use that if you must use python -m and need to have the full qualifying name of the package being run as __main__ as the main attribute:So for a package.main module, the above would print package.main and not __main__:so if your reloader requires sys.argv to contain -m package.main, you could update sys.argv with:


Answer URL
https://docs.python.org/3/reference/import.html#module-spec
