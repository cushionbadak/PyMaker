Natural Text
I am using Python to build a parser for a file format that has many types of small chunks. Although I expect my own parsing to be sufficient, I'd like to let clients subclass the parser class to provide custom behavior if they need to.In C++, I could write something like this:As this might not be familiar to people who don't write a lot of C++: parse_method, in this example, is a "pointer-to-member" to a Parser method which accepts a size_t argument. (parser.*method)(chunk_offset) applies the method method to parser and passes it the chunk_offset parameter. Note that this respects virtual dispatch: with a subclass of Parser that overrides parse_foo, (parser.*method)(chunk_offset) (when method is parse_foo), the subclass's implementation will be called.In Python, I can write something like this:However, Parser.parse_foo is a reference to Parser's implementation of parse_foo, specifically. Even if I call it on a subclass of Parser that overrides it, what is called is still the original implementation.Is there a way, in Python, to get a "method reference" that respects virtual dispatch? I can make per-instance tables that use self.parse_foo, but that seems wasteful.
The closest thing to a method reference is basically just a string containing the method's name. You can use that name to look up the method on the parser object with getattr and then call it:Alternatively, you can use proxy functions that call the corresponding methods:
It's not a bound method, but the performance overhead is pretty minimal:If you don't want to be tied to a specific argument signature, you can write:Better yet, if chunk_type() returns a string such as parse_foo, you can just write:without the list of methods at all.
So you would use pointer to members in C++. The closest in Python would be to have an instance attribute that will receive a bound method. Here is some code demonstrating it:prints as expected:This allows different instances of A to have a.method(offset) invoke different methods.Anyway, as you are asking for an idiomatic way, this is not very Pythonic. But what is not Pythonic is a dispatcher on an integer (the enum or index array) while Python natively allows to dispatch by names:outputs


Answer URL
https://docs.python.org/3/library/functions.html#getattr
