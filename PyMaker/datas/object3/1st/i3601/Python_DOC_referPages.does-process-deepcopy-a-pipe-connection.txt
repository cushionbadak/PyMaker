Natural Text
In Python multiprocessing, I saw some codes doing the followingThe question I have isWhy in worker, we can directly close the parent connection, it should have broken the pipe. So does the process fork (deepcopy) both parent and child connections for the worker ?Why also in master main program, we can also directly close child_conn with same reason as question above ?If I didn't send 'close' to the worker from parent connection, it seems the worker while loop will goes infinitely even though I do join the process in the master main program. 
Pipe() creates two connections, how they are propagated to a subprocess depends on the implementation for the used OS.On *nix systems,fork() is used to spawn a new process, which inherits all open file descriptors from the parent process. It is best practice to immediately close all inherited file descriptors which are not needed after forking, that is what is being done here. This makes less sense on systems without fork() (windows), where connnections are implemented differently, but it still works.The parent and the worker both close the one end of the connection they are not using. As they are separate processes, calling child_conn.close() in the parent does have no effect on child_conn in the worker, it only closes one end of the connection, the other can still be used. So the worker can call recv() on client_conn to get objects sent in the parent using parent_conn.send() and vice versa.Your example actually wouldn't work because in the main process there is a call to child_conn.recv() after the connnection was closed. This will raise an exception.process.join() waits for the process to finish, which it does only if the loop ends, so if you never send a 'close' message the woker will block on child_conn.recv() indefinitely, and join() will never return. This is a typical deadlock.A different way signalling the worker to exit would be to call parent_conn.close() instead of sending a close message. This would cause an EOF error to be raised by child_conn.recv(), but only if all processes, including the worker, have closed the underlying file descriptor, which is one reason why it is customary to close unneeded file descriptors.


Answer URL
https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Pipe
