Natural Text
For every row in my dataframe, I need to create every combination of two values of column a from a three-day sliding window ending at that row. My dataframe is like this:Note that the time index is ragged (inconsistent intervals between rows). The combinations should come out to be:I can do this easily enough without the window, just use itertools.combinations to generate every combination of two elements of column a with:but I need the windowed version for my application. My best bet so far is to use df.rolling. I can do simple things like summing the elements over a three day window with something like:but I can't seem to perform more complicated operations (or return more complicated types than real numbers from an operation) on the rolling window.QuestionHow do I use df.rolling to make combinations over my rolling window? Or is there some other tool to do this?AttemptsMy thought so far is that there is some way to use df.rolling and df.apply along with it.combinations to generate iterators for each window in my dataframe, and then plug that iterator into a new column of my dataframe. Something like:which gives a TypeError:TypeError: must be real number, not itertools.combinationsbecause df.rolling.apply requires that its argument return a single real value, not an object, nor a list.I also tried using it.combinations directly on the rolling window:which gives:KeyError: 'Column not found: 0'and if I select column a explicitly:I get:Exception: Column(s) a already selectedSo is there maybe a way to define a function that I can call with df.apply that plugs the iterator over my rolling window into a new column for each row of my dataframe? Can I even operate on rows other than the current row in a function passed to apply?
Okay, this is a hack, but it might be useful.All we want to do is reuse df.rolling's windowing facilities.  We could try to look inside some non-public parts of the code, but instead let's just take advantage of the fact we can force a function call inside apply before we return a float:And so:After which you can do what you like.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.combinations
