Natural Text
First of all let me put you in context. My main background is Java and I'm working in Python since 2 months ago. I don't know if the approach it's wrong due to my Java background and in Python has a different solution or it's just a technical ignorance problem.In Java often you have a packaging structure like:Thus, when you execute this from tests (with Maven or IDE):Either Maven or IDE loads the test path in the classpath, making test resources available rather than the ones within the main package. Conversely, when previous line is executed as main, only the resources within the main path are loaded to the classpath.My question is: Is there any mechanism in Python to simulate this feature? Does Python have other ways to manage resources depending on the execution path? 
I think mock might be what you are looking for.  It allows for 'mock'ing out external functions to limit the test to strictly the unit under test.  This could mean changing some of the philosophy around some of it.  For example, if you want to test that a function is reading a file correctly the filename would get passed to the method as a parameter.  In your unit test for the function, pass in a different filename from your test folder.In another test mock out the open call to the os to check that the method responds as expected when the file is not there, or cannot be opened, or whatever other mis-behaviors you want to test for.   
I don't know very well Python but you are right to ask yourself the question as separating test and application code makes part of good practice to have a robust/reliable application and tests.The pytest (a known test framework for Python) documentation explains in its best practice guide the two ways (separating and not separating the test code from the application).Here is the part referencing the isolated layout :Choosing a test layout / import rulespytest supports two common test layouts:Tests outside application codePutting tests into an extra directory outside your actual application  code might be useful if you have many functional tests or for other  reasons want to keep tests separate from actual application code  (often a good idea): This way your tests can run easily against an installed version of  mypkg.Note that using this scheme your test files must have unique names,  because pytest will import them as top-level modules since there are  no packages to derive a full package name from. In other words, the  test files in the example above will be imported as test_app and  test_view top-level modules by adding tests/ to sys.path.If you need to have test modules with the same name, you might add  init.py files to your tests folder and subfolders, changing them to packages: Now pytest will load the modules as tests.foo.test_view and  tests.bar.test_view, allowing you to have modules with the same name.  But now this introduces a subtle problem: in order to load the test  modules from the tests directory, pytest prepends the root of the  repository to sys.path, which adds the side-effect that now mypkg is  also importable. This is problematic if you are using a tool like tox  to test your package in a virtual environment, because you want to  test the installed version of your package, not the local code from  the repository.In this situation, it is strongly suggested to use a src layout where  application root package resides in a sub-directory of your root: This layout prevents a lot of common pitfalls and has many benefits, which are better explained in this  excellent blog post by Ionel Cristian Mărieș.https://docs.pytest.org/en/latest/goodpractices.html
No, Python has no deployable like Java has (WAR, JAR, etc...). You will run your code directly from the source, so, just read the file.In the Java context, you do not have the code when it is deployed. So every resource should be package inside a file (JAR or WAR). If you want to find the file in the current folder, look this question.


Answer URL
https://docs.python.org/3/library/unittest.mock.html
