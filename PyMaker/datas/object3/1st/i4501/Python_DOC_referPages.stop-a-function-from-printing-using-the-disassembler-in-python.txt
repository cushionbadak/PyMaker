Natural Text
I have this function here and it looks like this when disassembled:Is there a way to modify the bytecode so it doesn't print "Hello world." It's like I want to skip line 10 and continue to 11. There's a lot of material like inspectors and settrace but it's not very direct. does anyone have any info on this or can someone point me to what I could do? 
The best way to modify the bytecode of a function (well, assuming anything can be called a good way in the first place…) is with a third-party library. At present, bytecode seems to be the best one, but for older versions of Python, you probably want byteplay—for 3.4 (which you seem to be using), specifically Seprex's version of the 3.x port.But you can do everything manually. It's worth doing that at least once, just to make sure you understand everything (and to learn why bytecode is such a cool library).As you can see from the inspect documentation, a function is basically a wrapper around a __code__ object with extra stuff (closure cells, default values, and reflection stuff like the name and type annotations), and a code object is a wrapper around a co_code bytestring full of bytecode with a whole bunch of extra stuff. So, you'd think chopping out some bytecode would just be a matter of:But sadly, bytecode does everything in terms of offsets, from jump instructions to the line-number table used for generating tracebacks. You can fix everything up, but it's painful. So you can instead replace the instructions you wanted to kill with NOP. (Under the covers, the compiler and the peephole optimizer drop NOPs in all over the place and then do one big fixup at the end. But the code to do that fixup isn't exposed to Python.)Also, bytecode is stored in immutable bytes, not a mutable bytearray, and code objects are themselves immutable (and trying to change them behind the interpreter's back via C API hacks is a very bad idea). So, you have to build a new code object around the modified bytecode. But functions are mutable, so you can hack up your function to point at that new code object.So, here's a function to NOP out a range of instructions by offset:If you're wondering about that version check: In Python 2.x and 3.0-3.5, each instruction is either 1 or 3 bytes long, depending on whether it needs any arguments, so NOP is 1 byte; in 3.6+, each instruction is 2 bytes long, including NOP.Anyway, I only actually tested on 3.6, not 3.4 or 3.5, so hopefully I didn't get that part wrong. And hopefully I didn't add any functions added to dis after 3.4. So, cross your fingers, then:… will do exactly what you wanted. Or it'll modify your function to raise a RuntimeError or crash when you try to call it, but segfaults are part of learning, right? Anyway, if you dis.dis(noprange) you should see the four instructions from line 10 replaced by a string of NOP lines, and then the rest of the function unchanged, so try that before you call it.Once you're confident you've got this working properly, if you want to knock out all of the instructions from one source line without having to dis the function and read them manually, you can use findlinestarts to do it programmatically:And now it's just:This has the nice advantage that you can use it in code will work (or crash) the same way in 3.4 and 3.8, because offsets may change between Python versions, but the way line numbers are counted obviously won't.


Answer URL
https://docs.python.org/3/library/inspect.html#types-and-members
https://docs.python.org/3/library/dis.html#opcode-NOP
https://docs.python.org/3/library/dis.html#dis.findlinestarts
