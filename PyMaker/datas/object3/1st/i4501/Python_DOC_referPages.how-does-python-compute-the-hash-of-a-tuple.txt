Natural Text
In python, if I have a tuple with many elements, is its hash calculated from its elements' ids or its elements' content? In this example,It errors out saying list is unhashable. So I guess it's not computed by id, or probably there is a check on whether the element is mutable.Now see this exampleHere it turns out the hash of ta does not change with the modification of its element, i.e., a0. So maybe a0's id is used for the hash calculation? Is a0 somehow considered as immutable? How does python know if a type is mutable?Now consider this caseIt seems the content of b and c are used for the hash calculation.How should I understand these examples?
Neither. It is calculated on the basis of the hashes of these elements, not their "contents" (values/attributes).Take a look at this paragraph in python's documentation glossary. Whether something is hashable or not, and how it is hashed, depends on the implementation of its .__hash__() method. Python itself has no idea about mutability of an object.In your first example, tuple happens to hash itself on the basis of its elements, while a list doesn't have a hash at all - the .__hash__() method is not implemented for it (and for a good reason). That's why a tuple with a list object inside of it is not hashable.Now, having that in mind, let's have a look at python data model documentation, and what it has to say on the topic:User-defined classes have __eq__() and __hash__() methods by default; with them, all objects compare unequal (except with themselves) and x.__hash__() returns an appropriate value such that x == y implies both that x is y and hash(x) == hash(y).That's why you don't have to define .__hash__() for your classes - python does it for you in this case. The default implementation doesn't take instance fields into account though. That's why you can change the values inside your object without changing its hash.In this regard you're right - the default (CPython's) implementation of the hashing function for custom classes relies on the id() of an object, and not on the values inside of it. It is an implementation detail, and it differs between Python versions though. In more recent versions of Python the relation between hash() and id() involves some randomization.But how does it actually hash itself?While the details are quite complicated and probably involve some advanced math, the implementation of the hash function for tuple objects is written in C, and can be seen here (see static Py_hash_t tuplehash(PyTupleObject *v).The calculation involves XORing a constant with the hashes of each of the tuple's elements. The line responsible for hashing of the elements is this one:So, to answer your original question: it does a bunch of XOR hokus-pocus with the hashes of each of its elements. Whether or not the contents of these elements are used depends on their specific hash functions.
The core contract of hashing is that equal objects have equal hashes. In particular, hashing does not directly care about mutability or mutation; it only cares about mutation that affects equality comparisons.Your first tuple is unhashable because mutating the nested list would change how the tuple behaves in equality comparisons.Mutating a0 in your second example doesn't affect the hash of the tuple because it doesn't affect equality comparisons. a0 is still only equal to itself, and its hash is unchanged.tb and tc in your third example have equal hashes because they are equal tuples, regardless of whether their elements are the same objects.This all means that tuples cannot (directly) use id for hashes. If they did, equal tuples with distinct but equal elements could hash differently, violating the contract of hashing. Without special-casing element types, the only things tuples can use to compute their own hashes are their elements' hashes, so tuples base their hashes on their elements' hashes.
The answer to the question "Is the tuple's hash calculated based on the identity or the value?" is: Neither.The correct answer is that the tuple's hash is calculated from the elements' hashes. How those hashes are calculated is (more or less) irrelevant.An easy way to prove this is to see what happens when you put a list into a tuple:Because lists aren't hashable, a tuple containing a list isn't hashable either.Let's take a closer look at this example you brought:Why doesn't setting a0.x = 20 affect the tuple's hash? Well, if we modify this code to output the hash of a0, you'll see that setting a0.x = 20 has no effect on a0's hash value:The reason for this is that python implements a default hash function for you. From the docs:User-defined classes have __eq__() and __hash__() methods by default;  with them, all objects compare unequal (except with themselves) and  x.__hash__() returns an appropriate value such that x == y implies  both that x is y and hash(x) == hash(y).The default hash function ignores the object's attributes and calculates the hash based on the object's id. No matter what changes you make to a0, its hash will always stay the same. (Though it is possible to define a custom hash function for instances of your A class by implementing a custom __hash__ method.)Addendum: The reason why lists aren't hashable is because they're mutable. From the docs:If a class defines mutable objects and implements an __eq__() method,  it should not implement __hash__(), since the implementation of  hashable collections requires that a key’s hash value is immutable (if  the object’s hash value changes, it will be in the wrong hash bucket).Lists fall into this category.
the hash of a tuple is based on the contents, not on the _id_s of the tuples. And the hashes are computed recursively: if one element isn't hashable (like a list element), then the tuple itself isn't hashable.That's perfectly normal that if a and b are tuples and a == b, then hash(a) == hash(b) (if hashes can be computed of course), even if a is not b.(on the contrary hash(a) == hash(b) doesn't mean that a == b)The information conveyed by is is often not very useful, because of python object interning for example.


Answer URL
https://docs.python.org/3/glossary.html#term-hashable
https://docs.python.org/3/reference/datamodel.html#object.__hash__
https://docs.python.org/3/library/functions.html#id
https://docs.python.org/3/reference/datamodel.html#object.__hash__
https://docs.python.org/3/reference/datamodel.html#object.__hash__
https://docs.python.org/3/reference/datamodel.html#object.__hash__
