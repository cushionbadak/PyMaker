Natural Text
If within an instance, I have self.foo = 1, what is the difference between these (or other more complicated examples):I'm currently looking at a code base where all the self variables are reassigned to something else. Just wondering if there is any reason to do so and would like to hear both from an efficiency standpoint and a code clarity standpoint.
Consider these possibilities:The local variable self gets rebound in the middle of the loop. (That's not possible with the specific code you've given, but a different loop could conceivably do it.) In that case, #1 will see the new self's foo attribute, while #2 will not. Although, of course, you could just as easily rebind the local variable foo as the local variable self…self is mutable, and self.foo is rebound to a different value in the middle of the loop. (That could happen more easily with, e.g., another thread operating on the same object.) Again, #1 will see the new value of the foo attribute, but #2 will not.self.foo is itself mutable, and its value is mutated in the middle of the loop (e.g., it's a list, and some other thread calls append(2) on it). Now both #1 and #2 will see the new value.Everything is immutable, or there's just no code (including on other threads) to mutate anything. Now both #1 and #2 are going to see the original value, because there is no other value to see.If any of those semantic differences are relevant, then of course you want to use whichever one gives you the right answer.Meanwhile, every time you access self.foo, that requires doing an attribute lookup. In the most common case, this means looking up 'foo' in self.__dict__, which is pretty quick, but not free. And you can easily create pathological cases where it goes through 23 base classes in MRO order before calling a __getattr__ that creates the value on the fly and returns a descriptor whose __get__ method does some non-trivial transformation.Accessing foo, on the other hand, is going to be compiled into just loading a value out of an array on the frame using a compiled-in index. So it will almost always be faster, and in some cases it can be a lot faster.In most real-life cases, this doesn't matter at all. But occasionally, it does. In which case copying the value to a local outside the loop is a worthwhile micro-optimization. This is a little more common with bound methods than with normal values (because they always have a descriptor call in the way); see the unique_everseen recipe in the itertools docs for an example.Of course you could contrive a case where this optimization actually made things slower—e.g., make that loop really tiny, but put the whole thing inside an outer loop. Now the extra self.foo copy each time through the outer loop (and the fact that the bytecode involved in the loop is longer and may spill onto another cache line) could cost a lot more than it saves.If there's no semantic difference that matters, and the performance difference doesn't matter, then it's just a matter of clarify.If the expression is a lot more complicated than self.foo, it may well be clearer to pull out the value and give it a name.But for a trivial case like this, it's probably clearer to just use self.foo. By taking the extra step of copying it to a local variable, you're signaling that you had some reason to do so. So a reader will wonder whether maybe self.foo can get rebound in a different thread, or maybe this loop is a major bottleneck in your code and the self.foo access is a performance issue, etc., and waste time dealing with all of those irrelevancies instead of just reading your code as intended.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools-recipes
