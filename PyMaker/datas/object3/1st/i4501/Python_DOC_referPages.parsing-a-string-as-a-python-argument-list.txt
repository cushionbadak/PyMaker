Natural Text
SummaryI would like to parse a string that represents a Python argument list into a form that I can forward to a function call.Detailed versionI am building an application in which I would like to be able to parse out argument lists from a text string that would then be converted into the *args,**kwargs pattern to forward to an actual method. For example, if my text string is:the parsed result would be something comparable to:I am aware of Python's ast module, but it only seems to provide a mechanism for parsing entire statements. I can sort of fake this by manufacturing a statement around it, e.g.and then pull the relevant fields out of the Call node, but this seems like an awful lot of roundabout work.Is there any way to parse just one known node type from a Python AST, or is there an easier approach for getting this functionality?If it helps, I only need to be able to support numeric and string arguments, although strings need to support embedded commas and escaped-out quotes and the like.If there is an existing module for building lexers and parsers in Python I am fine with defining my own AST, as well, but obviously I would prefer to just use functionality that already exists and has been tested correct and so on.Note: Many of the answers focus on how to store the parsed results, but that's not what I care about; it's the parsing itself that I'm trying to solve, ideally without writing an entire parser engine myself.Also, my application is already using Jinja which has a parser for Python-ish expressions in its own template parser, although it isn't clear to me how to use it to parse just one subexpression like this. (This is unfortunately not something going into a template, but into a custom Markdown filter, where I'd like the syntax to match its matching Jinja template function as closely as possible.)
I think ast.parse is your best option.If the parameters were separated by whitespace, we could use shlex.split:But unfortunately, that doesn't split on commas:I also thought about using ast.literal_eval, but that doesn't support keyword arguments:I couldn't think of any python literal that supports both positional and keyword arguments.In lack of better ideas, here's a solution using ast.parse:Output:
You can use re and a simple class to keep track of the tokens:Output:Full tests:Output:
This is not entirely what you wanted, but it comes close.


Answer URL
https://docs.python.org/3/library/ast.html
https://docs.python.org/3/library/shlex.html#shlex.split
https://docs.python.org/3/library/ast.html#ast.literal_eval
https://docs.python.org/3/library/ast.html#ast.parse
