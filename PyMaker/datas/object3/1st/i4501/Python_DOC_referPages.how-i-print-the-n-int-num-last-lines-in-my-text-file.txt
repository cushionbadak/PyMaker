Natural Text
I'm writing a log file viewer for a web application and for that I want to paginate through the lines of the log file.  The items in the file are line based with the newest item on the bottom.So I need a tail() method that can read n lines from the bottom and supports an offset.  What I came up with looks like this:Is this a reasonable approach?  What is the recommended way to tail log files with offsets?
This may be quicker than yours.  Makes no assumptions about line length.  Backs through the file one block at a time till it's found the right number of '\n' characters.I don't like tricky assumptions about line length when -- as a practical matter -- you can never know things like that.Generally, this will locate the last 20 lines on the first or second pass through the loop.  If your 74 character thing is actually accurate, you make the block size 2048 and you'll tail 20 lines almost immediately.Also, I don't burn a lot of brain calories trying to finesse alignment with physical OS blocks.  Using these high-level I/O packages, I doubt you'll see any performance consequence of trying to align on OS block boundaries.  If you use lower-level I/O, then you might see a speedup.
Assumes a unix-like system on Python 2 you can do:For python 3 you may do:
If reading the whole file is acceptable then use a deque.Prior to 2.6, deques didn't have a maxlen option, but it's easy enough to implement.If it's a requirement to read the file from the end, then use a gallop (a.k.a exponential) search.
S.Lott's answer above almost works for me but ends up giving me partial lines. It turns out that it corrupts data on block boundaries because data holds the read blocks in reversed order. When ''.join(data) is called, the blocks are in the wrong order. This fixes that.
Here is my answer. Pure python. Using timeit it seems pretty fast. Tailing 100 lines of a log file that has 100,000 lines:Here is the code:
The code I ended up using.  I think this is the best so far:
Simple and fast solution with mmap:
An even cleaner python3 compatible version that doesn't insert but appends & reverses:use it like this:
I found the Popen above to be the best solution. It's quick and dirty and it worksFor python 2.6 on Unix machine i used the followingsoutput will have will contain last n lines of the code. to iterate through soutput line by line do:
Update @papercrane solution to python3.Open the file with open(filename, 'rb') and:
Posting an answer at the behest of commenters on my answer to a similar question where the same technique was used to mutate the last line of a file, not just get it.For a file of significant size, mmap is the best way to do this. To improve on the existing mmap answer, this version is portable between Windows and Linux, and should run faster (though it won't work without some modifications on 32 bit Python with files in the GB range, see the other answer for hints on handling this, and for modifying to work on Python 2).This assumes the number of lines tailed is small enough you can safely read them all into memory at once; you could also make this a generator function and manually read a line at a time by replacing the final line with:Lastly, this read in binary mode (necessary to use mmap) so it gives str lines (Py2) and bytes lines (Py3); if you want unicode (Py2) or str (Py3), the iterative approach could be tweaked to decode for you and/or fix newlines:Note: I typed this all up on a machine where I lack access to Python to test. Please let me know if I typoed anything; this was similar enough to my other answer that I think it should work, but the tweaks (e.g. handling an offset) could lead to subtle errors. Please let me know in the comments if there are any mistakes.
based on S.Lott's top voted answer (Sep 25 '08 at 21:43), but fixed for small files.Hope this is useful.
There are some existing implementations of tail on pypi which you can install using pip: mtFileUtilmultitaillog4tailer...Depending on your situation, there may be advantages to using one of these existing tools.
Here is a pretty simple implementation:
For efficiency with very large files (common in logfile situations where you may want to use tail), you generally want to avoid reading the whole file (even if you do do it without reading the whole file into memory at once)  However, you do need to somehow work out the offset in lines rather than characters.  One possibility is reading backwards with seek() char by char, but this is very slow.  Instead, its better to process in larger blocks.I've a utility function I wrote a while ago to read files backwards that can be used here.[Edit] Added more specific version (avoids need to reverse twice)
you can go to the end of your file with f.seek(0, 2) and then read off lines one by one with the following replacement for readline():
Based on Eyecue answer (Jun 10 '10 at 21:28): this class add head() and tail() method to file object.Usage:
Several of these solutions have issues if the file doesn't end in \n or in ensuring the complete first line is read.
I had to read a specific value from the last line of a file, and stumbled upon this thread. Rather than reinventing the wheel in Python, I ended up with a tiny shell script, saved as/usr/local/bin/get_last_netp:And in the Python program:
Not the first example using a deque, but a simpler one.  This one is general:  it works on any iterable object, not just a file.




There is very useful module that can do this:
On second thought, this is probably just as fast as anything here.It's a lot simpler.  And it does seem to rip along at a good pace.  
I found a probably the easiest way to find the first or last N lines of a fileLast N lines of a file(For Ex:N=10)First N lines of a file(For Ex:N=10)
it's so simple:
Although this isn't really on the efficient side with big files, this code is pretty straight-forward:It reads the file object, f.It splits the string returned using newlines, \n.It gets the array lists last indexes, using the negative sign to stand for the last indexes, and the : to get a subarray.


Answer URL
https://docs.python.org/3/library/mmap.html
