Natural Text
I'm having an issue which I believe is related to improper implementation of custom class __eq__/__hash__ functions. I created a custom Line class, where a line holds a slope and y intercept which are calculated from 2 Points. I'm running a test on equality between 2 lines, which is producing unexpected results as shown below. I'm looking for an explanation of why the first 2 lines in the test code I've included below are not equal, but the 2nd set of 2 lines are equal, despite both sets of lines having matching values for slope and y intercept?test code:This test produces output:
Your original line1 and line2 are not equal, because of rounding errors.They're close, close enough that your output is hiding the difference, but if you try printing the repr of the numbers (e.g., replacing each {} with {!r}), or just specifying a whole mess of digits in your format, you will see that they're the y-intercept values are actually 0.10000000000000009 and 0.09999999999999987.There's a famous paper called What Every Computer Scientist Should Know About Floating Point that's so important it's been incorporated by reference into various standards documents. (I've seen a few answer link to a similarly-named site, What Every Programmer Should Know About Floating Point, which looks like it might be friendlier, but I can't vouch for its accuracy.)Anyway, in general, the right way to deal with this is to use math.isclose. Of course if you want to learn Python 2.7 even though it's 2018, you can't do that, because it doesn't have such a thing. PEP 485 includes a pseudocode description of the algorithm, and links to a pure-Python implementation.But in this specific case, there's an issue you have to think through: the values aren't actually equal, so they shouldn't hash the same. Does that break your intended design? Usually, the answer is that your design shouldn't be using lines, or anything else with float values, as dict keys, or whatever you were intending. But occasionally, it's worth building a wrapper that handles both equality and hashing by rounding things off to a fixed number of bits or digitsâ€”although that doesn't actually make rounding errors impossible; it just makes it possible to deal with them for some sets of input, so it only works if you know your input set.
Computing the same logical result in different ways with floating point numbers doesn't get consistent results. For highly precise values like this, you likely want to use an infinite precision numeric type, like fractions.Fraction.If you create your Points with Fraction with equivalent but (unlike float) 100% precise values:then your code works as expected:which prints:fractions.Fraction uses a normalized form of the Fraction too (as you can see, it's always 1/10 x + 99/100, even with distinct Points as input), so your hashing code will "just work".


Answer URL
https://docs.python.org/3/library/fractions.html#fractions.Fraction
