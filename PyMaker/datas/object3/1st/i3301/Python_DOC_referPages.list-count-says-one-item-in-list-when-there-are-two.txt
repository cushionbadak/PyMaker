Natural Text
I have written some code in python to delete unique numbers from a list so given the input:[1,2,3,2,1]It should return[1,2,2,1]But my program returns[1,2,1]My code is:I found the error occurs at the if data.count(i) == 1:. It says data.count(2) == 1 when clearly there are 2 occurrences of the number 2 in the list. I do not understand why this is giving the wrong answer
Try appending to a new list rather than changing your old one:It's bad practice to change list size during iteration, and pop will do that. This returns res = [1, 2, 2, 1]
If you have a long list, you should put all numbers into a Counter(iterable) - dictionary.This will count all occurences with one pass of your list (O(n)) and the lookup how often it occurs inside the created dictionary is O(1). Together this is much faster then use a list comprehension like  for a list of 100 values it will go through your 100 values 100 times, to count each single one of them wich is O(n^2) - bad thing to have.Output:
Solution using list comprehensionI believe a more pythonic answer could be, using list comprehension:Solutions time comparison for example listI have moved C.Nivis and Patrick Artner answers inside a function to run timeit more easily on it.To account for the time required to call the function, I have also wrapper the list comprehension into a function call.SetupSolution with loopsSolution with list comprehensionSolution with CounterSolution with numpy.uniqueConclusionsIt appears that list comprehension is slightly but consistently faster than looping and quite faster than Counter with small lists. Numpy, for small lists, is the slower one.Solutions time comparison for large listsSuppose that we have a large list of n random elements, from [0, n]Solution with loopsSolution with list comprehensionSolution with CounterSolution with numpy.uniqueConclusions for large listsFor large lists the undisputed winner is numpy.unique, followed just behind by Counter.Final conclusionsFor small lists list comprehension seems to do the trick, but for larger lists the numpy.unique approach works best.
This is a recursive problem. You misunderstood list.pop(). It takes an index not a specific element. Therefore, you're not removing what you expect.the thing to do here is to use enumerate,this way you're popping the item a the right index.EDITI edited, thanks to @wim for his comment. I'm now iterating over a copy (dup_list) of the original list not to iterate and mutate the original list at the same time.Also, I created a copy explicity for the sake of explanation. But you could use a shorter version of the code, Note that I added a comment because this syntax can be confusing for some people.  
Do not modify a list while iterating over it. Behavior will most likely not be the desired one.numpy.unique with return_counts=TrueOne more option is to use numpyFor big arrays this is way faster than list comprehension and CounterThen
You could use list comprehension to build a new list:Also, the pop() method takes the index of the element as an argument, not the value.


Answer URL
https://docs.python.org/3/library/collections.html#collections.Counter
https://docs.python.org/3/library/collections.html#collections.Counter
https://docs.python.org/3/library/collections.html#collections.Counter
https://docs.python.org/3/library/functions.html#enumerate
