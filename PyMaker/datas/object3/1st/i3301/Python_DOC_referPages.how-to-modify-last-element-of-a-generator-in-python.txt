Natural Text
I have a generator and I want to modify the last element of the generator.I want to replace the last element with another element. I know how to retrieve the last element, but not how to modify it.What would be the best way to approach this?For more context, this is what I want to do:My generator object is: children_of_child and for the second child all its children are:I want to replace the last layer Linear(in_features=4096, out_features=1000, bias=True) with my own regression net. `
Since you're working with a reasonably small list (even ResNet-150 is "reasonably small" in RAM terms), I'd make this easy to understand and maintain.  There is no "obvious" way to detect that you're one step short of exhausting a generator.Deplete the current generator, making a list of its output.Replace the last element as desired.Wrap a new generator around this altered list.The "nice" (?) way to do this is to write a wrapper generator with a one-element look-ahead in the original: at each call N, you already have element N in your wrapper.  You grab element N+1 from the "real" generator (your posted code).  If that element exists, then you return element N normally.  If that generator is exhausted, then you replace this last element with the one you want, and return the alteration.EXAMPLE:TO keep this simple, I've used range in place of your original generator.Output:Does that help?
The way to do this is to iterate one step ahead, keeping track of the previous value as you go. For each value, yield the previous one. When you get to the end, instead of yielding the last previous value, yield the replacement value:Or you can treat the first element specially instead of using a sentinel:You may want to think about what should happen with a completely empty iterator. I'm not sure whether you want to yield nothing, yield the replacement value, or raise an exception. The first version yields the replacement value; the secondâ€¦ well, it should raise an exception, but as of 3.7, it issues a DeprecationWarning and yields nothing, which is probably not the behavior you want.Anyway, you can either use next with a sentinel default value, or except StopIteration: the next. Then it's easy to do any of the three you wanted.But you can make this simpler if you think of it a little more abstractly: If you had all of the adjacent pairs of elements, the first element of each such pair gives you all but the last element. So, using the pairwise recipe from the itertools docs:Or, if you prefer, you can even make it a single expression using itertools.chain and operator.itemgetter, although this is probably a bit silly:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools-recipes
https://docs.python.org/3/library/itertools.html#itertools.chain
https://docs.python.org/3/library/operator.html#operator.itemgetter
