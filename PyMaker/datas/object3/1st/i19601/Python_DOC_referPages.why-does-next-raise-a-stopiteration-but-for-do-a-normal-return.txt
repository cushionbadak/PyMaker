Natural Text
In this piece of code, why does using 'for' result in no 'StopIteration'or is the 'for' loop trapping all exceptions and then silently exiting?In which case, why do we have the extraneous 'return'?? Or is theraise StopIteration caused by: return None?Assuming StopIteration is being triggered by: return None.When is GeneratorExit generated?If i manually do a:In which case why don't I see a traceback?
The for loop listens for StopIteration explicitly.The purpose of the for statement is to loop over the sequence provided by an iterator and the exception is used to signal that the iterator is now done; for doesn't catch other exceptions raised by the object being iterated over, just that one.That's because StopIteration is the normal, expected signal to tell whomever is iterating that there is nothing more to be produced.A generator function is a special kind of iterator; it indeed raises StopIteration when the function is done (i.e. when it returns, so yes, return None raises StopIteration). It is a requirement of iterators; they must raise StopIteration when they are done; in fact, once a StopIteration has been raised, attempting to get another element from them (through next(), or calling the .next() (py 2) or .__next__() (py 3) method on the iterator) must always raise StopIteration again.GeneratorExit is an exception to communicate in the other direction. You are explicitly closing a generator with a yield expression, and the way Python communicates that closure to the generator is by raising GeneratorExit inside of that function. You explicitly catch that exception inside of countdown, its purpose is to let a generator clean up resources as needed when closing.A GeneratorExit is not propagated to the caller; see the generator.close() documentation.


Answer URL
https://docs.python.org/3/reference/expressions.html#generator.close
