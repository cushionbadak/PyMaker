Natural Text
Say I have an array of positive whole integers; I'd like to manipulate the order so that the concatenation of the resultant array is the largest number possible. For example [97, 9, 13] results in 99713; [9,1,95,17,5] results in 9955171. I'm not sure of an answer.
sorted(x, cmp=lambda a, b: -1 if str(b)+str(a) < str(a)+str(b) else 1)
Intuitively, we can see that a reverse sort of single digit numbers would lead to the higest number:so reverse sorting should work. The problem arises when there are multi-digit snippets in the input. Here, intuition again lets us order 9 before 95 and 17 before 1, but why does that work? Again, if they had been the same length, it would have been clear how to sort them:The trick then, is to 'extend' shorter numbers so they can be compared with the longer ones and can be sorted automatically, lexicographically. All you need to do, really, is to repeat the snippet to beyond the maximum length:comparing 9 and 95: compare 999 and 9595 instead and thus 999 comes first.comparing 1 and 17: compare 111 and 1717 instead and thus 1717 comes first.comparing 132 and 13: compare 132132 and 1313 instead and thus 132132 comes first.comparing 23 and 2341: compare 232323 and 23412341 instead and thus 2341 comes first.This works because python only needs to compare the two snippets until they differ somewhere; and it's (repeating) matching prefixes that we need to skip when comparing two snippets to determine which order they need to be in to form a largest number.You only need to repeat a snippet until it is longer than the longest snippet * 2 in the input to guarantee that you can find the first non-matching digit when comparing two snippets. You can do this with a key argument to sorted(), but you need to determine the maximum length of the snippets first. Using that length, you can 'pad' all snippets in the sort key until they are longer than that maximum length:where s*(mlen//len(s)+1) pads the snippet with itself to be more than mlen in length.This gives:Note that this solution is a) 3 lines short and b) works on Python 3 as well without having to resort to functools.cmp_to_key() and c) does not bruteforce the solution (which is what the itertools.permutations option does).
Hint one: you concatenate strings, not integers. Hint two: itertools.permutations().
You can use itertools.permutations as hinted and use the key argument of the max function (which tells which function to apply to each element in order to decide the maximum) after you concat them with the join function.It's easier to work with strings to begin with.
I don't like the brute force approach to this. It requires a massive amount of computation for large sets.You can write your own comparison function for the sorted builtin method, which will return a sorting parameter for any pair, based on any logic you put in the function.Sample code:
Well, there's always the brute force approach...Or this, an adaptation of @Zah's answer that receives a list of integers and returns an integer, as specified in the question:
You can do this with some clever sorting.If two strings are the same length, choose the larger of the two to come first. Easy.If they're not the same length, figure out what would be the result if the best possible combination were appended to the shorter one. Since everything that follows the shorter one must be equal to or less than it, you can determine this by appending the short one to itself until it's the same size as the longer one. Once they're the same length you do a direct comparison as before.If the second comparison is equal, you've proven that the shorter string can't possibly be better than the longer one. Depending on what it's paired with it could still come out worse, so the longer one should come first.This should be much more efficient than running through all the permutations.



Answer URL
