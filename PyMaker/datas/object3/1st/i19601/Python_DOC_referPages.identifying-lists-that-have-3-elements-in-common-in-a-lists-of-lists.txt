Natural Text
I have a list of lists. If there are subslists that have the first three elements in common , merge them into one list and add all the fourth elements.The problem is best explained in code and the required output.I already have code for a similar problem (given to me by another user in Stack Overflow some time ago), but i don't understand it completely so I'm unable to modify it accordingly. What this code does is it checks if the 0th and 2nd elements are the same, if they are, it merges the sublists, adding the 1st and 3th element:How should the code be modified to fit to my new problem? I'd really appreciate if you could also take the time and explain the code thoroughly, too.
You can use the same principle, by using the first three elements as a key, and using int as the default value factory for the defaultdict (so you get 0 as the initial value):If you are using Python 3, you can simplify this to:because you can use a starred target to take all 'remaining' values from a list, so each sublist is assigned mostly to key and the last value is assigned to v, making the loop just that little simpler (and there is no .iteritems() method on a dict in Python 3, because .items() is an iterator already).So, we use a defaultdict that uses 0 as the default value, then for each key generated from the first 3 values (as a tuple so you can use it as a dictionary key) sum the last value.So for the first item ['apple', 50, 60, 7] we create a key ('apple', 50, 60), look that up in d (where it doesn't exist, but defaultdict will then use int() to create a new value of 0), and add the 7 from that first item.Do the same for the ('orange', 70, 50) key and value 8.for the 3rd item we get the ('apple', 50, 60) key again and add 12 to the pre-existing 7 in d[('apple', 50, 60)]. for a total of 19.Then we turn the (key, value) pairs back into lists and you are done. This results in:An alternative implementation that requires sorting the data uses itertools.groupby:for the same output. This is going to be slower if your data isn't sorted, but it's good to know of different approaches.
I'd do something like this:This doesn't give the sum however.  It could be easily be fixed by doing:There isn't much of a reason to prefer this over the slightly more elegant solution by Martijn, other than it will allow the user to have an input list with more than 4 items (with the latter elements being summed as expected).  In other words, this would pass the list:as well.
Form the key from [:3] so that you get the first 3 elements.


Answer URL
