Natural Text
Possible Duplicate:Python passing list as argument I looked for many topics about that, but I can't understand what happen really.I have this code:and the result is:I can't understand how the Lista1 was modified and Lista2 not. However before test the code, I thought that Lista1 and Lista2 would stay unmodified because they are global variables.
When you do L1.append(elemento) you are calling a method that actually changes the list named by the variable L1. All the other commands setting the values of L1 and L2 are actually just creating new names for new variables.This version doesn’t change anything:While this one does:However there is a tricky matter with L += [2] which is not exactly the same as L = L + 2. The Python Language Reference  section on Augmented assignment statements explains the difference: An augmented assignment expression like x += 1 can be rewritten as x = x + 1 to achieve a similar, but not exactly equal effect. In the augmented version, x is only evaluated once. Also, when possible, the actual operation is performed in-place, meaning that rather than creating a new object and assigning that to the target, the old object is modified instead.”
Lists are passed by reference in Python. Lista1 is modified because you directly call .append:Lista2 is not modified because you did not modify the list. You used the addition operator, L2 = L2 + [4], which does not modify L2. Instead, it creates a new list and returns the result.If you Google the term "pass by reference" you should be able to find some good explanatory examples in Python.
There are two different things happening in your function:To expand on the comments I added inline:inside altera, the variable L1 is whatever you passed in (so it is Lista1). It isn't a copy, a new list with the same contents - it refers to the same actual objectwhen you assign L2 = L2 + [4] you do two things:create a new list with the value L2 + [4]set L2 to point to this new list, instead of whatever you passed inIf we re-name the variable it becomes explicit, and works exactly the same:Alternatively, if you want to modify the original L2 in place (ie, to actually modify Lista2), you would doNote the last line still means Lista3 will be a different list object to Lista2, but it will have the same values. If you just return L2, the Lista3 will be identical with L2, so they'll be two names for the same list object.If you want to prevent this behaviour, you can call altera like this:now, inside altera, it will be working on its own copies of the arguments, and can't affect the original Lista1 and Lista2.
When you assigned a new value to the name L2 with the L2 = L2 + [4] statement, it no longer refers to Lista2. Most of your other statements change the value of the objects to which they already refer.


Answer URL
