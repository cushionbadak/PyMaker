Natural Text
Questions arise when I type in these expressions to Python 3.3.0It appears as though it takes the approximate floating point (-3.33)? and rounds down either way in integer division but in the modulo operation it does something totally different. It seems like it returns the remainder +/-1 and only switches the sign depending on where the negative operand is. I am utterly confused, even after looking over other answers on this site! I hope someone can clearly explain this too me! The book says hint: recall this magic formula a = (a//b)(b)+(a%b) but that doesn't seem to clear the water for me at all. -Thanks in advance!Edit: Those are just my personal assessments of what happens (above), I know, I'm completely off! 
The integer division there is just taking the floor of the number obtained at the end.(Why it floors)The modulo operation on the other hand is following the mathematical definition.
Magic formula: a = (a // b) * b + (a % b)a: -10b: 3a // b: -4a % b: 2Substitute in magic formula: -10 = -4 * 3 + 2 = -12 + 2 = -10a: 10b: -3a // b:  -4a % b: -2In magic formula: 10 = -4 * -3 - 2 = 12 - 2 = 10So the magic formula seems to be correct.If you define a // b as floor(a / b) (which it is), a % b should be a - floor(a / b) * b. Let's see:a: -10b: 3a % b = a - floor(a / b) * b = -10 - floor(-3.33) * 3 = -10 + 4 * 3 = 2Â The fact that a // b is always floored is pretty easy to remember (please read Cthulhu's first link, it's an explanation by the creator of Python). For negative a in a % b.. try to imagine a table of numbers that starts at 0 and has b columns:If a is the number in a cell, a % b would be the column number:Now extend the table back in the negatives:-10 % 3 would be 2. Negative a in a % b would come up in these sorts of context. a % b with negative b doesn't come up much.
A simple rule: for a % b = c, if c is not zero, then should have the same sign as b.And apply the magic formula:10 % -3 = -2 => 10 // -3 = (10 - (-2)) / (-3) = -4-10 % 3 = 2 => -10 // 3 = (-10 - 2) / 3 = -4-10 % -3 = -1 => -10 // -3 = (-10 - (-1)) / (-3) = 3
OK, so I did some digging and I think that the problem isn't Python, but rather the Modulo function. I'm basing this answer off of http://mathforum.org/library/drmath/view/52343.html10 % 3 Uses the highest multiple of 3 that is LESS THAN 10. In this case, 9. 10 - 9 = 1-10 % 3 does the same thing. It's still looking for a multiple of 3 that is LESS THAN -10. In this case, -12. (-10) - (-12) = 2


Answer URL
