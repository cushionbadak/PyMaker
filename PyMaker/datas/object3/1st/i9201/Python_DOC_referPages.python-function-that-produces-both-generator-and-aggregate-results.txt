Natural Text
What is the Pythonic way to make a generator that also produces aggregate results? In meta code, something like this (but not for real, as my Python version does not support mixing yield and return):As I see it, I could:Not make produce() a generator, but pass it a callback function to call on every item. With every yield, also yield the aggregate results up until now. I'd rather not calculate the intermediate results with every yield, only when finishing. Send a dict as argument to produce() that will be populated with the aggregate results. Use a global to store aggregate results.All of them don't seem very attractive...NB. total is a simple example, my actual code requires complex aggregations. And I need intermediate results before produce() finishes, hence a generator.
Maybe you shouldn't use a generator but an iterator.Maybe better to see this with an example:
you can use enumerate to count stuff, for example(notice the start value of the enumerate)for more complex stuff, you can use the same principle, make produce a generator that yield both values and ignore one in the iteration and use it later when finished.other alternative is passing a modifiable object, for examplein either case the result is the same for this example
Am I missing something? Why not:


Answer URL
https://docs.python.org/3/library/functions.html#enumerate
