Natural Text
I always thought comparisons were the fastest operation a computer could execute. I remember hearing it on a presentation from D. Knuth where he'd write loops in descending order "because comparison against 0 is fast". I also read that multiplications should be slower than additions here.I'm surprised to see that, in both Python 2 and 3, testing under both Linux and Mac, comparisons seem to be much slower than arithmetic operations.Could anyone explain why?And under python 3:
This is happening due to Constant Folding in the Peep Hole optimizer within Python compiler.Using the dis module, if we break each of the statements to look inside how they are being translated at machine level, you will observe that all operators like inequality, equality etc are first loaded into memory and then evaluated. However, all expressions like multiplication, addition etc are calculated and loaded as a constant into memory.Overall, this leads to a lesser number of execution steps, making the steps faster: 
As others have explained, this is because Python's peephole optimiser optimises arithmetic operations but not comparisons.Having written my own peephole optimiser for a Basic compiler, I can assure you that optimising constant comparisons is just as easy as optimising constant arithmetic operations. So there is no technical reason why Python should do the latter but not the former.However, each such optimisation has to be separately programmed, and comes with two costs: the time to program it, and the extra optimising code taking up space in the Python executable. So you find yourself having to do some triage: which of these optimisations is common enough to make it worth the costs?It seems that the Python implementers, reasonably enough, decided to optimise the arithmetic operations first. Perhaps they will get round to comparisons in a future release.
A quick disassambling reveals that the comparison involves more operations. According to this answer, there is some precalculation done by the "peephole optimiser" (wiki) for multiplication, addition, etc., but not for the comparison operators:
Like others have commented - it is due to the peep hole optimizer which pre-computes the results of 2*3 (6). As the dis showsBut try this - it will disable the optimizer from pre-computing the resultsIf you time these functions the compare will be faster.
For python case the above answers are correct.  For machine code things a bit more complicated.  I assume we are talking about integer operations here, with floats and complex objects none of the below will apply.  Also, we assume that the values you are comparing are already loaded into registers.  If they are not fetching them from wherever they are could take 100 of times longer than the actual operationsModern CPUs have several ways to compare two numbers.  Very popular ones are doing XOR a,b if you just want to see if two values are equal or CMP a,b if you want to know the relationship between the values ( less, greater, equal, etc ).  CMP operation is just a subtraction with the result thrown away because we are only interested in post-op flags.Both of these operations are of depth 1, so they could be executed in a single CPU cycle.  This is as fast as you can go.   Multiplication is a form of repeated additions so the depth of the operation is usually equal to the size of your register.  There are some optimizations that could be made to reduce the depth, but generally multiplication is one of the slower operations that CPU can perform.However, multiplying by 0,1 or any power of 2 could be reduced to shift operation. Which is also depth one operation.  So it takes the same time as comparing two numbers.  Think about decimal system,  you can multiply any number by 10, 100, 1000 by appending zeros at the end of the number.   Any optimizing compiler will recognize this type of multiplication and use the most efficient operation for it.  Modern CPUs are also pretty advanced, so they can perform same optimization in the hardware by counting how many bits are set in any of the operands.  And if it's just one bit the operation will be reduced to the shift.So in your case multiplying by 2 is as fast as comparing two numbers.  As people above pointed out any optimizing compiler will see that you are multiplying two constants, so it will replace just replace the function with returning a constant.
Wow, The answer by @mu ç„¡ blew my mind! However, it is important not to generalize when deriving your conclusions... You are checking the times for CONSTANTS not variables. For variables, multiplication seems to be slower than comparison.Here is the more interesting case, in which the numbers to be compared are stored in actual variables...The result gives:And order is restored in the universe ;)For completeness, lets see some more cases... What about if we have one variable and one constant?what happens with bools?:D Now this is interesting, it seems boolean and is faster than ==. However all this would be ok as the Donald Knuth would not loose his sleep, the best way to compare would be to use and...In practice, we should check numpy, which may be even more significant...Again, same behavior...So I guess, one can benefit by using instead for == in general,at least in Python 2 (Python 2.7.11 |Anaconda 2.4.1 (64-bit)| (default, Feb 16 2016, 09:58:36) [MSC v.1500 64 bit (AMD64)]), where I tried all these...


Answer URL
https://docs.python.org/3/library/dis.html
