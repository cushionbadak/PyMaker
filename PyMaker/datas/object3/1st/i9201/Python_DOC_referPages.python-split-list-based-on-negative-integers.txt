Natural Text
I have a list say l = [1,5,8,-3,6,8,-3,2,-4,6,8]. Im trying to split it into sublists of positive integers i.e. the above list would give me [[1,5,8],[6,8],[2],[6,8]]. I've tried the following:With this I can get the 1st sublist  ( [1,5,8] ) and the index number of the 1st negative integer at 3. Now if I run my function again and pass it l[index+1:], I cant get the next sublist and assume that index will be updated to show 6. However i cant, for the life of me cant figure out how to run the function in a loop or what condition to use so that I can keep running my function and giving it l[index+1:] where index is the updated, most recently encountered position of a negative integer. Any help will be greatly appreciated
You need to keep track of two levels of list here - the large list that holds the sublists, and the sublists themselves. Start a large list, start a sublist, and keep appending to the current sublist while i is non-negative (which includes positive numbers and 0, by the way). When i is negative, append the current sublist to the large list and start a new sublist. Also note that you should handle cases where the first element is negative or the last element isn't negative.The result:
Since somelist never changes, rerunning index will always get index of the first instance of an element, not the one you just reached. I'd suggest looking at enumerate to get the index and element as you loop, so no calls to index are necessary.That said, you could use the included batteries to solve this as a one-liner, using itertools.groupby:Still worth working through your code to understand it, but the above is going to be fast and fairly simple.
This code makes use of concepts found at this URL:Python list comprehension- "pop" result from original list?Applying an interesting concept found here to your problem, the following are some alternatives to what others have posted for this question so far.  Both use list comprehensions and are commented to explain the purpose of the second option versus the first.  Did this experiment for me as part of my learning curve, but hoping it may help you and others on this thread as well:What's nice about these is that if your input list is very very large, you won't have to double your memory expenditure to get the job done.  You build one up as you shrink the other down.This code was tested on Python 2.7 and Python 3.6:It produces result sets like this (on iPython Jupyter Notebooks):[1, 5, 8, 6, 9, 2, 6, 7, 999, 888][-1, -43, -7, -5, -4, -3][1, 5, 8, 6, 8, 2, 6, 8][-4, -3, -3]Here is another version that also uses list comprehensions as the work horse, but functionalizes the code in way that is more read-able (I think) and easier to test with different numeric lists.  Some will probably prefer the original code since it is shorter:Final Thoughts:Link provided earlier had a number of ideas in the comment thread:It recommends a Google search for the "python bloom filter library" - this sounds promising from a performance standpoint but I have not yet looked into itThere is a post on that thread with 554 up-voted, and yet it has at least 4 comments explaining what might be faulty with it.  When exploring options, it may be advisable to scan the comment trail and not just review what gets the most votes.  There are many options proposed for situations like this.
Just for fun you can use re too for a one liner.Output:[[1, 5, 8], [6, 8], [2], [6, 8]]


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.groupby
