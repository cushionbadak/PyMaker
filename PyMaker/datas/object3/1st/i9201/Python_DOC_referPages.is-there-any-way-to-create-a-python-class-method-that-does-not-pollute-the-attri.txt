Natural Text
I want to provide a method that can be used on a Python 2.7 class object, but does not pollute the attribute namespace of its instances. Is there any way to do this?
You could subclass the classmethod descriptor:This is how it would behave:This desugars to the descriptor call (rather, it is invoked by the default implementation of __getattribute__):Required reading: Data Model â€” Implementing Descriptors and Descriptor HowTo Guide.
ugh is not in the namespace:but the rules for attribute lookup fall back to the type of the instance for missing names. You can override Foo.__getattribute__ to prevent this.This produces:You must use __getattribute__, which is called unconditionally on any attribute access, rather than __getattr__, which is only called after the normal lookup (which includes checking the type's namespace) fails.
Yes, you can create the method in the metaclass.Note that metaclasses are a power feature, and their use is discouraged if unnecessary.  In particular, multiple inheritance requires special care if the parent classes have different metaclasses.
Python has quasi-private variables that use name-munging to reduce accidental access. Methods and object variables of the form __name are converted to _ClassName__name. Python automatically changes the name when compiling methods on the class but doesn't change the name for subclasses.I can use the private method in a classBut not outside the classOr in subclasses


Answer URL
https://docs.python.org/3/reference/datamodel.html#implementing-descriptors
https://docs.python.org/3/howto/descriptor.html
https://docs.python.org/3/tutorial/classes.html#private-variables
