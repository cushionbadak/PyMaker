Natural Text
QuestionThe standard library clearly documents how to import source files directly (given the absolute file path to the source file), but this approach does not work if that source file uses implicit sibling imports as described in the example below.How could that example be adapted to work in the presence of implicit sibling imports?I already checked out this and this other Stackoverflow questions on the topic, but they do not address implicit sibling imports within the file being imported by hand.Setup/ExampleHere's an illustrative exampleDirectory structure:app.py:lib.py:implicit_sibling_import.py:Running python folder/implicit_sibling_import.py with the if __name__ == '__main__': block commented out yields ISI says: world in Python 3.6.But running python directory/app.py yields:WorkaroundIf I add import sys; sys.path.insert(0, os.path.dirname(isi_path)) to app.py, python app.py yields world as intended, but I would like to avoid munging the sys.path if possible.Answer requirementsI'd like python app.py to print ISI says: world and I'd like to accomplish this by modifying the path_import function.I'm not sure of the implications of mangling sys.path. Eg. if there was directory/requests.py and I added the path to directory to the sys.path, I wouldn't want import requests to start importing directory/requests.py instead of importing the requests library that I installed with pip install requests.The solution MUST be implemented as a python function that accepts the absolute file path to the desired module and returns the module object.Ideally, the solution should not introduce side-effects (eg. if it does modify sys.path, it should return sys.path to its original state). If the solution does introduce side-effects, it should explain why a solution cannot be achieved without introducing side-effects.PYTHONPATHIf I have multiple projects doing this, I don't want to have to remember to set PYTHONPATH every time I switch between them. The user should just be able to pip install my project and run it without any additional setup.-mThe -m flag is the recommended/pythonic approach, but the standard library also clearly documents How to import source files directly. I'd like to know how I can adapt that approach to cope with implicit relative imports. Clearly, Python's internals must do this, so how do the internals differ from the "import source files directly" documentation?
The easiest solution I could come up with is to temporarily modify sys.path in the function doing the import:This should not cause any problems unless you do imports in another thread concurrently. Otherwise, since sys.path is restored to its previous state, there should be no unwanted side effects.Edit:I realize that my answer is somewhat unsatisfactory but, digging into  the code reveals that, the line spec.loader.exec_module(module) basically results in exec(spec.loader.get_code(module.__name__),module.__dict__) getting called. Here spec.loader.get_code(module.__name__) is simply the code contained in lib.py. Thus a better answer to the question would have to find a way to make the import statement behave differently by simply injecting one or more global variables through the second argument of the exec-statement. However, "whatever you do to make the import machinery look in that file's folder, it'll have to linger beyond the duration of the initial import, since functions from that file might perform further imports when you call them", as stated by @user2357112 in the question comments.Unfortunately the only way to change the behavior of the import statement seems to be to change sys.path or in a package __path__. module.__dict__ already contains __path__ so that doesn't seem to work which leaves sys.path (Or trying to figure out why exec does not treat the code as a package even though it has __path__ and __package__ ... - But I don't know where to start - Maybe it has something to do with having no __init__.py file).Furthermore this issue does not seem to be specific to importlib but rather a general problem with sibling imports.Edit2: If you don't want the module to end up in sys.modules the following should work (Note that any modules added to sys.modules during the import are removed):
add to the PYTHONPATH environment variable the path your application is onAugment the default search path for module files. The format is the same as the shellâ€™s PATH: one or more directory pathnames  separated by os.pathsep (e.g. colons on Unix or semicolons on  Windows). Non-existent directories are silently ignored.on bash its like this:or run directly:
Make sure your root is in a folder that is explicitly searched in the PYTHONPATHUse an absolute import:from root.folder import implicit_sibling_import #called from app.py
The OP's idea is great, this work only for this example by adding sibling modules with proper name to the sys.modules, I would say it is the SAME as adding PYTHONPATH. tested and working with version 3.5.1.
Try:or run directly:Make sure your root is in a folder that is explicitly searched in the PYTHONPATH. Use an absolute import:


Answer URL
https://docs.python.org/3/library/importlib.html#importing-a-source-file-directly
https://docs.python.org/3/using/cmdline.html#cmdoption-m
https://docs.python.org/3/library/importlib.html#importing-a-source-file-directly
https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH
https://docs.python.org/3/reference/import.html#the-module-cache
