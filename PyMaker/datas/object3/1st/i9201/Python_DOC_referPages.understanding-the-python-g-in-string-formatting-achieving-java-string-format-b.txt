Natural Text
In Java:This prints 3.0e+09In Python 2.7, if I run this codeI getHuh? It looks like the precision (.2) argument is treated totally differently in Python's %g than in Python's %f, Python's %e, or Java's %g. Here's the doc (my emphasis):General format. For a given precision p >= 1, this rounds the number to p significant digits and then formats the result in either fixed-point format or in scientific notation, depending on its magnitude.The precise rules are as follows: suppose that the result formatted with presentation type 'e' and precision p-1 would have exponent exp. Then if -4 <= exp < p, the number is formatted with presentation type 'f' and precision p-1-exp. Otherwise, the number is formatted with presentation type 'e' and precision p-1. In both cases insignificant trailing zeros are removed from the significand, and the decimal point is also removed if there are no remaining digits following it.Positive and negative infinity, positive and negative zero, and nans, are formatted as inf, -inf, 0, -0 and nan respectively, regardless of the precision.A precision of 0 is treated as equivalent to a precision of 1. The default precision is 6.WTF? Is there any way to prevent those trailing zeros from being removed? The whole point of string formatting is to achieve some consistency, e.g. for text alignment.Is there any way to get the Java behavior (essentially the number of significant digits to the right of the decimal point) without having to rewrite the whole thing from scratch?
The formatting that python does is more consistent with C's printf style formatting, which also drops trailing zeros for the g conversion. Since python's reference implementation is in C, why should it be consistent with Java in this case?When using the % operator for string formatting, the relevant documentation is String Formatting Operations, which has some differences to the one you linked to, notably that it allows the # alternate form for g:The alternate form causes the result to always contain a decimal point, and trailing zeroes are not removed as they would otherwise be.The precision determines the number of significant digits before and after the decimal point and defaults to 6.So in your case:This is different from what is allowed by str.format(), where # is used to enable prefixes for binary, octal or hexadecimal output (at least in python2, this was changed in python3).
With the format method, you can do something like this:Output:There are two parts to it that might not be so well known.1. Parametrizing the string formattingIn addition to simple formatting:and formatting with more detailed specification of the result:you can use keyword arguments in formatthat you can access in the string :You can use these also for the format specification itself:2. The if expressionIn addition to the if statement there is an if expression, a.k.a. ternary operator.So, this expression:is equivalent to this statement:Putting both together yields something like this:


Answer URL
https://docs.python.org/3/reference/expressions.html#conditional-expressions
