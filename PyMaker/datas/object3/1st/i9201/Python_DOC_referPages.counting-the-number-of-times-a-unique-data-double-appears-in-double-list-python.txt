Natural Text
Say I have a double list in python [[],[]]:I want to count how many times doublelist[0][0] & doublelist[1][0] = all, the appear in the dual list. With the second [] being the index.For example you see one count of it at doublelist[0][0] doublelist[1][0] and another at doublelist[0][6] doublelist[1][6].What code would I use in Python 3 to iterate through doublelist[i][i] grab each value set ex. [["all"],["the"]] and also an integer value for how many times that value set exists in the list.Ideally I'd like to output it to a triple list triplelist[[i],[i],[i]] that contains the [i][i] value and the integer in the third [i].Example code:Output:etc...Also it would preferably skip duplicates so there wouldn't be 2 indexes in the list where [i][i][i] = [[all],[the],[2]] since there are 2 instances in the original list ([0][0] [1][0] & [0][6] [1][6]). I just want all unique dual sets of words and the amount of times they appear in the original text.The purpose of the code is to see how often one word follows another word in a given text. It's for building essentially a smart Markov Chain Generator that weights word values. I already have the code to break the text into a dual list that contains the word in the first list and the following word in the second list for this purpose.Here is my current code for reference (the problem is after I initialize wordlisttriple, I don't know how to make it do what I described above after that):Any advice would be greatly appreciated. If I'm going about this the wrong way and there is an easier method to accomplish the same thing, that would also be amazing. Thank you!
Assuming you already have the text parsed to list of words you can just create iterator that starts from second word, zip it with words and run it through Counter:Output:In above nxt is an iterator that iterates over the word list. Since we want it to start from second word we pull one word out with next before using it:Then we pass the original list and iterator to zip that will return iterable of tuples where each tuple has one item from both:Finally the output from zip is passed to Counter that counts each pair and returns dict like object where keys are pairs and values are counts:
So, originally I was going to go with a straightforward approach to generating ngrams:But I got inspired by niemmi to write what seems like a more efficient approach, than is again, generalizable to higher order ngrams:So, observe:And of course, it still works for what you want to accomplish:
If you are looking for only all and the word ,this could be helpful to you.Code : Output :


Answer URL
https://docs.python.org/3/library/collections.html#collections.Counter
