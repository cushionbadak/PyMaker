Natural Text
I have class Count which takes 3 parameters including self, mystart and myend. It should count from mystart until myend (also reversed)  using magic methods __iter__, __next__ and __reversed__.  I have implemented all three magic methods. But I am still not sure whether it is the right way to implemnet next and reversed methods. Is it possible that I can call built-in functions next and reversed inside my  __next__ and __reversed__ methods or is there any pythonic way?
Now I have done it using yield statement. @jedwards thanks for your tipp.
You are mixing up Iterators and Iterables:Iterators:Keep a state associated with their current iteration progressImplement __next__ to get the next stateImplement __iter__ to return themselves.Iterables:Contain (or define with some rule) a collection of elements that can be traversedImplement __iter__ to return an iterator that can traverse the elementscan implement __reversed__ to return an iterator that goes backwards.The __reversed__ magic method is:Called (if present) by the reversed() built-in to implement reverse  iteration. It should return a new iterator object that iterates over  all the objects in the container in reverse order.So you probably don't want to implement an iterator that can be __reversed__ mid iteration, for example the implementation in your answer means that this code:Will cause an infinite loop, the output is just this pattern repeated:the reason for this is because both for loops are changing self.current in opposite directions, the outer loop will increment it by 1 then the inner loop will set it to self.myend and lower it back to 0, then the process repeats.The only way to properly implement all three magic methods is to use two classes, one for the iterator and one for the iterable:


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__reversed__
