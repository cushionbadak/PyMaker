Natural Text
I'm trying to build a counter in python with the property of closure. The code in the following works:However when I change the list CNT to a var, it did not work:when I print the closure property of an instance, I found the __closure__ of the second case is none:Just wondering why the index in outer function has to be a list?Thanks for the answers! Found the docs which clearly explained this problemhttps://docs.python.org/3/faq/programming.html#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value
Python determines the scope of a name by looking at name binding behaviour; assignment is one such behaviour (function parameters, importing, the target in for target ... or while .. as target are other examples). A name you bind to in a function is considered local. See the Naming and Binding section of the reference documentation.So the name x in your second example is a local variable, because you assigned directly to it:In fact, because you never gave that x a local value, you'll get an exception when you try to use that function; the local name is unbound when you try to read it:In your first example no such binding takes place; you are instead altering the contents of CNT, what that name references is not altered.If you are using Python 3, you can override the decision to make a name local, by using a nonlocal statement:By making x non-local, Python finds it in the parent context and creates a closure for it again.nonlocal is new in Python 3; in Python 2 you are limited to tricks like using a mutable list object to evade the binding rule. Another trick would be to assign the counter to an attribute of the nested function; again, this avoids binding a name in the current scope:
It doesn't have to be a list, it just has to be an mutable object which you mutate, not reassign.From the docs:If a variable is assigned a value anywhere within the function’s body, it’s assumed to be a local unless explicitly declared as global.Thus, in your second example, x is considered local (to the inner function), and, after your first assignment, you're shadowing the outer 'x'.On the other hand, in the first example (since you don't assign a value to CNT) it operates on the CNT defined in the outer function.


Answer URL
https://docs.python.org/3/faq/programming.html#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value
https://docs.python.org/3/reference/executionmodel.html#naming-and-binding
https://docs.python.org/3/reference/simple_stmts.html#the-nonlocal-statement
https://docs.python.org/3/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python
