Natural Text
This question already has an answer here:what does `super()` in `__new__`                    3 answers                I've read the documentation for super() multiple times but I still don't get what the two argument version returns.Return a proxy object that delegates method calls to a parent or  sibling class of type. This is useful for accessing inherited methods  that have been overridden in a class.What is a proxy object?parent or sibling? If the second argument is an object, isinstance(obj, type) must be  true. If the second argument is a type, issubclass(type2, type) must  be true (this is useful for classmethods).That's all nice but what is returned? And what does the syntax super(a,b) mean? In context of __new__, Typical implementations create a new instance of the class by invoking  the superclassâ€™s __new__() method using super(currentclass,  cls).__new__(cls[, ...]) with appropriate arguments and then modifying  the newly-created instance as necessary before returning it.super(currentclass, cls).__new__(cls[, ...])If currentclass is equal to cls, you have super(currentclass, currentclass)What does that return? What does that syntax mean?How does this statement return an instance of cls so that __init__ will be called on the returned object?
The answer to "what does super return" isn't anything like "it returns a list" or "it returns a modified copy of the second object". super returns an object of type super, a type designed specifically to have the qualities the documentation says it has.Perhaps it would help to show a pure-Python implementation of super. If super wasn't written in C, it would look basically like this:Now you can see that super(a, b) constructs a super object, and super(a, b).whatever calls the __getattribute__ method of that super object to search the method resolution order of the second argument for the attribute we want. The attribute lookup procedure for b.whatever is very similar, just without chopping off the first part of the MRO, and checking the instance dict if b isn't a class.
You should definitely watch Raymond Hettinger's talk from PyCon 2015, Super is considered super!But if not, why not add a bunch of print statements to answer your questions?That produces the following output (with added commentary):Apparently, super returns a class of type super. Which, according to the documentation, is a proxy object. A proxy, by definition, is a replacement for something else. In this case, the proxy is a replacement for getting Mom. You can see that when we actually call the __init__ function, that Mom's init function is called.You'll notice here, that Dad's init function isn't called. That's because, if you watch Raymond's talk, you'll know that super looks for the function on parents from left to right.You see the same behavior repeated hereIf you change the order on Sister, to Dad, Mom, you'll see that those calls change:To sum up:A proxy is something that stands in for something else. In our case, super is a proxy for both Mom & Dad, depending on which order they're inherited from.Honestly, I couldn't get any kind of meaningful sibling thing to work. I'm not sure when you'd even need that anyway.An instance of super is returned.That would really only work if you had something that inherited from type, e.g. super(type, type), because you need an instance of that type. object would also work because:print(isinstance(object, object))print(isinstance(type, type))print(isinstance(object, type))print(isinstance(type, object))There's some pretty involved magic going on around that process.Are you asking how functions return things? Because new is a function - and it returns or it doesn't. object.__new__ returns something. I'm not sure where the actual source code is for that function, or I could point you there if you were interested in the exact mechanism.


Answer URL
https://docs.python.org/3/library/functions.html#super
https://docs.python.org/3/reference/datamodel.html#object.__new__
https://docs.python.org/3/library/functions.html#super
