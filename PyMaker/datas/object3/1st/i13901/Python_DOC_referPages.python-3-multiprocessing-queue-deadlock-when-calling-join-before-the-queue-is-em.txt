Natural Text
I have a question understanding the queue in the multiprocessing module in python 3This is what they say in the programming guidelines:Bear in mind that a process that has put items in a queue will wait beforeterminating until all the buffered items are fed by the “feeder” thread tothe underlying pipe.  (The child process can call theQueue.cancel_join_threadmethod of the queue to avoid this behaviour.)This means that whenever you use a queue you need to make sure that allitems which have been put on the queue will eventually be removed before theprocess is joined.  Otherwise you cannot be sure that processes which haveput items on the queue will terminate.  Remember also that non-daemonicprocesses will be joined automatically.An example which will deadlock is the following:A fix here would be to swap the last two lines (or simply remove thep.join() line).So apparently, queue.get() should not be called after a join().However there are examples of using queues where get is called after a join like:I've run this program and it works (also posted as a solution to the StackOverFlow question Python 3 - Multiprocessing - Queue.get() does not respond).Could someone help me understand what the rule for the deadlock is here?
The queue implementation in multiprocessing that allows data to be transferred between processes relies on standard OS pipes.OS pipes are not infinitely long, so the process which queues data could be blocked in the OS during the put() operation until some other process uses get() to retrieve data from the queue.For small amounts of data, such as the one in your example,  the main process can join() all the spawned subprocesses and then pick up the data.  This often works well, but does not scale, and it is not clear when it will break.But it will certainly break with large amounts of data.  The subprocess will be blocked in put() waiting for the main process to remove some data from the queue with get(), but the main process is blocked in join() waiting for the subprocess to finish.  This results in a deadlock.Here is an example where a user had this exact issue.  I posted some code in an answer there that helped him solve his problem.
Don't call join() on a process object before you got all messages from the shared queue.I used following workaround to allow processes to exit before processing all its results:It can be shortened but I left it longer to be more clear for newbies.Here resultQueue is the multiprocess.Queue that was shared with multiprocess.Process objects. After this block of code you will get the result array with all the messages from the queue.The problem is that input buffer of the queue pipe that receive messages may become full causing writer(s) infinite block until there will be enough space to receive next message. So you have three ways to avoid blocking:Increase the multiprocessing.connection.BUFFER size (not so good)Decrease message size or its amount (not so good)Fetch messages from the queue immediately as they come (good way)


Answer URL
https://docs.python.org/3/library/multiprocessing.html#all-start-methods
