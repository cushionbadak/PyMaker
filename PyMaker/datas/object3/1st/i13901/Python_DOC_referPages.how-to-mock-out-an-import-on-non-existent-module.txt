Natural Text
Here is the tracebackQ1. Why is this error thrown? They are <class type='MagicMock>Q2. How do I pause the mocking so that the first line will pass if the error is fixed?From the docNormally the class attribute of an object will return its type.  For a mock object with a spec class returns the spec class  instead. This allows mock objects to pass isinstance tests for the  object they are replacing / masquerading as: Thanks
Don't use isinstance, instead check for the existence of the say_it method. If the method exists, call it:This is a better design anyway: relying on type information is much more brittle.
IMHO this is a good question and saying "don't use isinstance, use duck typing instead" is a bad answer. Duck typing is great, but not a silver bullet. Sometimes isinstance is necessary, even if it is not pythonic. For instance, if you work with some library or legacy code that isn't pythonic you must play with isinstance. It is just the real world and mock was designed to fit this kind of work.In the code the big mistake is when you write:From patch documentation we read (emphasize is mine):Inside the body of the function or with statement, the target is patched with a new object.That means when you patch the HelloWorld class object the reference to HelloWorld will be replaced by a MagicMock object for the context of the test_mock() function. Then, when i_call_hello_world() is executed in if isinstance(hw_obj, HelloWorld): HelloWorld is a MagicMock() object and not a class (as the error suggests).That behavior is because as a side effect of patching a class reference the 2nd argument of isinstance(hw_obj, HelloWorld) becomes an object (a MagicMock instance). This is neither a class or a type. A simple experiment to understand this behavior is to modify i_call_hello_world() as follows:The error will disappear because the original reference to HelloWorld class is saved in HelloWorld_cache when you load the module. When the patch is applied it will change just HelloWorld and not HelloWorld_cache.Unfortunately, the previous experiment doesn't give us any way to play with cases like yours because you cannot change the library or legacy code to introduce a trick like this. Moreover, these are that kind of tricks that we would like to never see in our code.The good news is that you can do something ,but you cannot just patch the HelloWord reference in the module where you have  isinstace(o,HelloWord) code to test. The best way depends on the real case that you must solve. In your example you can just create a Mock to use as HelloWorld object, use spec argument to dress it as HelloWorld instance and pass the isinstance test. This is exactly one of the aims for which spec is designed. Your test would be written like this:And the output of just unittest part is
Michele d'Amico provides the correct answer in my view and I strongly recommend reading it. But it took me a while a grok and, as I'm sure I'll be coming back to this question in the future, I thought a minimal code example would help clarify the solution and provide a quick reference:
You can do it by being inherited from the MagicMock class and overriding the __subclasscheck__ method:And then you can use this class with the @patch decorator:That's it!Remarks:You MUST mock all classes which are compared using issubclass.Example:issubclass(class_1, ClassC) will cause an error {TypeError}issubclass() arg 1 must be a class because ClassC contains a default __issubclass__ method. And then we should handle the test like this:
I've been wrestling with this myself lately while writing some unit tests. One potential solution is to not actually try to mock out the entire HelloWorld class, but instead mock out the methods of the class that are called by the code you are testing. For example, something like this should work:


Answer URL
https://docs.python.org/3/library/unittest.mock.html#patch
