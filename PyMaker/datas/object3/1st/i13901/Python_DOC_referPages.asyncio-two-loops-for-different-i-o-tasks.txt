Natural Text
I am using Python3 Asyncio module to create a load balancing application. I have two heavy IO tasks:A SNMP polling module, which determines the best possible serverA "proxy-like" module, which balances the petitions to the selected server.Both processes are going to run forever, are independent from eachother and should not be blocked by the other one.I cant use 1 event loop because they would block eachother, is there any way to have 2 event loops or do I have to use multithreading/processing? I tried using asyncio.new_event_loop() but havent managed to make it work.
Answering my own question to post my solution:What I ended up doing was creating a thread and a new event loop inside the thread for the polling module, so now every module runs in a different loop. It is not a perfect solution, but it is the only one that made sense to me(I wanted to avoid threads, but since it is only one...). Example:Asyncio requires that every loop runs its coroutines in the same thread. Using this method you have one event loop foreach thread, and they are totally independent: every loop will execute its coroutines on its own thread, so that is not a problem.As I said, its probably not the best solution, but it worked for me.
The whole point of asyncio is that you can run multiple thousands of I/O-heavy tasks concurrently, so you don't need Threads at all, this is exactly what asyncio is made for. Just run the two coroutines (SNMP and proxy) in the same loop and that's it. You have to make both of them available to the event loop BEFORE calling loop.run_forever(). Something like this:I don't know the structure of your code, so the different modules might have their own infinite loop or something, in this case you can run something like this:Remember, both snmp and proxy needs to be coroutines (async def) written in an asyncio-aware manner. asyncio will not make simple blocking Python functions suddenly "async".In your specific case, I suspect that you are confused a little bit (no offense!), because well-written async modules will never block each other in the same loop. If this is the case, you don't need asyncio at all and just simply run one of them in a separate Thread without dealing with any asyncio stuff.
Asyncio event loop is a single thread running and it will not run anything in parallel, it is how it is designed. The closest thing which I can think of is using asyncio.wait.an alternate way is to use asyncio.gather() - it returns a future results from the given list of futures.
But I used that like this, but still its synchronous no async:if received value contains (name="calculator2") I wait for 5 seconds if not, just answer and write data immediately.But when test it, first send data to server with containing (name="calculator2") and next data without (name="calculator2"), but next data handles after 5 seconds of first is done and after that 2th data will be handled.its sequential. what it wrong with it?and the other way, how should I get client connected ip and port?
If the proxy server is running all the time it cannot switch back and forth. The proxy listens for client requests and makes them asynchronous, but the other task cannot execute, because this one is serving forever. If the proxy is a coroutine and is starving the SNMP-poller (never awaits), isn't the client requests being starved aswell?every coroutine will run forever, they will not endThis should be fine, as long as they do await/yield from. The echo server will also run forever, it doesn't mean you can't run several servers (on differents ports though) in the same loop.


Answer URL
https://docs.python.org/3/library/asyncio-protocol.html#tcp-echo-server-protocol
