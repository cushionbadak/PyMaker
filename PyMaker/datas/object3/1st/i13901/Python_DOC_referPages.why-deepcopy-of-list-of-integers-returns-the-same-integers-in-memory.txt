Natural Text
I understand the differences between shallow copy and deep copy as I have learnt in class. However the following doesn't make senseShouldn't print(a[0] is b[0]) evaluate to False as the objects and their constituent elements are being recreated at a different memory location in a deep copy? I was just testing this out as we had discussed this in class yet it doesn't seem to work.
The reason of this behavior is that Python optimize small integers so they are not actually in different memory location. Check out the id of 1, they are always the same:Reference from Integer Objects:The current implementation keeps an array of integer objects for all integers between -5 and 256, when you create an int in that range you actually just get back a reference to the existing object. So it should be possible to change the value of 1. I suspect the behaviour of Python in this case is undefined. :-)
The answer by Yu Hao is actually not correct. While it is true that Python has interned objects for small integers, it is not what causes that behaviour.Let's have a look at what happens when we use bigger integers.If we dig down in the copy module we find out that calling deepcopy with an atomic value defers the call to the function _deepcopy_atomic.So what is actually happening is that deepcopy will not copy an immutable value, but only return it.By example this is the case for int, float, str, function and more.


Answer URL
https://docs.python.org/3/c-api/long.html
