Natural Text
So, there exists an easy way to calculate the intersection of two sets via set.intersection(). However, I have the following problem:(Object is a base-class provided by my ORM that implements basic __hash__ and __eq__ functionality, which essentially adds every member of the class to the hash. In other words, the __hash__ returned will be a hash of every element of the class)At this stage, I would like to run a set intersection operation by .name only, to find, say, Person('Bar', -1).intersection(union_list) #= [Person("Bar", -1), Person("Bar", 22), Person("Bar", 24)]. (the typical .intersection() at this point would not give me anything, I can't override __hash__ or __eq__ on the Person class, as this would override the original set union (I think)What's the best way to do this in Python 2.x?EDIT: Note that the solution doesn't have to rely on a set. However, I need to find unions and then intersections, so it feels like this is amenable to a set (but I'm willing to accept solutions that use whatever magic you deem worthy, so long as it solves my problem!)
Sounds likeis what you want, since name is your unique key?
If you want the age to be irrelevant with respect to comparing, you should override __hash__() and __eq__() in Person although you have it in your Object.If you need this behaviour only in this (and similiar) contexts, you could create a wrapper object which contains the Person and behaves differently, such asand then do(untested)
I hate answering my own questions, so I'll hold off on marking this as the 'answer' for a little while yet.Turns out the way to do this is as follows:It's certainly dirty and it relies on types.MethodType, but it's less intensive than the best solution proposed so far (glglgl's solution) as my actual union_list can contain potentially in the order of thousands of items, so this will save me re-creating objects every time I run this intersection procedure.
How about:It might be faster to throw intersectnames at your ORM, in which case you wouldn't build dictionaries, just collect names in lists.
This is clunky, but...
You'll have to override __hash__ and the comparision methods if you want to use sets like this.If you don't, thenwill always be false.If your objects are managed by an ORM, then you'll have to check how it compares objects.Usually it only looks at the objects id and comparision only works if both objects are managed. If you try to compare an object you got from the ORM with an instance you created yourself before it's persisted to the db, then they are likely to be different. Anyway, an ORM shouldn't have problems with you supplying your own comparision logic.But if for some reasons you can't override __hash__ and __eq__, then you can't use sets for intersection and union with the original objects. You could:calculate the intersection/union yourselfcreate a wrapper class which is comparable:


Answer URL
https://docs.python.org/3/reference/datamodel.html#special-lookup
