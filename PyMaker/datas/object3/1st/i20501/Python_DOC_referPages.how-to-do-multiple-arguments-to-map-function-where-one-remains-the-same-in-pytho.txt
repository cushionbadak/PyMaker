Natural Text
Lets say we have a function add as followswe want to apply map function for an array The semantics are I want to add 2 to the every element of the array. But the map function requires a list in the third argument as well.Note: I am putting the add example for simplicity. My original function is much more complicated. And of course option of setting the default value of y in add function is out of question as it will be changed for every call.
One option is a list comprehension:More options:
The docs explicitly suggest this is the main use for itertools.repeat:Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for invariant parameters to the called function. Also used with zip() to create an invariant part of a tuple record. And there's no reason for pass len([1,2,3]) as the times argument; map stops as soon as the first iterable is consumed, so an infinite iterable is perfectly fine:In fact, this is equivalent to the example for repeat in the docs:This makes for a nice lazy-functional-language-y solution that's also perfectly readable in Python-iterator terms.
Use a list comprehension.If you really, really, really want to use map, give it an anonymous function as the first argument:
If you have it available, I would consider using numpy. It's very fast for these types of operations:This is assuming your real application is doing mathematical operations (that can be vectorized).
Map can contain multiple arguments, the standard way is In your question, it should be 
Sometimes I resolved similar situations (such as using pandas.apply method) using closuresIn order to use them, you define a function which dynamically defines and returns a wrapper for your function, effectively making one of the parameters a constant.Something like this:Then, add_constant(y) returns a function which can be used to add y to any given value:Which allows you to use it in any situation where parameters are given one at a time:editIf you do not want to have to write the closure function somewhere else, you always have the possibility to build it on the fly using a lambda function:
The correct answer is simpler than you think.Simply do:And change the implementation of add to take a tuple i.eThis can handle any complicated use case where both add parameters are dynamic.
If you really really need to use map function (like my class assignment here...), you could use a wrapper function with 1 argument, passing the rest to the original one in its body; i.e. :Dirty & ugly, still does the trick
I believe starmap is what you need:
To pass multiple arguments to a map function.Here q is function with multiple argument that map() calls.Make sure, the length of both the ranges i.e.
def func(a, b, c, d): return a + b * c % dmap(lambda x: func(*x), [[1,2,3,4], [5,6,7,8]])
Another option is:This format is very useful when calling multiple functions.
In :nums = [1, 2, 3]In :map(add, nums, [2]*len(nums))Out:[3, 4, 5]


Answer URL
https://docs.python.org/3/library/functions.html#map
https://docs.python.org/3/library/functions.html#zip
https://docs.python.org/3/library/functions.html#map
