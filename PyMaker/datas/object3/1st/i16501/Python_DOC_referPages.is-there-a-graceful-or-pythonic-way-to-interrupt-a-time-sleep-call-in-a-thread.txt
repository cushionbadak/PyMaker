Natural Text
The code below works the way I expect it to work, namely:there is a QThread ("Ernie") that counts from 1 to 8, sleeping for 1 second between countsthere is a gratuitous UI widget ("Bert")under normal operation, the program runs until both the thread finishes and the UI is closeda Ctrl-C keyboard interrupt will stop the program gracefully prior to normal completion.To do this, I had to break up the 1-second sleep into 50 millisecond chunks that check a flag.Is there a more Pythonic way to sleep in a thread for some amount of time (e.g. 1 second) but be interruptable by some flag or signal?I'd rather do this, and somehow cause a GracefulShutdown exception in the thread:full program;
I am not sure how Pythonic it is but it works. Just use a queue and use blocking get with a timeout. See the example below:
Normally, a SIGINT will interrupt a time.sleep call, but Python will only allow signals to received by the main thread of an application, so it can't be used here. I would recommend avoiding time.sleep if possible, and utilize a QTimer instead.Instead of having the run() method run a for loop with time.sleep, we start an event loop inside the thread, and use QTimer to do the desired printing at a set interval. This way, we can call bernie.exit() whenever we want the thread to shutdown, which will result in the bernie's event loop immediately shutting down.Edit:Here's an alternative way to implement this same idea that at least hides some of the complexity away, allowing the original for loop to be kept intact:The coroutine allows the decorated function to give control back to the Qt event loop for a given amount of time whenever a yield appears, and then resumes execution of the decorated method. Granted, this is really just shifting complexity from my original example, but it does hide it away from the real work you're trying to do in the thread.How it works:The approach is inspired by the coroutine implementations in asynchronous libraries such as Tornado and the asyncio module. While I didn't try to come up with something as robust as those, the idea is the same. Methods which we want to be able to interrupt are implemented as generators, and decorated with a decorator that knows how to call and receive responses from the generator in a way that allows pausing/resuming the generator properly. The flow when do_print is called is basically this:do_print() is called from run. This actually results in coroutine.wrapper being called.wrapper calls the real do_print, which returns a generator object. It passes that object to execute. execute calls next on the generator object. This results in do_print running until a yield is hit. Execution of do_print is then suspended.execute schedules do_print to resume execution. It does this by first determining when to schedule it, by either using the value yielded from the previous iteration of do_print that ran, or by defaulting to 0 (which schedules execution to immediately resume). It calls QTimer.singleShot to schedule itself to run again in timeout milliseconds, using a partial so it can pass the generator object along, too.Steps 3-4 repeat until do_print stops yielding, calls self.exit() and returns, at which point StopIteration is raised, and the coroutine decorator simply returns rather than scheduling another execute call.
My instinct would be to raise a signal with os.kill, but only the main thread ever receives signals, so Ernie can't be interrupted that way. The documentation suggests using locks instead.My thoughts here would be to create a lock that can only be accessed when it's time to kill Ernie. After the main thread creates both Bert and Ernie, a lock file is created and locked. Then, instead of sleeping for one second, Ernie will spend one full second attempting to get the lock. Once it's time for the program to close, you can release the lock, which Ernie will immediately get; this tells Ernie that it's time to shut down.Since you can't integrate signals and threads the way we'd like, here's another post talking about lock timeouts with threads:How to implement a Lock with a timeout in Python 2.7I couldn't tell you how Pythonic this solution is, since I'm still trying to get a grasp on what exactly being Pythonic entails. Once you start introducing threads, elegant code gets harder and harder to write, in any case.


Answer URL
https://docs.python.org/3/library/asyncio-task.html#coroutines
