Natural Text
According to the Python docs: "when defining __eq__(), one should also define __ne__() so that the operators will behave as expected". However, it appears that Python computes __ne__ as not __eq__ automatically:So what's the point of defining __ne__ if it's just going to be return not self.__eq__(other)? And furthermore, where is this behavior actually documented?EDITApparently it matters that I am using Python 3. In Python 2, I getBut the docs I referenced are the Python 3 docs. Were they just not updated?
Python 3 changed behaviour for the == case, see Python 3, What's New:!= now returns the opposite of ==, unless == returns NotImplemented.It was deemed a useful change.The fact that the documentation has not been updated is indeed a long standing bug.However, as a comment on the report points out, if you inherit from a class that already has defined __ne__, overriding just __eq__ is not enough and you'll also have to override the __ne__ method.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__ne__
https://docs.python.org/3/whatsnew/3.0.html#operators-and-special-methods
