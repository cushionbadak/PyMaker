Natural Text
Following this answer, I am using imp.new_module and exec to dynamically load a module and extract functions from it. However, when I store the module in a local variable, functions from it get broken. Here is an example:Executing this with Python 2.7.3 yields None: codepad. After uncommenting global mod line, making mod global, the function works as expected and prints 42: codepad. What am I missing? Why does the behaviour change when module is stored in a local variable?
The mod module is a local, and not referenced anywhere else. Like all other objects in Python, that means it is cleaned up when main exits. By making it a global instead, a reference to the module object is kept.When a module is cleaned up, all the globals are set to None (this is done to break reference cycles early, setting to None is an optimisation to prevent excessive rehashing due to dictionary resizing). The func object still has a reference to the module globals dictionary, and thus sees a bound to None now.The normal procedure of importing a module adds a reference to the module object in sys.modules, keeping the module alive until interpreter shutdown.(In Python 3.4, globals are no longer rebound to None (in most cases), as per Safe Object Finalization; see PEP 442).


Answer URL
https://docs.python.org/3/whatsnew/3.4.html#whatsnew-pep-442
