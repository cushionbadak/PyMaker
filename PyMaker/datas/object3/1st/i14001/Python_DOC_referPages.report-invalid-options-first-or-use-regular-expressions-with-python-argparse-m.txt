Natural Text
When using the argparse module in Python I am looking for a way to trap invalid options and report them better.The documentation at https://docs.python.org/3/library/argparse.html#invalid-arguments provides an example:However it is quite easy to trip this up as bad options are not reported first. For example:will report:When I would prefer it to report the more useful:Is it possible to achieve this?It seems to me a quite basic use case.When writing argument parsers directly I typically use a patternsuch that anything starting with a -- option prefix that is not a known option is rejected immediately. For example in bashI believe argparse uses regular expressions internally but I don't think they are accessible via add_argument()Is there any way to do the equivalent easily with argparse?
The short answer is that parse_args uses parse_known_args.  This method lets you handle unknown arguments like --gold.  As a result, argument type errors get raised before unknown arguments errors.I've added a solution that involves subclassing ArgumentParser and modifying a method deep in its calling stack.I'll try to outline parse_args as applied to your example.The first thing it does is categorize the strings as either O or A.  Put simply, ones that begin with - are O, others A.  It also tries to match the O ones with a defined argument.In your example, it finds OAA.  Regex is used to match this string against patterns defined by the argument nargs.  (if needed I can explain this step in more detail)--gold does not match; at some point (whether in this initial loop or later) it gets put into a extras list.  (I'll check the code for details).For the 2nd loop through the strings it alternately tries to handle postionals and optionals.It's when trying to match the 5 with starttime that your Action class raises the type error, which propagates up to printing the usage and exiting.  Because --gold is not defined, 5 is not consumed as an optional's argument.  Thus it gets parsed as the first positional string.  (Some kinds of optionals take 0 arguments, so it does not assume anything following an --... is an optionals argument).I think, that without the 5, the last string would match.  parse_known_args would return with --gold in the extras term.  parse_args uses parse_known_args but raises an error when extras is not empty.So in a sense the parser does detect both errors, but it's the starttime one that triggers the error message.  It waits till the end to complain about unrecognized --gold.As a general philosophy, argparse does not try to detect and present all errors.  It does not collect a list of errors to present in one final comprehensive message.I'll review the code to check the details.  I don't think you can easily change basic parsing pattern.  If I think of a way to force an earlier unrecognized option error, I'll edit this answer.def _parse_optional(self, arg_string): tries to classify an argv string.  If the string looks like a positional it returns None.  If it matches an Action option_string, it returns a tuple '(action, option_string, None)` with the matching action.  Finally if not match, it returns:I think that is what happens with your --gold.  Note the reason why it might still be a valid option.This function is called by collecting that 'AOO' pattern, as well a list of these tuples.During a 2nd loop it alternates between consuming positionals and optionals.  The function that consumes an optional is:As I wrote earlier, your --gold gets put on the extras list, while 5 remains on the list of arguments that can be parsed as positionals.The namespace and extras are passed on through parse_known_args to you, the user, or to parse_args.Conceivably you could subclass ArgumentParser and define a modified _parse_optional method.  It could raise an error instead of returning that (None, arg_string, None) tuple.producesSubclassing to provide custom action is good argparse (and Python) practice.If you want more consideration of this case by Python developers, consider writing a bug/issue  (at PEP is for more developed formal ideas).  But there is quite a backlog of argparse bugs/patches, and a lot of caution about backwards compatibility.http://bugs.python.org/issue?%40columns=id%2Cactivity%2Ctitle%2Ccreator%2Cassignee%2Cstatus%2Ctype&%40sort=-activity&%40filter=status&%40action=searchid&ignore=file%3Acontent&%40search_text=_parse_optional&submit=search&status=-1%2C1%2C2%2C3is a list of bug/issues that reference _parse_optional.  Possible changes include how ambiguous optionals are handled.  (I'll scan them to see if I'm forgetting anything.  A some of the patches are mine.)  But by using super, my suggested change is not affected by changes within the function.  It's affected only by changes in how the function is called and what it returns, which is much less likely to occur.  By filing your own issue, you at least put the developers on notice that someone depends on this interface.


Answer URL
https://docs.python.org/3/library/argparse.html#invalid-arguments
