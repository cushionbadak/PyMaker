Natural Text
I have written a Sudoku solver for very easy Sudoku problems in Python. How it works is by checking each empty square, and if there is only one possible number that is legal, then replace the empty square with that number. Once it has gone through the whole puzzle, if there are still more than 1 empty squares, it calls itself again with the new puzzle. The part where I am having problems is I want the solver to check at the end of each call if the puzzle is the same as it was at the beginning of the call, and if it has not changed that means that all remaining empty squares have more than 1 possible value, and therefore the solver should return False to indicate that the solver isn't capable of solving that particular puzzle. However, when I tried to implement this, the Solver only goes through the puzzle once and returns False. Here is my code:The getPossible() function returns a list of possible values and the length of the list.Here is the main() function:puzzle = [['0','2','0','1','7','8','0','3','0'],['0','4','0','3','0','2','0','9','0'],['1','0','0','0','0','0','0','0','6'],['0','0','8','6','0','3','5','0','0'],['3','0','0','0','0','0','0','0','4'],['0','0','6','7','0','9','2','0','0'],['9','0','0','0','0','0','0','0','2'],['0','8','0','9','0','1','0','6','0'],['0','1','0','4','3','6','0','5','0']]if Solver(puzzle):    print "Solved!"    for row in puzzle:        print ' '.join(row)else:    print "Failed!"
Your problem is that the line:Makes a reference to puzzle called oldpuzzel not a copy so they are always the same - you need to either copy the puzzle to oldpuzzle with copy.copy or more simply set a flag:and in the:Then check changed if it is False return it.
You are setting the reference of puzzle to oldpuzzle , hence if you do any changes to puzzle , it will reflect in oldpuzzle as well. and puzzle would always be equal to oldpuzzle.I do not think you need to set the puzzle to old puzzle (or you need to save the complete puzzle at the start).According to the logic, the number of 0 cells would never increase and a cell that is marked non-zero previously would never become marked 0 .Hence you can just store the count of 0s at the start, and then at the end check if the count of 0s has changed or not, if it has then good, otherwise return False.Example code -
The problem is that if oldpuzzle == puzzle will always be true because when oldpuzzle is created it doesn't become a copy of the puzzle list but rather a duplicate. This means that if you change puzzle then oldpuzzle will also change.One way to make oldpuzzle a copy of puzzle is to use the copy library. In this case it is required to make a deep copy of puzzle because it is a list with list in it. One way to do this is to use the deep copy function from the copy library. So the function would look something like this:


Answer URL
https://docs.python.org/3/library/copy.html?highlight=copy#copy.deepcopy
