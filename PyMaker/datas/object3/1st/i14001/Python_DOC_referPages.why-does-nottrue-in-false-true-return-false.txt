Natural Text
If I do this:That returns True. Simply because False is in the list.But if I do:That returns False. Whereas not(True) is equal to False:Why?
Operator precedence 2.x, 3.x. The precedence of not is lower than that of in. So it is equivalent to:This is what you want:As @Ben points out: It's recommended to never write not(True), prefer not True. The former makes it look like a function call, while not is an operator, not a function.
not x in y is evaluated as x not in yYou can see exactly what's happening by disassembling the code.  The first case works as you expect:The second case, evaluates to True not in [False, True], which is False clearly:What you wanted to express instead was (not(True)) in [False, True], which as expected is True, and you can see why:
Operator precedence. in binds more tightly than not, so your expression is equivalent to not((True) in [False, True]).
It's all about operator precedence (in is stronger than not). But it can be easily corrected by adding parentheses at the right place:writing:is the same like:which looks if True is in the list and returns the "not" of the result.
It is evaluating as not True in [False, True], which returns False because True is in [False, True] If you try You get the expected result.
Alongside the other answers that mentioned the precedence of not is lower than in, actually your statement is equivalent to :But note that if you don't separate your condition from the other ones, python will use 2 roles (precedence or chaining) in order to separate that, and in this case python used precedence. Also, note that if you want to separate a condition you need to put all the condition in parenthesis not just the object or value :But as mentioned, there is another modification by python on operators that is chaining:Based on python documentation :Note that comparisons, membership tests, and identity tests, all have the same precedence and have a left-to-right chaining feature as described in the Comparisons section.For example the result of following statement is False:Because python will chain the statements like following :Which exactly is False and True that is False. You can assume that the central object will be shared between 2 operations and other objects (False in this case).And note that its also true for all Comparisons, including membership tests and identity tests operations which are following operands :Example :Another famous example is number range :which is equal to :
Let's see it as a collection containment checking operation: [False, True] is a list containing some elements.The expression True in [False, True] returns True, as True is an element contained in the list.Therefore, not True in [False, True] gives the "boolean opposite", not result of the above expression (without any parentheses to preserve precedence, as in has greater precedence than not operator).Therefore, not True will result False.On the other hand, (not True) in [False, True], is equal to False in [False, True], which is True (False is contained in the list).
To clarify on some of the other answers, adding parentheses after a unary operator does not change its precedence. not(True) does not make not bind more tightly to True. It's just a redundant set of parentheses around True. It's much the same as (True) in [True, False]. The parentheses don't do anything.  If you want the binding to be more tight, you have to put the parentheses around the whole expression, meaning both the operator and the operand, i.e., (not True) in [True, False].To see this another way, consider ** binds more tightly than -, which is why you get the negative of two squared, not the square of negative two (which would be positive four). What if you did want the square of negative two? Obviously, you'd add parentheses:However, it's not reasonable to expect the following to give 4because -(2) is the same as -2. The parentheses do absolutely nothing. not(True) is exactly the same. 


Answer URL
https://docs.python.org/3/reference/expressions.html#operator-precedence
https://docs.python.org/3/reference/expressions.html#operator-precedence
