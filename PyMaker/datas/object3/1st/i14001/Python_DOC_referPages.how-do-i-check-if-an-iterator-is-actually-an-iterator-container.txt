Natural Text
I have a dummy example of an iterator container below (the real one reads a file too large to fit in memory):This allows me to iterate over the value more than once so that I can implement something like this:How do I check in the normalise function that I am being passed an iterator container rather than a normal generator?
First of all: There is no such thing as a iterator container. You have an iterable.An iterable produces an iterator. Any iterator is also an iterable, but produces itself as the iterator:You don't have an iterator if the iter(ob) is ob test is false.
You can test whether you have an iterator (is consumed once next raises the StopIteration exception) vs just an iterable (can probably be iterated over multiple times) by using the collections.abcmodule. Here is an example: What makes my_iterator() an Iterator is the presence of both the __next__ and __iter__ magic methods (and by the way, basically what is happening behind the scenes when you call isinstance on a collections.abc abstract base class is a test for the presence of certain magic methods). Note that an iterator is also an Iterable, as is the empty list (i.e., both have the __iter__ magic method): Also note, as was pointed out in Martijn Pieters' answer, that when you apply the generic iter() function to both, you get an iterator: The difference here between [] and my_iterator() is that iter(my_iterator()) returns itself as the iterator, whereas iter([]) produces a new iterator every time. As was already mentioned in MP's same answer, your object above is not an "iterator container." It is an iterable object, i.e., "an iterable". Whether or not it "contains" something isn't really related; the concept of containing is represented by the abstract base class Container. A Container may be iterable, but it doesn't necessarily have to be. 


Answer URL
https://docs.python.org/3/library/collections.abc.html
