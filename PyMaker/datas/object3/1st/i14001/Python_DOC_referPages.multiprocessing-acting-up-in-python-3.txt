Natural Text
I was messing around with a zip file cracker and decided to use the multiprocessing module to speed the process up. It was a complete pain since it was my first time using the module and I don't even fully understand it yet.  However, I got it to work.The problem is that it doesn't complete the word list; it just stops at random puts during the word list, and if the password is found it continues to go through the word list instead of just stopping the process.Does anyone know why it's exhibiting this behaviour?Source Code For ZipFile Cracker
Here's an implementation of the advice from @phihag's and @Equality 7-2521's answers:Note:each worker process has its own ZipFile object and the zip file is opened once per process: it should make it more portable (Windows support)  and improve time performancethe content is not extracted: check(password) tries to open and immediately closes an archive member on success: it is safer and it should improve time performance (no need to create directories, etc)all errors except 'Bad password for file' while decrypting the archive member are assumed to happen after the password is accepted: the rational is to avoid silencing unexpected errors -- each exception should be considered individuallycheck(password) expects nonempty passwordschunksize parameter may drastically improve performancea rare for/else syntax is used, to report cases when the password is not  foundthe with-statement calls pool.terminate() for you
You are terminating your program too early. To test this out, add a harmless time.sleep(10) in the cracker method and observe your program still terminating within a second.Call join to wait for the pool to finish:Additionally, once you find the right password, calling close just indicates that no more future tasks are coming - all tasks already submitted will still be done. Instead, call terminate to kill the pool without processing any more tasks.Furthermore, depending on the implementation details of multiprocessing.Pool, the global variable pool may not be available when you need it (and its value isn't serializable anyways). To solve this problem, you can use a callback, as inOf course, since you now look at the result all the time, apply is not the right way to go. Instead, you can write your code using imap_unordered:Instead of using globals, you may also want to open the zip file (and create a ZipFile object) in each process, by using an initializer for the pool. Even better (and way faster), forgo all of the I/O in the first place and read just the bytes you need once and then pass them on to the children.
phihag's answer is the correct solution.I just wanted to provide an additional detail regarding calling terminate() when you've found the correct password.  The pool variable in cracker() was not defined when I ran the code.  So trying to invoke it from there simply threw an exception:(My fork() experience is weak, so I don't completely understand why the global zFile is copied to the child processes successfully while pool is not. Even if it were copied, it would not be the same pool in the parent process, right?  So any methods invoked on it would have no effect on the real pool in the parent process.  Regardless, I prefer this advice listed within the multiprocessing module's Programming guidelines section: Explicitly pass resources to child processes.)My suggestion is to make cracker() return the password if it is correct, otherwise return None.  Then pass a callback to apply_async() that records the correct password, as well as terminating the pool.  Here's my take at modifying your code to do this:


Answer URL
https://docs.python.org/3/library/multiprocessing.html#all-start-methods
