Natural Text
I have been using Python more and more, and I keep seeing the variable __all__ set in different __init__.py files.  Can someone explain what this does?
It's a list of public objects of that module, as interpreted by import *. It overrides the default of hiding everything that begins with an underscore.
Linked to, but not explicitly mentioned here, is exactly when __all__ is used. It is a list of strings defining what symbols in a module will be exported when from <module> import * is used on the module.For example, the following code in a foo.py explicitly exports the symbols bar and baz:These symbols can then be imported like so:If the __all__ above is commented out, this code will then execute to completion, as the default behaviour of import * is to import all symbols that do not begin with an underscore, from the given namespace.Reference: https://docs.python.org/3.5/tutorial/modules.html#importing-from-a-packageNOTE: __all__ affects the from <module> import * behavior only. Members that are not mentioned in __all__ are still accessible from outside the module and can be imported with from <module> import <member>.
I'm just adding this to be precise:All other answers refer to modules. The original question explicitely mentioned __all__ in __init__.py files, so this is about python packages.Generally, __all__ only comes into play when the from xxx import * variant of the import statement is used. This applies to packages as well as to modules.The behaviour for modules is explained in the other answers. The exact behaviour for packages is described here in detail.In short, __all__ on package level does approximately the same thing as for modules, except it deals with modules within the package  (in contrast to specifying names within the module). So __all__ specifies all modules that shall be loaded and imported into the current namespace when us use from package import *.The big difference is, that when you omit the declaration of __all__ in a package's __init__.py, the statement from package import * will not import anything at all (with exceptions explained in the documentation, see link above). On the other hand, if you omit __all__ in a module, the "starred import" will import all names (not starting with an underscore) defined in the module.
Explain __all__ in Python?I keep seeing the variable __all__ set in different __init__.py files.What does this do?What does __all__ do?It declares the semantically "public" names from a module. If there is a name in __all__, users are expected to use it, and they can have the expectation that it will not change. It also will have programmatic affects:import *__all__ in a module, e.g. module.py:means that when you import * from the module, only those names in the __all__ are imported:Documentation toolsDocumentation and code autocompletion tools may (in fact, should) also inspect the __all__ to determine what names to show as available from a module.__init__.py makes a directory a Python packageFrom the docs:The __init__.py files are required to make Python treat the directories as containing packages; this is done to prevent directories with a common name, such as string, from unintentionally hiding valid modules that occur later on the module search path.In the simplest case, __init__.py can just be an empty file, but it can also execute initialization code for the package or set the __all__ variable.So the __init__.py can declare the __all__ for a package.Managing an API:A package is typically made up of modules that may import one another, but that are necessarily tied together with an __init__.py file. That file is what makes the directory an actual Python package. For example, say you have the following:in the __init__.py you write:and in module_1 you have:and in module_2 you have:And now you have presented a complete api that someone else can use when they import your package, like so: And they won't have all the other names you used when creating your modules cluttering up the package namespace.__all__ in __init__.pyAfter more work, maybe you've decided that the modules are too big and need to be split up. So you do the following:And in each __init__.py you declare an __all__, e.g. in module_1:And module_2's __init__.py:And you can easily add things to your API that you can manage at the subpackage level instead of the subpackage's module level. If you want to add a new name to the API, you simply update the __init__.py, e.g. in module_2:And if you're not ready to publish Baz in the top level API, in your top level __init__.py you could have:and if your users are aware of the availability of Baz, they can use it:but if they don't know about it, other tools (like pydoc) won't inform them.You can later change that when Baz is ready for prime time:Prefixing _ versus __all__:By default, Python will export all names that do not start with an _. You certainly could rely on this mechanism. Some packages in the Python standard library, in fact, do rely on this, but to do so, they alias their imports, for example, in ctypes/__init__.py:Using the _ convention can be more elegant because it removes the redundancy of naming the names again. But it adds the redundancy for imports (if you have a lot of them) and it is easy to forget to do this consistently - and the last thing you want is to have to indefinitely support something you intended to only be an implementation detail, just because you forgot to prefix an _ when naming a function.I personally write an __all__ early in my development lifecycle for modules so that others who might use my code know what they should use and not use.Most packages in the standard library also use __all__.When avoiding __all__ makes senseIt makes sense to stick to the _ prefix convention in lieu of __all__ when:You're still in early development mode and have no users, and are constantly tweaking your API.Maybe you do have users, but you have unittests that cover the API, and you're still actively adding to the API and tweaking in development.An export decoratorThe downside of using __all__ is that you have to write the names of functions and classes being exported twice - and the information is kept separate from the definitions. We could use a decorator to solve this problem.I got the idea for such an export decorator from David Beazley's talk on packaging. This implementation seems to work well in CPython's traditional importer. If you have a special import hook or system, I do not guarantee it, but if you adopt it, it is fairly trivial to back out - you'll just need to manually add the names back into the __all__So in, for example, a utility library, you would define the decorator:and then, where you would define an __all__, you do this:And this works fine whether run as main or imported by another function.And API provisioning with import * will work too:
It also changes what pydoc will show:module1.pymodule2.py$ pydoc module1$ pydoc module2I declare __all__ in all my modules, as well as underscore internal details, these really help when using things you've never used before in live interpreter sessions.
From (An Unofficial) Python Reference Wiki:The public names defined by a module are determined by checking the module's namespace for a variable named __all__; if defined, it must be a sequence of strings which are names defined or imported by that module. The names given in __all__ are all considered public and are required to exist. If __all__ is not defined, the set of public names includes all names found in the module's namespace which do not begin with an underscore character ("_"). __all__ should contain the entire public API. It is intended to avoid accidentally exporting items that are not part of the API (such as library modules which were imported and used within the module).
__all__ customizes the asterisk in from <module> import *__all__ customizes the asterisk in from <package> import *A module is a .py file meant to be imported.A package is a directory with a __init__.py file. A package usually contains modules.MODULES__all__ lets humans know the "public" features of a module.[@AaronHall]  Also, pydoc recognizes them.[@Longpoke]from module import *See how swiss and cheddar are brought into the local namespace, but not gouda:Without __all__, any symbol (that doesn't start with an underscore) would have been available. Imports without * are not affected by __all__import modulefrom module import namesimport module as localnamePACKAGESIn the __init__.py file of a package __all__ is a list of strings with the names of public modules or other objects. Those features are available to wildcard imports. As with modules, __all__ customizes the * when wildcard-importing from the package.[@MartinStettner] Here's an excerpt from the Python MySQL Connector __init__.py:The default case, asterisk with no __all__ for a package, is complicated, because the obvious behavior would be expensive: to use the file system to search for all modules in the package. Instead, in my reading of the docs, only the objects defined in __init__.py are imported:If __all__ is not defined, the statement from sound.effects import * does not import all submodules from the package sound.effects into the current namespace; it only ensures that the package sound.effects has been imported (possibly running any initialization code in __init__.py) and then imports whatever names are defined in the package. This includes any names defined (and submodules explicitly loaded) by __init__.py. It also includes any submodules of the package that were explicitly loaded by previous import statements. Wildcard imports ... should be avoided as they [confuse] readers and many automated tools.[PEP 8, @ToolmakerSteve]
Short answer__all__ affects from <module> import * statements.Long answerConsider this example:In foo/__init__.py:(Implicit) If we don't define __all__, then from foo import * will only import names defined in foo/__init__.py.(Explicit) If we define __all__ = [], then from foo import * will import nothing.(Explicit) If we define __all__ = [ <name1>, ... ], then from foo import * will only import those names.Note that in the implicit case, python won't import names starting with _. However, you can force importing such names using __all__.You can view the Python document here.
__all__ is used to document the public API of a Python module. Although it is optional, __all__ should be used.Here is the relevant excerpt from the Python language reference:The public names defined by a module are determined by checking the module’s namespace for a variable named __all__; if defined, it must be a sequence of strings which are names defined or imported by that module. The names given in __all__ are all considered public and are required to exist. If __all__ is not defined, the set of public names includes all names found in the module’s namespace which do not begin with an underscore character ('_'). __all__ should contain the entire public API. It is intended to avoid accidentally exporting items that are not part of the API (such as library modules which were imported and used within the module).PEP 8 uses similar wording, although it also makes it clear that imported names are not part of the public API when __all__ is absent:To better support introspection, modules should explicitly declare the names in their public API using the __all__ attribute. Setting __all__ to an empty list indicates that the module has no public API.[...]Imported names should always be considered an implementation detail. Other modules must not rely on indirect access to such imported names unless they are an explicitly documented part of the containing module's API, such as os.path or a package's __init__ module that exposes functionality from submodules.Furthermore, as pointed out in other answers, __all__ is used to enable wildcard importing for packages:The import statement uses the following convention: if a package’s __init__.py code defines a list named __all__, it is taken to be the list of module names that should be imported when from package import * is encountered.
In addition to the existing answers, __all__ doesn't have to be a list. As per the documentation on the import statement, if defined, __all__ must be a sequence of strings which are names defined or imported by the module. So you may as well use a tuple to save some memory and CPU cycles. Just don't forget a comma in case the module defines a single public name:__all__ = ('some_name',)


Answer URL
https://docs.python.org/3/tutorial/modules.html#importing-from-a-package
https://docs.python.org/3/reference/simple_stmts.html#the-import-statement
https://docs.python.org/3/tutorial/modules.html#importing-from-a-package
https://docs.python.org/3/reference/simple_stmts.html#the-import-statement
