Natural Text
I was comparing three slightly different implementations of @property in python. Python documentation and "Source 1" initialize the private variable, _var_name.  Furthermore, the code from Source 1 has a bug; it doesn't access .setter when initializing.  By contrast, the third example correctly initializes the public variable x.Is there a good reason to initialize _x in place of x in __init__?  Are there any additional differences between these that I haven't described?From the docs:Source 1: Source 2: 
Is there a good reason to initialize __x or _x in place of x in __init__?Properties are often used to transform the input in some way. An internal method (including __init__) often already has the transformed data, and doesn't want it to get transformed again. For example, consider this somewhat silly but obvious example:Even when you're not doing anything that would be wrong to pass through the setter, internal code often knows about the class invariants, so the checks done by setters may be extra overhead for no benefit. For example, if you wanted a method to set the temperature to 0°C, it could just set self._x = 0 instead of self.x = 0, because you know that 0 doesn't need to be checked.On the other hand, some internal methods may want to see x the same way the public does. In that case, it should use the property rather than the underlying attribute. In fact, your Source 1 is a perfect example—__init__ just saves its parameter directly to _temperature, allowing you to construct temperatures below absolute 0 (which is bad, because that's actually hotter than infinity, and CPUs like to be cold). And it would be silly to repeat the same precondition test in __init__ that you already wrote in temperature.setter; in this case, just set self.temperature instead.There is additional difference in whether a single or double underscore is used.A single underscore makes the attribute "private by convention"; a double underscore goes further and mangles the name, which means it can't be accidentally accessed from outside your class's code.Using obj._x works on your instances; obj.__x raises AttributeError. But it only prevents accidental access—they can still use obj._C__x if they really want to get at it. The main reason to do this is to protect subclasses or superclasses from accidentally using the same names.


Answer URL
https://docs.python.org/3/library/functions.html?highlight=property#property
