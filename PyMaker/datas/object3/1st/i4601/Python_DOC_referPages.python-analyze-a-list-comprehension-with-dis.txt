Natural Text
Recently, I had a discussion on SO (see it for the context) about the two following pieces of code:And:Both iterate through strings s in a list lst and look for s in a dict d. If s is found, then the associated value is returned, else s is returned. I'm pretty sure the second piece of code is faster than the first, because (for each s) there is no lookup in the dictionary, just an iteration on the (key, value) pairs. The question is:How to check that this is really what happens under the hood?I tried, for the first time, the dis module, but the result was disappointing (python 3.6.3):How do I get a more detailed information?EDITAs suggested by @abarnert in the first comment, I tried to timeit both solutions. I played around with the following code:Maybe I missed something but, to my surprise, the first piece of code (f) was always faster than the second (g). Hence the secondary question: does anyone have an explanation?EDIT 2 Here are the most interesting parts of the disassembled code (with a little formatting to insert the inner loop).For f:For g:One can see that (again as suggested by @abarnert) the inner loop of g contains some extra cost:(hidden) the construction of the 2-uples by the iterator on d.items()an UNPACK_SEQUENCE 2 which unpacks those 2-uples and then puts k and v on the stacktwo STORE_FAST which pop k and v from the stack to store them in co_varnames.Before it finally loads k to compare it with s as in f. This inner loop is iterated |lst|*|d| and It seems that those operations make the difference.If this was optimized as I thought it was, the d.items() iterator would have put first k on the stack to test k in s, and then, only if k in s was true, put v on the stack for the YIELD_VALUE.
You've already got all the detailed information there is about the code that evaluates the list comprehension.But list comprehensions are equivalent to creating and then calling a function. (This is how they have their own scope, so they don't, e.g., leak loop variables into the outer scope.) So that automatically-generated function named <listcomp> is what you really want to see the code for.If you want to disassemble it—well, notice that LOAD_CONST 0 says it's loading a <code object <listcomp> at 0x7f8e302038a0? That's what you want. But we can't get to it, because all we did was compile a string for the sake of disassembling it, then throw the result away, so the listcomp function isn't around anymore. But it's pretty easy to see with real code:There's that code object const again—but now it's not just a const we compiled and immediately threw away, it's part of a function we can access.How do we access it? Well, this is documented in the inspect module docs, which probably isn't the first place you'd look. Functions have a code object in their __code__ member, code objects have a sequence of constants in their co_consts member, and we're looking for constant #1, so:Of course you have a generator expression nested inside your list comprehension, and, as you can probably guess, that's also equivalent to creating and then calling a generator function. But that generator function's code is just as easy to find (if even more tedious to type out): f.__code__.co_consts[1].co_consts[0].


Answer URL
https://docs.python.org/3/library/inspect.html
