Natural Text
I recently found out that python has a special value NotImpemented to be used with respect to binary special methods to indicate that some operation has not been implemented.The peculiar about this is that when checked in a binary situation it is always equivalent to True.For example using io.BytesIO (which is a case where __eq__ in not implemented for example) for two objects in comparison will virtually return True. As in this example (encoded_jpg_io1 and encoded_jpg_io2 are objects of the io.BytesIO class):EqualUnequalSince the second style is a bit too verbose and normally not prefered (even my pyCharm suggests to remove the explicit comparison with True) isn't a bit tricky behavior? I wouldn't have noticed it if I haven't explicitly print the result of the Boolean operation (which is not Boolean in this case at all).I guess suggesting to be considered False would cause the same problem with __ne__ so we arew back to step one.So, the only way to check out for these cases is by doing an  exact comparison with True or False in the opposite case.I know that NotImpemented is preferred over NotImplementedError for various reasons so I am not asking for any explanation over why this matter.
Per convention, objects that do not define a __bool__ method are considered truthy. From the docs:By default, an object is considered true unless its class defines either a __bool__() method that returns False or a __len__() method that returns zeroThis means that most classes, functions, and other builtin singletons are considered true, since they don't go out of their way to specify different behavior. (An exception is None, which is one of the few built-in singletons that does specifically signal it should be considered false):There is no real reason for the NotImplemented object to break this convention. The problem with your code isn't that NotImplemented is considered truthy; the real problem is that x.__eq__(y) is not equivalent to x == y.If you want to compare two objects for equality, doing it with x.__eq__(y) is incorrect. Using x.__eq__(y) == True instead is still incorrect.The correct solution is to do comparison with the == operator. If, for whatever reason, you can't use the == operator directly, you should use the operator.eq function instead.


Answer URL
https://docs.python.org/3/library/constants.html#NotImplemented
https://docs.python.org/3/reference/datamodel.html#object.__bool__
https://docs.python.org/3/library/stdtypes.html#truth-value-testing
https://docs.python.org/3/library/operator.html#operator.eq
