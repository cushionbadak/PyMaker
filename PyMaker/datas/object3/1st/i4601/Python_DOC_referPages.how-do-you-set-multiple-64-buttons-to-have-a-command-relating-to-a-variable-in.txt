Natural Text
I'm trying to create functions inside of a loop:The problem is that all functions end up being the same. Instead of returning 0, 1, and 2, all three functions return 2:Why is this happening, and what should I do to get 3 different functions that output 0, 1, and 2 respectively?
You're running into a problem with late binding -- each function looks up i as late as possible (thus, when called after the end of the loop, i will be set to 2).  Easily fixed by forcing early binding: change def f(): to def f(i=i): like this:Default values (the right-hand i in i=i is a default value for argument name i, which is the left-hand i in i=i) are looked up at def time, not at call time, so essentially they're a way to specifically looking for early binding.If you're worried about f getting an extra argument (and thus potentially being called erroneously), there's a more sophisticated way which involved using a closure as a "function factory":and in your loop use f = make_f(i) instead of the def statement.
The ExplanationThe issue here is that the value of i is not saved when the function f is created. Rather, f looks up the value of i when it is called.If you think about it, this behavior makes perfect sense. In fact, it's the only reasonable way functions can work. Imagine you have a function that accesses a global variable, like this:When you read this code, you would - of course - expect it to print "bar", not "foo", because the value of global_var has changed after the function was declared. The same thing is happening in your own code: By the time you call f, the value of i has changed and been set to 2.The SolutionThere are actually many ways to solve this problem. Here are a few options:Force early binding of i by using it as a default argumentUnlike local variables (like i), default arguments are evaluated immediately when the function is defined:To give a little bit of insight into how/why this works: A function's default arguments are stored as an attribute of the function; thus the current value of i is snapshotted and saved.Use a function factory to capture the current value of i in a closureThe root of your problem is that i is a variable that can change. We can work around this problem by creating another variable that is guaranteed to never change - and the easiest way to do this is a closure:Use functools.partial to bind the current value of i to ffunctools.partial lets you attach arguments to an existing function. In a way, it too is a kind of function factory.


Answer URL
https://docs.python.org/3/library/functools.html#functools.partial
