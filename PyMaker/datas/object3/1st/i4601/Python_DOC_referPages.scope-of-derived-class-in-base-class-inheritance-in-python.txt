Natural Text
I know that by inheriting the base class. All the functions in base class would be accessible in the derived class as well. But how does it work the other way, meaning can a function that is defined in the child class be accessible in the base class. I tried the above out with an example. And it works just fine. But how can that be. I am not able to get the logic behind the working. I understand that the instance is being passed and all through self, but the details of the child class should logically not be accessible in the base class, correct?!
You are accessing attributes on an instance, not on a class. Your self reference is never an instance of the fish class, only of one of the two derived classes, and those derived classes set the _colour attribute.If you created an instance of fish() itself, you'd get an attribute error, because that instance will not have the attribute set.You may perhaps think that in base classes, self becomes an instance of the base class; that's not the case.Instead, attributes on an instance are looked up on the instance directly, and on its class and base classes. So self._colour looks at the instance, at type(instance) and at all further objects in the type(instance).__mro__, the Method Resolution Order that sets all classes in a hierarchy in a linear order.You could print out the type() of your object:The self references are instances of the derived classes, passed into an inherited method. So self._colour will first look at the attributes directly set on self, then at type(self), and there _colour is found.Perhaps it would help to see how Python methods work. Methods are just thin wrappers around functions, created when you look up the attribute on an instance:Look closely at the names of the objects I access, and what happens when I call the __get__ method on a function. Python uses a process called binding when you access certain attributes on an instance; when you access an attribute this way, and that points to an object with a __get__ method, then that object is called a descriptor, and __get__ is called to bind the object to whatever you looked the object up on. See the descriptor howto.Accessing color on the instance, produces a bound method object, but the description of the object tells us it came from fish, it's named a *bound method fish.color of instance reference. Accessing the same name on the class gives us the fish.color function, and I can manually bind it to create a method again.Finally, the method has an attribute __self__, which is the original instance, and __func__ which is the original function. And there's the magic, when you call a bound method, the method object just calls __func__(__self__, ....), so passing in the instance it was bound to.When that function was inherited, (found on the fish class, so fish.color), it is still passed an instance of the derived class, and still has everything the derived class has.Python is very dynamic, and very flexible. You can take any old function and put it on a class, and it can be bound into a method. Or you can take any unbound function, and manually pass in an object with the right attributes, and it'll just work. Python doesn't care, really. So you can pass in a new, indepdent type of object and still have the fish.color function work:So even passing in a class object, completely unrelated to the fish hierarchy, but with the expected attribute, still works.To most Python code, if it walks like a duck, and quacks like a duck, the code will accept it as a duck. Call it duck typing.
The methods of a derived class are not available in the base class.  However, the fields are shared for any function operating on a particular object.  self._colour refers to the value of _colour in the object on which you are calling color(), regardless of how _colour was set.Edit because you are setting _colour = ... directly in the class, outside of a function, any catfish will have _colour == "Blue Cat fish" and any tunafish will have _colour == "Yellow Tuna fish".  Those values, although set on the class, are available in every instance.  That is why self._colour works even though you never directly said self._colour = ....  If you wanted fish-specific colors, you would need to set self._colour in catfish.__init__ or tunafish.__init__.


Answer URL
https://docs.python.org/3/howto/descriptor.html
