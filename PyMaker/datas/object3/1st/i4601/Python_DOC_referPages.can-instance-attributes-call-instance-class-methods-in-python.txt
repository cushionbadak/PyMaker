Natural Text
Python noob here, trying to work more with classes and have broken my code down into a more simple example of what I am working with:Lets say I have a class, with an instance and an attribute associated with that instanceNow, running the method from the instance 'a' works as expectedOut:However, trying to call the method from an attribute of 'a' results in errorThis results in an attribute error, which is expected. 'a.attribute' is no longer a class type of 'Foo' but rather a class type of 'str'. My question is, can I do something inside the class to allow the attribute to use the class methods?Furthermore, since I have not found any results for this during my interwebs searches, Im assuming that it likely is not recommended and probably not pythonic? (just a guess). I am open to suggestions on how to make this better, but ideally, I would like to keep the attribute the way it is while still being able to call the class methods. The dot syntax of attributes for classes really helps me keep things organized, but it is useless to me if it cannot call the methods in the class from which it originates.Thanks in advance!
No, this doesn't work. And it really doesn't make sense if you understand how classes work.That a.attribute is just a name for the string 'bar'. That string doesn't know anything about a, and shouldn't.1 There could be plenty of other names for the same string. For example:That's exactly what you'd expect, right? But…Since bar is the same object as a.attribute, it clearly has to do the same thing:1. There are some special cases where something like this would be useful, but they're solved by having the attribute not just be a string, but instead be some kind of smart object that works kind of like a string but also knows its class, instance, or parent. See the enum module in the stdlib for an example—and click on the source code link to see how it's implemented.
In this example the attribute is is a string when you execute a.attribute='bar' so if you were to do type(a.attribute) it would return string. So Python is looking for the attribute dosomething() in the str class and not finding it.
What you seem to be trying to do doesn't really make sense. At a guess, it seems like you've mixed up some concepts related to inheritance with your understanding of python's dot syntax for member reference, when these have nothing to do with each other.You wrote'a.attribute' is no longer a class type of 'Foo' but rather a class type of 'str'.and this indicates a fundamental misunderstanding of what is going on. No state has changed – a is still the instance a, of type Foo. It has a member attribute, which is a string. The expression a.attribute is merely pointing to that string. If you need to call a method on a, you can still do so anywhere you were trying to call it on a.attribute:The common scenario in which an object of one type invokes a method that is not defined in its class is inheritance:In this case, we say that b, an instance of Bar, is a Foo as well. Therefore any method that Foo defines, a Bar instance has access to.If you tell us a bit more about what you're trying to accomplish, I can be more specific about whether and how you should be using inheritance. But the dot notation is just a way to talk about values attached to objects. It's literally just looking in the left object's dictionary for a value associated with the name on the right – foo.bar is equivalent to getattr(foo, 'bar').


Answer URL
https://docs.python.org/3/library/enum.html
