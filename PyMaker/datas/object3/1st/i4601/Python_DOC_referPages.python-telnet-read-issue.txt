Natural Text
im trying to read from a telnet server that sends no ending line or special character to tell the python telnet client that the read should be finished. this data is then sent to a tkinter text entry widget where i want it to constantly update with new data sent from the telnet server. the problem in having is i cant find a way "without blocking the loop" to read from the telnet server. thanksi have used read_some() but i dont get all the data, and read_until(">", timeout=1) blocks the code becasue it never gets a ending line or command to stop reading
The traditional solution to this problem is to spawn a background thread to talk to the socket. That background thread can block on the read, and it won't affect any other threads. However, there is a problem with this: tkinter is not thread-safe, and attempting to update your Entry widget from a background thread will fail. (Depending on your platform, it may crash, block the program, or, worst of all, work intermittently and cause a slew of mysterious bugs.)There are workarounds you can search for, but none of them are great.The basic idea is to have the background thread send messages to the main thread—e.g., by posting them on a queue.Queue, which the main thread can check (with a get(block=False)). But checking each time through the event loop may be too often while you're moving the mouse, but not often enough while you're idle—and if you ask tkinter to fire your check every N seconds, that can keep a laptop from going to sleep. Also, getting this right isn't exactly hard, but it's not trivial.There used to be a nice library that wrapped this all up as well as possible, called mtTkinter, but it was abandoned long ago. I ported it to Python 3 a few years back, but ended up not using it, so that version is effectively abandoned too. It might just work, but I'm not making any promises.The advantage of this solution is that it's very easy: import mttkinter as tkinter, add a threading.Thread(target=telnet_loop), a couple more minor changes, and you're done… if it works.The more modern solution is to use asyncio (or a predecessor like Twisted or a competitor like Curio).You can drive the asyncio loop from the Tkinter event loop, and it's a lot cleaner than any of the threading workarounds. A there are ready-made libraries to do it for you. (I don't know the current state of things, but I used the original asyncio-tkinter a few years back.)The only problem is that you can't use telnetlib, because it wasn't designed for asyncio. But there are almost certainly more modern Telnet libraries out there that were. (From a quick search, I found telnetlib3, which looks promising, but I don't know nearly enough to recommend it.)Of course this solution requires rewriting most of your networking code—but you don't have very much of it, and it's not working, so that doesn't seem like too much of a tragedy. Your tkinter code, meanwhile, should only require a one-line change.


Answer URL
https://docs.python.org/3/library/queue.html
https://docs.python.org/3/library/asyncio.html
