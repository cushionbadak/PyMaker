Natural Text
I would like to ensure that the class is only instantiated within a "with" statement.i.e. this one is ok:and this is not:How can I ensure such functionality?
All answers so far do not provide what (I think) OP wants directly.(I think) OP wants something like this: This is what I come up with, it may not be very robust, but I think it's closest to OP's intention.This will give the exact same output as I showed above as long as with is in the same line with X() when using context manager.
There is no straight forward way, as far as I know. But, you can have a boolean flag, to check if __enter__ was invoked, before the actual methods in the objects were called.When you use it with with,you will getBut, when you manually create an object, and invoke do_something,you will getNote: This is not a solid solution. Somebody can directly invoke __enter__ method alone, before calling any other methods and the __exit__ method may never be called in that case.If you don't want to repeat that check in every function, you can make it a decorator, like this
There is no foolproof approach to ensure that an instance is constructed within  a with clause, but you can create an instance in the __enter__ method and return that instead of self; this is the value that will be assigned into x. Thus you can consider X as a factory that creates the actual instance in its __enter__ method, something like:Of course this is still reusable, but every with statement would create a new instance.Naturally one can call the __enter__ manually, or get a reference to the ActualInstanceClass but it would be more of abuse instead of use.For an even smellier approach, the X() when called does actually create a XFactory instance, instead of an X instance; and this in turn when used as a context manager, creates the ActualX instance which is the subclass of X, thus isinstance(x, X) will return true.You could take this further and have XFactory create an actual X instance with a special keyword argument to __new__, but I consider it to be too black magic to be useful.
Unfortunately, you can't very cleanly. Context managers require having __enter__ and __exit__ methods, so you can use this to assign a member variable on the class to check in your code.The stateful object approach has the nice added benefit of being able to tell if the __exit__ method was called later, or to cleanly handle method requirements in later calls:
Here is a decorator that automates making sure methods aren't called outside of a context manager:And here is an example of it in use:This was written as an answer to this duplicate question.


Answer URL
https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack
