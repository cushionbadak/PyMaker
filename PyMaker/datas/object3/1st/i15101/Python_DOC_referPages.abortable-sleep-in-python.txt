Natural Text
I need a sleep() method which can be aborted (as described here or here). My approach is to let a threading.Event.wait() timeout at the specified duration:After calling abortable_sleep(10, _abort) I can now (from another thread) call _event.set(_abort) to let abortable_sleep() terminate before the 10 seconds.Example:Output:    This code is working as expected but I still have some questions:isn't there an easier way to have s.th. likea sleep() which can be aborted?can this be done more elegant? E.g. this way I have to be careful with the Event instance which is not bound to an instance of abortable_sleep()do I have to expect performance issues with high frequency loops like while True: abortable_sleep(0.0001)? How is the wait()-timeout implemented?
I have a wrapper class which basically slaps some sleep semantics on top of an Event. The nice thing is that you only have to pass around a Sleep object, which you can call sleep() on several times if you like (sleep() is not thread safe though) and that you can wake() from another thread.Usage example:The above might output something like this:Exactly what you did, but encapsulated in a class.
I'd wrap the sleep/abort function up in a new class:I'd then also supply a Thread subclass to manage the sharing of the wakeup routine on a per-thread basis:Any other thread with access to this thread can call wakeup() to abort the current abortable_sleep() (if one is in progress).Using ThreadWithWakeupYou can create threads using the ThreadWithWakeup class, and use it like this:The output of which looks like:Using AbortableSleep on its ownYou can also use the AbortableSleep class on its own, which is handy if you can't use the ThreadWithWakeup class for some reason (maybe you're in the main thread, maybe something else creates the threads for you, etc.):
Due to race conditions, your solution is not always perfectly correct.  You should use a threading.BoundedSemaphore() instead.  Call aquire() immediately after creating it.  When you want to sleep, call acquire() with a timeout, then call release() if the acquire() returned true.  To abort the sleep early, call release() from a different thread; this will raise ValueError if there is no sleep in progress.Using an event instead is problematic if the other thread calls set() at the wrong time (i.e. at any time other than when you are actually waiting on the event).


Answer URL
https://docs.python.org/3/library/threading.html#threading.Semaphore
