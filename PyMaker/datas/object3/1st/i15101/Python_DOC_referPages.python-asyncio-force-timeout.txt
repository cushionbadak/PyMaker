Natural Text
Using asyncio a coroutine can be executed with a timeout so it gets cancelled after the timeout:The above example works as expected (it times out after 5 seconds).However, when the coroutine doesn't use asyncio.sleep() (or other asyncio coroutines) it doesn't seem to time out. Example:This takes more than 10 seconds to run because the time.sleep(10) isn't cancelled. Is it possible to enforce the cancellation of the coroutine in such a case?If asyncio should be used to solve this, how could I do that?
No, you can't interrupt a coroutine unless it yields control back to the event loop, which means it needs to be inside a yield from call. asyncio is single-threaded, so when you're blocking on the time.sleep(10) call in your second example, there's no way for the event loop to run. That means when the timeout you set using wait_for expires, the event loop won't be able to take action on it. The event loop doesn't get an opportunity to run again until coro exits, at which point its too late.This is why in general, you should always avoid any blocking calls that aren't asynchronous; any time a call blocks without yielding to the event loop, nothing else in your program can execute, which is probably not what you want. If you really need to do a long, blocking operation, you should try to use BaseEventLoop.run_in_executor to run it in a thread or process pool, which will avoid blocking the event loop:
Thx @dano for your answer. If running a coroutine is not a hard requirement, here is a reworked, more compact versionFor the curious, a little debugging in my Python 3.5.2 showed that passing None as an executor results in the creation of a _default_executor, as follows:
The examples I've seen for timeout handling are very trivial. Given reality, my app is bit more complex. The sequence is:When a client connects to server, have the server create another connection to internal serverWhen the internal server connection is ok, wait for the client to send data. Based on this data we may make a query to internal server.When there is data to send to internal server, send it. Since internal server sometimes doesn't respond fast enough, wrap this request into a timeout.If the operation times out, collapse all connections to signal the client about errorTo achieve all of the above, while keeping the event loop running, the resulting code contains following code:


Answer URL
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.BaseEventLoop.run_in_executor
