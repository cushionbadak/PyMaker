Natural Text
I found that some classes contain a __init__ function, and some don’t. I’m confused about something described below.What is the difference between these two pieces of code:andI know that the result or any instance created by these two class and the way of getting their instance variable are pretty much the same. But is there any kind of “default” or “hidden” initialization mechanism of Python behind the scene when we don’t define the __init__ function for a class? And why I can’t write the first code in this way:That’s my questions. Thank you very much!Thank you very much Antti Haapala! Your answer gives me further understanding of my questions. Now, I understand that they are different in a way that one is a "class variable", and the other is a "instance variable". But, as I tried it further, I got yet another confusing problem.Here is what it is. I created 2 new classes for understanding what you said:As you said in the answer to my first questions, I understand the class_variable is a "class variable" general to the class, and should be passed or changed by reference to the same location in the memory. And the instance_variable would be created distinctly for different instances.But as I tried out, what you said is true for the Test3's instances, they all share the same memory. If I change it in one instance, its value changes wherever I call it.But that's not true for instances of Test4. Shouldn't the int in the Test4 class also be changed by reference?i1 = Test3()Why is that? Does that "=" create an "instance variable" named "i" without changing the original "Test4.i" by default? Yet the "append" method just handles the "class variable"? Again, thank you for your exhaustive explanation of the most boring basic concepts to a newbie of Python. I really appreciate that!
In python the instance attributes (such as self.i) are stored in the instance dictionary (i.__dict__). All the variable declarations in the class body are stored as attributes of the class.Thusis equivalent toIf no __init__ method is defined, the newly created instance usually starts with an empty instance dictionary, meaning that none of the properties are defined.Now, when Python does the get attribute (as in print(instance.i) operation, it first looks for the attribute named i that is set on the instance).  If that fails, the i attribute is looked up on type(i) instead (that is, the class attribute i).So you can do things like:but what this actually does is:There is no i attribute on the newly created t at all! Thus in t.i += 1 the .i was looked up in the Test class for reading, but the new value was set into the t.If you use __init__:The newly created instance t2 will already have the attribute set.Now in the case of immutable value such as int there is not that much difference. But suppose that you used a list:vs Now, if you create 2 instances of both:c1.the_list and c2.the_list refer to the exactly same list object in memory, whereas i1.the_list and i2.the_list are distinct. Modifying the c1.the_list looks as if the c2.the_list also changes.This is because the attribute itself is not set, it is just read. The c1.the_list.append(42) is identical in behaviour toThat is, it only tries read the value of attribute the_list on c1, and if not found there, then look it up in the superclass. The append does not change the attribute, it just changes the value that the attribute points to. Now if you were to write an example that superficially looks the same:It would work identical toAnd do a completely different thing: first of all the original + [ 42 ] would create a new list object. Then the attribute the_list would be created in c1, and set to point to this new list. That is, in case of instance.attribute, if the attribute is "read from", it can be looked up in the class (or superclass) if not set in the instance, but if it is written to, as in instance.attribute = something, it will always be set on the instance.As for this:Such thing does not work in Python, because there is no self defined when the class body (that is all lines of code within the class) is executed - actually, the class is created only after all the code in the class body has been executed. The class body is just like any other piece of code, only the defs and variable assignments will create methods and attributes on the class instead of setting global variables.
I understood my newly added question. Thanks to Antti Haapala.Now, when Python does the get attribute (as in print(instance.i) operation, it first looks for the attribute named i that is set on the instance). If that fails, the i attribute is looked up on type(i) instead (that is, the class attribute i).I'm clear about why is:after few tests. The codeactually creates a new instance variable for j1 without changing the class variable. That's the difference between "=" and methods like "append".I'm a newbie of Python coming from c++. So, at the first glance, that's weird to me, since I never thought of creating a new instance variable which is not created in the class just using the "=". It's really a big difference between c++ and Python.Now I got it, thank you all.


Answer URL
https://docs.python.org/3/c-api/long.html#c.PyLong_FromLong
