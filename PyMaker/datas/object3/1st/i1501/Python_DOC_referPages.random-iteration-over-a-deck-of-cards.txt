Natural Text
I am trying to randomly iterate over a deck of cards with no repetition.Following is the code:The idea that I am trying to work with is, as soon as the card is picked, it should be removed from the deck.This is the error :From my understanding, KeyError is an exception raised when a mapping (dictionary) key is not found in the set of existing keys. But my IF LOOP is TRUE only when the condition choice == i and only then should the pop() be initiated.I have tried the above code without the pop() method in the code and the code works just fine, generating random cards after every run.
If you try your code several times, you'll notice that you won't get this error every time. Sometimes it'll get past the lineand hit another error later in the code.So what's going on? I assume that random.choice(self.total_cards) works fine and returns one of the four decks from the total_cards list. You represent that deck as a dictionary.Let's see what random.choice does with dictionaries on a simpler example:Huh, strange, it returned one of the values. I'd have expected one of the keys, like when iterating over a dictionary without calling .items() nor .values().Let's try again:Strange, isn't it? 0 is neither among the values nor among the keys here. Where did it come from?Let's see how random.choice is implemented. In IPython I can get its source code like this:To get the code on your system, you can also look at the file mentioned in the error message you got: C:\Users\Python\Python37-32\lib\random.py around line 262.On Python 3.6.6 (the version on my system) the source code is:private method random._randbelow has the descriptionReturn a random int in the range [0,n).  Raises ValueError if n==0.While this works fine for sequences (like lists, sets or tuples), I guess you can see why it won't do the right thing at all when seq happens to be a dictionary (or any other mapping):It takes the length of the sequence (len(seq))(which works fine for dictionaries, too) and then generates a random integer between 0 (inclusive) and that length (exclusive) (that's what self._randbelow does)so this will be the 0-indexed position of a random element of the sequenceand then it uses that random integer to index the sequence (seq[i]) and returns that value (return)which doesn't work on dictionaries as intended because they are indexed by their keys.That's also why we sometimes didn't get the error and instead one of the dictionary values was returned by random.choice: When the integer intended as a random positionalso happened to be one of the keys of the dictionary, it would just return the corresponding value. If it happens to be none of our keys (which b.t.w. would always be the case, if all the keys were non-integers, e.g. strings) then a KeyError occurs.
Quick answer: random.choice() is meant for sequences i.e. lists, as it says in documentation. Long answer: See das-g's answer.
I think a list would be better, here is how I would do it:
Try my solution:


Answer URL
https://docs.python.org/3/library/random.html?highlight=random#random.choice
https://docs.python.org/3/library/random.html#random.shuffle
