Natural Text
f-strings don't behave nicely when used with dictionaries, as mentioned here.Here is an example of the not-so-nice behavior:The last two f-strings listed result in a SyntaxError: invalid syntax, which happens because the string '{d['foo']}' is evaluated as '{d['foo']}'. What is the underlying reason everything inside the curly brackets of f-strings doesn't get evaluated separately, as when using the old .format() method, and what could possibly be the reason for implementing f-strings in this way?I love f-strings, but this seems like a point in favor of the old method. 
One traditional way of including quotes within quotes is to use a backslash. But PEP498 forbids backslashes in expressions within f-strings:Backslashes may not appear inside the expression portions of  f-strings...You can use a different type of quote inside the expression...Therefore, the only way left to access a dictionary value given a key in an f-string expression is to use a different type quote. Using single quotes, or double quotes, everywhere is ambiguous and gives SyntaxError.str.format is a regular method, and as such works differently: d['foo'] is evaluated before the string is constructed. Just like when you feed arguments to a function, the arguments are evaluated before the function does anything.
This has nothing to do with f-strings. f strings are common strings once evaluated. What you are trying would be a problem with standard strings tooThe problem is that is declares the literal a "b" cwhile the quotes close and reopen. So, it is equivalent to string a, followed by variable b, followed by string c.That's the whole reason python supports both types of quotation marks


Answer URL
https://docs.python.org/3/library/stdtypes.html#str.format
