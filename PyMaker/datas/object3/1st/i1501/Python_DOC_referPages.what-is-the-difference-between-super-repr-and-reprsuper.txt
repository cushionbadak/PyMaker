Natural Text
In python (3.5.2), I was expecting the repr(obj) function to call the magic method __repr__() of obj's class. However calling both of them do not seem to yield the same result. Can anyone explain why ?Sample code : result : 
Calling repr(super()) directly accesses the __repr__ on the super class (technically, the tp_repr of the C PyTypeObject struct defining the super type). Most special dunder methods behave this way when called implicitly (as opposed to explicitly calling them as methods). repr(x) isn't equivalent to x.__repr__(). You can think of repr as being defined as:while you were expecting it to be:This behavior is intentional; one, customizing dunder methods per-instance makes little sense, and two, prohibiting it allows for much more efficient code at the C level (it has much faster ways of doing what the illustrative methods above do).By contrast, super().__repr__() looks up the method on the super instance, and super defines a custom tp_getattro (roughly equivalent to defining a custom __getattribute__ method), which means lookups on the instance are intercepted before they find the tp_repr/__repr__ of the class, and instead are dispatched through the custom attribute getter (which performs the superclass delegation).
If you consult the docs, you'll see that super returns a proxy object which delegates method calls to the appropriate class according to method resolution order.So repr(super()) gets you the representation of the proxy object. Whereas the method call super().__repr__() gives you the representation defined by the next class in the method resolution order.If you want the superclass itself, try
In super().__repr__() you're calling the repr class of the super object so you get 'haha'In the second, you're calling repr of the super(). what does super() output? <super: <class 'child'>, <child object>> so you're effectively calling repr on some class hierarchy


Answer URL
https://docs.python.org/3/library/functions.html#super
