Natural Text
I am wondering why this function:is faster than this one ? :And why it's the opposite for example in C?
Let's look at what happens if we take your Python code and translate it as literally as possible to C.  We can do that very easily with Cython:The machine code you get from this is not as optimal as it could be, but it's close enough for a quick test.  This allows us to compare performance directly using timeit, like this:When I run this program, this is the output I get on the computer where I'm typing this. I've manually lined up the numbers to make them easier to compare by eye.So that confirms your original assertion: the loop is slower than converting to a string in Python, but in C it's the other way around.  But notice that converting to a string in C is still faster than converting to a string in Python.To know precisely why this is happening we would need to dig deeper into the guts of the Python interpreter than I feel like doing this morning, but I know enough about its guts already to tell you in outline.  The CPython interpreter is not very efficient.  Even operations on small integers involve reference counting and construction of scratch objects on the heap.  Your loop that does basic arithmetic in Python requires one or two scratch objects per iteration (depending on whether 0, 1, 2, ... are "interned").  Doing the calculation by converting to a string and taking its length involves creating only one temporary object, the string, for the whole calculation.  The bookkeeping involved with these scratch objects dwarfs the cost of the actual calculation, for both of the Python implementations.The C string-based implementation performs almost exactly the same steps that the Python string-based implementation performs, but its scratch object is a char array on the stack, not a full-fledged Python string object, and that all by itself is apparently good for a 40-50% speedup.The C loop-based implementation compiles down to eight machine instructions for the actual loop.  No memory accesses.  Not even a hardware divide instruction (that's the magic of strength reduction).  And then hundreds more instructions dealing with the Python object model.  Most of those 0.00025 seconds are still overhead.


Answer URL
https://docs.python.org/3/library/timeit.html
