Natural Text
It looks like, for Cython's cdef-classes, using class special methods is sometimes faster than identical "usual" method, for example __setitem__ is 3 times faster than setitem:and now:This neither the "normal" behavior for Python, for which the special functions are even somewhat slower (and obviosly slower than the Cython-equivalent):nor this is the case in Cython for all special functions:which leads to:i.e. almost identical running times.Why is __setitem__(...) so much faster, than setitem(...) in a cdef-class, even if both are cythonized?
There's quite a bit of overhead for a generic Python method call - Python looks up the relevant attribute (a dictionary lookup), ensures that the attribute is a callable object, and once it's called handles the result. This overhead also applies to generic def functions for cdef classes (the only difference being is that the implementation of the method is defined in C).However, special methods on C/Cython classes can be optimised, as follows:Lookup speedAs a shortcut,PyTypeObject in the Python C API defines a number of different "slots" - direct function pointers for special methods. For __setitem__ there's actually two available: PyMappingMethods.mp_ass_subscript which corresponds to a generic "mapping" call, and PySequenceMethods.sq_ass_item, which lets you use an int as the indexer directly and corresponds to the C API function PySequence_SetItem.For a cdef class, Cython only seems to generate the first (generic) one, so the speedup isn't from passing a C int directly. Cython does not fill these slots when generating a non-cdef class.The advantage of these is that (for a C/Cython class) finding the __setitem__ function just involves a couple of pointer NULL checks followed by a C function call. This also applies to __len__ which is also defined by slots in PyTypeObjectIn contrast,for a Python class calling __setitem__, it instead uses a default implementation which does a dictionary lookup for the string "__setitem__".For either a cdef or Python class calling a non-special def function, the attribute is looked up from the class/instance dictionary (which is slower)Note that if the setitem regular function were to be defined in a cdef class as cpdef instead (and called from Cython) then Cython implements its own mechanism for a speedy lookup.Calling efficiencyHaving found the attribute it must be called. Where the special functions have been retrieved from PyTypeObject (e.g. __setitem__ and __len__ on a cdef class), they are simply C function pointers and so can be called directly.For every other case the PyObject retrieved from attribute lookup must evaluated to see if it's a callable, then called.Return handlingWhen __setitem__ is called from PyTypeObject as a special function the return value is an int, which is simply used as an error flag. No reference counting or handling of Python objects is needed.When __len__ is called from a PyTypeObject as a special function, the return type is a Py_ssize_t, which must be converted to a Python object and then destroyed when no longer needed.For normal functions (e.g. setitem called from a Python or Cython class, or __setitem__ defined in a Python class), the return value is a PyObject*, which must be reference counted/destroyed appropriately.In summary,  the difference is really to do with shortcuts in finding and calling the function rather than whether the contents of the function is Cythonized.
@DavidW's answer hits the nail on the head, here are some more experiments and details which corroborate his answer.Calling a special function which returns Â´None`is fast, no matter how many arguments:and nowThe signature of the functions is known, there is no need to construct *args, **kwargs. The look-up in the slot is as fast as it gets.Overhead of calling a normal function depends on the number of arguments:and now:The overhead is bigger than for calling of methods from slots, but also bigger if there have (at least) two arguments (not taking self into account): 65ns vs 95ns.The reason: cython-methods can be one of the following typesMETH_NOARGS - only with argument selfMETH_O - only with self + one argumentMETH_VARARGS|METH_KEYWORDS - with arbitrary number of elementsThe method fun2 is of third type, thus in order to be called it Python has to construct list *args, which leads to additional overhead.** Returning from a special method can have more overhead as from normal method":leads to:As @DavidW has pointed out, for __len__, in every call a "new" int-object must be constructed from returned Py_ssize_t (in the case of 1 it is an integer from the pool, so it is not really constructed - but it were in case of bigger numbers).This is not the case for len(): for this special implementation, Cython initializes a global object, which is returned by len() - increasing the reference counter doesn't cost much (compared to creating an integer!).Thus, both __len__ and len() run approximately equally fast - but the time is spent for different things (creating integer vs. lookup overhead).


Answer URL
https://docs.python.org/3/c-api/typeobj.html#c.PyMappingMethods.mp_ass_subscript
https://docs.python.org/3/c-api/typeobj.html#c.PySequenceMethods.sq_ass_item
https://docs.python.org/3/c-api/sequence.html#c.PySequence_SetItem
https://docs.python.org/3/c-api/structures.html#METH_NOARGS
https://docs.python.org/3/c-api/structures.html#METH_O
https://docs.python.org/3/c-api/structures.html#METH_VARARGS
