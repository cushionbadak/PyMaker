Natural Text
I have learned python since 2 weeks ago.But I don't understand why copy_dic is {'a': 3}.save memory address ?? I don't know..1: Case of Variable2: Case of Dictionary
In Python names are just references to objects. When you have something like:dic and var_a are just names pointing to the respective objects.visual representation:And when you assign some other variable using = operator, what you are essentially doing is asking that other variable to point to the same exact object:visual representation:Now, changing that object affects all of the variables pointing to it, as is demonstrated in the question:visual representation:As can be seen, the single dict object both variables (dic, copy_dic) were pointing to is altered, and both of them still point to this object. One question remains, "Why changing changing the int object didn't have the same effect? Shouldn't operations on var_a affect copy_var too?"The answer is, in Python integers, strings, tuples and some other objects are immutable, meaning you cannot alter them. When you try to alter an integer like:orvar_a starts pointing to an entirely different integer object.  visual representation:What if you want to have separate dict objects? You can use the copy method:Output:copy creates a new copy of that object and returns it.visual representation:Be warned:copy()Return a shallow copy of the dictionary.What is a shallow copy, one might ask. As the documentation states:A shallow copy constructs a new compound object and then (to the extent possible) inserts references into it to the objects found in the original.Meaning the dict objects are two different objects but their components are the same, thus if their objects were mutable, and you altered them, that would still affect the other one:Output:If you need to avoid that behavior, what you need is deepcopy function:copy.deepcopy(x[, memo])Return a deep copy of x.And as is stated:A deep copy constructs a new compound object and then, recursively,  inserts copies into it of the objects found in the original.Meaning dictionaries hold references to different objects. In that case, you can alter one of them without ever worrying about the other. This function can be found in copy module:Output:However, in most cases a shallow copy is what you really need.
When you doboth copy_dic and dic point to the same dictionary (two references to same dictionary), so updating one will reflect in the other. What you need is to create a copy of dictionary and whatever you change in the original dictionary is not going to reflect in the copy:
1: Case of VariableBoth var_a and copy_var are int object, which is immutable. When you do var_a = 3, var_a points to a new memory address. Here is the detailed explanation to your code:var_a = 1 : variable var_a points to the memory address of 1copy_var = var_a : variable copy_var points to the same memory address of 1var_a = 3 : variable var_a points to the memory address of 3 while copy_var still points to the memory address of 1print(copy_var) : the result is 1 since the memory address of var_a is changed.2: Case of DictionaryBoth dic and copy_dic are dictionary object, which is mutable. When you do dic['a'] = 3, dic doesn't change its memory address and the content in the original memory address is changed. Here is the detailed explanatioofto your code:dic = {'a':1} : variable dic points to the memory address of {'a':1}copy_dic = dic : variable copy_dic points to the same memory address of {'a':1}dic['a'] = 3 : dic doesn't change its memory address, the content in the original memory address is changed to be {'a':3}print(copy_dic) : The result is  {'a': 3} since the content in the memory address is changed


Answer URL
https://docs.python.org/3/library/stdtypes.html?highlight=dict%20copy#dict.copy
