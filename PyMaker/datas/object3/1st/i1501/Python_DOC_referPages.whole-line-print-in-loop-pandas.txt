Natural Text
I have a DataFrame from pandas:Output:Now I want to iterate over the rows of this frame. For every row I want to be able to access its elements (values in cells) by the name of the columns. For example:Is it possible to do that in pandas?I found this similar question. But it does not give me the answer I need. For example, it is suggested there to use:orBut I do not understand what the row object is and how I can work with it.
DataFrame.iterrows is a generator which yield both index and row
To iterate through DataFrame's row in pandas one can use:DataFrame.iterrows()DataFrame.itertuples()itertuples() is supposed to be faster than iterrows()But be aware, according to the docs (pandas 0.21.1 at the moment):iterrows: dtype might not match from row to rowBecause iterrows returns a Series for each row, it does not preserve dtypes across the rows (dtypes are preserved across columns for DataFrames).iterrows: Do not modify rowsYou should never modify something you are iterating over. This is not guaranteed to work in all cases. Depending on the data types, the iterator returns a copy and not a view, and writing to it will have no effect.Use DataFrame.apply() instead:itertuples: The column names will be renamed to positional names if they are invalid Python identifiers, repeated, or start with an underscore. With a large number of columns (>255), regular tuples are returned.
While iterrows() is a good option, sometimes itertuples() can be much faster:
You can also use df.apply() to iterate over rows and access multiple columns for a function.docs: DataFrame.apply()
You can use the df.iloc function as follows:
I was looking for How to iterate on rows AND columns and ended here so :
Use itertuples(). It is faster than iterrows():
You can write your own iterator that implements namedtupleThis is directly comparable to pd.DataFrame.itertuples.  I'm aiming at performing the same task with more efficiency.For the given dataframe with my function:Or with pd.DataFrame.itertuples:A comprehensive testWe test making all columns available and subsetting the columns.  
To loop all rows in a dataframe you can use:
IMHO, the simplest decision
To loop all rows in a dataframe and use values of each row conveniently, namedtuples can be converted to ndarrays. For example:Iterating over the rows:results in:Please note that if index=True, the index is added as the first element of the tuple, which may be undesirable for some applications.
Adding to the answers above, sometimes a useful pattern is:Which results in:
Why complicate things?  Simple.
Q: How to iterate over rows in a DataFrame in Pandas?Don't!Iteration in pandas is an anti-pattern, and is something you should only want to do when you have exhausted every other option possible. You should not consider using any function with "iter" in its name for anything more than a few thousand rows or you will have to get used to a lot of waiting.Do you want to print a DataFrame? Use DataFrame.to_string().Do you want to compute something? In that case, search for methods in this order (list modified from here):vectorizationcython routinespure python list comprehension (for loop)applya. reductions that can be performed in cythonb. iteration in python spaceitertuples, iteritemsiterrowsiterrows and itertuples (both receiving many votes in answers to this question) should be used in very rare circumstances, such as generating row objects/nametuples for sequential processing, which these functions are good at. Appeal to AuthorityThe docs page on iteration has a huge red warning box that says:Iterating through pandas objects is generally slow. In many cases, iterating manually over the rows is not needed [...].Next Best Thing: List ComprehensionsIf you are iterating because there is no vectorized solution available, use a list comprehension. To iterate over rows using a single column, useTo iterate over rows using multiple columns, you can use If you need an integer row index while iterating, use enumerate:(where df.index[i] gets you the index label.)If you can turn it into a function, you can use list comprehension. You can make arbitrarily complex things work through the simplicity and speed of raw  python.
You can also do numpy indexing for even greater speed ups. It's not really iterating but works much better than iteration for certain applications.You may also want to cast it to an array. These indexes/selections are supposed to act like Numpy arrays already but I ran into issues and needed to cast
There are so many ways to iterate over the rows in pandas dataframe. One very simple and intuitive way is :
This example uses iloc to isolate each digit in the data frame. 
For both viewing and modifying values, I would use iterrows(). In a for loop and by using tuple unpacking (see the example: i, row), I use the row for only viewing the value and use i with the loc method when I want to modify values. As stated in previous answers, here you should not modify something you are iterating over.Here the row in the loop is a copy of that row, and not a view of it. Therefore, you should NOT write something like row['A'] = 'New_Value', it will not modify the DataFrame. However, you can use i and loc and specify the DataFrame to do the work.


Answer URL
https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions
https://docs.python.org/3/library/functions.html#enumerate
