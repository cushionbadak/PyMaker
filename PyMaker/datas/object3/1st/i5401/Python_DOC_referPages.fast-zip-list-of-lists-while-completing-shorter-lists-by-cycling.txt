Natural Text
Please note this is not a duplicate of this post because I want to zip more than 2 lists (or at least I cannot easily generalize that post for use here without explicit loops)I want to find the best performing (in terms of speed) implementation that merges list of lists in a particular way. The input is a list of lists (or tuples), ordered such that the length of the next list is always multiples of the previous one. For example:The output is a merged list of:That is, the shorter lists (in this case a) all get expanded to the longest list (in this case b) by cycling over itself so that lists will have equal length. Then all lists are merged in a vertical stacking fashion.Currently I have an implementation that essentially does the following:It works but not efficient:Is there a faster implementation? Performance is really crucial to my application as the input can be huge. Any suggestions are appreciated!
Using cycle, chain, islice from itertools:Or, in its parts:Or illustrated:The time complexity of this is O(n) where n is the length of the output list. In Python2 you will have to use itertools.izip instead of zip as the latter would try to build an infinite list.
Using the roundrobin itertools recipe:Two Inputsitertools.cycle() infinitely extends the shorter iterable.  zip() stops iterating after the shorter iterable.  roundrobin handles the interleaving of elements between iterables.Longer InputsTo work on more than two inputs, we need to cycle all but the last iterable:Now for two or more input iterables, we can apply the interleave function:Note: you can either reimplement the roundrobin recipe from the docs or install a third-party library that implements it for you, e.g. more_itertools.  > pip install more_itertools, then in Python, from more_itertools import roundrobin.
apply itertools.cycle to all lists shorter than the longest one and zip them all together, flattening the result.off-hand this should be O(2n) where n is the sum of the lengths of the lists. If you know the longest list and can pass it separately, this becomes O(n). Similarly if you know how much output you need (since you can just apply itertools.cycle to each list and pull from the infinite output)
will this work?output:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools
https://docs.python.org/3/library/itertools.html#itertools-recipes
https://docs.python.org/3/library/itertools.html#itertools-recipes
https://docs.python.org/3/library/itertools.html?highlight=itertools%20cycle#itertools.cycle
