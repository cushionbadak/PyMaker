Natural Text
I would like to do pseudo-randomization, meaning to randomize something by respecting certain rules.Imagine the following DataFrame:N stands for neutral and D for deviant. Before having a Deviant, I would like to at least have two Neutrals (but there can be more neutrals between deviants) and everything must be in a random order.As result: ColX should look likeI was wondering what kind of function I could use in python (function in pandas or other packages) or R (any function in a library that permits this?)Thank you in advance.
Here is the "correct" way of doing it. Correct in the sense that every legal combination is equally likely. The downside is that it is a bit more expensive than @BradSolomon's:Explanations: I suspect what makes this slow is numpy's choice without replacement function which I think generates a full permutation and then truncates it.The method works as follows: we can map legal patterns with nD Ds and nN Ns to patterns with nD Ds and nN - 2 nD Ns by removing 2 Ns before each D and conversely any pattern of the latter kind to a legal pattern by inserting 2 Ns before each D. This map is 1-to-1. And the unconstrained patterns we know how to draw with equal probability. So we do just that and then map to legal  patterns by inserting 2 Ns before each D.
Here's one way you can do this with NumPy, with a tiny speedup for looping provided by itertools:Walkthrough:You can independently generate each "chunk" of 2 or more N's followed by 1 D.  That is what get_chunk() does above.  In this case, it generates a NumPy array of N's followed by 1 D, where the number of N's is a random integer between 2 and your high parameter.Then in gen_series(), you can build individual chunks (3 of them is the default here) and concatenate them into a single 1d array.UpdateThe above uses a constant high parameter in each chunk's generation.  Perhaps this doesn't meet the definition of psueorandom that you are looking for.  To use a different high with each chunk generation, you could do:Either construction should be fairly quick:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.repeat
