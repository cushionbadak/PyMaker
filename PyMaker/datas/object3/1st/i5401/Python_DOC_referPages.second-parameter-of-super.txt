Natural Text
A colleague of mine wrote code analogous to the following today, asked me to have a look, and it took me a while to spot the mistake:The problem here is that there's no self parameter to super() in B's constructor. What surprised me is that absolutely nothing happens in this case, i.e. no error, nothing. What does the super object created by super(B) contain? As an object, it clearly has a constructor, so that's what gets called, but how is that object related to B? In particular, why is this valid code and doesn't throw an exception somewhere? Is super(B) an object with some actual use and what would that be?
The only thing that causes all these ambiguities is that "why obj = super(B).__init__() works?". That's because super(B).__self_class__ returns None and in that case you're calling the None objects' __init__ like following which returns None:Regarding the rest of the cases, you can simply check the difference by calling the super's essential attributes in both cases:For the rest of the things I recommend you to read the documentation thoroughly. https://docs.python.org/3/library/functions.html#super and this article by Raymond Hettinger https://rhettinger.wordpress.com/2011/05/26/super-considered-super/.Moreover, If you want to know why super(B) doesn't work outside of the class and generally why calling the super() without any argument works inside a class you can read This comprehensive answer by Martijn https://stackoverflow.com/a/19609168/2867928.A short description of the solution:As mentioned in the comments by @Nathan VÄ“rzemnieks you need to call the initializer once to get the super() object work. The reason is laid behind the magic of new super object that is explained in aforementioned links.
The confusion here comes from the fact that (in a class definition context) super() gives a bound super object which then delegates __init__ to its __self_class__, while super(B) creates an unbound super object which, because its __self_class__ is None, does not delegate. So when you call super(B).__init__(), it creates an unbound super but then immediately calls __init__ on it; that, because of the magic described in the various links in this other answer, binds that unbound super. There are no references to it, so it disappears, but that's what's happening under the hood.


Answer URL
https://docs.python.org/3/library/functions.html#super
