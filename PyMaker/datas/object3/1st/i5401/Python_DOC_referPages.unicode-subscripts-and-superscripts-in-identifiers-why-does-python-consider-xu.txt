Natural Text
Python allows unicode identifiers.  I defined Xᵘ = 42, expecting XU and Xᵤ to result in a NameError.  But in reality, when I define Xᵘ, Python (silently?) turns Xᵘ into Xu, which strikes me as somewhat of an unpythonic thing to do.  Why is this happening?
Python converts all identifiers to their NFKC normal form; from the Identifiers section of the reference documentation:All identifiers are converted into the normal form NFKC while parsing; comparison of identifiers is based on NFKC.The NFKC form of both the super and subscript characters is the lowercase u:So in the end, all you have is a single identifier, Xu:The above disassembly of the compiled bytecode shows that the identifiers have been normalised during compilation; this happens during parsing, any identifiers are normalised when creating the AST (Abstract Parse Tree) which the compiler uses to produce bytecode.Identifiers are normalized to avoid many potential 'look-alike' bugs, where you'd otherwise could end up using both ﬁnd() (using the U+FB01 LATIN SMALL LIGATURE FI character followed by the ASCII nd characters) and find() and wonder why your code has a bug.
Python, as of version 3.0, supports non-ASCII identifiers. When parsing the identifiers are converted using NFKC normalization and any identifiers where the normalized value is the same are considered the same identifier.See PEP 3131 for more details. https://www.python.org/dev/peps/pep-3131/


Answer URL
https://docs.python.org/3/reference/lexical_analysis.html#identifiers
