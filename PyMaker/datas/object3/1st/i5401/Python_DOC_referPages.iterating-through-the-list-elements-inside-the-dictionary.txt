Natural Text
I have a dictionary dict = {1:['cup','pen'],2:['one','two'],3:['five']}in which i have to iterate through the first elements of all the keysat first and then the second element.I have written in below way, but the output in which it,iterates through list index 0first and then index 1.Any one help me out to modify the code, so that it can iterate all the list's first element's at first and the second elementOutput of above code:but want it in this below way :
Using the zipped-transpose idiom, zip upto the longest list with itertools.zip_longest. Then iterate over each item in the sub-lists, filtering out None values.Here, data is your input dictionary. Don't use dict to name variables, it shadows the builtin class with the same name.Note that this order is not guaranteed on python versions below python-3.6, since dictionaries are not ordered in these older versions of python.Final note, for python-2.x, the appropriate function to be used is itertools.izip_longest. The output of zip_longest looks like this:These None values are inserted in place of missing values due to the "zip longest' behaviour of the function. These Nones are removed with filter.You can use this to get creative using itertools.chain and a print statement, accomplishing this in one line:Re-written a little more clearly:One more option, for homework submission without zip_longest. This just cycles over the keys, popping one element at a time from each list.This empties data of its contents, so you may want to make a copy of your data beforehand.
You could try converting each list in your dictionary to collections.deqeue() objects, then popping off the first item in each queue until all queues are empty:Which Outputs:Having shown this possible approach, it does require more work to produce what you want, whereas @cᴏʟᴅsᴘᴇᴇᴅ's answer addresses how to do this very easily. Also note that you don't need to use collections.deque() here, you can simply pop from lists instead with pop(). I used it for convenience and the O(1) popleft() function. The only efficiency issue you can run into here is that pop(0) is O(n) for lists. One way around this is reversing the lists beforehand, and calling pop() instead, which results in O(1) behavior. 
You can try this without any external library:output:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.zip_longest
