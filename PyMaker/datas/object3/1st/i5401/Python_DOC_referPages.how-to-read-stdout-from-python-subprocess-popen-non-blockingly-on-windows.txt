Natural Text
I am suffering from the Windows Python subprocess module.This is test code1(named test1.py):  and test code2(named test2.py):    Generally, the test code2 generates random integer(0~100) and print it out infinitely.I want the test code1 create a subprocess and launch it, read the stdout in realtime(not waiting for subprocess finished).But when I run the code, the output is :It blocks on stdout.read() forever.I have tried:Replace stdout.read with communicate(), doesn't work as python doc expected, it will blocking until subprocess terminate.use poll() methods to detect subprocess and read n bytes, forever block on read()Modify the test2.code, only generate one nunber and break the loop. The father process print it out immediately(I think it's because child process terminated)I searched a lot of similiar answers and did as they suggested(use stdout instead of communicate), but still didn't work?  Could anyone help me explaining why and how to do it?This is my platform information:Python 3.6.4 (v3.6.4:d48eceb, Dec 19 2017, 06:54:40) [MSC v.1900 64 bit (AMD64)] on win32
It has to do with Python's output buffering (for a child process in your case). Try disabling the buffering and your code should work. You can do it by either running python with -u key, or calling sys.stdout.flush().To use the -u key you need to modify the argument in the call to Popen, to use the flush() call you need to modify the test2.py.Also, your test1.py would print just a single number, because you read only 1 byte from the pipe, instead of reading them in a loop.Solution 1:test1.pyThis way you don't have to touch the test2.py at all.Solution 2:test1.pytest2.pyThis will print each received byte on a new line, e.g.:You can switch the pipe to text mode by providing encoding in arguments or providing universal_newlines=True, which will make it use the default encoding. And then write directly to sys.stdout of your parent process. This will basically  stream the output of a child process to the output of the parent process.test1.pyThis will provide the output as if the test2.py is executed directly:


Answer URL
https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate
