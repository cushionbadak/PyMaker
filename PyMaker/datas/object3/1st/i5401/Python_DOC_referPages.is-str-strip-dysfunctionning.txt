Natural Text
I have a list built from a string split operation, and I wanted to input it to map() function, then strip these substrings from their trailing parenthesis and spaces.And rebuild a list from them.  But in the end, I only strip oddly the substrings, while "all combinations are tested", as stated by docs.  I  know another method is available with list comprehension:which works.. But I wonder why map doesn't work correctly.  I am on python 3.6.4, with Anaconda 4.4 on windows64.  Subsidiary question; the following topic gives some pointers to find source code of functions. But I could not find the code for map (and generally, for builtin functions), so I could not see if there were bugs into it...
map with 3 arguments is not behaving the way you think it does. The 3rd argument for map is not the arguments for the function provided as the 1st argument. It is used as a 2nd iterable.From the docs:map(function, iterable, ...) Return an iterator that applies function  to every item of iterable, yielding the results. If additional  iterable arguments are passed, function must take that many arguments  and is applied to the items from all iterables in parallel. With  multiple iterables, the iterator stops when the shortest iterable is  exhausted. For cases where the function inputs are already arranged  into argument tuples, see itertools.starmap()In other words:map(str.strip, teststring.split('/'), ' ()') is not equivalent to[substr.strip(' ()' for substr in teststring.split('/')]. It is remotely equivalent to[(substr_1.strip(), substr_2.strip()) for (substr_1, substr_2) in zip(teststring.split("/"), ' ()')] See the difference?
map works differently from how you are using it. When you do map(f, a, b), it yields f(a[0], b[0]), f(a[1], b[1]), ..., while you are using it like it will yield f(a[0], b), f(a[1], b), ....To fix this, you can use a list comprehension, like in the question, or a lambda like lambda string: string.strip(" ()").
You could use operator.methodcaller:
The problem is that you seem to be under the impression that the last argument to map gets passed as an argument to the function being mapped, that isn't what happens, instead, from the docs:map(func, *iterables) --> map objectMake an iterator that computes the function using arguments from each  of the iterables.  Stops when the shortest iterable is exhausted.In other words, list(map(f, [1,2,3], 'abc')) is the equivalent of:Which is not what you want. You want to partially apply string.strip using " ()" as the second argument, but instead, " ()" is being take as another iterable of arguments. So, straightforward solution, use a helper function:You could make a factor function if you will be needing to be flexible:
Using lambda function it can be achieved as follows:


Answer URL
https://docs.python.org/3/library/functions.html#map
