Natural Text
I wonder why Python behaves differently in the cases below?Case 1. I change local integer variable but global variable remains the same. Well, that's OK.Case 2. I change property of local object... and it seems that I've changed global object.Maybe I have incomplete understanding about can object actually be local or not? In that case how can I code something similar to "local object"?
In python, arguments to functions are passed by assignment. [1]And in python, objects are not copied on assignment.So in your second example, to make what you call a local copy of the object, you will have to copy it explicitly, for instance using copy.deepcopy(x) [2]So your second code would become:[1] https://docs.python.org/3.4/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference [2] https://docs.python.org/3/library/copy.html
Your comparing apples to oranges(or whatever you wanna say). In your first case you were trying to change the value of a global variable inside of a function. Your global variable did not change when you called a function because Python passes variables by assignment not by reference. Observe what happens when we pass by assignment in your first case:This behavior is documented in Python3 FAQ:Remember that arguments are passed by assignment in Python. Since assignment just creates references to objects, thereâ€™s no alias between an argument name in the caller and callee, and so no call-by-reference per se.The emphasis is mine. In your second case, you did not change the value of a global variable. Obj1 is an object not a variable. You changed the attribute of Obj1 not Obj1 itself. See what happens when we attempt to pass Obj1 by reference:


Answer URL
https://docs.python.org/3/library/copy.html
https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference
