Natural Text
the getitem method to overload the [] (indexing operator) for this class: an index of 0 returns the value of the first field name in the field_names list; an index of 1 returns the value of the second field name in the field_names list, etc. Also, the index can be a string with the named field. So, for p = Point(1,2) writing p.get_x(), or p[0]), or p['x'] returns a result of 1. Raise an IndexError with an appropriate message if the index is out of bounds int or a string that does not name a field. I am not sure how to fix the getitme function. below is the bsc.txtcan someone tell how to fix my _getitem _ function to get the output in bsc.txt? many thanks. 
You've spelled __getitem__ incorrectly. Magic methods require two __ underscores before and after them.So you haven't overloaded the original __getitem__ method, you've simply created a new method named _getitem_.
Python 3 does not allow strings and integers to be compared with > or <; it's best to stick with == if you don't yet know the type of i. You could use isinstance, but here you can easily convert the only two valid integer values to strings (or vice versa), then work only on strings.
your function is interesting, but there are some issues with it:In python 3 you can't compare string with numbers, so you first should check with == against know values and or types. For exampleBut defined like that (in your code or in the example above) for an instance t1 this t1[X] for all string X others than "x" or "y" will always fail as you don't adjust it for any other value. And that is because  pnamedtuple looks like you want for it to be a factory like collections.namedtuple, but it fail to be general enough because you don't use any the arguments of your function at all. And no, type_name is not used either, whatever value it have is throw away when you make the class declaration.how to fix it?You need other ways to store the value of the fields and its respective name, for example a dictionary lets call it self._dataTo remember how you called yours field, use the argument of your function, for instance self._fields = field_namesTo accept a unknown number of arguments use * like __init__(self, *values) then verify that you have the same numbers of values and fields and build your data structure of point 1 (the dictionary)Once that those are ready then __getitem__ become something like: or you can simple inherit from a appropriate namedtuple and the only thing you need to do is overwrite its __getitem__ like


Answer URL
https://docs.python.org/3/library/collections.html#collections.namedtuple
