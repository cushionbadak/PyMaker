Natural Text
I'm using the list.count() method to check if a relationship has an element.While it works pretty well in a test code, it doesnt anymore when the counted class inherits the flask_login UserMixin class.Why , and how to fix it ?I should get the number of elements in the list (1 or 0 ).Instead I get the whole list length (2, even if I append more integers).It is as if it was counting class occurrences in the list, not the object.
First of all lets understand how list.count works. From the cpython source code the list.count has the following definition.So when you perform some_list.count(some_element), Python will iterate over every object in the list, and perform a rich comparison(ie, PyObject_RichCompareBool). From the C-API documentation the rich comparison(ie, PyObject_RichCompareBool(PyObject *o1, PyObject *o2, int opid)) will Compare the values of o1 and o2 using the operation specified by opid, which must be one of Py_LT, Py_LE, Py_EQ, Py_NE, Py_GT, or Py_GE, corresponding to <, <=, ==, !=, >, or >= respectively. Returns -1 on error, 0 if the result is false, 1 otherwise.So if the value is 1(ie, true) a counter will be incremented. After the iteration the counter will be return back to the caller.list_count in CPython roughly equivalent to the following in python layer,Now lets get back to your question.While it works pretty well in a test code, it doesnt anymore when the  counted class inherits the flask_login UserMixin class.Lets take a sample class(Without inheriting from UserMixin)This will print 1 as we expected. But how does python perform the comparison here???. By default python will compare the id(ie, memory address of the object) of p1 with ids of p1, p2, p3. Since each new object have different ids , count method will return 1.Ok, So what if we want to count the person as one if there names are equal???Let take the same example.But This still return 1 as python still comparing with its object ids. So how can I customize this?. You can override __eq__ of the object.  ie,Wow now it return 2 as expected.Now lets consider the class which inherit from   UserMixin.This will print 2. Why?. If the comparison was performed based on ids it would have been 1. So there will be an  __eq__ implemented somewhere. So if you look at the UserMixin class implementation it implement __eq__ method.As you can see the comparison is performed based on its id attribute. In this case Element class set the id attribute on the class level hence it will be same for all instances.How to fix this,From the logical perspective every object will have unique ids. Hence id should be a instance level attribute. See one example from the flask-login code base itself.
This 'id' issue is the key point. Back to the sqlalchemy context, the list holds objects with an id as primarykey ... set to 'None' at first for all objects.And it will be updated only after a session.add() and session.commit(), the final fix. Thanks.


Answer URL
https://docs.python.org/3/c-api/object.html#c.PyObject_RichCompare
