Natural Text
I have a module method which takes in a python list, and then outputs the same list with all items multiplied by 100.I've attemped to follow the C intro here as close as possible but still running into issues.The above complies fine, however when I run in ipython, I get the below error.If I take away the error handling I get a seg fault.Any help is appreciated.
So you have a number of issues that all need to be corrected. I've listed them all under separate headings so you can go through them one at a time.Always returning listObjWhen you get an error in your for loop, you would goto the error label, which was still returning the list. By returning this list you hide that there was an error in your function. You must always return NULL when you expect your function to raise an exception.Does not increment listObj ref count on returnWhen your function is invoked you are given a borrowed reference to your arguments. When you return one of those arguments you are creating a new reference to your list, and so must increment its reference count. Otherwise the interpreter will have a reference count that is one lower than the number of actual references to the object. This will end up with a bug where the interpreter deallocates your list when there is only 1 reference rather than 0! This could result in a seg fault, or it could in the worst case scenario result in random parts of the program access the that has since been deallocated and allocated for some other object.Uses PyObject_SetItem with primitivePyObject_SetItem can be used with dicts and other class that implements obj[key] = val. So you cannot supply it with an argument of type Py_ssize_t. Instead, use PyList_SetItem which only accepts Py_ssize_t as its index argument.Bad memory handling of item and incremented_itemPyObject_SetItem and PyList_SetItem both handle decreasing the reference count of the object that was already at the position that was being set. So we don't need to worry about managing the reference count of item as we are only working with a reference borrowed from the list. These pair of functions also steal a reference to incremented_item, and so we don't need to worry about managing its reference count either.Memory leak on incorrect argumentsFor example, when you call your function with an int. You will create a new reference to the 100 int object, but because you return NULL rather than goto error, this reference will be lost. As such you need to handle such scenarios differently. In my solution, I move the PyLong_FromLong call to after the arg and type checking. In this way we are only create this new* object once we are guaranteed it will be used.Working codeSide note: I removed the goto statements as there was only one left, and so it made more sense to do the error handling at that point rather than later.Footnote:* PyLong_FromLong(100) doesn't actually create a new object, but rather returns a new reference to an existing object. Integers with low values (0 <= i < 128 I think) are all cached and this same object is returned when needed. This is an implementation detail that is meant to avoid high levels of allocating and deallocating integers for small values, and so improve the performance of Python.


Answer URL
https://docs.python.org/3/c-api/intro.html
https://docs.python.org/3/c-api/object.html#c.PyObject_SetItem
https://docs.python.org/3/c-api/list.html#c.PyList_SetItem
https://docs.python.org/3/c-api/long.html#c.PyLong_FromLong
