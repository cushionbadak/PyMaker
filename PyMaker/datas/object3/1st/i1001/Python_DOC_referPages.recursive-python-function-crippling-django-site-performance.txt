Natural Text
I have a Django site with a Category model, each instance of which can hold zero to n subcategories.The categories are stored in a MySQL database. I need to build a nested HTML list of all categories.As a down and dirty way of getting this off the ground, I initially did this via a recursive function.This worked fine initially, but now there are over 800 categories and it's causing requests to slow down drastically. When running the development server, it's taking at least 60 seconds a go.Here's the function, simplified slightly:with the function initially called as follows:It generates the result I want, but at the expense of efficiency and time.I understand the basic performance issues with Python and recursion, but can this be salvaged or does it require a fundamentally different approach?
This is an educated guess: the performance issue you're experiencing is most likely due to the number of queries hitting the database, not to the recursive function to generate the template.subcategories = category.subcategories.all()Since you're not using any prefetching, the line above will trigger a query for each category you recursively visit, so with 800 top level categories you'll get 800 just to start with. Additionally, you're also performing a count query for each one:if subcategories.count() == 0:You could improve things a bit by using Django built-in eager loading for model relationships.Consider though that efficiently storing and querying a tree structure in a relational DB requires some clever algorithms. So I suggest to use (or at least draw inspiration from) this Django package:https://django-treebeard.readthedocs.io/en/latest/This is used by a Wagtail, a popular Django CMS that supports nested categories.This package implements three different strategies to store and query tree structures:Adjacency ListMaterialized PathNested SetsAnother popular alternative is this one:https://github.com/django-mptt/django-mpttI would recommend against a "home-made" solution in your case as you already have a considerable number of categories to handle, so performance already matters in your case). Implementing these algorithms by yourself from scratch wouldn't be trivial at all.


Answer URL
https://docs.python.org/3/library/profile.html
