Natural Text
I'm trying to use queue.PriorityQueue in Python 3(.6).I would like to store objects with a given priority.  But if two objects have the same priority, I don't mind PriorityQueue.get to return either.  In other words, my objects can't be compared at integers, it won't make sense to allow them to be, I just care about the priority.In Python 3.7's documentation, there's a solution involving dataclasses.  And I quote:If the data elements are not comparable, the data can be wrapped in a class that ignores the data item and only compares the priority number:Alas, I'm using Python 3.6.  In the documentation of this version of Python, there's no comment on using PriorityQueue for the priorities, not bothering about the "object value" which wouldn't be logical in my case.Is there a better way than to define __le__ and other comparison methods on my custom class?  I find this solution particularly ugly and counter-intuitive, but that might be me.
dataclasses is just a convenience method to avoid having to create a lot of boilerplate code.You don't actually have to create a class. A tuple with a unique counter value too:so that ties between equal priority are broken by the integer that follows; because it is always unique the item value is never consulted.You can also create a class using straight-up rich comparison methods, made simpler with @functools.total_ordering:
See priority queue implementation notes - just before the section you quoted (regarding using dataclasses) it tells you how to do it whitout them:... is to store entries as 3-element list including the priority, an entry count, and the task. The entry count serves as a tie-breaker so that two tasks with the same priority are returned in the order they were added. And since no two entry counts are the same, the tuple comparison will never attempt to directly compare two tasks.So simply add your items as 3rd element in a tuple (Prio, Count, YourElem) when adding to your queue. Contreived example:Using h.put( (1, O('write spec 1')) )  leads to Using def add(prioqueue,prio,item): pushes triplets as items wich have guaranteed distinct 2nd values so our O()-instances are never used as tie-breaker.Output:see MartijnPieters answer @here for a nicer unique 2nd element.
Let's assume that we don't want to write a decorator with equivalent functionality to dataclass. The problem is that we don't want to have to define all of the comparison operators in order to make our custom class comparable based on priority. The @functools.total_ordering decorator can help. Excerpt:Given a class defining one or more rich comparison ordering methods, this class decorator supplies the rest. This simplifies the effort involved in specifying all of the possible rich comparison operations:The class must define one of __lt__(), __le__(), __gt__(), or __ge__(). In addition, the class should supply an __eq__() method.Using the provided example:
All you need is a wrapper class that implements __lt__ in order for PriorityQueue to work correctly. This is noted here:The sort routines are guaranteed to use __lt__() when making comparisons between two objects. So, it is easy to add a standard sort order to a class by defining an __lt__() methodIt's as simple as something like thisIf your elements do not have priorities then it's as simple as:Now you can use PriorityQueue like soGetting at your original elements in that case would be as simple as Since you don't care about sort stability that's all you need.Edit: As noted in the comments and confirmed here, heappush is not stable: unlike sorted(), this implementation is not stable.


Answer URL
https://docs.python.org/3/library/functools.html#functools.total_ordering
https://docs.python.org/3/library/functools.html#functools.total_ordering
https://docs.python.org/3/howto/sorting.html#odd-and-ends
https://docs.python.org/3/library/heapq.html
