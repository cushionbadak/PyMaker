Natural Text
I needed to create a list of lists in Python, so I typed the following:  The list looked like this:  Then I changed one of the innermost values:  Now my list looks like this:  which is not what I wanted or expected. Can someone please explain what's going on, and how to get around it?
When you write [x]*3 you get, essentially, the list [x, x, x]. That is, a list with 3 references to the same x. When you then modify this single x it is visible via all three references to it.To fix it, you need to make sure that you create a new list at each position. One way to do it iswhich will reevaluate [1]*4 each time instead of evaluating it once and making 3 references to 1 list.You might wonder why * can't make independent objects the way the list comprehension does. That's because the multiplication operator * operates on objects, without seeing expressions. When you use * to multiply [[1] * 4] by 3, * only sees the 1-element list [[1] * 4] evaluates to, not the [[1] * 4 expression text. * has no idea how to make copies of that element, no idea how to reevaluate [[1] * 4], and no idea you even want copies, and in general, there might not even be a way to copy the element.The only option * has is to make new references to the existing sublist instead of trying to make new sublists. Anything else would be inconsistent or require major redesigning of fundamental language design decisions.In contrast, a list comprehension reevaluates the element expression on every iteration. [[1] * 4 for n in range(3)] reevaluates [1] * 4 every time for the same reason [x**2 for x in range(3)] reevaluates x**2 every time. Every evaluation of [1] * 4 generates a new list, so the list comprehension does what you wanted.Incidentally, [1] * 4 also doesn't copy the elements of [1], but that doesn't matter, since integers are immutable. You can't do something like 1.value = 2 and turn a 1 into a 2.
Live Python Tutor Visualize
Actually, this is exactly what you would expect. Let's decompose what is happening here:You writeThis is equivalent to:This means lst is a list with 3 elements all pointing to lst1. This means the two following lines are equivalent:As lst[0] is nothing but lst1.To obtain the desired behavior, you can use list comprehension:In this case, the expression is re-evaluated for each n, leading to a different list.
or even:Creates a list that references the internal [1,1,1,1] 3 times - not three copies of the inner list, so any time you modify the list (in any position), you'll see the change three times.It's the same as this example:where it's probably a little less surprising.
Alongside the accepted answer that explained the problem correctly, within your list comprehension, if You are using python-2.x use xrange() that returns a generator which is more efficient (range() in python 3 does the same job) _ instead of the throwaway variable n: Also, as a much more Pythonic way you can use itertools.repeat() to create an iterator object of repeated elements :P.S. Using numpy, if you only want to create an array of ones or zeroes you can use np.ones and np.zeros and/or for other number use np.repeat():
In simple words this is happening because in python everything works by reference, so when you create a list of list that way you basically end up with such problems.To solve your issue you can do either one of them:1. Use numpy array documentation for numpy.empty2. Append the list as you get to a list.3. You can also use dictionary if you want  
Python containers contain references to other objects. See this example:In this b is a list that contains one item that is a reference to list a. The list a is mutable.The multiplication of a list by an integer is equivalent to adding the list to itself multiple times (see common sequence operations). So continuing with the example:We can see that the list c now contains two references to list a which is equivalent to c = b * 2.Python FAQ also contains explanation of this behavior: How do I create a multidimensional list?
myList = [[1]*4] * 3 creates one list object [1,1,1,1] in memory and copies its reference 3 times over. This is equivalent to obj = [1,1,1,1]; myList = [obj]*3. Any modification to obj will be reflected at three places, wherever obj is referenced in the list.The right statement would be:orImportant thing to note here is that * operator is mostly used to create a list of literals. Since 1 is a literal, hence obj =[1]*4 will create [1,1,1,1] where each 1 is atomic and not a reference of 1 repeated 4 times. This means if we do obj[2]=42, then obj will become [1,1,42,1] not [42,42,42,42] as some may assume.
Let us rewrite your code in the following way:Then having this, run the following code to make everything more clear. What the code does is basically print the ids of the obtained objects, whichReturn the “identity” of an objectand will help us identify them and analyse what happens:And you will get the following output:So now let us go step-by-step. You have x which is 1, and a single element list y containing x. Your first step is y * 4 which will get you a new list z, which is basically [x, x, x, x], i.e. it creates a new list which will have 4 elements, which are references to the initial x object. The net step is pretty similar. You basically do z * 3, which is [[x, x, x, x]] * 3 and returns [[x, x, x, x], [x, x, x, x], [x, x, x, x]], for the same reason as for the first step.
I guess everybody explain what is happening.I suggest one way to solve it:myList = [[1 for i in range(4)] for j in range(3)]print myListAnd then you have:
Trying to explain it more descriptively,Operation 1:Operation 2:Noticed why doesn't modifying the first element of the first list didn't modify the second element of each list? That's because [0] * 2 really is a list of two numbers, and a reference to 0 cannot be modified.If you want to create clone copies, try Operation 3:another interesting way to create clone copies, Operation 4:
By using the inbuilt list function you can do like this


Answer URL
https://docs.python.org/3/library/stdtypes.html#typesseq-common
https://docs.python.org/3/faq/programming.html#faq-multidimensional-list
