Natural Text
My clock cache is not working. What I'm doing:if key in self.items_to_index: set bit to 1, return the value from self.buffers.if not:call function on input to get newval.call self._increment() until we see an entry in self.buffers with bit set to 0.self.buffers[self._p] is now equal to [newval, 1]Remove the dictionary entry with _p equal to that entry. Then do self.items_to_index[k] = _p.increment p.My code for what's described above is: [not working] The entire class is attached her for reference:How I'm testing this and my test results:Diff file:
Values are never added to the self.items_to_index dictionary, so values are never returned from cache. You can fix that by changing ClockMap.__getitem__() to handle the case that the current pointer is not in the index:Note the else block added to the for loop. This handles the case that the current pointer is not already in the index and adds it if so.Your cache resembles a LRU cache. If you are using Python 3 you might want to check out the functools.lru_cache decorator, e.g.
I believe its because of the lineself.items_to_index is initialized to be empty and isn't updated outside of the above loop, so any code inside the loop would never run.


Answer URL
https://docs.python.org/3/library/functools.html#functools.lru_cache
https://docs.python.org/3/reference/compound_stmts.html#the-for-statement
