Natural Text
I have a the following programme:What I expect this programme to do is: it loops through the dictionary keys, which comprises an embedded list of a 'number' (i.e. 1,1,3,6) and 'unit' (i.e. weeks and months), and extracts the correct value (or rate). Currently I get an error with the line print deposits([n,unit]).Here is the error I get:The name of my file is TestFunction.pyI know a way round this issue, which is where I convert the dictionary into two lists as follows:But then it does not look as tidy or as sophisticated. I'd be really grateful for your advice.
deposits is a dictionary with keys and values. The reference of a dictionary isThus given n and unit you get that ql.Period(n, unit) returns a type of <class 'QuantLib.QuantLib.Period'>. The result of ql.period(1, ql.Weekly) for example would be 1W.It would appear that if it is converted to a string, then it would be usable as a key.
Update per comments: It looks like the Period class implemented __hash__ incorrectly, so it doesn't obey the hash invariant required by Python (specifically, objects that compare equal should hash to the same value). Per your comment, when you run:you get 10, so p1==p2 is True.When you run:you get 0, so hash(p1) == hash(p2) is False. This is a clear violation of the Python rules, which makes the type appear to be a legal key for a dict (or value in a set), but behave incorrectly. Basically, you can't use Periods as keys without having the QuantLib folks fix this, or doing terrible things to work around it (and really terrible things if Period is a C extension type, which seems likely since QuantLib is apparently a SWIG wrapper).If the Period units behave properly, I'd recommend working with tuples of the paired counts and units most of the time, and only converting to Periods when you have need of a particular Period feature. So your dict would be:and your loop would be:If that still fails, then even the basic unit types are broken, and you just can't use them at all.If the keys are ql.Periods, you need to look up using ql.Periods (unless Period is tuple subclass). You also need to use brackets for dict lookup, not parentheses.If ql.Period is a namedtuple or the like, you can just do tuple lookup (lists can't be dict keys, because they're mutable):If ql.Period isn't a tuple subclass, you can do:or to make the periods in the loop,
In addition to the syntax problems others have identified, my guess is that your ql.Period object is not hashable; the keys for dictionaries need to be hashable objects.  Here's a direct copy-and-past from this answer, which explains the situation nicely.What happens when you try hash(ql.Period(1,ql.Weeks))?  A similar TypeError?  If you had control over QuantLib, you could possibly add a __hash__ method, so that they could be used in dictionaries.  But I see that such a module exists on pypi, so I guess you're just using it rather than writing it.You may still be able to monkey patch these objects to give them a __hash__ method:


Answer URL
https://docs.python.org/3/reference/datamodel.html?highlight=__hash__#object.__hash__
