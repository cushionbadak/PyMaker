Natural Text
Given a set What's a good way to produce the subsets:
The Python itertools page has exactly a powerset recipe for this:Output:If you don't like that empty tuple at the beginning, you can just change the range statement to range(1, len(s)+1) to avoid a 0-length combination.
Here is more code for a powerset. This is written from scratch:Mark Rushakoff's comment is applicable here: "If you don't like that empty tuple at the beginning, on."you can just change the range statement to range(1, len(s)+1) to avoid a 0-length combination", except in my case you change for i in range(1 << x) to for i in range(1, 1 << x).Returning to this years later, I'd now write it like this:And then the test code would look like this, say:Using yield means that you do not need to calculate all results in a single piece of memory. Precalculating the masks outside the main loop is assumed to be a worthwhile optimization.
If you're looking for a quick answer, I just searched "python power set" on google and came up with this: Python Power Set GeneratorHere's a copy-paste from the code in that page:This can be used like this:Now r is a list of all the elements you wanted, and can be sorted and printed:

There is a refinement of powerset:
For example:yield
I just wanted to provide the most comprehensible solution, the anti code-golf version.The resultsAll sets of length  0[()]All sets of length  1[('x',), ('y',), ('z',)]All sets of length  2[('x', 'y'), ('x', 'z'), ('y', 'z')]All sets of length  3[('x', 'y', 'z')]For more see the itertools docs, also  the wikipedia entry on power sets
I have found the following algorithm very clear and simple:Another way one can generate the powerset is by generating all binary numbers that have n bits. As a power set the amount of number with n digits is 2 ^ n. The principle of this algorithm is that an element could be present or not in a subset as a binary digit could be one or zero but not both.I found both algorithms when I was taking MITx: 6.00.2x Introduction to Computational Thinking and Data Science, and I consider it is one of the easiest algorithms to understand I have seen.
Just a quick power set refresher !Power set of a set X, is simply the set of all subsets of X including  the empty setExample set X = (a,b,c) Power Set = { { a , b , c } , { a , b } , { a , c } , { b , c } , { a } , { b } , { c } , { } }Here is another way of finding power set:full credit to source
TL;DR (go directly to Simplification)I know I have previously added an answer, but I really like my new implementation. I am taking a set as input, but it actually could be any iterable, and I am returning a set of sets which is the power set of the input. I like this approach because it is more aligned with the mathematical definition of power set (set of all subsets). If you want exactly the output you posted in your answer use this:ExplanationIt is known that the number of elements of the power set is 2 ** len(A), so that could clearly be seen in the for loop.I need to convert the input (ideally a set) into a list because by a set is a data structure of unique unordered elements, and the order will be crucial to generate the subsets.selector is key in this algorithm. Note that selector has the same length as the input set, and to make this possible it is using an f-string with padding. Basically, this allows me to select the elements that will be added to each subset during each iteration. Let's say the input set has 3 elements {0, 1, 2}, so selector will take values between 0 and 7 (inclusive), which in binary are:So, each bit could serve as an indicator if an element of the original set should be added or not. Look at the binary numbers, and just think of each number as an element of the super set in which 1 means that an element at index j should be added, and 0 means that this element should not be added.I am using a set comprehension to generate a subset at each iteration, and I convert this subset into a frozenset so I can add it to ps (power set). Otherwise, I won't be able to add it because a set in Python consists only of immutable objects.SimplificationYou can simplify the code using some python comprehensions, so you can get rid of those for loops. You can also use zip to avoid using j index and the code will end up as the following:That's it. What I like of this algorithm is that is clearer and more intuitive than others because it looks quite magical to rely on itertools even though it works as expected.
This is wild because none of these answers actually provide the return of an actual Python set. Here is a messy implementation that will give a powerset that actually is a Python set. I'd love to see a better implementation, though.
Here is my quick implementation utilizing combinations but using only built-ins.
A simple way would be to harness the internal representation of integers under 2's complement arithmetic. Binary representation of integers is as {000, 001, 010, 011, 100, 101, 110, 111} for numbers ranging from 0 to 7. For an integer counter value, considering 1 as inclusion of corresponding element in collection and '0' as exclusion we can generate subsets based on the counting sequence. Numbers have to be generated from 0 to pow(2,n) -1 where n is the length of array i.e. number of bits in binary representation.A simple Subset Generator Function based on it can be written as below. It basically relies and then it can be used asTestingAdding following in local filegives following output


Answer URL
https://docs.python.org/3/library/itertools.html#itertools-recipes
