Natural Text
My problem is as follows:I have a class that inherits from threading.Thread that I want to be able to stop gracefully. This class also has a Queue it get's its work from.Since there are quite some classes in my project that should have this behaviour, I've created some superclasses to reduce duplicate code like this:Thread related behaviour:Queue related behaviour:Combining the two above and adding queue.join() to the stop() callA base class for a datasource:An implementation for a datasource:Suppose there is a CSVDataSource instance called ds, if I want to stop the thread I call:The ds.join() call however, never returns. I'm not sure why this is, because the run() method does check if the stop event is set.Any Ideas?UpdateA little more clarity as requested: the applications is build up out of several threads. The RealStrategy thread (below) is the owner of all the other threads and is responsible for starting and terminating them. I haven't set the daemon flag for any of the threads, so they should be non-daemonic by default.The main thread looks like this:And here are the rs.run_engine() and rs.stop_engine() methods that are called in main:
If you want to use queue.Queue.join, then you must also use queue.Queue.task_done. You can read the linked documentation or see the following copied from information available online:Queue.task_done()Indicate that a formerly enqueued task is complete.  Used by queue consumer threads. For each get() used to fetch a task, a  subsequent call to task_done() tells the queue that the processing on  the task is complete.If a join() is currently blocking, it will resume when all items have  been processed (meaning that a task_done() call was received for every  item that had been put() into the queue).Raises a ValueError if called more times than there were items placed  in the queue.Queue.join()Blocks until all items in the queue have been gotten and processed.The count of unfinished tasks goes up whenever an item is added to the  queue. The count goes down whenever a consumer thread calls  task_done() to indicate that the item was retrieved and all work on it  is complete. When the count of unfinished tasks drops to zero, join()  unblocks.To test your problem, an example implementation was created to find out what was going on. It is slightly different from how your program works but demonstrates a method to solving your problem:


Answer URL
https://docs.python.org/3/library/queue.html#queue.Queue.join
https://docs.python.org/3/library/queue.html#queue.Queue.task_done
