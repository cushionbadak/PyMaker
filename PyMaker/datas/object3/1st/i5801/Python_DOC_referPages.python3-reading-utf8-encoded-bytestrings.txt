Natural Text
My program uses the output from "iwlist scan" to generate a report.It works fine except when the network name (ESSID) contains non-Ascii characters.IEEE802.11 state that ESSID may contain UTF8 characters. However these essid are reported by iwlist as an encoded bytestring. Example:      ESSID:"f\xC3\xAAte"\xC3\xAA is effectively the UTF-8 encoding of "ê"I can't find a way to specify to 'open' that these bytestrings should be automatically converted into UTF-8 characters.Question: what is the most pythonic way to solve my problem?PS: as a test case, I put the following line in a file (say xx):ESSID:"f\xC3\xAAte"and I execute:open( 'xx','rb').read().decode('UTF-8')and my result is:'ESSID:"f\xC3\xAAte"\n' 
This is actually a two-step process: convert the \xNN codes to the equivalent byte value, then convert those bytes from UTF-8 to Unicode characters. Python provides a unicode_escape codec to make the process simpler. Unfortunately you need an extra step - it won't convert the \xNN to bytes, it converts them to characters and you need to convert those back to the equivalent bytes.So you end up with a 3-step conversion. Encoding to latin1 is a hack to convert characters to bytes. It works because Unicode uses the Latin-1 encoding for its first 256 codepoints giving you a 1:1 mapping.
As far as I understood your problem:Looks like your file doesn't have Unicode characters at all, but instead, it has an escaped string. So instead of one ê symbol you actually have 8 characters — \xC3\xAA. So instead of decoding from Unicode with .decode("utf-8") you should decode from unicode escape characters (.decode('unicode_escape').To try this I made a file with a string:ESSID:"f\xC3\xAAte"then this script prints the following:And if you use unicode_escape instead, you will get
I'm answering to myself.Cannot find a python solution so I developed mine.Method is to remove '\x' and convert 2 hex characters to a byte. Repeat for each \x.Usage:It is an ugly hack but it works fine. I would gladly like a nicer solution.Thanks for your answers.


Answer URL
https://docs.python.org/3/library/codecs.html#python-specific-encodings
