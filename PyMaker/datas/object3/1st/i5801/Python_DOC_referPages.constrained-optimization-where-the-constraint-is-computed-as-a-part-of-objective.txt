Natural Text
I made a function f that takes a long time to run. The constraints are calculated at the end of f's routine. How can I return these constraints to cobyla without evaluating f twice?
LRU CacheThis is implementing Paul Panzer's suggestion, it relies on @lru_cache which is a Python 3 feature. We cannot directly apply this decorator to the objective function, because it receives a NumPy array, which is mutable and therefore not hashable. So we need two functions: func_with_cons computes the objective and constraint, given scalar arguments.f calls func_with_cons and returns either objective or constraint, based on returncons argument. Note that we need consargs parameter in the call to fmin_cobyla, because without it the same extra arguments args will be passed to the constraint function. Output: So, the cache works. I changed the constraint from x1-x0 to x0-x1 to show that it also works (the original constraint x1-x0 is satisfied by the global minimum of this function, so it would have no effect on the result). Cache size can be much smaller: with maxsize=2 we would have 40 hits (vs 41 with the above size). Global variableThis is implementing Jakob Lovern's suggestion. The function f stores the constraint in a global variable, from which the function cons retrieves it. The use of a global has obvious drawbacks, but then again, this works in Python 2.7.  This returns [ 1.14491021,  1.14491021] since the global minimum [2, 4] is disallowed by the constraint.


Answer URL
https://docs.python.org/3/library/functools.html#functools.lru_cache
