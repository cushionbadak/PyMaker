Natural Text
Is there a way to declare a constant in Python? In Java we can create constant values in this manner:What is the equivalent of the above Java constant declaration in Python?
No there is not. You cannot declare a variable or value as constant in Python. Just don't change it.If you are in a class, the equivalent would be:if not, it is justBut you might want to have a look at the code snippet Constants in Python by Alex Martelli.
There's no const keyword as in other languages, however it is possible to create a Property that has a "getter function" to read the data, but no "setter function" to re-write the data. This essentially protects the identifier from being changed.Here is an alternative implementation using class property:Note that the code is far from easy for a reader wondering about constants. See explanation belowCode Explanation:Define a function constant that takes an expression, and uses it to construct a "getter" - a function that solely returns the value of the expression.The setter function raises a TypeError so it's read-onlyUse the constant function we just created as a decoration to quickly define read-only properties.And in some other more old-fashioned way:(The code is quite tricky, more explanations below)Note that the @apply decorator seems to be deprecated.To define the identifier FOO, firs define two functions (fset, fget - the names are at my choice).Then use the built-in property function to construct an object that can be "set" or "get".Note hat the property function's first two parameters are named fset and fget. Use the fact that we chose these very names for our own getter & setter and create a keyword-dictionary using the ** (double asterisk) applied to all the local definitions of that scope to pass parameters to the property function
In Python instead of language enforcing something, people use naming conventions e.g __method for private methods and using _method for protected methods.So in same manner you can simply declare the constant as all caps e.g.If you want that this constant never changes, you can hook into attribute access and do tricks, but a simpler approach is to declare a functionOnly problem is everywhere you will have to do MY_CONSTANT(), but again MY_CONSTANT = "one" is the correct way in python(usually).You can also use namedtuple to create constants:
I've recently found a very succinct update to this which automatically raises meaningful error messages and prevents access via __dict__:We define over ourselves as to make ourselves an instance and then use slots to ensure that no additional attributes can be added. This also removes the __dict__ access route. Of course, the whole object can still be redefined.Edit - Original solutionI'm probably missing a trick here, but this seems to work for me:Creating the instance allows the magic __setattr__ method to kick in and intercept attempts to set the FOO variable. You could throw an exception here if you wanted to. Instantiating the instance over the class name prevents access directly via the class.It's a total pain for one value, but you could attach lots to your CONST object. Having an upper class, class name also seems a bit grotty, but I think it's quite succinct overall.
As you probably already know, Python doesn't have constants :(Perhaps the easiest alternative is to define a function for it. E.g.MY_CONSTANT() now has all the functionality of a constant (plus some annoying braces).
In addition to the two top answers (just use variables with UPPERCASE names, or use properties to make the values read-only), I want to mention that it's possible to use metaclasses in order to implement named constants.  I provide a very simple solution using metaclasses at GitHub which may be helpful if you want the values to be more informative about their type/name:This is slightly more advanced Python, but still very easy to use and handy.  (The module has some more features, including constants being read-only, see its README.)There are similar solutions floating around in various repositories, but to the best of my knowledge they either lack one of the fundamental features that I would expect from constants (like being constant, or being of arbitrary type), or they have esoteric features added that make them less generally applicable.  But YMMV, I would be grateful for feedback. :-)
Edit: Added sample code for Python 3Note: this other answer looks like it provides a much more complete implementation similar to the following (with more features).First, make a metaclass:This prevents statics properties from being changed. Then make another class that uses that metaclass:Or, if you're using Python 3:This should prevent instance props from being changed. To use it, inherit:Now the props, accessed directly or via an instance, should be constant:Here's an example of above in action. Here's another example for Python 3.
Properties are one way to create constants. You can do it by declaring a getter property, but ignoring the setter. For example:You can have a look at an article I've written to find more ways to use Python properties.
Here is an implementation of a "Constants" class, which creates instances with read-only (constant) attributes. E.g. can use Nums.PI to get a value that has been initialized as 3.14159, and Nums.PI = 22 raises an exception.Thanks to @MikeGraham 's FrozenDict, which I used as a starting point. Changed, so instead of Nums['ONE'] the usage syntax is Nums.ONE.And thanks to @Raufio's answer, for idea to override __ setattr __.Or for an implementation with more functionality, see @Hans_meine 'snamed_constants at GitHub
I would make a class that overrides the __setattr__ method of the base object class and wrap my constants with that, note that I'm using python 2.7:To wrap a string:It's pretty simple, but if you want to use your constants the same as you would a non-constant object (without using constObj.value), it will be a bit more intensive. It's possible that this could cause problems, so it might be best to keep the .value to show and know that you are doing operations with constants (maybe not the most 'pythonic' way though).
You can use a namedtuple as a workaround to effectively create a constant that works the same way as a static final variable in Java (a Java "constant"). As workarounds go, it's sort of elegant. (A more elegant approach would be to simply improve the Python language --- what sort of language lets you redefine math.pi? -- but I digress.)(As I write this, I realize another answer to this question mentioned namedtuple, but I'll continue here because I'll show a syntax that more closely parallels what you'd expect in Java, as there is no need to create a named type as namedtuple forces you to do.)Following your example, you'll remember that in Java we must define the constant inside some class; because you didn't mention a class name, let's call it Foo. Here's the Java class:Here's the equivalent Python.The key point I want to add here is that you don't need a separate Foo type (an "anonymous named tuple" would be nice, even though that sounds like an oxymoron), so we name our namedtuple _Foo so that hopefully it won't escape to importing modules.The second point here is that we immediately create an instance of the nametuple, calling it Foo; there's no need to do this in a separate step (unless you want to). Now you can do what you can do in Java:But you can't assign to it:Acknowledgement: I thought I invented the namedtuple approach, but then I see that someone else gave a similar (although less compact) answer. Then I also noticed What are "named tuples" in Python?, which points out that sys.version_info is now a namedtuple, so perhaps the Python standard library already came up with this idea much earlier.Note that unfortunately (this still being Python), you can erase the entire Foo assignment altogether:(facepalm)But at least we're preventing the Foo.CONST_NAME value from being changed, and that's better than nothing. Good luck.
Unfortunately the Python has no constants so yet and it is shame. ES6 already added support constants to JavaScript (https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/const) since it is a very useful thing in any programming language.As answered in other answers in Python community use the convention - user uppercase variable as constants, but it does not protect against arbitrary errors in code.If you like, you may be found useful a single-file solution as next(see docstrings how use it).file constants.pyIf this is not enough, see full testcase for it.Advantages: 1. Access to all constants for whole project 2. Strict control for values of constantsLacks: 1. Not support for custom types and the type 'dict'Notes:Tested with Python3.4 and Python3.5 (I am use the 'tox' for it)Testing environment:.
A tuple technically qualifies as a constant, as a tuple will raise an error if you try to change one of its values. If you want to declare a tuple with one value, then place a comma after its only value, like this:To check this variable's value, use something similar to this:  If you attempt to change this value, an error will be raised.
The Pythonic way of declaring "constants" is basically a module level variable:And then write your classes or functions. Since constants are almost always integers, and they are also immutable in Python, you have a very little chance of altering it.Unless, of course, if you explicitly set RED = 2.
Python dictionaries are mutable, so they don't seem like a good way to declare constants:
In python, a constant is simply a variable with a name in all capitals, with words separated by the underscore character,e.gDAYS_IN_WEEK = 7The value is mutable, as in you can change it.  But given the rules for the name tell you is a constant, why would you?  I mean, it is your program after all!This is the approach taken throughout python.  There is no private keyword for the same reason.  Prefix the name with an underscore and you know it is intended to be private.  Code can break the rule....just as a programmer could remove the private keyword anyway. Python could have added a const keyword... but a programmer could remove keyword and then change the constant if they want to, but why do that?  If you want to break the rule, you could change the rule anyway.  But why bother to break the rule if the name makes the intention clear?Maybe there is some unit test where it makes sense to apply a change to value? To see what happens for an 8 day week even though in the real world the number of days in the week cannot be changed.  If the language stopped you making an exception if there is just this one case you need to break the rule...you would then have to stop declaring it as a constant, even though it still is a constant in the application, and there is just this one test case that sees what happens if it is changed.The all upper case name tells you it is intended to be a constant. That is what is important. Not a language forcing constraints on code you have the power to change anyway.That is the philosophy of python. 
There is a cleaner way to do this with namedtuple:Usage ExampleWith this exactly approach you can namespace your constants.
We can create a descriptor object.1) If we wanted to work with constants at the instance level then:2) if we wanted to create constants only at the class level, we could use a metaclass that serves as a container for our constants (our descriptor objects); all the classes that descend will inherit our constants (our descriptor objects) without any risk that can be modified.If I create a subclass of Foo, this class will inherit the constant without the possibility of modifying them
You can use StringVar or IntVar, etc, your constant is const_val
In Python, constants do not exist. But you can indicate that a variable is a constant and must not be changed by adding ' _CONSTANT ' to the start of the variable name, naming the variable in BLOCK CAPITALS, and adding a comment using the hashtag (' # ') e.g. :
Simply you can just:hope that makes everything much simpler 
(This paragraph was meant to be a comment on those answers here and there, which mentioned namedtuple, but it is getting too long to be fit into a comment, so, here it goes.)The namedtuple approach mentioned above is definitely innovative. For the sake of completeness, though, at the end of the NamedTuple section of its official documentation, it reads:enumerated constants can be implemented with named tuples, but it is simpler and more efficient to use a simple class declaration:In other words, the official documentation kind of prefers to use a practical way, rather than actually implementing the read-only behavior. I guess it becomes yet another example of Zen of Python:Simple is better than complex.practicality beats purity.
Maybe pconst library will help you (github).$ pip install pconst[Out] Constant value of "APPLE_PRICE" is not editable.
In my case, I needed immutable bytearrays for an implementation of a crypto library containing many literal numbers I wanted to ensure were constant.This answer works but attempted reassignment of bytearray elements does not raise an error.Constants are immutable, but constant bytearray assignment fails silently:A more powerful, simple, and perhaps even more 'pythonic' approach involves the use of memoryview objects (buffer objects in <= python-2.6).ConstArray item assignment is a TypeError:
I write a util lib for python const: kkconst - pypi support str, int, float, datetime the const field instance will keep its base type behavior.For example:more details usage you can read the pypi url:  pypi  or  github 
You can wrap a constant in a numpy array, flag it write only, and always call it by index zero.of course this only protects the contents of the numpy, not the variable "CONSTANT" itself; you can still do:and CONSTANT would change, however that would quickly throw an TypeError the first time CONSTANT[0] is later called in the script.although... I suppose if you at some point changed it to now you wouldn't get the TypeError anymore.  hmmmm....https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.setflags.html
Here's a trick if you want constants and don't care their values:Just define empty classes.e.g:
There's no perfect way to do this. As I understand it most programmers will just capitalize the identifier, so PI = 3.142 can be readily understood to be a constant.On the otherhand, if you want something that actually acts like a constant, I'm not sure you'll find it. With anything you do there will always be some way of editing the "constant" so it won't really be a constant. Here's a very simple, dirty example:This looks like it will make a PHP-style constant.In reality all it takes for someone to change the value is this:This is the same for all the other solutions you'll find on here - even the clever ones that make a class and redefine the set attribute method - there will always be a way around them. That's just how Python is.My recommendation is to just avoid all the hassle and just capitalize your identifiers. It wouldn't really be a proper constant but then again nothing would.
You can do it with collections.namedtuple and itertools:
Extending Raufio's answer, add a repr to return the value.then the object behaves a little more like you might expect, you can access it directly rather then '.value'


Answer URL
https://docs.python.org/3/library/sys.html#sys.version_info
