Natural Text
I have the following python3 code:and when I run it on Python 3.6.3 (v3.6.3:2c5fed8, Oct  3 2017, 18:11:49) [MSC v.1900 64 bit (AMD64)] on win32 I get the following outputWhy isn't it outputting doing instance check? The documentation says the __instancecheck__ method needs to be defined on the metaclass and not the class itself, which I have done here. I even verify the metaclass is being used since creating class 'A' is printed. However, when I call isinstance it appears to be using the default implementation and not the one I defined in the metaclass.I'm probably not using metaclasses correctly, but I can't figure out where I made my mistake.
The isinstance function makes a quick check to see if the type of the instance supplied as an argument is the same as that of the class. If so, it returns early and doesn't invoke your custom __instancecheck__. This is an optimization used in order to avoid an expensive call to __instancecheck__ (it's Pythonland code) when it isn't required. You can see the specific test in PyObject_IsInstance, the function that handles the isinstance call in the CPython implementation:Of course, your __instancecheck__ fires correctly when that test isn't True:I am not certain if this is implementation specific, I would of thought so, though, since there's no reference to this in the corresponding PEP section nor in the documentation on isinstance.Interesting aside: issubclass actually doesn't behave this way. Due to its implementation it always calls __subclasscheck__. I had opened an issue on this a while back which is still pending. 
Jim's answer seems to nail it.But for whoever needs for some weid reason a fully customizedinstancheck (ok, now that I am writing this, there seems to beno correct reason for one to want that, let s hope I am wrong), a metaclass can getaway with it, but it is tricky. This one dynamically replaces the actual class of the object being instantiated by a "shadow class", thatis a clone of the original. This way, the native "instancheck" alwaysfail, and the metaclass one is called.It even has a mechanism do sync attributes in the shadow class and actual class. The one thing it does not support is if classes handled in this way do implement a custom __new__. If such a __new__  makes use of parameterless super, it starts to become tricky, as the parameter to super would not be the shadow class. 


Answer URL
https://docs.python.org/3/reference/datamodel.html#customizing-instance-and-subclass-checks
https://docs.python.org/3/reference/datamodel.html#customizing-instance-and-subclass-checks
