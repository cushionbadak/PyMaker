Natural Text
I'm trying to write a function that will return a list of items from a key from a key (if that makes sense). For example, here's a dictionary of authors, and similar authors.And the function I came up with is this:Which only returns the items for the first key. I'd like it to return all of the similar authors, like this:Where it finds the key given (author), looks at the items listed for that key, and then returns those key's items. In this case Harlan Ellison has four authors listed - Neil Stephenson, Kurt Vonnegut, Richard Morgan, and Douglas Adams. The function then looks up those authors, and returns the items listed for them - Kurt Vonnegut returns Terry Pratchett, Tom Robbins, Douglas Adams, Neil Stephenson, and Jeff Vandemeer, and Douglas Adams returns Terry Pratchett, Chris Moore, and Kurt Vonnegut,Duplicates are fine, and I'd like it in alphabetical order (I assume you could just use a sort command at the end) Any help would be much appreciated, I'm stumped!
I think this is what you are looking for.  Hopefully it gets you going.get_similar(authors, "Harlan Ellison") returns['Chris Moore', 'Douglas Adams', 'Douglas Adams', 'Jeff Vandemeer', 'Kurt Vonnegut', 'Kurt Vonnegut', 'Neil Stephenson', 'Neil Stephenson', 'Richard Morgan', 'Terry  Pratchett', 'Terry Pratchett', 'Tom Robbins']I'll leave it to you to figure out how to remove the duplicates.
You are very close but instead of returning after finding the first list of similar authors, you should store all of the authors you find in a list and then return them all after your for loop has finished:Notice that I also added an if statement to make sure that the item is in fact one of the keys in your dictionary so you don't get an error later on (for example: 'Neil Stephenson' is in the dictionary as a member of one of the values but is not a key).EXTRA INFO:(if you are interested)Another option is to turn your function into a generator instead.  This has the advantage of not having to store all the similar authors in a list and instead yields each author as it is found:Or if you are using python 3.3+ you can simplify this a bit by using the yield from expression to get functionally the same code as in get_similar2:All three of the functions/generators above will give you the same results (just remember to get all the values yielded from the generators):
Here's a simple solution using a set and list comprehension:Output:
What you're doing now will work the same way without the for loop - you're essentially just doing a single lookup and return that, hence you get only one entry. What you need to do instead is to do your lookup, find the authors and then do a lookup for each of those authors, then rinse and repeat... The easiest way to do that is to use a bit of recursion:Then all you need to do is to turn it into a set to get rid of the duplicates and then sort it, or if you don't mind a slight performance hit (due to recursion) you can do it right inside your function:Keep in mind that this modifies your input dictionary to avoid infinite recursion, so if you want to keep your authors dictionary intact call the function as get_similar(authors.copy(), author).
What is happening is that functions only accept one return to fix this, return the full row without iterating
I'd use recursion to find similar authors in this fashion.  Come to find out, it is even more inconvenient (and dangerous and slower) to want to return duplicates.Returns:
One way is using list comprehension + itertools.chain
I would not include parameter author in the output if that's one of the elements in a list value. You could use list comprehension:


Answer URL
https://docs.python.org/3/whatsnew/3.3.html#pep-380
