Natural Text
ProblemI'm willing to do a feature engineering using multiprocessing module (multiprocessing.Pool.starmap().However, it gives an error message as follows. I guess this error message is about the size of inputs (2147483647 = 2^31 âˆ’ 1?), since the same code worked smoothly for a fraction(frac=0.05) of input dataframes(train_scala, test, ts). I convert types of data frame as smallest as possible, however it does not get better. The anaconda version is 4.3.30 and the Python version is 3.6 (64 bit).And the memory size of the system is over 128GB with more than 20 cores. Would you like to suggest any pointer or solution to overcome this problem? If this problem is caused by a large data for a multiprocessing module, How much smaller data should I use to utilize the multiprocessing module on Python3?Code:Error Message:Extra infoshistoryCutoffs is a list of integerstrain_scala is a pandas DataFrame (377MB)test is a pandas DataFrame (15MB)ts is a pandas DataFrame (547MB)ul_parts_path is a list of directories (string)is_train_seq is a list of booleansExtra Code: Method multiprocess_FE
The communication protocol between processes uses pickling, and the pickled data is prefixed with the size of the pickled data. For your method, all arguments together are pickled as one object.You produced an object that when pickled is larger than fits in a i struct formatter (a four-byte signed integer), which breaks the assumptions the code has made.You could delegate reading of your dataframes to the child process instead, only sending across the metadata needed to load the dataframe. Their combined size is nearing 1GB, way too much data to share over a pipe between your processes.Quoting from the Programming guidelines section:Better to inherit than pickle/unpickleWhen using the spawn or forkserver start methods many types from multiprocessing need to be picklable so that child processes can use them. However, one should generally avoid sending shared objects to other processes using pipes or queues. Instead you should arrange the program so that a process which needs access to a shared resource created elsewhere can inherit it from an ancestor process.If you are not running on Windows and use either the spawn or forkserver methods, you could load your dataframes as globals before starting your subprocesses, at which point the child processes will 'inherit' the data via the normal OS copy-on-write memory page sharing mechanisms.
this problem was fixed in a recent PR to pythonhttps://github.com/python/cpython/pull/10305if you want, you can make this change locally to make it work for you right away, without waiting for a python and anaconda release.


Answer URL
https://docs.python.org/3/library/multiprocessing.html#programming-guidelines
