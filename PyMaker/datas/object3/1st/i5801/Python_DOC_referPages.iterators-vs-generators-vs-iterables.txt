Natural Text
This question already has an answer here:Difference between Python's Generators and Iterators                    8 answers                I am newbie to Python. I was able to understand Iterables and Iterators.However I have seen that there is lot of stuff that compares Generators vs Iterators.As per understanding, Iterable is an object which actually has elements stored inside it (E.g. a list). They follow an iteration protocol where they implement __iter__() method which returns an Iterator object which helps in iterating the Iterable.As per my understanding Generators helps in generating the data on the fly instead of creating a big data structure in memory and returning it. We can achieve simialr goal by the use of Iterators as well.Now my doubt, If we already had Iterators what was the need of Generators, since both helps acheiving a similar goal of generating data on the fly.Is that just to simplify the syntax or is there any other reason why Generators exist ?
Here's how these terms are defined in the glossary in the official Python documentation.iterableAn object capable of returning its members one at a time. Examples of  iterables include all sequence types (such as list, str, and  tuple) and some non-sequence types like dict, file objects, and  objects of any classes you define with an __iter__() method or with  a __getitem__() method that implements Sequence semantics.Iterables can be used in a for loop and in many other places where a  sequence is needed (zip(), map(), …). When an iterable object is  passed as an argument to the built-in function iter(), it returns an  iterator for the object. This iterator is good for one pass over the  set of values. When using iterables, it is usually not necessary to  call iter() or deal with iterator objects yourself. The for  statement does that automatically for you, creating a temporary  unnamed variable to hold the iterator for the duration of the loop.  See also iterator, sequence, and generator.iteratorAn object representing a stream of data. Repeated calls to the  iterator’s __next__() method (or passing it to the built-in function  next()) return successive items in the stream. When no more data are  available a StopIteration exception is raised instead. At this  point, the iterator object is exhausted and any further calls to its  __next__() method just raise StopIteration again. Iterators are  required to have an __iter__() method that returns the iterator  object itself so every iterator is also iterable and may be used in  most places where other iterables are accepted. One notable exception  is code which attempts multiple iteration passes. A container object  (such as a list) produces a fresh new iterator each time you pass it  to the iter() function or use it in a for loop. Attempting this with  an iterator will just return the same exhausted iterator object used  in the previous iteration pass, making it appear like an empty  container.More information can be found in Iterator Types.generatorA function which returns a generator iterator. It looks like a normal  function except that it contains yield expressions for producing a  series of values usable in a for-loop or that can be retrieved one  at a time with the next() function.Usually refers to a generator function, but may refer to a generator  iterator in some contexts. In cases where the intended meaning isn’t  clear, using the full terms avoids ambiguity.generator iteratorAn object created by a generator function.Each yield temporarily suspends processing, remembering the location  execution state (including local variables and pending  try-statements). When the generator iterator resumes, it picks-up  where it left-off (in contrast to functions which start fresh on every  invocation).


Answer URL
https://docs.python.org/3/glossary.html
