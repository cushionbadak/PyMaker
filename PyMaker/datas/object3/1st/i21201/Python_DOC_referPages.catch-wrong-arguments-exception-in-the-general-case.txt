Natural Text
I want to catch an exception, but only if it comes from the very next level of logic.The intent is to handle errors caused by the act of calling the function with the wrong number of arguments, without masking errors generated by the function implementation.How can I implement the wrong_arguments function below?Example:Addendum:There are several solutions that work nicely in the simple case, but none of the current answers will work in the real-world case of decorated functions.Consider that these are possible values of myfunc above:Even the conservative look-before-you-leap method (inspecting the function argument spec) fails here, since most decorators will have an argspec of *args, **kwargs regardless of the decorated function. Exception inspection also seems unreliable, since myfunc.__name__ will be simply "wrapper" for most decorators, regardless of the core function's name.Is there any good solution if the function may or may not have decorators?
You can do:Although it is kinda ugly and would seem to violate encapsulation.Stylistically, wanting to catch having passed too many arguments seem strange. I suspect that a more general rethink of what you are doing may resolve the problem. But without more details I can't be sure. EDITPossible approach: check if function you are calling has the arguments *args,**kwargs. If it does, assume its a decorator and adjust the code above to check if the exception was one further layer in. If not, check as above.Still, I think you need to rethink your solution. 
I am not a fan of doing magic this way. I suspect you have an underlying design problem rather.--original answer and code which was too unspecific to the problem removed--Edit after understanding specific problem:All your decorators, or at least those you want to be transparent in regard tocalling via the above code, need to set 'effective_argspec' on the returned callable.Very explicit, no magic. To achieve this, you could decorate your decorators with the appropriate code...Edit: more code, the decorator for transparent decorators.Use this on your decorator:Now if you create myfunc1 - myfunc3 as above, they work exactly as expected.
Ugh unfortunately not really.  Your best bet is to introspect the error object that is returned and see if myfunc and the number of arguments is mentioned.So you'd do something like:
you can do it by doing something likebut a better way should be to count the number of args of function and comparing with the number of args expected
You can retrieve the traceback and look at its length. Try:This prints
Well-written wrappers will preserve the function name, signature, etc, of the functions they wrap; however, if you have to support wrappers that don't, or if you have situations where you want to catch an error in a wrapper (not just the final wrapped function), then there is no general solution that will work.
I know this is an old post, but I stumbled with this question and later with a better answer. This answer depends on a new feature in python 3, Signature objectsWith that feature you can write:
Seems to me what you're trying to do is exactly the problem that exceptions are supposed to solve, ie where an exception will be caught somewhere in the call stack, so that there's no need to propagate errors upwards.Instead, it sounds like you are trying to do error handling the C (non-exception handling) way, where the return value of a function indicates either no error (typically 0) or an error (non 0 value).  So, I'd try just writing your function to return a value, and have the caller check for the return value.


Answer URL
https://docs.python.org/3/library/inspect.html#introspecting-callables-with-the-signature-object
