Natural Text
This question already has an answer here:Length of generator output [duplicate]                    9 answers                What's the shortest way to count the number of items in a generator/iterator?                    5 answers                Python generators are very useful. They have advantages over functions that return lists. However, you could len(list_returning_function()). Is there a way to len(generator_function())?UPDATE:Of course len(list(generator_function())) would work.....I'm trying to use a generator I've created inside a new generator I'm creating. As part of the calculation in the new generator it needs to know the length of the old one. However I would like to keep both of them together with the same properties as a generator, specifically - not maintain the entire list in memory as it may be very long.UPDATE 2:Assume the generator knows it's target length even from the first step. Also, there's no reason to maintain the len() syntax. Example - if functions in Python are objects, couldn't I assign the length to a variable of this object that would be accessible to the new generator?
Generators have no length, they aren't collections after all.Generators are functions with a internal state (and fancy syntax). You can repeatedly call them to get a sequence of values, so you can use them in loop. But they don't contain any elements, so asking for the length of a generator is like asking for the length of a function. if functions in Python are objects, couldn't I assign the length to a  variable of this object that would be accessible to the new generator?Functions are objects, but you cannot assign new attributes to them. The reason is probably to keep such a basic object as efficient as possible.You can however simply return (generator, length) pairs from your functions or wrap the generator in a simple object like this:
The conversion to list that's been suggested in the other answers is the best way if you still want to process the generator elements afterwards, but has one flaw: It uses O(n) memory. You can count the elements in a  generator without using that much memory with:Of course, be aware that this might be slower than len(list(generator)) in common Python implementations, and if the generators are long enough for the memory complexity to matter, the operation would take quite some time. Still, I personally prefer this solution as it describes what I want to get, and it doesn't give me anything extra that's not required (such as a list of all the elements).Also listen to delnan's advice: If you're discarding the output of the generator it is very likely that there is a way to calculate the number of elements without running it, or by counting them in another manner.
Suppose we have a generator:We can wrap the generator, along with the known length, in an object:Instances of LenGen are generators themselves, since calling them returns an iterator.Now we can use the lgen generator in place of gen, and access len(lgen) as well:
You can use len(list(generator_function()). However, this consumes the generator, but that's the only way you can find out how many elements are generated. So you may want to save the list somewhere if you also want to use the items.
You can len(list(generator)) but you could probably make something more efficient if you really intend to discard the results.
You can use send as a hack:
You can combine the benefits of generators with the certainty of len(), by creating your own iterable object:This is basically a simple implementation of xrange, which returns an object you can take the len of, but doesn't create an explicit list.
You can use reduce.For Python 3:In Python 2, reduce is in the global namespace so the import is unnecessary.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.count
