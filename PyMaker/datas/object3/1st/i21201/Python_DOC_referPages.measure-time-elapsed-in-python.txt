Natural Text
What I want is to start counting time somewhere in my code and then get the passed time, to measure the time it took to execute few function. I think I'm using the timeit module wrong, but the docs are just confusing for me.
If you just want to measure the elapsed wall-clock time between two points, you could use  time.time():This gives the execution time in seconds.Another option since 3.3 might be to use perf_counter or process_time, depending on your requirements. Before 3.3 it was recommended to use time.clock (thanks Amber). However, it is currently deprecated:On Unix, return the current processor time as a floating point number  expressed in seconds. The precision, and in fact the very definition  of the meaning of “processor time”, depends on that of the C function  of the same name.On Windows, this function returns wall-clock seconds elapsed since the  first call to this function, as a floating point number, based on the  Win32 function QueryPerformanceCounter(). The resolution is typically  better than one microsecond.Deprecated since version 3.3: The behaviour of this function depends  on the platform: use perf_counter() or process_time() instead,  depending on your requirements, to have a well defined behaviour.
Use timeit.default_timer instead of timeit.timeit. The former provides the best clock available on your platform and version of Python automatically:timeit.default_timer is assigned to time.time() or time.clock() depending on OS. On Python 3.3+ default_timer is time.perf_counter() on all platforms. See Python - time.clock() vs. time.time() - accuracy?See also:Optimizing codeHow to optimize for speed
Python 3 only:Since time.clock() is deprecated as of Python 3.3, you will want to use time.perf_counter() for system-wide timing, or time.process_time() for process-wide timing, just the way you used to use time.clock():The new function process_time will not include time elapsed during sleep.
Given a function you'd like to time,test.py:the easiest way to use timeit is to call it from the command line:Do not try to use time.time or time.clock (naively) to compare the speed of functions. They can give misleading results.PS. Do not put print statements in a function you wish to time; otherwise the time measured will depend on the speed of the terminal.
It's fun to do this with a context-manager that automatically remembers the start time upon entry to a with block, then freezes the end time on block exit. With a little trickery, you can even get a running elapsed-time tally inside the block from the same context-manager function. The core library doesn't have this (but probably ought to). Once in place, you can do things like:Here's contextmanager code sufficient to do the trick:And some runnable demo code:Note that by design of this function, the return value of elapsed() is frozen on block exit, and further calls return the same duration (of about 6 seconds in this toy example). 
I prefer this. timeit doc is far too confusing. Note, that there isn't any formatting going on here, I just wrote hh:mm:ss into the printout so one can interpret time_elapsed
Using time.time to measure execution gives you the overall execution time of your commands including running time spent by other processes on your computer. It is the time the user notices, but is not good if you want to compare different code snippets / algorithms / functions / ...More information on timeit:Using the timeit Moduletimeit – Time the execution of small bits of Python codeIf you want a deeper insight into profiling:http://wiki.python.org/moin/PythonSpeed/PerformanceTips#Profiling_CodeHow can you profile a python script?Update: I used http://pythonhosted.org/line_profiler/ a lot during the last year and find it very helpfull and recommend to use it instead of Pythons profile module.
Here is a tiny timer class that returns "hh:mm:ss" string: Usage: 
The python cProfile and pstats modules offer great support for measuring time elapsed in certain functions without having to add any code around the existing functions.For example if you have a python script timeFunctions.py:To run the profiler and generate stats for the file you can just run:What this is doing is using the cProfile module to profile all functions in timeFunctions.py and collecting the stats in the timeStats.profile file. Note that we did not have to add any code to existing module (timeFunctions.py) and this can be done with any module.Once you have the stats file you can run the pstats module as follows:This runs the interactive statistics browser which gives you a lot of nice functionality. For your particular use case you can just check the stats for your function. In our example checking stats for both functions shows us the following:The dummy example does not do much but give you an idea of what can be done. The best part about this approach is that I dont have to edit any of my existing code to get these numbers and obviously help with profiling.
Here's another context manager for timing code -Usage: or, if you need the time valuebenchmark.py:Adapted from http://dabeaz.blogspot.fr/2010/02/context-manager-for-timing-benchmarks.html
Use profiler module. It gives a very detailed profile.it outputs something like:I've found it very informative.
(With Ipython only) you can use %timeit to measure average processing time:and then:    the result is something like:
on python3:elegant and short.
Kind of a super later response, but maybe it serves a purpose for someone. This is a way to do it which I think is super clean.Keep in mind that "print" is a function in Python 3 and not Python 2.7. However, it works with any other function. Cheers!
We can also convert time into human-readable time.
Here are my findings after going through many good answers here as well as few other articles.First, you always want to use timeit and not time.time (and in many cases perf counter APIs) because timeit selects the best timer available on your OS and Python version. timeit disables garbage collection however this is not something you may or may not want.Now the problem is that timeit is not that simple to use because it needs setup and things get ugly when you have bunch of imports. Ideally you just want  a decorator or use with block and measure time. Unfortunately there is nothing built-in available for this so I created below little utility module.Timing Utility ModuleHow to Time FunctionsNow you can time any function just by putting a decorator in front of it:How to Time Code BlocksIf you want to time portion of code then just put it inside with block:AdvantagesThere are several half-backed versions floating around so I want to point out few highlights:Use timer from timeit instead of time.time for reasons described earlier.Disable GC during timing.Decorator accepts functions with named or unnamed params.Ability to disable printing in block timing (use with utils.MeasureBlockTime() as t and then t.elapsed).Ability to keep gc enabled for block timing.
One more way to use timeit:
I made a library for this, if you want to measure a function you can just do it like this https://github.com/Karlheinzniebuhr/pythonbenchmark 
You can use timeit.Here is an example on how to test naive_func that takes parameter using Python REPL:You don't need wrapper function if function doesn't have any parameters.                                                                                      
The only way I can think of is using time.time().Hope that will help.
Measuring time in seconds:
Better use timeit simply: (it run multiple runs for the same command and give you the results). Example is given below:
In addition to %timeit in ipython you can also use %%timeit for multi-line code snippets:Also it can be used in jupyter notebook the same way, just put magic %%timeit at the beginning of cell.


Answer URL
https://docs.python.org/3/library/time.html#time.perf_counter
https://docs.python.org/3/library/time.html#time.process_time
https://docs.python.org/3/library/time.html#time.perf_counter
https://docs.python.org/3/library/time.html#time.process_time
