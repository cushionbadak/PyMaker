Natural Text
Let's say, I have a pre-existing mapping as a dictionary:I can create an enum class from this like so:and use it like soBut then I want to define some methods to my new enum class:Of course, i can do this:But as I said, I have to use a pre-defined value mapping dictionary, so I cannot do this.How can this be achieved? I tried to inherit from another class defining this method like a mixin, but I could'nt figure it out.
You can pass in a base type with mixin methods into the functional API, with the type argument:For a fully functional approach that never uses a class statement, you can create the base mix-in with the type() function:You can also use enum.EnumMeta() metaclass the same way, the way Python would when you create a class MyEnum(enum.Enum): ... subclass:Create a class dictionary using the metaclass __prepare__ hookCall the metaclass, passing in the class name, the bases ((enum.Enum,) here), and the class dictionary created in step 1.The custom dictionary subclass that enum.EnumMeta uses isn't really designed for easy reuse; it implements a __setitem__ hook to record metadata, but doesn't override the dict.update() method, so we need to use a little care when using your value_map dictionary:Then pass in double_value=property(double_value) to that function (together with the enum name and value_map dictionary):You are otherwise allowed to create subclasses of an enum without members (anything that's a descriptor is not a member, so functions, properties, classmethods, etc.), so you can define an enum without members first:which is an acceptable base class for both in the functional API (e.g. enum.Enum(..., type=DoubledEnum)) and for the metaclass approach I encoded as enum_with_extras().
You can create a new meta class (Either using a meta-metaclass or a factory function, like I do below) that derives from enum.EnumMeta (The metaclass for enums) and just adds the members before creating the classA different solution was to directly try and update locals(), as it is replaced with a mapping that creates enum values when you try to assign values.This seems well defined enough, and a = 1 is most likely going to be the same as locals()['a'] = 1, but it might change in the future. The first solution is more robust and less hacky (And I haven't tested it in other Python implementations, but it probably works the same)


Answer URL
https://docs.python.org/3/library/functions.html#type
https://docs.python.org/3/reference/datamodel.html#preparing-the-class-namespace
https://docs.python.org/3/howto/descriptor.html
