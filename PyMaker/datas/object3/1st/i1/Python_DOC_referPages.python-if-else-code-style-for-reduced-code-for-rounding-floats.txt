Natural Text
Is there any shorter, more legible code style to solve this problem?I am trying to classify some float values into interregional folders.
Specific solutionThere is no real general solution, but in your case you can use the following expression.General solutionIf you actually need some kind of generalization, notice that any non-linear pattern will cause trouble. Although, there is a way to shorten the code.Notice that the above is still not totally safe from some float rounding error. You can add precision by manually typing down the intervals list instead of using a comprehension.Continuous intervalsIf the intervals in your data are continuous, that is there is no gap between them, as in your example, then we can use some optimizations. Namely, we can store only the higher bound of each interval in the list. Then by keeping those sorted, we can use bisect for efficient lookup.Important note: the choice of using the higher bounds and bisect_right is due to the fact the higher bounds are excluded in your example. If the lower bounds were excluded, then we would have to use those with bisect_left.Also note that you may want to treat numbers out of the range [-0.95, 0.95[ in some special way and note just leave those to bisect.
The bisect module will do exactly the right lookup for finding the right bin from a list of breakpoints.  In fact, the example in the documentation is exactly a case like this:The bisect() function is generally useful for categorizing numeric data. This example uses bisect() to look up a letter grade for an exam total (say) based on a set of ordered numeric breakpoints: 85 and up is an ‘A’, 75..84 is a ‘B’, etc.Instead of a string for the value lookups, you'd want a list of strings for the exact folder names you need for each range of values.  For example:If you can automate even part of this table generation (using round(), or something similar), of course you should.
One of the first rules with a block of code like this, is to always make the comparisons be in the same direction.  So instead of writeAt this point you can observe that python allows chaining of comparisons, so you can write:Which is an improvement itself.  Alternatively, you can observe this is an ordered list of comparisons, so if you add in an initial comparisons, you can just writeThat's still quite long, but a) it's a lot more readable; b) it has explicit code to handle value < -0.95 or 0.95 <= value
All answers revolve around rounding, which seems to be fine in this case, but just for the sake of argument I'd like to also point out a cool python use of dictionaries which is often described as an alternative to other languages switch(es) and that in turn allow for arbitrary values.Output:
You can use the round() built-in :More on round()
Actually in Python 3 .85 will be round to .8. As per the question .85 should be round to .9.Can you try the following:Output:
How about turning it into a loop?it's not efficient by any means, but it's equivalent to what you have, just shorter.

You don't need the and value >= -.85 in elif value < -0.75 and value >= -0.85:; if the value isn't greater than or equal to -.85, then you won't reach the elif. You can also just turn all the elifs into if by having each one return immediately.In this case, since you have the boundaries at regular intervals, you can just round (in the general case of regular intervals, you may have to divide and then round, for instance if the intervals are at every three units, then you would divide the number by three and round). In the general case, it's faster to store the boundaries in a tree structure, and then do a binary search for where the item goes. Doing a binary search explicitly would be something like this:Although this code is harder to read than yours, it runs in time logarithmic rather than linear with respect to the number of boundaries.If the number of items is significantly larger than the number of boundaries, it would probably be faster to actually create a tree of the items, and insert the boundaries.You could also create a list, sort it, and then look at the index. For instance, compare (sorted([(_-9.5)/10  for _ in range(20)]+[x]).index(x)-9)/10 to your function.
Take a look at the round() function in python. Maybe you can work it out without the if.With this function you can specify the number of digits you need to keep.For example :That code will print 5.77
Many of these answers suggest some kind of rounding as a solution. Unfortunately, there are three problems with using rounding for this purpose, and at the time of writing all of them fell prey to at least one.Floating point representation of decimal values is inexact. For example, the float 0.85 is in fact 0.8499999999999999777955395.... round() uses ties-round-to-even, also known as scientific or banker's rounding, rather than the arithmetic rounding many of us learned in school. This means e.g. 0.85 rounds to 0.8 instead of 0.9, and 0.25 rounds to 0.2 instead of 0.3.very small negative floats (and Decimals) round up to -0.0 rather than 0.0 as the OP's mapping requires.These can all be solved using the Decimal module, though not as prettily as I'd like:Both ROUND_HALF_DOWN and ROUND_HALF_UP are required as ROUND_HALF_UP actually rounds away from zero rather than towards Infinity. .quantize rounds a Decimal value to the places given by the first argument, and allows us to specify a rounding method.Bonus: Bisect Breakpoints using range()For the bisect solutions, this will generate the breakpoints used by the OP:
Try something like this, if you don't like loops:Of course, the loop is just "hidden" in the list comprehension.Obviously, in this example, it would be better to generate endpts and ts_fol programmatically rather than writing them all out, but you indicated that in the real situation the endpoints and values aren't so straightforward.This raises a ValueError if value ≥ 0.95 (because False is not found in the list comprehension) or if value < -0.95 (because then idx is 0); the original version raises a UnboundLocalError in these cases.You could also save three lines and skip a few comparisons by doing this:This version returns None rather than raising exceptions for any value outside the bounds.


Answer URL
https://docs.python.org/3/library/bisect.html
https://docs.python.org/3/library/functions.html#round
