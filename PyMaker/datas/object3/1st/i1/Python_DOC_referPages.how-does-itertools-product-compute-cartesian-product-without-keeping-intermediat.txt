Natural Text
As per the documentation here iterpools.product doesn't hold intermediate results in memory (it computes Cartesian product of input lists). But the rough sketch of the algorithm given makes me believe it does. Notice how result keeps getting updated in every iteration by taking elements in result and appending more to it.I tried groking the underlying C code here but couldn't. I would like to understand how does the C code work without keeping the intermediate results in memory. I came across a recursive approach(reproduced below) which doesn't keep intermediate results in memory except the recursive call stack. Does the C code also use a recursive approach, else how is it able to work without keeping the intermediate results in memory?
It stores the inputs in memory (as tuples), along with an index for each tuple, and repeatedly cycles all but the first one. Each time a new output value is requested, it:Advances the index into the rightmost tupleIf it goes past the end, it resets it to zero, and advances the next rightmost indexStep 2 is repeated until an index is found that can be incremented without going past the end of its particular iteratorA new tuple is created by pulling the value at the current index for each data sourceIt has a special case for the very first pull where it just pulls the 0th value from each tuple, but otherwise that pattern is followed every time.For a really simple example, the internal state for:would be to create tuples ('a', 'b') and ('c', 'd') up front, and an array of indices, [0, 0] initially. On the first pull, it yields ('a', 'b')[0], ('c', 'd')[0] or ('a', 'c'). On the next pull, it advances the indices array to [0, 1], and yields ('a', 'b')[0], ('c', 'd')[1] or ('a', 'd'). The next pull advances the rightmost index to 2, realizes it has overflowed, puts it back to 0, and advances the next index making it [1, 0], and yields ('a', 'b')[1], ('c', 'd')[0] or ('b', 'c'). This continues until the leftmost index overflows, at which point iteration is complete.Actually equivalent Python code would look more like:but as you can see, it's far more complex than the simpler version provided.As you can see, each output tuple is yielded immediately upon being created; only the inputs and the current indices for those inputs must be preserved as iterator state. Thus, as long as the caller doesn't store the results, and just iterates live, very little memory is needed.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.product
