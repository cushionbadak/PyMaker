Natural Text
This question already has an answer here:Boolean operators vs Bitwise operators                    8 answers                This is a pretty trivial question that I haven't been able to find the answer to. Here is the problem. I have the following array:And I want to check whether val[0] or val[1] is greater than 0. If either is true, then I should output True.My immediate thought was to use; (vals[1] or vals[0]) > 0) but I'm finding that (5 | -2) > 0 is False where (5 or -2) > 0 is TrueAny clarification would be much appreciated. 
What is the difference between or and |?or is a logical or and | is a bitwise or logical inclusive or.The logical orThe logical or in python returns the first value that is true.Example:The bitwise or logical inclusive orThe bitwise or logical inclusive or is represented by the | operator in python and creates a number where all bits are set that are set in at least one of the given numbers.Example:2 is in binary 00104 is in binary 0100A logical or between the two results in 0110 which is 6.How a negative number is stored is generally implementation specific. However on most systems a negative number is stored by creating the two's complement of the positive number by inverting each bit and adding 1.That number in bitwise ore two any other number still results in a negative number:Neither of the two solves your problemWhile using seems to work, it fails when you flip the values:You should check both values seperatlyFor a larger input this may be inconvenient. You should use any with a generator expression:
You want the any function:x | y computes the bitwise OR of the two values, while x or y evaluates to the first "truthy" value. In both cases, the result is then compared to 0: (x or y) > 0 and (x | y) > 0.What you want to compare each value to zero (as necessary), withIf you had three values, you'd writeThe any function generalizes this to a list of any size, without the need to decide how many terms to or together based on the size of the list.
To answer this question, I have to explain about Two's Complement.BINARY REPRESENTATION OF NUMBERSSo you know how internally, an integer like 5 is represented as a binary stringHow do you imagine you'd represent a negative number?Well, here's what we want to do:Addition should work the same with negative numbers and positive numbers; i.e. you do the same  steps to add 4 + 9 as 4 + -9.Integer overflow shouldn't break mathematics; i.e. MAX_VALUE + 1 == MIN_VALUE, MIN_VALUE - 1 == MAX_VALUESo what we do is called "Two's Complement."TWO'S COMPLEMENTTo represent a negative number, take its absolute value, bitflip every bit, and add 1.So if the positive number is 5the negative number -5 isEssentially, this means we pick the number 01111111111111111111111111111111 to be the largest positive number, and all numbers after that are negative.SO WHAT DOES (5 | -2) MEAN?The | is the bitwise or operator. Given two numbers, it takes every bit and or's them together, constructing a new number where a digit is 1 if the digit in that position in wither or both of the two original numbers is 1, and 0 otherwise. The calculation looks like this:So as you can see, 5 | -2 = -1 < 0.WHAT ABOUT (5 or -2)?The "or" operator takes two values, casts them to booleans and or's them together. This is important: it doesn't or the values, it returns the first value that is "truthy" -- in other words, if you put it in an if statement, it would run.The only integer that isn't "truthy" is 0. Therefore (5 or -2) returns the first non-zero integer of 5 and 2, which is 5 > 0. So 5 or -2 = 5 > 0.
| is a bitwise OR, and Python uses two's complement representation for integers.  Evaluating 5 | -2 gives:And -1 is not greater than zero, so (5 | -2) > 0 is false.or is a logical OR.  Unlike in other languages where this operator returns a Boolean (True/False) value, Python defines x or y as being equivalent to x if x else y (except that x is evaluated only once).  Note that any nonzero numeric value is “truthy” in Python, so if x≠0, then x or y evaluates to x.That (5 or -2) > 0 evaluates to True was a stroke of luck from having the positive number first.  In the other order, you would have gotten False.In general (x or y) > 0 is not equivalent to (x > 0) or (y > 0), which is what you meant.
When you do (5 | -2), you're doing a bitwise-OR. That will preserve the negation bit in the numbers. Therefore, you'll still have a negative number.The (5 or -2) is a logical-OR, to the Python interpreter will extend that to the next logical operator (the greater-than).
They are two completely different operations so that is expected.To illustrate, here's a small shell log:The or operator returns the first non-zero (non-None, non-False, etc.) value.The | operator does a bitwise or. To illustrate:


Answer URL
https://docs.python.org/3/library/stdtypes.html#boolean-operations-and-or-not
https://docs.python.org/3/library/stdtypes.html#bitwise-operations-on-integer-types
https://docs.python.org/3/library/functions.html#any
https://docs.python.org/3/reference/expressions.html#unary-arithmetic-and-bitwise-operations
https://docs.python.org/3/library/stdtypes.html
