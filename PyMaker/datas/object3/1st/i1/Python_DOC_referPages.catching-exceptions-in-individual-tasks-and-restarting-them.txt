Natural Text
If I create a series of asyncio tasks in a top level class, all of which should essentially run forever, like so:The above code doesn't handle the following situation, which I'm finding I need more and more, and I haven't seen an example in Googling or in the asyncio docs:If one of the tasks fails with an exception, the exception doesn't get handled - all of the other tasks proceed, but that one task simply halts silently (other than the exception output).So, how can I:Set up for the exception to be handled, so that the failure isn't silent any moreMost importantly, restart the failed task, effectively running self.event_loop.create_task(...) again, just for that task? This would seem to require finding the task that received the exception in the event loop, removing it, and adding a new one - how to do that is not clear to me.Allow the tasks that didn't have issues to continue uninterrupted.  Want to avoid any side effects of handling the task that received the exception.
Uncaught exceptions are attached to the task object, and could be retrieved from it via the Task.exception() method. The self.event_loop.create_task(...) call returns the task object, so you'd want to collect those to inspect exceptions.If you want to reschedule a task whenever an exception has occurred, then you'd want to do that in a new task (because you'd want it to run in the event loop), or use a wrapper co-routine that catches exceptions and just re-runs the given coroutine again.The latter could look something like:then wrap your coroutines with the above coroutine when scheduling them as a task:e.g. passing in the arguments to create the coroutine each time there is an exception.The other option is to use asyncio.wait() in a separate task so you can monitor for exceptions as the loop runs, and make decisions on how to handle exceptions there and then:The asyncio.wait() call is given control again by the event loop when when any one of the tasks scheduled exited due to an exception, but until that happens, tasks could have been cancelled or simply completed their work. When a task did exit because of an exception, you need a way to create the same coroutine again (with the same arguments), hence the *args, **kwargs setup above.You'd schedule just the exception_aware_scheduler(), passing in the tasks you wanted to pass in:


Answer URL
https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.exception
https://docs.python.org/3/library/asyncio-task.html#waiting-primitives
