Natural Text
I have two lists of equal length, one containing labels and the other data. For example:How can I extract sub-lists of both lists in parallel based on a particular label in the labels list? For example, using fish as a selection criteria, I want to generate:My best guess sounds cumbersome - make a list of element-wise tuples, extract a list of relevant tuples from that list, then de-tuple that list of tuples back into two lists of single elements. Even if that's the way to approach it, I'm too new to Python to stumble on the syntax for that. 
Using zip() and a generator expression this can be done like:Code:How does this work?The tuples line builds a generator expression which zips the two lists together and drops any thing that is uninteresting.  The second line uses zip again and then maps the resulting tuples into lists as desired.This has the advantage of building no intermediate data structures so should be fairly fast and memory efficient.Test Code:Results:
This might be a good place to apply itertools.compress, which is slightly faster than zip, at least for the size of data structures you're working with.Usage:Timing:(i=='fish' for i in labels) is a generator of True and False.  compress filters down data element-wise to cases where True occurs.From the docstring:Roughly equivalent to:
You can zip the lists together, filter them based on the keyword you are looking for and then unzipThen your selected_data and selected_labels would be:Another alternative is to use map function to get the desired format:
The simplest approach is totally fine here, and likely very performant:Some more timings, didn't have time to include every approach so far, but here's a few:I would say, relying on itertools.compress is doing just fine. I was worried that having to do selected_labels = ['fish'] * len(selected_data) would slow it down, but it is an expression that could be highly optimized in Python (size of the list known ahead of time, and simply repeating the same pointer). Finally, note, the simple, naive approach I gave can be optimized by "caching" the .append method:
As an alternative to the zip answer, you might consider using a different data structure.  I would put that in a dictThen to access, just data['fish'] will give [0.3, 0.2] You can load the data you have into such a dictby doing this one time onlyThen just do this for each query


Answer URL
https://docs.python.org/3/library/functions.html#zip
https://docs.python.org/3/library/itertools.html#itertools.compress
https://docs.python.org/3/library/functions.html#map
