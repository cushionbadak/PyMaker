Natural Text
I have two dictionaries:And I have returned the keys which have max length values in the convex dict:For each number in max_lens, I want to check that it does not exist as a key in concave and its values in convex exist as keys in concave. So in this example, '1' would satisfy this condition as it is not included in concave as a key, but its values in convex are (i.e. 2, 3 4 and 5).I have tried to figure out how to go about this using for loops/if statements:That is about as far as I got before getting totally confused. There must be an easier way to do this other than using multiple for loops and if statements?I'm a bit of a python noob so sorry if this comes across as confusing!
I think I understood (for the record I prefer the explicit concave.keys())Edit (see comments)
Spelling this problem out into steps always helps:Loop over each of the lengths l in max_lensCheck if l doesn't exist in concave but exists in convex. A conjunction of these two conditions is needed here. If either fails, don't continue. If the above two conditions are accepted, check if all the values from convex[l] exist in concave. If the code reaches here with no issues, all the conditions are met. Demo:Output:
You can do it with comprehension:
Using a simple forloop.Output:
If you don't understand a problem easily, it's often a good way, to divide it into several smaller problems:write a function that checks if a value is not key of a dict:def is_no_key_in(v, _dict):    return key not in _dictSince that is too simple return a list of keys that are not in dict:def no_key_values(_list, _dict):    return [ v for v in _list if is_no_key_in(v, _dict) ]Now that you only have values that fit your first condition, you can concentrate on your second condition. Since you want that every value of a list is in a list of keys, you can start making a union-like function:def union(a_lst, b_lst):    return [ a for a in a_lst if a in b_lst]To make it more into something serving your needs, you could change it to a function that checks for any diffs:def is_subset(a_lst, b_lst):    return len([a for a in a_lst if a not in b_lst]) == 0Now you piece the functions together:def satisfies_conditions(max_lens):    for lens in no_key_values(max_lens, concave):        if is_subset(convex[lens], concave.keys())            yield lensresult = [ lens for lens in satisfies_conditions(max_lens) ]result now contains all lenses that satisfy your conditions and if you want to change your conditions, you can easily do so. If your code works, you can go on and refactor it. For example you might not need is_no_key_in as it is a very simple function. Then go on and inline it into no_key_values:def no_key_values(_list, _dict):    return [ v for v in _list if v not in _dict ]If you write some tests before refactoring (or even writing the code) you can ensure, that your refactoring won't introduce bugs. Then simplify the code step by step. Maybe you will end up with a solution as simple as proposed in other answers here.(I hope this will also help you with future problems like that :-))


Answer URL
https://docs.python.org/3/library/stdtypes.html#dict-views
