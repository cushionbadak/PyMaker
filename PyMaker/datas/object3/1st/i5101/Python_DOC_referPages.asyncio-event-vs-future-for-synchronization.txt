Natural Text
I'm going through some asyncio source for networking and implementation raised a question in my head.To create a non-blocking I/O when waiting for the data to arrive from a socket, asyncio.StreamReader.read() at its end calls _wait_for_data method that creates an empty Future and awaits it.That future is set as finished (which allows it to be finally awaited) in _wakeup_waiter method that is called when a new data arrives to the stream (feed_data method).That makes complete sense.My question is:Why not use asyncio.Event? It feels to me like Event was designed exactly for these purposes. In fact, you wouldn't have to create a new Future on each _wait_for_data call, but would initialize a single Event in a class and would simply toggle its value during its lifetime. It also has specific .wait() method for awaiting its value to become True (for when the new data arrives from the socket).Can anyone elaborate if there's an actual difference between the two approaches? Or is it just a method chosen arbitrarily?
While usually you can replace Future with Event if you don't care about data future will be populated with, I don't think it's true in this case. In the code self._waiter is used not only to indicate wakeup event, but also to indicate exception that happened. set_exception to Future means that exact this exception will be raised inside code that awaits for future:You wouldn't be able to achieve this if you change self._waiter to an Event.
Future is low level primitive.It is powerful but user code usually don't need it.Like Linux has futex but user code uses high level objects like lock and recursive lock.


Answer URL
https://docs.python.org/3/library/asyncio-sync.html#asyncio.Event
