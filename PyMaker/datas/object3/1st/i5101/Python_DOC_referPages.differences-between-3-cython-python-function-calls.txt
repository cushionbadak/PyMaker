Natural Text
I wanted to test cython performance comparing it to standard python. So here I have 3 examples of a function which will loop through 200 ints adding the same number to the result over and over again and then returning the result. In the timeit module I made it to be called 1.000.000 times. So there's the first example:Here's the second (look closely, the first function definition matters):And there's the third one, which is placed in the main file:I compiled it with cythonize -a -i nocdefexample.pyx cdefexample.pyx and I got two .sos. Then when I run python test.py - this shows up:So the first one is only def <name>(int num). The second one (seems to be 1.5x faster than the first one) is cdef int <name>(int num). And the last one is just def <name>(num).The last ones performance is terrible, but that's what I wanted to see. The interesting thing for me is why those first two examples differ (I checked it many times, second is always ~1.5x faster than the first one).Is it only because I specified the return type? And if so, does it mean that they're both cython functions or is the first some kind of, I dunno, a mixed-type kinda function?
First, you must be aware, that in the case of cython-functions you are measuring just the overhead of calling a cdef- vs. a def-function:The C-compiler recognizes, that the loop will result in num*num and evaluates this multiplication directly without running the loop - and multiplication is equally fast for 10**3 and 10**4.This might come as surprise for a python-programmer, because the python-interpreter doesn't optimize and thus this loop has an O(n)-running time:Now, calling a cdef function is much faster! Just look at the generated C-code for calling the cdef version (actually the creation of python-integer is already incorporated):__pyx_f_4test_cdefex - is just a call of a C-function. Compared to call of def-version which happens via the whole python-machinery (here kind of abbreviated):The Cython has to:Create a python-integer from the C-int num to be able to call a Python-function (__Pyx_PyInt_From_int)locate this method using its name (__Pyx_GetModuleGlobalName + PyMethod_GET_SELF)and finally call the function.The first call is probably at least 100 times faster, but the overall speed-up is less than 2 only because calling the "inner"-function is not the only work that needs to be done: def-functions xd and xd1 have to be called anyway + the resulting python-integer must be created. Fun-fact:The reason is the integer pool for values -5...256=16^2 so the values from this range can be constructed faster.Specifying the return type doesn't play that big role in your example: it only decides, where the conversion to python-integer happens - either in nocdef or xd1 - but it happens eventually.


Answer URL
https://docs.python.org/3/c-api/long.html#c.PyLong_FromLong
