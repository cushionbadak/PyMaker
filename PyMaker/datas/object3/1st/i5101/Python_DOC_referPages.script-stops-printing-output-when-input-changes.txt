Natural Text
I'm making a coin flip game that asks the user "Heads or Tails", and after the user chooses one of the two, it will respond back saying either "correct" or "wrong". When I run my code, it works perfectly fine if I keep repeating either heads or tails. But if I switch it up like something like heads, heads, tails . It won't ask me the question "Heads or Tails" anymore. And what's weird is sometimes after switching it up it will ask but then eventually it stops. This is my code:And then this right here is the problem I'm talking about when I run it After that last heads I put it doesn't say correct or wrong, and sometimes it doesn't show it even earlier when I run it.
You can try implementing the same using:This allows the user to continue flipping the coin until the user enters 'quit'.
It isn't strange that your program stops after you stop responding "tails". This is because of basic control flow. You've used five types of control flow in your program. First, unless told otherwise, control will flow from one statement to the next. So import random happens first, then the assignment of coin, and so on. Second, you've used function calls such as raw_input() and random.choice(). These run other subprograms, which we don't need to consider very deeply here since all of them return to your main program. Third came two while loop constructs. These contain some section of code they repeat as long as their condition is satisfied; crucially, they therefore end when it is not. So the first loop actually ends when you respond something other than "heads". Fourth, you have an if statement within each loop. This runs its contents if a condition is satisfied, just like while, but doesn't repeat. Since the condition you used is exactly the same as the surrounding while, these checks are redundant; we wouldn't be executing this part of the program if the condition wasn't met. Fifth you used a for statement; these make loops, like while, but process every entry of some iterable. In this case, that served no purpose because there is only one entry in range(1) and you never actually used it. Like the if, it is redundant. Having deciphered these, we see the control flow moves from "heads" loop to "tails" loop then simply ends, having run out of program. To keep the program running we must have a loop that does not end, for instance:This loop exhibits another issue, namely that nothing checks that the answer entered was either heads or tails. It will therefore get stuck running nothing if we give another answer. You can solve this by ensuring we ask for a guess in every iteration, and for some extra flair, even respond to invalid guesses using else:Note that I moved the raw_input call outside of the conditional sections. Since it was equal for all branches, it doesn't need duplication. I also used elif and else to tie together the conditional sections, ensuring only one of them will run for any iteration (each time through the loop). And about duplication, your two conditionals perform the exact same operation! You've taken a shortcut and not actually calculated which side the coin landed on - only used its odds of success. Let's fix that too. Note that there are two if statements on different levels this time, each with their own else. These are independent, aside from the fact that the inner one only runs if the outer condition was true. All sorts of control flow statements (ending in :) can be nested this way. 


Answer URL
https://docs.python.org/3/tutorial/introduction.html#first-steps-towards-programming
https://docs.python.org/3/tutorial/controlflow.html#if-statements
