Natural Text
Looking for a elegant way to convert a list of substrings and the text between them to key, value pairs in a dict.  Example:This is solvable using str.find(), etc, but I know there's a better solution than what I've hacked together.
Option 1If the keys don't have spaces or colons, you can simplify your solution with dict + re.findall (import re, first):Only the placement of the colon (:) determines how keys/values are matched.DetailsNote that this code assumes the structure as presented in the question. It will fail on strings with invalid structures.Option 2Look ma, no regex...This operates on the same assumption as the one above.Split on colon (:)All elements but the first and last will need to be split again, on space (to separate keys and values)zip adjacent elements, and convert to dictionary   
If the keys don't have spaces or colons in it, you could:split according to alpha followed by colon to get the tokenszip half shifted slices in a dict comprehension to rebuild the dictlike this:result:using itertools.islice avoids to create sub-lists like toks[::2] would do
Another regex magic with splitting the input string on key/value pairs:The output:using re.compile() and saving the resulting regular expression object for reuse is more efficient when the expression will be used several times in a single program\s+(?=\w+:) - the crucial pattern to split the input string by whitespace character(s) \s+ if it's followed by a "key"(a word \w+ with colon :). (?=...) - stands for lookahead positive assertion
If you have a list of your known keys (and maybe also values, but I don't address that in this answer), you can do it with a regex. There might be a shortcut if, say, you can simply assert that the last whitespace before a colon definitely signals the beginning of the key, but this should work as well:Explanantion:Caveat 1: If your keys can contain each other order is important, and you might want to go from long keys to shorter ones in order to force longest matches first: key_list.sort(key=len, reverse=True)Caveat 2: If your key list contains regex metacharacters, it will break the expression, so they might need to be escaped first: key_list = [re.escape(key) for key in key_list]
This version is a bit more verbose but straightforward-ish, it doesn't require any library and takes key_list into account:Here are some examples:
Not that it's a great idea, but for the sake of completeness it is also an option to use ast.literal_eval in this case:Output:


Answer URL
https://docs.python.org/3/library/ast.html#ast.literal_eval
