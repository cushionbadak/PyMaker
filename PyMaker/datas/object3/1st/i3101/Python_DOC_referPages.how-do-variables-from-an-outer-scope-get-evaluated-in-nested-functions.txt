Natural Text
Code first:I am not sure that, "inner_func" calls a parameter of "outer_func", but that is in the body of "outer_func". How can it "know" there is a "pa" when called by another_func?I mean, what is actually passed to another_func when its called in "outer_func"? It seems there is something more than a reference of the function object.
Function objects in Python aren't just functions, they're closures:1 they carry around a reference to the local environment where the def statement was executed.In particular, local variables from inside outer_func can be accessed from inside inner_func. (Even if you return inner_func, those values are kept alive so the closure will still work, for as long as inner_func is alive.)If you add a nonlocal statement inside inner_func, it can even reassign the local variables from the body of outer_func.How does this work?Well, a def statement2 is just a statement, like any other. What it does is something like this:That <code from compiling inner_func body> is actually a constant value—the compiler compiles the body of every function in your module into constant code objects at import time.But the function object that comes back from that _make_closure is a new thing that's created on the fly, and it has a reference to the local variables baked into it. Every time you run outer_func, it creates a new inner_func closure from the same <code>, each one capturing the current local environment.The details are a little more complicated—and, to some extent, they differ between implementations, so this will be CPython-specific.Part of the compiler's job is figuring out what kind of variable each name in a function is. You may have read the rules on globals vs. locals (a variable is local if and only if you have an assignment for the name somewhere in the function body, and there's no global statement). But closures make things more complicated. If a variable would have been local, but a nested function references the variable without assigning to it, or has a nonlocal statement, then it's a cell variable in the outer function, and a free variable in the inner function.3When the interpreter calls a function, it creates a frame object that holds the local namespace—the references to all of the function's local variables. But cell variables are special: the interpreter creates a special cell object for each one, and a reference to that cell goes into the namespace, so there's an extra dereference in front of the value every time you access or change it. And what that _make_closure pseudo-code above does is to copy the cells from the outer function's frame to a special attribute on the nested function called __closure__.Then, when you call the inner function, the interpreter copies those cells from the __closure__ into the frame for that function. So, the outer function's frame and the inner function's frame both have references to the same cells, which is how they can share variables.From more on this, see the inspect module's docs, which show you how to find things like __closure__ and co_freevars in your interactive interpreter, and the dis module which lets you look at the actual bytecode that your functions get compiled to.1. This is one of those words that has a slew of related but different meanings. "Closure" can mean the technique of capturing the local namespace in a function, or it can mean the captured namespace, or it can mean the function with a captured namespace attached to it, or it can mean one of the variables in the captured namespace. Usually it's obvious which one you mean from context. If not, you have to say something like "closure capture" or "closure function" or "closure variable".2. In case you're wondering, lambda expressions work exactly the same way as def statements. And class definitions are not identical, but similar.3. It's actually still more complicated if you have multiple layers of nesting, but let's ignore that.
You seem to be confusing the code if the function with the function object. The code object is evaluated only once, when the source file is read. However, a new function object called inner_func is created every time outer_func is called. This happens because a def statement is a type of assignment: it associates a function object with the specified name.The function object contains a reference to its code as a matter of course, along with references to all the namespaces it will need to operate, including it's parent's nonlocal namespace and the global module namespace.So the value of pa in inner_func is going to be whatever it is in outer_func at the time of calling. The reference is to the namespace, not the name itself. If outer_func returns (think decorators), the namespace will be fixed, and only accessible through inner_func's special reference to it.


Answer URL
https://docs.python.org/3/library/inspect.html
https://docs.python.org/3/library/dis.html
