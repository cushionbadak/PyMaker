Natural Text
I want to write my own socket class for server-client talking with RSA and AES encryption, and for server side I need to overload accept() function to return not (socket, address) pair, but (MySocket, address). So that's why I need MySocket class to be initializable with another socket.This is simplified version of my code:And after executing this code, I get an error:As I understand, the problem is in the #9 string self = socket_obj, but googling the error didn't give anything.
If MySocket is a subclass of socket, then a MySocket instance is a socket instance; it can't become a different socket instance, nor can you change another socket instance into a MySocket if it wasn't one already.1Just assigning self = socket_obj doesn't do anything useful. self is just a local variable inside the __init__ method. So, for the rest of the body of that method, when you do something to self, you're doing it to socket_obj instead of to your actual self. Assigning to its key attribute fails, as you saw. But, even if it didn't fail, all you would have done would be to modify socket_obj, while leaving yourself basically uninitialized.There are two possible things that do make sense here, however.First, instead of being a socket, your MySocket can own a socket, and provide the same interface as the socket type by delegating calls to its owned socket. Then, you can easily choose whether to own a newly-created socket, or one that was passed in. Something like this:Writing explicit delegators (whether manually, or by looping over inspect.getmembers(socket.socket) and creating them programmatically) is probably a better design here than __getattr__, but this gets the idea across.The other option is to to do effectively what ssl.SSLSocket does.Socket objects are basically just a thin wrapper around a file descriptor. You can call detach on a socket to steal its fd, and then you can pass that fd into the socket initializer:What SSLSocket actually does is more complicated (although it's not that complicated, and it may be worth reading the source).But also, notice that its interface is different. Stealing another socket's fd is kind of a strange thing to do in a constructor call, so instead, SSLSocket(socket_obj) will raise a TypeError, and you're instead required to use a wrap_socket function. This is probably a less confusing design.However, if you don't need the extra complexity of having different Context objects that all wrap sockets differently, you might just want a @classmethod alternate constructor method, instead of an external factory function.1. Actually, in Python, you can sometimes change the type of a live object, by setting its __class__ attribute. But this is almost always a bad idea, and wanting to do so is usually a sign that your design has gone very wrong somewhere.


Answer URL
https://docs.python.org/3/library/ssl.html#ssl.SSLSocket
https://docs.python.org/3/library/socket.html#socket.socket.detach
https://docs.python.org/3/library/socket.html#socket.socket
https://docs.python.org/3/library/ssl.html#ssl.SSLContext.wrap_socket
