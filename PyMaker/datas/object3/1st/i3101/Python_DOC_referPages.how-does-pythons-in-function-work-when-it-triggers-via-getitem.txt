Natural Text
The official documentation indicates that python first tries to check via __contains__(), then __iter__(), and finally __getitem__(), depending on which function is defined, in order to resolve an in call.Eg: The linked documentation indicates that if there exists any non negative index i such that x[i] == y, then the result is True else False.How does it perform a search over all such i? A linear traversal over 'all' positive numbers seems out of the question. There must be some bounds in which the linear traversal happens (for lists, it should be 0 to len()). How are those bounds determined?  
Aaah, I think get it... You want to know how the key is obtained to iterate over all elements on custom containers that do not have neither __contains__() nor __iter__() - simple, it works exactly using linear iteration until IndexError is encountered, as stated in the documentation:... if a class defines __getitem__(), x in y is True if and only if there is a non-negative integer index i such that x == y[i], and all lower integer indices do not raise IndexError exception. (If any other exception is raised, it is as if in raised that exception).Case in point:
The purpose of these special methods is to give you, the designer of your data structure, a way to perform lookups in a fast way that is appropriate to your situation. For example, you could derive a class from list that is enhanced by a reverse index for fast lookup by value. (Obviously this would slow down insertion since the index needs to be updated, but let's assume that you'll be doing a lot of lookups so you know it's worth it.)If your class has no way to improve on the default access, you don't need to define the special methods. Python will fall back on whatever is available, including sequential search.
How does it perform a search over all such i?This depends, pretty much on the data structure of the object in which the search is performing on. For example if you have a list object, the complexity of membership checking is O(n) and if you have a data structure that uses hashtable accessing its items (the __getitem__ attribute) such as dictionary or set the complexity is approximately O(1).So in general for user defined objects it works as it's explained in documentation. For objects without hash table it's a linear search and for objects with hash table its a constant search.   
The iteration for objects without __contains__ or __iter__ occurs here. The sequence scan occurs here. The decision to use __contains__ or falling back on iteration occurs here.
That's exactly how it works. Here's a demonstration using list:You can observe the time complexity increasing proportional to the size of the container.


Answer URL
https://docs.python.org/3/reference/expressions.html#membership-test-details
https://docs.python.org/3/library/exceptions.html#IndexError
