Natural Text
Below is a code to remove the recurrent alphabets from a string in python. I would like to know the time complexity of this code. More specifically time complexity of line if string_1[i] not in char_found:. Searching in a list.Also if possible can this be explained using space allocated by a list.
This line does two things:First, it accesses string_1[i]. That takes constant time, because strings are basically just arrays of characters.Then it searches in a list char_found, comparing that character string_1[i] to each element until one matches. That takes (worst-case) linear time in the length of char_found. And, since char_found could (worst-case) be all of the characters in string_1[:i], that's linear in the length of string_1.So, this line is O(N).And of course this line is inside an outer loop that's even more obviously O(N): for i in range(0,len(string_1)):. So, that combination of the two is O(N**2).Even if you fix that in test to be constant time, you also do result = result+string_1[i] inside the loop. String concatenation is worst-case linear in the length of the string. Recent versions of CPython and PyPy have some optimizations so it's sometimes amortized constant time, like appending to a list, but Python the language doesn't guarantee those optimizations. And result is, worst-case, also as long as string_1. So, the whole thing is still O(N**2), unless your interpreter is extra nice.You could reduce the whole thing to O(N) by making two small changes.First, use a set rather than a list for char_found. Searching a set, and adding to it, are both amortized constant-time operations.Second, use a list rather than a str for result, then do result = ''.join(result) at the end. Appending to a list is amortized constant-time. Converting a list back to a string is of course linear time, but you're not doing it inside your loops, so that's fine.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools-recipes
