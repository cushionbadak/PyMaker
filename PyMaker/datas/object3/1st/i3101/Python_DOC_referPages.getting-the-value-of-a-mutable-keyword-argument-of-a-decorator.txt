Natural Text
I have the following code, in which I simply have a decorator for caching a function's results, and as a concrete implementation, I used the Fibonacci function.After playing around with the code, I wanted to print the cache variable, that's initiated in the cache wrapper.(It's not because I suspect the cache might be faulty, I simply want to know how to access it without going into debug mode and put a breakpoint inside the decorator)I tried to explore the fib_w_cache function in debug mode, which is supposed to actually be the wrapped fib_w_cache, but with no success.
cache is of course a perfectly normal local variable in scope within the cache function, and a perfectly normal nonlocal cellvar in scope within the wrapper function, so if you want to access the value from there, you just do it—as you already are.But what if you wanted to access it from somewhere else? Then there are two options.First, cache happens to be defined at the global level, meaning any code anywhere (that hasn't hidden it with a local variable named cache) can access the function object.And if you're trying to access the values of a function's default parameters from outside the function, they're available in the attributes of the function object. The inspect module docs explain the inspection-oriented attributes of each builtin type:__defaults__ is a sequence of the values for all positional-or-keyword parameters, in order.__kwdefaults__ is a mapping from keywords to values for all keyword-only parameters.So:So, for a simple case where you know there's exactly one default value and know which argument it belongs to, all you need is:If you need to do something more complicated or dynamic, like get the default value for c in the f function above, you need to dig into other information—the only way to know that c's default value will be the second one in __defaults__ is to look at the attributes of the function's code object, like f.__code__.co_varnames, and figure it out from there. But usually, it's better to just use the inspect module's helpers. For example:Alternatively, if you're trying to access the cache from inside fib_w_cache, while there's no variable in lexical scope in that function body you can look at, you do know that the function body is only called by the decorator wrapper, and it is available there.So, you can get your stack frame… follow it back to your caller:… and grab it from that frame's locals:It's worth noting that f_locals works like the locals function: it's actually a copy of the internal locals storage, so modifying it may have no effect, and that copy flattens nonlocal cell variables to regular local variables. If you wanted to access the actual cell variable, you'd have to grub around in things like back.f_code.co_freevars to get the index and then dig it out of the function object's __closure__. But usually, you don't care about that.
I admit this is not an "elegant" solution in a sense, but keep in mind that python functions are also objects. So with some slight modification to your code, I managed to inject the cache as an attribute of a decorated function:
Just for a sake of completeness, python has caching decorator built-in in functools.lru_cache with some inspecting mechanisms:Prints:
I managed to find a solution (in some sense by @Patrick Haugh's advice).I simply accessed cache.__defaults__[0] which holds the cache's dict.The insights about the shared cache and how to avoid it we're also quite useful.Just as a note, the cache dictionary can only be accessed through the cache function object. It cannot be accessed through the decorated functions (at least as far as I understand). It logically aligns well with the fact that the cache is shared in my implementation, where on the other hand, in the alternative implementation that was proposed, it is local per decorated function.
You can make a class into a wrapper. Each function has its own cache. you can access it by calling function.cache.  This also allows for any methods you wish to attach to your function.  If you wanted all decorated functions to share the same cache, you could use a class variable instead of an instance variable:


Answer URL
https://docs.python.org/3/library/inspect.html
https://docs.python.org/3/library/functions.html#locals
