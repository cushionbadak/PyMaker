Natural Text
We know how bool() acts on various python objects such as str, int, list.This is a question about the reverse.You can cast bool to int aswhich I think kinda makes sense, but with string we getwhich I don't get, as firstly it seems to imply some relation between False and 'False', which only seems relevant at the code level. If what is written in code is to be treated this way, how does this work ...Second, it's not obvious it's for consistency, asMy question is ... is there a reason we're allowed to cast bool to str in this way? list for example won't allow it ... 
For debugging. If you can't cast a thing to a string, you can't print it. If you want to print a data structure for debugging, you need to be able to cast each element to a string. That's what str is documented to do...Return a string containing a nicely printable representation of an object.If what is written in code is to be treated this way, how does this work ...not True resolves to False which is then passed to str. It's similar to how with foo(1 + 1) foo receives 2.Second, it's not obvious it's for consistency, asCasting is not guaranteed to round trip. Examples are int(float(2.34)) or int(unichr(97)).There's an important difference between converting something to a string for humans, which is what str does, and converting something to a string for marshalling which must round trip. There are specialized packages like marshal or json for marshalling.But casting is the wrong way to think about bool and str in Python. As above, str returns a printable representation, not a machine-readable one. bool is for asking "what is the truthiness of this expression"? From the docs...x is converted using the standard truth testing procedure."True" and "False" are both true. If they added a special case just for bool that would be very inconsistent.
str() and bool() are not "casts", they're constructors (type objects). Calling str(x) for any value x will construct a new str object with its value initialized (somehow) from x. There is no implied relationship between the two objects; str(x) could return anything as long as it is a str object.Basically: stop thinking of Python as having "casts" like other languages you may be used to. Constructors are just another kind of callable, and the general rule is for each type to do something sensible with the argument(s) passed to the constructor. In the case of str(), it delegates to the __str__ special method if present, which means that bool objects return the strings 'True' and 'False' because that's what the bool type decided to do.
Well, what is the problem with str(True) being 'True'? That's quite the expected.Now, if you convert boolean to integer, it's obvious that the result must be a number. And, naturally, not True evaluates to False. That is str(False), then: 'False'.About the bool() function, it's supposed to return True for anything that is not empty, zero, None or False. So any string that is not '' fits this and returns True. See more: https://docs.python.org/3/library/stdtypes.html#truth
There is a very limited set of things considered False in Python:NoneFalsezero of any numeric type, for example, 0, 0L, 0.0, 0j.any empty sequence, for example, '', (), [].any empty mapping, for example, {}.instances of user-defined classes, if the class defines a nonzero() or len() method, when that method returns the integer zero or bool value FalseSo if you do bool(something) it will only return False for those items. Everything else in Python is True including string representations of falsy things: '0' 'False', 'None' etc because the string itself is True.


Answer URL
https://docs.python.org/3/library/stdtypes.html#truth
https://docs.python.org/3/reference/datamodel.html#object.__str__
https://docs.python.org/3/library/functions.html#bool
