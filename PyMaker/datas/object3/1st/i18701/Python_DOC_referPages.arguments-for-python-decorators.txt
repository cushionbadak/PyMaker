Natural Text
This question already has an answer here:How to create a decorator function with arguments on python class?                    1 answer                So with the following...The result isI would like to do something like this...and have the result be something like...Any advice would be great!
Wrap your function with another function:I leave working out how to build the string as an exercise for the reader.Note that the structure of a decorator expression is @ <callable object of one parameter, w> <declaration of callable object, f>. It's effect is f = w(f). Accordingly, w (the decorator) has to return a callable of the same type as f.In @makebold(foo)def bar(x):pass, the expression makebold(foo) is the decorator - that is, the final effect of the decorator is bar = makebold(foo)(bar), and so bar ends up holding wrapped.The purpose of functools.wraps is to fix up properties of the decorated function to copy over metadata (such as name and docstring) from the argument function to the wrapped function, so that the whole wrapping process is transparent.
I'm perhaps dubious that this is a good use case for decorators, but here:Example:Demo:The common misconception with decorators is that the parameters (attr1=...) are parameters to the decorator @myDecorator; that is not the case. Rather the result of the function call myDecoratorFactory(attr1=...) is calculated as someresult and becomes an anonymous decorator @someresult. Therefore 'decorators with arguments' are actually decorator factories that need to return a decorator as a value.
In order to do something like this, you would need a function that returns a decorator function. So in this case (assuming you want to accept arbitrary attributes), you would writeIn order to make this makeBold function a little more general, you want to pass arguments through to fn and keep other information such as function name using functools.wraps:


Answer URL
