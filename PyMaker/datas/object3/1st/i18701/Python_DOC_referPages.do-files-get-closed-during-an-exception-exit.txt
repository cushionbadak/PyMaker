Natural Text
Do open files (and other resources) get automatically closed when the script exits due to an exception?I'm wondering if I need to be closing my resources during my exception handling.**EDIT: to be more specific, I am creating a simple log file in my script. I want to know if I need to be concerned about closing the log file explicitly in the case of exceptions.since my script has a complex, nested, try/except blocks, doing so is somewhat complicated, so if python, CLIB, or the OS is going to close my text file when the script crashes/errors out, I don't want to waste too much time on making sure the file gets closed.If there is a part in Python manual that talks about this, please refer me to it, but I could not find it.
No, they don't. Use with statement if you want your files to be closed even if an exception occurs.From the docs:The with statement is used to wrap the execution of a block with  methods defined by a context manager. This allows common  try...except...finally usage patterns to be encapsulated for convenient reuse.From docs: The with statement allows objects like files to be used in a way that ensures they are always cleaned up promptly and correctly.After the statement is executed, the file f is always closed, even if a problem was encountered while processing the lines. Other objects which provide predefined clean-up actions will indicate this in their documentation.
A fairly straightforward question.Two answers.One saying, “Yes.”The other saying, “No!”Both with significant upvotes.Who to believe? Let me attempt to clarify.Both answers have some truth to them, and it depends on what you mean by afile being closed.First, consider what is meant by closing a file from the operating system’sperspective.When a process exits, the operating system clears up all the resourcesthat only that process had open. Otherwise badly-behaved programs thatcrash but didn’t free up their resources could consume all the systemresources.If Python was the only process that had that file open, then the file willbe closed. Similarly the operating system will clear up memory allocated bythe process, any networking ports that were still open, and most otherthings. There are a few exceptional functions like shmat that createobjects that persist beyond the process, but for the most part theoperating system takes care of everything.Now, what about closing files from Python’s perspective? If any programwritten in any programming language exits, most resources will get cleanedup—but how does Python handle cleanup inside standard Python programs?The standard CPython implementation of Python—as opposed to other Pythonimplementations like Jython—uses reference counting to do most of itsgarbage collection. An object has a reference count field. Every timesomething in Python gets a reference to some other object, the referencecount field in the referred-to object is incremented. When a reference islost, e.g, because a variable is no longer in scope, the reference count isdecremented. When the reference count hits zero, no Python code can reachthe object anymore, so the object gets deallocated. And when it getsdeallocated, Python calls the __del__() destructor.Python’s __del__() method for files flushes the buffers and closes thefile from the operating system’s point of view. Because of referencecounting, in CPython, if you open a file in a function and don’t return thefile object, then the reference count on the file goes down to zero whenthe function exits, and the file is automatically flushed and closed. Whenthe program ends, CPython dereferences all objects, and all objects havetheir destructors called, even if the program ends due to an unhandedexception. (This does technically fail for the pathological case where you have a cycleof objects with destructors,at least in Python versions before 3.4.)But that’s just the CPython implementation. Python the language is definedin the Python language reference, which is what all Pythonimplementations are required to follow in order to call themselvesPython-compatible.The language reference explains resource management in its data modelsection:Some objects contain references to “external” resources such as open  files or windows. It is understood that these resources are freed when  the object is garbage-collected, but since garbage collection is not  guaranteed to happen, such objects also provide an explicit way to  release the external resource, usually a close() method. Programs are  strongly recommended to explicitly close such objects. The  ‘try...finally‘ statement and the ‘with‘ statement provide convenient  ways to do this.That is, CPython will usually immediately close the object, but that maychange in a future release, and other Python implementations aren’t evenrequired to close the object at all.So, for portability and because explicit is better than implicit,it’s highly recommended to call close() on everything that can beclose()d, and to do that in a finally block if there is code betweenthe object creation and close() that might raise an exception. Or to usethe with syntactic sugar that accomplishes the same thing. If you dothat, then buffers on files will be flushed, even if an exception israised.However, even with the with statement, the same underlying mechanisms areat work. If the program crashes in a way that doesn’t give Python’s__del__() method a chance to run, you can still end up with a corruptfile on disk:This program produces a zero-length file. It’s an abnormal case, but itshows that even with the with statement resources won’t alwaysnecessarily be cleaned up the way you expect. Python tells the operatingsystem to open a file for writing, which creates it on disk; Python writes hiinto the C library’s stdio buffers; and then it crashes before the withstatement ends, and because of the apparent memory corruption, it’s not safefor the operating system to try to read the remains of the buffer and flush them to disk. So the program fails to clean up properly even though there’s a with statement. Whoops. Despite this, close() and with almost always work, and your program is always better off having them than not having them.So the answer is neither yes nor no. The with statement and close() are technically notnecessary for most ordinary CPython programs. But not using them results innon-portable code that will look wrong. And while they are extremelyhelpful, it is still possible for them to fail in pathological cases.
Yes they do. This is a CLIB (at least in cpython) and operating system thing. When the script exits, CLIB will flush and close all file objects. Even if it doesn't (e.g., python itself crashes) the operating system closes its resources just like any other process. It doesn't matter if it was an exception or a normal exit or even if its python or any other program. Here's a script that writes a file and raises an exception before the file contents have been flushed to disk. Works fine:
I, as well as other persons in this thread, are left with the question, "Well what is finally true?" Now, supposing that files are left open in a premature program termination -- and there are a lot of such cases besides exceptions due to file handling -- the only safe way to avoid this, is to read the whole (or part of the) file into a buffer and close it. Then handle the contents in the buffer as needed. This is esp. the case for global search, changes, etc. that have to be done on the file. After changes are done, one can then write the whole buffer to the same or other file at once, avoiding the risk to leave the the newly created file open -- by doing a lot readings and writings -- which is the worst case of all!


Answer URL
