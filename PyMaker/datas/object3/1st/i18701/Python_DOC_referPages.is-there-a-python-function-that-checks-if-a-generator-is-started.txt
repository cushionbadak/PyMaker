Natural Text
I try to define a generator function mycount() that can be reset with the generator function send(0) as in the example below. Everything works fine, except when I use send(0) on a new generator object that hasn't started yet. In this case it gives a TypeError. Is there any function that checks if the generator has started or do I have to catch the TypeError and create a new generator object with mycount(0) in such case?
To avoid sending a non-None value to a just-started generator, you need to call next or send(None) first.  I agree with the others that David Beazley's coroutine decorator (in python 3.x you need to call to __next__() function instead of next()) is a great option.  Though that particular decorator is simple, I've also successfully used the copipes library, which is a nice implementation of many of the utilities from Beazley's presentations, including coroutine.Regarding whether one can check if a generator is started - in Python 3, you can use inspect.getgeneratorstate.  This isn't available in Python 2, but the CPython implementation is pure python and doesn't rely on anything new to Python 3, so you can check yourself in the same way:Specifically, g2 is started if inspect.getgeneratorstate(g2) != inspect.GEN_CREATED.
As your error implies the send function must be called with None on a just-started generator(docs-link). You could catch the TypeError and roll from there:Either way it can't be used to 'reset' the generator, it just has to be remade. Great overview of generator concepts and syntax here, covering chaining of generators and other advanced topics.
In particular, you might find a way to use the consumer decorator described on p. I-131 of David Beazley's "Generator Tricks," to which J. Gwyn provided a link:I use something similar in my code.Note that if v is None is preferred over if v == None.
Here's a complete implementation Python2 compatible routine, getgeneratorstate(gtor), with test code.


Answer URL
