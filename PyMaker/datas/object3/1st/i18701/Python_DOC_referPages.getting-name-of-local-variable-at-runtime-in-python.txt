Natural Text
I should preface this by saying the following: I know this functionality is not supported by default - what I'm attempting is a hacky workaround that has very little practical application, and is a complete practice in mental masturbation as a result of boredom and curiosity. That said, I'm trying to do the following:Based upon the following Python code,I'd like to generate a file, mybuild.build with the contents:Ideally, I'd want to associate the variable name at the point of creation, so that if I were to set a breakpoint just after the objdir = 'obj' I'd like to be able to do the following:That wouldn't be possible with builtin functionality, however, since there's no way to override the type inferred from the syntax. I may end up hacking together a workaround in the BuildFile.__enter__ method that uses ctypes to monkey patch the tp_new or tp_dict fields on the underlying PyTypeObject struct (and subsequently revert that override at exit), but for simplicity sake, let's just assume that I'm not associating the variable name until I reach the BuildFile.__exit__ method.What I'm wondering about is the following:Is there builtin Python functionality for halting execution, tracing back to the frame in which a local variable was declared, and getting the local name associated with a variable?
Python doesn't have a portable way to trace frames… but the CPython implementation does: sys._getframe returns you a frame object.What can you do with a frame object? See the handy chart in the inspect docs for all the fun things it has, but they include the locals() and globals() as seen by the frame, and the code object executed in the frame—which itself includes local names, unbound names, and cells for closures.But, as others have points out, you don't really need the frame for this; all you need is the locals, and it's much simpler just to pass it to your context manager explicitly.If you really want to do this:When run, this should print:In other words, the names and values of only the new variables which were declared within the with block—which is, I think, what you wanted, right?If you want both new and rebound locals, you'd probably want to store something like this:Of course you can also rebind nonlocals and globals, so if you care about that, either stash globals as well (but make sure to check for locals is globals for module-level code), or walk the closure.If you're using CPython 2 (why? for real projects it sometimes makes sense, but to learn how the internals work for fun? and yet, some people to…), the same code will work. There may be slightly different attribute names, but you can guess them by dumping out the dir of a frame and a code. And obviously you want the 2.x print syntax.It also works in PyPy, at least 2.0b.If you're wondering how I knew to use _getframe(2)… I didn't. I was pretty sure it would be 1 or 2 frames up, just possibly 3, but which one? So I just did this:0 is of course dumping itself; 1 is the wrapper function in contextlib.contextmanager; 2 is the calling frame; 3 is the module top level. Which is obvious once you think about it, but it wasn't obvious until I knew the answer. :)
Actually you can perform similar trick like this:In your case it would look like:Is that what you wanted to do?
I think you can try this:Use this should do the trick, I have test this code myself.


Answer URL
