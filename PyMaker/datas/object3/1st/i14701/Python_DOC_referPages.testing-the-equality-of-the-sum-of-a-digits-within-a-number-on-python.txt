Natural Text
for example def f(n):and I wanna check whether the sum of the numbers within n equal to 100 whether it is in 1s, 2s, 3,s 4s, 5s and so on, depending on the length of n.This tests whether 5 + 0 + 5 + 0 == 100 and whether 50 + 50 ==100 and if any are true, it returns True.Whether it tests in 1s, 2s 3s 4s and so on, depends on the length of the number. For example a number with a length of 5 can only be tested in 1s. This tests whether 1 + 2 + 3 + 4 + 5 == 100 and only that.If the length of n was 15, it would test the digits in 1s, 3s and 5s.and finally one more example:This would test whether 2+5+2+5+2+5+2+5 == 100 and 25+25+25+25==100 and whether 2525+2525==100So n, which has a length of 8 would be tested in 1s , 2s , and 4s. It cannot be tested with 3s and 5s because the length of all the digits within the number being summed up must be the same. I hope I was able to explain what I'm after. Usually I would post what I've tried but I have no idea how to iterate over the digits of a number in such a way 
I think this does the trick. Not sure though:The zip thing comes from here. It's a little weird but it allows me to split the string up into n-length segments and then join it back together so I can apply an int mapping and then a sum reduction.The generator just gets all positive divisors of l from 1 to l, both inclusive. There may be faster ways of doing it for large n using math.sqrt and divmod.
The below approach uses generator to split the integer, and no integer <-> string conversion.This will likely be the most efficient approach of the ones currently listed.Output:Without comments and debugging print:
Assuming that the numbers are always positive integers, you can just divmod() them by 10 until you get to zero:Note that gives you the digits in reverse order. That doesn't matter if you're just adding them together, though.You can pass this around or use it in a for loop, like any other iterable:If you really need a sequence, just pass it to list():And if you need them in most-significant-first order, pass it to reversed():EDIT:Whoops, I missed…about half of the question. Things are rather more complicated. You'll need a function to get all the factors of a number—I'm sure there are plenty, so I'll leave that as an excercise for you. Let's assume there's a function factors(number) that returns an iterable of all a number's factors (including nonprimes and 1, but not number itself). We'll also use the int_iter() from my original answer, an int_from_digits() that takes a list of digits and returns a single integer (sort of like the inverse of int_iter()), and something called grouper() from the itertools recipes.Finally, armed with all these tools (or rather, one tool and its dependencies), we can perform your check with a simple comprehension and a call to any():
One possible way, separated into functions for each logical step :Get factors of n :For each l factor of n, split str(n) into chunks of length l :Check if sum of chunks in step 2 equals 100.



Answer URL
https://docs.python.org/3/library/itertools.html#itertools-recipes
