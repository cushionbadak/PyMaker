Natural Text
Sample code that works without issue:If you change p.apply_async(myfunc, [d]) to p.apply_async(myfunc, (d)) or p.apply_async(myfunc, d) then the pool will not work at all. If you add another arg to myfunc and then just pass in a None it'll work like this p.apply_async(myfunc, (None, d)) â€” but why?
The documentation for apply_async says the following:apply(func[, args[, kwds]])Call func with arguments args and keyword arguments kwds. It blocks until the result is ready. Given this blocks, apply_async() is better suited for performing work in parallel. Additionally, func is only executed in one of the workers of the pool.Thus instead of taking star and double star arguments, it takes positional arguments and keyword arguments to be passed to the target function as the 2nd and 3rd arguments to the function; the second must be an iterable and the 3rd one a mapping, respectively.Notice that since the apply works asynchronously, you won't see any exceptions, unless you .wait and .get them from the results; You can try simply:In the code above, the result.get() waits for the completion of the 100th thread and returns its returned value - or tries as it will fail, because the managed dictionary cannot be used as the positional arguments:Thus, looking at your original question: do note that [d] is a list of length 1; (d) is the same as d; to have a tuple of length 1 you need to type (d,). From the Python 3 tutorial section 5.3:A special problem is the construction of tuples containing 0 or 1  items: the syntax has some extra quirks to accommodate these. Empty  tuples are constructed by an empty pair of parentheses; a tuple with  one item is constructed by following a value with a comma (it is not  sufficient to enclose a single value in parentheses). Ugly, but  effective. For example:(d,), [d], {d}, or even iter(frozenset(d)) or {d: True} would work just nicely as your positional arguments; all these as args would result in an Iterable whose iterator yields exactly 1 value - that of d. On the other hand, if you had passed almost any other kind of value than that unfortunate managed dictionary, you would have gotten a much more usable error; say if the value was 42, you'd have got:


Answer URL
https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.apply
https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences
