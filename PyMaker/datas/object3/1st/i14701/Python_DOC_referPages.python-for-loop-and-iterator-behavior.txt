Natural Text
I wanted to understand a bit more about iterators, so please correct me if I'm wrong.An iterator is an object which has a pointer to the next object and is read as a buffer or stream (i.e. a linked list). They're particularly efficient cause all they do is tell you what is next by references instead of using indexing.However I still don't understand why is the following behavior happening:After a first loop through the iterator (In [2]) it's as if it was consumed and left empty, so the second loop (In [3]) prints nothing. However I never assigned a new value to the iter variable.What is really happening under the hood of the for loop?
Your suspicion is correct: the iterator has been consumed. In actuality, your iterator is a generator, which is an object which has the ability to be iterated through only once.The reason they are efficient has nothing to do with telling you what is next "by reference." They are efficient because they only generate the next item upon request; all of the items are not generated at once. In fact, you can have an infinite generator:Some other corrections to help improve your understanding: The generator is not a pointer, and does not behave like a pointer as you might be familiar with in other languages.One of the differences from other languages: as said above, each result of the generator is generated on the fly. The next result is not produced until it is requested.The keyword combination for in accepts an iterable object as its second argument. The iterable object can be a generator, as in your example case, but it can also be any other iterable object, such as a list, or dict, or a str object (string), or a user-defined type that provides the required functionality. The iter function is applied to  the object to get an iterator (by the way: don't use iter as a variable name in Python, as you have done - it is one of the keywords). Actually, to be more precise, the object's __iter__ method is called (which is, for the most part, all the iter function does anyway; __iter__ is one of Python's so-called "magic methods").If the call to __iter__ is successful, the function next() is applied to the iterable object over and over again, in a loop, and the first variable supplied to for in is assigned to the result of the next() function. (Remember: the iterable object could be a generator, or a container object's iterator, or any other iterable object.) Actually, to be more precise: it calls the iterator object's __next__ method, which is another "magic method". The for loop ends when next() raises the StopIteration exception (which usually happens when the iterable does not have another object to yield when next() is called).You can "manually" implement a for loop in python this way (probably not perfect, but close enough):There is pretty much no difference between the above and your example code. Actually, the more interesting part of a for loop is not the for, but the in. Using in by itself produces a different effect than for in, but it is very useful to understand what in does with its arguments, since for in implements very similar behavior. When used by itself, the in keyword first calls the object's __contains__ method, which is yet another "magic method" (note that this step is skipped when using for in). Using in by itself on a container, you can do things like this:If the iterable object is NOT a container (i.e. it doesn't have a __contains__ method), in next tries to call the object's __iter__ method. As was said previously: the __iter__ method returns what is known in Python as an iterator. Basically, an iterator is an object that you can use the built-in generic function next() on1. A generator is just one type of iterator. If the call to __iter__ is successful, the in keyword applies the function next() to the iterable object over and over again. (Remember: the iterable object could be a generator, or a container object's iterator, or any other iterable object.) Actually, to be more precise: it calls the iterator object's __next__ method). If the object doesn't have a __iter__ method to return an iterator, in then falls back on the old-style iteration protocol using the object's __getitem__ method2. If all of the above attempts fail, you'll get a TypeError exception.If you wish to create your own object type to iterate over (i.e, you can use for in, or just in, on it), it's useful to know about the yield keyword, which is used in generators (as mentioned above). The presence of yield turns a function or method into a generator instead of a regular function/method. You don't need the __next__ method if you use a generator (it brings __next__ along with it automatically). If you wish to create your own container object type (i.e, you can use in on it by itself, but NOT for in), you just need the __contains__ method. 1 Note that, to be an iterator, an object must implement the iterator protocol. This only means that both the __next__ and __iter__ methods must be correctly implemented (generators come with this functionality "for free", so you don't need to worry about it when using them). Also note that the ___next__ method is actually next (no underscores) in Python 2. 2 See this answer  for the different ways to create iterable classes.
For loop basically calls the next method of an object that is applied to (__next__ in Python 3).You can simulate this simply by doing:At this point there is no next element in the input object. So doing this:Will result in StopIteration exception thrown. At this point for will stop. And iterator can be any object which will respond to the next() function and throws the exception when there are no more elements. It does not have to be any pointer or reference (there are no such things in python anyway in C/C++ sense), linked list, etc. 
There is an iterator protocol in python that defines how the for statement will behave with lists and dicts, and other things that can be looped over.It's in the python docs here and here.The way the iterator protocol works typically is in the form of a python generator.  We yield a value as long as we have a value until we reach the end and then we raise StopIterationSo let's write our own iterator:The result is:A couple of things to note about that.  The my_iter is a function.  my_iter() returns an iterator. If I had written using iterator like this instead:And the result is the same as above.  The iter is exhausted by the time we enter the second for loop.But that's rather simplistic what about something more complicated?  Perhaps maybe in a loop why not?And when it runs, we use the iterator on the string type (which is built into iter).  This in turn, allows us run a for loop on it, and yield the results until we are done. So now this begs the question, so what happens between yields in the iterator?  The answer is the function is paused at the yield waiting for the next call to next().
Some additional details about the behaviour of iter() with __getitem__ classes that lack their own __iter__ method.Before __iter__ there was __getitem__.  If the __getitem__ works with ints from 0 - len(obj)-1, then iter() supports these objects.  It will construct a new iterator that repeatedly calls __getitem__ with 0, 1, 2, ... until it gets an IndexError, which it converts to a StopIteration.See this answer for more details of the different ways to create an iterator.
Excerpt from the Python Practice book:5. Iterators & Generators5.1. IteratorsWe use for statement for looping over a list.If we use it with a string, it loops over its characters.If we use it with a dictionary, it loops over its keys.If we use it with a file, it loops over lines of the file.So there are many types of objects which can be used with a for loop. These are called iterable objects.There are many functions which consume these iterables.5.1.1. The Iteration ProtocolThe built-in function iter takes an iterable object and returns an iterator.StopIterationEach time we call the next method on the iterator gives us the next element. If there are no more elements, it raises a StopIteration.Iterators are implemented as classes. Here is an iterator that works like built-in xrange function.The iter method is what makes an object iterable. Behind the scenes, the iter function calls iter method on the given object.The return value of iter is an iterator. It should have a next method and raise StopIteration when there are no more elements.Lets try it out:StopIterationMany built-in functions accept iterators as arguments.In the above case, both the iterable and iterator are the same object. Notice that the iter method returned self. It need not be the case always.If both iteratable and iterator are the same object, it is consumed in a single iteration.5.2. GeneratorsGenerators simplifies creation of iterators. A generator is a function that produces a sequence of results instead of a single value.Each time the yield statement is executed the function generates a new value.StopIterationSo a generator is also an iterator. You don’t have to worry about the iterator protocol.The word “generator” is confusingly used to mean both the function that generates and what it generates. In this chapter, I’ll use the word “generator” to mean the generated object and “generator function” to mean the function that generates it.Can you think about how it is working internally?When a generator function is called, it returns a generator object without even beginning execution of the function. When next method is called for the first time, the function starts executing until it reaches yield statement. The yielded value is returned by the next call.The following example demonstrates the interplay between yield and call to next method on generator object.StopIterationLets see an example:
Concept 1All generators are iterators but all iterators are not generatorConcept 2An iterator is an object with a next (Python 2) or next (Python 3)  method.Concept 3Quoting from wiki  Generators Generators  functions allow you to declare a function that behaves like an  iterator, i.e. it can be used in a for loop.In your case


Answer URL
https://docs.python.org/3/library/functions.html#iter
https://docs.python.org/3/reference/datamodel.html#object.__iter__
https://docs.python.org/3/library/functions.html#next
https://docs.python.org/3/library/stdtypes.html#iterator.__next__
https://docs.python.org/3/library/exceptions.html#StopIteration
https://docs.python.org/3/reference/datamodel.html#object.__contains__
https://docs.python.org/3/library/stdtypes.html#iterator-types
https://docs.python.org/3/library/functions.html#next
https://docs.python.org/3/library/functions.html#next
https://docs.python.org/3/library/stdtypes.html#iterator.__next__
https://docs.python.org/3/library/exceptions.html#TypeError
https://docs.python.org/3/glossary.html#term-generator
https://docs.python.org/3/library/stdtypes.html#iterator-types
https://docs.python.org/3/library/stdtypes.html
