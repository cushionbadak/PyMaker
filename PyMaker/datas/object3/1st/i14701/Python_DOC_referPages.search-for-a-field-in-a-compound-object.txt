Natural Text
I'm fairly new to Python, and am creating a program that tracks RFID badges used by the students in my school district.  In my program I have a class named Badge that creates a badge object with six public named variables (RFID, studentID, status, dateActivated, dateDeactivated, reason).  I then have a class named BadgeTable that holds badges.What I want to do is see if a specific RFID or studentID exists in any of the badges.  I know I can do this with loops, but that can take a while (I'm reading in about 450 CSV files, each of which contains 2000 to 14000 badges, and adding a badge to BadgeTable only if it hasn't already been added).  Edit: to expand on the above, all badge data for the last three years has been manually entered into a spreadsheet that has logic to identify duplicate RFID or studentID numbers, then exported each day as a CSV file for the badge reader software.  For the first year of our bus badge program each day's CSV file only contained active badges; we naively assumed that if we stopped sending inactive badges they would be rejected by the badge reader.  When we discovered we were wrong, we started including the inactive badges we knew about in the CSV files (we added a suffix to the studentID for each inactive badge to keep them unique), so from then on each days's CSV file was a superset of the previous day's file.  However, there are a not insignificant number inactive/lost badges not in the current CSV file, so the above process was meant to be a way use the old CSV files to a) get as complete a list as possible of badges we've issued, and b) eliminate misspellings in the student names associated with each badge.I'd like to be able to say something like:What I want that to do is see if the variable RFID matches the RFID field in any of the badges in studentBadges.  I've tried that, and studentBadges[:][1], but both fail (both with 'BadgeTable' object is not subscriptable)My current workaround is to actually store a separate list in the BadgeTable class named RFIDList, and when each badge gets added to BadgeTable I also add it's RFID value to RFIDList.  As long as I never sort either RFIDList or the list of badges itself I can do things like:Is there a more elegant, more Pythonic way to test for the existence of a value in a compound object in Python 3, one that doesn't involve keeping parallel lists in the class?
I'm not quite sure why you need BadgeTable to be a class rather than just having studentBadges be a collection of Badges. Does it do something additional to just hold the data?In any case, it makes sense to look at what collections python has to offer beyond lists. It seems you care about uniqueness of Badges, but not about their order. Lists (similar to "arrays" in other programming languages) are all about order. Sets and dictionaries ("associative arrays" or "hash maps" in other languages) are unordered, but help you with uniqueness:Sets contain each object at most onceDictionaries contain each key object at most once. Each key points to a value object. (Several keys might point to the same value.)So you could have two dictionaries, one mapping RFIDs to Badges and one mapping studentIDs to Badges. A lookup in these would be much quicker than in lists.But even better might be to just have the Badges in a single set. Trying to add a Badge a second time would do nothing. Holding a (mathematical) set of unique objects is exactly what a (python) set does.But when are two objects the "same"? Instances of user-defined classes like Badge are hashable by default, but compare unequal except with themselves. So each Badge you freshly create from read-in data would be considered different from all others, even if some share its RFID or studentID. Thus, override methods __hash__() and __eq__() in Badge, so that Badge compare equal iff their RFIDs match.Nota bene: Equality consistenceEquality should be transitive. (I.e. if a == b and b == c, then also a == c.) Thus you could make Badges compare equal if both, their RFIDs and their studientIDs match, but you should not make them equal already if any, their RFIDs or their studientIDs match. (It'd be impossible to find a meaningful __hash__() implementation consistent with the latter, anyway.)Though I guess if a student has been given several badges (with different RFIDs) in his or her school career your program might want to know about more than just the first badge, anyway.6'300'000 badgesLooking at the amounts of data you're handling here, are you sure you want to (and can) hold it all in memory? If not, using python to access the data base management system of your choice would probably be the way to go. Relational databases also support the set operation semantics you'd want to rely on.


Answer URL
https://docs.python.org/3/tutorial/datastructures.html#sets
https://docs.python.org/3/tutorial/datastructures.html#dictionaries
https://docs.python.org/3/glossary.html#term-hashable
