Natural Text
This is a tricky question and I've read a lot of posts about it, but I haven't been able to make it work.I have a big file. I need to read it line by line, and once I reach a line of the form "Total is: (any decimal number)", take this string and to save the number in a variable. If the number is bigger than 40.0, then I need to find the fourth line above the Total line (for example, if the Total line was line 39, this line would be line 35). This line will be in the format "(number).(space)(substring)". Finally, I need to parse this substring out and do further processing on it.This is an example of what an input file might look like:I have tried many things, including using the re.search() method to capture what I need from each line I need to focus on.Here is my code which I modified from another stackoverflow Q & A:The expected output would be:
This stores the line which starts with  a number and a dot into a variable called prevline. We print the prevline only if  re.search returns a match object.Output:
If the line you need is always four lines above the Total is: line, you could keep the previous lines in a bounded deque.A bounded deque (one with a maximum length) will discard an item from the opposite side if adding a new item would cause it to exceed its maximum length. In this case, we're appending strings to the right side of the deque, so once the length of the deque reaches 4, each new string we append to the right side will cause it to discard one string from the left side. Thus, at the beginning of the for loop, the deque will contain the four lines prior to the current line, with the oldest line at the far left (index 0).In fact, the documentation on collections.deque mentions use cases very similar to ours:Bounded length deques provide functionality similar to the tail filter in Unix. They are also useful for tracking transactions and other pools of data where only the most recent activity is of interest.
I suggested an edit to Blacklight Shining's post that built on its deque solution, but it was rejected with the suggestion that it instead be made into an answer.  Below, I show how Blacklight's solution does solve your problem, if you were to just stare at it for a moment.I don't take advantage of deque, but my code accomplishes the same thing imperatively.  I don't think it's necessarily a better answer than either of the others; I'm posting it to show how the problem you're trying to solve can be addressed with a very simple algorithm and simple tools. (Compare Avinash's clever 17 line solution with my dumbed-down 18 line solution.)This simplified approach won't make you look like a wizard to anyone reading your code, but it also won't accidentally match on anything in the intervening lines.  If you're dead set on hitting your lines with a regex, then just modify lines A and B.  The general solution still works.The point is, an easy way to remember what was on the line 4 lines back is to just store the last four lines in memory.


Answer URL
https://docs.python.org/3/library/collections.html#collections.deque
https://docs.python.org/3/library/collections.html#collections.deque
