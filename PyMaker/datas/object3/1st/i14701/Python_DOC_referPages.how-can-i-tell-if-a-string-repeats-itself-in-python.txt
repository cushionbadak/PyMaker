Natural Text
I'm looking for a way to test whether or not a given string repeats itself for the entire string or not.Examples:are strings which repeat themselves, andare examples of ones that do not.The repeating sections of the strings I'm given can be quite long, and the strings themselves can be 500 or more characters, so looping through each character trying to build a pattern then checking the pattern vs the rest of the string seems awful slow. Multiply that by potentially hundreds of strings and I can't see any intuitive solution.I've looked into regexes a bit and they seem good for when you know what you're looking for, or at least the length of the pattern you're looking for. Unfortunately, I know neither.How can I tell if a string is repeating itself and if it is, what the shortest repeating subsequence is?
Here's a concise solution which avoids regular expressions and slow in-Python loops:See the Community Wiki answer started by @davidism for benchmark results. In summary,David Zhang's solution is the clear winner, outperforming all others by at least 5x for the large example set.(That answer's words, not mine.)This is based on the observation that a string is periodic if and only if it is equal to a nontrivial rotation of itself. Kudos to @AleksiTorhamo for realizing that we can then recover the principal period from the index of the first occurrence of s in (s+s)[1:-1], and for informing me of the optional start and end arguments of Python's string.find.
Here's a solution using regular expressions.Iterating over the examples in the question:... produces this output:The regular expression (.+?)\1+$ is divided into three parts:(.+?) is a matching group containing at least one (but as few as possible) of any character (because +? is non-greedy).\1+ checks for at least one repetition of the matching group in the first part.$ checks for the end of the string, to ensure that there's no extra, non-repeating content after the repeated substrings (and using re.match() ensures that there's no non-repeating text before the repeated substrings).In Python 3.4 and later, you could drop the $ and use re.fullmatch() instead, or (in any Python at least as far back as 2.3) go the other way and use re.search() with the regex ^(.+?)\1+$, all of which are more down to personal taste than anything else.
You can make the observation that for a string to be considered repeating, its length must be divisible by the length of its repeated sequence. Given that, here is a solution that generates divisors of the length from 1 to n / 2 inclusive, divides the original string into substrings with the length of the divisors, and tests the equality of the result set:EDIT: In Python 3, the / operator has changed to do float division by default. To get the int division from Python 2, you can use the // operator instead. Thank you to @TigerhawkT3 for bringing this to my attention.The // operator performs integer division in both Python 2 and Python 3, so I've updated the answer to support both versions. The part where we test to see if all the substrings are equal is now a short-circuiting operation using all and a generator expression.UPDATE: In response to a change in the original question, the code has now been updated to return the smallest repeating substring if it exists and None if it does not. @godlygeek has suggested using divmod to reduce the number of iterations on the divisors generator, and the code has been updated to match that as well. It now returns all positive divisors of n in ascending order, exclusive of n itself.Further update for high performance: After multiple tests, I've come to the conclusion that  simply testing for string equality has the best performance out of any slicing or iterator solution in Python. Thus, I've taken a leaf out of @TigerhawkT3 's book and updated my solution. It's now over 6x as fast as before, noticably faster than Tigerhawk's solution but slower than David's.
Here are some benchmarks for the various answers to this question. There were some surprising results, including wildly different performance depending on the string being tested.Some functions were modified to work with Python 3 (mainly by replacing / with // to ensure integer division). If you see something wrong, want to add your function, or want to add another test string, ping @ZeroPiraeus in the Python chatroom.In summary: there's about a 50x difference between the best- and worst-performing solutions for the large set of example data supplied by OP here (via this comment). David Zhang's solution is the clear winner, outperforming all others by around 5x for the large example set.A couple of the answers are very slow in extremely large "no match" cases. Otherwise, the functions seem to be equally matched or clear winners depending on the test.Here are the results, including plots made using matplotlib and seaborn to show the different distributions:Corpus 1 (supplied examples - small set)Corpus 2 (supplied examples - large set)Corpus 3 (edge cases)The tests and raw results are available here.
Non-regex solution:Faster non-regex solution, thanks to @ThatWeirdo (see comments):The above solution is very rarely slower than the original by a few percent, but it's usually a good bit faster - sometimes a whole lot faster. It's still not faster than davidism's for longer strings, and zero's regex solution is superior for short strings. It comes out to the fastest (according to davidism's test on github - see his answer) with strings of about 1000-1500 characters. Regardless, it's reliably second-fastest (or better) in all cases I tested. Thanks, ThatWeirdo.Test:Results:
First, halve the string as long as it's a "2 part" duplicate.  This reduces the search space if there are an even number of repeats.  Then, working forwards to find the smallest repeating string, check if splitting the full string by increasingly larger sub-string results in only empty values.  Only sub-strings up to length // 2 need to be tested since anything over that would have no repeats.This returns the shortest match or None if there is no match.
The problem may also be solved in O(n) in worst case with prefix function.Note, it may be slower in general case(UPD: and is much slower) than other solutions which depend on number of divisors of n, but usually find fails sooner, I think one of bad cases for them will be aaa....aab, where there are n - 1 = 2 * 3 * 5 * 7 ... *p_n - 1 a'sFirst of all you need to calculate prefix functionthen either there's no answer or the shortest period isand you just have to check if k != n and n % k == 0 (if k != n and n % k == 0 then answer is s[:k], else there's no answerYou may check the proof here (in Russian, but online translator will probably do the trick)
This version tries only those candidate sequence lengths that are factors of the string length; and uses the * operator to build a full-length string from the candidate sequence:Thanks to TigerhawkT3 for noticing that length // 2 without + 1 would fail to match the abab case.
Here's a straight forward solution, without regexes. For substrings of s starting from zeroth index, of lengths 1 through len(s), check if that substring, substr is the repeated pattern. This check can be performed by concatenating substr with itself ratio times, such that the length of the string thus formed is equal to the length of s. Hence ratio=len(s)/len(substr). Return when first such substring is found. This would provide the smallest possible substring, if one exists.
I started with more than eight solutions to this problem. Some were bases on regex (match, findall, split), some of string slicing and testing, and some with string methods (find, count, split). Each had benefits in code clarity, code size, speed and memory consumption. I was going to post my answer here when I noticed that execution speed was ranked as important, so I did more testing and improvement to arrive at this:This answer seems similar to a few other answers here, but it has a few speed optimisations others have not used:xrange is a little faster in this application,if an input string is an odd length, do not check any even length substrings,by using s[:n] directly, we avoid creating a variable in each loop.I would be interested to see how this performs in the standard tests with common hardware. I believe it will be well short of David Zhang's excellent algorithm in most tests, but should be quite fast otherwise.I found this problem to be very counter-intuitive. The solutions I thought would be fast were slow. The solutions that looked slow were fast! It seems that Python's string creation with the multiply operator and string comparisons are highly optimised.
This function runs very quickly (tested and it's over 3 times faster than fastest solution here on strings with over 100k characters and the difference gets bigger the longer the repeating pattern is). It tries to minimise the number of comparisons needed to get the answer:Note that for example for string of length 8 it checks only fragment of size 4 and it does not have to test further because pattern of length 1 or 2 would result in repeating pattern of length 4:
In David Zhang's answer if we have some sort of circular buffer this will not work: principal_period('6210045662100456621004566210045662100456621') due to the starting 621, where I would have liked it to spit out: 00456621.Extending his solution we can use the following: 
Here is the code in python that checks for repetition of sub string in the main string given by the user.Input:  0045662100456621004566210045662100456621  Output :Length of your string : 40    Sub-String '00456621' repeats in string '0045662100456621004566210045662100456621' Input :004608294930875576036866359447Output:  Length of your string : 30No repeating Sub-String found in string '004608294930875576036866359447'


Answer URL
https://docs.python.org/3/library/re.html#regular-expression-syntax
https://docs.python.org/3/library/re.html#re.match
https://docs.python.org/3/library/re.html#re.fullmatch
https://docs.python.org/3/library/re.html#re.search
https://docs.python.org/3/library/statistics.html
