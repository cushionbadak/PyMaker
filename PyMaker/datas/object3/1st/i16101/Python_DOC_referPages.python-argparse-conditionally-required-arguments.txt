Natural Text
I have done as much research as possible but I haven't found the best way to make certain cmdline arguments necessary only under certain conditions, in this case only if other arguments have been given. Here's what I want to do at a very basic level:From what I have seen, other people seem to just add their own check at the end:Is there a way to do this natively within the argparse package?
I've been searching for a simple answer to this kind of question for some time. All you need to do is check if '--argument' is in sys.argv, so basically for your code sample you could just do:This way required receives either True or False depending on whether the user as used --argument. Already tested it, seems to work and guarantees that -a and -b have an independent behavior between each other.
You can implement a check by providing a custom action for --argument, which will take an additional keyword argument to specify which other action(s) should become required if --argument is used.The exact definition of CondAction will depend on what, exactly, --argument should do. But, for example, if --argument is a regular, take-one-argument-and-save-it type of action, then just inheriting from argparse._StoreAction should be sufficient.In the example parser, we save a reference to the --a option inside the --argument option, and when --argument is seen on the command line, it sets the required flag on --a to True. Once all the options are processed, argparse verifies that any option marked as required has been set.
Your post parsing test is fine, especially if testing for defaults with is None suits your needs.http://bugs.python.org/issue11588 'Add "necessarily inclusive" groups to argparse' looks into implementing tests like this using the groups mechanism (a generalization of mutuall_exclusive_groups).I've written a set of UsageGroups that implement tests like xor (mutually exclusive), and, or, and not.  I thought those where comprehensive, but I haven't been able to express your case in terms of those operations. (looks like I need nand - not and, see below)This script uses a custom Test class, that essentially implements your post-parsing test.  seen_actions is a list of Actions that the parse has seen.Sample output is:usage and error messages still need work.  And it doesn't do anything that post-parsing test can't.Your test raises an error if (argument & (!a or !b)).  Conversely, what is allowed is !(argument & (!a or !b)) = !(argument & !(a and b)).  By adding a nand test to my UsageGroup classes, I can implement your case as:The usage is (using !() to mark a 'nand' test):I think this is the shortest and clearest way of expressing this problem using general purpose usage groups.In my tests, inputs that parse successfully are:Ones that are supposed to raise errors are:
Until http://bugs.python.org/issue11588 is solved, I'd just use nargs:This way, if anybody supplies --arguments, it will have 2 values.Maybe its CLI result is less readable, but code is much smaller. You can fix that with good docs/help.
For arguments I've come up with a quick-n-dirty solution like this. Assumptions:  (1) '--help' should display help and not complain about required argument and (2) we're parsing sys.argvThis can easily be modified to match a specific setting.For required positionals (which will become unrequired if e.g. '--help' is given on the command line) I've come up with the following: [positionals do not allow for a required=... keyword arg!]basically this turns the number of required occurrences of 'pattern' on the command line from one-or-more into zero-or-more in case '--help' is specified.


Answer URL
https://docs.python.org/3/library/argparse.html?highlight=argumentparser#nargs
