Natural Text
I would like to have a function pointer ptr that can point to either: a function, the method of an object instance, or the constructor of the object. In the latter case, the execution of ptr() should instantiate the class.This produces as output:showing that the first two ptr() calls worked, but the last did not.
The reason this doesn't work is that the __init__ method isn't a constructor, it's an initializer.*Notice that its first argument is self—that self has to be already constructed before its __init__ method gets called, otherwise, where would it come from.In other words, it's a normal instance method, just like instance.m is, but you're trying to call it as an unbound method—exactly as if you'd tried to call C.m instead of instance.m.Python does have a special method for constructors, __new__ (although Python calls this a "creator" to avoid confusion with languages with single-stage construction). This is a static method that takes the class to construct as its first argument and the constructor arguments as its other arguments. The default implementation that you've inherited from object just creates an instance of that class and passes the arguments along to its initializer.** So:Or, if you prefer:However, it's incredibly rare that you'll ever want to call __new__ directly, except from a subclass's __new__. Classes themselves are callable, and act as their own constructors—effectively that means that they call the __new__ method with the appropriate arguments, but there are some subtleties (and, in every case where they differ, C() is probably what you want, not C.__new__(C)).So:As user2357112 points out in a comment:In general, if you want a ptr that does whatever_expression(foo) when you call ptr(foo), you should set ptr = whatever_expressionThat's a great, simple rule of thumb, and Python has been carefully designed to make that rule of thumb work whenever possible.Finally, as a side note, you can assign ptr to anything callable, not just the cases you described:a function,a bound method (your instance.m),a constructor (that is, a class),an unbound method (e.g., C.m—which you can call just fine, but you'll have to pass instance as the first argument),a bound classmethod (e.g., both C.cm and instance.cm, if you defined cm as a @classmethod),an unbound classmethod (harder to construct, and less useful),a staticmethod (e.g., both C.sm and instance.sm, if you defined sm as a @staticmethod),various kinds of implementation-specific "builtin" types that simulate functions, methods, and classes.an instance of any type with a __call__ method,And in fact, all of these are just special cases of the last one—the type type has a __call__ method, as do types.FunctionType and types.MethodType, and so on.* If you're familiar with other languages like Smalltalk or Objective-C, you may be thrown off by the fact that Python doesn't look like it has two-stage construction. In ObjC terms, you rarely implement alloc, but you call it all the time: [[MyClass alloc] initWithArgument:a]. In Python, you can pretend that MyClass(a) means the same thing (although really it's more like [MyClass allocWithArgument:a], where allocWithArgument: automatically calls initWithArgument: for you).** Actually, this isn't quite true; the default implementation just returns an instance of C, and Python automatically calls the __init__ method if isinstance(returnvalue, C).
I had a hard time finding the answer to this problem online, but I figured it out, so here is the solution.Instead of pointing constructorPtr at C.__init__, you can just point it at C, like this.which produces as output:


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__init__
https://docs.python.org/3/reference/datamodel.html#object.__new__
