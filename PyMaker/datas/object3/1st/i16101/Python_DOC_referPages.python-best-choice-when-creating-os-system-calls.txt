Natural Text
Im looking to connect to an SMB share using mount_smbfs (python on OSX). Im trying to find the most efficient way to do this. Below is what I am thinking, but I am not sure how to place the vairable names into the command line string correctly.Any advice on the best way to move forward would be appreciated.
Your code won't actually work:You're calling os.system with a whole slew of separate arguments: "mount_smbfs //", then domain, and so on. But it only takes one argument.I think you're expecting it to work like print—but even if it did, print would stick spaces between each element, so you'd end up with USER : PASS @ SERVER, which isn't going to do much good.If you want to concatenate them all together, you can do that by using the + operator, or, far better, str.format, like this:But that's still not going to work, because the shell is going to misinterpret that ; as a special character separating two statements. And, without quoting, it will also fail if there are spaces or other special characters in any of the strings.All of that is fixable if you really want to fight with it, but there's no good reason to do so. As the docs for os.system say:The subprocess module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using this function.Here's how you'd do it with subprocess:This leaves the shell out of it entirely—which is marginally more efficient (not that it's likely to ever matter), but also a whole lot simpler, because you don't have to worry about escaping or quoting special shell characters. It's also more robust; if the call fails, instead of failing silently, it will raise an exception. Using subprocess also gives you the opportunity to capture the stdout or stderr, or do various other things, with only minor changes to your code.
Don't use os.system. Use the subprocess module from the standard library.The problem with os.system is that it passes your command line through the shell (e.g. bash, csh) which opens up a number of security risks as well as opportunities for the shell to mangle the command line, such as by erroneously detecting special characters, shell variables, quoted strings, spaces, or escapes.With subprocess you can specify the exact individual command-line arguments that the external program receives.* You would probably use it something like this:Notice that there is no need to worry about, say, spaces or special characters that may appear in the parameters.* This should work on MacOS and any other POSIX-y OS; it's pretty reliable on Windows but it's not 100% possible to map unambiguously between the POSIX model of a command line as an array of strings and the Windows/DOS model as a single string.


Answer URL
https://docs.python.org/3/library/os.html#os.system
https://docs.python.org/3/library/subprocess.html#module-subprocess
