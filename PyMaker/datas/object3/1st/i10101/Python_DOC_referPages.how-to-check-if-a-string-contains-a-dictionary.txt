Natural Text
I want to recursively parse all values in a dict that are strings with ast.literal_eval(value) but not do that eval if the string doesn't contain a dict. I want this, because I have a string in a dict that is a dict in itself and I would like the value to be a dict. Best to give an exampleNow I don't want a do to ast.literal_eval(my_dict['c']) I want a generic solution where I can do convert_to_dict(my_dict)I wanted to write my own method, but I don't know how to check if a string contains a dict, and then ast.literal_eval will fail, hence the question.
Here is a proposition that handles recursion. As it was suggested in the comments, it tries to eval everything then check if the result is a dict, if it is we recurse, else we skip the value . I sligthly altered the initial dict to show that it hanldes recusion fine :Output:
You can check if you have a dict after using literal_eval and reassign:Just pass in the dict:You should also be aware that if you had certain other objects in the dict like datetime objects etc.. then literal_eval would fail so it really depends on what your dict can contain as to whether it will work or not.If you need a recursive approach, all you need is to call reassign on the new dict.And again just pass the dict:And if you want a new dict:Which will give you a new dict:You need to make sure to deepcopy objects or you won't get a true independent copy of the dict when you have nested object like  the list of lists above.
The general idea referenced in my above comment is to run thru the dictionary and try and evaluate. Store that in a local variable, and then check if that evaluated expression is a dictionary. If so, then reassign it to the passed input. If not, leave it alone. 
If you need to handle nested str defining dict, json.loads with an object_hook might work for you:That should recursively handle the case where the contained dicts might contain strs values that define subdicts. If you don't need to handle that case, you can omit the use of the object_hook, or replace json.loads entirely with ast.literal_eval.
The other answers were really good and lead me to the right solution, but the previous accepted answer had a bug. Here is my working solution:


Answer URL
https://docs.python.org/3/library/json.html#json.loads
