Natural Text
For example, I have some module(foo.py) with next code:And module bar.py with similiar code:I just can't understand why next happens:They are two mocked:<MagicMock name='get().content' id='4352254472'><MagicMock name='get().content' id='4352254472'>It is seemed to patch only foo.get_ip method due to with patch('foo.requests.get'), but it is not.I know that I can just get bar.get_fb calling out of with scope, but there are cases where I just run in context manager one method that calls many other, and I want to patch requests only in one module.Is there any way to solve this? Without changing imports in module
The two locations foo.requests.get and bar.requests.get refer to the same object, so mock it in one place and you mock it in the other.  Imagine how you might implement patch.  You have to find where the symbol is located and replace the symbol with the mock object.  On exit from the with context you will need to restore the original value of the symbol.  Something like (untested):So your problem is that the you are mocking the object in the request module, which you then are referring to from both foo and bar.Following @elethan's suggestion, you could mock the requests module in foo, and even provide side effects on the get method:A more direct solution is to vary your code so that foo and bar pull the reference to get directly into their name space.foo.py:bar.py:main.py:producing:Updated with a more complete explanation, and with the better solution (2016-10-15)Note: added wraps=requests.get to call the underlying function after side effect. 
Not to steal @Neapolitan's thunder, but another option would be to simply mock foo.requests instead of foo.requests.get:I think the reason why both methods get mocked in your case is that, since requests.get is not explicitly imported in foo.py, mock will have to look up the method in the requests module and mock it there, rather than mocking it in the requests object already imported into foo, so that when bar later imports requests and accesses requests.get it is geting the mocked version. However, if you patch foo.requests instead, you are just patching the module object already imported into foo, and the original requests module will not be affected.Although not particularly helpful for this particular problem, this article is very useful for understanding the subtleties of patch


Answer URL
https://docs.python.org/3/library/unittest.mock.html#where-to-patch
