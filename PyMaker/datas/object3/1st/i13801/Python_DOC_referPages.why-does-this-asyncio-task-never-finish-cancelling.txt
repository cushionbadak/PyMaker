Natural Text
If I run this on the python3 interpreter:I get the following result:Now if I run fut.cancel() I get True returned. But typing fut returns a representation of the task stating it is cancelling:And the task never actually cancels (fut.cancelled() never returns True)Why won't it cancel?
Calling task.cancel() only schedules the task to be cancelled on the next run of the event loop; it doesn't immediately cancel the task, or even guarantee that the task will be actually be cancelled when the event loop runs its next iteration. This is all described in the documentation:cancel() Request that this task cancel itself.This arranges for a CancelledError to be thrown into the wrapped  coroutine on the next cycle through the event loop. The coroutine then  has a chance to clean up or even deny the request using  try/except/finally.Unlike Future.cancel(), this does not guarantee that the task will be  cancelled: the exception might be caught and acted upon, delaying  cancellation of the task or preventing cancellation completely. The  task may also return a value or raise a different exception.Immediately after this method is called, cancelled() will not return  True (unless the task was already cancelled). A task will be marked as  cancelled when the wrapped coroutine terminates with a CancelledError  exception (even if cancel() was not called).In your case, you're never actually starting the event loop, so the task  never gets cancelled. You would need to call loop.run_until_complete(fut) (or loop.run_forever(), though that's not really the best choice for this particular case) for the task to actually end up getting cancelled.Also, for what it's worth, it's usually easier to test asyncio code using actual scripts, rather than the interpreter, since it tends to get tedious to have to constantly rewrite coroutines and start/stop the event loop.
With asyncio testing in the interpreter is tricky, because python needs to keep the event loop constantly polling its tasks.So a few pieces of advice to test asyncio are:Write and run scripts instead of using the interactive interpreterAdd a loop.run_forever() at the end of the script so all tasks get executed.An alternative is to run loop.run_until_complete(coro()) for each task you want to run.Have yield from in front of asyncio.sleep(n) so it can actually be run. The current code returns a generator and does nothing.


Answer URL
https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.cancel
