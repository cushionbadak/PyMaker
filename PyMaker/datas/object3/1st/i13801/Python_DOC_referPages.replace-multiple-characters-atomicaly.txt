Natural Text
I'm working on decrypting a substitution cipher (not Caesar/ROT) with frequency analysis and no specialized tools. Let's say I wanted to use this cipher dictionary which seems good enough after analysis:My code below has an obvious problem:Because it replaces every character one after the other, a character at a certain position gets replaced several times before the algorithm is done, instead of just once.(ie: first iteration the algorithm will replace all S with E, but then it reaches E in the dictionary and replaces all Es with W)Does Python have a convenient way of doing this operation in one shot? Or will I be forced to keep track of the positions that have already been changed myself?
For Python 3.x, You can use str.maketrans() (or string.maketrans() for Python 2.x) and str.translate() for this -For Python 2.x,


Answer URL
https://docs.python.org/3/library/stdtypes.html#str.maketrans
