Natural Text
I have a composite dictionary d that is built up from a set of component dictionaries, d1 and d2:The behavior I am trying to accomplish is for changes to the keys of d to automatically propagate to changes in d1 and d2. The above code does not behave this way, which can be verified by comparing the ids:The behavior I am looking for can be accomplished if my composite dictionary was only a composite of a single component and if I did not change keynames:Does python have a feature that enables a composite dictionary d, including different keynames, such that the keys point to the same point in memory, even if the keys have different names? 
This class will act like a ChainMap, except it'll respect your alternate key mapping where specified. It works in Python 2.7 and Python 3.3+.Note that when a key is in more than one dict, the value is taken from the dict that was passed in first; specifically, each mapping in cmwak.maps is checked in order until the key is found. Read up on ChainMap for the details; everything there applies to ChainMapWithAltKeys.
I believe something else may have caused the id of the values to change, maybe you did some other assignment to d dictionary before testing id , numbers in python are immutable, so two different numbers would not have the same id.When you do - d['altname_key1'] = d1['a'] - Python is pass by assignment, which means the reference of d1['a']'s reference is passed by value. Example -So what you are trying to achieve does work.But this given , I would like to advice against keeping multiple references to same mutable object, as this method can lead mysterious bugs, some code may wrongly update d dictionary, even though you did not want it to and it can cause the same changes to get reflected in d1. And it would be hard to debug the issues.Also, this method would break if you do an assignment on d , in that case, d dictionary's value would change, but d1 or d2 would not change. Example -You may want to reconsider what you are trying to design.Regarding Why you get the desired behavior when you do the following - It is because in the d is a reference to the d1 dictionary object, so they are basically pointing to the same dictionaries. And hence d['key1'] would always be d1['key1'] . You can do  the following to see that they are the same reference -And this again would not be recommended due to above said reasons.


Answer URL
https://docs.python.org/3/library/collections.html#chainmap-objects
https://docs.python.org/3/library/collections.html#chainmap-objects
