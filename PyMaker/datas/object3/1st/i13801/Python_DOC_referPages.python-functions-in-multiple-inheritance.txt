Natural Text
In the book Python in a Nutshell (2nd Edition) there is an example which usesold style classes to demonstrate how methods are resolved in classic resolution order andhow is it different with the new order. I tried the same example by rewriting the example in new style but the result is no different than what was obtained with old style classes. The python version I am using to run the example is 2.5.2. Below is the example: The call instance.amethod() prints Base1, but as per my understanding of the MRO with new style of classes the output should have been Base3. The call Derived.__mro__ prints:      (<class '__main__.Derived'>, <class '__main__.Base2'>, <class '__main__.Base1'>, <class '__main__.Base3'>, <type 'object'>)I am not sure if my understanding of MRO with new style classes is incorrect or that I am doing a silly mistake which I am not able to detect. Please help me in better understanding of MRO.
The crucial difference between resolution order for legacy vs new-style classes comes when the same ancestor class occurs more than once in the "naive", depth-first approach -- e.g., consider a "diamond inheritance" case:here, legacy-style, the resolution order is D - B - A - C - A : so when looking up D.x, A is the first base in resolution order to solve it, thereby hiding the definition in C.  While:here, new-style, the order is:with A forced to come in resolution order only once and after all of its subclasses, so that overrides (i.e., C's override of member x) actually work sensibly.It's one of the reasons that old-style classes should be avoided: multiple inheritance with "diamond-like" patterns just doesn't work sensibly with them, while it does with new-style.
Python's method resolution order is actually more complex than just understanding the diamond pattern.  To really understand it, take a look at C3 linearization.  I've found it really helps to use print statements when extending methods to track the order.  For example, what do you think the output of this pattern would be? (Note: the 'X' is suppose to be two crossing edges, not a node and ^ signifies methods that call super())Did you get A B D C E F G?After a lot of trial an error, I came up with an informal graph theory interpretation of C3 linearization as follows:  (Someone please let me know if this is wrong.)Consider this example:
The result you get is correct. Try changing base class of Base3 to Base1 and compare with the same hierarchy for classic classes:Now it outputs:Read this explanation for more information.
You're seeing that behavior because method resolution is depth-first, not breadth-first.  Dervied's inheritance looks likeSo instance.amethod()Checks Base2, doesn't find amethod.Sees that Base2 has inherited from Base1, and checks Base1. Base1 has a amethod, so it gets called.This is reflected in Derived.__mro__.  Simply iterate over Derived.__mro__ and stop when you find the method being looked for.


Answer URL
https://docs.python.org/3/library/functions.html#super
