Natural Text
I have a somewhat intricate project setup consisting of several components that work together. Each component is a separate Python project that is hosted as a uWSGI application behind an Nginx proxy. The components interact with each other and with the outside world through the proxy.I noticed myself about to cut-and-paste some code from one component to another, as they perform similar functions, but interact with different services. Obviously, I want to avoid this, so I am going to pull out common functionality and put it into a separate 'library' project, to be referenced by the different components.I am running these apps in a virtual environment (using virtualenv), so it should theoretically be easy to simple drop the library project into .env/includes.However, I have a bit of a strange setup. First of all, I am running the project from /var/www (i.e. uWSGI hosts the apps from here), but the projects actually are present in another source controlled directory. For various reasons, I don't want to move them, so I created symlinks for the project directories in /var/www. This works fine. However, now I have a potential problem, namely, where do I put the library project (which is currently in the same directory as the other components), which I also want to symlink?Do I symlink it in .env/includes? And if so, how should I reference the library from my other components? Do I reference it from sys.path or as a sibling directory? Is Nginx/uWSGI with virtualenv following the symlinks and taking into account the actual directory or is it blindly assuming that everything is in /var/www?I have not tried either approach because there seems to be a massive scope for problems, so I wanted to get some input first. Needless to say, I am more than a little confused.
I solved the problem quite easily by symlinking the package of interest in .env/lib/python2.7/site-packages. I originally tried to symlink the entire project folder but that didn't work as it couldn't find the package.It seems that my uWSGI/Nginx just follows the virtualenv's version of pythonpath, so whatever I configure there is used.It will be a bit of a pain to have to remember to symlink every package, but at least I only have to do it once for each package.I'm using PyDev, and it was masking the issue because I was using the default Python interpreter, not the one in virtualenv. Once I changed that, it was easier to solve.


Answer URL
https://docs.python.org/3/tutorial/modules.html#the-module-search-path
