Natural Text
I've started to use the python descriptor protocol more extensively in the code I've been writing.  Typically, the default python lookup magic is what I want to happen, but sometimes I'm finding I want to get the descriptor object itself instead the results of its __get__ method. Wanting to know the type of the descriptor, or access state stored in the descriptor, or somesuch thing.I wrote the code below to walk the namespaces in what I believe is the correct ordering, and return the attribute raw regardless of whether it is a descriptor or not. I'm surprised though that I can't find a built-in function or something in the standard library to do this -- I figure it has to be there and I just haven't noticed it or googled for the right search term.Is there functionality somewhere in the python distribution that already does this (or something similar)?Thanks!Edit Wed, Oct 28, 2009.Denis's answer gave me a convention to use in my descriptor classes to get the descriptor objects themselves. But, I had an entire class hierarchy of descriptor classes, and I didn't want to begin every __get__ function with a boilerplateTo avoid this, I made the root of the descriptor class tree inherit from the following:
Most descriptors do their job when accessed as instance attribute only. So it's convenient to return itself when it's accessed for class:This allows you to get descriptor itself:Note, that this works for (most?) built-in descriptors too:Accessing descriptor could be useful when you need to extent it in subclass, but there is a better way to do this.
The inspect library provides a function to retrieve an attribute without any descriptor magic: inspect.getattr_static.Documentation: https://docs.python.org/3/library/inspect.html#fetching-attributes-statically(This is an old question, but I keep coming across it when trying to remember how to do this, so I'm posting this answer so I can find it again!)
The above method Is a great method whenever you control the code of the property, but there are some cases, such as when the property is part of a library controlled by someone else, where another approach is useful.  This alternative approach can also be useful in other situations such as implementing object mapping, walking a name-space as described in the question, or other specialised libraries.Consider a class with a simple property:When accessed from the container objects class dict, the 'descriptor magic' is bypassed.  Note also that if we assign the property to a new class variable, it behaves just like the original with 'descriptor magic', but if assigned to an instance variable, the property behaves as any normal object and also bypasses 'descriptor magic'.
Let's say we want to get the descriptor for obj.prop where type(obj) is C.C.prop usually works because the descriptor usually returns itself when accessed via C (i.e., bound to C). But C.prop may trigger a descriptor in its metaclass. If prop were not present in obj, obj.prop would raise AttributeError while C.prop might not. So it's better to use  inspect.getattr_static(obj, 'prop').If you are not satisfied with that, here's a CPython-specific method (from _PyObject_GenericGetAttrWithDict in Objects/object.c):type_lookup(type(obj), 'prop') returns the descriptor in the same way when CPython uses it at obj.prop if obj is a usual object (not class, for example).


Answer URL
https://docs.python.org/3/library/inspect.html#fetching-attributes-statically
