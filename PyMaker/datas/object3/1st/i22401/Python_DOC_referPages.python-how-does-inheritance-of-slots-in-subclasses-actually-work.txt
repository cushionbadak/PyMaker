Natural Text
In the Python data model reference section on slots there is a list of notes on using __slots__.  I am thoroughly confused by the 1st and 6th items, because they seem to be contradicting each other. First item:When inheriting from a class without__slots__, the __dict__ attributeof that class will always beaccessible, so a __slots__definition in the subclass ismeaningless.Sixth item:The action of a __slots__declaration is limited to the classwhere it is defined. As a result,subclasses will have a __dict__unless they also define __slots__(which must only contain names of anyadditional slots).It seems to me these items could be better worded or shown through code, but I have been trying to wrap my head around this and am still coming up confused. I do understand how __slots__ are supposed to be used, and I am trying to get a better grasp on how they work.The Question:Can someone please explain to me in plain language what the conditions are for inheritance of slots when subclassing? (Simple code examples would be helpful but not necessary.)
As others have mentioned, the sole reason for defining __slots__ is to save some memory, when you have simple objects with a predefined set of attributes and don't want each to carry around a dictionary.  This is meaningful only for classes of which you plan to have many instances, of course.The savings may not be immediately obvious -- consider...:From this, it would seem the with-slots size is larger than the no-slots size!  But that's a mistake, because sys.getsizeof doesn't consider "object contents" such as the dictionary:Since the dict alone takes 140 bytes, clearly the "32 bytes" object n is alleged to take are not considering all that's involved in each instance.  You can do a better job with third-party extensions such as pympler:This shows much more clearly the memory footprint that's saved by __slots__: for a simple object such as this case, it's a bit less than 200 bytes, almost 2/3 of the object's overall footprint.  Now, since these days a megabyte more or less doesn't really matter all that much to most applications, this also tells you that __slots__ is not worth the bother if you're going to have just a few thousand instances around at a time -- however, for millions of instances, it sure does make a very important difference. You can also get a microscopic speedup (partly due to better cache use for small objects with __slots__):but this is somewhat dependent on Python version (these are the numbers I measure repeatably with 2.5; with 2.6, I see a larger relative advantage to __slots__ for setting an attribute, but none at all, indeed a tiny disadvantage, for getting it).Now, regarding inheritance: for an instance to be dict-less, all classes up its inheritance chain must also have dict-less instances.  Classes with dict-less instances are those which define __slots__, plus most built-in types (built-in types whose instances have dicts are those on whose instances you can set arbitrary attributes, such as functions). Overlaps in slot names are not forbidden, but they're useless and waste some memory, since slots are inherited:as you see, you can set attribute a on an AB instance -- AB itself only defines slot b, but it inherits slot a from A.  Repeating the inherited slot isn't forbidden:but does waste a little memory:so there's really no reason to do it.
First ItemSixth ItemYou probably won't need to use __slots__ in the near future. It's only intended to save memory at the cost of some flexibility. Unless you have tens of thousands of objects it won't matter.
Python: How does inheritance of __slots__ in subclasses actually work?I am thoroughly confused by the 1st and 6th items, because they seem to be contradicting each other. Those items don't actually contradict each other. The first regards subclasses of classes that don't implement __slots__, the second regards subclasses of classes that do implement __slots__.Subclasses of classes that don't implement __slots__I am increasingly aware that as great as the Python docs are (rightly) reputed to be, they are not perfect, especially regarding the less used features of the language. I would alter the docs as follows:When inheriting from a class without __slots__, the __dict__ attribute  of that class will always be accessible, so a __slots__ definition in  the subclass is meaningless .__slots__ is still meaningful for such a class. It documents the expected names of attributes of the class. It also creates slots for those attributes - they will get the faster lookups and use less space. It just allows for other attributes, which will be assigned to the __dict__.This change has been accepted and is now in the latest documentation.Here's an example:Bar not only has the slots it declares, it also has Foo's slots - which include __dict__:Subclasses of classes that do implement __slots__The action of a __slots__ declaration is limited to the class where it  is defined. As a result, subclasses will have a __dict__ unless they  also define __slots__ (which must only contain names of any additional  slots).Well that's not quite right either. The action of a __slots__ declaration is not entirely limited to the class where it is defined. They can have implications for multiple inheritance, for example.I would change that to:For classes in an inheritance tree that defines __slots__, subclasses will have a __dict__ unless they  also define __slots__ (which must only contain names of any additional  slots).I have actually updated it to read:The action of a __slots__ declaration is not limited to the class  where it is defined. __slots__ declared in parents are available in  child classes. However, child subclasses will get a __dict__ and  __weakref__ unless they also define __slots__ (which should only contain names of any additional slots).Here's an example:And we see that a subclass of a slotted class gets to use the slots:(For more on __slots__, see my answer here.)
From the answer you linked:The proper use of __slots__ is to save space in objects. Instead of having a dynamic dict..."When inheriting from a class without __slots__, the __dict__ attribute of that class will always be accessible", so adding your own __slots__ cannot prevent objects from having a __dict__, and cannot save space.The bit about __slots__ not being inherited is a little obtuse.  Remember that it's a magic attribute and doesn't behave like other attributes, then re-read that as saying this magic slots behavior isn't inherited.  (That's really all there is to it.)
My understanding is as follows:class X has no __dict__ <-------> class X and its superclasses all have __slots__ specifiedin this case, the actual slots of the class are comprised from the union of __slots__ declarations  for X and its superclasses; the behavior is undefined (and will become an error) if this union is not disjoint


Answer URL
https://docs.python.org/3/reference/datamodel.html#notes-on-using-slots
