Natural Text
This question already has an answer here:Using global variables in a function                    18 answers                Is there a way to set up a global variable inside of a module? When I tried to do it the most obvious way as appears below, the Python interpreter said the variable __DBNAME__ did not exist.And after importing the module in a different fileAnd the traceback was: UnboundLocalError: local variable '__DBNAME__' referenced before assignmentAny ideas? I'm trying to set up a singleton by using a module, as per this fellow's recommendation.
Here is what is going on.First, the only global variables Python really has are module-scoped variables.  You cannot make a variable that is truly global; all you can do is make a variable in a particular scope.  (If you make a variable inside the Python interpreter, and then import other modules, your variable is in the outermost scope and thus global within your Python session.)All you have to do to make a module-global variable is just assign to a name.Imagine a file called foo.py, containing this single line:Now imagine you import it.However, let's suppose you want to use one of your module-scope variables as a global inside a function, as in your example.  Python's default is to assume that function variables are local.  You simply add a global declaration in your function, before you try to use the global.By the way, for this example, the simple if not __DBNAME__ test is adequate, because any string value other than an empty string will evaluate true, so any actual database name will evaluate true.  But for variables that might contain a number value that might be 0, you can't just say if not variablename; in that case, you should explicitly test for None using the is operator.  I modified the example to add an explicit None test.  The explicit test for None is never wrong, so I default to using it.Finally, as others have noted on this page, two leading underscores signals to Python that you want the variable to be "private" to the module.  If you ever do an import * from mymodule, Python will not import names with two leading underscores into your name space.  But if you just do a simple import mymodule and then say dir(mymodule) you will see the "private" variables in the list, and if you explicitly refer to mymodule.__DBNAME__ Python won't care, it will just let you refer to it.  The double leading underscores are a major clue to users of your module that you don't want them rebinding that name to some value of their own.It is considered best practice in Python not to do import *, but to minimize the coupling and maximize explicitness by either using mymodule.something or by explicitly doing an import like from mymodule import something.EDIT: If, for some reason, you need to do something like this in a very old version of Python that doesn't have the global keyword, there is an easy workaround.  Instead of setting a module global variable directly, use a mutable type at the module global level, and store your values inside it.In your functions, the global variable name will be read-only; you won't be able to rebind the actual global variable name.  (If you assign to that variable name inside your function it will only affect the local variable name inside the function.)  But you can use that local variable name to access the actual global object, and store data inside it.You can use a list but your code will be ugly:A dict is better.  But the most convenient is a class instance, and you can just use a trivial class:(You don't really need to capitalize the database name variable.)I like the syntactic sugar of just using __m.dbname rather than __m["DBNAME"]; it seems the most convenient solution in my opinion.  But the dict solution works fine also.With a dict you can use any hashable value as a key, but when you are happy with names that are valid identifiers, you can use a trivial class like Box in the above.
Explicit access to module level variables by accessing them explicity on the moduleIn short: The technique described here is the same as in steveha's answer, except, that no artificial helper object is created to explicitly scope variables. Instead the module object itself is given a variable pointer, and therefore provides explicit scoping upon access from everywhere. (like assignments in local function scope).Think of it like self for the current module instead of the current instance !As modules are cached and therefore import only once, you can import db.py as often on as many clients as you want, manipulating the same, universal state:As an additional bonus I find it quite pythonic overall as it nicely fits Pythons policy of Explicit is better than implicit.
Steveha's answer was helpful to me, but omits an important point (one that I think wisty was getting at). The global keyword is not necessary if you only access but do not assign the variable in the function.If you assign the variable without the global keyword then Python creates a new local var -- the module variable's value will now be hidden inside the function.  Use the global keyword to assign the module var inside a function.Pylint 1.3.1 under Python 2.7 enforces NOT using global if you don't assign the var.
For this, you need to declare the variable as global. However, a global variable is also accessible from outside the module by using module_name.var_name. Add this as the first line of your module:
You are falling for a subtle quirk. You cannot re-assign module-level variables inside a python function. I think this is there to stop people re-assigning stuff inside a function by accident. You can access the module namespace, you just shouldn't try to re-assign. If your function assigns something, it automatically becomes a function variable - and python won't look in the module namespace.You can do:but you cannot re-assign __DB_NAME__ inside a function. One workaround:Note, I'm not re-assigning __DB_NAME__, I'm just modifying its contents.


Answer URL
https://docs.python.org/3/library/types.html#additional-utility-classes-and-functions
