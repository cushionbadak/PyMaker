Natural Text
Haven't Python iterators got a hasNext method?
No, there is no such method. The end of iteration is indicated by an exception. See the documentation.
There's an alternative to the StopIteration by using next(iterator, default_value).For exapmle:So you can detect for None or other pre-specified value for end of the iterator if you don't want the exception way.
If you really need a has-next functionality (because you're just faithfully transcribing an algorithm from a reference implementation in Java, say, or because you're writing a prototype that will need to be easily transcribed to Java when it's finished), it's easy to obtain it with a little wrapper class.  For example:now something likeemitsas required.Note that the use of next(sel.it) as a built-in requires Python 2.6 or better; if you're using an older version of Python, use self.it.next() instead (and similarly for next(x) in the example usage). [[You might reasonably think this note is redundant, since Python 2.6 has been around for over a year now -- but more often than not when I use Python 2.6 features in a response, some commenter or other feels duty-bound to point out that they are 2.6 features, thus I'm trying to forestall such comments for once;-)]]
In addition to all the mentions of StopIteration, the Python "for" loop simply does what you want:
Try the __length_hint__() method from any iterator object:
hasNext somewhat translates to the StopIteration exception, e.g.:StopIteration docs: http://docs.python.org/library/exceptions.html#exceptions.StopIterationSome article about iterators and generator in python: http://www.ibm.com/developerworks/library/l-pycon.html
No. The most similar concept is most likely a StopIteration exception. 
You can tee the iterator using, itertools.tee, and check for StopIteration on the teed iterator.
I believe python just has next() and according to the doc, it throws an exception is there are no more elements.http://docs.python.org/library/stdtypes.html#iterator-types
The use case that lead me to search for this is the followingwhere hasnext() is available, one could dowhich to me is cleaner.  Obviously you can work around issues by defining utility classes, but what then happens is you have a proliferation of twenty-odd different almost-equivalent workarounds each with their quirks, and if you wish to reuse code that uses different workarounds, you have to either have multiple near-equivalent in your single application, or go around picking through and rewriting code to use the same approach.  The 'do it once and do it well' maxim fails badly.Furthermore, the iterator itself needs to have an internal 'hasnext' check to run to see if it needs to raise an exception.  This internal check is then hidden so that it needs to be tested by trying to get an item, catching the exception and running the handler if thrown.  This is unnecessary hiding IMO.
good approach for such question/problems is check what we have in dir(object/method/iterator/type/class/ ...)you will see that dir(iterator) return __length_hint__and iterator.__length_hint__() is positive until end of the iteration.that's it.
Suggested way is StopIteration.Please see Fibonacci example from tutorialspoint
The way I solved my problem is to keep the count of the number of objects iterated over, so far. I wanted to iterate over a set using calls to an instance method. Since I knew the length of the set, and the number of items counted so far, I effectively had an hasNext method.A simple version of my code:Of course, the example is a toy one, but you get the idea. This won't work in cases where there is no way to get the length of the iterable, like a generator etc.


Answer URL
https://docs.python.org/3/library/itertools.html?highlight=itertools#itertools.cycle
