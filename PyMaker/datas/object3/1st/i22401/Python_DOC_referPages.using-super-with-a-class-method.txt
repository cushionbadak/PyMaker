Natural Text
I'm trying to learn the super() function in Python.I thought I had a grasp of it until I came over this example (2.6) and found myself stuck.http://www.cafepy.com/article/python_attributes_and_methods/python_attributes_and_methods.html#super-with-classmethod-exampleIt wasn't what I expected when I read this line right before the example:If we're using a class method, we don't have an instance to call super with. Fortunately for us, super works even with a type as the second argument. --- The type can be passed directly to super as shown below. Which is exactly what Python tells me is not possible by saying that do_something() should be called with an instance of B.
Sometimes texts have to be read more for the flavor of the idea rather than for the details. This is one of those cases.In the linked page, Examples 2.5, 2.6 and 2.7 should all use one method, do_your_stuff. (That is, do_something should be changed to do_your_stuff.) In addition, as Ned Deily pointed out, A.do_your_stuff has to be a class method.super(B, cls).do_your_stuffreturns a bound method (see footnote 2).  Since  cls was passed as the second argument to super(), it is cls that gets bound to the returned method. In other words, cls gets passed as the first argument to the method do_you_stuff().So super(B, cls).do_your_stuff() causes A's do_your_stuff method to becalled with cls passed as the first argument. In order for that to work, A'sdo_your_stuff has to be a class method. The linked page doesn't mention that,but it's true.PS. do_something = classmethod(do_something) is the old way of making a classmethod.The new(er) way is to use the @classmethod decorator.Note that super(B, cls) can not be replaced by super(cls, cls). Doing so could lead to infinite loops. For example,will raise RuntimeError: maximum recursion depth exceeded while calling a Python object. If cls is C, then super(cls, cls) searches C.mro() for the class that comes after C.Since that class is B, when cls is C, super(cls, cls).do_your_stuff() always calls B.do_your_stuff. Since super(cls, cls).do_your_stuff() is called inside B.do_your_stuff, you end up calling B.do_your_stuff in an infinite loop.In Python3, the 0-argument form of super was added so super(B, cls) could be replaced by super(), and Python3 will figure out from context that super() in the definition of class B should be equivalent to super(B, cls).But in no circumstance is super(cls, cls) (or for similar reasons, super(type(self), self)) ever correct.
In Python 3, you can skip specifying arguments for super,
I've updated the article to make it a bit clearer: Python Attributes and Methods # SuperYour example using classmethod above shows what a class method is - it passes the class itself instead of the instance as the first parameter. But you don't even need an instance to call the method, for e.g.:
The example from the web page seems to work as published.  Did you create a do_something method for the superclass as well but not make it into a classmethod?  Something like this will give you that error:
I think I've understood the point now thanks to this beatiful site and lovely community.If you don't mind please correct me if I'm wrong on classmethods (which I am now trying to understand fully):I hope this illustration shows ..


Answer URL
https://docs.python.org/3/library/functions.html#super
