Natural Text
Is it possible to add a documentation string to a namedtuple in an easy manner?I triedbut that doesn't cut it. Is it possible to do in some other way?
You can achieve this by creating a simple, empty wrapper class around the returned value from namedtuple.  Contents of a file I created (nt.py):Then in the Python REPL:Or you could do:If you don't like doing that by hand every time, it's trivial to write a sort-of factory function to do this:which outputs:
Came across this old question via Google while wondering the same thing.Just wanted to point out that you can tidy it up even more by calling namedtuple() right from the class declaration:
In Python 3, no wrapper is needed, as the __doc__ attributes of types is writable.This closely corresponds to a standard class definition, where the docstring follows the header.This does not work in Python 2.AttributeError: attribute '__doc__' of 'type' objects is not writable. 
Is it possible to add a documentation string to a namedtuple in an easy manner?Python 3In Python 3, you can easily alter the doc on your namedtuple:Which allows us to view the intent for them when we call help on them:This is really straightforward compared to the difficulties we have accomplishing the same thing in Python 2.Python 2In Python 2, you'll need tosubclass the namedtuple, and declare __slots__ == () Declaring __slots__ is an important part that the other answers here miss . If you don't declare __slots__ - you could add mutable ad-hoc attributes to the instances, introducing bugs.And now:Each instance will create a separate __dict__ when __dict__ is accessed (the lack of __slots__ won't otherwise impede the functionality, but the lightweightness of the tuple, immutability, and declared attributes are all important features of namedtuples). You'll also want a __repr__, if you want what is echoed on the command line to give you an equivalent object:a __repr__ like this is needed if you create the base namedtuple with a different name (like we did above with the name string argument, 'NTBase'):To test the repr, instantiate, then test for equality of a pass to eval(repr(instance))Example from the documentationThe docs also give such an example, regarding __slots__ - I'm adding my own docstring to it:...The subclass shown above sets __slots__ to an empty tuple. This helps  keep memory requirements low by preventing the creation of instance  dictionaries.This demonstrates in-place usage (like another answer here suggests), but note that the in-place usage may become confusing when you look at the method resolution order, if you're debugging, which is why I originally suggested using Base as a suffix for the base namedtuple:To prevent creation of a __dict__ when subclassing from a class that uses it, you must also declare it in the subclass. See also this answer for more caveats on using __slots__.
Since Python 3.5, docstrings for namedtuple objects can be updated.From the whatsnew:
In Python 3.6+ you can use:
No need to use a wrapper class as suggested by the accepted answer. Simply literally add a docstring:This results in: (example using ipython3):Voilà!
You could concoct your own version of the namedtuple factory function by Raymond Hettinger and add an optional docstring argument.  However it would be easier -- and arguably better -- to just define your own factory function using the same basic technique as in the recipe.  Either way, you'll end up with something reusable.
I created this function to quickly create a named tuple and document the tuple along with each of its parameters:You can then create a new named tuple:Then instantiate the described named tuple with your own data, ie.When executing help(MyTuple) via the python3 command line the following is shown:Alternatively, you can also specify the parameter's type via:
No, you can only add doc strings to modules, classes and function (including methods)


Answer URL
https://docs.python.org/3/whatsnew/3.5.html#collections
https://docs.python.org/3/library/typing.html#typing.NamedTuple
