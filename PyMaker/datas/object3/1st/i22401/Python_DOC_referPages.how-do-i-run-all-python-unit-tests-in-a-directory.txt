Natural Text
I have a directory that contains my Python unit tests. Each unit test module is of the form test_*.py. I am attempting to make a file called all_test.py that will, you guessed it, run all files in the aforementioned test form and return the result. I have tried two methods so far; both have failed. I will show the two methods, and I hope someone out there knows how to actually do this correctly.For my first valiant attempt, I thought "If I just import all my testing modules in the file, and then call this unittest.main() doodad, it will work, right?" Well, turns out I was wrong.This did not work, the result I got was:For my second try, I though, ok, maybe I will try to do this whole testing thing in a more "manual" fashion. So I attempted to do that below:This also did not work, but it seems so close!I seem to have a suite of some sort, and I can execute the result. I am a little concerned about the fact that it says I have only run=1, seems like that should be run=2, but it is progress. But how do I pass and display the result to main? Or how do I basically get it working so I can just run this file, and in doing so, run all the unit tests in this directory?
You could use a test runner that would do this for you.  nose is very good for example.  When run, it will find tests in the current tree and run them.Updated:Here's some code from my pre-nose days.  You probably don't want the explicit list of module names, but maybe the rest will be useful to you.
With Python 2.7 and higher you don't have to write new code or use third-party tools to do this; recursive test execution via the command line is built-in.You can read more in the python 2.7or python 3.x unittest documentation.
This is now possible directly from unittest: unittest.TestLoader.discover.
Well by studying the code above a bit (specifically using TextTestRunner and defaultTestLoader), I was able to get pretty close. Eventually I fixed my code by also just passing all test suites to a single suites constructor, rather than adding them "manually", which fixed my other problems. So here is my solution.Yeah, it is probably easier to just use nose than to do this, but that is besides the point. 
In python 3, if you're using unittest.TestCase:You must have an empty (or otherwise) __init__.py file in your test directory (must be named test/)Your test files inside test/ match the pattern test_*.py. They can be inside a subdirectory under test/, and those subdirs can be named as anything.Then, you can run all the tests with:Done! A solution less than 100 lines. Hopefully another python beginner saves time by finding this. 
If you want to run all the tests from various test case classes and you're happy to specify them explicitly then you can do it like this: where uclid is my project and TestSymbols and TestPatterns are subclasses of TestCase.
I have used the discover method and an overloading of load_tests to achieve this result in a (minimal, I think) number lines of code:Execution on fives something like
I tried various approaches but all seem flawed or I have to makeup some code, that's annoying.   But there's a convinient way under linux, that is simply to find every test through certain pattern and then invoke them one by one.and most importantly, it definitely works.
In case of a packaged library or application, you don't want to do it. setuptools will do it for you. To use this command, your projectâ€™s tests must be wrapped in a unittest test suite by either a function, a TestCase class or method, or a module or package containing TestCase classes. If the named suite is a module, and the module has an additional_tests() function, it is called and the result (which must be a unittest.TestSuite) is added to the tests to be run. If the named suite is a package, any submodules and subpackages are recursively added to the overall test suite.Just tell it where your root test package is, like:And run python setup.py test.File-based discovery may be problematic in Python 3, unless you avoid relative imports in your test suite, because discover uses file import. Even though it supports optional top_level_dir, but I had some infinite recursion errors. So a simple solution for a non-packaged code is to put the following in __init__.py of your test package (see load_tests Protocol).
I use PyDev/LiClipse and haven't really figured out how to run all tests at once from the GUI. (edit: you right click the root test folder and choose Run as -> Python unit-testThis is my current workaround:I put this code in a module called all in my test directory. If I run this module as a unittest from LiClipse then all tests are run. If I ask to only repeat specific or failed tests then only those tests are run. It doesn't interfere with my commandline test runner either (nosetests) -- it's ignored.You may need to change the arguments to discover based on your project setup.
Based on the answer of Stephen Cagle I added support for nested test modules.The code searches all subdirectories of . for *Tests.py files which are then loaded. It expects each *Tests.py to contain a single class *Tests(unittest.TestCase) which is loaded in turn and executed one after another.This works with arbitrary deep nesting of directories/modules, but each directory in between needs to contain an empty __init__.py file at least. This allows the test to load the nested modules by replacing slashes (or backslashes) by dots (see replace_slash_by_dot).
This BASH script will execute the python unittest test directory from ANYWHERE in the file system, no matter what working directory you are in: its working directory always be where that test directory is located.ALL TESTS, independent $PWDunittest Python module is sensitive to your current directory, unless you tell it where (using discover -s option).This is useful when staying in the ./src or ./example working directory and you need a quick overall unit test:SELECTED TESTS, independent $PWDI name this utility file: runone.py and use it like this:No need for a test/__init__.py file to burden your package/memory-overhead during production.
Because Test discovery seems to be a complete subject, there is some dedicated framework to test discovery : nosePy.TestMore reading here : https://wiki.python.org/moin/PythonTestingToolsTaxonomy
Here is my approach by creating a wrapper to run tests from the command line:For sake of simplicity, please excuse my non-PEP8 coding standards.Then you can create BaseTest class for common components for all your tests, so each of your test would simply look like:To run, you simply specifying tests as part of the command line arguments, e.g.:


Answer URL
https://docs.python.org/3/library/unittest.html#unittest.TestLoader.discover
https://docs.python.org/3/library/unittest.html#load-tests-protocol
