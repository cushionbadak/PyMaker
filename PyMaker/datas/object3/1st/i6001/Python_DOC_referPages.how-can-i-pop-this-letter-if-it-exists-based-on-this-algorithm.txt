Natural Text
I'm trying to pop any letters given by the user, for example if they give you a keyword "ROSES" then these letters should be popped out of the list.Note: I have a lot more explanation after the SOURCE CODE SOURCE CODESAMPLE INPUT Let's say keyword is "Roses"this what it gives me a list of the following ['A', 'C', 'E', 'G', 'I', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']But that's wrong It should of just removed the characters that existed in the keyword given by the user, like the word "Roses" each letter should of been removed and not in the list being popped. as you can see in the list the letters "B","D","F","H",etc were gone. What I'm trying to do is pop the index of the alphabet letters that the keyword exists.this is what should of happened.["A","B","C","D","F","G","H","I","J","K","L","M","N","P","Q","T","U","V","W","X","Y","Z"]The letters of the keyword "ROSES" were deleted of the list
There is some shortcomings in your code here is an implementation that works:ExplanationsYou can iterate on a string, no need to cast it as a listUse remove since you can use the str type directlyYou need to .upper() the input because you want to remove A if the user input aNote that I did not handle encrypted_message since it is unused at the moment.Also, as some comments says you could use a set instead of a list since lookups are faster for sets.EDITThis is a new implementation with the handling of your encrypted_message. This will keep the order of the alphabet after the input of the user. Also, if you're wondering why there's no duplicate, you will be appending only if letter is in alphabet which means the second time it won't be in alphabet and therefore not added to your encrypted_message.
you can directly check with input keyiterate all the letters in data, and check whether or not the letter in the input_key, if yes discard it
You can do something like this....


Try this:Explanation:When checking for (in)existence, it's better to use set. https://docs.python.org/3/tutorial/datastructures.html#setsInstead of iterating over it N times (N = number of input characters), you hash the character N times and check if there's already something at the result hash or not.If you check the speed, try with "WXYZZZYW" and you'll see that it'll be a lot slower than if it were "ABCDDDCA" with the list way. With set, it will be always the same time.The rest is pretty trivial. Casting to lowercase (or uppercase), to make sure it hits a match, case insensitive. And then, we end by doing a set difference (-). It's all the items that are in the first set but not in the second one.


Answer URL
https://docs.python.org/3/tutorial/datastructures.html#sets
https://docs.python.org/3/tutorial/datastructures.html#sets
https://docs.python.org/3/library/string.html#string.ascii_uppercase
