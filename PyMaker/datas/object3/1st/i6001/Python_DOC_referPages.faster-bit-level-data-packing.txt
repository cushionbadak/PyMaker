Natural Text
An 256*64 pixel OLED display connected to Raspberry Pi (Zero W) has 4 bit greyscale pixel data packed into a byte (i.e. two pixels per byte), so 8192 bytes in total. E.g. the bytesbecomeConverting these bytes either obtained from a Pillow (PIL) Image or a cairo ImageSurface takes up to 0.9 s when naively iterating the pixel data, depending on color depth.Combining every two bytes from a Pillow "L" (monochrome 8 bit) Image:This (omitting state and saving float/integer conversion) brings it down to about half (0.2 s):Basically the first applied to an RGB24 (32 bit!) cairo ImageSurface, though with crude greyscale conversion:takes about twice as long (0.9 s vs 0.4 s).The struct module does not support nibbles (half-bytes).bitstring does allow packing nibbles: But there does not seem to be a method to unpack this into a list of integers quickly -- this takes 30 seconds!:Does Python 3 have the means to do this efficiently or do I need an alternative?External packer wrapped with ctypes? The same, but simpler, with Cython (I have not yet looked into these)? Looks very good, see my answer.
Down to 130 ms from 200 ms by just wrapping the loop in a functionDown to 35 ms by Cythonizing the same codeDown to 16 ms with typeNot much of a difference with a "simplified" loopMaybe a tiny bit faster even (15 ms)Here's with timeitThis already meets my requirements, but I guess there may be further optimization possible with the input/output iterables (-> unsigned int array?) or accessing the input data with a wider data type (Raspbian is 32 bit, BCM2835 is ARM1176JZF-S single-core).Or with parallelism on the GPU or the multi-core Raspberry Pis.A crude comparison with the same loop in C (ideone):It's apparently 100 times faster:Eliminating the the shifts/division may be another slight optimization (I have not checked the resulting C, nor the binary):results in 


Answer URL
https://docs.python.org/3/library/stdtypes.html#bytes
https://docs.python.org/3/library/timeit.html
