Natural Text
I have to use functional programming to implement the following function takes in a list of numbers from 0 to 9. The goal is to find the five consecutive elements of the list that have the greatest product. The function should return tuple of the index of the greatest product and the value of the greatest product without using the max function.I can easily implement this without functional programming but I am having trouble implementing it without any loops.This is my approach so far but the part that I am stuck on is how to loop through the array to find those consecutive five numbers without loops. I am trying to use map to do that but I don't think it is correct. Is it possible to incorporate enumerate in any way? Any help is appreciated. 
This doesn't have any explicit loops or call the max function. The function assumes that there're at least five elements in the input list and outputs a tuple (start_index, max_product).win = zip(l, l[1:], l[2:], l[3:], l[4:]) creates a sliding window iterator of size 5 over the input list. products = map(partial(reduce, operator.mul), win) is an iterator calling partial(reduce, operator.mul) (translates to reduce(operator.mul, ...)) on every element of win. reduce(lambda x, y: x if x[1] > y[1] else y, enumerate(products)) adds a counter to products and returns the index-value pair with the highest value.If you need a more general version and/or the input list is large you'd use itertools.islice:The code above uses a generator expression which is a loop, technically. A pure functional version of that might look like
pdts contains all the possible 5 tuple products, and then using reduce to mimic the max function, we find the maximum among the products.
You could do the following:For each start index in range(0, len(L) - 5)Map the index to the tuple of start and the product of items L[start:start + 5]Reduce the tuples to the one that has the highest productGet the first value of the resulting tuple = the start index of the 5 elements that have the highest productReturn the slice L[result:result + 5]This algorithm could be further improved to avoid re-calculating sub-products, but use a "rolling product", that is updated as you reduce from left to right, dividing by the element that was dropped, and multiplying by the new element that was added.
Here is a Haskell solution, which is purely functional:Here is what it does:Starting in the last line, it computes the consecutive products from that list.tails xs gives all the subsets starting with different starting values:From these tails we only take those that are at least 5 elements long.Then we zip them with natural numbers such that we have the starting index associated with it.From each of the subsets we take the first five elements.These five elements are passed to the multiply function. There those are reduced to a single number, the product.After that we go back to the last line, we sort the list by the product value descending.From the resulting list we only take the first element.And then we print the result, which is (5,450) for my input data.
This solution uses reduce to calculate a 5-value product, list comprehension for generating all of those products, tuple creation for having the index to go with each, reduce again to get the best tuple.An if else operator is used to catch the case when there are no 5 values in the input. Output for the example call is:
A Pure Python Solution using recursion First, we need to create a recursive function to find the product of a list:which we can do some tests for:Then, we can use this function in another recursive function to solve your problem:which works!Here are some tests to show it working:
want one liner using max  and without max try this
Imperative paradigm is often:This is the "natural" way of programming for lot of people and you know how do that in this way.The pure functional paradigm forbid variables, which have some advantages . It works with functions which communicates through parameters(IN) and return values(OUT). It frequently uses recursive functions.A generic functional recursive scheme is : Here we can find a solution with (l,i,imax,prodmax) as parameters, and:None other than functions have been defined.You can even define no functions to do that, see  here for example, but readability suffers even more.  Run :Python limits this approach by setting recursive depth to 2000, and from Python 3, by hiding functional tools in the module functools.  


Answer URL
https://docs.python.org/3/library/functools.html#functools.partial
