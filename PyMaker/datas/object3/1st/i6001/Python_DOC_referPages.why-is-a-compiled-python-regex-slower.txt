Natural Text
In another SO question, the performance of regexes and Python's in operator were compared. However, the accepted answer uses re.match, which only matches the beginning of a string, and thus behaves completely different to in. Also, I wanted to see the performance gain of not recompiling the RE each time.Surprisingly, I see that the pre-compiled version seems to be slower.Any ideas why?I am aware that there are quite a few other questions here that wonder about a similar issue. Most of them perform the way they do simply because they do not correctly reuse the compiled regex. If that is also my issue, please explain.Output:
Short answerIf you call compiled_pattern.search(text) directly, it won't call _compile at all, it will be faster than re.search(pattern, text) and much faster than re.search(compiled_pattern, text).This performance difference is due to KeyErrors in cache and slow hash calculations for compiled patterns.re functions and SRE_Pattern methodsAny time a re function with a pattern as 1st argument (e.g. re.search(pattern, string) or re.findall(pattern, string)) is called, Python tries to compile the pattern first with _compile and then calls the corresponding method on the compiled pattern. For example:Note that pattern could be either a string or an already compiled pattern (an SRE_Pattern instance)._compileHere's a compact version of _compile. I simply removed debug and flags check:_compile with String patternWhen _compile is called with a string pattern, the compiled pattern is saved in _cache dict. Next time the same function is called (e.g. during the many timeit runs), _compile simply checks in _cache if this string has already been seen and returns the corresponding compiled pattern.Using ipdb debugger in Spyder, it's easy to dive into re.py during execution.With a breakpoint at the second re.search(pattern, text), it can be seen that the pair:is saved in _cache. The compiled pattern is returned directly._compile with compiled patternslow hashWhat happens if _compile is called with an already compiled pattern?First, _compile checks if the pattern is in _cache. To do so, it needs to calculate its hash. This calculation is much slower for a compiled pattern than for a string:hash(compiled_pattern) is 60 times slower than hash(pattern) here.KeyErrorWhen a pattern is unknown, _cache[type(pattern), pattern, flags] fails with a KeyError.The KeyError gets handled and ignored. Only then does _compile check if the pattern is already compiled. If it is, it gets returned, without being written in cache.It means that the next time _compile is called with the same compiled pattern, it will calculate the useless, slow hash again, but will still fail with a KeyError.Error handling is expensive, and I suppose that's the main reason why re.search(compiled_pattern, text) is slower than re.search(pattern, text).This weird behaviour might be a choice to speed up calls with string patterns, but it might have been a good idea to write a warning if _compile is called with an already compiled pattern.


Answer URL
https://docs.python.org/3/library/re.html#re.regex.search
https://docs.python.org/3/library/re.html#re.search
