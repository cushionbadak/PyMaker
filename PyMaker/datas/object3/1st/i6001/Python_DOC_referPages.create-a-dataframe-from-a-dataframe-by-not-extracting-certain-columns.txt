Natural Text
When deleting a column in a DataFrame I use:And this works great. Why can't I use the following?As you can access the column/Series as df.column_name, I expect this to work.
As you've guessed, the right syntax is It's difficult to make del df.column_name work simply as the result of syntactic limitations in Python. del df[name] gets translated to df.__delitem__(name) under the covers by Python.
The best way to do this in pandas is to use drop:where 1 is the axis number (0 for rows and 1 for columns.)To delete the column without having to reassign df you can do:Finally, to drop by column number instead of by column label, try this to delete, e.g. the 1st, 2nd and 4th columns:
Use:This will delete one or more columns in-place. Note that inplace=True was added in pandas v0.13 and won't work on older versions. You'd have to assign the result back in that case:
Drop by indexDelete first, second and fourth columns:Delete first column:There is an optional parameter inplace so that the originaldata can be modified without creating a copy.PoppedColumn selection, addition, deletionDelete column column-name:Examples:print df:df.drop(df.columns[[0]], axis=1, inplace=True)print df:three = df.pop('three')print df:
The actual question posed, missed by most answers here is:Why can't I use del df.column_name?At first we need to understand the problem, which requires us to dive into python magic methods.As Wes points out in his answer del df['column'] maps to the python magic method df.__delitem__('column') which is implemented in pandas to drop the columnHowever, as pointed out in the link above about python magic methods:In fact, del should almost never be used because of the precarious circumstances under which it is called; use it with caution!You could argue that del df['column_name'] should not be used or encouraged, and thereby del df.column_name should not even be considered.However, in theory, del df.column_name could be implemeted to work in pandas using the magic method __delattr__. This does however introduce certain problems, problems which the del df['column_name'] implementation already has, but in lesser degree.Example ProblemWhat if I define a column in a dataframe called "dtypes" or "columns".Then assume I want to delete these columns.del df.dtypes would make the __delattr__ method confused as if it should delete the "dtypes" attribute or the "dtypes" column.Architectural questions behind this problemIs a dataframe acollection of columns?Is a dataframe a collection of rows?Is a column an attribute of a dataframe?Pandas answers:Yes, in all waysNo, but if you want it to be, you can use the .ix, .loc or .iloc methods.Maybe, do you want to read data? Then yes, unless the name of the attribute is already taken by another attribute belonging to the dataframe. Do you want to modify data? Then no.TLDR;You cannot do del df.column_name because pandas has a quite wildly grown architecture that needs to be reconsidered in order for this kind of cognitive dissonance not to occur to its users.Protip:Don't use df.column_name, It may be pretty, but it causes cognitive dissonanceZen of Python quotes that fits in here:There are multiple ways of deleting a column.There should be one-- and preferably only one --obvious way to do it.Columns are sometimes attributes but sometimes not.Special cases aren't special enough to break the rules.Does del df.dtypes delete the dtypes attribute or the dtypes column?In the face of ambiguity, refuse the temptation to guess.
A nice addition is the ability to drop columns only if they exist. This way you can cover more use cases, and it will only drop the existing columns from the labels passed to it:Simply add errors='ignore', for example.:This is new from pandas 0.16.1 onward. Documentation is here.
from version 0.16.1 you can do 
It's good practice to always use the [] notation. One reason is that attribute notation (df.column_name) does not work for numbered indices:
In pandas 0.16.1+ you can drop columns only if they exist per the solution posted by @eiTanLaVi.  Prior to that version, you can achieve the same result via a conditional list comprehension:
Pandas 0.21+ answerPandas version 0.21 has changed the drop method slightly to include both the index and columns parameters to match the signature of the rename and reindex methods. Personally, I prefer using the axis parameter to denote columns or index because it is the predominant keyword parameter used in nearly all pandas methods. But, now you have some added choices in version 0.21.
TL;DRA lot of effort to find a marginally more efficient solution.  Difficult to justify the added complexity while sacrificing the simplicity of df.drop(dlst, 1, errors='ignore')PreambleDeleting a column is semantically the same as selecting the other columns.  I'll show a few additional methods to consider.  I'll also focus on the general solution of deleting multiple columns at once and allowing for the attempt to delete columns not present.  Using these solutions are general and will work for the simple case as well.SetupConsider the pd.DataFrame df and list to delete dlstThe result should look like:Since I'm equating deleting a column to selecting the other columns, I'll break it into two types:Label selectionBoolean selectionLabel SelectionWe start by manufacturing the list/array of labels that represent the columns we want to keep and without the columns we want to delete.df.columns.difference(dlst)np.setdiff1d(df.columns.values, dlst)df.columns.drop(dlst, errors='ignore')list(set(df.columns.values.tolist()).difference(dlst))[x for x in df.columns.values.tolist() if x not in dlst]Columns from LabelsFor the sake of comparing the selection process, assume:Then we can evaluate  df.loc[:, cols]df[cols]df.reindex(columns=cols)df.reindex_axis(cols, 1)Which all evaluate to:Boolean SliceWe can construct an array/list of booleans for slicing~df.columns.isin(dlst)~np.in1d(df.columns.values, dlst)[x not in dlst for x in df.columns.values.tolist()](df.columns.values[:, None] != dlst).all(1)Columns from BooleanFor the sake of comparison  df.loc[: bools]Which all evaluate to:Robust Timing Functions Testing This is relative to the time it takes to run df.drop(dlst, 1, errors='ignore').  It seems like after all that effort, we only improve performance modestly.If fact the best solutions use reindex or reindex_axis on the hack list(set(df.columns.values.tolist()).difference(dlst)).  A close second and still very marginally better than drop is np.setdiff1d.
If you want to drop a single column (col_name) from a dataframe (df), try one of the following:OR If you want to drop a list of columns (col_lst = [col_name_1,col_name_2,...]) from a dataframe (df), try one of the following:OR 
The dot syntax works in JavaScript, but not in Python.Python: del df['column_name']JavaScript: del df['column_name'] or del df.column_name
Another way of Deleting a Column in Pandas DataFrameif you're not looking for In-Place deletion then you can create a new DataFrame by specifying the columns using DataFrame(...) function  asCreate a new DataFrame asYou get a result as good as what you get with del / drop
try this , i think this is the simplest way :drop((['A','B'],axis=1)


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__delattr__
https://docs.python.org/3/howto/descriptor.html
