Natural Text
I have a wood sheet and have given N mark on wood sheet.Now i have to cut all the marks on wood sheet such that cost of cutting all the marks in minimum.Now suppose i first cut the i th mark then the cost is given by using two multipliers a and b which are inputs and the cost is a*(left)+b*(right) where left and right are the size of remaining part of the wood after cutting .for example if i have a wood of length 10 and a=3 and b=4 and if i have mark list for ex: [1,3,5,7,10] so i cant cut first and last mark because they are the starting and end point of the wood so suppose if i start with mark 7 first then cost of cutting will be 3*(7-1)+4*(10-7)=18+12=30 and now the wood which i would have is one starting with mark 1 to mark 7 and other would be one with mark 7 to the end of the wood ad i would repeat the process till all of the marks have been cut .Now after reading the question it immediately came to my mind that in order to cut the wood in minimum cost i first need to find the mid point(median of cut points) and there i should cut the wood and repeat this process again and again till the wood has no cut points left but i am having problem in solving the right wood obtained after cutting  sample input:wood having cut with [1,3,5,9,16,22] would have minimum cost=163 when we first start with median 9 then we would have wood of mark[1,3,5,9] and [9,16,22] now first solving the left wood we would have [1,3,5][5,9],now again cutting we have [1,3][3,5][5,9] and the one which was left [9,16,22] now on operating this wood we have cut all the marks and the list would be [1,3][3,5][5,9][9,16][16,22] and the cost on this operation would be minimumhere is my code:
Firstly, here's a recursive generator solve_gen that checks all the possible cutting sequences and then chooses the minimum one. Although the code is compact, and it runs ok if the number of marks is small, it soon gets rather inefficient as the number of marks increases. I've also included a function apply_cuts that applies a sequence of cuts to a mark sequence, so you can see the cuts happening in that order.solve_gen uses a global count to keep track of the number of recursive calls that get made. count isn't necessary for the operation of the algorithm, but it gives us an indication of how much work the function is doing.outputFWIW, here are the results for the same a & b with a longer mark sequence.We can make this more efficient by finding the minima at each stage of the recursion, rather than finding the minimum of all the possibilities. However, as the algorithm investigates the various cutting options it often repeats calculations that it's done before. So we can make the code much more efficient by using caching, i.e, we store previous results in a dictionary, so if we ever need to make the same cut again we can just look it up in the cache instead of recalculating it. We could code our own cache, but the functools module provides lru_cache which can be used as a decorator. We can also give the cost function a cache, although its calculations are fairly simple, so caching probably doesn't save much time there. A nice feature of lru_cache is that it can also provide cache statistics, which lets us know how useful the cache is.outputFortunately, we get the same results as before. ;) Notice that the recursion count is now much lower. Let's try it with that longer mark sequence.The recursion count is a mere 55 compared to the previous 41990; a significant reduction. And we can see that the caches are being well-used.FWIW, the number of all the possible cutting sequences is given by the Catalan numbers which often crop up in combinatorial problems.
This question requires functions and recursion.  What you want is something like this:Now you have less than 3 marks, the problem is easy.  No cuts are needed and the cost is 0.If you have more than 2 marks, the cost of cutting at any particular place is the cost of cutting there, plus the cost of cutting the rest.  The cost of cutting is therefore the min or those costs.  That should be enough to fill in the something clever.This solution will run slowly with many cuts.  To solve that problem, you should look up "memoization".


Answer URL
https://docs.python.org/3/library/functools.html#functools.lru_cache
