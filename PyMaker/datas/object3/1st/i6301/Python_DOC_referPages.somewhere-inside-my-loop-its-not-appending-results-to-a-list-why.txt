Natural Text
So I have two files/dictionaries I want to compare, using a binary search implementation (yes, this is very obviously homework).One file isamerican-englishAnd the other file is british-englishThe code below should be pretty straight forward. Import files, compare them, return differences. However, somewhere near the bottom, where it says entry == found_difference: I feel as if the debugger skips right over, even though I can see the two variables in memory being different, and I only get the final element returned in the end. Where am I going wrong?
You don't have an else suite for your if statement. Your if statement does nothing (it uses pass when the test is true, skipped otherwise).You do have an else suite for the for loop:A for loop can have an else suite as well; it is executed when a loop completes without a break statement. So when your for loop completes, the current value for found_difference is appended; so whatever was assigned last to that name.Fix your indentation if the else suite was meant to be part of the if test:However, you shouldn't use a pass statement there, just invert the test:Note that the variable name matches feels off here; you are appending words that are missing in the other list, not words that match. Perhaps missing is a better variable name here.Note that your binary_search() function always returns element, the word you searched on. That'll always be equal to the element you passed in, so you can't use that to detect if a word differed! You need to unindent that last return line and return False instead:Now you can use a list comprehension in your wordfile_differences_binarysearch() loop:Last but not least, you don't have to re-invent the binary seach wheel, just use the bisect module:
With setsBinary search is used to improve efficiency of an algorithm, and decrease complexity from O(n) to O(log n).Since the naive approach would be to check every word in wordlist1 for every word in wordlist2, the complexity would be O(n**2).Using binary search would help to get O(n * log n), which is already much better.Using sets, you could get O(n):You could get the american words not present in the british dictionary:You could get the british words not present in the american dictionary:You could get the union of the two last sets. I.e. words that are present in exactly one dictionary:This approach is faster and more concise than any binary search implementation. But if you really want to use it, as usual, you cannot go wrong with @MartijnPieters' answer.With two iteratorsSince you know the two lists are sorted, you could simply iterate in parallel over the two sorted lists and look for any difference:It outputs:It's O(n) as well.


Answer URL
https://docs.python.org/3/library/bisect.html
