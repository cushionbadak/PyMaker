Natural Text
This question already has an answer here:Differentiate False and 0                    2 answers                this line evaluates to True in pythonbecause False and 0 are equal after typecasting.Is there any way to avoid this typecasting?Something like === operator for list?(I know that I can handle this case with a loop by explicitly checking for value types, but I am curious if there is some short and sweet trick to do this without a loop).
If you really feel the need to do the same you can as follows.Or as @JonClements suggestedHowever, such use case seldom arises where you need to differentiate between 0 and False as both are falsy as far as Python is concerned. Perhaps, you need to re-think your use-case.
First of all, there is no typecasting in Python. False == 0 is true because bool is a subclass of int, and the two objects really are equal.And no, there is no === operator, you need to explicitly test for types if you don't want this to happen:This explicitly asserts that the two objects are the exact same type, disallowing for subclasses.Yes, this is a loop. But in for a list also uses a loop, only internally, and both the in containment check and any() short circuit, they return True as soon as the first match is found.Note that this would disallow float equality too. 0.0 == 0 is true too, but by testing for exact types you disallow that as well. The same goes for complex numbers, and Decimal():bool is just another numeric type here, albeit one limited to the numeric values 0 and 1.The better approach, going forward, is to use type hinting in your code; the type hints checker would catch issues like you using booleans where integers or numbers are expected.
You can use "is" keyword for this.


Answer URL
https://docs.python.org/3/library/typing.html
