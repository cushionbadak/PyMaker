Natural Text
I'm a little confused at some behavior of the time.time() function, and am curious as to whether I'm just being ignorant.Alright, so I know I can unpack and assign two function calls like this:This equality makes sense, as at the time of execution, the first time.time() and the second time.time() are the same -- they're evaluated at the same point in time.What's more confusing is this:This equality I find weird. I guess time.time() only rounds to 7 decimal places, and maybe Python's quick enough to execute both of these commands in less than 0.0000001 seconds (my gut tells me this is the case). I thought this equality was maybe just Python being really quick one time, so I tried it lots of times:For me, this raises no AssertionError. What's the deal, here? Is Python quicker than I'm giving it credit for? My assumption is that ;-separated statements evaluate consecutively, but not simultaneously (thus my astonishment that beg never didn't equal end).Edit:Here's what time.time() returns for me, along with the specs of my machine:
First, the assumption about unfolding the list is just wrong. beg, end = time.time(), time.time() can provide different values of time, since the time() function is calculated twice, and can return separate results.Specifically, Python builds a tuple of two time values first (time.time(), time.time()). And then unpacks that tuple into the variables beg, end.There is no special magic with paralellisation or values caching or even var-by-var assignment (consider: a,b = b,a value-swapping pattern: it literally does t = (b,a); (a,b) = t).Second, the timestamps comparison highly depends on your system (OS mostly).For time.time(), the fine-grained resolution is just not guaranteed:Note that even though the time is always returned as a floating point  number, not all systems provide time with a better precision than 1  second.On the unix systems (not MacOSX), you can try using time.clock_getres(clk_id) to get the clock resolution.On Windows, as it seems to be your case, you can probably find the information from the Win32 calls to QueryPerformanceCounter() mentioned in the manual for time.clock() (I do not have enough knowledge to comment on the Windows APIs).You should also google for the time precision on your OS to answer this question, as it is not much python-related.If the resolution is not enough for such measurements, and the CPU is very fast (typical for nowadays), then the time measurements will be too close to distinguish them. They will be different and far apart if measured in the CPU tacts, of course. But not different in the minimum available time units.To notice that, try executing your code on the much slower machine or when the CPU is highly overloaded with some computational tasks (i.e. 99-100% CPU used), and cannot spend too much time on your process. It is better if the CPU is not just busy with one process, but switches the context very often between multiple processes â€” e.g. by having few hundreds of CPU-intensive processes or maybe 1-2 thousands of just idling CPUs (as in the fork bomb).UPD: TO the added details on the question: the number of the digits after the comma says nothing about the time resolution on your machine, except that it is not 1 sec.The OS just measures something within the 1-second frames. The result depends not only on the clock resolution, but also at which time the time request was made, and it can vary.Not to mention the problems with the floating precision, where the fractions can be improperly rounded to the nearest "fitting" float. Compare the precision of the floats depending on how big is the part before the comma:


Answer URL
https://docs.python.org/3/library/time.html#time.clock_getres
https://docs.python.org/3/library/time.html#time.clock
