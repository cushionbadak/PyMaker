Natural Text
In python3's multiprocess,  can't call the __del__ method.  I've read other issues about circular references,but I can't find the situation in multiprocess.  There is a circular reference in foo, __del__ will be called when  foo is called directly,but in multiprocess the __del__ will never be called.Output:call foocall foodelwhy __del__ is not called in p?
Forked Process objects terminate after running their task using os._exit(), which forcibly terminates the child process without the normal cleanup Python performs on exit. Cyclic garbage isn't cleaned (because the process is terminated without giving the cyclic GC a chance to run), it's just dropped on the floor, leaving the OS to clean up.This is intentional, since exiting normally (invoking all normal cleanup procedures) would risk stuff like unflushed buffers getting flushed in both parent and child (doubling output), and other weirdness involved when a forked process inherits all the state of the parent but isn't supposed to use it except when told to do so explicitly.
The question isn't actually why it isn't called in multiprocess, but why it is called in the other example. And the answer to that is that it isn't called when you call foo. It's called at the end of the program. Since the program is finished, Python knows that anything else can be cleaned up even if it's still referenced, so it cleans up circular references.If you add a print statement at the end of the script, or call this from the REPL, you can see that __del__ still isn't called at your second foo call either, but only at the end of the script.Given that Python cleans up circular references when the script ends, ShadowRanger's answer explains why that doesn't happen when the multiprocessing function is finished.


Answer URL
https://docs.python.org/3/library/os.html#os._exit
https://docs.python.org/3/library/gc.html
