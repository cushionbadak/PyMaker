Natural Text
I would like to compare all elements in my iterable object combinatorically with each other. The following reproducible example just mimics the functionality of a plain list, but demonstrates my problem. In this example with a list of ["A","B","C","D"], I would like to get the following 16 lines of output, every combination of each item with each other. A list of 100 items should generate 100*100=10,000 lines.The following code seemed like it should do the job.But after finishing the y-loop, the x-loop seems done, too, even though it's only used the first item in the iterable.After much searching, I eventually tried the following code, hoping that itertools.tee would allow me two independent iterators over the same data:But I got the same output as before.The real-world object this represents is a model of a directory and file structure with varying numbers of files and subdirectories, at varying depths into the tree. It has nested links to thousands of members and iterates correctly over them once, just like this example. But it also does expensive processing within its many internal objects on-the-fly as needed for comparisons, which would end up doubling the workload if I had to make a complete copy of it prior to iterating. I would really like to use multiple iterators, pointing into a single object with all the data, if possible.Edit on answers: The critical flaw in the question code, pointed out in all answers, is the single internal self.idx variable being unable to handle multiple callers independently. The accepted answer is the best for my real class (oversimplified in this reproducible example), another answer presents a simple, elegant solution for simpler data structures like the list presented here.
It's actually impossible to make a container class that is it's own iterator. The container shouldn't know about the state of the iterator and the iterator doesn't need to know the contents of the container, it just needs to know which object is the corresponding container and "where" it is. If you mix iterator and container different iterators will share state with each other (in your case the self.idx) which will not give the correct results (they read and modify the same variable).That's the reason why all built-in types have a seperate iterator class (and even some have an reverse-iterator class):So, basically you could just return iter(self.stuff) in __iter__ and drop the __next__ altogether because list_iterator knows how to iterate over the list:prints 16 lines, like expected.If your goal is to make your own iterator class, you need two classes (or 3 if you want to implement the reversed-iterator yourself).works as well. For completeness, here's one possible implementation of the reversed-iterator:Instead of defining your own iterators you could use generators. One way was already shown in the other answer:or explicitly delegate to a generator function (that's actually equivalent to the above but maybe more clear that it's a new object that is produced):Note: You don't have to implement the __reversed__ iterator. That was just meant as additional "feature" of the answer.
Your __iter__ is completely broken. Instead of actually making a fresh iterator on every call, it just resets some state on self and returns self. That means you can't actually have more than one iterator at a time over your object, and any call to __iter__ while another loop over the object is active will interfere with the existing loop.You need to actually make a new object. The simplest way to do that is to use yield syntax to write a generator function. The generator function will automatically return a new iterator object every time:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.chain
