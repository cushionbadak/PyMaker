Natural Text
I'm confused on what an immutable type is. I know the float object is considered to be immutable, with this type of example from my book:Is this considered to be immutable because of the class structure / hierarchy?, meaning float is at the top of the class and is its own method call. Similar to this type of example (even though my book says dict is mutable):Whereas something mutable has methods inside the class, with this type of example:Also, for the last class(SortedKeyDict_a), if I pass this type of set to it:without calling the example method, it returns a dictionary. The SortedKeyDict with __new__ flags it as an error. I tried passing integers to the RoundFloat class with __new__ and it flagged no errors.
What? Floats are immutable? But can't I doDoesn't that "mut" x?Well you agree strings are immutable right? But you can do the same thing.The value of the variable changes, but it changes by changing what the variable refers to. A mutable type can change that way, and it can also change "in place".Here is the difference.Concrete examples
You have to understand that Python represents all its data as objects. Some of these objects like lists and dictionaries are mutable, meaning you can change their content without changing their identity. Other objects like integers, floats, strings and tuples are objects that can not be changed. An easy way to understand that is if you have a look at an objects ID. Below you see a string that is immutable. You can not change its content. It will raise a TypeError if you try to change it. Also, if we assign new content, a new object is created instead of the contents being modified.You can do that with a list and it will not change the objects identityTo read more about Python's data model you could have a look at the Python language reference:Python 2 datamodelPython 3 datamodel
Common immutable type: numbers: int(), float(), complex()immutable sequences: str(), tuple(), frozenset(), bytes()Common mutable type (almost everything else):mutable sequences: list(), bytearray()set type: set()mapping type: dict()classes, class instancesetc.One trick to quickly test if a type is mutable or not, is to use id() built-in function. Examples, using on integer,using on list,
First of all, whether a class has methods or what it's class structure is has nothing to do with mutability.ints and floats are immutable. If I doIt points the name a at a 1 somewhere in memory on the first line. On the second line, it looks up that 1, adds 5, gets 6, then points a at that 6 in memory -- it didn't change the 1 to a 6 in any way. The same logic applies to the following examples, using other immutable types:For mutable types, I can do thing that actallly change the value where it's stored in memory. With:I've created a list of the locations of 1, 2, and 3 in memory. If I then doI just point e to the same list d points at. I can then do:And the list that both e and d points at will be updated to also have the locations of 4 and 5 in memory.If I go back to an immutable type and do that with a tuple:Then f still only points to the original tuple -- you've pointed g at an entirely new tuple.Now, with your example of Where you pass (which is a tuple of tuples) as val, you're getting an error because tuples don't have a .clear() method -- you'd have to pass dict(d) as val for it to work, in which case you'll get an empty SortedKeyDict as a result.
Whether an object is mutable or not depends on its type. This doesn't depend on whether or not it has certain methods, nor on the structure of the class hierarchy.User-defined types (i.e. classes) are generally mutable. There are some exceptions, such as simple sub-classes of an immutable type. Other immutable types include some built-in types such as int, float, tuple and str, as well as some Python classes implemented in C.A general explanation from the "Data Model" chapter in the Python Language Reference":The value of some objects can change. Objects whose value can change  are said to be mutable; objects whose value is unchangeable once they  are created are called immutable.(The value of an immutable container  object that contains a reference to a mutable object can change when  the latter’s value is changed; however the container is still  considered immutable, because the collection of objects it contains  cannot be changed. So, immutability is not strictly the same as having  an unchangeable value, it is more subtle.)An object’s mutability is  determined by its type; for instance, numbers, strings and tuples are  immutable, while dictionaries and lists are mutable.
If you're coming to Python from another language (except one that's a lot like Python, like Ruby), and insist on understanding it in terms of that other language, here's where people usually get confused:In Python, assignment is not mutation in Python.In C++, if you write a = 2, you're calling a.operator=(2), which will mutate the object stored in a. (And if there was no object stored in a, that's an error.)In Python, a = 2 does nothing to whatever was stored in a; it just means that 2 is now stored in a instead. (And if there was no object stored in a, that's fine.)Ultimately, this is part of an even deeper distinction.A variable in a language like C++ is a typed location in memory. If a is an int, that means it's 4 bytes somewhere that the compiler knows is supposed to be interpreted as an int. So, when you do a = 2, it changes what's stored in those 4 bytes of memory from 0, 0, 0, 1 to 0, 0, 0, 2. If there's another int variable somewhere else, it has its own 4 bytes.A variable in a language like Python is a name for an object that has a life of its own. There's an object for the number 1, and another object for the number 2. And a isn't 4 bytes of memory that are represented as an int, it's just a name that points at the 1 object. It doesn't make sense for a = 2 to turn the number 1 into the number 2 (that would give any Python programmer way too much power to change the fundamental workings of the universe); what it does instead is just make a forget the 1 object and point at the 2 object instead.So, if assignment isn't a mutation, what is a mutation?Calling a method that's documented to mutate, like a.append(b). (Note that these methods almost always return None). Immutable types do not have any such methods, mutable types usually do.Assigning to a part of the object, like a.spam = b or a[0] = b. Immutable types do not allow assignment to attributes or elements, mutable types usually allow one or the other.Sometimes using augmented assignment, like a += b, sometimes not. Mutable types usually mutate the value; immutable types never do, and give you a copy instead (they calculate a + b, then assign the result to a).But if assignment isn't mutation, how is assigning to part of the object mutation? That's where it gets tricky. a[0] = b does not mutate a[0] (again, unlike C++), but it does mutate a (unlike C++, except indirectly).All of this is why it's probably better not to try to put Python's semantics in terms of a language you're used to, and instead learn Python's semantics on their own terms.
A mutable object has to have at least a method able to mutate the object. For example, the list object has the append method, which will actually mutate the object:but the class float has no method to mutate a float object. You can do:but the = operand is not a method. It just make a bind between the variable and whatever is to the right of it, nothing else. It never changes or creates objects. It is a declaration of what the variable will point to, since now on. When you do b = b + 0.1 the = operand binds the variable to a new float, wich is created with te result of  5 + 0.1.When you assign a variable to an existent object, mutable or not, the = operand binds the variable to that object. And nothing more happensIn either case, the = just make the bind. It doesn't change or create objects.When you do a = 1.0, the = operand is not wich create the float, but the 1.0 part of the line. Actually when you write 1.0 it is a shorthand for float(1.0) a constructor call returning a float object. (That is the reason why if you type 1.0 and press enter you get the "echo" 1.0 printed below; that is the return value of the constructor function you called)Now, if b is a float and you assign a = b, both variables are pointing to the same object, but actually the variables can't comunicate betweem themselves, because the object is inmutable, and if you do b += 1, now b point to a new object, and a is still pointing to the oldone and cannot know what b is pointing to.but if c is, let's say, a list, and you assign a = c, now a and c can "comunicate", because list is mutable, and if you do c.append('msg'), then just checking a you get the message.(By the way, every object has an unique id number asociated to, wich you can get with id(x). So you can check if an object is the same or not checking if its unique id has changed.)
Difference between Mutable and Immutable objectDefinitionsMutable object: Object that can be changed after creating it.Immutable object: Object that cannot be changed after creating it.In python will try to change the value of the immutable object it will give the new object.Mutable ObjectsHere are the list objects in python that are of mutable type:listDictionarySetbytearrayuser defined classesImmutable ObjectsHere are the list objects in python that are of immutable type:intfloatdecimalcomplexboolstringtuplerangefrozensetbytesSome Unanswered QuestionsQuestions: Is string a immutable type?Answer: yes  it is, but can you explain this:Proof 1:OutputIn the above example string got once created as "Hello" finally changed to "Hello World". This implies that string is of the mutable type. But it is not we can check its identity and check whether it is of mutable type or not.OutputProof 2:OutputQuestions: Is Tuple a immutable type?Answer: yes  it isProof 1:Output
A class is immutable if each object of that class has a fixed value upon instantiation that cannot SUBSEQUENTLY be changed In another word change the entire value of that variable (name) or leave it alone.Example: you expected this to work and print hello world but this will throw the following error: The interpreter is saying : i can't change the first character of this stringyou will have to change the whole string in order to make it works:check this table: source
It would seem to me that you are fighting with the question what mutable/immutable actually means. So here is a simple explenation:First we need a foundation to base the explenation on. So think of anything that you program as a virtual object, something that is saved in a computers memory as a sequence of binary numbers. (Don't try to imagine this too hard, though.^^) Now in most computer languages you will not work with these binary numbers directly, but rather more you use an interpretation of binary numbers.E.g. you do not think about numbers like 0x110, 0xaf0278297319 or similar, but instead you think about numbers like 6 or Strings like "Hello, world". Never the less theses numbers or Strings are an interpretation of a binary number in the computers memory. The same is true for any value of a variable.In short: We do not program with actual values but with interpretations of actual binary values.
The goal of this answer is to create a single place to find all the good ideas about how to tell if you are dealing with mutating/nonmutating (immutable/mutable), and where possible, what to do about it?  There are times when mutation is undesirable and python's behavior in this regard can feel counter-intuitive to coders coming into it from other languages.As per a useful post by @mina-gabriel:Books to read that might help:  "Data Structures and Algorithms in Python"Excerpt from that book that lists mutable/immutable types: mutable/imutable types imageAnalyzing the above and combining w/ a post by @arrakëën:What cannot change unexpectedly?scalars (variable types storing a single value) do not change unexpectedlynumeric examples: int(), float(), complex()there are some "mutable sequences":str(), tuple(), frozenset(), bytes()What can? list like objects (lists, dictionaries, sets, bytearray())a post on here also says classes and class instances but this may depend on what the class inherits from and/or how its built.by "unexpectedly" I mean that programmers from other languages might not expect this behavior (with the exception or Ruby, and maybe a few other "Python like" languages).Adding to this discussion:This behavior is an advantage when it prevents you from accidentally populating your code with mutliple copies of memory-eating large data structures.  But when this is undesirable, how do we get around it?With lists, the simple solution is to build a new one like so:list2 = list(list1)with other structures ... the solution can be trickier.  One way is to loop through the elements and add them to a new empty data structure (of the same type).functions can mutate the original when you pass in mutable structures.  How to tell?There are some tests given on other comments on this thread but then there are comments indicating these tests are not full proofobject.function() is a method of the original object but only some of these mutate.  If they return nothing, they probably do.  One would expect .append() to mutate without testing it given its name.  .union() returns the union of set1.union(set2) and does not mutate.  When in doubt, the function can be checked for a return value.  If return = None, it does not mutate.sorted() might be a workaround in some cases.  Since it returns a sorted version of the original, it can allow you to store a non-mutated copy before you start working on the original in other ways. However, this option assumes you don't care about the order of the original elements (if you do, you need to find another way).  In contrast .sort() mutates the original (as one might expect).Non-standard Approaches (in case helpful):Found this on github published under an MIT license: github repository under: tobgu named: pyrsistentWhat it is:  Python persistent data structure code written to be used in place of core data structures when mutation is undesirableFor custom classes, @semicolon suggests checking if there is a __hash__ function because mutable objects should generally not have a __hash__() function.This is all I have amassed on this topic for now.  Other ideas, corrections, etc. are welcome.  Thanks.
One way of thinking of the difference:Assignments to immutable objects in python can be thought of as deep copies, whereas assignments to mutable objects are shallow
The simplest answer:A mutable variable is one whose value may change in place, whereas in an immutable variable change of value will not happen in place. Modifying an immutable variable will rebuild the same variable.Example:Will create a value 5 referenced by xx -> 5This statement will make y refer to 5 of xx -------------> 5 <-----------yAs x being an integer (immutable type) has been rebuild.In the statement, the expression on RHS will result into value 10 and when this is assigned to LHS (x), x will rebuild to 10. So nowx--------->10y--------->5
For immutable objects, assignment creates a new copy of values, for example.For mutable objects, the assignment doesn't create another copy of values. For example,
In Python, there's a easy way to know:Immutable:Mutable:And:So I think built-in function is also immutable in Python.But I really don't understand how float works:It's so weird.
I haven't read all the answers, but the selected answer is not correct and I think the author has an idea that being able to reassign a variable means that whatever datatype is mutable. That is not the case. Mutability has to do with passing by reference rather than passing by value.Lets say you created a ListIf you were to say:Even though you reassigned a value on B, it will also reassign the value on a. Its because when you assign "b = a". You are passing the "Reference" to the object rather than a copy of the value. This is not the case with strings, floats etc. This makes list, dictionaries and the likes mutable, but booleans, floats etc immutable.


Answer URL
https://docs.python.org/3/reference/datamodel.html
