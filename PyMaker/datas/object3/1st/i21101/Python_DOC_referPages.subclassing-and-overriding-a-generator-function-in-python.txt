Natural Text
I need to override a method of a parent class, which is a generator, and am wondering the correct way to do this. Is there anything wrong with the following, or a more efficient way?
What you have looks fine, but is not the only approach. What's important about a generator function is that it returns an iterable object. Your subclass could thus instead directly create an iterable, for example:The better approach is going to depend on exactly what you're doing; the above looks needlessly complex, but I wouldn't want to generalize from such a simple example. 
For Python 3.3 and up, the best, most general way to do this is:This uses the new yield from syntax for delegating to a subgenerator. It's better than the other solutions because it's actually handing control to the generator it delegates to; if said generator supports .send and .throw to pass values and exceptions into the generator, then delegation means it actually receives the values; explicitly looping and yielding one by one will receive the values in the gen wrapper, not the generator actually producing the values, and the same problem applies to other solutions like using itertools.chain.
To call a method from a subclass you need the keyword super.New Source Code:This:produces the output:In the first Iteration your generator stops at '3', for the following iterations it just goes on as the superclass normally would. This Question provides a really good and lengthy explanation of generators, iterators and the yield- keyword:What does the "yield" keyword do in Python?
Your code is correct.Or rather, I don't see problem in it and it apparently runs correctly.The only thing I can think of is the following one..Post-scriptumFor new-style classes, see other answers that use super()But super() only works for new-style classesAnyway, this answer could be useful at least, but only, for classic-style classes.   .When the interpreter arrives on the instruction for n in A.gen(self):, it must find the function A.gen.  The notation A.gen doesn't mean that the object A.gen is INSIDE the object A.The object A.gen is SOMEWHERE in the memory and the interpreter will know where to find it by obtaining the needed information (an address) from A.__dict__['gen'] , in which A.__dict__ is the namespace of A.So, finding the function object A.gen in the memory requires a lookup in A.__dict__ But to perform this lookup, the interpreter must first find the object A itself.So, when it arrives on the instruction for n in A.gen(self): , it first searches if the identifier  A is among the local  identifiers, that is to say it searches for the string 'A' in the local namespace of the function (of which I don't know the name).Since it is not, the interpreter goes outside the function and searches for this identifier at the module level, in the global namespace (which is globals() )At this point, it may be that the global namespace would have hundreds or thousands of attributes names among which to perform the lookup for 'A'. However, A has very few attributes: its __dict__ 's keys are only '_ module _' , 'gen' and '_ doc _' (to see that, make print A.__dict__ )So, it would be a pity that the little search for the string 'gen' in A._dict_ should be done after a search among hundreds of items in the dictionary-namespace globals() of the module level..That's why I suggest another way to make the interpreter able to find the function A.genself._class_ is the class from which has been instanciated the instance, that is to say it is Bu self._class_._bases_ is a tuple containing the base classes of BuPresently there is only one element in this tuple , so self._class_._bases_[0]  is A __class__ and __bases__ are names of special attributes that aren't listed in _dict_ ;In fact _class_ , _bases_ and _dict_ are special attributes of similar nature, they are  Python-provided attributes, see:http://www.cafepy.com/article/python_attributes_and_methods/python_attributes_and_methods.html.Well, what I mean , in the end, is that there are few elements in self._class_  and in  self._class_._bases_  , so it is rational to think that the successive lookups in these objects to finally find the way to access to A.gen will be faster than the lookup to search for 'gen' in the global namespace in case this one contains hundreds of elements.Maybe that's trying to do too much optimization, maybe not.This answer is mainly  to give information on the underlying implied mechanisms, that I personally find interesting to know..EditYou can obtain the same as your code with a more concise instructionproduces


Answer URL
https://docs.python.org/3/whatsnew/3.3.html#pep-380
