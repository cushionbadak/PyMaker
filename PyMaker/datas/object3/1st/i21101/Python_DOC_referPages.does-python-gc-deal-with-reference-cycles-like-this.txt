Natural Text
Using objgraph, I found a bunch of objects like this:Will Python's garbage collector deal with cycles like this, or will it leak?A slightly wider view of the loop:
Python's standard reference counting mechanism cannot free cycles, so the structure in your example would leak.The supplemental garbage collection facility, however, is enabled by default and should be able to free that structure, if none of its components are reachable from the outside anymore and they do not have __del__() methods.If they do, the garbage collector will not free them because it cannot determine a safe order to run these __del__() methods.
To extend on Frédéric's answer a bit, the "reference counts" section of the docs explains the supplementary cycle detection nicely.Since I find explaining things a good way to confirm I understand it, here are some examples... With these two classes:Creating an object and losing the reference from a triggers the __del__ method, thanks to the ref-counting:If we make a reference loop between two objects with no __del__ method, all is still leak-free, this time thanks to the cycle detection. First, enable the garbage-collection debug output:Then make a reference loop between the two objects:(the dict is from the objects internal __dict__ attribute)All is fine, until even one of the objects in the cycle contains a __del__ method:As Paul mentioned, the loop can be broken with a weakref:Then when the b reference to the WithDel object is lost, it gets deleted, despite the cycle:Oh, objgraph would have helpfully indicated the problematic __del__ method like this
Python's GC is designed to traverse all live objects to locate and eliminate reference cycles with no external references.You can validate that is what is happening by running gc.collect() and then printing gc.garbage and gc.get_objects.
If you use weakrefs for your parent pointers, then GC will happen normally.


Answer URL
https://docs.python.org/3/library/gc.html#gc.garbage
