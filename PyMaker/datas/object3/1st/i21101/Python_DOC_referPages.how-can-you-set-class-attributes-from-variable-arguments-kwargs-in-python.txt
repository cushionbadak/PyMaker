Natural Text
Suppose I have a class with a constructor (or other function) that takes a variable number of arguments and then sets them as class attributes conditionally.I could set them manually, but it seems that variable parameters are common enough in python that there should be a common idiom for doing this.  But I'm not sure how to do this dynamically.I have an example using eval, but that's hardly safe.  I want to know the proper way to do this -- maybe with lambda?
You could update the __dict__ attribute (which represents the class attributes in the form of a dictionary) with the keyword arguments:then you can:and with something like:you could filter the keys beforehand (use iteritems instead of items if youâ€™re still using Python 2.x).
You can use the setattr() method:There is an analogous getattr() method for retrieving attributes.
Most answers here do not cover a good way to initialize all allowed attributes to just one default value.So, to add to the answers given by @fqxp and @mmj:
I propose a variation of fqxp's answer, which, in addition to allowed attributes, lets you set default values for attributes:This is Python 3.x code, for Python 2.x you need at least one adjustment, iteritems() in place of items().
I called the class SymbolDict because it essentially is a dictionary that operates using symbols instead of strings.  In other words, you do x.foo instead of x['foo'] but under the covers it's really the same thing going on.
The following solutions vars(self).update(kwargs) or self.__dict__.update(**kwargs) are not robust, because the user can enter any dictionary with no error messages. If I need to check that the user insert the following signature ('a1', 'a2', 'a3', 'a4', 'a5') the solution does not work. Moreover, the user should be able to use the object by passing the "positional parameters" or the "kay-value pairs parameters".So I suggest the following solution by using a metaclass.
this one is the easiest via larsksmy example:
Their might be a better solution but what comes to mind for me is:
Yet another variant based on the excellent answers by mmj and fqxp. What if we want toAvoid hardcoding a list of allowed attributesDirectly and explicitly set default values for each attributes in the constructorRestrict kwargs to predefined attributes by eithersilently rejecting invalid arguments or, alternatively, raising an error.By "directly", I mean avoiding an extraneous default_attributes dictionary.Not a major breakthrough, but maybe useful to someone...EDIT:If our class uses @property decorators to encapsulate "protected" attributes with getters and setters, and if we want to be able to set these properties with our constructor, we may want to expand the allowed_keys list with values from dir(self), as follows:The above code excludesany hidden variable from dir() (exclusion based on presence of "__"), andany method from dir() whose name is not found in the end of an attribute name (protected or otherwise) from __dict__.keys(), thereby likely keeping only @property decorated methods. This edit is likely only valid for Python 3 and above.
I suspect it might be better in most instances to use named args (for better self documenting code) so it might look something like this:


Answer URL
https://docs.python.org/3/library/functions.html#setattr
https://docs.python.org/3/library/functions.html#getattr
