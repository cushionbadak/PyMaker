Natural Text
I want to use redis' pubsub to transmit some messages, but don't want be blocked using listen, like the code below:The last for section will block. I just want to check if a given channel has data, how can I accomplish this? Is there a check like method?
I don't think that would be possible. A Channel doesn't have any "current data", you subscribe to a channel and start receiving messages that are being pushed by other clients on the channel, hence it is a blocking API. Also if you look at the Redis Commands documentation for pub/sub it would make it more clear.
If you're thinking of non-blocking, asynchronous processing, you're probably using (or should use) asynchronous framework/server.if you're using Tornado, there is Tornado-Redis. It's using native Tornado generator calls. Its Websocket demo provides example on how to use it in combination with pub/sub.if you're using Twisted, there is txRedis. There you also have pub/sub example.it also seems that you can use Redis-py combined with Gevent with no problems using Gevent's monkey patching (gevent.monkey.patch_all()). UPDATE:It's been 5 years since the original answer, in the mean time Python got native async IO support. There now is AIORedis, an async IO Redis client. 
The new version of redis-py has support for asynchronous pubsub, check https://github.com/andymccurdy/redis-py for more details.Here's an example from the documentation itself:
Accepted answer is obsolete as redis-py recommends you to use the non-blocking get_message(). But it also provides a way to easily use threads. https://pypi.python.org/pypi/redisThere are three different strategies for reading messages.Behind the scenes, get_message() uses the system’s ‘select’ module to quickly poll the connection’s socket. If there’s data available to be read, get_message() will read it, format the message and return it or pass it to a message handler. If there’s no data to be read, get_message() will immediately return None. This makes it trivial to integrate into an existing event loop inside your application.Older versions of redis-py only read messages with pubsub.listen(). listen() is a generator that blocks until a message is available. If your application doesn’t need to do anything else but receive and act on messages received from redis, listen() is an easy way to get up an running.The third option runs an event loop in a separate thread. pubsub.run_in_thread() creates a new thread and starts the event loop. The thread object is returned to the caller of run_in_thread(). The caller can use the thread.stop() method to shut down the event loop and thread. Behind the scenes, this is simply a wrapper around get_message() that runs in a separate thread, essentially creating a tiny non-blocking event loop for you. run_in_thread() takes an optional sleep_time argument. If specified, the event loop will call time.sleep() with the value in each iteration of the loop.Note: Since we’re running in a separate thread, there’s no way to handle messages that aren’t automatically handled with registered message handlers. Therefore, redis-py prevents you from calling run_in_thread() if you’re subscribed to patterns or channels that don’t have message handlers attached.So to answer you question, just check get_message when you want to know if a message has arrived.
This is a working example to thread the blocking listener.
Here is a nonblocking solution without threads:ps.get_message() is enough on its own, but I use this method so that I can wait on multiple fds instead of just the redis connection.
To reach a none blocking code you must do another kind of paradigm code. It's not hard, using a new thread to listen all changes and leaving main thread to do another things. Also, you will need some mechanism to interchange data between main thread and redis subscriber thread.
The most efficient approach would be greenlet-based rather than thread-based. As a greenlet-based concurrency framework, gevent is already quite established in the Python world. A gevent integration with redis-py would be therefore be wonderful. That is exactly what's being discussed in this issue on github:https://github.com/andymccurdy/redis-py/issues/310
You can use gevent, gevent monkey patching to build a non-blocking redis pubsub app.
Redis' pub/sub sends messages to clients subscribed (listening) on a channel. If you are not listening, you will miss the message (hence the blocking call). If you want to have it non-blocking, I recommend using a queue instead (redis is pretty good at that too). If you have to use pub/sub you can use as suggested gevent to have a asynchronous, blocking listener, push messages to a queue and use a separate consumer to process messages from that queue in a non-blocking way.


Answer URL
https://docs.python.org/3/library/asyncio.html
