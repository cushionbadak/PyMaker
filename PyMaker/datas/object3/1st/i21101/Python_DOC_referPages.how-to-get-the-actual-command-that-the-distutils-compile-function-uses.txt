Natural Text
I have a Distutils setup.py script which uses new_compiler().compile() to compile test programs to make sure certain features (eg. MPI) are available on the system.My problem is that there is one case where the compile() call results in a compiler error, but compiling the same little test program manually does not. The error is inside a standard header (mpi.h). All my actual source files also include this header but they compile fine! This particular check would be very useful to have, but I need to figure out why it's failing when it shouldn't be.So my question is, how can I get the actual command used by ccompiler.compile()?
Adam (Wagner)'s comment is the right place to start: you have to hunt through the Distutils source code. There are a lot of levels of abstraction so you do have to trace the execution through several different files, but here's the gist:The package distutils.ccompiler includes an abstract class CCompiler which handles invoking the actual compiler. It has methods for the various tasks a compiler needs to perform: preprocess, compile, and link. CCompiler itself does not implement any of these methods except for compile, but even there it delegates the actual compiler invocation to the method _compile. So you need to check the subclass of CCompiler that is used on your platform and look at its implementation of _compile.There are several different subclasses of CCompiler, each implemented in its own package, but the "big two" are distutils.unixccompiler.UnixCCompiler (which invokes the native compiler on a UNIX-like system) and distutils.msvccompiler.MSVCCompiler (which invokes Visual Studio). Both of these use the function distutils.spawn.spawn to actually run the external process.In the source for distutils.spawn.spawn, you'll notice that each command is logged at the level INFO before it is run. But the catch is, this doesn't use Python's builtin logging system; rather it uses Distutils' custom logger implemented in distutils.log.If you now look at the source for distutils.log, you'll see that there is a function set_verbosity which sets the logging level. Unfortunately, it isn't tied to any of the other debugging infrastructure in Distutils (such as the DISTUTILS_DEBUG environment variable), so you'll need to manually callsomewhere in your setup script, before any compilation commands are run. Once you do that, all compilation commands (and who knows what other information) should be printed to standard output.
This is insanely late, but I found out how to do this from within python (without checking logs) in case anyone is wondering:The "compiler_so" attribute is a list of every argument that distutils is going to use when compiling something. It adds on the filename and -c (for object files) when it actually starts compiling. EDIT: I have only tested this on macOS and Linux, it doesn't seem like this will work on Windows. EDIT2: I should add, it is not the full command, but only the arguments before distutils processes any Extension() instances. The remaining arguments are unique to the extension and depend on the arguments you give when making an Extension class, like sources, include_dirs, define_macros. If you want the full raw command that distutils runs, the only way I know of (without parsing logs) is to grab the command string at the last minute after all the processing and right before the spawn function. Here is an incredibly hacky way of doing it:The more elegant thing would be to fork distutils and add this functionality but that's like so much work and stuff. 
Additionally, if you would like to see the linker flags, you can do the following:


Answer URL
https://docs.python.org/3/distutils/apiref.html#distutils.core.Extension
