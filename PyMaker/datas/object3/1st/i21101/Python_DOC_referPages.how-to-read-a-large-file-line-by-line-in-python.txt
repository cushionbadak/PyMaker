Natural Text
I want to iterate over each line of an entire file. One way to do this is by reading the entire file, saving it to a list, then going over the line of interest. This method uses a lot of memory, so I am looking for an alternative.My code so far:Executing this code gives an error message: device active.Any suggestions?The purpose is to calculate pair-wise string similarity, meaning for each line in file, I want to calculate the Levenshtein distance with every other line.
The correct, fully Pythonic way to read a file is the following:The with statement handles opening and closing the file, including if an exception is raised in the inner block. The for line in f treats the file object f as an iterable, which automatically uses buffered I/O and memory management so you don't have to worry about large files.There should be one -- and preferably only one -- obvious way to do it.
Two memory efficient ways in ranked order (first is best) -use of with - supported from python 2.5 and aboveuse of yield if you really want to have control over how much to read1. use of withwith is the nice and efficient pythonic way to read large files. advantages - 1) file object is automatically closed after exiting from with execution block. 2) exception handling inside the with block. 3) memory for loop iterates through the f file object line by line. internally it does buffered IO (to optimized on costly IO operations) and memory management. 2. use of yieldSometimes one might want more fine-grained control over how much to read in each iteration. In that case use iter & yield. Note with this method one explicitly needs close the file at the end.Pitfalls and for the sake of completeness - below methods are not as good or not as elegant for reading large files but please read to get rounded understanding.In Python, the most common way to read lines from a file is to do the following: When this is done, however, the readlines() function (same applies for read() function) loads the entire file into memory, then iterates over it. A slightly better approach (the first mentioned two methods are the best) for large files is to use the fileinput module, as follows:the fileinput.input() call reads lines sequentially, but doesn't keep them in memory after they've been read or even simply so this, since file in python is iterable. ReferencesPython with statement
To strip newlines:With universal newline support all text file lines will seem to be terminated with '\n', whatever the terminators in the file, '\r', '\n', or '\r\n'. EDIT - To specify universal newline support:Python 2 on Unix - open(file_path, mode='rU') - required [thanks @Dave]Python 2 on Windows - open(file_path, mode='rU') - optionalPython 3 - open(file_path, newline=None) - optionalThe newline parameter is only supported in Python 3 and defaults to None. The mode parameter defaults to 'r' in all cases. The U is deprecated in Python 3. In Python 2 on Windows some other mechanism appears to translate \r\n to \n.Docs:open() for Python 2open() for Python 3To preserve native line terminators:Binary mode can still parse the file into lines with in.  Each line will have whatever terminators it has in the file.Thanks to @katrielalex's answer, Python's open() doc, and iPython experiments.
this is a possible way of reading a file in python:it does not allocate a full list. It iterates over the lines.
Some context up front as to where I am coming from. Code snippets are at the end.When I can, I prefer to use an open source tool like H2O to do super high performance parallel CSV file reads, but this tool is limited in feature set. I end up writing a lot of code to create data science pipelines before feeding to H2O cluster for the supervised learning proper.I have been reading files like 8GB HIGGS dataset from UCI repo and even 40GB CSV files for data science purposes significantly faster by adding lots of parallelism with the multiprocessing library's pool object and map function. For example clustering with nearest neighbor searches and also DBSCAN and Markov clustering algorithms requires some parallel programming finesse to bypass some seriously challenging memory and wall clock time problems. I usually like to break the file row-wise into parts using gnu tools first and then glob-filemask them all to find and read them in parallel in the python program. I use something like 1000+ partial files commonly. Doing these tricks helps immensely with processing speed and memory limits.  The pandas dataframe.read_csv is single threaded so you can do these tricks to make pandas quite faster by running a map() for parallel execution.  You can use htop to see that with plain old sequential pandas dataframe.read_csv, 100% cpu on just one core is the actual bottleneck in pd.read_csv, not the disk at all.I should add I'm using an SSD on fast video card bus, not a spinning HD on SATA6 bus, plus 16 CPU cores.Also, another technique that I discovered works great in some applications is parallel CSV file reads all within one giant file, starting each worker at different offset into the file, rather than pre-splitting one big file into many part files. Use python's file seek() and tell() in each parallel worker to read the big text file in strips, at different byte offset start-byte and end-byte locations in the big file, all at the same time concurrently. You can do a regex findall on the bytes, and return the count of linefeeds. This is a partial sum.  Finally sum up the partial sums to get the global sum when the map function returns after the workers finished.Following is some example benchmarks using the parallel byte offset trick:I use 2 files: HIGGS.csv is 8 GB. It is from the UCI machine learning repository.  all_bin .csv is 40.4 GB and is from my current project.I use 2 programs: GNU wc program which comes with Linux, and the pure python fastread.py program which I developed.That’s some 4.5 GB/s, or 45 Gb/s, file slurping speed.  That ain’t no spinning hard disk, my friend. That’s actually a Samsung Pro 950 SSD. Below is the speed benchmark for the same file being line-counted by gnu wc, a pure C compiled program.What is cool is you can see my pure python program essentially matched the speed of the gnu wc compiled C program in this case.  Python is interpreted but C is compiled, so this is a pretty interesting feat of speed, I think you would agree.  Of course, wc really needs to be changed to a parallel program, and then it would really beat the socks off my python program. But as it stands today, gnu wc is just a sequential program.  You do what you can, and python can do parallel today. Cython compiling might be able to help me (for some other time). Also memory mapped files was not explored yet.Conclusion: The speed is good for a pure python program compared to a C program. However, it’s not good enough to use the pure python program over the C program, at least for linecounting purpose. Generally the technique can be used for other file processing, so this python code is still good.Question: Does compiling the regex just one time and passing it to all workers will improve speed? Answer: Regex pre-compiling does NOT help in this application. I suppose the reason is that the overhead of process serialization and creation for all the workers is dominating.One more thing. Does parallel CSV file reading even help?  Is the disk the bottleneck, or is it the CPU?  Many so-called top-rated answers on stackoverflow contain the common dev wisdom that you only need one thread to read a file, best you can do, they say. Are they sure, though?Let’s find out:Oh yes, yes it does. Parallel file reading works quite well.  Well there you go!Ps. In case some of you wanted to know, what if the balanceFactor was 2 when using a single worker process? Well, it’s horrible:Key parts of the fastread.py python program:The def for PartitionDataToWorkers is just ordinary sequential code. I left it out in case someone else wants to get some practice on what parallel programming is like. I gave away for free the harder parts: the tested and working parallel code, for your learning benefit.Thanks to:  The open-source H2O project, by Arno and Cliff and the H2O staff for their great software and instructional videos, which have provided me the inspiration for this pure python high performance parallel byte offset reader as shown above.  H2O does parallel file reading using java, is callable by python and R programs, and is crazy fast, faster than anything on the planet at reading big CSV files.
Katrielalex provided the way to open & read one file.However the way your algorithm goes it reads the whole file for each line of the file. That means the overall amount of reading a file - and computing the Levenshtein distance - will be done N*N if N is the amount of lines in the file. Since you're concerned about file size and don't want to keep it in memory, I am concerned about the resulting quadratic runtime. Your algorithm is in the O(n^2) class of algorithms which often can be improved with specialization.I suspect that you already know the tradeoff of memory versus runtime here, but maybe you would want to investigate if there's an efficient way to compute multiple Levenshtein distances in parallel. If so it would be interesting to share your solution here.How many lines do your files have, and on what kind of machine (mem & cpu power) does your algorithm have to run, and what's the tolerated runtime?Code would look like:But the questions are how do you store the distances (matrix?) and can you gain an advantage of preparing e.g. the outer_line for processing, or caching some intermediate results for reuse.
Open your file for reading (r)Read the whole file and save each line into a list (text)Loop through the list printing each line.If you want, for example, to check a specific line for a length greater than 10, work with what you already have available.
From the python documentation for fileinput.input():This iterates over the lines of all files listed in sys.argv[1:], defaulting to sys.stdin if the list is emptyfurther, the definition of the function is:reading between the lines, this tells me that files can be a list so you could have something like:See here for more information
I would strongly recommend not using the default file loading as it is horrendously slow. You should look into the numpy functions and the IOpro functions (e.g. numpy.loadtxt()).http://docs.scipy.org/doc/numpy/user/basics.io.genfromtxt.htmlhttps://store.continuum.io/cshop/iopro/Then you can break your pairwise operation into chunks:It's almost always much faster to load data in chunks and then do matrix operations on it than to do it element by element!!
Best way to read large file, line by line is to use python enumerate function


Answer URL
https://docs.python.org/3/library/functions.html#open
