Natural Text
The iter function wraps objects like lists or tuples in order to use them as iterators, i.e. one is able to use next, for example. For instance,returns 1.What happens internally if the object we pass to iter is already an iterator? Does it simply return the original object, i.e. no-op? Or does it produce a new iterator wrapping the original one? And by wrapping I don't mean copying the original iterator, of course.
TLDNR: iter returns obj.__iter_. It doesn't return obj "as is".The Cpython implementation of iter is pretty straightforward:So when you call iter(obj) and obj.__iter__ exists it just returns that. Most (all?) built-in iterators have __iter__ = self, e.g.but that's not necessary true for userland objects:
Empirical evidence is nice, but the docs are pretty explicit.Iterators are required to have an __iter__() method that returns the iterator object itselfIf you implement an object with a __next__(), you should have an __iter__() method that returns self. Breaking this rule means you have an object that isn't an iterator but looks like one, which is a recipie for disaster.


Answer URL
https://docs.python.org/3/glossary.html#term-iterator
https://docs.python.org/3/reference/datamodel.html#object.__iter__
