Natural Text
I am currently practicing python multi-thread module, and I write some code as below, but it is not working as I just expect.In my opinion, whether there is time.sleep(1) in the main thread does not count much for the new threads's running, because the lock is global and belongs to the main thread, the lock.acquire() operation would always work fine, so the main thread should not wait for those new threads to proceed. According to the property of thread.start_new(), when the main thread ends, all new threads would also stop. However, when I comment out the time.sleep() line, the program goes as what I have expected, but when I add this line in, the main thread always waits for new threads to finish.This confuses me a lot and hope someone would explain to me the functionality of Rlock() as well as which thread does it belong to when I create it in the main thread while passing it to the sub-new thread and calling lock.acquire()?
A lock belongs to the thread that last did .acquire() it successfully, until it has been .release()d.A RLock, short for re-entrant lock is a lock that can be acquired  many times by the same thread that acquired it initially; the lock stays locked and held by the thread until each acquisition has been released.The re-entrancy means here that the execution enters a section of code guarded by the lock, while the lock is held already.  Your code does not demonstrate a case where a re-entrant lock is needed but suppose you have functions:A non-re-entrant lock would not work there, as the "lock was already locked" in guarded op; the locking would fail in another_op; but RLock works just fine.By the way, you should always use the with statement with locks whenever possible to ensure their orderly release.


Answer URL
https://docs.python.org/3/library/threading.html
