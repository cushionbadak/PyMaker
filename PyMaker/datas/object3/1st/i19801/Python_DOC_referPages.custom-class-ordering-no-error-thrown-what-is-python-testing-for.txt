Natural Text
Without specifying the equality comparison properties of objects, Python is still doing something when using > and <. What is Python actually comparing these objects by if you don't specify __gt__ or __lt__? I would expect an unsupported operand error here, as you get when trying to add two objects together without defing __add__. 
An arbitrary order is imposed for objects. The ordering is only defined to be stable within a program execution.This means it's up to the Python implementation to define an ordering when comparing arbitrary objects. CPython uses the memory address if the types are the same (from the C source):The same value is the basis for the id() function, and is also represented in the default repr() string for custom classes, so it may appear that the repr() of classes determine ordering. It's only the memory address that does.For objects that are not the same type, the type name is used instead (with number-like types sorting before others), and if the types differ but their names are the same, the code falls back to the memory address of the type (as opposed to the memory address of the instance when the types are the same).This implicit ordering has been considered an error in the language, and has been remedied in Python 3:The ordering comparison operators (<, <=, >=, >) raise a TypeError exception when the operands donâ€™t have a meaningful natural ordering.This applies to custom classes that do not implement the necessary ordering hooks:
EDIT: See the update after reading! The completely correct answer is "undefined, but consistent".It's testing repr(me) vs repr(you) which essentially is doing string comparison. Here is an easy to see example:I agree that this seems a little strange to me. Perhaps there's a good reason for this that I am not aware of?UPDATE: I am wrong about repr, though it does look like it uses the base object repr in test. http://docs.python.org/2/reference/expressions.html#not-inThere is a line there that states "The choice whether one object is considered smaller or larger than another one is made arbitrarily but consistently within one execution of a program." In other words, it might be using repr but that's not guaranteed. It will, however, be consistently done.
Python uses the object's repr() if there are no rich comparison operators. (At least, this is valid for Py2; I don't know for Py3).So if you dothe objects are sorted by their repr(), the A() coming first and then the B().


Answer URL
