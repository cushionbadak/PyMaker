Natural Text
Recently I've gone through an existing code base containing many classes where instance attributes reflect values stored in a database. I've refactored a lot of these attributes to have their database lookups be deferred, ie. not be initialised in the constructor but only upon first read. These attributes do not change over the lifetime of the instance, but they're a real bottleneck to calculate that first time and only really accessed for special cases. Hence they can also be cached after they've been retrieved from the database (this therefore fits the definition of memoisation where the input is simply "no input").I find myself typing the following snippet of code over and over again for various attributes across various classes:Is there an existing decorator to do this already in Python that I'm simply unaware of? Or, is there a reasonably simple way to define a decorator that does this?I'm working under Python 2.5, but 2.6 answers might still be interesting if they are significantly different.NoteThis question was asked before Python included a lot of ready-made decorators for this. I have updated it only to correct terminology.
For all sorts of great utilities I'm using boltons.As part of that library you have cachedproperty:
Here is an example implementation of a lazy property decorator:Interactive session:
I wrote this one for myself... To be used for true one-time calculated lazy properties.  I like it because it avoids sticking extra attributes on objects, and once activated does not waste time checking for attribute presence, etc.:Note: The lazy_property class is a non-data descriptor, which means it is read-only. Adding a __set__ method would prevent it from working correctly.
Here's a callable that takes an optional timeout argument, in the __call__ you could also copy over the __name__, __doc__, __module__ from func's namespace:ex:
property is a class. A descriptor to be exact. Simply derive from it and implement the desired behavior.
What you really want is the reify (source linked!) decorator from Pyramid:Use as a class method decorator. It operates almost exactly like the Python @property decorator, but it puts the result of the method it decorates into the instance dict after the first call, effectively replacing the function it decorates with an instance variable. It is, in Python parlance, a non-data descriptor. The following is an example and its usage:
There is a mix up of terms and/or confusion of concepts both in question and in answers so far.Lazy evaluation just means that something is evaluated at runtime at the last possible moment when a value is needed. The standard @property decorator does just that.(*) The decorated function is evaluated only and every time you need the value of that property. (see wikipedia article about lazy evaluation)(*)Actually a true lazy evaluation (compare e.g. haskell) is very hard to achieve in python (and results in code which is far from idiomatic). Memoization is the correct term for what the asker seems to be looking for. Pure functions that do not depend on side effects for return value evaluation can be safely memoized and there is actually a decorator in functools @functools.lru_cache so no need for writing own decorators unless you need specialized behavior.
You can do this nice and easily by building a class from Python native property:We can use this property class like regular class property ( It's also support item assignment as you can see)Value only calculated first time and after that we used our saved valueOutput:


Answer URL
https://docs.python.org/3/howto/descriptor.html#descriptor-protocol
https://docs.python.org/3/library/functools.html
