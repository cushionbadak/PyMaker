Natural Text
How can I pretty print a dictionary with depth of ~4 in Python? I tried pretty printing with pprint(), but it did not work:I simply want an indentation ("\t") for each nesting, so that I get something like this:etc. How can I do this?
I'm not sure how exactly you want the formatting to look like, but you could start with a function like this:
My first thought was that the JSON serializer is probably pretty good at nested dictionaries, so I'd cheat and use that:
You could try YAML via PyYAML.  Its output can be fine-tuned.  I'd suggest starting with the following:print yaml.dump(data, allow_unicode=True, default_flow_style=False)The result is very readable; it can be also parsed back to Python if needed.Edit:Example:
As of what have been done, I don't see any pretty printer that at least mimics the output of the python interpreter with very simple formatting so here's mine :To initialize it :It can support the addition of formatters for defined types, you simply need to make a function for that like this one and bind it to the type you want with set_formater :For historical reasons, I keep the previous pretty printer which was a function instead of a class, but they both can be used the same way, the class version simply permit much more :To use it :Compared to other versions :This solution looks directly for object type, so you can pretty print almost everything, not only list or dict.Doesn't have any dependancy.Everything is put inside a string, so you can do whatever you want with it.The class and the function has been tested and works with Python 2.7 and 3.4.You can have all type of objects inside, this is their representations and not theirs contents that being put in the result (so string have quotes, Unicode string are fully represented ...).With the class version, you can add formatting for every object type you want or change them for already defined ones.key can be of any valid type.Indent and Newline character can be changed for everything we'd like.Dict, List and Tuples are pretty printed.
Another option with yapf:  Output:
As others have posted, you can use recursion/dfs to print the nested dictionary data and call recursively if it is a dictionary; otherwise print the data.
I took sth's answer and modified it slightly to fit my needs of a nested dictionaries and lists:Which then gives me output like:
Sth, i sink that's pretty ;)

I wrote this simple code to print the general structure of a json object in Python. the result for the following datais very compact and looks like this:
pout can pretty print anything you throw at it, for example (borrowing data from another answer):would result in output printed to the screen like:or you can return the formatted string output of your object:Its primary use case is for debugging so it doesn't choke on object instances or anything and it handles unicode output as you would expect, works in python 2.7 and 3.disclosure: I'm the author and maintainer of pout.
Here's something that will print any sort of nested dictionary, while keeping track of the "parent" dictionaries along the way. This is a good starting point for printing according to different formats, like the one specified in OP. All you really need to do is operations around the Print blocks. Note that it looks to see if the value is 'OrderedDict()'. Depending on whether you're using something from Container datatypes Collections, you should make these sort of fail-safes so the elif block doesn't see it as an additional dictionary due to its name. As of now, an example dictionary like will print~altering code to fit the question's format~Using the same example code, it will print the following: This isn't exactly what is requested in OP. The difference is that a parent^n is still printed, instead of being absent and replaced with white-space. To get to OP's format, you'll need to do something like the following: iteratively compare dicList with the lastDict. You can do this by making a new dictionary and copying dicList's content to it, checking if i in the copied dictionary is the same as i in lastDict, and -- if it is -- writing whitespace to that i position using the string multiplier function.
From this link:
I'm just returning to this question after taking sth's answer and making a small but very useful modification. This function prints all keys in the JSON tree as well as the size of leaf nodes in that tree.It's really nice when you have large JSON objects and want to figure out where the meat is. Example:This would tell you that most of the data you care about is probably inside JSON_object['key1']['key2']['value2'] because the length of that value formatted as a string is very large.
I'm a relative python newbie myself but I've been working with nested dictionaries for the past couple weeks and this is what I had came up with.You should try using a stack. Make the keys from the root dictionary into a list of a list:Going in reverse order from last to first, lookup each key in the dictionary to see if its value is (also) a dictionary. If not, print the key then delete it. However if the value for the key is a dictionary, print the key then append the keys for that value to the end of the stack, and start processing that list in the same way, repeating recursively for each new list of keys.If the value for the second key in each list were a dictionary you would have something like this after several rounds:The upside to this approach is that the indent is just \t times the length of the stack:The downside is that in order to check each key you need to hash through to the relevant sub-dictionary, though this can be handled easily with a list comprehension and a simple for loop:Be aware that this approach will require you to cleanup trailing empty lists, and to delete the last key in any list followed by an empty list (which of course may create another empty list, and so on).There are other ways to implement this approach but hopefully this gives you a basic idea of how to do it.EDIT: If you don't want to go through all that, the pprint module prints nested dictionaries in a nice format.
Here's a function I wrote based on what sth's comment. It's works the same as json.dumps with indent, but I'm using tabs instead of space for indents. In Python 3.2+ you can specify indent to be a '\t' directly, but not in 2.7.Ex:


Answer URL
https://docs.python.org/3/library/collections.html
