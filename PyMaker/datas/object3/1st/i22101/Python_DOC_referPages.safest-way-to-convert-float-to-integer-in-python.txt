Natural Text
Python's math module contain handy functions like floor & ceil. These functions take a floating point number and return the nearest integer below or above it. However these functions return the answer as a floating point number. For example:Now f returns:What is the safest way to get an integer out of this float, without running the risk of rounding errors (for example if the float is the equivalent of 1.99999) or perhaps I should use another function altogether?
All integers that can be represented by floating point numbers have an exact representation. So you can safely use int on the result. Inexact representations occur only if you are trying to represent a rational number with a denominator that is not a power of two.That this works is not trivial at all! It's a property of the IEEE floating point representation that int∘floor = ⌊⋅⌋ if the magnitude of the numbers in question is small enough, but different representations are possible where int(floor(2.3)) might be 1.To quote from Wikipedia,Any integer with absolute value less than or equal to 224 can be exactly represented in the single precision format, and any integer with absolute value less than or equal to 253 can be exactly represented in the double precision format.
Use int(your non integer number) will nail it.
You could use the round function.  If you use no second parameter (# of significant digits) then I think you will get the behavior you want.IDLE output.
Combining two of the previous results, we have:This converts a float to an integer fairly dependably.
That this works is not trivial at all! It's a property of the IEEE floating point representation that int∘floor = ⌊⋅⌋ if the magnitude of the numbers in question is small enough, but different representations are possible where int(floor(2.3)) might be 1.This post explains why it works in that range.In a double, you can represent 32bit integers without any problems. There cannot be any rounding issues. More precisely, doubles can represent all integers between and including 253 and -253.Short explanation: A double can store up to 53 binary digits. When you require more, the number is padded with zeroes on the right.It follows that 53 ones is the largest number that can be stored without padding. Naturally, all (integer) numbers requiring less digits can be stored accurately.Adding one to 111(omitted)111 (53 ones) yields 100...000, (53 zeroes). As we know, we can store 53 digits, that makes the rightmost zero padding.This is where 253 comes from.More detail: We need to consider how IEEE-754 floating point works.The number is then calculated as follows (excluding special cases that are irrelevant here):-1sign × 1.mantissa ×2exponent - biaswhere bias = 2exponent - 1 - 1, i.e. 1023 and 127 for double/single precision respectively.Knowing that multiplying by 2X simply shifts all bits X places to the left, it's easy to see that any integer must have all bits in the mantissa that end up right of the decimal point to zero.Any integer except zero has the following form in binary:1x...x where the x-es represent the bits to the right of the MSB (most significant bit).Because we excluded zero, there will always be a MSB that is one—which is why it's not stored. To store the integer, we must bring it into the aforementioned form: -1sign × 1.mantissa ×2exponent - bias.That's saying the same as shifting the bits over the decimal point until there's only the MSB towards the left of the MSB. All the bits right of the decimal point are then stored in the mantissa.From this, we can see that we can store at most 52 binary digits apart from the MSB.It follows that the highest number where all bits are explicitly stored isFor this, we need to set the exponent, such that the decimal point will be shifted 52 places. If we were to increase the exponent by one, we cannot know the digit right to the left after the decimal point.By convention, it's 0. Setting the entire mantissa to zero, we receive the following number:That's a 1 followed by 53 zeroes, 52 stored and 1 added due to the exponent.It represents 253, which marks the boundary (both negative and positive) between which we can accurately represent all integers. If we wanted to add one to 253, we would have to set the implicit zero (denoted by the x) to one, but that's impossible.
math.floor will always return an integer number and thus int(math.floor(some_float)) will never introduce rounding errors.The rounding error might already be introduced in math.floor(some_large_float), though, or even when storing a large number in a float in the first place. (Large numbers may lose precision when stored in floats.)
If you need to convert a string float to an int you can use this method.Example: '38.0' to 38In order to convert this to an int you can cast it as a float then an int. This will also work for float strings or integer strings.Note: This will strip any numbers after the decimal.
Another code sample to convert a real/float to an integer using variables."vel" is a real/float number and converted to the next highest INTEGER, "newvel".
Since you're asking for the 'safest' way, I'll provide another answer other than the top answer.An easy way to make sure you don't lose any precision is to check if the values would be equal after you convert them. If the float is 1.0 for example,  1.0 is equal to 1. So the conversion to int will execute. And if the float is 1.1, int(1.1) equates to 1, and 1.1 != 1. So the value will remain a float and you won't lose any precision.


Answer URL
https://docs.python.org/3/c-api/long.html
