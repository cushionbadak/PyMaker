Natural Text
I know that when a module or even if a specific object in that module is imported -- from foo import bar -- that entire module is evaluated first. But I was just being curious that if we define an __init__ or a __new__ inside that module would it have an specially meaning or treatment like it does inside a class and a package? And why so?
No. There is a module class, and modules are instances of this class, but it's internal to Python. Defining magic methods in a module won't add them to the module class, and they won't do anything special at import time.
Putting it loosely, modules do not have methods.More strictly, each module is an instance of some class, usually builtins.module (although you can replace this with an import hook or by monkeypatching), and that class does of course have methods. But the module's global functions are not methods of the module object.You can verify this pretty easily by just printing out type(foo.func). It's a function, not a bound method of the foo instance.On top of that, even if module global functions were instance methods, that wouldn't make any difference, because __init__ is checked in the class dictionary, not the instance dictionary. If you think about it, there's no way it could possibly be otherwise, because you don't have an instance dictionary to check until __init__ returns. So, this could only possibly work if each module were a class object (and instance of type), which they obviously aren't.Your confusion with __init__.py is a red herring. Files are not functions, much less methods, and neither files nor modules can be called.If you want the rigorous definitions: classes and modules are defined here. As you can see, the __new__ method is a feature specific to classes. Its behavior is defined here. Note that __init__ is actually called as a consequence of object.__new__, so it's not even technically defined for classesâ€”but it certainly isn't defined for anything else.Meanwhile, __init__.py is defined here. (Note that, as of Python 3.2, this is just a convention used by the default importers for regular packages, not actually part of the language itself.)The two features have nothing in common except naming and some vague similarities. Maybe the naming was a mistake, but I think more people get useful intuitions out of the naming than are confused. (At any rate, since it goes back to the ni module for Python 1.3, I doubt it will be changed anytime soon.)
I think you could make a class that had __init__() and/or __new__() methods module-like by doing something similar to what is done in my answer to the unrelated question Can I prevent modifying an object in Python?


Answer URL
