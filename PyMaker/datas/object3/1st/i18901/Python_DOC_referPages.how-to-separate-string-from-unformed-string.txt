Natural Text
I have this format of stringsome of them looks like thisI want to extract value of PERSONNELID,REGION,ACCESS_TYPE,EVENT_TIME_UTCI was going to use split(" ") however READER_NAME and ACCESS_TYPE value has bunch of spacesCan I convert to JSON and search by keyWhat is the way to extract those strings.Thank you in advance
One hack I've found useful in the past is to use shlex.split:And then we can turn this into a dictionary:As @abarnert points out, you can keep more of the information around if you want:Et cetera.  The key point, as he nicely put it, is that the syntax you've shown looks a lot like minimal shell syntax.  OTOH, if there are violations of the pattern that you've shown elsewhere, you might want to fall back to writing a custom parser.  The shlex approach is handy when it applies but isn't as robust as you might want.
Looking for an existing parser is a good idea. If you can find a format that already describes your data, or that you can trivially convert your data into, you win.In this case, converting to JSON seems like it'll be as much work as parsing in the first place.But you're just looking to split into simple value and name=value components, where the value part can be quotedâ€¦ those are the same rules as minimal shell syntax. So, shlex will do it for you:You will still need to separate each name=value pair out into name and value components, but that's just namevalue.split('=', 1). But it's pretty much implicit that you need to do that separately given that you've got some elements that aren't name-value pairs (2013-06-05T11:01:02.955).Of course you can always choose to treat them as name-value pairs with empty values:
Let's analyze the problem: You want to match one of the four identifiers, then an = sign, and then either a quoted string or a sequence of non-whitespace characters.That's a perfect job for a regular expression:Explanation:\b makes sure that the match starts at a word boundary."[^"]*" matches a quote, followed by any number of non-quote characters, and another quote.\S+ matches one or more non-whitespace characters.By enclosing the "interesting" parts of the regex in parentheses, building capturing groups, you get a list of tuples for each part of the match separately.


Answer URL
