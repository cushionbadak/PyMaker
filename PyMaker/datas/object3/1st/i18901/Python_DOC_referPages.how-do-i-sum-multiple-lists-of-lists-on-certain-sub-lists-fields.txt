Natural Text
I have 3 lists-of-lists.The sub-lists' field 1 is a name, field 2 is a number, and field 3 is a number. This format is always the same, and doesn't change. There are always the same names in the 3 lists; however, the order may not be the same.I would like a result (any object type) with the sum of fields 2 & 3 of the lists' sub-lists.In pseudo Python3 code, I'm guessing it'd look like this, but I cannot figure out the correct way to do it in Python3. Let alone doing it in a Pythonic way:Any ideas? What built-in Python tools can help me with this?
To illustrate why using the right data structures makes things a lot easier…Let's say that a, b, and c were actually dicts, and your numbers were actually ints instead of strs. After all, the whole point of a dict is to look things up by name, and the whole point of an int is to be able to do arithmetic. So:Now, all you have to do is this:And the result is:There's still a bit of room for improvement—you can use a defaultdict to get rid of the if not k in result: bit—but even with just novice-level stuff this is pretty compact and simple.But what if you got those lists as input—you'd like to have nice dicts in the end, but you don't start there?You can write a function to convert them, like this:And if you spot the familiar values = []… for value in … values.append(…) pattern, you can turn that into the simple list comprehension [int(value) for value in element[1:]]. And then the whole thing is the dict equivalent of the same pattern, so you can reduce all of it to:Meanwhile, if you need to convert back to the original form, that's just:
This seems to give what you want using more pythonic list comprehensions.If you want it to work with out of order names, you could do something like thisDon't judge me.  I don't really write code like that.
Recursive's answer is the most compact reasonable way to do this, and Ashwini Chaudhary's is the most flexible and conceptually nicest… but if you want to know how to make your almost-code work:The key thing you're missing is "How do I iterate over two lists in lock-step?" That's exactly what zip is for. Just zip the two lists together, and you get this:(Except it's an iterator, not a list.)The rest of your code pretty much works, except that you got a bit confused about the names. Here's a fixed-up version.Except that you're summing up a bunch of strings. That's perfectly legal, but what it gets you is this:You probably wanted to convert these values to int at some point. If not, if you want to convert to int, sum, and convert back to str, that's pretty trivial:Once you've got this, there are a number of ways you can improve it.For example, you can always replace a results = [], for loop, and result.append(…) with a list comprehension once you recognize that you've hit the exact pattern a comprehension is for:Or, you can generalize it to work on all three lists together, or even any number of lists—zip already does that, and you can just replace the + with sum:                              sum(element[2] for element in elements)]            result.append(result_element)        return resultOr you can make it work for 0 or more numbers instead of exactly two, or not depend on ordering, etc. When you take it far enough, step by step, you'll end up with something like one of the two other answers.
Using dict, this will work for unordered items as well:
Once again, list comprehension will do the trick:But don't forget what the Zen of Python says: Readability counts. You should avoid one-liners if they require too much time to be understood.
Since you state any result type is accepted, here is a form that returns a dict, which I think is an appropriate return type for this sort of work:RETURNSThere's certain to be more compact and perhaps performant options, but the plus to this approach (I believe!) is that it does seem readable.


Answer URL
