Natural Text
There is this code:In both function bodies there is used variable m which is not defined when used but the error messages are different. Do Python know what variables are defined in function before using them (like in function f)? Why the error messages are different?
If there is an assignment to a variable anywhere in a function, then it is considered a local variable everywhere in that function.  This means that for the function f(), even though the assignment to m happens after the attempt to access m, the line x = m will only look for the name m within the local scope.  This is why the error message for f() refers to m as a local variable.In the function g() there is no assigment to m, so the line x = m will look for m using the order described here:the innermost scope, which is searched first, contains the localnamesthe scopes of any enclosing functions, which are searched starting with the nearest enclosing scope, contains non-local, but also non-global namesthe next-to-last scope contains the current moduleâ€™s global namesthe outermost scope (searched last) is the namespace containing built-in namesThe error message for g(), "global name 'm' is not defined", refers to the global scope because that is the last location that was searched (except built-in, but it would be confusing to have a message like "the name 'm' was not found in the built-in namespace").Note that you can use the global or nonlocal statements to change this behavior (nonlocal only exists in Python 3.x).
Python checks it as soon as you call it.When importing, and typing directly into the interpreter, it only cares if you broke any syntax rules. it doesnt care about locals or globals at this level.it runs from top to bottom, and checks locals() and globals() if it sees that variable then its okay and does whatever with it.it even works with definitions and sub definitions.. or anything else you are assigning
Yes. If you assign to a variable at any point in a function (without using the global keyword), Python treats all references to that name in the function as local.
When you execute a function, you actually invoke __call()__ on a function object.The function object is created in the scripts global namespace when the script is parsed.Created, but not executed.As part of the parsing process, the objects namespace is computed. So the interpreter can actually know which variable exists and when.
When the above function parsed python thinks that m is  local variable as it finds m = 2, so when the function is actually called x = m will raise error as m is not defined yet in local scope.In this python thinks that m is going to be some value from the global scope, it searches the global namespace first and then built-ins, but when m is not found anywhere the error is raised.To modify a global variable use global:
You need to use global m inside the function


Answer URL
