Natural Text
Trying to get the SSL certificate from a response in requests.What is a good way to do this?
requests deliberately wraps up low-level stuff like this. Normally, the only thing you want to do is to verify that the certs are valid. To do that, just pass verify=True. If you want to use a non-standard cacert bundle, you can pass that too. For example:Also, requests is primarily a set of wrappers around other libraries, mostly urllib3 and the stdlib's http.client (or, for 2.x, httplib) and ssl. Sometimes, the answer is just to get at the lower-level objects (e.g., resp.raw is the urllib3.response.HTTPResponse), but in many cases that's impossible. And this is one of those cases. The only objects that ever see the certs are an http.client.HTTPSConnection (or a urllib3.connectionpool.VerifiedHTTPSConnection, but that's just a subclass of the former) and an ssl.SSLSocket, and neither of those exist anymore by the time the request returns. (As the name connectionpool implies, the HTTPSConnection object is stored in a pool, and may be reused as soon as it's done; the SSLSocket is a member of the HTTPSConnection.)So, you need to patch things so you can copy the data up the chain. It may be as simple as this:That's untested, so no guarantees; you may need to patch more than that. Also, subclassing and overriding would probably be cleaner than monkeypatching (especially since HTTPAdapter was designed to be subclassed).Or, even better, forking urllib3 and requests, modifying your fork, and (if you think this is legitimately useful) submitting pull requests upstream.Anyway, now, from your code, you can do this:This will give you a dict with 'subject' and 'subjectAltName' keys, as returned by pyopenssl.WrappedSocket.getpeercert. If you instead want more information about the cert, try Christophe Vandeplas's variant of this answer that lets you get an OpenSSL.crypto.X509 object. If you want to get the entire peer certificate chain, see GoldenStake's answer.Of course you may also want to pass along all the information necessary to verify the cert, but that's even easier, because it already passes through the top level.
To start, abarnert's answer is very complete. While chasing the proposed connection-close issue of Kalkran I actually discovered that the peercert didn't contain detailed information about the SSL Certificate.I dug deeper in the connection and socket info and extracted the self.sock.connection.get_peer_certificate() function which contains great functions like:get_subject() for CNget_notAfter() and get_notBefore() for expiration datesget_serial_number() and get_signature_algorithm() for crypto related technical details ...Note that these are only available if you have pyopenssl installed on your system. Under the hood, urllib3 uses pyopenssl if it's available and the standard library's ssl module otherwise. The self.sock.connection attribute shown below only exists if self.sock is a urllib3.contrib.pyopenssl.WrappedSocket, not if it's a ssl.SSLSocket. You can install pyopenssl with pip install pyopenssl.Once that's done, the code becomes:You will be able to access the result easily:If, like me, you want to ignore SSL Certificate warnings just add the following in the top of the file and do not SSL verify:
This, although not pretty at all, works:
To start, abarnert's answer is very completeBut I would like to add, that in the case you're looking for the peer cert chain, you would need to patch yet another piece of codeafter that you can call it in a very similiar manner as the accepted answeryou will get resp.peercertchain which contains a tuple of OpenSSL.crypto.X509 objects
Thanks for everyone's awesome answers.It helped me over engineer an answer to this question:How to add a custom CA Root certificate to the CA Store used by Python in Windows?UPDATE 2019-02-12Please take a look at Cert Human: SSL Certificates for Humans for an impressive rewrite of my https://github.com/neozenith/get-ca-py project by lifehackjim.I have archived the original repository now.Stand alone snippet


Answer URL
