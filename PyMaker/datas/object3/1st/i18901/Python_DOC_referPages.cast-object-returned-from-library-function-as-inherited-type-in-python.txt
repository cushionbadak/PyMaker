Natural Text
The library I'm using has a function that returns an object of type A.I have a class, B, that inherits from A. I want the constructor of B to call the library function and wrap the A object that is returned. I saw the answer to a different question that did this:Is there a better way to do this?
Would just forwarding all attribute accesses that B doesn't provide to A work for your purposes? I.e. like this:That said, this has a few caveats. For one, B can't inherit from A, which would foil instanceof checks. Also, most __magic__ methods will require wrapping manually as well.
Instead of adding functionality by attempting to inherit from A, just monkey-patch the instance of A returned by the_lib.lib_function().  For example:This will give you a function that you can use like a class to return instances of A as returned by the_lib.lib_function(), but those instances will also include my_method.
Here are some alternatives to what you're trying to do.If you just need my_method to access attributes of the A instance, you don't need to do anything. Python has no "private attributes"; there is no difference between accessing an attribute via the self argument vs. accessing it via any other argument. So:If you really want to attach the method to a as a bound method, you can do that without having to monkey about with classes:If you really do need to wrap the A instance, it's often better to do it by delegation than by inheritance. Whether you do this by statically delegating the methods you need, dynamically building the delegation methods right after the class definition, dynamically building them at construction time, or just using __getattr__ to do it on the fly depends on your actual needs.If you want B to act as a subclass of A even though it isn't one, you can use ABCs to fool isinstance, etc.Or you can even turn the B instance into an A instance (e.g., by changing its __class__)â€”but keep in mind that this will make it use A's implementations of most dunder methods (including __getattr__).If you really want B to be a subclass, you can write an __init__ constructor (or a classmethod alternate constructor) that copies over the attributes. Again, you can do this with a static set of attributes, or dynamically (just remember that __dict__ doesn't handle __slots__, dynamic __getattr__ attributes, @property and similar fake attributes, some attributes inherited from builtin/extension classes, etc.).So, which one is right?Without knowing what you're actually trying to accomplish, it's impossible to answer that. All of these are right in some cases, although some of them are right far more rarely than others.


Answer URL
