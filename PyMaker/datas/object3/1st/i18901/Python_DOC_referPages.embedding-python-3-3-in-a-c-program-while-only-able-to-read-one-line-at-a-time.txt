Natural Text
I am currently working on adding embedded Python support (and yes, extending is not an option) to a large program as part of my summer internship. Ideally, I can keep the Python support within a single .DLL, which currently contains the program's in-house scripting language and is the easiest place to integrate said language and Python.However, due to the program's API, I only have a single input function to use. This function's return value is a single line from the current input, which could be the console or a file. The input interface cannot (within the .DLL) be converted into a stream object, buffer, or FILE pointer.My current test code (written outside of the program, using std::string, istream, and getline to ape the restriction) isI have not encountered serious problems with this hack, but it strikes me as woefully inelegant. Can anyone think of a better way to do this?I have already cleared the boost.python libraries with my boss, if that offers some useful trick that eluded me.EDIT: I should probably mention the program itself, while not my meagre testbed, must run on MS Windows.
What you've written is going to look superficially similar to the stock interpreter, but it won't follow the same indent/dedent and continuation rules for any but the most trivial cases.The easiest way to embed an interactive interpreter shell is to embed a bare interpreter that runs an interactive interpreter written in pure Python, usually via the code module.For that to work, you will have to hook up your line-by-line reader to the embedded stdin file object, but it seems like for any realistic use you're going to want that anyway. (Otherwise, what's going to happen if, e.g., the user types input() at the shell?)An alternative is to set up a pty and run the stock interactive interpreter against that (possibly as a child process), feeding the pty's input pipe from your line reader.


Answer URL
