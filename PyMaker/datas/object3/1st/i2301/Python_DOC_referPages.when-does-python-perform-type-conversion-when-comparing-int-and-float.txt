Natural Text
Why does Python return True when I compare int and float objects which have the same value?For example:
Objects of different types, except different numeric types, never compare equal. And:Python fully supports mixed arithmetic: when a binary arithmetic operator has operands of different numeric types, the operand with the “narrower” type is widened to that of the other, where integer is narrower than floating point, which is narrower than complex. Comparisons between numbers of mixed type use the same rule.https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complexThe comparison logic is implemented by each type's __eq__ method. And the standard numeric types are implemented in a way that they support comparisons (and arithmetic operations) among each other. Python as a language never does implicit type conversion (like Javascript's == operator would do implicit type juggling).
10 == 10.0 translates to a call to (10).__eq__(10.0) (or even more formally, int.__eq__(10, 10.0)). The implementation of int.__eq__ can handle comparisons to other types, but there is no type conversion at the language level.
The simple answer is that the langue is designed this way. Here is an excerpt from the documentation supporting this:6.10.1 Value ComparisonsNumbers of built-in numeric types (Numeric Types — int, float, complex) and of the standard library types fractions.Fraction and decimal.Decimal can be compared within and across their types, with the restriction that complex numbers do not support order comparison.In other words, we want different numeric types with the same value to be equal.PEP 20Special cases aren't special enough to break the rules.Although practicality beats purity.What benefit is there to making numeric types not comparable, besides making life difficult in most common cases?
You can have a look at the source code for the CPython implementation.The function is preceded by this comment explaining how the conversion is attempted:Other implementations are not guaranteed to follow the same logic.
From the documentation:Python fully supports mixed arithmetic: when a binary arithmetic  operator has operands of different numeric types, the operand with the  “narrower” type is widened to that of the other, where plain integer  is narrower than long integer is narrower than floating point is  narrower than complex. Comparisons between numbers of mixed type use  the same rule.According to this 5*2 is widened to 10.0 and which is equal to 10.0If you are comparing the mixed data types then the result will be considered on the basics of data type which is having long range, so in your case float range is more then int float max number can be  --> 1.7976931348623157e+308int max number can be --> 9223372036854775807Thanks
The == operator compares only the values but not the types. You can use the 'is' keyword to achieve the same effect as using === in other languages. For instancereturns    False
is a comparison operatorYou are actually asking the interpreter if both sides of your expression are equal or not.In other words you are asking for it to return a Boolean value, not to convert data types. If you want to convert the data types you will have to do so implicitly in your code.


Answer URL
https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex
https://docs.python.org/3/reference/datamodel.html#object.__eq__
https://docs.python.org/3/reference/expressions.html#value-comparisons
https://docs.python.org/3/reference/datamodel.html#object.__eq__
https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex
https://docs.python.org/3/reference/expressions.html#value-comparisons
