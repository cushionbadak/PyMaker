Natural Text
Environment:Hi everyone,I'm trying to determine if an object is a function. And I do this with the types library, the code I wrote is like the following.The first function "is_function" dosn't works on class methods. So, I wrote the second function "is_classmethod". And I read the code of the types library in order to find something like "ClassmethodType", but I found the following code, so the type I'm using in the second function is "type(cls.is_classmethod)".Then, I did some experiment with it:These 2 functions work as expected. But, when I pass datetime.datetime.now into these functions, both of them return False.And I already read the code of datetime library before doing this, datetime.datetime.now is definitely a class method.I cannot even imagine about this, how could it be? The second function has already been proven, it do detects class methods and I found nothing special on datetime.datetime.now, it just a normal classmethod.So, what caused this?
Your code doesn't detect datetime.now as a classmethod because that method is implemented in C.The method definition you found in datetime.py is only used as a fallback if the C implementation of the datetime module isn't available. On the bottom of datetime.py, you'll find this import that attempts to import the C implementation:So the class and method you've found simply aren't used.Methods implemented in C do not use the @classmethod decorator, so your function's isinstance(...) check will never succeed. In order to detect a method written in C, you have to make use of the various types defined in the types module:BuiltinMethodTypeWrapperDescriptorTypeMethodDescriptorTypeClassMethodDescriptorTypeMethodWrapperType (for bound dundermethods)datetime.now happens to be an instance of BuiltinMethodType:But if you want to detect all kinds of classmethods, you should check against all of the aforementioned types:However, you must be aware that there is no difference between functions and methods if they're defined in C. As such, it is impossible to detect classmethods reliably:
It doesn't sound like you're really after a type check. It seems like what you're really looking for is a way to determine whether an object is callable, and the way to do that is with the built-in function callable:Regular function, C function, C method, slot wrapper, NumPy ufunc, whatever, if it can be called, callable will return True. Checking types is too sensitive to implementation details; Python has too many function and function-like types, and any library can introduce new ones. Also, the descriptor protocol means that you don't actually get a classmethod object when you try to access a classmethod, so the idea of testing for classmethods is kind of questionable in the first place.


Answer URL
https://docs.python.org/3/library/types.html
https://docs.python.org/3/library/types.html#types.BuiltinMethodType
https://docs.python.org/3/library/types.html#types.WrapperDescriptorType
https://docs.python.org/3/library/types.html#types.MethodDescriptorType
https://docs.python.org/3/library/types.html#types.ClassMethodDescriptorType
https://docs.python.org/3/library/types.html#types.MethodWrapperType
https://docs.python.org/3/library/functions.html#callable
https://docs.python.org/3/reference/datamodel.html#descriptors
