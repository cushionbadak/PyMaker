Natural Text
My solution is at the bottom of the question, based on MisterMiyagi's exampleI wasn't sure how best to phrase the title. My idea is the following. I have an abstract base class with some implementations. Some of these implementations refer to eachother as part of their logic, simplified as follows:Now I want to use these classes somewhere, let's say in another module. However I want to add some extra functionality (for example a function g) to all classes in the hierarchy. I could do that by adding it to the base class X, but I want to keep the functionality defined separately. For example I might want to define the new functionality like this:This creates another base class with the new functionality, but of course doesn't add it to the existing implementations X1 and  X2. I'd have to use diamond inheritance to get that:The above works correctly, but there is still a problem. In X2.__init__, an instance of X1 is created. For my idea to work this would have to become Y1 in Y2.__init__. But this is of course not the case:I think what I might be looking for is a way to turn X into an abstract metaclass, such that its implementations require a 'base' parameter to become classes, which can then be instantiated. This parameter is then used within the class to instantiate other implementations with the correct base.Creating an instance with the new functionality in the base class would then look something like this:Which would result in an object equivalent to an instance of the following class:However I don't know how to create a metaclass that would do this. I'd like to hear whether a metaclass is the right idea and, if so, how to do it.SolutionUsing MisterMiyagi's example I was able to get something that I think will work. The behaviour is close to the metaclass idea that I had.Usage is like this:
Since you are looking at a way to customise your classes, the easiest approach is to do just that:Since component_type is a class attribute, it allows to specialise different variants (read: subclasses) of the same class.Note that you can of course use other code to construct such classes. Classmethods can be used to create new, derived classes.Say that for example your classes are capable of picking the correct subclasses from their hierarchy.Since Python3.7, it is possible to use __class_getitem__ to write the above as Y2 = X2[Y], similar to how Tuple can be specialised to Tuple[int].Class attributes often serve the functionality of metaclass fields, since they express precisely that. In theory, setting a class attribute is equivalent to adding a metaclass field, then setting it as an attribute for each class. What is exploited here is that Python allows instances to have attributes without classes defining their fields. One can think of class attributes as duck-typing metaclasses.
You problem is one that arrives quite often, namely that you want to change the behavior of an existing class.  The one aspect you can achieve by inheriting it and adding your new behavior.  All instances you then create of this subclass have the new behavior.But you also want that someone else (in this case it's X2) who creates further instances of this class now instead creates instances of your own subclass with the added behavior instead.This can be considered to be meddling in the affairs of someone else.  I mean, if the class X2 wants to create an instance of X1, who are you (a mere user of X2!) to tell it that it shall instead create something else??  Maybe it doesn't work properly with something which is not of type X1!Butâ€”of course.  Been there.  Done that.  I know that sometimes this need arises.The straight way to achieve this is to make the class X2 cooperate.  That means, instead of creating an instance of the class X1 it could instead create an instance of a class passed as parameter:This could also be nicely embedded using method overriding instead of parameter passing:and then in the other module:But all this just works if you can change the X2, and in some cases you cannot do this (because the module of the X is third-party provided or even a builtin library, so effectively read-only).In these cases you can consider monkey-patching:Similar solutions can be approached using mocks as known from unit test modules.  but all these have in common that they are applied to intimate details of the current implementations of the used classes.  As soon as these change, the code breaks.So if you can, it's way better to prepare the base classes (X2) to your project and make it more flexible for your use case.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__class_getitem__
