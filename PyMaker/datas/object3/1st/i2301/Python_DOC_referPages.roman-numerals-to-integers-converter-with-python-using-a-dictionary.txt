Natural Text
I'm learning to code and I had an exercise to make a converter of roman numerals to integers. I realize there are a lot of different ways to write this program, but I would appreciate it if you could help me find my mistake. I'd love to hear suggestions on how to write it better, but what I really could use right now is understanding what I did wrong with this one.I have a dictionary called roman_numerals. Its keys are the roman numeral values, and its values are their matching integer.When I run my code,if I use a numeral that is equal to a key of more than one character ("IV" for example) I get a result that is an addition of both "IV" and "V". or "CM" and "M".I know why it happens, because I asked for an iteration. But, can I ask my program to stop iterating when it returns a value? I feel like I'm really close to the solution, but I'm just confused at this point.Thank you!
You have to make sure that you consume all characters that contribute to the sum. Since all the multi-char "atomic" literals begin with the lower valued unit, and otherwise, higher valued units come first, a simple greedy approach is workable:Try to convert the first two chars as a whole, if that's not possible, convert the first single char.  Move forward the appropriate number of steps.
It might be better to represent the values as a list of tuples, since this allows us to define an order in them, and therefore we can avoid matching 'I' in case the string contains at that point 'IX'. So we can define the conversion as:Note that you forgot to use IX, this makes it to some extent problematic, since it will interpret IX as 11.Now we can process the string by each time performing a str.startswith() [Python-doc] check, and from the moment we found a prefix, add the corresponding value, and advance the offset of the string, like:We thus enumerate through the string, and each time look to match a Roman numeral. For example:The system will also error if for example we enter invalid characters:The above is however not very efficient: each time we enumerate roman_literals until we find the match. But once we are processing the "fifties" (L), then we know that we will never parse "thousands" (M) again. We can boost performance by remembering the index in the roman_numerals:This again yields the results we expect:But is also stricter, for example CMM is not a valid Roman numeral, whereas MCM is:
There is no need to loop through the dictionary. My code is slightly different but I have tried to keep as much of your code as possible.
Another way to look at it I guess
Count the number of occurences of each numeral in string instead of checking string for occurrences, then just remove the occurrences where double letters such as CM appear so remove nulber of occurrences of CM * value of C and M 


Answer URL
https://docs.python.org/3/library/stdtypes.html#str.startswith
