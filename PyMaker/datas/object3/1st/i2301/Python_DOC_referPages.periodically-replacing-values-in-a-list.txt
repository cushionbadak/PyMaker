Natural Text
Suppose I have the following list in Python:Given n, I want to replace any other m elements with zero in my list, while keeping the next n elements. For example, if n = 3 and m = 2, I want my list to look like:If it can't be filled perfectly, as is the case with n = 4 and m = 2, then it's OK if my list looks like this:How should I try to solve this problem?
This just needs m assignments to do the job (and m probably is small).If you really just have two possible values (e. g. 10 and 0), you can do it even simpler:But that iterates in Python over the whole range of 95, so probably is not very fast.A bit more complex but probably more efficient (especially for huge lists and large values for n and m) would be this:But it builds internally lots of lists, so its up to tests to find out whether this is efficient in your case.  (Also memory consumption should be taken into account for large lists.)If you can use numpy (a bit off the question, but since it's widespread):
You could use itertools.cycle to create an endless sequence of [10, 10, 10, 0, 0] and then take the first 95 elements of that sequence with itertools.islice:
Yet another possibility, this time with enumerate:It uses the fact that False and True are equal to 0 and 1 in Python (see here).As a bonus, it works fine even if the list isn't constant:If the list contains strings, it replaces them with an empty string instead of 0:
This worked for me:which outputs:The code takes n and m and constructs a mask of ones and zeros with a length matching your initial list using the np.tile function. Afterwards you just multiply the mask onto the list and get the zeros where you want them to be. It should also be flexibel to different lengths of the list and an (almost) arbitrary choice of n and m.You can cast the array back to a list if you want.
How about this?Edit I found out that the above code changes the length of resulting list in some cases.Thus, the length should be restored somehow.
numpy can do this pretty concisely, too!
Maybe?Result
Also in the itertools family, you  can repeat a desired pattern:GivenCodeTestHowever, @Aran-Fey's itertools.cycle solution is cleaner as it does not require chaining.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.cycle
https://docs.python.org/3/library/itertools.html#itertools.islice
https://docs.python.org/3/library/functions.html#enumerate
https://docs.python.org/3/library/itertools.html#itertools.repeat
https://docs.python.org/3/library/itertools.html#itertools.cycle
