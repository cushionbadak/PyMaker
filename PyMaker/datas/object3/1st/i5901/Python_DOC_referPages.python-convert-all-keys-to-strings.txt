Natural Text
I have nested dictionary that has some numeric keys. I need to store this dictionary as JSON and since these keys are numeric, I cant store them as JSON. I wrote the code below but it gives me the error saying the length of the dictionary has changed (RuntimeError: dictionary changed size during iteration). How do I avoid this? The dictionary that I have is -EDITAdding an image of the errorEDIT-2I got serialization errors ebfore for using numpy objects. So I began,using this encoder to convert them to python objects.I have been doing the json.dump while using cls = CustomEncoder. This is the command I had used 
You'll need to recursively convert all keys; generate a new dictionary with a dict comprehension, that's much easier than altering the keys in-place. You can't add string keys and delete the non-string keys in a dictionary you are iterating over, because that mutates the hash table, which can easily alter the order the dictionary keys are listed in, so this is not permitted.You should not forget to handle lists; they too can contain further dictionaries.  Whenever I need to transform a nested structure like this, I'd use the @functools.singledispatch decorator to split out handling for the different container types to different functions:Then JSON encode the result of keys_to_string():Not that this is all needed. json.dumps() accepts integer keys natively, turning them to strings. Your input example works without transforming:From the json.dumps() documentation:Note: Keys in key/value pairs of JSON are always of the type str. When a dictionary is converted into JSON, all the keys of the dictionary are coerced to strings. As a result of this, if a dictionary is converted into JSON and then back into a dictionary, the dictionary may not equal the original one. That is, loads(dumps(x)) != x if x has non-string keys.This only applies to types that JSON could otherwise already handle, so None, booleans, float and int objects. For anything else, you'd still get your exception. You probably have an object whose representation is 0, but it is not a Python int 0:I picked a numpy integer type because that's a commonly confused integer value that is not a Python int.A custom encoder, as you added to your post, won't be used for keys; that only applies to values in dictionaries, so if you have non-standard objects for keys, then you indeed still need to use the above recursive solution.
json.dumps automatically turn interger indexes to string indexes


Answer URL
https://docs.python.org/3/library/functools.html#functools.singledispatch
https://docs.python.org/3/library/json.html#json.dumps
