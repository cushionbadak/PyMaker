Natural Text
There's a class in a library I'm using that I want to override. It looks like this, and I can't change it:In my child class, I want data to behave differently based on rules that apply at runtime:Unfortunately, this doesn't work, for at least two reasons:1) super().data doesn't seem to actually work for accessing the version of data that's defined on A.2) A.__init__ crashes on the self.data = {} line, because it can't assign to the version of data that B defines.3) Theoretically, even if I could get this to work, the loop in A.__init__ would also not work, because it's getting data in order to assign key/value pairs inside it. But doing that get will result in the @property being accessed, and returning a different object than A.data, meaning that A.data won't be altered.I can't edit A, and I need the @property to have the same name as the original dict attribute, because various other code in the library accesses data, and that code also can't be changed.I also can't really override A.__init__ to make it not mess with data, because I need Q.__init__ to run.Is there any viable way to do what I'm trying to do, here?
Property objects are data descriptor objects that live on the class, while your base class uses data as an instance attribute. By making it a property in the subclass, any and all access to self.data will now address the property, even in methods defined on the base class. And as super() addresses attributes (including descriptors) only on the specific parent class, super().data will fail; there is no such class attribute on the base class.That means that the linewill trigger your data property setter, which tries to address a class attribute on a parent class that doesn't exist. Note that even if it did exist, you cant assign to a super()-bound object; super() only supports the __get__ method on descriptors, it does not support the __set__ or __delete__ hooks required mutating attributes; so super().data = ... fails doubly here.Every read access will trigger the getter, sowill call the getter each time, returning the result, then assigning to a key in the resulting dictionary. Because your getter creates a new dictionary each time, that assignment is lost entirely; the result of the dict comprehension is not referenced anywhere else, so after the key-value pair is assigned, the dictionary is garbage collected, changes and all.You'll need to redirect storage of that dictionary to a new instance attribute, and mutate the dictionary in-place (so that a reference is retained at all times):So now the property uses an instance attribute _data. Assignment to self.data will trigger the setter, which redirects the new dictionary produced from the value to self._data instead. The getter removes unwanted keys, keeping the same dictionary object so that any other references to it are still valid, and assignments of new values to keys will end up in the right place.The filtering uses a set intersection with the dictionary view on the keys; this produces a new set so the loop only iterates on keys actually present in both.


Answer URL
https://docs.python.org/3/howto/descriptor.html
https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects
