Natural Text
Given a string (e.g.,  jaghiuuabc
There's a nice example in the Python 2.6 itertools docs that shows how to find consecutive sequences. To quote:Find runs of consecutive numbers using groupby.  The key to the  solution is differencing with a range so that consecutive numbers all  appear in same group.For some strange reason, that example is not in the later versions of the docs. That code works for sequences of numbers, the code below shows how to adapt it to work on letters.outputHow it worksThe heart of this code is enumerate(s) generates tuples containing the index number and character for each character in s. For example:outputgroupby takes items from a sequence or iterator and gathers adjacent equal items together into groups. By default, it simply compares the values of the items to see if they're equal. But you can also give it a key function. When you do that, it passes each item to the key function and uses the result returned by that key function for its equality test.Here's a simple example. First, we define a function div_by_10 that divides a number by 10, using integer division. This basically gets rid of the last digit in the number.outputSo if we use div_by_10 as the key function to groupby it will ignore the last digit in each number and thus it will group adjacent numbers together if they only differ in the last digit.outputMy keyfunc receives a (index_number, character) tuple and subtracts that index_number from the character's code number and returns the result. Let's see what that does with my earlier example of 'ABCEF':outputThe code number for 'A' is 65, the code number for 'B' is 66, the code number for 'C' is 67, etc. So when we subtract the index from the code number for each of 'A', 'B', and 'C' we get 65. But we skipped over 'D' so when we do the subtractions for 'E' and 'F' we get 66. And that's how groupby can put 'A', 'B', & 'C' in one group and 'E' & 'F' in the next group.This can be tricky stuff. Don't expect to understand it all completely straight away. But if you do some experiments yourself I'm sure it will gradually sink in. ;)Just for fun, here's the unreadable multiply-nested list comprehension version of that code. ;)Here's another version which was inspired by Amit Tripathi's answer. This one doesn't use any imports because it does the grouping manually. prev contains the codepoint number of the previous character. We initialize prev to -2 so that the first time the if i != prev + 1 test is performed it's guaranteed to be true because the smallest possible value of ord(ch) is zero, so a new empty list will be added to groups.output
This can be done easily with pure PythonPython 3(should work with Python 2 also) implementation. A simple 8 linerord converts char to equivalent ASCII numberchr converts a number to equivalent ASCII charsetdefault set default value as list if a key doesn't exists
What about some recursion without any external module ?output:


Answer URL
https://docs.python.org/3/library/functions.html#enumerate
https://docs.python.org/3/library/itertools.html#itertools.groupby
https://docs.python.org/3/library/itertools.html#itertools.groupby
https://docs.python.org/3/library/functions.html#enumerate
