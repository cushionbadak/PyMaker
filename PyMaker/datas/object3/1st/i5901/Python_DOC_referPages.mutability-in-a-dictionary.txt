Natural Text
How come my curr_value is not mutating from mydict? I did not clone curr_value or anything.
There is no way to create a plain variable that "updates" itself when some other data structure is updated.  That kind of behavior can only be achieved with kind of expression, like an attribute or item lookup.  In other words, you can make an object curr_value so that evaluating curr_value[0] gives you the value of mydict[1][45] at that moment, or evaluating curr_value.value gives you the value of mydict[1][45] at that moment, but you cannot make it so that evaluating just plain curr_value gives you the value of mydict[1][45] at that moment.  Doing curr_value = mydict[1][45] always sets the curr_value to what it is at the moment you assign it, and it will not be updated later if mydict[1][45] changes.
Output: Your dictionary is mutable - it was mutated. The curr_value is a string and not mutable.Midly annoing idea:This just encapsules remembering the point inside the dict you want to reference and the funtion gets you the value of the dict at the moment you call it.
What you want isn't possible because simple assignment always creates a new binding (i.e., binds the new object to the name on the LHS of the = sign). OTOH, performing a mutation doesn't create a new binding, so you can do, eg which prints zzzz as desired.This topic is covered nicely by Stack Overflow veteran Ned Batchelder in Facts and myths about Python names and values, and summarized in Other languages have "variables", Python has "names".Another option is to do Generally it's best to avoid creating clutter like that, but sometimes that sort of thing is useful. For example, by adding an extra layer of indirection to a 2D list we can make it accessible via columns as well as via rows.outputAt the start of this answer I stated that "simple assignment always creates a new binding". However, augmented assignment will perform an in-place operation when that is possible, i.e. the target is a mutable object. From the docs:An augmented assignment expression like x += 1 can be rewritten as  x = x + 1 to achieve a similar, but not exactly equal effect. In the  augmented version, x is only evaluated once. Also, when possible, the  actual operation is performed in-place, meaning that rather than  creating a new object and assigning that to the target, the old object  is modified instead.


Answer URL
https://docs.python.org/3/reference/simple_stmts.html#augmented-assignment-statements
https://docs.python.org/3/library/operator.html#operator.itemgetter
