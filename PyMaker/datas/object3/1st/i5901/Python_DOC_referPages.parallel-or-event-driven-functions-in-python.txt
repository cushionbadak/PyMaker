Natural Text
I'm fairly new to Python, so maybe my whole concept of how this should Work is wrong:I'm building a RFID Reader for time managing purposes. E.g. User logs in with RFID chip -> Timer Starts counting and updating a Google  spreadsheet every Minute. The updating part works fine, but takes a little while. But I want to Check for RFID Logins all the time. Somewhere  I read that Event driven Programming is what I'm looking for.Currently I'm doing everything in a while true loop, which feels like a hack itself. Can i somehow just execute my code when the RFID reader sends a signal? And then time my update to run every minute or so parallel? I'd like to know whats best practice here.
Parallel and Event Driven are basically orthogonal, although it is generally "easy" to parallelize events. I'll first cover the event driven and then the parallelisation, although you may only want to use the later.The "normal" controlflow in python is iterative.That means you define the instructions the code should do and then the pc executes these step for step.There are different ways to organize your code (functional, event driven, object oriented, although I don't want to say that these are absolute categories where you can only do X or Y). Event driven normally means you define events and how to handle them.There is nothing you could program with event driven which you couldn't program iterativly and vice versa.Python mainly got support for asyncronuos stuff with version 3.4 when the asyncio library was introduced. With 3.5 you also got syntactic sugar await and async. Because you are on 2.7 this is not available for you.There is a backport from asyncio named trollius but this is overkill if you only have a "low amount of events". Also it's not hard to "roll your own basic event loop" (of course asyncio and trollius do much more, but if we are not going to use these features, why bother?).The basic workflow is waiting for events and then handling them as they occur:You somehow need to know how to differentiate between events and how to handle them.For a "full featured event loop" you would probably use different classes with inheritance, but lets just use a name for each event.Also we probably need some kind of data like which RFID we encountered.Then we simply need to map events to how to handle them:We still need to generate events, so lets rewrite the eventloop to get events:And now we are "event driven". The nice thing is that we can easily extend this to more events.The bad thing is that it still does the same thing you probably already have, but it's more complicated.Also if the event handling needs a lot of time (which seems to be the case with updating the spreadsheet) the other events will notbe generated and handled. This is were parallelism comes into play. Parallelism basically means we can use multiple cores.Here we actually only need "concurrency" which means two things can happen at once. This is "easier" than true parallelism, we can just switch between different things but still do all the things sequentially. In python this basically boils down to multiprocessing (parallelism) and threads ("only" concurrency) (in other programming languages threads actually do parallelism, but in python this is for reasons I don't want to go into not the case). The problem with concurrency is always syncronisation. If things can happen at the same time, bad things can happenif two threads try to change the same variable. In general as long as you only use thread-safe functions to access variables shared between threads, you are safe.In python threads are created by the threading module.I personally find it hard to understand if you don't already know threads from somewhere else, but the gist is the following:To run a function in a thread use threading.Thread(target=function) and then thread.start().You could use it the following:Note that if you access variables from within _update_spreadsheet you need to be carefule to only use thread safe function.It is "best" to use as little inter-thread communication as possible.A queue is often a good choice.You can use parallelism/concurrency without the event driven organisation.Because we already divided the code into event handlers we can call long running event handlers in a seperate thread.If we have lots of events and event handlers running everything in threads is a bad idea (because thread switching has an overhead).Thus asyncio (and probably all other event loops) implement some kind of "wait until atleast one event can be handled".This is most interesting for internet input and output, because these need "a long time".Often something like select is used. Other events (timers, read from disk, wait for some hardware events, ...) need other mechanisms for "wake me up when something happens". Integrating all of these is one of the features asyncio offer for you.


Answer URL
https://docs.python.org/3/library/asyncio.html
