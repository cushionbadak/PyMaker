Natural Text
I've got two structure that should be identical in size and content:however sizeof(struct_1) is 4 and sizeof(struct_2) is 8.  When I convert instances of each structure to a bytes array like so:I get the following output:Which shows to me that the structure is properly storing the data, but incorrectly setting the size of the structure.  Furthermore, if I add another field after it:and I set the values to those, I get a "padding" in between:
struct_1 has two 16 bit fields which equal 4 bytes. (2 * 16 / 8)struct_2 is putting 2 16 bit fields into a 64 bit field, no matter what you do 64 bits is 8 bytes.Packing only helps when you are adding small fields near each other by default compilers will align the fields to start at 16, 32 or 64 bit alignments, but it will not make a int64 smaller.
When dealing with the ctypes module, everything is going to be byte aligned (8 bits).  To account for the possibility of fields with non-byte aligned bit lengths, ctypes automatically allocates the space with the size of the field selected and then places the sub-fields into the newly byte aligned allocated space.  For example, given the following ctypes Structure:The end packet produced in memory will be:This is nice and lined up as expected.  Now, let's look at , if you have two sub-fields whose bit lengths added up aren't byte aligned:You'll get empty or spare bits:Notice that there is a gap between B and C.  This is the case for all of the c_<int> data types within the ctypes module.  As far as I know, there is no way around this.  


Answer URL
https://docs.python.org/3/library/ctypes.html#structure-union-alignment-and-byte-order
