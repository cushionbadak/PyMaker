Natural Text
Please see the following code:The output is:The docs say  that super() will:Return a proxy object that delegates method calls to a parent or sibling class of typeIIUC here super() is the same as super(MyTupleS, self). Now the docs further say thatThe search order is same as that used by getattr() except that the type itself is skipped. The __mro__ attribute of the type lists the method resolution search order used by both getattr() and super().Ohkay but then:So the super() line should first look within tuple to find __init__ and tuple's __init__ can certainly take one parameter (other than self of course) and is what is being called by the explicit tuple.__init__ line. So why doesn't the super().__init__ call work identical to that? Why is it trying to invoke object.__init__ and failing?IIUC one should only need to explicitly specify the superclass when one is worried that the inheritance hierarchy can change in a "dynamic execution environment" (phrase from the docs) and wants the method of a particular superclass to be called. But this error effectively makes it mandatory for the superclass to be specified. Why?NOTE: This is different from another similarly titled question.
If you call tuple.__init__ it returns object.__init__ because tuple has no custom __init__ method and only inherits it from object. The first argument for object.__init__ is self and what object.__init__ does is nothing. So when you pass in contents it's interpreted as self and doesn't throw an Exception. However it probably doesn't do what you think it does because tuple.__new__ is responsible for setting up a new tuple instance.If you use super().__init__ it also resolves to object.__init__ but it already binds the current "self" as first argument. So when you pass contents to this function it's interpreted as additional argument which doesn't exist for object.__init__ and therefore throws that Error.


Answer URL
https://docs.python.org/3/library/functions.html#super
