Natural Text
Suppose you find yourself in the unfortunate position of having a dependency on a poorly behaved library. Your code needs to call FlakyClient.call(), but sometimes that function ends up hanging for an unacceptable amount of time.As shown below, one way around this is to wrap the call in its own Process, and use the timeout parameter in the join method to define a maximum amount of time that you're willing to wait on the FlakyClient. This provides a good safeguard, but it also prevents the main body of code from reacting to the result of calling FlakyClient.call(). The only way that I know of addressing this other problem (getting the result into the main body of code) is by using some cumbersome IPC technique.What is a clean and pythonic way of dealing with these two problems? I want to protect myself if the library call hangs, and be able to use the result if the call completes.Thanks!
If you are using Process I would suggest you use a Queue to handle result transfer and indirectly also manage function timeout. 
I cannot speak to Python 2.7, but in Python 3, the correct way to handle this is to make use of asyncio and the concept of futures.This is fairly Pythonic. You can integrate this with the main body of the code. It correctly uses try-except for error handling. It comes with an inbuilt timeout. It only works in Python 3.5 (thanks to await - but changing to yield from makes it compatible with Python 3.4).For Python 2.7, unfortunately, the right way to handle that is to do what you are currently doing. 


Answer URL
https://docs.python.org/3/library/concurrent.futures.html
