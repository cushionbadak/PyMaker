Natural Text
In python, staticmethods are "just functions", and I can refer to them in two different ways:Both a.f and A.f are names that refer to the same object, which happens to be "just a function". Great.Now, say I have a classmethod:I know that b.f and B.f are not functions: they're bound mothods. This means that the cls argument is implicit, and is always equal to B. Because of this, I would understand that if B2 is a subclass of B, B2().f is B().f would be false, because they're bound methods with different cls arguments. But I don't understand why B().f is B.f yields False. Shouldn't they be the same object, just like A().f and A.f?EDIT: This question is not the same as "What is the difference between @staticmethod and @classmethod in Python?". I know the difference between staticmethod and classmethod. I want to know one specific thing, which is not addressed in the "umbrella" question linked.
B().f and B.f are different objects because Python creates a new bound method object each time you refer to a non-static method via attribute access.For example, B.f is B.f is also False.Similarly, you will get a new method object even if the instance stays the same:@staticmethod creates a new static method object, butWhen a static method object is retrieved from a class or a class  instance, the object actually returned is the wrapped object, which is  not subject to any further transformation.(from Data model)In this case A.f always returns the same f function object.


Answer URL
https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy
