Natural Text
What I've succeeded to do so far:I've made an elem class to represent html elements (div, html, span, body, etc.).I'm able to derivate this class like this to make subclasses for each element:And it works pretty well.But I have to write this for each subclass declaration, and that's pretty repetitive and redundant if I want to do every HTML tag type.So I was trying to make a make_elem() function that would make my class by taking the corresponding tag name as a string parameter.So instead of the previous class definition, I would simply have something like this:Where I'm stuckThis function should create a class. And the __init__() method from this class should call the __init__() method from the class it inherits from.I tried to make this make_elem_class() function and it looked like this :But when running html = make_elem_class('html'), then html("html element") I get the following error:I guess that it has something to do with the empty super() call, so I tried with super(elem, self) instead. But it obviously doesn't work better.How could I achieve this?NB : If I remove the "__init__":init from the dictionnary in the type() call, it works fine but the tag isn't correctly set in my elem. I've also tried to directly pass {"tag":name} to type() but it didn't work either.
You can't use the no-argument form of super() here, as there is no class statement here to provide the context that that function normally needs.Or rather, you can't unless you provide that context yourself; you need to set the name __class__ as a closure here:super() automatically will take the __class__ value from the closure. Note that I pass on the value for content, not None, to the elem.__init__ method; you wouldn't want to lose that value.If that is too magical for you, explicitly name the class and self when calling super(); again, the class is going to be taken from the closure:
What's about a more straight-forward solution like inferring the tag for the class __name__?And then:A bit less magic (controversial), and a bit more explicit. :-)
I think this is a little bit of an XY problem. In that you've asked to how to use super in a dynamically created class, but what you really want is a less verbose way to set various class variables and defaults for your subclasses. Since you don't expect all instances of the same tag class to share the same tag name, you might as well set it as a class variable rather than an instance variable. eg.You can now write very short child classes, and still have your classes explicitly declared. You'll note that I changed a couple of the defaults to None. For attr, this is because having mutable default arguments won't work how you expect -- it'll behave more like it's a shared class variable. Instead, have the default as None, if attr has not been specified then create a new attr for each instance. The second (tag_type) is so that if tag_type is specified then the instance will have it's tag_type set, but all other instances will rely on the class for the default value.


Answer URL
https://docs.python.org/3/reference/lexical_analysis.html#keywords
