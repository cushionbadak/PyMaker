Natural Text
How do I force Python's print function to output to the screen?This is not a duplicate of Disable output buffering - the linked question is attempting unbuffered output, while this is more general. The top answers in that question are too powerful or involved for this one (they're not good answers for this), and this question can be found on Google by a relative newbie.
Print by default prints to sys.stdout.References:http://docs.python.org/reference/simple_stmts.html#the-print-statementhttp://docs.python.org/library/sys.htmlhttp://docs.python.org/library/stdtypes.html#file-objects
Running python -h, I see a command line option:-u     : unbuffered binary stdout and stderr; also PYTHONUNBUFFERED=x           see man page for details on internal buffering relating to '-u'Here is the relevant doc.
Since Python 3.3, you can force the normal print() function to flush without the need to use sys.stdout.flush(); just set the "flush" keyword argument to true.  From the documentation:print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)Print objects to the stream file, separated by sep and followed by end. sep, end and file, if present, must be given as keyword arguments.All non-keyword arguments are converted to strings like str() does and written to the stream, separated by sep and followed by end. Both sep and end must be strings; they can also be None, which means to use the default values. If no objects are given, print() will just write end.The file argument must be an object with a write(string) method; if it is not present or None, sys.stdout will be used. Whether output is buffered is usually determined by file, but if the flush keyword argument is true, the stream is forcibly flushed.
How to flush output of Python print?I suggest five ways of doing this:In Python 3, call print(..., flush=True) (the flush argument is not available in Python 2's print function, and there is no analogue for the print statement).Call file.flush() on the output file (we can wrap python 2's print function to do this), for example, sys.stdoutapply this to every print function call in the module with a partial function,print = partial(print, flush=True) applied to the module global.apply this to the process with a flag (-u) passed to the interpreter commandapply this to every python process in your environment with PYTHONUNBUFFERED=TRUE (and unset the variable to undo this).Python 3.3+Using Python 3.3 or higher, you can just provide flush=True as a keyword argument to the print function: Python 2 (or < 3.3)They did not backport the flush argument to Python 2.7 So if you're using Python 2 (or less than 3.3), and want code that's compatible with both 2 and 3, may I suggest the following compatibility code. (Note the __future__ import must be at/very "near the top of your module"):The above compatibility code will cover most uses, but for a much more thorough treatment, see the six module.Alternatively, you can just call file.flush() after printing, for example, with the print statement in Python 2:Changing the default in one module to flush=TrueYou can change the default for the print function by using functools.partial on the global scope of a module:if you look at our new partial function, at least in Python 3:We can see it works just like normal:And we can actually override the new default:Note again, this only changes the current global scope, because the print name on the current global scope will overshadow the builtin print function (or dereference the compatibility function, if using Python 2, in that current global scope).If you want to do this inside a function instead of on a module's global scope, you should give it a different name, e.g.:If you declare it a global in a function, you're changing it on the module's global namespace, so you should just put it in the global namespace, unless that specific behavior is exactly what you want.Changing the default for the processI think the best option here is to use the -u flag to get unbuffered output.or  From the docs:Force stdin, stdout and stderr to be totally unbuffered. On systems where it matters, also put stdin, stdout and stderr in binary mode.Note that there is internal buffering in file.readlines() and File Objects (for line in sys.stdin) which is not influenced by this option. To work around this, you will want to use file.readline() inside a while 1: loop.Changing the default for the shell operating environmentYou can get this behavior for all python processes in the environment or environments that inherit from the environment if you set the environment variable to a nonempty string:e.g., in Linux or OSX:or Windows:from the docs:PYTHONUNBUFFEREDIf this is set to a non-empty string it is equivalent to specifying the -u option.AddendumHere's the help on the print function from Python 2.7.12 - note that there is no flush argument:
Also as suggested in this blog one can reopen sys.stdout in unbuffered mode:Each stdout.write and print operation will be automatically flushed afterwards.
With Python 3.x the print() function has been extended:So, you can just do:Python Docs Entry
Using the -u command-line switch works, but it is a little bit clumsy. It would mean that the program would potentially behave incorrectly if the user invoked the script without the -u option.  I usually use a custom stdout, like this:... Now all your print calls (which use sys.stdout implicitly), will be automatically flushed.
Why not try using an unbuffered file?OR

Dan's idea doesn't quite work:The result:I believe the problem is that it inherits from the file class, which actually isn't necessary. According to the docs for sys.stdout:stdout and stderr neednâ€™t be built-in  file objects: any object is acceptable  as long as it has a write() method  that takes a string argument.so changingtomakes it work just fine.
Here is my version, which provides writelines() and fileno(), too:
Loved Dan's solution! For python3 do:
In Python 3 you can overwrite print function with default set to flush = True 
I did it like this in Python 3.4:


Answer URL
https://docs.python.org/3/glossary.html#term-file-object
https://docs.python.org/3/library/io.html
