Natural Text
I'm still very confused about how asyncio works, so I was trying to set a simple example but couldn't achieve it.The following example is a web server (Quart) that receives a request to generate a large PDF, the server then returns a response before start processing the PDF, then starts processing it and will send the download link to an email later.How would I go about this? in the above example I don't want the 5 seconds to be waited before the return.I'm not even sure if asyncio is what I need.And I'm afraid that blocking the server app after the response has returned is not a thing that should be done, but not sure either.Also the pdf library is synchronous, but I guess that's a problem for another day...
The comment has everything you need to respond to the web request and schedule the pdf generation for later. However it is not a good idea if the pdf processing is slow as it will block the asyncio event thread. i.e. The current request will be responded quickly but the following request will have to wait till the pdf generation is complete.The correct way would be run the task in an executor (especially ProcessPoolExecutor).It is important to note that since, it is running in different process, the generatePdf cannot access any data without synchronization. So pass everything the function needs when calling the function.UpdateIf you can refactor the generatePdf function and make it async, it works best.Example if the generate pdf looks likeYou can make the function async like:Note: All the helper functions like downloadImage, queryData need to be rewritten to support async. This way, requests won't be blocked even if the database or image servers are slow. Everything runs in the same asyncio thread.If some of them are not yet async, those can be used with run_in_executor and should work good with other async functions.
I highly recommend on reviewing this explanatory article by  Brad Solomon on parallel programming and asyncio in python.For the purpose of asynchronously performing a task, without the need to block the request until the task is complete - I think the best option is to use a queue that with a "PDFGenerator" class that consumes from the queue pattern(also covered in the article)
For your task, generating a large PDF, you can use an asynchronous task/job queue. As an example, you can use Celery. Since you don't want to wait for the task, rather return a reply like - "generating PDF, please wait a minute/second". So when a request comes to the "generate PDF" endpoint, you will create a task in Celery and Celery will process it asynchronously and after completion, you can push to client or client can use the "task lookup" using the task-id (or as you implement). Here is an example answer - How to check task status in Celery?The difference between Celery and Asyncio is, Celery can execute a task in a totally separated environment and the communication with the server is done by a distributed message passing like RabbitMQ. Where Asyncio uses coroutines to utilize the blocking I/O time. It will use the same environment and processors where your server resides.


Answer URL
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor
https://docs.python.org/3/library/asyncio-queue.html#queue
https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task
