Natural Text
When reading source code of python logging module, I found code like this:why? Is it equals this?
Obvious - there is no exc_info (exception info) until some exception arises. So we need to rise exception to access its info and get call stack from it.This seems to be the easiest way to access current call stack.
According to the official docs for sys.exc_info, you need an exception in any stack frame to get a tuple of (type, value, traceback). If there is no exception handled, you get a tuple with None values. The stack frame could be: the current stack, or the calling stack for a function or the caller(function) itself. In logging, we are concerned with the traceback for the current stack(notice sys.exc_info()[2]) only and therefore will have to raise an Exception in order to access the tuple values. Here's an excerpt from the docs:This function returns a tuple of three values that give information about the exception that is currently being handled. The information returned is specific both to the current thread and to the current stack frame. If the current stack frame is not handling an exception, the information is taken from the calling stack frame, or its caller, and so on until a stack frame is found that is handling an exception. Here, “handling an exception” is defined as “executing an except clause.” For any stack frame, only information about the exception being currently handled is accessible.If no exception is being handled anywhere on the stack, a tuple  containing three None values is returned. Otherwise, the values  returned are (type, value, traceback). Their meaning is: type gets the  type of the exception being handled (a subclass of BaseException);  value gets the exception instance (an instance of the exception type);  traceback gets a traceback object (see the Reference Manual) which  encapsulates the call stack at the point where the exception  originally occurred.sys._getframe([depth]) returns the frame object from the call stack. If optional integer depth is given, return the frame object that many calls below the top of the stack. The default for depth is zero, returning the frame at the top of the call stack. Another important point to consider is that this function is not guaranteed to exist in all implementations of Python. We know that CPython has it. The following piece of code from logging/__init__.py performs this check. Note that currentframe() is a lambda function.:This means: if sys._getframe() exists in the Python implementation, return the 3rd frame object from the top of the call stack.  If sys does not have this function as an attribute, the else statement below raises an Exception to capture the frame object from the Traceback.To understand this concept better, I've used the above if-else code to frame an example(no pun intended). This is inspired by the excellent explanation here. The following example contains 3 functions which were saved in a file called main.py.On running this code with python main.py, we get the following output:Explanation:Function get_current_frame(x): This function contains the same code from the if-else statement from logging/__init__.py. The only difference is that we are passing the depth argument x to the function which is used by the lambda function to grab the frame object at that depth: currentframe = lambda: sys._getframe(x).Function show_frame(num, frame): This function prints the frame object, the frame function call with its depth, sys._getframe(num), the caller function name eg. show_frame()..etc. , the file name of the file that executes the calling function code along with the current line no. in the code of the calling function. f_code is an attribute of the frame object returned by sys._getframe() and is a code object. co_name is an attribute of this code object and returns the name with which the code object was defined(you can print f_code to check this). Similarly, co_filename retrieves the filename and f_lineno retrieves the current line no. You can find an explanation of these attributes in the inspect docs which is also used to get frame objects interestingly. You can also write some isolated code to understand how these attributes work. For eg. the below code gets the current frame frameobj(i.e.: the frame object at the top of the stack, depth 0(default)) and prints the filename of the code object for that frame(I'm running this code in main_module.py). The calling stack is not too deep because there is just one function call to _getframe(). If we change the code to get the frame at depth 1, we get an error:Function test(): This function gets the current frame object for depth num in some range and then calls show_frame() for that num and frame object.When test() is called, the calling stack is: test --> get_current_frame --> show_frame. In subsequent calls, the stack is get_current_frame ---> show_frame until the for loop completes for the range(4) in test(). If we examine the output from the top, the frame at the top of the stack has depth 0: frame     = sys._getframe(0) and the calling function is the lambda function itself. The line no. 74 in file/line = main.py:74 is the current line no. when this function was called(imagine it like the last cursor position for that frame). Finally, we look at the frame at the bottom of the stack. This is also the frame object(with depth 3) that is used in logging:In logging, we need a depth of 3 to reach the stack frame of the caller function. We can also use our previous toy example to understand this concept. As the stack is not too deep, we get the current frame at depth 0.Now, what if my Python implementation does not have _getframe() attribute for sys? In this case, the code in else will execute and raise an Exception to get the current frame from the traceback. The following function does this and the calling function here is <module> again(notice the output):f_back returns the frame object for the traceback frame tb_frame returned by the current Exception . We can check this by printing the return statement: print(sys.exc_info()[2].tb_frame.f_back) and we get something like: <frame object at 0x000000000049B2C8>This explains how the logging module captures the current frame.So, where is currentframe() later used in the logging source code? You will find it here:The above function gets the current frame of the caller function and uses this information later to get the same attributes(file name etc.) that we accessed earlier.


Answer URL
https://docs.python.org/3/library/sys.html#sys._getframe
