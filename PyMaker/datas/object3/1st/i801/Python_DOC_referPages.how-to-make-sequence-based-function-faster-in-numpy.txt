Natural Text
Considering a function below:That is, for a general function that calculates t+1 based on t in an array, can I make this faster? I'm aware there's a np.vectorize but not seeming appropriate for this case.
You can use cumsum I think that would be helpful.Or you can use np.cumsum():
It is possible to reduce the two for loops to one for loop with little bit of copying overhead in addition.To make this work for a generic function, you can look for an equivalent function in numpy or implement one using numpy operations (vectorized one). For the example you provided, I just used numpy.sum() that does the job for us.In terms of performance, this approach would be much better than operating using two for loops at the indices level, particularly for larger arrays. In the approach I used above, we work with slices of columns.Here are the timings which suggest more than 3X speedup over native python implementation.Native Python:Slightly vectorized:
What you're looking for is called accumulate here's an example:There is no optimized accumulate function in numpy because it's not really possible to write accumulate in a way that's both performant & general. The python implementation is general, but will perform much like a hand coded lok. To get optimal performance you'll probably need to find or write a low level implementation of the specific accumulate function that you need. You've already mentioned numba and you could also look into cython.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.accumulate
