Natural Text
While preparing for a test, I am solving tests from previous years.Write the function compress(lst) that receives a non empty list of repetitive letters and returns a list of tuples, each tuple containing the letter and the number or subsequent repetitions. ( see example)e.g.:for:the function should return:Here's my code:My function returns:I can see why it does that, but I cant see how to change my code to solve the problem.
(Assuming you want to correct your code) Save the index of the current analyzed letter and just sum to it how many times this letter repeats, so you skip already analyzed letters
Use groupby from itertools module which perfectly fits here:
The issue is that the while loop correctly counts occurrences, the for loop marches on inexorably, one character at a time. Since you're already incrementing the index correctly in the while loop, the simplest thing would be to get rid of either the for or while loop entirely. The only purpose to having multiple loops here is to attempt to avoid an if, and as you see, that doesn't really work.This is similar to what you'd get from itertools.groupby:
groupby is the pythonic way. If you want to emulate that, you can do it with O(1) with only one loop, no indexes (not very pythonic) and a variable to store the previous letter:result:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.groupby
