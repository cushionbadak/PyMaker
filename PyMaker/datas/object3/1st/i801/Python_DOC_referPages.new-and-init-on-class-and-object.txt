Natural Text
In Python 3, when defining a subclass, why do you need to use cls as the first argument of __new__, but not to use self as the first argument of __init__?An example:When I compared these functions I got more confused:So, what are the differences between __new__ and __init__ behind these results? Which methods are bound and which are free? Why are you able to call self.__init__() but not cls.__init__()? Is cls.__init__ a method defined in cls itself or in its metaclass?
The biggest part of the picture you're probably missing is that __new__ is a staticmethod, special-cased to be one even if you don't use the @staticmethod decorator.When calling a method through super(), super() performs the same kind of argument binding that would be performed normally for that kind of method (using the descriptor protocol). For a staticmethod like __new__, that means no arguments are automatically bound, so cls has to be passed explicitly. For an instance method like __init__, that means self is bound automatically, which is why you don't have to pass self to super().__init__.
The main purpose of __new__ is to allocate a new instance of the class, while __init__'s job is to set up an existing instance.According to the docs:__new__() is a static method (special-cased so you need not declare it as such)__init__ on the other hand, is a proper instance method. It can be called multiple times on the same instance, by the way.That should be enough to explain your terminal session:You just called object.__call__, which essentially doesNotice that the return value of __new__ is not required to be an instance of the class it belongs to, but __init__ is called only if it is. In your case, it is.__new__ is a static method, so attempting to bind it to the instance does nothing: it stays a class method. This is the same reason that you have to pass cls explicitly when calling super().__new__: it's the same free function, unbound to either class or instance.Not only are these not the same thing, but their types are different. cls.__init__ is a regular function. self.__init__ is a bound method which lacks the first parameter of cls.__init__.This has already been called, but for object, it's a no-op you can call as many times as you like. Notice that the first parameter is not being passed in, being as it is a bound method.This is calling the raw __init__ function, which requires that the self parameter be passed in. Since you don't do that, it raises. Try this instead:
cls stands for class itself, while self stands for object itself. These are just conventions.The __new__ method is called before the object is created, in fact, __new__should create the object and return it. Therefore, it needs a class to create object. After that, the __init__ is called to initialize the object, so it needs the object as the first argument.  For example:__new__ is static method, so the class and instance share the same __new__ method. __init__ is the method of instance. If you want to call it via class, you need to pass the instance as the first argument explicitly.Anything in Python is object, including the class itself. So for class, it has its own __new__ and __init__ which are used by metaclass to create class and initialize class.These are meta programming of Python, I suggest to read the ninth chapter of Python Cookbook.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__new__
https://docs.python.org/3/reference/datamodel.html#implementing-descriptors
https://docs.python.org/3/reference/datamodel.html#object.__new__
https://docs.python.org/3/reference/datamodel.html#object.__init__
