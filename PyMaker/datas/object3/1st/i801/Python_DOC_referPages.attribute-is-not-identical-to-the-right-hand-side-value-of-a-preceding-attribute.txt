Natural Text
This question might superficially look like a duplicate,but it is not about the usual mutable surprise with lists.More details later, but in a nutshell, just aftersometimes self.facts and facts were not identical.The app is single-threaded, and the difference lasts,so it does not seem to be a race condition or buffer delay.I did clear the cache:find . -name "*.pyc" -deleteI tried to come up with an mcve,but could not reproduce the bug. Here is an attempt.A snapshot and steps to reproduce can be found in this issue.As soon as the __eq__ was expanded to check also fields that did change, both facts and self.facts held elements that were equal (in the sense of __eq__), so good enough, but not identical, which is still weird.Is that something known ? here is my python version:What could be happening ?
Such behavior can be caused by many things, all of which control how an object's attributes are accessed.In that sense self.x = y is very much different from x = y. The former attempts to set the attribute "x" with yon the object self while the latter binds the name "x" to the object y in the local scope.DescriptorsDescriptors can control how attributes aredealt with by defining the special methods __get__, __set__, __delete__. An example:Propertiesproperty is probably one of the most prominent usage scenarios fordata descriptors. Hence the workings are very similar:__getattr__ and __setattr__By defining the methods __getattr__ and__setattr__ a class can control the attribute accessof its instances. For example:How can I find out what intercepts the attribute access?You can check type(obj).facts in order to find out whether facts is defined to be a descriptor.Similarly you can check type(obj).__(get|set)attr__ to see whether any of the base classes definesthis special method. Worth noting here is that any of the above described methods also works if it is definedon any of the classes sitting in the method resolution order (__mro__, i.e. the parent classes).So you would need to check for example:The OP's specific exampleThe class you linked inherits fromthis class which defines__setattr__in a way that it checksfor equality (==; not identity (is)) with an existing value and returns if they compare equal.That means especially if you have two lists that compare equal, i.e. self.facts == facts, thendoing self.facts = facts will just return and not set the attribute. Hence nothing changedand the two objects (self.facts and facts) are still distinct. The code basically comes down to this:


Answer URL
https://docs.python.org/3/reference/datamodel.html#descriptors
https://docs.python.org/3/library/functions.html#property
https://docs.python.org/3/reference/datamodel.html#object.__getattribute__
https://docs.python.org/3/reference/datamodel.html#object.__setattr__
