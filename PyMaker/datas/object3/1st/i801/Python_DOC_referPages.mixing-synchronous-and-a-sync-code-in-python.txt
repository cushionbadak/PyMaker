Natural Text
I'm trying to convert a synchronous flow in Python code which is based on callbacks to an A-syncronious flow using asyncio. Basically the code interacts a lot with TCP/UNIX sockets. It reads data from the sockets, manipulates it to make decisions and writes stuff back to the other side. This is going on over multiple sockets at once and data is shared between the contexts to make decisions sometimes.EDIT :: The code currently is mostly based on registering a callback to a central entity for a specific socket, and having that entity run the callback when the relevant socket is readable (something like "call this function when that socket has data to be read"). Once the callback is called - a bunch of stuff happens, and eventually a new callback is registered for when new data is available. The central entity runs a select over all sockets registered to figure out which callbacks should be called. I'm trying to do this without refactoring my entire code and making this as seamless as possible to the programmer - so I was trying to think about it like so - all code should run the same way as it does today - but whenever the current code does a socket.recv() to get new data - the process would yield execution to other tasks. When the read returns, it should go back to handling the data from the same point using the new data it got. To do this, I wrote a new class called AsyncSocket - which interacts with the IO streams of asyncIO and placed the Async/await statements almost solely in there - thinking that I would implement the recv method in my class to make it look like a "regular IO socket" to the rest of my code. So far - this is my understanding of what A-sync programming should allow.Now to the problem : My code awaits for clients to connect - when it does, each client's context is allowed to read and write from it's own connection.I've simplified to flow to the following to clarify the problem: mit2() and mit3() are synchronous functions that do stuff with the data on the way back before returning to the main client's loop - but here I'm just using them as empty functions. The problem starts when I play with the implementation of some_func().A pass through implementation (edit: kind-of-works) - but still has issues : While an implementation which reads the data and does something with it - like adding a suffix before returning, throws an error:The error (as far as I understand it) means it's not really doing what it should:And the echo server obviously doesn't work.Obviously my code looks more like option #2 with a lot more stuff in some_func(),mit2() and mit3() - but I can't get this to work. I'm fairly new in using asyncio/async/await - so what (rather basic concept I guess) am I missing? 
This code won't work as envisioned:You cannot call an async function from a sync function and get the result, you must await it, which ensures that you return to the event loop in case the data is not yet ready. This mismatch between async and sync code is sometimes referred to as the issue of function color.Since your code is already using non-blocking sockets and an event loop, a good approach to porting it to asyncio might be to first switch to the asyncio event loop. You can use event loop methods like sock_recv to request data:Once you have the program working in that mode, you can start moving to coroutines, which allow the code to look like sync code, but work in exactly the same way:The next step can be eliminating make_socket and switching to asyncio streams.


Answer URL
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.sock_recv
https://docs.python.org/3/library/asyncio-stream.html#asyncio-streams
