Natural Text
I am curious to understand how Python for loops work under the hood. I tried to implement it somewhat like the following code snippet, is that how the for loop has been implemented?
Yes, that's a good approximation of how the for loop construct is implemented. It certainly matches the for loop statement documentation:The expression list is evaluated once; it should yield an iterable object. An iterator is created for the result of the expression_list. The suite is then executed once for each item provided by the iterator, in the order returned by the iterator. Each item in turn is assigned to the target list using the standard rules for assignments (see Assignment statements), and then the suite is executed. When the items are exhausted (which is immediately when the sequence is empty or an iterator raises a StopIteration exception), the suite in the else clause, if present, is executed, and the loop terminates.You only missed the assigned to the target list using the standard rules for assignments part; you'd have to use i = next(iter_list) and print(i) rather than print the result of the next() call directly.Python source code is compiled to bytecode, which the interpreter loop then executes. You can look at the bytecode for a for loop by using the dis module:The various opcodes named are documented in the same dis module, and their implementation can be found in the CPython evaluation loop (look for the TARGET(<opcode>) switch targets); the above opcodes break down to:SETUP_LOOP 12 marks the start of the suite, a block of statements, so the interpreter knows where to jump to in case of a break, and what cleanup needs to be done in case of an exception or return statement; the clean-up opcode is located 12 bytes of bytecode after this opcode (so POP_BLOCK here).LOAD_NAME 0 (mylist) loads the mylist variable value, putting it on the top of the stack (TOS in opcode descriptions).GET_ITER calls iter() on the object on the TOS, then replaces the TOS with the result.FOR_ITER 4 calls next() on the TOS iterator. If that gives a result, then that's pushed to the TOS. If there is a StopIteration exception, then the iterator is removed from TOS, and 4 bytes of bytecode are skipped to the POP_BLOCK opcode.STORE_NAME 1 takes the TOS and puts it in the named variable, here that's i.JUMP_ABSOLUTE 6 marks the end of the loop body; it tells the interpreter to go back up to bytecode offset 6, to the FOR_ITER instruction above. If we did something interesting in the loop, then that would happen after STORE_NAME, before the JUMP_ABSOLUTE.POP_BLOCK removes the block bookkeeping set up by SETUP_LOOP and removes the iterator from the stack.The >> markers are jump targets, there as visual cues to make it easier to spot those when reading the opcode line that jumps to them.


Answer URL
https://docs.python.org/3/reference/compound_stmts.html#the-for-statement
https://docs.python.org/3/library/dis.html
https://docs.python.org/3/library/dis.html#opcode-SETUP_LOOP
https://docs.python.org/3/library/dis.html#opcode-LOAD_NAME
https://docs.python.org/3/library/dis.html#opcode-GET_ITER
https://docs.python.org/3/library/dis.html#opcode-FOR_ITER
https://docs.python.org/3/library/dis.html#opcode-STORE_NAME
https://docs.python.org/3/library/dis.html#opcode-JUMP_ABSOLUTE
https://docs.python.org/3/library/dis.html#opcode-POP_BLOCK
