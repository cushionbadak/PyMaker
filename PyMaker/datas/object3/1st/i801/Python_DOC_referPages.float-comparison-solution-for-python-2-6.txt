Natural Text
I am doing a simple comparison between a string value and floats minValue and maxValue to check if value is outside of a certain range It works fine unless value and minValue are the same. So when value = -1.234 and minValue = -1.234, it goes inside the if statement because for some reason -1.234 < -1.234 evaluates to True.My workaround is to use Decimal But Decimal(str(minValue)) looks a little messy so I'm wondering if there is a better way of comparing two floats that won't fail when they are the same value without having to do float to string to decimal conversion first.EDITvalue comes from a csv file, so there is no truncation there. What you see is what you get. minValue is, however, a result of a polynomial function, but I don't believe there is any truncation or rounding there.Here's the function to calculate minValue
Note that in general, this isn't going to be solvable without Decimal; floating point math is inherently imprecise across many calculations, and what should logically arrive at -1.234 can easily become -1.2339999999999998 or -1.2340000000000002 (only for illustration, your computer may differ, but those are the closest values to -1.234 on either side on my machine that don't end up rounding off to the canonical representation of -1.234; your calculation might be that close, or it might be off by a bit more, but likely still an error of less than 0.00000000001).That said, if you happen to know, with certainty, that your values should never need more than X decimal places of precision, you can often get away with using the faster float, via the round function, to ensure your values are really the closest representable value to what they should be logically. Since it appears minValue and maxValue are computed once up front, just change the last step to round them off as well, e.g.:which removes any spurious excess precision. Heck, if you're not sure how precise you need to be, just double your best guess; the imprecision you're likely to see in most cases is usually well past 10 digits past the decimal point, so if you only think you need three digits, but you're worried you might still remove valid data (e.g. maybe you've got a division by 8 that might leave an extra, valid 125 at the end), just go up a bit more, rounding to 6, or even 9 decimal places.Similarly, change the code that performs the comparison to normalize value as well, e.g.:or even better (avoids doubling up the conversion code):which takes advantage of Python's chained comparison operators (it's equivalent to typing if not (minValue <= round(float(value), 3) and round(float(value), 3) <= maxValue):, except round(float(value), 3) is only computed once).
The reason it is not working is becasue -1.234 is not greater or less than -1.234. -1.234 > 1.234 is false and -1.234 < 1.234is also false. If you want to also make it true if they are equal you would need to use => or =< which means "greater then or equal to" 


Answer URL
https://docs.python.org/3/library/functions.html#round
