Natural Text
When using __new__ to customize the creation of a metaclass, we can pass attributes to the type().__new__ method which will be set on the object before it is returned, e.g.So that:However I don't know how to do the same for a normal (non-meta) class, which causes a problem when using __setattr__:So that unfortunately:In the __new__ of Bar I get back a fully fledged class instance from object() and any attribute access goes through normal lookup rules, in this case invoking __setattr__. Metaclass Foo avoids this as type() will set attributes before returning the instance during low-level creation whereas object() will not.Is there a way of passing attributes to object() or is another another type I can use as the instance returned from __new__ that does allow attributes to be set before it becomes a full class instance? I am not interesting in solutions like setting __class__ after instance creation.
You have to explictly bypass your own class's __setattr__ by calling the super or root object __setattr__. So you'd change:to:A less general approach (doesn't apply to __slots__ based classes) is to directly assign to __dict__ using dict operations:The first approach is what the newly __slots__-ed uuid.UUID now uses; before it became __slots__-ed, it used the second approach. In both cases this was needed because they used the same __setattr__ trick to make the type as immutable as possible (without going to the trouble of subclassing tuple, a la typing.NamedTuple).


Answer URL
https://docs.python.org/3/library/typing.html#typing.NamedTuple
