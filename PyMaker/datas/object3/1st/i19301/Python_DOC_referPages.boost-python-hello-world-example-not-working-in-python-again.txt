Natural Text
I have the same problem than the guy hereBoost Python Hello World example not working in Pythonwho solved his problem, without indicating how. The posts there being quite old, after having posted there also, I create now a new question here, for refreshing things a bit. So... :My configuration : windows 8 62bits, python 2.7.3 32 bits, visual studio 2010 ultimateI followedhttp://www.boost.org/doc/libs/1_53_0/libs/python/doc/tutorial/doc/html/python/exposing.htmlI have created a win32application project called CLIB in visual studio, and ticked "dll" but not "export symbols".In VC++ directories in properties I put : C:\Python27x86\include;C:\boost\boost_1_53_0;$(IncludePath)for include directories and C:\boost\boost_1_53_0\stage\lib;C:\Python27x86\libs;$(LibraryPath)for library directories.In CLIB.cpp I putI tried with or without addingThen I compiled in debug mode (with success), the output .dll (or .pyd, I have tried both without any success by modifying the target extension from .dll to .pyd in "general" in "configuration properties" of the project) CLIB.dll is in a directory whose path I added to the PYTHONPATH also. I have even tried to put a blank init.py in the same directory than the dll, and, whatever I do, I am not able to do ain the python script (created from fresh either with notepad++ or with pyscripter 32 bits). So if someone could give precise help, that would be perfect.Thx a lot.////////////////////////// EDIT 1 ///////////////////////////In the meantime I saw python 2.7 was compiled with mvs2008, so erase everything, installed python 3.3, rebuilt boost and boost.python with python 3.3, and retried, but... same result...////////////////////////// EDIT 2 ///////////////////////////As suggested a run the python script with the very verbose -vv command, here is the result :
There appears to be a difference between the the import statement(s), the extension module name, and the extension library name:The BOOST_PYTHON_MODULE macro defines the module initializer function.  In CLIB.cpp changetoNext, verify that the resulting output library has a CLIB prefix.  Python3.3 removed support for some of the rarely used module name variants.  Per the documentation, I would suggest trying a .pyd file extension first, and resorting to .dll if the .pyd does not work.  Thus, the resulting library should be CLIB.pyd.Finally, when trying to import the extension useinstead of


Answer URL
