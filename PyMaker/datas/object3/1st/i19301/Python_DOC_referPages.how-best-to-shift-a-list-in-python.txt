Natural Text
What is the most efficient way to shift a list in python? Right now I have something like this:Is there a better way?
A collections.deque is optimized for pulling and pushing on both ends. They even have a dedicated rotate() method. 
What about just using pop(0)?list.pop([i])Remove the item at the given position in the list, and return it. If  no index is specified, a.pop() removes and returns the last item in  the list. (The square brackets around the i in the method signature  denote that the parameter is optional, not that you should type square  brackets at that position. You will see this notation frequently in  the Python Library Reference.)
Numpy can do this using the roll command:
It depends on what you want to have happen when you do this:You might want to change your:to:
If you just want to iterate over these sets of elements rather than construct a separate data structure, consider using iterators to construct a generator expression:
Simplest way I can think of:                                        
This also depends on if you want to shift the list in place (mutating it), or if you want the function to return a new list.  Because, according to my tests, something like this is at least twenty times faster than your implementation that adds two lists:In fact, even adding a l = l[:] to the top of that to operate on a copy of the list passed in is still twice as fast.Various implementations with some timing at http://gist.github.com/288272
Just some notes on timing:If you're starting with a list, l.append(l.pop(0)) is the fastest method you can use. This can be shown with time complexity alone:deque.rotate is O(k) (k=number of elements)list to deque conversion is O(n)list.append and list.pop are both O(1)So if you are starting with deque objects, you can deque.rotate() at the cost of O(k). But, if the starting point is a list, the time complexity of using deque.rotate() is O(n). l.append(l.pop(0) is faster at O(1).Just for the sake of illustration, here are some sample timings on 1M iterations:Methods which require type conversion:deque.rotate with deque object: 0.12380790710449219 seconds (fastest)deque.rotate with type conversion: 6.853878974914551 secondsnp.roll with nparray: 6.0491721630096436 secondsnp.roll with type conversion: 27.558452129364014 secondsList methods mentioned here:l.append(l.pop(0)): 0.32483696937561035 seconds (fastest)"shiftInPlace": 4.819645881652832 seconds...Timing code used is below.collections.dequeShowing that creating deques from lists is O(n):If you need to create deque objects:1M iterations @ 6.853878974914551 secondsIf you already have deque objects:1M iterations @ 0.12380790710449219 secondsnp.rollIf you need to create nparrays1M iterations @ 27.558452129364014 secondsIf you already have nparrays:1M iterations @ 6.0491721630096436 seconds"Shift in place"Requires no type conversion1M iterations @ 4.819645881652832 secondsl.append(l.pop(0))Requires no type conversion1M iterations @ 0.32483696937561035
For an immutable implementation, you could use something like this:
I also got interested in this and compared some of the suggested solutions with perfplot (a small project of mine).It turns out thatis by far the fastest method for small shifts n.For larger n, isn't bad.Essentially, perfplot performs the shift for increasing large arrays and measures the time. Here are the results:shift = 1:shift = 100:Code to reproduce the plot:
Possibly a ringbuffer is more suitable. It is not a list, although it is likely that it can behave enough like a list for your purposes.The problem is that the efficiency of a shift on a list is O(n), which becomes significant for large enough lists.Shifting in a ringbuffer is simply updating the head location which is O(1)
I think you are looking for this:
If efficiency is your goal, (cycles? memory?) you may be better off looking at the array module: http://docs.python.org/library/array.htmlArrays do not have the overhead of lists.  As far as pure lists go though, what you have is about as good as you can hope to do.
Another alternative:
I take this cost model as a reference:http://scripts.mit.edu/~6.006/fall07/wiki/index.php?title=Python_Cost_ModelYour method of slicing the list and concatenating two sub-lists are linear-time operations. I would suggest using pop, which is a constant-time operation, e.g.:
I don't know if this is 'efficient', but it also works:EDIT: Hello again, I just found a big problem with this solution!Consider the following code:The shift_classlist() method executes the same code as my x.insert(0,x.pop())-solution, otherlist is a list indipendent from the class. After passing the content of otherlist to the MyClass.classlist list, calling the shift_classlist() also changes the otherlist list:CONSOLE OUTPUT:I use Python 2.7. I don't know if thats a bug, but I think it's more likely that I missunderstood something here.Does anyone of you know why this happens?
The following method is O(n) in place with constant auxiliary memory:Note that in python, this approach is horribly inefficient compared to others as it can't take advantage of native implementations of any of the pieces.
I have similar thing. For example, to shift by two...
I think you've got the most efficient way
For a list X = ['a', 'b', 'c', 'd', 'e', 'f'] and a desired shift value of shift less than list length, we can define the function list_shift() as belowExamples, list_shift(X,1) returns ['b', 'c', 'd', 'e', 'f', 'a']list_shift(X,3) returns ['d', 'e', 'f', 'a', 'b', 'c']
What is the use case? Often, we don't actually need a fully shifted array --we just need to access a handful of elements in the shifted array. Getting Python slices is runtime O(k) where k is the slice, so a sliced rotation is runtime N. The deque rotation command is also O(k). Can we do better? Consider an array that is extremely large (let's say, so large it would be computationally slow to slice it). An alternative solution would be to leave the original array alone and simply calculate the index of the item that would have existed in our desired index after a shift of some kind. Accessing a shifted element thus becomes O(1). 
Following function copies sent list to a templist, so that pop function does not affect the original list: Testing: Output:
Jon Bentley in Programming Pearls (Column 2) describes an elegant and efficient algorithm for rotating an n-element vector x left by i positions:Let's view the problem as transforming the array ab into the array  ba, but let's also assume that we have a function that reverses the  elements in a specified portion of the array. Starting with ab, we  reverse a to get arb, reverse b to get  arbr, and then reverse the whole  thing to get (arbr)r,  which is exactly ba. This results in the following code for  rotation:This can be translated to Python as follows:Demo:
for similar functionality as shift in other languages:


Answer URL
https://docs.python.org/3/tutorial/datastructures.html#more-on-lists
