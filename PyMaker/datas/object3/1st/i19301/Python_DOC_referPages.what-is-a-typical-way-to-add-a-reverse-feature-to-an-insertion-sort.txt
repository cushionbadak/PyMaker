Natural Text
I wrote the following insertion sort algorithmEdit: All you need to do is change the final > to < to get it to work in reverse.However, what do most people do in these situations? Write the algorithm twice in two if-statements, one where it's > and the other where it's < instead? What is the "correct" way to typically handle these kinds of scenarios where the change is minor but it simply changes the nature of the loop/code entirely? I know this question is a little subjective.
You could use a variable for the less-than operator:
Option 1:Option 2:
You'll probably notice that sorted and list.sort and all other functions that do any kind of potentially-decorated processing have a key parameter, and those that specifically do ordering also have a reverse parameter. (The Sorting Mini-HOWTO covers this.)So, you can look at how they're implemented. Unfortunately, in CPython, all of this stuff is implemented in C. Plus, it uses a custom algorithm called "timsort" (described in listsort.txt). But I think can explain the key parts here, since it's blindingly simple. The list.sort code is separate from the sorted code, and they're both spread out over a slew of functions. But if you just look at the top-level function listsort, you can see how it handles the reverse flag:Why reverse the list at the start as well as the end? Well, in the case where the list is nearly-sorted in the first place, many sort algorithms—including both timsort and your insertion sort—will do a lot better starting in the right order than in backward order. Yes, it wastes an O(N) reverse call, but you're already doing one of those—and, since any sort algorithm is at least O(N log N), and yours is specifically O(N^2), this doesn't make it algorithmically worse. Of course for smallish N, and a better sort, and a list in random order, this wasted 2N is pretty close to N log N, so it can make a difference in practice. It'll be a difference that vanishes as N gets huge, but if you're sorting millions of smallish lists, rather than a few huge ones, it might be worth worrying about.Second, notice that it does the reversing by creating a reverse slice. This, at least potentially, could be optimized by referencing the original list object with __getitem__ in reverse order, meaning the two reversals are actually O(1). The simplest way to do this is to literally create a reverse slice: lst[::-1]. Unfortunately, this actually creates a new reversed list, so timsort includes its own custom reverse-slice object. But you can do the same thing in Python by creating a ReversedList class.This probably won't actually be faster in CPython, because the cost of the extra function calls is probably high enough to swamp the differences. But you're complaining about the algorithmic cost of the two reverse calls, and this solves the problem, in effectively the same way that the built-in sort functions do.You can also look at how PyPy does it. Its list is implemented in listobject.py. It delegates to one of a few different Strategy classes depending on what the list contains, but if you look over all of the strategies (except the ones that have nothing to do), they basically do the same thing: sort the list, then reverse it.So, it's good enough for CPython, and for PyPy… it's probably good enough for you.


Answer URL
