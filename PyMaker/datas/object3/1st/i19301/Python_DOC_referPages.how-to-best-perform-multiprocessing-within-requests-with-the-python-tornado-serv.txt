Natural Text
I am using the I/O non-blocking python server Tornado.  I have a class of GET requests which may take a significant amount of time to complete (think in the range of 5-10 seconds).  The problem is that Tornado blocks on these requests so that subsequent fast requests are held up until the slow request completes.I looked at: https://github.com/facebook/tornado/wiki/Threading-and-concurrency and came to the conclusion that I wanted some combination of #3 (other processes) and #4 (other threads).  #4 on its own had issues and I was unable to get reliable control back to the ioloop when there was another thread doing the "heavy_lifting". (I assume that this was due to the GIL and the fact that the heavy_lifting task has high CPU load and keeps pulling control away from the main ioloop, but thats a guess).So I have been prototyping how to solve this by doing "heavy lifting" tasks within these slow GET requests in a separate process and then place a callback back into the Tornado ioloop when the process is done to finish the request. This frees up the ioloop to handle other requests.I have created a simple example demonstrating a possible solution, but am curious to get feedback from the community on it.My question is two-fold: How can this current approach be simplified?  What pitfalls potentially exist with it?The ApproachUtilize Tornado's builtin asynchronous decorator which allows a request to stay open and for the ioloop to continue.Spawn a separate process for "heavy lifting" tasks using python's multiprocessing module.  I first attempted to use the threading module but was unable to get any reliable relinquishing of control back to the ioloop. It also appears that mutliprocessing would also take advantage of multicores.Start a 'watcher' thread in the main ioloop process using the threading module who's job it is to watch a multiprocessing.Queue for the results of the "heavy lifting" task when it completes.  This was needed because I needed a way to know that the heavy_lifting task had completed while being able to still notify the ioloop that this request was now finished.Be sure that the 'watcher' thread relinquishes control to the main ioloop loop often with time.sleep(0) calls so that other requests continue to get readily processed.When there is a result in the queue then add a callback from the "watcher" thread using tornado.ioloop.IOLoop.instance().add_callback() which is documented to be the only safe way to call ioloop instances from other threads.Be sure to then call finish() in the callback to complete the request and hand over a reply.Below is some sample code showing this approach.  multi_tornado.py is the server implementing the above outline and call_multi.py is a sample script that calls the server in two different ways to test the server.  Both tests call the server with 3 slow GET requests followed by 20 fast GET requests.  The results are shown for both running with and without the threading turned on.In the case of running it with "no threading" the 3 slow requests block (each taking a little over a second to complete).  A few of the 20 fast requests squeeze through in between some of the slow requests within the ioloop (not totally sure how that occurs - but could be an artifact that I am running both the server and client test script on the same machine).  The point here being that all of the fast requests are held up to varying degrees.In the case of running it with threading enabled the 20 fast requests all complete first immediately and the three slow requests complete at about the same time afterwards as they have each been running in parallel.  This is the desired behavior. The three slow requests take 2.5 seconds to complete in parallel - whereas in the non threaded case the three slow requests take about 3.5 seconds in total.  So there is about 35% speed up overall (I assume due to multicore sharing).  But more importantly - the fast requests were immediately handled in leu of the slow ones.I do not have a lot experience with multithreaded programming - so while this seemingly works here I am curious to learn:Is there a simpler way to accomplish this?  What monster's may lurk within this approach? (Note:  A future tradeoff may be to just run more instances of Tornado with a reverse proxy like nginx doing load balancing.  No matter what I will be running multiple instances with a load balancer - but I am concerned about just throwing hardware at this problem since it seems that the hardware is so directly coupled to the problem in terms of the blocking.)Sample Codemulti_tornado.py (sample server):call_multi.py (client tester):Test ResultsBy running python call_multi.py slow  (the blocking behavior):By running python call_multi.py slow_threaded  (the desired behavior):
If you're willing to use concurrent.futures.ProcessPoolExecutor instead of multiprocessing, this is actually very simple. Tornado's ioloop already supports  concurrent.futures.Future, so they'll play nicely together out of the box. concurrent.futures is included in Python 3.2+, and has been backported to Python 2.x.Here's an example:Output:ProcessPoolExecutor has a more limited API than multiprocessing.Pool, but if you don't need the more advanced features of multiprocessing.Pool, it's worth using because the integration is so much simpler.
multiprocessing.Pool can be integrated into the tornado I/O loop, but it's a bit messy. A much cleaner integration can be done using concurrent.futures (see my other answer for details), but if you're stuck on Python 2.x and can't install the concurrent.futures backport, here is how you can do it strictly using multiprocessing:The multiprocessing.Pool.apply_async and multiprocessing.Pool.map_async methods both have an optional callback parameter, which means that both can potentially be plugged into a tornado.gen.Task. So in most cases, running code asynchronously in a sub-process is as simple as this:As I mentioned, this works well in most cases. But if worker() throws an exception, callback is never called, which means the gen.Task never finishes, and you hang forever. Now, if you know that your work will never throw an exception (because you wrapped the whole thing in a try/except, for example), you can happily use this approach. However, if you want to let exceptions escape from your worker, the only solution I found was to subclass some multiprocessing components, and make them call callback even if the worker sub-process raised an exception:With these changes, the exception object will be returned by the gen.Task, rather than the gen.Task hanging indefinitely. I also updated my async_run method to re-raise the exception when its returned, and made some other changes to provide better tracebacks for exceptions thrown in the worker sub-processes. Here's the full code:Here's how it behaves for the client:And if I send two simultaneous curl requests, we can see they're handled asynchronously on the server-side:Edit:Note that this code becomes simpler with Python 3, because it introduces an error_callback keyword argument to all asynchronous multiprocessing.Pool methods. This makes it much easier to integrate with Tornado:All we need to do in our overridden apply_async is call the parent with the error_callback keyword argument, in addition to the callback kwarg. No need to override ApplyResult.We can get even fancier by using a MetaClass in our TornadoPool, to allow its *_async methods to be called directly as if they were coroutines:
If your get requests are taking that long then tornado is the wrong framework. I suggest you use nginx to route the fast gets to tornado and the slower ones to a different server.PeterBe has an interesting article where he runs multiple Tornado servers and sets one of them to be 'the slow one' for handling the long running requests see: worrying-about-io-blocking I would try this method.


Answer URL
https://docs.python.org/3/library/concurrent.futures.html#processpoolexecutor
