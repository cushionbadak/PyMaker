Natural Text
I'm trying to iterate through a subset of elements in a list based on another list of indices. The shortest / most pythonic way seems like it would use list comprehension to the effect of:But I can't shake the feeling that if I'm going to be looping this a lot, rebuilding the list comprehension every time might be expensive and I should spend the extra line to just write:Can someone who knows more about python and its relative efficiencies / inefficiencies way in on the actual computational cost difference between these approaches? I know, I know both ways could probably work fine, but once I started wondering about the difference it got me curious.
Your second loop is fine, but your first loop can be made to work without building a temporary list by just using a generator expression:or (probably slightly faster if there are a lot of indices) by (ab?)using map:In both cases (at least on Py3 where map returns an iterator, not a new list), the effect is to lazily look up each index as the next elt is requested; it's not eagerly making a list before the loop even begins.There is one other option that you might consider if you're going to be looking up the same set of indices repeatedly (that is, idxs doesn't change). You could create an operator.itemgetter once up front, and use that. It would operate eagerly (like the list comprehension), but it would:Return a tuple instead of a list (slightly more memory efficient and with better memory locality, but usually not a meaningful difference)Push the building of said tuple, start to finish, down to the C layer, where a list comprehension, while using specialized bytecodes, still has to do all of its work in the regular interpreter, which at least on CPython is slower than most work pushed to CFor that approach, you'd do:You'd need to profile to determine:Whether any of this optimization is actually neededWhich solution makes the most sense for you (eager solutions like itemgetter and the listcomp use more memory, but might run faster; lazy solutions have fixed and small memory overhead, but might run a titch slower)


Answer URL
https://docs.python.org/3/glossary.html#term-generator-expression
