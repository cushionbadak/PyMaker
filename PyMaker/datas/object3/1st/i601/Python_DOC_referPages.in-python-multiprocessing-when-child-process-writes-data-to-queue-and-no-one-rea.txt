Natural Text
I have a python code where the main process creates a child process. There is a shared queue between the two processes. The child process writes some data to this shared queue. The main process join()s on the child process.If the data in the queue is not removed with get(), the child process does not terminate and the main is blocked at join(). Why is it so.Following is the code that I used :At present the q.get() is commented and so the output is :and then the code is blocked.But if I uncomment one of the q.get() invocations, then the code runs completely with the following output :
Well, if you look at the Queue documentation, it explicitly says that Queue.join : Blocks until all items in the queue have been gotten and processed. It seems logic to me that join() blocks your program if you don't empty the Queue.To me, you need to learn about the philosophy of Multiprocessing. You have several tasks to do that don't need each other to be run, and your program at the moment is too slow for you. You need to use Multiprocess !But don't forget there will (trust me) come a time when you will need to wait until some parallel computations are all done, because you need all of these elements to do your next task. And that's where, in your case, join() comes in. You are basically saying : I was doing things asynchronously. But now, my next task needs to be synced with the different items I computed before. Let's wait here until they are all ready.


Answer URL
https://docs.python.org/3/library/queue.html#queue.Queue.join
