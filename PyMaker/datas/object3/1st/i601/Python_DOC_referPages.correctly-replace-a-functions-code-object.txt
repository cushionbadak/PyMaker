Natural Text
I am attempting to take the source code of a function, add code to it, and then put it back in the original function.Basically like so:This works perfectly when new_code doesn't contain any name which wasn't in the original function.However when new_code contains a variable name which wasn't there in the original func, then on the last line I get the following error:Any ideas?EDIT:It seems I have found where in the CPython source code this exception is raised (file funcobject.c). Omitted some lines for clarity:Does this help you help me? :)
This exception is due to attempting to assign a code object to a function which closes over a different number of variables than the function it came from did. If that sentence sounded like gibberish then you should take a look at this answer.The easiest way to avoid this problem is to simply reassign the existing name in the obvious way, ie f = g instead of f.__code__ = g.__code__. By doing it this way the code object always stays with its matching closure (more on that later). In your case, that would look like func = getattr(throwaway_module, func.__name__). Is there some reason you can't do this and were mucking around with internal implementation details instead?In order to better illustrate what's happening here, suppose we have some silly functions.Even though do_stuff has a different number of local variables than dog, we can still successfully reassign code objects between them.However, we can't reassign between cats and dog because cats closes over the argument animal.ValueError: dog() requires a code object with 0 free vars, not 1This problem can be avoided by simply reassigning the name to the desired function object.In fact, if you were to successfully pull off a code object reassignment for a function with a closure, things would most likely not go as expected if the function were executed. This is because the closed over variables are saved separately from the compiled code, so they wouldn't match.As it turns out, we can't easily replace the __closure__ attribute because it is read-only. You could presumably work around it if you were really determined, but that's almost certainly a terrible idea.For more details about function object attributes, see this answer and the docs.


Answer URL
https://docs.python.org/3/library/inspect.html
