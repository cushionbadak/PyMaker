Natural Text
I read about the repr() function in python . I thought of experimenting something and thought of evaluating the output of repr() inside the object itself to see what it leads to . So I wrote the following code :I expected that by the time init gets called  the object would already have been created .  So thought of creating a new object of the same class inside one already created object . However , in the line  :I am getting a run-time error stating :However , I cannot understand as to why it is complaining of non-existence of an object when by the time init is being called the object would already have gotten created . However on replacing :by everything is working fine . What might be the reason behind this behavior ? Although semantically both and    self.b = eval(repr(self))mean the same . I guess I might be wrong in terms of detailing  here like , self.b = eval(repr(self)) might be meaning something else in terms of memory layout and might not mean the same as creating a replica object , but that kind of is what I am posting this question for . So why is yielding a run-time error ?(Additionally , it would be quite insightful to know how language designers think about permitting or restricting such kind of assignments )
If you want anything like this to work, you need to define a __repr__ that produces a valid, evaluable string. The default repr, as you've seen, just produces <qualified.classname object at 0xmemoryaddress>, which isn't valid Python code, and thus can't be eval-ed. This is an insane design even if you do that, because even if you can eval yourself, you've just created an infinite loop, where each instance tries to create an identical sub-instance, which creates an identical sub-instance, which creates an identical sub-instance, etc., etc., ad infinitum.Don't do this. Feel free to define a useful __repr__, but don't try evaling it in your own __init__.To be clear, self.b = self is not the same thing as self.b = eval(repr(self)). The former is just creating a reference cycle (a problem in its own right in some contexts, but generally not fatal). The latter is creating a brand new object based on the current object, which, given the current object is in the process of being constructed, would be a bad idea in many contexts even if it didn't lead to infinitely recursive object construction.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__repr__
