Natural Text
So I just came across what seems to me like a strange Python feature and wanted some clarification about it.  The following array manipulation somewhat makes sense:I imagine it is actually just appending this value to the end, correct?Why can I do this, however?  And even more so this:  This just seems like wrong logic. It seems like this should throw an error! Any explanation?-Is it just a weird thing Python does?-Is there a purpose to it?-Or am I thinking about this the wrong way?
Part of question regarding out-of-range indicesSlice logic automatically clips the indices to the length of the sequence.Allowing slice indices to extend past end points was done for convenience.  It would be a pain to have to range check every expression and then adjust the limits manually, so Python does it for you.Consider the use case of wanting to display no more than the first 50 characters of a text message.The easy way (what Python does now):Or the hard way (do the limit checks yourself):Manually implementing that logic for adjustment of end points would be easy to forget, would be easy to get wrong (updating the 50 in two places), would be wordy, and would be slow.  Python moves that logic to its internals where it is succint, automatic, fast, and correct.  This is one of the reasons I love Python :-)Part of question regarding assignments length mismatch from input lengthThe OP also wanted to know the rationale for allowing assignments such as p[20:100] = [7,8] where the assignment target has a different length (80) than the replacement data length (2).It's easiest to see the motivation by an analogy with strings.  Consider, "five little monkeys".replace("little", "humongous").  Note that the target "little" has only six letters and "humongous" has nine.  We can do the same with lists:This all comes down to convenience.  Prior to the introduction of the copy() and clear() methods, these used to be popular idioms:Even now, we use this to update lists when filtering:Hope these practical examples give a good perspective on why slicing works as it does.  
The documentation has your answer:s[i:j]: slice of s from i to j (note (4))(4) The slice of s from i to j is defined as the sequence of items  with index k such that i <= k < j. If i or j is greater thanlen(s), use len(s). If i is omitted or None, use 0. If j  is omitted or None, use len(s). If i is greater than or equal to  j, the slice is empty.The documentation of IndexError confirms this behavior:exception IndexErrorRaised when a sequence subscript is out of range. (Slice indices are silently truncated to fall in the allowed range; if an index is  not an integer, TypeError is raised.)Essentially, stuff like p[20:100] is being reduced to p[len(p):len(p]. p[len(p):len(p] is an empty slice at the end of the list, and assigning a list to it will modify the end of the list to contain said list. Thus, it works like appending/extending the original list.This behavior is the same as what happens when you assign a list to an empty slice anywhere in the original list. For example:


Answer URL
https://docs.python.org/3/library/stdtypes.html#common-sequence-operations
https://docs.python.org/3/library/exceptions.html#IndexError
