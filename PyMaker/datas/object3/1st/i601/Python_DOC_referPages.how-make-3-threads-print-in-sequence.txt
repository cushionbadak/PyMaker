Natural Text
I need make 3 threads for printing a semaphore colors: red, yellow and green on this order, and after that, each tread must sleep for N seconds randomly.Each color must be printed for one thread, and all this process must repeat N times. I've tried move the lock.acquire() and lock.release() to out of the for loop but does not work =(Briefly my code is printing that: but I need this to be the displayed result:
Okay, you're desired output would kill the whole point of multi-threading.Why?A thread has a beginning, an execution sequence, and a conclusion. It  has an instruction pointer that keeps track of where within its  context it is currently running.Continuing from that, the point in your question would be running the multiple threads concurrently, regardless of the fact which function executes first.What you're trying is:Running the threads in a sequential manner, regardless of which thread completes first, that is so not multi-threading. Above that, your using lock.acquire() and lock.release() inside each function to take the soul out of multi-threadingAnswer:if you really want the threads to run in sequential manner, you should not be acquiring and releasing the threads inside the functions,A little change:OUTPUT:
Don't try to use threading.Lock().  A lock object is only meant to be used for mutual exclusion (i.e., to prevent two or more threads from accessing the same data at the same time.)  It is not intended for communication between threads.IMO, the best way to do this would be to use three Semaphore instances.  Python has a class, asyncio.Semaphore, but I'm a little puzzled by the words "not thread safe" in its documentation. I have never used that class, but it looks like the semaphores from other language libraries which are intended for signalling between threads.A semaphore is like a blocking queue that contains zero or more permits. The permits are abstract; they don't actually exist. The semaphore merely keeps a count of how many of them it is supposed to "contain" at any given moment in time. A caller can attempt to acquire() a permit, which will decrement the count and immediately return if the count was greater than zero, or which will wait until some other thread release()s a permit otherwise.So here's how you would use it:Make three empty semaphores (count == 0), one for each of your threads, and give each thread a reference to its own semaphore, and also, to the next thread's semaphore.  Then each thread should loop:After your main thread has created the three semaphores and the three worker threads, nothing will happen because all three workers will be waiting in acquire().  So then, the last thing the main thread needs to do is red_worker_semaphore.release(), and then they should start running, one-by-one, in the proper order.
I made it!Thanks for everyone tips! but I remake all my code usingo threading.Lock() and threading.Event() and work's fine!
That is another version of the same code, but using pure semaphore, instead events


Answer URL
https://docs.python.org/3/library/asyncio-sync.html#asyncio.Semaphore
