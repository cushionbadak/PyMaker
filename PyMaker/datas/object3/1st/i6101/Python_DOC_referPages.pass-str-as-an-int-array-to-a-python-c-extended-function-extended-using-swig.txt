Natural Text
How can I pass a str value (containing 3000 {'0', '1'} bytes) obtained using python code as an argument to a python c extended function (extended using SWIG) which requires int * (fixed length int array) as an input argument? My code is such:What I've tried was to use ctypes (see below code):with 3072 {0, 1} entered in the  position. Python returns syntax error : more than 255  arguments. This still doesn't help me to pass assigned str value instead of the initialized ctypes int array.Other suggestion included using SWIG typemaps but how would that work for converting a str into int * ? Thanks in advance.
Regarding my comment, here are some more details about returning arrays from functions: [SO]: Returning an array using C. In short: ways handle this:Make the returned variable staticDynamically allocate it (using malloc (family) or new)Turn it into an additional argument for the functionGetting that piece of C code to run within the Python interpreter is possible in 2 ways:[Python 3]: Extending Python with C or C++ - which creates a C written Python moduleA way of doing that is using swig which offers a simple interface for generating the module ([swig]: SWIG Basics) saving you the trouble of writing it yourself using [Python 3]: Python/C API Reference ManualThe other way around, leaving the code in a standard dll which can be accessed via [Python 3]: ctypes - A foreign function library for PythonSince they both are doing the same thing, mixing them together makes no sense. So, pick the one that best fits your needs.1. ctypesThis is what you started withIt's one of the ways of doing things using ctypesctypes_demo.c:Notes:Based on comments, I changed the types in the function from int* to char*, because it's 4 times more compact (although it's still ~700% inefficient since 7 bits of each char are ignored versus only one of them being used; that can be fixed, but requires bitwise processing)I took a and turned into the 2nd argument (bitsOut). I think this is best because it's caller responsibility to allocate and deallocate the array (the 3rd option from the beginning)I also modified the index range (without changing functionality), because it makes more sense to work with low index values and add something to them in one place, instead of a high index values and subtract (the same) something in another placeThe return value is the number of bits set (obviously, 1000 in this case) but it's just an exampleprintf it's just dummy, to show that the C code gets executedWhen dealing with such arrays, it's recommended to pass their dimensions as well, to avoid out of bounds errors. Also, error handling is an important aspecttest_ctypes.py:Notes:1st, I want to mention that running your code didn't raise the error you gotSpecifying function's argtypes and restype is mandatory, and also makes things easier (documented in the ctypes tutorial)I am printing the bits_out array (only the first - and relevant - part, as the rest are 0) in order to prove that the C code did its jobI initialize bits_in array with 2000 dummy 0 at the beginning, as those values are not relevant here. Also, the input string (bits_string) is not 3000 characters long (for obvious reasons). If your bits_string is 3000 characters long you can simply initialize bits_in like: bits_in = create_string_buffer(bits_string.encode())Do not forget to initialize bits_out to an array with a size large enough (in our example 1000) for its purpose, otherwise segfault might arise when trying to set its content past the sizeFor this (simple) function, the ctypes variant was easier (at least for me, since I don't use swig frequently), but for more complex functions / projects it will become an overkill and switching to swig would be the right thing to doOutput (running with Python3.5 on Win):2. swigAlmost everything from the ctypes section, applies here as wellswig_demo.c:swig_demo.i:swig_demo.h:Notes:Here I'm allocating the array and return it (the 2nd option from the beginning)The .i file is a standard swig interface fileDefines the module, and its exports (via %include)One thing that is worth mentioning is the %newobject directive that deallocates the pointer returned by exposekey to avoid memory leaksThe .h file just contains the function declaration, in order to be included by the .i file (it's not mandatory, but things are more elegant this way) The rest is pretty much the sametest_swig.py:Notes:Things make much more sense from Python programmer's  PoVCode is a lot shorter (that is because swig did some "magic" behind the scenes):The wrapper .c wrapper file generated from the .i file has ~120KThe swig_demo.py generated module has ~3KI used the same technique with 2000 0 at the beginning of the stringOutput:3. Plain Python C APII added this part as a personal exerciseThis is what swig does, but "manually"capi_demo.c:Notes:It requires swig_demo.h and swig_demo.c (not going to duplicate their contents here)It only works with Python 3 (actually I got quite some headaches making it work, especially because I was used to PyString_AsString which is no longer present)Error handling is poortest_capi.py is similar to test_swig.py with one (obvious) difference: from swig_demo import exposekey should be replaced by from capi_demo import exposekeyThe output is also the same to test_swig.py (again, not going to duplicate it here)


Answer URL
https://docs.python.org/3/extending/extending.html
https://docs.python.org/3/c-api/index.html#c-api-index
https://docs.python.org/3/library/ctypes.html#module-ctypes
