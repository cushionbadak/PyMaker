Natural Text
I want to create a python dictionary that returns me the key value for the keys are missing from the dictionary.Usage example:
dicts have a __missing__ hook for this:
Why don't you just useSure, you can subclass dict as others point out, but I find it handy to remind myself every once in a while that get can have a default value!If you want to have a go at the defaultdict, try this:except... well: AttributeError: ^collections.defaultdict^object attribute '__missing__' is read-only, so you will have to subclass:
The first respondent mentioned defaultdict,but you can define __missing__ for any subclass of dict:Also, I like the second respondent's approach:
Congratulations. You too have discovered the uselessness of thestandard collections.defaultdict type. If that execrable midden heap of code smelloffends your delicate sensibilities as much as it did mine, this is your luckyStackOverflow day.Thanks to the forbidden wonder of the 3-parametervariant of the type()builtin, crafting a non-useless default dictionary type is both fun and profitable.What's Wrong with dict.__missing__()?Absolutely nothing, assuming you like excess boilerplate and the shocking silliness of collections.defaultdict â€“ which should behave as expected but really doesn't. To be fair, JochenRitzel's acceptedsolution of subclassing dict andimplementing the optional __missing__()method is a fantasticworkaround for small-scale use cases only requiring a single default dictionary.But boilerplate of this sort scales poorly. If you find yourself instantiatingmultiple default dictionaries, each with their own slightly different logic forgenerating missing key-value pairs, an industrial-strength alternativeautomating boilerplate is warranted.Or at least nice. Because why not fix what's broken?Introducing DefaultDictIn less than ten lines of pure Python (excluding docstrings, comments, andwhitespace), we now define a DefaultDict type initialized with a user-definedcallable generating default values for missing keys. Whereas the callable passedto the standard collections.defaultdict type uselessly accepts noparameters, the callable passed to our DefaultDict type usefully accepts thefollowing two parameters:The current instance of this dictionary.The current missing key to generate a default value for.Given this type, solving sorin'squestion reduces to a single line of Python:Sanity. At last.Code or It Didn't HappenThe key ...get it, key? to this arcane wizardry is the call tothe 3-parameter variantof the type() builtin:This single line dynamically generates a new dict subclass aliasing theoptional __missing__ method to the caller-defined callable. Note the distinctlack of boilerplate, reducing DefaultDict usage to a single line of Python.Automation for the egregious win.
I agree this should be easy to do, and also easy to set up with different defaults or functions that transform a missing value somehow.Inspired by Cecil Curry's answer, I asked myself: why not have the default-generator (either a constant or a callable) as a member of the class, instead of generating different classes all the time? Let me demonstrate:How does it work? Not so difficult:Of course, one can debate whether one wants to allow changing the default-function after initialisation, but that just means removing @default.setter and absorbing its logic into __init__.Enabling introspection into the current (constant) default value could be added with two extra lines.
Subclass dict's __getitem__ method.  For example, How to properly subclass dict and override __getitem__ & __setitem__


Answer URL
https://docs.python.org/3/library/functions.html#type
https://docs.python.org/3/library/stdtypes.html#dict
https://docs.python.org/3/library/functions.html#type
