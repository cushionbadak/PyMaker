Natural Text
Here is the way I come up with:But that doesn't work at all, and the function still outputs the original strings ('bats bear', 'cats pear'). What's wrong with this approach?
The problem you are having is that in Python, strings (i.e., str type objects) are immutable objects. Because a string object cannot be changed, ANY function you perform on a string never changes the original string. It ALWAYS remains the same:If you want to get a manipulated version of your string, you have to save the manipulated version somewhere and return THAT. The other answers that have been provided show clearly how to do this.As for your actual problem, I would suggest using a generator. A generator is a function that behaves very differently from a normal function. One of these differences is the generator function is capable of generating multiple results- one at a time- with only a single function call.To make a generator, instead of using the word return, you use yield. Here is an example:Note that the *strings syntax allows the function to accept multiple arguments. The arguments are available inside your function under a list with the name strings.The reason the above code works is that the last line auto-magically performs an UNPACKING of your executed generator. In other words, each result is yielded one at a time, and unpacked into the corresponding provided names one at a time.Be careful, however, that you don't try to do THIS:This will NOT work the way you expect. It will not work because a = sub_strings(a) does not unpack the generator; it instead creates a generator and assigns it to a; the generator has NOT been unpacked. Clarification on terminology: sub_strings is a generator function; sub_strings(a,b,c) creates a generator using that generator function.To unpack the generator to a single name, do this instead:The extra comma makes the a into a tuple of symbols instead of a singleton. This lets the interpreter know that you mean to "unpack" the generator into the lone symbol, a. I like this syntax very much because it keeps you from making errors that are not always easy to see. For example, if you provide too many arguments to sub_strings but not enough variables, it will give you an error and let you know there is a problem:Another way to use your generator is to simply stuff the results into a list, a tuple, or anything else that accepts an iterable object (generators are iterable):There is also another very nice alternative syntax that does the same thing. Here we see that star again (some people call it the "splat"). The splat "unpacks" the generator one value at a time, much the same as it was automatically unpacked before:Lastly: you don't even have to define a function to make a generator. You can instead just use what is called a generator expression. You can use such an expression in any of the places we used our generator above:Observe that the part that is called the generator expression replaced the generator function call- which creates a generator- in the previous versions of the code.However, if your goal is a list an even shorter syntax is just to use what is called a list comprehension:There is much, MUCH more to learn about Python generators. Go here to get started.
does not do what you think it does. It merely rebinds the variable named s to the modified string returned by re.sub(). It does not alter the variables a nor b. You can check that by printing out the value of s in the loop.Instead you can return a generator:A list comprehension will also work:Either way, the result will be unpacked into the variables a and b as required.You might want to consider generalising the function so that it accepts an arbitrary number of parameters:Now you can call it with any number of arguments:
Try this


Answer URL
https://docs.python.org/3/reference/expressions.html#grammar-token-generator_expression
