Natural Text
From the Google Style Guide on lexical scoping:A nested Python function can refer to variables defined in enclosing  functions, but can not assign to them.This specification can be seen here:Reversing the order of the two statements in nested gets rid of this issue:My question is, what is it about Python's implementation that tells the first function that a will be declared locally (after the print statement)?  My understanding is that Python is effectively interpreted line by line.  So, shouldn't it default to looking for a nonlocal a at that point in the code?To elaborate, if I was to use just reference (no assignment),somehow the print statement knows to reference the nonlocal a defined in the enclosing function.  But if I assign to a local a after that line, the function is almost too smart for its own good.
My understanding is that Python is effectively interpreted line by line.That's not the right mental model.The body of the entire function is analysed to determine which names refer to local variables and which don't.To simplify your example, the following also gives UnboundLocalError:Here, func() compiles to the following bytecodes:Compare this withwhich compiles toObserve how the absence of assignment to a turns the reference from a local to a global one.
My understanding is that Python is effectively interpreted line by lineThat's where you're wrong. The whole file is compiled to bytecode before any interpretation begins.Also, even if the bytecode compilation pass didn't exist, print(a + 2) wouldn't actually be executed before a = 7 is seen, because it's in a function definition. Python would still know about the a = 7 by the time it actually tries to execute print(a + 2).
As per documentA special quirk of Python is that – if no global statement is in effect – assignments to names always go into the innermost scope. Assignments do not copy data — they just bind names to objects.


Answer URL
https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces
