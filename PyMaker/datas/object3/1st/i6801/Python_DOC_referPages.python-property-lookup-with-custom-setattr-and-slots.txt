Natural Text
I have a class that uses __slots__ and makes them nearly immutable by overriding __setattr__ to always raise an error:Here, the "private" attribute _x is a place-holder for a complex operation to interact with some custom hardware.Since x is a property, I expect to be able to do something likeInstead, I see my AttributeError with the message Immutable!.There are a number of obvious workarounds here, such as to remove the custom __setattr__ (which I do not want to do) or to rewrite it asThis seems like an awkward method that has the potential to balloon out of proportion if I start adding more properties like that.The real issue is that I do not understand why there is no conflict between __slots__ and the property, but there is one between __setattr__ and the property. What is happening with the lookup order, and is there another, more elegant workaround to this problem?
The real issue is that I do not understand why there is no conflict between __slots__ and the property, but there is one between __setattr__ and the property.Both __slots__ and property implement attribute lookup by providing a descriptor for the corresponding attribute(s). The presence of __slots__ prevents arbitrary instance attribute creation not by doing anything to __setattr__, but by preventing creation of a __dict__. property and other descriptors don't rely on an instance __dict__, so they're unaffected.However, __setattr__ handles all attribute assignment, meaning that descriptor invocation is __setattr__'s responsibility. If your __setattr__ doesn't handle descriptors, descriptors won't be handled, and property setters won't be invoked.is there another, more elegant workaround to this problem?You could explicitly allow only properties:or you could explicitly reject assignment to slots, and delegate other attribute assignment to super().__setattr__:


Answer URL
https://docs.python.org/3/reference/datamodel.html#descriptors
