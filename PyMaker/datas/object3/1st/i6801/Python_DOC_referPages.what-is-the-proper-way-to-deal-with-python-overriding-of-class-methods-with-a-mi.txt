Natural Text
I'm having a minor, I hope, issue with theory and the proper way to deal with a problem. It's easier for me to show an example then to explain as I seem to fail with my vocabulary.Now the goal is to extend Original_1 or Original_2 with new methods in the Mixin, but I run into some questions if I use meth1(), meth2(), or meth3() in the mixin. 1. I'm not referencing Original_1 or Origninal_2 in the mixin. (At this point it runs but I don't like it.) 2. If I make Mixin a child of Original_1, it breaks. I could make two separate NewClass_X but then I'm duplicating all of that code. 
Mixins are used to add functionality (usually methods) to classes by using multiple inheritance.For example, let's say you want to make a class's __str__ method return everything in uppercase. There are two ways you can do this:Manually change every single class's __str__ method:Create a mixin class that does only this and inherit from it:In the second example, notice how UpperStrMixin is completely useless as a standalone class. Its only purpose is to be used with multiple inheritance as a base class and to override your class's __str__ method.In your particular case, the following will work:Even though Mixin.meth1 and Mixin.meth2 aren't defined, this isn't an issue because an instance of Mixin is never created directly and it's only used indirectly through multiple inheritance.
Since Mixin is not a standalone class, you can just write it to assume that the necessary methods exist, and it will find them on self assuming the self in question provides, or derives from another class which provides, meth1 and meth2.If you want to ensure the methods exist, you can either document it in the Mixin docstring, or for programmatic enforcement, use the abc module to make Mixin an ABC and specify what methods must be defined; if a given class doesn't provide them (directly or via inheritance) then you'll get an error if you attempt to instantiate it (because the class is still abstract until those methods are defined):Beyond that, you can simplify your code significantly by using super appropriately, which would remove the need to explicitly call the __init__s for each parent class; they'd be called automatically so long as all classes use super appropriately (note: for safety, in cooperative inheritance like this, you usually accept the current class's recognized arguments plus varargs, passing the varargs you don't recognize up the call chain blindly):Note that using super everywhere means you don't need to explicitly call each __init__ for your parents; it automatically linearizes the calls, so for example, in NewClass_2, that single super().__init__ will delegate to the first parent (Original_2), which then delegates to Original_1, which then delegates to Mixin (even though Original_1 knows nothing about Mixin).In more complicated multiple inheritance (say, you inherit from Mixin through two different parent classes that both inherit from it), using super is the only way to handle it reasonably; super naturally linearizes and deduplicates the parent class tree, so even though two parents derive from it, Mixin.__init__ would still only be called once, preventing subtle errors from initializing Mixin more than once.Note: You didn't specify which version of Python you're using. Metaclasses and super are both better and simpler in Python 3, so I've used Python 3 syntax. For Python 2, you'd need to set the metaclass a different way, and call super providing the current class object and self explicitly, which makes it less nice, but then, Python 2 is generally less nice at this point, so consider writing new code for Python 3?


Answer URL
https://docs.python.org/3/library/abc.html
https://docs.python.org/3/library/functions.html#super
