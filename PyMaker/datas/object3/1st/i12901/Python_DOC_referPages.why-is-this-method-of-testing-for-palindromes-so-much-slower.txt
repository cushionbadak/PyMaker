Natural Text
I have two different methods of testing for a palindrome. One is the following:Very simple, of course, but I had imagined it would be slow as it (surely) has to store the value of text[::-1] somewhere after reversing it, then it checks every character in both. So, I attempted another method:It starts at the start and end points, and works its way into the center. This should, as far as I can tell, be faster, since it only checks [0, n // 2) and vice versa for the end. However, when I use timeit to test these, the first is 0.32 and the second is 1.34. Why?
I think it is informative to use dis to have a look at the the bytecode produced here:Palindrome:Palindrome_2:Essentially when doing the same amount of work C code will be faster than the corresponding python code.As you can see the first approach calls a built in function, which is written in fast C. The second function has to do more of the work in python code, including handling the looping construct overhead, which will be slower than the call to the C.


Answer URL
https://docs.python.org/3/library/dis.html
