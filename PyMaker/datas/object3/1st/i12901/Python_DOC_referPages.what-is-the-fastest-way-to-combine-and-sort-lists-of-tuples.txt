Natural Text
I have a list of lists of tuples. Each tuple has the form (string,int), e.g.Think of the int's as counts of each string in different blocks of text.What I need to do is produce a list of top-N occurring strings together with their cumulative counts. So in the example above, a appears 5 times, b appears twice, c appears 24 times etc. If N=2, then I would have to produce either a pair of parallel lists ['d','c'] and [25,24] or a list of tuples [('d',25),('c',24)]. I need to do it as quickly as possible. My machine has lots of RAM so memory is not an issue.I have this implementation:There's gotta be a better way, but what would it be?
Use collections.Counter:Output:The Counter is basically a dictionary with some added functionality, so looking up a value and adding to it's current count is really fast. dict(x) will just turn the list of tuples into a regular dict, mapping strings to numbers, then the update method of Counter will add those counts (instead of just overwriting the values, as a regular dict would do).Alternatively, a more manual approach using a defaultdict:As pointed out by John in comments, the defaultdict is indeed much faster:
Another option, using numpy:This will get you counts (unique_counts) for each unique character (unique_chars) in the lists, not just the top N. This should be pretty fast, but might be heavy on memory.


Answer URL
https://docs.python.org/3/library/collections.html#collections.Counter
https://docs.python.org/3/library/collections.html#collections.defaultdict
