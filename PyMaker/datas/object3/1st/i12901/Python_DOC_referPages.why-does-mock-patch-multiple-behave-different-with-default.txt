Natural Text
If patch.multiple is used as a method/function decorator it's behaviour is different if the patched object is mock.DEFAULT or not.Example:Is there a reason for this behaviour that I'm not seeing? I can't see a reason why it doesn't pass the new mock into the function in all cases.
The docs say (emphasis is mine):Use DEFAULT as the value if you want patch.multiple() to create mocks  for you. In this case the created mocks are passed into a decorated  function by keyword, and a dictionary is returned when  patch.multiple() is used as a context manager.So, when you don't use DEFAULT keyword what you use tho set your patched method isn't passed to the decorated function.Your with_other's decorator case can be rewrited as:Even when you use new attribute the argument isn't passed to decorated function because it supposed that you already know it and you don't need to get it as argument.General speaking: patch.multiple can be replaced by a stack of simple patch where the path is extend by argument name and use new to set the value:BecomeOr more simple by new positional argument:


Answer URL
https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch.multiple
