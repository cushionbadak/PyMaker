Natural Text
Here is my code:   Error:I have no idea why the linehistory object is not an iterator since it has already included __iter__ method in the class.
In short, "iterable" is the object I want to iterate over. It has __iter__().However, "iterator" is the object which is used for iteration. It has next() or __next__(). As any iterator is iterable as well (being its own iterator), it has __iter__() as well.You can get an iterator for any iterable with iter(obj).In your example, linehistory (which should be written LineHistory) is iterable as it has an .__iter__(). The generator object created with this is an iterator (as every generator object).
I have no idea why the linehistory object is not an iterator since it has already included __iter__ method in the class.Wrong. See Iterator Types:The iterator objects themselves are required to support the following two methods, which together form the iterator protocol:iterator.__iter__()  Return the iterator object itself. This is required to allow both containers and iterators to be used with the for and in statements. This method corresponds to the tp_iter slot of the type structure for Python objects in the Python/C API.iterator.__next__()  Return the next item from the container. If there are no further items, raise the StopIteration exception. This method corresponds to the tp_iternext slot of the type structure for Python objects in the Python/C API.However you can iterate over lines, that's because your __iter__ method is a generator function, see Generator Types:Python’s generators provide a convenient way to implement the iterator protocol. If a container object’s __iter__() method is implemented as a generator, it will automatically return an iterator object (technically, a generator object) supplying the __iter__() and __next__() methods. More information about generators can be found in the documentation for the yield expression.
Iterator objects need an __iter__ method but they also need to have next implemented:The iterator objects themselves are required to support the following two methods, which together form the iterator protocol:iterator.__iter__()  Return the iterator object itself. iterator.next()  Return the next item from the container. Python 2.7 SourceIn Python 3.x these are the function names:iterator.__iter__()  iterator.__next__()Python 3.x Source
Actually,All these other answers are wrong (except for @glglgl who has an obtuse style of writing). Your generator function __iter__() would work as is if you called it with a for loop like soBut because you used next(lines) you have to first use iter() to get the iterator (I presume it just calls iter() on the object) like soas Mr.Beazley points out


Answer URL
https://docs.python.org/3/library/stdtypes.html#iterator-types
https://docs.python.org/3/library/stdtypes.html#generator-types
https://docs.python.org/3/library/stdtypes.html#iterator-types
