Natural Text
I want to pass an instance of TestObj from the C++ code into python. The code posted here produces the error in cout: "No to_python (by-value) converter found for C++ type: class TestObj". If I move the object creation and main_module.attr("obj") = obj; into the BOOST_PYTHON_MODULE macro, the code runs fine.Similar things happen when I try passing a *TestObj with or without boost::ptr.testembed.py:testobj.htestobj.cppmain.cpp
Passing a C++ object to Python via Boost.Python has the same pre-conditions regardless of context in which it is called: a to-Python converter must be registered for the C++ object's type.When creating an instance of boost::python::class_<T>, to-Python and from-Python converters are automatically registered for type T.  The BOOST_PYTHON_MODULE macro only declares a Python module initialization function that Python will invoke when the module gets imported.  In this particular case, the problem can be resolved by performing either of the following before passing a TestObj instance to Python:Expose TestObj via class_ after the interpreter has been initialized within main().Import the statically linked sfgame module.  This requires explicitly adding the module initialization function tot he Python initialization table via PyImport_AppendInittab().  See this answer for details.Calling the module initialization functions directly is not recommended.  When called directly, the module itself is not created, but the types will be registered with Boost.Python.  Upon importing the module, the module will be created and initialized, causing the types to be registered once more.  In debug builds of Boost.Python, this will fail an assertion, and in release builds it will print a warning.Here is a complete example demonstrating passing C++ objects to Python when embedding.  In the example, the spam type if exposed within the statically linked example module, and the egg type is exposed within the __main__ scope.
From the documentation:"This macro generates two functions in the scope where it is used: extern "C" void initname(), and void init_module_name(), whose body must follow the macro invocation."You need to call initsfgame();.


Answer URL
https://docs.python.org/3/c-api/import.html#c.PyImport_AppendInittab
