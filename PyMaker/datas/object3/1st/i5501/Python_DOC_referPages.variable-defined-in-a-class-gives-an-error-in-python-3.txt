Natural Text
This question already has an answer here:Accessing class variables from a list comprehension in the class definition                    5 answers                This following simple code gives an error in Python 3.6 (but OK in 2.7):When I put the same code inside a function instead of a class: def XY(): ... it works. When I roll the list comprehension inside a regular loop, it also works. Python 2.7 works with the same code that gives an error in 3.6!Any idea what's wrong with accessing a local class variable from inside a list comprehension?
List comprehensions now use a function scope, that was a change between Python 2 and 3.  The variable pre will be inaccessible from within the list comprehension for this reason.  The new behavior is documented under the execution model (emphasis mine), with an example given that is very similar to the one you have found:Class definition blocks and arguments to exec() and eval() are special in the context of name resolution. A class definition is an executable statement that may use and define names. These references follow the normal rules for name resolution with an exception that unbound local variables are looked up in the global namespace. The namespace of the class definition becomes the attribute dictionary of the class. The scope of names defined in a class block is limited to the class block; it does not extend to the code blocks of methods â€“ this includes comprehensions and generator expressions since they are implemented using a function scope.  This means that the following will fail:Furthermore, pre name will also be inaccessible via the class XY.pre, because the class doesn't exist yet.  You will have to find another way to go about what you want to do.  
You can create z in the __init__ method of XY:


Answer URL
https://docs.python.org/3/reference/executionmodel.html
