Natural Text
What is the difference between the following class methods?Is it that one is static and the other is not?
In Python, there is a distinction between bound and unbound methods. Basically, a call to a member function (like method_one), a bound functionis translated toi.e. a call to an unbound method. Because of that, a call to your version of method_two will fail with a TypeErrorYou can change the behavior of a method using a decoratorThe decorator tells the built-in default metaclass type (the class of a class, cf. this question) to not create bound methods for method_two.Now, you can invoke static method both on an instance or on the class directly:
Methods in Python are a very, very simple thing once you understood the basics of the descriptor system.  Imagine the following class:Now let's have a look at that class in the shell:As you can see if you access the foo attribute on the class you get back an unbound method, however inside the class storage (the dict) there is a function.  Why's that?  The reason for this is that the class of your class implements a __getattribute__ that resolves descriptors.  Sounds complex, but is not.  C.foo is roughly equivalent to this code in that special case:That's because functions have a __get__ method which makes them descriptors.  If you have an instance of a class it's nearly the same, just that None is the class instance:Now why does Python do that?  Because the method object binds the first parameter of a function to the instance of the class.  That's where self comes from.  Now sometimes you don't want your class to make a function a method, that's where staticmethod comes into play:The staticmethod decorator wraps your class and implements a dummy __get__ that returns the wrapped function as function and not as a method:Hope that explains it.

When you call a class member, Python automatically uses a reference to the object as the first parameter. The variable self actually means nothing, it's just a coding convention. You could call it gargaloo if you wanted. That said, the call to method_two would raise a TypeError, because Python is automatically trying to pass a parameter (the reference to its parent object) to a method that was defined as having no parameters.To actually make it work, you could append this to your class definition:or you could use the @staticmethod function decorator.
method_two won't work because you're defining a member function but not telling it what the function is a member of. If you execute the last line you'll get:If you're defining member functions for a class the first argument must always be 'self'.
Accurate explanation from Armin Ronacher above, expanding on his answers so that beginners like me understand it well:Difference in the methods defined in a class, whether static or instance method(there is yet another type - class method - not discussed here so skipping it), lay in the fact whether they are somehow bound to the class instance or not. For example, say whether the method receives a reference to the class instance during runtimeThe __dict__ dictionary property of the class object holds the reference to all the properties and methods of a class object and thus the method foo is accessible as above. An important point to note here is that everything in python is an object and so references in the dictionary above are themselves pointing to other objects. Let me call them Class Property Objects - or as CPO within the scope of my answer for brevity.If a CPO is a descriptor, then python interpretor calls the __get__() method of the CPO to access the value it contains.In order to determine if a CPO is a descriptor, python interpretor checks if it implements the descriptor protocol. To implement descriptor protocol is to implement 3 methodsfor e.g. where self is the CPO (it could be an instance of list, str, function etc) and is supplied by the runtimeinstance is the instance of the class where this CPO is defined (the object 'c' above) and needs to be explicity supplied by usowner is the class where this CPO is defined(the class object 'C' above) and needs to be supplied by us. However this is because we are calling it on the CPO. when we call it on the instance, we dont need to supply this since the runtime can supply the instance or its class(polymorphism)value is the intended value for the CPO and needs to be supplied by usNot all CPO are descriptors. For example This is because the list class doesnt implement the descriptor protocol.Thus the argument self in c.foo(self) is required because its method signature is actually this C.__dict__['foo'].__get__(c, C) (as explained above, C is not needed as it can be found out or polymorphed)And this is also why you get a TypeError if you dont pass that required instance argument.If you notice the method is still referenced via the class Object C and the binding with the class instance is achieved via passing a context in the form of the instance object into this function. This is pretty awesome since if you chose to keep no context or no binding to the instance, all that was needed was to write a class to wrap the descriptor CPO and override its __get__() method to require no context. This new class is what we call a decorator and is applied via the keyword @staticmethodThe absence of context in the new wrapped CPO foo doesnt throw an error and can be verified as follows:Use case of a static method is more of a namespacing and code maintainability one(taking it out of a class and making it available throughout the module etc). It maybe better to write static methods rather than instance methods whenever possible, unless ofcourse you need to contexualise the methods(like access instance variables, class variables etc). One reason is to ease garbage collection by not keeping unwanted reference to objects.
that is an error.first of all, first line should be like this (be careful of capitals)Whenever you call a method of a class, it gets itself as the first argument (hence the name self) and method_two gives this error 
The second one won't work because when you call it like that python internally tries to call it with the a_test instance as the first argument, but your method_two doesn't accept any arguments, so it wont work, you'll get a runtime error.If you want the equivalent of a static method you can use a class method.There's much less need for class methods in Python than static methods in languages like Java or C#. Most often the best solution is to use a method in the module, outside a class definition, those work more efficiently than class methods.
The call to method_two will throw an exception for not accepting the self parameter the Python runtime will automatically pass it.If you want to create a static method in a Python class, decorate it with the staticmethod decorator.
Please read this docs from the Guido First Class everything Clearly explained how Unbound, Bound methods are born.
The definition of method_two is invalid. When you call method_two, you'll get TypeError: method_two() takes 0 positional arguments but 1 was given from the interpreter. An instance method is a bounded function when you call it like a_test.method_two(). It automatically accepts self, which points to an instance of Test, as its first parameter. Through the self parameter, an instance method can freely access attributes and modify them on the same object.


Answer URL
https://docs.python.org/3/library/functions.html?highlight=classmethod#classmethod
https://docs.python.org/3/library/functions.html#staticmethod
