Natural Text
I'm having a hard time understanding this:Running Python 3.5.3The number 809880023823263820 is obviously representable as an integer since it's the sum of an a.p. series with all integer parameters. What is the explanation for the 1st and 4th computations?
Python int objects have infinite precision (bounded only by memory). float objects do not have infinite precision; numbers are represented as an exponent and a significant, with the latter building up a number from 53 binary fractions. Binary fractions can't represent every possible decimal number and that is what is happening here.809880023823263820 is not cleanly representable using binary fractions:The number is stored as Note the last two digits; they are 72, not 20.Note that a float value is always stored as fractions, with the exponent determining the position of the decimal point; there is non 'integer portion'. Both very large and very small numbers are simply represented as a fraction with the decimal point shifted by the exponent.For the third expression, Python converts numbers to a common type. Subtracting an integer from a float causes the integer to be converted to a float first. Since float(809880023823263820) is the same floating point value as the result on the left of the - operator, the result is 0.0.From the Binary arithmetic operations section of the expressions reference documentation:The - (subtraction) operator yields the difference of its arguments. The numeric arguments are first converted to a common type.and a separate Arithmetic conversions section documents how this conversion is done:When a description of an arithmetic operator below uses the phrase “the numeric arguments are converted to a common type,” this means that the operator implementation for built-in types works as follows:If either argument is a complex number, the other is converted to complex;otherwise, if either argument is a floating point number, the other is converted to floating point;otherwise, both must be integers and no conversion is necessary.You probably want to explore a different representation of rational numbers, either the fractions or the decimal modules. Either let you handle rational numbers as abstract fractions, or let you configure the numeric precision.
Floats are only of limited precision, while integers have arbitrary precision. That means you cannot represent every integer as float in Python! You can easily see this if you check:From Wikipedia:The 53-bit significand precision gives from 15 to 17 significant decimal digits precision (2−53 ≈ 1.11 × 10−16). If a decimal string with at most 15 significant digits is converted to IEEE 754 double-precision representation, and then converted back to a decimal string with the same number of digits, the final result should match the original string.But your integer has 18 digits, so you shouldn't expect that a float can exactly represent that integer. There are values that can be represented exactly that are longer than 18 digits, but the conditions have to be "right" (for example powers of two):Your last example is actually a bit misleading because 52920/2.0 can be represented exactly as float and because you actually convert it to an integer the calculation will be done completely with integers and result in an accurate integer result.In the general case you could use Fraction to represent the value exactly:Note the , 2 instead of the / 2.0 here.


Answer URL
https://docs.python.org/3/reference/expressions.html#binary-arithmetic-operations
https://docs.python.org/3/reference/expressions.html#arithmetic-conversions
https://docs.python.org/3/library/fractions.html
https://docs.python.org/3/library/decimal.html
