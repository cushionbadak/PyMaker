Natural Text
I am trying to convert some data into a nested dictionary, where there is a general State key and then specific Area keys that match to numbers (as seen below).To get the data into this better form, I have a painful triple loop as seen below. However, it is not working properly because it is only saving the last number for every state/area. I have tried to adjust this code but do not see where to fix my iteration to make it properly loop through each iterator and place the growth numbers aaccordingly. The output that I am trying to get vs. the actual output is below - while there is no error message, the output is not what I am aiming for. Thank you for your help on this, and curious if this is a wildly inefficient (or okay) way to iterate when there are dictionaries inside dictionaries. Expected Output: Wrong Output:Edits above to reflect comments
You are assigning both the 2nd and 3rd values from your growth rows to all state and area pairings, with your innermost loop:So you end up assigning twice:Note how i and j have not changed!You don't need that 3rd loop at all, you already have picked your state and area; just pick out the right value from the table with that, using the area index, plus 1 to map to the right column:Now, using indices single-letter indices makes it hard to follow your code. You should really learn about the enumerate() function here, to generate indices:By looping directly over state, and using enumerate() to add an index starting at 1, you get both the state name ('NJ') and the right index into growth (1). The same happens for the area list (so 'North' and 1, or 'South' and 2).However, you already have all your row and column names in the growth matrix, so you can just generate all your dictionaries directly with that:The zip() function puts the area names (found on the first row of growth), together with the values from each column (stored in row, with the first value diverted to state).Note the for state, *row in .. loop; Python unpacks each list from growth into two variables; the first value is stored in state, and because row is prefixed with *, all remaining values are stored in row:That's really all you need:Last but not least, if all this data came from a CSV file, perhaps you should use the csv module instead:A DictReader() object takes the first row of a CSV file as the column names, and produces a dictionary for each row. If your state column uses quotes around the names, you can even use quoting=csv.QUOTE_NONNUMERIC to have the module automatically convert anything that is not quoted into a float() value for you.
Unless I'm missing something important, you do not need any nested loops for this, and you do not need those other two lists, as well. A single (nested) dict comprehension is enough.(This is assuming that the growth list contains each state no more than once and that the first, second and third items are always the state, north, and south values, in that order.)


Answer URL
https://docs.python.org/3/library/functions.html#enumerate
https://docs.python.org/3/library/functions.html#zip
https://docs.python.org/3/library/csv.html
