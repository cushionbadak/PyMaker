Natural Text
I am doing a rather complex match with python using re.match, which takes the form of (some_pattern_1)?(some_pattern_2)?..(.*)On the other side of it I have a unit test with about one hundred examples I am checking, which are all sending request asynchronously to my (local, development) server. The server is in django.I am sometime seing the match apparently be non-greedy (i.e. too many things end up in the last catch all block) and the unit test fail, but can't really reproduce it in isolation, and I don't really have an idea what's going on.More concretely, the relevant part of the regex is (in Python):And I am sometimes seeing this printed:Are there know conditions where this could happen (and am I correct to assume that the regex match is guaranteed to be fully deterministic in principle?) ?
Most of the string literals you're using to build your pattern are raw literals (introduced with the r prefix), which is greatâ€”the string interpreter therefore does not give backslash any special meaning, but instead leaves them intact for the regex parser.  However, you have unfortunately not used raw literals in every case:Consequently, the backslashes in those literals have the effect described under String and Bytes literals before the interpreted string is given to the regex compiler.  Accordingly, your \b boundary anchors are replaced with ASCII backspace characters!Either use raw string literals by prefixing them with r or else be sure to escape the backslashes they contain.There are however also a number of other issues with your code worth noting:As currently written, your regex won't compile due to some syntax errors.  In particular, the capture groups named amount and name are not terminated due to unbalanced brackets:There are four opening brackets, but only three closing brackets.  You probably intended to write:Similarly, r'(?P<name>.*, ... should probably be r'(?P<name>.*)', ... (note also the pattern string needs to be terminated before the argument separator).\b boundary anchors bind more tightly than | alternation, so when placed at the same level as your joined arrays they are only bound to the first and last elements of the alternatives respectively.  For example, the capture group named size is currently specified by the following pattern:Which is equivalent, in terms of precedence, to:Better instead to place the boundary anchors outside of the brackets:As shown above, the whitespace in your join expressions is likely to lead to unintended consequences: anySize and anyColor require that all but the final terms in their underlying arrays are, if present, followed by a space character (in addition to those that match the \s* patterns.  Better to join the arrays with '|' alone, rather than ' |':Depending on the source of the underlying arrays, and how confident you are that they do not contain any special regex patterns, you may wish to first escape the array elements.


Answer URL
https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals
