Natural Text
TL;DR: Is globals()[name] the CORRECT way to fall back to the "default"?I have a large set of dynamically created classes that are defined from a YML file.Dynamic class creation is accomplished via a combination of PyYAML yaml.safe_load_all and the dataclasses.make_dataclass (new in 3.7). I expect the specifications for these classes to occasionally change over time, which is why I chose YML as an easily understood format to describe them.Python 3.7 is introducing new functionality (see PEP 562): a module-level __getattr__ function for managing module attribute access (there is also a module-level __dir__ function). It would be convenient to utilize this new function to allow importing of each dynamically created dataclass class from the module namespace, like so:...and like so:In reading PEP 562 it isn't immediately clear to me how to fall back to default functionality for module attribute access. For a class, one would just call super().__getattr__(*args). I do see this line in one of the examples:This approach seems to work. Is globals()[name] the CORRECT way to fall back to the "default"? It doesn't seem to be, given that globals()[name] will raise a KeyError rather than the expected AttributeError.
You have it backwards. The module-level __getattr__ function is only called as a last resort. There is nothing to fall back to - all other mechanisms have already failed to find an attribute of that name.For example, if your module defines a global foo variable and someone accesses your_module.foo, then __getattr__ won't even be called.The PEP explains this in the specification:If an attribute is not found on a module object through the normal  lookup (i.e. object.__getattribute__), then __getattr__ is searched in  the module __dict__ before raising an AttributeError.Hence, the correct "fallback behavior" is to raise an AttributeError.


Answer URL
https://docs.python.org/3/library/functions.html#getattr
