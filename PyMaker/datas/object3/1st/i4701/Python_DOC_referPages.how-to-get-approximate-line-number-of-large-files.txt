Natural Text
I have CSV files with up to 10M+ rows.  I am attempting to get the total line numbers of a file so I can split the processing of each file into a multiprocessing approach.  To do this, I will set a start and end line for each sub-process to handle.  This cuts down my processing time from 180s to 110s for a file size of 2GB.  However, in order to do this, It requires to know the line number count.  If I attempt to get the exact line number count, it will take ~30seconds.  I feel like this time is wasted as an approximate with the final thread possibly having to read an extra hundred thousand lines or so, would only add a couple seconds as apposed to the 30 seconds it takes to get the exact line count.  How would I go about getting an approximate line count for files? I would like this estimate to be within 1 million lines (Preferably within a couple hundred thousand lines).  Would something like this be possible?
This will be horribly inaccurate but it will get the size of a row and divide it against the size of the file.(Edit) If you change the last line to  math.floor(os.path.getsize("example.csv") / _Size) It's actually  quite accurate
I'd suggest you split the file into chunks of similar size, before even parsing.The example code below will split data.csv into 4 chunks of approximately equal size, by seeking and searching for the next line break. It'll then call launch_worker() for each chunk, indicating the start offset and length of the data that worker should handle.Ideally you'd use a subprocess for each worker.Some expansion on markers in the code:You'll need to make sure that the read() will consume at least an entire line. Alternatively you could loop to perform multiple read()s if you don't know how long a line could be upfront.This assumes \n line endings... you may need to modify for your data.The last worker will get slightly less data to handle that the others... this is because we always search-forwards for the next line break. The more workers you have, the less data the final worker gets. It's not very significant (~200-500 bytes in my testing).Make sure you always use binary-mode, as text-mode can give you wonky seek()s / read()s.An example launch_worker() would look like this:


Answer URL
https://docs.python.org/3/library/subprocess.html
