Natural Text
I create all three-element permutations without mirroring, using itertools.product():  Output:How do I delete these sublisters from the list list_1, which have the same number of corresponding values and then leave only one of them?For example, in sublists [1,1,2], [1,2,1] the number of given values is the same in all, that is, in each sub-list there are two 1 and one 2, that's why I consider the sublisters to be the same and that's why I want to leave only the first one, namely  [1,1,2]. How can this be done?I was thinking about counting the number of corresponding values in each sub-list and creating a list with the occurring feature regarding the amount of given values, and then checking each element from the list list_1 in the loop or the element with the given feature has not occurred before. But it seems to me to be very complicated.
Rather than using product from the itertools module, use combinations_with_replacement. That does what you want in one line without any massaging afterward:The result of print(list1) after that isNote that your conversion of the range object to a tuple is not necessary.
This might do the trick:Which outputs:
You can sort each sublist and then extract unique sublists out as follows.Output:Now, there are more efficient options than sorting each sublist, but I will leave that upto you.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.combinations_with_replacement
