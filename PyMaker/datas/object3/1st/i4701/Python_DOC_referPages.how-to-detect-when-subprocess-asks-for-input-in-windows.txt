Natural Text
I have a subprocess that either quits with a returncode, or asks something and waits for user input.I would like to detect when the process asks the question and quit immediately. The fact that the process asks the question or not is enough for me to decide the state of the system.The problem is that I cannot read the question because the child process probably does not flush standard output. So I cannot rely on parsing subprocess.Popen().stdout: when trying to read it, well, it blocks because input is being read first.A bit like thisOf course, the actual subprocess is a third party binary, and I cannot modify it easily to add the necessary flush calls, which would solve it.I could also try the Windows equivalent of unbuffer (What is the equivalent of unbuffer program on Windows?) which is called winpty, which would (maybe) allow me to detect output and solve my current issue, but I'd like to keep it simple and I'd like to solve the standard input issue first...I tried... well, lots of things that don't work, including trying to pass a fake file as stdin argument, which doesn't work because subprocess takes the fileno of the file, and we cannot feed it rubbish...Using communicate with a string doesn't work either, because you cannot control when the string is read to be fed to the subprocess (probably through a system pipe).Those questions were promising but either relied on standard output, or only apply to LinuxDetecting when a child process is waiting for inputHow can I know whether my subprocess is waiting for my input ?(in python3)What I'm currently doing is running the process with a timeout, and if the timeout is reached, I then decide that the program is blocked. But it costs the timeout waiting time. If I could decide as soon as stdin is read by the subprocess, that would be better.I'd like to know if there's a native python solution (possibly using ctypes and windows extensions) to detect read from stdin. But a native solution that doesn't use Python but a non-Microsoft proprietary language could do.
if we not want let to child process process user input, but simply kill it in this case, solution can be next:start child process with redirected stdin to pipe.pipe server end we create in asynchronous mode and main set pipebuffer to 0 sizebefore start child - write 1 byte to this pipe.because pipe buffer is 0 size - operation not complete, until anotherside not read this byteafter we write this 1 byte and operation in progress (pending) -start child process.finally begin wait what complete first: write operation or child process ?if write complete first - this mean, that child process begin readfrom stdin  - so kill it at this pointone possible implementation on c++:another variant of code - use event completion, instead apc. however this not affect final result. this variant of code give absolute the same result as first:
My idea to find out if the subprocess reads user input is to (ab)use the fact that file objects are stateful: if the process reads data from its stdin, we should be able to detect a change in the stdin's state.The procedure is as follows:Create a temporary file that'll be used as the subprocess's stdinWrite some data to the fileStart the processWait a little while for the process to read the data (or not), then use the tell() method to find out if anything has been read from the fileThis is the code:Ideally the temporary file could be replaced by some kind of pipe or something that doesn't write any data to disk, but unfortunately I couldn't find a way to make it work without a real on-disk file.


Answer URL
https://docs.python.org/3/library/io.html#io.IOBase.tell
