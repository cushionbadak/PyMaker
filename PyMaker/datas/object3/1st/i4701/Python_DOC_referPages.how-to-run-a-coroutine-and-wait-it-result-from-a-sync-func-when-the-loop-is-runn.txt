Natural Text
I have a code like the foolowing:When the loop is not running is quite easy, just use loop.run_until_complete and it return the coro result but if the loop is already running (my blocking code running in app which is already running the loop) I cannot use loop.run_until_complete since it will raise an exception; when I call asyncio.ensure_future the task gets scheduled and run, but I want to wait there for the result, does anybody knows how to do this? Docs are not very clear how to do this.I tried passing a concurrent.futures.Future calling set_result inside the coro and then calling Future.result() on my blocking code, but it doesn't work, it blocks there and do not let anything else to run. ANy help would be appreciated.
To implement runner with the proposed design, you would need a way to single-step the event loop from a callback running inside it. Asyncio  explicitly forbids recursive event loops, so this approach is a dead end.Given that constraint, you have two options:make render() itself a coroutine;execute render() (and its callers) in a thread different than the thread that runs the asyncio event loop.Assuming #1 is out of the question, you can implement the #2 variant of render() like this:Note that you cannot use asyncio.get_event_loop() in render because the event loop is not (and should not be) set for that thread. Instead, the code that spawns the runner thread must call asyncio.get_event_loop() and send it to the thread, or just leave it in a global variable or a shared structure.
Waiting Synchronously for an Asynchronous CoroutineIf an asyncio event loop is already running by calling loop.run_forever, it will block the executing thread until loop.stop is called [see the docs]. Therefore, the only way for a synchronous wait is to run the event loop on a dedicated thread, schedule the asynchronous function on the loop and wait for it synchronously from another thread.For this I have composed my own minimal solution following the answer by user4815162342. I have also added the parts for cleaning up the loop when all work is finished [see loop.close].The main function in the code below runs the event loop on a dedicated thread, schedules several tasks on the event loop, plus the task the result of which is to be awaited synchronously. The synchronous wait will block until the desired result is ready. Finally, the loop is closed and cleaned up gracefully along with its thread.The dedicated thread and the functions stop_loop, run_forever_safe, and await_sync can be encapsulated in a module or a class.For thread-safery considerations, see section “Concurrency and Multithreading” in asyncio docs.


Answer URL
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.run_forever
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.close
https://docs.python.org/3/library/asyncio-dev.html#asyncio-multithreading
