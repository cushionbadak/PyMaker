Natural Text
We can see, that we need the ' to refer to the value for key 'Bibi'. But if want to use the same format in .format(), it gives this error:I have to use the reference without ', then it works.Why doesn't the first work, and why does the second? It should be the opposite, first should work, and second shouldn't.
First, some terminology:'Bibi' is a string literal, syntax to create a string value. Your keys are strings, and using a string literal you can specify one of those keys.You could use a variable instead; assign as string value to a variable and use the variable to get an item from your dictionary:In string formatting, the {...} are replacement fields. The str.format() method provides values for the replacement fields.The 0[Bidi] part in the {...} replacement field syntax is the field name. When you use [...] in a field name, it is a compound field name (there are multiple parts). The [...] syntax is usually referred to as indexing.The format used in field names is deliberately kept simple, and is only Python-like. The syntax is simplified to limit what it can be used for, to constrain the functionality to something that is usually safe to use.As such, if you use a compound name with getitem [...] indexing syntax, names are treated as strings, but you don't use quotes to create the string. You could not pass in a variable name anyway, there is no need to contrast between 'name' (a string) and name (a variable). In other words, in a Python expression, my_dic[foo] works by looking up the value of the variable foo, and that is a different concept from using a string literal like my_dic['Bidi']. But you can't use variables in a field name, in a str.format() operation, using {0[foo]} should never find the variable foo.The original proposal to add the feature explains this as:Unlike some other programming languages, you cannot embed arbitrary expressions in format strings. This is by design - the types of expressions that you can use is deliberately limited. Only two operators are supported: the '.' (getattr) operator, and the '[]' (getitem) operator. The reason for allowing these operators is that they don't normally have side effects in non-pathological code.andIt should be noted that the use of 'getitem' within a format string is much more limited than its conventional usage. In the above example, the string 'name' really is the literal string 'name', not a variable named 'name'. The rules for parsing an item key are very simple. If it starts with a digit, then it is treated as a number, otherwise it is used as a string.Keeping the syntax simple makes templates more secure. From the Security Considerations section:Barring that, the next best approach is to ensure that string formatting has no side effects. Because of the open nature of Python, it is impossible to guarantee that any non-trivial operation has this property. What this PEP does is limit the types of expressions in format strings to those in which visible side effects are both rare and strongly discouraged by the culture of Python developers.Permitting {0[foo]} to look up variables in the current scope could easily produce side effects, while treating foo as a string instead means you can know, with certainty, that it'll always be the string 'foo' and not something else.If you are only using string literals and not dynamic values (so 'some {} template'.format(...) and not some_variable.format(...), and you are using Python 3.6 or newer, you can use formatted string literals instead, as you can then use full Python expressions:In an f string, you use actual Python expressions instead of field names, so you use quotes again to pass in a string literal. Because they are string literals, they are evaluated right where they are defined, and you as a developer can see what local variables are available, so presumably you know how to keep that secure.
It should be the opposite, first should work, and second shouldn't.No, it shouldn't because 'Bibi' inside a double quoted string is a quoted string not just Bibi. You can check this simply as following:If in first case the key was "'Bibi'" Then it'd worked perfectly:The reason that why it doesn't accept "Bibi" in first case and doesn't give you a the expected result is that Python looks for everything between brackets in dictionary and in this case you have "'Bibi'" inside the brackets not 'Bibi'.


Answer URL
https://docs.python.org/3/whatsnew/3.6.html#whatsnew36-pep498
