Natural Text
I am on a Python 3.6 project that uses Sqlalchemy where we want another layer of abstraction over Sqlalchemy. This will allow us to more easily replace Sqlalchemy with another library if desired.In this example it is the DbHelper class:dbhelper.pymain.pyQuestion: Is there a better method than creating the DbHelper class for use as a container and having only staticmethod in it? I have read that this is not pythonic.Converting all the staticmethod functions in dbhelper.py to regular methods will populate the namespace when we do from dbhelper import *
Yes, there is a better solution than creating a class full of staticmethods: Just don't create the class, and make them all module-level functions:The only real point of a class full of staticmethods is to provide a namespace for all those functions to live in. A module already is a namespace for all those functions to live in. And, because it's more directly supported by the language syntax, it means you can more easily go around the namespacing when you want to do so explicitly (e.g., from dbhelper import ...).You say:Converting all the staticmethod functions in dbhelper.py to regular methods will populate the namespace when we do from dbhelper import *But the answer to that is obvious: Don't from dbhelper import *, just import dbhelper. Then, all the code that you would have written with DbHelper.spam() becomes dbhelper.spam().If you really want two levels of namespace, you can just use a package with a submodule, rather than a module with a class. But I can't see any good reason you'd need two levels of namespace here.Another alternative (as suggested by juanpa.arrivillaga in the comments) is to turn this into a real class, where each instance (even if there will probably only be one in your real code) has its own self.dbconn instead of using a module global. That dbconn can either be passed into the __init__, or constructed directly inside the __init__. For example:Notice that we're using normal methods, and accessing a normal instance variable. This is what a class is forâ€”to wrap up some state together with the methods that transform that state.How do you decide between the two? Well, if there's only ever going to be one dbconn per process, they're functionally equivalent, but conceptually they have different connotations. If you think of a DbHelper as a database, both the connection and the database behavior, it should be a class, and you should instantiate an instance of that class and use it that way. If you think of it as just a bunch of helper functions that operate on a dbconn that has its own independent existence, it should be a flat module.In some languages (like Java), there is another point to using a class full of staticmethod-equivalents: the language either doesn't support "free functions", or makes them a completely different kind of thing from methods. But that isn't true in Python.While we're at it, do you want your module to export Dogs and dbconn as a "public" part of the interface? If not, you should add an __all__ spec to the top of your module, like this:Or, alternatively, name all your "private" module members with underscores:Either way, users of your module can still access the "private" data, but it won't show up in  from dbhelper import *, help(dbhelper), the default autocomplete in many IDEs, etc.


Answer URL
https://docs.python.org/3/tutorial/modules.html
