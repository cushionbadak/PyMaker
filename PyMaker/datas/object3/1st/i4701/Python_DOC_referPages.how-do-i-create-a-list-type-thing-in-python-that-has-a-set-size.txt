Natural Text
In C++, I can create a array like...in python,I just know that I can declare a list,than append some items,or like..Can I initialize a list by a given size,like c++,and do not do any assignment?
(tl;dr: The exact answer to your question is numpy.empty or numpy.empty_like, but you likely don't care and can get away with using myList = [None]*10000.) Simple methodsYou can initialize your list to all the same element. Whether it semantically makes sense to use a non-numeric value (that will give an error later if you use it, which is a good thing) or something like 0 (unusual? maybe useful if you're writing a sparse matrix or the 'default' value should be 0 and you're not worried about bugs) is up to you:(Here _ is just a variable name, you could have used i.)You can also do so like this:You probably don't need to optimize this. You can also append to the array every time you need to:Performance comparison of simple methodsWhich is best?Results in python2.7:Results in python 3.2:As we can see, it is likely better to do the idiom [None]*10000 in both python2 and python3. However, if one is doing anything more complicated than assignment (such as anything complicated to generate or process every element in the list), then the overhead becomes a meaninglessly small fraction of the cost. That is, such optimization is premature to worry about if you're doing anything reasonable with the elements of your list.Uninitialized memoryThese are all however inefficient because they go through memory, writing something in the process. In C this is different: an uninitialized array is filled with random garbage memory (sidenote: that has been reallocated from the system, and can be a security risk when you allocate or fail to mlock and/or fail to delete memory when closing the program). This is a design choice, designed for speedup: the makers of the C language thought that it was better not to automatically initialize memory, and that was the correct choice.This is not an asymptotic speedup (because it's O(N)), but for example you wouldn't need to first initialize your entire memory block before you overwrite with stuff you actually care about. This, if it were possible, is equivalent to something like (pseudo-code) x = list(size=10000).If you want something similar in python, you can use the numpy numerical matrix/N-dimensional-array manipulation package. Specifically, numpy.empty or numpy.empty_likeThat is the real answer to your question.
You can use this: [None] * 10. But this won't be "fixed size" you can still append, remove ... This is how lists are made.You could make it a tuple (tuple([None] * 10)) to fix its width, but again, you won't be able to change it (not in all cases, only if the items stored are mutable).Another option, closer to your requirement, is not a list, but a collections.deque with a maximum length. It's the maximum size, but it could be smaller.But, just use a list, and get used to the "pythonic" way of doing things.
It's not really the python way to initialize lists like this. Anyway, you can initialize a list like this:
Note also that when you used arrays in C++ you might have had somewhat different needs, which are solved in different ways in Python:You might have needed just a collection of items; Python lists deal with this usecase just perfectly.You might have needed a proper array of homogenous items. Python lists are not a good way to store arrays.Python solves the need in arrays by NumPy, which, among other neat things, has a way to create an array of known size:
Python has nothing built-in to support this. Do you really need to optimize it so much as I don't think that appending will add that much overhead.However, you can do something like l = [None] * 1000.Alternatively, you could use a generator.

where n is the size of your arraythough it works, it may not be the best idea as you have to import a library for this purpose. Hope this helps!
You can do it using array module. array module is part of python standard library:repeat function repeats 0 value 10 times. It's more memory efficient than [0]*10, since it doesn't allocate memory, but repeats returning the same number x number of times.
This is more of a warning than an answer.Having seen in the other answers my_list = [None] * 10, I was tempted and set up an array like this speakers = [['','']] * 10 and came to regret it immensely as the resulting list did not behave as I thought it should.I resorted to:As [['','']] * 10 appears to create an list where subsequent elements are a copy of the first element.for example:Whereas with the .append option:I'm sure that the accepted answer by ninjagecko does attempt to mention this, sadly I was too thick to understand.Wrapping up, take care!


Answer URL
https://docs.python.org/3/library/array.html
https://docs.python.org/3/library/itertools.html?highlight=itertools%20repeat#itertools.repeat
