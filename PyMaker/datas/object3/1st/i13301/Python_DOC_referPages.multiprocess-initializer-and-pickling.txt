Natural Text
I've been playing around with multiprocessing.Pool and trying to understand how exactly the initializer argument works. From what I understand, the initializer function is called for each process, so I assumed the arguments to it (i.e. initargs) would have to be pickled across process boundaries. I know that the map method of a pool also uses pickling for its arguments, so I assumed that anything that works as an argument for the initializer should also work as an argument for mapping.However, when I run the following piece of code, initialize gets called just fine, but then map throws an exception about not being able to pickle the module. (There's nothing special about using the current module as the argument; it was just the first non-pickleable object that came to mind.) Does anyone know what could be behind this difference?
Initialize doesn't require pickling, but the map call does. Maybe this will shed some light…  (here I'm using multiprocess instead of multiprocessing to give better pickling and interactivity).Cool. The threading pool works… (because it doesn't need to pickle anything).  How about when we are shipping both worker and work using serialization?So let's look at pickling work:So, you can't pickle a module… ok, can we do better using dill?The answer is yes -- the module starts to pickle, however, fails due to the contents in the module… so it looks like it works for everything in __main__ except when there's an instance of a pool in __main__ -- then it will fail.So, if your last two lines of code were replaced with this one, it will work:That's using multiprocess, as it uses dill under the covers.  pickle will still fail to pickle here because pickle can't serialize a module.  Serialization is needed, as the object have to be sent to another python instance on another process. 


Answer URL
https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing.pool
https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods
