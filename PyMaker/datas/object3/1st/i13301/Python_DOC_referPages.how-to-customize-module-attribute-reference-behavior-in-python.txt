Natural Text
How can implement the equivalent of a __getattr__ on a class, on a module?ExampleWhen calling a function that does not exist in a module's statically defined attributes, I wish to create an instance of a class in that module, and invoke the method on it with the same name as failed in the attribute lookup on the module.Which gives:
A while ago, Guido declared that all special method lookups onnew-style classes bypass __getattr__ and __getattribute__. Dunder methods had previously worked on modules - you could, for example, use a module as a context manager simply by defining __enter__ and __exit__, before those tricks broke.Recently some historical features have made  a comeback, the module __getattr__ among them, and so the existing hack (a module replacing itself with a class in sys.modules at import time) should be no longer necessary.In Python 3.7+, you just use the one obvious way.  To customize attribute access on a module, define a __getattr__ function at the module level which should accept one argument (name of attribute), and return the computed value or raise an AttributeError:This will also allow hooks into "from" imports, i.e. you can return dynamically generated objects for statements such as from my_module import whatever.On a related note, along with the module getattr you may also define a __dir__ function at module level to respond to dir(my_module). See PEP 562 for details.
There are two basic problems you are running into here:__xxx__ methods are only looked up on the classTypeError: can't set attributes of built-in/extension type 'module'(1) means any solution would have to also keep track of which module was being examined, otherwise every module would then have the instance-substitution behavior; and (2) means that (1) isn't even possible... at least not directly.Fortunately, sys.modules is not picky about what goes there so a wrapper will work, but only for module access (i.e. import somemodule; somemodule.salutation('world'); for same-module access you pretty much have to yank the methods from the substitution class and add them to globals() eiher with a custom method on the class (I like using .export()) or with a generic function (such as those already listed as answers).  One thing to keep in mind: if the wrapper is creating a new instance each time, and the globals solution is not, you end up with subtly different behavior.  Oh, and you don't get to use both at the same time -- it's one or the other.UpdateFrom Guido van Rossum:There is actually a hack that is occasionally used and recommended: a  module can define a class with the desired functionality, and then at  the end, replace itself in sys.modules with an instance of that class  (or with the class, if you insist, but that's generally less useful).  E.g.:This works because the import machinery is actively enabling this  hack, and as its final step pulls the actual module out of  sys.modules, after loading it. (This is no accident. The hack was  proposed long ago and we decided we liked enough to support it in the  import machinery.)So the established way to accomplish what you want is to create a single class in your module, and as the last act of the module replace sys.modules[__name__] with an instance of your class -- and now you can play with __getattr__/__setattr__/__getattribute__ as needed.Note that if you use this functionality anything else in the module, such as globals, other functions, etc., will be lost when the sys.modules assignment is made -- so make sure everything needed is inside the replacement class.
This is a hack, but you can wrap the module with a class:
We don't usually do it that way.  What we do is this.Why?  So that the implicit global instance is visible.For examples, look at the random module, which creates an implicit global instance to slightly simplify the use cases where you want a "simple" random number generator.
Similar to what @Håvard S proposed, in a case where I needed to implement some magic on a module (like __getattr__), I would define a new class that inherits from types.ModuleType and put that in sys.modules (probably replacing the module where my custom ModuleType was defined).See the main __init__.py file of Werkzeug for a fairly robust implementation of this.
This is hackish, but...This works by iterating over the all the objects in the global namespace. If the item is a class, it iterates over the class attributes. If the attribute is callable it adds it to the global namespace as a function. It ignore all attributes which contain "__".I wouldn't use this in production code, but it should get you started.
Here's my own humble contribution -- a slight embellishment of @Håvard S's highly rated answer, but a bit more explicit (so it might be acceptable to @S.Lott, even though probably not good enough for the OP):
Create your module file that has your classes. Import the module. Run getattr on the module you just imported. You can do a dynamic import using __import__ and pull the module from sys.modules.Here's your module some_module.py:And in another module:Doing this dynamically:
In some circumstances the globals() dictionary can suffice, for example you can instantiate a class by name from the global scope:


Answer URL
https://docs.python.org/3/library/functions.html#dir
