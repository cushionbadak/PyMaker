Natural Text
Is there a way to create a class which instances respond to arbitrary method calls? I know there is a the special method __getattr__(self, attr) which would be called when someone is trying to access an attribute of an instance. I am searching for something similar that enables me to intercept method calls, too. The desired behavior would look something like this:EDITThe other suggested questions do not address my case: I do not want to wrap another class or change the metaclass of a second class or similar. I just want to have a class that responds to arbitrary method calls.Thanks to jonrshape I now know that __getattr__(self, attr) will also be called when a method is called in the same way as it would be when an attribute is accessed. But how do i distinguish in __getattr__ if attr comes from a method call or an attribute access and how to get the parameters of a potential method call? 
This is something I came up with, which will behave exactly as if the method exists.First let's establish one thing: You cannot distinguish in __getattr__ if attr comes from a function call or an "attribute access", because a class method is an attribute of your class. So someone can access that method even if they don't intend to call it, as in: Therefore, the closest thing I could think of is this behavior:Create a class A, such that:When we try to access an attribute / method, which already exists in that class, act normal and just return the requested attribute / method.When we try to access something that doesn't exist in the class definition, treat it as a class method and have 1 global handler for all such methods. I will first write the class definition and then show how accessing a method that doesn't exist behaves exactly like accessing one that exists, whether you are just accessing it, or actually calling it.Class definition:I added the method real_method just so I have something that actually exists in the class to compare its behavior with that of an 'imaginary method' Here's the result:
unittest.mock.Mock does this by default.
Method calls aren't any different from attribute access. __getattr__() or __getattribute__() is the way to respond to arbitrary attribute requests.You cannot know if the access comes from "just retrieval" or "method call".It works like this: first, attribute retrieval, then, call on the retrieved object (in Python, call is just another operator: anything can be called and will throw an exception if it isn't callable). One doesn't, and shouldn't, know about the other (well, you can analyze the code up the call stack, but that's totally not the thing to do here).One of the reasons is - functions are first-class objects in Python, i.e. a function (or, rather, a reference to it) is no different from any other data type: I can get the reference, save it and pass it around. I.e. there's completely no difference between requesting a data field and a method.Elaborate on what you need this for for us to suggest a better solution.E.g., if you need the "method" to be able to be called with different signatures, *args and **kwargs is the way to go.


Answer URL
https://docs.python.org/3/library/unittest.mock.html#the-mock-class
