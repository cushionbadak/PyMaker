Natural Text
I'm trying to write a custom filter method that takes an arbitrary number of kwargs and returns a list containing the elements of a database-like list that contain those kwargs.For example, suppose d1 = {'a':'2', 'b':'3'} and d2 = the same thing. d1 == d2 results in True. But suppose d2 = the same thing plus a bunch of other things. My method needs to be able to tell if d1 in d2, but Python can't do that with dictionaries.Context:I have a Word class, and each object has properties like word, definition, part_of_speech, and so on. I want to be able to call a filter method on the main list of these words, like Word.objects.filter(word='jump', part_of_speech='verb-intransitive'). I can't figure out how to manage these keys and values at the same time. But this could have larger functionality outside this context for other people.
Convert to item pairs and check for containment.Optimization is left as an exercise for the reader.
In Python 3, you can use dict.items() to get a set-like view of the dict items.  You can then use the <= operator to test if one view is a "subset" of the other:In Python 2.7, use the dict.viewitems() to do the same:In Python 2.6 and below you will need a different solution, such as using all():
Note for people that need this for unit testing: there's also an assertDictContainsSubset() method in Python's TestCase class.http://docs.python.org/2/library/unittest.html?highlight=assertdictcontainssubset#unittest.TestCase.assertDictContainsSubsetIt's however deprecated in 3.2, not sure why, maybe there's a replacement for it.
for keys and values check use: set(d1.items()).issubset(set(d2.items()))if you need to check only keys:        set(d1).issubset(set(d2))
For completeness, you can also do this:However, I make no claims whatsoever concerning speed (or lack thereof) or readability (or lack thereof).
context:
My function for the same purpose, doing this recursively:In your example, dictMatch(d1, d2) should return True even if d2 has other stuff in it, plus it applies also to lower levels:Notes:  There could be even better solution which avoids the if type(pvalue) is dict clause and applies to even wider range of cases (like lists of hashes etc).  Also recursion is not limited here so use at your own risk. ;)
This seemingly straightforward issue costs me a couple hours in research to find a 100% reliable solution, so I documented what I've found in this answer."Pythonic-ally" speaking, small_dict <= big_dict would be the most intuitive way, but too bad that it won't work. {'a': 1} < {'a': 1, 'b': 2} seemingly works in Python 2, but it is not reliable because the official documention explicitly calls it out. Go search "Outcomes other than equality are resolved consistently, but are not otherwise defined." in this section. Not to mention, comparing 2 dicts in Python 3 results in a TypeError exception.The second most-intuitive thing is small.viewitems() <= big.viewitems() for Python 2.7 only, and small.items() <= big.items() for Python 3. But there is one caveat: it is potentially buggy. If your program could potentially be used on Python <=2.6, its d1.items() <= d2.items() are actually comparing 2 lists of tuples, without particular order, so the final result will be unreliable and it becomes a nasty bug in your program. I am not keen to write yet another implementation for Python<=2.6, but I still don't feel comfortable that my code comes with a known bug (even if it is on an unsupported platform). So I abandon this approach.I settle down with @blubberdiblub 's answer (Credit goes to him):def is_subdict(small, big):       return dict(big, **small) == bigIt is worth pointing out that, this answer relies on the == behavior between dicts, which is clearly defined in official document, hence should work in every Python version. Go search:"Dictionaries compare equal if and only if they have the same (key, value) pairs." is the last sentence in this page"Mappings (instances of dict) compare equal if and only if they have equal (key, value) pairs. Equality comparison of the keys and elements enforces reflexivity." in this page
Here's a general recursive solution for the problem given:NOTE: The original code would fail in certain cases, credits for the fixing goes to @olivier-melanÃ§on
This function works for non-hashable values. I also think that it is clear and easy to read.
I know this question is old, but here is my solution for checking if one nested dictionary is a part of another nested dictionary. The solution is recursive.
If you don't mind using pydash  there is is_match there which does exactly that:


Answer URL
