Natural Text
For a specific program I'm working in, we need to evaluate some code, then run a unittest, and then depending on whether or not the test failed, do A or B.But the usual self.assertEqual(...) seems to display the results (fail, errors, success) instead of saving them somewhere, so I can't access that result.I have been checking the modules of unittest for days but I can't figure out where does the magic happen or if there is somewhere a variable I can call to know the result of the test without having to read the screen (making the program read and try to find the words "error" or "failed" doesn't sound like a good solution).
You can use pdb to debug this issue, in the test simply add these two lines to halt execution and begin debugging.import pdb pdb.settrace()Now for good testing practice you want deterministic test results, a test that fails only sometimes is not a good test. I recommend mocking the random function and using data sets that capture the errors you find.
After some days of researching, I sent an email to help@python.org and got the perfect solution for my issue.The answer I got was:I suspect that the reason that you're having trouble getting unittest  to do that is that that's not the sort of thing that unittest was  written to do. A hint that that's the case seems to me to be that over  at the documentation:https://docs.python.org/3/library/unittest.htmlthere's a section on the command-line interface but nothing much about  using the module as an imported module.A bit of Googling yields this recipe:http://code.activestate.com/recipes/578866-python-unittest-obtain-the-results-of-all-the-test/Which looks as though it might be useful to you but I can't vouch for  it and it seems to involve replacing one of the library's files.  (Replacing one of the library's files is perfectly reasonable in my  opinion. The point of Python's being open-source is that you can hack  it for yourself.)But if I were doing what you're describing, I'd probably write my own  testing code. You could steal what you found useful from unittest  (kind of the inverse of changing the library in place). Or you might  find that your needs are sufficiently simple that a simple file of  testing code was sufficient.If none of that points to a solution, let us know what you get and  I'll try to think some more.Regards, MattAfter changing my result.py module from unittest, I'm able to access the value of the test (True, False, or Error).Thank you very much, Matt.P.S. I edited my question so it was more clear and didn't have unnecessary code.


Answer URL
https://docs.python.org/3/library/unittest.html
