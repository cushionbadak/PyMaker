Natural Text
I know Python can do enums (well sort of) but the type of enums it does is very primitive. For example I can do this:This is fine but what if I want each color to have a name and a hex value? I have several options (like making the enum values be dictionaries) but I prefer the way Java does enums. In Java, enums are allowed to have fields and methods like a class. So normally when a language only supports simple enums like the above example, I restructure the code similar to the following:Now I can have multiple values, custom methods and can refer to the different fields by name since each color is an object. I've done this in several languages without issue, but Python seems to complain that "name 'Color' is not defined". Can I not create an instance of a class inside that class? My hacky solution is to do this:Which works just fine. My question, though, is why are the fields not allowed inside the class? Can I add something or restructure it to make it allowed? Thanks in advance for any answers!
Enums support this usecase directly. The documentation for the library covers this in the Planet example in the examples section:If __new__() or __init__() is defined the value of the enum member will be passed to those methods:[...]So for your specific example, just define a __init__ method:I did not use name as an attribute because that is a reserved attribute (used to reflect the enum value name, here BLACK and WHITE):You can still override the name attribute with a @property but Iâ€™d not deviate from the standard here. I used this technique to define the virus states in my Advent of Code day 22 solution, defining both the next state name and the direction change for each entry. 
Use tuple values and @property accessors to give names to the tuple elements:Output:As for why your code doesn't work, Python class definitions are imperative. At the time you're trying to construct a Color instance, the Color class doesn't exist yet.
The "chicken and egg"-problemYou encounter the "chicken and egg"-problem here. Since if you construct a class, Python has to associate the names of attributes and functions, with the values of tha attributes and functions. If you access Color.abc, then it will look whether it finds such corresponding name, and returns the value/function definition.But now there is a problem. If you write:Why? Well in order to construct the class, it first has to construct the attributes. So it has to construct a 'bar' entry that maps to the result of Foo() but we are constructing Foo at that moment, so how can we construct a Foo if Foo depends on that construction. We can not. In Java it is simpler since classes are conceptually constructed at compile time.We have some options here however.Monkey-patching the Color classWe can first construct the Color class and then "monkey patch" that class:Here we first define the Color class, and then add attributes to the Color class. We can do this afterward, since now the objects are defined.Attaching values to the Enum objectsWe can also attach values to the Enum objects:We can attach a value to every Enum member. For instance we attach {'name': 'white', 'hex': '#fff'} to white. We can later access that value, through self.value. So now we can define a property on Color.white by defining a property function def name(self): that accesses the 'name' key of the dictionary.
How about a named tuple solution ?Outputsblack #000Adding new ones is as easy as thisred #ff0
You could do what you want by using a meta-class to help construct the Color class:
I think user2357112 has already the answer you are looking for, but it might be worthwhile looking intonamedtuples as well to access properties.Named Tuples:


Answer URL
https://docs.python.org/3/library/enum.html#planet
