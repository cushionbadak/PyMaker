Natural Text
I have a list of numbers ; 1 6 3 15 54...Let's say list is L,  I want to apply this condition as simple as possible ;Then a new list emerges let's say L2, apply the same rule again ;Until there is only one number is left from the initial L list.I am currently working on something like this ;works for 1 loop but to introduce corresponding iterations I am looking for a decent approach. I will gladly accept the innovative answer. Thank you!
Assuming that your example should be the following:Where in each step, the numbers are taken as a pair and the first number is substracted from the second.In that case, you can use the pairwise function from the itertools recipes:
Assuming that [1, 6, 3, 15, 54] gets reduced to [-11] in the end, you can just use recursion for this. What recursion will do here is keep calling the same function over and over again, until a base case is met. In your case, it will keep reducing the list on each recursive call, until the length of the list only has one element. I'm also assuming that you want to return the final singleton list at the end. Recursion Approach:Which Outputs:Note: zip() was used to pair every 2 elements elements together in the list, and minus the second element from the first element. Here is an example that breaks down the above usage of zip():Additionally, anything done with recursion can be done with a simple loop, which @poke has nicely shown.EDIT:Since the above code is prone to RecursionError: maximum recursion depth errors with lists of size 1000 or greater, because 1000 is the recusion limit,  you can see this post for more details on how to increase the limit. Alternatively, you can also just make an iterative version that is bypasses this problem, as shown below. Iterative Approach:
You can try recursive approach :output:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools-recipes
