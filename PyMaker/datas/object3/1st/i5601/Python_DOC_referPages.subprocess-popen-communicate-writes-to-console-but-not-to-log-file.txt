Natural Text
I have the following line in a Python script that runs a separate Python script from within the original script:Using the above line, any print() statements found in the separate Python file do appear in the console of the main Python script.However, these statements are not reflected in the .txt file log that the script writes to.Does anyone know how to fix this, so that the .txt file exactly reflects the true console text of the main Python script?This is the method I am using to save the console as a .txt file, in real time:I am not necessarily attached to this method. I am interested in any method that will achieve what I've detailed.
Keep in mind that subprocess spawns a new process, and doesn't really communicate with the parent process (they're pretty much independent entities). Despite its name, the communicate method is just a way of sending/receiving data from the parent process to the child process (simulate that the user input something on the terminal, for instance)In order to know where to write the output, subprocess uses numbers (file identifiers or file numbers). When subprocess spawns a process, the child process only knows that the standard output is the file identified in the O.S. as 7 (to say a number) but that's pretty much it. The subprocess will independently query the operative system with something like "Hey! What is file number 7? Give it to me, I have something to write in it." (understanding what a C fork does is quite helpful here)Basically, the spawned subprocess doesn't understand your Logger class. It just knows it has to write its stuff to a file: a file which is uniquely identified within the O.S with a number and that unless otherwise specified, that number corresponds with the file descriptor of the standard output (but as explained in the case #2 below, you can change it if you want)So you have several "solutions"... Clone (tee) stdout to a file, so when something is written to stdout, the operative system ALSO writes it to your file (this is really not Python-related... it's OS related):Choose whether to write to terminal OR to the file using the fileno() function of each. For instance, to write only to the file:What I personally find "safer" (I don't feel confortable overwriting sys.stdout): Just let the command run and store its output into a variable and pick it up later (in the parent process):This way, you can also do a print(contents) somewhere in your code to output whatever the subprocess "said" to the terminal.For example purposes, the script "./run_something.py" is just this:
Do you really need subprocess.Popen's communicate() method? It looks like you just want the output. That's what subprocess.check_output() is for.If you use that, you can use the built-in logging module for "tee"-ing the output stream to multiple destinations.As always, be careful with shell=True. If you can write the call as subprocess.check_output(['/path/to/script.py', 'arg1', 'arg2']), do so!


Answer URL
https://docs.python.org/3/library/logging.html
