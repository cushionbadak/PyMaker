Natural Text
I have a python app written in the Tornado Asynchronous framework. When an HTTP request comes in, this method gets called:The three database operations are interrelated. And this is a concurrent application so multiple such HTTP calls can be happening concurrently and hitting the same DB.For data-integrity purposes, its important that the three database operations in this method are all called without another processes reading or writing to those database rows in between.How can I make sure this method has database atomicity? Does Tornado have a decorator for this?
Synchronous database accessYou haven't stated how you access your database. If, which is likely, you have synchronous DB access in get_val_from_db_table1 and friends (e.g. with pymysql) and my_method is blocking (doesn't return control to IO loop) then you block your server (which has implications on performance and responsiveness of your server) but effectively serialise your clients and only one can execute my_method at a time. So in terms of data consistency you don't need to do anything, but generally it's a bad design. You can solve both with @xyres's solution in short term (at cost of keeping in mind thread-safely concerns because most of Tornado's functionality isn't thread-safe).Asynchronous database accessIf you have asynchronous DB access in get_val_from_db_table1 and friends (e.g. with tornado-mysql) then you can use tornado.locks.Lock. Here's an example:Note that the above is said about normal single-process Tornado application. If you use tornado.process.fork_processes, then you can only go with multiprocessing.Lock.
Since you want to run those three db operations one right after the other,  the function my_method must be non-asynchronous.But this would also mean that my_method will block the server. You definitely don't want that. One way that I can think of is to run this function in another thread. This won't block the server and will keep accepting new requests while the operations are running. And since, it's going to be non-async, db atomicity is guaranteed.Here's the relevant code to get you started:


Answer URL
https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Lock
