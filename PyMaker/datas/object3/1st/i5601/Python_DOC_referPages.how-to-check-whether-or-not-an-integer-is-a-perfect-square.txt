Natural Text
How could I check if a number is a perfect square?Speed is of no concern, for now, just working.
The problem with relying on any floating point computation (math.sqrt(x), or x**0.5) is that you can't really be sure it's exact (for sufficiently large integers x, it won't be, and might even overflow). Fortunately (if one's in no hurry;-) there are many pure integer approaches, such as the following...:Hint: it's based on the "Babylonian algorithm" for square root, see wikipedia.  It does work for any positive number for which you have enough memory for the computation to proceed to completion;-).Edit: let's see an example...this prints, as desired (and in a reasonable amount of time, too;-):Please, before you propose solutions based on floating point intermediate results, make sure they work correctly on this simple example -- it's not that hard (you just need a few extra checks in case the sqrt computed is a little off), just takes a bit of care.And then try with x**7 and find clever way to work around the problem you'll get,you'll have to get more and more clever as the numbers keep growing, of course.If I was in a hurry, of course, I'd use gmpy -- but then, I'm clearly biased;-).Yeah, I know, that's just so easy it feels like cheating (a bit the way I feel towards Python in general;-) -- no cleverness at all, just perfect directness and simplicity (and, in the case of gmpy, sheer speed;-)...
Use Newton's method to quickly zero in on the nearest integer square root, then square it and see if it's your number. See isqrt.
Since you can never depend on exact comparisons when dealing with floating point computations (such as these ways of calculating the square root), a less error-prone implementation would beImagine integer is 9. math.sqrt(9) could be 3.0, but it could also be something like 2.99999 or 3.00001, so squaring the result right off isn't reliable. Knowing that int takes the floor value, increasing the float value by 0.5 first means we'll get the value we're looking for if we're in a range where float still has a fine enough resolution to represent numbers near the one for which we are looking.
A perfect square is a number that can be expressed as the product of two equal integers. math.sqrt(number) return a float. int(math.sqrt(number)) casts the outcome to int.If the square root is an integer, like 3, for example, then math.sqrt(number) - int(math.sqrt(number)) will be 0, and the if statement will be False. If the square root was a real number like 3.2, then it will be True and print "it's not a perfect square".
If youre interested, I have a pure-math response to a similar question at math stackexchange, "Detecting perfect squares faster than by extracting square root".My own implementation of isSquare(n) may not be the best, but I like it. Took me several months of study in math theory, digital computation and python programming, comparing myself to other contributors, etc., to really click with this method. I like its simplicity and efficiency though. I havent seen better. Tell me what you think.Pretty straight forward. First it checks that we have an integer, and a positive one at that. Otherwise there is no point.   It lets 0 slip through as True (necessary or else next block is infinite loop).The next block of code systematically removes powers of 4 in a very fast sub-algorithm using bit shift and bit logic operations.  We ultimately are not finding the isSquare of our original n but of a k<n that has been scaled down by powers of 4, if possible. This reduces the size of the number we are working with and really speeds up the Babylonian method, but also makes other checks faster too.The third block of code performs a simple Boolean bit-logic test.  The least significant three digits, in binary, of any perfect square are 001. Always. Save for leading zeros resulting from powers of 4, anyway, which has already been accounted for.  If it fails the test, you immediately know it isnt a square. If it passes, you cant be sure.Also, if we end up with a 1 for a test value then the test number was originally a power of 4, including perhaps 1 itself.Like the third block, the fourth tests the ones-place value in decimal using simple modulus operator, and tends to catch values that slip through the previous test. Also a mod 7, mod 8, mod 9, and mod 13 test.The fifth block of code checks for some of the well-known perfect square patterns. Numbers ending in 1 or 9 are preceded by a multiple of four. And numbers ending in 5 must end in 5625, 0625, 225, or 025. I had included others but realized they were redundant or never actually used.Lastly, the sixth block of code resembles very much what the top answerer - Alex Martelli - answer is.  Basically finds the square root using the ancient Babylonian algorithm, but restricting it to integer values while ignoring floating point. Done both for speed and extending the magnitudes of values that are testable. I used sets instead of lists because it takes far less time, I used bit shifts instead of division by two, and I smartly chose an initial start value much more efficiently.By the way, I did test Alex Martelli's recommended test number, as well as a few numbers many orders magnitude larger, such as:printed the following results:And it did this in 0.33 seconds.In my opinion, my algorithm works the same as Alex Martelli's, with all the benefits thereof, but has the added benefit highly efficient simple-test rejections that save a lot of time, not to mention the reduction in size of test numbers by powers of 4, which improves speed, efficiency, accuracy and the size of numbers that are testable. Probably especially true in non-Python implementations.Roughly 99% of all integers are rejected as non-Square before Babylonian root extraction is even implemented, and in 2/3 the time it would take the Babylonian to reject the integer. And though these tests dont speed up the process that significantly, the reduction in all test numbers to an odd by dividing out all powers of 4 really accelerates the Babylonian test.I did a time comparison test.  I tested all integers from 1 to 10 Million in succession.  Using just the Babylonian method by itself (with my specially tailored initial guess) it took my Surface 3 an average of 165 seconds (with 100% accuracy). Using just the logical tests in my algorithm (excluding the Babylonian), it took 127 seconds, it rejected 99% of all integers as non-Square without mistakenly rejecting any perfect squares. Of those integers that passed, only 3% were perfect Squares (a much higher density).  Using the full algorithm above that employs both the logical tests and the Babylonian root extraction, we have 100% accuracy, and test completion in only 14 seconds.  The first 100 Million integers takes roughly 2 minutes 45 seconds to test.EDIT: I have been able to bring down the time further. I can now test the integers 0 to 100 Million in 1 minute 40 seconds.  A lot of time is wasted checking the data type and the positivity.  Eliminate the very first two checks and I cut the experiment down by a minute.  One must assume the user is smart enough to know that negatives and floats are not perfect squares.
I'm new to Stack Overflow, and did a quick skim to find a solution. I just posted a slight variation on some of the examples above on another thread (Finding perfect squares) and thought I'd include a slight variation of what I posted there here (using nsqrt as a temporary variable), in case it's of interest / use:
This can be solved using the decimal module to get arbitrary precision square roots and easy checks for "exactness":For demonstration with truly huge values:If you increase the size of the value being tested, this eventually gets rather slow (takes close to a second for a 200,000 bit square), but for more moderate numbers (say, 20,000 bits), it's still faster than a human would notice for individual values (~33 ms on my machine). But since speed wasn't your primary concern, this is a good way to do it with Python's standard libraries.Of course, it would be much faster to use gmpy2 and just test gmpy2.mpz(x).is_square(), but if third party packages aren't your thing, the above works quite well.
My answer would be:This basically does a square root, then modulo by 1 to strip the integer part and if the result is 0 return True otherwise return False. In this case x can be any large number, just not as large as the max float number that python can handle: 1.7976931348623157e+308
This is my method take square root of number convert to integer then take the square if the numbers are equal then it is a perfect square otherwise not.
You could binary-search for the rounded square root. Square the result to see if it matches the original value.You're probably better off with FogleBirds answer - though beware, as floating point arithmetic is approximate, which can throw this approach off. You could in principle get a false positive from a large integer which is one more than a perfect square, for instance, due to lost precision.
Decide how long the number will be.take a delta 0.000000000000.......000001see if the (sqrt(x))^2 - x is greater / equal /smaller than delta and decide based on the delta error.
This response doesn't pertain to your stated question, but to an implicit question I see in the code you posted, ie, "how to check if something is an integer?"The first answer you'll generally get to that question is "Don't!" And it's true that in Python, typechecking is usually not the right thing to do.For those rare exceptions, though, instead of looking for a decimal point in the string representation of the number, the thing to do is use the isinstance function:Of course this applies to the variable rather than a value. If I wanted to determine whether the value was an integer, I'd do this:But as everyone else has covered in detail, there are floating-point issues to be considered in most non-toy examples of this kind of thing.
If you want to loop over a range and do something for every number that is NOT a perfect square, you could do something like this:If you want to do something for every number that IS a perfect square, the generator is even easier:
I think that this works and is very simple: 
This is numerically about as naive a solution as you can possibly have. It works for small numbers.Evidently it fails for a large number such as 152415789666209426002111556165263283035677490.
I'm not sure of the Python, but you could do something like:That is, take a number, find the square root, round it to the nearest integer, square it, and test if it's the same as the original number. (floor and adding 0.5 is done to prevent cases like sqrt(4) returning 1.9999999... due to floating point math, as Mike Graham pointed out.)In case you're interested, there was once a very good discussion on the Fastest way to determine if an integer’s square root is an integer.Edited for clarification.

I have a slight improvement on the original solution using the Babylonian approach.  Instead of using a set to store every previously generated approximation,  only the most recent two approximations are stored and checked against the current approximation.  This saves the huge amount of time wasted checking through the entire set of previous approximations.  I'm using java instead of python and a BigInteger class instead a normal primitive integer.
There is a VERY easy way to do this. Find how many factors the number has (including one and itself). If it has an odd amount of factors, it is a square.If the result of the function is odd, it is a square.EDIT:This might not be the best method for a computer program but it's a good method for humans.


Answer URL
https://docs.python.org/3/library/decimal.html
