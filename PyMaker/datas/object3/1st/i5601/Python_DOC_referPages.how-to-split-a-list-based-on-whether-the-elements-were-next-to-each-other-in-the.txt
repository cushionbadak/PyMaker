Natural Text
I'm going through Problem 3 of the MIT lead python course, and I have an admittedly long drawn out script that feels like it's getting close. I need to print the longest substring of s in which the letters occur in alphabetical order. I'm able to pull out any characters that are in alphabetical order with regards to the character next to it. What I need to see is:Input : 'aezcbobobegghakl'needed output: 'beggh'my output: ['a', 'e', 'b', 'b', 'b', 'e', 'g', 'g', 'a', 'k']My code: I know after looking that there are much shorter and completely different ways to solve the problem, but for the sake of my understanding, is it even possible to finish this code to get the output I'm looking for? Or is this just a lost cause rabbit hole I've dug?
I would build a generator to output all the runs of characters such that l[i] >= l[i-1].  Then find the longest of those runs.  Something likeEdit: Notes on your codeis getting the "number value" for each letter.  You can use the ord function to simplify thisYou never use index_list, and you never should.  Look into the enumerate function.this part doesn't make a ton of sense.  You break out of the while loop every time, so it's basically an if. You have no way of keeping track of more than one run. You have no mechanism here for comparing runs of characters against one another. I think you might be trying to do something like (Disclaimer: I'm pretty sure the above is off by one but it should be illustrative).  The above can be improved in a lot of ways.  Note that it loops over the last character as many as len(s) times, making it a n**2 solution.  Also, I'm not sure why you need number_list, as strings can be compared directly. 
What about a simple recursive approach :output:
You can find a list of all substrings of the input string, and then find all the strings that are sorted alphabetically. To determine of a letter is sorted alphabetically, sorted the original string by position in the alphabet, and then see if the final string equals the original string:Output:
This is one way of getting the job done:"run" is basically an uninterrupted run; it keeps growing as you add elements bigger than what is previously seen ("b" is bigger than "a", just string comparison), and resets else. "allrun" contains all "run"s, which looks like this:"result" finally picks the longest "run" in "allrun", and merges it into one string.Regarding your code:It is very very inefficient, I would not proceed with it. I would adopt one of the posted solutions. Your number_list can be written as [a.index(_) for _ in s], one liner.Your letter_list is actually just list(s), and you are using a loop for that! Your index_list, what does it even do? It is equivalent to range(len(letter_list)), so what are you aiming with the append in the loop? Finally, the way you write loops reminds me of matlab. You can just iterate on the elements of a list, no need to iterate on index and fetch the corresponding element in list.


Answer URL
https://docs.python.org/3/library/functions.html#enumerate
