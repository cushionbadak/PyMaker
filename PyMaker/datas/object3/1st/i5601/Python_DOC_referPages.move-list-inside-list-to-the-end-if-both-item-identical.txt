Natural Text
I have the following list of paired values :This list can contain one or more remarkable pairs that are made of the same item:['D', 'D']I'd like to move those pairs to the end of the list to obtain :I can't figure it out, but I believe I'm not too far:
Straight-forward sorting:This simple key function works because False is sorted before True while mapping all pairs to only two keys maintains stability. The downside to this approach is that sorting is O(N_logN). For a linear solution without unecessary list concatenations, you could use itertools.chain with appropriate generators:
Use list comprehensions:Note that a more efficient solution would beIt is more efficient, as here you iterate a only once, whereas in the list comprehensions solution, you iterate a twice. Still, both solutions take O(n) time complexity and O(n) space complexity, which are better (and more natural for this problem), than a sorting solution.
If you want your original solution to work, you can do something simple like this instead:This however is O(N^2), because of pop(i) in the for loop, which is O(N) itself. pop() is only O(1) if you pop from the end of a list.You could also group using a dictionary by the length of lists sets, which is O(N) if you avoid sorting at the end and just use min() and max(), both of which are O(N) operations. Here is an example:Of course, as shown by @schwobaseggl, you can also accept the O(NlogN) approach of sorting:
Just collect all the duplicates in a list and at last extend the list :output:


Answer URL
https://docs.python.org/3/howto/sorting.html#sorting-basics
https://docs.python.org/3/howto/sorting.html#key-functions
https://docs.python.org/3/howto/sorting.html#sort-stability-and-complex-sorts
https://docs.python.org/3/library/itertools.html#itertools.chain
