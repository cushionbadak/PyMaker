Natural Text
Python 3.4.2I am learning asyncio and I use it to continously listen IPC bus, while gbulb listens to the dbus.Some side notes:So I created a function listen_to_ipc_channel_layer that continously listens for incoming messages on the IPC channel and passes the message to a message_handler.I am also listening to SIGTERM and SIGINT. So when I send a SIGTERM to the python process running the code you find at the bottom, the script should terminate gracefully.The problem… I am having is the following warning:… with the following code:I still only understand very little of asyncio, but I think I know what is going on. While waiting for yield from asyncio.sleep(0.1) the signal handler caught the SIGTERM and in that process it calls task.cancel().Question thrown in: Shouldn't this trigger the CancelledError within the while True: loop? (Because it is not, but that is how I understand "Calling cancel() will throw a CancelledError to the wrapped coroutine").Eventually loop.stop() is called which stops the loop without waiting for either yield from asyncio.sleep(0.1) to return a result or even the whole coroutine listen_to_ipc_channel_layer.Please correct me if I am wrong.I think the only thing I need to do is to make my program wait for the yield from asyncio.sleep(0.1) to return a result and/or coroutine to break out the while-loop and finish.I believe I confuse a lot of things. Please help me get those things straight so that I can figure out how to gracefully close the event loop without warning.
The problem comes from closing the loop immediately after cancelling the tasks. As the cancel() docs state "This arranges for a CancelledError to be thrown into the wrapped coroutine on the next cycle through the event loop."Take this snippet of code:Notice ask_exit cancels the tasks but does not stop the loop, on the next cycle looping_coro() stops it. The output if you cancel it is:Notice how pending_doom cancels and stops the loop immediately after. If you let it run until the pending_doom coroutines awakes from the sleep you can see the same warning you're getting:
The meaning of the issue is that a loop doesn't have time to finish all the tasks.This arranges for a CancelledError to be thrown into the wrapped coroutine on the next cycle through the event loop.There is no chance to do a "next cycle" of the loop in your approach. To make it properly you should move a stop operation to a separate non-cyclic coroutine to give your loop a chance to finish.Second significant thing is CancelledError raising.Unlike Future.cancel(), this does not guarantee that the task will be cancelled: the exception might be caught and acted upon, delaying cancellation of the task or preventing cancellation completely. The task may also return a value or raise a different exception.Immediately after this method is called, cancelled() will not return True (unless the task was already cancelled). A task will be marked as cancelled when the wrapped coroutine terminates with a CancelledError exception (even if cancel() was not called).So after cleanup your coroutine must raise CancelledError to be marked as cancelled.Using an extra coroutine to stop the loop is not an issue because it is not cyclic and be done immediately after execution.


Answer URL
https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.cancel
