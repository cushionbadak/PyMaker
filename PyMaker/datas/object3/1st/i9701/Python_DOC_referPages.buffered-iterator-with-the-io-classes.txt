Natural Text
When writing to a file in a setting like the following, where production.iterlines() generates many lines of text:then – if I understand correctly – the following happens:The TextIOWrapper object f accepts line by line, encodes it, and, whenever a certain limit is reached (eg. 4096 bytes in the buffer), writes a chunk of bytes to disk. So the actual disk-writing operations are not at the same pace as the lines yielded, but typically less frequent (unless the lines are very long).Now I would like to have an iterator over these chunks, eg. for sending them over a network. It could be used like this:So this hypothetical BufferedIterator object assembles strings from its argument into chunks of reasonable size and yields them to its caller as encoded bytes.I feel like this should be possible with a clever combination of the classes in the io module – I just can't get my head around how to use them. Something like StringIO, but with some kind of queue behaviour, with interleaved write and read calls.But maybe I'm wrong and they aren't designed for this kind of task. (After all, it's not that hard to piece together an iterator that encodes and concatenates strings until a fixed chunk size is reached.) Answers are encouraged to give me a better understanding of the usage of the io classes. I am very fond of the official documentation usually, but the one on the io module just leaves me behind hopelessly.
There is no need to use any io classes here. You are not really performing I/O, only buffering (which is not unique to I/O). Trying to re-use the BufferIOBase interface is sub-optimal here, since your input is an iterable, and so is your output; neither is a file-like object and no .read() is available for a BufferedReader() to fill the buffer from.You can implement the class yourself; I used the collections.deque() type to keep this as efficient as possible:By using two deque objects, one for the lengths, and one for the lines themselves, we avoid having to call len() too often. Getting the length of a string is cheap enough, but pushing and popping the current stack frame to retrieve it each time is costly enough to want to avoid this.Demo:


Answer URL
https://docs.python.org/3/library/collections.html#collections.deque
