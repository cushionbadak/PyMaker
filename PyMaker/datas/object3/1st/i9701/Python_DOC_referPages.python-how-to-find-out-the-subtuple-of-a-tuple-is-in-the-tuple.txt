Natural Text
For instance, a tuple is (1,0,1,1,1,0)and subtuple is (1,0)in increasing order, how to find out this subtuple is in the tuple?Is it only way to compare one by one by using iteration?Ex.(1,0,1,1,1,0) =(1,0, *, *, *, *)So subtuple (1,0) is in the tuple!c.f. I don't need to know (1,0) is in (1,0,1,1,1,0) like this : (1,0,1,1,1,0) = ( *, *, *, *, 1,0) so (1,0) is in (1,0,1,1,1,0).. => wrong one.
The documentation for the builtin sequence types says that the in operation can do a subsequence check, but only for certain types:Notes:While the in and not in operations are used only for simple containment testing in the general case, some specialised sequences (such as str, bytes and bytearray) also use them for subsequence testing:>>> "gg" in "eggs"  TrueSo if your data is only integers between 0 and 255, you could convert to bytes to check:>>>bytes((1,0)) in bytes((1,0,1,1,1,0))TrueFor other types of data, this expression is a one-line way of iterating:A = ('L', 'R')  B = ('L', 'R', 'L', 'L', 'L', 'R') any(A == B[i:len(A) + i] for i in range(len(B) - len(A) + 1)) True...though perhaps writing it out in a for loop would be easier to read.These methods would catch (1, 0) if it comes anywhere in the second tuple, so the example you have labelled as the wrong one would be matched. If you only want to match if the first tuple is found starting with the first entry in the second tuple, then perhaps you could slice and compare:>>> A = (1, 0)>>> B = (1, 0, 1, 1, 1, 0)>>> A == B[:len(A)]True


Answer URL
https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range
