Natural Text
Simple operations, such as rounding a number, creating an increasing vector, etc., can't be done reliably in python (see the examples below). The common explanation given by the python community is the floating point precision.However, there are existing tools, like Matlab and Octave, that do not suffer from such floating point precision phenomena (see the examples below). These tools also work on the binary architectures as python and are still capable of doing the real schoolbook math.I have already written my own round operation for python. I'm about to write my own range operation for python, and who knows what else in the future...My question is following:Before I write the whole new math module for python, is there maybe such a module already existing?(and I mean a module that is capable of doing the real trustworthy schoolbook math) 
There is nothing unreliable about numpy's behavior in the examples you show as compared to MATLAB, nor do any of the examples you show have anything to do with floating-point issues (with one exception).For the rounding behavior, MATLAB is the one doing it wrong here. Numpy is following the IEEE standard for rounding.  The standard calls for rounding to the nearest even number when the decimal value is .5.  There is a good reason for this: MATLAB's rounding behavior is statistically biased, producing more higher values than lower values for random numbers.  For the arange function, Numpy is following the half-open interval convention, which excludes the last value in a range, while MATLAB is following the closed interval convention, which includes the last value.  Neither is right or wrong, and both have their advantages and disadvantages, but Numpy's behavior is in line with the vast majority of programming languages.If you want to use closed intervals, you can use the linspace function, which lets you control whether to include the last value or not (it includes the last value by default).  If you really need to use the range function, it is easy to add one value on to the end, or create your own wrapper function that does it automatically.As for floating-point issues, MATLAB and numpy are exactly the same.  Both use identical IEEE-standard floating-point numbers (except where MATLAB violates the standard's rounding rules).  Python, however, supports true decimal numbers and fractions, which MATLAB doesn't, so it is at least possible to avoid these issues in Python but not in MATLAB.The only exception is this operation: numpy.arange(89+0.1,90,0.1).  The result you show is indeed a floating-point issue.  As I said, floating-point issues like these present in both MATLAB and numpy.  This particular example was present in numpy but not MATLAB, but there are other examples that show up in MATLAB but not numpy.  For ranges, numpy does the arithmetic very literally in this case: it adds the step size to the starting value, then adds it again to that value, and so on.  This means that these issues happen in a very predictable way.  MATLAB apparently tries to be more clever, but that means it fails in more obscure and hard-to-predict ways (I can't find documentation on exactly how MATLAB does this calculation).  For both MATLAB and numpy, you really should be using linspace for these sorts of ranges, as it doesn't have these sorts of issues.
There are a bunch of libraries out there:SAML (Simple Algebraic Math Library)pymatPYML


Answer URL
https://docs.python.org/3/library/decimal.html
https://docs.python.org/3/library/fractions.html
