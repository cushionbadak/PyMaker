Natural Text
I'm trying to duplicate and then modify a class programmatically but I'm running into problems with python 3's magic super for example the following raises TypeError: super(type, obj): obj must be an instance or subtype of typeSo I'm wondering, is there someway I can help super() find the right __class__ cell in a class created through type()? 
Note: I corrected the spelling of Original in this answerIt appears that the problem is that when your Modified object is being instantiated and super is called, its being called like:  super(Original, self) since those are the default arguments for super.  Since Original is not a superclass of Modified (check isinstance(m, Original)), python is not allowing you to call super in that way.The following code does something similar to yours but better illustrates the problem.Adding Original to the bases of Modified will make it work:Edit:Per the comments, the above suggestion can be simplified since all the methods contained within Original will be included in Modified without needing to pass the dict in the type call:and going one step further, if you don't want Modified to be a subclass of Original, you could simply make Modified a copy of Original and then add attributes the same as you do in your example:
According to the documentation,Also note that, aside from the zero argument form, super() is not limited to use inside methods. The two argument form specifies the arguments exactly and makes the appropriate references. The zero argument form only works inside a class definition, as the compiler fills in the necessary details to correctly retrieve the class being defined, as well as accessing the current instance for ordinary methods.So, the super() in the code is equivalent to super(Orginal, self).__init__(), and it's determined in compile time.


Answer URL
https://docs.python.org/3/library/functions.html#super
