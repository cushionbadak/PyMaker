Natural Text
I'm trying to program a worlfram alpha like math expression solver. My current obstacle is figuring out which opening and closing brackets are corresponding. For example, how would I figure out which brackets in ((1 * 3) / (4 / 2)) are matching. The program will solve each of these sections individually, and when doing so replacing the section in the original with the answer. So, for example, the first section the program would try to solve in ((1 * 3) / (4 / 2)) would be (1 * 3), so it would replace that section with the product, 3, and ((1 * 3) / (4 / 2)) would now be (3 / (4 / 2)). My current code, if helpful is here - http://pastebin.com/Xpayzbff, the function that is handling the paring is parse(). Thanks! 
I'm not gonna write code for you, because that would defeat the point, but what you probably want is the Shunting-yard algorithm. It converts from infix (how humans normally represent series of operations, with the operator in the operands) into postfix(which is easy for a computer to evaluate, with the operator after the operands).Here is someone who did it for boolean login in python: https://msoulier.wordpress.com/2009/08/01/dijkstras-shunting-yard-algorithm-in-python/You could also try parsing the statement directly into an AST, which you could then manipulate.Also make sure to check out the tokenizer module for python.
Treat an expression between brackets as a list of symbols which can also contain another list. So "((1 * 3) / (4 / 2))" is represented by [['1', '*', '3'], '/', ['4', '/' '2']]. Call a list of symbols a ‘node’.As you iterate the string, maintain a stack, which keeps track of the ‘bracket pair’ (or node) that you’re in. Append symbols to the last node in the stack (current_node). At each '(', add a new node to the node you’re in, and to the stack. At each ')', pop the stack, so that you’re in the parent node, and further symbols will be appended there.Then you can recursively evaluate each node, inside first, until you have a final value.Reverse engineer this code.Check out this question:Python parsing bracketed blocks
You can use the Shunting-Yard algorithm. However, a complete implementation of the algorithm is pretty involved. Here is simpler, somewhat naive version that could give you a basic understanding https://gist.github.com/tiabas/339f5c06f541c176a02c02cc3113d6f7 


Answer URL
https://docs.python.org/3/library/tokenize.html
