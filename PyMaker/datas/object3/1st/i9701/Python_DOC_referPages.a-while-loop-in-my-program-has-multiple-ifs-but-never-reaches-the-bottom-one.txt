Natural Text
I am in the middle of a really difficult to grasp assignment for school. I've been trying for a few days and I think I'm finally almost done, but... I'm stuck again and don't know why. I am supposed to let the user fill in a number invoer (Dutch)/input. That number is supposed to be smaller than, or equal to 50. This number determines how many more inputs the user can do - these new inputs are test cases.Each test case should be a number larger than 0, but equal to, or lower than 100. It is not required to go very deep into handling bad input, so I only use some basic handling for that.Then what needs to be tested for each test case, is what the smallest number is that is divisible by the test case, but the sum of the separate digits of that smallest number should equal your test case itself. So in the example they state: input = 1, (which means 1 test case, but they dont state that), input 2 = 10 (which means your only test case is the number 10, but they dont state that). What it sends out is the number 190 (this is because 190/10 = 19, so it's a correct outcome, but 1+9+0 = 10 as well, so it passes the second test, but again, they dont state that. I had to figure this all out myself, which is why the assigment takes me so long... the question itself is in Dutch and barely gives you any information at all).So what my program DOES test, if I input number 25 as test case for example, that 25/25 = 1, so valid and 2+5 = 7. However, after calculating this number 7, it never seems to check the second condition. The sum of the digits needs to be 25, not 7. The program gets thrown in an infinite loop now and I don't see what is wrong.I will post my code below. I apologize for the variable names and printed text, as they are in Dutch. I hope I explained the meaning of all this clearly enough.I hope you guys can help me. Thanks a lot for you time in advance, I know it's quite the wall of text.
There are multiple issues at hand:In your inner loop in the second test's (if the sum of digits matches) else branch you've forgot to increment vermenigvuldiging, so when it "finds" the first getal that satisfies the modulo condition, it will loop forever.Handling of getal in the modulo test is also broken and will only match when vermenigvuldiging is 1, otherwise testgevallen[t] % getal will always equal testgevallen[t], since getal is larger. This will also result in an infinite loop. In fact the wholeseems like it is meant to iterate through numbers divisible by testgevallen[t] quickly in ascending order. This makes the whole modulo test redundant.A working solution for at least the input 10 could be for example:Note that I've removed using an index variable to iterate through the values of the list. Just iterate through it directly. You could also "enhance" your solution further using itertools.count, in which case you'd replace the while-loop with something like:
In this while loop t is never modified, so som == testgevallen[t] will be constant, causing an infinite loop. 
First, you should look up the usage of sys.exit() on the docs here. This command will exit the program when called, so if it is called at the end of the first while loop, the second while loop won't ever get run. The command you should use to break out of a while loop is break as used belowI suspect that the second while loop never gets run because you are using sys.exit() instead of just breaking from the loop. Also, in the second while loop, you need to alter your t variable or else Output moet zijn: ', som will constantly be printed and stuck in this loop.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.count
