Natural Text
How do I sort a multidimensional list to alphabetical order based on its first row of data without using numpy nor other modulesFor example I have a list:I want it to be like:Thanks!
I think there should be a better way; anyway, this would do the trick:Edit:zip(*l) gives you an iterator (in Python 3), if you do [i for i in zip(*l)], you'll find it looks like [('M', 1, 2), ('A', 3, 6), ('R', 5, 7), ('K', 4, 8)]sorted(zip(*l)) sorts the list above (becomes [('A', 3, 6), ('K', 4, 8), ('M', 1, 2), ('R', 5, 7)] under the hood), I didn't specify the key, so it compares the elements directlythen, you zip again, and you get an iterator of what you wants (elements in l are ('A', 'K', 'M', 'R'), (3, 4, 1, 5), (6, 8, 2, 7) if you print them out); however, you have to do map() so you can get <class 'list'> instead of <class 'tuple'>finally, map() also returns an iterator in Python3, to get a list, you simply use list([iterable]) to construct the final list.Documentations: zip, sorted, and map
Once you know the new "order" (or mapping) of the sorted indexes, you should be able to use operator.itemgetter to basically walk all the rows and get the items in the order that you just found.In your case, you have ['M', 'A', 'R', 'K']. In order to get those letters sorted, you should first get index 1, then index 3, then index 0 and finally index 2: (A K M R). Once you find that mapping, you can just call itemgetter to get you the items on each row in that order.Which ouputs:EDIT:rpatisso made me see (in comments to this answer) that there's more effective way to calculate the sorted_indexes variable than using list.index which is O(n2):
Try it with numpy.Without numpy:


Answer URL
https://docs.python.org/3/library/functions.html#zip
https://docs.python.org/3/library/functions.html#sorted
https://docs.python.org/3/library/functions.html#map
