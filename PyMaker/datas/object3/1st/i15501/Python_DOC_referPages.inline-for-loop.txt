Natural Text
I'm trying to learn neat pythonic ways of doing things, and was wondering why my for loop cannot be refactored this way:I tried replacing the for loop with:But it doesn't work. The for v in vm: loop evicts numbers from vm based on when they come next in q.
What you are using is called a list comprehension in Python, not an inline for-loop (even though it is similar to one). You would write your loop as a list comprehension like so:When using a list comprehension, you do not call list.append because the list is being constructed from the comprehension itself.  Each item in the list will be what is returned by the expression on the left of the for keyword, which in this case is q.index(v) if v in q else 99999.  Incidentially, if you do use list.append inside a comprehension, then you will get a list of None values because that is what the append method always returns.
your list comphresnion will, work but will return list of None because append return None:demo:better way to use it like this:
you can use enumerate keeping the ind/index of the elements is in vm, if you make vm a set you will also have 0(1) lookups:
Output:Instead of using append() in the list comprehension you can reference the p as direct output, and use q.index(v) and 99999 in the LC.Not sure if this is intentional but note that q.index(v) will find just the first occurrence of v, even tho you have several in q. If you want to get the index of all v in q, consider using a enumerator and a list of already visited indexesSomething in those lines(pseudo-code):


Answer URL
https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions
