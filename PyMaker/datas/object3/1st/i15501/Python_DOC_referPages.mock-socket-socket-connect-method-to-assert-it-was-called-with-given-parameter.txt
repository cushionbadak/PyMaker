Natural Text
I'm using Python 2.7 and the mock library to test if the connect method of an object instance of socket.socket class is called with certain arguments. However I want to use the mock only as a "marker" and continue with the function call normally. In the case below, I want socket.socket.connect to call to the real non-patched function as a "side-effect" so the method doesn't fail later.That is, I want a mock of the socket.socket class keeping the same functionality and behaviour but with the extra ability of recording the calls.Here is the (simplified) test. This is what I think I got wrong:And for reference, this is the (again simplified) code to connect and retrieve the results:However when running the test TypeError: connect() takes exactly 2 arguments (1 given)is raised. How can I do what I want?
To mocking unbound method you must use autospec=True to preserve the signature.... But unfortunately socket.socket.connect() cannot be mocked because is a C method. But our goal is not mock it but just wrap it by a mock. So the simplest but not really clean trick that I found was use a new class to fool mock frameworkYou must use ANY from mock helpers because you don't know what socket object will be passed to your wrapper.That trick works either for Python3 and Python2.7 but in Python3 the behavior is little bit different because socket.socket.connect() is not a function but a method_descriptor.Also in that case use autospec=True doesn't work.The real question is : are you sure you need a real connection to make your tests. Mock aims is uncouple testing from real resources, register calls and assert on arguments is a plus but the first use is replace real object by mocks that are simple, fast and can be configured to return what we need for testing defined behaviors.Maybe what you really need is patch() socket.socket and set some return_values or side_effect to drive your test in the cases you would test.
The inner function connect inside the method test_ip_from_settings is not a method but a function. So you must remove the first argument self.This:def connect(self, address):    socket.socket.connect(self, address)Should be:def connect(address):    socket.socket.connect(address)This is because of that when you call s.connect((settings.SERVER_IP, TCP_PORT)), the tuple (settings.SERVER_IP, TCP_PORT) is one argument, which goes to self argument in your case and then address variable still needs to be specified. In the second correct case, there is no self argument, so the tuple is bound to address argument.


Answer URL
https://docs.python.org/3/library/unittest.mock-examples.html#mocking-unbound-methods
