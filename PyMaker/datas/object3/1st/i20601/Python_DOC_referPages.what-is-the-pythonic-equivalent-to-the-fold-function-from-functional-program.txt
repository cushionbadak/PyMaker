Natural Text
What is the most idiomatic way to achieve something like the following, in Haskell:Or its equivalent in Ruby:Obviously, Python provides the reduce function, which is an implementation of fold, exactly as above, however, I was told that the 'pythonic' way of programming was to avoid lambda terms and higher-order functions, preferring list-comprehensions where possible. Therefore, is there a preferred way of folding a list, or list-like structure in Python that isn't the reduce function, or is reduce the idiomatic way of achieving this?
The Pythonic way of summing an array is sum. For other purposes, you can sometimes use some combination of reduce and the operator module, e.g.Be aware that reduce is actually a foldl, in Haskell terms. There is no special syntax to perform folds, there's no builtin foldr, and actually using reduce with non-associative operators is considered bad style.Using higher-order functions is quite pythonic; it makes good use of Python's principle that everything is an object, including functions and classes. You are right that lambdas are frowned upon by some Pythonistas, but mostly because they tend not to be very readable when they get complex.
Haskellfoldl (+) 0 [1,2,3,4,5]Pythonreduce(lambda a,b: a+b, [1,2,3,4,5], 0)Obviously, that is a trivial example to illustrate a point. In Python you would just do sum([1,2,3,4,5]) and even Haskell purists would generally prefer sum [1,2,3,4,5].For non-trivial scenarios when there is no obvious convenience function, the idiomatic pythonic approach is to explicitly write out the for loop and use mutable variable assignment instead of using reduce or a fold.That is not at all the functional style, but that is the "pythonic" way. Python is not designed for functional purists. See how Python favors exceptions for flow control to see how non-functional idiomatic python is.
In Python 3, the reduce has been removed: Release notes. Nevertheless you can use the functools moduleOn the other hand, the documentation expresses preference towards for-loop instead of reduce, hence:
You can reinvent the wheel as well:
Not really answer to the question, but one-liners for foldl and foldr:
The actual answer to this (reduce) problem is: Just use a loop!This will be faster than a reduce and things like PyPy can optimize loops like that.BTW, the sum case should be solved with the sum function 
I may be quite late to the party, but we can create custom foldr using simple lambda calculus and curried function. Here is my implementation of foldr in python.Even though the implementation is recursive (might be slow), it will print the values 15 and 120 respectively
I believe some of the respondents of this question have missed the broader implication of the fold function as an abstract tool. Yes, sum can do the same thing for a list of integers, but this is a trivial case. fold is more generic. It is useful when you have a sequence of data structures of varying shape and want to cleanly express an aggregation. So instead of having to build up a for loop with an aggregate variable and manually recompute it each time, a fold function (or the Python version, which reduce appears to correspond to) allows the programmer to express the intent of the aggregation much more plainly by simply providing two things:A default starting or "seed" value for the aggregation.A function that takes the current value of the aggregation (starting with the "seed") and the next element in the list, and returns the next aggregation value.


Answer URL
https://docs.python.org/3/howto/functional.html#the-functools-module
https://docs.python.org/3/library/functions.html#sum
