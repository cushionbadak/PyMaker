Natural Text
Originally I wanted to ask this question, but then I found it was already thought of before... Googling around I found this example of extending configparser. The following works with Python 3:But not with Python 2:Then I read a little bit on Python New Class vs. Old Class styles (e.g. here.And now I am wondering, I can do:But, shouldn't I call init? Is this in Python 2 the equivalent:
super() (without arguments) was introduced in Python 3 (along with __class__):so that would be the Python 2 equivalent for new-style classes:for old-style classes you can always use:
In a single inheritance case (when you subclass one class only), your new class inherits methods of the base class. This includes __init__. So if you don't define it in your class, you will get the one from the base.Things start being complicated if you introduce multiple inheritance (subclassing more than one class at a time). This is because if more than one base class has __init__, your class will inherit the first one only.In such cases, you should really use super if you can, I'll explain why. But not always you can. The problem is that all your base classes must also use it (and their base classes as well -- the whole tree).If that is the case, then this will also work correctly (in Python 3 but you could rework it into Python 2 -- it also has super):Notice how both base classes use super even though they don't have their own base classes.What super does is: it calls the method from the next class in MRO (method resolution order). The MRO for C is: (C, A, B, object). You can print C.__mro__ to see it.So, C inherits __init__ from A and super in A.__init__ calls B.__init__ (B follows A in MRO).So by doing nothing in C, you end up calling both, which is what you want.Now if you were not using super, you would end up inheriting A.__init__ (as before) but this time there's nothing that would call B.__init__ for you.To fix that you have to define C.__init__:The problem with that is that in more complicated MI trees, __init__ methods of some classes may end up being called more than once whereas super/MRO guarantee that they're called just once.
In short, they are equivalent. Let's have a history view:(1) at first, the function looks like this.(2) to make code more abstract (and more portable). A common method to get Super-Class is invented like:And init function can be:However  requiring an explicit passing of both the class and instance break the DRY (Don't Repeat Yourself) rule a bit. (3) in V3. It is more smart, is enough in most case. You can refer to http://www.python.org/dev/peps/pep-3135/
Just to have a simple and complete example for Python 3, which most people seem to be using now.gives
Another python3 implementation that involves the use of Abstract classes with super().  You should remember that   super().init(name, 10)has the same effect as  Person.init(self, name, 10)Remember there's a hidden 'self' in super(), So the same object passes on to the superclass init method and the attributes are added to the object that called it. Hence super()gets translated to  Person and then if you include the hidden self, you get the above code frag.  


Answer URL
https://docs.python.org/3/reference/datamodel.html#creating-the-class-object
