Natural Text
Given a list containing a known pattern surrounded by noise, is there an elegant way to get all items that equal the pattern. See below for my crude code.we would get 2, 1, 2, 3, 4, 2, 1, 2, 3, 4, 1, 2, 3, 4, 4, 3bonus: avoid appending i if the full pattern is not present (ie., allow 1,2,3,4 but not 1,2,3)examples: The lists contain named tuples.
I know this question is 5 months old and already "accepted", but googling a very similar problem brought me to this question and all the answers seem to have a couple of rather significant problems, plus I'm bored and want to try my hand at a SO answer, so I'm just going to rattle off what I've found.The first part of the question, as I understand it, is pretty trivial: just return the original list with all the elements not in the "pattern" filtered out. Following that thinking, the first code I thought of used the filter() function:I would say that this solution is definitely more succinct than the original solution, but it's not any faster, or at least not appreciably, and I try to avoid lambda expressions if there's not a very good reason for using them. In fact, the best solution I could come up with involved a simple list comprehension:This solution is both more elegant and significantly faster than the original: the comprehension is about 120% faster than the original, while casting the pattern into a set first bumps that up to a whopping 320% faster in my tests.Now for the bonus: I'll just jump right into it, my solution is as follows:This is a variation of Steven Rumbalski's "inefficient one liner", that, with the addition of the "mylist[i] == pattern[0]" check and thanks to python's short-circuit evaluation, is significantly faster than both the original statement and the itertools version (and every other offered solution as far as I can tell) and it even supports overlapping patterns. So there you go.
This will get the "bonus" part of your question:For non-bonus:Finally, this one handles overlaps:

Given:Here is an inefficient one liner:Here is a more efficient itertools version:
An idiomatic, composable solution to the problem.First off, we need to borrow an itertools recipe, consume (which consumes and discards a given number of elements from an iterator. Then we take the itertools recipe for pairwise, and extend it to an nwise function using consume:Now that we have that, solving the bonus problem is really easy:Similarly, a more succinct and speedier (if somewhat less pretty) solution to the main problem replaces:with:This behaves the same way, but avoids needing to store the temporary set to a name, and pushes all the filtering work to C.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools-recipes
