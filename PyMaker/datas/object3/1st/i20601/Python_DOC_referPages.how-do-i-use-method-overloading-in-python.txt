Natural Text
I am trying to implement method overloading in Python: but the output is second method 2; similarly:givesHow do I make this work?
It's method overloading not method overriding. And in Python, you do it all in one function:You can't have two methods with the same name in Python -- and you don't need to.See the Default Argument Values section of the Python tutorial. See "Least Astonishment" and the Mutable Default Argument for a common mistake to avoid.Edit: See PEP 443 for information about the new single dispatch generic functions in Python 3.4.
In Python, you don't do things that way. When people do that in languages like Java, they generally want a default value (if they don't, they generally want a method with a different name). So, in Python, you can have default values.As you can see, you can use this to trigger separate behaviour rather than merely having a default value.
You can also use pythonlangutil:Edit: With official support of Overloading in Python 3 you can use @overload decorator. 
You can't, never need to and don't really want to.In Python, everything is an object. Classes are things, so they are objects. So are methods.There is an object called A which is a class. It has an attribute called stackoverflow. It can only have one such attribute.When you write def stackoverflow(...): ..., what happens is that you create an object which is the method, and assign it to the stackoverflow attribute of A. If you write two definitions, the second one replaces the first, the same way that assignment always behaves.You furthermore do not want to write code that does the wilder of the sorts of things that overloading is sometimes used for. That's not how the language works.Instead of trying to define a separate function for each type of thing you could be given (which makes little sense since you don't specify types for function parameters anyway), stop worrying about what things are and start thinking about what they can do
I write my answer in Python 3.2.1.How it works:overload takes any amount of callables and stores them in tuple functions, then returns lambda.The lambda takes any amount of arguments, then returns result of calling function stored in functions[number_of_unnamed_args_passed] called with arguments  passed to the lambda.Usage:
I think the word you're looking for is "overloading".  There is no method overloading in python.  You can however use default arguments, as follows.When you pass it an argument it will follow the logic of the first condition and execute the first print statement.  When you pass it no arguments, it will go into the else condition and execute the second print statement.
I write my answer in Python 2.7:In Python, method overloading is not possible; if you really want access the same function with different features, I suggest you to go for method overriding.
In Python, overloading is not an applied concept. However, if you are trying to create a case where, for instance, you want one initializer to be performed if passed an argument of type foo and another initializer for an argument of type bar then, since everything in Python is handled as object, you can check the name of the passed object's class type and write conditional handling based on that.This concept can be applied to multiple different scenarios through different methods as needed.
In Python, you'd do this with a default argument.
Just came across this https://github.com/bintoro/overloading.py for anybody who may be interested.From the linked repository's readme:overloading is a module that provides function dispatching based on  the types and number of runtime arguments.When an overloaded function is invoked, the dispatcher compares the  supplied arguments to available function signatures and calls the  implementation that provides the most accurate match.FeaturesFunction validation upon registration and detailed resolution rules  guarantee a unique, well-defined outcome at runtime. Implements  function resolution caching for great performance. Supports optional  parameters (default values) in function signatures. Evaluates both  positional and keyword arguments when resolving the best match.  Supports fallback functions and execution of shared code. Supports  argument polymorphism. Supports classes and inheritance, including  classmethods and staticmethods.
Python does not support method overloading like Java or C++. We may overload the methods but can only use the latest defined method.We need to provide optional arguments or *args in order to provide different number of args on calling.Courtesy from https://www.geeksforgeeks.org/python-method-overloading/
While @agf was right with the answer in the past now with PEP-3124 we got our syntax sugger. See typing documentation for details  on the @overload decorator but note that this is really just syntax sugger and IMHO this is all people have been arguing about ever since. Personally I agree that having multiple functions with different signatures makes it more readable then having a single function with 20+ arguments all set to a default value (None most of the time) and then having to fiddle around using endless if, elif, elsechains to find out what the caller actually wants our function to do with the provided set of arguments. This, this is long overdue following the Python Zen Beautiful is better than ugly.and arguably also Simple is better than complex.Straight from the official Python documentation linked above: 
Python 3.x includes standard typing library which allows for method overloading with the use of @overload decorator. Unfortunately, this is to make the code more readable, as the @overload decorated methods will need to be followed by a non-decorated method that handles different arguments. More can be found here here but for your example:
In MathMethod.py fileIn Main.py fileWe can overload method by using multipledispatch 


Answer URL
https://docs.python.org/3/library/typing.html#typing.overload
https://docs.python.org/3/library/typing.html#typing.overload
https://docs.python.org/3/library/typing.html
https://docs.python.org/3/library/typing.html#typing.overload
