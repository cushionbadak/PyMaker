Natural Text
The docs say that a class is hashable as long as it defines __hash__ method and __eq__ method. However:What makes X unhashable?Note that I must have identical lists (in terms of regular equality) to be hashed to the same value; otherwise, I will violate this requirement on hash functions:The only required property is that objects which compare equal have  the same hash valueThe docs do warn that a hashable object shouldn't be modified during its lifetime, and of course I don't modify instances of X after creation. Of course, the interpreter won't check that anyway.
Simply setting the __hash__ method to that of the tuple class is not enough. You haven't actually told it how to hash any differently. tuples are hashable  because they are immutable. If you really wanted to make you specific example work, it might be like this:In this case you are actually defining how to hash your custom list subclass. You just have to define exactly how it can generate a hash. You can hash on whatever you want, as opposed to using the tuple's hashing method:
From the Python3 docs:If a class does not define an __eq__() method it should not define a  __hash__() operation either; if it defines __eq__() but not __hash__(), its instances will not be usable as items in hashable collections. If a class defines mutable objects and implements an  __eq__() method, it should not implement __hash__(), since the implementation of hashable collections requires that a key’s hash  value is immutable (if the object’s hash value changes, it will be in  the wrong hash bucket).Ref: object.__hash__(self)Sample code:
What you could and should do, based on your other question, is:don't subclass anything, just encapsulate a tuple. It's perfectly fine to do so in the init.which yields:
If you don't modify instances of X after creation, why aren't you subclassing tuple? But I'll point out that this actually doesn't throw an error, at least in Python 2.6. I hesitate to say "works" because this doesn't do what you think it does. It's just using the object id as a hash. When you actually call __hash__ you still get an error; likewise for __eq__. I gather that the python internals, for some reason, are detecting that X has a __hash__ and an __eq__ method, but aren't calling them. The moral of all this is: just write a real hash function. Since this is a sequence object, converting it to a tuple and hashing that is the most obvious approach.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__hash__
