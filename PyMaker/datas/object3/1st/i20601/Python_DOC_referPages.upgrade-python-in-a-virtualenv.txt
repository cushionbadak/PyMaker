Natural Text
Is there a way to upgrade the version of python used in a virtualenv (e.g. if a bugfix release comes out)?I could pip freeze --local > requirements.txt, then remove the directory and pip install -r requirements.txt, but this requires a lot of reinstallation of large libraries, for instance, numpy, which I use a lot. I can see this is an advantage when upgrading from, e.g., 2.6 -> 2.7, but what about 2.7.x -> 2.7.y?
Did you see this? If I haven't misunderstand that answer, you may try to create a new virtualenv on top of the old one. You just need to know which python is going to use your virtualenv (you will need to see your virtualenv version). If your virtualenv is installed with the same python version of the old one and upgrading your virtualenv package is not an option, you may want to read this in order to install a virtualenv with the python version you want.EDITI've tested this approach (the one that create a new virtualenv on top of the old one) and it worked fine for me. I think you may have some problems if you change from python 2.6 to 2.7 or 2.7 to 3.x but if you just upgrade inside the same version (staying at 2.7 as you want) you shouldn't have any problem, as all the packages are held in the same folders for both python versions (2.7.x and 2.7.y packages are inside your_env/lib/python2.7/).If you change your virtualenv python version, you will need to install all your packages again for that version (or just link the packages you need into the new version packages folder, i.e: your_env/lib/python_newversion/site-packages)
If you happen to be using the venv module that comes with Python 3.3+, it supports an --upgrade option. Per the docs:Upgrade the environment directory to use this version of Python, assuming Python has been upgraded in-place
Updated again:The following method might not work in newer versions of virtualenv. Before you try to make modifications to the old virtualenv, you should save the dependencies in a requirement file (pip freeze > requirements.txt) and make a backup of it somewhere else. If anything goes wrong, you can still create a new virtualenv and install the old dependencies in it (pip install -r requirements.txt).Updated: I changed the answer 5 months after I originally answered. The following method is more convenient and robust.Side effect: it also fixes the Symbol not found: _SSLv2_method exception when you do import ssl in a virtual environment after upgrading Python to v2.7.8.Notice: Currently, this is for Python 2.7.x only.If you're using Homebrew Python on OS X, first deactivate all virtualenv, then upgrade Python:Run the following commands (<EXISTING_ENV_PATH> is path of your virtual environment):Finally, re-create your virtual environment:By doing so, old Python core files and standard libraries (plus setuptools and pip) are removed, while the custom libraries installed in site-packages are preserved and working, as soon as they are in pure Python. Binary libraries may or may not need to be reinstalled to function properly.This worked for me on 5 virtual environments with Django installed.BTW, if ./manage.py compilemessages is not working afterwards, try this:
I wasn't able to create a new virtualenv on top of the old one.  But there are tools in pip which make it much faster to re-install requirements into a brand new venv.  Pip can build each of the items in your requirements.txt into a wheel package, and store that in a local cache.  When you create a new venv and run pip install in it, pip will automatically use the prebuilt wheels if it finds them.  Wheels install much faster than running setup.py for each module.My ~/.pip/pip.conf looks like this:I install wheel (pip install wheel), then run pip wheel -r requirements.txt.  This stores the built wheels in the wheel-dir in my pip.conf.From then on, any time I pip install any of these requirements, it installs them from the wheels, which is pretty quick.  
How to upgrade the Python version for an existing virtualenvwrapper project and keep the same nameI'm adding an answer for anyone using Doug Hellmann's excellent virtualenvwrapper specifically since the existing answers didn't do it for me.Some context:I work on some projects that are Python 2 and some that are Python 3; while I'd love to use python3 -m venv, it doesn't support Python 2 environmentsWhen I start a new project, I use mkproject which creates the virtual environment, creates an empty project directory, and cds into itI want to continue using virtualenvwrapper's workon command to activate any project irrespective of Python versionDirections:Let's say your existing project is named foo and is currently running Python 2 (mkproject -p python2 foo), though the commands are the same whether upgrading from 2.x to 3.x, 3.6.0 to 3.6.1, etc.  I'm also assuming you're currently inside the activated virtual environment.1. Deactivate and remove the old virtual environment:Note that if you've added any custom commands to the hooks (e.g., bin/postactivate) you'd need to save those before removing the environment.2. Stash the real project in a temp directory:3. Create the new virtual environment (and project dir) and activate:4. Replace the empty generated project dir with real project, change back into project dir:5. Re-install dependencies, confirm new Python version, etc:If this is a common use case, I'll consider opening a PR to add something like $ upgradevirtualenv / $ upgradeproject to virtualenvwrapper.
I moved my home directory from one mac to another (Mountain Lion to Yosemite) and didn't realize about the broken virtualenv until I lost hold of the old laptop. I had the virtualenv point to Python 2.7 installed by brew and since Yosemite came with Python 2.7, I wanted to update my virtualenv to the system python. When I ran virtualenv on top of the existing directory, I was getting OSError: [Errno 17] File exists: '/Users/hdara/bin/python2.7/lib/python2.7/config' error. By trial and error, I worked around this issue by removing a few links and fixing up a few more manually. This is what I finally did (similar to what @Rockalite did, but simpler):After this, I was able to just run virtualenv on top of the existing directory.
On OS X or macOS using Homebrew to install and upgrade Python3 I had to delete symbolic links before python -m venv --upgrade ENV_DIR would work.I saved the following in upgrade_python3.sh so I would remember how months from now when I need to do it again:UPDATE: while this seemed to work well at first, when I ran py.test it gave an error.  In the end I just re-created the environment from a requirements file.
If you're using pipenv, I don't know if it's possible to upgrade an environment in place, but at least for minor version upgrades it seems to be smart enough not to rebuild packages from scratch when it creates a new environment. E.g., from 3.6.4 to 3.6.5:
I just want to clarify, because some of the answers refer to venv and others refer to virtualenv.Use of the -p or --python flag is supported on virtualenv, but not on venv. If you have more than one Python version and you want to specify which one to create the venv with, do it on the command line, like this:You can of course upgrade with venv as others have pointed out, but that assumes you have already upgraded the Python that was used to create that venv in the first place. You can't upgrade to a Python version you don't already have on your system somewhere, so make sure to get the version you want, first, then make all the venvs you want from it.
For everyone with the problemError: Command '['/Users/me/Sites/site/venv3/bin/python3', '-Im', 'ensurepip', '--upgrade', '--default-pip']' returned non-zero exit status 1.You have to install python3.6-venv


Answer URL
https://docs.python.org/3/library/venv.html
