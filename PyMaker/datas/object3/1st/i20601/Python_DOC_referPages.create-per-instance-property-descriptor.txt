Natural Text
Usually Python descriptor are defined as class attributes. But in my case, I want every object instance to have different set descriptors that depends on the input. For example:Each object are have different set of attributes that are decided at instantiation time. Since these are one-off objects, it is not convenient to first subclass them.Assign Descriptor to the object does not seem to work. If I try to access the attribute, I got something likeDo you know why is this not working? Is there any work around?
This is not working because you have to assign the descriptor to the class of the object.if you writeso it does not work because the type dictionairy is looked up for descriptors and not the object dictionairy.there are possible work arounds:put the descriptor into the class and make it use e.g. obj.xxxattr to store the value. If there is only one descriptor behaviour this works.overwrite setattr and getattr and delattr to respond to discriptors.put a discriptor into the class that responds to descriptors stored in the object dictionairy. 
You are using descriptors in the wrong way.Descriptors don't make sense on an instance level. After all the __get__/__set__methods give you access to the instance of the class.Without knowing what exactly you want to do, I'd suggest you put the per-instancelogic inside the __set__ method, by checking who is the "caller/instance" and act accordingly.Otherwise tell us what you are trying to achieve, so that we can propose alternative solutions.
This looks like a use-case for named tuples
The reason it is not working is because Python only checks for descriptors when looking up attributes on the class, not on the instance; the methods in question are:__getattribute____setattr____delattr__It is possible to override those methods on your class in order to implement the descriptor protocol on instances as well as classes:When the above class is used as below:The results are:hello!BIGreally?can't delete attributehello!can't delete attributereally?
I dynamically create instances by execing a made-up class. This may suit your use case.  Test;  But the instances are of different class.  


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__getattribute__
https://docs.python.org/3/reference/datamodel.html#object.__setattr__
https://docs.python.org/3/reference/datamodel.html#object.__delattr__
