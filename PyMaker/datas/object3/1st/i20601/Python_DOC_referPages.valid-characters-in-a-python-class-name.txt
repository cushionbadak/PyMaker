Natural Text
I'm dynamically creating python classes, and I know not all characters are valid in this context. Is there a method somewhere in the class library that I can use to sanitize a random text string, so that I can use it as a class name? Either that or a list of the allowed characters would be a good help.Addition regarding clashes with identifier names: Like @Ignacio pointed out in the answer below, any character that is valid as an identifier is a valid character in a class name. And you can even use a reserved word as a class name without any trouble. But there's a catch. If you do use a reserved word, you won't be able to make the class accessible like other (non-dynamically-created) classes (e.g., by doing globals()[my_class.__name__] = my_class). The reserved word will always take precedence in such case. 
Python Language Reference, ยง2.3, "Identifiers and keywords"Identifiers (also referred to as names) are described by the following lexical definitions:Identifiers are unlimited in length. Case is significant.
As per Python Language Reference, ยง2.3, "Identifiers and keywords", a valid Python identifier is defined as:Or, in regex:
The thing that makes this interesting is that the first character of an identifier is special.  After the first character, numbers '0' through '9' are valid for identifiers, but they must not be the first character.Here's a function that will return a valid identifier given any random string of characters.  Here's how it works:First, we use itr = iter(seq) to get an explicit iterator on the input.  Then there is a first loop, which uses the iterator itr to look at characters until it finds a valid first character for an identifier.  Then it breaks out of that loop and runs the second loop, using the same iterator (which we named itr) for the second loop.  The iterator itr keeps our place for us; the characters the first loop pulled out of the iterator are still gone when the second loop runs.This is a clean and Pythonic way to handle a sequence two different ways.  For a problem this simple, we could just have a Boolean variable that indicates whether we have seen the first character yet or not:I don't like this version nearly as much as the first version.  The special handling for one character is now tangled up in the whole flow of control, and this will be slower than the first version as it has to keep checking the value of saw_first_char constantly.  But this is the way you would have to handle the flow of control in most languages!  Python's explicit iterator is a nifty feature, and I think it makes this code a lot better.Looping on an explicit iterator is just as fast as letting Python implicitly get an iterator for you, and the explicit iterator lets us split up the loops that handle the different rules for different parts of the identifier.  So the explicit iterator gives us cleaner code that also runs faster.  Win/win.
This is an old question by now, but I'd like to add an answer on how to do this in Python 3 as I've made an implementation.The allowed characters are documented here: https://docs.python.org/3/reference/lexical_analysis.html#identifiers . They include quite a lot of special characters, including punctuation, underscore, and a whole slew of foreign characters. Luckily the unicodedata module can help. Here's my implementation implementing directly what the Python documentation says:This code is adapted from here under CC0: https://github.com/Ghostkeeper/Luna/blob/d69624cd0dd5648aec2139054fae4d45b634da7e/plugins/data/enumerated/enumerated_type.py#L91 . It has been well tested.


Answer URL
https://docs.python.org/3/reference/lexical_analysis.html#identifiers
