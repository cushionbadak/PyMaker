Natural Text
I was checking a calculator example, in the example used eval() which is dangerous normally, but here is a part of that example;    I checked it but I didn't understand; how eval(str1,{"__builtins__":None},{}) is not dangerous? It's about {"__builtins__":None},{} this part obviously, but I don't understand.Note: str1 is a string that we are adding numbers and smybols like 4+5. Then eval() processing it. 
The code is not safe in the slightest. It's relatively easy to get access to the builtins module just by accessing attributes of literals.eg.Broken down:''.__class__.__base__ is shorthand for objectobject.__subclasses__() lists all the subclasses of object in the interpreter (this includes classes used by the import machinery[klass for klass in ... if klass.__name__ == "BuiltinImporter"][0] -- select the BuiltinImporter class.load_module("builtins") use the BuiltinImporter to get access to the builtins module -- the very thing you were trying to restrict access to.
According to the documentation of eval,The expression argument is parsed and evaluated as a Python expression using the globals and locals dictionaries as global and local namespace. If the globals dictionary is present and lacks '__builtins__', the current globals are copied into globals before expression is parsed. This means that expression normally has full access to the standard builtins module and restricted environments are propagated. If the locals dictionary is omitted it defaults to the globals dictionary. If both dictionaries are omitted, the expression is executed in the environment where eval() is called.So the attempt of the code you are showing is to eval an expression in a context where no potentially dangerous functions are available.  For example, eval('print("bad stuff")') will print bad stuff but not if you pass an empty global namespace even without the builtin print.Don't take this sense of security too far.  Untrusted code can also harvoc your program even within those restrictions.  For example, the following string if eval()d will crash your Python interpreter by exceeding its recursion stack:As HÃ¥ken Lid has mentioned in his comment, a safer approach would be to use ast.literal_eval which was just made for this.  As a general rule: it is always better to use the least powerful command that does the job rather than using a powerful one and trying to restrict it manually.  There are too many things you can forget.
The reason why that is a safer way of executing eval() is because it is explicitly restricting which builtin methods are allowed (which are none in this case). You can use that parameter to specify any of the builtins that are allowed.  Here is more information on the subject


Answer URL
https://docs.python.org/3/library/functions.html#eval
