Natural Text
I have a variable, x, and I want to know whether it is pointing to a function or not.I had hoped I could do something like:But that gives me:The reason I picked that is because
If this is for Python 2.x or for Python 3.2+, you can also use callable(). It used to be deprecated, but is now undeprecated, so you can use it again. You can read the discussion here: http://bugs.python.org/issue10518. You can do this with:If this is for Python 3.x but before 3.2, check if the object has a __call__ attribute. You can do this with:The oft-suggested types.FunctionTypes approach is not correct because it fails to cover many cases that you would presumably want it to pass, like with builtins:The proper way to check properties of duck-typed objects is to ask them if they quack, not to see if they fit in a duck-sized container. Don't use types.FunctionType unless you have a very specific idea of what a function is.
Builtin types that don't have constructors in the built-in namespace (e.g. functions, generators, methods) are in the types module. You can use types.FunctionType in an isinstance call.
Since Python 2.1 you can import isfunction from the inspect module.
The accepted answer was at the time it was offered thought to be correct. As itturns out, there is no substitute for callable(), which is back in Python3.2: Specifically, callable() checks the tp_call field of the object beingtested. There is no plain Python equivalent.  Most of the suggested tests arecorrect most of the time:We can throw a monkey-wrench into this by removing the __call__ from theclass. And just to keep things extra exciting, add a fake __call__ to the instance!Notice this really isn't callable:callable() returns the correct result:But hasattr is wrong:can_o_spam does have that attribute after all; it's just not used when callingthe instance.Even more subtle, isinstance() also gets this wrong:Because we used this check earlier and later deleted the method, abc.ABCMetacaches the result. Arguably this is a bug in abc.ABCMeta. That said,there's really no possible way it could produce a more accurate result thanthe result than by using callable() itself, since the typeobject->tp_callslot method is not accessible in any other way.Just use callable()
The following should return a boolean:
Python's 2to3 tool (http://docs.python.org/dev/library/2to3.html) suggests:It seems this was chosen instead of the hasattr(x, '__call__') method because of http://bugs.python.org/issue7006.
callable(x) will return true if the object passed can be called in Python, but the function does not exist in Python 3.0, and properly speaking will not distinguish between:You'll get <class 'A'> True and <type function> True as output.isinstance works perfectly well to determine if something is a function (try isinstance(b, types.FunctionType)); if you're really interested in knowing if something can be called, you can either use hasattr(b, '__call__') or just try it.This, of course, won't tell you whether it's callable but throws a TypeError when it executes, or isn't callable in the first place.  That may not matter to you.
If you want to detect everything that syntactically looks like a function: a function, method, built-in fun/meth, lambda ... but exclude callable objects (objects with __call__ method defined), then try this one:I compared this with the code of is*() checks in inspect module and the expression above is much more complete, especially if your goal is filtering out any functions or detecting regular properties of an object.
Try using callable(x).
A function is just a class with a __call__ method, so you can doFor example:That is the "best" way of doing it, but depending on why you need to know if it's callable or note, you could just put it in a try/execpt block:It's arguable if try/except is more Python'y than doing if hasattr(x, '__call__'): x().. I would say hasattr is more accurate, since you wont accidently catch the wrong TypeError, for example:
Here's a couple of other ways:Here's how I came up with the second:
Note that Python classes are also callable.To get functions (and by functions we mean standard functions and lambdas) use:
If you have learned C++, you must be familiar with function object or functor, means any object that can be called as if it is a function.In C++,  an ordinary function is a function object, and so is a function pointer; more generally, so is an object of a class that defines operator(). In C++11 and greater, the lambda expression is the functor too.Similarity, in Python, those functors are all callable. An ordinary function can be callable, a lambda expression can be callable, a functional.partial can be callable, the instances of class with a __call__() method can be callable. Ok, go back to question : I have a variable, x, and I want to know whether it is pointing to a function or not.If you want to judge weather the object acts like a function, then the callable method suggested by @John Feminella is ok.If you want to judge whether a object is just an ordinary function or not( not a callable class instance, or a lambda expression), then the xtypes.XXX suggested by @Ryan is a better choice.Then I do an experiment using those code:Define a class and an ordinary function.Define the functors:Define the functors' list and the types' list:Judge wether the functor is callable. As you can see, they all are callable.Judge the functor's type( types.XXX). Then the types of functors are not all the same.I draw a table of callable functor's types using the data.Then you can choose the functors' types that suitable.such as:
Since classes also have __call__ method, I recommend another solution:
As the accepted answer, John Feminella stated that:The proper way to check properties of duck-typed objects is to ask them if they quack, not to see if they fit in a duck-sized container. The "compare it directly" approach will give the wrong answer for many functions, like builtins.Even though,  there're two libs to distinguish functions strictly, I draw an exhaustive comparable table:8.9. types — Dynamic type creation and names for built-in types — Python 3.7.0 documentation30.13. inspect — Inspect live objects — Python 3.7.0 documentationThe "duck typing" is a preferred solution for general purpose:As for the builtins functionWhen go one more step to check if builtin function or user-defined funtionDetermine if builtin functionSummaryEmploy callable to duck type checking a function,Use types.BuiltinFunctionType if you have further specified demand.
Instead of checking for '__call__' (which is not exclusive to functions), you can check whether a user-defined function has attributes func_name, func_doc, etc. This does not work for methods. Another way of checking is using the isfunction() method from the inspect module.To check if an object is a method, use inspect.ismethod()
Whatever function is a class so you can take the name of the class of instance x and compare:
The solutions using hasattr(obj, '__call__') and callable(.) mentioned in some of the answers have a main drawback: both also return True for classes and instances of classes with a __call__() method. Eg.One proper way of checking if an object is a user-defined function (and nothing but a that) is to use isfunction(.):If you need to check for other types, have a look at inspect — Inspect live objects.
In Python3 I came up with type (f) == type (lambda x:x) which yields True if f is a function and False if it is not. But I think I prefer isinstance (f, types.FunctionType), which feels less ad hoc. I wanted to do type (f) is function, but that doesn't work. 
Following previous replies, I came up with this:
If the code will go on to perform the call if the value is callable, just perform the call and catch TypeError.
The following is a "repr way" to check it. Also it works with lambda.


Answer URL
https://docs.python.org/3/library/inspect.html
