Natural Text
Okay, so this is a little hard to explain, but here goes:I have a dictionary, which I'm adding content to. The content is a hashed username (key) with an IP address (value). I was putting the hashes into an order by running them against base 16, and then using Collection.orderedDict. So, the dictionary looked a little like this:What I needed was a mechanism that would allow me to pick one of those keys, and get the key/value item one higher and one lower. So, for example, If I were to pick 2345, the code would return the key:value combinations '1234:8.8.8.8' and '3213:4.4.4.4'So, something like:
As seen in the OrderedDict source code, if you have a key and you want to find the next and prev in O(1) here's how you do that.This will give you next and prev by insertion order. If you add items in random order then just keep track of your items in sorted order. 
Edit: OP now states that they are using OrderedDicts but the use case still requires this sort of approach.Since dicts are not ordered you cannot directly do this. From your example, you are trying to reference the item like you would use a linked list.A quick solution would be instead to extract the keys and sort them then iterate over that list:The keyList holds the order of your items and you have to go back to it to find out what the next/previous key is to get the next/previous value. You also have to check for i+1 being greater than the list length and i-1 being less than 0.You can use an OrderedDict similarly but I believe that you still have to do the above with a separate list as OrderedDict doesn't have next/prev methods.
You could use a generic function, based on iterators, to get a moving window (taken from this question):Using the above function with OrderedDict.items() will give you three (key, value) pairs, in order:Of course using this function the first and last values will never be in the middle position (although this should not be difficult to do with some adaptation).I think the biggest advantage is that it does not require table lookups in the previous and next keys, and also that it is generic and works with any iterable.
Try:As in @AdamKerz's answer enumerate seems pythonic, but if you are a beginner this code might help you understand it in an easy way.And I think its faster + smaller compared to sorting followed by building list & then enumerating
You can store the keys and values in temp variable in prior, and can access previous and next key,value pair using index. It is pretty dynamic, will work for any key you query. Please check this code :
Maybe it is an overkill, but you can keep Track of the Keys inserted with a Helper Class and according to that list, you can retrieve the Key for Previous or Next. Just don't forget to check for border conditions, if the objects is already first or last element. This way, you will not need to always resort the ordered list or search for the element.
You could also use the list.index() method.This function is more generic (you can check positions +n and -n), it will catch attempts at searching a key that's not in the dict, and it will also return None if there's nothing before of after the key:
I think this is a nice Pythonic way of resolving your problem using a lambda and list comprehension, although it may not be optimal in execution time:


Answer URL
https://docs.python.org/3/tutorial/controlflow.html?highlight=lambda#lambda-expressions
https://docs.python.org/3/library/stdtypes.html?highlight=list%20comprehension#lists
