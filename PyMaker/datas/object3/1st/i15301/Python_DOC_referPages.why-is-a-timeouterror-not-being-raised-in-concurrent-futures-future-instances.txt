Natural Text
I'm basing this off of the sample from https://docs.python.org/3/library/concurrent.futures.html#id1.  I've update the following:data = future.result()to this:data = future.result(timeout=0.1) The doc for concurrent.futures.Future.result states:  If the call hasnâ€™t completed in timeout seconds, then a TimeoutError will be raised. timeout can be an int or float (I know there is a timeout on the request, for 60, but in my real code I'm performing a different action that doesn't use a urllib request)TimeoutError is raised if I set it on the call to as_completed, but I need to set the timeout on a per Future basis, not all of them as a whole.UpdateThanks @jme, that works with a single Future, but not with multiples using the below. Do I need to yield at the beginning of the functions to allow the build-up of the futures dict? From the docs it sounds like the calls to submit shouldn't block.  
The exception is being raised in the main thread, you just aren't seeing it because stdout hasn't been flushed. Try for example:Run this and you'll see "Too long!" appear after one second, but the interpreter will wait an additional four seconds for the threads to finish executing. Then you'll see 42 -- the result of wait() -- appear.What does this mean? Setting a timeout doesn't kill the thread, and that's actually a good thing. What if the thread is holding a lock? If we kill it abruptly, that lock is never freed. No, it's much better to let the thread handle its own demise. Likewise, the purpose of future.cancel is to prevent a thread from starting, not to kill it.
The issue seems to be with the call to concurrent.futures.as_completed().  If I replace that with just a for loop, everything seems to work:  I misinterpreted the doc for as_completed which states:  ...yields futures as they complete (finished or were cancelled)...  as_completed will handle timeouts but as a whole, not on a per future basis.


Answer URL
https://docs.python.org/3/library/concurrent.futures.html#id1
