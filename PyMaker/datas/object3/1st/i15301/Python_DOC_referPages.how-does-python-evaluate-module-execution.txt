Natural Text
I have two files in the same directory one that contains the contents of my program poker.py and the other that has test cases poker_test.py.In poker_test.py I execute the following commands to run the test cases:Then at the end of poker.py while I'm developing i have the following commnands:Everything works just fine(for now) and this setup is great for iterative development. My question is how does python evaluate poker.py when I run it, given that poker_test.py depends on poker.py and vice versa?I have a rough idea, but was wondering what the "official" answer is.Thanks,-M
In terms of whether you should do it, as Alex says, avoid it at all costs.  Cyclical imports are a state of sin.With that aside, it's interesting to look at what's happening (roughly - it looks like the module import mechanism is an area that gets tweaked from version to version in Python.  My main source for this was the Python 3.4.2 docs on the importing system)When the line within poker_test.py:gets executed, the system first checks if the module is already loaded.  Loaded modules live in a dictionary called sys.modules.If the module being imported is in sys.modules already, any reference to poker in poker_test.py just points to that namespace.  (Note that in the case of cyclical imports, the module might already be added to sys.modules, but the populating of the namespace may not be fully over.  Execution of that module might be paused for the moment at the line that says import this_or_that_other_module)If the module is not there, then the system creates a new namespace, adds it to sys.modules, looks for the code that is associated with the poker module (in this case, living in poker.py) and begins to execute it, putting all the variables in the newly created namespace.So you'd think poker.py gets run once, and poker_test.py gets run once and already notices that poker is a loaded module, so the importing ends there.  Except...When a module is run as the original script, it gets registered as __main__ in sys.modules, instead of its actual name.  So poker.py is going to be called the __main__ module, and as a result, when poker_test tries running import poker, it can't find poker under sys.modules.  poker will be loaded twice, once as __main__ and again as poker.  Cyclical imports are frowned upon, but cyclical imports of the __main__ module is downright condemned because of this issue of creating two identical(ish) namespaces and the potential weird errors that can result.There are two more complications in your code.1) from poker_test import *Because you're doing an import *, instead of putting all the variables created from poker_test in its own namespace, it gets thrown into the __main__ namespace.2) if __name__=='__main__':Because you're only importing from poker_test if the module is the main script being executed, the Python interpreter will not touch that line when poker gets imported from poker_test.  So your code isn't really looping conceptually.  poker as __main__ imports poker_test which imports poker and stops there.  Simple!...so let's not do circular imports.Some reference material:Official Python 3.4.2 docs on the import system2008 comp.lang.python discussion on cyclical imports
It's always soundest to avoid circular dependencies like the one you've created here.  However you luck out because the from poker_test import * comes at the very end of poker.py, i.e, after the latter has defined all it does define, so it can be imported in a good state by the circularly-dependent poker_test.py.However, while this happens to work in current Python version,s it's not guaranteed by the language spec.  For solidity, break the circular dependency, e.g as follows:move all the "substantial" contents of poker.py before the if __name__ check to e.g _poker.pyin poker.py, just do from _poker import *in poker_test.py, instead of import poker, use import _poker as pokerThis way, your dependency graph becomes acyclical, and as a consequence your code will work as intended in any correct version of Python, including hypothetical future ones:-).


Answer URL
https://docs.python.org/3/reference/import.html#references
https://docs.python.org/3/reference/import.html
