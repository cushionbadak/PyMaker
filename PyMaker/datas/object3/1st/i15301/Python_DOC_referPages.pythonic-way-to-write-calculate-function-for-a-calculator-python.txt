Natural Text
I am creating a text calculator that does not work completely conventionally. It works like this:Operation Input: The user inputs the operation the calculator will process (+ for addition, - for subtraction, * for multiplication, or / for division)Operand Input: The user inputs in each operand of the calculation, pressing Return between operands. Once the user has inputted all of his desired operands, striking Return three times initiates calculation.Calculation:When a user enters in more than two operands, instead of doing:operand1 plus/minus/times/divided by operand2,It does:operand1 plus/minus/times/divided by operand2 plus/minus/times/divided by operand3,And so on for all of the inputted operands.The code for this simply loops through the list of inputted operands, operandList, and uses the chosen operation, operation (and result is the result of the calculation):This is super inefficient because it checks for the operation twice, and once inside the while loop, which is even worse.Obviously if I write one of those while loop blocks for each operation and begin each one with an if statement to check for the operation that is much worse.If I did that you would see that the only difference between each block of code is the operation sign in result +,-,*,/= operandList[operateCount].How can I:Cut out the redundant code that checks for the operation and executes the respective loop, and Reduce/ change the redundant code that checks for the operation when it displays the result?Any help is greatly appreciated. Please ask for specifications if necessary. And if you down vote, please comment your reason for doing so so I can make changes.
The key idea is, build a dict:I'm associating to each operator symbols three items: the function to use, the name to use, and (which you seem to have ignored!) the "neutral" starting point.  Starting always at 0 as you do makes products and quotient risible -- multiply and divide by whatever, it doesn't matter, if it starts at 0, it stays at 0 forever, you know!-)Now things get simpler...:I have no idea why you're so inordinately fond of global and messing with indexing without necessity.  is_number apparently is a method only of floats and you're initializing result to an int, so it could crash the code -- I've replaced it with a sensible check.No need for global for names you're only using and not assigning -- and of course it would make sense to lose the global result and instead return result at the end; but I've left it in just in case there might be any sane reason to have it global (I can't think of any).But the core idea is: in Python, for dispatching purposes, think dict first and foremost!Added: OP asks peculiar questions in comments, such as "What exactly is the function of the import statement?" -- answer, obviously, is "to make another module available" (in this case, module operator from Python's standard library, to get its functions performing addition, multiplication, and so forth).  Also "what is the 'neutral starting point'" -- answer, obviously, is "the initial value of result before you start adding, multiplying and so on.In the OP's original code in the Q, result was unconditionally initialized to zero.  If you start with zero and multiply it by whatever number(s), it stays zero -- it's not a "neutral" starting point for a series of multiplication, it's more of a "fixed" point, a "black hole" in a sense.  So, I used different initial values depending on the operation.


Answer URL
https://docs.python.org/3/library/stdtypes.html#float.is_integer
