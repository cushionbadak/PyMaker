Natural Text
I just started learning python and here I have a sorted list of protein sequences (total 59,000 sequences) and some of them overlap. I have made a toy list here for example:I would like to remove those shorter overlap and just keep the longest one so the desired output would look like this:How can I do it? My code looks like this:And I got the error message:
There is other working answers, but none of them explain your actual problem. you were actually really close of a valid solution and what is, in my opinion, the most readable answer.The error came from the fact that you were mutating the same list while checking for index using range().Thus, while increasing the i variable you were removing item from the list which at one point causes the index error inevitably. Therefore, here is a working version of your initial code with some changes, Note that this code will work if your list is previously sorted as you mentioned in comment section.What is this code doing ?Basically, it use the same logic of your initial answer where it iterates on the list and check if the next item contains the current item. But, using another list and iterating until the before last item, will fix your index problem. But now comes a question, What should I do with the last item ? Since the list is sorted, you can consider the last item as always being unique. This is why I'm using which adds the last item of the initial list. Important noteThis answer was written in response to OP's initial question where he wanted to keep the longer overlap and I quote based on the next item in same list. As stated by @Chris_Rands if your concerns are related to a biological task and need to find any overlap, this solution is not suited for your needs. Example where this code would fail to recognize a potential overlap,where it would output the same result without removing the possible "ACD" overlap. Now, just as a clarification though, this would imply a much more complex algorithm and I initially thought it was out of the scope of the question's requirements. If ever this is your case, I may be completely wrong here, but I truly think a C++ implementation seems more appropriate. have a look at the CD-Hit algorithm suggested by @Chris_Rands in the comment section.
You could use groupby() and max() to help here:This would display:groupby() works by returning a list of matching items based on a function, in this case consecutive lines with the same first 2 characters. The max() function then takes this list and returns the list item with the longest length.
Output:['ABCDEFGHIJKLMNO', 'CEST', 'DBTSFDEO', 'EOEUDNBNUW', 'EAEUDNBNUW',  'FGH']
Output
You can use a binary tree whose insertion process attempts to find nodes that precede the value:Output:
This will get you where you want to be:I've added set just in case of multiple occurrences of same text.
A simple way is to process the input file one line at a time, compare each line with the previous one and keep previous one if it is not contained in current one.Code can be as simple as:
Not an exact match with your expectations, but, given that you state it's sorted (and it's not, near EOEUDNBNUWD EAEUDNBNUW) and that I don't know why you're missing EOEUDNBNUWD I am not sure if your expectations are correctly stated or if I've misread your question.(ah, yes, I see the notion of overlap throws a wrench into the sort and startswith approach).Might be nice for the OP to restate that particular aspect, I read @DSM comment without really understanding his concern.  Now I do.output:
Kenny,You almost got it, but there are two problems which @scharette pointed out:for loop and removing of list item should not go together. The fix is to use the while loop and explicitly increase the index. The while loop is less efficient because it calls len() several times instead once, but that's what it take to get the correct result.The IndexError. This only happens at the very last line. My way to deal with this problem is to ignore the error.With that, I modified your code to:
CodeOutputDetailsWe use read_file to yield each line of the file.find_longest_sequences builds a defaultdict that groups similar sequences together.  It iterates the data with two loops:  The first loop builds a dict of empty lists with unique sequences as keys.  The second loop appends as values any strings that are similar to the key.  A set of the values is made of the resulting dict, and the longest sequences are returned.Note some discrepancies with your expected output:FGH overlaps with ABCDEFGHIJKLMNO and is thus not a valid output.FEOEUDNBNUWD is not an original sequence.  Post-processing is needed for overlapping sequences.
As stated in other answers, your error comes from calculating the length of your input at the start and then not updating it as you shorten the list.Here's another take at a working solution:


Answer URL
https://docs.python.org/3/library/itertools.html?highlight=groupby#itertools.groupby
