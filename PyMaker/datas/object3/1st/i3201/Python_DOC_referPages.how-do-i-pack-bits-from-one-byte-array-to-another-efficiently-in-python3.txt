Natural Text
I have a fairly large byte array in python. In the simplest situation the byte array only contains 0 or 1 values (0x00, 0x01), also the array is always a multiple of 8 in length. How can I pack these "bits" into another byte array (it doesn't need to be mutable) so the source index zero goes to the MSB of the first output byte etc.For example if src = bytearray([1,0,0,0,1,0,0,1, 1,1,1,0,0,0,1,0, 1,1,1,1,1,1,1,1])Desired output would be b'\x89\xe2\xff'.I could do it with a for loop and bit shifting and or-ing and concatenation, but there surely is a faster/better built-in way to do this.In a follow up question, I also might want to have the source byte array contain values from the set 0-3 and pack these 4 at a time into the output array. Is there a way of doing that?In general is there a way of interpreting elements of a list as true or false and packing them 8 at a time into a byte array?
As ridiculous as it may sound, the fastest solution using builtins may be to build a string and pass it to int, much as the fastest way to count 1-bits in an int is bin(n).count('1'). And it's dead simple, too:Equivalent (but marginally more complex) code using gmpy2 instead of native Python int is a bit faster.And you can extend it to 2-bit values pretty easily:If you want something more flexible, but possibly slower, here's a simple solution using ctypes.If you know C, you can probably see a struct of 8 single-bit bit-fields would come in handy here. And you can write the equivalent struct type in Python like this:And you can construct one of them from 8 ints that are all 0 or 1:And you can convert that to a single int by using an ugly cast or a simple union:So now it's just a matter of chunking src into groups of 8 in big-endian order:And it should be pretty obvious how to extend this to four 2-bit fields, or two 4-bit fields, or even two 3-bit fields and a 2-bit field, per byte.However, despite looking like low-level C code, it's probably slower. Still, it might be worth testing to see if it's fast enough for your uses.A custom C extension can probably do better. And there are a number of bit-array-type modules on PyPI to try out. But if you want to go down that road, numpy is the obvious answer. You can't get any simpler than this:(A bytearray works just fine as an "array-like".)It's also hard to beat for speed.For comparison, here's some measurements:60ns/byte + 0.3µs: np.packbits on an array instead of a bytearray60ns/byte + 1.9µs: np.packbits440ns/byte + 3.2µs: for and bit-twiddling in PyPy instead of CPython570µs/byte + 3.8µs: int(…, 2).to_bytes(…) in PyPy instead of CPython610ns/byte + 9.1µs: bitarray800ns/byte + 2.9µs: gmpy.mpz(…)…1.0µs/byte + 2.8µs: int(…, 2).to_bytes(…)2.9µs/byte + 0.2µs: (UBits(Bits(*chunk)) …)16.µs/byte + 0.9µs: for and bit-twiddling
Using numpy, with test code and comments:Similar code exists for other deinterleaving, bit since the number of bits between inputs is less than the number of bytes in a word, we can avoid the masking here (note that the 0ABCDEFG does not overlap the ABCDEFGH).


Answer URL
https://docs.python.org/3/library/ctypes.html
