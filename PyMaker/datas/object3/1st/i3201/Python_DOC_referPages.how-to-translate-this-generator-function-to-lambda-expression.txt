Natural Text
I was trying to initiate a new list which every index's value is previous accumulation, according to args nums(type list), using list comprehension.the final result would look like[i for i in f(nums)]Is there ways to translate the function to lambda expression? or any other ones to make it one-line?
I would propose the following as a replacement for that:That is a generator, so a O(n^2) operation is not being performed for elements not yet needed.Then to get the elements, use next:And if you do want them all at once, just use list on the generator:The performance of this function on non trivial lists is HORRIBLE because it has O(n^2) complexity. Only use it as a curiosity. See timings below. And (thanks to AChampion) another reduce:But the right answer is itertools.accumulate or your your original function. Any one line solution will have far greater computational complexity.Here is a set of timings to show that other than itertools.accumulate, the single line replacements have O(n^2) type complexity (ie, 10x more items, 100x more time roughly). That is because for each element in the list, because lambdas or reduce or comprehensions do not have any form of accumulator, the entire list up to that point must be looped over again. Your original function and itertools.accumulate are both O(n) type complexity (ie, 10x more items, a linear 10x more time).Here is a graph and cheatsheet of O Complexity.Here is the timing and results:Results:
This is one way to do it:Output:Another way is to use itertools.accumulate as suggested by @Blckknght.Output:
If the list is continuously.A simple but not efficient way:[sum(range(1, i+1)) for i in range(1, 5))]Output:[1, 3, 6, 10]


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.accumulate
https://docs.python.org/3/library/itertools.html#itertools.accumulate
