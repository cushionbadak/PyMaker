Natural Text
Let's say I have two python lists like so:[30, 400, 500][55, 396, 478]I want to find the sum of minimum (absolute value of the) difference between the elements. In this case it would be easy: (55-30) + (400-396) + (500-478) = 51But how would I go about doing this efficiently when the lists don't have an equal number of elements. For example:Set 1: list1 = [30, 400, 500]list2 = [412, 489]or even if it was Set 2list1 = [30, 400, 500]list2 = [24, 563]lastly, Set 3list1 = [30, 50]list2 = [20, 31, 90]For Set 1, the answer would be (412-400) + (500-489) = 23For Set 2, the answer would be (30-24) + (563-500) = 69For Set 3, the answer would be (30-20) + (50-31) =29I can't compare by element. In set 1, the sum of the minimum difference is achieved by comparing the second element of list1 to the first element of list2, and the third element of list1 to the second element of list2. In set 2, the sum of the minimum difference is achieved by comparing the first element of list1 to the first element of list2, and the third element of list1 to the second element of list2. Any help is appreciated.Some other info:The lists will never be more than 2 times longer than the other, but there is no bound on whether list1 is the bigger list or if list2 is the bigger list.The lists will be in sorted orderAll elements in the shorter list have to be used at least once
In order to be sure to get the right answer I would use a bipartite weighted matching, where the abs-diff between each pair are the weights. This will avoid all the pitfalls from sorting based approaches, such as where most intuitve algorithms would pair 30 with 31. (giving sum 41)Here is a solution using scipy's linear_sum_assignment:This should always give the right result.
you could use the bisect module:results in [12, 11] (which is [412-400, 500-489])If you use list2 = [24, 563] then you get [6, 63] (which is [30-24, 563-500])
One way to do this problem is to choose the smaller list first. Take numbers one by one from smaller list and search for the minimum absolute difference (keep track of index as well) and once you found the minimum absolute difference add it to your final sum and delete that element from bigger list so you won't consider that again. This solution is O(NM). Assuming list size constraint are N, M for list1 and list2 respectively. You can optimise the solution to O(NLogN + NLogM) it by sorting the bigger list in O(NLogN) and using binary search to find the minimum absolute difference.
Okay before jumping into coding this is how I would reason about the problem:1. Simply calculate all the possible values. 2. Just take out the minimum I don't think anything more complex will be more efficient because, eventually, you still have to test all the combinations to have full certainty.With this in mind I will do:At this stage we need a function to be able to split a single list into a list of lists where each child list (that is item) has the length given by the number specified. They also cannot contain the same item (from the split list) twice. Enter itertools. To get all the sums of differences for each mix we find all the combinations; partition them in twos; then for each combination sum the absolute values of the difference of the items in each partition... 
Use sorted and zip.If you need to still use the "hanging" values in the list you can use zip_longest with fillvalue being the default value to pair the hanging values. Then with sorted, you can add reverse=True to change list to descending order.EditWith the added info, removing reverse=True pretty much does it.
If i've understood this correctly, I believe the following should work:A mistake was pointed out in the comments, here is the revised version.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.zip_longest
