Natural Text
I have an own class derived from BaseHTTPRequestHandler, which implements my specific GET method. This works quite fine:But why do I need to pass my class MyHTTPRequestHandler to the HTTPServer? I know that it is required by documentation:class http.server.BaseHTTPRequestHandler(request, client_address, server)This class is used to handle the HTTP requests that arrive at the server. By itself, it cannot respond to any actual HTTP requests; it  must be subclassed to handle each request method (e.g. GET or POST).  BaseHTTPRequestHandler provides a number of class and instance  variables, and methods for use by subclasses.The handler will parse the request and the headers, then call a method specific to the request type. The method name is constructed  from the request. For example, for the request method SPAM, the  do_SPAM() method will be called with no arguments. All of the relevant  information is stored in instance variables of the handler. Subclasses  should not need to override or extend the init() method.But I do want to pass an instantiated object of my subclass instead. I don't understand why this has been designed like that and it looks like design failure to me. The purpose of object oriented programming with polymorphy is that I can subclass to implement a specific behavior with the same interfaces, so this seems to me as an unnecessary restriction.That is what I want:But if I do that, evidently I receive the expected error message:TypeError: 'MyHTTPRequestHandler' object is not callableHow can I workaround this so that I can still use print a specific string?There is also a 2nd reason why I need this: I want that MyHTTPRequestHandler provides also more information about the client, which uses the GET method to retrieve data from the server (I want to retrieve the HTTP-Header of the client browser).I just have one client which starts a single request to the server. If a solution would work in a more general context, I'll be happy, but I won'tneed it for my current project.Somebody any idea to do that?
A server needs to create request handlers as needed to handle all the requests coming in. It would be bad design to only have one request handler.  If you passed in an instance, the server could only ever handle one request at a time and if there were any side effects, it would go very very badly.  Any sort of change of state is beyond the scope of what a request handler should do.  BaseHTTPRequestHandler has a method to handle message logging, and an attribute self.headers containing all the header information.  It defaults to logging messages to sys.stderr, so you could do $ python -m my_server.py 2> log_file.txt to capture the log messages. or, you could write to file in your own handler.
It is possible to derive a specific HTTPServer class (MyHttpServer), which has the following attributes:myArg: the specific "message text" which shall be printed by the HTTPrequest handler headers: a dictionary storing the headers set by aHTTP request handlerThe server class must be packed together with MyHTTPRequestHandler. Furthermore the implementation is only working properly under the following conditions:only one HTTP request handler requests an answer from the server at the same time (otherwise data kept by the attributes are corrupted)MyHTTPRequestHandler is only used with MyHttpServer and vice versa (otherwise unknown side effects like exceptions or data corruption can occur)That's why both classes must be packed and shipped together in a way like this:The usage of these classes could look like this, whereas only one request of a client (i.e. Web-Browser) is answered by the server:


Answer URL
https://docs.python.org/3/library/http.server.html
