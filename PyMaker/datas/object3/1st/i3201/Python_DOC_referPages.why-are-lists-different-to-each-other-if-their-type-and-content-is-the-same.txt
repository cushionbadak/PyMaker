Natural Text
The is operator does not match the values of the variables, but the  instances themselves.What does it really mean?I declared two variables named x and y assigning the same values in both variables, but it returns false when I use the is operator.I need a clarification. Here is my code.
You misunderstood what the is operator tests. It tests if two variables point the same object, not if two variables have the same value.From the documentation for the is operator:The operators is and is not test for object identity: x is y is true if and only if x and y are the same object.Use the == operator instead:This prints True. x and y are two separate lists:If you use the id() function you'll see that x and y have different identifiers:but if you were to assign y to x then both point to the same object:and is shows both are the same object, it returns True.Remember that in Python, names are just labels referencing values; you can have multiple names point to the same object. is tells you if two names point to one and the same object. == tells you if two names refer to objects that have the same value.
Another duplicate was asking why two equal strings are generally not identical, which isn't really answered here:So, why aren't they the same string? Especially given this:Let's put off the second part for a bit. How could the first one be true?The interpreter would have to have an "interning table", a table mapping string values to string objects, so every time you try to create a new string with the contents 'abc', you get back the same object. Wikipedia has a more detailed discussion on how interning works.And Python has a string interning table; you can manually intern strings with the sys.intern method.In fact, Python is allowed to automatically intern any immutable types, but not required to do so. Different implementations will intern different values.CPython (the implementation you're using if you don't know which implementation you're using) auto-interns small integers and some special singletons like False, but not strings (or large integers, or small tuples, or anything else). You can see this pretty easily:OK, but why were z and w identical?That's not the interpreter automatically interning, that's the compiler folding values.If the same compile-time string appears twice in the same module (what exactly this means is hard to define—it's not the same thing as a string literal, because r'abc', 'abc', and 'a' 'b' 'c' are all different literals but the same string—but easy to understand intuitively), the compiler will only create one instance of the string, with two references.In fact, the compiler can go even farther: 'ab' + 'c' can be converted to 'abc' by the optimizer, in which case it can be folded together with an 'abc' constant in the same module.Again, this is something Python is allowed but not required to do. But in this case, CPython always folds small strings (and also, e.g., small tuples). (Although the interactive interpreter's statement-by-statement compiler doesn't run the same optimization as the module-at-a-time compiler, so you won't see exactly the same results interactively.)So, what should you do about this as a programmer?Well… nothing. You almost never have any reason to care if two immutable values are identical. If you want to know when you can use a is b instead of a == b, you're asking the wrong question. Just always use a == b except in two cases:For more readable comparisons to the singleton values like x is None.For mutable values, when you need to know whether mutating x will affect the y.
is only returns true if they're actually the same object. If they were the same, a change to one would also show up in the other. Here's an example of the difference.
Prompted by a duplicate question, this analogy might work:
is and is not are the two identity operators in Python. is operator does not compare the values of the variables, but compares the identities of the variables. Consider this:The above example shows you that the identity (can also be the memory address in Cpython) is different for both a and b (even though their values are the same). That is why when you say a is b it returns false due to the mismatch in the identities of both the operands. However when you say a == b, it returns true because the == operation only verifies if both the operands have the same value assigned to them.Interesting example (for the extra grade):In the above example, even though a and b are two different variables, a is b returned True. This is because the type of a is int which is an immutable object. So python (I guess to save memory) allocated the same object to b when it was created with the same value. So in this case, the identities of the variables matched and a is b turned out to be True.This will apply for all immutable objects:Hope that helps.
As you can check here to a small integers. Numbers above 257 are not an small ints, so it is calculated as a different object.It is better to use == instead in this case.Further information is here: http://docs.python.org/2/c-api/int.html
x is y is same as id(x) == id(y), comparing identity of objects.  As @tomasz-kurgan pointed out in the comment below is operator behaves unusually with certain objects.  E.g.Ref;https://docs.python.org/2/reference/expressions.html#is-nothttps://docs.python.org/2/reference/expressions.html#id24
X points to an array, Y points to a different array. Those arrays are identical, but the is operator will look at those pointers, which are not identical.
It compares object identity, that is, whether the variables refer to the same object in memory. It's like the == in Java or C (when comparing pointers).
A simple example with fruits   Output:If you try The output is different:That's because the == operator compares just the content of the variable. To compare the identities of 2 variable use the is operator To print the identification number: 


Answer URL
https://docs.python.org/3/library/sys.html#sys.intern
