Natural Text
I would like to have my print output length limited to X characters. I've been looking for some info and I found the command textwrap.fill which makes just what I was looking for by using something like: However, I was wondering if there is a way to apply this length limitation to every print without having to write it (I do have plenty of them) by creating or setting a class or something at the very beginning of the script.
Monkeypatching print is doable, but it's not a good idea. For one thing, what do you want to happen if someone does a print(spam, eggs)? Or print(spam, end='')? Or print(spam, file=outfile)?A better solution is probably replacing sys.stdout with a wrapper. The normal sys.stdout is a plain old text file object, a TextIOWrapper just like the ones you get from open, except that when you write to it, it goes to the console instead of to a file on disk.And you're allowed to replace it with anything else that meets the TextIOBase protocol.And writing a TextIOBase is really simple. All you really need to implement is write and/or read and readline (depending on whether you're wrapping output, input, or both), and all our wrapper needs to do in write is to buffer up lines, fill them, and pass them to the real file object underneath.Like this:Technically, I think I may be cheating in a few ways here:The docs say the ABC TextIOBase wants detach, read, and readline, even if they don't make sense here. But the ABC doesn't seem to enforce them as abstract methods, so I didn't bother.I think it's legal (and it works) to leave encoding and errors set to None, since we're just passing through to another TextIOBase and expecting it to do the encoding, but I can't find anything that says it's legal. And if some code were to test sys.stdout.encoding to see if it's UTF-8 or something, that might be trouble.Similarly for newlines. And, since I haven't tested on Windows, I can't be as sure that it works.Also, forwarding other methods to self.file might be a good idea, like fileno() and isatty(). But I'd worry that any app that wants to access stdout as a TTY probably need to know about the Filler that we stuck in front of it, not just transparently go through it.This is of course all Python 3-specific. In Python 2:sys.stdout is a file, not a TextIOWrapper. The API you need to wrap is a bit different, and not nearly as well defined. Unless you __future__ up the 3.x-style print function, print is a statement, so you can't monkeypatch it. (I mean, you could write an import hook that bytecode-hacks out every PRINT_* bytecode, or maybe even inject a .so that replaces PyObject_Printâ€¦ but who cares anyway? It's Python 2.)


Answer URL
https://docs.python.org/3/library/functions.html#print
https://docs.python.org/3/library/sys.html#sys.stdout
https://docs.python.org/3/library/io.html#io.TextIOWrapper
https://docs.python.org/3/library/io.html#io.TextIOBase
