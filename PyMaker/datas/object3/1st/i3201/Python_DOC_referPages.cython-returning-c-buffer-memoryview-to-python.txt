Natural Text
I have following Cython code with one C buffer defined (c_buffer):I'm using this class to store elements that eventually go to OpenGL VBO buffer. What I'm trying to do is avoid unnecessary copies of memory.When I call get_array() I get result of type with get_memoryview() the result is:What's the difference between them (in functionality/speed)? I'm reading official document in about Typed Memoryviews, but it focuses mainly on numpy. Am I returning the memoryviews here correctly?Now the buffer is fixed (max 1000 elements). Does in Cython exist dynamic array that I could use and it automatically handles memory for me (for adding/removing elements at runtime) and having continuous memory layout (that I could eventually supply to OpenGL VBO)? Or should I use from libcpp.vector cimport vector?
That is a quite complicated question! There are some aspects that need to be considered.The speed:Let's start with a simple int-buffer (I've skipped the unnecessary &c_buffer[0]-business):"Typed memory view" is somewhat opaque in Cython, there are some classes which are very similar and are returned from the function depending on the signature of the function:arraymemoryviewmemoryviewsliceThere is also a helper struct __Pyx_memviewslice, which is not returned by used in function.However, none of these above is the memoryview you are returning in your second-function: it returns Python's memoryview.Quite confusing! Personally, I keep it simple and trust Cython to return the best suitable class - to me it just a buffer. When we measure the speed, the first version will be faster, because wrapping array_obj into a Python's memoryview just adds complexity:The lifetime:The memory from c_buffer isn't copied:Which sounds like a Good Thing, but isn't!  The problem: c_buffer isn't a Python-object and when it goes out of scope, the data-pointer of the memory-view becomes dangling:I got lucky, the python didn't crash but it could, because after binding c to the memoryview, the underlying object is destroyed and the memory freed.Using std::vector will not help you there. What you need is a real Python-object with reference counting! For example we could use Cython's array for that:Now the code from above is safe:Custom structs:But what about customs structs, as in your example above? The probably easiest way is to use numpy:Which works as advertised:Two more remarks:using numpy is slower - get_array() is three times slower than the original get_array() versionusing my_struct_t c_buffer would not really help you there (beside being dangerous), because there would be no rule how to translate the data from c-struct to an python object, but this check happens at run time, when the elements of the array are acccessed.


Answer URL
https://docs.python.org/3/library/stdtypes.html#memoryview
