Natural Text
I'm building a photo gallery in Python and want to be able to quickly generate thumbnails for the high resolution images.What's the fastest way to generate high quality thumbnails for a variety of image sources?Should I be using an external library like imagemagick, or is there an efficient internal way to do this?The dimensions of the resized images will be (max size):Quality is an issue, as I want to preserve as many of the original colors as possible and minimize compression artifacts.Thanks.
You want PIL it does this with easeIf you desperately need speed. Then thread it, multiprocess it or get another language.
A little late to the question (only a year!), but I'll piggy backing on the "multiprocess it" part of @JakobBowyer's answer. This is a good example of an embarrassingly parallel problem, as the main bit of code doesn't mutate any state external to itself. It simply reads an input, performs its computation and saves the result.Python is actually pretty good at these kinds of problems thanks to the map function provided by multiprocessing.Pool. The core of the code is exactly the same as @JakobBowyer, but instead of running it in a loop in a single thread, we wrapped it in a function spread it out across multiple cores via the multiprocessing map function. 
I fancied some fun so I did some benchmarking on the various methods suggested above and a few ideas of my own.I collected together 1000 high resolution 12MP iPhone 6s images, each 4032x3024 pixels and use an 8-core iMac.Here are the techniques and results - each in its own section.Method 1 - Sequential ImageMagickThis is simplistic, unoptimised code. Each image is read and thumbnail is produced. Then it is read again and a different sized thumbnail is produced.Result: 170 secondsMethod 2 - Sequential ImageMagick with single load and successive resizingThis is still sequential but slightly smarter. Each image is only read one time and the loaded image is then resized down three and saved at three resolutions. The improvement is that each image is read just once, not 3 times.Result: 76 secondsMethod 3 - GNU Parallel + ImageMagickThis builds on the previous method, by using GNU Parallel to process N images in parallel, where N is the number of CPU cores on your machine.Result: 18 secondsMethod 4 - GNU Parallel + vipsThis is the same as the previous method, but it uses vips at the command-line instead of ImageMagick.Result: 8 secondsMethod 5 - Sequential PILThis is intended to correspond to Jakob's answer.Result: 38 secondsMethod 6 - Sequential PIL with single load & successive resizeThis is intended as an improvement to Jakob's answer, wherein the image is loaded just once and then resized down three times instead of re-loading each time to produce each new resolution.Result: 27 secondsMethod 7 - Parallel PILThis is intended to correspond to Audionautics' answer, insofar as it uses Python's multiprocessing. It also obviates the need to re-load the image for each thumbnail size.Result: 6 secondsMethod 8 - Parallel OpenCVThis is intended to be an improvement on bcattle's answer, insofar as it uses OpenCV but it also obviates the need to re-load the image to generate each new resolution output.Result: 5 seconds
Another option is to use the python bindings to OpenCV. This may be faster than PIL or Imagemagick. There's a more complete walkthrough here.If you want to run it in parallel, use concurrent.futures on Py3 or the futures package on Py2.7:
If you are already familiar with imagemagick, why not stick with the python-bindings?PythonMagick
Python 2.7, Windows, x64 usersIn addition to @JakobBowyer & @Audionautics, PIL is quite old and you can find yourself troubleshooting and looking for the right version... instead, use Pillow from here (source)the updated snippet will look like this:full enumeration script for thumbnail creation:
I stumbled upon this when trying to figure out which library I should use:It seems like OpenCV is clearly faster than PIL.That said, I'm working with spreadsheets and it turns out that the module I was using openpyxl already requires me to import PIL to insert images.


Answer URL
https://docs.python.org/3/library/concurrent.futures.html
