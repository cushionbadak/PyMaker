Natural Text
I am finding that I am using plenty of context managers in Python. However, I have been testing a number of things using them, and I am often needing the following:When this gets to many tests, this is clearly going to get boring, so in the spirit of SPOT/DRY (single point of truth/dont repeat yourself), I'd want to refactor those bits into the test setUp() and tearDown() methods.However, trying to do that has lead to this ugliness:There must be a better way to do this. Ideally, in the setUp()/tearDown() without repetitive bits for each test method (I can see how repeating a decorator on each method could do it).Edit: Consider the undertest object to be internal, and the GetResource object to be a third party thing (which we aren't changing).I've renamed GetSlot to GetResource here—this is more general than specific case—where context managers are the way which the object is intended to go into a locked state and out.
How about overriding unittest.TestCase.run() as illustrated below?  This approach doesn't require calling any private methods or doing something to every method, which is what the questioner wanted.This approach also allows passing the TestCase instance to the context manager, if you want to modify the TestCase instance there.
Manipulating context managers in situations where you don't want a with statement to clean things up if all your resource acquisitions succeed is one of the use cases that contextlib.ExitStack() is designed to handle.For example (using addCleanup() rather than a custom tearDown() implementation):That's the most robust approach, since it correctly handles acquisition of multiple resources:Here, if GetOtherResource() fails, the first resource will be cleaned up immediately by the with statement, while if it succeeds, the pop_all() call will postpone the cleanup until the registered cleanup function runs.If you know you're only ever going to have one resource to manage, you can skip the with statement:However, that's a bit more error prone, since if you add more resources to the stack without first switching to the with statement based version, successfully allocated resources may not get cleaned up promptly if later resource acquisitions fail.You can also write something comparable using a custom tearDown() implementation by saving a reference to the resource stack on the test case:
The problem with calling __enter__ and __exit__ as you did, is not that you have done so: they can be called outside of a with statement. The problem is that your code has no provision to call the object's __exit__ method properly if an exception occurs. So, the way to do it is to have a decorator that will wrap the call to your original method in a withstatement. A short metaclass can apply the decorator transparently to all methods named test* in the class -(I also included mock implementations of "GetSlot" and the methods and functions in your example so that I myself could test the decorator and metaclass I am suggesting on this answer)
pytest fixtures are very close to your idea/style, and allow for exactly what you want:
I'd argue you should separate your test of the context manager from your test of the Slot class. You could even use a mock object simulating the initialize/finalize interface of slot to test the context manager object, and then test your slot object separately.This makes code simpler, prevents concern mixing and allows you to reuse the context manager without having to code it in many places.


Answer URL
https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack
https://docs.python.org/3/library/unittest.html#unittest.TestCase.addCleanup
