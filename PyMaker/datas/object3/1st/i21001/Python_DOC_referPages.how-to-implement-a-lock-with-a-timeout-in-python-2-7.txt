Natural Text
Is there a way to implement a lock in Python for multithreading purposes whose acquire method can have an arbitrary timeout? The only working solutions I found so far use polling, whichI find inelegant and inefficientDoesn't preserve the bounded waiting / progress guarantee of the lock as a solution to the critical section problemIs there a better way to implement this?
to elaborate on Steven's comment suggestion:Things to notice:there are two threading.Lock() objects, one is internal to the threading.Condition().  when manipulating cond, it's lock is acquired; the wait() operation unlocks it, though, so any number of threads can watch it.the wait is embedded inside a for loop that keeps track of the time.  threading.Condition can become notified for reasons other than timeouts, so you still need to track the time if you really want it to expire.even with the condition, you still 'poll' the real lock, because its possible for more than one thread to wake and race for the lock.  if the lock.acquire fails, the loop returns to waiting.callers of this waitLock function should follow a lock.release() with a cond.notify() so that other threads waiting on it are notified that they should retry aquiring the lock.  This is not shown in the example.
My version using thread safe queues http://docs.python.org/2/library/queue.html and their put/get methods that supports timeout.Until now is working fine, but if someone can do a peer review on it I'll be grateful.
I'm doubtful that this can be done.If you want to implement this without any sort of polling, then you need the OS to know that the thread is blocked, and the OS needs to be aware of the timeout, in order to unblock the thread after a while. For that, support needs to already exist in the OS; you can't implement this at the Python level.(You could have the thread blocked at either OS-level or app-level, and have a mechanism whereby it can be woken up by a different thread at the appropriate time, but then you need that other thread to be effectively polling)In general you don't have a truly bounded waiting/progress guarantee of the lock anyway, as your thread will have to wait an unbounded time for a context switch to take place for it to notice that it's been unblocked. So unless you can put an upper bound on the amount of CPU contention going on, you're not going to be able to use the timeout to hit any hard real-time deadlines. But you probably don't need that, otherwise you wouldn't dream of using locks implemented in Python.Due to the Python GIL (Global Interpreter Lock), those polling-based solutions probably aren't as inefficient or as badly unbounded as you think (depending on how they're implemented) (and assuming you're using either CPython or PyPy).There's only ever one thread running at a time, and by definition there's another thread that you want to run (the one that holds the lock you're waiting for). The GIL is held for a while by one thread to execute a bunch of bytecodes, then dropped and reacquired to give someone else a chance at it. So if the blocked-with-timeout thread is just in a loop checking the time and yielding to other threads, it will only wake up every so often when it gets the GIL and then almost immediately drop it back to someone else and block on the GIL again. Because this thread could only ever wake up when it gets a turn at the GIL anyway, it will also do this check as soon after the timeout expires as it would be able to resume execution even if the timeout was magically perfect.The only time this will cause a lot of inefficiency is if your thread is blocked waiting for the lock-holding thread, which is blocked waiting for something that can't be caused by another Python thread (say, blocked on IO), and there are no other runnable Python threads. Then your polling timeout really will just sit there checking the time repeatedly, which could be bad if you expect this situation to happen for long periods of time.
If somebody needs Python >= 3.2 API:
I took SingleNegationElimination's answer and created a class with can be used in a with-statement the following way:This way it will only warn if the timeout expired (default=1s) and show the owner of the lock for investigation. Use it this way and an exception will be thrown after the timeout:The timeout_lock.lock() instance has to be created once and can be used across threads.Here is the class - it works for me but feel free to comment and improve:To be sure the threads really don't interfere and don't wait get notified as soon as possible I wrote a small multithreading test which will sum up the time needed to run all threads:Output is:
Okay, this is already implemented in python 3.2 or above:      https://docs.python.org/3/library/threading.htmlLook for threading.TIMEOUT_MAXBut I improved on the test case over frans' version ... though this is already a waste of time if you're on py3.2 or above:Now under "Util" folder, I have "ThreadingUtil.py":


Answer URL
https://docs.python.org/3/library/threading.html
