Natural Text
I'm implementing a program that needs to serialize and deserialize large objects, so I was making some tests with pickle, cPickle and marshal modules to choose the best module. Along the way I found something very interesting:I'm using dumps and then loads (for each module) on a list of dicts, tuples, ints, float and strings.This is the output of my benchmark:So, from these results we can see that marshal was extremely fast in the dumping part of the benchmark:14.8x times faster than pickle and 2.6x times faster than cPickle.But, for my big surprise, marshal was by far slower than cPickle in the loading part:2.2x times faster than pickle, but 3.1x times slower than cPickle.And as for RAM, marshal performance while loading was also very inefficient:I'm guessing the reason why loading with marshal is so slow is somehow related with the length of the its serialized string (much longer than pickle and cPickle).Why marshal dumps faster and loads slower?Why marshal serialized string is so long?Why marshal's loading is so inefficient in RAM?Is there a way to improve marshal's loading performance?Is there a way to merge marshal fast dumping with cPickle fast loading?
cPickle has a smarter algorithm than marshal and is able to do tricks to reduce the space used  by large objects. That means it'll be slower to decode but faster to encode as the resulting output is smaller.marshal is simplistic and serializes the object straight as-is without doing any further analyze it. That also answers why the marshal loading is so inefficient, it simply has to do more work - as in reading more data from disk - to be able to do the same thing as cPickle.marshal and cPickle are really different things in the end, you can't really get both fast saving and fast loading since fast saving implies analyzing the data structures less which implies saving a lot of data to disk.  Regarding the fact that marshal might be incompatible to other versions of Python, you should generally use cPickle:"This is not a general “persistence” module. For general persistence and transfer of Python objects through RPC calls, see the modules pickle and shelve. The marshal module exists mainly to support reading and writing the “pseudo-compiled” code for Python modules of .pyc files. Therefore, the Python maintainers reserve the right to modify the marshal format in backward incompatible ways should the need arise. If you’re serializing and de-serializing Python objects, use the pickle module instead – the performance is comparable, version independence is guaranteed, and pickle supports a substantially wider range of objects than marshal." (the python docs about marshal)
Some people might think this too much of a hack, but I've had great success by simply wrapping the pickle dump calls with gc.disable() and gc.enable().  For example, the the snips below writing a ~50MB list of dictionaries goes from 78 seconds to 4.
The difference between these benchmarks gives one idea for speeding up cPickle:In the first case, the list repeats the same string. The second list is equivalent, but each string is a separate object, because it is the result of an expression. Now, if you are originally reading your data in from an external source, you could consider some kind of string deduplication.
You can make cPickle cca. 50x (!) faster by creating instance of cPickle.Pickler and then setting undocumented option 'fast' to 1:But if your myHugeObject has cyclic references, the dump method will never end.
As you can see, the output produced by cPickle.dump has about 1/4 of the length of the output produced by marshal.dump. This means that cPickle must use a more complicated algorithm to dump the data as unneeded things are removed. When loading the dumped list, marshal has to work through much more data while cPickle can process its data quickly as there is less data that has to be analysed.Regarding the fact that marshal might be incompatible to other versions of Python, you should generally use cPickle:"This is not a general “persistence” module. For general persistence and transfer of Python objects through RPC calls, see the modules pickle and shelve. The marshal module exists mainly to support reading and writing the “pseudo-compiled” code for Python modules of .pyc files. Therefore, the Python maintainers reserve the right to modify the marshal format in backward incompatible ways should the need arise. If you’re serializing and de-serializing Python objects, use the pickle module instead – the performance is comparable, version independence is guaranteed, and pickle supports a substantially wider range of objects than marshal." (the python docs about marshal)
You could improve the storage efficiency by compressing the serialize result.My hunch are that compressing data and feeding it into the unserialize would be faster than reading raw from disk via HDD.Test below was made to prove that compression would speed up the unserialize process.The result wasn't as expect since the machine were equip with SSD.On HHD equip machine compressing the data using lz4 would be faster since reading from disk average between 60-70mb/s.LZ4: At a speed reduction of 18%, the compression yield 77.6% of additional storage.


Answer URL
