Natural Text
The following code prints 123:But the following fails:I would have expected this to print:What am I missing here?P.S. I'm using Python 2.6.6 if that matters.
If a function only reads from a variable, it's assumed to be global. If the function writes to  it ever, it's assumed to be local. In your second function, a is written to, so it's assumed to be local. Then the line above (where it's read from) isn't valid.Here's a link to the Python FAQ: http://docs.python.org/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python
What you are using is named a closure: you take a variable from the outter scope and enclose in a function block.Your code is perfectly alright, and would work in javascript.Unfortunatly, in Python, closures are read-only.And the error is always UnboundLocalError: local variable 'var_name' referenced before assignment which is completly misleading.En short, this is not you, it's a language limitation combined a bad error message.EDIT:I can see several persons here advocating the use of global, which has dangerous side effects: you would get access to variables with the same name several scopes above the current one, which is not what you want with closures.The solution has been added in Python 3, with the nonlocal keyword which does exactly that: rebind a variable from the outer scope in the inner scope.There is a way to simulate nonlocal for python 2.x, but really you are better off just just not assign anything to your variable: copy values, return values, modify in place only mutable types and you will be fine.
That's becouse Python automatically acts like the variable is global unless you define or try to modify it in function. Try adding global a to your code.In the first example you did not define and did not modify, so it was a global one. But if you would like to, for example, add 20 to a, you also have to use global a.Also be aware, that the a in f function is a global and it's value will differ after the run of f function.If you want to create a local variable, then remember, that declaration always go before the reading, so print a can not be done before a = 456.EDIT:Ok, while we're talking about closures and dangerous of using global there's other possibility.Here we use a closure read-only ability to make a copy of a and than modify this copy, without modifing the outside a variable AS LONG AS IT'S INTEGER. Remember, that b keeps a reference to a. If a is, for example, a list and the f operation is like b.append(3), then both a and b will be available and modified outside the scope.The choice of method is different due to needs.
The comment space is too small to fit the quotes below, so I post a new answer here.I think this is variable scope problem. In the Execution Model of Python doc it says:If a name binding operation occurs anywhere within a code block, all  uses of the name within the block are treated as references to the  current block. This can lead to errors when a name is used within a  block before it is bound. This rule is subtle. Python lacks  declarations and allows name binding operations to occur anywhere  within a code block. The local variables of a code block can be  determined by scanning the entire text of the block for name binding  operations.


Answer URL
