Natural Text
I usually use the following pattern (as mentioned in this question):I think it's a great way to write easily readable code.Sometimes it's useful to "chain" string formats, in order to "modularize" the creation of complex strings:Pretty soon, the code is pestered with X.format(**locals()). To solve this problem, I tried to create a lambda:but this throws a KeyError, since locals() are the lambda's locals.I also tried to apply the format only on the last string:But this doesn't work, since python only formats once.Now, I could write a function that formats repeatedly until there's nothing more to do:but I'm wondering: is there a better way to do this?
f = lambda x, l=locals(): x.format(**l) appears to work... and if you wanted a version that is a little more all-encompassing (and probably a lot slower):will find the symbols in either locals or globals. 
If you only need to do this within the function scope as a local shortcut, the following will work:However, this will bind the value returned by locals() at the time of function declaration, rather than execution, so it will not be updated as values change, nor will it be useful when called from any other scope.If you want to get access to the calling method's locals, you need to inspect the call stack (http://docs.python.org/2/library/inspect.html)Note that this may not work for implementations of python that are not CPython.Now you can do:
Starting with Python 3.6 the effect of **locals() is already included in string#format or rather "formatted string literals".See also PEP 498and Python 3.6 release notes.
It's not a one-liner, but it works:Here's a one line (and slightly less efficient) recursive version:


Answer URL
https://docs.python.org/3/whatsnew/3.6.html#whatsnew36-pep498
