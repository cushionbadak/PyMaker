Natural Text
So, the program works just fine, but even after incorporating that last modification suggested by abarnert, it still won't make sure to generate a unique mutation. This is what I've got so far. I'm sure it's not right, but I don't fully understand how python executes the code written by abarnert below. I have also tried to write this your way without using range, although I like using the range function so that I can print out 10 or 100 codons and manually check if the output is correct, but then I get a Keyerror: 'r', which didn't occur before when i ran this program before trying to make sure that each substitution is unique: 
The function random.choice picks a random element from a sequence. So:To pick a letter from a given codon, you really want to pick an index at random—0, 1, or 2. (After all, for the codon 'AAA', you presumably want to be able to replace any of the three 'A' characters, right?) For that, use random.randrange(3):Except that if each codon is a string, of course, you can't mutate it in-place, so you need a function like this:What we're doing here is building a new string out of slices: s[:index] is all of the characters from the start to the indexth (remember that Python slicing is half-open: s[i:j] includes i, i+1, …, j-1, but not j), and s[index+1] is all of the characters from the index+1th to the end. So, this is everything before index, char in place of whatever was in index, and then everything after index. This is described in detail in the Strings section of the tutorial (with a bit of followup in the Lists section of the same chapter).And while you're already doing things immutably:This uses a list comprehension: instead of modifying the list of codons in-place, we build a new list of codons. List Comprehensions in the tutorial explains how these work, but a simple example may help:You can also filter the list as you build it with if clauses, nest multiple for clauses together, build a set or dict, or a lazy generator, instead of a list… see the documentation for full details.Here's how to put it all together, with a few other fixes (using a with to make sure the file gets closed, and some of the stuff I commented on the question):If you want to guarantee a single point mutation in each codon, and you don't need each one to mutate to the same base, you need to rethink things a little. For each codon, pick one of the three positions. Then, instead of picking randomly from all four bases, pick from all of the bases except the one that's already there. So:If that function line is confusing, let me explain: Sets have a nice - operator that computes the set difference—that is, all values in the left set that aren't also in the right set. {'A', 'C', 'T', 'G'} - {'T'} is {'A', 'C', 'G'}. So, I take the set of all four bases, subtract out the one that's already at codon[index], and randomly choose any of the other three. Since choice only works on sequences, I have to make a list out of the set.You could, of course, rewrite this to use a list (or even str) in the first place, but then you have to write the "list difference" manually. Not a big deal:


Answer URL
