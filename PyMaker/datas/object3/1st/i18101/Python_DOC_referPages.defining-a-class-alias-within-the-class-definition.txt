Natural Text
I'd like to be able to assign aliases to class names, and somehow define the aliases within the class body. So, for example, rather than doing this:I'd like to be able to do this:or something of the sort. My objective is to make the information about the aliases contained within the class definition so that auto-completion works in the right environments and any kind of introspection will reveal the class' aliases (so, for example, documentation can be made to include these aliases.)I'm guessing I can play games with jumping to the containing frame or whatever, but I'd just like to avoid any ugly trickery if that's possible. The question is, is this possible?
Seems like this would be a good job to handle with a metaclass:Note: In Python 3.x the syntax for specifying a metaclass is different and would need to be:
Here's yet another way to do something similar with a class decorator—but the aliases aren't specified within the class body like you wanted. It's very similar to @BrenBarn's answer, except the aliases are decorator arguments—which I think might be more desirable for some types of usage (and it seems more explicit since it makes them more conspicuous that way). 
It's a bad idea, but it can be done with an abuse of class decorators:This is an abuse because the point of decorators is to modify the object they decorate, but this one is used only for its global side-effect of assigning additional names in the global namespace that point to the same class.Use at your own risk! ;-)
Defining a python class “alias” within the class definitionI'm just responding to the above problem statement. Martineau's non-accepted answer is close to what I'd do to provide a simple alias. But maybe we don't really want an alias, maybe we really just want to take steps towards getting rid of a bad name.Naming is hard. Sometimes we wind up with names we'd like to change.I'm looking at some library code with unfortunately named classes that need deprecation. For example:A multitude of aliases is not helpful, however. Multiple names that point to the same object mean more to learn, and make your code more complex than it needs to be. The bad names need to eventually go away.I propose the following sort of change as a solution to warn and not break your users:Autocomplete will automatically know these names, and introspection (help(BadC)) will immediately reveal that you should stop using BadC.Now you can start replacing BadC with GoodC in the rest of your code.and when you or your users use BadC, they'll get their warning:And still be able to continue using it:Tests will usually show these warnings, or users can enable them, from the docsIn the ideal case, the code will have a suitable test suite, and the test runner will take care of implicitly enabling all warnings when running tests (the test runner provided by the unittest module does this).In less ideal cases, applications can be checked for use of deprecated interfaces by passing -Wd to the Python interpreter (this is shorthand for -W default) or setting PYTHONWARNINGS=default in the environment. This enables default handling for all warnings, including those that are ignored by default. To change what action is taken for encountered warnings you can change what argument is passed to -W (e.g. -W error). See the -W flag for more details on what is possible.


Answer URL
https://docs.python.org/3/library/warnings.html#updating-code-for-new-versions-of-dependencies
