Natural Text
How do I share a global variable with thread?My Python code example is:I don't know how to get the two threads to share one variable.
You just need to declare a as a global in thread2, so that you aren't modifying an a that is local to that function.In thread1, you don't need to do anything special, as long as you don't try to modify the value of a (which would create a local variable that shadows the global one; use global a if you need to)>
In a function:will be interpreted by the compiler as assign to a => Create local variable a, which is not what you want. It will probably fail with a a not initialized error since the (local) a has indeed not been initialized:You might get what you want with the (very frowned upon, and for good reasons) global keyword, like so:In general however, you should avoid using global variables which become extremely quickly out of hand. And this is especially true for multithreaded programs, where you don't have any synchronization mechanism for your thread1 to know when a has been modified. In short: threads are complicated, and you cannot expect to have an intuitive understanding of the order in which events are happening when two (or more) threads work on the same value. The language, compiler, OS, processor... can ALL play a role, and decide to modify the order of operations for speed, practicality or any other reason.The proper way for this kind of thing is to use Python sharing tools (locks and friends), or better, communicate data via a Queue instead of sharing it, e.g. like this:
A lock should be considered to use, such as threading.Lock. See lock-objects for more info.The accepted answer CAN print 10 by thread1, which is not what you want. You can run the following code to understand the bug more easily.Using a lock can forbid changing of a while reading more than one time:If thread using the variable for long time, coping it to a local variable first is a good choice.
Well, running example:WARNING! NEVER DO THIS AT HOME/WORK! Only in classroom ;) Use semaphores, shared variables, etc. to avoid rush conditions.and the output:If the timing were right, the a += 100 operation would be skipped:Processor executes at T a+100 and gets 104. But it stops, and jumps to next threadHere, At T+1 executes a+1 with old value of a, a == 4.  So it computes 5.Jump back (at T+2), thread 1, and write a=104 in memory.Now back at thread 2, time is T+3 and write a=5 in memory.Voila! The next print instruction will print 5 instead of 104. VERY nasty bug to be reproduced and caught.
Thanks so much Jason Pan for suggesting that method. The thread1 if statement is not atomic, so that while that statement executes, it's possible for thread2 to intrude on thread1, allowing non-reachable code to be reached. I've organized ideas from the prior posts into a complete demonstration program (below) that I ran with Python 2.7.With some thoughtful analysis I'm sure we could gain further insight, but for now I think it's important to demonstrate what happens when non-atomic behavior meets threading.As predicted, in running the example, the "unreachable" code sometimes is actually reached, producing output.Just to add, when I inserted a lock acquire/release pair into thread1 I found that the probability of having the "unreachable" message print was greatly reduced. To see the message I reduced the sleep time to 0.01 sec and increased NN to 1000. With a lock acquire/release pair in thread1 I didn't expect to see the message at all, but it's there. After I inserted a lock acquire/release pair also into thread2, the message no longer appeared. In hind signt, the increment statement in thread2 probably also is non-atomic.


Answer URL
https://docs.python.org/3/library/queue.html
