Natural Text
I have dt = datetime(2013,9,1,11), and I would like to get a Unix timestamp of this datetime object.When I do dt - datetime(1970,1,1)).total_seconds() I got the timestamp 1378033200.When converting it back using datetime.fromtimestamp I got datetime.datetime(2013, 9, 1, 6, 0).The hour doesn't match. What did I miss here?
What you missed here is timezones.Presumably you've five hours off UTC, so 2013-09-01T11:00:00 local and 2013-09-01T06:00:00Z are the same time.You need to read the top of the datetime docs, which explain about timezones and "naive" and "aware" objects.If your original naive datetime was UTC, the way to recover it is to use utcfromtimestamp instead of fromtimestamp.On the other hand, if your original naive datetime was local, you shouldn't have subtracted a UTC timestamp from it in the first place; use datetime.fromtimestamp(0) instead.Or, if you had an aware datetime object, you need to either use a local (aware) epoch on both sides, or explicitly convert to and from UTC.If you have, or can upgrade to, Python 3.3 or later, you can avoid all of these problems by just using the timestamp method instead of trying to figure out how to do it yourself. And even if you don't, you may want to consider borrowing its source code.(And if you can wait for Python 3.4, it looks like PEP 341 is likely to make it into the final release, which means all of the stuff J.F. Sebastian and I were talking about in the comments should be doable with just the stdlib, and working the same way on both Unix and Windows.)
solution is
Rather than this expression to create a POSIX timestamp from dt,Use this:I get the right answer in your example using the second method.EDIT: Some followup... After some comments (see below), I was curious about the lack of support or documentation for %s in strftime. Here's what I found:In the Python source for datetime and time, the string STRFTIME_FORMAT_CODES tells us:So now if we man strftime (on BSD systems such as Mac OS X), you'll find support for %s:Anyways, that's why %s works on the systems it does.  But there are better solutions to OP's problem (that take timezones into account).  See @abarnert's accepted answer here.
If you want to convert a python datetime to seconds since epoch you should do it explicitly:In Python 3.3+ you can use timestamp() instead:
If your datetime object represents UTC time, don't use time.mktime, as it assumes the tuple is in your local timezone. Instead, use calendar.timegm:
For working with UTC timezones:
Well, when converting TO unix timestamp, python is basically assuming UTC, but while converting back it will give you a date converted to your local timezone.See this question/answer;Get timezone used by datetime.datetime.fromtimestamp()
You've missed the time zone info (already answered, agreed)arrow package allows to avoid this torture with datetimes; It is already written, tested, pypi-published, cross-python (2.6 â€” 3.xx). All you need: pip install arrow (or add to dependencies)Solution for your case
If you want UTC timestamp :time.mktime just for local dt .Use calendar.timegm is safe but dt must the utc zone so change the zone to utc. If dt in UTC just use calendar.timegm.


Answer URL
https://docs.python.org/3/library/datetime.html?highlight=re#datetime.datetime.timestamp
