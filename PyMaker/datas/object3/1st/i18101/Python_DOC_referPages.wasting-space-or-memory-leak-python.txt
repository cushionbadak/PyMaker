Natural Text
I'm confused about the following situation, and perhaps my vocabulary is wrong here, so apologies.Say we have a tuple, x = ('a', []) and then we do x = (x[0], [1, 2, 3]). Since the new tuple is referencing the old tuple we can't delete the old tuple object, but since of that old tuple object we are only using the reference to x[0], we are wasting memory as x[1] of the old tuple object cannot be accessed by anything. Is this bona-fide case of memory leak; are we wasting memory just so that the new tuple object's references make sense.
You're probably coming to Python from a language like C++, where variables are memory locations that values are stored in. In Python, values are stored somewhere that you don't have to worry about, and your variables are just names that reference those values. There is no way to make a variable reference another variable*â€”you can make it reference the same value as another variable, but that's not a problem.For example, in C++:Here, x is a memory location big enough for three int values, and y is a reference to the first of those locations. So, if x goes away while y is still alive, you'd have a dangling reference, which would be bad. But in Python:Here, x is a name for a list object, whose three positions are names for three different int objects stored elsewhere, and y is just another name for the first int object. If x goes away, Python can free up the list, after which it can free up the 2 and 3 objects** (because nobody else refers to them), leaving only the 1 object behind.This is also why there are no "copy constructors"*** in Python. In C++, int z = x[0] creates a new memory location, and implicitly copies the int from x[0] into that memory location; in Python, unless you explicitly write something like z = copy.copy(x[0]), you are never copying anything.* This isn't quite true if you look at how closure cells work under the covers.** In fact, small integers are usually treated specially, and kept alive forever, but let's ignore that.*** Much less copy assignment operators, move constructors, and move assignment operators.
Here's an annotated Python session using your example to show what is and isn't currently referenced.The original tuple, object 4340112344, is no longer referenced, so it is free to be garbage collected whenever convenient without affect the new object referenced by x.
Slight logic error.Python strings are immutable. When you do this:and then this:x[0] is now a new string, i.e., not tied to the original. Therefore the GC is free to collect the original tuple.


Answer URL
