Natural Text
Is output buffering enabled by default in Python's interpreter for sys.stdout?If the answer is positive, what are all the ways to disable it?Suggestions so far:Use the -u command line switchWrap sys.stdout in an object that flushes after every writeSet PYTHONUNBUFFERED env varsys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)Is there any other way to set some global flag in sys/sys.stdout programmatically during execution?
From Magnus Lycka answer on a mailing list:You can skip buffering for a whole  python process using "python -u"   (or#!/usr/bin/env python -u etc) or by  setting the environment variable  PYTHONUNBUFFERED.You could also replace sys.stdout with  some other stream like wrapper which  does a flush after every call.
I would rather put my answer in How to flush output of Python print? or in Python's print function that flushes the buffer when it's called?, but since they were marked as duplicates of this one (what I do not agree), I'll answer it here.Since Python 3.3 print() supports the keyword argument "flush" (see documentation):
Credits: "Sebastian", somewhere on the Python mailing list.3rd Party EDITUnsupported in recent versions of Python 3
Yes, it is.You can disable it on the commandline with the "-u" switch.Alternatively, you could call .flush() on sys.stdout on every write (or wrap it with an object that does this automatically)
Without saving the old sys.stdout, disable_stdout_buffering() isn't idempotent, and multiple calls will result in an error like this:Another possibility is:(Appending to gc.garbage is not such a good idea because it's where unfreeable cycles get put, and you might want to check for those.)
This relates to  Cristóvão D. Sousa's answer, but I couldn't comment yet.A straight-forward way of using the flush keyword argument of Python 3 in order to always have unbuffered output is:afterwards, print will always flush the output directly (except flush=False is given).Note, (a) that this answers the question only partially as it doesn't redirect all the output. But I guess print is the most common way for creating output to stdout/stderr in python, so these 2 lines cover probably most of the use cases.Note (b) that it only works in the module/script where you defined it. This can be good when writing a module as it doesn't mess with the sys.stdout.Python 2 doesn't provide the flush argument, but you could emulate a Python 3-type print function as described here https://stackoverflow.com/a/27991478/3734258 .
The following works in Python 2.6, 2.7, and 3.2:
Yes, it is enabled by default. You can disable it by using the -u option on the command line when calling python.
You can also run Python with stdbuf utility:stdbuf -oL python <script>
You can also use fcntl to change the file flags in-fly.
Variant that works without crashing (at least on win32; python 2.7, ipython 0.12) then called subsequently (multiple times):
(I've posted a comment, but it got lost somehow. So, again:)As I noticed, CPython (at least on Linux) behaves differently depending on where the output goes. If it goes to a tty, then the output is flushed after each '\n'If it goes to a pipe/process, then it is buffered and you can use the flush() based solutions or the -u option recommended above.Slightly related to output buffering:If you iterate over the lines in the input withfor line in sys.stdin:...then the for implementation in CPython will collect the input for a while and then execute the loop body for a bunch of input lines. If your script is about to write output for each input line, this might look like output buffering but it's actually batching, and therefore, none of the flush(), etc. techniques will help that.Interestingly, you don't have this behaviour in pypy.To avoid this, you can usewhile True:   line=sys.stdin.readline()...
It is possible to override only write method of sys.stdout with one that calls flush. Suggested method implementation is below.Default value of w argument will keep original write method reference. After write_flush is defined, the original write might be overridden.The code assumes that stdout is imported this way from sys import stdout.
You can create an unbuffered file and assign this file to sys.stdout.You can't magically change the system-supplied stdout; since it's supplied to your python program by the OS.
One way to get unbuffered output would be to use sys.stderr instead of sys.stdout or to simply call sys.stdout.flush() to explicitly force a write to occur.You could easily redirect everything printed by doing:Or to redirect just for a particular print statement:To reset stdout you can just do:
In Python 3, you can monkey-patch the print function, to always send flush=True:


Answer URL
