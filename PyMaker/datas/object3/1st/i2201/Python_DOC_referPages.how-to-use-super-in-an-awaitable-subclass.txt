Natural Text
I'd like to add a new functionality to an existing awaitable class by subclassing it.Let's start with a very simple base class creating objects which asynchronously return 99 after a short sleep. The subclass should just add +1 to the result.I can't find the proper way to use super() to refer to the base class.
The await method must return an iterator, so you can make it a generator and use the yield from syntax:
If you are allowed to modify R99, you can make __await__() invoke an actual coroutine, which can chain to super() in the regular way:If that is not an option, @Vincent's answer precisely explains how to chain from one __await__ to another. Note that you were quite correct in thinking that await is the new yield from - it is, and there is normally no reason to use yield from in newly written asyncio code. (This of course doesn't apply to non-asyncio-related generators that delegate to sub-generators; those are welcome to keep using yield from.)However, by implementing __await__() you are dropping into the lower-level API which uses generators to implement coroutines. At this level yield suspends the coroutine, returning control to the event loop, and yield from delegates to another generator that implements a coroutine. In new code the only valid purpose for this layer is to implement an awaitable object without using the interpreter, e.g. in Python/C or Cython. This is done by providing an __await__ that returns an iterator, as shown here. The resulting object is equivalent to an async def.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__await__
