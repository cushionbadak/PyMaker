Natural Text
How do I get it to pick 5 random numbers between (0,50), then 2 random numbers between(0,12)?
You can vary the second argument to randint() based on the value of i:The 50 if i < 5 else 12 expression will change what is passed to random.randint() for the last two iterations.There are many more variations you can spell this in. List comprehensions are a bunch of loops and if filters that repeatedly execute the expression at the front. There are lots of ways to spell vary the arguments to a function call based on the iteration values in expressions.For example, you could record those arguments in functools.partial() objects:The possibilities are endless. Lambdas, randint(0, upperbound), randint(*args), a function that'll vary its results depending on how often it has been called, etc. But I wouldn't argue that any of these are actually more readable or understandable.For this case, with just 7 values, I'd just concatenate the two lists:as it's just cleaner and more readable. The small performance cost of creating a 3rd list that contains the results of the two list comprehensions is negligible here.
Something like this maybe, concatenating 2 lists:
Don't reuse the name list.  One way would be to loop through an iterable of the bounds, and send those to randintYou could also use itertools.chain and itertools.repeat to avoid building that list of bounds

Here's another variation that avoids doing an if test on every iteration. It also uses randrange, which is slightly more efficient than randint.typical outputThis is equivalent toThe outer loop selects num, the number of items in the sublist, and hi the size of the random range for that sublist; the inner loop generates the required amount of random numbers in the desired range.FWIW, here's some timeit code comparing the various algorithms that have been submitted. It also verifies that they produce the same results when given the same random seed. My simple verification code uses eval, so it can only test expressions, not statements, so it can't test jpp's or Abhishek's code; besides, jpp's Numpy code gives different results anyway, since it uses a different seeding algorithm. Please see the timeit docs for info on what timeit does, and how to interpret the results.typical outputAs you can see, jpp's Numpy code is the fastest. I expect that the speed difference would be even more apparent if we were generating a longer list of numbers.These timing were performed on an ancient 32 bit single core 2GHz machine, running Python 3.6.0 on a Debian derivative distro. YMMV.Here are timings for the production of lists (or arrays) of 50 + 20 = 70 values in the same ranges.
If you are happy using a 3rd party library, you can via NumPy:The benefit of this method, memory pre-allocation, will be evident with larger arrays.

You can do this using list-comprehensions and only built-ins, some monstrosity like:Perhaps, if you want to use itertools, you can do something like:Both of these approaches are hardly readable and simple. Instead, I would personally go with two for-loops, the naive approach. It would be efficient, simple, and readable. Other than showboating, I see no advantage to the above approaches in production code.


Answer URL
https://docs.python.org/3/library/functools.html#functools.partial
https://docs.python.org/3/library/timeit.html#timeit.Timer.repeat
