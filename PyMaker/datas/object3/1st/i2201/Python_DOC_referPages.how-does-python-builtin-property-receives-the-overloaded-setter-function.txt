Natural Text
When defining a builtin python property using the @property, how does the property object differentiates the setter from the getter method, provided that they are overloaded (have the same name)?If I define a custom property decorator, say:Executing the code results in the following output    Both the getter and the setter funtions passed to the decorator are the same funtion, but they should be different functions.If I use the annotation like this:A different function is printed, as expected.How does python solves this issue with the builtin @property? Is the decorator treated differently from user decorators ?
The reason you're seeing what you're seeing here is because you don't keep a reference to the getter anywhere. This means that once the __init__ method ends, there's no more reference to the first B.x, (i.e. the refcount is zero), so the function is released. Since the original getter function has been released, Python is free to reuse the exact same memory address for another object/function, which is what happens in this case.If you modify my_property to keep a reference to the original getter method as such:you'll see that the function name (B.x) is still the same (which is ok, as python doesn't use the function name to uniquely identify a function), however the memory address of the two functions are different:Is the decorator treated differently from user decorators ?No, property just a regular decorator. However, if you want to reimplement the property decorator, you'd probably be interested in the descriptor protocol (there's a pure python reimplementation of @property in that page).


Answer URL
https://docs.python.org/3/howto/descriptor.html
