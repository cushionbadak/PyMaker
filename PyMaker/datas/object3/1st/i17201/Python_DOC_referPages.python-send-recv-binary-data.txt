Natural Text
I a trying to send and receive binary data in python(v3). The way I am attempting to do it is at the client end, I manually create a string of bytes and then send it through a socket to the server. On the server side, I receive the data and manually access individual bits to resolve the message.This is how the client looks:this is how the server handles the data:In that last line of code, I get an error saying that (str(var)) is being treated as a unicode string rather than a binary one. However, if I don't cast as a string, I get an access out of bounds error.Can someone explain to me what the correct way to send and receive binary data in python is? I have tried using struct.pack and unpack before/after sending data, but I always get errors during the unpacking, even though the format strings are identical
(int)(remoteStruct[0])This looks a lot like some C code.  Python doesn't have type casts like C.int refers to an object.  The way you use it is by calling it - like it's a function.Instead write something like int(remoteStruct[0]).  What you wrote works because the extra parenthesis are totally redundant and don't change the meaning.  This isn't just a syntactic difference, though.  It's a basic difference in the type systems of the two languages.This has nothing to do with your question, though.This is an incredibly verbose way to pack an IPv4 address into four bytes.  Try this instead:Though this is also not directly related to your question.The source of your IndexError problem (I'm guessing that's the exception you encounter, you said "access out of bounds error" which isn't something that actually exists in Python's built-in types - don't paraphrase errors, quote them verbatim) is very likely somewhere in the vicinity of:Notice the return value of recvfrom: The return value is a pair (bytes, address).If you try to index into this object at 6 then you'll definitely get an IndexError raised, yes.Using str to get a unicode string representation of this pair won't really help though - although it might prevent the indexing operation from failing because the resulting unicode string will probably be long enough. :)  You'll be getting garbage, though.Instead, try indexing into the bytes that you read instead:Notice you really do need to be careful about length checking here.  Just because you passed 12 to recvfrom doesn't mean it returns 12 bytes.  It means it returns up to 12 bytes.  You don't want your program to explode with an unhandled exception the first time someone sends you a short datagram.


Answer URL
