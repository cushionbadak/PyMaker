Natural Text
I want to get the only Non-None element from this list:I've triedBut the result isDeleting only the None that are not inside of any list. Is there any way to clean the whole list? so the output is
I'll break this down for you, first starting with generators. The yield keyword is sister to return, but with much different functionality. Both are used to bring values out of a function into its calling scope, but yield allows you to jump back into the function afterwards! As an example, below is a generator that accepts a list full of numbers and produces the square for each number in the list.Generators are one-time use, however. As you can see, after I reached the end of the generator, it threw an exception StopIteration. If I built it again and ran through it with a loop, then tried to run through it AGAIN...It doesn't do anything the second time. The generator is exhausted. That's the downside -- the upside is that it's generally much faster and more memory-efficient to use generators instead of lists.yield also allows you to use another keyword: from. That's what I did there in case of a nested list (hasattr(element,"__iter__") just means that the element has an attribute .__iter__, which means it can be iterated upon using something like a for loop). You give yield from another generator, and it yields each element from THAT generator in turn. For example:Here's what it does in turn:So basically the code above says (in pseudocode):When you call it, it builds a generator that can be iterated upon. To make it into a formal list, you'll have to do list(flatten(L)), but in most cases you don't need that.Is that any clearer?
Another slightly more modular approach:A generic flatten function is something you should keep in your toolbox, since (so far) it's not something you can find in the standard library, and it comes up occasionally.
Just for fun, how about:This will return a list with only the Car element present. It will generalize to return a list with any non-None element.In Python 3.x I think you swap ifilterfalse for filterfalse and it works the same.chain() is designed to flatten a list of lists for iteration. ifilterfalse can work directly on the chain returned. ifilterfalse gets rid of elements that match the predicate specified by the lambda function. Note that if you have strings in L, chain() will essentially break the strings up into individual elements. If that is a problem for you, see this other SO post.Another implementation which avoids the problem of non-iterables at the base level:I'm told this may not work in Python 3 because of how str is implemented there. Anyway I'm only posting these ideas so that you are aware of functionality already available in the Python standard library under itertools. Have fun learning Python!


Answer URL
