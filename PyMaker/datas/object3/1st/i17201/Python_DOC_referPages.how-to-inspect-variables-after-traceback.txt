Natural Text
My Python script is crashing. To debug it, I ran it in interactive mode python -i example.pyAt this point, I would like to inspect the variable message. I triedAlas message is not in scope (though main is). That's frustrating. How can I inspect the variable? Is there a more useful version of python -i that keeps what's in scope at the crash (rather than the top level)?Code used for example.py above. Needless to say, this is a simplification. 
To drop to a debugger only if there is an exception you could define a custom excepthook:Running the script drops you into pdb and in the frame which raised the exception:If defining the excepthook seems like too much code, you could tuck it away in autility module, such as utils_debug.py:and then you would only need to addto your script.py.Or, if you are using IPython, you could use the %pdb magic function (which drops you into ipdb when there is an exception). It is unclear why inspecting  size at the pdb prompt is giving you a NameError. (A runnable example would be very useful.) You might try using bt (backtrace) to inspect the frame stack. If size is defined in a different frame than the one pdb is currently in, you might be able use u (up) to go up to the frame where size is defined.
According to the Python docs https://docs.python.org/3.4/library/pdb.htmlpdb.py can also be invoked as a script to debug other scripts. For example: python -m pdb myscript.py. When invoked as a script, pdb will automatically enter post-mortem debugging if the program being debugged exits abnormally. This isn't entirely accurate. It actually enters debugging at the first line. However if you type c it will then continue to the crashAt this point you can type message to inspect the variable.Wahey!
A simple alternative is to use cgitb module.Now the traceback itself prints the value of the message.
You can use some of the Python debuggers as mentioned at the other answer or give a try to my diagnostics library that stores more detailed traceback for you as HTML file :) Just create directory named log next to the cheaters.py file and enable exception hook by lines below:
I usually use the code module for this type of thing.  Catch the exception as early as you can and dump everything into an interactive console right there.This will start a python REPL inside the exception handler, the raised exception will be in local_vars['e'], and you'll have access to the scope where the try block was called.  If the exception is being raised inside some other library, you can modify the other library's code with this exception handler, use the PYTHONPATH environment variable to point python at the modified version of the library, and leave the original in place.
I highly recommend both ipython and ipdb for these sorts of situations.From within the ipython shell, you typeWhen the unhandled exception returns you to the ipython shell, you typeThis will put you in ipdb, at the exact line of code that throws the unhandled exception. You can then inspect the variables simply by evaluating them, just as you would in a normal python shell.My answer is similar to Colonel Panic's answer that was already accepted. The main advantage here is ipython and ipdb. I prefer these tools for a variety of reasons, the most prominent is that they enable tab completion of variable names. Once you become used to tab completion, it's hard to live without it, because it allows you to work so much faster.
use , pdb for debugging each line this will give you break after each line and you can track your code when main() will be call this function will start working and you can track message , you can debug it your terminal will look like it


Answer URL
https://docs.python.org/3/library/cgitb.html
