Natural Text
Docs:With three arguments, return a new type object. This is essentially a dynamic form of the class statement. The name string is the class name and becomes the __name__ attribute; the bases tuple itemizes the base classes and becomes the __bases__ attribute; and the dict dictionary is the namespace containing definitions for class body and becomes the __dict__ attribute.While learning Python I have come across this use of type as "a dynamic form of the class statement", this seems very interesting and useful and I wish to understand it better.  Can someone clearly explain the role of __name__, __bases__, and __dict__ in a class and also give example where type(name, bases, dict) comes into its own right.
When you define a class:Python essentially does this:where Foo is then added to the namespace the class statement was defined in.The block under the class statement is executed as if it was a function with no arguments and the resulting local namespace (a dictionary) forms the class body; in this case a dictionary with 'bar' and 'spam' keys is formed.You can achieve the same result by passing a name string, a tuple of base classes and a dictionary with string keys to the type() function.Once you start exploring metaclasses as well (which are essentially subclasses of type(), letting you customize how classes are created), you'll find that body doesn't have to be a plain dictionary. PEP 3115 - Metaclasses in Python 3 expanded the possible values to anything dict like, letting you implement all sorts of interesting class behaviour by letting you use augmented dictionaries for the class body. The new Python 3.4 enum module for example, uses an OrderedDict() instance instead, to preserve attribute ordering.
__name__ is a string containing the name of the class.__bases__ is a tuple of classes from which the current class derives.__dict__ is a dictionary of all methods and fields defined in the class.  The use case for type(name, bases, dict) is when you want to dynamically generate classes at runtime.Just imagine that you want to create ORM for a database and you want all the classes representing database tables to be generated automatically. You have an idea how these classes should behave but you don't know their names, their fields until you inspect the database schema. Then you can use this function to generate these classes.
Just like creates an instance of Foo and assigns it to a,creates an instance of type and assigns it to Foo. Not only does this allow you to create classes dynamically (similar to, but not as restricted as, using lambda to create a function), but it lets you (correctly) think of type not as a function, but as a type itself. An instance of type is a class object. type.__new__ creates the object, type.__init__ initializes it, type.__call__ lets you use the class as a callable object (which in turn is how Foo() creates and initializes instances of Foo).Understanding type is how you understand metaclasses. When you don't specify a metaclass, Python uses type to create the class, as if you had written (in Python 2.x)Just like you can subclass ordinary classes, you can subclass type to create your own metaclass!If you run the above, you'll see output that is generate as the class statement is executed, because mymetaclass.__new__ is executed when the class statement is executed.


Answer URL
