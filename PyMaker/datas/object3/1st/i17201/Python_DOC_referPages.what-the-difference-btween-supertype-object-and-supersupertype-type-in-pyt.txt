Natural Text
Won't super(type, object) and super(supertype, type) all return the object of super class of type(supertype)? What's the difference?
The difference is huge; super() with a type (class) second argument instead of an object (instance) gives you unbound methods, not bound methods (just like accessing those methods on a class would).I'll explain first how super() works with an instance second argument.super() inspects the MRO of self, finds the first argument (type or supertype) in the MRO, then finds the next object that has the requested attribute.Demo:The MRO of Derived is (Derived, Intermediary, BaseClass); super() finds this MRO by looking at the second argument, using type(d).__mro__. The search for foo starts at the next class after the first argument given.The foo() method is bound here, you can just call it.If you give super() a type as the second argument, then it'll use the MRO of that type, e.g. instead of using type(instance).__mro__ it just goes for type.__mro__. However it then has no instance to bind the methods to. super(supertype, type).foo is unbound:To call .foo() I have to explicitly pass in a self argument.(In Python 3, the above would return the foo function object instead of an unbound method, but the principle is the same).The method returned is also, again, from the next class in the MRO chain; BaseClass.foo was returned there.This is down to the function.__get__ method (i.e. the descriptor protocol, responsible for binding), as it returns an unbound object (an unbound method in Python 2, the function itself in Python 3) when passed a class to bind to. (For classmethod objects, __get__ does return a bound object when passed in a class).So, TL;DR, for methods super(type, object) returns a bound method, super(supertype, type) returns unbound methods. 


Answer URL
https://docs.python.org/3/howto/descriptor.html
https://docs.python.org/3/library/functions.html#classmethod
https://docs.python.org/3/library/functions.html#super
