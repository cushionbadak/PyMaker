Natural Text
Let's say I have a class, members of which I want to compare with the usual operators ==, <, <=, >, and >=.As I understand, this could be accomplished by initializing defining magic method __cmp__(a, b) which returns -1 (a < b), 0 (a == b), or 1 (a > b).It seems like __cmp__ was deprecated since Python 3 in favor of defining __eq__, __lt__, __le__, __gt__, and _ge__ methods separately.I defined __eq__ and __lt__ assuming that the default values for __le__ would look something like return a == b or a < b. It seems to be not the case with the following class:And I get this outcome:This has left me to conclude that I'll have to define all the comparison magic methods manually to make a class comparable. Is there any better way?Why has __cmp__ been deprecated? That seems like a much nicer way to deal with it
For two objects a and b, __cmp__ requires that one of a < b, a == b, and a > b is true.  But that might not be the case: consider sets, where it's very common that none of those are true, e.g. {1, 2, 3} vs {4, 5, 6}.So __lt__ and the likes were introduced.  But that left Python with two separate ordering mechanisms, which is kind of ridiculous, so the less flexible one was removed in Python 3.You don't actually have to implement all six comparison methods. You can use the functools.total_ordering class decorator to help define the rest of the magic comparison methods:


Answer URL
https://docs.python.org/3/library/functools.html#functools.total_ordering
