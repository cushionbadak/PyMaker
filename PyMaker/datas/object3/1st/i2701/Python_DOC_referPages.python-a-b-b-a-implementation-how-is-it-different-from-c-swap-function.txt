Natural Text
I met this problem when I want to try a python version of:https://leetcode.com/problems/first-missing-positive/discuss/17071/My-short-c++-solution-O(1)-space-and-O(n)-timeI am not sure why a[0], a[a[0]] = a[a[0]], a[0] this one does not do the swap?My guess is that the implementation of a, b = b, a syntax is something like:Then I checked the implementation of swap function in C++. I know nothing about C++, but it looks like the idea is the same:http://www.cplusplus.com/reference/algorithm/swap/we have c = a, then a = b and b = aSo why C++ swap function does not have this problem?And how to write this kind of swap function in a pythonic way?
To understand this you need to go inside the implementation using dis.First lets consider a simple swap function:Output Byte Code:You can see that there is ROT_TWO which means that Swaps the two top-most stack items.This ROT_TWO is mainly responsible for the swapping.Now coming to your question:Lets take the example which is working:Output Byte Code :Output byte code is similar to what we have when it is a simple swap function. But when the code is changed:Output is You can see the output byte code that top two items are the same. Hence it doesn't swap
This kind of the behaviour is indeed related to the way Python evaluates the expression of the typeIn fact, what Python does is first it "prepares" the values of the right side by creating a tuple (b,a). Then this tuple is unpacked and assigned to the variables in the reverse order.It is important to note that the temporary tuple is created using values of variables (de facto copies of values), not references to the variables (you can read here about the difference between passing by value and by reference).To break down the example with reference types (lists) that you used:a[a[0]] takes the value from the a[0] element (equal to 2) of the list a (value 0).a[0] is 2 hence the tuple created is (0,2)Tuple (0,2) is unpacked and 0 replaces 2 in the list (0th element).Now, a[a[0]] can be read as: take 0th element of list a (which is currently 0) and then replace the value in the list at that place with 2 from tuple unpacking (now 0 is replaced by 2 - which make the operation  look like it does nothing to the list).As suggested in the answer from von Oak changing the order helps because the step from the point 4. above does not replace the value again.
Python and C++ are different languages with different rules. That's largely the reason why superficially similar constructs behave differently in these languages.You cannot write a generic swap in Python that would work with input like a[0], a[a[0]]. This is not a problem. You shouldn't ever try to swap such things in any language in order to avoid confusion and improve your chances for future employment as a programmer.If you absolutely positively need to swap array elements indexed by elements of the same array, you can do it like so in Python:where index0 and index1 may be any expression involving a[i], a[a[i]], a[a[a[i]]] or anything similar. For exampleworks.
It's easy to think about it also only on the paper (e.g. at the job interview) and you don't need to debug or disassemble code to bytecode for understanding. I also think it hasn't anything to do with the implementation of swap function in C++. These are unrelated things.What you only need to know is that the right side is completely evaluated first and then the values from the right side of the expression are assigned to the values on the left side in the order from the left to the right. Sophros answered it right way I only expand the idea further and in more detail.Imagine the first case. We have:When we start to execute this code, the right side evaluates first, so we will haveOn the right side, we have tuple (0, 2) and a is still [2, 1, 0]Next, we start to assign to the left side of the expression from the left, so to the a[0] we assign the first item from the tuple, which is 0. Now we haveAnd now we execute the last part of the assignment, which is to a[a[0]] assign 2. But a[0] is now 0, so after reduction we assign to a[0] value 2. Therefore values after the last assignment areWhich seems, that nothing changed and values didn't swap, but as is apparent from above a was [2,1,0], then [0,1,0] and lastly again [2,1,0]. So it seems, nothing changed and swap doesn't work.And now the second case, where we only change the order of variables in the expression:When we start to execute this code, the right side evaluates first, so we will haveOn the right side, we have tuple (2, 0) and a is still [2, 1, 0]Next, we start to assign to the left side of the expression from the left, so to the a[a[0]] we assign the first item from the tuple, which is 2. a[0] is 2, so after reduction, we assign to a[2] value 2. Now we haveAnd now we execute the last part of the assignment, which is to a[0] assign 0. Therefore values after the last assignment areNow this works as expected.So it is necessary also think about the order when you have dependent variables in your swap expression. As dependent variables I mean that in the first case we have on the left side a[0], a[a[0]] that means a[0] change it's value and a[a[0]] use this changed value, which leads to unwanted behavior.Finally, regardless of the programming language, it's better not to use dependent variables (array index for another array index etc.), when you want to swap their values.


Answer URL
https://docs.python.org/3/library/dis.html#opcode-ROT_TWO
