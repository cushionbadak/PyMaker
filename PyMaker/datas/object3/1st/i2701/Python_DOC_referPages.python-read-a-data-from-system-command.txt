Natural Text
I want to write a function that will execute a shell command and return its output as a string, no matter, is it an error or success message. I just want to get the same result that I would have gotten with the command line.What would be a code example that would do such a thing?For example:
The answer to this question depends on the version of Python you're using. The simplest approach is to use the subprocess.check_output function:check_output runs a single program that takes only arguments as input.1 It returns the result exactly as printed to stdout. If you need to write input to stdin, skip ahead to the run or Popen sections. If you want to execute complex shell commands, see the note on shell=True at the end of this answer.The check_output function works on almost all versions of Python still in wide use (2.7+).2 But for more recent versions, it is no longer the recommended approach.Modern versions of Python (3.5 or higher): runIf you're using Python 3.5 or higher, and do not need backwards compatibility, the new run function is recommended. It provides a very general, high-level API for the subprocess module. To capture the output of a program, pass the subprocess.PIPE flag to the stdout keyword argument. Then access the stdout attribute of the returned CompletedProcess object:The return value is a bytes object, so if you want a proper string, you'll need to decode it. Assuming the called process returns a UTF-8-encoded string:This can all be compressed to a one-liner:If you want to pass input to the process's stdin, pass a bytes object to the input keyword argument:You can capture errors by passing stderr=subprocess.PIPE (capture to result.stderr) or stderr=subprocess.STDOUT (capture to result.stdout along with regular output). When security is not a concern, you can also run more complex shell commands by passing shell=True as described in the notes below.This adds just a bit of complexity, compared to the old way of doing things. But I think it's worth the payoff: now you can do almost anything you need to do with the run function alone.Older versions of Python (2.7-3.4): check_outputIf you are using an older version of Python, or need modest backwards compatibility, you can probably use the check_output function as briefly described above. It has been available since Python 2.7.It takes takes the same arguments as Popen (see below), and returns a string containing the program's output. The beginning of this answer has a more detailed usage example. You can pass stderr=subprocess.STDOUT to ensure that error messages are included in the returned output -- but don't pass stderr=subprocess.PIPE to check_output. It can cause deadlocks. When security is not a concern, you can also run more complex shell commands by passing shell=True as described in the notes below.If you need to pipe from stderr or pass input to the process, check_output won't be up to the task. See the Popen examples below in that case. Complex applications & legacy versions of Python (2.6 and below): PopenIf you need deep backwards compatibility, or if you need more sophisticated functionality than check_output provides, you'll have to work directly with Popen objects, which encapsulate the low-level API for subprocesses. The Popen constructor accepts either a single command without arguments, or a list containing a command as its first item, followed by any number of arguments, each as a separate item in the list. shlex.split can help parse strings into appropriately formatted lists. Popen objects also accept a host of different arguments for process IO management and low-level configuration. To send input and capture output, communicate is almost always the preferred method. As in:Or If you set stdin=PIPE, communicate also allows you to pass data to the process via stdin:Note Aaron Hall's answer, which indicates that on some systems, you may need to set stdout, stderr, and stdin all to PIPE (or DEVNULL) to get communicate to work at all.In some rare cases, you may need complex, real-time output capturing. Vartec's answer suggests a way forward, but methods other than communicate are prone to deadlocks if not used carefully.As with all the above functions, when security is not a concern, you can run more complex shell commands by passing shell=True.Notes1. Running shell commands: the shell=True argumentNormally, each call to run, check_output, or the Popen constructor executes a single program. That means no fancy bash-style pipes. If you want to run complex shell commands, you can pass shell=True, which all three functions support.However, doing so raises security concerns. If you're doing anything more than light scripting, you might be better off calling each process separately, and passing the output from each as an input to the next, viaOrThe temptation to directly connect pipes is strong; resist it. Otherwise, you'll likely see deadlocks or have to do hacky things like this.2. Unicode considerationscheck_output returns a string in Python 2, but a bytes object in Python 3. It's worth taking a moment to learn about unicode if you haven't already.
This is way easier, but only works on Unix (including Cygwin).it returns a tuple with the (return_value, output)This only works in python2.7: it is not available on python3. For a solution that works in both, use the subprocess module instead:
Something like that: Note, that I'm redirecting stderr to stdout, it might not be exactly what you want, but I want error messages also.This function yields line by line as they come (normally you'd have to wait for subprocess to finish to get the output as a whole).For your case the usage would be:
Vartec's answer doesn't read all lines, so I made a version that did:Usage is the same as the accepted answer:
This is a tricky but super simple solution which works in many situations:A temporary file(here is tmp) is created with the output of the command and you can read from it your desired output.Extra note from the comments:You can remove the tmp file in the case of one-time job. If you need to do this several times, there is no need to delete the tmp.
In Python 3.5:
I had the same problemBut figured out a very simple way of doing thisfollow thisHope it helps outNote: This solution is python3 specific as subprocess.getoutput() don't work in python2
You can use following commands to run any shell command. I have used them on ubuntu.
Modern Python solution (>= 3.1): 
Your Mileage May Vary, I attempted @senderle's spin on Vartec's solution in Windows on Python 2.6.5, but I was getting errors, and no other solutions worked. My error was: WindowsError: [Error 6] The handle is invalid. I found that I had to assign PIPE to every handle to get it to return the output I expected - the following worked for me.and call like this, ([0] gets the first element of the tuple, stdout):After learning more, I believe I need these pipe arguments because I'm working on a custom system that uses different handles, so I had to directly control all the std's.To stop console popups (with Windows), do this:
I had a slightly different flavor of the same problem with the following requirements:Capture and return STDOUT messages as they accumulate in the STDOUT buffer (i.e. in realtime). @vartec solved this Pythonically with his use of generators and the 'yield'keyword abovePrint all STDOUT lines (even if process exits before STDOUT buffer can be fully read)Don't waste CPU cycles polling the process at high-frequencyCheck the return code of the subprocessPrint STDERR (separate from STDOUT) if we get a non-zero error return code.I've combined and tweaked previous answers to come up with the following:This code would be executed the same as previous answers:
If you need to run a shell command on multiple files, this did the trick for me.Edit: Just saw Max Persson's solution with J.F. Sebastian's suggestion.  Went ahead and incorporated that.
Splitting the initial command for the subprocess might be tricky and cumbersome.Use shlex.split to help yourself out.Sample commandgit log -n 5 --since "5 years ago" --until "2 year ago"The code
eg, execute('ls -ahl')differentiated three/four possible returns and OS platforms:no output, but run successfullyoutput empty line, run successfullyrun failedoutput something, run successfullyfunction below


Answer URL
https://docs.python.org/3/library/subprocess.html#subprocess.check_output
https://docs.python.org/3/library/subprocess.html#using-the-subprocess-module
https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess
https://docs.python.org/3/library/shlex.html
https://docs.python.org/3/library/subprocess.html#subprocess.Popen
https://docs.python.org/3/library/subprocess.html#security-considerations
https://docs.python.org/3/howto/unicode.html
