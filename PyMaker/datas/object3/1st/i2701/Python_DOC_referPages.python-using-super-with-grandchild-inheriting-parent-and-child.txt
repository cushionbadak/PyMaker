Natural Text
[using Python3.6]I have a design where Grandchild inherits a Parent and Child (of Parent).the result is -Calling a function from Parent causes the aux_func to resolve from the Child class. I tried to go through MRO process but can't explain functions being called from different classes. Could someone help me withWhy this is happening ?What would be a workaround to achieve [parent main][parent aux] ?  
You are misunderstanding what super() does. super() does not alter the type of the self reference. super(..., self).method() will still pass in that self reference to the method being called, so self is, in all three cases, the Grandchild() instance.That means that in all cases, self.aux_func() follows the normal attribute resolution order, and for Grandchild() instances, self.aux_func() will always find Child.aux_func and call that.Put differently, the only lookup that is altered, is the attribute you look up on the super() object itself. If you need more such alterations, you need to use super() again, or you need to give your aux_func() functions different names per class. One way to do that is to make the methods class private.The latter can be done by naming your function with two underscores at the start (but not at the end). Such names are then altered at compile time to inject the class names in all places that it is referenced:See the Reserved classes of identifiers documentation:__*  Class-private names. Names in this category, when used within the context of a class definition, are re-written to use a mangled form to help avoid name clashes between “private” attributes of base and derived classes.and the Identifiers (Names) section:Private name mangling: When an identifier that textually occurs in a class definition begins with two or more underscore characters and does not end in two or more underscores, it is considered a private name of that class. Private names are transformed to a longer form before code is generated for them. The transformation inserts the class name, with leading underscores removed and a single underscore inserted, in front of the name. For example, the identifier __spam occurring in a class named Ham will be transformed to _Ham__spam. This transformation is independent of the syntactical context in which the identifier is used.By using class private naming for __aux_func, any reference to it from methods defined on Parent will look up and find _Parent__aux_func, and any reference to the same name in Child will look up and find _Child__aux_func. The two names are distinct and thus don't clash:A different way to achieve this is to use distinct names, explicitly; say parent_aux_func() and child_aux_func(). Class private names are really only intended in APIs that are meant to be subclassed by third-party code without too many restrictions on what names the subclass can use.


Answer URL
https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers
https://docs.python.org/3/reference/expressions.html#atom-identifiers
