Natural Text
I was studying a coding challenge in which you need to write a function that counts duplicate occurrences of character patterns in a string and returns how many times it occurs. For example if string is s = 'catcatcat', output is 3. If string s = 'abcdabcd', output is 2. If s = 'catcatcatcatcat', output is 5.The answer ended up beingCan anyone help explain this code because im having trouble understanding. Btw just started learning python. 
If you just started learning python, it's rather early for such snippets. You need to read first aboutlist comprehensionslists/strings/iterables & slicingstrings & string operations (in this case, string-integer multiplication)Let's take it piece by piece   In the string s, count how many times the substring of the n first characters appearstry this for all values of x, from 0 to the total lenght of sFrom all the above values, keep only the ones for which this condition holds. As said before, the left operand is a substring and the second a number. In python, multiplication of a string with integer repeats the string. eg 'aa' * 3 => 'aaaaaa'In the end, you just take the max of all the above values.
Let's breakdown the expression bit by bit and highlight the Python concepts/features being used.max([s.count(s[:x]) for x in range(len(s)) if s[:x]*s.count(s[:x]) == s])when you have a python expression inside [] invoked the way it is here it usually means a Python capability called List comprehension is being invoked. What does this mean? I like to think of it as comprehend this expression for the range of input specified and return all the answers as a list. This allows you to write powerful, albeit unpythonic(non idiomatic python), expressions.Now let's examine the expression inside the []s.count(s[:x]) for x in range(len(s)) if s[:x]*s.count(s[:x]) == sIf I were to translate this expression into plain English I would say: Please return the count of the substring ending before xs[:x], for all x in the range 0 to len(for ...) of the original string, in the original string s(s.count...)Finally the max is invoked on the returned list to get you the max value.That being said this method is somewhat inefficient because you perform a substring search and count for every substring.What I would do instead:Look at prefix trees, i.e Tries.They offer far more efficient ways for you to compute such things.
You need to break it down step by step.Hopefully, you know what this does: it evaluates <something> and exits the function, making the value the result of the function.The max function can be called two ways, but here, there's only one argument, so, whatever <something> is, it will be an iterable, and max will give you the biggest value in that iterable.This is a list comprehension. You can always convert a list comprehension into an equivalent nested statement:So, now let's look at the parts. The <var> and <iterable> are:So, x just takes all the values from 0 up to but not including len(s).The <expr> is:That s[:x] is just a slice of the first x characters of s. So, if s is 'abcdefabc', when x is 2, it's 'ab'; when x is 4, it's 'abcd'.The s.count just tells you how many times that substring appears. So, when x is 2, 'ab' appears twice, so that's 2; when x is 4, 'abcd' only appears once, so that's 1.So, if we ignore the condition for the moment, these are the values we're putting in the list for 'abcdefabc': [2, 2, 2, 1, 1, 1, 2, 2, 2] The max of that will of course be 2.Finally, the hairiest part is the <condition>:You already know s[:x] and s.count(s[:x]).When you multiply a string (or any sequence) like 'abc' with a number like 2, it just repeats the string that many times, so 'abc' * 2 is 'abcabc'.We're checking whether that's equal to the whole string. Which in this case, it isn't. But if we were using s='catcatcat', then when x is 3, it would be.And that's everything.Now work through it with one of your examples, 'catcatcatcatcat'.For x=0, you get '', which occurs 16 times in s, but ''*16 is still '', which is not s, so skip it.For x=1, you get 'c', which occurs 5 times, bug 'c'*5 is 'ccccc', which is not s, so skip it.For x=2, you get 'ca', which occurs 5 times, but 'ca'*5 is 'cacacacaca', which is not s, so skip it.For x=3, you get 'cat', which occurs 5 times, and 'cat'*5 is 'catcatcatcatcat', which is equal to s, so keep it.The value for x=3 is s.count(s[:x]), which is 5 again, so that's what goes in the list.For x=4, you get 'catc', which occurs 2 times, and 'catccatc' != s, skip.â€¦ and so on for 5-14; none of them will match.For x=15, you get 'catcatcatcatcat', which occurs 1 time, and obviously it equals s.The value is 1 again, so that goes in the list.So the list ends up as just [5, 1].And max([5, 1]) is 5.


Answer URL
https://docs.python.org/3/library/functions.html#max
