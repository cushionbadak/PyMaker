Natural Text
My machine is Win7 with anaconda. i am recently converting C++ dll functions to a python project.There are numbers of difficulty I had overcame yet I have no idea how to deal with the following conversion:where,In python, I tried,The error is:i am not an export in C++ or programming. So not quite sure what byref is. It would be nice if someone can clear my concept.
POINTER(…) constructs a new pointer type, not a value of that type. So, when you do this:… you’re passing a Python type object, not a ctypes wrapper around a C pointer object.To get a pointer to a ctypes wrapper object, you want to call either pointer or byref. The former constructs a POINTER(…) instance, sets it to point to your object, and passes the wrapped pointer; the latter just directly passes a pointer to your object without constructing a pointer wrapper object, and usually that’s all you need. See Passing pointers in the docs for further details.However, I don’t think this is going to do much good, for two reasons.First, most functions that take a pointer to some struct and return an int are doing it so they can fill in that struct with useful values. Constructing a new empty struct and passing a pointer to it and not holding onto a reference to it means you have no way to look at whatever values got filled in. Also, you probably want to check the return value.In general, you need to do something like this:While we’re at it, you almost certainly want to set the argtypes and restype of the function, so ctypes knows how to convert things properly, and can give you an exception if you do something that makes no sense, instead of making it guess how to convert and pass things and segfault if it guesses wrong.Also, for the case of functions that return a success-or-error int, it's usually better to assign a function to the restype, which looks up the error and raises an appropriate exception. (Use an errcheck if you need anything more flexible than just checking that an int return is nonzero or a pointer return is zero.)But even this isn’t going to help here, because the function you’re trying to call doesn’t take a pointer to an ApiOrder in the first place, it takes a reference to a std::vector of them. So you need to call into the C++ stdlib to construct an object of that type, then you can byref that as the argument.But usually, it’s easier to write some C++ code that provides a C API to the library, then use ctypes to call that C API, instead of trying to build and use C++ objects from Python.Your C++ code would look something like this:Now, you can call this from Python by creating an array of 1 ApiOrder (or creating a POINTER to an ApiOrder and passing it directly, if you prefer):Of course you're still going to want argtypes and restype.


Answer URL
https://docs.python.org/3/library/ctypes.html#ctypes.POINTER
https://docs.python.org/3/library/ctypes.html#ctypes.pointer
https://docs.python.org/3/library/ctypes.html#ctypes.byref
https://docs.python.org/3/library/ctypes.html#specifying-the-required-argument-types-function-prototypes
https://docs.python.org/3/library/ctypes.html#ctypes._FuncPtr.errcheck
https://docs.python.org/3/library/ctypes.html#arrays
