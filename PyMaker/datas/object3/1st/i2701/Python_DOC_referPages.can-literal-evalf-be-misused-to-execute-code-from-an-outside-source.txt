Natural Text
I am just curious if this is a risk at all, I can't think of a way a user might be able to cause this to happen... but it seems worrisome.ast.literal_eval(f'{os.remove("dontdelete.txt")-hello-world}') will execute the file deletion. Is there any risk that this could be used against an application? What does "Safely evaluate an expression node"mean?
The reason literal_eval is defined in this way is that it's a specialized function in the ast module, not a magic function designed to be used for all kinds of other purposes, so you're expected to have at least skimmed the ast docs if you're using it.literal_eval can take either an ast.Node representing a parsed expression, or a string that, when given to ast,parse, produces such a node.Then, as long as the expression only uses "the following Python literal structures: strings, bytes, numbers, tuples, lists, dicts, sets, booleans, and None", it will evaluate the expression; otherwise, it will raise an error.So, if you pass it the string 'os.remove("dontdelete.txt")-hello-world', well, when you parse that, you get a BinOp expression, which is not one of the kinds of expression nodes that literal_eval accepts, so it immediately rejects it with a ValueError.And if you pass it the string """f'{os.remove("dontdelete.txt")-hello-world}'""", when you parse that, you get a JoinedStr expression node with a bunch of nodes inside it that literal_eval also doesn't accept (it's worth doing an ast.dump to see exactly what those nodes are, if you don't understand how f-strings work), so it's going to reject it with a ValueError again.But what if you pass it the string f'{os.remove("dontdelete.txt")-hello-world}'? Well, that string gets evaluated by the interpreter before it even gets passed to literal_eval.In most scenarios, that's going to raise an exception before literal_eval can even be called, so literal_eval is completely irrelevant. For example:If os is not imported, you get a NameError.If the file doesn't exist, you get a FileNotFoundError.If hello or world don't exist, you get a NameError.If hello exists but is any normal kind of value, because remove returns None, you get a TypeError about trying to subtract whatever type hello is from None.In some of those scenarios, the file is removed, of course. But since literal_eval never even got called, it's hardly relevant here. You could do the same thing with print instead of literal_eval, or just nothing at all.But what if os is imported, and the file exists, and hello is an instance of some type with an __rsub__ that accepts None, and world is an instance of some type that can be passed to the __sub__ of whatever hello.__rsub__ returned? Then literal_eval will get called with whatever that sub returns. If it's a string or an ast.Node, it will even evaluate it. And maybe that would be some other dangerous string? But in that case, literal_eval will raise a ValueError on that dangerous string, so no additional harm is done.


Answer URL
https://docs.python.org/3/library/ast.html#ast.literal_eval
