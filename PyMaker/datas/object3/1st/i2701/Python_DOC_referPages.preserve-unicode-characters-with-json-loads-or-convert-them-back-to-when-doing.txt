Natural Text
I have a json file that contains the unicode characters \u003c and \u003e. When loading the file with json.load() these characters get converted to < and >. Consider the following experiment:Which then prints like:Say that I need to dump this back to a file and need to have the characters < and > converted back to \u003c and \u003e. I am currently using f.write(json.dumps(d)) but that does not seem to work.I have searched for hours but am just not able to figure this out.
Well, here it would be useful to understand what the Python interpreter is doing.When the interpreter finds the beginning of a string literalIn your source code, you have this piece of text:When the parser finds the first character, ', it concludes: "This is a string literal! Until I find the next ', I should get all characters and put it in a list, to use as a string." So, let us say it creates the following list in memory:Then it finds the next character, ". Since the string literal is not closes (because no ' was found) it adds it to the list. As everything inside computers, characters are represented as numbers. The number is its Unicode point, and for " the code point is 34:It does the same to the next characters, putting their code points in the list:The \ and u characters from your source codeNow, the interpreter finds the character \. But this is not a common char at all! To the interpreter, it means the next characters do not mean themselves, but should be interpreted. So the interpreter does not add \ to the list, and get the next interpreter to understand what should be done. This is why there is no \  in your result.The next character is u. Since it was prefixed by \, the interpreter does not insert it into the list. Instead, the \u pair is interpreted as a command to get the next four characters, convert them to a hexadecimal number. That's why there is no \u in your results.How six characters become only oneThe next four chars are 0, 0, 3 and c. They form the 0x3C hex number, that is 60 in decimal form. So it is added to the list:Well, 60 is < in Unicode. That's why there is a < in your result. This is why the six characters (\, u, 0, 0, 3, c) actually represent only one (>) when the program runs.How to get what you wantOf course, you may want to have the characters \, u etc. in your result string. If so, Python gives you some options, and the simplest one is the raw string literal. To do this, you just need to prefix your string literal with r, as below:When the interpreter fins the r in the source code, and then a quote (such as '), it knows it is a string literal, but this string literal does not have \ interpreted at all. Everything inside it is to be used as it was typed in the source code. This brings a result similar to the one you seem to want:Be Careful What You Wish ForNote however that these strings are completely different! Even their sizes are very different, because the second one has more characters:Now, I have to say, you likely do not want to have a raw string here. You may only be wanting to represent the string with the Unicode points, but it also begs the question of why. Anyway, it is up to you now to decide what you want :)


Answer URL
https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals
