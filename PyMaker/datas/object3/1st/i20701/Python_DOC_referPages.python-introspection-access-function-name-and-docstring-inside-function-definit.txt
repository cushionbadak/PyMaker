Natural Text
Consider the following python code:What do I need to replace the question marks with so that I get the name and the docstring of the function from inside the same function?EDIT:Most of the answers so far explicitly hardcode the name of the function inside its definition. Is it possible do something like below where a new function get_name_doc would access the function from the outer frame from which it is called, and return its name and doc?
This is not possible to do cleanly in a consistent way because names can be changed and reassigned.However, you can use this so long as the function isn't renamed or decorated.It's not at all reliable. Here's an example of it going wrong.This is because the name test isn't defined at the time that the function is actually created and is a global reference in the function. It hence gets looked up in the global scope on every execution. So changes to the name in the global scope (such as decorators) will break your code.
The code below solves the problem for the name of the function. However, it fails to detect the correct docstring for the example given by aaronasterling. I wonder if there is a way to get back to the abstract syntax tree associated with a bytecode object. Then it would be quite easy to read the docstring. 
This will find the name and the doc of a function calling get_doc.In my sense, get_doc should have the function as argument (that would have made it really easier, but way less fun to achieve ;))

For my personal projects, I developed function name and doc recovery techniques for functions and class methods.  These are implemented in an importable module (SelfDoc.py) which has its own self test in its main.  It is included below.  This code executes as is in Python 2.7.8 on linux and MacOS.  It is in active use.
You have to use the name of the function to get it:There is also a module called inspect:http://docs.python.org/library/inspect.html.This is useful to get further information about the function (or any python object).
How about this:Shortly, the giveme decorator adds the (decorated) function object as the first argument. This way the function can access its own name and docstring when it is called.Due to decoration, the original myfunc function is replaced by decor. To make the first argument be exactly the same as myfunc, what is passed into the function is decor and not func.The functools.wraps decorator is used to give decor the properties (name, docstring, etc.) of the original myfunc function.

This should do it, use the function's name, in your case, function.Here is a very nice tutorial that talks about it: http://epydoc.sourceforge.net/docstrings.htmlAnd of course: http://docs.python.org/tutorial/controlflow.html#documentation-stringsEdit: Refer to your edited version of the question, I think you might have to mess with inspect.stack() from this SO question. Ayman Hourieh's answer gives a small example.
for a hard-coded version that works decently with 'well behaved' decorators.It must be declared after function. if function gets rebound later the changes updated here.This is a rather nasty hack, in that it abuses the way default args work. It will used whatever function is bound to at the time this function is 'initialized', and remember it even if the function gets rebound. Calling it with args is going to lead to interesting results. and a dynamic one that still hard coded but does update on function getting called with an argument of True. Basically this version will only update when told to do so.Now of course there are decorator examples to this too.you should read on the decorator decorator (atleast).Look at NamedTuple source (from the collections module) as it involves noting being hard-coded. Sadly the named tuple code is rather weird. It is a string format used with eval rather then traditional code, but it works really neatly. This seems to be the most promising variant.You might be able to do this with metaclasess too, which leads to neat code, but rather nasty stuff hidden behind the scenes, which you need to code. This id advise againstIm suspecting that there probably is an easier way than going into inspection/reflection/templates/metaclasess by simply adding the following line at the end of the module.where  is the name of the module you are working on (a string). Or even the variable  __name__. This could be done in the __init__.py file too if working with multiple modulesor on individual classes too i think.
As noted many times, using the function name inside the function is actually a dynamic lookup in the globals() of the current module. Using any kind of eval() is only a variation from it as its name resolution will work again with the globals() dictionary. Most of the examples will fail with a member function - you need to lookup the class name first from globals() and you can then access the member function from it. So actuallyis equivalent toIn many cases this dynamic lookup will be enough. But actually you have to retype the function name inside the function. However if you write a helper function to find out the caller's doc string then you will face the fact that the helper function might live in a different module with a different globals() dictionary. So the only correct way would be to use the current frame info to find the function - but Python's frame object does not have a reference to the function object, it only carries a reference to the "f_code" code it uses. It needs to search through the referenced "f_globals" dictionary to find the mapping from f_code to the function object, for example like this:It is named get_caller_doc() instead of get_my_doc() because in the vast majority of cases you do want to have the doc string to hand it down as an argument to some helper function. But the helper function can easily get the doc string from its caller - I am using this in my unittest scripts where a helper function can use the doc string of the test to post it into some log or to use it as actual test data. That's why the presented helper only looks for doc strings of test functions and test member functions.It is left to the reader to expand the example for other use cases.
Reference http://stefaanlippens.net/python_inspectOutput:


Answer URL
https://docs.python.org/3/library/functools.html#functools.wraps
