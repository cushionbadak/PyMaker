Natural Text
What is the most basic definition of "iterable", "iterator" and "iteration" in Python?I have read multiple definitions but I am unable to identify the exact meaning as it still won't sink in.Can someone please help me with the 3 definitions in layman terms?
Iteration is a general term for taking each item of something, one after another. Any time you use a loop, explicit or implicit, to go over a group of items, that is iteration.In Python, iterable and iterator have specific meanings.An iterable is an object that has an __iter__ method which returns an iterator, or which defines a __getitem__ method that can take sequential indexes starting from zero (and raises an IndexError when the indexes are no longer valid). So an iterable is an object that you can get an iterator from.An iterator is an object with a next (Python 2) or __next__ (Python 3) method. Whenever you use a for loop, or map, or a list comprehension, etc. in Python, the next method is called automatically to get each item from the iterator, thus going through the process of iteration.A good place to start learning would be the iterators section of the tutorial and the iterator types section of the standard types page. After you understand the basics, try the iterators section of the Functional Programming HOWTO.
Here's the explanation I use in teaching Python classes:An ITERABLE is:anything that can be looped over (i.e. you can loop over a string or file) oranything that can appear on the right-side of a for-loop:   for x in iterable: ... oranything you can call with iter() that will return an ITERATOR:  iter(obj) oran object that defines __iter__ that returns a fresh ITERATOR,or it may have a __getitem__ method suitable for indexed lookup.An ITERATOR is an object:with state that remembers where it is during iteration,with a __next__ method that:returns the next value in the iterationupdates the state to point at the next valuesignals when it is done by raising StopIterationand that is self-iterable (meaning that it has an __iter__ method that returns self).Notes:The __next__ method in Python 3 is spelt next in Python 2, andThe builtin function next() calls that method on the object passed to it.For example:
The above answers are great, but as most of what I've seen, don't stress the distinction enough for people like me.Also, people tend to get "too Pythonic" by putting definitions like "X is an object that has __foo__() method" before.  Such definitions are correct--they are based on duck-typing philosophy, but the focus on methods tends to get between when trying to understand the concept in its simplicity.So I add my version.In natural language,iteration is the process of taking one element at a time in a row of elements.In Python,iterable is an object that is, well, iterable, which simply put, means thatit can be used in iteration, e.g. with a for loop.  How?  By using iterator.I'll explain below.... while iterator is an object that defines how to actually do theiteration--specifically what is the next element.  That's why it must havenext() method. Iterators are themselves also iterable, with the distinction that their __iter__() method returns the same object (self), regardless of whether or not its items have been consumed by previous calls to next().So what does Python interpreter think when it sees for x in obj: statement?Look, a for loop.   Looks like a job for an iterator...  Let's get one. ...  There's this obj guy, so let's ask him."Mr. obj, do you have your iterator?" (... calls iter(obj), which calls  obj.__iter__(), which happily hands out a shiny new iterator _i.) OK, that was easy... Let's start iterating then. (x = _i.next() ... x = _i.next()...)Since Mr. obj succeeded in this test (by having certain method returning a valid iterator), we reward him with adjective: you can now call him "iterable Mr. obj".However, in simple cases, you don't normally benefit from having iterator and iterable separately.  So you define only one object, which is also its own iterator.  (Python does not really care that _i handed out by obj wasn't all that shiny, but just the obj itself.) This is why in most examples I've seen (and what had been confusing me over and over),you can see:instead ofThere are cases, though, when you can benefit from having iterator separated from the iterable, such as when you want to have one row of items, but more "cursors".  For example when you want to work with "current" and "forthcoming" elements, you can have separate iterators for both.  Or multiple threads pulling from a huge list: each can have its own iterator to traverse over all items. See @Raymond's and @glglgl's answers above.Imagine what you could do:Notes: I'll repeat again: iterator is not iterable.  Iterator cannot be used asa "source" in for loop.  What for loop primarily needs is __iter__()(that returns something with next()).Of course, for is not the only iteration loop, so above applies to some otherconstructs as well (while...).Iterator's next() can throw StopIteration to stop iteration.  Does not have to,though, it can iterate forever or use other means.In the above "thought process", _i does not really exist.  I've made up that name.There's a small change in Python 3.x: next() method (not the built-in) nowmust be called __next__().  Yes, it should have been like that all along.You can also think of it like this: iterable has the data, iterator pulls the nextitemDisclaimer: I'm not a developer of any Python interpreter, so I don't really know what the interpreter "thinks".  The musings above are solely demonstration of how I understand the topic from other explanations, experiments and real-life experience of a Python newbie.
An iterable is a object which has a __iter__() method. It can possibly iterated over several times, such as list()s and tuple()s.An iterator is the object which iterates. It is returned by an __iter__() method, returns itself via its own __iter__() method and has a next() method (__next__() in 3.x).Iteration is the process of calling this next() resp. __next__() until it raises StopIteration.Example:
I don’t know if it helps anybody but I always like to visualize concepts in my head to better understand them. So as I have a little son I visualize iterable/iterator concept with bricks and white paper.Suppose we are in the dark room and on the floor we have bricks for my son. Bricks of different size, color, does not matter now. Suppose we have 5 bricks like those. Those 5 bricks can be described as an object – let’s say bricks kit. We can do many things with this bricks kit – can take one and then take second and then third, can change places of bricks, put first brick above the second. We can do many sorts of things with those. Therefore this bricks kit is an iterable object or sequence as we can go through each brick and do something with it. We can only do it like my little son – we can play with one brick at a time. So again I imagine myself this bricks kit to be an iterable.Now remember that we are in the dark room. Or almost dark. The thing is that we don’t clearly see those bricks, what color they are, what shape etc. So even if we want to do something with them – aka iterate through them – we don’t really know what and how because it is too dark.What we can do is near to first brick – as element of a bricks kit – we can put a piece of white fluorescent paper in order for us to see where the first brick-element is. And each time we take a brick from a kit, we replace the white piece of paper to a next brick in order to be able to see that in the dark room. This white piece of paper is nothing more than an iterator. It is an object as well. But an object with what we can work and play with elements of our iterable object – bricks kit.That by the way explains my early mistake when I tried the following in an IDLE and got a TypeError:List X here was our bricks kit but NOT a white piece of paper. I needed to find an iterator first:Don’t know if it helps, but it helped me. If someone could confirm/correct visualization of the concept, I would be grateful. It would help me to learn more.
Here's my cheat sheet:Quiz: Do you see how...every iterator is an iterable?a container object's __iter__() method can be implemented as a generator?an iterable plus a __next__ method is not necessarily an iterator?
I don't think that you can get it much simpler than the documentation, however I'll try:Iterable is something that can be iterated over. In practice it usually means a sequence e.g. something that has a beginning and an end and some way to go through all the items  in it.You can think Iterator as a helper pseudo-method (or pseudo-attribute) that gives (or holds) the next (or first) item in the iterable. (In practice it is just an object that defines the method next())Iteration is probably best explained by the Merriam-Webster definition of the word :b : the repetition of a sequence of computer instructions a specified  number of times or until a condition is met — compare recursion
Iterable:- something that is iterable is iterable; like sequences like lists ,strings etc.  Also it has either the __getItem__() method or an iter() function which returns an iterator.  Iterator:- When we get iterator object from the iter() method of iterable; we call __next__() method (in python3) or simply next() (in python2) to get elements one by one. This class or instance of this class is called an iterator.From docs:-The use of iterators pervades and unifies Python. Behind the scenes, the for statement calls iter() on the container object. The function returns an iterator object that defines the method __next__() which accesses elements in the container one at a time. When there are no more elements, __next__() raises a StopIteration exception which tells the for loop to terminate. You can call the __next__() method using the next() built-in function; this example shows how it all works:Ex of a class:- 
so,iterable is an object that can be looped over. e.g. list , string , tuple etc.using the iter function on our iterable object will return an iterator object.now this iterator object has method named __next__ (in Python 3, or just next in Python 2) by which you can access each element of iterable.so,     OUTPUT OF ABOVE CODE WILL BE:12
Before dealing with the  iterables and iterator the major factor that decide the iterable and iterator is sequenceSequence:Sequence is the collection of dataIterable:Iterable are the sequence type object that support Iter method.Iter method:Iter method take sequence as an input and create an object which is known as iteratorIterator:Iterator are the object which call next method and transverse through the sequence.On calling the next method it returns the object that it transversed currently.example:x is a sequence which consists of collection of dataOn calling iter(x) it returns a iterator only when the x object has iter method otherwise it raise an exception.If it returns iterator then y is assign like this:As y is a iterator hence it support next() methodOn calling next method it returns the individual elements of the list one by one.After returning the last element of the sequence if we again call the next method it raise an StopIteration errorexample:
Iterables have a __iter__ method that instantiates a new iterator every time.  Iterators implement a __next__ method that returns individual items, and a __iter__ method that returns self .   Therefore, iterators are also iterable, but iterables are not iterators.  Luciano Ramalho, Fluent Python.
In Python everything is an object. When an object is said to be iterable, it means that you can step through (i.e. iterate) the object as a collection.Arrays for example are iterable. You can step through them with a for loop, and go from index 0 to index n, n being the length of the array object minus 1.Dictionaries (pairs of key/value, also called associative arrays) are also iterable. You can step through their keys.Obviously the objects which are not collections are not iterable. A bool object for example only have one value, True or False. It is not iterable (it wouldn't make sense that it's an iterable object).Read more. http://www.lepus.org.uk/ref/companion/Iterator.xml


Answer URL
https://docs.python.org/3/tutorial/classes.html#iterators
https://docs.python.org/3/library/stdtypes.html#iterator-types
