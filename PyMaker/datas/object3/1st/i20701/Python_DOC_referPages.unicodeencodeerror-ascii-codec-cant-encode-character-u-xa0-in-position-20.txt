Natural Text
I'm having problems dealing with unicode characters from text fetched from different web pages (on different sites). I am using BeautifulSoup. The problem is that the error is not always reproducible; it sometimes works with some pages, and sometimes, it barfs by throwing a UnicodeEncodeError. I have tried just about everything I can think of, and yet I have not found anything that works consistently without throwing some kind of Unicode-related error.One of the sections of code that is causing problems is shown below:Here is a stack trace produced on SOME strings when the snippet above is run:I suspect that this is because some pages (or more specifically, pages from some of the sites) may be encoded, whilst others may be unencoded. All the sites are based in the UK and provide data meant for UK consumption - so there are no issues relating to internalization or dealing with text written in anything other than English.Does anyone have any ideas as to how to solve this so that I can CONSISTENTLY fix this problem?
You need to read the Python Unicode HOWTO. This error is the very first example.Basically, stop using str to convert from unicode to encoded text / bytes.Instead, properly use .encode() to encode the string:or work entirely in unicode.
This is a classic python unicode pain point! Consider the following:All good so far, but if we call str(a), let's see what happens:Oh dip, that's not gonna do anyone any good! To fix the error, encode the bytes explicitly with .encode and tell python what codec to use:Voil\u00E0!The issue is that when you call str(), python uses the default character encoding to try and encode the bytes you gave it, which in your case are sometimes representations of unicode characters. To fix the problem, you have to tell python how to deal with the string you give it by using .encode('whatever_unicode'). Most of the time, you should be fine using utf-8.For an excellent exposition on this topic, see Ned Batchelder's PyCon talk here: http://nedbatchelder.com/text/unipain.html
I found elegant work around for me to remove symbols and continue to keep string as string in follows:It's important to notice that using the ignore option is dangerous because it silently drops any unicode(and internationalization) support from the code that uses it, as seen here (convert unicode):
well i tried everything but it did not help, after googling around i figured the following and it helped.python 2.7 is in use.
A subtle problem causing even print to fail is having your environment variables set wrong, eg. here LC_ALL set to "C".  In Debian they discourage setting it: Debian wiki on Locale
I've actually found that in most of my cases, just stripping out those characters is much simpler:
For me, what worked was:Hope this helps someone.
Try this might solve,
Add line below at the beginning of your script ( or as second line):That's definition of python source code encoding. More info in PEP 263.
The problem is that you're trying to print a unicode character, but your terminal doesn't support it.You can try installing language-pack-en package to fix that:which provides English translation data updates for all supported packages (including Python). Install different language package if necessary (depending which characters you're trying to print).On some Linux distributions it's required in order to make sure that the default English locales are set-up properly (so unicode characters can be handled by shell/terminal). Sometimes it's easier to install it, than configuring it manually.Then when writing the code, make sure you use the right encoding in your code.For example:If you've still a problem, double check your system configuration, such as:Your locale file (/etc/default/locale), which should have e.g.or:Value of LANG/LC_CTYPE in shell.Check which locale your shell supports by:Demonstrating the problem and solution in fresh VM.Initialize and provision the VM (e.g. using vagrant):See: available Ubuntu boxes..Printing unicode characters (such as trade mark sign like ™): Now installing language-pack-en:Now problem should be solved:Otherwise, try the following command:
Here's a rehashing of some other so-called "cop out" answers.  There are situations in which simply throwing away the troublesome characters/strings is a good solution, despite the protests voiced here.  Testing it:Results:Suggestion: you might want to name this function to toAscii instead?  That's a matter of preference. 
I always put the code below in the first two lines of the python files:
Simple helper functions found here.
In shell:Find supported UTF-8 locale by the following command:Export it, before running the script, e.g.:or manually like:Test it by printing special character, e.g. ™:Above tested in Ubuntu.
Just add to a variable encode('utf-8')
I just used the following:Check what documentation says about it:unicodedata.normalize(form, unistr) Return the normal form form for  the Unicode string unistr. Valid values for form are ‘NFC’, ‘NFKC’,  ‘NFD’, and ‘NFKD’.The Unicode standard defines various normalization forms of a Unicode  string, based on the definition of canonical equivalence and  compatibility equivalence. In Unicode, several characters can be  expressed in various way. For example, the character U+00C7 (LATIN  CAPITAL LETTER C WITH CEDILLA) can also be expressed as the sequence  U+0043 (LATIN CAPITAL LETTER C) U+0327 (COMBINING CEDILLA).For each character, there are two normal forms: normal form C and  normal form D. Normal form D (NFD) is also known as canonical  decomposition, and translates each character into its decomposed form.  Normal form C (NFC) first applies a canonical decomposition, then  composes pre-combined characters again.In addition to these two forms, there are two additional normal forms  based on compatibility equivalence. In Unicode, certain characters are  supported which normally would be unified with other characters. For  example, U+2160 (ROMAN NUMERAL ONE) is really the same thing as U+0049  (LATIN CAPITAL LETTER I). However, it is supported in Unicode for  compatibility with existing character sets (e.g. gb2312).The normal form KD (NFKD) will apply the compatibility decomposition,  i.e. replace all compatibility characters with their equivalents. The  normal form KC (NFKC) first applies the compatibility decomposition,  followed by the canonical composition.Even if two unicode strings are normalized and look the same to a  human reader, if one has combining characters and the other doesn’t,  they may not compare equal.Solves it for me. Simple and easy.
Below solution worked for me, Just added u "String"(representing the string as unicode) before my string.
We struck this error when running manage.py migrate in Django with localized fixtures.Our source contained the # -*- coding: utf-8 -*- declaration, MySQL was correctly configured for utf8 and Ubuntu had the appropriate language pack and values in /etc/default/locale.The issue was simply that the Django container (we use docker) was missing the LANG env var.Setting LANG to en_US.UTF-8 and restarting the container before re-running migrations fixed the problem.
I just had this problem, and Google led me here, so just to add to the general solutions here, this is what worked for me:I had this idea after reading Ned's presentation.I don't claim to fully understand why this works, though. So if anyone can edit this answer or put in a comment to explain, I'll appreciate it.
If you have something like packet_data = "This is data" then do this on the next line, right after initializing packet_data:
Please open terminal and fire the below command:
Update for python 3.0 and later. Try the following in the python editor:This sets the system`s default locale encoding to the UTF-8 format.More can be read here at PEP 538 -- Coercing the legacy C locale to a UTF-8 based locale.
Many answers here (@agf and @Andbdrew for example) have already addressed the most immediate aspects of the OP question.However, I think there is one subtle but important aspect that has been largely ignored and that matters dearly for everyone who like me ended up here while trying to make sense of encodings in Python: Python 2 vs Python 3 management of character representation  is wildly different. I feel like a big chunk of confusion out there has to do with people reading about encodings in Python without being version aware. I suggest anyone interested in understanding the root cause of OP problem to begin by reading Spolsky's introduction to character representations and Unicode and then move to Batchelder on Unicode in Python 2 and Python 3.
I had this issue trying to output Unicode characters to stdout, but with sys.stdout.write, rather than print (so that I could support output to a different file as well).From BeautifulSoup's own documentation, I solved this with the codecs library:


Answer URL
https://docs.python.org/3/library/imp.html
