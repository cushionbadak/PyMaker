Natural Text
This is a problem that came up when performing a single test that had multiple independent failure modes, due to having multiple output streams.  I also wanted to show the results of asserting the data on all those modes, regardless of which failed first.  Python's unittest has no such feature outside of using a Suite to represent the single test, which was unacceptable since my single test always needed to be run as a single unit; it just doesn't capture the nature of the thing.A practical example is testing an object that also generates a log.  You want to assert the output of it's methods, but you also want to assert the log output.  The two outputs require different tests, which can be neatly expressed as two of the stock asserts expressions, but you also don't want the failure of one to hide the possible failure of the other within the test.  So you really need to test both at the same time.I cobbled together this useful little widget to solve my problem.Which is used like so:The result is that logFailures() will raise an exception that contains a log of all the assertions that were raised in methods within the list.The question: While this does the job, I'm left wondering if there's a better way to handle this, other than having to go to the length of creating nested suites of tests and so forth?
I disagree with the dominant opinion that one should write a test method for each assertion. There are situations where you want to check multiple things in one test method. Here is my answer for how to do it:And here are some situations where I think it's useful and not risky:1) When you want to test code for different sets of data. Here we have an add() function and I want to test it with a few example inputs. To write 3 test methods for the 3 data sets means repeating yourself which is bad. Especially if the call was more elaborate.:2) When you want to check multiple outputs of a function. I want to check each output but I don't want a first failure to mask out the other two.3) Testing things with heavy setup costs. Tests must run quickly or people stop using them. Some tests require a db or network connection that takes a second which would really slow down your test. If you are testing the db connection itself, then you probably need to take the speed hit. But if you are testing something unrelated, we want to do the slow setup once for a whole set of checks.
This feels like over-engineering to me.  Either:Use two asserts in one test case. If the first assert fails, it's true, you won't know whether the second assert passed or not.  But you're going to fix the code anyway, so fix it, and then you'll find out if the second assert passed.Write two tests, one to check each condition.  If you fear duplicated code in the tests, put the bulk of the code in a helper method that you call from the tests.
With using a subtest, execution would not stop after the first failurehttps://docs.python.org/3/library/unittest.html#subtestsHere are example with two fail asserts:Output will be:You can easy wrap subtest as following


Answer URL
https://docs.python.org/3/library/unittest.html#subtests
