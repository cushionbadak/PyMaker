Natural Text
So, I have two very large lists of numbers l1 and l2.  I'd like to multiply each element of l1 with each element of l2 without explictly creating a new list of products.  Thus, I'd like a generator.  This part is easy.  I can just do something likeHowever, I also need these products to be ordered by their magnitude.  I am wondering if there is some clever trick to order the yield statements so that this can also be done with a generator.  In Python 3, if possible.  Thanks.
I'll call the lists xs and ys, and assume they're sorted.  As you noted in a comment, the smallest product is necessarily xs[0] * ys[0] - but only if you're also assuming that all numbers are non-negative, so I'll assume that too.After the first product, it gets messier - else you already would have solved it ;-)  The next two to consider are xs[0] * ys[1] and xs[1] * ys[0].  Easy enough, but then the next to consider depends on which of those won.  If xs[0] * ys[1] won, you only need to replace it with xs[0] * ys[2], but if xs[1] * ys[0] won then both xs[1] * ys[1] and xs[2] * ys[0] come into play.  And so on.The following keeps track of the growing set of possibilities with a heap.  The heap never holds more than len(xs) items, so the code first arranges to make xs the shorter list:I'd be pleasantly surprised if an essentially more efficient solution existed.  If someone thinks they have one, please try it first using this randomized tester:EDIT - THEORETICALLY BETTER IN SOME SENSE ;-)The above doesn't fully exploit the partial ordering we can deduce from indices alone:  ifthen we knowbecause sorting implies xs[i1] <= xs[i2] and ys[j1] <= ys[j2].So, for example, if the index pairs (0, 1) and (1, 0) are on the heap, and the second one wins, (2, 0) needs to be added to the heap but (1, 1) doesn't:  from the indices alone, we know that the product from the (0, 1) remaining in the heap is no larger than the product from (1, 1).  It's only when (0, 1) is also removed that (1, 1) needs to be added.In general, each pair of the form (i, 0) has a single immediate predecessor (i-1, 0), and (0, j) the single (0, j-1), and all other (i, j) have two immediate predecessors:  (i-1, j) and (i, j-1).  There's no need to put a pair on the heap until all its predecessors have been taken off the heap.Which leads to this code, which is seemingly "more elegant" because more symmetric:Compared to the first code, it keeps the heap somewhat smaller in many cases.  But heap operations take time logarithmic in the number of heap entries, and the heap can still grow to len(xs) entries, so that's not much of a win.  It's probably lost to the overhead of the two new function calls (while inlining those is too ugly to bear).
My solution is to create a list of generators, one generator for each row in the product matrix, and then to use heapq.merge to sort the outputs of those generators. Each generator has a size of 44 bytes on a 32 bit machine, so the whole list of generators only consumes a modest amount of RAM. heapq.merge (when no sorting key function is supplied) works by creating a 3-tuple of each of the iterables you pass it. That tuple contains the next value from the iterable, an index number for the iterable, and a reference to the iterable's __next__ method. It places those tuples onto a heap to perform a mergesort of the iterables' values. You can see the details in its Python source code.Thus my approach is not quite as frugal as Tim Peters' solutions, but it's not too shabby, IMHO. ;)Here's some timeit code which shows the running time of sorted_prod_merge, Tim Peters' solutions, plus a few other versions of mine. I've used Tim's variable names to keep the code uniform. It's interesting to note that Tim's 1st version is roughly twice as fast as his more advanced solution. My sorted_prod_row runs quite quickly, but it's a terrible RAM hog.The timeit code uses a technique given in the itertools recipes to exhaust an iterator: we feed it to a zero-length deque. The time_test code sorts the 3 results from each Timer run. That's because the minimum result is the important one, the other values just give an indication of the variance in the system at the time the test ran. See the note in the docs for Timer.repeat for details.Here's the output on my ancient 2GHz 32 bit single core machine, running Python 3.6.0 on an old Debian derivative distro of Linux. YMMV.
It doesn't seem like there is any other way to order these outputs without creating a list, because the outputs cannot be sorted without being stored. Here's how you could do that.Hope that helps.


Answer URL
https://docs.python.org/3/library/heapq.html#heapq.merge
https://docs.python.org/3/library/itertools.html#itertools-recipes
https://docs.python.org/3/library/timeit.html#timeit.Timer.repeat
