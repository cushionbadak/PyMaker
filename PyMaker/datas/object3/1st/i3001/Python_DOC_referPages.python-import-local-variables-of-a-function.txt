Natural Text
I'm trying to make a debugger function, which is called when an error is raised, and let me access a console so I can check what happened in my program.Here is the basic function:The problem is that I can't enter something like print(var) because it's referenced in another function.Globals functions don't help me since I want to be able to call any variable in my program, and I can't globalize them all.. I know I can resolve it by putting all my functions in classes but I can't for many reasons.Is there a way to get local variables of the running functions ? (When I call DEBUGGER(), the mother function is still running)If no, can I export the local variables of the current function and pass it as an argument to DEBUGGER() ? Thanks for your answers.
You are basically re-implementing the Python debugger pdb. If you want to go this route, you probably want to study the source code. pdb itself is a user-interface around the lower-level bdb (basic debugger) module, and the source code for that is also available.To answer your direct question: when you catch an exception you have access to a traceback object (either via exception.__traceback__ or via sys.exc_info()), and tracebacks have access to both the local and global namespace of each frame in the stack, via the tb_frame attribute. That attribute is set to a frame object, which has f_locals and f_globals attributes.The bdb.Bdb.get_stack() method could be an interesting example on how to treat a traceback, and the internal pdb.Pdb._select_frame() method then is used to pick a frame from the stack to use the locals and globals from.If you don't want to re-implement the full debugger, you can use the pdb.pm() or pdb.port_mortem() functions. These take the last traceback raised and let you inspect the stack frame in an interactive environment:
The correct way to "write" your "DEBUGGER" function is:Now you can call DEBUGGER() wherever you want, you will be in an interactive environment with access not only to local vars but also to whole call stack, and the ability to execute the remaining code step by step (including stepping into other functions etc), change the control flow to continue executing from another line etc etc etc.Oh and yes: you can of course just write import pdb; pdb.set_trace() instead ;-)


Answer URL
https://docs.python.org/3/library/pdb.html
https://docs.python.org/3/library/bdb.html
https://docs.python.org/3/reference/datamodel.html#traceback-objects
https://docs.python.org/3/library/sys.html#sys.exc_info
https://docs.python.org/3/reference/datamodel.html#frame-objects
https://docs.python.org/3/library/pdb.html#pdb.pm
https://docs.python.org/3/library/pdb.html#pdb.post_mortem
https://docs.python.org/3/library/traceback.html
https://docs.python.org/3/library/pdb.html
