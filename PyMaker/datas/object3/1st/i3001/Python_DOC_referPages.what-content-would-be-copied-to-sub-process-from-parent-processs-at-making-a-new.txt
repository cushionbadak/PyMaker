Natural Text
Some articles told me that making an new sub process, the operation system will almost copy all data from partent, including process's struct, stack, heap and so on. So, i think the global variables, static variables may be copied to sub process, whose contens are equal to the parent's values at the monment of invoking the fork(). But following python code's result make me confusion:the executing results of above codes:The results i expected:I don't know why the changes of ids in function init() are not copied to sub process, but the changes in global section ids.extend([1, 2, 3, 4]) are visible to sub process.thanks for every reponse.
As explained in the docs, multiprocessing has three different ways of starting processes. The two main ones are fork and spawn.1fork copies your parent process. You were right on the nose about what this does:2 the children start with copies of the parent's globals, and so on.spawn creates a brand new process, starts the Python interpreter, and imports your module.On Unix, fork is the default, but spawn and forkserver are available as options. On Windows, spawn is the default, and the only option, because Windows doesn't provide a fork API.Since you're on Windows, the children don't get a copy of ids from the parent—but the ids = [] and ids.extend(…) code gets run on import, so they all end up with equal values anyway. But any code protected by a __main__ guard doesn't get run by import, so they don't call main, so no init, so no ids.append(-100).The multiprocessing library is designed so you can use it in a way that works the same on all platforms.3 Most of the details are covered pretty well in the Programming guidelines section of the docs, but the basic idea is: Don't assume that globals are copied, or that they aren't copied. This means you generally won't have any code outside a __main__ guard at the top level, except for import, def, and class statements, and maybe a few simple global constant assignments.Any complicated setup you need to do, you do in each child process.4 Anything you want to share between processes (like a Lock, or a Queue), you create inside the __main__ guard and pass to the children as arguments.1. For forkserver, see the docs for details; it's mainly there for programs that use libraries that expect to do fancy things with threads that don't work well with fork, which is a common thing on macOS—although it can be useful in some other cases.2. There are some complexities about things like open files, but they're not important here.3. You could just specify spawn and then treat every platform like Windows. But on some Unix platforms, it can be slow to spawn processes. Also, getting things like shared files to work can be painful on Unix, so it's sometimes easier to write code that works with fork or spawn, than to write code that works with spawn on Unix or spawn on Windows. Using forkserver on Unix and spawn on Windows can, however, be a good compromise/4. If you're using Pools, use an initializer function.


Answer URL
https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods
https://docs.python.org/3/library/multiprocessing.html#programming-guidelines
