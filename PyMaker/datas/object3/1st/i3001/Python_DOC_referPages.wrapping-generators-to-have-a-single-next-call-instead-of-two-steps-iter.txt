Natural Text
I'm receiving an unknown number of records for background processing from generators. If there is a more important job, I have to stop to release the process.The main process is best described as: Is there a way to get to __next__ without having to plug __iter__?Having two steps - (1) make an iterator, then (2) iterate over it, just seems clumsy.There are many cases where I'd prefer to submit a function to a function manager (mapreduce style), but in this case I need an instantiated class with some settings. Registering a single function can therefor only work if that function alone is __next__Q: Is there a simpler way?Working sample added for completeness:
Your UploadWrapper seems overtly complex, there is more than a single simpler solution.My first thought is to ditch the class altogether and just use a function instead:Just replace uw = UploadWrapper(gen) with uw = uploadwrapper(gen), and that'll work.If you insist on the class, you can just get rid of the __next__() and replace uw = UploadWrapper(gen) with uw = iter(UploadWrapper(gen)), and it'll work.In either case, you must also catch the StopIteration in the caller. __next__() is supposed to raise StopIteration when it's done, and not return None, like yours does. Otherwise, it won't work with things expecting a well-behaving iterator, eg. for loops.I think you might have some misconceptions about how it all is supposed to fit together, so I'll try my best to explain how it's supposed to work, to the best of my knowledge:The point of __iter__() is that if you have eg. a list, you can get multiple independent iterators by calling iter(). When you have a for loop, you're essentially first getting an iterator with iter() and then calling next() on it on every loop iteration. If you have two nested loops that use the same list, the iterators and their positions are still separate so there's no conflict. __iter__() is supposed to return an iterator for the container it's on, or if it's called on an iterator, it's supposed to just return self. In that sense, it's kind of wrong for UploadWrapper not to return self in __iter__(), since it wraps a generator and so can't really give independent iterators. As for why leaving out __next__() works, it's because when you define a generator (ie. use yield in a function), the generator has an __iter__() (that returns self, as it should) and __next__() that does what you'd expect. In your original code, you're not really using __iter__() at all for what it's supposed to be used: the code works even if you rename it to something else! This is because you never call iter() on the instance, and just directly call next().If you wanted to do it "properly" as a class, I think something like this might suffice:


Answer URL
https://docs.python.org/3/tutorial/classes.html#iterators
https://docs.python.org/3/library/stdtypes.html#typeiter
https://docs.python.org/3/reference/datamodel.html#object.__iter__
