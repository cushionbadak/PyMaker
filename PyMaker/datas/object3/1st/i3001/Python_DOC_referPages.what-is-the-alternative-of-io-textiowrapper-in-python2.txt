Natural Text
How can I wrap an open binary stream – a Python 2 file, a Python 3 io.BufferedReader, an io.BytesIO – in an io.TextIOWrapper?I'm trying to write code that will work unchanged:Running on Python 2.Running on Python 3.With binary streams generated from the standard library (i.e. I can't control what type they are)With binary streams made to be test doubles (i.e. no file handle, can't re-open).Producing an io.TextIOWrapper that wraps the specified stream.The io.TextIOWrapper is needed because its API is expected by other parts of the standard library. Other file-like types exist, but don't provide the right API.ExampleWrapping the binary stream presented as the subprocess.Popen.stdout attribute:In unit tests, the stream is replaced with an io.BytesIO instance to control its content without touching any subprocesses or filesystems.That works fine on the streams created by Python 3's standard library. The same code, though, fails on streams generated by Python 2:Not a solution: Special treatment for fileAn obvious response is to have a branch in the code which tests whether the stream actually is a Python 2 file object, and handle that differently from io.* objects.That's not an option for well-tested code, because it makes a branch that unit tests – which, in order to run as fast as possible, must not create any real filesystem objects – can't exercise.The unit tests will be providing test doubles, not real file objects. So creating a branch which won't be exercised by those test doubles is defeating the test suite.Not a solution: io.openSome respondents suggest re-opening (e.g. with io.open) the underlying file handle:That works on both Python 3 and Python 2:But of course it relies on re-opening a real file from its file handle. So it fails in unit tests when the test double is an io.BytesIO instance:Not a solution: codecs.getreaderThe standard library also has the codecs module, which provides wrapper features:That's good because it doesn't attempt to re-open the stream. But it fails to provide the io.TextIOWrapper API. Specifically, it doesn't inherit io.IOBase and doesn't have the encoding attribute:So codecs doesn't provide objects which substitute for io.TextIOWrapper.What to do?So how can I write code that works for both Python 2 and Python 3, with both the test doubles and the real objects, which wraps an io.TextIOWrapper around the already-open byte stream?
Use codecs.getreader to produce a wrapper object:Works on Python 2 and Python 3.
It turns out you just need to wrap your io.BytesIO in io.BufferedReader which exists on both Python 2 and Python 3.This answer originally suggested using os.pipe, but the read-side of the pipe would have to be wrapped in io.BufferedReader on Python 2 anyway to work, so this solution is simpler and avoids allocating a pipe.
Based on multiple suggestions in various forums, and experimenting with the standard library to meet the criteria, my current conclusion is this can't be done with the library and types as we currently have them.
Okay, this seems to be a complete solution, for all cases mentioned in the question, tested with Python 2.7 and Python 3.5. The general solution ended up being re-opening the file descriptor, but instead of io.BytesIO you need to use a pipe for your test double so that you have a file descriptor.
I needed this as well, but based on the thread here, I determined that it was not possible using just Python 2's io module.  While this breaks your "Special treatment for file" rule, the technique I went with was to create an extremely thin wrapper for file (code below) that could then be wrapped in an io.BufferedReader, which can in turn be passed to the io.TextIOWrapper constructor.  It will be a pain to unit test, as obviously the new code path can't be tested on Python 3.Incidentally, the reason the results of an open() can be passed directly to io.TextIOWrapper in Python 3 is because a binary-mode open() actually returns an io.BufferedReader instance to begin with (at least on Python 3.4, which is where I was testing at the time).At least this is small, so hopefully it minimizes the exposure for parts that cannot easily be unit tested.
Here's some code that I've tested in both python 2.7 and python 3.6.The key here is that you need to use detach() on your previous stream first. This does not close the underlying file, it just rips out the raw stream object so that it can be reused. detach() will return an object that is wrappable with TextIOWrapper.As an example here, I open a file in binary read mode, do a read on it like that, then I switch to a UTF-8 decoded text stream via io.TextIOWrapper.I saved this example as this-file.pyHere's what I get when I run it with both python2 and python3.Obviously the print syntax is different and as expected the variable types differ between python versions but works like it should in both cases.


Answer URL
https://docs.python.org/3/library/codecs.html#codecs.getreader
