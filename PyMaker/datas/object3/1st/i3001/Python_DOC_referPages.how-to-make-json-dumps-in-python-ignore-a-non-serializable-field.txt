Natural Text
I am trying to serialize the output of parsing some binary data with the Construct2.9 library. I want to serialize the result to JSON.packet is an instance of a Construct class Container.Apparently it contains a hidden _io of type BytesIO - see output of dict(packet) below:Now, calling json.dumps(packet) obviously leads to a TypeError:However what I am confused about, is that running json.dumps(packet, skipkeys=True) results in the exact same error, while I would expect it to skip the _io field. What is the problem here? Why is skipkeys not allowing me to skip the _io field?I got the code to work by overriding JSONEncoder and returning None for fields of BytesIO type, but that means my serialized string contains loads of "_io": null elements, which I would prefer not to have at all...
Keys with a leading _ underscore are not really 'hidden', they are just more strings to JSON. The Construct Container class is just a dictionary with ordering, the _io key is not anything special to that class.You have two options:implement a default hook that just returns a replacement value.Filter out the key-value pairs that you know can't work before serialising.and perhaps a third, but a casual scan of the Construct project pages doesn't tell me if it is available: have Construct output JSON or at least a JSON-compatible dictionary, perhaps by using adapters.The default hook can't prevent the _io key from being added to the output, but would let you at least avoid the error:Filtering can be done recursively; the @functools.singledispatch() decorator can help keep such code clean:I have the above implementation an additional skip_underscore argument too, to explicitly skip keys that have a _ character at the start. This would help skip all additional 'hidden' attributes the Construct library is using.Since Container is a dict subclass, the above code will automatically handle instances such as packet.
skipkeys doesn't do what you might think it does - it instructs the json.JSONEncoder to skip keys that are not of a basic type, not the values of the keys - i.e. if your had a dict {object(): "foobar"} it would skip the object() key, whereas without skipkeys set to True it would raise a TypeError.You can overload JSONEncoder.iterencode() (and its underbelly) and perform look-ahead filtering there, but you'll end up pretty much rewriting the json module, slowing it down in the process as you won't be able to benefit from the compiled parts. What I'd suggest you is to pre-process your data via iterative filtering and skip keys/types you don't want in your final JSON. Then the json module should be able to process it without any additional instructions. Something like:Then create your filter:In this case skipping just by type should suffice, but in case the _io key holds some other undesirable data this guarantees it won't be in the final result. Anyway, you can then just filter the data prior to passing it to the JSONEncoder:Of course, if your structure contains some other exotic data or data that is represented in JSON differently based on its type, this approach might mess it up as it turns all mappings into dict and all sequences into list. However, for general usage this should be more than enough.


Answer URL
https://docs.python.org/3/library/functools.html#functools.singledispatch
https://docs.python.org/3/library/json.html#json.dump
https://docs.python.org/3/library/json.html#json.JSONEncoder
https://docs.python.org/3/library/json.html#json.JSONEncoder.iterencode
