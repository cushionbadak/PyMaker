Natural Text
Today I realized that it matters for unittest.mock.patch how I import a function. Depending on the used way a mock.patch call worked or was ignored. In Python we typically import a function with:an import statement like import os ora from ... import ... statement like from os import systemA mock.patch works like a charm if I use import os, but it was ignored if I patch a from os import system. Example 1: Using importOutput of example 1Example 2: Using a full function import and from-importWhen I fully import os.system the mock.patch ignores the mocked.side_effect.Output of example 2In both cases I don't receive an error and mock could find os.system as a valid path. However, in the second case the function is not properly patched. Why mock.patch does not patch the function in the second example?Are there any implementation specific reasons why the second patch did not work?
When you do from os import system, you get a variable named system pointing to os.system function. Later, you assign, via patching, a different function to os.system, but system keeps to point to the old function. This is the same reason why the following works:It doesn't happen in the first example, because you reference os.system before it is mocked. To fix your second example, I'd go with the following:This way you make sure you patch the right reference. This is a rather common pattern. If echo function were in a file named echo.py, the patch call would look like with mock.patch('echo.system').


Answer URL
https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch.object
