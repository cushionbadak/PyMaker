Natural Text
Thanks everyone for your help so far. I've narrowed it down a bit. If you look at HERE in both the script and the class, and run the script, you'll see what is going on. The ADD line print "789 789"when it should be printing "456 789" What appears to be happening, is in new the class is detecting the type of the incoming argument. However if the incoming object, has the same type as the constructor it appears to be paging the incoming object, into itself (at the class level) instead of returning the old object. That is the only thing I can think of that would cause 456 to get creamed. So how do you detect something that is the same type of a class, within a constructor and decide NOT to page that data into the class memory space, but instead return the previously constructed object? testfoo.py:
How do I, at constructor time, return a non-new object?By overriding the constructor method, __new__, not the initializer method, __init__.The __new__ method constructs an instance—normally by calling the super's __new__, which eventually gets up to object.__new__, which does the actual allocation and other under-the-covers stuff, but you can override that to return a pre-existing value.The __init__ method is handed a value that's already been constructed by __new__, so it's too late for it to not construct that value.Notice that if Foo.__new__ returns a Foo instance (whether a newly-created one or an existing one), Foo.__init__ will be called on it. So, classes that override __new__ to return references to existing objects generally need an idempotent __init__—typically, you just don't override __init__ at all, and do all of your initialization inside __new__.There are lots of examples of trivial __new__ methods out there, but let's show one that actually does a simplified version of what you're asking for:Now:Notice that I made sure to use super rather than object, and cls._instances1 rather than Spam._instances. So:However, it may be a better option to use a classmethod alternate constructor, or even a separate factory function, rather than hiding this inside the __new__ method.For some types—like, say, a simple immutable container like tuple—the user has no reason to care whether tuple(…) returns a new tuple or an existing one, so it makes sense to override the constructor. But for some other types, especially mutable ones, it can lead to confusion. The best test is to ask yourself whether this (or similar) would be confusing to your users:If that can't happen (e.g., because Foo is immutable), override __new__.If that exactly what users would expect (e.g., because Foo is a proxy to some object that has the actual spam, and two proxies to the same object had better see the same spam), probably override __new__.If it would be confusing, probably don't override __new__.For example, with a classmethod:… it's a lot less likely to be surprising if f1 is f2 turns out to be true.1. Even though you define __new__ like an instance method, and its body looks like a class method, it's actually a static method, that gets passed the class you're trying to construct (which will be Spam or a subclass of Spam) as an ordinary first parameter, with the constructor arguments (and keyword arguments) passed after that.
Thanks everyone who helped! This answer was saught out to understand how to refactor an existing program that was already written, but that was having scalability problems. The following is the completed working example. What it demonstrates is: The ability to test incoming types and avoid unneccessary object duplication at constructor time, given incoming types that are both user-defined and built-in. The ability to construct on the fly from a redefined operator or method. These capabilities are neccessary for writing scalable supportable API code. YMMV.Foo.pytestfoo.py


Answer URL
https://docs.python.org/3/reference/datamodel.html#basic-customization
