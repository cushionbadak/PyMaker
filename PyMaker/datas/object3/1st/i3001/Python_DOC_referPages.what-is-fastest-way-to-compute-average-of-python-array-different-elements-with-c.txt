Natural Text
The Python code below executes in about 2 sec. An equivalent code in C executes in 6 ms.Some explanations: I have serial data of 2 ADC channels (adc0, adc1, adc0, adc1, ...).If adc1 <= 10 I must add adc1 to the sum, else I must add adc0. These values are multiplied by different coefficients (0.1 and 0.01).What is fastest way to do this with built-in functions or numpy?
Firstly you need to fix your average calc (operator precedence):You can do this in numpy, e.g.:
There are many ways to speed it up. Here is a solution using pandas (maybe that can also be done using just numpy).In this code, f1() is your original function and f2() is using pandas.This code shows that f2() is faster, using about 123 ms (less than 10% of the time of f1()).Obs: I assume that the difference of sum and avg between the two functions originates in how the float precision is handled, but I don't know for sure.How many decimal places do you need to consider for your use case? Does this small difference matter?


Answer URL
https://docs.python.org/3/library/time.html#time.clock
https://docs.python.org/3/library/time.html#time.perf_counter
https://docs.python.org/3/library/timeit.html
