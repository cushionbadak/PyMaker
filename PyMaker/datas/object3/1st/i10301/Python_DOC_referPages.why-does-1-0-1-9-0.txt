Natural Text
This question already has an answer here:Integer division compared to floored quotient: why this surprising result?                    1 answer                In Python 2.7 and 3.x, why does integer division give me a non-correct number when dividing by a number 0 < x < 1?Negative numbers -1 < x < 0 even work correctly:I understand that integer division with a negative (or positive) number rounds toward negative infinity, however I would have thought 1//.1 should result in 10.0 since 1 can be divided by .1 without remainder.
What you’re seeing here is essentially the effect of the difference between “normal” division using / and flooring division with //.What’s also always important to keep in mind is the general issue with floating point arithmetic which is a certain imprecision just because of how they work. In those situations, it’s always good to use the decimal module to check what’s actually going on. So let’s look at what you are doing here:First of all, .1 is already not precise:So, let’s look at the actual result of the divisions:As you can see, the normal division using / does not exactly give you 10 with floating point arithmetic. But it’s really close. That’s why, when you use normal floats, you actually get back 10 (since the division imprecision is immediately lost in the imprecision of the number type).When using flooring division, the result is floored before the imprecision is corrected, so that’s why you get 9:With negative numbers, the flooring effect is the opposite direction, as explained in that other question:


Answer URL
https://docs.python.org/3/library/decimal.html
