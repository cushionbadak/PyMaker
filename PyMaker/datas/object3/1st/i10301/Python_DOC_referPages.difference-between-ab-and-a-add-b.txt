Natural Text
I am currently trying to understand where the difference between using a+b and a.__add__(b) is when it comes to custom classes. There are numerous websites that say that using the '+'-operator results in using the special method __add__ - which is fine so far.But when i run the following example I get two different results.Result:Now from what I understood, when executing 1+c Python checks/executes the int __add__ method - finds that there is no implementation for adding int and C objects - returns NotImplemented - which lets Python know to check object C for __radd__ and executes the code within.Why does 1+c result in executing the __radd__ code but the other two version are just returning NotImplemented without checking __radd__ ??
a+b is equivalent to import operator; operator.add(a,b). It starts by calling a.__add__(b) and then, if necessary, b.__radd__(a). But ifsubclass(type(b), type(a)), then b.__radd__(a) is called first.Based on the docs on "special" methods:Regarding __add__():__add__() is called to implement the binary arithmetic "+" operation. For instance, to evaluate the expression x + y, where x is an instance of a class that has an __add__() method, x.__add__(y) is called. If one of those methods does not support the operation with the supplied arguments, it should return NotImplemented.Regarding __radd__():These functions are only called if the left operand does not support the corresponding operation and the operands are of different types. For instance, to evaluate the expression x + y, where y is an instance of a class that has an __radd__() method, y.__radd__(x) is called if x.__add__(y) returns NotImplemented.If the right operand’s type is a subclass of the left operand’s type and that subclass provides the reflected method for the operation, this method will be called before the left operand’s non-reflected method. This behavior allows subclasses to override their ancestors’ operations.Explanation with the examples based on the behaviour:Case 1:These functions radd are only called if the left operand does not support the corresponding operation and the operands are of different types. In this case, 1 does not support addition of the class hence, it falls back to the __radd__() function of the C class. In case __radd__ was not implement in C() class, it would have fallen back to __add__()Case2:1 .__add__(c) gives NotImplemented as 1 is of int type and add of int class do not supports add with C class object. But c .__add(1) run because C() class supports that.Case 3:Similar to case 2. But here, the call is made via class with first argument as object of that class. Behaviour would be same.Case 4: Vice-versa of case 3. As is cleared from the stack-trace, __add__ expected the object of the calling class as the first argument, failing which resulted in exception.


Answer URL
https://docs.python.org/3/reference/datamodel.html#special-method-names
https://docs.python.org/3/reference/datamodel.html#object.__add__
https://docs.python.org/3/reference/datamodel.html#object.__radd__
