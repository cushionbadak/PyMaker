Natural Text
This question already has an answer here:Why does the floating-point value of 4*0.1 look nice in Python 3 but 3*0.1 doesn't?                    4 answers                I am newbie to python.I have one surprise result after executing following mathematical operation:= 3.3000000000000003then 4 / (2.0 + 3) =  should be 0.80000000000000004 as per above operation.but python return 0.8.i am not understanding why this difference is?i am using Python 2.7.6 Please see attached image.i know that if i use print (1/3.0) then it will give 3.30My question are1. why all digits of second operation is not displayed but all digit of first one's displayed?how can we compare floating variables those values are dynamic for accurate result?
Python uses a minimalist repr for floats when possible. That is, it prints a value that is as precise as necessary to reproduce the exact value of the original float if you typed it in directly.For 1.1 + 2.2, the imprecision means it doesn't actually produce 3.3 precisely (1.1 + 2.2 == 3.3 will evaluate to False). By contrast, 4 / (2.0 + 3) is exact enough that 0.8 represents it precisely, (4 / (2.0 + 3) == 0.8 evaluates to True) so it doesn't include a whole bunch of 0s that aren't required to reproduce the value.If you want to explicitly print a certain number of places after the decimal, use str formatting to specify, e.g.:If you formatted it with additional digits, you'd see the 4, but that value is still exactly the same as 0.8; 0.80000000000000004 == 0.8 evaluates to True, so Python avoids the verbosity and just gives you shortest of many equivalent representations.The What's new in Python 3.1 docs (scroll to end of linked section, just before "New, Improved and Deprecated Modules") are a useful explanation for why/when Python 2.7/3.1+ have much shorter float reprs for some values. Straight from the horse's mouth, so to speak.


Answer URL
https://docs.python.org/3/whatsnew/3.1.html#other-language-changes
