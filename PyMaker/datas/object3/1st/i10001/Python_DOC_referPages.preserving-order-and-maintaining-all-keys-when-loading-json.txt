Natural Text
Using the approach described here, I pass OrderedDict as object_pairs_hook when loading a nested JSON file, to preserve order.Order is preserved, and this is fine for most of the JSON object. But there are parts of the JSON (at the lowest level of nesting), which look like:"In Content" : {    "Sulvo" : "abc.com_336x280_he-inlinecontentmobile",    "Sulvo" : "abc.com_336x280_he-inlinecontentmobile_level2",    "Sulvo" : "abc.com_336x280_he-inlinecontentmobile_level3",    "Adsense" : ""  },And when processed, only one of these identical keys gets preserved:OrderedDict([(u'Sulvo', u'homeepiphany.com_336x280_he-inlinecontentmobile_level3'),(u'Adsense', u'')])),I know that we can have a dictionary which has multiple items of the same key name with a defaultdict. The following doesn't work though, and even it it did, I presume we would gain the keys but lose the order, so we'd be no better off:j = json.load(open('he.json'), object_pairs_hook=defaultdict)Is it possible to maintain order AND preserve all keys in one go?Python 2.7.12
If you look at the docs for json.load, they outline what the object_pairs_hook parameter does:object_pairs_hook is an optional function that will be called with the result of any object literal decoded with an ordered list of pairs. The return value of object_pairs_hook will be used instead of the dict.All you need to do is write a function that, given a list of (key, value) pairs, constructs your object.One approach would be to do nothing and just pass the items list straight through without constructing a dictionary:Then, your JSON is parsed like so:If you do want to merge the values of duplicate keys into a list, you can use OrderedDict:Then, you'd object would be parsed as:


Answer URL
https://docs.python.org/3/library/json.html#json.load
