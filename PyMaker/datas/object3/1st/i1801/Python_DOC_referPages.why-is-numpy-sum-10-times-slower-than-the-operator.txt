Natural Text
I noticed that very straingely, np.sum is 10x slower than a hand written sum.np.sum with axis:186 µs ± 4.21 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)np.sum without axis:17.9 µs ± 236 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)+:15.8 µs ± 328 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)Multiplication:15.7 µs ± 701 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)I don't see any reason for this. Any idea why? My numpy version is 1.15.3.EDIT: with 10000000:So I guess there is some overhead playing around, to some extent...
The main difference is larger overhead when a.sum(axis=1) is calculated. Calculating a reduction (in this case sum) is not a trivial matter:one has to take the round-off errors into account and thus uses pairwise summation to reduce it.tiling is important for bigger arrays, as it makes the most out of the available cacheIn order to be able to use the SIMD-instructions/out-of-order execution abilities of modern CPUs one should calculate multiple rows in parallelI have discussed the topics above in more details for example here and here.However, all this is not needed and not better than a naive summation if there are only two elements to add - you get the same result but with much less overhead and faster.For only 1000 elements, the overhead of calling numpy functionality is probably higher than actually doing these 1000 additions (or multiplications for that matter, because on modern CPUs pipelined additions/multiplications have the same cost) -as you can see, that for 10^4 the running time is only about 2 times higher, a sure sign that overhead plays a bigger role for 10^3! In this answer the impact of overhead and cache misses is investigated in more details.Let's take a look at profiler-result to see whether the theory above holds (I use perf):For a.sum(axis=1):The overhead of using reduce_loop, pairwise_sum_DOUBLE is dominating.For a[:,0]+a[:,1]):As expected: Python overhead plays a big role, a simple DOUBLE_add is used.There are less overhead when calling a.sum()for once,  reduce_loop isn't called for every row but only once, which means considerable less overhead.no new resulting arrays are created, there is no longer need to write 1000 doubles to the memory.so it can be expected, that a.sum() is faster (despite the fact, that 2000 and not 1000 addition must be made - but as we have seen it is mostly about overhead and the actual work - the additions aren't responsible for the big share of the running time).Data obtaining by running:and 
Well for .sum() with axis vs without, with the axis has to generate an array of floats as long as your input, with an element for each row.  This means that it has to call reduce() 10,000 times along axis=1.  Without the axis argument it calculates the sum of every element into a single float, which is just one call to reduce through the flat representation of the array.I'm not sure why the manual add function is faster, and I don't feel like digging through the source code but I think I have a pretty good guess.  I believe that that the overhead comes from it having to perform reduce across axis=1 for each row, so 10,000 separate calls to reduce.  In the manual add function, the axis split is performed just a single time when defining the parameters of the "+" function, and then each element of the split columns can be added together in parallel.


Answer URL
https://docs.python.org/3/library/functools.html#functools.reduce
