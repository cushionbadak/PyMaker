Natural Text
In the above dictionaries all the values are the preferences for the key. Just like in matching problem https://www.cs.princeton.edu/~wayne/kleinberg-tardos/pdf/01StableMatching.pdf. I am trying to get all the possible combinations of preferences here without getting a memory error. Also I am putting every combination I get into gale-shapley algorithm to get all the possible matching. My code is below:From the above code I am getting the memory error. Is there any other way to do it? My suggestion is to get one combination at a time and plug it into the gale-shapley function and get the matching. Then append the matching in a dictionary. If the new matching is same as the last one we can delete the new matching to save the memory in the array. But it is still will be 278 million calculations. Do you guys have any efficient way to do it so i can run it on my computer with 16 GB of RAM?
GivenA helper functionCodeDemosYield all combinations based on preferences:Specify top preferred picks:Here only combinations of the number 1 choices are given.  You could select the top 2 choices by setting top=2.DetailsNaive approach (without preferences) using the itertools grouper recipe:Thus, the combinations with preferences is some subset of these combinations.  To select this subset, let's look at the preferences per floor grouped by top 1-5 choices:The top choices per floor are ordered from left to right, e.g. index 0 of each value in the dict indicates applicants that select that floor as their number 1 preference. Index 2 indicates their number 2 preference, etc.  Some floors have applicants with tied preferences (yoder3 and kartz3, at index [0]).  Some floors have no preferences (miller3 at [0]).  The rest of the logic in preferred_assignments(), i.e. variables a-e, make combinations of applicants based on preferences (think vertical columns).  Missing values are randomly substituted from the remaining pool of applicants.In the demo, since these combinations are grouped based on preferences, we flatten the combinations with itertools.chain.from_iterable() and cast to a set to remove any duplicates.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools-recipes
