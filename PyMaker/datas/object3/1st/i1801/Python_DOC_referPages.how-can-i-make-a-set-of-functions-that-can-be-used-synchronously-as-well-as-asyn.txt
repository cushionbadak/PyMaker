Natural Text
Imagine I have a set of functions like this:I want these to be usable synchronously:as well as asynchronously, for example like this:The problem is, of course, that func1 somehow has to propagate the "context" it's running in (synchronously vs. asynchronously) to func2.I want to avoid writing an asynchronous variant of each of my functions because that would result in a lot of duplicate code:Is there any way to do this without having to implement an asynchronous copy of all my functions?
Here's my "not-an-answer-answer," which I know that Stack Overflow loves...Is there any way to do this without having to implement an asynchronous copy of all my functions?I don't think that there is.  Making a "blanket translator" to convert functions to native coroutines seems next-to-impossible.   That's because making a synchronous function asynchronous is about more than throwing an async keyword in front of it and a couple of await statements within it.  Keep in mind that anything that you await must be awaitable.Your def func2(): time.sleep(1) illustrates that point.  Synchronous functions will make blocking calls, such as time.sleep(); asynchronous (native coroutines) will await non-blocking coroutines.  Making this function asynchronous, as you point out, requires not just using async def func(), but awaiting asyncio.sleep().  Now let's say instead of time.sleep(), you're calling a more complex, blocking function.  You build some sort of fancy decorator that slaps a function attribute called run_async, which is a callable, onto the decorated function.  But how does that decorator know how to "translate" the blocking calls within func2() into their coroutine equivalents, if those are even defined?  I can't think of any magic that would be smart enough to convert all of the calls in a synchronous function to their awaitable counterparts.In your comments, you mention that this is for HTTP requests.  For a real-world example the differences in call signatures and APIs between the requests and aiohttp packages.  In aiohttp, .text() is an instance method; in requests, .text is a property.  How could you build something smart enough to know differences such as that?I don't mean to be discouraging--but I think that using threading would be more realistic.
So I found a way to achieve this, but since this is literally the first time I've done anything with async I can't guarantee that this doesn't have any bugs or that it's not a terrible idea.The concept is actually pretty simple: Define your functions like normal asynchronous functions using async def and await where necessary, and then add a wrapper around them that automatically awaits the function if no event loop is running. Proof of concept:However, this approach does have its limitations. If you have a synchronous function calling a hybrid function, calling the synchronous function from an asynchronous function will change its behavior:Take care to account for this!


Answer URL
https://docs.python.org/3/glossary.html#term-awaitable
https://docs.python.org/3/library/asyncio-task.html#generator-based-coroutines
https://docs.python.org/3/library/select.html
