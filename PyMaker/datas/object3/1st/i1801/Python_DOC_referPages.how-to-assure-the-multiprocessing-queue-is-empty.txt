Natural Text
The code below first starts multiple processes. Then it runs a while True loop checking the queue objects. Lastly, it iterates the processes to check if any alive. After all the processes are completed it breaks the while loop.Unfortunately, it happens while the queue object is not empty. Breaking the loop without getting a data stored in queue could be an easy to oversee data loss. How to modify the code logic so it assures the queue object is empty before breaking the loop?
synchronization issue, again. when you check a queue find it is empty, there is no guarantee that no new item would come in the future.you could put a sentinel to the queue when a subprocess finishes its job, to notify there will be no more items in the queue. parent process could drain the queue until got the sentinel. this is also the method used by multiprocessing.Pool. you could use None as sentinel here:
A working solution is posted below. Instead of running the procs with the Process.run this approach uses multiprocessing.pool.ThreadPool.map_async method that starts the processes without blocking. multiprocessing.Queue object is then used to store data which is accessible by foo function running by the MainProcess.



Answer URL
https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing.pool
https://docs.python.org/3/library/concurrent.futures.html#processpoolexecutor
https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue.cancel_join_thread
