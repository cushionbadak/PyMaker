Natural Text
I'm trying to convert C function for python 3.6 use.  code as below:  function definition:  But different OSes with the same code seems to have different result:On Windows 7 64 bitOn Windows 10 64 bitI don't print "handle is here"What I've tried:According to some answers on stack overflow, this may be caused by not assigning function argtypes and restype explicitly, so I tried and failed.
In 99% of the cases, inconsistencies between arguments (and / or return) type inconsistencies are the cause ([SO]: Python ctypes cdll.LoadLibrary, instantiate an object, execute its method, private variable address truncated (@CristiFati's answer) is one such example).Always have [Python 3]: ctypes - A foreign function library for Python open when working with ctypes.I found [GitHub]: erikssm/futronics-fingerprint-reader - (master) futronics-fingerprint-reader/ftrScanAPI.h (I don't know how different it's from what you currently have, but things you posted so far seem to match), and I did some changes to your code:Define argtypes and restype for functionsDefine missing types (for clarity only)Some other insignificant changes (renames)One other thing that I noticed in the above file, is a #pragma pack(push, 1) macro (check [MSDN]: pack for more details). For this structure it makes no difference (thanks @AnttiHaapala for the hint), as the 3 int (4 byte) members alignment doesn't change, but for other structures (with "smaller" member types (e.g. char, short)) you might want to add: _pack_ = 1Your modified code (needless to say, I didn't run it as I don't have the .dll):
The problem seems to simply be that the device handle is a 64-bit entity (a typedef'd pointer to void). That it works in your Windows 7 was just a fluke, as the upper 33 bits of the handle were correctly zero. The return type of all functions in ctypes defaults to 32-bit int. Now in Windows 10 it seems that the 32th bit (sign bit) was set, which causes a sign extension somewhere when the handle-coerced-to-int is pushed on the 64-bit stack for function call. The resulting address has all upper bits set (0xFFFFFFFFA...) which points to kernel space and not in the user space.Thus perhaps you can get your code "working" with justThat is not to say that you shouldn't define the argument and return types for all functions - you should, otherwise they will follow just the default argument promotion rules of the C language, and work... or totally fail to work, depending on whether the function's prototype itself is compatible with default argument promotions. For example any function that accepts floats as arguments cannot be called correctly without defining the prototype.
You should show your .argtypes and .restype attempts, but give this a try:Check the use of WinDLL vs. CDLL.  It won't matter if your Python is 64-bit, but it makes a difference on 32-bit Python.  Use CDLL if the functions use C calling convention (__cdecl) and WinDLL if the functions use __stdcall calling convention.  If the header file isn't clear, the default is usually __cdecl.  Edit: from the API link in another answer, it is __stdcall and WinDLL should be used.


Answer URL
https://docs.python.org/3/library/ctypes.html
