Natural Text
I need to write a python script that can match two lists of strings and return the shortest and lexographically first common parts of lists.Lists corresponds to each other which means (a1, b1)...(aN, bN), pairs are frozen.The rule:If no such concatenation of string then result is IMPOSSIBLE:Restrictions:every element from each list can be used only oncelength of each individual string element [1;100]max list length is 11all elements can be permutated only in pairsNow i try to consider all combinations and permutation inside them starting from the shortes and lexographically first.I need to submit it for a test and during one of test I get Memory limit condition, limit is CPU 6 seconds and RAM 1024 MB.I wonder how can I optimize memory consumptiom?My current code is here:This problem was solved in C++ but i cannot get the idea under the hood https://github.com/adrian-budau/work/blob/master/Kattis/ACM-ICPC%20-%20World%20Finals%202013/Limited%20Correspondence/main.cpp
I think you could just generate the correct substrings (all of them, as in my opinion, in generatrion time you can not really decide if they are both "lexicographically" first and shortest) like this:Then proceed with checking if m remained empty or pick a "first" item with whatever clumsy way, as that list is going to be a short one anyway. Like sorting it alphabetically and then picking the sortest one:
So, I ended up with clearly and early specifying situations when such combinations is not possible. For example, we know that the answering strings should start and end with the same symbols. So we can create combination and BEFORE making permutation we check for such condition. Also we can check that sum of length of all substrings inside the piece we need to check are equal. If not then we do not go for permutation and instead proceed furtherCode


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.permutations
https://docs.python.org/3/library/functions.html#sorted
