Natural Text
I am perplexed by Python's un-escaping of backslashes in commands passed to os.system on Ubuntu 18.04 (things work fine on CentOS). Consider this program:When I run it on Ubuntu 18.04, I get this:Note that it outputs one backslash where it should output two, and outputs two backslashes where it should output three or four!However, on my CentOS 7 box things work as expected. On both machines the shell is /bin/bash. Here is the strace output of the python2.7 invocation of the script, just in case: https://gist.githubusercontent.com/mbautin/a97cfb6f880860f5fe6ce1474b248cfd/rawI guess the safest behavior for calling shell commands from Python is to write them to a temporary script file!
While I can agree that the behavior is strange, it is not inexplicable. There is a reason for the behavior, which has nothing to do with Python or subprocess. Exactly the same behavior is seen in a C program, using the system call to the OS (Linux) as with your Python program.The reason has to do with your shell, though, but not exactly with bash. The reason is rather that when calling os.system() or the subprocess.Popen() family (including  subprocess.check_output()) with shell=True. The documentation states that "On POSIX with shell=True, the shell defaults to /bin/sh." Thus, the shell that invokes your echo command is not bash even if that is your default shell and the shell from which you are running your script/starting Python.Instead, your command is executed by /bin/sh of your system. For a long time, this just pointed to /bin/bash (running in POSIX compliant mode) in almost all Linux versions, however, lately this has changed in some distributions, among them Ubuntu (but not CentOS apparently, since you do not see the same behavior there), which now have /bin/sh point at bin/dash instead:Thus, your script is in fact executed by dash instead of bash. And "for efficiency" (see man dash at the prompt) dash has chosen to internally implement echo instead of using /bin/echo (used by bash). Unfortunately, the dash echo is not as potent as /bin/echo and has a different interpretation of string inputs, namely dash echo does it's escaping of a number of backslash commands, which in effect means it "swallows"one extra backslash for you.It is possible to make /bin/echo behave in the same way by specifying the -e option (see man echo) but unfortunately, it is not possible to have the dash builtin echo to not escape backslashes.Now, this is the reason for what you see. A good way to avoid the problem is to not rely on the system shell invocation. If it is a single command, such as echo it is best to not invoke a shell at all, removing the shell=True flag. Or, if you need some shell specific functionality, control the invocation of the shell yourself. And, a third way, in this particular case, is to explicitly point to /bin/echo while executing, as that ensures that the "standard" echo is used:Note that when used without shell=True the command should be a list and not a string. This can be shlex.split() as shown.Of these approaches, the first one (direct echo invocation) is preferred, due to security concerns, if there is any chance of some parameters coming from untrusted sources. In that case, however, shlex.split() should also not be used, as it opens up the same security vulnerabilities.


Answer URL
https://docs.python.org/3/library/shlex.html
https://docs.python.org/3/library/subprocess.html#security-considerations
