Natural Text
Is it possible to access exec-provided globals dictionary from within a function, if the function was defined outside of the exec-ed code (and thus already bound to different __globals__)?In other words, is there a way to make the following example work?In general, is it possible to substitute the __globals__ of a function?
This is a pretty weird thing to do, but it's doable.Your exec call executes the statement f() in the provided globals. It does not execute the body of f in the provided globals. The provided globals are being used in the wrong stack frame. To access those globals from f, you can use stack inspection:If you want to execute the body of f with the provided globals rather than just gaining access to the globals, you need to make a copy of f with your own custom globals:The function type constructor is sort of documented; it's not in the online docs, but it is documented in the function type's docstring:
Not sure if I am fully correct about the explanation. In short, the example cannot work in Python 3.The reason is in the combination of 2 circumstances: [1] - exec is a function in Python 3, [2] - the code you try to execute contains function call.When you provide globals optional argument to the function exec it is local scope of this very function. So the following example works:But the original one does not. Because in the original example you call the function f. It has its own local scope. What Python does? It checks global scope (actual global scope of the program) and innermost scope (local scope of the function f). Both scopes lack for log and you get NameError.You can get the very same behavior (the same error) with two regular functions:


Answer URL
https://docs.python.org/3/library/inspect.html#inspect.currentframe
