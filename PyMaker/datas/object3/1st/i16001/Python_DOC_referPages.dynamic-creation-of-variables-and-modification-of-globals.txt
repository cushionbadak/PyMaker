Natural Text
If I do this:It is clear that the resulting variable is created at runtime, simply because it's the only possibility. However, if I do this:It seems that y is also created at runtime. Why is it the case? Where does the dynamic behavior come from?PS: I am aware that this is a bad practice, I just want to understand.
Your module's (or exec context's, etc.) globals are a dict, and globals() just returns that dict. After that, the ['y'] = 3 part is just like any other dictionary assignment.If you're asking why Python doesn't optimize this into a static assignmentâ€¦ well, think about what it would have to do.First, detecting that 'y' is a literal is pretty easy; that information is right there in the AST.But detecting that the dict is your module's global dictionary is a lot harder. globals isn't a keyword or anything else magical, it's just a regular function in builtins. You could hide it with a global, nonlocal, or local name, or monkeypatch builtins, or even replace the builtins for your globals so it's not accessible. So, it would have to do sufficient analysis to determine that there's no way the name lookup on globals could possibly return anything but the appropriate global dict.And, not only that, in order to make this useful, the language would have to require every implementation to make the same optimization. Otherwise, you could get different semantics from some programs based on whether the optimization took place.It's also worth keeping in mind that CPython doesn't do anything beyond basic peephole optimization, so you'd have to build the infrastructure for a more complicated optimizer from scratch just to add this one minor change.On top of that, references to the same global dictionary are stored all over the place. So, even with this optimization, you could still trick Python just as easily:


Answer URL
https://docs.python.org/3/library/functions.html#globals
