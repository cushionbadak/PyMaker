Natural Text
Why do we have to use __getitem__ rather than the usual operator access?We get TypeError: 'super' object is not subscriptable.Instead we must use super().__getitem__(key), but I never fully understood why - what exactly is it that prevented super being implemented in a way that would allow the operator access?Subscriptable was just an example, I have the same question for __getattr__, __init__, etc.The docs attempt to explain why, but I don't understand it.  
CPython's bug tracker's issue 805304, "super instances don't support item assignment", has Raymond Hettinger give a detailed explanation of perceived difficulties.The reason this doesn't work automatically is that such methods have to be defined on the class due to Python's caching of methods, whilst the proxied methods are found at runtime.He offers a patch that would give a subset of this functionality:so it is clearly possible.However, he concludesI've been thinking that this one could be left alone and just   document that super objects only do their magic upon   explicit attribute lookup.Otherwise, fixing it completely involves combing Python for   every place that directly calls functions from the slots table,   and then adding a followup call using attribute lookup if the   slot is empty.When it comes to functions like repr(obj), I think we want   the super object to identify itself rather than forwarding the   call to the target object's __repr__() method.The argument seems to be that if __dunder__ methods are proxied, then either __repr__ is proxied or there is an inconsistency between them. super(), thus, might not want to proxy such methods lest it gets too near the programmer's equivalent of an uncanny valley.
What you ask can be done, and easily. For instance:So the reason that super works with magic methods isn't because it's not possible. The reason must lie elsewhere. One reason is that doing so would violate the contract of equals (==). That is equals is, amongst other criteria, symmetric. This means that if a == b is true then b == a must also be true. That lands us in a tricky situation, where super(self, CurrentClass) == self, but self != super(self, CurrentClass) eg.Another reason is that once super is done searching it's given object's mro, it then has to give itself a chance to provide the requested attribute - super objects are still an objects in their own right -- we should be able to test for equality with other objects, ask for string representations, and introspect the object and class super is working with. This creates a problem if the dunder method is available on the super object, but not on object that the mutable object represents. For instance:With the list example the function __iadd__ could have been more simply written asWith the tuple example we fall into infinite recursion, this is because tuple.__iadd__ does not exist. Therefore when looking up the attribute __iadd__ on a super object the actual super object is checked for an __iadd__ attribute (which does exist). We get that method and call it, which starts the whole process again. If we'd not written an __iadd__ method on super and used super().__iadd__(other) then this would never have happened. Rather we'd get an error message about a super object not having the attribute __iadd__. Slightly cryptic, but less so than an infinite stack trace.So the reason super doesn't work with magic methods is that it creates more problems than it solves.
Dunder methods must be defined on the class, not the instance.  super() would need to have an implementation of every magic method in order to make this work.  It's not worth writing all that code and keeping it up-to-date with the language definition (e.g. the introduction of matrix multiplication in 3.5 created three new dunder methods), when you can just tell users to write out the dunder methods by hand.  That uses normal method lookup, which can be easily emulated.


Answer URL
https://docs.python.org/3/reference/datamodel.html#special-method-lookup
