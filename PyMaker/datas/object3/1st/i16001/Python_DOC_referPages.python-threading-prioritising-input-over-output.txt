Natural Text
I have a python program that sends a message over a network using sockets, which uses two threads, one to run the server, and one to run the client.However, if a message is received while the user has partially entered an input, the received message is printed between the halves of the input.While this makes no difference functionally, aesthetically it looks horrible. Is there any way I can make the message be output as if it was received before the user began typing?In case my explanation wasn't clear, assuming the user entered "hel" before the message ("Sup") was received, and then "lo" after, this would be shown:Any suggestions would be more than welcome.
I think you can do this with just readline.Of course that means it won't help on Windows. Or if you've done anything funky with sys.stdin, or you're reading directly from stdin instead of using functions like input, or you're not on a TTY, or you're running under an environment like IDLE that hooks input in its own way, etc. But assuming none of those is a deal-breaker, readline.get_line_buffer() may be what you want.If you're looking to queue up output until the user finishes typing—basically the same thing the shell does with, e.g., job control messages—something like this:If you instead want to interrupt the user's input, remember what they'd typed, show the output, and restart the input, that's a bit more complicated. The output thread will need some way to stash the current input buffer (readline.get_line_buffer), interrupt the input thread, clear the current input (printing '\r' then a row of spaces and another '\r' should do it in simple cases, but see below), print the output, start a newinputcall, and refill the buffer (readline.insert_textthen possiblyreadline.redisplay; note that you have to call this afterinputstarts but before it returns, so you probably want to useset_pre_input_hook` to do this).If the input is happening on the main thread, a signal handler (which just raises a custom exception) is a great way to interrupt the input call. If not, it's a lot trickier.Meanwhile, readline supports multi-line input, and by default will wrap things onto multiple lines if the user types more than 80 (or $COLS) characters. In that case, there's really no way to erase the whole input from the high-level API that Python's readline module provides. Unless you want to write or find a lower-level wrapper with ctypes or a custom extension module, I can't see any way around this problem.


Answer URL
https://docs.python.org/3/library/readline.html
https://docs.python.org/3/library/signal.html
