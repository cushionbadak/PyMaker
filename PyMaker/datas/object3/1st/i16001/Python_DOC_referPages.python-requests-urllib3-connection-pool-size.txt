Natural Text
In my application, I am sending off several request.post() requests in threads. Depending on the amount of data I have to post, the number of threads created can be in their hundreds. The actual creation of the request object is made using requests-oauthlib, which inserts authentication data into the request object when it is used.My issue is that when there is a large amount of data being sent in parallel, that the log is flooded with the following messages, and eventually no more input is sent to the log:Connection pool is full. Discarding connection.My question is, with the use of requests-oauthlib, is there a way to specity, perhaps within the post method itself, the size of the connection pool, or whether it should block so that other requests can complete before creating more? I ask for this because with the use of requests-oauthlib, it would be tricky to construct a custom request object, and ask requests-oauthlib to use it.One thing I have tried is as follows, but it had no effect - I continued to get the warnings:Update - The threads are now being created in a controlled manner.
The easiest way to block the requests so only N of them are trying to use the connection pool at once is to only create N at a time.The easiest way to do that is to use a pool of N threads servicing queue of M requests, instead of a separate thread for every request. If you're using Python 3.2+, this is very easy with the concurrent.futures library—in fact, it's nearly identical to the first ThreadPoolExecutor example, except that you're using requests instead of urllib. If you're not using 3.2+, there's a backport of the stdlib module named futures that provides the same functionality back to… I think 2.6, but don't quote me on that (PyPI is down at the moment).There may be an even easier solution: there's a third-party library named requests-futures that, I'm guessing from the name (again, PyPI down…), wraps that up for you in some way.You may also want to consider using something like grequests to do it all in one thread with gevent greenlets, but that won't be significantly different, as far as your code is concerned, from using a thread pool.


Answer URL
https://docs.python.org/3/library/concurrent.futures.html
