Natural Text
I'm still new to Python and learning the more basic things in programming.Right now i'm trying to create a function that will dupilicate a set of numbers varies names.Example:I'm not sure how to write the function for this. Basically i understand you want to times the letter variable to the number variable beside it.
The key to any solution is splitting things into pairs of strings to be repeated, and repeat counts, and then iterating those pairs in lock-step.If you only need single-character strings and single-digit repeat counts, this is just breaking the string up into 2-character pairs, which you can do with mshsayem's answer, or with slicing (s[::2] is the strings, s[1::2] is the counts).But what if you want to generalize this to multi-letter strings and multi-digit counts?Well, somehow we need to group the string into runs of digits and non-digits. If we could do that, we could use pairs of those groups in exactly the same way mshsayem's answer uses pairs of characters.And it turns out that we can do this very easily. There's a nifty function in the standard library called groupby that lets you group anything into runs according to any function. And there's a function isdigit that distinguishes digits and non-digits.So, this gets us the runs we want:Now we zip this up the same way that mshsayem zipped up the characters:So:
Naive approach (if the digits are only single, and characters are single too):Poor explanation:Terms/functions:iter() gives you an iterator object.zip() makes tuples from iterables.int() parses an integer from string<expression> for <variable> in <iterable> is list comprehension<string>.join joins an iterable strings with stringProcess:First we are making an iterator of the given stringzip() is being used to make tuples of character and repeating times. e.g. ('d','3'), ('s','5) (zip() will call the iterable to make the tuples. Note that for each tuple, it will call the same iterable twice—and, because our iterable is an iterator, that means it will advance twice)now for in will iterate the tuples. using two variables (c,d) will unpack the tuples into thosebut d is still an string. int is making it an integer<string> * integer will repeat the string with integer timesfinally join will return the resultHere is a multi-digit, multi-char version:By the way, using itertools.groupby is better, as shown by abarnert.
Let's look at how you could do this manually, using only tools that a novice will understand. It's better to actually learn about zip and iterators and comprehensions and so on, but it may also help to see the clunky and verbose way you write the same thing.So, let's start with just single characters and single digits:This is a very simple state machine. There are two states: either the next character is a character to be repeated, or it's a digit that gives a repeat count. After reading the former, we don't have anything to add yet (we know the character, but not how many times to repeat it), so all we do is switch states. After reading the latter, we now know what to add (since we know both the character and the repeat count), so we do that, and also switch states. That's all there is to it.Now, to expand it to multi-char repeat strings and multi-digit repeat counts:The state here is pretty similar—we're either in the middle of reading non-digits, or in the middle of reading digits. But we don't automatically switch states after each character; we only do it when getting a digit after non-digits, or vice-versa. Plus, we have to keep track of all the characters in the current repeat string and in the current repeat count. I've collapsed the state flag into that repeat string, but there's nothing else tricky here.
There is more than one way to do this, but assuming that the sequence of characters in your input is always the same, eg: a single character followed by a number, the following would workdef expand(input):    alphatest = False     finalexpanded = "" #Blank string variable to hold final output    #first part is used for iterating through range of size i    #this solution assumes you have a numeric character coming after your    #alphabetic character every time     for i in input:         if alphatest == True:            i = int(i) #converts the string number to an integer            for value in range(0,i): #loops through range of size i                finalexpanded += alphatemp #adds your alphabetic character to string            alphatest = False #Once loop is finished resets your alphatest variable to False            i = str(i) #converts i back to string to avoid error from i.isalpha() test        if i.isalpha(): #tests i to see if it is an alphabetic character            alphatemp = i #sets alphatemp to i for loop above            alphatest = True #sets alphatest True for loop above    print finalexpanded #prints the final result


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.groupby
https://docs.python.org/3/library/stdtypes.html#str.isdigit
https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions
https://docs.python.org/3/tutorial/classes.html#iterators
