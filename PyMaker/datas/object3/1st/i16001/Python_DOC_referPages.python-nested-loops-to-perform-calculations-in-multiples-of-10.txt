Natural Text
I'm new to using python and the goal of this program is to have it add (1/2) and (1/3) to itself a large number of times like the output below shows. What I believe I need to do is have the outer loop determine how many times to add when starting at "1000" and go up by multiples of ten from there (1000, 10000, 100000, etc...). The inner loop is where I want to do the actual addition of the (1/2) and (1/3). Below is the code I have currently written which isn't performing how I need it to as well as an example output of what the code should do. I think I'm on the right track I just don't know what else to do, I feel like I have tried everything. Any help with this would be greatly appreciated! Thanks!My code:Example output:
What I believe I need to do is have the outer loop determine how many times to add when starting at "1000" and go up by multiples of ten from there (1000, 10000, 100000, etc...). In other words, your question is how to write something that's like your range(1000, 1000000000), but instead of giving you all the values 1000, 1001, â€¦, 1000000000, it only gives you 1000, 10000, etc., right? So, just like range(start, stop, step), except that it multiplies, instead of adds, step at each iteration.Let's start with a simplified version of how range works:The real range is actually a sequence, not an iterator, and it handles things like negative step values, but let's ignore that; this minimal version is all you need.If you don't understand that yield bit, read Iterators and the following section on Generators in the tutorial, but for the moment you can pretend it's a smarter version of this:So, how do we turn that into a geometric range that multiplies instead of adds? Just change the + to a *:
What I believe I need to do is have the outer loop determine how many times to add when starting at "1000" and go up by multiples of ten from there (1000, 10000, 100000, etc...). That is exactly what the sample output suggests you should do.There are a number of ways to do this. I'll start with an easy to understand approach that will make most seasoned python programmers cringe and build up to something that hopefully wont make that seasoned python programmer cringe.Here's the easy to understand, non-pythonic approach:In general, it's better to use a for loop than a while loop, and it's better to use some kind of generator. What you want to do is to perform your analysis on the numbers 103, 104, ..., 108. This suggests working with the integers 3, 4, 5, ..., 8. In python, this is expressed with range(3,9).A seasoned python programmer might not cringe at the above, but will say that there's a better way. That better way starts with the python map function and ends with python list comprehensions. The map function takes a function and an iterable (or a set of iterables; map is a very powerful tool) as arguments. The result of the mapping is a list formed by applying the function to each element of the iterable. For example:The above applies the rest of your code to the list [1000, 10000, 100000, 1000000, 10000000, 100000000]. There are a some issues with the above. The first is that I had to define that function pow10 that most likely is never used anywhere else. Python has a concept of anonymous functions, implemented using the lambda keyword. We can get rid of that function pow10 by using a lambda expression.We still haven't fixed all of the problems. One issue is that using map and lambda expressions, while certainly pythonic, is perhaps a bit too esoteric. Another problem is that map returns a list. It would be much better to use a generator that only generates values when they are needed. The way around both problems is python's concept of a list comprehension. List comprehensions also use anonymous functions, but the lambda is implied. Think of list comprehensions as a more compact and easier to understand version of map. In addition to mappings, list comprehensions can also filter out things before applying the anonymous mapping. List comprehensions are incredibly powerful. Here's the start of your program using a list comprehension:


Answer URL
https://docs.python.org/3/tutorial/classes.html#iterators
