Natural Text
The following code returns the summation of the values in list "A" that exist before the first even value in the list. Example:if list A = [1,3,5,4] the result would return 1 + 3 + 5 = 9if list A = [1,2,5,4] the result would return 1I don't understand how, after the first iteration, we don't lose the 1st integer in the list.  In other words, here's how I imagine the code is working.Starts at the first value in the list "A" and prepares to move through all values one at a time:Checks the first iteration of the if statement:Although the first number in the list IS ODD, because found_even was set to False originally the code should move to the else statement:I imagine that the if statement has now been completed on the first value of the list and all that occurred was that the found_even bool was changed to True.  I assumed that the code would then move on; that the if statements would then be tested on the NEXT value in the list.  This, however appears incorrect.  If my thinking were right, in the example above, it would mean that the first value in the list "1" would be ignored when completing the summation, and we would end up with 3 + 5 = 8 NOT 1 + 3 + 5 = 9.I obviously don't understand something very foundational about how theline works...  It's as if it did not, in fact, move to the next integer in the list and reruns the code on the first integer in the list.  Can someone please explain why this is.
Although the first number in the list IS ODD, because found_even was set to False originally the code should move to the else statement[.]You got your logic wrong right there. not False is true, so the if statement test tests true and the else suite is not executed.You can test this yourself:The code itself is overly complicated; just return early. There is no need to iterate on, or use a flag; return ends a function and iteration:Alternatively, use break to stop the loop, and return afterwards.The Python standard library has a helpful tool in the itertools library for this, called itertools.takewhile(); it'll give you all elements of an iterable until the given test fails. It then just stops iterating:I removed the != 0 test there; % 2 only results in 0 or 1, and 0 is considered a false value in a boolean test. I also used the sum() function to add up all the numbers that takewhile does pass through.
You don't need to keep track if you found or not the first even number, just break and leave the for loop when you find it:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.takewhile
https://docs.python.org/3/library/functions.html#sum
