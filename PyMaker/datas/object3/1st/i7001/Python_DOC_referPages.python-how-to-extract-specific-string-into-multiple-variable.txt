Natural Text
i am trying to extract a specific line as variable in file.this is content of my test.txtthis is my code here is what i'm trying to do:but there's an error occurred in the outputReponse for SwiftsNamesakei tried out your code . i am still getting an error.this is my attempt by using your code
As previously mentioned, you need some sort of chunking. To chunk it usefully we'd also need to ignore the irrelevant lines of the file. I've implemented such a function with some nice Python witchcraft below.It might also suit you to use a namedtuple to store the values. A namedtuple is a pretty simple type of object, that just stores a number of different values - for example, a point in 2D space might be a namedtuple with an x and a y field. This is the example given in the Python documentation. You should refer to that link for more info on namedtuples and their uses, if you wish. I've taken the liberty of making a Task class with the fields ["number", "title", "weight", "fullMark", "desc"].As your variables are all properties of a task, using a named tuple might make sense in the interest of brevity and clarity.Aside from that, I've tried to generally stick to your approach, splitting by the colon. My code produces the outputwhich seems to be roughly what you're after - I'm not sure how strict your output requirements are. It should be relatively easy to modify to that end, though.Here is my code, with some explanatory comments:You can also reference each field of the Task, like this:If the namedtuple approach is not desired, feel free to replace the content of the main for loop with and then your code will be back to normal.Some notes on other changes I've made:filter does what it says on the tin, only iterating over lines that meet the predicate (line_is_relevant(line) is True).The * in the Task instantiation unpacks the iterator, so each parsed line is an argument to the Task constructor.The expression (line.strip().split(": ")[1] for line in task_lines) is a generator. This is needed because we're doing multiple lines at once with task_lines, so for each line in our 'chunk' we strip it, split it by the colon and take the second element, which is the value.The n_lines function works by passing a list of n references to the same iterator to the zip function (documentation). zip then tries to yield the next element from each element of this list, but as each of the n elements is an iterator over the file, zip yields n lines of the file. This continues until the iterator is exhausted.The line_is_relevant function uses the idea of "truthiness". A more verbose way to implement it might beHowever, in Python, every object can implicitly be used in boolean logic expressions. An empty string ("") in such an expression acts as False, and a non-empty string acts as True, so conveniently, if line.strip() is empty it will act as False and line_is_relevant will therefore be False. The and operator will also short-circuit if the first operand is falsy, which means the second operand won't be evaluated and therefore, conveniently, the reference to line[0] will not cause an IndexError.Ok, here's my attempt at a more extended explanation of the n_lines function:Firstly, the zip function lets you iterate over more than one 'iterable' at once. An iterable is something like a list or a file, that you can go over in a for loop, so the zip function can let you do something like this:The zip function returns a 'tuple' of one element from each list at a time. A tuple is basically a list, except it's immutable, so you can't change it, as zip isn't expecting you to change any of the values it gives you, but to do something with them. A tuple can be used pretty much like a normal list apart from that. Now a useful trick here is using 'unpacking' to separate each of the bits of the tuple, like this:A simpler unpacking example, which you may have seen before (Python also lets you omit the parentheses () here):Although the n-lines function doesn't use this. Now zip can also work with more than one argument - you can zip three, four or as many lists (pretty much) as you like.Now the n_lines function passes *[iter(read_file)] * n to zip. There are a couple of things to cover here - I'll start with the second part. Note that the first * has lower precedence than everything after it, so it is equivalent to *([iter(read_file)] * n). Now, what iter(read_file) does, is constructs an iterator object from read_file by calling iter on it. An iterator is kind of like a list, except you can't index it, like it[0]. All you can do is 'iterate over it', like going over it in a for loop. It then builds a list of length 1 with this iterator as its only element. It then 'multiplies' this list by n.In Python, using the * operator with a list concatenates it to itself n times. If you think about it, this kind of makes sense as + is the concatenation operator. So, for example,By the way, this uses Python's chained comparison operators - a == b == c is equivalent to a == b and b == c, except b only has to be evaluated once,which shouldn't matter 99% of the time.Anyway, we now know that the * operator copies a list n times. It also has one more property - it doesn't build any new objects. This can be a bit of a gotcha -Here l is three objects - but they're all in reality the same object (you might think of this as three 'pointers' to the same object). If you were to build a list of more complex objects, such as lists, and perform an in place operation like sorting them, it would affect all elements of the list.So [iter(read_file)] * n is equivalent toNow the very first *, the one with the low precedence, 'unpacks' this, again, but this time doesn't assign it to a variable, but to the arguments of zip. This means zip receives each element of the list as a separate argument, instead of just one argument that is the list. Here is an example of how unpacking works in a simpler case:So in effect, now we have something likeRemember that when you 'iterate' over a file object in a for loop, you iterate over each lines of the file, so when zip tries to 'go over' each of the n objects at once, it draws one line from each object - but because each object is the same iterator, this line is 'consumed' and the next line it draws is the next line from the file. One 'round' of iteration from each of its n arguments yields n lines, which is what we want.
Your line variable gets only Task Identification Number: 210CT1 as its first input. You're trying to extract 5 values from it by splitting it by :, but there are only 2 values there. What you want is to divide your for loop into 5, read each set as 5 lines, and split each line by :.
The problem here is that you are spliting the lines by : and for each line there is only 1 : so there are 2 values. In this line:you are telling it that there are 5 values but it only finds 2 so it gives you an error.One way to fix this is to run multiple for loops one for each value since you are not allowed to change the format of the file. I would use the first word and sort the data into different of course you can use a loop for the prints but i was too lazy so i copy and pasted :).IF YOU NEED ANY HELP OR HAVE ANY QUESTIONS PLEASE PLEASE ASK!!!THIS CODE ASSUMES THAT YOU ARE NOT THAT ADVANCED IN CODINGGood Luck!!!
As another poster (@Cuber) has already stated, you're looping over the lines one-by-one, whereas the data sets are split across five lines. The error message is essentially stating that you're trying to unpack five values when all you have is two. Furthermore, it looks like you're only interested in the value on the right hand side of the colon, so you really only have one value.There are multiple ways of resolving this issue, but the simplest is probably to group the data into fives (plus the padding, making it seven) and process it in one go.First we'll define chunks, with which we'll turn this somewhat fiddly process into one elegant loop (from the itertools docs).Now, we'll use it with your data. I've omitted the file boilerplate.The 2 in 5+2 is for the padding (the comment above and the empty line below).The implementation of chunks may not make sense to you at the moment. If so, I'd suggest looking into Python generators (and the itertools documentation in particular, which is a marvellous resource). It's also a good idea to get your hands dirty and tinker with snippets inside the Python REPL.
You can still read in lines one by one, but you will have to help the code understand what it's parsing.  We can use an OrderedDict to lookup the appropriate variable name.Output
You're trying to get more data than is present on one line; the five pieces of data are on separate lines.As SwiftsNamesake suggested, you can use itertools to group the lines:If you want to use the data in other functions, output it as a dictionary from a generator:
Inspired by itertools-related solutions, here is another using the more_itertools.grouper tool from the more-itertools library.  It behaves similarly to @SwiftsNamesake's chunks function.OutputCare was taken to print the variable name with the corresponding value.


Answer URL
https://docs.python.org/3/library/collections.html#collections.namedtuple
https://docs.python.org/3/library/functions.html#zip
