Natural Text
I've been using Python for a while now to solve practical problems, but I still don't have a proper theoretical understanding of what's going on behind the hood. For example, I'm struggling to understand how Python manages to treat functions as objects. I know that functions are objects of the class 'function', with a 'call' method, and I am aware that I can make my custom-made classes behave like functions by writing a 'call method' for them. But I can't figure out what precisely gets stored in memory when new functions are created, and how to access the information that gets stored.To experiment, I wrote a little script that creates lots of function objects and stores them in a list. I noticed that this program used up a lot of memory.My questions are:What precisely gets stored in RAM when I define a new function object? Am I storing the details of how the function is to be implemented?If so, does my function object have attributes or methods that allow me to "inspect" (or possibly even "alter retrospectively") the way the function behaves?Maybe my previous question is circular, because the methods of the function object are functions in their own right...In my code above, some of the RAM is used simply to store the "pointers" to my function objects in the list. The rest of the RAM is presumably used to store the interesting stuff about how my function objects actually work. Roughly how is the RAM distributed between these two purposes?Suppose I alter the code snippet by making the function do more complicated stuff. Will I use up much more RAM as a consequence? (I would expect so. But when I altered the definition of my function by filling its body with 1000 lines of junk, there didn't appear to be any difference in the amount of RAM used up.)I would love to find a comprehensive reference about this. But whatever I type into google, I can't seem to find what I'm looking for!
A function object's data is divided into two primary parts. The parts that would be the same for all functions created by the same function definition are stored in the function's code object, while the parts that can change even between functions created from the same function definition are stored in the function object.The most interesting part of a function is probably its bytecode. This is the core data structure that says what to actually do to execute a function. It's stored as a bytestring in the function's code object, and you can examine it directly:...but it's not designed to be human-readable.With enough knowledge of the implementation details of Python bytecode, you could parse that yourself, but describing all that would take way too long. Instead, we'll use the dis module to disassemble the bytecode for us:There are a number of columns in the output here, but we're mostly interested in the one with the ALL_CAPS and the columns to the right of that.The ALL_CAPS column shows the function's bytecode instructions. For example, LOAD_CONST loads a constant value, and BINARY_ADD is the instruction to add two objects with +. The next column, with the numbers, is for bytecode arguments. For example, LOAD_CONST 3 says to load the constant at index 3 in the code object's constants. These are always integers, and they're packed into the bytecode string along with the bytecode instructions. The last column mostly provides human-readable explanations of the bytecode arguments, for example, saying that the 3 in LOAD_CONST 3 corresponds to the constant (0, 1), or that the 1 in STORE_FAST 1 corresponds to local variable x. The information in this column doesn't actually come from the bytecode string; it's resolved by examining other parts of the code object.The rest of a function object's data is primarily stuff needed to resolve bytecode arguments, like the function's closure or its global variable dict, and stuff that just exists because it's handy for introspection, like the function's __name__.If we take a look at the Python 3.6 function object struct definition at C level:we can see that there's the code object, and thenthe global variable dict,the default argument values,the keyword-only argument default values,the function's closure cells,the docstring,the name,the __dict__,the list of weak references to the function,the __module__,the annotations, andthe __qualname__, the fully qualified nameInside the PyObject_HEAD macro, there's also the type pointer and some refcount/GC metadata.We didn't have to go straight to C to examine most of that - we could have looked at the dir and filtered out non-instance attributes, since most of that data is available at Python level - but the struct definition provides a nice, commented, uncluttered list.You can examine the code object struct definition too, but the contents aren't as clear if you're not already familiar with code objects, so I'm not going to embed it in the post. I'll just explain code objects.The core component of a code object is a bytestring of Python bytecode instructions and arguments. We examined one of those earlier. In addition, the code object contains things like a tuple of the constants the function refers to, and a lot of other internal metadata required to figure out how to actually execute each instruction. Not all the metadata - some of it comes from the function object - but a lot of it. Some of it, like that tuple of constants, is fairly easily understandable, and some of it, like co_flags (a bunch of internal flags) or co_stacksize (the size of the stack used for temporary values) is more esoteric.
Functions are objects just like any other: they are instances of a type (or class). You can get the type of a function using type(f), where f is a function, or use the types module (types.FunctionType).When you define a function, Python builds a function object and assigns a name to it. This machinery is hidden behind the def statement, but it works the same as the instantiation of any other type. Which means that in Python, function definitions are executed, unlike in some other languages. Among other things, this means that functions don't exist until the flow of code reaches them, so you can't call a function before it has been defined.The inspect module lets you snoop around inside various kinds of objects. This table in its documentation is useful for seeing what kinds of components functions and related types of objects (such as methods) are made from, and how to get to them.The actual code inside a function becomes a code object, which contains the byte code that is executed by the Python interpreter. You can see this using the dis module.Looking at the help() of the types for functions and code objects is interesting, as it shows what arguments you need to pass in to build these objects. It is possible to make new functions from raw byte code, to copy byte code from one function to another but use a different closure, and so on.You can also build code objects using the compile() function and then build functions out of them.Fun FactAny object whose type has a __call__() method is callable. Functions are callable, and their type has a __call__() method. Which is callable. Which means it, too, has a __call__() method, which has a __call__() method, ad nauseam, ad infinitum. How does a function actually get called, then? Python actually bypasses __call__ for objects with __call__ implemented in C, such as a Python function's __call__ method. Indeed, (lambda: 0).__call__ is a method-wrapper, which is used to wrap a C function.


Answer URL
https://docs.python.org/3/library/dis.html
https://docs.python.org/3/library/inspect.html
https://docs.python.org/3/library/inspect.html#types-and-members
https://docs.python.org/3/library/dis.html
https://docs.python.org/3/library/functions.html#compile
