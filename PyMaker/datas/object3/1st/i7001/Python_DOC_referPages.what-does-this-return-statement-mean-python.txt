Natural Text
I am working on a genetic algorithm, and I found a code that works, and now I am trying to understand, but I saw this return statement:What does it do?Here is the full code:main.py:population.py:This is the full code of an working genetic algorithm. I modified some parts to make it more readable for me.The return statement is in the population.py file, in the get_fitness function.
Let's break that down:could be written as:zip(a, b) makes a list of pairs of items from a and b, like:yields [(1, 'a'), (2, 'b'), (3, 'c')]. So the zip(target, guess) expression returns a list of the first item from target and the first item of guess, then the second item from target and the second from guess, and so on.The for expected, actual in zip() bit unpacks the pairs of values from the output of zip(), so the first of the pair (from target) goes to the variable expected, and the second of the pair (from guess) goes to the variable actual.The 1 ... if expected == actual bit says "emit a value of 1 for every item from zip() if the value in expected equals the value in actual.sum() adds up the number of 1 values from the for loop.Ta-da! Now you have the count of items where the expected and actual values are the same. There are a couple of reasons to write it this way:It's very terse but expressive. People who write a lot of Python can glance at that and understand it.It's potentially very fast, as the Python interpreter is handling the looping, conditionals, etc. and improvements to the Python interpreter could make the code faster without it having to understand the whole program. Basically you're telling Python "I want this thing done" instead of "here are 100 little steps to do this thing".
I think it returns the total number of matches where actual= expected. Essentially I think it is checking how many times the algorithms model was able to correctly predict 
It is a type of List Comprehension that makes use of the zip() function.Basically, the code is saying:Create a list.   Retrieve variables "expected" and "actual" from zip(target, guess). If they are equal, add 1 to the list. Repeat for next values from zip(target, guess). Sum all the 1's. Return this summation.
There are several things going on:this means that you are returning a number.The inner part of the sum is a generator expression which creates and runs an implicit loop.In this case, 1 for expected, actual in zip(target, guess) if expected == actual creates a sequence of 1 values, with one entry created each time the guard condition is true (expected == actual). So this line is effectively creating code like: sum(1, 1, 1, 1, ...)Within the generator expression, you have a zip call. The zip expression will take the two (or more!) sequences, and convert them into a single sequence with tuples of two (or more!) values. That is, zip(['a', 'b', 'c'], [1, 2, 3]) will produce as its output a sequence like [('a', 1), ('b', 2), ('c', 3)].So if your expected is [1, 2, 3] and your actual is [1, 1, 3], you will get a zip result like:The generator expression contains a for which uses what was once called "tuple unpacking" to assign multiple targets in its target_list from a single aggregate (tuple) value.So when the zip expression produces (1, 1) the for expected, actual unpacks that into expected=1, actual=1.Thus, the zip takes two equal-length sequences and pairs their corresponding elements: a[0] with b[0], a[1] with b[1], etc. The for generator expression assigns those elements into variables called expected and actual. The for...if generator conditional part compares the expected == actual values, and either generates a value or does not generate a value. Thus, the length of the resulting sequence is guaranteed to be less than or equal to the length of the input sequences, but you don't know how long it will be. The expression part of the generator is simply 1. So you have a variable-length sequence of 1's. It's not 1 or 0. It's 1 or no-entry. Add up all the 1's, and that's the result.


Answer URL
https://docs.python.org/3/library/functions.html#zip
https://docs.python.org/3/reference/simple_stmts.html#assignment-statements
