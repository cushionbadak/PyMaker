Natural Text
Let's say I have something like this:Which gives me a list:However I want it to be like:Which splits every integer into single digits, is there anyway of achieving this without sacrificing too much performance?  Or is there a way of generating list like these in the first place?
You can build the final result efficiently without having to build one large and/or small intermediate strings using itertools.chain.from_iterable. Timings scale with input. The itertools version also uses memory efficiently although it is marginally slower than the str.join version if used with list(map(int, ...)):
simplest way is, 
Convert the integers to strings, then split() the string and reconvert the digits back to ints.Output:
I've investigated how performant I can make this a little more. The first function I wrote was naive_single_digits, which uses the str approach, with a pretty efficient list comprehension.As you can see, this approach works:However, I thought that it would surely be unecessary to always build a str object for each item in the list - all we actually need is a base conversion to digits. Out of laziness, I copied this function from here. I've optimised it a bit by specifying it to base 10.Using this, I madewhich also behaves correctly:Now to time it. I've also tested against one other answer (full disclosure: I modified it a bit to work in Python2, but that shouldn't have affected the performance much)As you can see arithmetic_single_digits is actually somewhat faster, although this is at the cost of more code and possibly less clarity. I've tested against ridiculously large inputs, so you can see a difference in performance - at any kind of reasonable scale, every answer here will be blazingly fast. Note that python's integer arithmetic is probably actually relatively slow, as it doesn't use a primitive integer type. If this were to be implemented in C, I'd suspect my approach to get a bit faster.Comparing this to viblo's answer, using (pure) Python 3 (to my shame I haven't installed ipython for python 3):This has the output of:My approach is quite a bit faster, presumably because I'm purely using integer arithmetic.
Another way to write an arithmetic solution. Compared to Izaak van Dongens solution this doesnt use a while loop but calculates upfront how many iterations it need in the list comprehension/loop.
Turn it to a string then back into a list :)
You can also do with map function
here is how I did it:



Answer URL
https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable
