Natural Text
I have the following function:On the face of it (naively), it should print 0, then 7. In fact it raises an error:How does defining min as a local variable in min = 7 prevent it from being used as the builtin before hand? Does Python build a list of local variables (something like __slots__ for a class) as it is compiling the function?
The compile phase for Python identifies all names that are assigned to within the scope of a function, and marks those names as locals (they're assigned an index in a local variable array in CPython, so using them doesn't involve dictionary lookups at all).Being a local is all or nothing, for the entire scope of the method. You can't treat a variable as local for part of the method, and global/built-in for the rest. Per the language reference on naming and binding:A scope defines the visibility of a name within a block. If a local variable is defined in a block, its scope includes that block.Like most language standards, that's rather dry, but the important point is that defining a local variable within the block makes it local for the (implied) whole block, not from point of definition.If you need to do something like this, you can make a local from the qualified name of the builtin initially, then change it later, e.g.:Or you can use a cheesy hack based on compile-time default value caching for the same purpose:If you're on Python 3, you'd want to do def x(*, min=min): to make it a keyword only argument, so it can't be overridden by the caller if they accidentally pass too many arguments positionally.
Yes, specifically, if you take a look at the byte code generated, you'll see that Python tries to load it as a local with LOAD_FAST:During compilation of the function object (I'm pretty sure it is during the construction of the symbol table), an assignment to min is detected and any look-ups for that name will be resolved in the local scope.You can actually peek at the symbol table constructed and see how the symbol (name) min is classified:Haven't taken a good look into the symtable internals but there just might be some overriding here. Afterwards, during execution, this will flat out fail due to the fact that the assignment happens after the reference and no value can be found.


Answer URL
https://docs.python.org/3/reference/executionmodel.html#naming-and-binding
https://docs.python.org/3/library/builtins.html#module-builtins
