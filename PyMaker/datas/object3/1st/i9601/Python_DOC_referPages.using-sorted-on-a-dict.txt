Natural Text
i'm trying to sort a dict with tasks as a key, and trying to untie them if there is more than one translator in the dict:So for example, after I iterate the keys and values, since key['harry potter volume 24'] has 2 possible translators, I want to untie them using some of the other paramenters (for example, the 1* but had no luck using lambda dicts iterators since i allways get the error that it's out of range. Same thing when i transformed the dict to a list.Any ideias? ThanksEdit1: Deleted for replacement.Edit2: 
simple, use the list.sort, to well ,sort the elements inside the dict itself and inside those list in place without making any copy of the data (unless that that is what you want)the meat of the deal is heret is each element inside each list, which in your case it can be expressed as (Name,ListData) then t[1] is said ListData and from there we want what you call "speed" (whatever that means here), I transform that to a float so it be orderer by it numeric value, and the rest should be self explanatory
One can pass a key parameter to the sorted function - this is a function that will take in the item to be sorted, and return another Python object that will compare naturally with the built-in operators.Therefore, you can have whatever complexity you want in a function to be used as "key", and still do all your sorting in a single call. The Key function takes a single Python object - in th case of a dictionary you will want a tuple of key, value such as provided by the items method. But on a second reading, you want to sort the values, regardless of the keys - that, yes, will require one call to sorted to each dictionary item:
The error is because the newList you demonstrate is actually a list of lists.Here it is "pretty-printed":newList is actually a list containing exactly one element, another list. That is, the data structure is something like this:I suspect this is not the data structure you intended to produce. But the reason you're getting the error is that you are calling sorted on the outermost list, which only has one element. That element, in turn, only has two elements. So lambda t: t[4] fails because it's being called on a length-two list.


Answer URL
https://docs.python.org/3/library/stdtypes.html#list.sort
