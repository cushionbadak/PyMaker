Natural Text
The old-style class works, but the new-style class doesn't.  Why?Note:  I'm using 2.7 above.  None of this applies in Python 3, where range is documented as responding to __index__ and old-style classes have gone the way of the Norwegian Blue.  
Old-style classes implement a different method to test if you can convert to a number, one that supports using __trunc__ if __int__ doesn't exist.range() (Python 2), uses Py_TYPE(arg)->tp_as_number->nb_int() to convert the value to an integer, which is roughly, but not quite, like using int(). So we have to look at the nb_int() slot for both old and new-style classes here.Old-style classes implement the nb_int slot as instance_int(), which uses hasattr() (or rather, the C equivalent) to test for __int__:hasattr() swallows all exceptions, including the TypeError your old-style class throws:Because hasattr() swallows the exception, hasattr() returns False:and the next line in instance_int() then uses __trunc__:New-style classes never also use __trunc__ when you ask for nb_int; they want __int__ or bust. That's because they support slots directly; tp_as_number->nb_int() directly calls __int__ if available (bypassing __getattribute__ altogether).Note that when explicitly using int() to convert, then the underlying C code will look for a __trunc__ attribute explicitly (using it only if no tp_as_number->nb_int() slot is available), but at least it won't use hasattr() for this. This means using int() on your new-style class still works:In Python 3, all use of __trunc__ treats it as a proper special method.


Answer URL
https://docs.python.org/3/reference/datamodel.html#special-lookup
