Natural Text
I just started programming in Python, and there's something OOP-related that I'm not quite clear on. So in Python, you can create and assign value to a new variable without needing to first declare it. So with that, is there any difference between creating and assigning a new variable for self (eg. self.variable = 5) inside a function (eg. __init__()) vs. creating and assigning a new private member variable? It seems to me like there is no difference at all.
There is in fact a difference between those two variables:Since __var_A is defined in class Foo instead of an individual member-function like __init__, you can change it for all instances at once like this:This will not work for __var_B since you define it individually per instance.Note though, that changing __var_A on an instance will not change it for everyone else, it will instead put a local override into the object itself:
It seems to me like there is no difference at all.That is correct.But remember that Python does not have 'private' members. That is only a convention.
The difference between protected and public is a matter of convention. And class or member variable prefixed by one _ indicates to a developer "don't use this unless you know what you're doing." Private is a SLIGHTLY different case, however: they require two _ and they cannot be suffixed by more than one _. Here are the docs:“Private” instance variables that cannot be accessed except from inside an object don’t exist in Python. However, there is a convention that is followed by most Python code: a name prefixed with an underscore (e.g. _spam) should be treated as a non-public part of the API (whether it is a function, a method or a data member). It should be considered an implementation detail and subject to change without notice.Name mangling is an important part of Python inheritence. It allows classes to protect API calls from accidental manipulation of descendants (see above docs). However, if necessary you can still access them via _<class-name><var name>. Eg:
There is no difference if the variable is declared under class foo: of within the __init__(self).  Both methods accomplish the same thing.  However, this is slight a twist if the variable (e.g. self.bar) is declared from a method other than __init__.  Usingcreates a variable within the object that is not part of the default class.  You can do this, but it is not good programming practice for python.  
There is a difference. Consider following example:This will return:But, following code:will returnThis leads to conclusion that __var_A will be accessible even if Foo is not instantiated, while __var_B will not be.


Answer URL
https://docs.python.org/3/tutorial/classes.html#private-variables
https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables
