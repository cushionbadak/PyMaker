Natural Text
When a function is assigned to an attribute during class definition, this attribute stays an ordinary function with its original signature:When the class is instantiated, this attribute becomes a bound method and its signature changes:I need to define a class that I can later customize by changing some attributes before instantiating. One of these attributes is a function and I need it to keep it's signature.Using @staticmethod is obviously not an option, since no function is defined on  class definition/customization, and decorations dont apply to attributes.Is there any way to keep a function to be transformed into a bound method on instantiation? 
Using @staticmethod is obviously not an option, since no function is defined on class definition/customization, and decorations dont apply to attributes.No, staticmethod is the option, just call it directly to produce an instance:@decorator syntax is only syntactic sugar to produce the exact same assignment after a function object has been created.This works fine:It doesn't matter where a function is defined, a def statement produces a function object regardless where it is used. def name is two things: creating the function object and an assignment of that function object no a name. Wether or not this takes place in a class statement or elsewhere doesn't actually matter.What turns functions into bound methods is accessing them on an instance, as then the descriptor protocol kicks in. For example,  accessing A().ff is turned into A.__dict__['ff'].__get__(A()), and it is the __get__ method on a function that produces the bound method. The bound method is only a proxy for the actual function, passing in the instance as a first argument when called.A staticmethod defines a different __get__, one that just returns the original function, unbound. You can play with those __get__ methods directly:


Answer URL
https://docs.python.org/3/howto/descriptor.html
https://docs.python.org/3/howto/descriptor.html
