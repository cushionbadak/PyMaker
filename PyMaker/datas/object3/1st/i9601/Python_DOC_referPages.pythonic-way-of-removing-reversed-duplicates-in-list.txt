Natural Text
I have a list of pairs:and I want to remove any duplicates whereSo we end up with justI can do an inner & outer loop checking for the reverse pair and append to a list if that's not the case, but I'm sure there's a more Pythonic way of achieving the same results.
If you need to preserve the order of the elements in the list then, you can use a the sorted function and set comprehension with map like this:or simply without map like this:Another way is to use a frozenset as shown here however note that this only work if you have distinct elements in your list. Because like set,  frozenset always contains unique values. So you will end up with unique value in your sublist(lose data) which may not be what you want.To output a list, you can always use list(map(list, result)) where result is a set of tuple only in Python-3.0 or newer.
If you only want to remove reversed pairs and don't want external libraries you could use a simple generator function (loosly based on the itertools  "unique_everseen" recipe):The generator function might be a pretty fast way to solve this problem because set-lookups are really cheap. This approach also keeps the order of your initial list and only removes reverse duplicates while being faster than most of the alternatives!If you don't mind using an external library and you want to remove all duplicates (reversed and identical) an alternative is: iteration_utilities.unique_everseenThis checks if any item has the same contents in arbitary order (thus the key=set) as another. In this case this works as expected but it also removes duplicate [a, b] instead of only [b, a] occurences. You could also use key=sorted (like the other answers suggest). The unique_everseen like this has a bad algorithmic complexity because the result of the key function is not hashable and thus the fast lookup is replaced by a slow lookup. To speed this up you need to make the keys hashable, for example by converting them to sorted tuples (like some other answers suggest):The chained is nothing else than a faster alternative to lambda x: tuple(sorted(x)).EDIT: As mentioned by @jpmc26 one could use frozenset instead of normal sets:To get an idea about the performance I did some timeit comparisons for the different suggestions:Long list with many duplicates:And with fewer duplicates:So the variants with remove_reversed_duplicates, unique_everseen(key=frozenset) and set(map(frozenset, a)) seem to be by far the fastest solutions. Which one depends on the length of the input and the number of duplicates.
TL;DRExplanationIf the pairs are logically unordered, they're more naturally expressed as sets. It would be better to have them as sets before you even get to this point, but you can convert them like this:And then the natural way of eliminating duplicates in an iterable is to convert it to a set:(This is the main reason I chose frozenset in the first step. Mutable sets are not hashable, so they can't be added to a set.)Or you can do it in a single line like in the TL;DR section.I think this is much simpler, more intuitive, and more closely matches how you think about the data than fussing with sorting and tuples.Converting backIf for some reason you really need a list of lists as the final result, converting back is trivial:But it's probably more logical to leave it all as sets as long as possible. I can only think of one reason that you might need this, and that's compatibility with existing code/libraries.
You could sort each pair, convert your list of pairs to a set of tuples and back again :The steps might be easier to understand than a long one-liner :
You could use the builtin filter function.As a complement I would orient you to the Python itertools module which describes a unique_everseen function which does basically the same thing as above but in a lazy, generator-based, memory-efficient version. Might be better than any of our solutions if you are working on large arrays. Here is how to use it:I haven't done any metrics to see who's fastest. However memory-efficiency and O complexity seem better in this version.Timing min/max vs sortedThe builtin sorted function could be passed to unique_everseen to order items in the inner vectors. Instead, I pass lambda x: (min(x), max(x)). Since I know the vector size which is exactly 2, I can proceed like this. To use sorted I would need to pass lambda x: tuple(sorted(x)) which adds overhead. Not dramatically, but still.Timings done in Python 3, which adds the globals kwarg to timeit.timeit.
An easy and unnested solution:
EDITED to better explainFirst get each list sorted and next use the dictionaries keys to get a unique set of elements and them list comprehension.Why tuples?Replacing lists with tuples is necessary to avoid the "unhashable" error when passing through the fromkeys() functionUsing OrderedDict even preserve the list order.The above code will result in the desired list
If the order of pairs and pair-items matters, creating a new list by testing for membership might be the way to go here. Otherwise, I'd go with Styvane's answer. Incidentally, the above solution will not work for cases in which you have matching pairs. For example, [0,0] would not be added to the list. For that, you'd need to add an additional check: However, that solution will not pick up empty "pairs" (eg, []). For that, you'll need one more adjustment: The and not pair in no_dups bit is required to prevent adding the [0,0] or [] to no_dups twice. 
Well, I am "checking for the reverse pair and append to a list if that's not the case" as you said you could do, but I'm using a single loop.The advantage over existing answers is being, IMO, more readable. No deep knowledge of the standard library is needed here. And no keeping track of anything complex. The only concept that might be unfamiliar for beginners it that [::-1] reverts the pair.The performance is O(n**2) though, so do not use if performance is an issue and/or lists are big.


Answer URL
https://docs.python.org/3/library/functions.html#sorted
https://docs.python.org/3/library/functions.html#map
