Natural Text
Trying to understand things at a deeper level.If I am opening a file, or a web request, tensorflow session, or anything that can be handled with a with statement; is there ever a time when I shouldn't use a with statement?E.g., is there ever a time when I should use the more generic / general try except structure?My real question is, what is the underlying structure of what with really does?  I read some nice helpful hints as well as the documentation itself, but still some of the inner workings of with seem a bit like black magic to me.  I am trying to demystify the magical components.
I always go to the Python Enhancement Proposals (PEPs) to understand concepts in python since they focus more on the conceptual reasoning for things compared to the documentation and usually directly address:the reason for the new feature / change.how it could be done with existing code / how it affects existing code.since you are interested in the implementation aspect here is a relevant exert from PEP 343 - the "with" statement:Specification: The 'with' StatementA new statement is proposed with the syntax:(paragraph omitted - not really relevent for this question)The translation of the above statement is:So the internal workings of the with statement are exactly implemented like try: finally constructs, just with a cleaner syntax that makes it harder to forget to close files etc.
There are reasons for not using a with-statement: If a failure/success requires custom cleanup.Normally you shouldn't need to know what cleanups should be performed when you have finished with a file. The with-statement takes care of closing the file no matter what (except for cases where Python has no chance of entering the __exit__ method of the contextmanager, for example an abrupt system shutdown or similar really exceptional stuff).But if you need to perform some local and important cleanup then using a try/except/finally might make more sense. An important keyword in this context is: separation of concerns.Say you call a function that hypothetically creates an object that isn't managed by Pythons GC and open a file and try to write it to a file. In this case you need to perform more cleanup than just opening and closing the file:I had a really hard time to think of an example where it's of advantage to use try/finally instead of just creating a contextmanager and I'm not sure I suceeded (Normally I would implement this example as contextmanager :-) ). The important part should be that contextmanagers perform a default cleanup operation not localized, custom cleanup.


Answer URL
https://docs.python.org/3/reference/compound_stmts.html#with
