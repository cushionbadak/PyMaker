Natural Text
I'm trying to implement a tcp 'echo server'.Simple stuff:Client sends a message to the server.Server receives the messageServer converts message to uppercaseServer sends modified message to clientClient prints the response.It worked well, so I decided to parallelize the server; make it so that it could handle multiple clients at time.Since most Python interpreters have a GIL, multithreading won't cut it.I had to use multiproces... And boy, this is where things went downhill.I'm using Windows 10 x64 and the WinPython suit with Python 3.5.2 x64.My idea is to create a socket, intialize it (bind and listen), create sub processes and pass the socket to the children.But for the love of me... I can't make this work, my subprocesses die almost instantly.Initially I had some issues 'pickling' the socket...So I googled a bit and thought this was the issue. So I tried passing my socket thru a multiprocessing queue, through a pipe and my last attempt was 'forkpickling' and passing it as a bytes object during the processing creating.Nothing works.Can someone please shed some light here?Tell me whats wrong?Maybe the whole idea (sharing sockets) is bad... And if so, PLEASE tell me how can I achieve my initial objective: enabling my server to ACTUALLY handle multiple clients at once (on Windows) (don't tell me about threading, we all know python's threading won't cut it ¬¬)It also worth noting that no files are create by the debug function.No process lived long enough to run it, I believe.The typical output of my server code is (only difference between runs is the process numbers):The server code:edit: fixed the signature of "listen". My processes still die instantly.edit2: User cmidi pointed out that this code does work on Linux; so my question is: How can I 'made this work' on Windows?
You can directly pass a socket to a child process. multiprocessing registers a reduction for this, for which the Windows implementation uses the following DupSocket class from multiprocessing.resource_sharer:This calls the Windows socket share method, which returns the protocol info buffer from calling WSADuplicateSocket. It registers with the resource sharer to send this buffer over a connection to the child process. The child in turn calls detach, which receives the protocol info buffer and reconstructs the socket via socket.fromshare.It's not directly related to your problem, but I recommend that you redesign the server to instead call accept in the main process, which is the way this is normally done (e.g. in Python's socketserver.ForkingTCPServer module). Pass the resulting (conn, address) tuple to the first available worker over a multiprocessing.Queue, which is shared by all of the workers in the process pool. Or consider using a multiprocessing.Pool with apply_async.
def listen() the target/start for your child processes does not take any argument but you are providing serialized socket as an argument  args=(picklez,) to the child process this would cause an exception in the child process and exit immediately.def listen(picklez) should solve the problem this will provide one argument to the target of your child processes.


Answer URL
https://docs.python.org/3/library/socket.html#socket.socket.share
https://docs.python.org/3/library/socketserver.html#socketserver.ForkingTCPServer
https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing.pool
