Natural Text
I'm running Python 2.7.10.I need to intercept changes in a list. By "change" I mean anything that modifies the list in the shallow sense (the list is not changed if it consists of the same objects in the same order, regardless of the state of those objects; otherwise, it is). I don't need to find out how the list has changed, only that it has. So I just make sure I can detect that, and let the base method do its work. This is my test program:Cases #1, #2, #3, and #5 work as I expected; #4, #6, and #7 don't. The program prints:I'm not terribly surprised by #7: append is probably implemented in an ad-hoc way. But for #4 and #6 I am confused. The __getitem__ documentation says: "Called to implement evaluation of self[key]. For sequence types, the accepted keys should be integers and slice objects." (my emphasys). And for __setitem__: " Same note as for __getitem__()", which I take to mean that key can also be a slice.What's wrong with my reasoning? I'm prepared, if necessary, to override every list-modifying method (append, extend, insert, pop, etc.), but what should override to catch something like #6?I am aware of the existence of __setslice__, etc. But those methods are deprecated since 2.0 ...Hmmm. I read again the docs for __getslice__, __setslice__, etc., and I find this bone-chilling statement:"(However, built-in types in CPython currently still implement __getslice__(). Therefore, you have to override it in derived classes when implementing slicing.)"Is this the explanation? Is this saying "Well, the methods are deprecated, but in order to achieve the same functionality in 2.7.10 as you had in 2.0 you still have to override them"? Alas, then why did you deprecate them? How will things work in the future? Is there a "list" class - that I am not aware of - that I could extend and would not present this inconvenience?  What do I really need to override to make sure I catch every list-modifying operation?
Your problem is that you are subclassing a builtin, and so have to deal with a few wrinkles.  Before I delve into the issue, I'll go straight to the "better" answer:How will things work in the future? Is there a "list" class - that I am not aware of - that I could extend and would not present this inconvenience? Yes, the modern way to do this is to use python's Abstract Base Classes.  You can avoid these ugly complications you are seeing when subclassing builtin list, by using the ABCs instead.  For something list-like, try subclassing MutableSequence:Now you should only need to deal with __getitem__ and friends for slicing behaviour.  If you want to push ahead with subclassing the builtin list, read on...Your guess is correct, you will need to override __getslice__ and __setslice__.  The language reference explains why and you already saw that:However, built-in types in CPython currently still implement __getslice__(). Therefore, you have to override it in derived classes when implementing slicing.Note that l[3:7] will hook into __getslice__, whereas the otherwise equivalent l[3:7:] will hook into __getitem__.  So you have to handle slices in both... groan!


Answer URL
https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableSequence
