Natural Text
What is the best possible way to check if a string can be represented as a number in Python? The function I currently have right now is:Which, not only is ugly and slow, seems clunky. However I haven't found a better method because calling float in the main function is even worse. 
Which, not only is ugly and slowI'd dispute both.A regex or other string parsing would be uglier and slower.  I'm not sure that anything much could be faster than the above.  It calls the function and returns.  Try/Catch doesn't introduce much overhead because the most common exception is caught without an extensive search of stack frames.The issue is that any numeric conversion function has two kinds of resultsA number, if the number is validA status code (e.g., via errno) or exception to show that no valid number could be parsed.C (as an example) hacks around this a number of ways.  Python lays it out clearly and explicitly.I think your code for doing this is perfect.
In case you are looking for parsing (positive, unsigned) integers instead of floats, you can use the isdigit() function for string objects.String Methods - isdigit()There's also something on Unicode strings, which I'm not too familiar withUnicode - Is decimal/decimal
TL;DR The best solution is s.replace('.','',1).isdigit()I did some benchmarks comparing the different approachesIf the string is not a number, the except-block is quite slow. But more importantly, the try-except method is the only approach that handles scientific notations correctly.Float notation ".1234" is not supported by:- is_number_regex  Scientific notation "1.000000e+50" is not supported by:- is_number_regex- is_number_repl_isdigitScientific notation "1e50" is not supported by:- is_number_regex- is_number_repl_isdigit  EDIT: The benchmark resultswhere the following functions were tested
There is one exception that you may want to take into account: the string 'NaN'If you want is_number to return FALSE for 'NaN' this code will not work as Python converts it to its representation of a number that is not a number (talk about identity issues):Otherwise, I should actually thank you for the piece of code I now use extensively. :)G.
how about this:which will return true only if there is one or no '.' in the string of digits.will return falseedit: just saw another comment ...adding a .replace(badstuff,'',maxnum_badstuff) for other cases can be done. if you are passing salt and not arbitrary condiments (ref:xkcd#974) this will do fine :P
Updated after Alfe pointed out you don't need to check for float separately as complex handles both:Previously said: Is some rare cases you might also need to check for complex numbers (e.g. 1+2i), which can not be represented by a float:
Which, not only is ugly and slow, seems clunky.It may take some getting used to, but this is the pythonic way of doing it.  As has been already pointed out, the alternatives are worse.  But there is one other advantage of doing things this way:  polymorphism.The central idea behind duck typing is that "if it walks and talks like a duck, then it's a duck."  What if you decide that you need to subclass string so that you can change how you determine if something can be converted into a float?  Or what if you decide to test some other object entirely?  You can do these things without having to change the above code.Other languages solve these problems by using interfaces.  I'll save the analysis of which solution is better for another thread.  The point, though, is that python is decidedly on the duck typing side of the equation, and you're probably going to have to get used to syntax like this if you plan on doing much programming in Python (but that doesn't mean you have to like it of course).One other thing you might want to take into consideration: Python is pretty fast in throwing and catching exceptions compared to a lot of other languages (30x faster than .Net for instance).  Heck, the language itself even throws exceptions to communicate non-exceptional, normal program conditions (every time you use a for loop).  Thus, I wouldn't worry too much about the performance aspects of this code until you notice a significant problem.
For int use this:But for float we need some tricks ;-). Every float number has one point...Also for negative numbers just add lstrip():And now we get a universal way:
Just Mimic C#In C# there are two different functions that handle parsing of scalar values:Float.Parse()Float.TryParse()float.parse():Note: If you're wondering why I changed the exception to a TypeError, here's the documentation.float.try_parse():Note: You don't want to return the boolean 'False' because that's still a value type. None is better because it indicates failure. Of course, if you want something different you can change the fail parameter to whatever you want.To extend float to include the 'parse()' and 'try_parse()' you'll need to monkeypatch the 'float' class to add these methods.If you want respect pre-existing functions the code should be something like:SideNote: I personally prefer to call it Monkey Punching because it feels like I'm abusing the language when I do this but YMMV.Usage:And the great Sage Pythonas said to the Holy See Sharpisus, "Anything you can do I can do better; I can do anything better than you."
For strings of non-numbers, try: except: is actually slower than regular expressions.  For strings of valid numbers, regex is slower.  So, the appropriate method depends on your input. If you find that you are in a performance bind, you can use a new third-party module called fastnumbers that provides a function called isfloat.  Full disclosure, I am the author.  I have included its results in the timings below.As you can seetry: except: was fast for numeric input but very slow for an invalid inputregex is very efficient when the input is invalidfastnumbers wins in both cases
I know this is particularly old but I would add an answer I believe covers the information missing from the highest voted answer that could be very valuable to any who find this:For each of the following methods connect them with a count if you need any input to be accepted. (Assuming we are using vocal definitions of integers rather than 0-255, etc.)x.isdigit()works well for checking if x is an integer.x.replace('-','').isdigit()works well for checking if x is a negative.(Check - in first position)x.replace('.','').isdigit()works well for checking if x is a decimal.x.replace(':','').isdigit()works well for checking if x is a ratio.x.replace('/','',1).isdigit()works well for checking if x is a fraction.
Casting to float and catching ValueError is probably the fastest way, since float() is specifically meant for just that. Anything else that requires string parsing (regex, etc) will likely be slower due to the fact that it's not tuned for this operation. My $0.02.
You can use Unicode strings, they have a method to do just what you want:Or:http://www.tutorialspoint.com/python/string_isnumeric.htmhttp://docs.python.org/2/howto/unicode.html
I wanted to see which method is fastest. Overall the best and most consistent results were given by the check_replace function. The fastest results were given by the check_exception function, but only if there was no exception fired - meaning its code is the most efficient, but the overhead of throwing an exception is quite large.Please note that checking for a successful cast is the only method which is accurate, for example, this works with check_exception but the other two test functions will return False for a valid float:Here is the benchmark code:Here are the results with Python 2.7.10 on a 2017 MacBook Pro 13:Here are the results with Python 3.6.5 on a 2017 MacBook Pro 13:Here are the results with PyPy 2.7.13 on a 2017 MacBook Pro 13:
This answer provides step by step guide having function with examples to find the string is:Positive integerPositive/negative - integer/floatHow to discard "NaN" (not a number) strings while checking for number?Check if string is positive integerYou may use str.isdigit() to check whether given string is positive integer. Sample Results:Check for string as positive/negative - integer/floatstr.isdigit() returns False if the string is a negative number or a float number. For example:If you want to also check for the negative integers and float, then you may write a custom function to check for it as:Sample Run:Discard "NaN" (not a number) strings while checking for numberThe above functions will return True for the "NAN" (Not a number) string because for Python it is valid float representing it is not a number. For example:In order to check whether the number is "NaN", you may use math.isnan() as:Or if you don't want to import additional library to check this, then you may simply check it via comparing it with itself using ==. Python returns False when nan float is compared with itself. For example:Hence, above function is_number can be updated to return False for "NaN" as:Sample Run:PS: Each operation for each check depending on the type of number comes with additional overhead. Choose the version of is_number function which fits your requirement.
Lets say you have digits in string.str = "100949"and you would like to check if it has only numbersisdigit docsotherwise your method works great to find the occurrence of a digit in a string. 
So to put it all together, checking for Nan, infinity and complex numbers (it would seem they are specified with j, not i, i.e. 1+2j) it results in:
Your code looks fine to me.Perhaps you think the code is "clunky" because of using exceptions?  Note that Python programmers tend to use exceptions liberally when it improves code readability, thanks to its low performance penalty.
I did some speed test. Lets say that if the string is likely to be a number the try/except strategy is the fastest possible.If the string is not likely to be a number and you are interested in Integer check, it worths to do some test (isdigit plus heading '-'). If you are interested to check float number, you have to use the try/except code whitout escape.
I needed to determine if a string cast into basic types (float,int,str,bool). After not finding anything on the internet I created this:ExampleYou can capture the type and use it 
The input may be as follows:a="50"b=50c=50.1d="50.1"1-General input:The input of this function can be everything!Finds whether the given variable is numeric. Numeric strings consist of optional sign, any number of digits, optional decimal part and optional exponential part. Thus +0123.45e6 is a valid numeric value. Hexadecimal (e.g. 0xf4c3b00c) and binary (e.g. 0b10100111001) notation is not allowed.is_numeric functiontest:is_float functionFinds whether the given variable is float. float strings consist of optional sign, any number of digits, ...test:what is ast?2- If you are confident that the variable content is String:use str.isdigit() method3-Numerical input:detect int value:detect float:
RyanN suggestsIf you want to return False for a NaN and Inf, change line to x = float(s); return (x == x) and (x - 1 != x). This should return True for all floats except Inf and NaNBut this doesn't quite work, because for sufficiently large floats, x-1 == x returns true. For example, 2.0**54 - 1 == 2.0**54
I also used the function you mentioned, but soon I notice that strings as "Nan", "Inf" and it's variation are considered as number. So I propose you improved version of your function, that will return false on those type of input and will not fail "1e3" variants:
If you want to know if the entire string can be represented as a number you'll want to use a regexp (or maybe convert the float back to a string and compare it to the source string, but I'm guessing that's not very fast).
Here's my simple way of doing it. Let's say that I'm looping through some strings and I want to add them to an array if they turn out to be numbers.Replace the myvar.apppend with whatever operation you want to do with the string if it turns out to be a number. The idea is to try to use a float() operation and use the returned error to determine whether or not the string is a number.
You can generalize the exception technique in a useful way by returning more useful values than True and False.  For example this function puts quotes round strings but leaves numbers alone.  Which is just what I needed for a quick and dirty filter to make some variable definitions for R. 
I was working on a problem that led me to this thread, namely how to convert a collection of data to strings and numbers in the most intuitive way.  I realized after reading the original code that what I needed was different in two ways:1 - I wanted an integer result if the string represented an integer2 - I wanted a number or a string result to stick into a data structureso I adapted the original code to produce this derivative:
Try this.
This code handles the exponents, floats, and integers, wihtout using regex.
use following it handles all cases:-


Answer URL
https://docs.python.org/3/library/functions.html#float
https://docs.python.org/3/c-api/float.html
