Natural Text
I have an large script where i found out that lot of connections to a machine are left open and the reason was that for one of the class destructor was never getting called. below is a simplified version of script manifesting the issue. I tiered searching around and found out that it could be because of GC and weakref does help but in this case no help.2 cases where i can see that the destructor is getting called areIf i call B_class object without passing A_class functionI call the make the B_class objects not global i.e not use selfBoth of these cases will cause further issues for my case. Last resort will be to close/del the objects at the end myself but i don't want to go that way.can anybody suggest a better way out of this and help me understand this issue? Thanks in advance.
You're not using the weakref.ref object properly. You're calling it immediately after it is created, which returns the referred-to object (the function passed in as printref).Normally, you'd want to save the weak reference and only call it when you're going to use the reffered-to object (e.g. in myprint). However, that won't work for the bound method self.myprint you're getting passed in as printfunc, since the bound method object doesn't have any other references (every access to a method creates a new object).If you're using Python 3.4 or later and you know that the object passed in will always be a bound method, you can use the WeakMethod class, rather than a regular ref. If you're not sure what kind of callable you're going to get, you might need to do some type checking to see if WeakMethod is required or not.
Use Python's "with" statement (http://www.python.org/dev/peps/pep-0343/).It creates a syntactic scope and the __exit__ function which it creates is guaranteed to get called as soon as execution leaves the scope.  You can also emulate "__enter__/__exit__" behavior by creating a generator with "contextmanager" decorator from the contextlib module (python 2.6+ or 2.5 using "from __future__ import with_statement" see PEP for examples).Here's an example from the PEP:and then in your main code, you writeIn your case, you'll want to use a different name (connecting or something) instead of "opening" and do socket connecting/disconnecting inside of your context manager.
isn't actually using weakrefs to solve your problem; the line is effectively a noop. You create a weakref with weakref.ref(printfunc), but you follow it up with call parens, which converts back from weakref to a strong ref which you store (and the weakref object promptly disappears). Apparently it's not possible to store a weakref to the bound method itself (because the bound method is its own object created each time it's referenced on self, not a cached object whose lifetime is tied to self), so you have to get a bit hacky, unbinding the method so you can take a weakref on the object itself. Python 3.4 introduced WeakMethod to simplify this, but if you can't use that, then you're stuck doing it by hand.Try changing it to (on Python 2.7, and you must import inspect):and change myprint to:Yeah, it's ugly. You could factor out the ugly if you like (borrowing the implementation of WeakMethod from Python 3.4's source code would make sense, but names would have to change; __self__ is im_self in Py2, __func__ is im_func), but it's unpleasant even so. It's definitely not thread safe if the weakrefs could actually go dark, since the checks and clears of the weakref members aren't protected.


Answer URL
https://docs.python.org/3/library/weakref.html#weakref.WeakMethod
https://docs.python.org/3/library/weakref.html#weakref.WeakMethod
https://docs.python.org/3/whatsnew/3.4.html#pep-442-safe-object-finalization
