Natural Text
Let's assume I have the following code:The problem with this code is that the loop inside async coroutine is never finishing the first iteration, while queue size is increasing.Why is this happening this way and what can I do to fix it?I can't get rid of separate thread, because in my real code I use a separate thread to communicate with a serial device, and I haven't find a way to do that using asyncio.
asyncio.Queue is not thread-safe, so you can't use it directly from more than one thread. Instead, you can use janus, which is a third-party library that provides a thread-aware asyncio queue:There is also aioprocessing (full-disclosure: I wrote it), which provides process-safe (and as a side-effect, thread-safe) queues as well, but that's overkill if you're not trying to use multiprocessing.
If you do not want to use another library you can schedule a coroutine from the thread. Replacing the queue.put_nowait with the following works fine.The variable loop represents the event loop in the main thread. EDIT:The reason why your async coroutine is not doing anything is thatthe event loop never gives it a chance to do so. The queue object isnot threadsafe and if you dig through the cpython code you find thatthis means that put_nowait wakes up consumers of the queue throughthe use of a future with the call_soon method of the event loop. Ifwe could make it use call_soon_threadsafe it should work. The majordifference between call_soon and call_soon_threadsafe, however, isthat call_soon_threadsafe wakes up the event loop by calling loop._write_to_self() . So let's call it ourselves:Then, everything works as expected. As for the threadsafe aspect ofaccessing shared objects,asyncio.queue uses under the hoodcollections.deque which has threadsafe append and popleft.Maybe checking for queue not empty and popleft is not atomic, but ifyou consume the queue only in one thread (the one of the event loop)it could be fine.The other proposed solutions, loop.call_soon_threadsafe from HuazuoGao's answer and my asyncio.run_coroutine_threadsafe are just doingthis, waking up the event loop.
BaseEventLoop.call_soon_threadsafe is at hand. See asyncio doc for detail.Simply change your threaded() like this:Here's a sample output:
What about just using threading.Lock with asyncio.Queue?See also - asyncio: Wait for event from other thread


Answer URL
https://docs.python.org/3/library/asyncio-queue.html#asyncio.Queue
https://docs.python.org/3/library/asyncio-dev.html#concurrency-and-multithreading
