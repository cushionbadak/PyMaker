Natural Text
Why does setdefault not increment by 1 for every occurrence in a inside a dictionary comprehension, but it does in a loop? What's going on here? Alternative solutions are great. I'm mostly interested in understanding why this doesn't work. A loop with setdefault worksA dictionary comprehension with setdefault doesn't workUpdateThanks for the answers, I wanted to try timing the solutions.
There is no dictionary yet inside the dict comprehension. You are building a completely new dictionary, replacing whatever b was bound to before.In other words, in your dictionary comprehension, b.setdefault() is a totally different dictionary, it has nothing to do with the object being built by the comprehension.In fact, your dictionary comprehension only works if b was bound to an object with a .setdefault() method before you run the expression. If b is not yet defined, or not bound to an object with such a method, it simply fails with an exception:You cannot do what you want with a dictionary comprehension, unless you group your numbers, which requires sorting and itertools.groupby(); this is not an efficient approach (requiring O(NlogN) steps rather than O(N)):Note that the standard library already comes with a tool to do counting; see the collections.Counter() object:
Actually, your second snippet raises a NameError if you try it in a clean namespace (one where there's no prior definition of b):Which should give you a hint at what went wrong.The statement:first evaluates (well, actually tries to...) the right-hand side expression {k: b.setdefault(k, 0) + 1 for k in a}, and then binds the result to name b. If b is not defined when the expression is eval'd, you get the above exception (of course). If it's defined and bound to a dict (or whatever have a  setdefault(x, y) method FWIW) you get the result of calling setdefault() on whathever b is bound to at this point.
This does not work because b is not defined before the dictionary comprehension is completed. Normally, you should get a NameError for this; if not, then because you already defined b before, but this will be a different dictionary.Having said that: It seems that you can just use collections.Counter for this.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.groupby
