Natural Text
I'm running into a bug with the heapq library -- the heappush function in particular. The error code (below) gives me no help.Here's the snippet that is causing the problem...I should note that h and depth are int's and child_node_puzzle_state is a numpy array. Checkout out some of the debugging code...Here's what I cannot figure out... if I change one little thing it works -- but it is semantically wrong. Here's is the change ...Did you catch the difference? Instead of computing f = h + depth I just use h. And magically it works? This couldn't be the size, because as I showed in debugging...This really doesn't make sense to me, so I'm going to include more code. First, here is everything needed to compute h there is nothing funky going on, so I really doubt this is the problem. All the functions return integers (although they use numpy arrays)...
heapq.heappush will compare an array with other arrays in the heap, if the preceding elements in the tuple you push are otherwise equal.Here is a pure Python implementation of heappush():The actual implementation will be in C, which is why you get the error without a deeper traceback.Note the newitem < parent comparison; it is that comparison that is throwing the exception, as numpy array objects would be compared element by element and produce a boolean array with true and false results. If there is a state in your heap where f and depth are equal, that comparison must compare the arrays:For you the problem 'disappeared' when you changed the value in the first position of the tuple, making the first two values unique again compared to what is already in your heap. But it doesn't actually solve the underlying problem.You can avoid this issue by inserting a unique count (using itertools.count()) before the array:The counter ensures that the first three elements of your tuples are always unique. It also means that any later addition to the heap that matches an already-present state on the heuristic score and depth are sorted before older ones. You can use count(step=-1) if you want to inverse that relationship.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.count
