Natural Text
I'm not sure how you name the n in the following for loop. Is there are a term for it? And, am I correct that the list itself is the iterator of the for loop ? 
The example you gave is an "iterator-based for-loop"n is called the loop variable.The role that list plays is more troublesome to name.Indeed, after an interesting conversation with @juanpa.arrivillaga I've concluded that there simply isn't a "clearly correct formal name", nor a commonly used name, for that syntactic element.That being said, I do think that if you referred to it in context in a sentence as "the loop iterator" everyone would know what you meant.In doing so, you take the risk of confusing yourself or someone else with the fact that the syntactic element in that position is not in fact an iterator, its a collection or (loosely, but from the definition in the referenced article) an "iterable of some sort".I suspect that one reason why there isn't a name for this is that we hardly ever have to refer to it in a sentence.  Another is that they types of element that can appear in that position vary widely, so it is hard to safely cover them all with a label. 
While n is called a loop variable the list is absolutely not an iterator. It is iterable object, i.e. and iterable, but it is not an iterator. An iterable may be an iterator itself, but not always. That is to say, iterators are iterable, but not all iterables are iterators. In the case of a list it is simply an iterable. It is an iterable because it implements an __iter__ method, which returns an iterator:From the Python Glossary an iterable is:An object capable of returning its members one at a time. Examples of  iterables include all sequence types (such as list, str, and tuple)  and some non-sequence types like dict, file objects, and objects of  any classes you define with an __iter__() or __getitem__() method.  Iterables can be used in a for loop and in many other places where a  sequence is needed (zip(), map(), ...). When an iterable object is  passed as an argument to the built-in function iter(), it returns an  iterator for the object. This iterator is good for one pass over the  set of values. When using iterables, it is usually not necessary to  call iter() or deal with iterator objects yourself. The for statement  does that automatically for you, creating a temporary unnamed variable  to hold the iterator for the duration of the loop. So, observe:    It is illuminating to understand that a for-loop in Python such as the following:is equivalent to:Iterators, which are returned by a call to an object's __iter__ method, also implement the __iter__ method (usually returning themselves) but they also implement a __next__ method. Thus, an easy way to check if something is an iterable is to see if it implements a next methodAgain, from the Python Glossary, an iterator is:An object representing a stream of data. Repeated calls to the  iteratorâ€™s __next__() method (or passing it to the built-in function  next()) return successive items in the stream. When no more data are  available a StopIteration exception is raised instead. At this point,  the iterator object is exhausted and any further calls to its  __next__() method just raise StopIteration again. Iterators are required to have an __iter__() method that returns the iterator object  itself so every iterator is also iterable and may be used in most  places where other iterables are accepted. One notable exception is  code which attempts multiple iteration passes. A container object  (such as a list) produces a fresh new iterator each time you pass it  to the iter() function or use it in a for loop. Attempting this with  an iterator will just return the same exhausted iterator object used  in the previous iteration pass, making it appear like an empty  container.I've illustrated the bevahior of an iterator with the next function above, so now I want to concentrate on the bolded portion.Basically, an iterator can be used in the place of an iterable because iterators are always iterable. However, an iterator is good for only a single pass. So, if I use a non-iterator iterable, like a list, I can do stuff like this:And this:An iterator behaves almost in the same way, so I can still do this:However, iterators do not support multiple iteration (well, you can make your an iterator that does, but generally they do not):Why is that? Well, recall what is happening with the iterator protocol which is used by a for loop under the hood, and consider the following:When I used iter() on an iterator, it returned itself!


Answer URL
https://docs.python.org/3/glossary.html#term-iterable
https://docs.python.org/3/glossary.html#term-iterator
