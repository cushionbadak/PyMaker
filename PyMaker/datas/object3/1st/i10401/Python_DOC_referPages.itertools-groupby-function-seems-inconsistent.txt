Natural Text
I'm having trouble understanding exactly what it is that this function does because of I guess, the programming magic around its use?It seems to me like it returns a list of keys (unique letters in a string) paired with iterators, that reference a list of the number of each of those letters in the original string, but sometimes it seems like this is not the case.For example:which prints:This seems correct, we have our unique keys paired with iterators. But when I run:I get:and when I runI get:It ignores the first element. This seems counter-intuitive, because if I just change the syntax a little bit:I get:which is right, and aligns with what I think this function should be doing.However, if I once again change the syntax just a bit:I get back:These two list comprehensions should be directly equivalent, but they return different results.What is going on? Insight would be extremely appreciated.
The docs already explain why your listcomps aren't equivalent:The returned group is itself an iterator that shares the underlying iterable with groupby(). Because the source is shared, when the groupby() object is advanced, the previous group is no longer visible. So, if that data is needed later, it should be stored as a listYourdoes use each group before groupby() advances, so it works.Yourdoesn't use any group until after all groups have been generated.  Not at all the same, and for the reason the quoted docs explained.
To get the answers you expect, convert the returned iterators to a list.Groupby consumes an input iterator lazily (that means that it reads data only as needed).  To find a new group, it needs to read up to next non-equal element (the first member of the next group).  If you list the subgroup iterator, it will advance the input to the end of the current group.In general, if you advance to the next group, then the previously returned subgroup iterator won't have an data and will appear empty.  So, if you need the data in the subgroup iterator, you need to list it before advancing to the next group.The reason for this behavior is that iterators are all about looking a one piece of data at a time and not keeping anything unnecessary in memory.Here's some code that make all the operations visible:In the example "that is driving you crazy", the list operation is being applied too late (in the outer list comprehension).  The solution is to move the list step to the inner comprehension:If you don't really care about conserving memory, then running grouped = [list(g) for k, g in itertools.groupby(data)] is a perfectly reasonable way to go.  Then you can lookup data in any of the sublists whenever you want and not be subject to rules about when the iterator is consumed.  In general, list of lists are easier to work with than iterators.  Hope this helps :-)


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.groupby
