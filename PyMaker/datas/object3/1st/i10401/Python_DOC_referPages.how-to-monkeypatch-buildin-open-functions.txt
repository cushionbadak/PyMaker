Natural Text
How do I test the following code with mocks (using mocks, the patch decorator and sentinels provided by Michael Foord's Mock framework):
The way to do this has changed in mock 0.7.0 which finally supports mocking the python protocol methods (magic methods), particularly using the MagicMock:http://www.voidspace.org.uk/python/mock/magicmock.htmlAn example of mocking open as a context manager (from the examples page in the mock documentation):
There is lot of noise in these answers; almost all are correct but outdated and not neat. mock_open is part of mock framework and is very simple to use. patch used as context returns the object used to replace the patched one: you can use it to make your test simpler.Python 3.xUse builtins instead of __builtin__.Python 2.7mock is not part of unittest and you should patch __builtin__Decorator caseIf you would use patch as decorator using mock_open()'s result as the new patch's argument can be a little bit weird. In this case is better to use the new_callable patch's argument and remember that every extra arguments that patch doesn't use will be passed to new_callable function as described in patch documentation.patch() takes arbitrary keyword arguments. These will be passed to the Mock (or new_callable) on construction.For instance decorated version for Python 3.x is:Remember that in this case patch will add the mock object as argument of you test function.
With the latest versions of mock, you can use the really useful mock_open helper:mock_open(mock=None, read_data=None) A helper function to create a  mock to replace the use of open. It works for open called directly or  used as a context manager.The mock argument is the mock object to configure. If None (the  default) then a MagicMock will be created for you, with the API  limited to methods or attributes available on standard file handles.read_data is a string for the read method of the file handle to  return. This is an empty string by default.
To use mock_open for a simple file read() (the original mock_open snippet already given on this page is geared more for write):Note as per docs for mock_open, this is specifically for read(), so won't work with common patterns like for line in f, for example.Uses python 2.6.6 / mock 1.0.1
I might be a bit late to the game, but this worked for me when calling open in another module without having to create a new file.test.pyMyObj.pyBy patching the open function inside the __builtin__ module to my mock_open(), I can mock writing to a file without creating one.Note: If you are using a module that uses cython, or your program depends on cython in any way, you will need to import cython's __builtin__ module by including import __builtin__ at the top of your file. You will not be able to mock the universal __builtin__ if you are using cython.
The top answer is useful but I expanded on it a bit.If you want to set the value of your file object (the f in as f) based on the arguments passed to open() here's one way to do it:Basically, open() will return an object and with will call __enter__() on that object.To mock properly, we must mock open() to return a mock object. That mock object should then mock the __enter__() call on it (MagicMock will do this for us) to return the mock data/file object we want (hence mm.__enter__.return_value). Doing this with 2 mocks the way above allows us to capture the arguments passed to open() and pass them to our do_something_with_data method.I passed an entire mock file as a string to open() and my do_something_with_data looked like this:This transforms the string into a list so you can do the following as you would with a normal file:


Answer URL
https://docs.python.org/3/library/unittest.mock.html#mock-open
https://docs.python.org/3/library/unittest.mock.html#module-unittest.mock
https://docs.python.org/3/library/unittest.mock.html#patch
https://docs.python.org/3/library/unittest.mock.html#patch
