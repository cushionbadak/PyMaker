Natural Text
I am reading lines from a file one at a time and before i store each, i wanna modify them according to the following simple rule:if the last character is not any of, e.g., {'a', 'b', 'c'} store the line.if that is not the case, remove the character (pop-like) and check again.What i currently have (felt like the obvious thing to do) is this:Which of course works, but the string slicing\reconstruction seems a bit too excessive to my untrained eyes. So i was wondering a couple of things:is there a better way to do this? like a pop type of function for strings?how is rstrip() or strip() in general implemented? is it also with a while?would it be worthwhile making rstrip() recursive for this example?Finally, how much better is the following:Any comment on any of the points made above would be appreciated â˜º.Note: the separator ("|") is only there for visualization.
Another nearly fast approach to re.sub albeit more intuitive (it sounds like the pop you're asking for) is itertools.dropwhile:Make an iterator that drops elements from the iterable as long as the  predicate is true;However, it appears rstrip was made and more suited for a task as this.Some timings:rstrip wins!
Slicing creates lots of unnecessary temporary copies of string. Recursion would be even worse - copies would still be made, and on top of it function call overhead would be intruduced. Both approaches are not that great.You may find an rstrip implementation in CPython source code. An iterative approach (similar to your last code snippet) is used there.So to sum up, your intuition to use index-based parsing is correct. Main advantage is that no temporary strings are created and copying things in memory is significantly reduced.
Not the direct answer to the question, but one alternative option would be to use regular expressions to remove the bad characters at the end of the string:The regular expression here is dynamically constructed from the set of "bad" characters. It would (or "could", since sets have no order) be [abc]+$ in this case:[abc] defines a "character class" - any of "a", "b" or "c" would be matched+ means 1 or more   $ defines the end of the string(Note that, if "bad" characters can contain a character that may have a special meaning in the character class (like, for example, [ or ]), it should be escaped with re.escape()).The last statement though may prove that old saying about having more problems than initially.
I understand what you mean by excessive, but I think in general, it looks good. The alternative would be to work with indices, which is not very readable. (I also happen to think that regexes are not very readable either...)You could, however, use a memoryview if you have a bytes object which may or may not be relevant:https://docs.python.org/3/library/stdtypes.html#memoryview1. pop function for stringsNo there are no .pop method for str. You'd have to use list(line_string).pop(), where list(s) creates a list with each character of the string as an element.2. (r)strip implementationThis is probably implemented with a while, yes.It should be all C code though.3. recursive rstripFirst of all, why would you need to make it recursive?Second, I think that (recursiveness) would make the mental load unnecessarily high -- so, no.4. Finally, how much better is the following:Measure it! Surely it would be faster.


Answer URL
https://docs.python.org/3/library/stdtypes.html#memoryview
