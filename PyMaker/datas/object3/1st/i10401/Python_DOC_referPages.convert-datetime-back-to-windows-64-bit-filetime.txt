Natural Text
I would like to create network timestamps in NT format.I've been able to convert them to readable time with this function:Output:Now I'd like to do the opposite, converting '2016/09/08 11:35:57' sec to this format:
If you understand how to perform the conversion in one direction, doing it in reverse is basically using the inverse of each method in reverse order. Just look at the documentation for the modules/classes you're using:strftime has a strptime counterpartfromtimestamp is matched by timestamp (if you're on pre-3.3 Python, timestamp doesn't exist, but you could define FILETIME_epoch = datetime.datetime(1601, 1, 1) - datetime.timedelta(seconds=time.altzone if time.daylight else time.timezone) outside the function to precompute a datetime that represents the FILETIME epoch for your timezone, then use int((mydatetime - FILETIME_epoch).total_seconds()) to get int seconds since FILETIME epoch directly, without manually adjusting for difference between FILETIME and Unix epoches separately)divmod (which you don't really need, since you only use the quotient, not the remainder, you could just do Epoch = (Ftime - 116444736000000000) // 10000000 and avoid indexing later) is trivially reversible (just multiply and add, with the add being unnecessary if you use my trick to convert to FILETIME epoch seconds directly from #2)struct.unpack is matched by struct.packI'm not providing the exact code because you really should learn to use these things yourself (and read the docs when necessary); I'm guessing your forward code was written without understanding what it is doing, because if you understood it, the reverse should have been obvious; every step has an inverse documented on the same page.
    Your code that converts the Window's FILETIME value into a datetime.datetime isn't as accurate as it could be—it's truncating any fractional seconds there might have been (because it ignores the remainder of the divmod() result). This isn't noticeable in the readable string your code creates since it only shows whole seconds.    Even if the fractional seconds are included, you can't do exactly what you want because the Windows FILETIME structure has values in intervals of 100-nanosecond (.1 microsecond), but Python's datetime only supports accuracy to whole microseconds. So best that's possible to do is approximate the original value due to this loss of information involved even doing the most accurate possible conversion.Here's code, for both Python 2 and 3, demonstrating this using the NetworkStamp test value in your question:Output:


Answer URL
https://docs.python.org/3/library/datetime.html#datetime.datetime.strptime
https://docs.python.org/3/library/datetime.html#datetime.datetime.timestamp
https://docs.python.org/3/library/struct.html#struct.pack
