Natural Text
I've been hunting for something that could be relatively stupid to some people, but to me very interesting! :-)Input and output errors have been merged with OSError in Python 3.3, so there's a change in the exception class hierarchy. One interesting feature about the builtin class OSError is that, it returns a subclass of it when passed errno and strerrorAs you can see passing errno and strerror to the constructor of OSError returns FileNotFoundError instance which is a subclass of OSError.Python Doc: The constructor often actually returns a subclass of OSError, as described in OS exceptions below. The particular subclass depends on the final errno value. This behaviour only occurs when constructing OSError directly or via an alias, and is not inherited when subclassing.I wanted to code a subclass that would behave in this way. It's mostly curiosity and not real world code. I'm also trying to know, where's the logic that creates the subclass object, is it coded in __new__ for example? If __new__ contains the logic for creating the instances of the subclasses, then inheriting from OSError would typically return this behavior, unless if there's some sort of type checking in __new__:There must be type checking then: I've been digging through C code to find out where's this code is placed exactly and since I'm not an expert in C, I suspect this is really the logic and (I'm quite skeptical about that to be frank): exceptions.cNow I'm wondering about the possibility of expanding errnomap from Python itself without playing with C code, so that OSErro can make instances of user-defined classes, if you ask me why would you do that? I would say, just for fun. 
You're correct that errnomap is the variable that holds the mapping from errno values to OSError subclasses, but unfortunately it's not exported outside the exceptions.c source file, so there's no portable way to modify it.It is possible to access it using highly non-portable hacks, and I present one possible method for doing so (using a debugger) below purely in a spirit of fun. This should work on any x86-64 Linux system.Quick explanation of how this works:gdb -p %d [...] --batch >/dev/null 2>&1 &Attach a debugger to the current Python process (os.getpid()), in unattended mode (--batch), discarding output (>/dev/null 2>&1) and in the background (&), allowing Python to continue running.b PyDict_GetItem if (PyLong_AsLongLong($rsi) == -1 ? (PyErr_Clear(), 0) : PyLong_AsLongLong($rsi)) == 0xbaadf00dWhen the Python program accesses any dictionary, break if the key is an int with a magic value (used as OSError(0xbaadf00d, '') later); if it isn't an int, we've just raised TypeError, so suppress it.call PySys_SetObject("errnomap", $rdi)When this happens, we know the dictionary being looked up in is the errnomap; store it as an attribute on the sys module.
You can't change the behavior of OSError from Python because it's not implemented in Python.For classes implemented in Python, you can write __new__ so it only returns a subclass if it's being called on the base class. Then the behavior won't be inherited.


Answer URL
https://docs.python.org/3/library/exceptions.html#os-exceptions
https://docs.python.org/3/c-api/dict.html#c.PyDict_GetItem
https://docs.python.org/3/c-api/long.html#c.PyLong_AsLongLong
https://docs.python.org/3/c-api/exceptions.html#c.PyErr_Clear
https://docs.python.org/3/c-api/sys.html#system-functions
