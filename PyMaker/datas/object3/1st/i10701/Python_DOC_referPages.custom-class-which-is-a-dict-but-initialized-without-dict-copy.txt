Natural Text
For legibility purposes, I would like to have a custom class that behaves exactly like a dict (but carries a meaningful type instead of the more general dict type):Now, is there a way of building new objects of this class in a way that does not involve copies? The naive usagein fact creates a copy of the dictionary passed as an argument, which I would like to avoid, for efficiency reasons.I tried to bypass the copy but then the class of the dict cannot be changed, in CPython:I would like to have both the ability to give an explicit class name to the dictionaries that the program manipulates and an efficient way of building such dictionaries (instead of being forced to copy a Python dict). Is this doable efficiently in Python?PS: The use case is maybe 100,000 creations of single-key Derivatives, where the key is a variable (not a string, so no keyword initialization). This is actually not slow, so "efficiency reasons" here means more something like "elegance": there is ideally no need to waste time doing a copy when the copy is not needed. So, in this particular case the question is more about the elegance/clarity that Python can bring here than about running speed.
TL;DR: There's not general-purpose way to do it unless you do it in C.Long answer:The dict class is implemented in C. Thus, there is no way to access it's internal properties - and most importantly, it's internal hash table, unless you use C.In C, you could simply copy the pointer representing the hash table into your object without having to iterate over the dict (key, value) pairs and insert them into your object. (Of course, it's a bit more complicated than this. Note that I omit memory management details).Longer answer:I'm not sure why you are concerned about efficiency.Python passes arguments as references. It rarely every copies unless you  explicitly tell it to.I read in the comments that you can't use named parameters, as the keys are actual Python objects. That leaves me to understand that you're worried about copying the dict keys (and maybe values). However, even the dictionary keys are not copied, and passed by reference! Consider this code:Thus, the only remaining area of concern is iterating through the dict and inserting the values in your Derivatives class.  This is unavoidable, unless you can somehow set the internal hash table of your class to the dict's internal hash table. There is no way to do this in pure python, as the dict class is implemented in C (as mentioned above).Note that others have suggested using generators. This seems like a good idea too - say if you were reading the derivatives from a file or if you were generating them with a simple formula. It would avoid creating the dict object in the first place. However, there will be no noticable improvements in efficiency if the generators are just wrappers around lists (or any other data structure that can contain an arbritary set of values).Your best bet is do stick with your original method. Generators are great, but they can't efficiently represent an arbritary set of values (which might be the case in your scenario). It's also not worth it to do it in C.EDIT: It might be worth it to do it in C, after all!I'm not too big on the details of the Python C API, but consider defining a class in C, for example,DerivativesBase (deriving from dict). All you do is define an __init__ function in C for DerivativesBase that takes a dict as a parameter and copies the hash table pointer from the dict into your DerivativesBase object. Then, in python, your Derivatives class derives from DerivativesBase and implements the bulk of the functionality.
By inheriting from dict you are given three possibilities for constructor arguments: (baring the {} literal)This means that, in order to instantiate your instance you must do one of the following:Pass the variables as keywords D(x=1) which are then packed into an intermediate dictionary anyway.Create a plain dictionary and pass it as a mapping.Pass an iterable of (key,value) pairs.So in all three of these cases you will need to create intermediate objects to satisfy the dict constructor.The third option for a single pair it would look like D(((var,1),)) which I highly recommend against for readability sake.So if you want your class to inherit from a dictionary, using Derivatives({var: 1}) is your most efficient and most readable option.  As a personal note if you will have thousands of single pair dictionaries I'm not sure how the dict setup is the best in the first place, you may just reconsider the basis of your class.


Answer URL
https://docs.python.org/3/library/functions.html#func-dict
