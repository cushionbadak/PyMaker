Natural Text
A little background: You'll notice my comments describe what I'll go through later. Let's say I have the following object...Now, when generating the objects I can have a dict that looks something like this: {"myContainer" : { "id" : 2, "foo" : { "id" : 3, "bar" : 1 } }} that, once created, can be called like this: myContainer.foo.id.value()In the scenario there's the self.m_field which tells the application what data type the object really is. This is referencing off of Django models but any python could apply.All containers will have an id (or pk) key to them as part of their instantiation. This is mandatory.The RubIdeally, we fill our the top level attributes and only when the user requests for the attributes that lie underneath it do we construct them based off the id value and the field type.So finally, let's say the myContainer.foo.bar attribute has a foreign key field type. If we call myContainer.foo.bar.newkey.value() the app should understand that the 'newkey' attribute does not exist, query against our django instance, store the bar attribute as the now more filled out Container, and return the newkey value that's been put to memory.The Python PitfallI'd hoped it would be a simple hasattr() but Python seems to just use getattr() with a default None (The recursion is real!). I've also had loads of trouble getting a try: except: to work.As I write this I'm realizing how much more complicated it may be due to the recursive attribute setting relying on getattr() and hasattr() Any suggestions would be greatly appreciated. - Cheers
So to answer the first part of the question: how to have __getattr__ call  self.get() only when the attribute is not defined already.  There are two attribute access methods in python classes: __getattribute__ and __getattr__.  The first is called every time an attribute lookup is attempted, the second is called only when the normal attribute lookup system fails (including lookups in superclasses).  Since you're defining __getattr__, which is only called when the attribute doesn't already exist, you can simply proxy it to a call to .get.  Where you run into recursion issues is if you try to look up another attribute of self, that also doesn't yet exist, inside of __getattr__.  The way to avoid this is to have a list of keys that require special handling and check if the current attribute requested is one of them.  This typically is only needed when implementing __getattribute__.Note that your .get method has a problem:  attr and values are undefined.  I'd give a slightly more concrete answer for what to put in __getattr__ if I knew what values for .get's attr and values want.
You could consider using the @property decorator with private internal fields. The idea would be something like:
Check this out:Here, instead of returning 'created a new key...', you create a new attribute and return it.


Answer URL
https://docs.python.org/3/reference/datamodel.html#customizing-attribute-access
