Natural Text
I read this question, but it didn't give me a clear answer:How does Python interpreter look for types?How does python interpreter know the type of a variable? I'm not looking how do get the type. I'm here looking at what happens behind the scene. In the example below, how does it associate the class int or string to my variable.How does it know that is an int:or that string:
how does it associate the class int or string to my variablePython doesn't. Variables have no type. Only the object that a variable references has a type. Variables are simply names pointing to objects.For example, the following also shows the type of an object, but no variable is involved:When you use type(variable), the variable part of the expression simply returns the object that name references, passing in the object to the type() function. When using 1 or 'foobar', the expression is a literal producing the object, which is then passed to the type() function.Python objects are simply datastructures in the interpreter memory; in CPython C structs are used. Variables are merely references (pointers) to those structures. The basic type struct in CPython is called PyObject, and this struct has a ob_type slot that tells Python what type something is. Types are simply more C structures.If you wanted to follow along in the CPython source code, you'd start at the bltinmodule.c source code (since type is a built-in name), which defines type as the PyType_Type structure. Calling a type (type is a type too) invokes their tp_new function, and PyType_Type defines that as the type_new function. This function handles calls with one argument as follows:Here x is the PyObject object you passed in; note, not a variable, but an object! So for your 1 integer object or 'foobar' string object, the Py_TYPE() macro result is returned. Py_TYPE is a macro that simply returns the ob_type value of any PyObject struct. So now you have the type object for either 1 or 'foobar'; how come you see <class 'int'> or <class 'str'> in your interpreter session? The Python interactive interpreter automatically uses the repr() function on any expression results. In the C structure for PyType_Type definitions the PyType_Type struct is incorporated so all the slots for that type are directly available; I'll omit here exactly how that works. For type objects, using repr() means the type_repr function is called which returns this:So in the end, type(1) gets the ->ob_type slot, (which turns out to be the PyLong_Type struct in Python 3, long story), and that structure has a tp_name slot set to "int".TL;DR: Python variables have no type, they are simply pointers to objects. Objects have types, and the Python interpreter will follow a series of indirect references to reach the type name to print if you are echoing the object in your interpreter.
The concept "type" of a variable is "implemented" by using objects of a specific class.So ina=float()an object of type float, as defined by the class float is returned by float().   Python knows what type it is because that's how objects work: you know what type they are.  a is now a float object, with value 0.0.With builtins, it's the same, it's just that they have shorthands for declaring them.i=123is the same as i=int(123)int() returns an object of class integer, with value 123.similarly i="123"is the same asi=str("123")str("123") returns an object of class str, with value "123"
Python variables have no type, they are just references to objects.  The size of a reference is the same regardless of what it is referring to.  In the C implementation of Python it is a pointer, and does have a type, it a pointer to a Python object: PyObject *.  The pointer is the same type regardless of class of object.  Objects, on the other hand, know which class they belong to. It has been argued that Python has no variables, only names, although that's a step too far for most people.References in the CPython implementation have an id (identifier) which is actually a virtual address.  The detail and value of this address is not worth pursuing - it can (and probably will) change between versions and is not meant to be used for anything other than a unique number identifying the object.  Nevertheless it can provide interesting pointers (pardon the pun) to what is happening:Note that the id (address) of x and y are the same - they are referencing the same object, an int with the value 42.  So, what happens when we change x, does y change as well?Thankfully not.  Now x is just referring to a new object of class str with the value "Hello".  When we:The id of y changed!  This is because it is now referencing a different object.  ints are immutable, so the assignment y = 37 did not change the original object (42) it created a new one.  The object with the value 42 has its reference count decremented and can now (in theory) be deleted.  In practice it would probably remain in memory for efficiency reason, but thats an implementation detail.   However:So changing the list a has changed b!  This is because lists are mutable, they can change.  The assignment b = a only copied the reference, not the list.  See copy in the standard library.


Answer URL
https://docs.python.org/3/c-api/structures.html#c.PyObject
https://docs.python.org/3/c-api/structures.html#c.PyObject_HEAD
https://docs.python.org/3/c-api/typeobj.html
https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_new
https://docs.python.org/3/c-api/structures.html#c.Py_TYPE
https://docs.python.org/3/library/functions.html#repr
