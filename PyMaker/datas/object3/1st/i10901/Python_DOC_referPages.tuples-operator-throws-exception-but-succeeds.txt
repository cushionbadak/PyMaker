Natural Text
This question already has an answer here:Append to a list defined in a tuple - is it a bug? [duplicate]                    4 answers                Why does the following throw an exception, although it succeeds?
Found the answer on IRC.t[0] += [1] is several discrete actions:loading t[0]building a new list with 1 in itadding that [1] to whatever t[0] isreassigning t[0]It seems that x += y is basically x = x + y (but, is it?)The tricky bit is that += implies assignment to both the tuple t and to the list t[0]t[0] += [1] is not literally t[0] = t[0] + [1], it is: t[0] = t[0].__iadd__([1])What really happens is:__iadd__ both mutates the list and returns it. So the list (which is the first element in t) has already got 1 appended to it.tuple's mutation is attempted in-place as well, but tuples are immutable, resulting in the exception.Why is this not visible in plain sight? Because a n00b like me would expect t[0] += [1] to either succeed all together or fail, because it's one short line of python. But that's not always the case.
It can also help to understand this behavior by taking a look at the bytecode with dis.dis.  The value of t[0] is placed on top of the stack with BINARY_SUBSCR, which is a (mutable) list in this case. The value on the top of the stack has += [1] performed on it with INPLACE_ADD, where in this case the top of the stack refers to the list inside the tuple. The assigning of t[0] to the top of the stack occurs with STORE_SUBSCR, which fails here as t itself is an immutable tuple, raising the error after the += assignment has already occurred. 
The Python developers wrote an official explanation about why it happens here: https://docs.python.org/2/faq/programming.html#why-does-a-tuple-i-item-raise-an-exception-when-the-addition-worksThe short version is that += actually does two things, one right after the other:Take the thing on the right and add it to the variable on the leftPut the result into the variable on the leftIn this case, step 1 works because you’re allowed to add stuff to lists (they’re mutable), but step 2 fails because you can’t put stuff into tuples after creating them (tuples are immutable). In a real program, I would suggest you don't do this because t[0].extend(['c']) does the exact same thing.


Answer URL
https://docs.python.org/3/library/dis.html
