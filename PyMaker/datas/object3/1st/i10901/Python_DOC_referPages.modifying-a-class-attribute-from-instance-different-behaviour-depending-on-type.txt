Natural Text
If I create a class in Python and I give it a class attribute (this is taken directly from the docs, here), as I see that, as the docs suggest, when doing I get that the trick is added to d2 as well:This is because tricks is a class attribute rather than an instance attribute so gets shared across all instances (correct me if this is not orthodox!).Now, suppose I do this insteadand I run this gives me 2 and 1 respectively, namely the count for the second instance has not changed. Why is this, why the behaviour difference?
The int class does not define the += operator (__iadd__ method). That wouldn't make sense because it is immutable.That's why += defaults to + and then =. referenceself.a += 1 becomes self.a = self.a + 1Now the first time you call improve_a the following happens:read class attribute a and put it on the stackadd 1 to the item on the stackcreate a new instance attribute a and assign it the value on the stackThat means the class attribute is not changed at all and you add a new instance attribute.On every subsequent call of improve on the same object the instance attribute is incremented, because attribute lookup starts on the instance dict and will only go to the class dict if that attribute does not exist.If you do the same with a mutable class which overloads the __iadd__ method you can get different behaviour:You will see that all instances and the class itself still hold the same list. The print shows the same list [1, 2, 3] each time. You can also check that all three lists are identical: fst.some_list is sec.some_list and fst.some_list is HasList.some_list  # -> True.That is because list.__iadd__ just calls list.extend and returns itself inside the method (at least if it was written in python).


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__iadd__
