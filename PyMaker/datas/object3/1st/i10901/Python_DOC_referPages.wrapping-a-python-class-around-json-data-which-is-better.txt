Natural Text
Preamble: I'm writing a python API against a service that delivers JSON.The files are stored in JSON format on disk to cache the values.The API should sport classful access to the JSON data, so IDEs and users can have a clue what (read-only) attributes there are in the object before runtime while also providing some convenience functions.Question: I have two possible implementations, I'd like to know which is nicer or 'pythonic'. While I like both, I am open for suggestions, if you come up with a better solution.First Solution: defining and inheriting JSONWrapper while nice, it is pretty verbose and repetitive.Second solution: using lambda for shorter syntax. While working and short, it does not quite look right (see edit1 below.)(Naming this function 'json' is not a problem, since I don't import json there.)I have a possible third solution in mind, that I cant quite wrap my head around: overriding the property builtin, so I can define a decorator that wraps the returned field name for lookup:That could be a little shorter, dunno if that makes code better.Disqualified solutions (IMHO):JSON{De,En}coder: kills all flexibility, provide no means of read-only attributes__{get,set}attr__: makes it impossible to determine attributes before runtime. While it whould shorten self.get('id') to self['id'] it whould also further complicate matters where an attribute was not in the underlying json data.Thank you for reading!Edit 1: 2016-07-20T08:26Z To further clarify (@SuperSaiyan) why I don't quite like the second solution:I feel the lambda function is completely disconnected from the rest of classes semantics (which is also the reason why it is shorter :D). I think I can help myself liking it more by properly documenting the decision in the code. The first solution is easy to understand for everybody who understands the meaning of @property without any additional explaination.On the second comment of @SuperSaiyan: Your question is, why I put Group.members as attribute in there? The list stores type(User) entities, might not be what you think it is, I changed the example.@jwodder: I will use Code Review next time, did not know that was a thing.(Also: I really think the Group.members threw some of you off, I edited the code to make it a little more obvious: Group members are Users that will be added to the list.The complete code is on github, while undocumented it may be interesting for somebody. Keep in mind: this is all WIP :D)
Have you considered using a meta-class?
I myself am a newbie in python and so excuse me if I sound naive. One of the solution could be using __dict__ as discussed in the article below:https://www.safaribooksonline.com/library/view/python-cookbook-3rd/9781449357337/ch06s02.htmlOf course this solution will create issues if there are objects inside a class which below to other class and need to be serialized or de-serialized. I would love to hear the opinion of the experts here on this solution and different limitations.Any feedback on jsonpickle.Update:I just saw your objection about the serialization and how you don't like it as everything is runtime. Understood. Thanks a lot. Below is the code I wrote to get around that. A bit of a stretch but works well and I do not have to add get/set everytime !!!Results below 
When developing an API like this- in which all the members are read-only (meaning you do not want them overwritten, but may still have mutable data structures as members), I have often considered using collections.namedtuple a hard-to-beat approach unless I have a very good reason to do otherwise. It is fast, and needs a bare minimum of code. Simple. If there is more data in your json than will be used in the object, just filter it out:If you want defaults for missing data, you can do that, too:One gotcha using the above technique of setting defaults: don't set the default value for one of the members to any mutable object, such as a list, because it will be the same mutable shared object across all instances:Instead, wrap it all up in a nice factory that instantiates a new list (or dict or whatever user-defined data structure you need) for the members that need them:Now given some json object that defines the fields you want present: And then as before: OR, if there is extra data: If you want the default container to be something other than a list, this is simple enough- just replace the new_list sentinel with whatever sentinel you wish. If needed you could have multiple sentinels at the same time. And if you still need extra functionality, you can always extend your MyJsonClass:The __new__ method above takes care of the missing data problem for good. So now you can always just do this: Simple.
So, it's been a year and I'm going to answer my own question. I don't quite like answering it myself, but: this will mark the thread as resolved which in itself might help others.On the other hand, I want to document and give reason to why I chose my solution over proposed answers. Not, to prove me right, but to highlight the different tradeoffs.I just realized, that this got quite long, so:tl;drcollections.abc contains powerful abstractions and you should use them if you have access to it (cpython >= 3.3).@property is nice to use, enables to add documentation easily and provides read only access.Nested classes look weird but replicate the structure of deeply nested JSON just fine.Proposed solutionspython meta-classesSo first off: I love the concept.I've considered many applications for where they prove useful, especially when: writing a pluggable API where meta-classes enforce correct usage of derived classes and their implementation specificshaving a fully automated registry of classes that derive a from a meta-class.On the other hand, python's meta-class logic felt obscure to wrap my head around (took me at least three days to figure it out). While simple in principle, the devil is in the details.So, I decided against it, simply because I might abandon the project in the not so far future and others should be able to pick up where I left off easily.namedtuplecollections.namedtuple is very efficient and concise enough to boil my solution down to several lines instead of the current 800+ lines. My IDE will also be able to introspect possible members of the generated class.Cons: the breverity of namedtuple leaves much less room for the awfully necessary documentation of the APIs returned values. So with less insane APIs you will possibly get away with just that.It also feels wierd to nest class objects into the namedtuple, but that's just personal preference.What I went withSo in the end, I chose to stick to my first original solution with a few minor details added, if you find the details interesting, you can look at the source on github.collections.abcWhen I started the project, my python knowledge was next to none, so I went with what I knew about python ("everything is a dict") and wrote code like that. For example: classes that work like a dict, but have a file structure underneath (that was before pathlib).While looking through python's code I noticed how they implement and enforce container "traits" through abstract base classes which sounds far more complicated than it really is in python.the very basicsThe following is indeed very basic, but we'll build up from there.The most basic class I could come up with, this will just enable you to call len on the container. You also can get read-only access through raw if you really want to bother with the underlying dictionary.So why am I inheriting from Sized instead of just starting from scratch and  def __len__ just like that?not overriding __len__ will not be accepted by the python interpreter. I forget when exactly, but AFAIR it's when you import the module that contains the class, so you're not getting screwed at runtime.While Sized does not provide any mixin methods, the next two abstractions do provide them. I'll explain there.With that down, we only got two more basic cases in JSON lists and dicts.ListsSo, with the API I had to worry about, we we're not always sure what we got; so I wanted a way of checking if I got a list when we initialize the wrapper class, mostly to abort early instead of "object has no member" during more complicated processes.Deriving from Sequence will enforce overriding __getitem__ and __len__ (which is already implemented in JsonWrapper). So you might have noted, that I chose to not implement __iter__.I wanted an iterator that yielded typed objects, so my IDE is able to autocomplete. To illustrate:Implementing the abstract methods of Sequence, the mixin methods __contains__, __reversed__, index and count are gifted to you, so you don't have to worry about possible side-effects.DictionariesTo complete the basic types to wrangle JSON, here's the class derived from Mapping:Mapping only enforces __iter__, __getitem__ and __len__. To avoid confusion: There is also MutableMapping which will enforce the writing methods. But that's neither needed nor wanted here.With the abstract methods out of the way, python provides the mixins __contains__, keys, items, values, get, __eq__, and __ne__ based on them.I'm not sure why I chose to override the get mixin, I might update the post when it get's back to me.__marker serves as a fallback to detect if the default keyword was not set. If somebody decided to call get(*args, default=None) you won't be able to detect that otherwise.So to pick up the previous example:The properties provide read-only access to members and can be documented like a function definition.Altough verbose, for basic accessors you can easily define a template in your editor, so it's less tedious to write.Properties also allow to abstract from magic numbers and optional JSON return values, to provide defaults instead guarding for KeyError everywhere:class nestingIt seems a little weird to nest classes in others.I chose to do that, becaue the API uses the same name for various objects with different attributes, depending on which remote function you called.Another benefit: new people can easily understand the structure of the returned JSON.The end of the file contains various aliases to the nested classes for easier access from outside the module.adding logicNow that we have encapsulated most of the returned values, I wanted to have more logic associated with the data, to add some convenience.It also seemed necessary to merge some of the data into a more comprehensive tree that contained all of the data gathered through several API calls:get all "assignments". each assignment contains many submissions, so:for(assignment in assigmnents) get all "submissions"merge submissions into respective assignment.now get grades for the submissions, and so on...I chose to implement them seperately, so I just inherited from the "dumb" accessors (full source):So in this classthese properties do the mergingand these implement some logic that can be abstracted from the data.While the setters obscure the wrangling, they are nice to write and use: so it's just a trade-off.Caveat: The logic implementation is not quite what I want it to be, there's much interdependance where it should not be. It's grown from me not knowing enough of python to get the abstractions right and getting things done, so I can do the actual work with the tedium out of my way.Now that I know, what could have been done: I look at some of that spaghetti, and well … you know the feeling.ConclusionEncapsulating the JSON into classes proved quite useful to me and the project's structue and I'm quite happy with it.The rest of the project is fine and works, although some parts are just awful :DThank you all for the feedback, I'll be around for questions and remarks.


Answer URL
https://docs.python.org/3/library/collections.abc.html
