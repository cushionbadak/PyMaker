Natural Text
I have a set of objects, and I'd like to remove values of the set using a lambda expression or some kind of condition.I'd do this like that:An example usecase is:This way, we can get a similar object from a set and consequently the set will be reduced after a call to the method.I'd like to know if there is a simpler way to do this with an actual data structure already available in python instead of looping over the set which could be expensive on big sets?
Instead of your complicated for loop, you could create a filter from that condition (or itertools.ifilter for Python 2) and remove the next element from that filter.Example:Or you could just simplify your function by immediately returning the found value:
Your pop() method is basically a duplicate of the already builtin filter() in combination with calling next() on the resulting filter object. You can simplify your code to this:This will raise StopIteration if there was no match.As for performance: If you have a set, which by definition is unordered, and your condition has to get checked for each entry, there's no way around iterating over all the elements. But since you only retrieve the first occurence, it will practically never need to iterate over the whole set. Since filter() evaluates its results lazily, it behaves the same way and only iterates through the set until it finds the first match.
For some reasons, I decided to go with a defaultdict variant. Instead of using a set. I just store the data in a defaultdict with a list.Setup the container:Pop from the container:The only downside I see with this method is that, there is no easy way to know if the container is empty or not. But trying to pop from an empty list will raise an exception just as expected and the data get actually removed from the container.Since the condition is quite "fixed" just as if I was using a single condition for the set, it's much simpler that way. But if I had to use "custom" keys that can't be hashed. The other answers with "next/filter" would be a better tool I guess.No algorithm there really.


Answer URL
https://docs.python.org/3/library/functions.html#filter
