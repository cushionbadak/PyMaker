Natural Text
I am trying to calculate the std in a non-vectorized and semi-vectorized way. the code for non-vectorized version works well, the semi-vectorized version works as well but the results they generate are not the same.this is the version 1 :   semi-vectorized :and this is the method for calculating mean if its needed :the output generated using pythons numpy.std() and the two method is as follows:generates : As you can see, all three generate the same result up to 8 digits. but the 3rd method has different remaining digits. What am I doing wrong here? 
There are lots of good ressources on floating point arithmetic error propagation. But one immediate problem is that numpy.ndarray display floats to a different precision that python floats. So to compare your results you should convert to an identical data structure (for example lists):In your explicit case:The difference between calc_std_classic and calc_std_classic2 is because one uses naive summation a1+a2+....+an while the other uses np.sum. The np.sum could be naive summation but as far as I know it uses pairwise summation. If you want even higher accuracy you could implement Kahan summation or use the python-builtin statistics._sum.The difference between np.std and your variants is harder to explain because I don't know what algorithm is used by numpy. There is a whole article about "Algorithms for calculating variance" on wikipedia. Note that any naive implementation may suffer from under-/overflow issues especially because of the item - mean subtraction.A general advice: If you want it fast then use numpy, if you want it with highest precision then use statistics. NumPy mostly focusses on the performance aspect so they might not implement the most accurate algorithm. Avoid any naive implementations without doing research on the algorithm, because they probably are neither accurate nor fast.


Answer URL
https://docs.python.org/3/library/statistics.html
