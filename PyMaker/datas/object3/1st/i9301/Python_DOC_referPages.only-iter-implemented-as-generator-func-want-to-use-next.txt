Natural Text
I have a class with __iter__ defined like below:I want to do next(my_iterator) but I have to implement __next__ to do so. But it would change this simple implementation to a fairly complicated one - or actually I don't know how to implement this instead of defining __iter__ as a generator function.Generally spealing, if __iter__ is implemented as a generator fuction which might be difficult to be done without generator, how should I do if I want to use __next__?Note: Apparently, next(iter(my_iterator)) works, but I don't want to do it.
If your class is supposed to be an iterator, it should not have its __iter__ method implemented as a generator function. That makes the class iterable, but not an iterator. An iterator's __iter__ method is supposed to return itself.If you really want your class to be an iterator, try something like this:The next(self._iterator) call may raise StopIteration, which I deliberately do not catch. That exception is the signal we're finished iterating, so if we caught it we'd only have to raise it again.This code uses a "Easier to Ask Forgiveness than Permission" (EAFP) approach to detecting iterable items within the iterator it's been given. It simply tries calling iter on each one and catches the TypeError that will be raised if they're not iterable. If you prefer to stick with the "Look Before You Leap" (LBYL) style and explicitly test with is_iterator (which is badly named, since it checks for any kind of iterable, not only iterators), you could replace the inner try with:I usually prefer EAFP style to LBYL style in my Python code, but there are situations where either one can be better. Other times it's just a matter of style.
As @BrenBarm commented, the apparent answer was to return next(iter(self)), or next(self._iter_self) by keeping self._iter_self = iter(self). I couldn't just come up with it.
an iterator is an object with a __next__ method that returns values until finally raising StopIteration.an iterable is an object with an __iter__ method that returns an iterator.a generator is a special iterable created by python when a function or method include the yield statement.In your example, __iter__ has a yield so it is a generator. And that means it returns another iterable, not an iterator. That's why you have to do that strange next(iter(my_iterator)) thing, and that doesn't work because it restarts the enumation each time.How best to solve this problem depends on how you are using this class. You could create a generator function instead and then use iter to make iterators as needed:Or you can implement __next__ instead of __iter__. But you can't use yield and have to return a value on each call until the outer iterator completes and raises StopIteration.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable
