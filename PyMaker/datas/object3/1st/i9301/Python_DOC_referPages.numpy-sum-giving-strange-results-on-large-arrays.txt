Natural Text
I seem to have found a pitfall with using .sum() on numpy arrays but I'm unable to find an explanation. Essentially, if I try to sum a large array then I start getting nonsensical answers but this happens silently and I can't make sense of the output well enough to Google the cause.For example, this works exactly as expected:Giving the same output for both:However, this does not work:Giving the following output:And on an even larger array, it's possible to get back a positive result. This is more insidious because I might not identify that something unusual was happening at all. For example this:Gives this:I guessed that this was to do with data types and indeed even using the python float seems to fix the problem:Giving:I have no background in Comp. Sci. and found myself stuck (perhaps this is a dupe). Things I've tried:numpy arrays have a fixed size. Nope; this seems to show I should hit a MemoryError first.I might somehow have a 32-bit installation (probably not relevant); nope, I followed this and confirmed I have 64-bit.Other examples of weird sum behaviour; nope (?) I found this but I can't see how it applies.Can someone please explain briefly what I'm missing and tell me what I need to read up on? Also, other than  remembering to define a dtype each time, is there a way to stop this happening or give a warning? Possibly relevant:Windows 7numpy 1.11.3Running out of Enthought Canopy on Python 2.7.9
This is clearly numpy's integer type overflowing 32-bits.  Normally you can configure numpy to fail in such situations using np.seterr:However, sum is explicitly documented with the behaviour "No error is raised on overflow", so you might be out of luck here.  Using numpy is often a trade-off of performance for convenience!  You can however manually specify the dtype for the accumulator, like this:Watch ticket #593, because this is an open issue and it might be fixed by numpy devs sometime.  
On Windows (on 64-bit system too) the default integer NumPy uses if you convert from Python ints is 32-bit. On Linux and Mac it is 64-bit.Specify a 64-bit integer and it will work:Output:While not most elegant, you can do some monkey patching, using functools.partial:From now on np.arange works with 64-bit integers as default.
I'm not a numpy expert, but can reproduce your arange(200000) result in pure Python:In other words, the result you're seeing is what I expect if numpy is doing its arithmetic on signed 2's-complement 32-bit integers.Since I'm not a numpy expert, I can't suggest a good approach to never getting surprised (I would have left this as a comment, but I couldn't show nicely formatted code then).
Numpy's default integer type is the same as the C long type. Now, this isn't guaranteed to be 64-bits on a 64-bit platform. In fact, on Windows, long is always 32-bits.As a result, the numpy sum is overflowing the value and looping back around.Unfortunately, as far as I know, there is no way to change the default dtype. You'll have to specify it as np.int64 every time.You could try to create your own arange:and then use that version instead of numpy's.EDIT: If you want to flag this, you could just put something like this in the top of your code:


Answer URL
https://docs.python.org/3/library/functools.html#functools.partial
