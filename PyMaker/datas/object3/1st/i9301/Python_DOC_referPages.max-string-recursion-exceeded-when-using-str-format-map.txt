Natural Text
I am using str.format_map to format some strings but I encounter a problem when this string contains quotes, even escaped. Here is the code:For reqular strings (that do not include brackets or quotes) it works, however for strings like "{\"libraries\":[{\"file\": \"bonjour.so\", \"modules\":[{\"name\": \"hello\"}]}]}" it crashes with the message ValueError: Max string recursion exceeded. Escaping the quotes using json.dumps(item) before formatting it does not solve the issue. What should be done to fix this problem? I am modifying strings I get from JSON files and I would prefer to fix the Python code instead of updating the JSON documents I use.
You can't use your __missing__ trick on JSON data. There are multiple problems. That's because the text within {...} replacement fields are not just treated as strings. Take a look at the syntax grammar:Within a replacement field, !... and :... have meaning too! What goes into those sections has strict limits as well.The recursion error comes from the multiple nested {...} placeholders inside placeholders inside placeholders; str.format() and str.format_map() can't support a large number of levels of nesting:but there are other problems here:The : colon denotes a formatting specification, which is then passed to the object (key) from the part before the :. You'd have to give your __missing__ return values a wrapper object with __format__ method if you wanted to recover those.Field names with . or [...] in them have special meaning too; "bonjour.so" will be parsed as the "bonjour key, with a so attribute. Ditto for [...] in the field name, but for item lookups.Those last two can be approached by returning a wrapper object with __format__ and __getitem__ and __getattr__ methods, but only in limited cases:This fails for 'empty' attributes:In short, the format makes too many assumptions about what is contained inside {...} curly braces, assumptions JSON data easily breaks.I suggest you look at using the string.Template() class instead, a simpler templating system that can be subclassed; the default is to look for and replace $identifier strings. The Template.safe_substitute() method does exactly what you want; replace known $identifier placeholders, but leave unknown names untouched.


Answer URL
https://docs.python.org/3/library/string.html#formatstrings
https://docs.python.org/3/library/string.html#format-specification-mini-language
https://docs.python.org/3/library/string.html#template-strings
https://docs.python.org/3/library/string.html#string.Template.safe_substitute
