Natural Text
I have a pool_map function that can be used to limit the number of simultaneously executing functions.The idea is to have a coroutine function accepting a single parameter that is mapped to a list of possible parameters, but to also wrap all function calls into a semaphore acquisition, whereupon only a limited number is running at once:I modified and didn’t test above code for the sake of an example, but my variant works well. E.g. you can use it like this:But a problem arises if there is an exception thrown while awaiting a future. I can’t see how to cancel all scheduled or still-running tasks, neither the ones still waiting for the semaphore to be acquired.Is there a library or an elegant building block for this that I don’t know, or do I have to build all parts myself? (i.e. a Semaphore with access to its waiters, a as_finished that provides access to its running task queue, …)
Use ensure_future to get a Task instead of a coroutine:
Here's a naive solution, based on the fact that cancel is a no-op if the task is already finished:


Answer URL
https://docs.python.org/3/library/asyncio-task.html#coroutine
