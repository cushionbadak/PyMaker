Natural Text
I'm having a difficult time to debug a problem in which the float nan in a list and nan in a numpy.array are handled differently when these are used in itertools.groupby:Given the following list and array:When I iterate over the list the contiguous nans are grouped:However if I use the array it puts successive nans in different groups:Even if I convert the array back to a list:I'm using:I know that generally nan != nan so why do these operations give different results? And how is it possible that groupby can group nans at all?
Python lists are just arrays of pointers to objects in memory. In particular lst holds pointers to the object np.nan:(np.nan is at 139832272211880 on my computer.)On the other hand, NumPy arrays are just contiguous regions of memory; they are regions of bits and bytes that are interpreted as a sequence of values (floats, ints, etc.) by NumPy.The trouble is that when you ask Python to iterate over a NumPy array holding floating values (at a for-loop or groupby level), Python needs to box these bytes into a proper Python object. It creates a brand new Python object in memory for each single value in the array as it iterates.For example, you can see that that distinct objects for each nan value are created when .tolist() is called:itertools.groupby is able to group on np.nan for the Python list because it checks for identity first when it compares Python objects. Because these pointers to nan all point at the same np.nan object, grouping is possible.However, iteration over the NumPy array does not allow this initial identity check to succeed, so Python falls back to checking for equality and nan != nan as you say.
The answers of tobias_k and ajcr are correct, it's because the nans in the list have the same id while they have different ids when they are "iterated over" in the numpy-array.This answer is meant as a supplement for these answers.The problem is that Python uses the PyObject_RichCompare-operation when comparing values, which only tests for object identity if == fails because it's not implemented. itertools.groupby on the other hand uses PyObject_RichCompareBool (see Source: 1, 2) which tests for object identity first and before == is tested.This can be verified with a small cython snippet:The source code for PyObject_RichCompareBool reads like this:The object identity test (if (v == w)) is indeed done before the normal python comparison PyObject_RichCompare(v, w, op); is used and mentioned in its documentation:Note :If o1 and o2 are the same object, PyObject_RichCompareBool() will always return 1 for Py_EQ and 0 for Py_NE. 
I am not sure whether this is the reason, but I just noticed this about the nan in lst and arr:I.e., while all nan are inequal, the regular np.nan (of type float) are all the same instance, while the nan in the arr are different instances of type numpy.float64). So my guess would be that if no key function is given, groupby will test for identity before doing the more expensive equality check.This is also consistent with the observation that is does not group in arr.tolist() either, because even though those nan are now float again, they are no longer the same instance.


Answer URL
https://docs.python.org/3/c-api/object.html#c.PyObject_RichCompareBool
https://docs.python.org/3/c-api/object.html#c.PyObject_RichCompareBool
