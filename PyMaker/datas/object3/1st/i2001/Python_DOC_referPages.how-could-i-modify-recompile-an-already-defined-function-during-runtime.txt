Natural Text
Firstly, yes I know this is not good practice. It's just an experiment, not actual planned code.The problem:I have a functionIs there any way to manipulate the definition of foo() from foo2() during runtime? I have been fiddling with trying to change variables in the frames, but most are read only (save f_local).
If you are interested in byte code level stuff in python let me introduce dis, compile and CodeTypedon't do any of this in production codeYou can compile python code (as a string) into a Code object which can then override a functions __code__ propertyif you want to modify more than a no inputs no outputs function take a look at the types.CodeType constructor:Which - much like writing assembly code - involves risking seg-faults, crashing the python interpreter or worse.  You know when the only documentation is Not for the faint of heart. the developer was not intending for it to be directly used.if you want to see what byte code actually executes as you can use dis. which is short for "disassemble"This is interesting to see how python code actually executes.I'm not sure exactly what you are trying to do with the stack but I'm fairly certain what ever it is, the developers of python have made sure it's not easy since that is not something you should be touching in python. These types only exist in python for introspection reasons (like seeing what the arguments of a function are at runtime by inspecting it's call signature)
If you want to manipulate the definition of foo, it's straightforward to redefine foo much the same way you would assign any other global variable, with a global statement and =:It's probably also safe to just def foo(): ... inside foo2 instead of defining replacement_foo and then assigning, but that's officially not permitted, even though the implementation doesn't enforce it.In the comments, you seem to be very interested in manipulating foo through the stack somehow. The definition of foo doesn't live on the stack, and no call to foo is on the stack during the execution of foo, so the stack is the wrong place to look.Also, most of Python's stack inspection is read-only. Even if you were to reassign a function's code object, it wouldn't change the code of calls already on the stack. You can't change main's code object to make it not call foo (though you can change foo's code object, and that'll take effect when main calls foo).


Answer URL
https://docs.python.org/3/reference/simple_stmts.html#the-global-statement
