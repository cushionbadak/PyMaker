Natural Text
I have created a very basic script that periodically writes some data into a database:test.pyNow I can achieve a simple concurrency by running the script several times:I have tried to read some articles about scripts writing into the same database file at same time but still I'm not sure how will my script handle such event and I didn't figure any way how to test it.My expectations are that in the unlikely event when the two instances of my script try to write to the database in the same millisecond, the later one will simply silently wait till the earlier finishes its job.Does my current implementation meet my expectations? If it does not, how does it behave in case of such event and how can I fix it?
TL;DRThis script will meet the expectations.ExplanationWhen the unlikely event of two script instances trying to write at the same time happens, the first one locks the database and the second one silently waits for a while until the first one finishes its transaction so that the database is unlocked for writing again.More precisely, the second script instance waits for 5 seconds (by default) and then raises the OperationalError with the message database is locked. As @roganjosh commented, this behavior is actually specific for a Python SQLite wrapper. The documentation states:When a database is accessed by multiple connections, and one of the processes modifies the database, the SQLite database is locked until that transaction is committed. The timeout parameter specifies how long the connection should wait for the lock to go away until raising an exception. The default for the timeout parameter is 5.0 (five seconds).TestsTo demonstrate the collision event of the two instances I modified the main function:The documentation states that the database is locked until the transaction is commited. So simply sleeping during the transaction should be enough to test it.Test 1We run the following command:The first instance is being run and after 1s the second instance is being run. The first instance creates a 10s long transaction during which the second one tries to write to the database, waits and then raises an exception. The log demonstrates that:Test 2We run the following command:The first instance is being run and after 1s the second instance is being run. The first instance creates a 3s long transaction during which the second one tries to write to the database and waits. Since it has been created after 1s it has to wait 3s - 1s = 2s which is less than the default 5s so both transactions will finish successfully. The log demonstrates that:ConclusionThe time needed for the transaction to finish is significantly smaller (milliseconds) than the lock time limit (5s) so in this scenario the script indeed meets the expectations. But as @HarlyH. commented, the transactions wait in a queue to be commited so for a heavily used or very large database this is not a good solution since the communication with the database will become slow.


Answer URL
https://docs.python.org/3/library/sqlite3.html#sqlite3.connect
