Natural Text
I can see two very similar ways of having properties in Python(a) Property class(b) Property decoratorQuestionAre those two pieces of code identical (e.g. bytecode wise)? Do they show the same behavior? Are there any official guides which "style" to use?Are there any real advantages of one over the other?What I've triedpy_compile + uncompyle6I've compiled both:and then decompiled both with uncompyle6. But that just returned exactly what I started with (with a bit different formatting)import + disI triedI'm super confused by the output of test2:whereas the first one was way bigger:Where does that difference come from? Where is the value range check for the first example?
You want to use the decorator, always. There is no advantage to the other syntax, and only disadvantages.The point of decoratorsThat's because the decorator syntax was invented specifically to avoid the other syntax. Any examples you find of the name = property(...) variety is usually in code that predates decorators.Decorator syntax is syntactic sugar; the formis executed a lot likewithout functionname being assigned to twice (the def functionname(...) part creates a function object and assigns to functionname normally, but with a decorator the function object is created and passed directly to the decorator object).Python added this feature because when your function body is long, you can't easily see that the function has been wrapped with a decorator. You'd have to scroll down past the function definition to see that, and that's not very helpful when almost everything else you'd want to know about a function is right at the top; the arguments, the name, the docstring are right there.From the original PEP 318 â€“ Decorators for Functions and Methods specification:The current method of applying a transformation to a function or method places the actual transformation after the function body. For large functions this separates a key component of the function's behavior from the definition of the rest of the function's external interface.[...]This becomes less readable with longer methods. It also seems less than pythonic to name the function three times for what is conceptually a single declaration.and under Design Goals:The new syntax should[...]move from the end of the function, where it's currently hidden, to the front where it is more in your faceSo usingis far more readable and self documenting than No namespace pollutionNext, because the @property decorator replaces the function object you decorate with the decoration result (a property instance), you also avoid namespace pollution. Without @property and @<name>.setter and @<name>.deleter, you have to add 3 extra, separate names to your class definition that then no-one will ever use:Imagine a class with 5, or 10 or even more property definitions. Developers less familiar with the project and an auto-completing IDE will surely get confused by the difference between get_latitude, latitude and set_latitude, and you end up with code that mixes styles and makes it harder to now move away from exposing these methods at the class level.Sure, you can use del get_latitude, set_latitude right after the latitude = property(...) assignment, but that's yet more extra code to execute for no real purpose.Confusing method namesAlthough you can avoid having to prefix the accessor names with get_ and set_ or otherwise differentiate between the names to create a property() object from them, that's still how almost all code that doesn't use the @property decorator syntax ends up naming the accessor methods.And that can lead to some confusion in tracebacks; an exception raised in one of the accessor methods leads to a traceback with get_latitude or set_latitude in the name, while the preceding line used object.latitude. It may not always be clear to the Python property novice how the two are connected, especially if they missed the latitude = property(...) line further down; see above.Accessing to the accessors, how to inheritYou may point out that you may need access to those functions anyway; for example when overriding just the getter or a setter of for the property in a subclass, while inheriting the other accessor.But the property object, when accessed on the class, already gives you references to the accessors, via the .fget, .fset and .fdel attributes:and you can reuse the @<name>.getter / @<name>.setter / @<name>.deleter syntax in a subclass without having to remember to create a new property object!With the old syntax, it was commonplace to try to override just one of the accessors:and then wonder why it would not be picked up by the inherited property object.With the decorator syntax, you'd use:and the SpecialLocation subclass then is given a new property() instance with the getter inherited from Location, and with a new setter.TLDRUse the decorator syntax. It is self-documentingIt avoids namespace pollutionIt makes inheriting accessors from properties cleaner and more straightforward
The results of the two versions of your code will be almost exactly the same. The property descriptor you have at the end will be functionally identical in both cases. The only difference in the descriptors will be in the function names you can access if you really try (via Location.longitude.fset.__name__), and that you might see in an exception traceback, if something goes wrong.The only other difference is the presence of the get_foo and set_foo methods after you're done. When you use @property, you won't have those methods cluttering up the namespace. If you build the property object yourself manually, they will remain in the class namespace, and so you can call them directly if you really want to instead of using normal attribute access via the property object.Unusually the @property syntax is better since it hides the methods, which you usually don't need. The only reason I can think of that you might want to expose them is if you expect to pass the methods as callbacks to some other function (e.g. some_function(*args, callback=foo.set_longitude)). You could just use a lambda though for the callback though (lambda x: setattr(foo, "longitude", x)), so I don't think it's worth polluting a nice API with extraneous getter and setter methods just for this corner case.


Answer URL
https://docs.python.org/3/library/timeit.html#module-timeit
