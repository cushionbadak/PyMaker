Natural Text
I want to check if two lists have the same type of items for every index. For example if I havethe check should be True for x and y.The check should be False for y and z because the types of the elements at the same positions are not equal.
Just map the elements to their respective type and compare those:For Python 3, you will also have to turn the map generators into proper lists, either by using the list function or with a list comprehension:I did some timing analysis, comparing the above solution to that of @timgeb, using all and izip and inputs with the first non-matching type in different positions. As expected, the time taken for the map solution is almost exactly the same for each input, while the all + izip solution can be very fast or take three times as long, depending on the position of the first difference.
Lazy evaluation with all:Use regular zip in Python 3, it already returns a generator.If the lists can have different lengths, just check the length upfront. Checking the length is a very fast O(1) operation:The and will be short-circuit evaluated, that means all won't even be called if the lengths differ.
Another option with lambda:
It's very simple when you use a generator expression:In that example, x and y are the lists you are checking.  If you want something that you can add to:In that way, you can just change lists, and it will still work.  It works by using the fact that a set removes all duplicates.  For each tuple that zip() returns, it creates a set of each item's types and checks to see if they have are the same by seeing if the length of the set is 1.
I just iterate over the list (check if they have same length first) and then when some types mismatch I return False. At the end (no mismatch) I return True.
You can keep the lazy evaluation using operator.eq with itertools which overall gives you decent average times without storing copies of the lists:If the lists were different lengths, just checking the lengths first ould be the simplest and fastest but if you were to incorporate it into the logic you could use object as the fillvalue to itertools.izip_longest:


Answer URL
https://docs.python.org/3/library/functions.html#func-list
https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions
