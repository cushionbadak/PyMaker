Natural Text
I am looking to make a program that can  pick out car information from a file using module re. The user is asked questions about the car that he wants to view and if the input is not in the file I should display an error message and loop the code again if the user wants to. I am having difficulty trying to find the inputs in the file: this is the code so far:Text file is:        bmw : X6 : 3.4l : Engine size 4395cc: petrol: 0-62mph in 4.8s: gear type automatic : 5 doors : economy  29mpg : top speed 155 mph        audi : Q7 : 3.0l : Engine size 2967cc: disel: 0-62mph in 6.5s: gear type automatic : 5 doors : economy: 48mpg : top speed 145 mph         honda : CRV : 2.0l: Engine size    1997cc: petrol : 0-62mph in 10.0s: gear type manual : 5 doors : economy 30mpg : top speed 18 mph
In this line, you are re-defining myList to be a line in the file. But you have an outer loop (for line in carfile) that does the same thing.Change this to eliminate the for expression, and you'll be on the right track:FWIW, this is going to be very hit-or-miss, because you have things like engine size that use different measures (cc vs. l) in the file.Next, please be aware that you can (and probably should, as a matter of avoiding errors) use .append() in order to grow a list, instead of .insert(). The difference is that append does not require you to keep track of an index, which in cases like this is not benefiting you (you don't make use of the position information at any time) and is a source of error if you copy/paste a block of code to add a new field.Also, you should probably give users the option of not entering a field, and skip searching if they don't enter it. (Just don't append the field if it's empty, perhaps?)EDITOkay, just got done for the day, back to this program. :-)There are some more problems, but let's take care of the "all requires an iterableissue first. If you look at the docs for [all`](https://docs.python.org/3/library/functions.html#all), it saysall(iterable)So we need to restructure the test to give all an iterable (a list, tuple, view, or other expression that can be iterated), or we need to stop using all.Well, we are trying to iterate over myList, so it should be possible to come up with an iterable. Let's start with that in mind:In fact, we can put the .lower() back in - that made sense. So:Now, let's treat s.lower() as a word (which it is) and search for it in the input line. What we are doing is converting our previous string expression, s.lower(), into a boolean expression: word in list, within the context of the iteration we already have. This will be a different flavor of the in keyword:When I make this change, I can match the make of the car.There are some problems with the logic, as well. You want to match the user query to a car type. If you can't match that, then you want to print a message about "We don't have the car ..." But you can't get that test (not matching) in one line. If you could get that test into one line, you could probably get the searching part into one line as well. (Not always, but it's worth looking!)Instead, just keep track of whether or not you found the car:Next, let's make the program run longer (for testing if nothing else). You are doing for loops, so I assume you can do a while loop. Let's add a loop around the whole thing to keep going until the user types quit:Finally, let's take a look at your regular expression. You are using \w+, which will match "word characters" (whatever those are) one or more times.That's a good start for things like "audi" and "honda", but word characters don't include the period ('.') or the hyphen ('-'), both of which appear in your data.Instead, try changing your regex to match either a word character or a dot, one or more times:Good luck!
You have bugs!First, you are initializing myList = ([]) as a tuple containing a single empty list, so append() or insert() aren't going to work. Try myList = [].Second, you're getting the indexes wrong in your myList.insert(...) statements. Just use myList.append(...) instead, no need to worry about indexes that way.Then, try replacing (not tested...):... with:A simple optimization which also makes the code more readable:


Answer URL
https://docs.python.org/3/library/functions.html#all
