Natural Text
This question already has an answer here:Recursively find the kth largest int in list of list of int in Python                    2 answers                I want to find the second smallest int in list of lists where empty list may exist. I got stuck at the flatten step. my ideaa unsorted list e.g [1, [3, 2], [[]], [4]],[[]], [12, 12], [[12], []], [[]]]stucked!!!!!! Flatten the list with pure recursion. I tried to do this in the first part of recursive step. Above example become [1, 3, 2, 4], [12,12,12]  find the second smallest int (completed)  Here is the code
Just Fixing the Issue:You have to handle the case of an empty list in your recursion. A minimal (and admittedly somewhat hacky) change to your code would look something like this:This is far from perfect (e.g. yielding maxsize if there are not enough values and maybe having additional bugs). Refactoring Your Code: Therefore, I would refactor your code in two ways. Firstly, I would separate out flattening and searching (i.e. flatten first and then search the flattened list):And secondly, I would use heapq.nsmallest instead of your implementation for searching:If you are ok with a slightly different return value, feel free to drop the tuple and [::-1].Alternative Implementation:While I'd prefer the refactored code above for various reasons (e.g. robustness, expressiveness), here is an alternative implementation which arguably is more in line with your initial question. The main idea behind this implementation is to only check whether the first element is a list? If yes, flatten; if no, recursively go down the tail of the list:Note that the return type is slightly different (list instead of tuple). And you could replace sorted with heapq.nsmallest (which arguably is more efficient for small n).
If your use case is huge and you want to avoid recursion, you can perform some iteration magic and avoid the recursion:And then, you could do things like:There are more intelligent ways to retrieve the second smallest integer. To avoid sorting a potential huge size, you can use nested_walker being as it is a generator function.As @stephan pointed out, there is a way to use heapq which avoids the sort:it is worth checking the documentation about heapq, as it can be a little bit tricky in terms of performance.
Iterate through the list then use isinstance to check if you need recursion:   
Here's a solution in Python 3 which flattens the lists, sorts it and finally returns the second smallest item of the result:The flatten function was bluntly stolen from this answer. For Python 2.7 replace (str, bytes) with basestring in flatten.


Answer URL
https://docs.python.org/3/library/heapq.html#heapq.nsmallest
https://docs.python.org/3/library/heapq.html#heapq.nsmallest
