Natural Text
My problem is to find the common path prefix of a given set of files.Literally I was expecting that "os.path.commonprefix" would do just that. Unfortunately, the fact that commonprefix is located in path is rather misleading, since it actually will search for string prefixes. The question to me is, how can this actually be solved for paths? The issue was briefly mentioned in this (fairly high rated) answer but only as a side-note and the proposed solution (appending slashes to the input of commonprefix) imho has issues, since it will fail for instance for:To prevent others from falling into the same trap, it might be worthwhile to discuss this issue in a separate question: Is there a simple / portable solution for this problem that does not rely on nasty checks on the file system (i.e., access the result of commonprefix and check whether it is a directory and if not returns a os.path.dirname of the result)?
Awhile ago I ran into this where os.path.commonprefix is a string prefix and not a path prefix as would be expected. So I wrote the following:it could be made more portable by replacing '/' with os.path.sep.
It seems that this issue has been corrected in recent versions of Python.  New in version 3.5 is the function os.path.commonpath(), which returns the common path instead of the common string prefix.
Assuming you want the common directory path, one way is to:Use only directory paths as input. If your input value is a file name, call os.path.dirname(filename) to get its directory path."Normalize" all the paths so that they are relative to the same thing and don't include double separators. The easiest way to do this is by calling os.path.abspath( ) to get the path relative to the root. (You might also want to use os.path.realpath( ) to remove symbolic links.)Add a final separator (found portably with os.path.sep or os.sep) to the end of all the normalized directory paths.Call os.path.dirname( ) on the result of os.path.commonprefix( ).In code (without removing symbolic links):
A robust approach is to split the path into individual components and then find the longest common prefix of the component lists.Here is an implementation which is cross-platform and can be generalized easily to more than two paths:
I've made a small python package commonpath to find common paths from a list. Comes with a few nice options.https://github.com/faph/Common-Path


Answer URL
https://docs.python.org/3/library/os.path.html#os.path.commonpath
