Natural Text
Given the following code (that doesn't work):Is there a way to make this work? Or do I have do one check to break out of the input loop, then another, more limited, check in the outside loop to break out all together if the user is satisfied?Edit-FYI: get_input is a short function I wrote that supports showing a prompt and default values and all that fanciness and returns stdin.readline().strip()
My first instinct would be to refactor the nested loop into a function and use return to break out. 
Here's another approach that is short. The disadvantage is that you can only break the outer loop, but sometimes it's exactly what you want.This uses the for / else construct explained at: Why does python use 'else' after for and while loops?Key insight:  It only seems as if the outer loop always breaks. But if the inner loop doesn't break, the outer loop won't either. The continue statement is the magic here. It's in the for-else clause. By definition that happens if there's no inner break. In that situation continue neatly circumvents the outer break.
PEP 3136 proposes labeled break/continue.  Guido rejected it because "code so complicated to require this feature is very rare".  The PEP does mention some workarounds, though (such as the exception technique), while Guido feels refactoring to use return will be simpler in most cases.
First, ordinary logic is helpful.  If, for some reason, the terminating conditions can't be worked out, exceptions are a fall-back plan.  For this specific example, an exception may not be necessary.  On other other hand, we often have "Y", "N" and "Q" options in character-mode applications.  For the "Q" option, we want an immediate exit.  That's more exceptional.
I tend to agree that refactoring into a function is usually the best approach for this sort of situation, but for when you really need to break out of nested loops, here's an interesting variant of the exception-raising approach that @S.Lott described.  It uses Python's with statement to make the exception raising look a bit nicer.  Define a new context manager (you only have to do this once) with:Now you can use this context manager as follows:Advantages: (1) it's slightly cleaner (no explicit try-except block), and (2) you get a custom-built Exception subclass for each use of nested_break;  no need to declare your own Exception subclass each time.
First, you may also consider making the process of getting and validating the input a function; within that function, you can just return the value if its correct, and keep spinning in the while loop if not.  This essentially obviates the problem you solved, and can usually be applied in the more general case (breaking out of multiple loops).  If you absolutely must keep this structure in your code, and really don't want to deal with bookkeeping booleans...You may also use goto in the following way (using an April Fools module from here):I know, I know, "thou shalt not use goto" and all that, but it works well in strange cases like this.
Introduce a new variable that you'll use as a 'loop breaker'. First assign something to it(False,0, etc.), and then, inside the outer loop, before you break from it, change the value to something else(True,1,...). Once the loop exits make the 'parent' loop check for that value. Let me demonstrate:If you have an infinite loop, this is the only way out; for other loops execution is really a lot faster. This also works if you have many nested loops. You can exit all, or just a few. Endless possibilities! Hope this helped!
or something like that. You could set a variable in the inner loop, and check it in the outer loop immediately after the inner loop exits, breaking if appropriate. I kinda like the GOTO method, provided you don't mind using an April Fool's joke module - its not Pythonic, but it does make sense.
This isn't the prettiest way to do it, but in my opinion, it's the best way.  I'm pretty sure you could work out something using recursion here as well, but I dunno if that's a good option for you.
To break out of multiple nested loops, without refactoring into a function, make use of a "simulated goto statement" with the built-in StopIteration exception:See this discussion on the use of goto statements for breaking out of nested loops.
Factor your loop logic into an iterator that yields the loop variables and returns when done -- here is a simple one that lays out images in rows/columns until we're out of images or out of places to put them:This has the advantage of splitting up the complicated loop logic and the processing...
And why not to keep looping if two conditions are true?I think this is a more pythonic way:Isn't it?All the best.
In this case, as pointed out by others as well, functional decomposition is the way to go. Code in Python 3:
There is a hidden trick in the Python while ... else structure which can be used to simulate the double break without much code changes/additions.  In essence if the while condition is false, the else block is triggered. Neither exceptions, continue or break trigger the else block. For more information see answers to "Else clause on Python while statement", or Python doc on while (v2.7).The only downside is that you need to move the double breaking condition into the while condition (or add a flag variable). Variations of this exists also for the for loop, where the else block is triggered after loop completion.
Another way of reducing your iteration to a single-level loop would be via the use of generators as also specified in the python referenceYou could scale it up to any number of levels for the loopThe downside is that you can no longer break only a single level. It's all or nothing.Another downside is that it doesn't work with a while loop. I originally wanted to post this answer on Python - `break` out of all loops but unfortunately that's closed as a duplicate of this one 
My reason for coming here is that i had an outer loop and an inner loop like so:As you can see, it won't actually go to the next x, but will go to the next y instead.what i found to solve this simply was to run through the array twice instead:I know this was a specific case of OP's question, but I am posting it in the hope that it will help someone think about their problem differently while keeping things simple.
By using a function:Try running the above codes by commenting out the return as well.Without using any function:Now, run the above codes as is first and then try running by commenting out each line containing break one at a time from the bottom.


probably little trick like below will do if not prefer to refactorial into functionadded 1 break_level variable to control the while loop condition
You can define a variable( for example break_statement ), then change it to a different value when two-break condition occurs and use it in if statement to break from second loop also.    
Try using an infinite generator.
I'd like to remind you that functions in Python can be created right in the middle of the code and can access the surrounding variables transparently for reading and with nonlocal or global declaration for writing.So you can use a function as a "breakable control structure", defining a place you want to return to:
Hopefully this helps:
An easy way to turn multiple loops into a single, breakable loop is to use numpy.ndindexYou do have to index into your objects, as opposed to being able to iterate through the values explicitly, but at least in simple cases it seems to be approximately 2-20 times simpler than most of the answers suggested.
Solutions in 2 WaysWith an example: Are these two matrices equal/same? matrix1 and matrix2 are same size, n, 2 dimentional matrices.First Solution, without a function Second Solution, with a functionThis is the final solution for my case Have a nice day!
Similar like the one before, but more compact.(Booleans are just numbers)
Since this question has become a standard question for breaking into a particular loop, I would like to give my answer with example using Exception. Although there exists no label named breaking of loop in multipally looped construct, we can make use of User-defined Exceptions to break into a particular loop of our choice. Consider the following example where let us print all numbers upto 4 digits in base-6 numbering system: When we print the output, we will never get any value whose unit place is with 4. In that case, we don't break from any loop as BreakLoop(4) is raised and caught in same loop. Similarly, whenever ten place is having 3, we break into third loop using BreakLoop(3). Whenever hundred place is having 5, we break into second loop using BreakLoop(2) and whenver the thousand place is having 2, we break into first loop using BreakLoop(1).In short, raise your Exception (in-built or user defined) in the inner loops, and catch it in the loop from where you want to resume your control to. If you want to break from all loops, catch the Exception outside all the loops. (I have not shown this case in example).
The way I solve this is by defining a variable that is referenced to determine if you break to the next level or not. In this example, this variable is called 'shouldbreak'.This gives a lot of control over how exactly you want the program to break, allowing you to choose when you want to break and how many levels to go down.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.product
https://docs.python.org/3/tutorial/errors.html#user-defined-exceptions
