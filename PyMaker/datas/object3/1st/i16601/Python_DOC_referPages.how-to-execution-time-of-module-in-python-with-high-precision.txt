Natural Text
Which is better to use for timing in Python? time.clock() or time.time()? Which one provides more accuracy?for example:vs.
As of 3.3, time.clock() is deprecated, and it's suggested to use time.process_time() or time.perf_counter() instead.Previously in 2.7, according to the time module docs:time.clock()On Unix, return the current processor time as a floating point number  expressed in seconds. The precision, and in fact the very definition  of the meaning of “processor time”, depends on that of the C function  of the same name, but in any case, this is the function to use for  benchmarking Python or timing algorithms.On Windows, this function returns wall-clock seconds elapsed since the  first call to this function, as a floating point number, based on the  Win32 function QueryPerformanceCounter(). The resolution is typically  better than one microsecond.Additionally, there is the timeit module for benchmarking code snippets.
The short answer is: most of the time time.clock() will be better.However, if you're timing some hardware (for example some algorithm you put in the GPU), then time.clock() will get rid of this time and time.time() is the only solution left.Note: whatever the method used, the timing will depend on factors you cannot control (when will the process switch, how often, ...), this is worse with time.time() but exists also with time.clock(), so you should never run one timing test only, but always run a series of test and look at mean/variance of the times.
Others have answered re: time.time() vs. time.clock(). However, if you're timing the execution of a block of code for benchmarking/profiling purposes, you should take a look at the timeit module.
One thing to keep in mind:  Changing the system time affects time.time() but not time.clock().I needed to control some automatic tests executions. If one step of the test case took more than a given amount of time, that TC was aborted to go on with the next one.But sometimes a step needed to change the system time (to check the scheduler module of the application under test), so after setting the system time a few hours in the future, the TC timeout expired and the test case was aborted. I had to switch from time.time() to time.clock() to handle this properly.
clock() -> floating point numberReturn the CPU time or real time since the start of the process or sincethe first call to clock().  This has as much precision as the systemrecords.time() -> floating point numberReturn the current time in seconds since the Epoch.Fractions of a second may be present if the system clock provides them.Usually time() is more precise, because operating systems do not store the process running time with the precision they store the system time (ie, actual time)
Depends on what you care about. If you mean WALL TIME (as in, the time on the clock on your wall), time.clock() provides NO accuracy because it may manage CPU time. 
For my own practice. time() has better precision than clock() on Linux. clock() only has precision less than 10 ms. While time() gives prefect precision.My test is on CentOS 6.4， python 2.6using clock():
The difference is very platform-specific.clock() is very different on Windows than on Linux, for example.For the sort of examples you describe, you probably want the "timeit" module instead.
On Unix time.clock() measures the amount of CPU time that has been used by the current process, so it's no good for measuring elapsed time from some point in the past. On Windows it will measure wall-clock seconds elapsed since the first call to the function. On either system time.time() will return seconds passed since the epoch. If you're writing code that's meant only for Windows, either will work (though you'll use the two differently - no subtraction is necessary for time.clock()). If this is going to run on a Unix system or you want code that is guaranteed to be portable, you will want to use time.time().
Short answer: use time.clock() for timing in Python.On *nix systems, clock() returns the processor time as a floating point number, expressed in seconds. On Windows, it returns the seconds elapsed since the first call to this function, as a floating point number.time() returns the the seconds since the epoch, in UTC, as a floating point number. There is no guarantee that you will get a better precision that 1 second (even though time() returns a floating point number). Also note that if the system clock has been set back between two calls to this function, the second function call will return a lower value.
To the best of my understanding, time.clock() has as much precision as your system will allow it.
I use this code to compare 2 methods .My OS is windows 8 , processor core i5 , RAM 4GBoutput:time() = 0.0993799996376clock() = 0.0993572257367
Right answer : They're both the same length of a fraction.But which faster if subject is time ?A little test case :I am not work an Swiss labs but I've tested.. Based of this question : time.clock() is better than time.time()Edit : time.clock() is internal counter so can't use outside, got limitations max 32BIT FLOAT, can't continued counting if not store first/last values. Can't merge another one counter... 
As others have noted time.clock() is deprecated in favour of  time.perf_counter() or time.process_time(), but Python 3.7 introduces nanosecond resolution timing with time.perf_counter_ns(), time.process_time_ns(), and time.time_ns(), along with 3 other functions.These 6 new nansecond resolution functions are detailed in PEP 564:time.clock_gettime_ns(clock_id)time.clock_settime_ns(clock_id, time:int)time.monotonic_ns()time.perf_counter_ns()time.process_time_ns()time.time_ns()These functions are similar to the version without the _ns suffix, but  return a number of nanoseconds as a Python int.As others have also noted, use the timeit module to time functions and small code snippets.
Comparing test result between Ubuntu Linux and Windows 7.On UbuntuOn Windows 7
Use the time.time() is preferred.


Answer URL
https://docs.python.org/3/library/time.html#time.clock
https://docs.python.org/3/library/time.html#time.process_time
https://docs.python.org/3/library/time.html#time.perf_counter
https://docs.python.org/3/library/time.html#time.clock
