Natural Text
I have a list and I want to generate a dictionary d taking out duplicates and excluding a single item, such that the first key has value 0, the second has value 1, and so on.I have written the following code:If a_list = ['a', 'b', '<', 'c', 'b', 'd'], after running the code d contains {'a': 0, 'b': 1, 'c': 2, 'd':3}. Order is not important.Is there a more elegant way to obtain the same result?
set(a_list) creates a set from a_list.That effectively strips duplicate numbers in a_list, as a set can only contain unique values.
Use dict.fromkeys to get your unique occurrences (minus values you don't want), then .update it to apply the sequence, eg:Gives you:If order is important, then use collections.OrderedDict.fromkeys to retain the ordering of the original values, or sort the unique values if they should be alphabetical instead.
What is needed here is an ordereddict and to manually filter the list:Output:If original order is not important:
I personally find recursion quite elegant, tail-recursion especially so:So thatwill yieldjust like the original code does on the same input (modulo order of the keys).
If truly:Order is not important.EDIT: @qnnnnez's answer takes advantage of set operations, giving an elegant version of the latter code.Otherwise you can implement the unique_everseen itertools recipe to preserve order.  For convenience, you can import it from a library that implements this recipe for you, i.e. more_itertools.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools-recipes
