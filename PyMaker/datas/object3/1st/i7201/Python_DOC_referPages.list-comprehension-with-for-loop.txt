Natural Text
How can I double the first n odd numbers in a list using list comprehension?Here is my solution:You can see that I can't keep the same order of lst anymore...More example:
Name things with specificity, and the logic is exposed. How can I double the first n odd numbers in a list using list comprehension?We have odd numbers: v for v in l if n%2. This is a filter. We can take the first n of them using islice(odds, n). We call this a slice, other languages might call it "take". And doubling them is a per item operation, so a map. Join these operations and we arrive at one answer to your question:However, that isn't what you wanted. The issue is specificity; your question doesn't say what to do with other items than the first n odd ones, so I have just ignored them. So what do do if we want a replication of all the items your question did not mention? This means we have three groups: early odds, late odds, and evens, all processed distinctly. The latter may be mixed in arbitrarily, while we know late odds come after early odds. It's impractical to split them in individual streams, as you've shown, since that doesn't preserve their relative order. I'll apply a few more itertools functions to solve this problem. Note that the iterator oddfactors is read for each odd item, not even items, because the if-else expression doesn't evaluate the expression if it's not being used. The iterator is consumed and you need to create another to perform the work again. It is possible to place the oddfactors iterator's creation (and entire scope) within the list comprehension, but the first way I can think of is incredibly ugly:The trick here is to ensure we create the chained iterator only once, then feed it into each mapping operation. This exercise sure didn't help readability or performance. Using a nested comprehension would make it a bit cleaner but there's still only the one iterator, so it's a misleading hack.
Solution for the original requirement to *“double the first n numbers in a list if it’s odd”:Since you do not want to remove any items from your original list, you cannot use the filter of the list comprehension syntax (the if after the for). So what you need to do instead is simply transform the item you are putting into the target list.Your logic is something like this for an element x at index i:So you can use that exact function and use it in your list comprehension:And of course, you can put this also inline into the list comprehension:First n odd numbers:If you want to find the first n odd numbers, you cannot solve this like this. In order to solve this, you need to actually remember how many odd numbers you encountered before while going through the list. This means that you need to have some kind of “memory”. Such a thing is not a good fit for a list comprehension since list comprehensions are supposed to transform one item at a time without having side effects.So instead, you would simply do this the straightforward way:
For this to work, you'll need to keep count of odd numbers that you've already seen. For example, you could instantiate the itertools.count generator and advance it each time the odd number is encountered:
Use the ternary operator.or Update: Under the new requirement of doubling first n odd integers:
How about this?
[num if num%2 else 2*num for num in list]. num if a if b else c will return a if b is true, otherwise c.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.islice
