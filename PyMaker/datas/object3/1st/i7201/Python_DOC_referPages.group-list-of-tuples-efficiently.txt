Natural Text
I have a large list of tuples e.g. [ (1,2), (1,3), (1,4), (2,1), (2,3) ] etc. I want to convert it to [ (1, [1,2,3,4]), (2, [1,3] ) ] efficiently. I am grouping tuples by the first element of each tuple i.e. (1,2), (1,3), (1,4) becomes (1, [2,3,4]) (also see the Haskell version below). I doubt that this can be done in one pass? The input list is always ordered.In python in tried using defaultdict which I thought was the natural solution without reinventing the wheel. It works well but it does not preserve the order of keys. One solution is to use ordered defaultdict as explained here.Anyway, I'd like to know the language independent and efficient solution to this problem. My current solution requires two passes and one call to set( ) on a list.UpdateI am thinking of implementing following Haskell version:Performance of answersI implemented two answers (coldspeed and pm2ring). On moderate size lists (upto 10^4 elements)  PM2 ring solution is faster; at size 10^5, both takes same time, on larger list COLDSPEED starts winning. Below are the numbers (with python3).First column is number of entries in list, second is time taken by coldspeed and third column has time taken by pm2 ring solutions. All times are in second.Script is here http://github.com/dilawar/playground/raw/master/Python/so_group_tuple.pyWith Ashwini optimizationPM 2Ring solution is even faster (roughly 3x - 5x) with Ashwini's suggestions. With PYPYSomewhat mixed results. Last column is ratio of column 2 and column 3.I am going with PM 2Ring solution since it is much faster till list size 10^5.
You can do this with itertools.groupby, and using zip to rearrange the data from the collected groups:outputThat list comp is a bit dense. Here's a variation using a traditional for loop that prints an intermediate result to make it a little easier to see what's going on.outputAs Ashwini Chaudhary mentions in the comments, nesting another list comp in there makes the code much more readable, it's probably also more efficient, since it avoids a couple of calls.
You may use the collections.OrderedDict (import collections first):Now, convert o.items() to a list:
May be if the input list is already ordered, it is not required to use any other ordering function or feature to again reorder the list. Below code will automatically give the output as you've shown.Output:{1: [1, 2, 3, 4], 2: [2, 1, 3]}


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.groupby
https://docs.python.org/3/library/timeit.html
