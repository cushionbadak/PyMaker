Natural Text
There are already a lot of questions about sorting dictionaries but I can't find the right answer to my question.I have the dictionary  v:We have to turn the dictionary v into a sorted list.I have tried working with this code:This is the list I receive:Does anyone know how to convert this into a list of values sorted in order of their key, with the missing values padded with zero?
Just use itertools.chain.from_iterable to flatten your result (the list of tuples):In case I misunderstood your original request and the dictionary represents a "sparse vector" (where the keys are the indices) you could simply populate a list containing only zeros:Or if you have NumPy you could also avoid the for-loop:The last approach relies on the fact that even though the order of keys and values is arbitrary they nevertheless directly correspond as long as there is no modification of the dictionary:Keys and values are iterated over in an arbitrary order which is non-random, varies across Python implementations, and depends on the dictionaryâ€™s history of insertions and deletions. If keys, values and items views are iterated over with no intervening modifications to the dictionary, the order of items will directly correspond.Source 4.10.1. Dictionary view objects
You can try this using chain from itertools:Output:
One way to concatenate the (key, value) pairs is by using sum() with an initial value:This returns a tuple. Pass it to list() if you really, really need a list.P.S. As rightly pointed out by @MSeifert in the comments, this almost certainly has O(n**2) time complexity whereas list(chain(...)) is likely amortized linear.
Another option is to use the yield from syntax introduced in Python 3.3:Caveat: Note that using yield from this way inside of list comprehension may not be "offical syntax" and some (including Guido) consider it a bug.
You can use list-comprehension to achieve what you want, for example:if you want to keep 0.0 place holders for items that aren't available:output:If you don't want 0.0 place holders you can use:output:Explanation:when you use range() it will generate a sorted list so you don't have to worry about sorting, then it will try to get items from dictionary as per that list. In the first example if the key doesn't exist a 0.0 will be returned while in the 2nd example None will be returned and will be ignored because of the if-statement in the expression.EDIT:As Christian mentioned, you can change the 2nd option for more efficiency to:This will avoid calling v.get(i) twice.
This is not strictly answering the question but rather trying to understand what you may be trying to achieve. If you are trying to implement sparse vectors, before spending time on a new implementation you may want to look into scipy.sparse.For example:The advantage of sparse matrices is that (depending on the fraction of nonzero elements) they may take less memory and/or allow faster computations.
Result


Answer URL
https://docs.python.org/3/whatsnew/3.3.html#pep-380-syntax-for-delegating-to-a-subgenerator
