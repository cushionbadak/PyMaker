Natural Text
I'd like to be able to generate multiple colors close to one RGB color as the schema below.Here's the what I've made using Python :Question: I feel like I'm overcomplicating things with this method is there a way to make the code above cleaner and shorter? I'd like to avoid doing the same process for each color (red, blue, green) separately, I am also not sure if this method is really precise for what I'm trying to achieve.
We can condense that code quite a bit by looping over the RGB components. However, there's a bug in your current algorithm: it can produce color channel values that are < 0 or > 255, so we need to fix that.typical outputYou said: "I am also not sure if this method is really precise for what I'm trying to achieve". I don't know exactly what you're trying to achieve, but one problem I can see is that the human visual system is not equally sensitive to R, G, & B. So a change by a given amount in one channel will not have the same effect as the same change in another channel. To deal with that properly you need to work in a colorspace that's more closely aligned to the human visual system, eg Lab color space. However, we can get a reasonable approximation by using scaling factors on the channel deltas.The Wikipedia article on Grayscale provides a formula that can be used to compute the luminance of a RGB color:This formula was used in analog NTSC & PAL television.Here's a version of the above code that uses those scaling factors. We divide our base delta by those scaling factors, so the blue delta is the largest & the green delta is smallest, because the eye is most sensitive to green and least sensitive to blue.typical outputTo make that code more efficient, since we're using a fixed base delta we could pre-compute the deltas array, rather than re-computing it each time we call similarColors.
There's no need to copy-paste each color, you could use a for loop like this:Notice I also put difference in the parameters.And there's a bug where the rgb parts can be < 0 or > 255, you could fix that by using max(0, min(255, randint(curr_color - difference, curr_color + difference))) instead.
If you can use numpy, a much more compact solution is this:


Answer URL
https://docs.python.org/3/library/colorsys.html
