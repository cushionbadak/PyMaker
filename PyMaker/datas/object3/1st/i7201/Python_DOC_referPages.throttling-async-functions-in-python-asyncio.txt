Natural Text
I have a list of awaitables that I want to pass to the asyncio.AbstractEventLoop but I need to throttle the requests to a third party API.I would like to avoid something that waits to pass the future to the loop because in the meantime I block my loop waiting. What options do I have? Semaphores and ThreadPools will limit how many are running concurrently, but that's not my problem. I need to throttle my requests to 100/sec, but it doesn't matter how long it takes to complete the request.This is a very concise (non)working example using the standard library, that demonstrates the problem. This is supposed to throttle at 100/sec but throttles at 116.651/sec. What's the best way to throttle the scheduling of an asynchronous request in asyncio?Working code:Edit: I've added a simple example of TrottleTestApp here using semaphores, but still can't throttle the execution:
You can do this by implementing the leaky bucket algorithm:Note that we leak capacity from the bucket opportunistically, there is no need to run a separate async task just to lower the level; instead, capacity are leaked out when testing for sufficient remaining capacity.Note that tasks that wait for capacity are kept in an ordered dictionary, and when there might be capacity to spare again, the first still-waiting task is woken up early.You can use this as a context manager; trying to acquire the bucket when it is full blocks until enough capacity has been freed again:or you can call acquire() directly:or you can simply test if there is space first:Note that you can count some requests as 'heavier' or 'lighter' by increasing or decreasing the amount you 'drip' into the bucket:Do be careful with this though; when mixing large and small drips, small drips tend to get run before large drips when at or close to the maximum rate, because there is a greater likelyhood that there is enough free capacity for a smaller drip before there is space for a larger one.Demo:The bucket is filled up quickly at the start in a burst, causing the rest of the tasks to be spread out more evenly; every 2 seconds enough capacity is freed for another task to be handled.The maximum burst size is equal to the maximum rate value, in the above demo that was set to 5. If you do not want to permit bursts, set the maximum rate to 1, and the time period to the minimum time between drips:
Another solution - using bounded semaphores - by a coworker, mentor, and friend, is the following:Can still be used with the same async with bucket code as in @Martijn's answer


Answer URL
https://docs.python.org/3/library/asyncio-sync.html#asyncio.Semaphore
https://docs.python.org/3/library/asyncio-sync.html#asyncio.Semaphore
