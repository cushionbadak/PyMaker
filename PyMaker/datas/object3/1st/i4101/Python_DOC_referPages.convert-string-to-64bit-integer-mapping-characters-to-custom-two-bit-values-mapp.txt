Natural Text
I am trying to map a string of characters (A, T, C, G) into a 64 bit integer where each letter is represented as two bits using this mapping:The "sequence" string will not be longer than 28 characters, and I intend for the integer to be zero-padded at the beginning to make it 64 bits. Currently, I use the below function, but it is incredibly slow. I then convert the output using by calling: This currently works, but I'd like to make this function incredibly fast. I don't know C++ well so it's hard for me to port to that. I am trying Cython now but I am unfamiliar with that as well. Any help making this more efficient in Python (or even C++ or Cython equivalent) would be greatly appreciated. Below is my code, again which I call int() on afterwards.At typical sequence input would be something like: 'TGTGAGAAGCACCATAAAAGGCGTTGTG'
You are interpreting a string of 4 different 'digits' as a number, so a base 4 notation. If you had a string of actual digits, in the range 0-3, you could have int() produce an integer really fast.The above function uses str.translate() to replace each of the 4 characters with a matching digit (I used the static str.maketrans() function to create the translation table). The resulting string of digits is then interpreted as an integer number in base 4.Note that this produces an integer object, not binary string of zero and one characters:No padding is needed here; as long as your input sequence is 32 letters or less, the resulting integer will fit in an unsigned 8-byte integer representation. In the above output examples, I used the format() string to format that integer value as a hexadecimal and binary string, respectively, and zero-padded those representations to the correct number of digits for a 64-bit number.To measure if this is faster, lets take 1 million randomly produced test strings (each 28 characters long):The above function can produce 1 million conversions in under 3/4 of a second on my Macbook Pro with 2.9 GHz Intel Core i7, on Python 3.6.5:So that's 0.73 microseconds per call.(previously, I advocated a pre-computation version, but after experimentation I struck on the base-4 idea).To compare this to the other methods posted here so far, some need to be adjusted to produce integers too, and be wrapped into functions:And then we can compare these:The base-4 approach I propose easily wins this comparison.
My clumsy straight forward try in Cython, which is twice as fast as the best solution (@MartijnPieters's) so far:Compared to current @MartijnPieters's solution, it is twice as fast on my machine:That makes 0.795 seconds vs 0.363 seconds for the whole run (so it can be compared with timings measured by @MartijnPieters).One coould ask, how many overhead can be saved, if the conversion unicode <-> ascii were not needed?Only 10% faster - this is somewhat surprising...However, we should not forget we also measuring the overhead of "nexting" an iterator, without we get:Now there is actually about 40% speed-up now!Another interesting conclusion: There are also about 250ns (or 70%) overhead when tested with iterators. Without this overhead, cython beats @MartijnPieters's 140ns vs 550ns, i.e. by almost by factor 4.Listing function the cython have been compared to (current state of @MartijnPieters's  answer):test data:
Here is some timing code to compare options:I find that the two options are roughly the same, but your results may vary.
Use the bit shift operator and addition. You've got the right idea with using a dictionary to hold character codes:mapping = {'A': 0b00, 'C': 0b01, 'G': 0b10, 'T': 0b11}Produce a 28 character string (kind of redundant to call it this, string will do) for this example:chars = 'TGTGAGAAGCACCATAAAAGGCGTTGTG'Define a result and set it to zero:result = 0Strings in Python are actually just an array of characters, and you can iterate through the string as you would any array. We'll use this, along with a nested series of bit operations to do what you require:This will produce bits of length 2*len(chars) which in this case is 56. To get the extra To add an extra 8 bits of leading zeros, the integer representation of this is actually a QWORD (64 bits) and will automatically fill the 8 Most Significant Bits with zeros.If you wanted to get really fancy, you could use ctypes to speed up your code.
One way to think about this problem is to realize that the essence of what it's doing is a conversion from a base 4 number to a base 10. This can be done a number of ways, but one I like is the actually very generic accepted answer to the question Base 62 conversion.Below is a modified version of it the does a base 4 conversion by default:Note that this actually returns an integer of whatever bit length is needed (integers are variable length in Python) to store the number given as a character string packed in to binary integer value. The added call to format() turns that value into a binary string so it can be printed and compared to the result of calling your seq_to_binary() function which returns a string, not a 64-bit integer mentioned in the title.


Answer URL
https://docs.python.org/3/library/stdtypes.html#str.translate
https://docs.python.org/3/library/stdtypes.html#str.maketrans
