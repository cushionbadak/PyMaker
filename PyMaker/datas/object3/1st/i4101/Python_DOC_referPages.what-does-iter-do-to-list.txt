Natural Text
I have this code:and output is:I do not understad, why the zip works differently with a_iter than a. What does iter() do, list is iterable, so why use iter()? Could anybody explain me this with some nice example? I googled about it but I still do not understand it.
iter(l) returns an iterator object for l. Together with next(i) it can be used for iterating the elements of l.The code:is equivalent to this code explicitly using the iterator:Note that an iterator can also be traversed with a for loop:zip(a,b) consumes one element from a, b at a time.When the argument of zip is a sequence, it will create its own iterator for it.When the argument is an iterator, it will just consume elements from it.When it is the same iterator in both arguments, each iteration of zip will consume one element of the iterator for the first argument, and one element for the second argument.
iter() does nothing to a list; the list object has an __iter__ method that iter() uses to produce an iterator object. That object has a reference to the original list and an index; every time you ask for the next value in the iterator, the value at the current index is retrieved and returned, and the index is incremented.You can use the next() function to get the next value from an iterator:Notice how calling next() again gives you a new value. You can do so until the iterator is done:List iterator objects keep hold of the original list object; changing the list object will reflect in the iterator values produced on next():zip() asks for the next value in each of its arguments, which are assumed to be iterables; zip() calls iter() on them all. For iterator objects such as a_iter, iter(a_iter) returns the iterator itself (it's already an iterator, after all):Since a_iter will yield values from the original list, in order, that means that you get paired-up elements in a dictionary, because zip() has two references to the same object; you effectively creating (next(a_iter), next(a_iter)) as the iterator step values for zip(). If you pass in two references to a, on the other hand, zip() will call iter() twice, creating two separate iterator objects, and each have their own index to track.Let's look at that in detail. Note that zip() also produces an iterator object, so we can verify that calling next() on zip() in turn causes a_iter to step forward twice:Iterators are independent objects, they each have their own index:So when you use zip(a, a), what really happens is that zip() calls iter(a) two times, creating two new iterators, and both are used to create the output:
iter() function return a instance of iterator on which we can iterate for getting all the value one by one.It is memory efficient function because it stores only current element value.


Answer URL
https://docs.python.org/3/library/functions.html#iter
https://docs.python.org/3/library/functions.html#next
