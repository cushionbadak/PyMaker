Natural Text
A few threads are started in my code and I need at the end of the script to sleep indefinitely, without this sleep being a major hit on the performance1. One possibility can be to loop indefinitely with a short sleep:or sleep for a long timeor But:I did not manage to find the largest time sleep would accept (sys.maxint is too large)signal.pause() is implemented in Unix onlyand the first "sleep loop" does not look clean to me (why 1 second and not 10, or 0.1?)Is there a clean, pythonic way to sleep indefinitely?1 I do not control the threads directly, otherwise I would have gone for threading.Thread.join() as the threads themselves will not end.
threading.enumerate gives you the list of all running threads including the main one, so you could do this:The while True is needed in case your library creates new threads while you wait for the current ones to finish.Assuming that no threads are created while enumerate is running, you can check if L has only one element (the main thread) and if so, break the loop. This combined with Tadhg McDonald-Jensen's suggestion of using iter with a sentinel, results in:enumerate returns a list in undefined order, so if you have more than one "main" thread, order starts to matter. A solution would be to use sets, i.e. main_threads = {main_thread, } and iter(lambda : set(threading.enumerate()), main_threads).If you prefer the EAFP approach of asking for forgiveness instead of permission and all your threads are started when you reach the end of your script, you can also do this:


Answer URL
https://docs.python.org/3/library/threading.html#threading.Thread.join
https://docs.python.org/3/library/threading.html#threading.enumerate
https://docs.python.org/3/library/functions.html#iter
https://docs.python.org/3/library/stdtypes.html#set
https://docs.python.org/3/glossary.html#term-eafp
https://docs.python.org/3/library/threading.html#threading.enumerate
