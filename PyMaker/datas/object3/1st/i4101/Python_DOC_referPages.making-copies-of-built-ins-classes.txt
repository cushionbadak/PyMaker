Natural Text
I'm trying to write function which creates classes from classes without modifying original one.Simple solution (based on this answer)works fine except type itself:Tested on Python 3.2-Python 3.6.(I know that in current version modification of mutable attributes in namespace object will change original class, but it is not the case)UpdateEven if we remove __qualname__ parameter from namespace if there is anyresulting object doesn't behave like original typeWhy?Can someone explain what mechanism in Python internals prevents copying type class (and many other built-in classes).
The problem here is that type has a __qualname__ in its __dict__, which is a property (i.e. a descriptor) rather than a string:And trying to assign a non-string to the __qualname__ of a class throws an exception:This is why it's necessary to remove the __qualname__ from the __dict__.As for the reason why your type_copy isn't callable: This is because type.__call__ rejects anything that isn't a subclass of type. This is true for both the 3-argument form:As well as the single-argument form, which actually only works with type as its first argument:This isn't easy to circumvent. Fixing the 3-argument form is simple enough: We make the copy an empty subclass of type.But the single-argument form of type is much peskier, since it only works if the first argument is type. We can implement a custom __call__ method, but that method must be written in the metaclass, which means type(type_copy) will be different from type(type).There are two reasons why type is so difficult to copy:It's implemented in C. You'll run into similar problems if you try to copy other builtin types like int or str.The fact that type is an instance of itself:This is something that's usually not possible. It blurs the line between class and instance. It's a chaotic accumulation of instance and class attributes. This is why __qualname__ is a string when accessed as type.__qualname__ but a descriptor when accessed as vars(type)['__qualname__']. As you can see, it's not possible to make a perfect copy of type. Each implementation has different tradeoffs.The easy solution is to make a subclass of type, which doesn't support the single-argument type(some_object) call:The elaborate solution is to make a custom metaclass:


Answer URL
https://docs.python.org/3/howto/descriptor.html
https://docs.python.org/3/reference/expressions.html#is
