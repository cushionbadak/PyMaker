Natural Text
See the following two functions, the first one returns a function closure, the second one a "class closure". objects is used to track the created objects. In both cases an instance of MyObject is captured in the closure.If you run this, you get the following output:That means in the first case obj is deleted after the function closure is deleted (which is what I expected).In the second case however obj is never deleted. This can be fixed in Python 3 by using nonlocal and __del__, but not in Python 2.7 as nonlocal does not exist.So my question: Why is the captured variable not deleted in the case of the class; and: how can I delete it in Python 2.7 without using some weird tracking mechanism using weakref?
You don't have to do anything.CPython uses a combination of reference counting and a garbage collector to dispose of unneeded objects. In the first case, deleting the closure with del a reduces the refcount of the leaked object to 0 and it is immediately disposed. In the second case, there is a reference cycle between the Inner class, its __call__ method, and obj. This reference cycle prevents the refcount from dropping to 0, so the closure isn't immediately deleted. But once the garbage collector starts its next collection cycle, the closure will be disposed of.If you want to delete the closure immediately, you can manually trigger the garbage collection with gc.collect():Output:


Answer URL
https://docs.python.org/3/library/gc.html#gc.collect
https://docs.python.org/3/glossary.html#term-method-resolution-order
