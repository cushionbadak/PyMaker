Natural Text
What's the purpose of keeping track of blocks in Python bytecode?The documentation here mentions:... Per frame, there is a stack of blocks, denoting nested loops, try statements, and such.But they don't actually seem necessary to actually perform loops. For instance, playing around with the REPL I see:The JUMP_ABSOLUTE instruction listed jumps to the LOAD_GLOBAL instruction listed. From just looking at the instructions, it seems like SETUP_LOOP and POP_BLOCK opcodes could be no-ops.From what I understand, in Python there are no block scoped variables, so that doesn't like it would be the reason either.
CPython uses a stack machine model, where temporary values are pushed onto a value stack and popped by instructions that use them. When a loop ends, depending on how it ends, it may have left values on the value stack that are no longer needed.A frame's block stack keeps track of the value stack level at the start of loops and a few other constructs, so the value stack can be restored to the state that code after the loop/other construct needs the stack to be in. POP_BLOCK is one of the constructs that restores the stack to a pre-block-entry state.The information in the block stack is very important for exception-handling constructs, since the value stack could be in all sorts of weird states when an exception occurs. It's not as necessary for loops, and I believe a patch going into CPython 3.8 will eliminate block stack entries for loops, instead having the compiler determine the necessary handling statically.
The SETUP_LOOP and POP_BLOCK bytecodes in your example function are useless because the loop runs forever, but if you had a break statement inside the loop, the infrastructure they set up in the frame would be used. The interpreter would put a BREAK_LOOP bytecode where the break statement occurred, and it would use the block information to find the nearest loop to break out of.Note that this part of the bytecode is apparently going to change in Python 3.8, so you may not want to invest too much effort into understanding how it currently works. You can read issue 17611 on the Python bug tracker to see how the topic was discussed before being implemented.


Answer URL
https://docs.python.org/3/library/dis.html#opcode-POP_BLOCK
