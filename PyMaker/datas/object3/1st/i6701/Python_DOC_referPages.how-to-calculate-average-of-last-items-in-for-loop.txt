Natural Text
I've the following Python 3 code:which aims to generate 100 random numbers in the list along with the average of the last 10 items.Unfortunately the code fails with:as I'm not sure how I can access 10 last value items (or less items if all 10 are not available) from the list of dictionaries and pass it into numpy's average function.So for example I expect the output something like:[{'value': 11, 'avg10': 11}, {'value': 62, 'avg10': 36.5}, {'value': 56, 'avg10': 43}, {'value': 48, 'avg10': 44.25}, {'value': 43, 'avg10': 41.8}]and so on.Where avg10 is the average of last (at least) 10 items relatively from the current one (ideally including the current one, but doesn't have to). If there is only one previous element, then it's the average of 1 element, if two - it's average of two value items, and so on (with average of maximum last 10 items).What would be the correct syntax in this case?
To keep your dict solution and avoid problem with the first slices you can do the following.Your line:should be:But this will cause your mean NOT BEING the average of the 10 previous results, as there is no 10 previous results available...Note: I choose that the first value has for mean itself but the second has for mean the 10 last available ones, so the only last one. So the first two values have themself as mean. This is strange. You can decide to change this behaviour with avg10 = np.average([data[j]['value'] if j>=0 else firstAverage for j in range(i-10, i) ])If you decide to include the value itself within the last 10 for the average (i.e. dict of {value; mean of the last 9 items and the value itself}) then there is no more exception for the first item (which has no previous item) and you can do:In this last case you can edit your question to more precise ;)
Here is the complete solution where average also takes into account the current value:Basically np.average() accepts array containing data to be averaged, so list of dictionaries needs to be converted into flat list using list comprehensions. For the range, -min(len(data), 10): is used to fetch the last 10 items or less depending on the current size of data.To understand the above sample more easily, here is the simpler helper code:
I think what you're trying to do could be more easily accomplished with lists.You'll need an explicit check to take care of the condition where values is smaller than 10 elements.
The error message gives a good hint for where to look: "list indices must be integers or slices, not str". In other words, we have to look for somewhere we're using a string as an index of a list.data is a list of dicts. Therefore, data[:-10] is also a list of dicts, meaning data[:-10]['value'] doesn't make sense. You want something like [x['value'] for x in data[:-10]] instead, iterating over the list of dicts.

try this


Answer URL
https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions
