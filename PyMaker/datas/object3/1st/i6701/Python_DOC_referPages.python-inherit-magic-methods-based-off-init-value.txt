Natural Text
Let's imagine I have a single class X. The purpose of X is to wrap a list or dict and provide event-listening capabilities. All works well.So this can be used to wrap a dict like so:Or a list:Great. Almost to what I wanted to accomplish ...Now the current issue is that, because X is for both list and dict objects, it can't inherit from either. This means I don't have the magic class functions, such as __contains__.Which leads code like thisThrowing a KeyError.How can I work around this without defining every magic method I need inside of X. If I did it this way, for each of those definitions I would have to write two return values based off whether self._obj is a list or dict.I thought I could do this with metaclasses at first but that doesn't seem to be a solution, since I need access to the values being passed to check whether it's a dict or list.
An easy way would be to use a proxy class, for example wrapt.ObjectProxy. It will behave exactly like the "proxied" class except for the overridden methods. However instead of self._obj you can simply use self.__wrapped__ to access the "unproxied" object.This behaves like a dict if you wrap a dict:and like a list, if a list is wrapped:
You can use UserList or UserDict from collections
Try something like Or what ever method it is you want to inherit. When an instance method is called, the instance is auto-passed with self. But if you call the method from the class decleration you need to pass an object because self requires a value.This will print out Test and int


Answer URL
https://docs.python.org/3/library/collections.html#collections.UserList
