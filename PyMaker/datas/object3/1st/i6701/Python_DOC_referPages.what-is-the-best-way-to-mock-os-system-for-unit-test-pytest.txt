Natural Text
I have a Python script that does multiple os.system calls. Asserting against the series of them as a list of strings will be easy (and relatively elegant).What isn't so easy is intercepting (and blocking) the actual calls. In the script in question, I could abstract os.system in the SUT (*) like so:My test invokes my_script.do_the_thing() instead of my_script.main() of course (leaving a tiny amount of untested code).Alternate option: I could leave the SUT untouched and replace os.system globally in the test method before invoking main() in the SUT.That leaves me with new problems in that that's a global and lasting change. Fine, so I'd use a try/finally in the same test method, and replace the original before leaving the test method.  That'd work whether the test method passes or fails.Is there a safe and elegant setup/teardown centric way of doing this for PyTest, though?Additional complications: I want to do the same for stdout and stderr.  Yes, it really is a main() script that I am testing.SUT == System Under Test
The Python 3 (>= 3.3) standard library has a great tutorial about Mock in the official documentation. For Python 2, you  can use the backported library: Mock on PyPi.Here is a sample usage. Say you want to mock the call to os.system in this function:To do that, you can use the unittest.mock.patch decorator, like this:This test function will patch the os.system call during its execution. os.system is restored at the end.Then, there are several "assert" method to check the calls, the parameters, and the results. You can also check that an exception is raised in certain circonstances.


Answer URL
https://docs.python.org/3/library/unittest.mock.html#module-unittest.mock
