Natural Text
Trying to understand oop in python I came into this situation that puzzles me, and I wasn't able to find a satisfactory explanation... I was building a Countable class, which has a counter attribute that counts how many instances of the class have been initialized. I want this counter to be increased also when a subclass (or subsubclass) of the given class is initialized. Here is my implementation:where count(cls) is there for debugging purposes, and later i write it down.Now, let's have some subclasses of this:when I run a code like the following:I obtain the following output, which looks strange to me:Why at the beginning both the counter of A and B is incrementing, despite I am calling only A()? And why after the first time I call B() it behaves like expected?I already found out that to have a behavior like I want it is sufficient to add counter = 0 at each subclass, but I was not able to find an explanation of why it behaves like that.... Thank you!I added few debug prints, and for simplicity limited class creation to two. This is pretty strange:How come when B() is not initialized yet, it points to the same variable as A.counter but after creating single object it is a different one?
The problem with your code is that subclasses of Countable don't have their own counter attribute. They're merely inheriting it from Countable, so when Countable's counter changes, it looks like the child class's counter changes as well.Minimal example:If A had its own counter attribute, everything would work as expected:But if all of these classes share the same counter, why do we see different numbers in the output? That's because you actually add the counter attribute to the child class later, with this code:This is equivalent to cls.counter = cls.counter + 1. However, it's important to understand what cls.counter refers to. In cls.counter + 1, cls doesn't have its own counter attribute yet, so this actually gives you the parent class's counter. Then that value is incremented, and cls.counter = ... adds a counter attribute to the child class that hasn't existed until now. It's essentially equivalent to writing cls.counter = cls.__base__.counter + 1. You can see this in action here:So what's the solution to this problem? You need a metaclass. This gives you the possibility to give each Countable subclass its own counter attribute when it is created:


Answer URL
https://docs.python.org/3/reference/datamodel.html#customizing-class-creation
