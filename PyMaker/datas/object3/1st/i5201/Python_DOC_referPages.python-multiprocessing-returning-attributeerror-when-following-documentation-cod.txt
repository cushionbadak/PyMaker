Natural Text
I decided to try and get into the multiprocessor module to help speed up my program. To figure it out, I tried using some of the code examples on the official python documentation on multiprocessing.First attempt: IntroductionHere I assume that the pool function is broken; maybe there is a typo somewhere in the lastest version. So I try some of the more specific code.Second attempt: Process class code block 2At this point I know the underlying error is with the Process function of multiprocessing. However, I think that the extended code might have broken something, so I try the simple code.Third Attempt Process class code block 1At this point I was desperate. I think that maybe the argument was messing with the Process class.Final attempt: self-generated codeNow I am totally confused because I do not know why the error is occuring. Could someone help me figure out why I am getting this error every time?
You're in interactive mode. That basically doesn't work with multiprocessing, because the workers have to import __main__ and get something that mostly resembles the main process's __main__. This is one of the many ways in which the multiprocessing API is horribly confusing.Put your code in a script and run the script.
When multiprocessing is invoked on windows, it uses the spawn strategy for creating new processes.The parent process starts a fresh python interpreter process.The rough strategy taken here for function objects that are "pickled" across processes is:Record the module of the function before creating a new process (in this case f.__module__ => __main__)Encode that to some representationIn the newly spawned process, initialize the main module (for interactive execution this is an empty module)"unpickle" the arguments, for functions this means:import their moduleaccess their function name from that module (where you're getting your AttributeError)In your case this looks roughly like this:Record ('__main__', 'f')encode thatspawn a new process, initialize an empty __main__ moduleunpickle (recover __main__ and f)import __main__ as modobj = getattr(mod, 'f') (boom!)For more details about the specific pickling / unpickling, check out the ForkingPicklerHere's an excerpt:The fix is to put your code into an actual module such that when that is re-initialized on the other side it can import it.


Answer URL
https://docs.python.org/3/library/multiprocessing.html#introduction
https://docs.python.org/3/library/multiprocessing.html#the-process-class
https://docs.python.org/3/library/multiprocessing.html#the-process-class
https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods
