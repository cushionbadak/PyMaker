Natural Text
I am trying to solve a problem where I'm given an array, such as [0, 0, 1, 1, 2, 2, 6, 6, 9, 10, 10] where all numbers are duplicated twice, excluding one number, and I need to return the number that is not duplicated.I am trying to do it like this:However when it reaches the else statement, there is the following error:ValueError: list.remove(x): x not in listThis is occurring when i is in nums_copy, so I do not understand why this error occurs in this situation?
You already nums_copy.remove(i) so you can't nums_copy.remove(i) againYou could do:Result: 9
An easier (and more efficient) way of doing this than your initial approach is with a Counter object:The Counter object will create a dictionary-like object with the keys being the values in your list and the values being the number of times they appear. The most_common method will return a list of tuples of (value, count) sorted by count in decreasing order.If you don't know how many singlets there will be, you can get a list of them with:Complexity:I said my top solution was more efficient because your original implementation iterates through your list and for each item calls both remove and in which is going to get you to something like O(n2) complexity. In the Counter implementation the construction of the Counter object only does a single pass through the entire list. There is probably a sort going on when most_common is called so I'm guessing the complexity is about O(n log n). @Stefan Pochman has corrected me on this: Python uses the Timsort algorithm which will be very efficient in a case like this (if all but one of the numbers appear twice, the list is effectively almost completely sorted already) so its complexity will about about O(n).
The best algorithm is to use XOR to find the odd number.
Try this list comprehension. It goes through each element and checks if it is duplicated, and if it isn't, it lets it stay in the new list. It then gets the zeroth element of the new list:
If the array is sorted, we can find the answer in O(log n) time and O(1) extra space. Consider that repeated number pairs start on odd or even indexes depending on where the single element is:
This is a very long method of doing things.  As suggested you could use nums_copy.remove(i) or you could implement this is a much simpler manner using count():This will return the single number.  This method is fine as long as you do not have multiple values, if so it will return only the last one. You could otherwise return a list which would store multiple values like so:
Assuming a sorted iterable (otherwise sort it), here is the first occurrence of a non-duplicate pair:An alternative way to create non-overlapping pairs:more_itertools is a third-party library, > pip install more_itertools.
For anyone working with NumPy, this should be competitive in speed with other answers here:This just returns elements for which their count equals 1.


Answer URL
https://docs.python.org/3/library/collections.html#collections.Counter
