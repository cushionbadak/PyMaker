Natural Text
I'm trying to construct a numpy array, and then append integers and another array to it.I tried doing this:Printing out the output only gives my empty arrays. Why is that?In addition, how can I rewrite coords in a way that allows me to have 2D arrays like this: array[[0,0,0],[0,0,1],[0,0,-1]]?
numpy.append, unlike python's list.append, does not perform operations in place. Therefore, you need to assign the result back to a variable, as below.You can reshape coords as follows:More details on numpy.append behaviourDocumentation:Returns: A copy of arr with values appended to axis. Note that  append does not occur in-place: a new array is allocated and filled.If you know the shape of your numpy array output beforehand, it is efficient to instantiate via np.zeros(n) and fill it with results later.Another option: if your calculations make heavy use of inserting elements to the left of an array, consider using collections.deque from the standard library.
As stated above, numpy.append does not append items in place, but the reason why is important. You must store the returned array from numpy.append to the original variable, or else your code will not work. That being said, you should likely rethink your logic.Numpy uses C-style arrays internally, which are arrays in contiguous memory without leading or trailing unused elements. In order to append an item to an array, Numpy must allocate a buffer of the array size + 1, copy all the data over, and add the appended element.In pseudo-C code, this comes to the following:This is extremely inefficient, since a new array must be allocated each time (memory allocation is slow), all the elements must be copied over, and the new element added to the end of the new array.In comparison, Python lists reserve extra elements beyond the size of the container, until the size is the same as the capacity of the list, and grow exponentially. This is much more efficient for insertions at the end of the container than reallocating the entire buffer each time.You should use Python lists and list.append, and then convert the new list to a NumPy array. Or, if performance is truly critical, use a C++-extension using std::vector rather than numpy.append in all scenarios. Re-write your code, or it will be glacial.Edit Also,as pointed out in the comments, if you know the size of a Numpy array before hand, pre-allocating it with np.zeros(n) is efficient, as is using a custom wrapper around a NumPy array
np.append is not a list clone.  It is a clumsy wrapper to np.concatenate.  It is better to learn to use that correctly.List append is faster, and easier to initialize.  np.concatenate works fine with a list of arrays.  np.append uses concatenate, but only accepts two inputs.  np.array is needed if the list contains numbers or strings.You don't give an example of frag_str.  But the name and the use of split suggests it is a string.  I don't think anything else has a split method.That's a list of strings.  Using your indexing I can construct 2 lists:And I can make arrays from each of those lists:In the first case the array is 1d, in the second, 2d.It the string contains digits, we can make an integer array by specifying dtype.


Answer URL
https://docs.python.org/3/library/collections.html#collections.deque
