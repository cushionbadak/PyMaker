Natural Text
I got a waveform object, define as following:Through parsing, I get a list called waveforms with 770 instance of wfm in it. There is a lot of duplicate, and I need to delete them. My idea was to get the ID of equivalent object, store the largest ID in a list, and then loop on all the waveforms from the end while popping out each duplicate.Code:Turns out (thx to the print) that I have duplicates that don't appear into the ID list, for instance 750 is a duplicate of 763 (print says it; test too) and yet none of this 2 IDs appears in my duplicate list.I'm quite sure there is a better solution that this method (which doesn't yet work), and I would be glad to hear it. Thanks for the help!EDIT: More complicated scenarioI've got a more complicated scenario. I got 2 classes, wfm (see above) and stim:I parse my files to fill a dict: paradigm. It looks like that:Once again, I want to delete the duplicates, i.e. I want to keep only the data where:Waveforms are the sameAnd stim is the sameExample:The correlation is kinda messy in my head, so I got a few difficulties finding the right storage solution for wave forms and stimulation in order to compare them easly. If you got any idea, I'd be glad to hear it. Thanks!
ProblemThe .index method uses the .__eq__ method you overloaded. Sowill always find the first instance of the waveform in the list containing the same attributes as waveforms[j].SolutionImmutableYou don't need to store list indices if you do this immutably:MutableBig O AnalysisIt's a good habit to think about big O complexity when writing algorithms (though optimization should come at the cost of readability only when needed). In this case, these solutions are a bit more readable and also big O optimal. Your initial solution was O(n^2) due to the double for loop.Both solutions provided are O(n).


Answer URL
https://docs.python.org/3/library/collections.html#collections.namedtuple
