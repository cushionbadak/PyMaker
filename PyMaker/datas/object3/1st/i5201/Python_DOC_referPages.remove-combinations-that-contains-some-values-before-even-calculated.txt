Natural Text
given a list and exclusions elements, is it possible to ignore calculation of combinations that contains these elements ?Example 1Given l = [1, 2, 3, 4, 5], I want to calculate all combinations of size 4 and excluding combinations that contains (1, 3) before even calculated. The results would be :All combinations that contained 1 and 3 have been removed.Example 2suggested by @Eric Duminilthe result for l = [1, 2, 3, 4, 5, 6], size 4 and excluding (1, 2, 3) in second columnexcluding (1, 2) in third columnAll combinations that contained 1 and 2 and 3 have been removed from wanted results 1All combinations that contained 1 and 2 have been removed from wanted results 2I have a much bigger combinations to compute but it takes a lot of time and I want to reduce this time using these exclusions.Tried solutionsWith method 1, the combinations are still calculatedWith method 2, I tried to modify the combinations function but I could not find a proper way to ignore my exclusion list before calculated.EDIT:First of all, thank you all for your help, I forgot to give more details about constraints.The order of the ouputs is not relevant, from example, if result is [1, 2, 4, 5] [2, 3, 4, 5] or [2, 3, 4, 5] [1, 2, 4, 5], it is not important.The elements of the combinations should be (if possible) sorted, [1, 2, 4, 5] [2, 3, 4, 5] and not [2, 1, 5, 4] [3, 2, 4, 5] but it is not important since the combinations could be sorted after.The exclusions list is a list of all items that should not appear in the combinations together. e.g If my exclusion list is (1, 2, 3), all combinations that contains 1 and 2 and 3 should not be calculated. However, combinations with 1 and 2 and not 3 are allowed. In that case, if I exclude combinations that contains (1, 2) and (1, 2, 3) it is completely useless since all combinations that will be filtered by (1, 2, 3) are already filtered by (1, 2)Multiple exclude lists must be possible because I use multiple constraints on my combinations.Tested answers@tobias_kThis solution considers the exclusion list (1, 2, 3) as OR exclusion meaning (1, 2), (2, 3) and (1, 3) will be excluded if I understood well, this is useful in a case but not in my current problem, I modified the question to give more details, sorry for confusion. In your answer, I can't use only lists (1, 2) and (1, 3) as exclusion as you specified it. However the big advantage of this solution is to permit multiple exclusions.@Kasramvd and @mikuszefskiYour solution is really close to what I want, if it does include multiple exclusion lists, it would be the answer.Thanks
(As it turned out that my previous answer does not really satisfy the constraints of the question, here's another one. I'm posting this as a separate answer, as the approach is vastly different and the original answer may still help others.)You can implement this recursively, each time before recursing to add another element to the combinations checking whether that would violate one of the exclude-sets. This does not generate and invalid combinations, and it works with overlapping exclude-sets (like (1,3), (1,5)), and exclude-sets with more than two elements (like (2,4,5), allowing any combinations except all of them together).Example:Well, I did time it now, and it turns out this is considerably slower than naively using itertools.combination in a generator expression with a filter, much like you already do:Calculating the combinations in Python is just slower than using the library (which is probably implemented in C) and filtering the results afterwards. Depending on the amount of combinations that can be excluded, this might be faster in some cases, but to be honest, I have my doubts.You could get better results if you can use itertools.combinations for subproblems, as in Kasramvd's answer, but for multiple, non-disjunct exclude sets that's more difficult. One way might be to separate the elements in the list into two sets: Those that have constraints, and those that don't. Then, use itertoolc.combinations for both, but check the constraints only for the combinations of those elements where they matter. You still have to check and filter the results, but only a part of them. (One caveat, though: The results are not generated in order, and the order of the elements within the yielded combinations is somewhat messed up, too.) This is already much better then the recursive pure-Python solution, but still not as good as the "naive" approach for the above example:However, the results depend very much on the input. For a larger list, with constraints only applying to a few of those elements, this approach is in fact faster then the naive one:
(Turns out this does not do exactly what OP wants. Still leaving this here as it might help others.)To include mutually exclusive elements, you could wrap those in lists within the list, get the combinations of those, and  then the product of the combinations of sub-lists:A more complex example:This does not generate any "junk" combinations to be filtered out afterwards. However, it assumes that you want at most one element from each "exclusive" group, e.g. in the second example, it not only prevents combinations with 2,4,5, but also those with 2,4, 4,5, or 2,5. Also, it is not possible (or at least not easy) to have exclusively one of 1,3, and 1,5, but allow for 3,5. (It might be possible to extend it to those cases, but I'm not yet sure if and how.)You can wrap this in a function, deriving the slightly different input format from your (presumed) format and returning an accordant generator expression. Here, lst is the list of elements, r the number of items per combinations, and exclude_groups a list of groups of mutually-exclusive elements:
From an algorithmic perspective you can separate the excluded and the reset of the valid items and calculate the combinations of each set separately and just concatenate the result based on the desire length. This approach will entirely refuse of including all the excluded items at once in combination but will omit the actual order.Demo:Benckmark with other answers:Results: this approach is faster that the others
I have made an attempt to edit combinations according to your requirements :It will return something like this :(1, 2, 4, 5)  (2, 3, 4, 5)
I did the exclusion during the combination using the following code to save the second loop time. you just need to pass the indices of the excluded elements as a set. update: working fiddle
I guess my answer is similar to some others here, but this was what I fiddled together in parallel
Algorithmically you have to calculate the combination of the items within your list that are not among the excluded ones then add the respective combinations of the excluded items to the combination of the rest of items. This approach of course requires a lot of checking and need to keep track of the indexes which even if you do it in python it won't give you a notable difference in performance (known as drawbacks of Constraint satisfaction problem). (rather than just calculating them using combination and filtering the unwanted items out).Therefor, I think this is the best way to go in most of the cases:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.combinations
https://docs.python.org/3/library/itertools.html#itertools.combinations
https://docs.python.org/3/library/itertools.html#itertools.product
https://docs.python.org/3/library/itertools.html#itertools.combinations
