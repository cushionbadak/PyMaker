Natural Text
When I run the program, this returns:What I need is for x2 to be equal to -1e-9.The problem seems to be with the as it gives 10 as a result, obviously because 4*(10^-8)*(10^-8) is almost equal to 0, and is considered 0 by python.This results in:Any help would be greatly appreciated 
Use the decimal module:results in
You don't need extra precision to solve this problem: Python floats already have enough precision for the job.  You just need a (slightly) cleverer algorithm.Your problem stems from the subtraction of two nearly-equal computed values: for b positive and large (in comparison to a and c) when you do -b + sqrt(b*b-4*a*c), you end up with a result that has large relative error.  But note that this problem only applies to one of the two roots: in -b - sqrt(b*b-4*a*c), there's no such problem.  Similarly, for b large and negative, the first root is fine, but the second may be subject to loss of accuracy.The solution is to use your existing formula to compute whichever of the roots doesn't have the cancellation problem, and then use a different formula for the other root (essentially, using the fact that you know that the product of the two roots is c / a).  That formula is 2c / (-b +/- sqrt(b*b-4*a*c)).Here's some example code.  It uses math.copysign to pick the sign that won't lead to cancellation error:This deals with the most serious possible cause of numerical instability.  There's a second possible cause, in the computation of the discriminant, if b*b happens to be very close to 4*a*c.  In that case, it's possible to lose up to half the correct significant figures (so you'll get only 7-8 accurate digits for each root). Getting full-precision results in that case would require computing the discriminant using extended precision.The wikipedia article on loss of significance contains a useful discussion of exactly this problem.
You can also use the bigfloat library for the same, with arbitrary precision.


Answer URL
https://docs.python.org/3/library/math.html#math.copysign
