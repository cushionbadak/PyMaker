Natural Text
As is mentioned in the documentation: Python socket.accept()Accept a connection. The socket must be bound to an address and  listening for connections. The return value is a pair (conn, address)  where conn is a new socket object usable to send and receive data on  the connection, and address is the address bound to the socket on the  other end of the connection.The newly created socket is non-inheritable.Changed in version 3.4: The socket is now non-inheritable.The server code isThe client code isThe address of the new socket object that is returned, is always the same as the original socket which was actually accepting connections.I always thought that the server would create a new socket object with a different random port, but as can be seen above, even for multiple clients, the address and port of new conn object is still the same. How is then the server able to handle multiple clients?EditI know the above code is blocking. If I use multiple threads to handle different client connections, I'll have to do send the new socket object, and client address to my thread function. Therefore, multiple threads are then handling multiple clients using the same server address and port.Threaded server
I always thought that the server would create a new socket object with a different random portThat would require telling the client which new port to use for the connection. Nicely enough, it is not necessary, see below. It would also mean, you could not have more than 65535 open connections to a single host address, which probably would break quite a bit for some systems.How is then the server able to handle multiple clients?The tuple (server_addr, server_port, client_addr, client_port) is unique after a client connects. When a packet comes in, the network stack searches for open connections matching this tuple and redirects incoming packets to the relevant socket (/file descriptor).The server socket (which you perform accept() on), is unconnected (it is listen()ing), but bound. This means it doesn't have a peer on the other side (no client address), but it does have a local address (server side).accept() returns a new socket. This one is bound and connected. Bound is the same as above: it has a local address and port. That address is the same as for the server socket, however the new socket's state is also connected. This means that there is a known peer (with an address) on the other side that we can communicate with. We also have that peer's address (the peer address) and port (peer port). This information is enough to uniquely identify the connection.The client socket only accepts data that matches all four of (server_addr, server_port, client_addr, client_port).


Answer URL
https://docs.python.org/3/library/socket.html#socket.socket.accept
