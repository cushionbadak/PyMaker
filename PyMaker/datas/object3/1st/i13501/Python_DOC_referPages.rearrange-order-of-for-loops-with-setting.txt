Natural Text
I'm working with arrays having the following kind of structure/entries (for a masters project in quantum info games);The 1st column entries {0,1}, 2nd col {0,1}, 3rd col {0,2**(d-1)} , last col {0,d-1}.As follows for d=3:I'm using the following function to build this array:Now what I'd like to be able to do, is easily choose in which order the entries in the columns start counting. (Above its from the right column to the left.)For instance, say Id like the 1st column to begin counting, then the 3rd column, then the 4th column and at last the 2nd one. I can get this by permuting the for-loops in the function:Which gives:Permuting the order of the for-loops in the function works, but I'd have to write 24 different cases to cover all permutations. Anyone have an idea what would be, in general, a nicer solution/approach?
The thing you're calculating is called the "Cartesian product" and by chance popular demand the itertools module from the standard library has a function to construct it without all the explicit loops. By permuting the order of the arguments given to itertools.product, the column count-order is determined. The only thing left to do is rearranging the columns back to the desired order, but this is easily accomplished with Numpy.The output given as example can now be obtained by calling make_games(3, [0, 2, 3, 1]). Also, all possible permutations are now easily obtained by looping over itertools.permutations(range(4)).As a bonus, here's a way to make this operation perform a lot faster with just Numpy (for larger d):
Each column of G is made from 4 dimensions that extend to 2, 2, 4 and 3 units respectively. These 4 dimensions could be permuted in 24 ways. To form each column of G, one can use any 4 of those 24 permuted dimensions in permutations(24,4) = 10626 ways.Thus, if I got all of this correctly, you would have 10626 such G versions. So, to be memory-efficient, it would make sense to use a loop to run through those 10626 ways. Here's the implementation to fulfil all of the talk -
I think there is an inconsistency probelm in your question. I think you mean 3rd col {0,2**(d-1)-1} instead of {0,2**(d-1)}.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.product
