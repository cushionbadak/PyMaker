Natural Text
I am new to Python and I'm not able to understand why I am getting the results with None values.When I print the result it shows the following: [None, None]PS: I've seen other solutions and also aware of the list(set(list)) but I am trying to understand why the above result with integers gives [None, None] output.
Although using a set is the proper way, the problem with your code, as the comments indicated, is that you are not actually returning unique_list from your function, you are returning the result of the list comprehension.Here I simply made a throwaway variable do that is useless, it just "runs" the comprehension. Understand?That comprehension is storing a value each time you call unique_list.append(item) ... and that value is the result of the append method, which is None! So do equals [None, None].However, your unique_list is in fact being populated correctly, so we can return that and now your function works as expected.Of course, this is not a normal use for a list comprehension and really weird.
The problem with your code is that the method list.append returns None. You can test this easily with the following code:So, a solution for you would issue would beThe idea is that you will begin with an empty list of aldeady included elements and you will loop over all the elements in list, including them in the alreadyIncluded list. The not is necessary because the append will return None and not None is True, so the if will not be affected by the inclusion.You were including a list of the result of the appends (always None), but what you need is a list of the elements that passed the if test.I hope it helps.
As the other answers have explained, the reason you're getting a list of None values is because list.append returns None, and you're calling it in a list comprehension. That means you're building a list full of None values along side your list of unique values.I would like to suggest that you ditch the list comprehension. Because you need to access outside state (the list of unique values seen so far), a comprehension can't easily do what you want. A regular for loop is much more appropriate:A more Pythonic approach however would be to use a set to handle the unique items, and to make your function a generator:The itertools.ifilterfase function from the standard library can help improve this even further, as shown in the recipe in the docs (you'll have to scroll down a little to find the specific recipe):


Answer URL
https://docs.python.org/3/library/itertools.html#itertools-recipes
