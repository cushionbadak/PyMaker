Natural Text
Say there's a function functhat I need to examine.As a part of the examination I want to "retrieve" source code or objects of all nested classes and functions (if any). However I do realize that they don't exist yet and there's no direct/clean way of accessing them without running func or definingthem outside (before) func. Unfortunately, the most I can do is import a module containing func to obtain the func function object.I discovered that functions have the __code__ attribute containing the code object, which has the co_consts attribute so I wrote this:Those code objects look awfully similar and I don't think they contain data necessary to help me distinguish between types of objects they represent (e.g. type and function).Q1: Am I right?Q2: Is there any way to access classes/functions (ordinary and lambdas) defined within the function body?
A1: Things that can help you are -Constants of the code objectFrom the documentation:If a code object represents a function, the first item in co_consts is  the documentation string of the function, or None if undefined.Also, if a code object represents a class, the first item of co_consts is always the qualified name of that class. You can try to use this information.The following solution will correctly work in most cases, but you'll have to skip code objects Python creates for list/set/dict comprehensions and generator expressions:printsCode flagsThere's a way to get the required information from co_flags. Citing the documentation I linked above:The following flag bits are defined for co_flags: bit 0x04 is set if  the function uses the *arguments syntax to accept an arbitrary number  of positional arguments; bit 0x08 is set if the function uses the  **keywords syntax to accept arbitrary keyword arguments; bit 0x20 is set if the function is a generator.Other bits in co_flags are reserved for internal use.Flags are manipulated in compute_code_flags (Python/compile.c):There're 2 code flags (CO_NEWLOCALS and CO_OPTIMIZED) that won't be set for classes. You can use them to check the type (doesn't mean you should - poorly documented implementation details may change in the future):The output is exactly the same.Bytecode of the outer functionIt's also possible to get object type by inspecting the bytecode of the outer function.Search bytecode instructions to find blocks with LOAD_BUILD_CLASS, it  signifies the creation of a class (LOAD_BUILD_CLASS - Pushes builtins.__build_class__() onto the stack. It is later called by CALL_FUNCTION to construct a class.)The output is the same (again).A2: Sure.Source codeIn order to get the source code for code objects, you'd use inspect.getsource or equivalent:For instance nested_sources(complex_func) (see below)must yield source code for the first lambda, decorator, b (including @decorator) and c:Function and type objectsIf you still need a function/class object, you can eval/exec the source code. Examplefor lambda functions:for regular functionsfor classes
https://docs.python.org/3/library/dis.html#dis.dis


Answer URL
https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy
https://docs.python.org/3/library/dis.html
https://docs.python.org/3/library/inspect.html#inspect.getsource
https://docs.python.org/3/library/functions.html#eval
https://docs.python.org/3/library/functions.html#exec
https://docs.python.org/3/library/dis.html#dis.dis
