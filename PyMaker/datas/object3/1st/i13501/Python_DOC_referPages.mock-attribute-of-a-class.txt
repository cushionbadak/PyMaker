Natural Text
I'm doing an unit test on a file and I'm having trouble to mock an attribute or function call (self.logger.info) in my class B. I have two classes A and B and B inherit from A.and in another module:I want to mock self.logger.info to not be called. I tried to used patch('A.logging.info') but it didn't work. I also tried patch('A.logging.getLogger') but if I print type(self.logger) in function() while testing I get an logging object not a mock object.
Your attribute is set when creating an instance. Just patch logging.getLogger or even logging.Logger.info.If you patch the logging.getLogger() call, you don't have to patch any other self.logger calls either, as the resulting mock will take care of any attributes on it:With the mock in place, using logging.getLogger() returns a new mock object (the mock_log.return_value object), and any attempt to access self.logger.info then returns the mock_log.return_value.info object, which logs calls testable with the Mock.assert_called_with() method.Demo:
The real issue is that you want to patch just info logger and not logger. To do it you should useThe funny thing is that logging.getLogger() return a global object a so this method work even if B object is created before the patch context:


Answer URL
https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.return_value
https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.assert_called_with
