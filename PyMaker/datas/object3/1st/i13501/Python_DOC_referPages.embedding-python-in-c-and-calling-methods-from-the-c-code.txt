Natural Text
I try to embed a Python script into my C++ program. After reading some things about embedding and extending I understand how to open my own python script and how to pass some integers to it. But now I'm at a point a do not understand how to resolve my problem. I have to do both, calling Python functions from C++ and calling C++ functions from my embedded Python script. But I do not know where I have to start. I know I have to compile a .so file to expose my C++ functions to Python but this is nothing I can do, because I have to embed my Python file and control it by using C++ code (I have to extend a large software with a script language, to make some logic easy to edit).So, is there any way to do both things? Calling Python functions from C++ and calling C++ functions from Python?This is my C++ codeand this is my Python file
In short, Python extensions that are statically linked with embedded Python need to have their module initializer function explicitly added to the initialization table before the interpreter is initialized.Boost.Python uses the BOOST_PYTHON_MODULE macro to define a Python module initializer.  The resulting function is not the module importer.  This difference is similar to that of creating a example.py module and calling import example.When importing a module, Python will first check if the module is a built-in module.  If the module is not there, then Python will then search the module search path trying to find a python file or library based on the module name.  If a library is found, then Python expects the library to provide a function that will initialize the module.  Once found, the import will create an empty module in the modules table, then initialize it.  For statically linked modules, such as hello in the original code, the module search path will not be helpful, as there is no library for it to find.For embedding, the module table and initialization function documentation states that for static modules, the module initializer function will not be automatically called unless there is an entry in the initialization table.  For Python 2 and Python 3, one can accomplish this by calling  PyImport_AppendInittab() before Py_Initialize():Also note that the Python's C API for embedding changed naming conventions for module initialization functions between Python 2 and 3, so for BOOST_PYTHON_MODULE(hello), one may need to use &inithello for Python 2 and &PyInit_hello for Python 3.Here is  a complete example demonstrating having an embedded Python import a demo user module, that will then import a statically linked hello module.  It also invokes a function in the user module demo.multiply, that will then invoke a method exposed through the statically linked module.Contents of demo.py:Usage:In the above code, I opted to use Boost.Python instead of the Python/C API, with the C++ comments annotated with the equivalent Python code.  I find it to be much more succinct and far less error prone.  If a Python error occurs, Boost.Python will throw an exception and all reference counting will be handled appropriately.Also, when using Boost.Python, do not invoke Py_Finalize().  Per the Embedding - Getting started section:Note that at this time you must not call Py_Finalize() to stop the interpreter. This may be fixed in a future version of boost.python.


Answer URL
https://docs.python.org/3/tutorial/modules.html#the-module-search-path
https://docs.python.org/3/extending/extending.html#the-module-s-method-table-and-initialization-function
https://docs.python.org/3/c-api/import.html#c.PyImport_AppendInittab
https://docs.python.org/3/c-api/init.html#c.Py_Initialize
