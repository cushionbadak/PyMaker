Natural Text
I am using a C extension module in Python (call it ext) using ctypes to access a C library.  I have two ctypes structures, Foo and Bar, which circularly point to one another. Explicitly, Bar holds a ctypes pointer to an instance of Foo, and Foo holds a void pointer (for long reasons) that gets assigned to an instance of Bar, i.e.where the C code for ext.init, which assigns the pointers, looks like this:I can now print number withBut if I access this variable a second time, I get this error:  I believe ctypes always makes a new object whenever you retrieve an attribute, so maybe the problem is that Bar can't release the memory ptr points to since it didn't allocate it?  If it makes a difference, Foo and Bar are in different C extensions.UPDATEI think I understand things slightly better now.  When I call(I think) a new python object is created for b.ptr.contents.  Then, when it goes out of scope after the print statement, Foo.__del__ gets called (I'm at least sure of the last part, since I added a print statement in Foo.__del__).Foo.__del__ is set up to call a function in the C library to free all the pointers in the instance (the real struct is more complicated than above).  I don't understand how the object b.ptr.contents gets created.  If it doesn't call Foo.__init__, then the memory for the pointers wouldn't get allocated, so maybe it would make sense that I get the error above?
Thanks @eryksun for solving this for me.  In case it's useful to others, the problem was that I had:where free_pointers was a C function that freed all the pointers in C's Foo struct instance.  As eryksun points out, when I access b.ptr.contents, this makes a Foo instance, but it has a member _b_needsfree_ that's set to 0 (so that your original instance in C doesn't get deallocated whenever you access the pointer), so all I had to do to fix the problem, is check this variable, i.e.,


Answer URL
https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_clear
