Natural Text
I have the following SQL query and would like to parse it using sqlparsewould give all the tokens included in the SQL statement:How can I parse these tokens in order to process CASE WHEN statements in a way that I can extract all the conditions and maintain their precedence as defined by the use of parentheses. I was not able to find any relevant examples in the documentation. Any thoughts on this?
The project is indeed a little underdocumented. I looked at the examples and scanned the source code a little. The documentation unfortunately doesn't include all methods on the Token and TokenList classes that are useful for this task.For example, an important but omitted method is the TokenList.get_sublists() method, which lets you traverse over nested token lists more easily than other methods do; the TokenList.flatten() method only yields ungrouped tokens in the tree, whereas CASE is a grouped token, so going purely by the documentation you might find it hard to do something useful with the parsed token tree.Another handy method that I noticed in the codebase is the TokenList._pprint_tree() method, which dumps out the current token tree to stdout. This is very helpful when trying to write code that analyses the tree.All in all my overall impression of sqlparse is that it is less of a parsing library than a tool to re-format SQL. It includes a good parser but doesn't include the tools necessary to make general use of the tree it produces.What is really missing in the library is a base node visitor class such as that provided by the Python ast module, or a tree node walker, again like the ast module provides. Either is easy enough to build yourself, luckily:Now you can use either to access the Case nodes:orThe difference between the walk_tokens() and NodeVisitor patterns is negligible in this example, but we are simply extracting the separated tokens for each of the CASE statements, with no processing of the WHEN ... THEN ... tokens. In the NodeVisitor pattern you'd set more attributes on the current visitor instance to 'switch gears' and capture further information about those subtree tokens in more visit_.... methods, which may be easier to follow than a nested for loop over a generator.On the other hand, with the walk_tokens() generator, if you create a separate variable to reference the generator, you can hand over iteration to helper functions:where extract_branches would further iterate until it came to the end of the case statement.


Answer URL
https://docs.python.org/3/library/ast.html#ast.NodeVisitor
https://docs.python.org/3/library/ast.html#ast.walk
