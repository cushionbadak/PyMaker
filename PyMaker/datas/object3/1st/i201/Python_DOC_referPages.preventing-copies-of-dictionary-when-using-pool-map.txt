Natural Text
I have a function f(x) I want to evaluate over list of values xrange in parallel. The function does something like this:it takes values a matrix from a dictionary dict1, a vector from dictionary dict2, then multiplies them together. Now my normal approach for doing this in parallel would be something like this:Now when dict1 and dict2 are big dictionaries, this causes the code to fail with the error and I think this is because pool is making copies of the dict1 and dict2 for every evaluation of my function. Is there an efficient way, instead, to set these dictionaries as shared memory objects? Is map the best function to do this?
If you're on a fork-based system (read: Not Windows), one solution to this problem is to put the dicts in question in globals, write a function that doesn't take them as arguments, but simply access them from its own globals, and use that. functools.partial is, unfortunately, unsuited to this use case, but your use case makes it easy to replace with globals and a def-ed function:Changes to dict1/dict2 won't be reflected between processes after the Pool is created, but you seem to be using it in a read-only fashion anyway, so that's not a problem.If you're on Windows, or need to mutate the dicts, you can always make a multiprocessing.Manager and make dict proxies with the dict method of the manager (these are shared dicts, updated on key assignment), but it's uglier and slower, so I'd discourage it if at all possible.
If you want to share memory between processes using multiprocessing, you'll need to explicitly share the objects with multiprocessing.Array.  That's not ideal since you're wanting to access elements from dicts and finding the correct data might be time consuming.  There are likely ways around this if it does become a problem for you.As @Peque mentioned, the other option is to use threading.  With threading, memory is automatically shared across all processes but you can run into performance issues due to the global interpreter lock (GIL).  The GIL is Python's way to keep you thread-safe and avoid race conditions.


Answer URL
https://docs.python.org/3/library/multiprocessing.html#multiprocessing.managers.SyncManager.dict
