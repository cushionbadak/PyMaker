Natural Text
I have to do my study in a parallel way to run it much faster. I am new to multiprocessing library in python, and could not yet make it run successfully.Here, I am investigating if each pair of (origin, target) remains at certain locations between various frames of my study. Several points:It is one function, which I want to run faster (It is not several processes).The process is performed subsequently; it means that each frame is compared with the previous one.This code is a very simpler form of the original code. The code outputs a residece_list.I am using Windows OS.Can someone check the code (the multiprocessing section) and help me improve it to make it work. Thanks.
Multiprocessing does not make sense in the context you are presenting here.You are creating five subprocesses (and three threads belonging to the pool, managing workers, tasks and results) to execute one function once. All of this is coming at a cost, both in system resources and execution time, while four of your worker processes don't do anything at all. Multiprocessing does not speed up the execution of a function. The code in your specific example will always be slower than plainly executing Main_Residence(20, 50, 50) in the main process.For multiprocessing to make sense in such a context, your work at hand would need to be broken down to a set of homogenous tasks that can be processed in parallel with their results potentially being merged later.As an example (not necessarily a good one), if you want to calculate the largest prime factors for a sequence of numbers, you can delegate the task of calculating that factor for any specific number to a worker in a pool. Several workers would then do these individual calculations in parallel: Output:(the largest_prime_factor function is taken from @Stefan in this answer)As you can see, the pool is only roughly twice as fast as single process execution of the same amount of work, all while running in three processes in parallel. That's due to the overhead introduced by multiprocessing/the pool.So, you stated that the code in your example has been simplified. You'll have to analyse your original code to see if it can be broken down to homogenous tasks that can be passed down to your pool for processing. If that is possible, using multiprocessing might help you speed up your program. If not, multiprocessing will likely cost you time, rather than save it.Edit:Since you asked for suggestions on the code. I can hardly say anything about your function. You said yourself that it is just a simplified example to provide an MCVE (much appreciated by the way! Most people don't take the time to strip down their code to its bare minimum). Requests for a code review are anyway better suited over at Codereview.Play around a bit with the available methods of task delegation. In my prime factor example, using apply_async came with a massive penalty. Execution time increased ninefold, compared to using map. But my example is using just a simple iterable, yours needs three arguments per task. This could be a case for starmap, but that is only available as of Python 3.3.Anyway, the structure/nature of your task data basically determines the correct method to use.I did some q&d testing with multiprocessing your example function.The input was defined like this:I ran that in Python 3.6 in three subprocesses with your function unaltered, except for the removal of the print statment (I/O is costly). I used, starmap, apply, starmap_async and apply_async and also iterated through the results each time to account for the blocking get() on the async results.Here's the output:As you can see, the execution times differ, although all four methods do the same amount of work; the apply_async you picked appears to be the fastest method.Coding Style. Your code looks quite ... unconventional :) You use Capitalized_Words_With_Underscore for your names (both, function and variable names), that's pretty much a no-no in Python. Also, assigning the name Previous_List to a dictionary is ... questionable. Have a look at PEP 8, especially the section Naming Conventions to see the commonly accepted coding style for Python.Judging by the way your print looks, you are still using Python 2. I know that in corporate or institutional environments that's sometimes all you have available. Still, keep in mind that the clock for Python 2 is ticking


Answer URL
https://docs.python.org/3/library/multiprocessing.html?highlight=process#multiprocessing.pool.Pool.starmap
https://docs.python.org/3/library/multiprocessing.html?highlight=process#multiprocessing.pool.Pool.apply
https://docs.python.org/3/library/multiprocessing.html?highlight=process#multiprocessing.pool.Pool.starmap_async
https://docs.python.org/3/library/multiprocessing.html?highlight=process#multiprocessing.pool.Pool.apply_async
