Natural Text
The documentation for asyncio.gather says thatIf return_exceptions is False (default), the first raised exception is  immediately propagated to the task that awaits on gather(). Other  awaitables in the aws sequence wonâ€™t be cancelled and will continue to  run.However, from a simple test it seems that if one of the tasks raises an exception when return_exceptions is False, all other awaitable are cancelled (or to be more precise, in case the terminology is not clear to me, the other awaitables do not finish their job):What this piece of code is doing, just to make it simpler, it defines 3 tasks and call asyncio.gather() on them. One of the tasks raises an exception before one of the others is done, and this other task is not finished.Actually, I cannot even make sense with what the documentations says - if an exception is raised and caught by the task awaiting on gather, I would not even be able to get the returned results (even if the other task would, somehow, get done).Am I missing anything, or is there a problem with the documentation?This was tested with Python 3.7.2.
I've run your code and got the following output, as expected from documentation.What's going onTasks A,B and C are submitted to the queue;All tasks are running while C finishes earliest.Task B raises and exception.The await asyncio.gater() returns immediately and print('Got an exception:', e) to the screen.Task A continues to run and print "==>> Task A DONE ..."What's wrong with your testAs @deceze commented, your program exited immediately after the exception was caught and main() returns. Thus, the tasks A and C are terminated because the entire process dies, not because of cancellation.To fix it, add await asyncio.sleep(20) to the end of the main() function.


Answer URL
https://docs.python.org/3/library/asyncio-task.html#asyncio.gather
