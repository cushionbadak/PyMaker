Natural Text
I found some del behavior I don't understand and hope you can give me some insight. I'm trying to implement OpenGL's hello_triangle using PyOpenGL and glfw. After closing the OpenGL window my program is supposed to clean up, but glDeleteBuffers raises a TypeError, BUT ONLY if it is called inside a __del__ function:If instead I implement it like thisglDeleteBuffers suddenly works and throws no errors. Why is this? In case you wanna try it yourself, here's the full code:
glDeleteBuffers raises a TypeError, BUT ONLY if it is called inside a __del__ function:The error is caused, because the OpenGL context is destroyed, before the destructor is called.As for any other OpenGL instruction, for glDeleteBuffers a valid and current OpenGL context is needed.If is called, then delete() and by that glDeleteBuffers is called immediately. At this point the OpenGL context is current and the Operation will succeed in any case. But when you dothen there is not guarantee that the destructor is called immediately.See Python- 3.3.1. Data model - Basic customizationNote del x doesn’t directly call x.__del__() — the former decrements the reference count for x by one, and the latter is only called when x’s reference count reaches zero.When the destructor is called depends on the garbage collection. Python doesn't give any guarantee, about when the destructor is called it happens after all references have been deleted, so it might not necessary happen right after.This causes that the destructoris called, after the OpenGL contest was destroyed (after glfwTerminate()) and the operation fails.A safe method would be to call the destructor directly:e.g.


Answer URL
https://docs.python.org/3/reference/datamodel.html#basic-customization
