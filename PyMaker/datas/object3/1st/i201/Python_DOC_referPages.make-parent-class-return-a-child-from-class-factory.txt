Natural Text
I have a parent class, and I want to make it so that I can return its children from a class factory, here's some code:I get the following error:I get that its trying to call Super's __new__ method. Is there a way to skip that, or at least preserve the type signature in a way that doesn't cause infinite recursion? (I need to preserve the type signature of both classes).
When I run your code I get a different error, namely:    NameError: name 't' is not defined on the t = t line.This is because the body of a class statement is executed in its own namespace, so the t in the enclosing namespace isn't in scope as it usually is. Another issue is that your __new__() doesn't call its base class' __new__().Lastly, the call to Super(1)() is wrong. Calling a class returns an instance of the class (or in this case, an instance of a subclass).To fix all of these problems and get your code to work, you could need to do it like this:Update:Based on your comments, I would suggest using a class decorator instead. — something like this:This doesn't create subclasses, however you could change the name of the decorated class if you wished.
This may work:To avoid the error you need to define your custom __new__() method in Sub, so you can avoid to recursively call Super's __ new__() method.The type is preserverd in the _tp class attribute of Sub.With this code, the assert isinstance(Super(1)(), Super) does not raise any error.EDIT after commentFixed *args and **kwargs. The rule is that whatever argument signature you have in Sub.__init__() must be used also by Sub.__new__(). For example, if you need Sub.__init__(self, a, b) then you should have Sub.__new__(cls, a, b).


Answer URL
https://docs.python.org/3/glossary.html#term-metaclass
