Natural Text
Intuitively, the first list comprehension makes more sense. It's moving from specific to less specific, i.e. cell -> row -> table. (I find this really weird about Python list comprehensions, it should be table -> row -> cell, but I digress.)What's the logic behind cell -> table -> row? How does the parser see this?
The for loops are meant to be the same as if you wrote them out the "normal" way:So when you pull this into a list comprehension, you leave the loops as is (except for removing the ":") and just pull the final expression to the start:I admit it is a bit confusing when you just read the code left to right. You just have to remember to read the loops first, then the beginning statement goes at the end. I suppose it could have been implemented as but I think that looks even more confusing; it's harder to tell where the second loop ends and the statement within it starts. In the end, it's a design decision, though I'm sure some people would find the one approach or the other more intuitive.
I agree that your first attempt is overall more intuitive, as it more closely mimics how I and probably most people think about iterating over things from more specific to less specific.The nested python list comprehension is adapted from a nested for loop:Concatenate the lines:Wrap it in list brackets, delete :, and move the repeating expression to the front:
How does the parser see this?The syntax rules for such expressions in python are called "displays". You can find the definition here.the elements of the new container are those that would be produced by considering each of the for or if clauses a block, nesting from left to right, and evaluating the expression to produce an element each time the innermost block is reached.The iterable expression in the leftmost for clause is evaluated directly in the enclosing scope and then passed as an argument to the implictly nested scope. Subsequent for clauses and any filter condition in the leftmost for clause cannot be evaluated in the enclosing scope as they may depend on the values obtained from the leftmost iterable.Taking your example:The interpreter will break it down like this:Then the interpreter will reconstruct the nested loop in heirachy
You would think that the comprehension is inside-out version of the for loop. At least I did at first. But the easiest way for me to make sense of it is to notice that you'd call a variable before it is defined in your first attempt. row is called before it is defined. So logically you'd get an error.row is undefinedNo issues here


Answer URL
https://docs.python.org/3/reference/expressions.html#displays-for-lists-sets-and-dictionaries
