Natural Text
I have a dictionary of tuples such as:and the goal is to combine keys (regardless of ordering) and add their respective values, such that the result would look something likeI'm pretty sure I can do this with the following:However, I'm not very happy with this solution. I created another dictionary rather than maintaining the original, I have nested loops (though I don't think it's quite O(N**2) because the length of the second loop is always decreasing), and I have a feeling there's a more elegant solution.Is there a more pythonic or generally more elegant way of accomplishing this task?EDIT:For clarity, here are a few conditions that hold -- all tuples have exactly 2 elements, but the elements are not guaranteed to be comparable, as in we may have ('A', None). There do not exist any duplicate tuples, like ('A', 'A'), and the final order of the tuples is unimportant. This means that a resultis no better or worse than 
If you care about neither order nor duplicates within the tuples (that is, if your code converts ('A', 'B') into ('B', 'A'), and ('A', 'A') into ('A',), that's fine), you can use frozensets instead of tuples.If you care about duplicates but not order, sorted tuples will work. (Although if your tuple elements aren’t comparable, you’d need to come up with a comparison key—maybe just lambda x: type(x).__name__, x a la Python 2, but maybe something more complicated.)Either way, rather than building a dict, and then building another dict that sums up duplicates, just build a Counter in the first place:If you need to preserve but ignore order (the same way, e.g., some filesystems preserve but ignores case), you will need to do a bit more work. (You also need to decide whether you want to preserve the first or last of a matching set of keys.) One option is to use a "key-transforming dict" that wraps a dict, using the transformed key as the underlying key and the original key as an extra value in the values. Without a wrapper, it would look like this:
For a more pythonic solution, use collections.defaultdict or a collections.Counter:Result:Keep in mind that this only works if the values in your tuples are unique. If there was a tuple like ('A', 'A') in the dict, calling frozenset on it would collapse it to {'A'} and produce incorrect output. If this is a concern, you can replace the linewith to make it work correctly.


Answer URL
https://docs.python.org/3/library/collections.html#collections.defaultdict
https://docs.python.org/3/library/collections.html#collections.Counter
