Natural Text
Say for a list comprehension like this:what are the exact steps that Python is taking to evaluate the right hand expression and assign it to foo? Between 2.x and 3.x ... is the internal logic to handle something like this varying between the two?I would imagine that from a procedural perspective, Python is first performing foo[10:] then starting to iterate over the resulting list stripping the elements and then splitting them then appending the result a new list and finally pointing to that last list as foo.Is it internally allocating a new list for each operation? (One list for the resulting foo[10:], then another list for the result of strip, etc.?Thank you for any insight.
In Python 3.x, your list comprehension is compiled into something much like this:There are a few minor differences—the compiler can use something a bit faster than result.append because result isn't accessible; _comp is actually named something that isn't a valid identifier so you can't accidentally call it; etc. But that's basically it.1For full details, see Displays for lists, sets, and dictionaries in the reference documentation.That foo[10:] just calls foo.__getitem__(slice(None, 10, 10)). If foo is a list, that's handled by creating a new list with the elements from 10 through the end of foo. But if foo were, say, a numpy array, it might be a view into the same memory of foo, and if it were an instance of some crazy class you created just to see how you could screw with things, it could be anything you wanted, like the string 'abc'.Similarly, if the elements of foo are strings (or bytes), the strip method returns a new string with all of the characters but the stripped-off whitespace copied, and the split method returns a new list of copied strings.In Python 2.x, it's more like this:Although again, it's not exactly this—_result and _it have names that aren't valid identifiers, and the optimized special version of append is used, and so on.The 2.x documentation is in List Displays.The main reason for the change was that the 2.x design means the _ leaks out into the enclosing scope,2 although the fact that it allowed comprehensions and generator expressions to share most of the same code was another benefit.The other list and string operations are the same between 2.x and 3.x. While many functions did change to return iterators instead of copied lists in 3.x, slicing and splitting are not among them.The tutorial has a nice section on comprehensions, but it explains the 2.x behavior even in 3.x (because it's a bit easier to understand, and the difference isn't likely to matter to novices' code—it is a tutorial, after all).1. Also, notice the way the outermost iterable is passed in as an argument. This means you don't accidentally end up capturing a nested variable in a closure. Which doesn't make much difference for list comprehensions, but it's important for generator expressions, where the iteration may not start until after the value of that captured variable has changed.2. In 2.3-2.6, this leaking was officially documented behavior you could rely on. In 2.7, it was deprecated, and you aren't supposed to rely on it either leaking or not leaking. But in all current major implementations of 2.7 (and there won't be any new ones), list comprehensions always leak, although set and dict comprehensions do not.
Yeah, a new list is created for foo[10:] (assuming foo is a list), and a new list is created for each .split call (assuming _ is a str).It is equivalent to:Except that foo isn't assigned to until the endNote, by convention, you shouldn't use _ as a variable name unless you intend for it to not be used.Finally, one major difference between list comprehensions between Python 2 and Python 3 is that Python 3 creates an enclosing scope (essentially, a function scope) for the expression inside the list comprehension. Python 2 comprehensions do not, and variable will "leak" out of the construct.So, in Python 3:However, in Python 2:And if you really want, you can dig into the CPython internals a bit using dis:Note, the first three operations essentially create a function where the list comprehension magic happens. We can further introspect:And this is the bytecode that is actually executed for the comprehension. Note that the list is given the name .0, which you can see here: 3 LOAD_FAST                0 (.0) `


Answer URL
https://docs.python.org/3/reference/expressions.html#displays-for-lists-sets-and-dictionaries
https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions
