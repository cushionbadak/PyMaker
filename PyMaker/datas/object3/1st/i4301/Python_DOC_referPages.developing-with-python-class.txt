Natural Text
Nothing scares me more than the Python Class concept; and recently I have been trying to use/create classes to understand their purpose, structure and features, etc. However, I am not clear about the concept of class and how to create them. Please take a look at the following example:In this case, read_file, build_problem are custom functions that read data from a CSV file and build a PuLP-based linear problem, respectively. Now, my understanding is that when I initialize an object based on my Prob class, the file_contents are available for the class to use internally. In that case, how do I get the variables alpha, beta and gamma? For the current code, I get a TypeError: 'NoneType' object is not iterable. I have tested the functions and I know that they work without any error, which leaves me thinking that there is something wrong with the way I have defined the class. Any suggestions?   
Your prob_build method needs to return three values. You are currently not explicitly returning anything so it implicitly returns the single value None, and Python tries to parse that into three values, and obviously failing.This has nothing to do with the fact that this is a method of a class; functions return values regardless of how and where they are defined.It's perfectly okay for functions to not return anything, of course; but then obviously it doesn't produce a result you can obtain with something like variable = func()
Nothing scares me more than the Python Class concept;This is actually not a Python concept - classes exist in most object oriented languages. and recently I have been trying (...) to understand their purpose, structure and features, etc. However, I am not clear about the concept of classBefore we talk about classes, you have to understand objects. An object is a way to group together a state (a set of data) and a behavior (a set of functions acting on the state or according to the state). Now this is a bit of an abstract definition so let's see how it works with a simple example - a geometric point in a 2d space. For the state part, a 2d point is defined by it's x and y coordinates. You can represent this with a dict:Ok, fine but not very explicit and a bit error prone. We can start with a function that is responsible for creating a new point:Now we can build points without have to worry on the gory details. Ok, now let's a bit of behavior... A first useful function would be to check whether two points are equal (let's say they are equal if they have the same coordinates):You can see that this behavior depends on both points states.We could also want to move a point along the horizontal axis:or along the vertical axis:or both at the same time:Notice that here, the behavior is to change the point's state. And of course we want to have a way to get the point's x or y coordinates:What we've built here is what is known as an "abstract data type": instead of manually building a dict, manually comparing two dicts,  manually updating our dict and manually checking it's state, we have defined a set a function to do all this, more or less hiding the internal representation. and how to create them. A class is, mostly, another way to do the same thing, but with a lot of other goodness. Let's rewrite our "point" datatype as a Python class:And we don't actually need to write get_x() nor get_y(), we can directly access x and y:Actually, behind the hood, our p object is a dict:Other OOPLs might use other ways to store an object's state (structs for C-like languages for example), but in Python an object is actually mainly a dict. Well, a dict plus a class:and a set of "attribute lookup rules" (provided by the base class object) that will first lookup attributes on the object's __dict__ then on the object's class (which is how p.move_x(42) is actually interpreted as Point.move_x(p, 42).Classes and objects provide a lot of other goodies (inheritance etc), but basically they are just this: a dict (which stores the state) and a class (which stores the behavior). Now for your example:my understanding is that when I initialize an object based on my Prob class, the file_contents are available for the class to use internallyfile_contents is available for the instance - and the class functions can access it on the current instance - which is the self parameter. IOW, your build_prob function should use self.file_contents:Then you can access the problem and aux_vars on your instance:Just note that the problem and aux_vars attributes only exist after you called prob_build. This is considered as bad practice, since you can get an  AttributeError :A first step to fix this would be to initialize those attributes in the __init__ method (yes, that's why it's called "init"):but that's hardly better - you still need to call yourobj.prob_build() to have a usable state. The obvious fix here is to do all the initialization in the initializer and get rid of prob_build:but then you can ask yourself: what's the point of this class if it has no behavior, and all you do is:You could as well replace it with a simple function:As a general rule, if your class as either no state or no behavior, chances are you don't need a class. There are exceptions to this rule of course but this is still a good guideline. In your case, the hypothetical do_something_with(prob, aux_vars) might be a method too:but if that's the only behavior, you still don't need a class:So to make a long story short: ask yourself if and why you want a class. OOP is a good solution for some problems but is not the solution to all problems.
Similar to normal functions, class methods need to return something if you want the results! In your code, prob_build doesn't return anything! So, it should be something like this:Note that in this case, it returns two arguments. You should be more specific on what alpha, beta, and gamma are!
Your class function prob_build() does not return anything. It only sets variables internal to the class. 


Answer URL
https://docs.python.org/3/tutorial/classes.html
