Natural Text
Sample input stream: [ ('t','h'), ('h','e'), ('e', ' '), (' ','f') , ('f','o'), ('o','x'), ('x',' '), (' ','a'), ('a','t'), ('t','e'), ('e', <p>) ]Suppose you have a sentence {ABCABA}, where each letter is either a character or word, depending on tokenization.Then your bag-of-bigrams is {(AB), (BC), (CA), (AB), (BA)}.From here, I need an algorithm to list all the possible permutations of sentences with the same length as the original sentence, given these bigrams. Here, {ABCABA} (the original sequence) and (ABABCA) are both valid, possible sentences, but {ACBABA} is not. This example is for bigrams, but I also need this to work for any $n$. Any ideas?
Build a directed graph and then use recursion to enumerate all possible paths of length k. To wit,
Here's a very straightforward solution. First, compute all n-grams; second, get all possible sublists of these n-grams and get all permutations of those sublists.The n-grams (may be optional, given your sample input stream)You can use a comprehension list. Take n times the list with a start from indices 0 to n-1: [sentence[k:] for k in range(n)]. For ABCABA and 3, you get [ABCABA, BCABA, CABA]. You just have to zip the lists and join the resulting tuples (note the star to unpack the arguments):This gives:List sentencesYou can use itertools, specifically combinations and permutations. The combinations function gives the "r length subsequences of elements from the input iterable":You have to take the combinations for every possible length. The permutations function will permute all this subsequences:Or with a generator comprehension:This gives 206 possibilities:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.combinations
