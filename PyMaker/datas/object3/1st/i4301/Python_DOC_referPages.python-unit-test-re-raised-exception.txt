Natural Text
How does one write a unittest that fails only if a function doesn't throw an expected exception?
Use TestCase.assertRaises (or TestCase.failUnlessRaises) from the unittest module, for example:
Since Python 2.7 you can use context manager to get ahold of the actual Exception object thrown:http://docs.python.org/dev/library/unittest.html#unittest.TestCase.assertRaisesIn Python 3.5, you have to wrap context.exception in str, otherwise you'll get a TypeError
The code in my previous answer can be simplified to:And if afunction takes arguments, just pass them into assertRaises like this:
How do you test that a Python function throws an exception?How does one write a test that fails only if a function doesn't throw  an expected exception?Short Answer:Use the self.assertRaises method as a context manager:DemonstrationThe best practice approach is fairly easy to demonstrate in a Python shell. The unittest libraryIn Python 2.7 or 3:In Python 2.6, you can install a backport of 2.7's unittest library, called unittest2, and just alias that as unittest:Example testsNow, paste into your Python shell the following test of Python's type-safety:Test one uses assertRaises as a context manager, which ensures that the error is properly caught and cleaned up, while recorded. We could also write it without the context manager, see test two. The first argument would be the error type you expect to raise, the second argument, the function you are testing, and the remaining args and keyword args will be passed to that function. I think it's far more simple, readable, and maintainable to just to use the context manager.Running the testsTo run the tests:In Python 2.6, you'll probably need the following:And your terminal should output the following:And we see that as we expect, attempting to add a 1 and a '1' result in a TypeError.For more verbose output, try this:
Your code should follow this pattern (this is a unittest module style test):On Python < 2.7 this construct is useful for checking for specific values in the expected exception. The unittest function assertRaises only checks if an exception was raised.
from: http://www.lengrand.fr/2011/12/pythonunittest-assertraises-raises-error/First, here is the corresponding (still dum :p) function in file dum_function.py :Here is the test to be performed (only this test is inserted):We are now ready to test our function! Here is what happens when trying to run the test :The TypeError is actullay raised, and generates a test failure. The problem is that this is exactly the behavior we wanted :s.To avoid this error, simply run the function using lambda in the test call :The final output :Perfect !... and for me is perfect too!!Thansk a lot Mr. Julien Lengrand-Lambert
I use doctest[1] almost everywhere because I like the fact that I document and test my functions at the same time.Have a look at this code:If you put this example in a module and run it from the command line both test cases are evaluated and checked.[1] Python documentation: 23.2 doctest -- Test interactive Python examples
You can build your own contextmanager to check if the exception was raised.And then you can use raises like this:If you are using pytest, this thing is implemented already. You can do pytest.raises(Exception):Example:And the result:
Have a look at the assertRaises method of the unittest module.
I just discovered that the Mock library provides an assertRaisesWithMessage() method (in its unittest.TestCase subclass), which will check not only that the expected exception is raised, but also that it is raised with the expected message:
You can use assertRaises from the unittest module


Answer URL
https://docs.python.org/3/library/exceptions.html#bltin-exceptions
