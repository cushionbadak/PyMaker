Natural Text
I'm trying to learn python and came across some code that is nice and short but doesn't totally make sensethe context was:I get what it's doing, but why does python do this - ie return the value rather than True/False?returns 5. Similarly, changing the and to or will result in a change in functionality. SoWould return 10.Is this legit/reliable style, or are there any gotchas on this?
TL;DRWe start by summarising the two behaviour of the two logical operators and and or. These idioms will form the basis of our discussion below.andReturn the first Falsey value if there are any, else return the last  value in the expression.orReturn the first Truthy value if there are any, else return the last  value in the expression.The behaviour is also summarised in the docs, especially in this table:The only operator returning a boolean value regardless of its operands is the not operator."Truthiness", and "Truthy" EvaluationsThe statement Is a very pythonic concise (and arguably less readable) way of saying "if args is not empty, return the result of max(args) - min(args)", otherwise return 0. In general, it is a more concise representation of an if-else expression. For example,Should (roughly) translate to:Or, equivalently,Where exp1 and exp2 are arbitrary python objects, or expressions that return some object. The key to understanding the uses of the logical and and or operators here is understanding that they are not restricted to operating on, or returning boolean values. Any object with a truthiness value can be tested here. This includes int, str, list, dict, tuple, set, NoneType, and user defined objects. Short circuiting rules still apply as well. But what is truthiness?It refers to how objects are evaluated when used in conditional expressions. @Patrick Haugh summarises truthiness nicely in this post.All values are considered "truthy" except for the following, which are  "falsy":NoneFalse00.00jDecimal(0)Fraction(0, 1)[] - an empty list{} - an empty dict() - an empty tuple'' - an empty strb'' - an empty bytesset() - an empty setan empty range, like range(0)objects for which     obj.__bool__() returns Falseobj.__len__() returns 0 A "truthy" value will satisfy the check performed by if or while  statements.  We use "truthy" and "falsy" to differentiate from the  bool values True and False.How and WorksWe build on OP's question as a segue into a discussion on how these operators in these instances.Given a function with the definitionHow do I return the difference between the minimum and maximum value  in a list of zero or more arguments?Finding the minimum and maximum is easy (use the inbuilt functions!). The only snag here is appropriately handling the corner case where the argument list could be empty (for example, calling foo()). We can do both in a single line thanks to the and operator:Since and is used, the second expression must also be evaluated if the first is True. Note that, if the first expression is evaluated to be truthy, the return value is always the result of the second expression. If the first expression is evaluated to be Falsey, then the result returned is the result of the first expression. In the function above, If foo receives one or more arguments, len(args) is greater than 0 (a positive number), so the result returned is max(args) - min(args). OTOH, if no arguments are passed, len(args) is 0 which is Falsey, and 0 is returned.Note that an alternative way to write this function would be:Or, more concisely,If course, none of these functions perform any type checking, so unless you completely trust the input provided, do not rely on the simplicity of these constructs.How or WorksI explain the working of or in a similar fashion with a contrived example.Given a function with the definitionHow would you complete foo to return all numbers over 9000?We use or to handle the corner case here. We define foo as:foo performs a filtration on the list to retain all numbers over 9000. If there exist any such numbers, the result of the list comprehension is a non-empty list which is Truthy, so it is returned (short circuiting in action here). If there exist no such numbers, then the result of the list comp is [] which is Falsey. So the second expression is now evaluated (a non-empty string) and is returned.Using conditionals, we could re-write this function as,As before, this structure is more flexible in terms of error handling. 
Quoting from Python DocsNote that neither and nor or restrict the value and type they return  to False and True, but rather return the last evaluated argument. This  is sometimes useful, e.g., if s is a string that should be replaced by  a default value if it is empty, the expression s or 'foo' yields the  desired value. So, this is how Python was designed to evaluate the boolean expressions and the above documentation gives us an insight of why they did it so.To get a boolean value just typecast it.Why?Short-circuiting.For example:The same goes for or too, that is, it will return the expression which is Truthy as soon as it finds it, cause evaluating the rest of the expression is redundant.Instead of returning hardcore True or False, Python returns Truthy or Falsey, which are anyway going to evaluate to True or False. You could use the expression as is, and it will still work.To know what's Truthy and Falsey, check Patrick Haugh's answer
and and or perform boolean logic, but they return one of the actual values when they are comparing. When using and, values are evaluated in a boolean context from left to right. 0, '', [], (), {}, and None are false in a boolean context; everything else is true.If all values are true in a boolean context, and returns the last value.If any value is false in a boolean context and returns the first false value. So the codereturns the value of max(args)-min(args) when there is args  else it returns len(args) which is 0.
Is this legit/reliable style, or are there any gotchas on this?This is legit, it is a short circuit evaluation where the last value is returned. You provide a good example. The function will return 0 if no arguments are passed, and the code doesn't have to check for a special case of no arguments passed. Another way to use this, is to default None arguments to a mutable primitive, like an empty list:If some non-truthy value is passed to alist it defaults to an empty list, handy way to avoid an if statement and the mutable default argument pitfall
GotchasYes, there are a few gotchas.fn() == fn(3) == fn(4, 4)First, if fn returns 0, you cannot know if it was called without any parameter, with one parameter or with multiple, equal parameters :What does fn mean?Then, Python is a dynamic language. It's not specified anywhere what fn does, what its input should be and what its output should look like. Therefore, it's really important to name the function correctly. Similarly, arguments don't have to be called args. delta(*numbers) or calculate_range(*numbers) might describe better what the function is supposed to do.Argument errorsFinally, the logical and operator is supposed to prevent the function to fail if called without any argument. It still fails if some argument isn't a number, though:Possible alternativeHere's a way to write the function according to the "Easier to ask for forgiveness than permission." principle:As an example:If you really don't want to raise an exception when delta is called without any argument, you could return some value which cannot be possible otherwise (e.g. -1 or None):
Is this legit/reliable style, or are there any gotchas on this?I would like to add to this question that it not only legit and reliable but it also ultra practical. Here is a simple example:Therefore you can really use it at your advantage. In order to be conscise this is how I see it:Or operatorPython's or operator returns the first Truth-y value, or the last value, and stopsAnd operatorPython's and operator returns the first False-y value, or the last value, and stopsBehind the scenesIn python, all numbers are interpreted as True except for 0. Therefore, saying:is the same as:Which is clearly False. It is therefore logical that it returns 0
Yes. This is the correct behaviour of and comparison.At least in Python, A and B returns B if A is essentially True including if A is NOT Null, NOT None NOT an Empty container (such as an empty list, dict, etc). A is returned IFF A is essentially False or None or Empty or Null. On the other hand, A or B returns A if A is essentially True including if A is NOT Null, NOT None NOT an Empty container (such as an empty list, dict, etc), otherwise it returns B. It is easy to not notice (or to overlook) this behaviour because, in Python, any non-null non-empty object evaluates to True is treated like a boolean.For example, all the following will print "True"On the other hand, all the following will print "False"


Answer URL
https://docs.python.org/3/library/stdtypes.html#boolean-operations-and-or-not
https://docs.python.org/3/reference/expressions.html#and
