Natural Text
How to use recursion to implement "Finding the maximum value in an array"  in Python ?The following is a simple test code I wroteI want to do it by recursionI'm learning algorithms, learning recursion. Thanks very much!
If you want to use recursion, it's very important to define carefully the end cases.The maximum of the elements of a list is, obviously, either the first element or the maximum of the rest of the list: it's the greatest of the two values. That's actually the recursion you are looking for.But what happens when there is no first element? You have an empty list, and an undefined behaviour. Why not maximum([]) = 0? Because it would lead to some inconsistency: maximum([-1]) = greatest(-1, maximum([])) = greatest(-1, 0) = 0. (You could also try maximum([]) == -math.inf, but this won't be very intuitive!)What if the rest of the list is empty? No problem, you have just one element and it is the maximum.Just translate this analysis into code:More on maximum([])I will try to give a value to maximum([]). I repeat the argument above. For any given n, maximum([n]) = greatest(n, maximum([])) = n. This implies that, for every n, maximum([]) <= n. The only value that meets this condition is -math.inf. Why not define maximum([]) == -math.inf? Imagine you create a minimum function. For symetrical reasons, you will have to define minimum([]) == math.inf. Hence it exists a list l0 = [] such that minimum(l0) > maximum(l0). No one would accept such a possibility.What should we do now? There are two main possibilities: defensive programming or use a contract. In defensive programming, the function will check the arguments it has received, and fail if one of these arguments is not correct. That's what I did:If you use a contract, you will basically say: if you give this function an empty list, then the behaviour is undefined. It might return any value, crash, loop forever, .... Here, you would have something like:It seems the same, but there is a huge difference. You can use, for implementation reasons, -math.inf as the return value for maximum([]), because it is now clear that it doesn't have any meaning. Someone who tries to check if minimum(l0) <= maximum(l0) for l0 = [] clearly breaks the contract and won't be surprised by the result. Of course, if you want to make it robust, you will write:
Try this (using recursion, as requested by the OP):No built-in functions are used (such as max) because the OP has stated that they don't wish to use any built-in functions.The else part of the function returns either the first element of the list or the largest number in the list (excluding the first element) depending on whichever number is larger.Each time the else part is executed, the largest(arr[1:]) bit checks which number is largest inside arr without the first element. This means that, at one point, arr will contain two elements. When it does so, a one-line if statement is used to compare the two elements and returns the larger element.Eventually, the code recurses back to the first level and returns the largest element.
I would write max and max_allmax_all can be called with any number of argumentsOr use * to unpack argumentsIt even works when 0 inputs are given

max and list are built-in functions. So you want to avoid using those identifiers yourself.Here's a simple version that uses recursion:


Answer URL
https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists
