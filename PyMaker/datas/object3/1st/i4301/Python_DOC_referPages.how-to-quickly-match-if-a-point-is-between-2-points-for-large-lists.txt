Natural Text
I have a dictionary with information about single positions: position_info, and info about features feature_info. I have to find in which features (can be multiple) the positions are located, so that I can annotate the positions. What I use now is:The problem is that feature_info contains 800k+ features, and position_info 150k positions, and this is quite slow. I can optimize it myself a little bit, but probably there are already methods that do it better than I can, but I have not found them. EDITSo for example this is one way I can think of to speed it up:if I order the positions I can break when the position is larger than an end position of a feature (if I make sure those are ordered too). However, there must be a better way to do this. How can I implement this in the fastest way?Comparison of the 3 answersbisect: 0.08317881799985116panda method 1: 29.6151025639997panda method 2: 16.90901438500032  However, the bisect method only works if there are no overlapping features, e.g. does not work, which does work with the pandas solution. 
The fastest way is probably to use a fast library: pandas. Pandas vectorizes your operations to make them speedy.
The bisect library and function is amazing for things like this.We basically create a sorted list of ranges that a feature will fall under. Let me know if you need additional logic for checking if a position doesn't fall within a feature range.Since feature_info[n][0:1] is a range of 2 values, we need to divide the bisect result (which is an index position) by 2.This will print the following (you should be able to get all the info you need from this, but I wanted to show the basic result):
Is a textual description OK?Preprocessing:sort the positionsconvert list of features into a list of "boundaries" (as in, start indices and end indices for each feature) - these will be triples of (index, start/end, feature). Sort this list by index.Algorithm (two nested for loops):start with empty set of 'current features'for each feature boundary:for each position from the range of: from the next position after last-visited position, until the position of current boundary's position:output that this position belongs to each of current featuresif the current boundary is a start, add it to the current featuresif the current boundary is an end, remove it from the current featuresNote that:the outer for loop will execute exactly once for each boundary,the inner for loop will execute (in total) exactly once for each position.This will be fast because you don't need to look at any position or any feature twice in both loops. It will actually approach O(N+M) complexity if the positions don't overlap often (so that the current_features set remains small).I assumed that there are no duplicate positions; handling these would add a little more complexity but the general approach would still work.
Also using pandas. First converts them to dataframes, then merges, then filters where position info key is between feature info columns.


Answer URL
https://docs.python.org/3/library/bisect.html
