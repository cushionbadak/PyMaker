Natural Text
There is this code:Why f returns int when there is return generator statement? I guess that yield and generator expression both returns generators (at least when the statement return 3 is removed) but are there some other rules of function compilation when there is once generator expression returned and second time when there is yield keyword inside?This was tested in Python 3.3
As soon as you use a yield statement in a function body, it becomes a generator. Calling a generator function just returns that generator object. It is no longer a normal function; the generator object has taken over control instead.From the yield expression documentation:Using a yield expression in a function definition is sufficient to cause that definition to create a generator function instead of a normal function.When a generator function is called, it returns an iterator known as a generator. That generator then controls the execution of a generator function. The execution starts when one of the generatorâ€™s methods is called.In a regular function, calling that function immediately switches control to that function body, and you are simply testing the result of the function, set by it's return statement. In a generator function, return still signals the end of the generator function, but that results in a StopIteration exception being raised instead. But until you call one of the 4 generator methods (.__next__(), .send(), .throw() or .close()), the generator function body is not executed at all.For your specific function f(), you have a regular function, that contains a generator. The function itself is nothing special, other that that it exits early when return 3 is executed. The generator expression on the next line stands on its own, it does not influence the function in which it is defined. You can define it without the function:Using a generator expression produces a generator object, just like using yield in a function, then calling that function produces a generator object. So you could have called g() in f() with the same result as using the generator expression:g() is still a generator function, but using it in f() does not make f() a generator function too. Only yield can do that.
is the same as The second return statement never gets executed, just by having a generator expression within f does not make it a generator.
I believe what you meant is:
Returning a generator doesn't make f a generator function.  A generator is just an object, and generator objects can be returned by any function.  If you want f to be a generator function, you have to use yield inside the function, as you did with g.


Answer URL
