Natural Text
The simple way my script runs is the user provides a folder location and a filetype and glob.glob() finds the files with the filetype provided and adds them to a list. It then uses a for loop and goes through the list and converts each video. But it doesn't like when I try to run my ffmpeg command. Any help would be awesome. I'm also using Win 7 64 bit with 64 bit ffmpeg and Python 3.3Here's the error:Here is my code:I've looked around and most of the tutorials are in 2.7 the code is 3.3 and I can't find a tutorial to use ffmpeg for 3.3. My ffmpeg is set to 'ffmpeg64' on my PATH. Thanks!
First:This part cannot possibly do anything useful. The newFilePath is a path you've made by stripping the last 4 characters off a video file. You can't run the program at that path, because (unless you get very, very unlucky) there is no such problem.That explains the first OSError.For the second error, it's telling you that ffmpeg64 isn't on your PATH. You say that it is on your PATH, but there is no other way that you could get that error from that line of code. You can look up what CreateProcess does if you want.There are three common reasons for this:You've used SET to modify the PATH in a particular cmd.exe session (DOS prompt), but you're running code in a different DOS prompt, or running GUI code, or for some other reason have a different session.You've used the control panel to modify PATH for your user, but you're running the Python script as a different user (e.g., as part of a WSGI service).You haven't modified PATH at all; you're relying on the fact that you've cd'd into the same directory as ffmpeg64, and . is on the default PATH in Windows.As a side note, this:… is the same as:… except that it's harder to read, and less robust (it will raise an exception if fileLoc is under 4 characters wrong), and slower and easier to get wrong. But really, if you want to strip off an extension, you don't want either. If you have foobar.mpeg, do you really want to turn that into foobar..mp4? Use the os.path module to munge paths:While we're at it, you've got some other problems in your code:subprocess.Popen creates a subprocess object, which you are eventually going to have to wait on. Printing it out won't do anything particularly useful.If you want to do the conversions one at a time, waiting for each one to finish before doing the next, use check_call, not Popen here.If you want to kick them all off in parallel, return myFile here, and then do something like this:


Answer URL
