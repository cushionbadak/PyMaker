Natural Text
I have a string:and a file in csv style that I have opened and converted to list:I want to check if the string exist in the first position in every list. But, if I do this:it will give me result 77 88 instead of just 77. I don't know why I can't use if a == row[0] as it will produce no result. Have any idea what to do?EDIT:So actually my code looks like this:and it doesn't work!
Try running this through an interactive visualizer, like this one. When you can't do that for some reason, at least try experimenting in the normal interactive interpreter, or printing out intermediate results in your program.When a is "sky high", and row is ["sky high and high",'88'], that means row[0] is "sky high and high", so a in row[0] is True.That's why (if you fix it to use [1] instead of [2]) it will print both 77 and 88.Try this at the interactive interpreter (or the visualizer):Meanwhile, you say "I don't know why I can't use if a == row[0] as it will produce no result."But if you use a == row[0] it won't produce no result; it will produce 77.Try this at the interactive interpreter (or in the online visualizer):So, you must have a bug in some other part of the code. Show us the version that you claim isn't working, and we can find the bug.Most likely, the problem with your real code is that row (or, actually, d) is not actually ["sky high", '77'], but something with extra characters in it:Let's say text.qrel looked like this:This would make d[0] be "sky high " (with a space), not "sky high".Or:Then d[0] would be '"sky high"' (with extra quotes), not "sky high".You could show us an extract of that CSV file, or have your code print out each row and show us what it prints; otherwise, we're just guessing.You can try to fix things manually. For example, to handle both of the above cases, instead of this:… you'd do:If you don't understand list comprehensions, this line:… is a shortcut for:You already have the [:-1] to remove the trailing \n and the split(',') to split into two columns. But instead of just using the columns as-is, on each one, I call strip() to remove any extra whitespace at the edges (which turns out not to matter in your specific case, but it is a common problem in CSVs), and then call remove_quotes on the result to remove any matched pairs of quotes, and use that for the column value.As you can see, that's tedious and complicated.And there are still plenty of common cases it won't handle.This is exactly why you usually want to use the csv module instead of trying to parse CSV files yourself:Now, d[0] will be "sky high".If your CSV files aren't quite "standard"-enough for CSV to handle out-of-the-box, you can give a dialect object, or just some format parameters, to the reader, and it's still usually easier than trying to build it from scratch yourself.
You are asking it if the string sky high is in the first string in each row, not if the string is in the row. This code should do what you want:This only outputs 77.
For your example, you would need to use row[1]. Then it should work with ==.in checks if a string is in another string, and "sky high and high" contains "sky high", so that's correct.You could also use list comprehension for something as simple as this, if you like one-liners:


Answer URL
