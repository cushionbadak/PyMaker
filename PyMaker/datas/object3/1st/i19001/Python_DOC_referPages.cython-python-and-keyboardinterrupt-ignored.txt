Natural Text
Is there a way to interrupt (Ctrl+C) a Python script based on a loop that is embedded in a Cython extension?I have the following python script:This runs a loop that is part of a C++ Cython extension.Then, while pressing Ctrl+C, the KeyboardInterrupt is thrown but ignored, and the program keeps going until the end of the simulation.The work around I found, is to handle the exception from within the extension by catching the SIGINT signal :Then :Can't I make this work from Python, or at least from Cython instead ? As I am about to port my extension under Windows/MinGW, I would appreciate to have something less Linux specific.
You have to periodically check for pending signals, for example, on every Nth iteration of the simulation loop:PyErr_CheckSignals will run signal handlers installed with signal module (this includes raising KeyboardInterrupt if necessary).PyErr_CheckSignals is pretty fast, it's OK to call it often. Note that it should be called from the main thread, because Python runs signal handlers in the main thread. Calling it from worker threads has no effect.ExplanationSince signals are delivered asynchronously at unpredictable times, it is problematic to run any meaningful code directly from the signal handler. Therefore, Python queues incoming signals. The queue is processed later as part of the interpreter loop.If your code is fully compiled, interpreter loop is never executed and Python has no chance to check and run queued signal handlers.
If you are trying to handle KeyboardInterrupt in code that releases the GIL (for example, because it uses cython.parallel.prange), you will need to re-acquire the GIL to call PyErr_CheckSignals. The following snippet (adapted from @nikita-nemkin's answer above) illustrates what you need to do:
Release GIL when Cython runs parts that do not interface with Python, run loop in the main thread (sleep or check the simulation status), and call sim.Stop() (that can set some flag that your simulation can check periodically) in the except close.
Yes, using the macros sig_on and sig_off from the package cysignals:The macros sig_on and sig_off are declared as functions in cysignals/signals.pxd, and defined as macros in cysignals/macros.h in terms of the macro _sig_on_ (defined in terms of the functions _sig_on_prejmp and _sig_on_postjmp) and the function _sig_off_. The signal handler for keyboard interrupts (SIGINT) is installed here, and the implementation rationale is outlined here.As of cysignals == 1.6.5, only POSIX systems are supported. Cython's conditional compilation can be used in order to follow this approach wherever cysignals is available, and allow compiling on non-POSIX systems too (without Ctrl-C working on those systems).In the script setup.py:and in the relevant *.pyx file:See also this answer.


Answer URL
https://docs.python.org/3/library/signal.html#general-rules
