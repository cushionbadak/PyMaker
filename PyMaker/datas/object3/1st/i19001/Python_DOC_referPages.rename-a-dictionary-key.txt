Natural Text
Is there a way to rename a dictionary key, without reassigning its value to a new name and removing the old name key; and without iterating through dict key/value?In case of OrderedDict, do the same, while keeping that key's position.
For a regular dict, you can use:For an OrderedDict, I think you must build an entirely new one using a comprehension.  Modifying the key itself, as this question seems to be asking, is impractical because dict keys are usually immutable objects such as numbers, strings or tuples.  Instead of trying to modify the key, reassigning the value to a new key and removing the old key is how you can achieve the "rename" in python.  
best method in 1 line:
Using a check for newkey!=oldkey, this way you can do:
You can use this OrderedDict recipe written by Raymond Hettinger and modify it to add a rename method, but this is going to be a O(N) in complexity:Example:output:
A few people before me mentioned the .pop trick to delete and create a key in a one-liner.I personally find the more explicit implementation more readable:The code above returns {'a': 1, 'c': 2}
Other answers are pretty good.But in python3.6, regular dict also has order. So it's hard to keep key's position in normal case.
Even if its a list of dict just convert it to string.NOTE : Make sure you dont have values name same as key name.Might work for someone
I am using @wim 's answer above, with dict.pop() when renaming keys, but I found a gotcha.  Cycling through the dict to change the keys, without separating the list of old keys completely from the dict instance, resulted in cycling new, changed keys into the loop, and missing some existing keys. To start with, I did it this way:I found that cycling through the dict in this way, the dictionary kept finding keys even when it shouldn't, i.e., the new keys, the ones I had changed!  I needed to separate the instances completely from each other to (a) avoid finding my own changed keys in the for loop, and (b) find some keys that were not being found within the loop for some reason.I am doing this now:Converting the my_dict.keys() to a list was necessary to get free of the reference to the changing dict.  Just using my_dict.keys() kept me tied to the original instance, with the strange side effects.


Answer URL
https://docs.python.org/3/whatsnew/3.7.html
