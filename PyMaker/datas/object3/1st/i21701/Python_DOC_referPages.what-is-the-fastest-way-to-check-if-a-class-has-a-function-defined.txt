Natural Text
I'm writing an AI state space search algorithm, and I have a generic class which can be used to quickly implement a search algorithm. A subclass would define the necessary operations, and the algorithm does the rest. Here is where I get stuck: I want to avoid regenerating the parent state over and over again, so I have the following function, which returns the operations that can be legally applied to any state: And the invert_op function throws by default. Is there a faster way to check to see if the function is not defined than catching an exception? I was thinking something on the lines of checking for present in dir, but that doesn't seem right. hasattr is implemented by calling getattr and checking if it raises, which is not what I want. 
Yes, use getattr() to get the attribute, and callable() to verify it is a method:Note that getattr() normally throws exception when the attribute doesn't exist. However, if you specify a default value (None, in this case), it will return that instead.
It works in both Python 2 and Python 3hasattr returns True if connection object has a function invert_opt defined. Here is the documentation for you to grazehttps://docs.python.org/2/library/functions.html#hasattrhttps://docs.python.org/3/library/functions.html#hasattr
Is there a faster way to check to see if the function is not defined than catching an exception?Why are you against that? In most Pythonic cases, it's better to ask forgiveness than permission. ;-)hasattr is implemented by calling getattr and checking if it raises, which is not what I want.Again, why is that? The following is quite Pythonic:Or,Note, however, that getattr(obj, attr, default) is basically implemented by catching an exception, too. There is nothing wrong with that in Python land!
I like Nathan Ostgard's answer and I up-voted it.  But another way you could solve your problem would be to use a memoizing decorator, which would cache the result of the function call.  So you can go ahead and have an expensive function that figures something out, but then when you call it over and over the subsequent calls are fast; the memoized version of the function looks up the arguments in a dict, finds the result in the dict from when the actual function computed the result, and returns the result right away.Here is a recipe for a memoizing decorator called "lru_cache" by Raymond Hettinger.  A version of this is now standard in the functools module in Python 3.2.http://code.activestate.com/recipes/498245-lru-and-lfu-cache-decorators/http://docs.python.org/release/3.2/library/functools.html
The responses herein check if a string is the name of an attribute of the object. An extra step (using callable) is needed to check if the attribute is a method.So it boils down to: what is the fastest way to check if an object obj has an attribute attrib. The answer isThis is so because a dict hashes its keys so checking for the key's existence is fast.See timing comparisons below.
Like anything in Python, if you try hard enough, you can get at the guts and do something really nasty. Now, here's the nasty part:Please do us a favor, just keep doing what you have in your question and DON'T ever use this unless you are on the PyPy team hacking into the Python interpreter. What you have up there is Pythonic, what I have here is pure EVIL.
While checking for attributes in __dict__ property is really fast, you cannot use this for methods, since they do not appear in __dict__ hash. You could however resort to hackish workaround in your class, if performance is that critical:Then check for method as:Time comparision with getattr:Not that I'm encouraging this approach, but it seems to work.[EDIT] Performance boost is even higher when method name is not in given class:


Answer URL
https://docs.python.org/3/library/functions.html#hasattr
