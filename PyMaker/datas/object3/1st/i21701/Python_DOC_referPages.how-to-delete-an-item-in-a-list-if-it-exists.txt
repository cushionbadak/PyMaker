Natural Text
I am getting new_tag from a form text field with self.response.get("new_tag") and selected_tags from checkbox fields with I combine them like this:(f1.striplist is a function that strips white spaces inside the strings in the list.)But in the case that tag_list is empty (no new tags are entered) but there are some selected_tags, new_tag_list contains an empty string " ".For example, from logging.info:How do I get rid of the empty string?If there is an empty string in the list:But if there is no empty string:But this gives:Why does this happen, and how do I work around it?
1) Almost-English style:Test for presence using the in operator, then apply the remove method.The removemethod will remove only the first occurrence of thing, in order to remove all occurrences you can use while instead of if.Simple enough, probably my choice.for small lists (can't resist one-liners)2) Duck-typed, EAFP style:This shoot-first-ask-questions-last attitude is common in Python. Instead of testing in advance if the object is suitable, just carry out the operation and catch relevant Exceptions:Off course the second except clause in the example above is not only of questionable humor but totally unnecessary (the point was to illustrate duck-typing for people not familiar with the concept).If you expect multiple occurrences of thing:a little verbose for this specific use case, but very idiomatic in Python.this performs better than #1PEP 463 proposed a shorter syntax for try/except simple usage that would be handy here, but it was not approved.However, with contextlib's suppress() contextmanager (introduced in python 3.4) the above code can be simplified to this:Again, if you expect multiple occurrences of thing:3) Functional style:Around 1993, Python got lambda, reduce(), filter() and map(), courtesy of a Lisp hacker who missed them and submitted working patches*. You can use filter to remove elements from the list:There is a shortcut that may be useful for your case: if you want to filter out empty items (in fact items where bool(item) == False, like None, zero, empty strings or other empty collections), you can pass None as the first argument:[update]: in Python 2.x, filter(function, iterable) used to be equivalent to [item for item in iterable if function(item)] (or [item for item in iterable if item] if the first argument is None); in Python 3.x, it is now equivalent to (item for item in iterable if function(item)). The subtle difference is that filter used to return a list, now it works like a generator expression - this is OK if you are only iterating over the cleaned list and discarding it, but if you really need a list, you have to enclose the filter() call with the list() constructor.*These Lispy flavored constructs are considered a little alien in Python. Around 2005, Guido was even talking about dropping filter - along with companions map and reduce (they are not gone yet but reduce was moved into the functools module, which is worth a look if you like high order functions).4) Mathematical style:List comprehensions became the preferred style for list manipulation in Python since introduced in version 2.0 by PEP 202. The rationale behind it is that List comprehensions provide a more concise way to create lists in situations where map() and filter() and/or nested loops would currently be used.Generator expressions were introduced in version 2.4 by PEP 289. A generator expression is better for situations where you don't really need (or want) to have a full list created in memory - like when you just want to iterate over the elements one at a time. If you are only iterating over the list, you can think of a generator expression as a lazy evaluated list comprehension:See this Python history blog post by GvR.This syntax is inspired by the set-builder notation in math.Python 3 has also set and dict comprehensions.Notesyou may want to use the inequality operator != instead of is not (the difference is important)for critics of methods implying a list copy: contrary to popular belief, generator expressions are not always more efficient than list comprehensions - please profile before complaining
Note that this will only remove one instance of the empty string from your list (as your code would have, too). Can your list contain more than one?
If index doesn't find the searched string, it throws the ValueError you're seeing. Either catch the ValueError:or use find, which returns -1 in that case.
Eek, don't do anything that complicated : )Just filter() your tags.  bool() returns False for empty strings, so instead ofyou should writeor better yet, put this logic inside striplist() so that it doesn't return empty strings in the first place.
Adding this answer for completeness, though it's only usable under certain conditions.If you have very large lists, removing from the end of the list avoids CPython internals having to memmove, for situations where you can re-order the list. It gives a performance gain to remove from the end of the list, since it won't need to memmove every item after the one your removing - back one step (1).For one-off removals the performance difference may be acceptable, but if you have a large list and need to remove many items - you will likely notice a performance hit.Although admittedly, in these cases, doing a full list search is likely to be a performance bottleneck too, unless items are mostly at the front of the list.This method can be used for more efficient removal,as long as re-ordering the list is acceptable. (2)You may want to avoid raising an error when the item isn't in the list.While I tested this with CPython, its quite likely most/all other Python implementations use an array to store lists internally. So unless they use a sophisticated data structure designed for efficient list re-sizing, they likely have the same performance characteristic.A simple way to test this, compare the speed difference from removing from the front of the list with removing the last element:With:(gives an order of magnitude speed difference where the second example is faster with CPython and PyPy).In this case you might consider using a set, especially if the list isn't meant to store duplicates.In practice though you may need to store mutable data which can't be added to a set. Also check on btree's if the data can be ordered.
Here's another one-liner approach to throw out there:It doesn't create a list copy, doesn't make multiple passes through the list, doesn't require additional exception handling, and returns the matched object or None if there isn't a match. Only issue is that it makes for a long statement.In general, when looking for a one-liner solution that doesn't throw exceptions, next() is the way to go, since it's one of the few Python functions that supports a default argument.
All you have to do is thisbut that method has an issue. You have to put something in the except placeso i found this:


Answer URL
https://docs.python.org/3/library/contextlib.html#contextlib.suppress
