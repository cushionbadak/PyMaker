Natural Text
If I do A.something = 10, this goes into A.__dict__. What is this <attribute '__dict__' of 'A' objects> found in A.__dict__.__dict__, and when does it contain something?
First of all A.__dict__.__dict__ is  different from A.__dict__['__dict__'], and the former doesn't exist. The latter is the __dict__ attribute that the instances of the class would have. It's a descriptor object that returns the internal dictionary of attributes for the specific instance. In short, the __dict__ attribute of an object can't be stored in object's __dict__, so it's accessed through a descriptor defined in the class.To understand this, you'd have to read the documentation of the descriptor protocol.The short version:For an instance of class A, access to instance.__dict__ is provided by A.__dict__['__dict__'] which is the same as vars(A)['__dict__'].For the class A, access to A.__dict__ is provided by type.__dict__['__dict__'] (in theory) which is the same as vars(type)['__dict__'].The long version:Both classes and objects provide access to attributes both through the attribute operator (implemented via the class or metaclass's __getattribute__), and the __dict__ attribute/protocol which is used by vars(ob).For normal objects, the __dict__ object creates a separate dict object, which stores the attributes, and __getattribute__ first tries to access it and get the attributes from there (before attempting to look for the attribute in the class by utilizing the descriptor protocol, and before calling __getattr__). The __dict__ descriptor on the class implements the access to this dictionary.x.name is equivalent to trying those in order: x.__dict__['name'], type(x).name.__get__(x, type(x)), type(x).namex.__dict__ does the same but skips the first one for obvious reasonsAs it's impossible for the __dict__ of instance to be stored in __dict__ of the instance, it is accessed through the descriptor protocol directly instead, and is stored in a special field in the instance.A similar scenario is true for classes, although their __dict__ is a special proxy object that pretends to be a dictionary (but might not be internally), and doesn't allow you to change it or replace it with another one. This proxy allows you, among all else, to access the attributes of a class that are specific to it, and not defined in one of its bases.By default, a vars(cls) of an empty class carries three descriptors - __dict__ for storing the attributes of the instances, __weakref__ which is used internally by weakref, and the docstring of the class. The first two might be gone if you define __slots__. Then you wouldn't have __dict__ and __weakref__ attributes, but instead you'd have a single class attribute for each slot. The attributes of the instance then wouldn't be stored in a dictionary, and access to them will be provided by the respective descriptors in the class.And lastly, the inconsistency that A.__dict__ is different from A.__dict__['__dict__'] is because the attribute __dict__ is, by exception, never looked up in vars(A), so what is true for it isn't true for practically any other attribute you'd use. For example, A.__weakref__ is the same thing as A.__dict__['__weakref__']. If this inconsistency didn't exist, using A.__dict__ would not work, and you'd have to always use vars(A) instead.
Lets do some exploring!I wonder what that is?What attributes does a getset_descriptor object have?By making a copy of that dictproxy we can find some interesting attributes, specifically __objclass__ and __name__.So __objclass__ is a reference to A and __name__ is just the string '__dict__', name of an attribute perhaps?There we have it!  A.__dict__['__dict__'] is an object that can refer back to A.__dict__.
Since A.__dict__ is a dictionary storing A attributes, A.__dict__['__dict__'] is the direct reference to that same A.__dict__ attribute.A.__dict__ contains a (kind-of) reference to itself. The "kind-of" part is why the expression A.__dict__ returns a dictproxy instead of a normal dict.
You can try the following simple example to understand more of this:From the above example, it seems that class objects attributes are stored by their class, class's attributes are stored by their class, which are metaclasses. This is also validated by:


Answer URL
https://docs.python.org/3/howto/descriptor.html#descriptor-protocol
