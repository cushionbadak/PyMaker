Natural Text
So i am a noob in python and i don't usually ask a question unless i have searched exhaustively or tried several workarounds.I'm Creating an 8bit binary adder, by simulating the logic of various circuit gates..... Basically i want to take each element in the two lists and feed them into a function that loops 8 times. (8 bits)Creating two strings. (int can't start with a 0)    Assigning the slices to separate strings. One character each.  Adding those slices to lists and converting them into an int.Main function. Takes two inputs. One from each list... (aToInt and bToInt) (a,b)(a1,b1,a2,b2,a3,b3.....)a and b need to change to a1,b1,a2,b2,a3,b3... ++ each interation of the loop.. Other functions that also take two inputs... Any suggestions and recommendations much appreciated.=============================EDIT==================== SPECIFICSSo i have a list and i want to loop through that list=code goes here for loop that changes a and b according to the list? (a......,b.....)?So i don't know what to call it but i want to be able to maybe map a,b onto a1,b1.... respectively. 
I think your adder is implemented wrong, but you want something like this after you fix it.Call main(a_to_int, b_to_int) and see what it does.Note the following salient points:Use list comprehensions; don't type things out 8 times. Python has native bitwise operations for AND, OR, XOR, and NOT.zip pairs up two iterables, and so the for loop iterates over corresponding bits of a and b. But it does so from left to right, which is probably not what you want.return is not a function; it is conventional not to enclose a returned value in parentheses.a or b is 1 does not mean a is 1 or b is 1, but rather a or (b is 1). Do not test for integer equality using is. Use ==.a{i++} is not valid Python, and does not resemble any valid Python. I would tell you what to replace it with, but I don't even know what you want it to mean.Python has native binary literals, written like so: 0b00001001, which equals 9.In short, what you actually want (a working full-adder) is this:Now, main(example_a, example_b) == '11100101', as you would expect.
I think you are looking for zip() function
If you have two lists of numbers:and a function:you can use zip to iterate over both of them:prints:
I believe you're looking for something like this:where the lowest bits of a and b come first, as your code seemed to assume. The output of the above is 11010011, which is 00001001 + 11011100 (again, lowest bits are first).


Answer URL
https://docs.python.org/3/library/functions.html#zip
