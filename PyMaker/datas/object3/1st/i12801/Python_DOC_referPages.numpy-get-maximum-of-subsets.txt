Natural Text
I have an array of values, said v, (e.g. v=[1,2,3,4,5,6,7,8,9,10]) and an array of indexes, say g (e.g.            g=[0,0,0,0,1,1,1,1,2,2]).I know, for instance, how to take the first element of each group, in a very numpythonic way, doing:returns:Is there any numpythonic way (avoiding explicit loops) to get the maximum of each subset?Tests:Since I received two good answers, one with the python map and one with a numpy routine, and I was searching the most performing, here some timing tests:As a result I get:Interestingly, most of the slowdown of the map method is due to the list() call. If I do not try to reconvert my map result to a list ( but I have to, because python3.x returns an iterator:  https://docs.python.org/3/library/functions.html#map )
You can use np.maximum.reduceat:More about the workings of the ufunc reduceat method can be found here.Remark about performancenp.maximum.reduceat is very fast. Generating the indices idx is what takes most of the time here.While _, idx = np.unique(g, return_index=True) is an elegant way to get the indices, it is not particularly quick.The reason is that np.unique needs to sort the array first, which is O(n log n) in complexity. For large arrays, this is much more expensive than using several O(n) operations to generate idx. Therefore, for large arrays it is much faster to use the following instead:
Here's one convoluted vectorized approach using masking and broadcasting  that puts each group into rows of a regular 2D array and then finds maximum along each row -Sample run -
You can create your mask like following and use map function :If you don't want to get a generator with map you can use a list comprehension to achieve same result in list, and note that the iteration of list comprehension has performed at C language speed inside the interpreter, like built-in functions.But I think the numpythonic solution still is better to use.


Answer URL
https://docs.python.org/3/library/functions.html#map
