Natural Text
I was wondering if there was a relatively simple way to find all subsets of list iteratively. Using recursion, this is easily done and very concise...This will return a list of lists containing all subsets of a list.Is there a way to do something like this iteratively without it being overly complicated, or is recursion the best way? Some pseudo-code or something explaining a way to do this iteratively would be helpful. I know itertools is helpful but I would like a solution without the need for it if possible.
As there are 2**n subsets (n is length of the list). You can create a counter from 0 to 2**(n-1). Then create a list (which is a subset) in each iteration by adding the elements who's corresponding bit is set to 1 in the counter binary form.One could implement this like this,OutputBut as mentioned in comments and other answers it is better not to make the binary string. If you want to check if a certain bit is set, you can shift 1 by desired amount and do a bitwise-and with that number. For example to check if the third bit is set in 423 you can do this:
As @sudomakeinstall2 mentioned, you can use a counter from 0 to 2**(n-1) to iterate over the list, and use it as the mask to pick values from alist.The result may be very very large, you may want to create a generator to evaluate lazily.With list comprehension and generator:You can call it withor
Essentially building the list of subsets is the same as building the list of all combinations of sizes 1 through to length of the input. So one solution involves using itertools:see this in action here: http://ideone.com/geTdUSThe main reason I'd shy away from using recursion too much in a case such as this is because you might end up with a very large number of recursive calls and the maximum recursion depth in Python might not be deep enough. That said I'm not entirely sure how large an input size this itertools solution will work for.


Answer URL
https://docs.python.org/3/library/itertools.html
