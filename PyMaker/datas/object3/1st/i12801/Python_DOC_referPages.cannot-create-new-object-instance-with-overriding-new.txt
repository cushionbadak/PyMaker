Natural Text
I am trying to use Python's __new__ in order to return something different than the actual object instance upon instantiating the class (whether that's clever or not is a different discussion). Below is a minimal example, in which I return a list of two class instances from __new__, instead of the actual class instance.However, it appears that I am not able to create actual object instances with this method, as can be seen in the minimal example. The print statement should print 1, but prints 2, meaning the parameters passed to the second invocation of TestClass overwrite the parameters of the first invocation. My guess is that a and b are references to the same static class TestClass, and my deepcopy isn't helping either, because it makes no sense for a static class.How do I have to tweak __new__ and __init__ of TestClass such that I'm actually creating new instances (i.e. the print statement should print 1, not 2)?(Python 3.5)edit/small clarification: I actually do not want TestClass to be static (if that's the correct lingo anyway), but my non-functional implementation seems to produce something like a static class.SolutionThanks to Kay, the following code works:
You are calling the first parameter to __new__ self, but it is actually the class, commonly referred to as cls. So you are writing to the class, not the instances.To actually get two instances use:You cannot use deepcopy, since it will invoke X.__new__() (without the param parameter), which will cause a loop.
The specific problem that causes param to be shared class-wide is highlighted if you use the right parameters for __new__. As @Kay mentions in his answer, __new__ accepts a class as the first argument, not an instance.That's the error, because then it follows that __init__ gets a class when it expects an instance.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__new__
