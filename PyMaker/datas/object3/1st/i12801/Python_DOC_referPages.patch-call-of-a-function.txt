Natural Text
I need to patch current datetime in tests. I am using this solution:Then in my tests I do something like:But today an idea came to me, that I could make the implementation simpler by patching __call__ of function utcnow instead of having an additional _utcnow.This does not work for me:How to do this elegantly?
When you patch __call__ of a function, you are setting the __call__ attribute of that instance. Python actually calls the __call__ method defined on the class.For example:Assigning anything to a.__call__ is pointless.However:TLDR;a() does not call a.__call__. It calls type(a).__call__(a).LinksThere is a good explanation of why that happens in answer to "Why type(x).__enter__(x) instead of x.__enter__() in Python standard contextlib?".This behaviour is documented in Python documentation on Special method lookup.
[EDIT]Maybe the most interesting part of this question is Why I cannot patch somefunction.__call__? Because the function don't use __call__'s code but __call__ (a method-wrapper object) use function's code.I don't find any well sourced documentation about that, but I can prove it (Python2.7):Replace f's code by g's code:Of course f and f.__call__ references are not changed:Recover original implementation and copy __call__ references instead:This don't have any effect on f function. Note: In Python 3 you should use __code__ instead of func_code.I Hope that somebody can point me to the documentation that explain this behavior. You have a way to work around that: in utils you can defineAnd now your patch can work like a charm.Follow the original answer that I consider even the best way to implement your tests.I've my own gold rule: never patch protected methods. In this case the things are little bit smoother because protected method was introduced just for testing but I cannot see why. The real problem here is that you cannot to patch datetime.datetime.utcnow directly (is C extension as you wrote in the comment above). What you can do is to patch datetime by wrap the standard behavior and override utcnow function:Ok that is not really clear and neat but you can introduce your own function likeand nowdo exactly what you need without any other layer and for every kind of import.Another solution can be import datetime in utils and to patch ***.utils.datetime; that can give you some freedom to change datetime reference implementation without change your tests (in this case take care to change mock_utcnow() wraps argument too).
As commented on the question, since datetime.datetime is written in C, Mock can't replace attributes on the class (see Mocking datetime.today by Ned Batchelder). Instead you can use freezegun.Here's an example:As you mention, an alternative is to track each module importing datetime and patch them. This is in essence what freezegun does. It takes an object mocking datetime, iterates through sys.modules to find where datetime has been imported and replaces every instance. I guess it's arguable whether you can do this elegantly in one function.


Answer URL
https://docs.python.org/3/reference/datamodel.html#special-method-lookup
