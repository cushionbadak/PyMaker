Natural Text
This code returns a list [0,0,0] to [9,9,9], which produces no repeats and each element is in order from smallest to largest.Looking for a shorter and better way to write this code without using multiple variables (position1, position2, position3), instead only using one variable i.Here is my attempt at modifying the code, but I'm stuck at implementing the if statements:
On the same note as the other itertools answer, there is another way with combinations_with_replacement:
Simply use list comprehension, one way to do it:
Here's a simpler way than doing the checks, but which is still IMO worse than combinations_with_replacement:Namely, instead of filtering values after production you just only produce those values you want in the first place.
You can use itertools.product() to eliminate nested loops:Or better with list comprehensions:
I think it is worthwhile to point out that the original code is weird and can be rewritten easily to be simpler:There are better solutions here, but this one is the stepping stone to getting to them.
This code could be done pretty easily with recursion, without using itertools.n - being the length of the tuplem - being the upper bound of each valueThe Code:The result is the output of non_decreasing(3,9)


Answer URL
https://docs.python.org/3/library/itertools.html
https://docs.python.org/3/library/itertools.html#itertools.combinations_with_replacement
