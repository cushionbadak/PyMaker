Natural Text
I am trying to call a method on an other class and give the called class a reference of the current class along with some other parameters. But somehow it takes the self given as a parameter as the self of the called class.Let me show you:So I call the class logger and the method writeLog on it. Giving the Parameters message and a reference of the class thermo (self).As you can see I put the parameters self because its a method that belongs to a class, the sender should be the reference to the class thermo that was passed as self in the thermo class. Lastly there is the message wich was passed in the thermo class aswell.But this just gives me the error:So it seems that the self parameter wich was passed in the thermo class is interpetet as the self of the class logger wich gets it all mixed up.Can you guys help me here?Thank you all in advanceThe full code + additonal comments can be viewed HereEdit:Both the logger and the thermo class get initilized in the file wsPart.py:
yes, bad idea to call the instance and the class name the same. Here:You're passing the class itself to your constructors. So the methods are seen as static/expect one more parameter. You need to change the 2 last lines to pass the instance you just created:more importantly, you need to use different names for classes and instances of the same objects to avoid that confusion (python convention for class names is starting each word with upper case (camelcase) ex: Logger. Other languages don't use that convention, but python is a lot about conventions).With a different name you'd have gotten a NameError exception and you would have fixed the error yourself.Aside: don't "initialize" members like this in the class definition:those are creating class members, not instance members. Remove those, and let __init__ create instance members like you're currently doing. __init__ is called no matter what, and those lines above just add to the confusion (except for some corner cases, only constants should be declared that way)
Totally unrelated but code in comments is unreadable so I post this as an answer:this does not work as you seem to expect:class Whatever():    functional = False ## see line 8Python has no "implied this" sor here in __init__ you're not creating an instance attribute but a local variable. You want self.functional = TrueMake sure you close filesdef read(self):    fileobject = open(self.file)    filecontent = fileobject.read()    fileobject.close()If anything wrong happens between open() and fileobject.close(), the file is not garanteed to be properly closed. You want eiher a try/finally block ieor much better a with block:which will ensure the file is closed whatever happens.write mode truncates the filedef writeLog(self, sender, message):    conn = open(self.logfile, "w")    now = str(datetime.datetime.now().isoformat())    conn.write("[" + now + "]" + " (" + sender.getName() + "): " + message + "\n") ##Problem on this line    conn.close()as documented, opening a file in write mode truncates the file. You probably want the "append" mode instead here.Don't reinvent the squared wheel when there's a round one alreadyLogging is not as trivial as just writing to a file (concurrency issues, need to send the log message to some other destination, logging levels etc), and even if you don't need more (at least the moment) your solution is quite inefficient (opening a file is expensive). Python has a very comprehensive logging package in it's standard lib. I wholefully agree that it requires a bit of learning to configure and use properly but that's still a huge win compared to the time you'll spend trying to make a naive half-backed custom implementation works properly on production, AND this is a knowledge that you will need for just any serious project anyway.


Answer URL
https://docs.python.org/3/library/functions.html#open
