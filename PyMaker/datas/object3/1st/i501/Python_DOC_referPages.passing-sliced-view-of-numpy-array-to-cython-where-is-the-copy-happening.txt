Natural Text
In the following code I am slicing an array X, thereby creating a view on X, named X_cut. Then I use a cython memory view on the slice and pass it as 1d array to a c function that accesses the memory linearly.Can I be sure that the pointer passed to the C code is actually referring to a 6x6 linearised matrix?If so where is the copy operation happening? Is it in X_cut.ravel()?/some/path/to/get_5_5.c
Cython's typed memory views use Buffer-Protocol to get access to the data, that means they have nothing to do with copying of the data. Theoretically, an exporter could decide to copy the data when exposing it via Buffer-Protocol. However, usually Buffer-Protocol is used in order to avoid memory-copying, so copying is not the normal case. That means, you cannot be 100% sure, that no copying is happening when binding a typed memory view to an object exporting the buffer - you have to know the implementation of the exporter, but the cases of copying are really rare. And this is not what happening here.The copying must happen, when X_cut.ravel() is called - the resulting memory must be contiguous, but the underlying memory in X_cut isn't (see X_cut.flags), because it still shares memory with X and cutting off the last elements per row results in "holes" in memory.Here are the memory layouts (for simplicity M=2, N=3, N_cut=2):Where does it leave you? You either have to accept the copying of the memory or extend the interface of get5_5, so you can also pass non-contiguous memory layouts - not unsimilar to the Buffer-Protocol. For example to pass X_cut without copying you will need to specify not (only) the shape, but also the strides along the dimensions, i.e.The question is, how to get the pointer long* arr from X_cut without copying. One possibility is to use 2D-memory view I would choose this option):another would be to use np.reshape(-1), which creates a new 1-dimensional-view and doesn't always copy the data (unlike np.ravel()):


Answer URL
https://docs.python.org/3/c-api/buffer.html
