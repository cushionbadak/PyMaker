Natural Text
I've got a Django REST Framework serializer containing the following:This is problematic because if the datetime formatting ever changes it will be different to all the other datetimes. I want to reuse the code path which DRF uses to serialize other datetime fields.What I've tried so far:The only answer which looked relevant doesn't actually produce the same result as DRF (it includes milliseconds, which DRF does not), presumably because it's using the Django rather than DRF serializer.rest_framework.serializers.DateTimeField().to_representation(log_entry.timestamp), rest_framework.fields.DateTimeField().to_representation(log_entry.timestamp) and rest_framework.fields.DateTimeField(format=api_settings.DATETIME_FORMAT).to_representation(log_entry.timestamp) don't work either; they produce strings with microsecond accuracy. I've verified with a debugger that DRF calls the latter when serializing other fields, so I can't understand why it produces a different result in my case.LogEntry.timestamp is declared as a django.db.DateTimeField, but if I try something like LogEntry.timestamp.to_representation(log_entry.timestamp) it fails badly:AttributeError: 'DeferredAttribute' object has no attribute 'to_representation'
Taking a look through the source of DRF, the interesting stuff is happening in rest_framework/fields.py.In particular, all of the formatting stuff is happening directly in the DateTimeField.to_representation method.You have a couple of ways of replicating DRF's behaviour.First, you could just not pass a format at all. DRF should use its default if you don't explicitly supply a format.Alternatively, keep doing what you're doing, but explicitly pass the format string from DRF's api_settings.DATETIME_FORMAT. This might feel less magical, but honestly it's probably more brittle to API changes in the future.This might look like:However, given that you attempted the first and it failed, we need to look a bit deeper!The default DateFormat for DRF is ISO_8601, which has the following code in it:That is, it effectively just leans on the python isoformat function.isoformat will format differently if the value has microseconds or not.From the Python docs, isoformat will:Return a string representing the date and time in ISO 8601 format, YYYY-MM-DDTHH:MM:SS.ffffff or, if microsecond is 0, YYYY-MM-DDTHH:MM:SSIn this case, the solution is to explicitly set the microseconds to zero in the timestamp. There are a couple of ways to do this, but we can switch to a Unix timestamp, clip to seconds, and back againor keep using the DateTime object directly, which will have better timezone handling:


Answer URL
https://docs.python.org/3/library/datetime.html#datetime.datetime.isoformat
