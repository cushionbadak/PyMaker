Natural Text
I have following class with a function: Here, the function does not have self as argument. It also does not have @classmethod or @staticmethod as decorator. However, it works if called with class: Output: But give an error if called from any instance: Error output: probably because self was also sent as an argument.What kind of function will this be called? Will it be a static function? Is it advisable to use function like this in classes? What is the drawback?Edit: This function works only when called with class and not with object/instance. My main question is what is such a function called?Edit2: It seems from the answers that this type of function, despite being the simplest form, is not accepted as legal. However, as no serious drawback is mentioned in any of many answers, I find this can be a useful construct, especially to group my own static functions in a class that I can call as needed. I would not need to create any instance of this class. In the least, it saves me from typing @staticmethod every time and makes code look less complex. It also gets derived neatly for someone to extend my class. Although all such functions can be kept at top/global level, keeping them in class is more modular. However, I feel there should be a specific name for such a simple construct which works in this specific way and it should be recognized as legal. It may also help beginners understand why self argument is needed for usual functions in a Python class. This will only add to the simplicity of this great language.
This is not a true method. Correctly declarated instance methods should have a self argument (the name is only a convention and can be changed if you want hard to read code), and classmethods and staticmethods should be introduced by their respective decorator.But at a lower level, def in a class declaration just creates a function and assigns it to a class member. That is exactly what happens here: A.my_fn is a function and can successfully be called as A.my_fn().But as it was not declared with @staticmethod, it is not a true static method and it cannot be applied on a A instance. Python sees a member of that name that happens to be a function which is neither a static nor a class method, so it prepends the current instance to the list of arguments and tries to execute it.To answer your exact question, this is not a method but just a function that happens to be assigned to a class member.
The function type implements the descriptor protocol, which means when you access myfn via the class or an instance of the class, you don't get the actual function back; you get instead the result of that function's __get__ method. That is,Here, myfn is an instance method, though one that hasn't been defined properly to be used as such. When accessed via the class, though, the return value of __get__ is simply the function object itself, and the function can be called the same as a static method.Access via an instance results in a different call to __get__. If a is an instance of A, thenHere , __get__ tries to return, essentially, a partial application of myfn to a, but because myfn doesn't take any arguments, that fails.You might ask, what is a static method? staticmethod is a type that wraps a function and defines its own __get__ method. That method returns the underlying function whether or not the attribute is accessed via the class or an instance. Otherwise, there is very little difference between a static method and an ordinary function.
Such a function isn't the same as what @staticmethod provides, but is indeed a static method of sorts.With @staticmethod you can also call the static method on an instance of the class. If A is a class and A.a is a static method, you'll be able to do both A.a() and A().a(). Without this decorator, only the first example will work, because for the second one, as you correctly noticed, "self [will] also [be] sent as an argument":Running this:On the other hand:Now, the second version doesn't work:
further to @chepnet's answer, if you define a class whose objects implement the descriptor protocol like:you can embed an instance of this in a class and invoke various operations on it:which outputs:as functions also implement the descriptor protocol, we can replay this by doing:which outputs:hopefully that complements chepnet's answer which I found a little terse/opaque


Answer URL
https://docs.python.org/3/howto/descriptor.html
