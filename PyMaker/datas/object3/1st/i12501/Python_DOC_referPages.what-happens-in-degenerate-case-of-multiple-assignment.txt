Natural Text
I'm teaching myself algorithms. I needed to swap two items in a list. Python makes all things easy:This works a treat:Note the function is resilient to the degenerate case i = j. As you'd expect, it simply leaves the list unchanged:Later I wanted to permute three items in a list. I wrote a function to permute them in a 3-cycle:This worked well:However I (eventually) discovered it goes wrong in degenerate cases. I assumed a degenerate 3-cycle would be a swap. So it is when i = j, cycle(i, i, k) ≡ swap(i, k):But when i = k something else happens:What's going on? sum should be invariant under any permutation! Why does this case i = k degenerate differently?How can I achieve what I want? That is a 3-cycle function that degenerates to a swap if only 2 indices are distinct cycle(i, i, j) ≡ cycle(i, j, i) ≡ cycle(i, j, j) ≡ swap(i, j)
cycle is doing exactly what you ask it to: assigning to the left hand values the right hand values.is functionally equivalent to So when you do cycle(A, 1, 0, 1) what you are saying is that you wantIf you want cycle to work sequentially then you must write it sequentially, otherwise python evaluates the right hand and then expands that to the arguments on the left hand.
Well it seems you are re-assigning to the same target A[1], to get a visualization of the call:Remember, from the documentation on assignment statements:An assignment statement evaluates the expression list (remember that this can be a single expression or a comma-separated list, the latter yielding a tuple) and assigns the single resulting object to each of the target lists, from left to right.So your evaluation goes something like dis: Create tuple with values A[0], A[1], A[1] translating to (0, 1, 1)Assign these to the target list A[1], A[0], A[1] from left to right.Assignment from left to right takes place:A[1] = 0 A[0] = 1A[1] = 1 So the first assignment made is A[1] with the first element of the tuple 0, then the second assignment A[0] with the second element 1  and, finally, at the end, A[1] is overriden with the third element in the tuple 1. You can get a more convoluted view of this with dis.dis; notice how all elements in the right hand of the assignment statement are loaded first and then they are assigned to their values:
Because cycle(A, 1, 0, 1) becomes A[1], A[0], A[1] = A[0], A[1], A[1], resulting in both A[0] and A[1] ending up with the old value of A[1]. cycle(0, 0, 1) works because it becomes A[0], A[0], A[1] = A[0], A[1], A[0], which is equivalent to swap(A, k, j).


Answer URL
https://docs.python.org/3/library/dis.html#dis.dis
https://docs.python.org/3/library/itertools.html#itertools.permutations
