Natural Text
I'm trying to design a system to react to different binary flags.The sequence of this data represents a unique ID to reference the work, the flag and the number. Everything works, except the number flag. This is what I get...A long should be plenty big to represent the number 12345678, but why is it incorrectly unpacked?Edit:When I try to pack them separately, it looks like struct is adding too many null bytes between the flag and the long.I can reproduce this error by adding padding before the long.Potential fix?When I use little-endian order, the problem seems to correct itself and make the binary string shorter. Since this is destined for a SSL wrapped TCP socket, that's a win win, right? Keeping bandwidth low is generally good, yes?Why does this happen? I am perplexed.
You are running into byte alignment issues. You need to know that by default the individual parts of a struct are not just placed next to each other but they are properly aligned in memory. This makes it more efficient, especially for other applications, as they have more direct way to access individual bytes from it without having to account for overlap.You can easily see this by using struct.calcsize to see the required space needed to encode using a format:As you can see QHL requires 16 bytes, but QH requires 10. The L we left off is however only 4 bytes wide. So there is some padding going to on make sure that the L starts again on “a fresh block”. This is because any type requires (with padding) that it starts on a offset that is a multiple of its own size. For QH it looks like this:Once you use QHL, you get the following:As you can see, there were two padding bytes added to make sure that L starts on a new block of four.You can modify the alignment (as well as the endianness) using a special character at the beginning of the format string. In your case, you could use =QHL to disable alignment altogether:When I use little-endian order, the problem seems to correct itself and make the binary string shorter. Since this is destined for a SSL wrapped TCP socket, that's a win win, right? Keeping bandwidth low is generally good, yes?Using an explicit byte order also disables alignment yes, so that’s where the effect comes from. If it’s a good idea to turn of alignment depends though. If you want to use consume your data somewhere else, in other programs, it would be a good idea to stick to native alignment.
The correct output in your case:This happens because:Padding is only automatically added between successive structure members.Also, the reason your fix works is:No padding is added when using non-native size and alignment, e.g. with ‘<’, ‘>’, ‘=’, and ‘!’.
It is a byte alignment issue. In your case the following replacement will give you the correct output.


Answer URL
https://docs.python.org/3/library/struct.html#struct.calcsize
https://docs.python.org/3/library/struct.html#byte-order-size-and-alignment
