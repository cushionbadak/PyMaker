Natural Text
When a unittest.mock.Mock object has been called, I can check for the argument values with the exact signature of the call:Checking for a different signature with the same values will fail. E.g., if we check with 'baz' as a positional argument instead of a named argument, the assertion will fail:It has to. If the function replaced by m wasthen the calls would be equivalent, but if it wasthen the calls would not be equivalent. Mock doesn't know the actual function's signature, so it can't rely on the equivalence we would have in the first case.Is there a way of checking the call argument values that is agnostic about whether they were passed positionally or as keyword arguments, by letting the Mock (or an assertion helper function or similar) know about the actual function replaced by the mock?The Mock object can be made aware of the object it replaces (which can be a function or method) with the optional spec argument or with autospeccing, but those serve a different purpose (limiting what calls to allow on the mock) and don't affect after-the-fact checking.
The Mock object can be made aware of the object it replaces (which can be a function or method) with the optional spec argument or with autospeccing, but those serve a different purpose.. This is exactly what Issue 17015: mock could be smarter and inspect the spec's signature improvement issue was about. The spec actually is very much related and now makes the mock function-signature-aware.See how mock fails when we assert mock was called with a keyword argument  - without letting it know about the actual function signature:And now, see how it all passes if we provide a spec:(Used Python 3.5.1)


Answer URL
https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock
https://docs.python.org/3/library/unittest.mock.html#auto-speccing
