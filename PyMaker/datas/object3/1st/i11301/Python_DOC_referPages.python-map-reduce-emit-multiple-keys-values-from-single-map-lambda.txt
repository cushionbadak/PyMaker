Natural Text
Is there a canonical way to emit multiple keys from a single item in the input sequence so that they form a continuous sequence and I don't need to use a reduce(...) just to flatten the sequence?e.g. if I wanted to expand each digit in a series of numbers into individual numbers in a sequencethen I'd write some python that looked a bit like this:but would prefer not to have to call the flattened = reduce(...) if there was a neater (or maybe more efficient) way to express this.
map(func, *iterables) will always call func as many times as the length of the shortest iterable (assuming no Exception is raised). Functions always return a single object.  So list(map(func, *iterables)) will always have the same length as the shortest iterable. Thus list(map(lambda x:[int(c) for c in str(x)], somedata)) will always have the same length as somedata. There is no way around that. If the desired result (e.g. [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5]) has more items than the input (e.g. [1,12,123,1234,12345]) then something other than map must be used to produce it.You could, for example, use itertools.chain.from_iterable to flatten 2 levels of nesting:or, to flatten a list of lists, sum(..., []) suffices:but note that this is much slower than using IT.chain.from_iterable (see below).Here is a benchmark (using IPython's %timeit) testing the various methods on a list of 10,000 integers from 0 to a million:
Got two ideas, one with list comprehentions:Something new (from comments), string is already iterable, so it would be:second with opertations on strings and list comprehentions:output for both:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable
