Natural Text
Can someone give me an example of why the "send" function associated with Python generator function exists? I fully understand the yield function. However, the send function is confusing to me. The documentation on this method is convoluted: Resumes the execution and “sends” a value into the generator function. The value argument becomes    the result of the current yield expression. The send() method returns the next value yielded by the generator, or raises StopIteration if the generator exits without yielding another value.What does that mean? I thought value was the input to the function? The phrase "The send() method returns the next value yielded by the generator" seems to be also the exact purpose of the yield function; yield returns the next value yielded by the generator...Can someone give me an example of a generator utilizing send that accomplishes something yield cannot? 
It's used to send values into a generator that just yielded. Here is an artificial (non-useful) explanatory example:You can't do this just with yield.As to why it's useful, one of the best use cases I've seen is Twisted's @defer.inlineCallbacks. Essentially it allows you to write a function like this:What happens is that takesTwoSeconds() returns a Deferred, which is a value promising a value will be computed later. Twisted can run the computation in another thread. When the computation is done, it passes it into the deferred, and the value then gets sent back to the doStuff() function. Thus the doStuff() can end up looking more or less like a normal procedural function, except it can be doing all sorts of computations & callbacks etc. The alternative before this functionality would be to do something like:It's a lot more convoluted and unwieldy.
This function is to write coroutinesprintsSee how the control is being passed back and forth? Those are coroutines. They can be used for all kinds of cool things like asynch IO and similar.Think of it like this, with a generator and no send, it's a one way streetBut with send, it becomes a two way streetWhich opens up the door to the user customizing the generators behavior on the fly and the generator responding to the user.
This may help someone. Here is a generator that is unaffected by send function. It takes in the number parameter on instantiation and is unaffected by send:Now here is how you would do the same type of function using send, so on each iteration you can change the value of number:Here is what that looks like, as you can see sending a new value for number changes the outcome:You can also put this in a for loop as such:For more help check out this great tutorial.
The send method implements coroutines.If you haven't encountered Coroutines they are tricky to wrap your head around because they change the way a program flows. You can read a good tutorial for more details.
Some use cases for using generator and send()Generators with send() allow:remembering internal state of the executionwhat step we are atwhat is current status of our datareturning sequence of valuesreceiving sequence of inputsHere are some use cases:Watched attempt to follow a recipeLet us have a recipe, which expects predefined set of inputs in some order.We may:create a watched_attempt instance from the recipelet it get some inputswith each input return information about what is currently in the potwith each input check, that the input is the expected one (and fail if it is not)To use it, first create the watched_attempt instance:The call to .next() is necessary to start execution of the generator.Returned value shows, our pot is currently empty.Now do few actions following what the recipe expects:As we see, the pot is finally empty.In case, one would not follow the recipe, it would fail (what could be desired outcome of watchedattempt to cook something - just learning we did not pay enough attention when given instructions.Notice, that:there is linear sequence of expected stepsthe steps may differ (some are removing, some are adding to the pot)we manage to do all that by a functions/generator - no need to use complex class or similarstrutures.Running totalsWe may use the generator to keep track of running total of values sent to it.Any time we add a number, count of inputs and total sum is returned (valid forthe moment previous input was send into it).The output would look like:
The send() method controls what the value to the left of the yield expression will be.To understand how yield differs and what value it holds, lets first quickly refresh on the order python code is evaluated.Section 6.15 Evaluation orderPython evaluates expressions from left to right. Notice that while evaluating an assignment, the right-hand side is evaluated before the left-hand side.So an expression a = b the right hand side is evaluated first.As the following demonstrates that a[p('left')] = p('right') the right hand side is evaluated first.What does yield do?, yield, suspends execution of the function and returns to the caller, and resumes execution at the same place it left off prior to suspending.Where exactly is execution suspended? You might have guessed it already...the execution is suspended between the right and left side of the yield expression. So new_val = yield old_val the execution is halted at the = sign, and the value on the right (which is before suspending, and is also the value returned to the caller) may be something different then the value on the left (which is the value being assigned after resuming execution). yield yields 2 values, one to the right and another to the left.How do you control the value to the left hand side of the yield expression? via the .send() method.6.2.9. Yield expressionsThe value of the yield expression after resuming depends on the method which resumed the execution. If __next__() is used (typically via either a for or the next() builtin) then the result is None. Otherwise, if send() is used, then the result will be the value passed in to that method.
These confused me too.  Here is an example I made when trying to set up a generator which yields and accepts signals in alternating order (yield, accept, yield, accept)...The output is:


Answer URL
https://docs.python.org/3/reference/expressions.html#evaluation-order
https://docs.python.org/3/reference/expressions.html#yield-expressions
