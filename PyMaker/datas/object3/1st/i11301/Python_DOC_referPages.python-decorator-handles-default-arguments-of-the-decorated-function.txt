Natural Text
I want to create a 'cache' decorator for class methods, which registers in an internal class property the result of the method for avoiding to compute it several times (and I do not want to use a simple property, computed in the __init__, because I am not sure to compute it even once all the time).The first idea is to create a decorator 'cache' similar to this:Everything works fine:Now let us say that I want to do the same thing, but when the method can be called with arguments (keyworded and/or not).Of course, now we will store the results not in distinct properties (what would be the names?...), but in a dictionary, whose keys are composed with *args and **kwargs. Let us do it with tuples:Thanks to the fact that the method items turns a dictionary in a tuple without taking account on the order in the dictionary, it works perfectly if the keyworded arguments are not called in the same orders:Here is my problem: if the method has default arguments, then it doesn't work anymore:Now it does not work anymore:The result is computed 3 times, because the arguments are not given the same way (even if they are the "same" argument!).Does someone know how I could catch the "default" values given to the function, inside the decorator?Thank you
There can be various solutions depending on how complicated will be arguments' structure of function. The solution I prefer is to add inner function into hello. If you don't want to change the name of your cache, give it the same name your outer function have:Another approach is to add check for default variables in decorator, for example:If you'd have, e.g. 2 default variables, first code (with inner function) still would work, whereas the second one would need changes in "default variable check rules".
If you're using a sufficiently recent version of Python, you can use inspect.signature to get a Signature object that fully encapsulates the information about the function's arguments. Then you can call its bind method with the arguments your wrapper gets passed, to get a BoundArguments object. Call the apply_defaults method on the BoundArguments to fill in any missing arguments that have default values, and examine the arguments ordered dictionary to see an unambiguous listing of the parameters to the function and their values for this call:Note that I renamed your a and o variables to have more meaningful names. I also changed around the way the cache dictionary is set up on the object. Fewer getattr and setattr calls this way!The inspect.signature function and associated types were added in Python 3.3, but the apply_defaults method on BoundArguments objects is new in Python 3.5. There's a backport of the basic functionality for older Python versions on PyPi, but it doesn't include apply_defaults yet, it seems. I'm going to report that as an issue on the backport's github tracker.


Answer URL
https://docs.python.org/3/library/inspect.html#introspecting-callables-with-the-signature-object
https://docs.python.org/3/library/functools.html#functools.lru_cache
