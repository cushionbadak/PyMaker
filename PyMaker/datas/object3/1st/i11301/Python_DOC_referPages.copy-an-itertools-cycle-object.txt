Natural Text
I want to make a shallow copy of an itertools.cycle object, but I don't know how because it has no builtin copy method. I want to achieve something like the following, where I create a copy of the cycle, iterate through it a few times, then copy the original again, and iterate a few more times starting from the beginning of the cycle.
It may require some refactoring, but a factory would work well here.Otherwise, I'm not sure you're going to be able to satisfy the criteria of starting at the beginning of the cycle each time. The class-based approached will also work, but requires a lot more overhead. One of the issues with the itertools.tee approach is that it will resume iteration where the tee-d iterator left off instead of starting from the beginning. Thus, you have to tee it at the beginning. This may be the only option if you do not have control over how the cycle is generated.
Copying the cycle itself is going to run into problems. For example, copy.copying it doesn't produce independent copies.Instead of trying to copy the cycle, I recommend recreating it from your original object:If the object you made your original cycle from is an iterator, you can't just call cycle on it repeatedly. Instead, make a list before you call cycle the first time, and keep the list:If the object you made your original cycle from is an iterator that might or might not be infinite, you can't safely call list on it. Instead, you can tee it before creating the cycle and copy.copy the unadvanced tee when you need to make a new cycle. (tee supports copying.)All this assumes you control the creation of the cycle. If you're receiving a cycle from elsewhere, you might not have access to the object it cycles over. In that case, your best option is to tee the cycle itself. This could be expensive if you need to go through many loops of the cycle:
You could create a custom class to do what you want:Outputs:
copy should do the trick:    
Method 1: making two itertools.cycle objects[Preferred Solution] Method 2: split into n iterators by using itertools.teeWarning using copy module using the copy.copy function will not create a copy of the iterator as expected. Workaround using copy module: a possible solution for this can be to use copy.deepcopy function.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.tee
