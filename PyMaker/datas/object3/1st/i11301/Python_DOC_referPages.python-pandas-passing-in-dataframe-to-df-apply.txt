Natural Text
Long time user of this site but first time asking a question!  Thanks to all of the benevolent users who have been answering questions for ages :)I have been using df.apply lately and ideally want to pass a dataframe into the args parameter to look something like so:  df.apply(testFunc, args=(dfOther), axis = 1)My ultimate goal is to iterate over the dataframe I am passing in the args parameter and check logic against each row of the original dataframe, say  df , and return some value from  dfOther .  So say I have a function like this:My current understanding is that args expects a Series object, and so if I actually run this we get the following error:However before I wrote testFunc which only passes in a single dataframe, I had actually written priorTestFunc, which looks like this...  And it works!So to my dismay I have been coming into the habit of writing testFunc like so and it has been working as intended:I would really appreciate if someone could let me know why this would be the case and maybe errors that I will be prone to, or maybe another alternative for solving this kind of problem!!EDIT:  As requested by the comment: My dfs generally look like the below.. They will have two matching columns and will be returning a value from the dfOther.at[index, column] I have considered pd.concat([dfOther, df]) however I will be running an algorithm testing conditions on df and then updating it accordingly from specific values on dfOther(which will also be updating) and I would like  df to be relatively neat, as opposed to making a multindex and throwing just about everything in it.  Also I am aware df.iterrows is in general slow, but these dataframes will be about 500 rows at the max, so scalability isn't really a massive concern for me at the moment.
The error is in this line:Here, if kwds or args is checking whether the length of args passed to apply is greater than 0. It is a common way to check if an iterable is empty:l is empty!l is not empty!If you had passed a tuple to df.apply as args, it would return True and there wouldn't be a problem. However, Python does not interpret (df) as a tuple:It is just a DataFrame/variable inside parentheses. When you type if df:You get the same error message. However, if you use a comma to indicate that it'a tuple, it works fine:As a result, adding a comma to args=(dfOther) by making it a singleton  should solve the problem.


Answer URL
https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences
