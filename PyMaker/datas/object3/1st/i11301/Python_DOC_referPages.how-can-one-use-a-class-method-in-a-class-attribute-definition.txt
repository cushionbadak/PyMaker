Natural Text
All is in the title. I'd like to create a class method and a class attribute, both constructed only once, when the class is created, using the first in the second's definition.With my best try, I just get a TypeError: 'classmethod' object is not callable.Here is my code :EDIT 1 :'classmethod' object is not callable is a problem raising the same error, but with a lot of workarounds. My question is meant to go straight to the point and have a clear idea of how to use @classmethod without a scope giving access to cls.Another try that I made was the following :
@classmethods are implemented as a special object that gets processed using the descriptor protocol when looked up on the class; inside the definition, as a raw name (unqualified), it's a special classmethod object, not a normal function and it's not bound to the class properly. If you check the pure Python definition of classmethod, you'll note it's just a normal object that implements __init__ (for construction) and __get__ (for descriptor lookup), but not __call__, meaning that if you have the raw classmethod object, it's not actually a callable at all.The trick is to qualify the reference so the "magic" happens to bind it to the class, and move the qualified reference outside the class definition (so Foo is a defined name and can be referenced for binding) changing:to:Note that since you're using a classmethod, I suspect you may eventually be interested in subclassing and overriding bar. As written, you'd need to explicitly redefine bar_vect after defining each subclass, or it would use the inherited bar_vect, based on Foo.bar, even if the subclass defines its own bar classmethod. Explicitly redefining bar_vect each time is an option, but the other approach is to use metaclasses to implicitly define bar_vect when a class redefines bar:No need to define bar_vect explicitly at all, and bar_vect seamlessly uses the most local classes' definition of bar available at class definition time, so unless bar is redefined after class definition, it always works, and it works as efficiently as possible. To make it use bar live, you'd need to resort to more extreme measures that perform dynamic lookup and (barring a cache) reconstruction of the np.vectorize object on each use, which is suboptimal to say the least.For completeness, a dynamic caching based solution (hat tip to Tadhg McDonald-Jensen's answer) that uses a dynamically populating cache that adds minimal overhead (and more importantly in my opinion, abstracts out the boilerplate code that's irrelevant to the work) for the case where the cache entry already exists by using a dict subclass defining __missing__:Subclasses don't need to (and should not) override bar_vect (and can't accidentally access __bar_vect_registry because it's name mangled such that only methods defined by Foo will see it; change name to _bar_vect_registry, one underscore, if it should be accessible to subclasses), they just override bar and Foo's bar_vect will create/cache vectorized accessors when bar_vect is first accessed on the subclass (or an instance thereof).
Your confusion to why this is not an easy work around is understandable, let me elaborate on to why using classmethod in this way isn't going to work...The way classmethod works is that it creates a descriptor, an object that implements __get__ when it is retrieved as an attribute on an object.So when you do Foo.bar it basically loads the bar classmethod and calls:Where the None represents the instance (there is None because it is on the class itself) and the second argument represents the class, a classmethod is not callable because then it would not have a class to bind it too!Not only this but the class object to bind it too doesn't exist until the class definition block has ended (and the metaclass type actually puts it together) so the bare minimum is to create bar_vect after the class is actually defined:This will work sure, but then you break the functionality of subclasses, what if you wanted to change a?The only way to make it work in this case is to recreate the np.vectorize at least one for each subclass, the simplest version is to just do it every time you call bar_vect:This is obviously undesirable because it calls np.vectorize every time x.bar_vect is used, however you could make a record of all the classes and only make it when a new class is used:
You real problem is that you try to use bar before the class if fully constructed, so you do not get the expected object.Here is a simplified example:gives:That shows that until the class is fully constructed, the methods identifier are only bound to the method definitions and not to the real methods.If you want achieve what you want, you must define the class variable outside of class definition (after last line), as explained by @ShadowRanger


Answer URL
https://docs.python.org/3/howto/descriptor.html
https://docs.python.org/3/howto/descriptor.html#static-methods-and-class-methods
https://docs.python.org/3/library/functions.html?highlight=callable#callable
