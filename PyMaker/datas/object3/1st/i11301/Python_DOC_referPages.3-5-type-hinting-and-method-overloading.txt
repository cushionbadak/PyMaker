Natural Text
Edit: I misunderstood the feature currently. It's not designed for multiple dispatch:NOTE: While it would be possible to provide a multiple dispatch implementation using this syntax, its implementation would require using sys._getframe() , which is frowned upon. Also, designing and implementing an efficient multiple dispatch mechanism is hard, which is why previous attempts were abandoned in favor of functools.singledispatch() . (See PEP 443 , especially its section "Alternative approaches".) In the future we may come up with a satisfactory multiple dispatch design, but we don't want such a design to be constrained by the overloading syntax defined for type hints in stub files. It is also possible that both features will develop independent from each other (since overloading in the type checker has different use cases and requirements than multiple dispatch at runtime -- e.g. the latter is unlikely to support generic types).====I've been off in Java-land for a while, and I'm returning to Python 3.5. I want to use the new type hinting feature, but I'm having trouble with method overloading. From my reading of the feature, this should be supported. Here's a quick little class that I'm working on:licensing.pyi (note the pyi)licensing.pyThis is a toy example, but the idea is rather conventional. I provide two constructors one that takes an already existing gitlab client and another that will instantiate it. (There's no need for dual constructors for this script, but I saw @typing.overload and wanted to see how it works.)Pycharm and Cpython seem to be happy with this code, but the first constructor is inaccessible -- like @typing.overload decorator isn't working:Is there something special I have to do to get the overloading working? Presently, I'm just invoking either the built-in REPL or ipython. 
Untyped Python does not support overloading. Your second __init__ is overwriting the first one, thus the error. You need to write a single __init__ with runtime type-checking:(there is functools.singledispatch which can simulate overloading with only one argument changing type but it is not suitable for your case)The @typing.overload decorator just tells the type checker there can be multiple combinations of arguments, it does not mean you could write the implementation in two different functions with the same name now. From PEP 484:Uses of the @overload decorator as shown above are suitable for stub files. In regular modules, a series of @overload-decorated definitions must be followed by exactly one non-@overload-decorated definition (for the same function/method). The @overload-decorated definitions are for the benefit of the type checker only, since they will be overwritten by the non-@overload-decorated definition, while the latter is used at runtime but should be ignored by a type checker.


Answer URL
https://docs.python.org/3/library/functools.html#functools.singledispatch
