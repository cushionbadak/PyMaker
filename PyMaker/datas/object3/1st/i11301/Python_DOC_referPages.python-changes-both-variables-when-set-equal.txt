Natural Text
I noticed a very strange behavior when working with python that binds 2 variables, that are set equal, to the same changes and I want to know if anyone has an explanation for this behavior and if there is a better solution than mine for it.For example, I have an array called schema1. I later need to expand schema1 with a new set of variables but I can't mess up the original array so I create schema2 by setting it equal to schema1 like so:Suppose schema1 has array [a, b, c], then I:Now, schema2 should have [a, b, c, d, e, f]However, for some reason, schema1 also has [a, b, c, d, e, f]I don't understand this behavior, so if you have an explanation that would be great. As far as solutions go, this will work, but I'm wondering if there is another way that is better and can avoid a loop.Instead of setting schema2 = schema1 I just do this:
It's important to remember that in Python, variables are not little boxes that hold stuff, they're just handy names that are attached to stuff.So when you doYou're just attaching two names to the same piece of data, which is why the value of both variables changes.You need to copy the actual value. For lists, one way of doing this is:See this question for more on copying lists.
On this line:you are not creating a new array, but instead you are just setting the reference schema2 to point at the same array that schema1 is pointing at. Writingwill actually create a new list by copying schema1.
both answer above are right but instead of doing schema1[:]you can dowhich makes it more readable and can work with other object such as dict
When you assign an object to a variable, you are binding that name to that object. If you then set that variable to another variable, the second variable name is binding to the original object. In this example, schema1 and schema2 are bound to the same object. You could either use the python copy library or if the class you are working with accepts an object of that class as parameter in the constructor you can create a new object that way. For example if you are copying a dict you can do:orThe name binding is talked about in python's execution model. https://docs.python.org/3/reference/executionmodel.htmlThis might be a good start if you want to learn more: https://jeffknupp.com/blog/2012/11/13/is-python-callbyvalue-or-callbyreference-neither/


Answer URL
https://docs.python.org/3/reference/executionmodel.html
