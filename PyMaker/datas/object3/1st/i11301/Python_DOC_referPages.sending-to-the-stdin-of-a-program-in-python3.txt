Natural Text
I have to files, main.py and child.py.I am trying to send a string to the stdin of main.py.This is my incomplete code:main.pychild.pyI have no idea how to do this.I am running windows 10 with python 3.5.1-ThanksEDIT:When I am sending the argument back to main.py, I can not re-open the program. os.system re-opens the program which is not useful in my case.These programs are a small demo of what I am trying to do. In my actual program, I am not able to do that as the two programs are "communicating" with each other an need to be open at all times.What I need answered is a way to send an argument to main.py perhaps using stdin but when I am sending my argument, It can not re-open the program. Some examples like os.system re-open the program which is not what I am trying to do. I need main.py open at all times.I have my new current code which is not working. A window pops up and then closes.main.pychild.pyThat is my code.
What you need is something along the lines of (in main.py):You're assuming child.exe (in your mockup demo, python.exe) is communicating with main.py via sys.stdin/stdout, however these I/O's are used to communicate with the shell that spawned the process.Much like the childs stdout/stdin will be communicating with the shell that spawned that process, in this case Popen().Each spawned child process of subprocess.Popen(...) will be isolated with it's own stdout/stdin/stderr, otherwise every subprocess would make a huge mess of your main process stdout/stdin. This means you'll have to check for output on that particular subprocess and write to it accordingly as done in the above example.One way to look at it is this:You're starting main.py, and you communicate with it via sys.stdout and sys.stdin. Each input() in main.py will output something to sys.stdout so you can read it.Exactly the same logic applies to child.exe where every input() will output something to it's sys.stdout (- But remember - sys is not a shared variable across processes).But a simple print(1) would do the same because it will essentially output the 1 to sys.stdout for you.Edit 2018: Don't forget to close your inputs and outputs, as they might leave open file descriptors on your file system, hogging resources and causing problems later in life.Other conveyers of informationAssuming you have control of the code to child.exe and you can modify the communication pipe in any way, some other options are:sockets - Use regular sockets to communicate, on *nix the most efficient would be Unix sockets.Some other solutions can be found here: Best way to return a value from a python scriptMore cautionary tails!.readline() will assume there's a \n somewhere in your data, most likely at the end. I switched to .readline() for two reasons, .read() will hang and wait for EOF unless you specify exactly how many bytes to read, if I'm not out on a bicycle. To be able to read all kinds of output you need to incorporate select.select() into your code - or a buffer of some sort where you call x.stdout.read(1) to read one byte at a time. Because if you try to read .read(1024) and there's not 1024 bytes in the buffer, your read will hang until there are 1024 characters.I left a bug in your child.py code on purpose (mine works) - It's trivial and basic Python - in hopes that it's a learning experience on how to debug errors (you mentioned you're not good at it, this is a way to learn).


Answer URL
https://docs.python.org/3/library/select.html
