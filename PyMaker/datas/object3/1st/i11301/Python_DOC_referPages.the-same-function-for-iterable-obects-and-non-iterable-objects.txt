Natural Text
Is there a method like isiterable? The only solution I have found so far is to callBut I am not sure how fool-proof this is.
Checking for __iter__ works on sequence types, but it would fail on e.g. strings in Python 2. I would like to know the right answer too, until then, here is one possibility (which would work on strings, too):The iter built-in checks for the __iter__ method or in the case of strings the __getitem__ method.Another general pythonic approach is to assume an iterable, then fail gracefully if it does not work on the given object. The Python glossary:Pythonic programming style that determines an object's type by inspection of its method or attribute signature rather than by explicit relationship to some type object ("If it looks like a duck and quacks like a duck, it must be a duck.") By emphasizing interfaces rather than specific types, well-designed code improves its flexibility by allowing polymorphic substitution. Duck-typing avoids tests using type() or isinstance(). Instead, it typically employs the EAFP (Easier to Ask Forgiveness than Permission) style of programming....The collections module provides some abstract base classes, which allow to ask classes or instances if they provide particular functionality, for example:However, this does not check for classes that are iterable through __getitem__.
Duck typingType checkingUse the Abstract Base Classes. They need at least Python 2.6 and work only for new-style classes.However, iter() is a bit more reliable as described by the documentation:Checking isinstance(obj, Iterable) detects classes that are  registered as Iterable or that have an __iter__() method, but  it does not detect classes that iterate with the __getitem__()  method. The only reliable way to determine whether an object  is iterable is to call iter(obj).
I'd like to shed a little bit more light on the interplay of iter, __iter__ and __getitem__ and what happens behind the curtains. Armed with that knowledge, you will be able to understand why the best you can do isI will list the facts first and then follow up with a quick reminder of what happens when you employ a for loop in python, followed by a discussion to illustrate the facts.FactsYou can get an iterator from any object o by calling iter(o) if at least one of the following conditions holds true: a) o has an __iter__ method which returns an iterator object. An iterator is any object with an __iter__ and a __next__ (Python 2: next) method. b) o has a __getitem__ method.Checking for an instance of Iterable or Sequence, or checking for theattribute __iter__ is not enough.If an object o implements only __getitem__, but not __iter__, iter(o) will constructan iterator that tries to fetch items from o by integer index, starting at index 0. The iterator will catch any IndexError (but no other errors) that is raised and then raises StopIteration itself.In the most general sense, there's no way to check whether the iterator returned by iter is sane other than to try it out.If an object o implements __iter__, the iter function will make surethat the object returned by __iter__ is an iterator. There is no sanity checkif an object only implements __getitem__.__iter__ wins. If an object o implements both __iter__ and __getitem__, iter(o) will call __iter__.If you want to make your own objects iterable, always implement the __iter__ method.for loopsIn order to follow along, you need an understanding of what happens when you employ a for loop in Python. Feel free to skip right to the next section if you already know.When you use for item in o for some iterable object o, Python calls iter(o) and expects an iterator object as the return value. An iterator is any object which implements a __next__ (or next in Python 2) method and an __iter__ method. By convention, the __iter__ method of an iterator should return the object itself (i.e. return self). Python then calls next on the iterator until StopIteration is raised. All of this happens implicitly, but the following demonstration makes it visible:Iteration over a DemoIterable:Discussion and illustrationsOn point 1 and 2: getting an iterator and unreliable checksConsider the following class:Calling iter with an instance of BasicIterable will return an iterator without any problems because BasicIterable implements __getitem__.However, it is important to note that b does not have the __iter__ attribute and is not considered an instance of Iterable or Sequence:This is why Fluent Python by Luciano Ramalho recommends calling iter and handling the potential TypeError as the most accurate way to check whether an object is iterable. Quoting directly from the book:As of Python 3.4, the most accurate way to check whether an object x is iterable is to call iter(x) and handle a TypeError exception if it isn’t. This is more accurate than using isinstance(x, abc.Iterable) , because iter(x) also considers the legacy __getitem__ method, while the Iterable ABC does not.On point 3: Iterating over objects which only provide __getitem__, but not __iter__Iterating over an instance of BasicIterable works as expected: Pythonconstructs an iterator that tries to fetch items by index, starting at zero, until an IndexError is raised. The demo object's __getitem__ method simply returns the item which was supplied as the argument to __getitem__(self, item) by the iterator returned by iter.Note that the iterator raises StopIteration when it cannot return the next item and that the IndexError which is raised for item == 3 is handled internally. This is why looping over a BasicIterable with a for loop works as expected:Here's another example in order to drive home the concept of how the iterator returned by iter tries to access items by index. WrappedDict does not inherit from dict, which means instances won't have an __iter__ method.Note that calls to __getitem__ are delegated to dict.__getitem__ for which the square bracket notation is simply a shorthand.On point 4 and 5: iter checks for an iterator when it calls __iter__:When iter(o) is called for an object o, iter will make sure that the return value of __iter__, if the method is present, is an iterator. This means that the returned objectmust implement __next__ (or next in Python 2) and __iter__. iter cannot perform any sanity checks for objects which onlyprovide __getitem__, because it has no way to check whether the items of the object are accessible by integer index.Note that constructing an iterator from FailIterIterable instances fails immediately, while constructing an iterator from FailGetItemIterable succeeds, but will throw an Exception on the first call to __next__.On point 6: __iter__ winsThis one is straightforward. If an object implements __iter__ and __getitem__, iter will call __iter__. Consider the following classand the output when looping over an instance:On point 7: your iterable classes should implement __iter__You might ask yourself why most builtin sequences like list implement an __iter__ method when __getitem__ would be sufficient.After all, iteration over instances of the class above, which delegates calls to __getitem__ to list.__getitem__ (using the square bracket notation), will work fine:The reasons your custom iterables should implement __iter__ are as follows:If you implement __iter__, instances will be considered iterables, and isinstance(o, collections.Iterable) will return True.If the the object returned by __iter__ is not an iterator, iter will fail immediately and raise a TypeError.The special handling of __getitem__ exists for backwards compatibility reasons. Quoting again from Fluent Python:That is why any Python sequence is iterable: they all implement __getitem__ . In fact,  the standard sequences also implement __iter__, and yours should too, because the  special handling of __getitem__ exists for backward compatibility reasons and may be  gone in the future (although it is not deprecated as I write this).
This isn't sufficient: the object returned by __iter__ must implement the iteration protocol (i.e. next method). See the relevant section in the documentation.In Python, a good practice is to "try and see" instead of "checking".
Don't run checks to see if your duck really is a duck to see if it is iterable or not, treat it as if it was and complain if it wasn't.
In Python <= 2.5, you can't and shouldn't - iterable was an "informal" interface.But since Python 2.6 and 3.0 you can leverage the new ABC (abstract base class) infrastructure along with some builtin ABCs which are available in the collections module:Now, whether this is desirable or actually works, is just a matter of conventions. As you can see, you can register a non-iterable object as Iterable - and it will raise an exception at runtime. Hence, isinstance acquires a "new" meaning - it just checks for "declared" type compatibility, which is a good way to go in Python.On the other hand, if your object does not satisfy the interface you need, what are you going to do? Take the following example:If the object doesn't satisfy what you expect, you just throw a TypeError, but if the proper ABC has been registered, your check is unuseful. On the contrary, if the __iter__ method is available Python will automatically recognize object of that class as being Iterable.So, if you just expect an iterable, iterate over it and forget it. On the other hand, if you need to do different things depending on input type, you might find the ABC infrastructure pretty useful.
The best solution I've found so far:hasattr(obj, '__contains__')which basically checks if the object implements the in operator.Advantages (none of the other solutions has all three):it is an expression (works as a lambda, as opposed to the try...except variant)it is (should be) implemented by all iterables, including strings (as opposed to __iter__)works on any Python >= 2.5Notes: the Python philosophy of "ask for forgiveness, not permission" doesn't work well when e.g. in a list you have both iterables and non-iterables and you need to treat each element differently according to it's type (treating iterables on try and non-iterables on except would work, but it would look butt-ugly and misleading)solutions to this problem which attempt to actually iterate over the object (e.g. [x for x in obj]) to check if it's iterable may induce significant performance penalties for large iterables (especially if you just need the first few elements of the iterable, for example) and should be avoided
I found a nice solution here:
You could try this:If we can make a generator that iterates over it (but never use the generator so it doesn't take up space), it's iterable. Seems like a "duh" kind of thing. Why do you need to determine if a variable is iterable in the first place?
According to the Python 2 Glossary, iterables areall sequence types (such as list, str, and tuple) and some non-sequence types like dict and file and objects of any classes you define with an __iter__() or __getitem__() method. Iterables can be used in a for loop and in many other places where a sequence is needed (zip(), map(), ...). When an iterable object is passed as an argument to the built-in function iter(), it returns an iterator for the object.Of course, given the general coding style for Python based on the fact that it's “Easier to ask for forgiveness than permission.”, the general expectation is to useBut if you need to check it explicitly, you can test for an iterable by hasattr(object_in_question, "__iter__") or hasattr(object_in_question, "__getitem__"). You need to check for both, because strs don't have an __iter__ method (at least not in Python 2, in Python 3 they do) and because generator objects don't have a __getitem__ method.
I often find convenient, inside my scripts, to define an iterable function.(Now incorporates Alfe's suggested simplification):so you can test if any object is iterable in the very readable formas you would do with thecallable functionEDIT: if you have numpy installed, you can simply do: from numpy import iterable, which is simply something likeIf you do not have numpy, you can simply implement this code, or the one above.
pandas has a built-in function like that:
Since Python 3.5 you can use the typing module from the standard library for type related things:
This will say yes to all manner of iterable objects, but it will say no to strings in Python 2. (That's what I want for example when a recursive function could take a string or a container of strings.  In that situation, asking forgiveness may lead to obfuscode, and it's better to ask permission first.)Many other strategies here will say yes to strings. Use them if that's what you want.Note: is_iterable() will say yes to strings of type bytes and bytearray.bytes objects in Python 3 are iterable True == is_iterable(b"string") == is_iterable("string".encode('utf-8')) There is no such type in Python 2.bytearray objects in Python 2 and 3 are iterable True == is_iterable(bytearray(b"abc"))The O.P. hasattr(x, '__iter__') approach will say yes to strings in Python 3 and no in Python 2 (no matter whether '' or b'' or u''). Thanks to @LuisMasuelli for noticing it will also let you down on a buggy __iter__.
The easiest way, respecting the Python's duck typing, is to catch the error (Python knows perfectly what does it expect from an object to become an iterator):Notes:It is irrelevant the distinction whether the object is not iterable, or a buggy __iter__ has been implemented, if the exception type is the same: anyway you will not be able to iterate the object.I think I understand your concern: How does callable exists as a check if I could also rely on duck typing to raise an AttributeError if __call__ is not defined for my object, but that's not the case for iterable checking?I don't know the answer, but you can either implement the function I (and other users) gave, or just catch the exception in your code (your implementation in that part will be like the function I wrote - just ensure you isolate the iterator creation from the rest of the code so you can capture the exception and distinguish it from another TypeError.
The isiterable func at the following code returns True if object is iterable. if it's not iterable returns Falseexample
Instead of checking for the __iter__ attribute, you could check for the __len__ attribute, which is implemented by every python builtin iterable, including strings. None-iterable objects would not implement this for obvious reasons. However, it does not catch user-defined iterables that do not implement it, nor do generator expressions, which iter can deal with. However, this can be done in a line, and adding a simple or expression checking for generators would fix this problem. (Note that writing type(my_generator_expression) == generator would throw a NameError. Refer to this answer instead.)You can use GeneratorType from types:--- accepted answer by utdemir(This makes it useful for checking if you can call len on the object though.)
It's always eluded me as to why python has callable(obj) -> bool but not iterable(obj) -> bool...surely it's easier to do hasattr(obj,'__call__') even if it is slower.Since just about every other answer recommends using try/except TypeError, where testing for exceptions is generally considered bad practice among any language, here's an implementation of iterable(obj) -> bool I've grown more fond of and use often:For python 2's sake, I'll use a lambda just for that extra performance boost...(in python 3 it doesn't matter what you use for defining the function, def has roughly the same speed as lambda)Note that this function executes faster for objects with __iter__ since it doesn't test for __getitem__.Most iterable objects should rely on __iter__ where special-case objects fall back to __getitem__, though either is required for an object to be iterable.(and since this is standard, it affects C objects as well)
Not really "correct" but can serve as quick check of most common types like strings, tuples, floats, etc...
Apart from regular try and except, you could run help.help would give all the methods that could be run on that object(it could be any object and may not be a list as per example), which is temp in this case. Note: This would be something you would manually do.


Answer URL
https://docs.python.org/3/library/typing.html
