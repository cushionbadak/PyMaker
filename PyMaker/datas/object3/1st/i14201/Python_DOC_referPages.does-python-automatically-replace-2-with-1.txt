Natural Text
I saw suggestions (see e.g. Is multiplication and division using shift operators in C actually faster?) that you should not manually replace multiplication with the shift operator, because the compiler has to do it automatically and shift operators decrease readability. I have written a simple test to check this:I used equivalent operations (* 2 is equivalent to << 1 and // 2 to >> 1) and here is the result:What is wrong? Is my testing method wrong? Is the time measurement wrong? Or does Python not perform such optimizations (and, if yes, should I be afraid of that)? I used cPython 3.4.2 x64 on Win 8.1 x64.
This optimization doesn't occur at bytecode level:The dis module allows you to show you what happens "inside" Python when your code is executed or, more precisely, what exactly is executed. The output shows that the * operator is mapped to BINARY_MULTIPLY and the << operator is mapped to BINARY_LSHIFT. These two bytecode operations are implemented in C.
Using dis (to look at the bytecode equivalent of functions) and timeit (more robust timing than trying to do it manually using time) can give you a better idea of what's going on internally. Test script:And outputs (CPython v2.7.6 on Windows 7):Clearly Python is not replacing the multiplication/division operations with the equivalent bit shifts (e.g. BINARY_FLOOR_DIVIDE is not replaced by BINARY_RSHIFT), although it looks like such an optimisation could give performance improvements. As to why the bit shift is faster, see e.g. Speeds of << >> multiplication and division on Programmers.
Only in very limited circumstances could CPython implement these optimisations. The reason being that CPython is a ducked-typed language. Given the code fragment x * 2, this can mean very different things dependent on the value of x. If x is an integer than it does indeed have the same meaning as x << 1. However, if x is a float or a string or a list or any other class that implements __mul__ in its own unique way then it most certainly doesn't have the same meaning as x << 1. For example, "a" * 2 == "aa". So unless the value of x is known at compile time then this optimisation cannot be made. If the value of x is known beforehand then the entire operation can be optimised away eg.You can see that the compiler has performed the operation itself and just returns the constant value 4.


Answer URL
https://docs.python.org/3/library/dis.html
https://docs.python.org/3/library/timeit.html
https://docs.python.org/3/library/dis.html
https://docs.python.org/3/library/timeit.html
