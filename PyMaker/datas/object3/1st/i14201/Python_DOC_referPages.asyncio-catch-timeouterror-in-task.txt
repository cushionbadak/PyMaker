Natural Text
I have an asyncio.Task that I need to cancel after some amount of time. Before cancelling, the task needs to do some cleanup. According to the docs, I should just be able to call task.cancel or asyncio.wait_for(coroutine, delay) and intercept an asyncio.TimeoutError in the coroutine, but the following example is not working. I've tried intercepting other errors, and calling task.cancel instead, but neither have worked. Am I misunderstanding how cancelling a task works?
The documentation for asyncio.wait_for specifies that it will cancel the underlying task, and then raise TimeoutError from the wait_for call itself:Returns result of the Future or coroutine. When a timeout occurs, it  cancels the task and raises asyncio.TimeoutError.And you are correct that task cancellation can indeed be intercepted:[Task.cancel] arranges for a CancelledError to be thrown into the wrapped  coroutine on the next cycle through the event loop. The coroutine then  has a chance to clean up or even deny the request using  try/except/finally. Note that the docs specify that CancelledError is thrown into the coroutine, not TimeoutError.If you make that adjustment, things work the way you expect:Output:As you can see, now 'timed out' gets printed before the TimeoutError is raised by wait_for.


Answer URL
https://docs.python.org/3/library/asyncio-task.html#asyncio.wait_for
https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.cancel
