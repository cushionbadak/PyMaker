Natural Text
It is typical to use the with statement to open a file so that the file handle cannot be leaked:But what if the exception occurs somewhere within the open call?  The open function is very likely not an atomic instruction in the Python interpreter, so it's entirely possible that an asynchronous exception such as KeyboardInterrupt would be thrown* at some moment before the open call has finished, but after the system call has already completed.The conventional way of handle this (in, for example, POSIX signals) to use the masking mechanism: while masked, the delivery of exceptions is suspended until they are later unmasked.  This allows operations such as open to be implemented in an atomic way.  Does such a primitive exist in Python?[*] One might say it's doesn't matter for KeyboardInterrupt since the program is about to die anyway, but that is not true of all programs.  It's conceivable that a program might choose to catch KeyboardInterrupt on the top level and continue execution, in which case the leaked file handle can add up over time.
I do not think its possible to mask exceptions , you can mask signals but not exceptions . In your case KeyboardInterrupt is the exception that is raised when the signal.SIGINT is raised (which is the Ctrl + C) .It is not possible to mask Exceptions because well it does not make sense, right? Let's say you are doing open('file','r') , but file does not exist, this causes the open function to throw IOError Exception, we should not be able to mask these kinds of exceptions. It does not make sense to mask it, because open would never be able to complete in the above case.exceptions â€“ anomalous or exceptional conditions requiring special processingFor KeyboardInterrupt exception , its different because like I said, its actually a signal that causes the KeyboardInterrupt exception to be raised.You can only mask signals in Unix starting from Python 3.3 using the function signal.pthread_sigmask [Reference]For that you will have to move the the context expression to a different block so that we can so something like mask the signal, run the context expression to get the context manager and then unmask the signal , a sample code would look like (please note I have not personally tested this code) -
Some clarification: it seems that asynchronous exceptions are not commonly used in Python.  The standard library only documents KeyboardInterrupt AFAIK.  Other libraries can implement their own via signal handlers, but I don't think (or hope?) this is a common practice, as asynchronous exceptions are notoriously tricky to work with.Here is a naive solution that won't work:The exception-handling part is still vulnerable to exceptions: a KeyboardInterrupt could occur a second time after the exception is caught but before release is complete.There is also a "gap" between the end of the try statement and the beginning of the with statement where it is vulnerable to exceptions.I don't think there's anyway to make it work this way.Thinking from a different perspective, it seems that the only way in which asynchronous exceptions can arise is from signals.  If this is true, one could mask them as @AnandSKumar suggested.  However, masking is not portable as it requires pthreads.Nonetheless, we can fake masking with a little trickery:This will work if SIGINT is the only source that we care about.  Unfortunately it breaks down for multiple signals, not just because we don't know which ones are being handled, but also because we can't swap out multiple signals atomically!


Answer URL
https://docs.python.org/3/library/signal.html#signal.pthread_sigmask
