Natural Text
I need to iterate on a file, stop iteration on a condition and then continue parse the file at the same line with another function (That may change so I can't just add content in the previous function).An example file (file.txt) :Function I try to do : Result in terminal:My problem with this is the "4" line is skipped by the 1st function when I look for condition. How can I avoid this : I found any solution for cancel the last iteration or go back a line.The file.tell() function don't work with for on file.I tried to do this with while + file.readline() but it is very very slower than the for loop on file (And I want to parse files with millions of lines).Is there an elegant solution for keeping the use of the for loop ?
In python3, the 'for line in file' construct is represented by an iterator internally. By definition, a value that was produced from an iterator cannot be 'put back' for later use (http://www.diveintopython3.net/iterators.html).To get the desired behaviour, you need a function that chains together two iterators, such as the chain function provided by the itertools module. In the stop condition of parse1, you return the last line together with the file iterator:The chain statement connects two iterators. The first iterator contains just one element: the line you want to process again. The second iterator is the remaining part of the file. As soon as the first iterator runs out of values, the second iterator is accessed.You don't need to change parse2. For clarity, I modified the print statement:Then, you can call parse1 and parse2 in a most functional manner:The output of the above line is:Note, how the value '4' was produced by the parse2 function.
I suggest to make a copy1 of your file object and just iterate over the copy in else block and call the second function within first function , also as a more pythonic way you can use with statement for opening the file that will close the file at end of the statement and put the second function within first function :you can use itertools.tee for create copy1 of your file object :result :1) actually itertools.tee doesn't create a copy but you can use it for this aim based on DOC it Return n independent iterators from a single iterable.and you can assign one of this independent iterators to the object itself that has been iterated and create one another as temp.
IMHO, the simplest solution is to have first parser return the line where it found the stop condition, and pass it to second one. The second should have an explicit function to parse one line to avoid code duplication :


Answer URL
https://docs.python.org/3/library/itertools.html?itertools.chain#itertools.chain
