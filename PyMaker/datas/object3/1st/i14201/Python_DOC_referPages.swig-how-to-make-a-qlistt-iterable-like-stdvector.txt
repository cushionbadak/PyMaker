Natural Text
I'm using SWIG to generate Python Bindings for my qt app. I have several places where I use QLists and I would like to integrate those QLists like std::vector from the SWIG Library (see http://www.swig.org/Doc1.3/Library.html#Library_nn15).This means:  The QList objects should be iterable from python (= they must be an iterable python object)It should be possible to pass a python list to a function which takes a qlist... and all the other features listed in the SWIG Library for std::vectorTo achieve that I use the following Code:https://github.com/osmandapp/OsmAnd-core/blob/master/swig/java/QList.iLater in my classes using QLists, I add code like:This works so far, but it doesn't give me the kind of integration I get with std::vector.I'm having trouble finding out which parts of std_vector.i, std_container.i,... make an object iterable.How do I need to extend the QList interface file to make my QList's iterable?
What you are asking for -- a qlist.i swig file that achieves the same level of integration for QList in python as std_vector.i does for std::vector -- is a non-trivial task.I provide a very basic extended qlist.i file (and qlisttest.i to show you how to use it) and will try to explain what steps are required.qlist.i:qlisttest.i:Wrapping of QList to make it and its methods accessible from pythonThis is achieved by making the (partial) class definition available to swig. That is what your current qlist.i does.Note: You might need to add a "template specialization" for the case QList<T*> that typedefs const_reference as const T* since you are using a QList of pointers. Otherwise, QList<T*>::const_reference will be const T*&, which apparently might confuse swig. (see swig/Lib/std/std_vector.i)Automatic conversion between python list and QListThis is generally achieved by using swig typemaps. For instance, if you want a function f(const QList<int>& list) to be able to accept a python list, you need to specify an input typemap that performs the conversion from a python list to a QList<int>:Here, the situation is more difficult in several ways:You want to be able to pass a python lists or a wrapped QList: For this to work, you need to handle both cases in the typemap.You want to convert a python list of wrapped type T to a QList<T>:This also involves a conversion for every element of the list from the wrapped type T to the plain T. This is achieved by the swig function SWIG_ConvertPtr.I am not sure if you can specify typemaps with template arguments. Therefore, I wrote a swig macro %qlist_conversions(Type) that you can use to attach the typemap to the QList<Type> for a specific Type.For the other conversion direction (QList -> python list) you should first consider what you want. Consider a C++ function that returns a QList<int>. Calling this from python, should this return a wrapped QList object, or should it automatically convert the QList to a python list?Accessing the wrapped QList as a python sequence, i.e., make len and [] work from pythonFor this, you need to extend the QList class in the qlist.i file using %extend { ... } and implement __len__ and __getitem__ methods.If slicing should also work, you need to provide a __getitem__(PySliceObject *slice)__ member method and input and "typecheck" typemaps for PySliceObjects.If you want to be able to modify values in the wrapped QList using [] from python, you need to implement __setitem__.For a list of all the useful methods you can implement to achieve better integration, see the python documentation on "builtin types" and "abstract base classes for containers".Note: If you use the swig -builtin feature, then you need to additionally register the above functions to the appropriate "slots" using e.g.Making the wrapped QList iterable from pythonFor this you need to extend the QList class and implement an __iter__() method that returns a python iterator object.A python iterator object is an object that provides the methods __iter__() and __next__() (next() for older python), where __next__() returns the next value and raises the python exception StopIteration to signal the end.As mentioned before, you can implement the iterator object in python or C++. I show an example of doing this in python.I hope this helps as a basis for you to tweak the functionality that you require.
You provided an answer to the question "How to make a python Object iterable", but I asked for "How do I need to extend the QList interface file to make my QList's iterable?" which is more a SWIG, than a python related question.I tested the example from http://www.swig.org/Doc1.3/Library.html#Library_nn15 with Java, C# and Python. Only Python and C# provide iterators. The generated interface of Java doesn't implement Iterable or something like that. As far as I can see your question is related to the target language.Maybe extending MutableSequence is an option for you. The only methods you have to implement are __getitem__, __setitem__, __delitem__, __len__ and insert by delegating them to the corresponding methods of QList. Afterwards your generated class is iterable.
As described in the docs, you need the following:QList should have a method in python __iter__() that returns an iterator object (tp_iter if you implement it in C).The iterator object should implement __iter__() and return itselfThe iterator object should implement next() that returns the next item or raises StopIteration when it's done. It's probably easiest to do in python, but you can implement it in C as well.Another option is to use python generators to avoid implementing an iterator type. To do this you QList needs to implement __iter__() but instead of returning an iterator you simply yield the values.The methods mentioned only need to be visible to python. You don't have to make them available in C/Java.See also SWIG interfacing C library to Python (Creating 'iterable' Python data type from C 'sequence' struct)


Answer URL
https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableSequence
