Natural Text
This is my second day of learning python (I know the basics of C++ and some OOP.), and I have some slight confusion regarding variables in python.Here is how I understand them currently:Python variables are references (or pointers?) to objects (which are either mutable or immutable). When we have something like num = 5, the immutable object 5 is created somewhere in memory, and the name-object reference pair num is created in a certain namespace. When we have a = num, nothing is being copied, but now both variables refer to the same object and a is added to the same namespace.This is where my book, Automate the boring stuff with Python, confuses me. As it's a newbie book, it doesn't mention objects, namespaces, etc., and it attempts to explain the following code:The explanation it offers is exactly the same as that of a C++ book, which I am not happy about as we are dealing with references/pointers to objects. So in this case, I guess that in the 3rd line, as integers are immutable, spam is being assigned an entirely new pointer/reference to a different location in memory, i.e. the memory that it was initially pointing to wasn't modified. Hence we have cheese referring to the initial object referred to by spam. Is this the correct explanation?
As a C++ developer you can think of Python variables as pointers.Thus when you write spam = 100, this means that you "assign the pointer", which was previously pointing to the object 42, to point to the object 100.Earlier on, cheese was assigned to point to the same object as spam pointed to, which happened to be 42 at that time. Since you have not modified cheese, it still points to 42.Immutability has nothing to do with it in this case, since pointer assignment does not change anything about the object being pointed to.
The way I see it there are different views of a language.The "language lawyer" perspective. The "practical programmer" perspective.the "implementor" perspective.From the language lawyer perspective python variables always "point at" an object. However unlike Java and C++ the behvaiour of == <= >= etc depends on the runtime type of the objects that the variables point at. Furthermore in python memory management is handled by the language.From a practical programmer perspective we can treat the fact that integers, strings, tuples etc are immutable* objects rather than straight values as an irrelevent detail. The exception is when storing large ammounts of numeric data we may want to use types that can store the values directly (e.g. numpy arrays) rather than types that will end up with an array full of references to tiny objects.From an implementers perspective most languages have some sort of as-if rule such that if the specified behaviours are correct the implementation is correct regardless of how things are actually done under the hood.So yes your explanation is correct from a language lawyer perspective. Your book is correct from a practical programmer perspective. What an implementation actually does depends on the implementation. In cpython integers are real objects though small value integers are taken from a cache pool rather than created anew. I'm not sure what the other implementations (e.g. pypy and jython) do.* note the distinction between mutable and immutable objects here. With a mutable object we have to be careful about treating it "like a value" because some other code might mutate it. With an immutable object we have no such concerns.
It is correct you can more or less thing of variables as pointers. However example code would help greatly with explaining how this actually is working.First, we will heavily utilize the id function:Return the “identity” of an object. This is an integer which is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same id() value.It's likely this will return different absolute values on your machine.Consider this example:You can see that:The original foo/bar have different ids, because they point to different objectsWhen bar is assigned to foo, their ids are now the same. This is similar to them both pointing to the same location in memory that you see in making a C++ pointerwhen we change the value of foo, it is assigned to a different id:An interesting observation too is that integers implicitly have this functionality up to 256:However beyond 256 this is no longer true:however assigning a to b will indeed keep the id the same as shown before:
Python is neither pass-by-reference or pass-by-value. Python variables are not pointers, they are not references, they are not values. Python variables are names.Think of it as "pass-by-alias" if you need the same phrase type, or possibly "pass-by-object", because you can mutate the same object from any variable that indicates it, if it's mutable, but reassignment of a variable (alias) only changes that one variable.If it helps: C variables are boxes that you write values into. Python names are tags that you put on values.A Python variable's name is a key in the global (or local) namespace, which is effectively a dictionary. The underlying value is some object in memory. Assignment gives a name to that object. Assignment of one variable to another variable means both variables are names for the same object. Re-assignment of one variable changes what object is named by that variable without changing the other variable. You've moved the tag but not changed the previous object or any other tags on it.In the underlying C code of the CPython implementation, every Python object is a PyObject*, so you can think of it as working like C if you only ever had pointers to data (no pointers-to-pointers, no directly-passed values).you could say that Python is pass-by-value, where the values are pointers… or you could say Python is pass-by-reference, where the references are copies.
When you run spam = 100 python create one more object in the memory but not change existing. so you still have pointer cheese to 42 and spam to 100
What is happening in spam = 100 line is replacement of previous value (pointer to object of type int with value 42) with another pointer to another object (type int, value 100)
As @DeepSpace mentioned in the comments, Ned Batchelder does a great job demystifying variables (names) and assignments to values in a blog, from which he delivered a talk at PyCon 2015, Facts and Myths about Python names and values.  It can be insightful for Pythonistas at any level of mastery.
When you store spam = 42 , it creates an object in the memory. Then you assign cheese = spam , It assigns the object referenced by spam to cheese. And finally, when you change spam = 100, it changes only spam object. So cheese = 42.  


Answer URL
https://docs.python.org/3/library/functions.html#id
