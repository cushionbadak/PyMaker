Natural Text
Consider the following code (not a very good design, but that's the point):Now, if I want to test B.foo(), I need to mock A (as it accesses the file-system inside the constructor).To write a test that will make sure B.foo() returns False in case a1.get() and a2.get() provide different values, I also need to mock B.get().So, the test function should probably look like the following:Now, the strange point - as may be seen from the comments inside the code, if we assign mock_get to the class, it won't propagate, but if we create an instance and assign to it, it propagates to other instances of the class.I suppose this behavior is related to internal mechanisms of mock, so it's important for me to understand it, to make proper usage of this library with all it's rich functionality.So, does anyone has a clue?
On the first case I can not see anywhere that you are patching the get method. You should assign the mock value to the get method of A before B is called. For instance why does the following test fail?:The reason for the previous behaviour is that we are forgetting to patch the return value of the object (A), in this case MockA, instead of the object itself (MockA). The A object is the result of instantiating the A class and you should access the method throgh the return_value of the A class. In your example it would be something similar to this:You can check some of the following posts for more info on common python unit testing pitfalls:https://esaezgil.com/post/unittesting_pitfalls/ (written by me)http://alexmarandon.com/articles/python_mock_gotchas/And of course the docs: https://docs.python.org/3/library/unittest.mock.html


Answer URL
https://docs.python.org/3/library/unittest.mock.html
