Natural Text
Lately, I have been writing lots of unit tests for the classes I have developed. This is the first time I have adopted the approach of rigorously testing my library code before releasing and I have to agree that I have learned a lot during the process.The current challenge I face is with testing two instances for equality and non-equality.Here is a simple class abstracting the library code:Here are the unit tests I have written for testing the equality functionality:Both these test cases work fine. However, through the assertNotEqual method, I am testing the __ne__() of the User class. I find this somewhat misguiding since I have not implemented a custom __ne__ method in my User class. As a result of this dilemma, I thought of replacing the non-equality testcase with self.assertFalse(foo.__eq__(bar)) or self.assertFalse(foo == bar).I understand that all these approaches perform the same task and this question might seem highly subjective at first. However, I am looking for some fundamental advice/principle about testing which can help me in similar predicaments.
The Python data model is a good resource for this kind of question:By default, __ne__() delegates to __eq__() and inverts the result unless it is NotImplemented. There are no other implied relationships among the comparison operators, for example, the truth of (x<y or x==y) does not imply x<=y. To automatically generate ordering operations from a single root operation, see functools.total_ordering().That means it's totally fine to test: self.assertNotEqual(foo, bar) because by implementing __eq__ and not overriding __ne__ you implicitly defined __ne__.But you don't need to test this explicitly (but you can) because it's one of the data-model guarantees.However there is one thing that could lead to problems (bugs) which should be covered in the unit-tests: The is kind of a red-flag (the isinstance and self.__class__ combination).In this specific case it wouldn't work if you deal with sub-classes (because then self.__class__ can be the subclass). You should either hardcode the base class:or use duck-typing:or something similar.
While doing objects comparison, by default Python checks something like objects' memory addresses (iirc, id(obj) values)You should manually override both __eq__() and __ne__() methods.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__lt__
