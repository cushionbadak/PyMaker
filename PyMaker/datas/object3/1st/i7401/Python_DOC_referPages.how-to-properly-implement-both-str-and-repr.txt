Natural Text
In several of my classes, I want to implement both __str__ and __repr__ and usually end up with code like this:Which does what I'd expect:However the code violates DRY and as the number of arguments starts to grow maintaining this becomes cumbersome and I've often found that either of __str__ or __repr__ has come "out of sync" with the other.Is there a better way to simultaneously implement both __str__ and __repr__ without duplication?
Since your __str__ and __repr__ follow the same pattern, you could write a function to create the object's string representation for you. It would take an object, a list of attributes and str or repr as arguments:I would recommend putting this function in a class which you then inherit from:And you can even get it done completely automatically by grabbing the attributes directly from the __init__ function's signature:
There are no rules nor clear guidelines for implementing __str__ and __repr__—at least none that are consistently followed anywhere (not even in the stdlib). So there wouldn’t be a way to get the “standard behavior” automatically, simply because there isn’t a standard behavior. It’s up to you, so if you set up guidelines for yourself, maybe you can also come up with a utility to make it easier for you to follow them.In your case, you could for example create a base class which provides the __str__ and __repr__ implementations:You could then use that on a number of different types:
No need for duplication, just don't implement __str__.That way, the object will behave like __str__ = __repr__.I think you should also read this answer.
Neither the official Python documentation nor the Index of Python Enhancement Proposal seem to specify clear guidelines on how to override these methods, except for the 3.3 Special method names which, among other things, says of __repr__():If at all possible, this should look like a valid Python expression  that could be used to recreate an object with the same value [...]  This is typically used for debugging, so it is important that the  representation is information-rich and  unambiguous.I like to take inspiration from how __repr__() is implemented in some of the standard library modules, take e.g. socket.socket:So the pattern here is <self.__class__.__module__ + "." + self.__class__.__name__ attribute1=value1, ..., attributeN=valueN>.While __repr__() is preferred for debug/testing purposes, the scope of __str__() is much more informal and I'd deduce that even looser rules apply. Note that if __repr__() is overridden but __str__() is not, __repr__() calls __str__().Here again, if I have to pick some rules I prefer to have __str__() resemble __repr__(), but modifying:The number of items displayed. I don't need to be verbose as __repr__ mandates.The type of values displayed. I include the most "important" ones, and even values that do not reflect the arguments initially passed to __init__().Another few examples come from a PDF library I've been working on. There are two PdfFileReader and PdfFileWriter classes, and their __repr__() and __str__() methods have the following output:See also 2. Built-in Functions for repr():[...] For many types, this function makes an attempt to return a string that  would yield an object with the same value when passed to eval(),  otherwise the representation is a string enclosed in angle brackets  that contains the name of the type of the object together with  additional information often including the name and address of the  object. [...]


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__repr__
https://docs.python.org/3/library/functions.html#repr
