Natural Text
Newbie here in Python and sympy. I have simple question.If I start a worker using multiprocessing, and give it some small timeout say 3 seconds, in the join call. What happens if the worker is busy itself, may be waiting for something to complete? what happens when the timeout expires and worker itself is waiting for sympy?I found that if the worker calls sympy on a long computation, the join hangs waiting for the worker, much longer than the time out period. Here is a MWEQuestion: Is it possible to force the worker to terminate at the timeout? Is there another option to use to do that? Am I doing something wrong in the above?If not possible to force timeout at join, then what is the meaning of join() after n seconds, if the worker can't join? Only reason I am trying the above is to find a way to timeout on long computation in sympy, since I am on windows and timers and alarms do not work on windows, so I thought to try multiprocessing with timeout, but it does not seem to do what I want and hence this will not be any use for what I want.ps. if you run the above, worker will hang inside sympy for long time, may be 10 minutes or more, and might have to kill it manually.The above is on windows. But I also tried in on Linux, and it also hangs.Anacode 4.3.1, Python 3.6UpdateThanks to hint in answer, this below seems to work nowI still need to test it more to make sure the worker process() does get killed by terminate as I do not want to have zombie workers around. 
The reason why your code never reaches the print "in time" is because it doesn't get beyond the result=que.get(). You specified a timeout for p.join which makes the calling process resume after the specified timeout. However que.get is also blocking and therefore waits until an item has been put in the queue. You can specify a timeout here as well: que.get(timeout=...) or simply turn off blocking: que.get(block=False). In any case, if no item is available in the queue, it will raise a queue.Empty exception.However the documentation contains several warnings about terminating a process that holds a (shared) reference to a queue. The Programming Guidelines seem to contain a solution for that case and also warn of possible deadlocks (see "Joining processes that use queues").


Answer URL
https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue.get
https://docs.python.org/3/library/queue.html#queue.Empty
https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Process.terminate
https://docs.python.org/3/library/multiprocessing.html#pipes-and-queues
https://docs.python.org/3/library/multiprocessing.html#programming-guidelines
