Natural Text
I have some trouble with Python class creations. My task is to create objects using some parse method. But I want to turn off basic class creation using __init__For example, I have This gives me an opportunity to create object using command like thisa = A.create_from_file()But this code provides me a chance to create instance using __init__a = A() won't raise an exception...When I try to add own __init__ method, my parse function also raises an exception.How I can fix this trouble, and what is the most Pythonic way to write this classes?
__init__ is not responsible for creating a instance. It is a hook method that Python calls for you after the instance is already created. You can't prevent instance creation from there. Besides, you don't want to prevent all instance creation, even your classmethod has to create an instance at some point.Since all you want to do is raise an exception when your factory method is not used to create the instance, it's still fine to raise an exception in __init__ method. That'll prevent the new instance from being assigned anywhere. What you need to do then is distinguish between direct access, and your factory method being used.You could achieve this is several different ways. You could use a "secret" token that only the factory method passes in:The classmethod still creates an instance, the __init__ is still called for that instance, and no exception is raised because the right token was passed in.You could make your class an implementation detail of the module and only provide a public factory function:Now the public API only gives you create_from_file(), the leading underscore tells developers that _A() is an internal name and should not be relied on outside of the module.Actual instance creation is the responsibility of the object.__new__ method; you could also use that method to prevent new instances to be created. You could use the same token approach as I showed above, or you could bypass it altogether by using super() to call the original overridden implementation:Here a direct call to A() will raise an exception, but by using super().__new__ in the classmethod we bypass the A.__new__ implementation.Note: __new__ is implicitly made a staticmethod, so we have to manually pass in the cls argument when we call it from the classmethod.
If you only have one method to create the object, just make that the constructor. That is, instead ofyou would haveIf there are several different methods of creating an object, it's still typically going to be the case that one of them is more fundamental than any other - in other words, that the arguments to other methods can be "converted" into the arguments to the one method. For example, you might have create_from_file(), create_from_url(), and create_from_string(), where the former two methods basically read the content of the file or URL and then do the same thing with it that create_from_string() does. So just turn create_from_string() into __init__(), and have the other two methods read the file or URL and call the constructor with the content.If you really don't have a single "fundamental" way of creating the object, it's probably worth considering whether you should have different subclasses of a base class.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__new__
