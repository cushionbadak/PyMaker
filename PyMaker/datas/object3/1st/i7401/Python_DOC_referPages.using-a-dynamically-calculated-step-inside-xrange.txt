Natural Text
Suppose I have:It is obvious that the step = 2*n+3 part is calculated once.But is this guaranteed to be the same for xrange?According to this answer, xrange is a sequence object that evaluates lazily.So the question is basically - which part evaluates lazily?Is it only the start <= stop part, or also the step part?I tried a simple test in order to determine the answer:This test clearly shows that n is not reevaluated at every iteration.But I'm suspecting that perhaps the n inside the xrange expression "lives in a different scope" than that of the n declared before the xrange.Thank you.
Neither range() nor xrange() care how the step value was derived; the expression is executed and the result of the expression is passed to the call, be that range(), xrange() or any other callable object.That's because (...) is an expression too; it is a call expression; the arguments passed into a call are all expressions that are evaluated before the result is passed in to the  call. It doesn't matter what is being called here.TLDR; the xrange() object is passed the outcome of the expression, not the expression itself. As long as that outcome is an integer object, it'll be stored by the object (as an immutable value) to base the virtual sequence of.
The fact that xrange works lazily means that the arguments are evaluated at "construction" time of the xrange (in fact xrange never knew what the expressions were in the first place), but the elements that are emitted are generated lazily. So the step parameter is actually calculated before you even call xrange(..). As a result, xrange(..) does not know how the step was calcuated, and thus cannot ask to re-evaluate it.Although xrange(..) is more complex than that (since it can work with negative steps, etc.), a very basic implementation would be:
To add on top of the other answers: A good way to test this would be to provide a function as the step argument. If it is to be evaluated multiple times then the  function would need to be called multiple times.The above code outputswhich shows that the step argument is evaluated exactly once.
when you pass the appropriate arguments into xrange(), Python will construct a generator object that will compute values "on the fly".Once that generator object is constructed and returned, the object is set. It no longer cares whether a variable originally used in calculating its constructor arguments changes or not. This same principal applies not only to xrange(), but to other callable objects as well. Once you pass arguments to a callable, Python calculates the expressions using the current value of any variables, and passes the result to the callable. If any variables that were used in calculating the arguments of the callable have their value changed, Python does not care because only the current value of the variable was used. Python will not keep recalculating the arguments of a function every time a variable used in an expression passed into it changes:
Lazy evaluation does not mean you can change the evaluation while it is going on; while iterating xrange you are dealing with a generator, that is created with the parameters you provide. It can not change its step during iteration, at least not with the built in one.


Answer URL
https://docs.python.org/3/reference/expressions.html#calls
