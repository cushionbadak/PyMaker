Natural Text
I have a listI want to sort it according to a particular condition. I want to use a logic that whenever lis[i][0] is equal to lis[i + 1][0], swap the elements. Something likeIn the above list,the second and third elements are [1, -1] and [1, 0] where lis[i][0] == lis[i + 1][0]. So I will swap it such that my new list becomesThis is my function:I want to pass this function to the sort method of the list such that it sorts according to this logic:I tried doing this but doesn't work:How can I make this function work in the sort method?
As already said in the other answers it's not possible (or at least non-trivial) to make it work with sorted. However you can do it without any sorting, just by collecting the indices based on the first element:Then create a "result" list and just reverse the indices of all elements that have the same first element:Which gives a res of:Note: It may not be the desired behavior to "reverse" the elements with the same first element. Because as @hiro protagonist noted in the comments:the problem is not really well defined... lst = [(0,0), (0,1), (0,2)]: what is the result? how and how many times do your iterate over the list? when are you done?in case you need a different behavior which elements should be assigned to which position you (probably) only need to change the for orig_idx, target_idx in zip(value, reversed(value)): line and apply your desired operation there.A further advantage is that this approach only has O(n) runtime behavior whereas sort has O(n*log(n)) (average) runtime. So it could be faster.
You cannot make it work reliably with list.sort or sorted. The problem is that the sorting algorithm behind these functions doesn't make guarantees which elements are compared or not (it just says that the result will be sorted). For list.sort or sorted to work reliably you need a total ordering relation of the key, which your function doesn't provide.Also the key should be a function that converts one element to "the property that should be compared", it does pass each element of the list to the key function not the total list (in fact in CPython the list is empty while you sort it, so it couldn't work at all).
One way to perform this sorting is to use the cmp parameter for sorted (use functools.cmp_to_key for Python 3) and return -1 when the items at index 0 of two sublists compare equal or zero otherwise. This assumes the items are in pairs and are successive, so it isn't really an exhaustive sort, only an hackish way to swap your items:However, the sorting becomes ambiguous when more than two items have the same value at index 0 or the items are not successive.OTOH, you could just loop through your list and swap pair-wise successive items that match your condition. No need to apply sorting!
The python sort method will sort a list in place, using only < comparisons between items. You have to pass it a function which maps each element to something which may be compares to other mapped elements so that the 'less than' relation gives the desired result.Your rule however isn't defining any kind of relationship that can be described in terms of a < b for elements a, b. It is defining a relationship between adjacent elements only, and it isn't even a stable relationship: if a < b so you swap those two items then it immediately becomes the case that b < a.Or in short, lis.sort() is completely inappropriate for this task.


Answer URL
https://docs.python.org/3/library/functools.html#functools.cmp_to_key
