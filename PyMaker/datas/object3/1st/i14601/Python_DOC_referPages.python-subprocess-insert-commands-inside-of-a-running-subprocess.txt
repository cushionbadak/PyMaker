Natural Text
I have a subprocess running:and i want to be able to insert more commands that is recognized only by the currently running subprocess.note that there must be a cwd=os.path.abspath('candc') parameter so that the subprocess would be called from outside of the binary folder, otherwise it won't run.C&C is a NLP library and what it is actually going to do is to parse a given sentence. I want to be able to pass a sentence to the subprocess. how can I do this ?
I think what you're asking is how to pass commands to the standard input of candc, as if you'd run it on the command line and typed commands on its interface.If you can pass all the commands at once as one big string (presumably joined by newlines), you can do that with the input parameter, as shown in the examples in the check_output docs:If this is Python 3.x, you have to also use encoded bytes for commands, or add universal_newlines=True to make check_output do it for you. If your commands are pure ASCII, the former is easier; just change that line to commands = b"""….If this is an old enough version (I think that means 2.6/3.2, but I'm not sure—check the docs linked above), the input parameter didn't exist yet. In that case, you have three options:Install subprocess32 off PyPI, which backports the newer version of the library to older versions of Python.Look at how the current source handles the input argument and do exactly the same thing yourself.Popen.communicate took an input argument before check_output did, so, you can just manually create a Popen and call communicate on it.The last one is basically just a simpler version of the second one… but it is a lot simpler. In fact, it's just a two-liner if you don't need all the extra complexity of handling timeouts and doing something with the output and so on:If you need to send the commands interactively (wait for one response before sending the next), then check_output can't do that. It's just a convenience wrapper around the Popen object. You will instead want to create a Popen object explicitly, then do p.stdin.write and p.stdout.read to communicate with it.For example, a quick&dirty version might be:But that code can block if, say, the prompt is ever more than one line, or it isn't guaranteed to fit in one buffer, or…In general, this can be very hard to get right. (Python itself didn't get it right in the communicate function until 3.2 or 3.3…) Especially if you don't understand what the docs are talking about with blocking the output pipe. So if that's really what you need, you may want to consider using a third-party library that's made for driving interactive command-line programs, like pexpect, instead of doing it yourself.


Answer URL
https://docs.python.org/3/library/subprocess.html#subprocess.check_output
https://docs.python.org/3/library/subprocess.html#subprocess.Popen
