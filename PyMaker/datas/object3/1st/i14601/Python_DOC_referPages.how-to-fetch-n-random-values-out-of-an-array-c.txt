Natural Text
I would like to fetch n random values out of an array.I can do it in Python using x=random.sample(listName, numberOfValuesNeeded)I want to print on the screen:1: random name1  2: random name3 ...  6: random name6
Python's random.sample returns samples without replacement. That means you can't get the same element twice.Your algorithm obviously doesn't do the same. If you reshuffle after getting each value, that's replacing the values. But there's an easy way to fix that: just shuffle once, outside the loop, instead of each time through the loop.And that means the loop is dead-simple: you just want to print the first 6 numbers in the shuffled dispNames. So:A few side notes:random_shuffle is deprecated. And so is shuffle with the default PRNG. There's a good reason for that; even when you don't care about cryptographic randomness or anything fancy, you still want to use a specific PRNG, and the new version of shuffle, just to portably get a uniform distribution.It's more normal to count from 0 to <6 than from 1 to <=6. And that would mean you don't need the x-1.It would be even better to use an iterator instead of indexing; then the same code would work even if you replaced dispNames with some other randomly-accessible type instead of an array.For picking 6 samples out of a list of 17, this is fine. (Well, it's fine as long as it's acceptable to destructively modify the array, which Python's random.sample doesn't do… but if that's a problem, it's not hard to replace this with a copying shuffle, or just a copy plus a destructive shuffle…)But if your values get too much larger, you need to think about efficiency. Shuffling inherently takes O(N) time, because it has to shuffle most of the N values. But picking K values out of N shouldn't take that long. (And if you switch to a copying shuffle, you're also adding O(N) space, which isn't necessary either.)I don't think there's an equivalent in the C++ stdlib, but that's OK; it's worth learning how to implement this yourself so you'll understand what it's doing. There are a few different choices: You can build it on top of a permutation generator (which C++ does have in the stdlib), or on top of a trivial linear congruential generator for the next prime bigger than the length of your list (throwing out values that are too large), or a partial Fisher-Yates shuffle instead of a complete one, or probably other things I haven't thought of. (And some that are dead-simple and dead-fast in specific situations, but not in general—e.g., just choosing with replacement and keeping track of previous picks works great if K is tiny, but it's horrible if K is a sizable chunk of N.)Or, of course, you can read the CPython source, which is a pretty good way to figure out how to write C++ code that will do exactly the same thing as Python.
If you're not concerned about repetitions you can generate 6 random indexes and print the corresponding values like so:
You can use a technique called Reservoir Sampling. It only iterates once over the input and thus needs O(n). Here's your sample code with a working C++11 reservoir sampling:


Answer URL
https://docs.python.org/3/library/random.html#random.sample
