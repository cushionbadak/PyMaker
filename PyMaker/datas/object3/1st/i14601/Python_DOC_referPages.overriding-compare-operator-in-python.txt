Natural Text
The following piece of codeworks fine in Python 2, but in Python 3 I get an error:It only works for == and !=.
You need to provide the rich comparison methods for ordering in Python 3, which are  __lt__, __gt__, __le__, __ge__, __eq__, and __ne__. See also: PEP 207 -- Rich Comparisons.__cmp__ is no longer used.More specifically, __lt__ takes self and other as arguments, and needs to return whether self is less than other. For example:(This isn't a sensible comparison implementation, but it's hard to tell what you were going for.)So if you have the following situation:This will be equivalent to:which would return True. __eq__ would return True if the points are equal and False otherwise. The other methods work analogously.If you use the functools.total_ordering decorator, you only need to implement e.g. the __lt__ and __eq__ methods:
This was a major and deliberate change in Python 3.  See here for more details.The ordering comparison operators (<, <=, >=, >) raise a TypeError exception when the operands don’t have a meaningful natural ordering. Thus, expressions like 1 < '', 0 > None or len <= len are no longer valid, and e.g. None < None raises TypeError instead of returning False. A corollary is that sorting a heterogeneous list no longer makes sense – all the elements must be comparable to each other. Note that this does not apply to the == and != operators: objects of different incomparable types always compare unequal to each other.builtin.sorted() and list.sort() no longer accept the cmp argument providing a comparison function. Use the key argument instead. N.B. the key and reverse arguments are now “keyword-only”.The cmp() function should be treated as gone, and the __cmp__() special method is no longer supported. Use __lt__() for sorting, __eq__() with __hash__(), and other rich comparisons as needed. (If you really need the cmp() functionality, you could use the expression (a > b) - (a < b) as the equivalent for cmp(a, b).)
In Python3 the six rich comparison operatorsmust be provided individually. This can be abbreviated by using functools.total_ordering. This however turns out rather unreadable and unpractical most of the time. Still you have to put similar code pieces in 2 funcs - or use a further helper func.So mostly I prefer to use the mixin class PY3__cmp__ shown below. This reestablishes the single __cmp__ method framework, which was and is quite clear and practical in most cases. One can still override selected rich comparisons.Your example would just become:The PY3__cmp__ mixin class:


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__lt__
https://docs.python.org/3/reference/datamodel.html#object.__gt__
https://docs.python.org/3/reference/datamodel.html#object.__le__
https://docs.python.org/3/reference/datamodel.html#object.__ge__
https://docs.python.org/3/reference/datamodel.html#object.__eq__
https://docs.python.org/3/reference/datamodel.html#object.__ne__
