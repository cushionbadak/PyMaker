Natural Text
What I was trying to achieve, was something like this:So I searched and found this perfect regular expression:As the next logical step I tried:Why does this not work, and how do I achieve the result from the linked question in python?Edit: Solution summaryI tested all provided solutions with a few test cases:In summary you could say the solution by @kalefranz does not match the question (see the last case) and the solution by @casimir et hippolyte eats a single space, and thereby violates the idea that a split should not change the individual parts. The only difference among the remaining two alternatives is that my solution returns a list with the empty string on an empty string input and the solution by @200_success returns an empty list.I don't know how the python community stands on that issue, so I say: I am fine with either one. And since 200_success's solution is simpler, I accepted it as the correct answer.
As @nfs has explained, re.split() never splits on an empty pattern match.  Therefore, instead of splitting, you should try finding the components you are interested in.Here is a solution using re.finditer() that emulates splitting:
Use re.sub() and split()result
Most of the time when you don't need to check the format of a string, a global research is more simple than a split (for the same result):returnsTo deal with dromedary too, you can use:Note: (?=[A-Z]|$) can be shorten using a double negation (a negative lookahead with a negated character class): (?![^A-Z])
The documentation for python's re.split says:Note that split will never split a string on an empty pattern match.When seeing this:it becomes clear, why the split does not work as expected. The remodule finds empty matches, just as intended by the regular expression.Since the documentation states that this is not a bug, but rather intended behavior, you have to work around that when trying to create a camel case split:
I just stumbled upon this case and wrote a regular expression to solve it. It should work for any group of words, actually.The key here is the lookahead on the first possible case. It will match (and preserve) uppercase words before capitalized ones:
Here's another solution that requires less code and no complicated regular expressions:EditThe above code contains an optimization that avoids rebuilding the entire string with every appended character. Leaving out that optimization, a simpler version (with comments) might look like
I know that the question added the tag of regex. But still, I always try to stay as far away from regex as possible. So, here is my solution without regex:
I think below is the optimim Def count_word():    Return(re.findall(‘[A-Z]?[a-z]+’, input(‘please enter your string’))Print(count_word())


Answer URL
https://docs.python.org/3/library/re.html#re.split
https://docs.python.org/3/library/abc.html
