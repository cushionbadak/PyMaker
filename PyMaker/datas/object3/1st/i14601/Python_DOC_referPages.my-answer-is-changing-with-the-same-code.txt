Natural Text
I am a complete python beginner and I am trying to solve this problem :A number is called triangular if it is the sum of the first n positive  integers for some n For example, 10 is triangular because 10 = 1+2+3+4  and 21 is triangular because 21 = 1+2+3+4+5+6. Write a Python program  to find the smallest 6-digit triangular number. Enter it as your  answer below.I have written this program:And it only works in the python I have installed on my computer if I say while len(str(trinum)) < 8: but it is supposed to be while len(str(trinum)) < 6:. So I went to http://www.skulpt.org/ and ran my code there and it gave me the right answer with while len(str(trinum)) < 6: like it's supposed to. But it doesn't work with 6 with the python i have installed on my computer. Does anyone have any idea what's going on?
Short AnswerIn Python 3, division is always floating point division. So on the first pass you get something like str(trinum) == '0.5'. Which isn't what you want.You're looking for integer division. The operator for that is //. Long AnswerThe division operator changed in Python 2.x to 3.x. Previously, the type of the result was dependent on the arguments. So 1/2 does integer division, but 1./2 does floating point division.To clean this up, a new operator was introduced: //. This operator will always do integer division.So in Python 3.x, this expression (4 * 5)/2 is equal to 10.0. Note that this number is less than 100, but it has 4 characters in it.If instead, we did (4*5)//2, we would get the integer 10 back. Which would allow your condition to hold true.
In Python 2, the / operator performs integer division when possible: "x divided by y is a remainder b," throwing away the "b" (use the % operator to find "b"). In Python 3, the / operator always performs float division: "x divided by y is a.fgh." Get integer division in Python 3 with the // operator.
You have two problems here, that combine to give you the wrong answer.The first problem is that you're using /, which means integer division in Python 2 (and the almost-Python language that Skulpt implements), but float division in Python 3. So, when you run it on your local machine with Python 3, you're going to get floating point numbers.The second problem is that you're not checking for "under 6 digits" you're checking for "under 6 characters long". For positive integers, those are the same thing, but for floats, say, 1035.5 is only 4 digits, but it's 6 characters. So you exit early.If you solve either problem, it will work, at least most of the time. But you really should solve both.So:The first problem is fixed by using //, which always means integer division, instead of /, which means different things in different Python versions.The second problem is fixed by comparing the number as a number to 10**6 (that is, 10 to the 6th power, which means 1 with 6 zeros, or 1000000) instead of comparing its length as a string to 6.
Taking Malik Brahimi's answer further:count(1) is all the numbers from 1 to infinity.accumulate(count(1)) is all the running totals of those numbers.dropwhile(…) is skipping the initial running totals until we reach 100000, then all the rest of them.next(…) is the next one after the ones we skipped.Of course you could argue that a 1-liner that takes 4 lines to describe to a novice isn't as good as a 4-liner that doesn't need any explanation. :)(Also, the dropwhile is a bit ugly. Most uses of it in Python are. In a language like Haskell, where you can write that predicate with operator sectioning instead of a lambda, like (<= 99999), it's a different story.)
The division method in Py2.x and 3.x is different - so that is probably why you had issues.Just another suggestion - which doesn't deal with divisions and lengths - so less buggy in general. Plus addition is addition anywhere. 



Answer URL
https://docs.python.org/3/library/itertools.html#itertools.count
https://docs.python.org/3/library/itertools.html#itertools.accumulate
https://docs.python.org/3/library/itertools.html#itertools.dropwhile
https://docs.python.org/3/library/functions.html#next
