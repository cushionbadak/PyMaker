Natural Text
I want to open a text file, scan for lines which start with RECORD-FEB. If a line starts with RECORD-FEB, I want to find 2 uppercase letters followed by a number (call it number1), followed by a literal $--, then another number (call it number2). If number1 is equal to number2 then I want to add a '@' symbol at the beginning of that line and return the line number, otherwise just continue.Sample patterns in matching lines:My problem is that re.search is not working: it is neither giving a result nor error. Basically, my abc function is not working.Content of filename.txt is like this:
Basic Regex IssueThe biggest problem with your code is the gratuitous use of backslashes and square brackets in your regular expression. Aside from that, you are basically going about solving your problem correctly.Backslashes generally make special characters literal and give special meaning to regular characters. Any time you do \[, you are matching against the literal opening bracket, which you never want to do in your particular application.Square brackets do not indicate literal strings. They set up a character class, which means that any character in the brackets can match the corresponding character in the string. Specifically, [--] does not mean literal double dash. It means "any character that is either a dash or a dash", which is redundant and not what you want.You need to change r"\[A-Z]{2}\d+[$][--]\d+" to the much simpler r"[A-Z]{2}\d+\$--\d+". The only character class you need is [A-Z] for uppercase letters. The only escaped special character you need is \$, to get a literal dollar symbol instead of a match for EOL.Capturing NumbersTo be able to compare the numbers, you need to capture parts of your match. You can do this using parentheses to mark the capture group. Now your regex will look like r"[A-Z]{2}(\d+)\$--(\d+)".You do not need to convert the textual representation of the numbers. If the strings don't match, they don't match.Compiling Regular ExpressionsRight now you are using re.search in every iteration of your loop. This compiles the regex from scratch for every line in the file. Not a big deal for small files, but you will notice a difference for large files.In general, if you find yourself applying a regular expression more than once, consider pre-compiling it using re.compile. You can then use the search method on the compiled regex object, which operates the same way but will be much faster.Line NumbersTo get the line numbers when iterating a file, wrap your file iterator in enumerate:You can pass the line number to abc, to be returned if there is a match, or better yet, you can just eliminate abc entirely.Prepending Elements to a LineAs a rule, it is not practical to modify a file in-place. A file is a collection of bytes on the disk. If you were to insert a @ character into a random location in the file, all the remaining bytes would have to be shifted over. Instead, you usually write to another file, with all lines being identical except the ones you want to change. If you want the insertion to look seamless, you can move the resulting file to overwrite the original when you are done.This means you will have to open an output file. Every line that matches your pattern gets written with the @ prefix. All other lines will be passed-through as-is.CodeCombining all of the above, you get something like this:I've gotten rid of the abc function since it does not do much. All matching line numbers where number1 == number2 get appended into the list matches, which is printed at the end.If you want to overwrite the original file after you are done, do the following:


Answer URL
https://docs.python.org/3/library/re.html#re.search
https://docs.python.org/3/library/re.html#re.compile
https://docs.python.org/3/library/re.html#re.regex.search
https://docs.python.org/3/library/re.html#regular-expression-objects
https://docs.python.org/3/library/functions.html#enumerate
