Natural Text
The first demo:b.__dict__ is {}, but the second demo:b.__dict__ is None, why? And b.__dict__ invokes __getattribute__, but don't invoke __getattr__, does it mean __getattribute__ will prevent from invoking __getattr__?
The __getattribute__, __setattr__ and __delattr__ methods are called for all attribute access (getting, setting and deleting). __getattr__ on the other hand is only called for missing attributes; it is not normally already implemented, but if it is then __getattribute__ calls it if it could not otherwise locate the attribute, or if an AttributeError was raised by __getattribute__.You replaced the standard implementations of the 3 main methods with methods that do nothing but print and return None (the default in the absence of an explicit return statement). __dict__ is just another attribute access, and your __getattribute__ method returns None, and never itself calls __getattr__ or raises an AttributeError.From the Customizing attribute access documentation:object.__getattr__(self, name)  Called when an attribute lookup has not found the attribute in the usual places (i.e. it is not an instance attribute nor is it found in the class tree for self).and object.__getattribute__(self, name)  Called unconditionally to implement attribute accesses for instances of the class. If the class also defines __getattr__(), the latter will not be called unless __getattribute__() either calls it explicitly or raises an AttributeError.(Bold emphasis mine).Either call the base implementation (via super().__getattribute__) or raise an AttributeError:Note that by calling super().__getattribute__ the actual __dict__ attribute is found. By raising an AttributeError instead, __getattr__ was called, which also returned None.


Answer URL
https://docs.python.org/3/reference/datamodel.html#customizing-attribute-access
