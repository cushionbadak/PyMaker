Natural Text
I expanded and added as a new question.I have a list:Then I recognize which value occurs most often, which value I retain in the variable i2:Later all values that repeat are increased by 10, but in addition to the maximum values. This is the code that I use:After this operation I get:As you can see, the most common value is 2, so it remains unchanged. For example, 3 occurs three times and from all three new values are created 3, 3 + 10, 3 + 20. And the same with the rest of the value (except 2).But if the two maximum values are next to each other (or in a longer sequence), I would like to increase each subsequent in such a sequence one by 10, and get:How to do it?I could now do the same on a new loop, but already on the changed list and applying the condition li[i] == li[i+1], but maybe it can be done in the current loop?
First, you should use a collections.Counter to get the counts of the elements in the list and to find the most_common element.Then, you can use a second Counter for the running counts, and reset those to 0, if the current element is the first occurrence of the most common element. Then use that counter to add multiples of 10 to the number, and afterwards increment it.Afterwards, li is [2, 3, 1, 4, 2, 12, 22, 13, 11, 23, 2]
Here is a solution in one block of a nested loop:And it returns:Walkthrough step by step:Counter is a much quicker way to get i2, we want the zero element which is the value (not the count) of the most common element in list.The loop then loops over all unique values in the list, first getting the indices in the list where li is equal the value.Then if val==i2 it initializes multiplier c to 1 and the loop checks for consecutive indices (NB. this loop starts at 1, so first occurrence of any val never touched), if found it increases both the multiplier and the value in li, if not consecutive indices it resets the multiplier to 1.For all other values  it just loops over indices (again from second) increasing the value and the multiplier
I hope I got your question right. Here it is:Notes:based on the frequencies of the elements in the original list li, a dictionary is created (temp) that looks like this:Combined with the [temp[k].pop() if k != pivot else k for k in li] list comprehension, it results in a very (imo at least, love the poping action) elegant way of getting the first part of the requirements; incrementing all elements that are not the most frequent one.For the second, bizarre, requirement, the cleanest way to go about it is with a function (again imo). Every time the function meets the most frequent element, it increments the increment (0 -> 10 -> 20) and every time it finds a different one, it resets it to 0.
Here's my answer, but I think tobias_k's answer is the most elegant yet.


Answer URL
https://docs.python.org/3/library/collections.html#collections.Counter
