Natural Text
Can someone please help me to understand the execution of this code?My questions are the following:What are the multiple print arguments doing? What does gen == 0 mean? Isn't the gen a generator object?Also how is the reduce function remembering what to assign to a and b?And after gen = foo() is called, does execution just switch between the function and the reduce statement?If someone could please map out the functionalities of the generator and the reduce function, that would help a lot! Thanks!
As you note, gen is a generator; all of the tests in the print are nonsensical (if they added call parens to get gen.__next__() then the comparison to 0 and 1 would return True I suppose, but by not calling it, it's guaranteed False).As for reduce, that's in the docs. Each call of the reducer function uses the result of the prior call (stored internally in the reduce function's locals, not visible except when it's passed to the reducer function) as the first argument (on the first call, this is either the optional third argument initializer, or the first call is performed with the first two elements from gen), and the next result from the input iterable as b.So if __next__ had actually been called (consuming the first two values from gen), the first call would use 2 as a and 3 as b; the result (5) would be a for the next call, with b the next value from gen (4), producing 9, etc. Stepping it out the first few steps. you'd see:a = 2, b = 3 -> 5a = 5, b = 4 -> 9a = 9, b = 5 -> 14a = 14, b = 6 -> 20and so on; effectively, it's just using reduce as a slow/ugly form of the sum function.As for your fourth question: Generators are lazy. Execution switches to the generator when the next value is requested, and when it's produced, the generator is "hibernated" until the next value is requested. So in this case, yes, each call of the lambda passed to reduce corresponds to an additional read from gen (two reads for the first call since it needs to get an accumulator value to start), but it's entirely on-demand; there is no true parallelism going on here; when gen resumes, the code that asked it for a value is paused pending the result; when no value is being requested from it, gen is "frozen" indefinitely (not background processing at all).


Answer URL
https://docs.python.org/3/library/functools.html#functools.reduce
