Natural Text
I have objects that each have a unique ID and these objects are inserted to various lists. These objects need to be removed frequently from the middle of its corresponding list which would be O(n) typically, so I'd like to keep their locations in a dict and retrieve the object's location in O(1) each time I want to remove it.In example above, if I simply called del nodes_hash[ID_TO_REMOVE], the corresponding object in node_lsts remains even though it is removed from the dictionary - how should I get it removed from its corresponding list in O(1)?In C++ I can keep the pointers to list neighbors as node member variables (linked list) and look up a node by its memory address, get pointers to its neighbors, unlink that node from its neighbors (thereby removing it from the 'list') and finally free the node. I'm trying to replicate this behavior.
You can easily create a doubly linked list in Python:Being a linked list, this has O(1) insertion and deletion for any given node. If you can keep a reference to each node via a dictionary or some other better-suited data structure, this will allow you average case O(1) access and fast sequential iteration.Note that this is all wasted effort if you're going to have only a few hundred elements in your lists. Pure-Python data structures probably will not be faster than your Python implementation's list data structures for so few elements. Big-O notation ignores the constant term, which can be prohibitively large if you're not dealing with enough elements (e.g. the Coppersmith-Winograd algorithm).
Instead of using a list nested in a dict you can use a dict nested in a dict:Assuming ID_TO_REMOVE is a unique_id you can remove it with:Full code:OUTPUTSince we're now using dictionaries everything is done in O(1) and we avoid the performance issue that was presented when we try to remove an element from a list.


Answer URL
https://docs.python.org/3/library/collections.html#collections.OrderedDict
