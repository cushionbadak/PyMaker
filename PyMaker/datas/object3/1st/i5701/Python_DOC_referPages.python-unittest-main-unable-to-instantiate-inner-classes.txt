Natural Text
I'm trying to understand scope in nested classes in Python. Here is my example code:The creation of class does not complete and I get the error:Trying inner_var = Outerclass.outer_var doesn't work.I get:I am trying to access the static outer_var from InnerClass.Is there a way to do this?
This isn't quite the same as similar things work in other languages, and uses global lookup instead of scoping the access to outer_var. (If you change what object the name Outer is bound to, then this code will use that object the next time it is executed.)If you instead want all Inner objects to have a reference to an Outer because outer_var is really an instance attribute:Note that nesting classes is somewhat uncommon in Python, and doesn't automatically imply any sort of special relationship between the classes. You're better off not nesting. (You can still set a class attribute on Outer to Inner, if you want.)
I think you can simply do:The problem you encountered is due to this:A block is a piece of Python program text that is executed as a unit.  The following are blocks: a module, a function body, and a class  definition.  (...)  A scope defines the visibility of a name within  a block.  (...)  The scope of names defined in a class block is  limited to the class block; it does not extend to the code blocks of  methods – this includes generator expressions since they are  implemented using a function scope. This means that the following will  fail:http://docs.python.org/reference/executionmodel.html#naming-and-bindingThe above means:a function body is a code block and a method is a function, then names defined out of the function body  present in a class definition do not extend to the function body.Paraphrasing this for your case:a class definition is a code block, then names defined out of the inner class definition present in an outer class definition do not extend to the inner class definition.
You might be better off if you just don't use nested classes. If you must nest, try this:Or declare both classes before nesting them:(After this you can del InnerClass if you need to.)
Easiest solution:It requires you to be explicit, but doesn't take much effort. 
In Python mutable objects are passed as reference, so you can pass a reference of the outer class to the inner class.
All explanations can be found in Python Documentation The Python TutorialFor your first error <type 'exceptions.NameError'>: name 'outer_var' is not defined. The explanation is:There is no shorthand for referencing data attributes (or other methods!) from within methods. I find that this actually increases the readability of methods: there is no chance of confusing local variables and instance variables when glancing through a method.quoted from The Python Tutorial 9.4For your second error <type 'exceptions.NameError'>: name 'OuterClass' is not definedWhen a class definition is left normally (via the end), a class object is created.quoted from The Python Tutorial 9.3.1So when you try inner_var = Outerclass.outer_var, the Quterclass hasn't been created yet, that's why name 'OuterClass' is not definedA more detailed but tedious explanation for your first error:Although classes have access to enclosing functions’ scopes, though, they do not act  as enclosing scopes to code nested within the class: Python searches enclosing functions  for referenced names, but never any enclosing classes. That is, a class is a local scope  and has access to enclosing local scopes, but it does not serve as an enclosing local scope  to further nested code. quoted from Learning.Python(5th).Mark.Lutz


Answer URL
