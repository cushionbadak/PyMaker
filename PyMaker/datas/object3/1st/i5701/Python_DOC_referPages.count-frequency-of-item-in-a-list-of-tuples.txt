Natural Text
I have a list of tuples as shown below. I have to count how many items have a number greater than 1. The code that I have written so far is very slow. Even if there are around 10K tuples, if you see below example string appears two times, so i have to get such kind of strings. My question is what is the best way to achieve the count of strings here by iterating over the generatorList:My code so far:
You've got the right idea extracting the first item from each tuple. You can make your code more concise using a list/generator comprehension, as I show you below.From that point on, the most idiomatic manner to find frequency counts of elements is using a collections.Counter object.Extract the first elements from your list of tuples (using a comprehension)Pass this to CounterQuery count of exampleSure, you can use list.count if it’s only one item you want to find frequency counts for, but in the general case, a Counter is the way to go.The advantage of a Counter is it performs frequency counts of all elements (not just example) in linear (O(N)) time. Say you also wanted to query the count of another element, say foo. That would be done with -If 'foo' doesn’t exist in the list, 0 is returned.If you want to find the most common elements, call counts.most_common - Where n is the number of elements you want to display. If you want to see everything, don't pass n.To retrieve counts of most common elements, one efficient way to do this is to query most_common and then extract all elements with counts over 1, efficiently with itertools.(OP edit) Alternatively, use a list comprehension to get a list of items having count > 1 - Keep in mind that this isn’t as efficient as the itertools.takewhile solution. For example, if you have one item with count > 1, and a million items with count equal to 1, you’d end up iterating over the list a million and one times, when you don’t have to (because most_common returns frequency counts in descending order). With takewhile that isn’t the case, because you stop iterating as soon as the condition of count > 1 becomes false.
First method :What about without loop ?output:Second method :You can calculate using simple dict , without importing any external module or without making it so complex:output:Test_case :output:
Time it took me to do this  ayodhyankit-paul  posted the same - leaving it in non the less for the generator code  for testcases and timing:Creating 100001 items took roughly 5 seconds, counting took about 0.3s,filtering on counts was too fast to measure (with datetime.now() - did not bother with perf_counter) - all in all it took less then 5.1s from start to finish for about 10 times the data you operate on.I think this similar to what Counter in COLDSPEEDs answer does: foreach item in list of tuples:if item[0] not in list, put into dict with count of 1else increment count in dict by 1Code:Output:
Let me give you an example to make you understand.Although this example is very much different than your example, I found it very helpful while solving these type of questions.Now this is your example solved in the above manner


Answer URL
https://docs.python.org/3/library/time.html#time.perf_counter
