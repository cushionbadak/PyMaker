Natural Text
Let's quote numpy manual: https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#advanced-indexingAdvanced indexing is triggered when the selection object, obj, is a non-tuple sequence object, an ndarray (of data type integer or bool), or a tuple with at least one sequence object or ndarray (of data type integer or bool). There are two types of advanced indexing: integer and Boolean.Advanced indexing always returns a copy of the data (contrast with basic slicing that returns a view).Then operating on what was returned by advanced indexing should never modify the original array. And indeed:This prints:However, this does not always seem to be the case. Oddly if I don't save whatever was returned by the [] operator to an intermediate variable I am somehow operating on the original array. Please consider this example:This prints:I do not complain. Actually, this is a life saver for me. Yet, I fail to understand why does this work and I'd really like to understand this.To my best understanding, as soon as I write arr[indexes] I am creating a copy of the array; so the subsequent *= 5 should operate on this copy and not on the original array. The result of this calculation should, however, be discarded, since it is not written to any variable.Yet manifestly I am wrong.Where is my misunderstanding?
While statementsandlook similar, they are actually fundamentally different. The first binds the name 'a' to expr.The second is more or less equivalent to a.__setitem__(x, expr). What __setitem__ actually does is up to whoever implemented it, but the conventional semantics is to update the container object a at the position indicated by x with expr.In particular, no intermediate object "representing a[x]" is created.Just for the sake of completeness a[x] if it is not on the l.h.s. of what syntactically looks like an assignment is more or less equivalent to a.__getitem__(x).Update in response to a follow-up question (What happens when a[x] *= 5 is executed?) let us instrument the relevant methods so we can see what is going on. Below, __imul__ is the in-place multiplication "magic method":Prints:
The key point here is Advanced indexing always returns a copy of the data In your second example you're not using the index to return anything. You're only using the index to modify the values. So the object that you're modifying is the original object. Not the copy.


Answer URL
https://docs.python.org/3/reference/datamodel.html#emulating-container-types
