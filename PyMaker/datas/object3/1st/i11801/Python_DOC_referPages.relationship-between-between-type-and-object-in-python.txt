Natural Text
I'n reading through http://blog.thedigitalcatonline.com/blog/2014/09/01/python-3-oop-part-5-metaclasses/#.Vv1T7zG1XGA ,  which contains:Since in Python everything is an object, everything is the instance of a class, even classes. Well, type is the class that is instanced to get classes. So remember this: object is the base of every object, type is the class of every type. Sounds puzzling? It is not your fault, don't worry. However, just to strike you with the finishing move, this is what Python is built onI'm having trouble understanding this, Can anyone explain this relationship in a different way to make it clearer? 
The relationship between type(x) is basically the same as the result of x.__class__:__bases__ represents the bases that a class is derived from:however if you are asking about the odd relationship between object and type:that is more of a chicken vs. egg question: which came first?The answer is PyObject which is defined in C.before either object or type is available to the python interpreter their underlying mechanisms are defined in C and the instance checking is overrided after they are defined. (act like abstract classes, see PEP 3119)you can consider it something like this python implementation:actually it may be better represented as:but again if you want to know exactly how it works you would need to look at the source code written in C.
TL;DR - probably not. But I tried.This is really weird and feels like turtles all the way down. I've actually not delved into this arena very much before, though it's something that sounded fun and powerful. This explanation was confusing, and so was the rest of the information on that page, but I feel like I have some enlightenment. Whether or not I can explain that clearly, I'm not sure, but I'll have a go.Let's look at the turtles, first:Wait, what?How is object an instance of type, when type is an instance of object? That feels like saying something like:Should be True both times. But obviously it's not. Even (as Tadhg McDonald-Jensen pointed out)This should indicate to you that there is some magic going on behind the scenes. So at this point, let's just completely forget about Python (I know, why would we ever want to do such a horrible thing?)In general, all computer programs are are 1's and 0's (and more accurately they're just a bunch of logic gates and electrons at >~2.5v and ~<2.5v, but 0's and 1's are good enough). Whether you wrote it in assembly, actual machine code, Python, C#, Java, Perl, whatever - they're all just bits.If you write a class definition, that class is just bits. An instance of that class is just more bits. And a programming language and a compiler and an interpreter is just even more bits.In the case of Python, it's the python interpreter that gives meaning to the bits that are our Python programs. As an interesting point, a lot of what we typically consider to be Python is actually written in Python (though most of it is C, for us CPython folks, Java for Jython, etc.).So now we come to this thing we call type and object. As the article points out, they're kind of special. So, we know that we can create a class, and then that class is an object:Which makes sense, if you think about it - you may have created class-level variables:But as this last example shows (and is mentioned in the post), a class declaration, what you get with class SomeClass: pass, that declaration of a class is actually an instance of another class. In particular, it's an instance of the type class. And that instance (which we call a class) when called will produce an instance of itself:So what does all this have to do with the relationship between type and object?Well, somewhere, python creates a series of bits that is object, and a series of bits that is type, and then wires them together in such a way thatBecause I currently don't feel like looking through the source, I'm going to make a guess that type is created first, and object is produced from that type and that type.__bases__ is set to (class 'object'). By creating this circular relationships between type and object, it gives the appearance that it's just turtles all the way down, when really the last two turtles are just standing on top of each other.I don't think there's really a better way to explain what's going on here than how the article describes it - at least in a classical OOP is-a/has-a style of thinking, because it's not actually that sort of thing. Like trying to plot a 3d figure in 2d space, you're going to have problems.It's just two sets of bits that have some bits inside them that happen to be the address of one another.
While my first answer addresses the paradoxical relationship between the python builtin variables type and object, it doesn't necessarily try to clear up the confusion about what exactly type and object mean in the bigger picture.  This answer will explain how object and type affect other python objects in the context that you will likely see in practice.In Python everything is an objectThis means that the statement isinstance(x, object) will always give True for any possible value x. This also means that any class that is defined will be considered a subclass of object. So issubclass(x, object) is always true for any class.Practically this means operations that are standard across all python objects will be defined in object, things like attribute lookup and getting the size of an object in memory.  It also defines behaviours that are commonly overridden like converting to a string or initialization, so if you don't override __str__ or __init__ in your subclass it will still do something reasonable.type is the class that is instanced to get classesThis means that all classes are considered instances of type. So isinstance(x, type) will be true for all classes. When I say classes I mean things like int, str, bool or the variable created by the class keyword.everything is an object -  even classes.This means that the standard behaviour that exists for all objects is also applied to class objects.  So writing str.join will lookup the join method and give you <method 'join' of 'str' objects>type is the class of every typeso in the same way that int defines what 1+3 should do or str defines methods for strings, type defines behaviour that is specific to type objects. For example calling a class object (like int("34")) will create a new instance of that class - this behaviour of creating new objects is defined in type.__call__ method.As a more concrete example look at the duality between str.join and type.mroSo every class defines methods that act on its instances, behaviours of classes themselves is defined in the type class. Behaviour that is common to all objects - the kind of things you usually just write off as builtin - are defined by object so all objects share those behaviours (unless a subclass overrides it :)P.S. In the same way you can make a subclass of str to create special string objects that have different behaviour, you can create a subclass of type to create special classes that have different behaviour.  This is called a meta-class (the class of a class object) and the practical applications of using meta-classes are usually abstract. (pun intended)


Answer URL
https://docs.python.org/3/library/abc.html#abc.ABCMeta
