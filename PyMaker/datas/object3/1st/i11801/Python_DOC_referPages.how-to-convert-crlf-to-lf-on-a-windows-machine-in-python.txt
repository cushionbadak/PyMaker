Natural Text
So I got those template, they are all ending in LF and I can fill some terms inside with format and still get LF files by opening with "wb"Those templates are used in a deployment script on a windows machine to deploy on a unix server.Problem is, a lot of people are going to mess with those template, and I'm 100% sure that some of them will put some CRLF inside.How could I, using python convert all the crlf to lf?Thanks.EDITWell, my bad, I had a bug in my code, opening in "wb" always put lf at the end of the lines even if the file was using crlf before.Here is the code I'm using if you are wondering :So no problem, everything is working fine :x
Convert Line Endings in-place (with Python 3)Windows to Linux/UnixHere is a short script for directly converting Windows line endings (\r\n also called CRLF) to Linux/Unix line endings (\n also called LF) in-place (without creating an extra output file):Linux/Unix to WindowsJust swap the constants for the line endings in the str.replace() call like so: content.replace(UNIX_LINE_ENDING, WINDOWS_LINE_ENDING).Code ExplanationImportant: Binary Mode We need to make sure that we open the file both times in binary mode (mode='rb' and mode='wb') for the conversion to work.When opening files in text mode (mode='r' or mode='w' without b), the platform's native line endings (\r\n on Windows and \r on old Mac OS versions) are automatically converted to Python's Unix-style line endings: \n. So the call to content.replace() couldn't find any \r\n line endings to replace.In binary mode, no such conversion is done. Therefore the call to str.replace() can do its work.Binary Strings In Python 3, if not declared otherwise, strings are stored as Unicode (UTF-8). But we open our files in binary mode - therefore we need to add b in front of our replacement strings to tell Python to handle those strings as binary, too.Raw Strings On Windows the path separator is a backslash \ which we would need to escape in a normal Python string with \\. By adding r in front of the string we create a so called "raw string" which doesn't need any escaping. So you can directly copy/paste the path from Windows Explorer into your script.(Hint: Inside Windows Explorer press CTRL+L to automatically select the path from the address bar.)Alternative We open the file twice to avoid the need of repositioning the file pointer. We also could have opened the file once with mode='rb+' but then we would have needed to move the pointer back to start after reading its content (open_file.seek(0)) and truncate its original content before writing the new one (open_file.truncate(0)).Simply opening the file again in write mode does that automatically for us.Cheers and happy programming,winklerrr
Python's open function supports the 'rU' mode for universal newlines, in which case it doesn't mind which sort of newline each line has. In Python 3 you can also request a specific form of newline with the newline argument for open. Translating from one form to the other is thus rather simple in Python:(Due to the newline argument, the U is actually deprecated in Python 3; the equivalent form is newline=None.)
why don't you try below::str.replace('\r\n','\n');CRLF => \r\nLF => \nit's history of typewriter =)
It is possible to fix existing templates with messed-up ending with this code:


Answer URL
https://docs.python.org/3/library/functions.html#open
