Natural Text
I've seen several basic Python 3.5 tutorials on asyncio doing the same operation in various flavours.In this code:All the three variants above that define the futures variable achieve the same result; the only difference I can see is  that with the third variant the execution is out of order (which should not matter in most cases). Is there any other difference? Are there cases where I can't just use the simplest variant (plain list of coroutines)?
Actual info:Starting from Python 3.7 asyncio.create_task(coro) high-level function was added for this purpose. You should use it instead other ways of creating tasks from coroutimes. However if you need to create task from arbitrary awaitable, you should use asyncio.ensure_future(obj).Old info:ensure_future vs create_taskensure_future is a method to create Task from coroutine. It creates tasks in different ways based on argument (including using of create_task for coroutines and future-like objects).create_task is an abstract method of AbstractEventLoop. Different event loops can implement this function different ways.You should use ensure_future to create tasks. You'll need create_task only if you're going to implement your own event loop type.Upd:@bj0 pointed at Guido's answer on this topic:The point of ensure_future() is if you have something that could  either be a coroutine or a Future (the latter includes a Task because  that's a subclass of Future), and you want to be able to call a method  on it that is only defined on Future (probably about the only useful  example being cancel()). When it is already a Future (or Task) this  does nothing; when it is a coroutine it wraps it in a Task.If you know that you have a coroutine and you want it to be scheduled,  the correct API to use is create_task(). The only time when you should  be calling ensure_future() is when you are providing an API (like most  of asyncio's own APIs) that accepts either a coroutine or a Future and  you need to do something to it that requires you to have a Future.and later:In the end I still believe that ensure_future() is an appropriately  obscure name for a rarely-needed piece of functionality. When creating  a task from a coroutine you should use the appropriately-named  loop.create_task(). Maybe there should be an alias for that  asyncio.create_task()?It's surprising to me. My main motivation to use ensure_future all along was that it's higher-level function comparing to loop's member create_task (discussion contains some ideas like adding asyncio.spawn or asyncio.create_task).I can also point that in my opinion it's pretty convenient to use universal function that can handle any Awaitable rather than coroutines only.However, Guido's answer is clear: "When creating a task from a coroutine you should use the appropriately-named loop.create_task()"When coroutines should be wrapped in tasks?Wrap coroutine in a Task - is a way to start this coroutine "in background". Here's example:Output:You can replace asyncio.ensure_future(long_operation()) with just await long_operation() to feel the difference.
create_task()accepts coroutines, returns Task, it is invoked in context of the loop.ensure_future()accepts Futures, coroutines, awaitable objects,returns Task (or Future if Future passed). if the given arg is a coroutine it uses create_task,loop object can be passed. As you can see the create_task is more specific.async function without create_task or ensure_futureSimple invoking async function returns coroutineAnd since the gather under the hood ensures (ensure_future) that args are futures, explicitly ensure_future is redundant.Similar question What's the difference between loop.create_task, asyncio.async/ensure_future and Task?
Note: Only valid for Python 3.7 (for Python 3.5 refer to the earlier answer).From the official docs:asyncio.create_task (added in Python 3.7) is the preferable way for spawning new tasks instead of ensure_future(). Detail:So now, in Python 3.7 onwards, there are 2 top-level wrapper function (similar but different):asyncio.create_task: which simply call event_loop.create_task(coro) directly. (see source code)ensure_future which also call event_loop.create_task(coro) if it is coroutine or else it is simply to ensure the return type to be a asyncio.Future. (see source code). Anyway, Task is still a Future due to its class inheritance (ref). Well, utlimately both of these wrapper functions will help you call BaseEventLoop.create_task. The only difference is ensure_future accept any awaitable object and help you convert it into a Future. And also you can provide your own event_loop parameter in ensure_future. And depending if you need those capability or not, you can simply choose which wrapper to use.
for your example, all the three types execute asynchronously. the only difference is that, in the third example, you pre-generated all 10 coroutines, and submitted to the loop together. so only the last one gives output randomly.


Answer URL
https://docs.python.org/3/library/asyncio-task.html#creating-tasks
https://docs.python.org/3/library/asyncio-task.html#asyncio.Task
https://docs.python.org/3/library/asyncio-task.html#coroutines
https://docs.python.org/3/library/asyncio-future.html#asyncio.Future
https://docs.python.org/3/library/asyncio-eventloops.html#asyncio.AbstractEventLoopPolicy.get_event_loop
https://docs.python.org/3/library/asyncio-task.html#asyncio.ensure_future
