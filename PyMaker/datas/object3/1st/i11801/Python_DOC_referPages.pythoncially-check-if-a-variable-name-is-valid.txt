Natural Text
tldr; see the final line; the rest is just preamble.  I am developing a test harness, which parses user scripts and generates a Python script which it then runs. The idea is for non-techie folks to be able to write high-level test scripts.I have introduced the idea of variables, so a user can use the LET keyword in his script. E.g. LET X = 42, which I simply expand to X = 42. They can then use X later in their scripts - RELEASE CONNECTION XBut what if someone writes LET 2 = 3? That's going to generate invalid Python. If I have that X in a variable variableName, then how can I check whether variableName is a valid Python variable?
In Python 3 you can use str.isidentifier() to test whether a given string is a valid Python identifier/name.The last example shows that you should also check whether the variable name clashes with a Python keyword:So you could put that together in a function:Another option, which works in Python 2 and 3, is to use the ast module:This will parse the assignment statement without actually executing it. It will pick up invalid identifiers as well as attempts to assign to a keyword. In the above code None is an arbitrary value to assign to the given name - it could be any valid expression for the RHS.
You could use exceptions handling and catch actually NameError and SyntaxError. Test it inside try/except block and inform user if there is some invalid input.
You could try a test assignment and see if it raises a SyntaxError:
In Python 3, as above, you can simply use str.isidentifier. But in Python 2, this does not exist.The tokenize module has a regex for names (identifiers): tokenize.Name. But I couldn't find any documentation for it, so it may not be available everywhere. It is simply r'[a-zA-Z_]\w*'. A single $ after it will let you test strings with re.match.The docs say that an identifier is defined by this grammar:Which is equivalent to the regex above. But we should still import tokenize.Name in case this ever changes. (Which is very unlikely, but maybe in older versions of Python it was different?)And to filter out keywords, like pass, def and return, use keyword.iskeyword. There is one caveat: None is not a keyword in Python 2, but still can't be assigned to. (keyword.iskeyword('None') in Python 2 is False).So:
You can just let Python (works on any version in use today, as far as I know) do the check for you they way it normally would internally, and catch the exception:Notably, TypeError is consistently raised whenever a dict undergoes keyword argument expansion and has a key which isn't a valid function argument, and whenever a dict literal is being constructed with an invalid key.The advantage over the accepted answer is that it is both compatible across both Python 3 and 2, and not as fragile as the ast.parse/compile approach (which would count strings like foo = bar; qux as valid).I haven't thoroughly audited this solution or written Hypothesis tests for it to fuzz it, so there might be some corner case, but it seems to generally work on Python 3.7, 3.6, 2.7, and 2.5 (not that anyone ought to be using 2.5 nowadays, but it's still out in the wild and you might be one of the few poor sods stuck having to write code that works with 2.6/2.5).
I don't think you need the exact same naming syntax as python itself.Would rather go for a simple regexp like:to make sure it's something alphanumeric, and then add a prefix to keep away from python's own syntax. So the non-techie user's declaration:should probably become after your parsing:


Answer URL
https://docs.python.org/3/library/stdtypes.html?highlight=identifier#str.isidentifier
https://docs.python.org/3/library/stdtypes.html#str.isidentifier
