Natural Text
I have a somewhat bizarre metaclass question. I'm using a meta class to dynamically create a 'sibling' class that inherits from another superclass and assign it as an attribute on the original class. Below is a minimal setup:Something seems to be going wrong above with the creation of the 'sibling' class but I'm not quite sure what. I know for example that this would work:I can't see the difference between the two cases though.
The dictionary sdct passed to type includes __qualname__, which according to this PEP is what repr and str now use.Try addingand you'll see that it is truly the sibling.As to why sibling().x throws, the very same sdct also already contains Child.__init__, which ends up as __init__ of your dynamically created new type ChildSibling. During a call to sibling() the super() call resolves the class to Child and is given an instance of ChildSibling:Also note that, aside from the zero argument form, super() is not limited to use inside methods. The two argument form specifies the arguments exactly and makes the appropriate references. The zero argument form only works inside a class definition, as the compiler fills in the necessary details to correctly retrieve the class being defined, as well as accessing the current instance for ordinary methods.https://docs.python.org/3/library/functions.html#superAccessing the current instance is done by passing the first argument to method as instance.super() -> same as super(__class__, <first argument>)The error is raised at line 7210 of Object/typeobject.c.Try removing the wrong __init__ in your __new__ with:and nowwill print 3.A solution to "generic" inheritance and meta programming friendlier __init__ is to use the 2 argument form of super():


Answer URL
https://docs.python.org/3/library/functions.html#super
