Natural Text
The problemlet's assume we're working with a large dataset and for the sake of simplicity we use this smaller one in this question:and we want to find out which column has the longest range of consecutive values, what would be the fastest way to find out, which is the best column? The naive approachI found out it quickly can be sorted by each column withBut here comes the laggy part: we could go on from here and do a for loop for each of the sorted datasets, and count the consecutive elements but when it comes to processing for loops python is very slow.Now my the question: is there a faster way than this naive approach, is there maybe even an built-in function for these 2D-containers?Update:More precisely the meaning of a range can be described by this pseudo algorithm - this includes incrementing if current value == next value: 
You can do this with reasonable efficiency using groupby. I'll do this in stages, so you can see how it works.outputNow, to attack your actual question:outputFWIW, this can be condensed into a single line. It's a little more efficient since it uses a couple of generator expressions instead of list comprehensions, but it's not particularly readable:UpdateWe can handle your new consecutive sequence definition by making a few minor changes.Firstly, we need a key function that returns True if the difference between an adjacent pair of numbers in a sorted column is <= 1.And instead of taking the length of the sequences which match that key function we now do some simple arithmetic to see the size of the range of values in the sequence.Putting it all together:Update 2As noted in the comments, max raises ValueError if its arg is an empty sequence. A simple way to handle that is to wrap the max call in a try..except block. This is quite efficient if the exception happens rarely, try..except is actually faster than equivalent if...else logic when the exception isn't raised. So we could do something like this:But if that exception happens fairly frequently it's better to use another approach. Here's a new version that uses a fully-fledged generator function, find_runs, in place of the generator expression. find_runs simply yields a zero before it starts processing the column data so max will always have at least one value to process. I've inlined the runlen calculation to save on the overhead of an additional function call. This refactoring also makes it easier to build the runs list in a list comprehension.output


Answer URL
https://docs.python.org/3/library/functions.html#max
