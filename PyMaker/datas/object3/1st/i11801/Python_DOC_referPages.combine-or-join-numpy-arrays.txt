Natural Text
How can I join two numpy ndarrays to accomplish the following in a fast way, using optimized numpy, without any looping?
Let's walk through a prospective solution to handle generic cases involving different shaped arrays with some inlined comments to explain the method involved. (1) First off, we store shapes of input arrays.(2) Next up, initialize a 3D array with number of columns being the sum of number of columns in input arraysa and b. Use np.empty for this task.(3) Then, set the first axis of the 3D array for the first "na" columns with the rows from a with a[:,None,:]. So, if we assign it to out[:,:,:na], that second colon would indicate to NumPy that we need a broadcasted setting, if possible as always happens with singleton dims in NumPy arrays. In effect, this would be same as tiling/repeating, but possibly in an efficient way.(4) Repeat for setting elements from b into output array. This time we would broadcast along the first axis of out with out[:,:,na:], with that first colon helping us do that broadcasting.(5) Final step is to reshape the output to a 2D shape. This could be done with simply changing the shape with the required 2D shape tuple. Reshaping just changes view and is effectively zero cost.Condensing everything, the full implementation would look like this -
Not the prettiest, but you could combine hstack, repeat, and tile:Or for a 3x3 case:
What you want is, apparently, the cartesian product of a and b, stacked horizontally. You can use the itertools module to generate the indices for the numpy arrays, then numpy.hstack to stack them:This results in a c of:Breaking down the indices thing:product(range(len(a)), range(len(b)) will generate something that looks like this if you convert it to a list:You want something like this: [0, 0, 1, 1], [0, 1, 0, 1], so you need to transpose the generator. The idiomatic way to do this is with zip(*zipped_thing). However, if you just directly assign these, you'll get tuples, like this:But numpy arrays interpret tuples as multi-dimensional indexes, so you want to turn them to lists, which is why I mapped the list constructor onto the result of the product function.
You can use dstack() and broadcast_arrays():
All arrays are indexable, so you can merge the by just calling:or you can use core numpy stacking functions, should look something like this:


Answer URL
https://docs.python.org/3/library/itertools.html
