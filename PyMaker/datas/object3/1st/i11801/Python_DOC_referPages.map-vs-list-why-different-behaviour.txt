Natural Text
In the course of implementing the "Variable Elimination" algorithm for a Bayes' Nets program, I encountered an unexpected bug that was the result of an iterative map transformation of a sequence of objects.For simplicity's sake, I'll use an analogous piece of code here:This is definitely the wrong result.  Since [4, 5, 6] contains two even numbers, 10 should be added to each element at most twice.  I was getting unexpected behaviour with this in the VE algorithm as well, so I modified it to convert the map iterator to a list after each iteration.From my understanding of iterables, this modification shouldn't change anything, but it does.  Clearly, the n + 10 transform for the not x % 2 case is applied one fewer times in the list-ed version.My Bayes Nets program worked as well after finding this bug, but I'm looking for an explanation as to why it occurred.
The answer is very simple: map is a lazy function in Python 3, it returns an iterable object (in Python 2 it returns a list). Let me add some output to your example:Note the In[8] - the value of x is 6. We could also transform the lambda function, passed to map in order to track the value of x:Because map is lazy, it evaluates when list is being called. However, the value of x is 6 and that is why it produces confusing output. Evaluating nums inside the loop produces expected output.
The issue has to do with how the x variable is accessed by the lambda functions you are creating. The way Python's scoping works, the lambda functions will always use the latest version of x from the outside scope when they're called, not the value that it had when they were defined.Since map is lazy, the lambda functions don't get called until after the loop (when you consume the nested maps by passing them to list) and so, they all use the last x value.To make each lambda function save the value x has when they are defined, add x=x like this:This specifies an argument and its default value. The default will be evaluated at the time the lambda is defined, so when the lambda gets called later (without a second argument), the x inside the expression will be that saved default value.
If you want to use the lazy version, you need to fix x in each loop.functools.partial does exactly that:


Answer URL
https://docs.python.org/3/library/functions.html#map
https://docs.python.org/3/library/functools.html#functools.partial
