Natural Text
Say I already have a method with type annotations:Which I will then subclass multiple times:As you can see, I'm duplicating the -> float quite a lot. Say I have 10 different shapes, with multiple methods like this, some of which contain parameters too. Is there a way to just "copy" the annotation from the parent class, similar to what functools.wraps() does with docstrings?
This might work, though I'm sure to miss the edge cases, like additional arguments:which will assign "wrapper" function's __annotations__ attribute from f.__annotations__ (keep in mind that it is not a copy).According to documents the update_wrapper function's default for assigned includes __annotations__ already, but I can see why you'd not want to have all the other attributes assigned from wrapped.With this you can then define your Circle and Rectangle asand the resultAs a side effect your methods will have an attribute __wrapped__, which will point to Shape.area in this case.A less standard (if you can call the above use of update_wrapper standard) way to accomplish handling of overridden methods can be achieved using a class decorator:and then:Again, this will not handle overriding methods with additional arguments.
You can use a class decorator to update your subclass methods annotations. In your decorator you will need to walk through your class definition then update only those methods that are present in your superclass. Of course to access the superclass you need to use the it __mro__ which is just the tuple of the class, subclass, till object. Here we are interested in the second element in that tuple which is at index 1 thus __mro__[1] or using the cls.mro()[1]. Last and not least your decorator must return the class.Demo:


Answer URL
https://docs.python.org/3/library/functools.html#functools.update_wrapper
