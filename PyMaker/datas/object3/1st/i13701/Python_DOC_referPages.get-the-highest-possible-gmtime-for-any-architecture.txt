Natural Text
I am having a problem which started here. I found out why and am not trying to solve something else. What I need is to set CherryPy to the longest possible session time that is available on different platforms. For this CherryPy uses time.gmtime(). On my Windows 64 Bit I have no problems setting the session timeout 100 years in the future but this does not work on a armhf platform. armhf allows me to set the session to be alive for 22 years. Not I am looking for a way to set the timeout dynamically depending on the architecture. On armhf I tryed using time.gmtime(sys.maxsize) which returned me the date in the year 2038. time.gmtime(sys.maxsize+1) Returns a OverflowError: timestamp out of range for platform time_t error. So I guess that this is the highest date possible. Problem is that doing the same on my Windows machine with 64 bit (where sys.maxsize = 9223372036854775807) time.gmtime(sys.maxsize) returns OSError: [Errno 22] Invalid argument. Is there a way to do this across any architecture/platform?Edit: This issue is not only caused by my code in CherryPy where the timeout value for a session was too high for certain platforms/architectures (mainly arm) but on some of them (Arm7) it is caused by CherryPy internaly too. 
time.gmtime() accepts a float and therefore its input is limited by sys.float_info.max or an int in the range of C long (or long long if available).To find "the highest date possible" we could use a binary search like in@BlackJack's answer:where binary_search() is a custom function that is used to accept input outside of bisect.bisect() range:Results on my machine:67768036191676799 Python 3 max gmtime() timestamp corresponds to max 32-bit int year:In general, Python time.gmtime() delegates to the platform C gmtime() function:Most of the functions defined in this module call platform C library  functions with the same name. It may sometimes be helpful to consult  the platform documentation, because the semantics of these functions  varies among platforms.The corresponding function signature in C11:time_t limits are implementation-defined in C:The range and precision of times representable in clock_t and time_t  are implementation-defined.time_t is required to be a real type on c11:i.e., in principle time_t may be an extended integer type or e.g., a long double.time_t is an integer type on POSIXmax time_t may be larger than sys.maxsize e.g., time_t may be a 64-bit type on 32-bit system.See also:Maximum values for time_t (struct timespec)What is the biggest useful value of time_t?It is possible to find the max gmtime() timestamp without knowing time_t limit:The result is the same.If TZ=right/UTC then the result is 67768036191676825 that corresponds to the same max time 2147485547-12-31 23:59:59 UTC. right/UTC timestamp is larger because it includes leap seconds (26 as of 2015-07-01).
Highest possible value for time.gmtime for given python version is determined by highest possible value of time_t type this python is compiled with. Minimal sane time_t for any architecture python is running on is 32 bit signed integer (Python documentation says that minimal sys.maxint is 2**31-1). That means that answer is time.gmtime(2 ** 31 - 1) == time.gmtime(2147483647) == time.struct_time(tm_year=2038, tm_mon=1, tm_mday=19, tm_hour=3, tm_min=14, tm_sec=7, tm_wday=1, tm_yday=19...).See also https://en.wikipedia.org/wiki/Year_2038_problem


Answer URL
https://docs.python.org/3/library/time.html
