Natural Text
I wrote a func that I use constantly about 4 months ago and I'm having trouble remembering why I split things off like this:I read the doc on subprocess and see call() essentially does the same thing. Without remembering what happened that day, do any python sysadmins know a meaningful difference in use besides the above func and subprocess.call(["mycommand"])? I see my func doesn't return any exit status, is checking if the command worked the only difference/advantage for call()? Here is what I see todaythanks
subprocess.call(..) is essentially Popen(..).wait() that is different from Popen(..).communicate() if you redirect any of standard streams of the child process e.g., stdout=PIPE or if you need the exit status.subprocess.call() is a convenience function that is built on top of the interface provided by Popen(). If call() works in your case; use it. If it doesn't work; consider other convenience functions such as subprocess.check_output() and only then use Popen() directly.Writing a convenience function that works in your case as you did is a good idea in general (though your particular example is less useful). Popen() can do many things and a convenience function that limits its power makes the code easier to maintain.Don't call p.communicate() unless you need pass input, get output from the subprocess. Don't use shell=True unless you have complete control over the command parameter.
call is a convenience function for a typical use case of Popen. It's simpler to use it instead of the Popen constructor in this case because you are not using output from the executed command.If there is a need to exchange some data with the running child process or for further processing of the command output (stdout, stderr) Popen and communicate would be a better fit.If you're interested in the success of the call, there is another convenience function check_call which will raise an exception if the executed process exits with a non-zero status.


Answer URL
https://docs.python.org/3/library/subprocess.html#subprocess.call
