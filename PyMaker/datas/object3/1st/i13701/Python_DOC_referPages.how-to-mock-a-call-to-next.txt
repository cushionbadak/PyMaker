Natural Text
I am trying to mock a coroutine. As such, this mock's __next__() and close() are called. While mocking close() works, I cannot mock __next__():What am I missing? How to make sure my mock's __next__() method is called?For now, I am using the following:However, I very much rather use a standard mock.
You need to use MagicMock, not Mock, to have magic methods like __next__ available by default:Quoting from the documentation:Mock allows you to assign functions (or other Mock instances) to magic methods and they will be called appropriately. The MagicMock class is just a Mock variant that has all of the magic methods pre-created for you (well, all the useful ones anyway).So, alternatively, you could still use the regular Mock object, but then you need to explicitly add that attribute:That's because although Mock creates attributes on the fly as you access them, any attributes with leading and trailing underscores are explicitly exempted from that. See this footnote:The only exceptions are magic methods and attributes (those that have leading and trailing double underscores). Mock doesnâ€™t create these but instead raises an AttributeError. This is because the interpreter will often implicitly request these methods, and gets very confused to get a new Mock object when it expects a magic method. If you need magic method support see magic methods.But note that the magic methods are usually meant to be looked up on the class, not the instance, so directly adding the __next__ attribute to a Mock instance can still fail; the MagicMock class takes care of this specific issue for you.


Answer URL
https://docs.python.org/3/library/unittest.mock.html#quick-guide
https://docs.python.org/3/library/unittest.mock.html#id3
https://docs.python.org/3/library/unittest.mock.html#magic-methods
