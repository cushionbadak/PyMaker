Natural Text
Using this as a quick starting point;http://pandas.pydata.org/pandas-docs/stable/reshaping.htmlThen isolating 'A' gives this: Now creating new dataframe would be:Lets say B's would be: So, Isolating the dataframes into dfA, dfB, dfC......It runs... But when try dfA I get output "dfA" is not defined
To answer your question literally, globals()['dfA'] = dfNew would define dfAin the global namespace:However, there is never a good reason to define dynamically-named variables.If the names are not known until runtime -- that is, if the names are trulydynamic -- then you you can't use the names in your code since your code hasto be written before runtime. So what's the point of creating a variable nameddfA if you can't refer to it in your code?If, on the other hand, you know before hand that you will have a variablenamed dfA, then your code isn't really dynamic. You have static variable names.The only reason to use the loop is to cut down on boiler-plate code. However,even in this case, there is a better alternative.The solution is to use a dict (see below) or list1.Adding dynamically-named variables pollutes the global namespace.It does not generalize well. If you had 100 dynamically named variables, howwould you access them? How would you loop over them?To "manage" dynamically named variables you would need to keep a list of theirnames as strings: e.g. ['dfA', 'dfB', 'dfC',...] and then accessed the newlyminted global variables via the globals() dict: e.g. globals()['dfA']. Thatis awkward.So the conclusion programmers reach through bitter experience is thatdynamically-named variables are somewhere between awkward and useless and it ismuch more pleasant, powerful, practical to store key/value pairs in a dict. Thename of the variable becomes a key in the dict, and the value of the variablebecomes the value associated with the key. So, instead of having a bare name dfAyou would have a dict dfs and you would access the dfA DataFrame viadfs['dfA']:or, as Jianxun Li shows,This is why Jon Clements and Jianxun Li answered your question by showingalternatives to defining dynamically-named variables.  It's because we allbelieve it is a terrible idea.Using Jianxun Li's solution, to loop over a dict's key/value pairs you could then use:or using Jon Clements' solution, to iterate through groups you could use: 1If the names are numbered or ordered you could use a list instead of a dict.
Use groupby and get_group, eg:Then when you want to do something with each group, access it as such:Gives you:
df.groupby('variable') returns an iterator with key/df pairs. So to get a list/dict of subgroups,


Answer URL
https://docs.python.org/3/library/stdtypes.html#dict.items
