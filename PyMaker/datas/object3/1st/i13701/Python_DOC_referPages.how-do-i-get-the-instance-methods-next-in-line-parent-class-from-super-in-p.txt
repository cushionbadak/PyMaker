Natural Text
I'd like to know the type of an instance obtained from super() function.  I tried print(super()) and __print(type(super()))__The result is With those result, I was wondering how super().__init__() calls the correct constructor.
From your comments, you want to know how super knows which method to call next. Super inspects the mro of the instance, knows the current class method it's in, and calls the next one in line. The following demo will work in Python 2 and 3, and in Python 2, it prints the name of each class thanks to the metaclass, so I'll use that output:First the imports and setup to make the printing nicer:Next, we define a function to tell us what's going on based on the super object itselfFinally, we declare a class hierarchy based on the example from the wikipedia entry on C3 linearization, for a sufficiently complex example, note the metaclass repr doesn't work in Python3, but the attribute assignment won't break it. Also note that we use the full super call of super(Name, self) which is equivalent to super() in Python 3, and will still work:Now when we print the mro of Z, we get the method resolution order defined by this algorithm applied to the inheritance tree:And when we call Z(), because our function uses the mro, we'll visit each method in order:And we stop at object.__init__. From the above we can see that super always knows what class of the instance it is in, the class's method that it is currently in, and can deduce from the instance class's MRO where to go next. I'd like to know the name of the base class?If you only want the direct base (or more than one, in the case of multiple inheritance), you can use the __bases__ attribute, which returns a tupleI recommend the inspect module for getting the Method Resolution Order (which super follows based on the original caller's class):Getting it from supersuper().__self_class__ gives the instance class, and super().__thisclass__ gives us the current class. We can use the instance's MRO and look up the class that comes next. I presume you wouldn't do this in the final parent, so I'm not catching an index error:
You can't do what you want with super() directly. Go to the class MRO (see class.__mro__) instead:Here __class__ is the magic closure variable* that references the class the current function was defined in; the above continues to work even when you subclass or mix in additional classes with Derive, even when you produce a diamond inheritance pattern.Demo:Note how the Multiple class inherits from both Derive and Mixin, and the next class in the MRO is thus found to be Mixin, not Base, because Mixin also derives from Base.This copies what super() does; find the next class in the MRO for the instance, relative to the current class.* For background, see Why is Python 3.x's super() magic?


Answer URL
https://docs.python.org/3/library/stdtypes.html?highlight=__mro__#class.__mro__
