Natural Text
First, I wrote a recording class with a flush method:Then, I wanted to flush at exit: when manually stopped, crashed or whatever reason.So I used:And it worked pretty well.But now, I want to record, stop recording, record again, multiple times, with a different buffer size and to a different path. So I have to discard, then instanciate several Recorder. It kind of works, but older Recorder's memory (containing some fat self._big_buffer̀) is not freed since it's retained by atexit. Even when I explicitly call del.I can't atexit.unregister(self._flush) since it's Python 3 only.I would prefer not to reuse existing instances, but discarding older instances and create new ones.How would you handle such a case?
You can try using a weak reference to the atexit handler, so the objectwon't be retained if it is deleted elsewhere:The method is passed as a string in order to avoid a lot of problems withbound method weak references, if you find it disturbing you can always usea BoundMethodWeakref implementation like this one: http://code.activestate.com/recipes/578298-bound-method-weakref/
I would say you're trying to use the wrong tool. The with statement and context managers are a very good tool for this. File IO is the main example that most python users will get introduced to the with statement.Becomes:You can create your own context managers by writing __enter__ and __exit__ methods for your class.You would then use your Recorder object like:
Surely the answer is to allow your Recorder to change paths and buffer characteristics at will. You say "I would prefer not to reuse existing instances, but discarding older instances and create new ones." but you don't give any rationale for that,except perhaps your assumption that the "older Recorder's memory (containing some fat self._big_buffer̀) is not freed since it's retained by atexit", which I believe is incorrect.While it is true that atexit retains a reference to the recorder object, this will only mean that the buffer memory is retained as long as the recorder refers to it. It would be quite easy to add a close() method such asand bingo! No reference to the buffer memory exists, and it is collectable.Your __init__() method should simply register with atexit, then the open() method (which does the rest of what __init__() currently does) can be used multiple times, each one followed by a close() call.In summary, I think your problem cries out for a single object.
You can remove the handle by hand from the (undocumented) atexit._exithandlers list.Hope that helps.


Answer URL
https://docs.python.org/3/library/atexit.html
