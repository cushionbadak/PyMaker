Natural Text
This question already has an answer here:Is floating point math broken?                    28 answers                I'm a beginner python programmer and i'm wondering why this script won't work when inputted a float of 0.30. I've tried other inputs (i.e 0.50, 1.00, 0.10 etc...) and they worked fine. There may be simpler ways to do this calculator, but I just want to know why this script in particular won't work. The script is the following:
The issue occurs because of how internal representation of float works, when you do -You get a result as -And when you subtract 0.05 from this, you get a negative number not a 0.00 . Example to show this -I think since you are dealing with currencies, you can round the number to 2 decimal places at all times, and it should be fine.Example -Or if you do not want to round , you can use decimal.Decimal , in that case you would need to change all elements (to Decimal) , Example - 
Forget floating point, that way lies madness if you don't understand what's going on under the covers.If you want exactness, turn the value into an integer as soon as possible:You'll also notice I've cleaned up your coin detection code. There is no need to check both ends of the range (e.g., less than a nickel and at least a penny) because you're using elif which means the first part of that condition has already been checked.Of course, there's often a more efficient way to do it if you think about it a bit. A first step would be breaking each step into its own while to isolate each coin count calculation, something like:From there, it's a short step to realising that, once you've worked out all non-penny values, the number of pennies can be done quicker:But there's also a way to figure out each coin count without repeated subtraction, since repeated subtraction is exactly why division was invented :-)
As said by others, floating point representation is not precise. To use more precise decimal representation use fixed point notation with the Decimal class from the decimal Python module[0].[0] https://docs.python.org/3/library/decimal.html
I think your problem is while money != 0.00:Comparing floats is fraught with danger as binary representation of fractions aren't perfect. To compare a float properly you need to subtract one from the other and then see if the result is within some tolerance value which is reasonable for your application.I think using the decimal class would solve your problem and provide a much more sensible solution than trying to make floats work for you.https://docs.python.org/2/library/decimal.htmlFrom the page:Decimal numbers can be represented exactly. In contrast, numbers like 1.1 and 2.2 do not have exact representations in binary floating point. End users typically would not expect 1.1 + 2.2 to display as 3.3000000000000003 as it does with binary floating point.The exactness carries over into arithmetic. In decimal floating point, 0.1 + 0.1 + 0.1 - 0.3 is exactly equal to zero. In binary floating point, the result is 5.5511151231257827e-017. While near to zero, the differences prevent reliable equality testing and differences can accumulate. For this reason, decimal is preferred in accounting applications which have strict equality invariants.


Answer URL
https://docs.python.org/3/library/decimal.html
