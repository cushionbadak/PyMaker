Natural Text
Suppose we have x = ['a', 'b']. What is happening under the hood for the statement:that raises the unhashable type: 'list' error?The workaround I found is to write this instead:but I am confused because, mathematically, both boolean expressions are equivalent.
RationaleHere's what the official documentation states:[Python 3]: class set([iterable]):Return a new set or frozenset object whose elements are taken from iterable. The elements of a set must be hashable.[Python 3]: hashable:An object is hashable if it has a hash value which never changes during its lifetime (it needs a __hash__() method), and can be compared to other objects (it needs an __eq__() method). Hashable objects which compare equal must have the same hash value.  ...  All of Pythonâ€™s immutable built-in objects are hashable; mutable containers (such as lists or dictionaries) are not.[Python 3]: object.__contains__(self, item) (just above the anchor):The membership test operators (in and not in) are normally implemented as an iteration through a sequence. However, container objects can supply the following special method with a more efficient implementation, which also does not require the object be a sequence.Going into [GitHub]: python/cpython - (v3.5.4) cpython/Objects/setobject.c:Line #1991:Line #1843:Line #1823:Line #627:Line #614:As seen from the "callstack" (presented in reversed order), in order to test for membership (in / not in), hash is being performed (on all code paths) on the candidate member ("includee"), and since the list instance doesn't have the hash functionality, the interpreter spits out TypeError.ResolutionThere is a number of ways to get around this (as many others already pointed out most of them):Use a container that doesn't require its elements to be hashable (list, tuple)Test for __hash__ memberWrap the membership test in a try / except blockUse a a hashable container (tuple) for the element: x = ('a', 'b')but (generally) these are just ways to get around the problem (this is my personal opinion), since if you end up comparing a list to None and False, the code (that yields that list) could use some refactoring.
if you can enter all elements you want to test in a set, it means that all unhashable elements don't belong to your set (because you can't put them in)You could do:when object isn't hashable, x.__hash__ is None (other alternatives: Asking "is hashable" about a Python value) and the second part isn't evaluated.or (better ask forgiveness than permission):both solutions are faster than using a list or tuple ((None,False)), because there's no linear search involved (that is if there are a lot of elements in the test list, not true for only 2 elements)
{None, False} is a set. Sets can only contain hashable objects, and therefore you can only test for membership of hashable objects. Lists are not hashable.Instead, you could use a tuple to perform the same sort of membership comparison. Tuple elements do not need to be hashable.
I would like to do a brief comparison on membership tests on set vs listMembership tests invoke __contains__ dunder(if class implement this method). So, if we write it will equivalent to If we do:But why is above case not applicable to sets? Membership tests work in a different way in list and set. Infact list and set are implemented differently. Talking about set, they are implemented using Hash-Table. This allow sets to perform membership test i.e. lookups in O(1) as compared to list where lookups are O(n). So when in is performed on a set, __contains__ try to compute the hash of the object that need to be looked using __hash__. Since lists are unhashable in python, you get the error: TypeError: unhashable type: 'list'. If you do same with list you won't get any error since list don't compute hash for membership testing.In short membership tests cannot be performed on sets with an object that is unhashable. Generally speaking all mutable objects(list, sets, dict) are unhashable. 


Answer URL
https://docs.python.org/3/library/stdtypes.html#set
https://docs.python.org/3/glossary.html#term-hashable
https://docs.python.org/3/glossary.html#term-hashable
https://docs.python.org/3/reference/datamodel.html#object.__hash__
https://docs.python.org/3/reference/datamodel.html#object.__eq__
https://docs.python.org/3/reference/datamodel.html#object.__contains__
https://docs.python.org/3/reference/expressions.html#in
https://docs.python.org/3/reference/expressions.html#not-in
https://docs.python.org/3/reference/datamodel.html#object.__contains__
https://docs.python.org/3/reference/datamodel.html#object.__hash__
