Natural Text
According to this answer, a class object cls can be replicated withThis works perfectly for most normal cases. It does not work when the metaclass of cls is not type. My initial naive fix was to doHowever, this is simply pointless. There is no way to know what a metaclass does, as this answer to a related question points out, how it transforms the input dictionary, what additional keywords it requires, etc.The original use of type is almost good enough with a couple of minor exceptions:The __dict__ created by metaclasses that do not end up calling type.__new__ may be of a different type than the usual proxy object.Classes extending the copy will not have the correct metaclass, which may cause unexpected behavior.Any properties or other data descriptors defined in the original metaclass will no longer be available on the class object.I am willing to ignore item #1. It is a corner case that I am willing to document away should I find a viable solution to the other items. Items #2 and #3 can be solved if it were possible to change the metaclass of the copy. I tried (again, naively)This just raised a TypeError, as could be expected:This makes sense in light of the docs:Like its identity, an object’s type is also unchangeable. 1However, the footnote states thatIt is possible in some cases to change an object’s type, under certain controlled conditions. It generally isn’t a good idea though, since it can lead to some very strange behaviour if it is handled incorrectly.What are the conditions under which it is possible to change an object's type, specifically that of a class? Is this one of those cases, and if so, how?NoteI am aware that copy.deepcopy and inheritance are viable alternatives here. For the purpose of this question, I wish to ignore those alternatives and stick with using type-related techniques.
You could use type.__new__(type(cls), cls.__name__, cls.__bases__, dict(cls.__dict__)). This uses the normal type creation process, but creates an instance of type(cls) instead of type.As for the __metaclass__ issue, I think that is because __metaclass__ is usually what is called, so type can't use it.


Answer URL
https://docs.python.org/3/reference/datamodel.html#objects-values-and-types
https://docs.python.org/3/reference/datamodel.html#id8
