Natural Text
I have a utility module that I use to provide data to other scripts. I can't get my head around the best way of utilising this whilst minimising the amount of function calls (which are all, for the sake of the argument, slow).It looks something like this:helper.pyNow, say I need to run get_specific_data1 in a script. In the setup above, I'm importing the module, which means I call slow_process2 on import, unnecessarily. If I nest the assignment of dataset1 and dataset2, but then need to call get_specific_data1 and get_specific_data2 in the same script, I run slow_process1 twice, which again is unnecessary.If I create a Helper class with methods for the get_specific_data functions, which runs slow_process1 or slow_process2 if required, stores the data, and then can access as required when methods are called I can get around this. Is that appropriate?Something like:Apologies if this is a stupid question, but I have limited experience with OOP and don't want to make mistakes up front.Thanks
This is what I meant about using a class with properties, only in this case I've used a custom version of one named lazyproperty. It's considered "lazy" because it only gets computed when when it's accessed, like a regular property, but unlike them, the computed value is effectively cached in a way—changing it into a instance attribute—so it won't be re-computed every time. Caveat: Doing this assumes that the value would be the same no matter when it was calculated and any changes made to it after the first access will be visible to other methods of the same instance of the class in which it was used—i.e they won't see a freshly re-computed value.Once this is done, the methods in the class can just reference self.dataset1 or self.dataset2 as though they were regular instance attributes, and then, if it's the first time, the data associated with it will be computed, otherwise the value previously created value will simply be returned. You can see this happening in the output produced (shown far below).Output:
You might be able to solve this with a lazy loading technique:The side effect here is that if you never get around to examining either of dataset1 or dataset2 they never load.


Answer URL
https://docs.python.org/3/library/functions.html#property
