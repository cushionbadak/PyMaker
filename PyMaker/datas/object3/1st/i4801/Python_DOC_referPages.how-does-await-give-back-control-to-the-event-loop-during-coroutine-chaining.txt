Natural Text
I'm trying my hand at asyncio in Python 3.6 and having a hard time figuring out why this piece of code is behaving the way it is. Example code:Output:Expected Output:My reasoning for expected output:While the compute_sum coroutine is correctly called before the compute_product coroutine, my understanding was that once we hit await asyncio.sleep(5), the control would be passed back to the event loop which would start the execution of the compute_product coroutine. Why is "Returning sum" being executed before we hit the print statement in the compute_product coroutine?
You're right about how the coroutines work; your problem is in how you're calling them. In particular:This calls the coroutine compute_sum and then waits until it finishes.So, compute_sum does indeed yield to the scheduler in that await asyncio.sleep(5), but there's nobody else to wake up. Your print_computation coro is already awaiting compute_sum. And nobody's even started compute_product yet, so it certainly can't run.If you want to spin up multiple coroutines and have them run concurrently, don't await each one; you need to await the whole lot of them together. For example:(It doesn't matter whether awaitable_sum is a bare coroutine, a Future object, or something else that can be awaited; gather works either way.)Or, maybe more simply:See Parallel execution of tasks in the examples section.
Here's how it works.Lets use a main thread for primary reference...The main thread handles events and work from various locations. If there are 3 events fired at once from other threads the main thread can only handle one at a time.  If the main thread is processing your loop it will continue processing it until the method (or function) is returned before handling other work.This means that 'other work' is placed in a queue to be ran on the main thread.  When you use 'async await' you write 'async' to let it be known that the method will (or can be) broken into it's own set of queues.  Then when you say 'await' it should be doing work on another thread. When it does the main thread is allowed to process the other events and work that is stored in queue instead of just waiting there.So when the await work is complete it places the remaining portion of the method in the queue on the main thread as well.So in these methods it doesn't continue processing but places the remaining work in a queue to be accomplished when the await is complete.  Therefore it's in order.  await compute_sum(x, y) gives control back to the main thread to do other work and when it's complete the rest is added to the queue to be worked. So await compute_product(x, y) is queued after the former is complete.


Answer URL
https://docs.python.org/3/library/asyncio-task.html#asyncio.gather
https://docs.python.org/3/library/asyncio-task.html#example-parallel-execution-of-tasks
