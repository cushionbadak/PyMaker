Natural Text
I'm trying to write code that validates type hints, and in order to do so I have to find out what kind of object the annotation is. For example, consider this snippet that's supposed to tell the user what kind of value is expected:This should print "value type should be one of (int, str)", but instead it throws an exception:isinstance doesn't work either:What's the correct way to check if typ is a typing.Generic?If possible, I would like to see a solution that's backed by documentation or a PEP or some other resource. A "solution" that "works" by accessing undocumented, internal attributes is easy to find. But more likely than not, it'll turn out to be an implementation detail and will change in future versions. I'm looking for "the right way" to do it.
You may be looking for __origin__:The best I could find to advocate the use of this undocumented attribute is this reassuring quote from Guido Van Rossum (2 years ago):The best I can recommend is using __origin__ -- if we were to change this attribute there would still have to be some other way to access the same information, and it would be easy to grep your code for occurrences of __origin__. (I'd be less worried about changes to __origin__ than to __extra__.) You may also look at the internal functions _gorg() and _geqv() (these names will not be part of any public API, obviously, but their implementations are very simple and conceptually useful).This caveat in the documentation seem to indicate that nothing is set in marble yet:New features might be added and API may change even between minor releases if deemed necessary by the core developers.
There is no official way to obtain this information. The typing module is still in heavy development, and has no public API to speak of. (In fact, it will probably never have one.)All we can do is to look at the module's internals and find the least gross way to get the information we're after. And because the module is still being worked on, its internals will change. A lot.In python 3.5 and 3.6, generics had an __origin__ attribute that held a reference to the original generic base class (i.e. List[int].__origin__ would've been List), but this was changed in 3.7. Now the easiest way to find out if something is a generic is probably to check its __parameters__ and __args__ attributes.Here is a set of functions that can be used to detect generics:All of these functions should work in all python versions <= 3.7 (including anything <3.5 that uses the typing module backport).
The most you could do, I think, is to use your typ on a variable, use typing.get_type_hints on it and extract the info you need from the returned __annotations__-like dictionary.PEP-484 says:get_type_hints(), a utility function to retrieve the type hints from a function or method. Given a function or method object, it returns a dict with the same format as __annotations__, but evaluating forward references (which are given as string literals) as expressions in the context of the original function or method definition.26.1.7. Classes, functions, and decorators says:At runtime, isinstance(x, T) will raise TypeError. In general, isinstance() and issubclass() should not be used with types.However, PEP-526 says in 'Non-goals':While the proposal is accompanied by an extension of the typing.get_type_hints standard library function for runtime retrieval of annotations, variable annotations are not designed for runtime type checking. Third party packages will have to be developed to implement such functionality.


Answer URL
https://docs.python.org/3/library/typing.html#classes-functions-and-decorators
