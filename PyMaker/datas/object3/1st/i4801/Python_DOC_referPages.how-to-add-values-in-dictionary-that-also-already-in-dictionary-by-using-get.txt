Natural Text
I want to add multiple values in overlapped(same one, i mean) key by using .get()I already searched google with these kewords but they were kinda different problems. So, I'm just looking for new method to solve this. '''dictionary = {}dictionary[key] = dictionary.get(key, {}) + {value}'''but apparently this code is impossible and there's TypeError  +: 'set' and 'set'so I tried to make two dictionary and put default is [] and + [value]but it wasn't work, too...'''for example,key = exercise, study, music, etc...values = exercise : basketball, football , study : science, history, math , muscic : classic etcResult that i want is...{'excercise': {'basketball', 'football'}, 'study': {'science', 'history', 'math'}, 'muscic': {'classic'} ..}'''What should I do?
You're close, but this isn't quite right:Unfortunately, {} is not the way you write an empty set (because it already means an empty dict, and it would be ambiguous); you need set() instead.Your {value} is already, correctly, a set.But to union two sets together (that is, to add all the values from one to the other), you need to use |, not +.So:You can actually make this easier:The setdefault does the get and assigning all in one step. And then we mutate the looked-up-or-created set by calling its add method. Which means we don't need to create a one-element set {value} just to union with the old one, we can just pass value directly.Alternatively, you can make your dictionary a defaultdict(set), and it will automatically (in effect) turn every dictionary[key] into a dictionary.setdefault(key, set()). Whether this is better or worse depends on whether you have some later code that should look up values and actually fail rather than create empty sets.
First things first, what does the error mean? Basically, + isn't defined for sets. Instead, you want union: Switching to union would solve your problem (aside, from as noted by the other answers that {} is a dictionary), but you may be interested in defaultdict. Something like:
.get doesn't add the value when it's missing. .setdefault does. Also, {} is the empty dict, not the empty set (set()). So you could just do:but that's actually rather inefficient, because it needs to construct empty sets whether or not the key already exists. So the best solution is to use collections.defaultdict to handle lazily constructing the new set as needed and only as needed (when the key doesn't exist):


Answer URL
https://docs.python.org/3/library/stdtypes.html#dict.setdefault
https://docs.python.org/3/library/collections.html#collections.defaultdict
