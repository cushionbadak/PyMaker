Natural Text
I have a string that holds a very long sentence without whitespaces/spaces. I would like to find all of the repeated substrings that contains minimum 4 chars. So I would like to achieve something like this:As both abcd,text and sample can be found two times in the mystring they were recognized as propely matched substrings with more than 4 char length. It's important that I am seeking repeated substrings, finding only existing english words is not a requirement. The answers I found are helpful for finding duplicates in texts with whitespaces, but I couldn't find a proper resource that covers the situation when there are no spaces and whitespaces in the string. I would really appreciate if somebody could show me how this should be done the most efficient way. 
This is in Python 2 because I'm not doing Python 3 at this time. So you'll have to adapt it to Python 3 yourself.
Let's go through this step by step. There are several sub-tasks you should take care of:Identify all substrings of length 4 or more.Count the occurrence of these substrings.Filter all substrings with 2 occurrences or more.You can actually put all of them into a few statements. For understanding, it is easier to go through them one at a time.The following examples all use1. Substrings of a given lengthYou can easily get substrings by slicing - for example, mystring[4:4+6] gives you the substring from position 4 of length 6: 'thisis'. More generically, you want substrings of the form mystring[start:start+length].So what values do you need for start and length?start must...cover all substrings, so it must include the first character: start in range(0, ...).not map to short substrings, so it can stop max_length characters before the end: start in range(..., len(mystring) - max_length + 1).length must...cover the shortest substring of length 4: length in range(min_length, ...).not exceed the remaining string after i: length in range(..., len(mystring) - i + 1))The +1 terms come from converting lengths (>=1) to indices (>=0).You can put this all together into a single comprehension:2. Count substringsTrivially, you want to keep a count for each substring. Keeping anything for each specific object is what dicts are made for. So you should use substrings as keys and counts as values in a dict. In essence, this corresponds to this:You can simply feed your substrings to collections.Counter, and it produces something like the above.Notice how the duplicate 'abcd' maps to the count of 2.3. Filtering duplicate substringsSo now you have your substrings and the count for each. You need to remove the non-duplicate substrings - those with a count of 1.Python offers several constructs for filtering, depending on the output you want. These work also if counts is a regular dict:Using Python primitivesPython ships with primitives that allow you to do this more efficiently.Use a generator to build substrings. A generator builds its member on the fly, so you never actually have them all in-memory. For your use case, you can use a generator expression:Use a pre-existing Counter implementation. Python comes with a dict-like container that counts its members: collections.Counter can directly digest your substring generator. Especially in newer version, this is much more efficient.You can exploit Python's lazy filters to only ever inspect one substring. The filter builtin or another generator generator expression can produce one result at a time without storing them all in memory.
Script (explanation where needed, in comments):Output:
Nobody is using re! Time for an answer [ab]using the regular expression built-in module ;)Finding all the maximal substrings that are repeatedThis matches the longest substrings which have at least a single repetition after (without consuming). So it finds all disjointed substrings that are repeated while only yielding the longest strings.Finding all substrings that are repeated, including overlapsThis ensures that all --not only disjoint-- substrings which have repetition are returned. It should be much slower, but gets the work done.If you want in addition to the longest strings that are repeated, all the substrings, then:That will ensure that for long substrings that have repetition, you have also the smaller substring --e.g. "sample" and "ample" found by the re.search code; but also "samp", "sampl", "ampl" added by the above snippet.Counting matchesBecause (by design) the substrings that we count are non-overlapping, the count method is the way to go:ResultsFinding maximal substrings:With the question's original mystring:with the mystring_overlap sample:Finding all substrings:With the question's original mystring:... and if we add the code to get all substrings then, of course, we get absolutely all the substrings:with the mystring_overlap sample:Future workIt's possible to filter the results of the finding all substrings with the following steps:take a match "A"check if this match is a substring of another match, call it "B"if there is a "B" match, check the counter on that match "B_n"if "A_n = B_n", then remove Ago to first stepIt cannot happen that "A_n < B_n" because A is smaller than B (is a substring) so there must be at least the same number of repetitions.If "A_n > B_n" it means that there is some extra match of the smaller substring, so it is a distinct substring because it is repeated in a place where B is not repeated.

Here's a Python3 friendly solution:Bonus: largest string Everything as a function:Example:Output:
CODE: OUTPUT:Hope this helps as my code length was short and it is easy to understand. Cheers!
This is my approach to this problem:
This is how I would do it, but I don't know any other way:Output:Efficient, no, but easy to understand, yes.
Here is simple solution using the more_itertools library.GivenCodeOutputDetailsThe procedures are:build sliding windows of varying sizes lbound <= n < uboundcount all occurrences and filter replicatesmore_itertools is a third-party package installed by > pip install more_itertools.


Answer URL
https://docs.python.org/3/library/collections.html#collections.Counter
