Natural Text
I'm trying this:and getting this:Ideally, I'd like to push some data with timestamps into sqlite3 and recover it back into pandas/python/numpy interoperably.I've seen Appending Pandas dataframe to sqlite table by primary key for appending, but I'm not sure how to work with datetime.datetime, pandas Timestamps or numpy.datetime64 times with sqlite3.Also, there was How to read datetime back from sqlite as a datetime instead of string in Python? but I couldn't figure out how to do it in pandas.One thing I spent a lot of time on was https://stackoverflow.com/a/21916253/1653571 and the confusing multiple to_datetime()s.What's a good way to work with times, sqlite3, and pandas?####### update:I tried these changes:to use the SQLite3 datatypes and to test the returned values:Also, as I tried datetime.datetime.now(pytz.utc) to get UTC-aware times, but it broke lots of stuff.  Using datetime.datetime.utcnow() worked much better by returning a not-timezone-aware object that isn't affected by timezones.Note also the Python sqlite3 documentation on the sqlite3.connect(detect_types=...) parameter.  Enabling detect_types=PARSE_DECLTYPES|PARSE_COLNAMES cues python to run converters on data passed between the systems.https://docs.python.org/3/library/sqlite3.html#sqlite3.PARSE_DECLTYPES for create table ... xyzzy timestamp, ... conversionshttps://docs.python.org/3/library/sqlite3.html#sqlite3.PARSE_COLNAMES for select ... date as "dateparsed [datetime]"... conversions  
The main issue is that SQLite doesn't have a datetime datatype.PARSE_DECLTYPES can't help when reading out of SQLite because the declared datatypes of columns in SQLite will never be datetimes. Since you are in control of the Pandas dataframe, you know the types at the point in time you are saving them back to SQLite. the read_sql method you are using... is a convenience wrapper around read_sql_table and read_sql_query (and  for backward compatibility) and will delegate to the specific function  depending on the provided input (database table name or SQL query).In your example you've provided a query so it is delegating to the read_sql_query method https://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_sql_query.html#pandas.read_sql_queryThis has a parameter parse_dates which can be:Dict of {column_name: arg dict}, where the arg dict corresponds to the  keyword arguments of pandas.to_datetime() Especially useful with  databases without native Datetime support, such as SQLiteSince you know ahead of time which columns are datatypes, you can store those as a dict with a structure that matches what this parse_dates expects, and just pass it into the read_sql method. In other situations where I've saved a pandas df back to a csv or other file, I've used something like this to save the schema to reintroduce when loading csv back to pandas. The read_csv method has a dbtypes parameter that takes exactly the structure below. 
Issue derives from pandas' to_records() which is converting your datetime field into an ISO timestamp with T separator:Consider converting datetime column to string and then run cursor executemany():Altogether:


Answer URL
https://docs.python.org/3/library/sqlite3.html#sqlite3.PARSE_DECLTYPES
https://docs.python.org/3/library/sqlite3.html#sqlite3.PARSE_COLNAMES
