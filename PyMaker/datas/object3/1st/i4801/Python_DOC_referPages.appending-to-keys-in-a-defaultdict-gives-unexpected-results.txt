Natural Text
I am running Python 3.6.4 64 bit. I need to use a defaultdict that produces phn_dictionary as its default as shown in the code above.I dont know in advance what are the the keys like "asd" and "qwe" that I will be accessing. It can be seen that in the line i extend to "asd" the "actual" key of both asd AND qwe is extended. Is this a bug or am I doing something wrong?
The problem is that lambda: phn_dictionary is a function that returns phn_dictionary—the exact same dictionary object—every time you call it. So, you end up with the same dictionary as the value for a bunch of keys. Every time you append through one key, that's visible on all other keys.What you want is not this dictionary, but a new dictionary that starts off as a copy of that one. As Brendan Abel points out in a comment, you probably want a deep copy here—not just a new dict, but a new dict with new lists in it:Or, maybe this is clearer (relying on the fact that the original lists should always be empty):Or, if you don't need phn_dictionary anywhere except here, just use Brendan's answer and create the dict from scratch in the function:If this is a stripped-down sample, and the real dict is much larger, or a variable, etc., obviously the last version won't work, but if this is the real code, it's the simplest.There are other ways to solve this, some of which may be clearer, but this is the one that fits best into an inline lambda, which seems to match the way you're thinking.
It's because they're both representing the same dictionary.  If you defined the factory to return a dictionary literal, it would fix the issueThis is because each time the default factory lambda is called, it returns a new dictionary instead of just returning the same dictionary over and over.Alternatively, you could use copy.deepcopyThis will copy the defined dictionary and all the internal values as well.
Other answers point out the reuse of the references of the inner lists.Unless you really want to raise a KeyError if the object is used with a wrong key, you could go with a defaultdict of a defaultdict of lists:result:


Answer URL
https://docs.python.org/3/faq/programming.html#why-are-default-values-shared-between-objects
