Natural Text
Can anybody explain or propose a fix for why when I round a decimal in Python 3 with the context set to round half up, it rounds 2.5 to 2, whereas in Python 2 it rounds correctly to 3:Python 3.4.3 and 3.5.2:Python 2.7.6:
Notice that when you call round you are getting a float value as a result, not a Decimal. round is coercing the value to a float and then rounding that according to the rules for rounding a float.If you use the optional ndigits parameter when you call round() you will get back a Decimal result and in this case it will round the way you expected.I haven't found where it is documented that round(someDecimal) returns an int but round(someDecimal, ndigits) returns a decimal, but that seems to be what happens in Python 3.3 and later. In Python 2.7 you always get a float back when you call round() but Python 3.3 improved the integration of Decimal with the Python builtins.As noted in a comment, round() delegates to Decimal.__round__() and that indeed shows the same behaviour:I note that the documentation for Fraction says:Thus the behaviour is consistent in that with no argument it changes the type of the result and rounds half to even, however it seems that Decimal fails to document the behaviour of its __round__ method.Edit to note as Barry Hurley says in the comments, round() is documented as returning a int if called without the optional arguments and a "floating point value" if given the optional argument. https://docs.python.org/3/library/functions.html#round
Expanding on @Duncan's answer, the round builtin function changed between python 2 and python 3 to round to the nearest even number (which is the norm in statistics).  Python2 docs:...if two multiples are equally close, rounding is done away  from 0 (so, for example, round(0.5) is 1.0 and round(-0.5) is -1.0).Python3 docs:...if two multiples are equally close, rounding is done toward the even  choice (so, for example, both round(0.5) and round(-0.5) are 0, and  round(1.5) is 2)Since round converts to float if no argument is given for ndigits (credit to @Duncan's answer), round behaves the same way as it would for floats.Examples (in python3):
This is a combination of changes between the rounding mode of round in Python 2 vs 3 and the re-implementation of Decimal from Python to C (See "Other final large-scale changes" in the Features for 3.3 section PEP 398).For round, the rounding strategy changed as can be seen in What's New In Python 3.0 [Also see Python 3.x rounding behavior ]. Additionally, round in Python 3 first tries to find an appropriate __round__ method defined for the object passed:While in Python 2.x it first tries to coerce it specifically to a float and then round it: For Decimal, in Python 2, the implementation even lacked a __round__ method to be called: So, calling round on a Decimal object coerced it to a float which  got rounded using _Py_double_round; this resulted in a float always getting returned irregardless of if a value for ndigits was supplied. decimal is implemented in pure Python for 2.x and (was?) for Python 3 until 3.2.In Python 3.3 it got shinny new __round__ method as it was re-implemented in C:and now, it gets picked up by round when round(<Decimal_object>) is invoked.This, mapped to PyDec_Round in C, now returns a PyLong (an integer) using the default context (ROUND_HALF_EVEN) if the argument ndigits is not supplied and, if it is, calls quantize on it and returns a new rounded Decimal object.


Answer URL
https://docs.python.org/3/library/functions.html#round
https://docs.python.org/3/library/functions.html#round
