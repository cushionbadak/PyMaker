Natural Text
So I'm trying to work out a generic solution that will collect all values from a function and append them to a list that is later accessible.  This is to be used during concurrent.futures or threading type tasks.  Here is a solution I have using a global master_list:I would like to find a solution that does not include globals, and perhaps can return the commented out master_list that is stored as a closure?
If you don't want to use globals, don't discard the results of map. map is giving you back the values returned by each function, you just ignored them. This code could be made much simpler by using map for its intended purpose:If you need a master_list that shows the results computed so far (maybe some other thread is watching it), you just make the loop explicit:This is what the Executor model is designed for; normal threads aren't intended to return values, but Executors provided a channel for returning values under the covers so you don't have to manage it yourself. Internally, this is using Queues of some form or another, with additional metadata to keep the results in order, but you don't need to deal with that complexity; from your perspective, it's equivalent to the regular map function, it just happens to parallelize the work.Update to cover dealing with exceptions:map will raise any exceptions raised in the workers when the result is hit. Thus, as written, the first set of code will not store anything if any of the tasks fail (the list will be partially constructed, but thrown away when the exception raises). The second example will only keep results before the first exception is thrown, with the rest discarded (you'd have to store the map iterator and use some awkward code to avoid it). If you need to store all successful results, ignoring failures (or just logging them in some way), it's easiest to use submit to create a list of Future objects, then wait on them, either serially or in order of completion, wrapping the .result() calls in try/except to avoid throwing away good results. For example, to store results in order of submission, you'd do:For more efficient code, you can retrieve results in order of completion, not submission, using concurrent.futures.as_completed to eagerly retrieve results as they finish. The only change from the previous code is that:becomes:where as_completed does the work of yielding completed/cancelled futures as soon as they complete, instead of delaying until all futures submitted earlier complete and get handled.There are more complicated options involving using add_done_callback so the main thread isn't involved in explicitly handling the results at all, but that's usually unnecessary, and often confusing, so it's best avoided if possible.
I have faced this issue in the past: Running multiple asynchronous function and get the returned value of each function. This was my approach to do it:Sample run:


Answer URL
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.as_completed
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.as_completed
