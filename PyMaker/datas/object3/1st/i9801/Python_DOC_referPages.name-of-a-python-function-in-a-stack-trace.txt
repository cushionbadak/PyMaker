Natural Text
In both Python2 and Python3, in the stack trace the __name__ of a function is not used, the original name (the one that is specified after def) is used instead.Consider the example:The output is:Why so? How do I change the name that is used in the stack trace? Where is the __name__ attribute used then?
So, basically every function has three things that can be considered being name of the function:The original name of the code blockIt's stored in the f.__code__.co_name (where f is the function object). If you use def orig_name to create function, orig_name is that name. For lambas it's <lambda>.This attribute is readonly and can't be changed. So the only way to create function with the custom name in runtime I'm aware of is exec:(There is also more low-level way to do this that was mentioned in a comment to the question.)The immutability of co_name actually makes sense: with that you can be sure that the name you see in the debugger (or just stack trace) is exactly the same you see in the source code (along with the filename and line number).The __name__ attribute of the function objectIt's also aliased to func_name.You can modify it (orig_name.__name__ = 'updated name') and you surely do on a daily basis: @functools.wraps copies the __name__ of the decorated function to the new one.__name__ is used by tools like pydoc, that's why you need @functools.wraps: so you don't see the technical details of every decorator in your documentation. Look at the example:Here is the pydoc output:With wraps there is no sign of decorated in the documentation.Name of the referenceOne more thing that can be called function name (though it hardly is) is the name of a variable or an attribute where reference to that function is stored.If you create function with def name, the name attribute will be added to the current scope. In case of lambda you should assign the result to some variable: name = lambda: None.Obviously you can create more than one reference to the same function and all that references can have different names.The only way all that three things are connected to each other is the def foo statement that creates function object with both __name__ and __code__.co_name equal to foo and assign it to the foo attribute of the current scope. But they are not bound in any way and can be different from each other:Output:Pydoc:I thank other people for comments and answers, they helped me to organize my thoughts and knowledge.
Tried to explore the CPython implementation, definitely not an expert. As pointed out in the comments, when the stack entry of f is printed, the attribute f.__code__.co_name is used. Also, f.__name__ is initially set to f.__code__.co_name, but when you modify the former, the latter is not modified accordingly.Therefore, I tried to modify that directly, but it is not possible:Why are there two ways to say a function's name? Well, according to the documentation, __name__ is defined for "class, function, method, descriptor, or generator instance", so in the case of functions it maps to that attribute, for other objects it will map to something else.


Answer URL
https://docs.python.org/3/library/stdtypes.html#definition.__name__
