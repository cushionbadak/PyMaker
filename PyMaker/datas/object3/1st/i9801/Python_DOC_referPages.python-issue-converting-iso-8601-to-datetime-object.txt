Natural Text
I need to parse RFC 3339 strings like "2008-09-03T20:56:35.450686Z" into Python's datetime type.I have found strptime in the Python standard library, but it is not very convenient.What is the best way to do this?
The python-dateutil package can parse not only RFC 3339 datetime strings like the one in the question, but also other ISO 8601 date and time strings  that don't comply with RFC 3339 (such as ones with no UTC offset, or ones that represent only a date).Be warned that the dateutil.parser is intentionally hacky: it tries to guess the format and makes inevitable assumptions (customizable by hand only) in ambiguous cases. So ONLY use it if you need to parse input of unknown format and are okay to tolerate occasional misreads. (thanks ivan_pozdeev)The Pypi name is python-dateutil, not dateutil (thanks code3monk3y):If you're using Python 3.7, have a look at this answer about datetime.datetime.fromisoformat.
Note in Python 2.6+ and Py3K, the %f character catches microseconds.See issue here
Several answers here suggest using datetime.datetime.strptime to parse RFC 3339 or ISO 8601 datetimes with timezones, like the one exhibited in the question:This is a bad idea.Assuming that you want to support the full RFC 3339 format, including support for UTC offsets other than zero, then the code these answers suggest does not work. Indeed, it cannot work, because parsing RFC 3339 syntax using strptime is impossible. The format strings used by Python's datetime module are incapable of describing RFC 3339 syntax.The problem is UTC offsets. The RFC 3339 Internet Date/Time Format requires that every date-time includes a UTC offset, and that those offsets can either be Z (short for "Zulu time") or in +HH:MM or -HH:MM format, like +05:00 or -10:30.Consequently, these are all valid RFC 3339 datetimes:2008-09-03T20:56:35.450686Z2008-09-03T20:56:35.450686+05:002008-09-03T20:56:35.450686-10:30Alas, the format strings used by strptime and strftime have no directive that corresponds to UTC offsets in RFC 3339 format. A complete list of the directives they support can be found at https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior, and the only UTC offset directive included in the list is %z:%zUTC offset in the form +HHMM or -HHMM (empty string if the the object is naive).Example: (empty), +0000, -0400, +1030This doesn't match the format of an RFC 3339 offset, and indeed if we try to use %z in the format string and parse an RFC 3339 date, we'll fail:
New in Python 3.7+The datetime standard library introduced a function for inverting datetime.isoformat().classmethod datetime.fromisoformat(date_string):Return a datetime corresponding to a date_string in one of the formats  emitted by date.isoformat() and datetime.isoformat(). Specifically, this function supports strings in the format(s):YYYY-MM-DD[*HH[:MM[:SS[.mmm[mmm]]]][+HH:MM[:SS[.ffffff]]]]where * can match any single character. Caution: This does not support parsing arbitrary ISO 8601 strings - it is only intended as the inverse  operation of datetime.isoformat().Example of use:
Try the iso8601 module; it does exactly this.There are several other options mentioned on the WorkingWithTime page on the python.org wiki.

What is the exact error you get? Is it like the following?If yes, you can split your input string on ".", and then add the microseconds to the datetime you got.Try this:
Starting from Python 3.7, strptime supports colon delimiters in UTC offsets (source). So you can then use:
In these days, Arrow also can be used as a third-party solution:
If you don't want to use dateutil, you can try this function:Test:Result:
If you are working with Django, it provides the dateparse module that accepts a bunch of formats similar to ISO format, including the time zone.If you are not using Django and you don't want to use one of the other libraries mentioned here, you could probably adapt the Django source code for dateparse to your project.
Just use the python-dateutil module:Documentation
I have found ciso8601 to be the fastest way to parse ISO 8601 timestamps. As the name suggests, it is implemented in C.The GitHub Repo README shows their >10x speedup versus all of the other libraries listed in the other answers.My personal project involved a lot of ISO 8601 parsing. It was nice to be able to just switch the call and go 10x faster. :)Edit: I have since become a maintainer of ciso8601. It's now faster than ever!
I'm the author of iso8601 utils. It can be found on GitHub or on PyPI. Here's how you can parse your example:
One straightforward way to convert an ISO 8601-like date string to a UNIX timestamp or datetime.datetime object in all supported Python versions without installing third-party modules is to use the date parser of SQLite.Output:
I've coded up a parser for the ISO 8601 standard and put it on GitHub: https://github.com/boxed/iso8601. This implementation supports everything in the specification except for durations, intervals, periodic intervals, and dates outside the supported date range of Python's datetime module.Tests are included! :P
Django's parse_datetime() function supports dates with UTC offsets:So it could be used for parsing ISO 8601 dates in fields within entire project:
Because ISO 8601 allows many variations of optional colons and dashes being present, basically CCYY-MM-DDThh:mm:ss[Z|(+|-)hh:mm]. If you want to use strptime, you need to strip out those variations first.The goal is to generate a utc datetime object.If you just want a basic case that work for UTC with the Z suffix like 2016-06-29T19:36:29.3453Z:If you want to handle timezone offsets like 2016-06-29T19:36:29.3453-0400 or 2008-09-03T20:56:35.450686+05:00 use the following. These will convert all variations into something without variable delimiters like  20080903T205635.450686+0500 making it more consistent/easier to parse.If your system does not support the %z strptime directive (you see something like ValueError: 'z' is a bad directive in format '%Y%m%dT%H%M%S.%f%z') then you need to manually offset the time from Z (UTC). Note %z may not work on your system in python versions < 3 as it depended on the c library support which varies across system/python build type (i.e. Jython, Cython, etc.).
This works for stdlib on Python 3.2 onwards (assuming all the timestamps are UTC):For example,
For something that works with the 2.X standard library try:calendar.timegm is the missing gm version of time.mktime.
The python-dateutil will throw an exception if parsing invalid date strings, so you may want to catch the exception.
Nowadays there's Maya: Datetimes for Humans™, from the author of the popular Requests: HTTP for Humans™ package:
Thanks to great Mark Amery's answer I devised function to account for all possible ISO formats of datetime:
Note that we should look if the string doesn't ends with Z, we could parse using %z.


Answer URL
https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior
