Natural Text
What's the result of returning NotImplemented from __eq__ special method in python 3 (well 3.5 if it matters)?The documentation isn't clear; the only relevant text I found only vaguely refers to "some other fallback":When NotImplemented is returned, the interpreter will then try the reflected operation on the other type, or some other fallback, depending on the operator. If all attempted operations return NotImplemented, the interpreter will raise an appropriate exception. See Implementing the arithmetic operations for more details.Unfortunately, the "more details" link doesn't mention __eq__ at all.My reading of this excerpt suggests that the code below should raise an "appropriate exception", but it does not:From experimenting, I think that when NotImplemented is returned from __eq__, the interpreter behaves as if __eq__ wasn't defined in the first place (specifically, it first swaps the arguments, and if that doesn't resolve the issue, it compares using the default __eq__ that evaluates "equal" if the two objects have the same identity). If that's the case, where in the documentation can I find the confirmation of this behavior?Edit: see Python issue 28785
Actually the == and != check work identical to the ordering comparison operators (< and similar) except that they don't raise the appropriate exception but fall-back to identity comparison. That's the only difference.This can be easily seen in the CPython source code. I will include a Python version of that source code (at least as far as it's possible):and calling a == b then evaluates as richcmp(a, b, '__eq__'). The if op == '__eq__' is the special case that makes your a == b return False (because they aren't identical objects) and your a == a return True (because they are).However the behaviour in Python 2.x was completly different. You could have up to 4 (or even 6, I don't remember exactly) comparisons before falling back to identity comparison!
Not sure where (or if) it is in the docs, but the basic behavior is:try the operation: __eq__(lhs, rhs)if result is not NotImplemented return itelse try the reflected operation:  __eq__(rhs, lhs)if result is not NotImplemented return itotherwise use appropriate fall back:eq -> same objects? -> True, else Falsene -> different objects? True, else Falsemany others -> raise exceptionThe reason that eq and ne do not raise exceptions is:they can always be determined (apple == orange? no)


Answer URL
https://docs.python.org/3/library/constants.html#NotImplemented
https://docs.python.org/3/library/numbers.html#implementing-the-arithmetic-operations
