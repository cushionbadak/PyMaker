Natural Text
Suppose I have two Python modules in my project:Class1 has some functions, but the important one is doEverythingAndGetData(). Let's pretend it gives a number back while executing several internal functions.Now suppose that Class2 uses Class1, and then has further functionality implemented. Class2 only has two functions - __init__ and foo().Now I want to write a unit test for Class2 that covers foo().This unit test is the only one written for the project. We run the unit test and generate a Code Coverage report.After examining the Code Coverage report, we will see that Class2 is well covered, as we have have our unit test and it is doing what it is supposed to. Fantastic!However, we also note that Class1 is also well covered, as the unit test also covered class1.doEverythingAndGetData() and any of it's underlying functions. Our report is showing fantastic coverage for the entire project! Send it to the PO and let's take an early weekend!This is misleading though. What I really want the report to show is Class2 being covered, as we have written a unit test that covers the module reliably. I don't want it to show Class1 as being covered, as we don't have any unit tests that check it's internal functionality. It simply assumes that Class1 works correctly, and if the unit test fails, it's description will not be very helpful nor transparent if Class1 is at fault.So, to simplify:Class2 is covered appropriately via Unit TestingClass1 has no direct coverage and puts the project at riskWhen Unit Tests are ran and the Code Coverage report is generated, it incorrectly shows both modules as well testedInstead, I'd like the report to show that Class2 is covered, as foo() is explicitly called by the test, and Class1 is not covered, as it's functions are called within Class2.foo()This leads me to the following questions:Is there a way to prevent this from happening in the coverage report? What, if any, is the term to use to refer to this type of coverage?Is there a particular coding pattern that helps prevent this issue?Thanks!
You will need to mock the data coming from class1.doEverythingAndGetData(). In your current implementation, the actual code inside that function is being run whenever you call the unittest for class2. Something like this will help you,Now you can write a separate unittest for class1.doEverythingAndGetData() and get the correct coverage report!So answering your 3 questions,Is there a way to prevent this from happening in the coverage report?Is there a particular coding pattern that helps prevent this issue?Yes! Use mock.What, if any, is the term to use to refer to this type of coverage?In some sense, what you've done could refer to integration tests, where you test a number of functions together against a series of input combinations. In unit tests on the other hand, you test every function and try to see its working without caring about whether dependent functions work or not.


Answer URL
https://docs.python.org/3/library/unittest.mock.html
https://docs.python.org/3/library/unittest.mock.html
