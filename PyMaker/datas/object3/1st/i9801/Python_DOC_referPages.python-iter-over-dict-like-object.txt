Natural Text
I try to iter over this class. It is said in this doc  that implementing __getitem__ should be enough to iter over my Test class. Indeed, when I try to iter over it, it does not tell me that I can't, but I've got a KeyError:Do you know where this 0 come from ? (what's going on under the hood)I know I can solve it by adding an __iter__ function:Is it the best way to solve this problem ? (I might also inherit from dict class).
You missed a crucial wording in the documentation you found:For sequence types, the accepted keys should be integers and slice objects. [...] [I]f of a value outside the set of indexes for the sequence (after any special interpretation of negative values), IndexError should be raised.Note: for loops expect that an IndexError will be raised for illegal indexes to allow proper detection of the end of the sequence.Bold italic emphasis is mine. If you accept keys, not integers, you don't have a sequence.The Python glossary explains more; see the definition of sequence:An iterable which supports efficient element access using integer indices via the __getitem__() special method and defines a __len__() method that returns the length of the sequence. [...] Note that dict also supports __getitem__() and __len__(), but is considered a mapping rather than a sequence because the lookups use arbitrary immutable keys rather than integers.So sequences accept integer indices, and that's exactly what for provides when iterating *. When given an object to iterate over, if there are no other means but __getitem__ available, then a special iterator is constructed that starts at 0 and keeps increasing the counter until IndexError is raised. In pure Python that'd be:The actual implementation is in C, see the PySeqIter_Type definition and functions.Implement the __iter__ method instead; it is used when present. Since you wrap a dictionary, you could simply return the iterator for that dictionary (use the iter() function rather than directly call special methods):* Technically speaking, for doesn't provide this. for just uses iter(obj) and it is that call that produces the special iterator when no __iter__ method is available instead.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__getitem__
https://docs.python.org/3/glossary.html#term-sequence
https://docs.python.org/3/reference/datamodel.html#object.__iter__
https://docs.python.org/3/library/functions.html#iter
