Natural Text
I started reading about python's += syntax and stumbled onto the following post/answer:Interactive code about +=So what I noticed was that there seems to be a difference between frames and objects.In the global frame, they point to the same object even though they're different variables; if the linewas insteadthen 'l2' becomes a separate object when that line runs. My biggest question is when would you want a variable to point to a separate object? Also, why and when would you want to keep them pointed at the same object?Any explanation or use cases would be greatly appreciated! Extra thanks if you can mention anything relevant to data science :)
frame and object don't mean what you think they mean.In programming you have something called a stack. In Python, when you call a function you create something called a stack frame. This frame is (as you see in your example) basically just a table of all of the variables that are local to your function.Note that defining a function doesn't create a new stack frame, it's the calling a function. For instance something like this:Your global frame is just going to hold one reference: say_hello. You can see that by checking out what's in the local namespace (in Python you pretty much have a 1:1 relationship between namespace, scope, and stack frames):You'll see something that looks like this:Note the dunder (short for double underscore  double underscore) names - those are automagically provided, and for the purposes of our discussion you can ignore them. That leaves us with:That 0x bit is the memory address where the function itself lives. So here, our global stack/frame contains just that one value. If you call your function and then check locals() again, you'll see that name isn't there. That's because when you call the function you create a new stack frame and the variable is assigned there. You can prove this by adding print(locals()) at the end of your function. Then you'll see something like this:No dunder names here. You'll also note that this doesn't show a memory address. If you want to know where this value lives, there's a function for that.That's what the example means when it's talking about a frame.But what about objects? Well, in Python, everything is an object. Just try it:They're all objects. But they may be different objects. And how can you tell? With id:Note that you also can compare whether or not two objects are the same object by using is.Ehhhhh...? Wait a minute, what happened there? Well, as it turns out, python(that is, CPython) caches small integers. So the object 512 is different from the object that is the result of the object 500 added to the object 12.One important thing to note is that the assignment operator = always assigns a new name to the same object. For example:And it doesn't matter how many other names you give an object, or even if you pass the object around to different frames, you still have the same object.But as you're starting to gather, it's important to understand the difference between operations that change an object and operations that produce a new object. Generally speaking you have a few immutable types in Python, and operations on them will produce a new object.As for your question, when do you want to change objects and when do you want to keep them the same is actually looking at it the wrong way. You want to use a mutable type when you want to change things, and you want to use an immutable type if you don't want things to change.For instance, say you've got a group, and you want to add members to the group. You might use a mutable type like a list to keep track of the group, and an immutable type like strings to represent the members. Like this:What happens when a member of the group is eaten?You'll notice that you still have the same group, just the members have changed.


Answer URL
https://docs.python.org/3/reference/datamodel.html
