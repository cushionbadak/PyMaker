Natural Text
The following code produces the given output.Output:Why does __sizeof__() print a smaller result when a second element is considered? Shouldn't the output be larger? I realize from this answer that I should be using sys.getsizeof(), but the behavior seems odd nonetheless. I'm using Python 3.5.2.Also, as @Herbert pointed out, 'Hello' takes up more memory than ('Hello',), which is a tuple. Why is this?
This is due to the fact that tuple objects (and I'm pretty sure all containers except from string) assess their size not by including the actual sizes of their respective contents but, rather, by calculating the size of pointers to PyObjects times the elements they contain. That is, they hold pointers to the (generic) PyObjects contained and that's what contributes to its overall size.This is hinted in the Data Model chapter of the Python Reference manual:Some objects contain references to other objects; these are called containers. Examples of containers are tuples, lists and dictionaries. The references are part of a containerâ€™s value.(I'm emphasizing the word references.)In PyTupleType, a struct where the information on the tuple type is contained, we see that the tp_itemsize field has sizeof(PyObject *) as its value:32bit builds and 64bit builds of Python have a sizeof(PyObject *) equal to 8 bytes.This is the value that is going to be multiplied by the number of items contained in the tuple instance. When we look at object_size, the __sizeof__ method that tuples inherit from object (examine object.__sizeof__ is tuple.__sizeof__), we see this clearly:see how isize (obtained from tp_itemsize) is multiplied by Py_SIZE(self), which, is another macro that grabs the ob_size value indicating the number of elements inside the tuple.This is why, even if we create a somewhat large string inside a tuple instance:with the element inside it having a size of:the size of the tuple instance: equals that of one with simply "Hello" inside:For strings, each individual character increases the value returned from str.__sizeof__. This, along with the fact that tuples only store pointers, gives a misleading impression that "Hello" has a larger size than the tuple containing it.Just for completeness, unicode__sizeof__ is the one that computes this. It really just multiplies the length of the string with the character size (which depends on what kind the character is 1, 2 and 4 byte chars).The only thing I'm not getting with tuples is why it's basic size (indicated by tb_basicsize) is listed as sizeof(PyTupleObject) - sizeof(PyObject *). This sheds 8 bytes from the overall size returned; I haven't found any explanation for this (yet).


Answer URL
https://docs.python.org/3/reference/datamodel.html#objects-values-and-types
https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_itemsize
