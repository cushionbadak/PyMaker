Natural Text
Is it possible to override the __bases__ field of a metaclass (i.e. class deriving from type) using a get-set property? The following code works for getting C.__bases__, but not setting it:I've tried a few substitutions for super() in the setter function, but none of them work:type.__setattr__(cls, '__bases__', value) leads to recursion.object.__setattr__(cls, '__bases__', value) gives TypeError: can't apply this __setattr__ to type objectSo, what this boils down to is how to set the cls.__bases__ field when it isshadowed by a property on the metaclass. Any ideas?(Yes, I am aware that defining the __bases__ property has no effect on the actual __mro__ of the class, although that can be arranged by overriding mro())
super() doesn't support data descriptors, only plain descriptors, as only super().__get__ is implemented.Put differently, the assignmentfails because the super() proxy object does not implement the descriptor.__set__() method, and thus that assignment tries to set __bases__ as an attribute on that proxy object.You'd have to manually access the descriptor on the type object:For symmetry's sake, I've used the same manual descriptor access in the getter, although super().__bases__ would work too.Above, I hardcoded type rather than search the MRO; you could also use a helper function to find the right descriptor with a full MRO search:Either way, now you can intercept __bases__ being set:


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__set__
