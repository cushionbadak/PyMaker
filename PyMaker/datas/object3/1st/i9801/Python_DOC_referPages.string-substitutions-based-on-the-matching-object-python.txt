Natural Text
I struggle to understand the group method in Python's regular expressions library. In this context, I try to do substitutions on a string depending on the matching object.That is, I want to replace the matched objects (+ and \n in this example) with a particular string in the my_dict dictionary (with rep1 and rep2 respectively).As seen from this question and answer,I have tried this:But I get None for t followed by an IndexError when computing v.Any explanations and example code would be appreciated.
The r'[+\-*/]' regex does not match a newline, so your '\n': 'rep2' would not be used. Else, add \n to the regex: r'[\n+*/-]'.Next, you get None because your regex does not contain any named capturing groups, see re docs:match.lastgroup  The name of the last matched capturing group, or None if the group didnâ€™t have a name, or if no group was matched at all.To replace using the match, you do not even need to use re.finditer, use re.sub with a lambda as the replacement:See the Python demoThe m.group() gets the whole match (the whole match is stored in match.group(0)). If you had a pair of unescaped parentheses in the pattern, it would create a capturing group and you could access the first one with m.group(1), etc.
Despite of Wiktor's truly pythonic answer, there's still the question why the OP's orginal algorithm wouldn't work.Basically there are 2 issues:The call of new_content = re.sub(regex, repl_func(mobj), content) will substitute all matches of regex with the replacement value of the very first match.The correct call has to be new_content = re.sub(regex, repl_func, content).As documented here, repl_func gets invoked dynamically with the current match object!repl_func(mobj) does some unnecessary exception handling, which can be simplified:This is equivalent to Wiktor's solution - he just got rid of the function definition itself by using a lambda expression.With this modification, the for mobj in re.finditer(regex, content): loop has become superfluos, as it does the same calculation multiple times.Just for the sake of completeness here is a working solution using re.finditer(). It builds the result string from the matched slices of content:


Answer URL
https://docs.python.org/3/library/re.html#re.match.lastgroup
