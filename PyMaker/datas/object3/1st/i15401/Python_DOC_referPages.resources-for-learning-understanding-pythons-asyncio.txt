Natural Text
TLDR: I'm looking for a comprehensive or authoritative explanation (tutorial/book/presentation/...) of asyncio for application developers.While I have a decent understanding of event loops and futures/deferreds/promises (largely thanks to JavaScript), somehow the intricacies of Python's asyncio continue to confound me. asyncio seems significantly more complex than what I'm used to - presumably because it was partly designed for low-level compatibility with existing implementations (Twisted, Tornado etc.) and because it allows for multiple event loops in separate threads.As far as I can tell, there's no comprehensive walkthrough of the basic concepts, so I've consulted the official docs as well as various articles and presentations across the web.Yet I remain unsure of my understanding, quite possibly because it's not always clear what's relevant at the application level or if you don't need to worry about the aforementioned alternatives. (Many resources seem to assume familiarity with Twisted et al.)A few examples of things that induced uncertainty for me:So far I've only used asyncio.coroutine in combination with yield from, but this comparison suggests I should reconsider.A server might either be created using loop.create_server(MyProtocol) or asyncio.start_server(my_connection_handler) - when would I use either?What is proper hygiene in managing loops' life cycle (e.g. loop.close() after loop.run_forever())?I have yet to understand why Tasks are required in addition to Futures.What if I want a class constructor to be non-blocking (i.e. use yield from, which appears to be invalid)?Can class getters be asynchronous (i.e. combining @property and asyncio.coroutine)?How do I know whether any given function is asynchronous? For example, I'd expect StreamWriter.write to be non-blocking, but I don't know whether that's actually the case.I'm not asking for answers to these particular questions, they merely illustrate how I'm struggling at a conceptual level.
I am like you,  looking for answers, but i can help you withone thing:Regarding  the non-blocking problem: I created a program that uses asynchronous loops to listen to twitter feeds, i found the answer here: asyncio yield from concurrent.futures.Future of an ExecutorBasically,  using the executor, you can make any task non-blocking. Just a warning, my tasks are independant and do not need syncing, i just needed them to become non blocking. If you need them to wait for each toher, youhave to use semaphoreHere os how i did it :Here are a few links i found that helped me better understand:http://www.drdobbs.com/open-source/the-new-asyncio-in-python-34-servers-pro/240168408http://sahandsaba.com/understanding-asyncio-node-js-python-3-4.htmlhttp://www.drdobbs.com/open-source/the-new-asyncio-module-in-python-34-even/240168401http://ntoll.org/article/asyncioSure it is not a book, but it is a good starting place


Answer URL
https://docs.python.org/3/library/asyncio.html
