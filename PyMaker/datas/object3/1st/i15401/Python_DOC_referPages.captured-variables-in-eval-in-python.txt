Natural Text
I'm having trouble understanding the semantics of "eval()" and "exec" in Python. (All code in this question behaves the same way in Python 2.7.8 and Python 3.4.2). The documentation for "eval" says:If both [locals and globals] are omitted, the expression is executed  in the environment where eval() is called.There is similar language for "exec". I clearly don't understand this sentence because I would expect the four functions defined by the following program to do the same thing.They do not.Disassembling the code reveals why: "x" is treated as a global variable by "eval" and "exec".Output:The question"j" and "l" above have the behaviour I want. How can I get this behaviour using "eval" or "exec"?Failure 1Using a class instead of a function as the outer wrapper does change the semantics, but in the opposite to the desired way. It makes "x" into a global.Output:Wrapping in "classmethod" or leaving it as an unbound instance method just makes things worse.Failure 2Substituting "x" using string interpolation works for integers:Output:However, I don't want to assume that "x" can be losslessly converted to a string and back. The attempt is broken in the following examples:Failure 3Since Python is looking for a global variable, one obvious attempt is to pass "x" as a global variable:Output:This attempt is broken because it reads the value of "w" too early:Success 1I did eventually find an approach that works, but I really don't like it:Output:In particular, this is going to become painful if I do not know the full list of local variables captured by the string I'm passing to "eval".Can you do better?Update 2014-12-25Failure 4Looking for more ways of creating the local variable "x", I tried this:The extra assignment to "x" has no effect. The assertions verify that "x" is in the dictionary of locals, but it is not captured by the lambdas. Here is the output:The calls to "i" and "j" both crash, complaining that there is no global variable "x".Success 2[Edit 2014-12-29: This succeeds only on Python 3.]Another way of creating a local variable is like this:Strangely, in this case the extra assignment to "x" does have an effect. This does work, i.e. "i" is different from "j". Here is the output:The call to "j" crashes, complaining that there is no global "x", but "i" works as desired and has the correct bytecode.Why does this work, while "Failure 4" above does not? What is the rule that determines whether the local "x" can be captured? And what is the history of this design? (It seems absurd!)
I think you want your created functions to inherit the local environment of the function that creates them, but also the real global environment (of the function that creates them).  That's why you don't like them referring to x as a global, right?The following creates a "wrapper" function around the desired function, all within the same exec string.  The values of the creating function's locals are passed in when you call or re-call the wrapper, creating a new wrapped closure.The code is sensitive to new variables being created in the locals context. It goes to some trouble to make sure that the function and wrapper names are both known and have values there.So, to answer the original question, this code......produces this output:And this example shows what to do when the locals in the creator function change:This produces the output:
I'm not sure I quite got it myself, but I'll try my best:I guess when you run the eval/exec python does not understand that it was inside the function, I don't really know why.What I'll try to do is using format string like thisI'm not sure if this thing works though.Also, why do you need to use eval and exec this way?
I will share in my own understanding that why python behave like thisHow Lambda Captures referencesEvery time a variable that's not in the parameter list used, python creates a closure for it. For examplecreates a closure that captures x, you could check it by accessingwhich will show you that x is store along with the function creation.However, y is NOT stored with the function because it is defined as a global variableClass definitionThis will cause name error when run A.f()since python will look for c in global namespace which doesn't have c definedThe ReasonPython 3's doc to exec function saidIf exec gets two separate objects as globals and locals, the code  will be executed as if it were embedded in a class definition.which shows why the lambda isn't capture variables in the locals namespaceWork Around


Answer URL
https://docs.python.org/3/library/functions.html#exec
