Natural Text
Is there a way to begin a block of code with a with statement, but conditionally?Something like:To clarify, one scenario would have a block encased in the with statement, while another possibility would be the same block, but not encased (i.e., as if it wasn't indented)Initial experiments of course give indentation errors..
If you want to avoid duplicating code and are using a version of Python prior to 3.7 (when contextlib.nullcontext was introduced) or even 3.3 (when contextlib.ExitStack was introduced), you could do something like:or:and then use it as:You alternatively could make get_stuff() return different things based on needs_with().(See Mike's answer or Daniel's answer for what you can do in later versions.)
Python 3.3 introduced contextlib.ExitStack for just this kind of situation.  It gives you a "stack", to which you add context managers as necessary.  In your case, you would do this:Anything that is entered to stack is automatically exited at the end of the with statement as usual.  (If nothing is entered, that's not a problem.)  In this example, whatever is returned by get_stuff() is exited automatically.If you have to use an earlier version of python, you might be able to use the contextlib2 module, although this is not standard.  It backports this and other features to earlier versions of python.  You could even do a conditional import, if you like this approach.
A third-party option to achieve exactly this:https://pypi.python.org/pypi/conditional
As of Python 3.7 you can use contextlib.nullcontext:contextlib.nullcontext is pretty much just a no-op context manager. You can pass it an argument that it will yield, if you depend on something existing after the as:Otherwise it'll just return None:It's super neat, check out the docs for it here: https://docs.python.org/3/library/contextlib.html#contextlib.nullcontext
You can use contextlib.nested to put 0 or more context managers into a single with statement.This solution has its quirks and I just noticed that as of 2.7 its been deprecated. I wrote my own context manager to handle juggling multiple context managers. Its worked for me so far, but I haven't really considered edge conditons
It was hard to find @farsil's nifty Python 3.3 one-liner, so here it is in its own answer:Note that ExitStack should come first, otherwise get_stuff() will be evaluated. 


Answer URL
https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack
https://docs.python.org/3/library/contextlib.html#contextlib.nullcontext
https://docs.python.org/3/library/contextlib.html#simplifying-support-for-single-optional-context-managers
https://docs.python.org/3/library/contextlib.html?highlight=contextmanager#simplifying-support-for-single-optional-context-managers
