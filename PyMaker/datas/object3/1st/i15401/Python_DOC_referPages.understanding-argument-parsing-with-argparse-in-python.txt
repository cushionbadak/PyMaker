Natural Text
I am now starting exploring Python, and was testing how arguments can be passed to a script with "argparse".The way I wrote a sample script was as following, where arguments passed through flags -i and -o are compulsory and flag -u is optional:Running this script:prints:I understand the printing statement in the if conditional (5 is higher than 2), however, after reading the argparse documentation (https://docs.python.org/3/library/argparse.html) I still don't quite understand why -i and -o flags are counted as arguments. This behaviour seems to be quite different from e.g. perl Getopt::Std, which I'm more used to.So, the question is what is the best way of parsing arguments in Python and to evaluate the presence of mandatory arguments (without using required=True)
It gives you 5 because sys.argv contains the raw input passed to python as arguments (the script name and 4 arguments). You can see argparse as an abstraction for this, so once you use it, you can forget about sys.argv. In most cases it is better not to mix these two methods. argparse its a nice way to handle arguments, I don't quite get why you don't want to use the  required option when that's exactly the way to go. Another alternative is to parse the sys.argv yourself (regex maybe?) and drop argparse altogether.
There's a Python getopt which probably is similar to the Perl one (assuming both are modelled after the C/Unix version).https://docs.python.org/2/library/getopt.htmlIn your code, sys.argv is a list of strings from the command line (as interpreted by the shell and interpreter).  It is the raw input for any of the parsers ('getopt', 'optparse', 'argparse').  And it is available for your parsing as well.  When learning it is a good idea to include a line.  parser.parse_args() uses this list.  sys.argv[0] is used as prog attribute (in the default usage), while sys.argv[1:] (the rest) is parsed according to the rules you define with add_argument.   For testing I often like to use parse_args with a custom list of strings, e.g.With your definition I'd expect to see something like:The parser returns an object (type argparse.Namespace), which has attributes defined by your arguments.  Values are usually accessed with expressions like args.input, args.isunfolded.  The docs also show how you easily express this as a dictionary.By long standing UNIX conventions, arguments flagged by strings like '-i' are options, that is they are optional.  argparse generalizes this concept by letting you specify a required=True parameter.Other arguments are positionals.  They are interpreted according to their order.  And as such they are normally required.  What argparse adds is the ability to define those positionals, such as type, nargs, etc.  With nargs='?' they are optional.  Many of the nargs values are similar to regular expression characters (e.g. +?*).  In fact argparse uses a form a regular expression parsing to allocate strings among arguments.  I'd refine your arguments thus (taking advantage of various defaults)If input and output were required, I could change them to:Now input and output are positional arguments, as in test.py -u inputfile outputfileBy using a1 = parser... I can look at the object produced by this statement.producesThis tells me that a1 is a _StoreAction object (a subclass of argparse.Action).  It also displays a number (not all) of its attributes, ones that define its action.  A positional, on the other hand, has values like these:It may also be instructive to look at a1.required and a2.required, which are respectively False and True.  required is an Action attribute that is not routinely displayed, but is, never the less accessible.I've pulled all these test values from a parser defined in an interactive shell (Ipython).  It's a great way to explore Python and modules like argparse.
After reading other related posts it seems that the best way to do this is as was suggested by @Rufflewind and inspect the args itself:


Answer URL
https://docs.python.org/3/library/argparse.html
