Natural Text
I wanted to have a function that handled a dictionary, addressed like a dictionary or similar with little work, so that when called I could run other code.I thought it seemed easier to subclass dict, so I have. From reading help(dict) I think I have covered all dictionary editing functions so that a callback is called too. Have I? Also are there any other like pop which return a value of the editing ones?Also a better title and class name would be good.
I'd use composition rather than inheritance, and implement the MutableMapping from collections.abc so that I get some of the methods implemented for free. Per the documentation, you have to provide implementations of __getitem__, __setitem__, __delitem__, __iter__, and __len__:Note that you don't need to put a bare return at the end of a method, and I've added a docstring to explain what the class does. Thanks to the abstract base class, the following additional methods will now be implemented for you: __contains__, keys, items, values, get, __eq__, and __ne__, pop, popitem, clear, update, and setdefault. Because they all call through to the five fundamental methods defined above, it's guaranteed that any change through the MutableMapping interface (although not changes to _map directly) will invoke the callback, as it will always involve calling either __setitem__ or __delitem__.In use:The only downside to this is that if you have explicit type checking, you might have issues:However, you should generally be using the ABCs for your type checks, too (or just duck typing):I think when you ask "and that explains why I only see one callback with my example?" below you want to know why the following happens with our different implementations:This is due to the implementation of MutableMapping.clear; it loops over the keys in the dictionary, calls popitem for each one, which in turn calls __delitem__, which in turns calls the callback. By contrast, your implementation calls the callback only once, because you implement clear directly and call it from there.Note that the ABC approach doesn't prevent you from doing this. It's not clear from your question (and you may not yet know) which is the correct behaviour, but you can still come in and override the default implementations provided by the ABC:The reason I recommend using the ABC rather than subclassing dict is that this gives you sensible default implementations that you can override where you need to, so you only need to worry about where your behaviour differs from the defaults. Fewer methods implemented also means a smaller risk of simple typos like __delitme__ (if you don't provide a required @abstractmethod you get an error when you try to instantiate the class) and super().__init__(*a, *kw).


Answer URL
https://docs.python.org/3/library/collections.abc.html
https://docs.python.org/3/glossary.html#term-duck-typing
https://docs.python.org/3/library/collections.abc.htmlhttps://docs.python.org/3/library/collections.abc.html
https://docs.python.org/3/library/collections.abc.html
https://docs.python.org/3/library/abc.html#module-abc
