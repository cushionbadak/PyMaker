Natural Text
What is the cost (if any) of calling the str function on an object that is already a string? The use case here is to normalize an array of objects of different types and convert them into string, naively it can be implemented like so:But if the str() causes too much overhead, and my arr contains primarily strings, I may consider using:Any suggestions? 
Calling str on a string object is pretty cheap: it just returns the original string object. Calling isinstance explicitly will definitely be slower.If you want to test this on real data, take a look at the timeit module. BTW, you should eliminate the not from your 2nd version And you can speed things up slightly by caching str:Happy micro-optimizing. :)Why cache str? Well, each time you use a name, Python has to look for it. If you're inside a function, first it looks in the local namespace, and if it can't find the name then it looks in the globals. Even though str is built-in, it still "lives" in the global namespace; it would be inefficient to "import" all the built-ins into every function. By doingwe create a local name str that gets bound to the built-in str type, and because it's a default argument that search & bind process happens once, when the function definition is executed, not each time the function is called.So each time we call arr_2_strarr the interpreter will immediately find that local str, which will save a tiny amount of time. Here's some timeit code that compares the various strategies. It runs on both Python 2 & Python 3, although on Python 3 it substitutes str for basestr, since basestr doesn't exist in Python 3.This code runs the functions on lists of various sizes first with integer data, then with string data which is created by converting the integer data to strings. Each line of output gives the time to perform the given number of loops over 3 repetitions, sorted from fastest to slowest. As the timeit repeat docs mention, the main number to look at in each run is the smallest one.The results for all functions on a given list size and type are also sorted from fastest to slowest. typical Python 2 outputtypical python3 outputThese timings were performed on a rather old 32 bit single core 2GHz machine with 2GB of RAM running on a Debian derivative of Linux. I used Python 2.6.6 and Python 3.6.0. Your results may vary. ;) In any case, these results should only be used as a rough guide. timeit does a pretty good job of only timing the stuff we want to time, but it has no control over other processes that also want to use the CPU.
In these test cases it was twice as fast to just perform str(string) as opposed to using the conditional statement.


Answer URL
https://docs.python.org/3/library/timeit.html
https://docs.python.org/3/library/timeit.html#timeit.Timer.repeat
