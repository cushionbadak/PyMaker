Natural Text
I am learning c++ and in trying to code a little program i found something strange. It is about modulus :c++ code and python codeCan someone explain me that pls ? Thq 
This is a bit out of my expertise but its likely python follows the Donald Knuth remainder calculation which is: a + b*[a/b] being [] the floor operation. As so:results in:I'm a bit surprised C++ does not return the same (but I'm also not knowledgeable enough about the subject). EDIT: Made a quick search for this topic and learncpp mentions the reason why C++, specifically C++ 11, standardized the floor operation always towards 0. I quote:Prior to C++11, if either of the operands of integer division are  negative, the compiler is free to round up or down! For example, -5 /  2 can evaluate to either -3 or -2, depending on which way the compiler  rounds. However, most modern compilers truncate towards 0 (so -5 / 2  would equal -2). The C++11 specification changed this to explicitly  define that integer division should always truncate towards 0 (or put  more simply, the fractional component is dropped).Also prior to C++11, if either operand of the modulus operator is  negative, the results of the modulus can be either negative or  positive! For example, -5 % 2 can evaluate to either 1 or -1. The  C++11 specification tightens this up so that a % b always resolves to  the sign of a.Regarding Python you can take a look at the documentation for divmod which states:Take two (non complex) numbers as arguments and return a pair of  numbers consisting of their quotient and remainder when using integer  division. With mixed operand types, the rules for binary arithmetic  operators apply. For integers, the result is the same as (a // b, a %  b). For floating point numbers the result is (q, a % b), where q is  usually math.floor(a / b) but may be 1 less than that. In any case q *  b + a % b is very close to a, if a % b is non-zero it has the same  sign as b, and 0 <= abs(a % b) < abs(b)EDIT2: Even more information on the Python Programming FAQ regarding this subject.Why does -22 // 10 return -3? It’s primarily driven by the desire that  i % j have the same sign as j. If you want that, and also want:i == (i // j) * j + (i % j)then integer division has to return the  floor. C also requires that identity to hold, and then compilers that  truncate i // j need to make i % j have the same sign as i.There are few real use cases for i % j when j is negative. When j is  positive, there are many, and in virtually all of them it’s more  useful for i % j to be >= 0. If the clock says 10 now, what did it say  200 hours ago? -190 % 12 == 2 is useful; -190 % 12 == -10 is a bug  waiting to bite.
It looks phyton doesn't accept negative modulus results, so adds 100 to -25.print(-325 - (-325 % 100))
I don't really know much about it, but since you are learning C++,i would like to tell you something from my personal experience, that if you are making a program in C++ and you're using modulus operator, and you want +ve mod always, you should do something like this - I am not so sure on when and why, but a can take a negative value for any b and m (not only when b is -ve)


Answer URL
https://docs.python.org/3/faq/programming.html#why-does-22-10-return-3
