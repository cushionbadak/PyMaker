Natural Text
The goal of the code is to find the longest alphabetical substring within a string. When I run this code, it gives 'abbccd' as the longest substring, when it's actually 'abcd'. This is because it checks the character a, comparing it to the next in the sequence, and then adds a to b giving "ab". Then it checks b, comparing to c and adds bc together, and then adds "bc" to "ab". To fix this, I've been attempting to make the loop skip the next character if it's in alphabetical order already, and check the next one by increasing the value of 'n' once the condition is met, but this doesn't seem to do anything at all.Advice, tips, corrections and harsh criticism are all welcomed.EDIT: It appears I've misled some of you, so I apologise. What I meant was that if I have a string, it extracts the longest possible substring in alphabetical order. In the case of xyzbcdezzz, it will extract 'bcdezzz' because that's the longest possible alphabetical order substring, not bcde. The problem with my current code, is that it gives bccddeezzzzz. If I could skip one loop when the first if condition is true, then I think it might work in my code.
After your edit, it is clearer what was your question. I have modified your code as little as possible to show you where the bug in your solution came from.Here is the code:the problematic part was taking 2 chars at once in by replacing it with you will be adding to the current string exactly if the addition is valid (the last char current_string[-1] and the added wannabe s[n] are in order)The elif part is simplified to not check s[n] and s[n+1] because it does not reflect what we are trying to do : we do not care if the chars are not in order in the whole string s we care about our current string (this logic is caught by the if statement above and else will be visited only if there is a problem)so the change here istoadding a new winner if necessary and resetting the current string to the char that was not in orderThe last set of ifs are checking the case when current_string ends on the last char of the s, while this is correct it would be less distracting if you add a check after the loop and print only the longest_stringthis way the output is the first valid longest string in every case and not 2 different longest ones when one of them is on the tail of the string
TL;DR: the last code after the edit solves the problemThis is a variant of the Longest Common Substring Problem. Credits to this post for the subroutine. Edit:It seems like the above code doesn't work for all cases, so I had to redesign the function.Output:This works on the assumption that the substring should always begin with a. This iterates through every possible substring from 'a', 'ab', 'abc', ... , up to the full string of alphabets and then stores the longest substring encountered in the check. For the sake of completeness, here is the code that would work for any longest common substring:where one string contains the alphabets in order and the other contains the test string. Be aware that this is O(n^2) in complexity (not that it matters for small cases).
a different version looping over zip(strg, strg[1:]) in order to compare the previous and the current character in the same loop iteration:comparing the characters with ord this way has the disadvantage that these characters !"#$%&'()*+,-./0123456789:;=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_``abcdefghijklmnopqrstuvwxyz{|}~ will be considered as 'in alphabetical order'. you may need to tweak that to your needs...
From an algorithmic perspective, the most optimized approach is using a Suffix Tree in order to find the longest sub string in a given string. (I've implemented an optimized version of the suffix tree in python a while ago. In case you're interested you can check https://github.com/kasramvd/SuffixTreeAs another hacky way you can utilize the Numpy in order to find the largest sub-string using the diff(), where() and split() functions:Explanation:The logic behind this code is to find the indices of the characters that the difference of their ascii value is 1.                         In numpy we can simply do that by np.diff function. But since it needs an array of items we can use a list comprehension to pass the list of intended values to the function. Then by comparing the result with 1 we can get a list of bool array as follows:Now we can get the indices of the False items using np.where to pass them to split function:The +1 is actually because np.split splits from 0 to our first index and then from first index to the next and etc.And at the end we can get the longest array using max function by passing the len as the key function.Also note that this approach will give you the longest consecutive sequence, if you just care about the order you can replace the == 1 with > 0. Here is an example:
Here's a simple, efficient and (IMO) quite readable solution, which dodges the "what does alphabetical order actually mean" issue by taking a custom test function as a parameter:You can use it e.g. like this:which will print "abcd".  If you'd like to use a case-insensitive comparison, and/or to ignore non-alphabetic characters entirely, you can do that by changing the test function, e.g. like this:Of course, by defining a suitable test function, you can also use the same longest_matching_substring function to find the longest consecutive substring where the adjacent pairs of characters satisfy any arbitrary criterion (like, say, "does not contain a consonant followed by a vowel").  And you can even use the same function for finding longest matching consecutive subsequences in other sequence types like lists and tuples, not just in strings.(This implementation does not, however, work for arbitrary iterable types; to handle those, we'd have to memorize the current and the longest matching substring as we iterate over the input.  While doable, that would somewhat complicate the code, and also make it less efficient for ordinary strings and other sequence types.)
How about using a base string of the alphebetic characters and check if the substring is into this base string then return the max substring found in the base string based in its lenght ? This is an example:Output:
Using iteration:
Here's my implementation:Tests (taken from @salparadise's answer):I haven't compared the performance against the other proposed answers and keep in mind that it is case sensitive and expects the string to consist of characters.If necessary, you could first extract only the letters from the string and convert it to lowercase by using:
I Tweaked you code a little, and tried it.It seems to work perfectly.I am still a learner, don't mind my minor mistakes if there are any. Add your string as s='....'


Answer URL
https://docs.python.org/3/library/functions.html#zip
https://docs.python.org/3/library/functions.html#ord
