Natural Text
Here's a little bench-marking code to illustrate my question:Basically I want a numpy array to be shared between multiple processes because it's big and read-only. This method works great, no extra copies are made and the actual computation time on the processes is good. But the overhead of creating the shared array is immense.This post offered some great insight into why certain ways of initializing the array are slow (note that in the example above I'm using the faster method). But the post doesn't really describe how to really improve the speed to numpy like performance.Does anyone have any suggestions on how to improve the speed? Would some cython code make sense to allocate the array?I'm working on a Windows 7 x64 system.
This is slow for the reasons given in your second link, and the solution is actually pretty simple: Bypass the (slow) RawArray slice assignment code, which in this case is inefficiently reading one raw C value at a time from the source array to create a Python object, then converts it straight back to raw C for storage in the shared array, then discards the temporary Python object, and repeats 1e8 times.But you don't need to do it that way; like most C level things, RawArray implements the buffer protocol, which means you can convert it to a memoryview, a view of the underlying raw memory that implements most operations in C-like ways, using raw memory operations if possible. So instead of doing:use memoryview to manipulate it as a raw bytes-like object and assign that way (np.arange already implements the buffer protocol, and memoryview's slice assignment operator seamlessly uses it):Note, the time for the latter is milliseconds, not seconds; copying using memoryview wrapping to perform raw memory transfers takes less than 1% of the time to do it the plodding way RawArray does it by default!
Just put a numpy array around the shared array:then time:No need to figure out how to cast the memoryview (as I had to in python3 Ubuntu 16) and mess with reshaping (if x has more dimensions, since cast() flattens). And use sh_np.dtype.name to double check data types just like any numpy array.  :)
On ms-windows when you create a Process, a new Python interpreter will be spawned which then imports your program as a module. (This is why on ms-windows you should only create Process and Pool from within a if __name__ is "__main__" block.) This will recreate your array, which should take about the same time as creating it originally did. See the programming guidelines, especially concerning the spawn start method which has to be used on ms-windows.So probably a better way is to create a memory mapped numpy array using numpy.memmap. Write the array to disk in the parent process. (On ms-windows this must be done in the if __name__ is "__main__" block, so it's only called once). Then in the target function use numpy.memmap in read-only mode to read the data.


Answer URL
https://docs.python.org/3/library/stdtypes.html#memoryview
https://docs.python.org/3/library/multiprocessing.html#programming-guidelines
