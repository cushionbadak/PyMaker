Natural Text
I am very often confronted to this case and did not manage to discover a stable way to deal with it.Suppose I have a class defined like that:Property c may be now be retrieved by:However, every time I ask for obj.c, the heavy computations will be performed, resulting in a poor performance code as c results from heavy computations and it would preferably be calculated only while a or b is set or modified.What would the better way to deal with this case ? I am thinking of creating a c_update method to use as a decorator for some @a.setter and @b.setter decorated methods but is that the better way ?Regards,
There is a small pypi package that fits well: cached-propertyOf course you could also build an abstraction for the a/b properties on top of that, that utilizes del self.c.One benefit of using cached_property is that you can easily make the cache thread-safe by changing it to threaded_cached_property.
But what if I have a lot of XX dependent properties that rely on a and b values. Do I have to write an update_XX method for each of them and add this method to init and to each a.setter and b.setter ? That seems to me quite verbose...You can have the c value (and any other number of dependent properties) updated everytime either a or b is mutated, I implemented an update_properties() method below:Do you think it would be possible to implement this machinery as some decorators in order to lighten the code The verbosity seems to be only on the side that tracks the free variables (e.g. here a and b), so if I had to support an arbitrary number of those, I would implement a MyClass.set_value(name, value)So the idea here is that our set_value() can work with an arbitrary number of attributes. And it's possible to call it from __init__ if you use **kwargs to unpack the key-values passed to the constructor.One requirement here, since we haven't set the free variables as @property we're required to use obj.set_value('a', 42) instead of obj.a = 42
I'd simply store the actual value of c in a private attribute and check if this is not None. Set this to None when either a or b changes.So the "proper" way of doing this using properties would be:If you want to avoid creating all these properties and setters you probably want to hijack the __getattr__ and __setattr__ methods instead:Note that this last solution could be extended to like 10 attributes a1, ..., a10 without having to define 10 properties and setters.It's probably a bit less robust.
So based on your answers, I managed to build a new answer using a dict for dependent properties.This seem to do the trick but it is still quite verbose... and I have still to write a property for each of the dependent property I am expecting. However, it does force the calculation of update_dependent_properties() when either attribute a or b is modidied.I wonder if it does not exist a module to do it. It seem that my problem sounds like memoize technique... and may a decorator lighten the code by systematizing the procedure ?


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__getattr__
https://docs.python.org/3/reference/datamodel.html#object.__setattr__
