Natural Text
I have the following code that is leveraging multiprocessing to iterate through a large list and find a match.  How can I get all processes to stop once a match is found in any one processes?  I have seen examples but I none of them seem to fit into what I am doing here.Thanks for your time.UPDATE 1:I have implemented the changes suggested in the great approach by @ShadowRanger and it is nearly working the way I want it to.  So I have added some logging to give an indication of progress and put a 'test' key in there to match.I want to be able to increase/decrease the iNumberOfProcessors independently of the num_parts.  At this stage when I have them both at 4 everything works as expected, 4 processes spin up (one extra for the console).  When I change the iNumberOfProcessors = 6, 6 processes spin up but only for of them have any CPU usage.  So it appears 2 are idle.  Where as my previous solution above, I was able to set the number of cores higher without increasing the num_parts, and all of the processes would get used.I am not sure about how to refactor this new approach to give me the same functionality.  Can you have a look and give me some direction with the refactoring needed to be able to set iNumberOfProcessors and num_parts independently from each other and still have all processes used?Here is the updated code:UPDATE 2:Ok here is my attempt at trying @noxdafox suggestion.  I have put together the following based on the link he provided with his suggestion.  Unfortunately when I run it I get the error:... line 322, in apply_async    raise ValueError("Pool not running")ValueError: Pool not runningCan anyone give me some direction on how to get this working.  Basically the issue is that my first attempt did multiprocessing but did not support canceling all processes once a match was found.  My second attempt (based on @ShadowRanger suggestion) solved that problem, but broke the functionality of being able to scale the number of processes and num_parts size independently, which is something my first attempt could do.My third attempt (based on @noxdafox suggestion), throws the error outlined above.If anyone can give me some direction on how to maintain the functionality of my first attempt (being able to scale the number of processes and num_parts size independently), and add the functionality of canceling all processes once a match was found it would be much appreciated.Thank you for your time.Here is the code from my third attempt based on @noxdafox suggestion:
You can check this question to see an implementation example solving your problem.This works also with concurrent.futures pool.Just replace the map method with apply_async and iterated over your list from the caller.Something like this.grouper recipe
multiprocessing isn't really designed to cancel tasks, but you can simulate it for your particular case by using pool.imap_unordered and terminating the pool when you get a hit:This will run do_job for each part, returning results as fast as it can get them. When a worker returns True, the loop breaks, and the with statement for the Pool is exited, terminate-ing the Pool (dropping all work in progress).Note that while this works, it's kind of abusing multiprocessing; it won't handle canceling individual tasks without terminating the whole Pool. If you need more fine grained task cancellation, you'll want to look at concurrent.futures, but even there, it can only cancel undispatched tasks; once they're running, they can't be cancelled without terminating the Executor or using a side-band means of termination (having the task poll some interprocess object intermittently to determine if it should continue running).


Answer URL
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future.cancel
