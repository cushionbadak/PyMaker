Natural Text
In Python, I have a function that takes a list of URL's(url_list) and add headers. The list can have up to 25,000 urls so I wanted to try and make use multiprocessing. I tried the following code but I think it isn't truely doing multilprocessing because of the join. How can I make this truely mutliprocessing? 
You definitely don't want to create 25000 child processes that each handles 1 URL. But you also don't want 1 process that handles 25000 (which is what you've built). You probably want, say, 8 processes, each handling about 1/8th of 25000.You could do this by creating a Queue full of URLs, creating 8 processes to loop around servicing that queue by pulling the next URL and doing the work, and then joining all 8 processes.But what you'd be doing is building a process pool. And there's already one built in to multiprocessing. On top of being already built and debugged, it also has features you probably wouldn't think of yourself. It can also pass results back, in various different ways. It lets you chunk up batches of a few URLs at a time (if you give each process a full 1/8th of the list, there's no load balancing; if you give each process 1 at a time, you're wasting time on inter-process communication that could be spent doing real work). And so on.So, let's just use that:The only real problem with this code is that you're waiting for it to build up a list of 25000 results, which are all None. There are other ways you can wait on it without building up return results, but really, the cost of this list isn't worth the extra complexity to deal with it.The reason I used a lambda there is that you need a function that just takes each url, and you only have a function that takes each url plus a headers argument. You can create that function by defining a new wrapper with lambda or def, or by calling a higher-order function that does it for you like partial. These are basically equivalent:You may also want to consider using an Executor instead of a plain pool. An Executor returns smarter result objects called Futures that in many cases are easier to deal with. (For example, instead of having to decide between the four different map variants in Pool, you can just create a comprehension over the simple submit method, and then call as_completed or wait on the resulting Futures.) Since this wasn't added to Python until 3.2, for 2.x you'll have to install the backport library futures to use it. Anyway, for a trivial case like this, it isn't going to be much different:â€¦ or:


Answer URL
