Natural Text
Let C be a Python class and assume that the constructor of C takes an integer as argument.Consider now the instructionsThe default behavior of Python implies that x and y occupy two different place in the memory.Is it possible to force x and y to share the same place in memory?I would be very happy if some Python decorator makes the job.[Note] I am looking for a way to memoize constructors (see http://en.wikipedia.org/wiki/Memoization for the memoization of functions).[Add] The Sage Open Source Mathematics Software provides a very good solution to this problem through the class UniqueRepresentation (see here). Any class should inherit from this one to have the expected behavior. Nevertheless, I am wondering if there is a pure Python solution to this problem.
You may want to use lru_cache.  If your class definition isthen it behaves likeHowever, this makes the name C a function, and any class features aren't usable before the class is actually instantiated.  If you want, you can also directly cache the method __new__, which is responsible for the creation of the object.  __new__ is a method which takes all the same arguments as __init__ and it is called before __init__ when we create class instances.As caching the output of __new__ is straightforward, we could make things a little bit more interesting.  Let's create a new decorator, which works just like lru_cache, but it can be used with classes to cache the output of __new__:We give __new__ all possible arguments and keyword arguments so that it can be used with other classes as well.  Now we can cache the instances of class C2 like this:And we can see that the objects are cached:There is, however, another subtle difference in this approach compared to the first.  For instance:This behavior is expected because __init__ is called anyway, although the object's memory location remains the same.  Depending on your use case, you may want to cache the output of __init__ as well.
You could just override the __new__ to store cached versions of each object:Demonstration:Obviously, if you later change x instead of creating a new class, it won't become the same object as one previously defined with that value of x:
If you are willing to have a function create the class instance for you, this might work.  Assuming you have your class C that accepts an integer:Use it like this:I am taking advantage of the fact that if you use a mutable object as a default argument to a function, the same mutable object is used for each time the function is called.EditIf you wanted to make this generic (assuming all your classes need a single number), you could do the following:You can use it like this:


Answer URL
https://docs.python.org/3/library/functools.html#functools.lru_cache
