Natural Text
I'm running a program which is processing 30,000 similar files. A random number of them are stopping and producing this error...The source/creation of these files all come from the same place. What's the best way to correct this to proceed with the import?
read_csv takes an encoding option to deal with files in different formats. I mostly use read_csv('file', encoding = "ISO-8859-1"), or alternatively encoding = "utf-8" for reading, and generally utf-8 for to_csv.You can also use one of several alias options like 'latin' instead of 'ISO-8859-1' (see python docs, also for numerous other encodings you may encounter).See relevant Pandas documentation,python docs examples on csv files, and plenty of related questions here on SO.To detect the encoding (assuming the file contains non-ascii characters), you can use enca (see man page) or file -i (linux) or file -I (osx) (see man page). 
Simplest of all Solutions:Open the csv file in Sublime text editor.Save the file in utf-8 format.In sublime, Click File -> Save with encoding -> UTF-8Then, you can read your file as usual:EDIT 1:If there are many files, then you can skip the sublime step.Just read the file usingand the other different encoding types are:
Pandas allows to specify encoding, but does not allow to ignore errors not to automatically replace the offending bytes. So there is no one size fits all method but different ways depending on the actual use case.You know the encoding, and there is no encoding error in the file. Great: you have just to specify the encoding:You do not want to be bothered with encoding questions, and only want that damn file to load, no matter if some text fields contain garbage. Ok, you only have to use Latin1 encoding because it accept any possible byte as input (and convert it to the unicode character of same code):You know that most of the file is written with a specific encoding, but it also contains encoding errors. A real world example is an UTF8 file that has been edited with a non utf8 editor and which contains some lines with a different encoding. Pandas has no provision for a special error processing, but Python open function has (assuming Python3), and read_csv accepts a file like object. Typical errors parameter to use here are 'ignore' which just suppresses the offending bytes or (IMHO better) 'backslashreplace' which replaces the offending bytes by their Pythonâ€™s backslashed escape sequence:
after executing this code you will find encoding of 'filename.csv' then execute code as followingthere you go
Struggled with this a while and thought I'd post on this question as it's the first search result.  Adding the encoding='iso-8859-1" tag to pandas read_csv didn't work, nor did any other encoding, kept giving a UnicodeDecodeError. If you're passing a file handle to pd.read_csv(), you need to put the encoding= attribute on the file open, not in read_csv. Obvious in hindsight, but a subtle error to track down.
This answer seems to be the catch-all for CSV encoding issues. If you are getting a strange encoding problem with your header like this:Then you have a byte order mark (BOM) character at the beginning of your CSV file. This answer addresses the issue:Python read csv - BOM embedded into the first keyThe solution is to load the CSV with encoding="utf-8-sig":Hopefully this helps someone.
In my case, a file has "USC-2 LE BOM" encoding, according to Notepad++. It is encoding="utf_16_le" for python. Hope, it helps to find an answer a bit faster for someone.
I am posting an update to this old thread. I found one solution that worked, but requires opening each file. I opened my csv file in LibreOffice, chose Save As > edit filter settings. In the drop-down menu I chose UTF8 encoding. Then I added encoding="utf-8-sig" to the data = pd.read_csv(r'C:\fullpathtofile\filename.csv', sep = ',', encoding="utf-8-sig").Hope this helps someone.
Try specifying the engine='python'. It worked for me but I'm still trying to figure out why.


Answer URL
https://docs.python.org/3/library/codecs.html#standard-encodings
