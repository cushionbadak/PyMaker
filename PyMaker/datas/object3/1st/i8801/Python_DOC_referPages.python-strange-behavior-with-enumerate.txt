Natural Text
I know I'm not supposed to modify the list inside a loop, but just out of curiosity, I would like to know why the number of iterations is different between the following two examples.Example 1:Example 2:Example 1 runs only 3 times because when i==3, len(x)==2. Example 2 runs 5 times even though len(x)==1.So my question is, does enumerate generate a full list of (index, value) pairs at the beginning of the loop and iterate through it? Or are they generated on each iteration of the loop?
enumerate() returns an iterator, or some other object which supports iteration. The __next__() method of the iterator returned by enumerate() returns a tuple containing a count (from start which defaults to 0) and the values obtained from iterating over iterable.__next__() returns the next item from the container. If there are no further items, raise the StopIteration exception.Does enumerate() generate a full list of (index, value) pairs at the beginning of the loop and iterates through it? Or are they generated on each iteration of the loop? So, enumerate() returns an iterator and at every iteration, __next__() checks if there are further items. enumerate() doesn't create a full list at the beginning of the loop. As, @Wisperwind mentioned, in your second case, you're assigning a new object to the name x. The object, the loop iterates over does not change during the iteration.
In the first example, you're actually modifying the list you're iterating over.On the other hand, in the second case, you're only assigning a new object to the name x. The object the loop iterates over does not change, though.Have a look at http://foobarnbaz.com/2012/07/08/understanding-python-variables/ for a more detailed explanation about names and variables in Python.
Just a clarification to what Wasi Ahmad and Wisperwind have said.  Both state that "you're only assigning a new object to the name x".  This might be slightly confusing as it might be interpreted as saying "you're creating a new object ([1]) and storing it to the name x, to which you'd say "Well yah, so why isn't it changing?!"  To see what's happening, print out the id of the object You'll notice that the id of x is changing each time through the loop and when you're finished with the loop, x will point to the last modification made in the loop.  When you're going through your loop, it is iterating over the original instance of x, regardless of whether you can still reference it.  As you can see, y points to the original x.  As you make your iterations through the loop, even though x is changing, y is still pointing to the original x which is still being looped over.
Indeed: Your first snippet modifies the iterated-over list in place; the second points the variable x to a new list, leaving unmodified the list transversed by enumerate(). You can see this in action by going to the following links on www.pythontutor.com, which allow you to single-step over your code and visualize the contents of your variables:First version (x is modified in place).Second version (x is redirected to [1]).To better see what's going on, go here instead to step over the following expanded code:
Others have already pointed out that your second example only changes the value to which x points, but not the list over which you're iterating. This is a perfect example for the difference between ordinary assignment (x = [1]) and slice assignment (x[:] = [1]). The latter modifies the list x points to in-place:will print
The list [1, 2, 3, 4, 5] is 'tagged' with xenumerate() attaches another tag, so [1, 2, 3, 4, 5] is now tagged x and y. enumerate() will continue using the y tag, not the x tag. The list stored in memory is modified, so x and y now both refer to [2, 3, 4, 5]Alternatively, when you useA new list [1] is created in memory, and the x tag now points to that. The y tag is still pointing to the original list.How Python variable work:http://foobarnbaz.com/2012/07/08/understanding-python-variables/


Answer URL
https://docs.python.org/3/library/functions.html#enumerate
https://docs.python.org/3/library/stdtypes.html#iterator.__next__
https://docs.python.org/3/library/functions.html#enumerate
https://docs.python.org/3/library/stdtypes.html#iterator.__next__
