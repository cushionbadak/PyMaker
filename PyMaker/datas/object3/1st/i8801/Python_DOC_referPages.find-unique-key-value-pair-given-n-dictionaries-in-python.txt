Natural Text
I would like to find an easy and/or fast way to find all common couple (pair: value) given N dictionaries in python. (3.X would be best)PROBLEMGiven a set of 3 dicts (but it could be any dict, it is just for the example)The result for common (key: values) for n1, n2 and n3should be:And for n2 and n3 it should beI first though about using a brute force algorithm that will check every pair (key: value) for every dictHere is a implementation using a recursive algorithmSOLUTION ABut it is not easily understandable and the complexity is high(I'm not sure how to calculate complexity; but since we compare all the elements on all dict, the complexity should be O(N²)?)Then, I though about Sets. because it could naturally compare all the elementSOLUTION B It is so much better than the previous solution, unfortunately, when one of the key have a list as values it throws an error:TypeError: unhashable type: 'list'My question is then double:is there any better algorithm than SOLUTION A? or is there a way to avoid the TypeError with SOLUTION B?of course, any other remarks will be welcome.
Simpler and more efficient way:Using an extra variable for list_dict[1:] might be beneficial, otherwise the short-circuiting of all somewhat goes to waste. Or if you don't need the list afterwards you could just pop the "master" dictionary:Or using get with a default that cannot be in the dictionary as suggested by @Jean-FrançoisFabre:
If unhashable values are a problem you can always compute the intersection of the keys up-front by using .keys() and then compare only the values associated with the keys that all dictionaries have in common:This should be pretty faster than solution a, slower than solution b, but works on all inputs.
A batteries-included version.To handle unhashable types, we use pickling; replace it with dill or json or any other predictable serialization to taste.Note that serialization only goes so far. To properly compare dicts if dicts, for instance, these dicts must be turned into (key, value) pairs and sorted before serialization. Any structures that reference each other may have issues (or not). Replace pickling with a custom predictable serializer if you care about these issues.


Answer URL
https://docs.python.org/3/tutorial/datastructures.html#sets
