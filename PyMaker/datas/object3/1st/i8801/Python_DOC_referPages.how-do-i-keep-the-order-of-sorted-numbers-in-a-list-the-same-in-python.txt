Natural Text
I have a function in which:Given a list of Python values xs and a non-negative integer n, construct and return a copy of xs but with each value replicated n times. Do NOT modify the original list 'xs'To do this, I created some small code that multiplied the list xs and then sorted it. def replicate(xs,n):    xscopy = sorted(n * xs)    return xscopy This code will result in a function input like "replicate([1,2,2,3],2)" to output as [1,1,2,2,2,2,3,3] which is correct. Note how the correct output has the numbers' places matching. However, when a negative number is in the list, the 'sort' function sees the negative number as smaller than the positive numbers and shifts the position of the negative number from where it was originally on the list. For example: replicate([1,-1,2,1],2) outputs to [-1,-1,1,1,1,1,2,2] rather than, the correct version, [1,1,-1,-1,2,2,1,1]. Notice how the negative 1 shifted?I am required to use a loop of some sort (while or for) for this task and I can't figure out how I could incorporate a loop that would both preserve the positions of the numbers and append the numbers properly into a new list (a new list that contains both the original xs, and the duplicates, in the same order as the original.EDIT: I should add that list comprehension is restricted for this task
You don't need to sort it. For each number in the list, loop n times and add it to a new list, so you preserve the original list and still get what you wanted.A cleaner way would be using list comprehension return [num for num in xs for _ in range(n)]Either way, output of  replicate([1,-1,2,1],2) is [1, 1, -1, -1, 2, 2, 1, 1]
You could just use a nested list comprehension if you want to keep the order of the elements from the original list, this will take each element from the list xs, repeat it n times and then go for the next element and so on:

You can create a single-element list, and then multiply it. Once you have an n-element list, you can extend() the result list with that portion of the result.The functools.reduce function can be used for this:The sum builtin can do something similar:The itertools.chain function can paste together a bunch of iterables, so you could just multiply the values into a bunch of sub-lists and pass them to it:Or, without the splat (*) operator:Or, you could zip the original list against itself, then flatten those tuples. (This would be good for long lists, especially if you could just return the iterable instead of a list):


Answer URL
https://docs.python.org/3/library/itertools.html?highlight=itertools.chain#itertools.chain
https://docs.python.org/3/library/itertools.html?highlight=itertools.chain#itertools.chain
