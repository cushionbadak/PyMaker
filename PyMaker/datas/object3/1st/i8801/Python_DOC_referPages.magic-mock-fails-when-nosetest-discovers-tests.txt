Natural Text
I'm using MagicMock to test a function in a web app. The function is imported directly from a module.The expected behaviour is: when the function being tested is called, it calls on a third party api (but I'm mocking this for my test). That returns a dictionary and the function under test inserts that into an object and returns the object.That works fine when I use nosetests to run that specific module of tests.When I use nosetests to discover and run tests in my test/unit/ folder, the test doesn't work as expected. Instead the mocked API returns a NoneType and the function being tested returns a Magic Mock instance.The test:The function being tested (in user_service module):Can you please help me understand why the result is inconsistent?EDITNew information - if I use nosetests on the module directly, the function I'm testing accesses the mocked Facepy dictionary values as unicode (as expected). If I user nosetests to discover tests, or if I use the solution posted by dm03514 below and run the tests directly, the function accesses the dictionary from the mocked facepy API as Magic Mock instances. Meaning, each result of accessing the dict is an Magic Mock instance. That's confusing, as I set the return_value (in all tests) to be the dictionary.
Sorry long day, so can't really mentally parse through why things are working the way they currently are :pBut to solve it so it performs the same way regardless of where the test is executed, is to patch facepy import in the user_service module.The above patches the facepy local to user_service module.
My issue was a misunderstanding about the way MagicMock handles dictionaries. You need to declare its __getitem__ property.I think the "inconsistency" I mentioned was more of being a fluke that my tests worked at all.This borrows heavily from @dm03514's answer.


Answer URL
https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch
