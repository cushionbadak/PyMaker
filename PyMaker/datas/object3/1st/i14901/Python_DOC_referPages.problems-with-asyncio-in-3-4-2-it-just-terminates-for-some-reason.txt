Natural Text
A newbie at python and spending many hours reading docs and other code I cannot seem to get the new asyncio module in Python 3.It keeps on terminating without a stack trace to give me a clue and should run forever but does not.The fundamental process concept I am trying to emulate is the following:read from port:open port -> read data (variable length) -> place on queue1then process data:get data from queue1 -> condition applies -> outcome put on queue2then write to port:get data from queue2 and write to portloop around from top foreverNote: The data on the in port is sporadic, variable length and several blocks may arrive out of 'sequence' thus I use asyncio. I understand asyncio will allow the case of a block arrives, then another prior to my app responding - i.e. the call get_io_from_port() facilitates multiple executions of the co-routine. This is why I have use the queues to ensure non-blocking of the process_queue()My toy example code so far:Also, as an aside - how does one debug this code - ie tracing? What techniques could be suggested? I am using Eclipse and PyDev but to no avail.
You've made several mistakes here. First, you're treating main like its a normal function, but you've placed a yield from call in there, which will automatically convert it into a generator. That means when you domain is not actually executed; the call to main() just creates a generator object that's immediately thrown away (because you're not assigning it to a variable). This is why you're having a hard time debugging - none of the code inside main is even executing. You should convert main to be a coroutine and call it using loop.run_until_complete instead.Next, you're trying to use the queue module, which is not designed for use in a single-threaded asynchronous program. As soon as you call queue.get(), it's going to block your main thread, which means your asyncio event loop will be blocked, which means your whole program will be deadlocked. You should use the coroutine-safe asyncio.Queue instead.You also have a race condition in put_io_to_port. You're only trying to consume from q2 if it isn't empty, but its possible that put_io_to_port could execute before process_queue has a chance to run and populate the queue. It looks like you would be fine if you just removed the if not q2.empty() check from put_io_to_port altogether.Finally, you're adding your coroutines to the event loop using asyncio.async, which is fine. But you have a comment that says # do these tasks, in this order, but that's not how the program will behave with asyncio.async. It just adds all the coroutines to the event loop, and they'll all run in parallel. If you really want them to run sequentially, you should just do:But that's really not necessary here. You can run all of them at the same time and get the correct behavior; if one coroutine executes ahead of the other, it will just wait until the coroutine it depends on passes it the data it needs, and then resume execution.You also have a few typos in there (q1.Get(), q2.put =(...), etc).So, put all those fixes together and you get this:
Find comments inline with code to understand the problem.


Answer URL
https://docs.python.org/3/library/asyncio.html
https://docs.python.org/3/library/asyncio-queue.html#asyncio.Queue
