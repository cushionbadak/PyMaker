Natural Text
I have a function let's say def temp.i am mocking it the following way:Its a huge project so cant post the details here.But what's happening is the function temp does get mocked and i do get the correct message but later on i get stop called on unstarted patcher and the program fails.Is there any workaround here,which somehow disables the _exit of mock or any other method.i guess the contents is somehow insufficient to create the whole scenario but that's d best i can do.Also,what happens if i dont provide mock_A to function def temp.What does the patch work on in that case?EDIT:I have got a workaround wherein i have defined my patch as follows:Now the question is 1)When i used side_effect or return_value i had to provide a mock_object to the function following the decorator.2)When i just used a function instead of side_effect,i need not provide a mock_object to the function following the decorator..So,When we dont pass mock_obj,do all the function know about the patch?how exactly is this working?What is the difference between the scenario wherein we have to explicitly pass mock_object and wherein we dont have to?(P.S is this something to do with new_callable thing in the definition of patch.)
First base things about patch:Inside the body of the function or with statement, the target is  patched with a new object. When the function/with statement exits the  patch is undone.If new is omitted, then the target is replaced with a MagicMock. If  patch() is used as a decorator and new is omitted, the created mock is  passed in as an extra argument to the decorated function. If patch()  is used as a context manager the created mock is returned by the  context manager.The first one tell us that patch act as context manager in the body of the function (decorator case). The second one tell if you don't specify new argument (the first after targeting arguments in patch class function) patch create a new MagicMock() object to patch the target and the created mock is passed in as an extra argument to the decorated function.That explain the last section of the question because byyou replace Someothermodule.Someclass.Somefunction by some_function object and patch decorator doesn't need to pass it to temp. Now come back to the root of the question: the stop called on unstarted patcher error message.That means you try to remove the patch more that once. How could it possible? If you took a look to mock.py code you can easily understand that patch doesn't support stack of patches and it was designed to be executed just one time per context. In other words if you try to patch something that is already patched in your context you will get the same error. At the end of the answer I provided a synthetic example that generate the error.Without saw your code I can just do some guess and speculations about why your issue seams fixed if you don't use mock but patch your method by a function. IMHO it work just by chance and you playing with some kind of race condition.What I can do is give you a way to catch your problem and a good work around.To catch if you are calling __exit__ more that once in your patch simply use patch as a contex manager and override __exit__. An untested way to do it could be:Finally the workaround (to use just if you don't find any way to fix the double call)It easy to extend it and write the decorator too... but I think it is enough for a workaround.That is a synthetic example that generate stop called on unstarted patcher error message. To generate it we must call patch one more time while we are just in patch context. We can do it by recursion or by threads, recursion is something really strange in this context.target call patched method and start a new thread that call t() too. I used an Event() to force the error and make the race condition always true. 


Answer URL
https://docs.python.org/3/library/unittest.mock.html#patch
