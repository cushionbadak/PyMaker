Natural Text
The following example returns True in Python 2.x, while it returns False in Python 3.xI can't find any explanation for the difference. bool(b'\x00') returns True in both Python 2.x and Python 3.x. I will expect the value true as the byte sequence contains an element there evaluates to True.Which part of the language specification / documentation have I miss? 
On Python 2.x, when iterating over a byte string such as b'\x00\x00\x00', its components are yielded by the iterator as sub strings:This is because byte strings are just strings in Python 2 and thus show the same behaviour.OTOH, if we use python 3, a byte string yields its contents as ints:And from this difference, everything else is clear: as we already have noted, bool(b'\x00') is True while bool(0) is False.The same holds true when iterating over one element strings: list(b'\x00') gives ['\x00'] in Py2 and [0] in Py3, [bool(i) for i in b'\x00'] gives [True] in Py2 vs. [False] in Py3, and thus the difference.Note that are semantically the same: iterate over the given object, get the truth value of every item and return of any of them is True.TLDR: b'\x00'[0] == b'\x00' in Python 2 and 0 in Python 3.
In Python2, b'\x00' is type str. In Python3, b'\x00' is \type bytes.In Python3While bytes literals and representations are based on ASCII text, bytes objects actually behave like immutable sequences of integers, [...](https://docs.python.org/3/library/stdtypes.html#binaryseq)Thus, in Python3, your byte string is composed of the integer 0, which is False. In Python2, it is composed of a str "character", which is nonempty, and therefore True.


Answer URL
https://docs.python.org/3/library/stdtypes.html#binaryseq
