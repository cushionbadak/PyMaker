Natural Text
I want to subclass int (or some other analogous builtin numerical type), that I can explicitly type check.  This q&a is similar, but didn't answer what I'm seeing exactly:Sub-classing a built-in Python type such as intHere's a rough example of what I'm trying to achieve: Unfortunately, my invocation of isinstance returns False. How do I make it succeed (ideally with this same basic concept)? It's obvious how to achieve is this by giving MyId class a "has a" rather than "is a" relationship with int... but I thought it be nicer to just make it an int with a specific "name".Currently, I'm writing this in Py2, but any cross version answers are appreciated if applicable. 
That's because you need to override the __add__ method.If you don't override this method, it will use the builtin int __add__ method which returns a new integer object.See this topic which explains this behavior as mentioned by @martineau in comments. Prints: isinstance True
Instead of subclassing int just check that your instance variable is an int.
It sounds like what you're after is being able to check that values being passed around have been created in a specific way. In Python 3.5.2+ there is the typing module that provides NewType. This allows you to do static analysis of your code to make sure it's doing the things you expect it to do. The example given in the documentation is:The static type checker will treat the new type as if it were a subclass of the original type. This is useful in helping catch logical errors:No actual type checking is performed at runtime, and the value returned by NewType is just a pass-through function that returns its argument unchanged. This also means you cannot do things like isinstance(obj, UserId), since UserId is not an actual class. What is does mean is, as mentioned by the documentation, static type checkers will help uncover logical errors -- which seems like what you're after.
Per Dunes' suggestion, I simply dropped the entire int concept entirely. As he pointed out, any vanilla object can implicitly be used as a unique key!In fact MyId could be defined as simply: class MyId: pass. Often, that would be it - a perfectly usable, implicitly unique key!For my use case, however, I need to pass these keys back and forth across sub processes (via multiprocessing queues).  I ran into trouble with that ultra light weight approach, as the hash value would change when the objects where pickled and pushed across processes.  A minor secondary concern was that I wanted to make these objects easy to log and manually read / match up through logs.  As such, I went with this:As you can see, I wrapped the short and sweet approach into a more comprehensive/verbose one. When I create the MyId object, I create a _MyIdPrivate member, and take the hash of that at that moment of creation.  When pickling, and pushing across sub projects, that _MyIdPrivate hash will change - but it doesn't matter because I captured the initial value, and everything ends up pivoting off of that.  The main benefit of this approach over the original int plan is that I get a unique key without "calculating" or assigning it directly.  As Dunes' suggested I could have also used a uuid. I can see pros and cons to that vs this...


Answer URL
https://docs.python.org/3/library/typing.html#newtype
https://docs.python.org/3/reference/datamodel.html#object.__hash__
