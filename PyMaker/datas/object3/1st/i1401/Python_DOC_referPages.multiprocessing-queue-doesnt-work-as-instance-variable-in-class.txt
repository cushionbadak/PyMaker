Natural Text
I want to encapsulate a multiprocessing task into a class. Both control and worker functions are members of the class. The workers are run using Pool.map_async(), so the results can be processed while other workers are still running. The results for processing are stored in multiprocessing.Queue. When the Queue is an instance variable, it doesn't work, whereas global variable or class variable, it works.Example:Now, when you call class as follows (put it below classes definitions)              does not work (probably stops waiting on self.qout.get(), butandworks (prints results). Why?I haven't found any relevant info in Python documentation. I haven't tried to pass the queue as an argument, but it is a feature which should be hidden from the user.The B option should be out of question, C is not ideal, as the queue would be shared between all instances of the class.Note: This is tested on Linux (Debian, Python 3.5 from repository). 
This isn't an answer. I'm posting it because it's complete, runnable,  and shows what I used to come to the conclusion that none of your classes "work"—in fact, class A is the only one whose while loop finishes (without printing anything though), whereas in both class B and C it never ends.Note also that I know that due to the commonality of these three classes, they could all been subclasses of some base class—but that's not the subject of this question (and that's why there's so much redundant code).Anyway, something like this is would be considered an acceptable MCVE for your question—if only the results it produced jibed with what you're claiming, that is.
SO algorithm gave me interesting hints, I couldn't find earlier.Based on this answer, queues cannot be passed as an argument to functions, which are opening new processes, because queues cannot be pickled. And this what in general self.function() does: it is equivalent to function(self). In the case of class A, the queue is attempted to be passed to workers; where as in B and C it is not and lives more or less independent on the processThe same reasoning concludes from this question and answers. Needless to say, that the manager.Queue does not work here either.Failed testing of MCVEThis is probably due to different default start methods of multiprocessing (see docs)
Again, this isn't an answer to your question. However I'm posting it because it makes the whole issue moot — because you don't really need to explicitly create and use a multiprocessing.Queue to do something like this. Instead consider using concurrent.futures.ProcessPoolExecutor to accomplish the task. For example:Output:


Answer URL
https://docs.python.org/3/library/concurrent.futures.html#processpoolexecutor
