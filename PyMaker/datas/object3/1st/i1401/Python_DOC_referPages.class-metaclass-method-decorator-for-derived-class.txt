Natural Text
I have a metaclass that defines a class level attribute which should be unique for each subclass but shared across instances of each subclass.Now I'd like to implement a decorator that appends the decorated class method to valid_funcs within the derived class. However because the derived class is still being defined I don't have a reference to the derived decorator so I end up appending to the base class. Here's my code:This prints:I want:
There is no class object yet when decorators on functions in the class body are executed. The class body is executed first, then the class is created.Instead of having the decorator look for a class attribute to mutate, add an attribute to a decorated function object. The metaclass, or the _validate() implementation then looks for any objects with this attribute and adds them to the list once the class object has been created.I'm going to assume you'd want to retain the order in which the decorators would have added the decorated items to the list:and in the metaclass:Note that if you are using Python 3.6 or newer, then you don't need a metaclass at all any more. You can put the same logic into the class.__init_subclass__ method.Note that this registers unbound objects. For staticmethod objects, that means the call will fail with:You perhaps want to register the __func__ attribute in that case, or use .__get__ to 'bind' the object to something (a staticmethod ignores the binding context anyway)`.If you bind explicitly, in the _validate() method, then you don't actually have to use staticmethod objects:Now @validator.add will work with staticmethod, classmethod and regular functions.And if you have the _validate() method look for the methods, then binding can be done for you. You can choose to support inheritance here by just using dir() and getattr():getattr() gives you a bound object, no further binding necessary.
While having the metaclass __new__ handle adding functions to valid_funcs is an option, another option would be to inject valid_funcs into the namespace of the class body before the class even exists, using __prepare__:I'd probably skip all the metaclass stuff and require classes to do valid_funcs = [] themselves, though. The additional complexity of a metaclass isn't worth it just to save one line of boilerplate per class.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__init_subclass__
https://docs.python.org/3/reference/datamodel.html#preparing-the-class-namespace
