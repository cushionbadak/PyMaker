Natural Text
imap version:apply_async version:Results:I expected imap to be slower because child processes need to pickle the results to the main process and then write to file, whereas each child process in apply_async directly write the results to file. Instead, imap is slower than apply_async.Why is this so?nb: This was done using Python 3.4.3 on Mac OS X 10.11
A quick glance at your source code shows that the imap_version() opens your output file once per process where apply_version() opens it once per worker which is 5 times per process due to being inside your range(5) loop.with open(FILE, 'a') as fp is called 125 times in your async version vs 25 times in your imap version.
My guess is the busy loop is the culprit (besides it being an anti-pattern in its own right).By checking the state yourself, you do redundant work: multiprocessing's machinery does pretty much the same with the work queue behind the scenes (in multiprocessing.pool.Pool._handle_workers() running in a separate thread). On the other hand, IMapIterator.next uses threading.Condition(threading.Lock()) to suspend the main thread's execution until an item is ready (so _handle_workers runs unhindered - remember that only one thread can run Python code at each moment).Anyway, this is but another guess. The only decisive evidence would be a profiling result.


Answer URL
https://docs.python.org/3/library/profile.html?highlight=profile#instant-user-s-manual
