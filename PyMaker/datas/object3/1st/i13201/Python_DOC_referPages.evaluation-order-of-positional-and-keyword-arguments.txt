Natural Text
Consider this contrived* example:Three shall be the number thou shalt count, and the number of the countingshall be three.Four shalt thou not count,neither count thou two, excepting that thou then proceed to three.Five is right out.After having read this question,I would actually have thought that x = [1, 2] is the only one that works, becausefirst, map(int, x) would be evaluated, one set to 1 and two set to 2then, x still [1, 2], x.pop() would be evaluated and three set to 2, too.My expectation for x = [1, 2, 3] was to get the error that I actually sawfor x = [1, 2, 3, 4].What is going on here? Why are the arguments seemingly not evaluated from left to right? Are keyword arguments evaluated first?*actually my real code corresponds to x = [1, 2, 3], which works, but I wasn't sure it was safe, and after reading the other question I thought it shouldn't actually work.I'm using Python 2.7, if that matters.
Python 2.7If we look at the CPython source related to creating the AST(ast_for_call) for a function call the order of argument evaluation turns out to be:ie. args --> keywords --> vararg --> kwargSo, in your case the keyword argument is evaluated first and then the star based expression(vararg) is evaluated.Byte code:Hence in your case the pop() call will happen first followed by the varargs evaluation.So, if three is a part of kwargs then we will get an error with map:It will work if we do it *lazily:*The reason why generator works and map or list comprehension fails is explained at the end.Python 3.5The ast_for_call function here only maintains two lists: args and keywords. Here the varargs are inserted into the args list and kwargs go to the keywords list. So, in the end the call looks like:Byte code:Now things can get a little exciting if the expression yielding the varargs is lazy:Byte code:The lazy call works because unpacking(aka actual evaluation of the generator) doesn't happen until the function is actually called, hence in this case pop() call will remove the 3 first and then later on map will only pass 1, 2.But, in the case of list comprehension the list object already contains 3 items and then even though pop() removed 3 later on we are still passing two values for the third argument.


Answer URL
https://docs.python.org/3/reference/expressions.html#calls
https://docs.python.org/3/whatsnew/3.5.html#whatsnew-pep-448
