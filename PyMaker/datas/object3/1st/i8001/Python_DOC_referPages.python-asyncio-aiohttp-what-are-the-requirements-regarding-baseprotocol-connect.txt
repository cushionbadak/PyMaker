Natural Text
The python documentation for connection_lost states: connection_made() and connection_lost() are called exactly once per successful connection.Further down there's also the following state machine:start -> connection_made() [-> data_received() *] [-> eof_received() ?] -> connection_lost() -> endAlso, the documentation for BaseTransport.close() states:After all buffered data is flushed, the protocol’s connection_lost() method will be called with None as its argument.and the documentation for WriteTransport.abort() states:The protocol’s connection_lost() method will eventually be called with None as its argument.This seems to me to indicate the following responsibilities:The transport must, if it has called connection_made(), later also call connection_lost() on the protocol (regardless of whether the connection is lost because of a call to close(), a call to abort() or an issue with the underlying connection).The protocol must not assume that I/O has finished when a call to close() or abort() returns. It must wait for the call to connection_lost(). In particular, after close() or abort() returns, there may be work relating to the transport still scheduled on the event loop.With that in mind, consider the following trivial aiohttp client program, using SSL:Running this on my (windows) machine appears to workcorrectly. However, if I put breakpoints or print statements into theconnection_made() and connection_lost() methods of aiohttp'sResponseHandler class (a protocol implementation), I see thatconnection_made() is called but connection_lost() is not.The transport used is _SSLProtocolTransport, defined in asyncio'ssslproto.py file. Its close() method is called, and it sets offa shutdown process. Due to the nature of SSL this shutdown process isnecessarily asynchronous, and the expectation appears to be that oncethe shutdown is complete the SSLProtocol underlying the_SSLProtocolTransport would, from its _finalize() method, closeits underlying transport. This would then cause a call toconnection_lost to bubble up the stack. However, none of thisasynchronous stuff actually happens. aiohttp appears to just callclose() and immediately discard the _SSLProtocolTransport (themethod where it does this is not even a coroutine), and the transportnever progresses with its shutdown sequence and never callsconnection_lost().So my question is: is this a bug in aiohttp and/or aysncio's SSLprotocol/transport, or am I misinterpreting the documentation asregards the responsitilities of the transport and protocol?Why I'm Asking ThisThe reason for this question is that I have written an SSL transportof my own, to allow me to use PyOpenSSL with asyncio, instead of thestandard library ssl module. In my implementation, after the call tomy close() method returns, there are still callbacks queued on theevent loop (scheduled with call_soon()). This is necessary in orderfor the asynchronous shutdown sequence to be performed correctly, andI expect the protocol to give my transport a chance to complete theprocess and call connection_lost().When I use my transport with aiohttp, the __aexit__ method of theClientSession created in the code above calls its own close()method (not a coroutine), which causes my transport to be closed,without waiting for connection_lost(). The event loop is then closedand the module finalised while the transport is still alive andperforming I/O, resulting in a variety of errors.I'm trying to figure out whether this is my fault or a bug in aiohttp(and perhaps also asyncio's SSL transport). If it's my fault, I needto know how I'm supposed to perform this asynchronous shutdown. Icould in principle handle it at the top level by running the eventloop until it's empty before calling loop.close(), but I don't see anyway to do that (there's Task.all_tasks() but that doesn't work forthings scheduled with call_soon). Even if I can do that somehow, itwould seem exceptionally ugly and is certainly not described as astandard requirement for shutting down after such work in anydocumentation I've seen for asyncio or aiohttp.
I suggest you to create an issue in aiohttp bug tracker and copy your question into it.IMHO Stack Overflow is not the best place for discussing questions like this.


Answer URL
https://docs.python.org/3/library/asyncio-protocol.html#asyncio.BaseProtocol.connection_lost
https://docs.python.org/3/library/asyncio-protocol.html#asyncio.BaseTransport.close
https://docs.python.org/3/library/asyncio-protocol.html#asyncio.WriteTransport.abort
