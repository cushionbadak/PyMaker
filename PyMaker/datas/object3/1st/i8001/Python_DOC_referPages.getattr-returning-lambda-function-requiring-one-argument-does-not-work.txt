Natural Text
I am in the process of learning Python 3 and just ran into the getattr function. From what I can tell, it is invoked when the attribute call is not found in the class definition as a function or a variable.In order to understand the behaviour, I wrote the following test class (based on what I've read):And I then initate my object and call the non-existent function test which, expectedly, returns the reference to the function:However, if I call the function, the result is not the expected "FooBar", but an error:In order to get my expected results, I need to call the function with the same object as the first parameter, like this:I find this behaviour rather strange, as when calling p.some_function(), is said to add p as the first argument.I would be grateful if someone could shine some light over this headache of mine. I am using PyDev in Eclipse.
__getattr__ return values are "raw", they don't behave like class attributes, invoking the descriptor protocol that plain methods involve that causes the creation of bound methods (where self is passed implicitly). To bind the function as a method, you need to perform the binding manually:types.MethodType is poorly documented (the interactive help is more helpful), but basically, you pass it a user-defined function and an instance of a class and it returns a bound method that, when called, implicitly passes that instance as the first positional argument (the self argument).
To get what you want, you need a lambda that doesn't take arguments:But you should really use a property for this, instead.Note the lack of parentheses.If you're absolutely determined that it must be a function, do this:
You need to create something that behaves like a bound method, you could simply use functools.partial to bind the instance to the function:The test:
"I find this behaviour rather strange, as when calling  p.some_function(), is said to add p as the first argument."some_function is actually a method, which is why it gets passed an instance implicitly when the method is "bound to an object." But plain functions don't work that way, only functions defined in the class body have this magic applied to them automagically. And actually, unbound methods (accessed via the class directly) function the same as normal functions! The terminology "bound and unbound" methods no longer applies, because in Python 3 we only have methods and functions (getting rid of the distinction between unbound methods and plain functions). When an instance is instantiated, accessing the attribute returns a method which implicitly calls the instance on invocation.However, if you access the attribute of the class you'll see it's just a function:Now, observe:But this is the magic of classes. Note, you can even add functions to classes dynamically, and they get magically turned into methods when you invoke them on an instance:And, as one would hope, the behavior still applies to objects already created!Note, this doesn't work if you dynamically add to an instance:You have to do the magic yourself:
Notice that if you do print(t.__getattr__) you get something like <bound method Test.__getattr__ of <__main__.Test object at 0x00000123FBAE4DA0>>. The key point is that methods defined on an object are said to be 'bound' and so always take the object as the first parameter. Your lambda function is just an anonymous function not 'bound' to anything, so for it to access the object it needs to be explicitly passed in.I presume you are only doing this to experiment with using `__getattr__', as what you are doing could be much more easily achieved by making your lambda a method on the object.


Answer URL
https://docs.python.org/3/library/types.html#types.MethodType
https://docs.python.org/3/howto/descriptor.html#properties
