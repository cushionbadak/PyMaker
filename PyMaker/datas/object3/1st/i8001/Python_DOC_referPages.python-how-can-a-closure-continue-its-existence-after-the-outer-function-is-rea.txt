Natural Text
I learning about closures in Python, and I get the concept well enough. While messing around in IDLE I thought about what would happen if I reassigned the enclosing function and then tried to call the enclosed function:I think that this is very interesting, but I realize that I do not have a good enough understanding about what happens to the closure in memory etc. Can someone explain how I can call inner_function after reassignment of outer_function? 
In CPython (i.e. the reference implementation written in C that most people think of as just "Python"), lexical closures are implemented as 'flat closures' (see PEP 227) that use cell object references instead of searching a linked list of frame objects (nested scopes) at runtime. This allows for quick lookup and improves garbage collection when returning a closure function.The bytecode in outer_function is specialized to access a cell object in the stack frame instead of directly referencing the message object. The interpreter knows about this when setting up the stack frame for the call because the code object has this variable defined as a cell variable:The bytecode in inner_function also dereferences a cell object for the value of message, but since it's not the source of the object, it's classified instead as a free variable:Each inner_function function object that gets instantiated has a __closure__ tuple that references the cell for the enclosed free variable. For example:The cells in this __closure__ tuple are loaded in the stack frame when function is called. This tuple of cells is what makes it flattened. No matter how deeply you nest the scopes, the __closure__ will always propagate all of the required cells. For example:Functions b and c don't directly reference x, but they have to propagate the cell for the inner function d to reference it.The above inspection relies on CPython implementation details. In Python 3.3+ you can instead call inspect.getclosurevars to inspect closure variables. For example:
This behavior is not limited to closures. What you just did is create a copy of the whole function object which refers to the older function and obviously it persists even if you create another function of the same name. Tests Also, you can check the locations of both t and test which shows they are different objects - You can see they are both the same functions but at different locations and hence different objects. The same thing is happening in your case. 


Answer URL
https://docs.python.org/3/library/inspect.html#inspect.getclosurevars
