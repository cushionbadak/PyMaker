Natural Text
I have a task to create a function that reverse any string character inside the regular bracket sequence, starting from the innermost pair. The string sequence can have, spaces, punctuation marks, letters and brakets. So the result should be sting.ExampleFor string the output should beI have wrote the following code to solve this problem:However, I become false results for following strings:It should be  I getAnd It should be like this:But I get only:How should I correct or adjust my code for becoming right results for last two examples?Code AdjustmentI have tried to take into consideration answers and hints but I could not use recursion. I adressed the problem with the parantacies when there are just two of them located as: "..(...) (...).., .."So I made the following code:However, I think that it can not perform well for the following example:The answer should be: "abc741ab321c21asd" but I get "abc12c321ba147asd"What should be changed in order to get the correct answer?
rather than doing this manually, use the regular expression module re that specialize in string manipulationhere the expression '(\([^\(\)]*\))' would search anything that is between ( and ) that is a one of characters defined in [^\(\)]* which in turn means any numbers character that is not a ( or ), this way it will search the innermost group that match, then I use the function re.sub to replace those in the string with that auxiliary function, that take a string of the form "(xyz)" and return "zyx". As this only work for the innermost group, the process should be repeated while there are changes to be made, hence the loop.
The reason your solution isn't working is because it is mismatching parentheses:Your method ultimately won't work: Instead, I recommend you figure out a better way of figuring out which parens match:Once you have that capability, you can then just while has_parens(str): through until you're done.Additional note: Each time you reverse a section, the inner parens will get swapped, ((ob)) will become )bo(.
Since it appears that any number of () pairs could occur, I would recommend implementing a recursive function that can be called as long as pairs of parens still exist at a level outside the first:


Answer URL
https://docs.python.org/3/library/re.html
https://docs.python.org/3/library/re.html#re.sub
