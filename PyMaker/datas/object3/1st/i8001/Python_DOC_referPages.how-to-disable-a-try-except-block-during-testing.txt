Natural Text
I wrote a cronjob that iterates through a list of accounts and performs some web call for them (shown below):Because this job is run by heroku one every 10 minutes, I do not want the entire job to fail just because one account is running into issues (it happens). I placed a try catch clause here so that this task is "fault-tolerant".However, I noticed that when I am testing, this try/catch block is giving me cryptic problems because of the task is allowed to continue executing even though there is some serious error. What is the best way to disable a try/except block during testing? I've though about implementing the code directly like this:in my test cases but then this makes my tests very clumsy as I am copying large amounts of code over. What should I do? 
First of all: don't swallow all exceptions using except Exception. It's bad design. So cut it out. With that out of the way: One thing you could do is setup a monkeypatch for the logger.exception method. Then you can handle the test however you see fit based on whether it was called, whether it's creating a mock logger, or a separate testing logger, or a custom testing logger class that stops the tests when certain exceptions occur. You could even choose to end the testing immediately by raising an error. Here is an example using pytest.monkeypatch. I like pytest's way of doing this because they already have a predefined fixture setup for it, and no boilerplate code is required. However, there are others ways to do this as well (such as using unittest.mock.patch as part of the unitest module).  I will call your class SomeClass. What we will do is create a patched version of your SomeClass object as a fixture. The patched version will not log to the logger; instead, it will have a mock logger. Anything that happens to the logger will be recorded in the mock logger for inspection later. If call.exception appears in the method calls of the mock logger, you know that method was called. There are a lot of other ways you could handle this as well, this is just one. If you're using the logging module, LoggerClass should just be logging.Logger. Alternatively, you can just do mock_logger = mock.Mock(). Or, you could create your own custom testing logger class that raises an exception when its exception method is called. The sky is the limit! Use your patched object in any test like so: If you are not familiar with pytest, see this training video for a little bit more in depth information. 
try...except blocks are difficult when you are testing because they catch and try to dispose of errors you would really rather see. As you have found out. While testing, for (don't use Exception,e, it's not forward-compatible) substitute an exception type that is really unlikely to occur in your circumstances, such as A text editor will do this for you (and reverse it afterwards) at the cost of a couple of mouse-clicks.
You can make callables test-aware by add a _testing=False parameter.  Use that to code alternate pathways in the callable for when testing.  Then pass _testing=True when calling from a test file.For the situation presented in this question, putting if _testing: raise in the exception body would 'uncatch' the exception.Conditioning module level code is tricker.  To get special behavior when testing module mod in package pack, I put Then test_mod I put something like:


Answer URL
https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch
