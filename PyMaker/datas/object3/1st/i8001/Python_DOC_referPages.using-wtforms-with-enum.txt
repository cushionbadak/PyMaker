Natural Text
I have the following code: And this is my wtform field:This is the html generated in my form:Somehow, when I click submit, I keep getting "Not a Valid Choice". Any ideas why?This is my terminal output:When I look at my terminal I see the following:
I think you need to convert the argument passed to coerce method into an instance of the enum.
This is a lot cleaner than the accepted solution, as you don't need to put the options more than once.By default Python will convert objects to strings using their path, which is why you end up with Company.EnterMedia and so on. In the below solution, I use __str__ to tell python that the name should be used instead, and then use the [] notation to look up the enum object by the name.
WTForm will either pass in strings, None, or already coerced data to coerce; this is a little annoying but easily handled by testing if the data to coerce is already an instance:The coerce function must otherwise raise a ValueError or TypeError when coercing.You want to use the enum names as the values in the select box; these are always going to be strings. If your enum values are suitable as labels, then that's great, you can use those for the option readable text, but don't confuse those with the option values, which must be unique, enum values do not need to be.Enum classes let you map a string containing an enum name to the Enum instance by using subscription:See Programmatic access to enumeration members and their attributes in the enum module documentation.Next, we could leave conversion of the enum objects to unique strings (for the value="..." attribute of <option> tags) and to label strings (to show to the users) to standard hook methods on the enum class, such as __str__ and __html__.Together, for your specific setup, use:The above keeps the Enum class implementation separate from the presentation; the cource_for_enum() function takes care of mapping KeyErrors to ValueErrors. The (v, escape(v)) pairs provide the value and label for each option; str(v) is used for the <option value="..."> attribute value, and that same string is then used via Company[__html__result] to coerce back to enum instances. WTForms 3.0 will start using MarkupSafe for labels, but until then, we can directly provide the same functionality with escape(v), which in turn uses __html__ to provide a suitable rendering.If having to remember about what to put in the list comprehension, and to use coerce_for_enum() is becoming tedious, you can generate the choices and coerce options with a helper function; you could even have it verify that there are suitable __str__ and __html__ methods available:and for your example, then useNote that once WTForm 3.0 is released, you can use a __html__ method on enum objects without having to use markdownsafe.escape(), because the project is switching to using MarkupSafe for the label values.
I've just been down the same rabbit hole. Not sure why, but coerce gets called with None when the form is initialised. After wasting a lot of time, I decided it's not worth coercing, and instead I just used:and to get the value:
So I hacked around and this works. It seems to me that coerce will be applied to both (x,y) for (x,y) in choices. I can't seem to understand why I keep seeing: Can't coerce None <type 'NoneType'> though 


Answer URL
https://docs.python.org/3/library/enum.html#programmatic-access-to-enumeration-members-and-their-attributes
https://docs.python.org/3/library/enum.html#programmatic-access-to-enumeration-members-and-their-attributes
https://docs.python.org/3/library/enum.html#programmatic-access-to-enumeration-members-and-their-attributes
