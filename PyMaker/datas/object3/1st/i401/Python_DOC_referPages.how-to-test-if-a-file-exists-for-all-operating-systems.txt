Natural Text
How do I see if a file exists or not, without using the try statement?
If the reason you're checking is so you can do something like if file_exists: open_it(), it's safer to use a try around the attempt to open it. Checking and then opening risks the file being deleted or moved or something between when you check and when you try to open it.If you're not planning to open the file immediately, you can use os.path.isfileReturn True if path is an existing regular file. This follows symbolic links, so both islink() and isfile() can be true for the same path.if you need to be sure it's a file.Starting with Python 3.4, the pathlib module offers an object-oriented approach (backported to pathlib2 in Python 2.7):To check a directory, do:To check whether a Path object exists independently of whether is it a file or directory, use exists():You can also use resolve(strict=True) in a try block:
You have the os.path.exists function:This returns True for both files and directories but you can instead useto test if it's a file specifically. It follows symlinks.
Unlike isfile(), exists() will return True for directories.So depending on if you want only plain files or also directories, you'll use isfile() or exists(). Here is a simple REPL output.

Use os.path.isfile() with os.access():

Although almost every possible way has been listed in (at least one of) the existing answers (e.g. Python 3.4 specific stuff was added), I'll try to group everything together.Note: every piece of Python standard library code that I'm going to post, belongs to version 3.5.3.Problem statement:Check file (arguable: also folder ("special" file) ?) existenceDon't use try / except / else / finally blocksPossible solutions:[Python 3]: os.path.exists(path) (also check other function family members like os.path.isfile, os.path.isdir, os.path.lexists for slightly different behaviors)Return True if path refers to an existing path or an open file descriptor. Returns False for broken symbolic links. On some platforms, this function may return False if permission is not granted to execute os.stat() on the requested file, even if the path physically exists.All good, but if following the import tree:os.path - posixpath.py (ntpath.py)genericpath.py, line ~#20+it's just a try / except block around [Python 3]: os.stat(path, *, dir_fd=None, follow_symlinks=True). So, your code is try / except free, but lower in the framestack there's (at least) one such block. This also applies to other funcs (including os.path.isfile).1.1. [Python 3]: Path.is_file()It's a fancier (and more pythonic) way of handling paths, butUnder the hood, it does exactly the same thing (pathlib.py, line ~#1330):[Python 3]: With Statement Context Managers. Either:Create one:And its usage - I'll replicate the os.path.isfile behavior (note that this is just for demonstrating purposes, do not attempt to write such code for production):Use [Python 3]: contextlib.suppress(*exceptions) - which was specifically designed for selectively suppressing exceptionsBut, they seem to be wrappers over try / except / else / finally blocks, as [Python 3]: The with statement states:This allows common try...except...finally usage patterns to be encapsulated for convenient reuse.Filesystem traversal functions (and search the results for matching item(s))[Python 3]: os.listdir(path='.') (or [Python 3]: os.scandir(path='.') on Python v3.5
This is the simplest way to check if a file exists. Just because the file existed when you checked doesn't guarantee that it will be there when you need to open it.
Python 3.4+ has an object-oriented path module: pathlib.  Using this new module, you can check whether a file exists like this:You can (and usually should) still use a try/except block when opening files:The pathlib module has lots of cool stuff in it: convenient globbing, checking file's owner, easier path joining, etc.  It's worth checking out.  If you're on an older Python (version 2.6 or later), you can still install pathlib with pip:Then import it as follows:
Prefer the try statement. It's considered better style and avoids race conditions.Don't take my word for it. There's plenty of support for this theory. Here's a couple:Style: Section "Handling unusual conditions" of http://allendowney.com/sd/notes/notes11.txtAvoiding Race Conditions
How do I check whether a file exists, using Python, without using a try statement?Now available since Python 3.4, import and instantiate a Path object with the file name, and check the is_file method (note that this returns True for symlinks pointing to regular files as well):If you're on Python 2, you can backport the pathlib module from pypi, pathlib2, or otherwise check isfile from the os.path module:Now the above is probably the best pragmatic direct answer here, but there's the possibility of a race condition (depending on what you're trying to accomplish), and the fact that the underlying implementation uses a try, but Python uses try everywhere in its implementation. Because Python uses try everywhere, there's really no reason to avoid an implementation that uses it.But the rest of this answer attempts to consider these caveats.Longer, much more pedantic answerAvailable since Python 3.4, use the new Path object in pathlib. Note that .exists is not quite right, because directories are not files (except in the unix sense that everything is a file).So we need to use is_file:Here's the help on is_file:So let's get a file that we know is a file:By default, NamedTemporaryFile deletes the file when closed (and will automatically close when no more references exist to it).If you dig into the implementation, though, you'll see that is_file uses try:Race Conditions: Why we like tryWe like try because it avoids race conditions. With try, you simply attempt to read your file, expecting it to be there, and if not, you catch the exception and perform whatever fallback behavior makes sense.If you want to check that a file exists before you attempt to read it, and you might be deleting it and then you might be using multiple threads or processes, or another program knows about that file and could delete it - you risk the chance of a race condition if you check it exists, because you are then racing to open it before its condition (its existence) changes. Race conditions are very hard to debug because there's a very small window in which they can cause your program to fail.But if this is your motivation, you can get the value of a try statement by using the suppress context manager.Avoiding race conditions without a try statement: suppressPython 3.4 gives us the suppress context manager (previously the ignore context manager), which does semantically exactly the same thing in fewer lines, while also (at least superficially) meeting the original ask to avoid a try statement:Usage:For earlier Pythons, you could roll your own suppress, but without a try will be more verbose than with. I do believe this actually is the only answer that doesn't use try at any level in the Python that can be applied to prior to Python 3.4 because it uses a context manager instead:Perhaps easier with a try:Other options that don't meet the ask for "without try":isfilefrom the docs:os.path.isfile(path)Return True if path is an existing regular file. This follows symbolic  links, so both islink() and isfile() can be true for the same path.But if you examine the source of this function, you'll see it actually does use a try statement:All it's doing is using the given path to see if it can get stats on it,  catching OSError and then checking if it's a file if it didn't raise the exception.If you intend to do something with the file, I would suggest directly attempting it with a try-except to avoid a race condition:os.accessAvailable for Unix and Windows is os.access, but to use you must pass flags, and it does not differentiate between files and directories. This is more used to test if the real invoking user has access in an elevated privilege environment:It also suffers from the same race condition problems as isfile. From the docs:Note:  Using access() to check if a user is authorized to e.g. open a file  before actually doing so using open() creates a security hole, because  the user might exploit the short time interval between checking and  opening the file to manipulate it. It’s preferable to use EAFP  techniques. For example:is better written as:Avoid using os.access. It is a low level function that has more opportunities for user error than the higher level objects and functions discussed above.Criticism of another answer:Another answer says this about os.access:Personally, I prefer this one because under the hood, it calls native APIs (via "${PYTHON_SRC_DIR}/Modules/posixmodule.c"), but it also opens a gate for possible user errors, and it's not as Pythonic as other variants:This answer says it prefers a non-Pythonic, error-prone method, with no justification. It seems to encourage users to use low-level APIs without understanding them. It also creates a context manager which, by unconditionally returning True, allows all Exceptions (including KeyboardInterrupt and SystemExit!) to pass silently, which is a good way to hide bugs.This seems to encourage users to adopt poor practices.
Importing os makes it easier to navigate and perform standard actions with your operating system. For reference also see How to check whether a file exists using Python?If you need high-level operations, use shutil.
Testing for files and folders with os.path.isfile(), os.path.isdir() and os.path.exists()Assuming that the "path" is a valid path, this table shows what is returned by each function for files and folders:You can also test if a file is a certain type of file using os.path.splitext() to get the extension (if you don't already know it)
In 2016 the best way is still using os.path.isfile:Or in Python 3 you can use pathlib:
It doesn't seem like there's a meaningful functional difference between try/except and isfile(), so you should use which one makes sense.If you want to read a file, if it exists, doBut if you just wanted to rename a file if it exists, and therefore don't need to open it, doIf you want to write to a file, if it doesn't exist, doIf you need file locking, that's a different matter.
You could try this (safer):The ouput would be:([Errno 2] No such file or directory:  'whatever.txt')Then, depending on the result, your program can just keep running from there or you can code to stop it if you want.
Although I always recommend using try and except statements, here are a few possibilities for you (my personal favourite is using os.access):Try opening the file:Opening the file will always verify the existence of the file. You can make a function just like so:If it's False, it will stop execution with an unhanded IOErroror OSError in later versions of Python. To catch the exception,you have to use a try except clause. Of course, you can alwaysuse a try except` statement like so (thanks to hsandtfor making me think):Use os.path.exists(path):This will check the existence of what you specify. However, it checks for files and directories so beware about how you use it.Use os.access(path, mode):This will check whether you have access to the file. It will check for permissions. Based on the os.py documentation, typing in os.F_OK, it will check the existence of the path. However, using this will create a security hole, as someone can attack your file using the time between checking the permissions and opening the file. You should instead go directly to opening the file instead of checking its permissions. (EAFP vs LBYP). If you're not going to open the file afterwards, and only checking its existence, then you can use this.Anyway, here:I should also mention that there are two ways that you will not be able to verify the existence of a file. Either the issue will be permission denied or no such file or directory. If you catch an IOError, set the IOError as e (like my first option), and then type in print(e.args) so that you can hopefully determine your issue. I hope it helps! :)
Date:2017-12-04Every possible solution has been listed in other answers.An intuitive and arguable way to check if a file exists is the following:I made an exhaustive cheatsheet for your reference:
In Python 3.4 the language provides a new module to manage files:
Additionally, os.access():Being R_OK, W_OK, and X_OK the flags to test for permissions (doc).
If the file is for opening you could use one of the following techniques:UPDATEJust to avoid confusion and based on the answers I got, current answer finds either a file or a directory with the given name.
Raising exceptions is considered to be an acceptable, and Pythonic,  approach for flow control in your program. Consider handling missing  files with IOErrors. In this situation, an IOError exception will be  raised if the file exists but the user does not have read permissions.SRC: http://www.pfinn.net/python-check-if-file-exists.html
You can write Brian's suggestion without the try:.suppress is part of Python 3.4. In older releases you can quickly write your own suppress:
If you imported NumPy already for other purposes then there is no need to import other libraries like pathlib, os, paths, etc.This will return true or false based on its existence.
Check file or directory existsYou can follow these three ways:Note1: The os.path.isfile used only for filesNote2: The os.path.exists used for both files and directoriesThe pathlib.Path method (included in Python 3+, installable with pip for Python 2)
Adding one more slight variation which isn't exactly reflected in the other answers.This will handle the case of the file_path being None or empty string.Adding a variant based on suggestion from ShahbazAdding a variant based on suggestion from Peter Wood
I'm the author of a package that's been around for about 10 years, and it has a function that addresses this question directly. Basically, if you are on a non-Windows system, it uses Popen to access find.  However, if you are on Windows, it replicates find with an efficient filesystem walker.The code itself does not use a try block… except in determining the operating system and thus steering you to the "Unix"-style find or the hand-buillt find. Timing tests showed that the try was faster in determining the OS, so I did use one there (but nowhere else).And the doc…The implementation, if you care to look, is here:https://github.com/uqfoundation/pox/blob/89f90fb308f285ca7a62eabe2c38acb87e89dad9/pox/shutils.py#L190
Here's a 1 line Python command for the Linux command line environment. I find this VERY HANDY since I'm not such a hot Bash guy.I hope this is helpful.
You can use the "OS" library of Python:
How do I check whether a file exists, without using the try statement?In 2016, this is still arguably the easiest way to check if both a file exists and if it is a file:isfile is actually just a helper method that internally uses os.stat and stat.S_ISREG(mode) underneath. This os.stat is a lower-level method that will provide you with detailed information about files, directories, sockets, buffers, and more. More about os.stat hereNote: However, this approach will not lock the file in any way and therefore your code can become vulnerable to "time of check to time of use" (TOCTTOU) bugs.So raising exceptions is considered to be an acceptable, and Pythonic, approach for flow control in your program. And one should consider handling missing files with IOErrors, rather than if statements (just an advice).


Answer URL
https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file
https://docs.python.org/3/library/os.path.html#os.path.exists
https://docs.python.org/3/library/os.html#os.stat
https://docs.python.org/3/library/os.html#os.stat
https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file
https://docs.python.org/3/reference/datamodel.html#context-managers
https://docs.python.org/3/library/contextlib.html#contextlib.suppress
https://docs.python.org/3/reference/compound_stmts.html#with
https://docs.python.org/3/reference/compound_stmts.html#try
https://docs.python.org/3/reference/compound_stmts.html#except
https://docs.python.org/3/reference/compound_stmts.html#finally
https://docs.python.org/3/library/os.html#os.listdir
https://docs.python.org/3/library/os.html#os.scandir
https://docs.python.org/3/library/contextlib.html#contextlib.suppress
https://docs.python.org/3/library/os.html#os.access
https://docs.python.org/3/whatsnew/3.6.html#optimizations
https://docs.python.org/3/library/os.html#os.replace
https://docs.python.org/3/library/os.path.html#os.path.exists
