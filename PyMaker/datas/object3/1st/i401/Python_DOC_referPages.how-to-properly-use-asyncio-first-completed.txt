Natural Text
The problem is that I keep getting RuntimeError: Event loop is closed error even when I use return_when=asyncio.FIRST_COMPLETED inside await asyncio.wait().My code:Expected behaviour:return_when=asyncio.FIRST_COMPLETED should kill all remaining tasks when first result is returned "under the hood". But in fact there still remain uncompleted tasks after first result returned. And after I close the loop in get_proxy_loop() and access result inside __main__ those remaing tasks raise RuntimeError: Event loop is closed.Console output:
The asyncio.wait(..., return_when=asyncio.FIRST_COMPLETED) coroutine returns when at least one of the tasks has completed. Other tasks can still be active. It is not the job of asyncio.wait() to cancel those tasks for you. The use-case of asyncio.wait(..., return_when=asyncio.FIRST_COMPLETED) is to let you monitor tasks and act on their results as they complete; you usually would call it repeatedly until all your tasks are finished.From the asyncio.wait() documentation:Run awaitable objects in the aws set concurrently and block until the condition specified by return_when.[...]return_when indicates when this function should return. It must be one of the following constants:FIRST_COMPLETED  The function will return when any future finishes or is cancelled.[...]Unlike wait_for(), wait() does not cancel the futures when a timeout occurs.The documentation explicitly states that it will not cancel futures, even when you set a timeout (if you do set a timeout, then the first done set is simply empty, the tasks are all still active and listed in the second pending set).If you need the unfinished tasks to be cancelled, do so explicitly:Demo with some extra printing and randomised tasks:


Answer URL
https://docs.python.org/3/library/asyncio-task.html#asyncio.wait
https://docs.python.org/3/whatsnew/3.6.html#whatsnew36-pep498
