Natural Text
I got the following code from github about MRO and C3, and I don't quite understand the the last three lines, and what the difference among super().foo(), super(B,self).foo() and super(C,self).foo() in python3.x, code as follows:the expected and actual results is as follow:
First of all, the form super() in Python 3 is really the same thing as super(<CurrentClass>, self), where the Python compiler provides enough information for super() to determine what the correct class to use is. So in E.foo(), super().foo() can be read as super(E, self).foo().To understand what is going on, you need to look at the class.__mro__ attribute:This attribute is a tuple of classes that are considered when looking for base classes during method resolution.It is this tuple that shows you what the C3 Method Resolution Order is for any given class hierarchy. For your class E, that order is:The super() object bases everything off from that ordered sequence of classes. The callresults in the following series of steps:The super() object retrieves the self.__mro__ tuple.super() locates the index for the SomeClass class in that tuple.Accessing the foo attribute on the super() object triggers a search for a class that has a foo attribute on the MRO, starting at the next index after the SomeClass index.If the attribute found this way is a descriptor object binds the attribute found this way to self. Functions are descriptors, binding produces a bound method, and this is how Python passes in the self reference when you call a method.Expressed as simplified Python code that ignores edge cases and other uses for super(),  that would look like:Combining those two pieces of information, you can see what happens when you call e.foo():print('foo in E') is executed, resulting in foo in Esuper().foo() is executed, effectively the same thing as super(E, self).foo().The MRO is searched, starting at the next index past E, so at D (no foo attribute), moving on to B (no foo attribute), then C (attribute found). C.foo is returned, bound to self.C.foo(self) is called, resulting in foo fo Csuper(B, self).foo() is executed.The MRO is searched, starting at the next index past B, so at C (attribute found). C.foo is returned, bound to self.C.foo(self) is called, resulting in foo fo Csuper(C, self).foo() is executed.The MRO is searched, starting at the next index past C, so at A (attribute found). A.foo is returned, bound to self.A.foo(self) is called, resulting in foo of A


Answer URL
https://docs.python.org/3/library/stdtypes.html#class.__mro__
https://docs.python.org/3/howto/descriptor.html
