Natural Text
This is a bit of a silly thing, but I want to know if there is concise way in Python to define class variables that contain string representations of their own names.  For example, one can define:Probably a more concise way to write it in terms of lines consumed is:Even there, though, I still have to type each identifier twice, once on each side of the assignment, and the opportunity for typos is rife.What I want is something like what sympy provides in its var method:The above injects into the namespace the variables a, b, and c, defined as the corresponding sympy symbolic variables.Is there something comparable that would do this for plain strings?EDIT: To note, I want to be able to access these as separate identifiers in code that uses foo:ADDENDUM: Given the interest in the question, I thought I'd provide more context on why I want to do this.  I have two use-cases at present: (1) typecodes for a set of custom exceptions (each Exception subclass has a distinct typecode set); and (2) lightweight enum.  My desired feature set is:Only having to type the typecode / enum name (or value) once in the source definition. class foo(object): bar = 'bar' works fine but means I have to type it out twice in-source, which gets annoying for longer names and exposes a typo risk.Valid typecodes / enum values exposed for IDE autocomplete.Values stored internally as comprehensible strings:For the Exception subclasses, I want to be able to define myError.__str__ as just something like return self.typecode + ": " + self.message + " (" + self.source + ")", without having to do a whole lot of dict-fu to back-reference an int value of self.typecode to a comprehensible and meaningful string.For the enums, I want to just be able to obtain widget as output from e = myEnum.widget; print(e), again without a lot of dict-fu. I recognize this will increase overhead. My application is not speed-sensitive (GUI-based tool for driving a separate program), so I don't think this will matter at all.Straightforward membership testing, by also including (say) a frozenset containing all of the typecodes / enum string values as myError.typecodes/myEnum.E classes.  This addresses potential problems from accidental (or intentional.. but why?!) use of an invalid typecode / enum string  via simple sanity checks like if not enumVal in myEnum.E: raise(ValueError('Invalid enum value: ' + str(enumVal))).Ability to import individual enum / exception subclasses via, say, from errmodule import squirrelerror, to avoid cluttering the namespace of the usage environment with non-relevant exception subclasses.  I believe this prohibits any solutions requiring post-twiddling on the module level like what Sinux proposed.For the enum use case, I would rather avoid introducing an additional package dependency since I don't (think I) care about any extra functionality available in the official enum class. In any event, it still wouldn't resolve #1.I've already figured out implementation I'm satisfied with for all of the above but #1.  My interest in a solution to #1 (without breaking the others) is partly a desire to typo-proof entry of the typecode / enum values into source, and partly plain ol' laziness.  (Says the guy who just typed up a gigantic SO question on the topic.)
I recommend using collections.namedtuple:Example:Side Note: If you are using/on Python 3.x I'd recommend Enum as per @user2357112's comment. This is the standardized approach going forward for Python 3+Update: Okay so if I understand the OP's exact requirement(s) here I think the only way to do this (and presumably sympy does this too) is to inject the names/variables into the globals() or locals() namespaces. Example:Output:NB: I don't really recommend this! :)Update #2: The other example you showed in your question is implemented like this:Output:NB: This is inspired by zope.interface.implements().
then run this:
This doesn't work exactly like what you asked for, but it seems like it should do the job:Demo:If you want to do what SymPy does with var, you can, but I would strongly recommend against it. That said, here's a function based on the source code of sympy.var:Demo:It'll always create global variables, even if you call it from inside a function or class. inspect is used to get at the caller's globals, whereas globals() would get var's own globals.
How about you define the variable as emtpy string and then get their name:
Here's an extension of bman's idea. This has its advantages and disadvantages, but at least it does work with some autocompleters.This allows access like foo.xxx â†’ 'xxx' for all xxx, but also guides autocomplete through __dir__.
Figured out what I was looking for:Only have to define the element strings once, and I'm pretty sure it will work for all of my requirements listed in the question.  In actual implementation, I plan to encapsulate the str(s) + "='" + str(s) + "'" in a helper function, so that I can just call exec(helper(s)) in the for loop.  (I'm pretty sure that the exec has to be placed in the body of the class, not in the helper function, or else the new variables would be injected into the (transitory) scope of the helper function, not that of the class.)EDIT: Upon detailed testing, this DOES NOT WORK -- the use of exec prevents the introspection of the IDE from knowing of the existence of the created variables.
I think you can achieve a rather beautiful solution using metaclasses, but I'm not fluent enough in using those to present that as an answer, but I do have an option which seems to work rather nicely:This should recreate the class you've given as example, and if you want you can change the inheritance by changing the second parameter of the call to class type(name, bases, dict). 


Answer URL
https://docs.python.org/3/library/enum.html
https://docs.python.org/3/library/enum.html
https://docs.python.org/3/library/functions.html#locals
