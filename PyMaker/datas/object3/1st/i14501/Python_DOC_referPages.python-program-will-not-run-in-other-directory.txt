Natural Text
I am running ubuntu 12.04 and running programs through the terminal.  I have a file that compiles and runs without any issues when I am in the current directory. Example below,Now when I go back one directory and try running the same piece of code, I get an error message, ValueError: need more than 1 value to unpack. Below is what happens when I run the sample code one folder back and then the sample code below that.The code, bill.py, below.  This program reads two text files from the folder that it is located in and parses the lines into variables. What is going on here?  Am I not running the compile and run command in the terminal correctly?  Another note to know is that I eventually call this code from another file and it will not run the for loop, I am assuming since it doesn't run unless its called from its own folder/directory?
As eomer explains, the problem is that './*.txt' is a relative path—relative to the current working directory. If you're not running from the directory that all those *.txt files are in, you won't find anything.If the *.txt files are supposed to be in the same directory as the script, use the same directory as the script, not the current working directory.The standard way of doing that is to put code like this at the top of your script:argv[0] gets the path to the script itself. So, if you ran the script as python BillList/bill.py, this will be 'BillList/bill.py'.*dirname just takes a path to a file, and gives you the path to the directory the file was in.  So, in this case, BillList.abspath normalizes and absolutizes the path.** So, you'll get /home/david/Documents/BudgetAutomation/BillList/. And that's the directory the *.txt files are in.Then, instead of this:… you do this:* Actually, on some platforms you will get an absolute path here, rather than relative, meaning the later abspath is unnecessary. But for portability, it's worth doing. A bigger problem is that in some cases you will get just bill.py, with no path. There used to be cases where it was worth checking for that and trying __file__ instead, but as far as I know that isn't true on any modern platform—and there are cases where __file__ is wrong but argv[0] is right.** For a relative path, it absolutizes it relative to the current working directory. That's why it's important to do this at the top of the script—in case someone does an os.chdir later.
Your problem starts in line 5:You are telling glob to look in the local directory for all .txt files. Since you are one directory up you do not have these files.You are getting a ValueError because the line variable is empty. As it is written you will need to run it from that directory.Edit:The way I see it you have three separate options.You could simply run script with the full path (assuming it is executable)~/Documents/BudgetAutomation/BillList/bill.pyYou could put the full path into the file (although not very Pythonic)arr = glob.glob('/home/[username]/Documents/BudgetAutomation/BillList/*.txt')You could use sys.argv to pass the path in the file. This would be my personal preferred way. Use os.path.join to put the correct slashes.arr = glob.glob(os.path.join(sys.argv1, '*.txt'))
You don't need to create that range object to iterate over the glob result. You can just do it like this:The reason of why that exception is raised, I guess, is there exist text files contain content not conforming with your need. You read a line from that file, which is something may be like "foo|bar", then the splitting result of it is ["foo", "bar"].If you want to avoid this exception, you could just catch it:
You must use absolute path arr = glob.glob('./*.txt') here.Do something like arr = glob.glob('/home/abc/stack_overflow/*.txt')If possible use below codeThis will provide you with list of files that you want to glob with


Answer URL
https://docs.python.org/3/library/sys.html#sys.argv
https://docs.python.org/3/library/os.path.html#os.path.dirname
https://docs.python.org/3/library/os.path.html#os.path.abspath
https://docs.python.org/3/library/sys.html?highlight=sys.argv#sys.argv
https://docs.python.org/3/library/sys.html?highlight=sys.argv#sys.argv
