Natural Text
I'm just trying to streamline one of my classes and have introduced some functionality in the same style as the flyweight design pattern.However, I'm a bit confused as to why __init__ is always called after __new__. I wasn't expecting this. Can anyone tell me why this is happening and how I can implement this functionality otherwise? (Apart from putting the implementation into the __new__ which feels quite hacky.)Here's an example:Outputs:Why?
Use __new__ when you need to control  the creation of a new instance. Use  __init__ when you need to control initialization of a new instance.__new__ is the first step of instance creation.  It's called first, and is  responsible for returning a new  instance of your class.  In contrast,  __init__ doesn't return anything; it's only responsible for initializing the  instance after it's been created.In general, you shouldn't need to  override __new__ unless you're  subclassing an immutable type like  str, int, unicode or tuple.From: http://mail.python.org/pipermail/tutor/2008-April/061426.htmlYou should consider that what you are trying to do is usually done with a Factory and that's the best way to do it. Using __new__ is not a good clean solution so please consider the usage of a factory. Here you have a good factory example.
__new__ is static class method, while __init__ is instance method. __new__ has to create the instance first, so __init__ can initialize it. Note that __init__ takes self as parameter. Until you create instance there is no self.Now, I gather, that you're trying to implement singleton pattern in Python. There are a few ways to do that.Also, as of Python 2.6, you can use class decorators. 
In most well-known OO languages, an expression like SomeClass(arg1, arg2) will allocate a new instance, initialise the instance's attributes, and then return it.In most well-known OO languages, the "initialise the instance's attributes" part can be customised for each class by defining a constructor, which is basically just a block of code that operates on the new instance (using the arguments provided to the constructor expression) to set up whatever initial conditions are desired. In Python, this corresponds to the class' __init__ method.Python's __new__ is nothing more and nothing less than similar per-class customisation of the "allocate a new instance" part. This of course allows you to do unusual things such as returning an existing instance rather than allocating a new one. So in Python, we shouldn't really think of this part as necessarily involving allocation; all that we require is that __new__ comes up with a suitable instance from somewhere.But it's still only half of the job, and there's no way for the Python system to know that sometimes you want to run the other half of the job (__init__) afterwards and sometimes you don't. If you want that behavior, you have to say so explicitly.Often, you can refactor so you only need __new__, or so you don't need __new__, or so that __init__ behaves differently on an already-initialised object. But if you really want to, Python does actually allow you to redefine "the job", so that SomeClass(arg1, arg2) doesn't necessarily call __new__ followed by __init__. To do this, you need to create a metaclass, and define its __call__ method.A metaclass is just the class of a class. And a class' __call__ method controls what happens when you call instances of the class. So a metaclass' __call__ method controls what happens when you call a class; i.e. it allows you to redefine the instance-creation mechanism from start to finish. This is the level at which you can most elegantly implement a completely non-standard instance creation process such as the singleton pattern. In fact, with less than 10 lines of code you can implement a Singleton metaclass that then doesn't even require you to futz with __new__ at all, and can turn any otherwise-normal class into a singleton by simply adding __metaclass__ = Singleton!However this is probably deeper magic than is really warranted for this situation!
To quote the documentation:Typical implementations create a new instance of the class by invoking  the superclass's __new__() method using "super(currentclass,  cls).__new__(cls[, ...])"with appropriate arguments and then  modifying the newly-created instance as necessary before returning it....If __new__() does not return an instance of cls, then the new  instance's __init__() method will not be invoked.__new__() is intended mainly to allow subclasses of immutable  types (like int, str, or tuple) to customize instance creation.
I realize that this question is quite old but I had a similar issue.The following did what I wanted:I used this page as a resource http://infohost.nmt.edu/tcc/help/pubs/python/web/new-new-method.html
I think the simple answer to this question is that, if __new__ returns a value that is the same type as the class, the __init__ function executes, otherwise it won't. In this case your code returns A._dict('key') which is the same class as cls, so __init__ will be executed.
When __new__ returns instance of the same class, __init__ is run afterwards on returned object. I.e. you can NOT use __new__ to prevent __init__ from being run. Even if you return previously created object from __new__, it will be double (triple, etc...) initialized by __init__ again and again.Here is the generic approach to Singleton pattern which extends vartec answer above and fixes it:Full story is here.Another approach, which in fact involves __new__ is to use classmethods:Please pay attention, that with this approach you need to decorate ALL of your methods with @classmethod, because you'll never use any real instance of MyClass.
outputs:NB As a side effect M._dict property automatically becomes accessible from A as A._dict so take care not to overwrite it incidentally.
__new__ should return a new, blank instance of a class. __init__ is then called to initialise that instance. You're not calling __init__ in the "NEW" case of __new__, so it's being called for you. The code that is calling __new__ doesn't keep track of whether __init__ has been called on a particular instance or not nor should it, because you're doing something very unusual here.You could add an attribute to the object in the __init__ function to indicate that it's been initialised. Check for the existence of that attribute as the first thing in __init__ and don't proceed any further if it has been.
An update to @AntonyHatchkins answer, you probably want a separate dictionary of instances for each class of the metatype, meaning that you should have an __init__ method in the metaclass to initialize your class object with that dictionary instead of making it global across all the classes.I have gone ahead and updated the original code with an __init__ method and  changed the syntax to Python 3 notation (no-arg call to super and metaclass in the class arguments instead of as an attribute).Either way, the important point here is that your class initializer (__call__ method) will not execute either __new__ or __init__ if the key is found. This is much cleaner than using __new__, which requires you to mark the object if you want to skip the default __init__ step.
Referring to this doc: When subclassing immutable built-in types like numbers and strings,  and occasionally in other situations, the static method new comes  in handy. new is the first step in instance construction, invoked  before init. The new method is called with the class as its  first argument; its responsibility is to return a new instance of that  class. Compare this to init: init is called with an instance  as its first argument, and it doesn't return anything; its  responsibility is to initialize the instance. There are situations  where a new instance is created without calling init (for example  when the instance is loaded from a pickle). There is no way to create  a new instance without calling new (although in some cases you can  get away with calling a base class's new).Regarding what you wish to achieve, there also in same doc info about Singleton patternyou may also use this implementation from PEP 318, using a decorator
Digging little deeper into that!The type of a generic class in CPython is type and its base class is Object (Unless you explicitly define another base class like a metaclass). The sequence of low level calls can be found here. The first method called is the type_call which then calls tp_new and then tp_init. The interesting part here is that tp_new will call the Object's (base class) new method object_new which does a tp_alloc (PyType_GenericAlloc) which allocates the memory for the object :)At that point the object is created in memory and then the __init__ method gets called. If __init__ is not implemented in your class then the object_init gets called and it does nothing :)Then type_call just returns the object which binds to your variable.
One should look at __init__ as a simple constructor in traditional OO languages. For example, if you are familiar with Java or C++, the constructor is passed a pointer to its own instance implicitly. In the case of Java, it is the this variable. If one were to inspect the byte code generated for Java, one would notice two calls. The first call is to an "new" method, and then next call is to the init method (which is the actual call to the user defined constructor). This two step process enables creation of the actual instance before calling the constructor method of the class which is just another method of that instance.Now, in the case of Python, __new__ is a added facility that is accessible to the user. Java does not provide that flexibility, due to its typed nature. If a language provided that facility, then the implementor of __new__ could do many things in that method before returning the instance, including creating a totally new instance of a unrelated object in some cases. And, this approach also works out well for especially for immutable types in the case of Python.    
The __init__ is called after __new__ so that when you override it in a subclass, your added code will still get called.If you are trying to subclass a class that already has a __new__, someone unaware of this might start by adapting the __init__ and forwarding the call down to the subclass __init__.  This convention of calling __init__ after __new__ helps that work as expected.The __init__ still needs to allow for any parameters the superclass __new__ needed, but failing to do so will usually create a clear runtime error.  And the __new__ should probably explicitly allow for *args and '**kw', to make it clear that extension is OK.It is generally bad form to have both __new__ and __init__ in the same class at the same level of inheritance, because of the behavior the original poster described.
However, I'm a bit confused as to why init is always called after new.I think the C++ analogy would be useful here:(A)    new simply allocates memory for the object. The instance variables of an object needs memory to hold it, and this is what the step new would do.(B)    init initialize the internal variables of the object to specific values (could be default).
However, I'm a bit confused as to why __init__ is always called after __new__.Not much of a reason other than that it just is done that way. __new__ doesn't have the responsibility of initializing the class, some other method does (__call__, possibly-- I don't know for sure).I wasn't expecting this. Can anyone tell me why this is happening and how I implement this functionality otherwise? (apart from putting the implementation into the __new__ which feels quite hacky).You could have __init__ do nothing if it's already been initialized, or you could write a new metaclass with a new __call__ that only calls __init__ on new instances, and otherwise just returns __new__(...).
The simple reason is that the new is used for creating an instance, while init is used for initializing the instance. Before initializing, the instance should be created first. That's why new should be called before init.
Now I've got the same problem, and for some reasons I decided to avoid decorators, factories and metaclasses. I did it like this:Main fileExample classesIn useWarning: You shouldn't initialize Parent, it will collide with other classes - unless you defined separate cache in each of the children, that's not what we want.Warning: It seems a class with Parent as grandparent behaves weird. [Unverified]Try it online!


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__new__
