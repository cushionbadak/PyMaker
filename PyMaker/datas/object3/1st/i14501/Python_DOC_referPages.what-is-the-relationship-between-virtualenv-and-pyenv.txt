Natural Text
I recently learned how to use virtualenv and virtualenvwrapper in my workflow but I've seen pyenv mentioned in a few guides but I can't seem to get an understanding of what pyenv is and how it is different/similar to virtualenv. Is pyenv a better/newer replacement for virtualenv or a complimentary tool? If the latter what does it do differently and how do the two (and virtualenvwrapper if applicable) work together? 
Pyenv and virtualenv are very different tools that work in different ways to do different things:Pyenv is a bash extension - will not work on Windows - that intercepts your calls to python, pip, etc., to direct them to one of several of the system python tool-chains.  So you always have all the libraries that you have installed in the selected python version available - as such it is good for users who have to switch between different versions of python.VirtualEnv, is pure python so works everywhere, it makes a copy of, optionally a specific version of, python and pip local to the activate environment which may or may not include links to the current system tool-chain, if it does not you can install just a known subset of libraries into that environment.  As such it is almost certainly much better for testing and deployment as you know exactly which libraries, at which versions, are used and a global change will not impact your module.  venv python > 3.3Note that from Python 3.3 onward there is a built in implementation of VirtualEnv called venv (with, on some installations a wrapper called pyvenv - this wrapper is deprecated in Python 3.6), which should probably be used in preference. To avoid possible issues with the wrapper it is often a good idea to use it directly by using /path/to/python3 -m venv desired/env/path or you can use the excellent py python selector on windows with py -3 -m venv desired/env/path.  It will create the directory specified with desired/env/path configure and populate it appropriately.  In general it is very much like using VirtualEnv.Additional ToolsThere are a number of tools that it is worth mentioning, and considering, as they can help with the use of one or more of the above:VirtualEnvWrapper Manage and simplify the use and management of VirtualEnv - Cross Platform.pyenv-virtualenv, installed by pyenv-installer, which gives PyEnv tools for managing and interfacing to VirtualEnv - with this you can have a base installation that includes more than one version of python and create isolated environments within each of them - Linux/OS-X. Suggested by Johann VisagiePyInstaller can take your python code, possibly developed & tested under VirtualEnv, and bundle it up so that it can run one platforms that do not have your version of python installed - Note that it is not a cross compiler you will need a Windows (virtual-)machine to build Windows installs, etc., but it can be handy even where you can be sure that python will be installed but cannot be sure that the version of python and all the libraries will be compatible with your code.
virtualenv allows you to create a custom Python installation e.g. in a subdirectory of your project. Each of your projects can thus have their own python (or even several) under their respective virtualenv. It is perfectly fine for some/all virtualenvs to even have the same version of python (e.g. 2.7.16) without conflict - they live separately and don't know of each other. If you want to use any of those pythons, you have to activate it (by running a script which will temporarily modify your PATH to ensure that that virtualenv's bin/ directory comes first). From that point, calling python (or pip etc.) will invoke that virtualenv's version until you deactivate it (which restores the PATH).pyenv operates on a wider scale than virtualenv - it holds a register of Python installations (and can be used to install new ones) and allows you to configure which version of Python to run when you use the python command. Sounds similar but practical use is a bit different. It works by prepending its shim python script to your PATH (permanently) and then deciding which "real" python to invoke. You can even configure pyenv to call into one of your virtualenv pythons (by using the pyenv-virtualenv plugin). Python versions you install using pyenv go into its $(pyenv root)/versions/ directory (by default, pyenv root is ~/.pyenv) so are more 'global' than virtualenv. Ordinarily, you can't duplicate Python versions installed through pyenv, at least doing so is not the main idea.To create a virtualenv with a specific Python version, you need to have that version somewhere in your system (whether it's on the PATH or not) and essentially clone it into your newly created virtualenv. Of course, one way to obtain a particular version is to install it via pyenv. Once that's done, individual virtualenvs are free to diverge by having different modules (or versions thereof) installed into them.In short:virtualenv allows you to create local, independent pythoninstallations by cloning from existing onespyenv allows you toinstall different versions of python simultaneously (eithersystem-wide or just for the local user) and then choose which of themultitude of pythons to run at any given time (including thosecreated by virtualenv or Anaconda)


Answer URL
https://docs.python.org/3/library/venv.html
