Natural Text
I am trying to write a function that given a list of non negative integers, arranges them such that they form the largest possible number. For example, given [50, 2, 1, 9], the largest formed number is 95021. Here is the code that I have tried to solve the problem:However, I get 50921 , as 50 is largest, but it should show 9 first.
In Python 2 you can do this with an appropriate comparison function passed to sort.outputIn Python 3, sort no longer takes a custom comparison function. scpio's answer shows how to use functools to convert a comparison function into a key function, but it's not that hard to do "by hand".outputThe previous Python 3 compatible version I posted doesn't actually work on Python 3 :oops:! That's because the __cmp__ method is no longer supported in Python 3. So I've changed my old __cmp__ method to _cmp and used it to implement all 6 of the rich comparison methods.Important noteI have to mention that this comparison function is a bit weird: it's non-transitive, in other words, a>b and b>c doesn't necessarily imply a>c. And that means that the results of using it in .sort() are unpredictable. It does appear to do the right thing for the data I've tested it with, eg, it returns the correct result for all permutations of [1, 5, 10], but I guess it really shouldn't be trusted to do so for all input.An alternative strategy that's guaranteed to work is brute force: generate all permutations of the input list & find the permutation that yields the maximum result. But hopefully there's a more efficient algorithm, since generating all permutations of a large list is rather slow.As Antti Haapala points out in the comments, my old comparison functions were unstable when comparing different numbers that consist of the same sequences of repeating digits, eg 123123 and 123123123. Such sequences should compare equal, my old functions didn't do that. The latest modification addresses that problem.UpdateIt turns out that mycmp() / _cmp() actually is transitive. It's also stable, now that it handles the ab == ba case properly, so it's safe to use with TimSort (or any other sorting algorithm). And it can be shown that it gives the same result as Antti Haapala's fractionalize() key function.In what follows I'll use uppercase letters to represent integers in the list and I'll use the lowercase version of a letter to represent the number of digits in that integer. Eg, a is the number of digits in A. I'll use _ as an infix operator to represent digit concatenation. Eg, A_B is int(str(A)+str(B); note that A_B has a+b digits. Arithmetically,A_B = A * 10**b + B.For the sake of brevity, I'll use f() to represent Antti Haapala's fractionalize() key function. Note that f(A) = A / (10**a - 1).Now for some algebra. I'll put it in a code block to keep the formatting simple.A mathematical induction-style argument shows that sorting a list of anyfinite length using pairwise comparisons with mycmp() / _cmp() as thecomparison function or with fractionalize() as the key function sufficesto find the permutation that yields the largest possible integerproduced by digit concatenation. The details of this argument will beleft as an exercise for the reader. :)
One-liner using insights from Antti Haapala, PM 2Ring and Stefan Pochmann:Given a = [50, 5, 51, 59, 2, 1, 9, 98]:
Here is an ugly solution that does work without passing a cmp comparison  function to the sorted. Basically, the key function takes each number and calculates a rational number that has that number as the repeating decimals; that isThe 0 is sorted the smallest with sort key 0, and 1 followed by most zeroes would have key closest to 0.1, and thus sorted second smallest. Numbers that consist of digit 9 all have sort key equal to 1; it does not really matter if you sort 9 before or after 99.Sorting using these values as the key will necessarily give the correct output, unless you use numbers that are too big for float precision. (probably much sooner than 2 ** 53)Thus we get the following program:Which producesAs we're essentially calculating i / (10 ** ceil(log10(i + 1)) - 1) here, one can also write the following oneliner:The i and part guards for division by zero error, in case 0 is among the numbers.
I hope I'm not varying too much on this.  My input is cast as a list of strings.  I generate the list of permutations, creating a list of lists, and then sort the sublists from least to greatest.  Finally, I take the last element of the sorted list.If you'd rather have the number itself rather than the list of elements...That second one actually also serves to show the the first is properly sorting on lists.I'm pretty new with Python and would appreciate comments/improvements.

The most straight-forward way is to use itertools.permutations() to model how you would solve this by hand:
I would love to understand from all the python experts here what is wrong with my one-liner solution. Leet code website keeps rejecting with failed tcs which works just fine on my local env.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__lt__
https://docs.python.org/3/library/stdtypes.html#int.bit_length
https://docs.python.org/3/library/functions.html#map
