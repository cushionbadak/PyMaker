Natural Text
I'm trying to write a Python script that installs some packages but unfortunately it's not playing friendly with Ubuntu's apt-get install.Here's my code:And here is the output:From what I understand, I believe the auto Abort is due to the blocking nature of the call, so it's not able to wait. Assuming that's true, how can I get around this?Edit: I forgot to mention that I am well aware of the -y flag that may be passed to apt-get. I'm more interested to know whether it's possible to call a command that requires input and wait for that to complete before returning back to Python.
The problem has nothing to do with "the blocking nature of the call".The apt-get program is waiting for input, a Y or N.But you've told communicate to send no input and just close the input pipe as quickly as possible.So, apt-get gets an EOF or a closed-pipe error instead of a Y or N, and it takes that as you wanting to abort.What you probably want to do here is pass the appropriate arguments to apt-get to tell it to never ask you for confirmation. Usually you want the -y flag, which answers yes to anything that's not too dangerous. IIRC, there are also flags that always answer no and answer yes whenever there's a yes answer, but I could be wrong; you can man apt-get yourself to find out what it provides and decide which one you want.You almost certainly don't want to just unconditionally pass a y and a newline to the apt-get process. At best, that'll do the same thing as just passing the -y flag. But at worst, who knows what it'll do? The -y flag is documented to answer "yes" to all safe prompts and abort on anything that can't be safely ignored; sending a y response to the first prompt happens to do the same thing in this one particular case on this one particular version of apt-get, but in another case it could very well mean "yes, reinitialize my dpkg database" or "yes, ignore the bad signature and install this malware" or anything else.But if you really do want to do this, it's pretty easy: communicate takes an input parameter, and it sends whatever you pass it to the child process's input, so:But what if you can't just use -y or similar flags because you need to do something more complicated (drive an installation like MySQL's, or access the super cow powers)? Well, there are good ways of doing that—e.g., you can preconfigure the setup with debconf-set-selections and then use noninteractive mode to skip the setup screens.If you really do want to try to access the output and prompts provided by both apt-get and individual packages and respond to them, that's doable. But it's not easy. First, you need to capture the output, by adding stdout=subprocess.PIPE to your Popen. Then, instead of calling communicate, you store the Popen in a variable, say, p. Then you can read from p.stdout, parse the responses, and respond appropriately to each prompt by writing to p.stdin. And then p.wait() at the end. But if you really want to do something like this, you're usually better off using a library like pexpect instead of doing it manually. But the big problem is… what are you going to do with that output? Do you really want to write a parser than understands everything that apt-get in verbose mode prints out? And, even if you do, how are you going to know when to answer 'y\n' or 'n\n' or something completely different? If you can do that, you can probably just use multiple apt commands in non-interactive mode with a lot less effort.
Try adding -y to your apt-get install command so that manual intervention is not required.This will tell the apt-get install command to automatically presume that you want to continue.


Answer URL
https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate
