Natural Text
Can magic methods be overridden outside of a class?When I do something like thisit prints '5' instead of '10'. Do I do something wrong or magic methods just can't be overridden outside of a class?
Short answer; not really.You cannot arbitrarily change the behaviour of int() a builtin function (*which internally calls __int__())  on arbitrary builtin types such as int(s).You can however change the behaviour of custom objects like this:Example:Demo:This overrides two things here and implements two special methods:__repr__() which get called by repr()__add__() which get called by the + operator.Update: As per the comments above; techincally you can redefine the builtin function int; Example:However this is not recommended and does not change the overall behaviour of the object x.Update #2: The reason you cannot change the behaviour of bultin types (without modifying the underlying source or using Cuthon or ctypes) is because builtin types in Python are not exposed or mutable to the user unlike Homoiconic Languages (See: Homoiconicity). -- Even then I'm not really sure you can with Cython/ctypes; but the reason question is "Why do you want to do this?"Update #3: See Python's documentation on Data Model (object.__complex__ for example).
You can redefine a top-level __int__ function, but nobody ever calls that.As implied in the Data Model documentation, when you write int(x), that calls x.__int__(), not __int__(x).And even that isn't really true. First, __int__ is a special method, meaning it's allowed to call type(x).__int__(x) rather than x.__int__(), but that doesn't matter here. Second, it's not required to call __int__ unless you give it something that isn't already an int (and call it with the one-argument form). So, it could be as if it's was written like this:So, there is no way to change what int(5) will do… short of just shadowing the builtin int function with a different builtin/global/local function of the same name, of course.But what if you wanted to, say, change int(5.5)? That's not an int, so it's going to call float.__int__(5.5). So, all we have to do is monkeypatch that, right?Well, yes, except that Python allows builtin types to be immutable, and most of the builtin types in CPython are. So, if you try it:However, if you're defining your own types, that's a different story:


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__complex__
https://docs.python.org/3/reference/datamodel.html#object.__complex__
https://docs.python.org/3/reference/datamodel.html#object.__complex__
