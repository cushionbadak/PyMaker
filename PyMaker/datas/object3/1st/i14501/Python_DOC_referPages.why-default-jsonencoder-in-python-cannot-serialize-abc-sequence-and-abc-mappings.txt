Natural Text
So, if we create some class, implementing collections.abc.MutableSequence, and list is such an example,we cannot pass its instance to default JSONEncoder.Question is not how to serialize custom classes, but why python can serialize only its own implementations of Sequence and Mapping, but not arbitrary ones, implementing exactly same interface.
As far as I know, Bob Ippolito (the primary author of simplejson, who also did the changes to stdlibify it as json in the stdlib, and does most of the maintenance on the stdlib version) has never given his rationale for this, so if you really wanted to know for sure, the only thing you could do is to ask him.But I think there's an obvious answer: If you encoded all Sequence types to JSON arrays, there'd be no way to distinguish the difference Sequence types at decode time. And, since your code is presumably using something other than list for some reason, and some reason that the json module can't predict, it may be throwing away important information.That said, wanting to treat other sequence types—or even arbitrary iterables—the same as list is a common-enough use case that it was made easy to do if you want it, and it's the example the docs use for JSONEncode.default.
Well, the standard library's json module knows how to encode Lists and Tuples into JSON because that support is explicitly built-in to the module: the relevant code is here.You'll notice that code knows nothing about collections.MutableSequence, or your custom subclass thereof; that's why your json.dumps(w) call fails with TypeError. There are some instructions in JSONEncoder.default() for how you might subclass that function to support serializing your class.   


Answer URL
https://docs.python.org/3/library/json.html#json.JSONEncoder.default
