Natural Text
I'm writing two scripts which are intended to be run from the command line.  Let's call them foo.py and bar.py.  In addition, I have a utility module called util which is to be shared by both of these scripts.  How do I structure my code so that foo and bar can both have a simple line like import util?  Currently, my directory structure is like this:Within foo, I want to be able to write import foo_util and import util but I dont' want to be able to write import bar, because they are independent programs which have no reason to use each others' code.Update: A slightly modified version of chepner's solution, I've found something that seems to work for me.  My project is now structured like this:foo.py can write import MyProject.foo as foo and bar.py can do something similar, and both foo and bar can do import MyProject.shared
I would suggest the following layout: foo.py and bar.py, as scripts, can be placed anywhere. You should install in a known place the following packages:Then, use import foo.util, import bar.util, and import util to access the individual modules where and when necessary.As abarnert pointed out, you can't hide bar/util.py from foo, nor should you care about doing so.
Put util in site-packages. That's where any modules that you want to be able to import into multiple projects are supposed to go.
The import util, given your current structure, does not import your util: it imports Python's util module. To solve this, you have to add __init__.py to util directory, which makes it valid Python package.In order to import your util, you can either do relative import (which would violate your second wish and require even your app to be a package) or use PYTHONPATH to run your script.If you wanted to use util as a library, it belongs to a site-packages directory, located implicitly in PYTHONPATH.
I think what you're missing here is that building an installable setuptools-based package solves your problem without actually requiring you to install anything system-wide.First, this kind of thing is exactly what virtualenv was created for. (Or, if you're on 3.4+, the stdlib's venv.) You create a new virtual environment. Within that environment, you pip install . your util library, and now it's in that environment's site-packages. And then you can run foo and bar and whatever else you want inside that environment, and they can all import util—but nothing has changed in your main system environment.Even if you don't want to use virtualenv for some reason (but you really should…), if you build your setup right, it will allow you to run everything in "development" mode, which does a fake install to a directory under your source tree and sets up all the links to make it work. This can be a bit fussy when you're trying to install multiple separate scripts as well as modules that they share, but it does work.A full tutorial on how to layout distributions, make setuptools auto-generate the wrapper scripts and install them to bin, etc. is way too big for an answer here, and the PyPA people already wrote one. There are some complicated bits, so you probably will get stuck at some point, but when you do, you'll have another good question to ask at SO. :)


Answer URL
https://docs.python.org/3/library/venv.html
