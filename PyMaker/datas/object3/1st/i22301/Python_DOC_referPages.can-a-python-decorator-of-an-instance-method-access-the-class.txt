Natural Text
Hi I have something roughly like the following.  Basically I need to access the class of an instance method from a decorator used upon the instance method in its definition.The code as-is givesAttributeError: 'function' object has no attribute 'im_class'I found similar question/answers - Python decorator makes function forget that it belongs to a class and Get class in Python decorator - but these rely upon a workaround that grabs the instance at run-time by snatching the first parameter.  In my case I will be calling the method based upon the information gleaned from its class, so I can't wait for a call to come in.Thank you.
If you are using Python 2.6 or later you could use a class decorator, perhaps something like this (warning: untested code).The method decorator marks the method as one that is of interest by adding a "use_class" attribute - functions and methods are also objects, so you can attach additional metadata to them.After the class has been created the class decorator then goes through all the methods and does whatever is needed on the methods that have been marked.If you want all the methods to be affected then you could leave out the method decorator and just use the class decorator.
As others have pointed out, the class hasn't been created at the time the decorator is called. However, it's possible to annotate the function object with the decorator parameters, then re-decorate the function in the metaclass's __new__ method. You'll need to access the function's __dict__ attribute directly, as at least for me, func.foo = 1 resulted in an AttributeError.
As Ants indicated, you can't get a reference to the class from within the class.  However, if you're interested in distinguishing between different classes ( not manipulating the actual class type object), you can pass a string for each class. You can also pass whatever other parameters you like to the decorator using class-style decorators.Prints:Also, see Bruce Eckel's page on decorators.
The problem is that when the decorator is called the class doesn't exist yet. Try this:This program will output:As you see, you are going to have to figure out a different way to do what you want.
Here's a simple example: The output is: 
What flask-classy does is create a temporary cache that it stores on the method, then it uses something else (the fact that Flask will register the classes using a register class method) to actually wraps the method.You can reuse this pattern, this time using a metaclass so that you can wrap the method at import time.On the actual class (you could do the same using a metaclass):Source: https://github.com/apiguy/flask-classy/blob/master/flask_classy.py
As Mark suggests:Any decorator is called BEFORE class is built, so is unknown to the decorator.We can tag these methods and make any necessary post-process later.We have two options for post-processing: automatically at the end of the class definition or somewhere before the application will run. I prefer the 1st option using a base class, but you can follow the 2nd approach as well.This code shows how this may works using automatic post-processing:The output yields:Note that in this example:We can annotate any function with any arbitrary parameters.Each class has its own exposed methods.We can inherit exposed methods as well.methods can be overriding as exposing feature is updated.Hope this helps
This is an old question but came across venusian.  http://venusian.readthedocs.org/en/latest/It seems to have the ability to decorate methods and give you access to both the class and the method while doing so.Note tht calling setattr(ob, wrapped.__name__, decorated) is not the typical way of using venusian and somewhat defeats the purpose.Either way... the example below is complete and should run.
Since python 3.6 you can use object.__set_name__ to accomplish this in a very simple way. The doc states that __set_name__ is "called at the time the owning class owner is created".Here is an example:Notice that it gets called at class creation time:If you want to know more about how classes are created and in particular exactly when __set_name__ is called, you can refer to the documentation on "Creating the class object".
You will have access to the class of the object on which the method is being called in the decorated method that your decorator should return.  Like so:Using your ModelA class, here is what this does:
Function doesn't know whether it's a method at definition point, when the decorator code runs. Only when it's accessed via class/instance identifier it may know its class/instance. To overcome this limitation, you may decorate by descriptor object to delay actual decorating code until access/call time:This allows you to decorate individual (static|class) methods:Now you can use decorator code for introspection......and for changing function behavior:


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__set_name__
https://docs.python.org/3/reference/datamodel.html#creating-the-class-object
