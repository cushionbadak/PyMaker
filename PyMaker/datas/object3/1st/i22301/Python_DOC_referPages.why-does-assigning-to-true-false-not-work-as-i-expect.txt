Natural Text
As part of answering another question, I wrote the following code whose behaviour seems bizarre at first glance:Can anyone explain this strange behaviour? I think it has something to do with Python's object model but I'm not sure.It's version 2.5.2 under Cygwin.
Python has these two (among others) builtin objects. They are just objects; in the beginning, they don't have any names yet, but to know what we refer to, let's call them 0x600D and 0xBAD.Before starting to execute a Python (2.x) script, the name True gets bound to the object 0x600D, and the name False gets bound to the object 0xBAD, so when the program refers to True, it looks at 0x600D.Because 0x600D and 0xBAD know that they are usually used by the names True and False, that's what they output when they get printed, i.e. the __str__ method of 0x600D returns 'True' and so on.now binds the name True to a different object. From now on, both names True and False refer to the same object 0xBAD, which, when printed, outputs False.doesn't really do anything: It takes the object referred to by the name True, and binds  the new (and old) name True to this object. Since (because of the previous step) True refers to 0xBAD before this, it still refers to 0xBAD after this. Hence, printing still outputs False.first takes the object that the name True is bound to, which is 0xBAD. It gives this object to the not operator. not doesn't care (or know) what name is used here to refer to 0xBAD, it just knows that when given 0xBAD it should return 0x600D. This return value is then given to the assignment operator =, binding the name True to this object.Since the name True now once more refers to the object 0x600D, calling print True outputs True, and the world is good again.
Imagine this instead:The exact same thing is going on, but in your version it's confusing, because you don't expect that you can redefine True and False.
In 2.x, True and False are not keywords so it's possible to shadow the built-ins in this manner.
You can check whether True/False is a keyword:Since it's not (in my version), assigning True=False just means "True" is another "variable" name.
You could easily restore the original values using simple Boolean comparisons:Or by converting integer literals to bools:


Answer URL
https://docs.python.org/3/reference/lexical_analysis.html#keywords
