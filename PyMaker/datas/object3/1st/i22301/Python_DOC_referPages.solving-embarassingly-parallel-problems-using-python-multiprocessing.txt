Natural Text
How does one use multiprocessing to tackle embarrassingly parallel problems?Embarassingly parallel problems typically consist of three basic parts:Read input data (from a file, database, tcp connection, etc.).Run calculations on the input data, where each calculation is independent of any other calculation.Write results of calculations (to a file, database, tcp connection, etc.).We can parallelize the program in two dimensions:Part 2 can run on multiple cores, since each calculation is independent; order of processing doesn't matter.Each part can run independently. Part 1 can place data on an input queue, part 2 can pull data off the input queue and put results onto an output queue, and part 3 can pull results off the output queue and write them out.This seems a most basic pattern in concurrent programming, but I am still lost in trying to solve it, so let's write a canonical example to illustrate how this is done using multiprocessing.Here is the example problem: Given a CSV file with rows of integers as input, compute their sums. Separate the problem into three parts, which can all run in parallel:Process the input file into raw data (lists/iterables of integers)Calculate the sums of the data, in parallelOutput the sumsBelow is traditional, single-process bound Python program which solves these three tasks:Let's take this program and rewrite it to use multiprocessing to parallelize the three parts outlined above. Below is a skeleton of this new, parallelized program, that needs to be fleshed out to address the parts in the comments:These pieces of code, as well as another piece of code that can generate example CSV files for testing purposes, can be found on github.I would appreciate any insight here as to how you concurrency gurus would approach this problem.Here are some questions I had when thinking about this problem. Bonus points for addressing any/all:Should I have child processes for reading in the data and placing it into the queue, or can the main process do this without blocking until all input is read?Likewise, should I have a child process for writing the results out from the processed queue, or can the main process do this without having to wait for all the results?Should I use a processes pool for the sum operations?If yes, what method do I call on the pool to get it to start processing the results coming into the input queue, without blocking the input and output processes, too? apply_async()? map_async()? imap()? imap_unordered()?Suppose we didn't need to siphon off the input and output queues as data entered them, but could wait until all input was parsed and all results were calculated (e.g., because we know all the input and output will fit in system memory). Should we change the algorithm in any way (e.g., not run any processes concurrently with I/O)?
My solution has an extra bell and whistle to make sure that the order of the output has the same as the order of the input.  I use multiprocessing.queue's to send data between processes, sending stop messages so each process knows to quit checking the queues.  I think the comments in the source should make it clear what's going on but if not let me know.
I realize that I'm a bit late for the party, but I've recently discovered GNU parallel, and want to show how easy it is to accomplish this typical task with it.Something like this will do for sum.py:Parallel will run sum.py for every line in input.csv (in parallel, of course), then output the results to sums. Clearly better than multiprocessing hassle
Coming late to the party...joblib has a layer on top of multiprocessing to help making parallel for loops. It gives you facilities like a lazy dispatching of jobs, and better error reporting in addition to its very simple syntax.As a disclaimer, I am the original author of joblib.
Old School.p1.pyp2.pyp3.pyHere's the multi-processing final structure.Yes, the shell has knit these together at the OS level.  It seems simpler to me and it works very nicely.  Yes, there's slightly more overhead in using pickle (or cPickle).  The simplification, however, seems worth the effort.If you want the filename to be an argument to p1.py, that's an easy change.More importantly, a function like the following is very handy.That allows you to do this:This is very simple, but it does not easily allow you to have multiple copies of P2.py running.You have two problems: fan-out and fan-in.  The P1.py must somehow fan out to multiple P2.py's.  And the P2.py's must somehow merge their results into a single P3.py.The old-school approach to fan-out is a "Push" architecture, which is very effective.Theoretically, multiple P2.py's pulling from a common queue is the optimal allocation of resources.  This is often ideal, but it's also a fair amount of programming.  Is the programming really necessary?  Or will round-robin processing be good enough?Practically, you'll find that making P1.py do  a simple "round robin" dealing among multiple P2.py's may be quite good.  You'd have P1.py configured to deal to n copies of P2.py via named pipes.  The P2.py's would each read from their appropriate pipe.  What if one P2.py gets all the "worst case" data and runs way behind?  Yes, round-robin isn't perfect.  But it's better than only one P2.py and you can address this bias with simple randomization.Fan-in from multiple P2.py's to one P3.py is a bit more complex, still.  At this point, the old-school approach stops being advantageous.  P3.py needs to read from multiple named pipes using the select library to interleave the reads.
It's probably possible to introduce a bit of parallelism into part 1 as well. Probably not an issue with a format that's as simple as CSV, but if the processing of the input data is noticeably slower than the reading of the data, you could read larger chunks, then continue to read until you find a "row separator" (newline in the CSV case, but again that depends on the format read; doesn't work if the format is sufficiently complex). These chunks, each probably containing multiple entries, can then be farmed off to a crowd of parallel processes reading jobs off a queue, where they're parsed and split, then placed on the in-queue for stage 2.


Answer URL
