Natural Text
I'd like to have loglevel TRACE (5) for my application, as I don't think that debug() is sufficient. Additionally log(5, msg) isn't what I want. How can I add a custom loglevel to a Python logger?I've a mylogger.py with the following content:In my code I use it in the following way:Now I'd like to call self.log.trace("foo bar")Thanks in advance for your help.Edit (Dec 8th 2016): I changed the accepted answer to pfa's which is, IMHO, an excellent solution based on the very good proposal from Eric S.
@Eric S.Eric S.'s answer is excellent, but I learned by experimentation that this will always cause messages logged at the new debug level to be printed -- regardless of what the log level is set to. So if you make a new level number of 9, if you call setLevel(50), the lower level messages will erroneously be printed. To prevent that from happening, you need another line inside the "debugv" function to check if the logging level in question is actually enabled.Fixed example that checks if the logging level is enabled:If you look at the code for class Logger in logging.__init__.py for Python 2.7, this is what all the standard log functions do (.critical, .debug, etc.).I apparently can't post replies to others' answers for lack of reputation... hopefully Eric will update his post if he sees this. =)
I took the "avoid seeing lambda" answer and had to modify where the log_at_my_log_level was being added.  I too saw the problem that Paul did "I don't think this works. Don't you need logger as the first arg in log_at_my_log_level?"  This worked for me
This question is rather old, but I just dealt with the same topic and found a way similiar to those already mentioned which appears a little cleaner to me. This was tested on 3.4, so I'm not sure whether the methods used exist in older versions:
Combining all of the existing answers with a bunch of usage experience, I think that I have come up with a list of all the things that need to be done to ensure completely seamless usage of the new level. The steps below assume that you are adding a new level TRACE with value logging.DEBUG - 5 == 5:logging.addLevelName(logging.DEBUG - 5, 'TRACE') needs to be invoked to get the new level registered internally so that it can be referenced by name.The new level needs to be added as an attribute to logging itself for consistency: logging.TRACE = logging.DEBUG - 5.A method called trace needs to be added to the logging module. It should behave just like debug, info, etc.A method called trace needs to be added to the currently configured logger class. Since this is not 100% guaranteed to be logging.Logger, use logging.getLoggerClass() instead.All the steps are illustrated in the method below:
Who started the bad practice of using internal methods (self._log) and why is each answer based on that?! The pythonic solution would be to use self.log instead so you don't have to mess with any internal stuff:
I find it easier to create a new attribute for the logger object that passes the log() function. I think the logger module provides the addLevelName() and the log() for this very reason. Thus no subclasses or new method needed. nowshould work as expected.
I think you'll have to subclass the Logger class and add a method called trace which basically calls Logger.log with a level lower than DEBUG. I haven't tried this but this is what the docs indicate. 
Tips for creating a custom logger:Do not use _log, use log (you don't have to check isEnabledFor)the logging module should be the one creating instance of the custom logger since it does some magic in getLogger, so you will need to set the class via setLoggerClassYou do not need to define __init__ for the logger, class if you are not storing anythingWhen calling this logger use setLoggerClass(MyLogger) to make this the default logger from getLoggerYou will need to setFormatter, setHandler, and setLevel(TRACE) on the handler and on the log itself to actually se this low level trace
This worked for me:The lambda/funcName issue is fixed with logger._log as @marqueed pointed out.  I think using lambda looks a bit cleaner, but the drawback is that it can't take keyword arguments.  I've never used that myself, so no biggie.
In my experience, this is the full solution the the op's problem... to avoid seeing "lambda" as the function in which the message is emitted, go deeper:I've never tried working with a standalone logger class, but I think the basic idea is the same (use _log).
Addition to Mad Physicists example to get file name and line number correct:
While we have already plenty of correct answers, the following is in my opinion more pythonic:If you want to use mypy on your code, it is recommended to add # type: ignore to suppress warnings from adding attribute.
As alternative to adding an extra method to the Logger class I would recommend using the Logger.log(level, msg) method.
I'm confused; with python 3.5, at least, it just works:output:DEBUG:root:y1 TRACE:root:y2
based on pinned answer, i wrote a little method which automaticaly create new logging levelsconfig may smth like that:
In case anyone wants an automated way to add a new logging level to the logging module (or a copy of it) dynamically, I have created this function, expanding @pfa's answer:


Answer URL
https://docs.python.org/3/library/logging.html?highlight=logging#logging.setLoggerClass
