Natural Text
How to format a float so it does not containt the remaing zeros? In other words, I want the resulting string to be as short as possible..?Like:
Me, I'd do ('%f' % x).rstrip('0').rstrip('.') -- guarantees fixed-point formatting rather than scientific notation, etc etc.  Yeah, not as slick and elegant as %g, but, it works (and I don't know how to force %g to never use scientific notation;-).
You could use %g to achieve this:or, for Python 2.6 or better:From the docs for format: g causes (among other things)insignificant trailing zeros [to be]  removed from the significand, and the  decimal point is also removed if there  are no remaining digits following it.
What about trying the easiest and probably most effective approach?The method normalize() removes all the rightmost trailing zeros.Works in Python 2 and Python 3.-- Updated --The only problem as @BobStein-VisiBone pointed out, is that numbers like 10, 100, 1000... will be displayed in exponential representation. This can be easily fixed using the following function instead:
After looking over answers to several similar questions, this seems to be the best solution for me:My reasoning:%g doesn't get rid of scientific notation.15 decimal places seems to avoid strange behavior and has plenty of precision for my needs.I could have used format(inputValue, '.15f'). instead of '%.15f' % inputValue, but that is a bit slower (~30%).I could have used Decimal(inputValue).normalize(), but this has a few issues as well. For one, it is A LOT slower (~11x). I also found that although it has pretty great precision, it still suffers from precision loss when using normalize().Most importantly, I would still be converting to Decimal from a float which can make you end up with something other than the number you put in there. I think Decimal works best when the arithmetic stays in Decimal and the Decimal is initialized with a string.I'm sure the precision issue of Decimal.normalize() can be adjusted to what is needed using context settings, but considering the already slow speed and not needing ridiculous precision and the fact that I'd still be converting from a float and losing precision anyway, I didn't think it was worth pursuing.I'm not concerned with the possible "-0" result since -0.0 is a valid floating point number and it would probably be a rare occurrence anyway, but since you did mention you want to keep the string result as short as possible, you could always use an extra conditional at very little extra speed cost.
Here's a solution that worked for me. It's a blend of the solution by PolyMesh and use of the new .format() syntax.Output:
You can simply use format() to achieve this:format(3.140, '.10g') where 10 is the precision you want.
While formatting is likely that most Pythonic way, here is an alternate solution using the more_itertools.rstrip tool.The number is converted to a string, which is stripped of trailing characters that satisfy a predicate.  The function definition fmt is not required, but it is used here to test assertions, which all pass. Note: it works on string inputs and accepts optional predicates.See also details on this third-party library, more_itertools.

If you can live with 3. and 3.0 appearing as "3.0", a very simple approach that right-strips zeros from float representations:(thanks @ellimilial for pointing out the exceptions)
OP would like to remove superflouous zeros and make the resulting string as short as possible.I find the %g exponential formatting shortens the resulting string for very large and very small values. The problem comes for values that don't need exponential notation, like 128.0, which is neither very large or very small.Here is one way to format numbers as short strings that uses %g exponential notation only when Decimal.normalize creates strings that are too long. This might not be the fastest solution (since it does use Decimal.normalize) 
For float you could use this:Test it:For Decimal see solution here: https://stackoverflow.com/a/42668598/5917543
Handling %f and you should put %.2f, where:.2f == .00 floats.Example:print "Price: %.2f" % prices[product]output:Price: 1.50
Use %g with big enough width, for example '%.99g'.It will print in fixed-point notation for any reasonably big number.EDIT: it doesn't work
You can use max() like this:print(max(int(x), x))
You can achieve that in most pythonic way like that:python3:


Answer URL
https://docs.python.org/3/library/string.html#format-specification-mini-language
