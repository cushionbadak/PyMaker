Natural Text
This question already has an answer here:Test if executable exists in Python?                    21 answers                How do I check if a program exists from a python script?Let's say you want to check if wget or curl are available. We'll assume that they should be in path.It would be the best to see a multiplatform solution but for the moment, Linux is enough.Hints: running the command and checking for return code is not always enough as some tools do return non 0 result even when you try --version. nothing should be visible on screen when checking for the commandAlso, I would appreciate a solution that that is more general, like is_tool(name)
shutil.whichLet me recommend an option that has not been discussed yet: a Python implementation of which, specifically shutil.which. It was introduced in Python 3.3 and is cross-platform, supporting Linux, Mac, and Windows. It is also available in Python 2.x via whichcraft. You can also just rip the code for which right out of whichcraft here and insert it into your program.distutils.spawn.find_executableAnother option that has already been mentioned is distutils.spawn.find_executable.find_executable's docstring is as follows:Tries to find 'executable' in the directories listed in 'path'So if you pay attention, you'll note that the name of the function is somewhat misleading. Unlike which, find_executable does not actually verify that executable is marked as executable, only that it is on the PATH. So it's entirely possible (however unlikely) that find_executable indicates a program is available when it is not.For example, suppose you have a file /usr/bin/wget that is not marked executable. Running wget from the shell will result in the following error: bash: /usr/bin/wget: Permission denied. which('wget') is not None will return False, yet find_executable('wget') is not None will return True. You can probably get away with using either function, but this is just something to be aware of with find_executable.
The easiest way is to try to run the program with the desired parameters, and handle the exception if it doesn't exist:This is a common pattern in Python: EAFP
You could use a subprocess call to the binary needed with :"which" : *nix"where" : Win 2003 and later (Xp has an addon)to get the executable path (supposing it is in the environment path).or just use Ned Batchelder's wh.py script, that is a "which" cross platform implementation:http://nedbatchelder.com/code/utilities/wh_py.html 

I'd go for:
I would probably shell out to which wget or which curl and check that the result ends in the name of the program you are using. The magic of unix :)Actually, all you need to do is check the return code of which. So... using our trusty subprocess module:Note that I tested this on windows with cygwin... If you want to figure out how to implement which in pure python, i suggest you check here: http://pypi.python.org/pypi/pycoreutils (oh dear - it seems they don't supply which. Time for a friendly nudge?)UPDATE: On Windows, you can use where instead of which for a similar effect.
I'd change @sorin's answer as follows, the reason is it would check the name of the program without passing the absolute path of the program

A slight modification to @SvenMarnach's code that addresses the issue of printing to the standard output stream.  If you use the subprocess.check_output() function rather than subprocess.call() then you can handle the string that is normally printed to standard out in your code and still catch exceptions and the exit status code.If you want to suppress the standard output stream in the terminal, donâ€™t print the std out string that is returned from check_output:The non-zero exit status code and output string are raised in the CalledProcessError as  subprocess.CalledProcessError.returncode and subprocess.CalledProcessError.output so you can do whatever you'd like with them. If you want to print the executable's standard output to the terminal, print the string that is returned:print() adds an extra newline to the string.  If you want to eliminate that (and write std error to the std err stream instead of the std out stream as shown with the print() statements above), use sys.stdout.write(string) and sys.stderr.write(string) instead of print():


Answer URL
https://docs.python.org/3/library/shutil.html#shutil.which
