Natural Text
What is the difference between these two lines of code:and Is one more efficient than the other?Would it be better to use
Using dis to look at the bytecode generated for the two versions:not ==!=The latter has fewer operations, and is therefore likely to be slightly more efficient. It was pointed out in the commments (thanks, @Quincunx) that where you have if foo != bar vs. if not foo == bar the number of operations is exactly the same, it's just that the COMPARE_OP changes and POP_JUMP_IF_TRUE switches to POP_JUMP_IF_FALSE:not ==:!=In this case, unless there was a difference in the amount of work required for each comparison, it's unlikely you'd see any performance difference at all.However, note that the two versions won't always be logically identical, as it will depend on the implementations of __eq__ and __ne__ for the objects in question. Per the data model documentation:There are no implied relationships among the comparison operators. The  truth of x==y does not imply that x!=y is false.For example:Finally, and perhaps most importantly: in general, where the two are logically identical, x != y is much more readable than not x == y.
@jonrsharpe has an excellent explanation of what's going on. I thought I'd just show the difference in time when running each of the 3 options 10,000,000 times (enough for a slight difference to show).Code used:And the cProfile profiler results:So we can see that there is a very minute difference of ~0.7% between if not x == 'val': and if x != 'val':. Of these, if x != 'val': is the fastest.However, most surprisingly, we can see that is in fact the fastest, and beats if x != 'val': by ~0.3%. This isn't very readable, but I guess if you wanted a negligible performance improvement, one could go down this route.
In the first one Python has to execute one more operations than necessary(instead of just checking not equal to it has to check if it is not true that it is equal, thus one more operation). It would be impossible to tell the difference from one execution, but if run many times, the second would be more efficient. Overall I would use the second one, but mathematically they are the same
Here you can see that not x == y has one more instruction than x != y. So the performance difference will be very small in most cases unless you are doing millions of comparisons and even then this will likely not be the cause of a bottleneck. 
An additional note, since the other answers answered your question mostly correctly, is that if a class only defines __eq__() and not __ne__(), then your COMPARE_OP (!=) will run __eq__() and negate it. At that time, your third option is likely to be a tiny bit more efficient, but should only be considered if you NEED the speed, since it's difficult to understand quickly.
It's about your way of reading it. not operator is dynamic, that's why you are able to apply it in But != could be read in a better context as an operator which does the opposite of what == does.
I want to expand on my readability comment above.Again, I completely agree with readability overriding other (performance-insignificant) concerns.What I would like to point out is the brain interprets "positive" faster than it does "negative".  E.g., "stop" vs. "do not go" (a rather lousy example due to the difference in number of words).So given a choice:is preferable to the functionally-equivalent:Less readability/understandability leads to more bugs.  Perhaps not in initial coding, but the (not as smart as you!) maintenance changes...


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__bool__
