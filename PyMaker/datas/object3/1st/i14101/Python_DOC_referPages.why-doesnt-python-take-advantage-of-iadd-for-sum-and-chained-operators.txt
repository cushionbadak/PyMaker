Natural Text
I just conducted an interesting test:Obviously, the __iadd__ method is more efficient than the __add__ method, not requiring the allocation of a new class.  If my objects being added were sufficiently complicated, this would create unnecessary new objects, potentially creating huge bottlenecks in my code.  I would expect that, in an a[0] + a[1] + a[2], the first operation would call __add__, and the second operation would call __iadd__ on the newly created object.Why doesn't python optimize this?
The __add__ method is free to return a different type of object, while __iadd__ should, if using in-place semantics, return self. They are not required to return the same type of object here, so sum() should not rely on the special semantics of __iadd__.You can use the functools.reduce() function to implement your desired functionality yourself:Demo:
Martjin's answer provides an excellent workaround, but I feel the need to summarize the bits and pieces of answers scattered throughout the comments:The sum function is primarily used for immutable types.  Performing all additions except the first in-place would create a performance improvement on objects that had an __iadd__ method, but checking for the __iadd__ method would cause a performance loss in the more typical case. Special cases aren't special enough to break the rules.I also stated that __add__ should probably only be called once in a + b + c, where a + b creates a temporary variable, and then calls tmp.__iadd__(c) before returning it.  However, this would violate the principle of least surprise.
Since you are writting your class anyway, you know it's __add__ can return the same object as well, don't you? And therefore you can do your currying optimized code to run with both the + operator and the built-in sum:(Just beware of passing your code to third party functions that expect "+" to be a new object)


Answer URL
https://docs.python.org/3/library/functools.html#functools.reduce
