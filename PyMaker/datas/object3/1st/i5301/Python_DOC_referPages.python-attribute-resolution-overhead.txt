Natural Text
During attribute resolution, does Python check for each attribute if it exists in the class? If so, doesn't it incur a large overhead?For example, checking the attribute a.x. Python must first check if A.__dict__["x"] is a data descriptor (as they override normal attribute lookups), meaning it should check the entire __mro__ for data descriptors.This in turn means that every attribute lookup in an instance dict, makes a lookup in the entire class mro which sounds like it's a HUGE overhead. Is this cached? And even if it is, what prevents the modification of one of the base classes, by dynamically adding a data descriptor? How will this theoretical cache get invalidated?
The class is already responsible for handling attribute lookups. But yes, to look up attributes the current class and the base classes are consulted, because the attribute could be a data descriptor.That's because some objects are special, in that they can be bound to the instance or class (a descriptor, and that they'll override any attribute with the same name on the instance if they are data descriptors (descriptors that support setting or deleting values).All this is handled in the C implementation of the class's __getattribute__ method (usually inherited from object.__getattribute__), and in C, access to both the instance and class namespaces is relatively cheap.See the Descriptor HOWTO for further details on how and why this is done.


Answer URL
https://docs.python.org/3/reference/datamodel.html#implementing-descriptors
https://docs.python.org/3/reference/datamodel.html#object.__getattribute__
https://docs.python.org/3/howto/descriptor.html
