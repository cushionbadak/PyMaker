Natural Text
I am trying to read one short and long from a binary file using python struct. But the which is wrong, It should have been 2 bytes for short and 8 bytes for long. I am not sure i am using the struct module the wrong way. When i print the value for each it is Is there a way to force python to maintain the precision on datatypes?
By default struct alignment rules, 16 is the correct answer. Each field is aligned to match its size, so you end up with a short for two bytes, then six bytes of padding (to reach the next address aligned to a multiple of eight bytes), then eight bytes for the long.You can use a byte order prefix (any of them disable padding), but they also disable machine native sizes (so struct.calcsize("=l") will be a fixed 4 bytes on all systems, and struct.calcsize("=hl") will be 6 bytes on all systems, not 10, even on systems with 8 byte longs).If you want to compute struct sizes for arbitrary structures using machine native types with non-default padding rules, you'll need to go to the ctypes module, define your ctypes.Structure subclass with the desired _pack_ setting, then use ctypes.sizeof to check the size, e.g.:which outputs 10 as desired.This could be factored out as a utility function if needed (this is a simplified example that doesn't handle all struct format codes, but you can expand if needed):which, once defined, lets you compute sizes padded or unpadded like so:
This is what the doc says:By default, the result of packing a given C struct includes pad bytes in order to maintain proper alignment for the C types involved; similarly, alignment is taken into account when unpacking. This behavior is chosen so that the bytes of a packed struct correspond exactly to the layout in memory of the corresponding C struct. To handle platform-independent data formats or omit implicit pad bytes, use standard size and alignment instead of native size and alignmentChanging it from standard to native is pretty easy: you just append the prefix = before the format characters. EDITSince from the native to standard mode, some default sizes are changed, you have two options:keeping the native mode, but switching the format characters, in this way: struct.calcsize("lh"). In C even the order of your variable inside the struct is important. Here the padding is 8 bytes, it means that every variable has to be referenced at multiple of 8 bytes.Using the format characters of the standard mode, so: struct.calcsize("=hq")


Answer URL
https://docs.python.org/3/library/struct.html#byte-order-size-and-alignment
https://docs.python.org/3/library/ctypes.html#ctypes.Structure
https://docs.python.org/3/library/ctypes.html#ctypes.sizeof
https://docs.python.org/3/library/struct.html
