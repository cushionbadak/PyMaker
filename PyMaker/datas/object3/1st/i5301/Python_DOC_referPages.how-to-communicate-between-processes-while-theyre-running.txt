Natural Text
I would like to have two processes which run parallel. The one gets input from the other, processes the data and sends the processed data back as output for the other. The other process does the same thing. Obviously there needs to be a starting point and an end point.How can I communicate between the processes while they're running? I only managed to run the two processes after each other. I tried to solve it with multiprocessing:
I tried to understand your need, but it is not fully clear to me, thus I propose this producer-consumer version of the code, where the two process communicate to reach the final result for a certain amount of iterations.First of all you need two queues in order to avoid that the same process that puts the content into the queue reads it before the other one.Second, you need a mechanism to agree on the end of the computation, in this case a None message.My proposed solution is summarised in the following code:
You could use sockets for this task, or even a micro-service approach (by rest api calls for instance).
@Roberto TraniStarting out from your solution I was even able to log the communication, that is going on between the two processes, using a third queue.Thank you, I was really stuck and didn't know how to tackle the problem.
Could you explain further what you mean by micro-service approach? I heard about REST and right now I'm trying to figure out, how I can implement this paradigm in Python. â€“ Like a web-service, for instance. You provide access to services (functions, methods) inside a module. This module can be accessed via a REST API, using for example a top-down approach as  OpenApi specification (https://en.wikipedia.org/wiki/OpenAPI_Specification ).Im currently using this kind of approach: design a high level interface (modules, functionality of each module, hierarchy and modules' interconnections); write down that design to meet REST endpoints using CRUD (https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) in a yaml/json file in an openapi editor (online: https://editor.swagger.io); use the editor functionality to generate python code (flask); edit the boiler plate code to actually implement the backend funcionalities; run the server to provide access to your API methods.You can even turn the module into a docker image for scalability: Im using this base image: https://github.com/tiangolo/uwsgi-nginx-flask-docker/


Answer URL
https://docs.python.org/3/library/ipc.html
