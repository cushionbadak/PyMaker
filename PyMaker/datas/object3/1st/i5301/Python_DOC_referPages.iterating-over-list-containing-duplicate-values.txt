Natural Text
I am looking to iterate over a list with duplicate values. The 101 has 101.A and 101.B which is right but the 102 starts from 102.C instead of 102.A
GivenCodeSimple, Two-Line Solutionor OutputDetailsIn the first example we are using itertools.count as a default factory.  This means that a new count() iterator is made whenever a new room number is added to the defaultdict dd.  Iterators are useful because they are lazily evaluated and memory efficient.  In the list comprehension, these iterators get initialized per room number.   The next number of the counter is yielded, the number is used as an index to get a letter, and the result is simply joined as a suffix to each room number.In the second example (recommended), we use an iterator of strings as the default factory.  The callable requirement is satisfied by returning the iterator in a lambda function. An iterator of strings enables us to simply call next() and directly get the next letter.  Consequently, the comprehension is simplified since slicing letters is no longer required.
The problem in your implementation is that you have a value num_count which is continuously incremented for each item in the list than just the specific items' count. What you'd have to do instead is to count the number of times each of the item has occurred in the list.Pseudocode would be1. For each room in room numbers2. Add the room to a list of visited rooms3. Count the number of times the room number is available in visited room4. Add the count to 64 and convert it to an ascii uppercase character where 65=A5. Join the required strings in the way you want to and then append it to the door_numbers list.Here's an implementationdoor_numbers now contains the final list you're expecting which is for the given input room_numbers
The naive way, simply count the number of times the element is contained in the list up until that index:This two explicit for-loops make the quadratic complexity pop out. Indeed, (1/2) * (N * (N-1)) iterations are made. I would say that in most cases you would be better off keeping a dict of counts instead of counting each time.That way, there's no messing around with indices, and it's more time efficient (at the expense of auxiliary space).
Using iterators and comprehensions:Enumerate the rooms to preserve the original orderGroup rooms by room number, sorting first as required by groupby()For each room in a group, append .A, .B, etc.Sort by the enumeration values from step 1 to restore the original orderExtract the door numbers, e.g. '101.A'.


Answer URL
https://docs.python.org/3/library/collections.html#collections.defaultdict.default_factory
