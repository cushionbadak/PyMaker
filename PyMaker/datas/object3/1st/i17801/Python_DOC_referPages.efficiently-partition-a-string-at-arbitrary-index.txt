Natural Text
Given an arbitrary string (i.e., not based on a pattern), say:I am trying to partition a string based a list of indexes.Here is what I tried, which does work:The split is based on a list of indexes [3,10,12,40]. This list then needs to be transformed into a list of start, end pairs like [[0, 3], [3, 10], [10, 12], [12, 40], [40, 52]]. I used a slice assignment to set the evens and odds, then a list comprehension to group into pairs and a second LC to return the partitions. This seems a little complex for such a simple function. Is there a better / more efficient / more idiomatic way to do this? 
I have a feeling someone asked this question very recently, but I can't find it now.  Assuming that the dropped letters were an accident, couldn't you just do:after which we have
This seems like a job for itertools.groupby.You will need to import bisect_right from the bisect module.This works the way you'd think an efficient implementation should: for each character in the string, it uses binary search in indices to compute a number representing which string in the final list that character should go in, and then groupby separates the characters by those numbers. Though it turns out to be less efficient in most cases, because array access is so quick.


Answer URL
