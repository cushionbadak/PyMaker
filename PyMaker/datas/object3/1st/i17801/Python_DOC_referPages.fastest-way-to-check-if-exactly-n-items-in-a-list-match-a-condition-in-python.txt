Natural Text
If I have m items in a list, what is the fastest way to check if exactly n of those items in the list meet a certain condition? For example:How would I check if any two items in the list match the condition x%2 == 0?The naive approach would be to use nested for loops:But that is an incredibly inefficient way of checking, and would become especially ugly if I wanted to check for any 50,000 items in a list of 2-10 million items.
This works:It has the advantage of running trough the list only once.
[Edited to reflect exact matching, which we can still accomplish with short-circuiting!]I think you'd want this to short-circuit (stop when determined, not only at the end):If you wanted to do the query much faster on the same input data several times, you should use NumPy instead (with no short-circuiting):This doesn't short-circuit, but it will be super-fast once the input array is constructed, so if you have a large input list and lots of queries to do on it, and the queries can't short-circuit very early, this will likely be faster.  Potentially by an order of magnitude.
A sum solution adding up True valuesis correct, probably more efficient than an explicit loop, and definitely the most concise:However, it relies on understanding that in an integer context like addition, True counts as 1 and False as 0. You may not want to count on that. In which case you can rewrite it (squiguy's answer):But you might want to factor this out into a function:And at that point, it might arguably be more readable to filter the list and count the length of the resulting filtered iterable instead:However, the down side of all of these variations—as with any use of map or filter is that your predicate has to be a function, not just an expression. That's fine when you just wanted to check that some_function(x) returns True, but when you want to check x % 2 == 0, you have to go to the extra step of wrapping it in a function, like this:… at which point I think you lose more readability than you gain.Since you asked for the fastest—even though that's probably misguided, since I'm sure any of these solutions are more than fast enough for almost any app, and this is unlikely to be a hotspot anyway—here are some tests with 64-bit CPython 3.3.2 on my computer with a length of 250:So, as it turns out, at least in 64-bit CPython 3.3.2 whether you use an explicit loop, sum up False and True, or sum up 1s if True makes very little difference; using not instead of == 0 makes a bigger difference in some cases than the others; but even the worst of these is only 12% worse than the best.So I would use whichever one you find most readable. And, if the slowest one isn't fast enough, the fastest one probably isn't either, which means you will probably need to rearrange your app to use NumPy, run your app in PyPy instead of CPython, write custom Cython or C code, or do something else a lot more drastic than just reorganizing this trivial algorithm.For comparison, here's some NumPy implementations (assuming lst is a np.ndarray rather than a list):Even the most obvious translation to NumPy is almost twice as fast; with a bit of work you can get it 3x faster still.And here's the result of running the exact same code in PyPy (3.2.3/2.1b1) instead of CPython:More than twice as fast with no change in the code at all.
You might want to look into numpyFor example:Timings:However, if you account for conversion from list to numpy.array, numpy is not faster:Edit:@abarnert's solution is the fastest:
You could use the sum built in with your condition and check that it equals your n value.
Why don't you just use filter() ?Ex.: Checking number of even integers in a list:then if you want the number of matches:And finally your answer:
I would use a while loop:If you are concerned about 'fastest' replace the list with a deque:In either case, it is easy to read and will short circuit when the condition is met. This does do exact matching as written with short-circuiting:You can also use an iterator over your list:
Build a generator that returns 1 for each item that matches the criteria and limit that generator to at most n + 1 items, and check that the sum of the ones is equal to the number you're after, eg:
Itertools is a useful shortcut for list trolling tasksif you're concerned about memory limit, tweak the signature so that *values is a generator rather than a tuple
A simple way to do it:Here's a slightly sillier way to write it:Giving:
Any candidate for "the fastest solution" needs to have a single pass over the input and an early-out.Here is a good base-line starting point for a solution:Here are some ideas for improving on the the algorithmicially correct baseline solution:Optimize the computation of the condition.  For example, replace x % 2 == 0 with not x & 1.  This is called reduction in strength.Localize the variables.  Since global lookups and assignments are more expensive than local variable assignments, the exact match test will run faster if it is inside a function.For example:Remove the interpreter overhead by using itertools to drive the looping logic.For example, itertools.ifilter() can isolate the matches at C-speed:Likewise, itertools.islice() can implement the early-out logic at C speed:The built-in sum() function can tally the matches at C speed.Put these together to check for an exact number of matches:These optimizations are only worth doing if it is an actual bottleneck in a real program.  That would typically only occur if you're going to make many such exact-match-count tests.  If so, then there may be additional savings by caching some of the intermediate results on the first pass and then reusing them on subsequent tests.For example, if there is a complex condition, the sub-condition results can potentially be cached and reused.Instead of:Pre-compute all the conditions (only once per data value):


Answer URL
