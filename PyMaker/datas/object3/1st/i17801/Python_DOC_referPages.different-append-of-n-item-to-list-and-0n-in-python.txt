Natural Text
I have two Code that is sameCode1Code2 in My pc Time needed for Code1 is 1s But for Code2 is 480s !!Why ? Waht is Different?
(In what follows I'm assuming you're using Python 3; in Python 2 the story would be similar but we'd have to discuss the cost of memory allocation due to range.)Your second program spends its time running in Python bytecode. Let's disassemble it using the dis module:The loop runs from bytes 22 to 41, and each time round the loop, Python has to decode and execute seven byte code instructions, and call a function too (the function being a.append). That's 420 million byte code instructions and 60 million function calls.Whereas your first program spends its time running in native code:You can see that not only is there no loop, there are no function calls. All the work happens "under the hood" inside the BINARY_MULTIPLY instruction, which dispatches to list_multiply in listobject.c, and since the list [0] contains just one element, the result is constructed in this tight loop at lines 529–536:
range in Python 2.7 creates a list itself, and not an iterator. Therefore, you do double the work in Code2. That means, you first create a list of 6000000 items, and then iterate over it. Code1 does not need that intermediate step.This [range] is a versatile function to create lists containing arithmetic  progressionsSoure: Range Python 2.xCompare that to Python 3.x: Rather than being a function, range is actually an immutable sequence  type, as documented in Ranges and Sequence Types — list, tuple, range.Source: Range Python 3.xTry to use xrange instead of range, and test it again.
Ignoring the fact that you used range instead of xrange, there are two things that are going on:1) The functions don't do the same thing, though they arrive at the same output.  Your code1 means "60 million copies of [0] concatenated together".  That is not what Code2 is doing, obviously- it has to call the append method of lists 60 million times.2) Explicit loops in python are slow.  There is a loop in Code1, somewhere, but it occurs "at C speed" as opposed to, well, python speed.In a tight loop like this, the majority of the overhead is in the loop itself rather than the operations contained therein.  So a popular method to optimize tight loops is to drop them into a comprehension:Note that again the two functions are not doing the same thing, which is why there is discrepancy between f and h.


Answer URL
