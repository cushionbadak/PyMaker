Natural Text
I'm trying to use python to control cuda, through ctypes.  Here, to illustrate my problem, I use python to pass pointers along to c functions which allocate cuda memory, copy numpy array to cuda mempory, and copy cuda memory back to a new numpy array. But it doesnt seem to work, despite my basic ctypes setup working.  I think the issue is with what's being returned from cudaMalloc function to python.  here's the python code and the C:The code should copy a random vector a to cuda memory, and then copy that cuda memory back to an empty vector c.  When I print c, thought, it is just 0s.I've wrestled with different possibilities of the float* and void*, particularly in the way alloc_gpu_mem works.  But I don't know what to do.As for the err return values, the cudaMalloc returns 0 but both cudaMemcpy return 11.What's python doing wrong with the pointer? Help? 
The problem is here:This doesn't do anything. What you wanted was:See Return types in the ctypes docs.And without that, ctypes assumes that your function returns a C int. On a 32-bit platform, you might get away with it, because you end up constructing a c_void_p whose value is that intâ€¦ but on a 64-bit platform, that pointer is going to end up with the upper 32 bits missing.So, when you pass that into CUDA, it recognizes that the pointer isn't in any range it knows about, and gives you back a cudaErrorInvalidValue (11).Also, if you get everything right, this line should be unnecessary:You're calling a function whose argtypes specifies c_void_p, so you can pass it an int that you got from a c_void_p-returning function just fine.You can see the same behavior with plain old malloc and free, except that you'll probably get a segfault at free instead of a nice error:


Answer URL
