Natural Text
I have two lists:a - dictionary which contains keywords such as ["impeccable", "obvious", "fantastic", "evident"] as elements of the listb - sentences which contains sentences such as ["I am impeccable", "you are fantastic", "that is obvious", "that is evident"]The goal is to use the dictionary list as a reference.The process is as follows:Take an element for the sentences list and run it against each element in the dictionary list. If any of the elements exists, then spit out that sentence to a new listRepeating step 1 for each of the elements in the sentences list.Any help would be much appreciated.Thanks.Below is the code:
Now that you've fixed the original problem, and fixed the next problem with doing the check backward, and renamed all of your variables, you have this:And your problem with it is:The way I have the code written i can get the dictionary items but instead i want to print the sentences. Well, yes, your match is a dictionary item, and that's what you're printing, so of course that's what you get.If you want to print the sentences that contain the dictionary item, you can't use any, because the whole point of that function us to just return True if any elements are true. It won't tell you which ones—in fact, if there are more than one, it'll stop at the first one.If you don't understand functions like any and the generator expressions you're passing to them, you really shouldn't be using them as magic invocations. Figure out how to write them as explicit loops, and you will be able to answer these problems for yourself easily. (Note that the any docs directly show you how to write an equivalent loop.)For example, your existing code is equivalent to:Written that way, it should be obvious how to fix it. First, you want to print the sentence instead of the word, so print value instead of match (and again, it would really help if you used meaningful variable names like sentence and word instead of meaningless names like value and misleading names like match…). Second, you want to print all matching sentences, not just the first one, so don't break. So:And if you go back to my first answer, you may notice that this is the exact same structure I suggested.You can simplify or shorten this by using comprehensions and iterator functions, but not until you understand the simple version, and how those comprehensions and iterator functions work.
First translate your algorithm into psuedocode instead of a vague description, like this:The only one of these steps that isn't completely trivial to convert to Python is "spit out the sentence to a new list". To do that, you'll need to have a new list before you get started, like a_new_list = [], and then you can call append on it.Once you convert this to Python, you will discover that "I am impeccable and fantastic" gets spit out twice. If you don't want that, you need to find the appropriate please to break out of the inner loop and move on to the next sentence. Which is also trivial to convert to Python.
Now that you've posted your code… I don't know what problem you were asking about, but there's  at least one thing obviously wrong with it.sentences is a list of sentences.So, for partial in sentences means each partial will be a sentence, like "I am impeccable".dictionary is a list of words. So, for value in dictionary means each value will be a word, like "impeccable".Now, you're checking partial in value for each value for each partial. That will never be true. "I am impeccable" is not in "impeccable".If you turn that around, and check whether value in partial, it will give you something that's at least true sometimes, and that may even be what you actually want, but I'm not sure.As a side note, if you used better names for your variables, this would be a lot more obvious. partial and value don't tell you what those things actually are; if you'd called them sentence and word it would be pretty clear that sentence in word is never going to be true, and that word in sentence is probably what you wanted.Also, it really helps to look at intermediate values to debug things like this. When you use an explicit for statement, you can print(partial) to see each thing that partial holds, or you can put a breakpoint in your debugger, or you can step through in a visualizer like this one. If you have to break the any(genexpr) up into an explicit loop to do, then do so. (If you don't know how, then you probably don't understand what generator expressions or the any function do, and have just copied and pasted random code you didn't understand and tried changing random things until it worked… in which case you should stop doing that and learn what they actually mean.)


Answer URL
