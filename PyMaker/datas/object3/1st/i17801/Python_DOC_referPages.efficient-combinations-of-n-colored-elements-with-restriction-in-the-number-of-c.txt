Natural Text
Given a set of N elements colored with C colors, how can I find every possible combination of length L that contains no more than a maximum of M colors?I tried this algorithm that uses itertools.combinations to generate all the possible combinations, and then filter out those that do not hold the maximum colors condiction.the output is like:The problem is that generating all possible combinations can be computationally very expensive. In my case, for instance, L is often 6 and  the number of elements N is around 50, so it gives us Bin(50,6) = 15890700 possible combinations. If maximum number of colors allowed in a comination is small, most of combinations are "useless" and so they are discarded in the filter step. My intuition is that I should put the filtering step inside/before the combinatory step, to avoid the explotion of combinations, but I don't see how.
Combinatorial problems are notorious for being easy to state but possibly difficult to solve.  For this one, I wouldn't use itertools at all, but instead write a custom generator.  For example,Then:produces the same 188 combinations as your post-processing code, but internally abandons a partial combination as soon as it would span more than max_colors colors.  There's no way to change what itertools functions do internally, so when you want control over that, you need to roll your own.Using itertoolsHere's another approach, generating first all solutions with exactly 1 color, then exactly 2 colors, and so on.  itertools can be used directly for much of this, but at the lowest level still needs a custom generator.  I find this harder to understand than a fully custom generator, but it may be clearer to you:I haven't timed these, because I don't care ;-)  The fully custom generator's single result list is reused for building each output, which slashes the rate of dynamic memory turnover.  The second way creates a lot of memory churn by pasting together multiple levels of from_first and rest tuples - and that's mostly unavoidable because it uses itertools to generate the from_first tuples at each level.Internally, itertools functions almost always work in a way more similar to the first code sample, and for the same reasons, reusing an internal buffer as much as possible.AND ONE MOREThis is more to illustrate some subtleties.  I thought about what I'd do if I were to implement this functionality in C as an itertools function.  All the itertools functions were first prototyped in Python, but in a semi-low-level way, reduced to working with vectors of little integers (no "inner loop" usage of sets, dicts, sequence slicing, or pasting together partial result sequences - sticking as far as possible to O(1) worst-case time operations on dirt simple native C types after initialization).At a higher level, an itertools function for this would accept any iterable as its primary argument, and almost certainly guarantee to return combinations from that in lexicographic index order.  So here's code that does all that.  In addition to the iterable argument, it also requires an elt2ec mapping, which maps each element from the iterable to its equivalence class (for you, those are strings naming colors, but any objects usable as dict keys could be used as equivalence classes):(Note that this is Python 3 code.)  As advertised, nothing in inner() is fancier than indexing a vector with a little integer.  The only thing remaining to make it directly translatable to C is removing the recursive generation.  That's tedious, and since it wouldn't illustrate anything particularly interesting here I'm going to ignore that.Anyway, the interesting thing is timing it.  As noted in a comment, timing results are strongly influenced by the test cases you use.  combs3() here is sometimes fastest, but not often!  It's almost always faster than my original combs(), but usually slower than my combs2() or @GarethRees's lovely constrained_combinations().So how can that be when combs3() has been optimized "almost all the way down to mindless ;-) C-level operations"?  Easy!  It's still written in Python.  combs2() and constrained_combinations() use the C-coded itertools.combinations() to do much of their work, and that makes a world of difference.  combs3() would run circles around them if it were coded in C.Of course any of these can run unboundedly faster than the allowed_combinations() in the original post - but that one can be fastest too (for example, pick just about any inputs where max_colors is so large that no combinations are excluded - then allowed_combinations() wastes little effort, while all these others add extra substantial extra overheads to "optimize" pruning that never occurs).
Here's an implementation that's a bit simpler than the other answers posted so far. The basic approach is to:Pick a value ("colour" in your terminology) that has not been picked so far;Loop over i, the number of keys ("elements") associated with that value that will be included in the output;  Loop over c, the combinations of those keys of length i;    Recurse to pick the next value.NotesIn Python 3.3 or later, you could use the yield from statement to simplify the recursive call:If you're wondering why the doctests use collections.OrderedDict, it's so that the combinations can be returned in a predictable order, which is necessary for the tests to work.The code reverses the list values, and iterates downwards over i so that if the caller passes in an OrderedDict, the combinations are returned in a sensible order (with values that appear early in the input also appearing early in the output).Given the slight awkwardness in getting predictable output from this function, it would, I think, be worth considering changing the interface so that instead of taking a dictionary mapping keys to values, it would take an iterable of (key, value) pairs.PerformanceThis is broadly similar in speed to Tim Peter's combs2:
Rough outline.You have in total C different colors. For each k, 1 <= k <= M, choose k colorsin Bin(C,k) ways. (I'm using your notation here assuming Bin mean binomial coefficient).For each of the above choices, collect all the elements with the chosen colors. Let's say it gives P distinct elements. Then choose L from these P elements in Bin(P, L) different ways.All of the above subject to obvious checks, M <= C, L <= P, etc.The advantage of this approach is that it will generate only valid combinations and every valid combination will be generated exactly once. (edit: and as pointed out in a comment, this is not true duplicate, combination can be generated).PS. And here's an implementation of the above algorithm, with the fix for duplicated combinations:PS. I also timed Tim's comb2, my own comb and Gareth's constrained_combinations with the program here with these results:


Answer URL
