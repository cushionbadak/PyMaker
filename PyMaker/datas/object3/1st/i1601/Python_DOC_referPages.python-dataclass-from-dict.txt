Natural Text
The standard library in 3.7 can recursively convert a dataclass into a dict (example from the docs):I am looking for a way to turn a dict back into a dataclass when there is nesting. Something like C(**tmp) only works if the fields of the data class are simple types and not themselves dataclasses. I am familiar with jsonpickle, which however comes with a prominent security warning. 
Below is the CPython implementation of asdictâ€“ or specifically, the internal recursive helper function _asdict_inner that it uses:asdict simply calls the above with some assertions, and dict_factory=dict by default.How can this be adapted to create an output dictionary with the required type-tagging, as mentioned in the comments?1. Adding type informationMy attempt involved creating a custom return wrapper inheriting from dict:Looking at the original code, only the first clause needs to be modified to use this wrapper, as the other clauses only handle containers of dataclass-es:Imports:Functions used:Tests with the example dataclasses:Results are as expected.2. Converting back to a dataclassThe recursive routine used by asdict can be re-used for the reverse process, with some relatively minor changes:Functions used:Test:Again as expected.
I'm the author of dacite - the tool that simplifies creation of data classes from dictionaries.This library has only one function from_dict - this is a quick example of usage:Moreover dacite supports following features:nested structures(basic) types checkingoptional fields (i.e. typing.Optional)unionscollectionsvalues casting and transformationremapping of fields names... and it's well tested - 100% code coverage!To install dacite, simply use pip (or pipenv):
You can use mashumaro for creating dataclass object from a dict according to the scheme. Mixin from this library adds convenient from_dict and to_dict methods to dataclasses:
If your goal is to produce JSON from and to existing, predefined dataclasses, then just write custom encoder and decoder hooks. Do not use dataclasses.asdict() here, instead record in JSON a (safe) reference to the original dataclass.jsonpickle is not safe because it stores references to arbitrary Python objects and passes in data to their constructors. With such references I can get jsonpickle to reference internal Python data structures and create and execute functions, classes and modules at will. But that doesn't mean you can't handle such references unsafely. Just verify that you only import (not call) and then verify that the object is an actual dataclass type, before you use it.The framework can be made generic enough but still limited only to JSON-serialisable types plus dataclass-based instances:This uses JSON-RPC-style class hints to name the dataclass, and on loading this is verified to still be a data class with the same fields. No type checking is done on the values of the fields (as that's a whole different kettle of fish).Use these as the default and object_hook arguments to json.dump[s]() and json.dump[s]():or create instances of the JSONEncoder and JSONDecoder classes with those same hooks.Instead of using fully qualifying module and class names, you could also use a separate registry to map permissible type names; check against the registry on encoding, and again on decoding to ensure you don't forget to register dataclasses as you develop.
All it takes is a five-liner:Sample usage:Full code, including to/from json, here at gist: https://gist.github.com/gatopeich/1efd3e1e4269e1e98fae9983bb914f22


Answer URL
https://docs.python.org/3/library/json.html#json.JSONEncoder
https://docs.python.org/3/library/json.html#json.JSONDecoder
