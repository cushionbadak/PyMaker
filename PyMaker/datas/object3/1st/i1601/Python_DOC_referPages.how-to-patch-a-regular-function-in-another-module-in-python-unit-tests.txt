Natural Text
I'm trying to patch a function defined in a different module from the module containing the testing code. If the function and its test are defined in the same module, I've found that the following works:Moreover, if I drop into the debugger in test function just before the foo() call, I see that foo is a MagicMock instance, and that if I call it, it returns 'baz' (not 'bar') as expected.I've tried to adapt this somewhat as follows. In the same directory, I've written a foo_module.py containing just the definition of foo():and I've imported this function in the testing module and changed the patch() argument from __main__.foo to foo_module.foo:However, if I try to run this, I get an AssertionError because the mock_foo was not called:Indeed now if I drop into the debugger, foo is an ordinary function and no longer a MagicMock instance, and it returns 'bar' instead of 'baz':Any idea why this is not working? I've consulted the docs (https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch) but to no avail so far...
I managed to get the example to work by, instead of from foo_module import foo and calling foo(), doing import foo_module followed by foo_module.foo():Basically the patch() decorator determines a target and an attribute, and internally replaces that attribute by a mock instance, along the lines ofsetattr(target, attribute, MagicMock())In the original example, the foo() function was being imported directly and was not an 'attribute' of the foo_module, so the patcher was not patching the intended object.


Answer URL
https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch
