Natural Text
I know that in Python, generators are invoked lazily. For example:The line print('this was evaluated now 1') was evaluated only after the first next(g) was called.I wonder whether there is a simple way to invoke the generator non-lazily. This means that when calling g = G(), the function would calculate everything up to and including the first yield result, without actually yielding. Then, on the first call to next(g), the already-calculated result will be yielded, and also everything up to and including the second yield result would be calculated. And so on.How can this be achieved? Here is the expected behavior under this non-lazy scheme:Here is a solution attempt, which does not work:This fails since the value is yielded only after the return statement, while the calculation of everything up to the next yield happens before the return statement. This example made me realize that it may not be possible to perform what I am seeking for, since it would require doing steps after the function has returned (might require multi-threading).
You could probably write some kind of decorator for it, such as:Then you can simply decorate your normal generators:which will work as follows:
credit: this was inspired by @L3viathan answerIn this version, itertools.tee is used to store the one yielded value the wrapper is behind the original generator.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.tee
