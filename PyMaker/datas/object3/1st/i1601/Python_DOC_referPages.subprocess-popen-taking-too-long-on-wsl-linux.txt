Natural Text
I have this subprocess.Popen() context manager:And it seems to take 53 seconds to process list(process.stdout) when running in a WSL Linux enviorment. However, when I run it in a Windows enviorment, it only takes 0.6 seconds. I'm finding it strange to see why the timings are so different. I've tried using subprocess.run() and subprocess.check_output() instead, but they still lead to the same long lag before processing the tqdm() loop. Am I missing something here? I've tried looking at the docs to see what are the differences using subprocess.Popen() in a Windows vs WSL Linux enviorment, but I'm still unsure what the issue is. Perhaps list(process.stdout) is unnecessary here, and there is a better way to store the lines from stdout.Any sort of guidance would be very helpful here. 
Windows Subsystem for Linux is a bit rubbish. It's got many, many bugs and it's significantly slower than it needs to be. This is just another bug manifesting itself. Here are some possible bottlenecks:Slow context switching in WSL.WSL not noticing that an entire process waiting for a pipe means that the other end of the pipe should be run now.The child process being executed lazily.Windows taking a while to figure out that it needs to use wsl.exe to launch the program (thanks RoadRunner!)The usual overhead of Windows, plus the usual (comparatively small) overhead of Linux.A poor choice of Ubuntu distro causing many unnecessary services to be running in systemd(?)Windows deciding to run other stuff before the child process for some unknown reason.Deliberate malice on the part of the Windows Subsystem for Linux developers, conspiring to "prove" that Windows is the superior operating system by setting up a strawman. Too silly.There's nothing wrong with your Python code that would make this slow.


Answer URL
https://docs.python.org/3/library/subprocess.html#subprocess.Popen
https://docs.python.org/3/library/subprocess.html#subprocess.run
https://docs.python.org/3/library/subprocess.html#subprocess.check_output
