Natural Text
I have managed to get my first python script to work which downloads a list of .ZIP files from a URL and then proceeds to extract the ZIP files and writes them to disk.I am now at a loss to achieve the next step. My primary goal is to download and extract the zip file and pass the contents (CSV data) via a TCP stream. I would prefer not to actually write any of the zip or extracted files to disk if I could get away with it.Here is my current script which works but unfortunately has to write the files to disk.
My suggestion would be to use a StringIO object. They emulate files, but reside in memory. So you could do something like this:Or more simply (apologies to Vishal):In Python 3 use BytesIO instead of StringIO.
Below is a code snippet I used to fetch zipped csv file, please have a look: Python 2:Python 3:Here file is a string.  To get the actual string that you want to pass, you can use zipfile.namelist().  For instance,
I'd like to offer an updated Python 3 version of Vishal's excellent answer, which was using Python 2, along with some explanation of the adaptations / changes, which may have been already mentioned. Necessary changes:There's no StringIO in Python 3. Instead, I use io, and from it I import BytesIO, because we will be handling a bytestream -- Docs, also this thread. urlopen:"The legacy urllib.urlopen function from Python 2.6 and earlier has been discontinued; urllib.request.urlopen() corresponds to the old urllib2.urlopen.",  Docs. import urllib.request:This thread. Note:In Python 3, the printed output lines will look like so: b'some text'. This is expected, as they aren't strings - remember, we're reading a bytestream. Have a look at Dan04's excellent answer.A few minor changes I made:I use with ... as instead of zipfile = ... according to the Docs. The script now uses namelist() to cycle through all the files in the zip and print their contents.I moved the creation of the ZipFile object into the with-statement, altough I'm not sure if that's better.I added (and commented out) an option to write the bytestream to file (per file in the zip), in response to NumenorForLife's comment; it adds "unzipped_and_read_" to the beginning of the filename and a ".file" extension (I prefer not to use ".txt" for files with bytestrings). The indenting of the code will, of course, need to be adjusted if you want to use it. Need to be careful here -- because we have a byte string, we use binary mode, so "wb"; I have a feeling that writing binary opens a can of worms anyway...I am using an example file, the UN/LOCODE text archive:What I didn't do:NumenorForLife asked about saving the zip to disk. I'm not sure what he meant by it -- downloading the zip file? That's a different task; see Oleh Prypin's excellent answer. Here's a way: 
write to a temporary file which resides in RAMit turns out the tempfile module ( http://docs.python.org/library/tempfile.html ) has just the thing:tempfile.SpooledTemporaryFile([max_size=0[,  mode='w+b'[, bufsize=-1[, suffix=''[,  prefix='tmp'[, dir=None]]]]]])This  function operates exactly as  TemporaryFile() does, except that data  is spooled in memory until the file  size exceeds max_size, or until the  fileâ€™s fileno() method is called, at  which point the contents are written  to disk and operation proceeds as with  TemporaryFile().The resulting file has one additional  method, rollover(), which causes the  file to roll over to an on-disk file  regardless of its size.The returned object is a file-like  object whose _file attribute is either  a StringIO object or a true file  object, depending on whether  rollover() has been called. This  file-like object can be used in a with  statement, just like a normal file.New in version 2.6.or if you're lazy and you have a tmpfs-mounted /tmp on Linux, you can just make a file there, but you have to delete it yourself and deal with naming
I'd like to add my Python3 answer for completeness:
Adding on to the other answers using requests:Use help(f) to get more functions details for e.g. extractall() which extracts the contents in zip file which later can be used with with open. 
It wasn't obvious in Vishal's answer what the file name was supposed to be in cases where there is no file on disk. I've modified his answer to work without modification for most needs.
Vishal's example, however great, confuses when it comes to the file name, and I do not see the merit of redefing 'zipfile'. Here is my example that downloads a zip that contains some files, one of which is a csv file that I subsequently read into a pandas DataFrame:(Note, I use Python 2.7.13)


Answer URL
https://docs.python.org/3/whatsnew/3.0.html
https://docs.python.org/3/library/urllib.request.html#urllib.request.urlopen
https://docs.python.org/3/library/zipfile.html
