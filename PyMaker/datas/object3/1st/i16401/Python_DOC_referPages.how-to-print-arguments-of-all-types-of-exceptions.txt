Natural Text
I'm writing a program that parses 10 websites, locates data files, saves the files, and then parses them to make data that can be readily used in the NumPy library. There are tons of errors this file encounters through bad links, poorly formed XML, missing entries, and other things I've yet to categorize. I initially made this program to handle errors like this:But now I want to log errors:Note this is printing to a log file for later review. This usually prints very useless data. What I want is to print the exact same lines printed when the error triggers without the try-except intercepting the exception, but I don't want it to halt my program since it is nested in a series of for loops that I would like to see to completion.
Some other answer have already pointed out the traceback module.Please notice that with print_exc, in some corner cases, you will not obtain what you would expect. In Python 2.x:...will display the traceback of the last exception:If you really need to access the original traceback one solution is to cache the exception infos as returned from exc_info in a local variable and display it using print_exception:Producing:Few pitfalls with this though:From the doc of sys_info:Assigning the traceback return value to a local variable in a function that is handling an exception will cause a circular reference. This will prevent anything referenced by a local variable in the same function or by the traceback from being garbage collected. [...] If you do need the traceback, make sure to delete it after use (best done with a try ... finally statement)but, from the same doc:Beginning with Python 2.2, such cycles are automatically reclaimed when garbage collection is enabled and they become unreachable, but it remains more efficient to avoid creating cycles.On the other hand, by allowing you to access the traceback associated with an exception, Python 3 produce a less surprising result:... will display:
traceback.format_exc() or sys.exc_info() will yield more info if that's what you want.
If you're debugging and just want to see the current stack trace, you can simply call:traceback.print_stack()There's no need to manually raise an exception just to catch it again.
How to print the full traceback without halting the program?When you don't want to halt your program on an error, you need to handle that error with a try/except:To extract the full traceback, we'll use the traceback module from the standard library:And to create a decently complicated stacktrace to demonstrate that we get the full stacktrace:PrintingTo print the full traceback, use the traceback.print_exc method:Which prints:Better than printing, logging:However, a best practice is to have a logger set up for your module. It will know the name of the module and be able to change levels (among other attributes, such as handlers)In which case, you'll want the logger.exception function instead:Which logs:Or perhaps you just want the string, in which case, you'll want the traceback.format_exc function instead:Which logs:ConclusionAnd for all three options, we see we get the same output as when we have an error:
In addition to @Aaron Hall's answer, if you are logging, but don't want to use logging.exception() (since it logs at the ERROR level), you can use a lower level and pass exc_info=True. e.g.
You will need to put the try/except inside the most innerloop where the error may occur, i.e.... and so onIn other words, you will need to wrap statements that may fail in try/except as specific as possible, in the most inner-loop as possible.   
To get the precise stack trace, as a string, that would have been raised if no try/except were there to step over it, simply place this in the except block that catches the offending exception.Here's how to use it (assuming flaky_func is defined, and log calls your favorite logging system): It's a good idea to catch and re-raise KeyboardInterrupts, so that you can still kill the program using Ctrl-C.  Logging is outside the scope of the question, but a good option is logging.  Documentation for the sys and traceback modules.
First, don't use prints for logging, there is stable, proven and well-thought stdlib's module to do that: logging. You definitely should use it instead.Second, don't be tempted to do mess with unrelated tools when there is native and simple approach. Here is it:That's it. You are done now.Explanation for anyone who is interested in how things go under the hoodWhat log.exception doing is actually just call to log.error (that is, log event with level ERROR) and print traceback then.Why it is better?Well, here is some considerations:it is just right;it is straightforward;it is simple.Why nobody shouldn't use treceback nor call logger with exc_info=True nor get him/her hands dirty with sys.exc_info?Well, because! They are all exist for different purposes. For example, traceback.print_exc's output is a little bit different from tracebacks produced by interpreter itself. If you going to use it, you will confuse anyone who will be banging him head with your logs.Passing exc_info=True to log calls is just inappropriate. But, it is useful when you catching recoverable errors and want to log them (using, e.g INFO level) with tracebacks as well, because log.exception produces logs of only one level - ERROR.And you definitely should avoid messing with sys.exc_info as much as you can. It is just not public interface, it is internal one - you can use it if you definitely know what you are doing. It is not intended just for printing exceptions.
You want the traceback module. It will let you print stack dumps like Python normally does. In particular, the print_last function will print the last exception and a stack trace.
A remark about this answer's comments: print(traceback.format_exc()) does a better job for me than traceback.print_exc(). With the latter, the hello is sometimes strangely "mixed" with the traceback text, like if both want to write to stdout or stderr at the same time, producing weird output (at least when building from inside a text editor and viewing the output in the "Build results" panel).Traceback (most recent call last):   File "C:\Users\User\Desktop\test.py", line 7, in hell    do_stuff()    File "C:\Users\User\Desktop\test.py", line 4, in do_stuff      1/0  ZeroDivisionError: integer division or modulo by zeroo  [Finished in 0.1s]  So I use:


Answer URL
https://docs.python.org/3/library/traceback.html#traceback.print_stack
https://docs.python.org/3/library/logging.html
