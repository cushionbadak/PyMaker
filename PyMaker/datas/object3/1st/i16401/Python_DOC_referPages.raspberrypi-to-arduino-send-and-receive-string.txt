Natural Text
This is the code I am currently using to send and receive int values from a RaspberryPi to an Arduino using i2C. It works fine for values 0-255, but because of the 1 byte limit, anything larger fails.To circumvent this, I'd like to send and receive string values instead, and then convert back to int if necessary.What changes would I need to make in the following?Here is my RPi Python codeAnd here is my Arduino code 
Check the following Link:[http://www.i2c-bus.org/][1]When I was sending data back and forward using I2C I was converting the string characters to bytearrays and viceversa.  So since you are always sending bytes.  It will always work since you are sending numbers between 0-255.Not sure this helps but at least may give you an idea.
This problem essentially has two parts: splitting an integer into its bytes and reassembling an integer from bytes. These parts must be replicated on both the Pi and Arduino. I'll address the Pi side first, in Python:Splitting an integer:Reassembling an integer from bytes:Arduino Side, in CSplit an Integer:Reassembling a received Integer:Note: I'm having some trouble understanding what your other code in this routine is doing, so I'm going to reduce it to just assembling the integer.I don't have the materials on hand to test this, so it's possible I've gotten the byte order flipped in one routine or another. If you find stuff coming in or out backwards, the easiest place to fix it is in the Python script by using the built-in function reversed() on the strings or lists.References (I used some code from the Arduino Examples):Arduino String objectsArduino String ConstructorsPython Built-ins chr() and ord()
You could convert the number to a string of digits like you said. But you could also send the raw bytes.String of digitsAdvantagesNumber can have infinite digits. Note that when Arduino reads the number as a string, it is infinite, but you can't convert it all to integer if it overflows the 16-bit range (or 32-bit for Due).DisadvantagesVariable size, thus requiring more effort in reading.Waste of bytes, because each decimal digit would be a byte, plus the null-terminator totalizing (digits + 1) size.Having to use decimal arithmetic (which really is only useful for human counting), note that a "number to string" operation also uses decimal arithmetic.You can't send/receive negative numbers (unless you send the minus signal, wasting more time and bytes).Raw bytesAdvantagesNumber of bytes sent for each integer is always 4.You can send/receive negative numbers.The bitwise arithmetic in C++ for extracting each byte from the number is really fast.Python already has the struct library which packs/unpacks each byte in a number to a string to send/receive, so you don't need to do the arithmetic like in C++.DisadvantagesNumber has a limited range (signed 32-bit integer in our case, which ranges from -2147483648 to 2147483647). But it doesn't matter because no Arduino can handle more than 32-bit anyways.So I would use the raw bytes method, which I can provide some untested functions here:And the Arduino part:I don't have any experience with I2C, but if its queue is a FIFO, then the code should work.


Answer URL
https://docs.python.org/3/library/binascii.html
