Natural Text
I have to translate euro's (in a string) to euro cents (int):Examples: '12,1' => 1210  '14,51' => 1451I use this python function: But with this amount '1229,84' the result is : 122983 UpdateI use the solution from Wim, bacause I use integers in both Python / Jinja and javascript for currency artitmetic. See also the answer from Chepner.My questions was anwered by Mr. Me, who explained the above result.
What the Docs Say, and a simple explanationI tried it out, and was surprised that this was happening. So I turned to the documentation, and there is a little note in there that says.Note The behavior of round() for floats can be surprising: for  example, round(2.675, 2) gives 2.67 instead of the expected 2.68. This  is not a bug: it’s a result of the fact that most decimal fractions  can’t be represented exactly as a float. Now what does that mean, most decimal fractions can't be represented as a float. Well the documentations follows up with a great link at explains this, but since you probably didn't come here to read a nerdy technical document, let me summarize what is going on.Python uses the IEEE-754 floating point standard to represent floats. This standard compromises accuracy for speed. Some numbers cannot be accurately represented. For example .1 is actually represented as 0.1000000000000000055511151231257827021181583404541015625. Interestingly, .1 in binary is actually an infinitely repeating number, just like 1/3 is an infinitely repeating .333333.An Under the Hood Case StudyNow on to your particular case. This was pretty fun to look into, and this is what I discovered.first lets simplify what you where trying to dotoSometimes Python1 is unable to 100% accurately display binary floating point numbers, for the same reason we are unable to display the fraction 1/3 as a decimal. When this happens Python hides any extra digits. .1 is actually stored as -0.100000000000000092, but Python will display it as .1 if you type it into the console. We can see those extra digits by doing int(1.1) - 1.13. we can apply this int(myNum) - myNum formula to most floating point numbers to see the extra hidden digits behind them.4. In your case we would do the following.1229.84 is actually 1229.8399999999999181. Continuing on.5Now on to the last step. This is the part we are concerned about. Changing it back to an integer.It rounds downwards instead of upwards, however, if we never had multiplied it by 100, we would still have 2 more 9s at the end, and Python would round up.??? Now what is going on. Why is Python rounding 122983.99999999999 down, but it rounds 122983.9999999999999 up? Well whenever Python turns a float into a integer it rounds down. However, you have to remember that to Python 122983.9999999999999 with the extra two 99s at the end is the same thing as 122984.0 For example.and without the two extra 99s on the end.Python is definitely treating 122983.9999999999999 as 122984.0 but not 122983.99999999999. Now back to casting 122983.99999999999 to an integer. Because we have created ourselves a decimal portion that is less than 122984 that Python sees as being a seperate number from 122984, and because casting to an integer always causes Python to round down, we get 122983 as a result.Whew. That was a lot to go through, but I sure learned a lot writing this out, and I hope you did to. The solution to all of this is to use decimal numbers instead of floats which compromises speed for accuracy.What about rounding? The original problem had some rounding in it as well -- it's useless. See appendix item 6.The Solutiona) The easiest solution is to use the decimal module instead of floating point numbers. This is the preferred way of doing things in any finance or accounting program.The documentation also mentioned the following solutions which I've summarized.b) The exact value can be expressed and retrieved in a hexadecimal form via myFloat.hex() and float.fromhex(myHex)c) The exact value can also be retrieved as a fraction through myFloat.as_integer_ratio()d) The documentation briefly mentions using SciPy for floating point arithmitic, however this SO question mentions that SciPy's NumPy floats are nothing more than aliases to the built-in float type. The decimal module would be a better solution.Appendix1 - Even though I will often refer to Python's behavior, the things I talk about are part of the IEEE-754 floating point standard which is what the major programming languages use for their floating point numbers.2 - int(1.1) - 1.1 gives me -0.10000000000000009, but according to the documentation .1 is really 0.10000000000000000555111512312578270211815834045410156253 - We used int(1.1) - 1.1 instead of int(.1) - .1 because int(.1) - .1 does not give us the hidden digits, but according to the documentation they should still be there for .1, hence I say int(someNum) -someNum works most of the time, but not all of the time.4 - When we use the formula int(myNum) - myNum what is happening is that casting the number to an integer will round the number down so int(3.9) becomes 3, and when we minus 3 from 3.9 we are left with -.9. However, for some reason that I do not know, when we get rid of all the whole numbers, and we're just left with the decimal portion, Python decides to show us everything -- the whole mantissa.5 - this does not really affect the outcome of our analysis, but when multiplying by 100, instead of the hidden digits being shifted over by 2 decimal places, they changed a little as well.6 - It may seem like we can get rid of all those extra digits by rounding to two decimal places.But when we use our int(someNum) - someNum formula to see the hidden digits, they are still there.This is because Python cannot store 1229.84 as a binary floating point number. It can't be done. So... rounding 1229.84 does absolutely nothing.
Don't use floating-point arithmetic for currency; rounding error for values that cannot be represented exactly will cause the type of loss you are seeing. Instead, convert the string representation to an integer number of cents, which you can convert to euros-and-cents for display as needed.(Notice you'll need a check to handle cents without a trailing 0.)You can also use the Decimal class from the decimal module, which essentially encapsulates all the logic for using integers to represent fractional values.
As @wim mentions in a comment, use the Decimal type from the stdlib decimal module instead of the built in float type. Decimal objects do not have the binary rounding behavior that floats have and also have a precision that can be user defined.Decimal should be used anywhere you are doing financial calculations or anywhere you need floating point calculations that behave like the decimal math people learn in school (as opposed to the binary floating point behavior of the built in float type).


Answer URL
https://docs.python.org/3/library/functions.html#round
https://docs.python.org/3/tutorial/floatingpoint.html#tut-fp-issues
