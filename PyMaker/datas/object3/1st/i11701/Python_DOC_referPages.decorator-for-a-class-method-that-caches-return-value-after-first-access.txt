Natural Text
My problem, and whyI'm trying to write a decorator for a class method, @cachedproperty. I want it to behave so that when the method is first called, the method is replaced with its return value. I also want it to behave like @property so that it doesn't need to be explicitly called. Basically, it should be indistinguishable from @property except that it's faster, because it only calculates the value once and then stores it. My idea is that this would not slow down instantiation like defining it in __init__ would. That's why I want to do this.What I triedFirst, I tried to override the fget method of the property, but it's read-only.Next, I figured I'd try to implement a decorator that does needs to be called the first time but then caches the values. This isn't my final goal of a property-type decorator that never needs to be called, but I thought this would be a simpler problem to tackle first.Â In other words, this is a not-working solution to a slightly simpler problem.I tried:However, this doesn't seem work. I tested this with:but I get an error about how the class didn't pass itself to the method:At this point, me and my limited knowledge of deep Python methods are very confused, and I have no idea where my code went wrong or how to fix it. (I've never tried to write a decorator before)The questionHow can I write a decorator that will return the result of calling a class method the first time it's accessed (like @property does), and be replaced with a cached value for all subsequent queries?I hope this question isn't too confusing, I tried to explain it as well as I could.
First of all Test should be instantiatedSecond, there is no need for inspect cause we can get the property name from func.__name__And third, we return property(cache) to make python to do all the magic."""
If you don't mind alternative solutions, I'd recommend lru_cachefor exampleExpected output
I think you're better off with a custom descriptor, since this is exactly the kind of thing descriptors are for. Like so: EDIT: By the way, you don't even actually need a custom descriptor. You could just cache the value inside of your property function. E.g.: That's all there is to it. However, many would consider this a bit of an abuse of property, and to be an unexpected way of using it. And unexpected usually means you should do it another, more explicit way. A custom CachedProperty descriptor is very explicit, so for that reason I would prefer it to the property approach, though it requires more code. 
You can use something like this:When adding to the cache dictionary it generates keys based on the convention  class_id_function in case you are caching entities and the property could possibly return a different value for each one.It also checks a settings key CACHING_ENABLED in case you want to turn it off temporarily when doing benchmarks.But it does not encapsulate the standard property decorator so you should still call it like a function, or you can use it like this (why restrict it to properties only):Also it may be worth noting that in case you are caching a result from lazy foreign key relationships, there are times depending on your data where it would be faster to simply run an aggregate function when doing your select query and fetching everything at once, than visiting the cache for every record in your result-set. So use some tool like django-debug-toolbar for your framework to compare what performs best in your scenario.
Django's version of this decorator does exactly what you describe and is simple, so besides my comment I'll just copy it here:(source).As you can see, it uses func.name to determine the name of the function (no need to fiddle with inspect.stack) and it replaces the method with its result by mutating instance.__dict__. So subsequent "calls" are just an attribute lookup and there is no need for any caches, et cetera.


Answer URL
https://docs.python.org/3/library/functools.html#functools.lru_cache
