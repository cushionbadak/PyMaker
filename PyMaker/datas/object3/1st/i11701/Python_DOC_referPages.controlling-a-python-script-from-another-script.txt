Natural Text
I am trying to learn how to write a script control.py, that runs another script test.py in a loop for a certain number of times, in each run, reads its output and halts it if some predefined output is printed (e.g. the text 'stop now'), and the loop continues its iteration (once test.py has finished, either on its own, or by force). So something along the lines:The problem with the above is that, it does not check the output of test.py as it is running, instead it waits until test.py process is finished on its own, right?Basically trying to learn how I can use a python script to control another one, as it is running. (e.g. having access to what it prints and so on).Finally, is it possible to run test.py in a new terminal (i.e. not in control.py's terminal) and still achieve the above goals?An attempt:test.py is this:And control.py is this: (following Marc's suggestion)
What you are hinting at in your comment to Marc Cabos' answer is ThreadingThere are several ways Python can use the functionality of other files. If the content of test.py can be encapsulated in a function or class, then you can import the relevant parts into your program, giving you greater access to the runnings of that code.As described in other answers you can use the stdout of a script, running it in a subprocess. This could give you separate terminal outputs as you require.However if you want to run the test.py concurrently and access variables as they are changed then you need to consider threading. 
You can use subprocess module or also the os.popen Open a pipe to or from command. The return value is an open file object connected to the pipe, which can be read or written depending on whether mode is 'r' (default) or 'w'.With subprocess I would suggest or the subprocess.Popen --> that is similar to os.popen (for instance)With popen you can read the connected object/file and check whether "Stop now" is there.The os.system is not deprecated and you can use as well (but you won't get a object from that), you can just check if return at the end of execution.From subprocess.call you can run it in a new terminal or if you want to call multiple times ONLY the test.py --> than you can put your script in a def main() and run the main as much as you want till the "Stop now" is generated.Hope this solve your query :-) otherwise comment again.Looking at what you wrote above you can also redirect the output to a file directly from the OS call --> os.system(test.py *args >> /tmp/mickey.txt) then you can check at each round the file. As said the popen is an object file that you can access.
Yes you can use Python to control another program using stdin/stdout, but when using another process output often there is a problem of buffering, in other words the other process doesn't really output anything until it's done.There are even cases in which the output is buffered or not depending on if the program is started from a terminal or not.If you are the author of both programs then probably is better using another interprocess channel where the flushing is explicitly controlled by the code, like sockets.
You can use the "subprocess" library for that.


Answer URL
https://docs.python.org/3/library/threading.html
