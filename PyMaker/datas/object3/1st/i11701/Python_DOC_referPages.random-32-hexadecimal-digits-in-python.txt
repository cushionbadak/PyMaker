Natural Text
I am trying to find a great way to produce a 32 digit hex sequence that is random and gets its randomness from a Big Number like 10*78.For Python code I also found this:This produces a 64 digit hex string, BUT sometimes the result is 63 or even 61 characters and I'm not sure why? I need it to return 64 exactly each time.I need helping tweaking the above code so that it ALWAYS returns 64 only. I do not know enough about the how the "%030x" part works. I've also tried producing a longer hex string and shortening it with:But I was still seeing strings that were less than 64 being returned.In the end I just need exactly 64 hexadecimal string derived from a Big Number like 10*78, returned each time.Solution I went withSeems @ScottMillers answer below was the key I needed to find the answer so I'm selecting his answer as the solution, but wanted to post my final code that worked for me here.Thanks everyone
"%030x" says to display the associated value with at least 30 digits, padding with 0's in front as necessary.  Since your numbers are almost always bigger than that, this isn't doing much for you.It sounds like you need "%064x".
The UUID module can return a 32 hexadecimal digits object:
In modern Python distributions, the new library secrets makes it easy and might be what you need. From the docs:The secrets module is used for generating cryptographically strong random numbers suitable for managing data such as passwords, account authentication, security tokens, and related secrets.In particularly, secrets should be used in preference to the default pseudo-random number generator in the random module, which is designed for modeling and simulation, not security or cryptography.For Python 3.6 and up, try this:https://docs.python.org/3/library/secrets.html#module-secrets
You can use os.urandom instead of hexdump. Python 2.7:Py3.4+:
There's no such things as "hex numbers"; there's only different representation of the same number (10 in decimal is 0xA in hex and is 0b1010 in binary, but it's still the same number).This produces a 64 digit hex string, BUT sometimes the result is 63 or even 61 characters and I'm not sure why? I need it to return 64 exactly each time.so: I ask you to give me a random number above 0 and below 1000; how many digits will that number have?Right. It can have one, two or three digits, with three digits being the most likely case (there's 900 three-digit numbers below 1000, but only 90 two digit numbers and 9 one-digit numbers). Obviously, you just have to pad with 0 in front!In the end I just need exactly 64 hexadecimal string derived from a Big Number like 10*78, returned each time.you need to think about what random means. If you're ok with every single digit being drawn from a uniform distribution in 0..F, then why don't just throw a sixteen-sided die 64 times and concatenate the result? Python makes that extremely easyEDIT:In the comments below, OP says he wants to use that random string to seed a bitcoin private key generation. Never build your own seeder unless you're really an expert in the field. So, although I believe these 1024 bit (really, that's what a 64 digit of Hex number are) of info are random, I will not claim this suffices for crypto purposes. Don't implement crypto yourself, and don't meddle with seed generation lest you know your ways around stochastics, numerics, cryptography and RNG, computer security research and possible attack vectors. Simply don't.
I would try something like this:And if you want it as number, not as string just use eval().


Answer URL
https://docs.python.org/3/library/secrets.html#module-secrets
