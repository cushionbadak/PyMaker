Natural Text
I'm new to coding and trying to do the project euler exercises to improve my knowledge on coding. I have come across several solutions with regards to Project Euler #2. However, I would want to know why my code takes so much longer to compute as compared to a solution I found. I would appreciate if anyone can guide me as to the differences between the two.My code:Online Solution I found:
To calculated fib(10), with your implementation:in which fib(9) is calculated recursively:See the problem? The result of fib(8) has to be calculated twice! To further expand the expression (e.g, to get the result of fib(8)), the redundant calculation is huge when the number is big.Recursion itself isn't the problem, but you have to store the result of smaller fibonacci numbers rather than calculating the same expression on and on. One possible solution is to use a dictionary to store the intermediate result.
You are using recursive calls to a function where the other solution uses a plain iterative loop.Making a function call is bound to some overhead for calling and returning from it. For bigger numbers of n you will have a lot of those function calls.Appending to a list over and over and summing it up is probably also slower than doing this via an accumulator.
Your solution calls a recursive function (with 2 recursions) each time it goes in your while loop. Then in the loop you run that same function again. The other solution only adds numbers and then does a permutation.I guess you didn't really need the fibonacci, but if you insist on using it, run it only once and save the result, instead of re-runing it. Plus you store all your results and sum it at the end. That consumes a bit of time (not only) too, maybe you didn't need to store intermediate results.
As several other answers pointed out, the recursion causes your fib() function to be called very often, 111 561 532 times in fact. This is easily seen by adding a counter:There are two ways to fix this; rewrite your program to be iterative rather than recursive (like the other solution you posted), or cache intermediate results from fib().See, you call fib(8), which in turn has to call fib(7) and fib(6), etc, etc. Just calculating fib(8) takes 67 calls to fib()!But later, when you call fib(9), that also calls fib(8), which has to do all the work over again (67 more calls to fib()). This gets out of hand quickly. It would be better, if fib() could remember that it already calculated fib(8) and remember the result. This is known as caching or memoization.Luckily, Python's standard library has a decorator just for that purpose, functools.lru_cache:On my computer, your program execution goes from 111 561 532 invocations of fib() in 27 seconds to 35 invocations in 0.028 seconds.


Answer URL
https://docs.python.org/3/library/functools.html#functools.lru_cache
