Natural Text
If I have a list that is already sorted and use the in keyword, for example:I think this should do a sequential search but can I make it faster by doing binary search?Is there a pythonic way to search in a sorted list?
There is a binary search for Python in the standard library, in module bisect. It does not support in/contains as is, but you can write a small function to handle it:ThenThis is not going to be very speedy though, as bisect is written in Python, and not in C, so you'd probably find sequential in faster for quite a lot cases. bisect has had an optional C acceleration in CPython  since Python 2.4.It is hard to time the exact break-even point in CPython. This is because the code is written in C; if you check for a value that is greater to or less than any value in the sequence, then the CPU's branch prediction will play tricks on you, and you get:Here, the best of 3 is not representative of the true running time of the algorithm.But tweaking tests, I've reached the conclusion that bisecting might be faster than in for lists having as few as 30 elements.However, if you're doing really many in operations you ought to use a set; you can convert the list once into a set (it does not even be sorted) and the in operation will be asymptotically faster than any binary search ever would be:On the other hand, sorting a list has greater time-complexity than building a set, so most of the time a set would be the way to go.
The standard library has the bisect module which supports searching in sorted sequences.However, for small lists, I would bet that the C implementation behind the in operator would beat out bisect.  You'd have to measure with a bunch of common cases to determine the real break-even point on your target hardware...It's worth noting that if you can get away with an unordered iterable (i.e. a set), then you can do the lookup in O(1) time on average (using the in operator), compared to bisection on a sequence which is O(logN) and the in operator on a sequence which is O(N).  And, with a set you also avoid the cost of sorting it in the first place :-).


Answer URL
https://docs.python.org/3/library/bisect.html
