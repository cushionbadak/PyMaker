Natural Text
I am trying to create a high scores list for a little trivia game for class. I'm having an issue though because I can't seem to get the printed output to not just print the dictionary randomly.  This snippet is not actually from the full program because I didn't want to ruin anything so it's just an attempt at reasoning out the function.My output is random every time though.  I just want the dictionary to print in order of highest to lowest eg:etc etc  The other issue I am having is that I'm not sure how to approach moving the other scores lower in the dictionary.  So if JKE's score replaces the score at blh, blh isn't just removed from the dictionary but it moves down to score4 index and score4 values would move to score5 etc etc.  I appreciate any advice!  Thank you!  
I think you might be trying to make this a bit too complicated (though it sounds like homework so that might be a requirement).I would approach it like so:Then you can easily add players and scores via:
Dictionaries don't maintain any particular order, if you use OrderedDict however it will. Output: 
Dictionary is a non sorted type so it is reasonable that every time to expect that the order would be change every time. I think that you should consider different data type to deal with this problem (this also answers the second part of you question).I think you should consider either ordered dictionary - http://docs.python.org/2/library/collections.htmlor something I think is better for this purpose - http://docs.python.org/2/library/heapq.html 
I would use the list of dictionaries, you could then easily sort the scores, and for example show only best 3.The format for the list could be:[{score:player},...]
You need to keep your scores ordered somehow. The best way is to keep an ordered list. You can use the bisect module to help you do this. bisect.bisect(list, item) returns the index where you should insert item into the list such that the list is still sorted. If we keep the scores as a list of (score, name) tuples, then the default tuple comparison will work - smaller scores will be first, with larger scores last. We can delete all but the last five elements each time to only keep the top 5 scores.To print them we reverse the list:Usage:
Dictionaries are stored in arbitrary order. If you want to sort the output, you have to do that manually. Since you have keys score1, score2, etc. that happen to sort in the right order, you can just do it like this:However, your code doesn't actually seem to maintain that dictionary properly; when you find a user whose score beats score2, you're just going to replace score2 with the new score, rather than pushing it down to score3 and so on.And I'm not sure why you want to store the scores this way in the first place. If you want to maintain an order, why not just use keys 0 through 4 in a list instead of score1 through score5 in a dict? For example:Now, they're always in sorted order:You can make this more efficient by using a heapq. However, this gets a bit complicated, because a heapq keeps it values sorted by comparing the values themselves, but you want it to compare on value['score']. Unlike most sort-related functionality in Python, heapq doesn't have a key function to make this easy. So, you have to do some manual "decorate-sort-undecorate" work:Now, to add a new high score:Another way to simplify this is to use an auto-sorting list, like the SortedCollection recipe referenced in the bisect docs, or a library like blist.sortedlist.
I think there may be better data structures to start with than what you have, I only made one adjustment, make your keys to the dictionary integers, this will solve your printing problem, the function will build a new leader board that will max at 5 entries, and put the new score in where it belongs.  In the event of a tie, the second score of that is submitted will go to the lower of the spots entered. Score has to beat the min score to make the board.


Answer URL
