Natural Text
I am studying python with the book Beginning Python: From Novice to Professional, and I get confused about the section discussing iterators. There is an example in this section:To be honest, I only know that fibs is an object with methods __next__ and __iter__, but have no idea about what happens in each step of the loop. And I made a test:This makes me much more confused! Why the boolean value of f is fibs is False? And why fibs.a become 1597 after the execution of the loop?(Is the method __next__ automatically called in the loop?) Thanks in advance.
Line 1 creates a Fibs() object, calling __init__(). Line 2 calls __iter__(), which returns an iterator object (in this case, just fibs itself). The interpreter will then begin calling the __next__() method repeatedly; it returns self.a, a plain number, which is assigned to the loop variable f (so of course it's not a Fibs() object and certainly not the one named fibs). When that value reaches 1000, the if clause will fire, print the result, and break out of the loop.
And why fibs.a become 1597 after the execution of the loop?Well this is because it is going through the Fibonacci sequence and this is the first number over 1000 in the sequence.0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987,  1597, 2584 ...
On enter to the loop interpreter calls __iter__ method. On every loop step interpreter calls __next__ method of Fibs.
implicitly calls fibs.__iter__ and binds f to all the objects that it yields, in turn. None of these objects are instances of Fibs, let alone equal to fibs. The whole is (roughly) equivalent to(iter and next are the clean ways to call __iter__ and __next__, respectively.)
Yes, the loop automatically calls __next__.The for loop does this to the given object:The iter() function calls given_object.__iter__(), and the next() function calls given_object.__next__(); these functions offer some extra functionality and are the proper way of calling into the iterator API.So, in each loop iteration, f is assigned the value that the Fib.__next__ method returned.You can also see that Fib is its own iterator; __iter__ returns self. Other types can return a dedicated iterator object; lists do, for example:Returning dedicated iterators lets you create multiple 'views' on an object where each iterator maintains its own position, like nested loops:or you can explicitly reuse the iterator:


Answer URL
