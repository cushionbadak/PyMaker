Natural Text
I use Python's lru_cache on a function which returns a mutable object, like so:If I call this function, mutate the result and call it again, I do not obtain a "fresh", unmutated object:I get why this happens, but it's not what I want. A fix would be to leave the caller in charge of using list.copy:However I would like to fix this inside f. A pretty solution would be something likethough no copy argument is actually taken by functools.lru_cache.Any suggestion as to how to best implement this behavior?EditBased on the answer from holdenweb, this is my final implementation. It behaves exactly like the builtin functools.lru_cache by default, and extends it with the copying behavior when copy=True is supplied.
Since the lru_cache decorator has unsuitable behaviour for you, the best you can do is to build your own decorator that returns a copy of what it gets from lru_cache. This will mean that the first call with a particular set of arguments will create two copies of the object, since now the cache will only be holding prototype objects.This question is made more difficult because lru_cache can take arguments (mazsize and typed), so a call to lru_cache returns a decorator. Remembering that a decorator takes a function as its argument and (usually) returns a function, you will have to replace lru_cache with a function that takes two arguments and returns a function that takes a function as an argument and returns a (wrapped) function which is not an easy structure to wrap your head around.You would then write your functions using the copying_lru_cache decorator instead of the standard one, which is now applied "manually" inside the updated decorator.Depending on how heavy the mutations are, you might get away without using deepcopy, but you don't give enough information to determine that.So your code would then readThis printsso the cacheing behaviour your require appears to be present. Note also tht the documentation for lru_cache specifically warns thatIn general, the LRU cache should only be used when you want to reuse previously computed values. Accordingly, it doesnâ€™t make sense to cache functions with side-effects, functions that need to create distinct mutable objects on each call, or impure functions such as time() or random().


Answer URL
https://docs.python.org/3/library/functools.html#functools.lru_cache
