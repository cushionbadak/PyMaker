Natural Text
Assuming that I have an expression similar to the one below (in reality this is an SQL statement):I want to parse it in order to process strings and maintain parentheses' precedence. To do so, I've used the following recursive functionthat gives the following output: The expected output however, would either be or Any thoughts how to achieve this?
You want to tokenize your input. The simplest tokenizer needed to parse your balanced expressions could be a simple regular expression here, splitting on ( and ), ignoring whitespace:and use tokenize()) instead of iter():The filter(None, ...) call filters out the empty strings that re.split() produces at points where the input starts or ends with a ( or ), or if two ( or ) characters directly follow one another.Demo:To split out operators too, you can either add valid operators to the splitting expression, or just add whitespace as a delimiter.Splitting on whitespace, where we don't include the spaces in the tokens:produces:while focusing on valid operators would be:and for your sample input that produces the same result.Note that your code has a bug; it won't detect an unbalanced closing parenthesis:You need to validate that the first _helper() call returns False for the second element in the returned tuple. Instead of return _helper(tokenize(expr))[0], use:Finally, I'd not use recursion here, and instead use an explicit stack to replace the call stack on which recursion builds. Your own stack is only limited by memory, where a recursion stack is limited to a fixed size (1000 by default):You might be interested in looking at the tokenize module, which implements a tokenizer for Python code; the source code uses a series of regular expressions to split out Python source code into tokens (where a token not only contains the token text, but also a token type, the start and end positions (a column, line tuple) and the full line it came from).


Answer URL
https://docs.python.org/3/library/tokenize.html
https://docs.python.org/3/library/token.html
