Natural Text
I'm learning how to use Enum classes in Python, and have found that whenever I need to access the actual value of the enum, I need to append the .value property:As an exercise, I'm trying configure my Enum class so that I do not need to continually access that value property. My desired behavior is that when I call Pets.DOG, I get Fido as my value.I'm tried to implement this with __getattr_(cls, item):However, I receive a RecursionError: maximum recursion depth exceeded while calling a Python object, and item is a string value of _value_. I'm not quite understanding why this behavior is happening - is this built in Python behavior, or because I am using a special class Enum?I did take a look at a similar SO post, but the solutions there were to use another module (inspect), or access the __dict__ or dir() and parse it yourself with a combination of conditionals or regex. Is there a better way to access the underlying Enum's value?
Don't use the enum class if you want to map attributes to strings. The whole point of the enum module is to produce a set of singleton objects that represent an enumeration, not strings. From the module documentation:An enumeration is a set of symbolic names (members) bound to unique, constant values. Within an enumeration, the members can be compared by identity, and the enumeration itself can be iterated over.)Bold emphasis mine. Strings are not unique, constant values (I can create more "Fido" strings at will) and are not designed to be compared by identity (even though sometimes, for a subset of strings, you can).Just define your own class with attributes that are strings, directly:Your infinite recursion error is caused by a misunderstanding on your part as to what that method is used for. Like all special methods, object.attr looks up __getattr__ on the object type, meaning here that your method applies to instances of your Enum subclass, the DOG and CAT attributes here, not to the class itself, and interferes with the EnumMeta metaclass trying to test for the _value_ attibute, which is handled by your __getattr__ method with self being the newly-minted Pets.DOG instance, and item set to '_value_', which then calls getattr(Pets.DOG, '_value_'), which calls __getattr__, etc.For your approach to work, you'd have to subclass EnumMeta and implement __getattribute__ on that subclass (__getattr__ is only ever called for missing attributes). However, take into account that __getattribute__ is used for all attribute access, so you have to take care to check for instances of the current class first:at which point Pets.DOG produces 'Fido'.


Answer URL
https://docs.python.org/3/reference/datamodel.html#special-method-lookup
https://docs.python.org/3/reference/datamodel.html#object.__getattribute__
