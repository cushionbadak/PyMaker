Natural Text
This is the code I have so far, my teacher wants the game to "flip the X's over" when you guess a number and when they match the numbers stay but when the numbers are different the numbers "flip back over" and become X's again. And he wants the game to say that "you win" when all the numbers have been exposed.
Here are the discrete steps in the game as I understand it:Initialize the board and data.Shuffle the dataEnter LoopPrint the boardAsk user for their first guessAsk user for their second guessPrint the board with revealsCover them back up if user missedCheck win condition (everything revealed?)Loop back or print winYour code successfully initializes the board (step 1), shuffles the data (2), enter loop (3), prints board (4), and asks for the guesses (5)(6).Here is some guidance on the pieces you are missing:After you get the inputs, you always want to print the board with the reveals (7). To do this you need to update visuals first with the piece you have written: and then print your visuals. This does not need to happen with an if statement, because you always want to do a print of the revealed board.Afterwards, you want to do the swap back to X's if the user misses (8). You have this condition already basically written. You need to check if it's a miss in the data board and swap those visuals back to X's if true:Side Note: Ideally, you want to clear the previous board print of the reveals to test memory. This part is kind of tricky. There are no simple ways to clear the print of the reveals without using operating system commands which are almost certainly beyond the scope of your class. I would check with your teacher about expectations around flipping back over. If you are interested in how this is achievable using operating system command in Python here is a relevant StackOverflow post. You would need to import os and import time. After you print reveal, use time.sleep(number_of_seconds) to give the user however many seconds to try to memorize placements and then use os.system('clear') for linux/mac os or os.system('CLS') for windows to clear the screen. Again, it's very unlikely that this is what your teacher is looking for.Now let's deal with the win condition (9). Currently you are using a "while True:" with a break. While this may be functional in this case, using "while True:" should be almost always avoided (there are many reasons why-- here is a post that addresses one reason). Loop structures like "while", "do-while", and "for" have built-in stopping conditions which will be checked each time you loop. In this program, your stopping condition is that the board is completely revealed (that is how you know the game is over and user no longer needs to guess). So, until this happens you want your while loop to keep going. This looks like this:There are multiple ways to check your win condition is not yet met. One option is that you know you have not won yet if the visual board is still not the same as data board:In summary, TLDR:There are a handful of smaller points that could improve your code as well if you're interested: be very vigilant about indents, a do-while loops is more appropriate here (can you think of why?), you can write functions and loops that reduce a lot of the repeating code (like when you print the visuals). But this should be enough for you to grapple with.
Some suggestions for your code:Since you display the board so often, you may want to write a separate function that takes the variable visual as input and prints the content.  Then you can just call the function instead of writing all of those print statements.In your current code, you only display the cards when there's a match.  One of the whole strategies for playing a memory game is that if you overturn two cards and see "5" and "2" for example, it's not a match, but if you overturn a new pair of cards and one of them is another "5", you might remember where that first "5" was you overturned in your previous turn and thus know how to make a match.  So perhaps you should do this: update and display visual after selecting the first card, then do the same with the second card.  If there's a match, then leave visual as is.  If they don't match, then replace the two spots back with 'X' and go back to the top of the loop. Your code seems to consider a single match a "win".  Shouldn't it be considered won once all of the cards have been matched?  In this case, you can follow up the previous step by checking to see if 'X' shows up anywhere in visual.  If it doesn't, then that means all of the cards have been uncovered, thus the player has won.


Answer URL
https://docs.python.org/3/library/time.html#time.sleep
