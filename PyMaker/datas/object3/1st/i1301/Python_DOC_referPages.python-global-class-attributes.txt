Natural Text
I want to create a baseclass that has an attribute which should not change. Any derived class from this baseclass should have this attribute aswell. My idea was:My thinking was, if I know look at child.__dict__:it should return "special attribute ... baseclass" but instead I get a KeyError: while when calling baseclass.__dict__['flag']everything is fine. Is there a way to set flags for all derived class that inherit from baseclass?
First of all, I think it would be nice if you could review the concepts related to a Class definition so you can understand the difference between a class instance and a class object.Overall, the __dict__ that you're trying to access implements the object namespace. It was not suppose to be accessed directly as you're trying to do. But for the sake of understanding I'll use it to illustrate the class instance vs class object difference.Calling __dict__ as you were will get you the dict containing the attributes of your child class object (the default ones and the ones you defined in your Class definition):>>> child.dictdict_proxy({'module': 'main', 'doc': None, 'init': })However, when you decided to put flag in your baseclass like you did, you were defining it as a part of your baseclass class object. It is not declared each time for instance, it was declared once you imported your class definition. Therefore, you can see flag if you do:>>> baseclass.dictdict_proxy({'module': 'main', 'flag': 'some attr for all classes', 'dict': , 'weakref': , 'doc': None, 'init': })Finally, if you access an object instance __dict__ you'll see the attributes you declared with self (including baseattr that was declared when you called super):>>> child('some base attr', 'some child attr').dict{'childattr': 'some child attr', 'baseattr': 'some base attr'}That being said, you already have to access to flag from any object instance. Being more specific, you have access to every attribute defined in the class definition, the inherit class definition and in your instance. So I really recommend you stop using __dict__ and access things the way they were intended to:>>> your_obj_instance = child('some base attr', 'some child attr')>>> your_obj_instance.childattr'some child attr'>>> your_obj_instance.baseattr'some base attr'>>> your_obj_instance.flag'some attr for all classes'


Answer URL
https://docs.python.org/3/reference/compound_stmts.html#class-definitions
https://docs.python.org/3/reference/datamodel.html
