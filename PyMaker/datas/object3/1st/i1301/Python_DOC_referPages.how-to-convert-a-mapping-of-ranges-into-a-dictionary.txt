Natural Text
How can this be converted into a dictionary?I know how to make basic dictionaries, however, I am not sure whether it would look something like this:Thanks!
The short answer is that you should not convert this to a dictionary. This is best suited as a function, and it appears you are just missing your function definition, as I see you are using return in your code. Dictionaries are constructed from key-value pairs, and since your conditions involve >= evaluations, a dictionary is not appropriate. See the function implementation below:Returns:
Without a dict, you could solve the problem like this: This is preferable over a dictionary because builtin dictionaries make a guarantee of orderedness (i.e., that they will iterate in the order that keys/values were inserted) only for >= Python 3.6. Being able to run code over more Python versions is preferable to depending on a specific version detail.
You can use a dictionary for holding the grading information, but it does not really provide any benefit as you can not use the fast dictionary lookup with those ranges. Instead, I'd suggest using a sorted list of (points, grade) pairs and then using bisect to binary-search the matching score in O(logn).Unzipping the grade_ranges to points and scores is optional here, but IMHO it's a bit cleaner that way. If you don't unzip, you will have to pass a tuple to bisect, e.g. bisect(grade_ranges, (55,))
Dicts are especially useful if you want to store key-value pairs and want to be able to retrieve an arbitrary entry really fast. As the other answers show, you only need to go through the sequence of elements and use the value of the first one that matches. So the most straight forward (and probably most efficient) strategy is to use a sequence data type. Here's how that looks like in code:Dicts are great, but if you don't need their powers, use something simpler.
Another option is to use range-key-dict:You can install this Python package with pip install range-key-dict. You would also need to examine the source code for the complexity, since this won't maintain O(1) hashing like regular dictionaries. It might be easier and efficient to just use regular if statements. 
If you can use a 3rd party library, you can use Pandas via pd.cut. This will be especially efficient if you have a large number of input grades to categorise.See related: How to map numeric data into categories / bins in Pandas dataframe
This would be one way, if you really need to use a dictionary; taking dictionary keys as the condition checking values and dictionary values as the values to be returned.Check:
If you are using Python before 3.6, you can use collections.OrderedDict (including Python 2.7), otherwise dict objects are natively insertion-sorted (see here for more)!With that, you can simply iterate over your dict and return the first range match.Note if you expect your table to change, it probably makes sense to test if your dict is in descending order or always accept an iterable of iterables and then sort 'em (I use a tuple of tuples above, but anything of the same form should work and be easy to sort) Otherwise it will return incorrect results.
It's not possible to convert this logic into a dictionary. Dictionaries are key value pairs, so there's no way you can do the "greater than" check just by way of a lookup.
I'm not a maths person but thought that interpolation might, maybe, work for this? You'd need to pad-up to 100 and pad-down because it is interpolation so your data points of interest need to be within sample'able scope.


Answer URL
https://docs.python.org/3/library/bisect.html
