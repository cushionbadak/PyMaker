Natural Text
How to perform a (LEFT|RIGHT|FULL) (INNER|OUTER) join with pandas?How do I add NaNs for missing rows after merge?How do I get rid of NaNs after merging?Can I merge on the index?Cross join with pandas?How do I merge multiple DataFrames?   merge? join? concat? update? Who? What? Why?!... and more. I've seen these recurring questions asking about various facets of the pandas merge functionality. Most of the information regarding merge and its various use cases today is fragmented across dozens of badly worded, unsearchable posts. The aim here is to collate some of the more important points for posterity.This QnA is meant to be the next instalment in a series of helpful  user-guides on common pandas idioms (see this post on pivoting, and this post on concatenation, which I will be touching on, later). Please note that this post is not meant to be a replacement for the documentation, so please read that as well! Some of the examples are taken from there. 
This post aims to give readers a primer on SQL-flavoured merging with pandas, how to use it, and when not to use it.In particular, here's what this post will go through:The basics - types of joins (LEFT, RIGHT, OUTER, INNER)merging with different column namesavoiding duplicate merge key column in output   Merging with index under different conditions effectively using your named indexmerge key as the index of one and column of anotherMultiway merges on columns and indexes (unique and non-unique)Notable alternatives to merge and joinWhat this post will not go through:Performance-related discussions and timings (for now). Mostly notable mentions of better alternatives, wherever appropriate.Handling suffixes, removing extra columns, renaming outputs, and other specific use cases. There are other (read: better) posts that deal with that, so figure it out!Note  Most examples default to INNER JOIN operations while demonstrating various features, unless otherwise specified. Furthermore, all the DataFrames here can be copied and replicated so  you can play with them. Also, see this  post  on how to read DataFrames from your clipboard.Lastly, all visual representation of JOIN operations are borrowed with  thanks from the article  https://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins.Enough Talk, just show me how to use merge!Setup For the sake of simplicity, the key column has the same name (for now).An INNER JOIN is represented by                                              NoteA here refers to the keys from the join column in the left DataFrame, B  refers to keys from the join column in the right DataFrame, and the intersection  represents keys common to both left and right.  The shaded region represents the keys that are present in the JOIN result. This convention will be followed throughout. Keep in mind that Venn diagrams are not a 100% accurate representation of JOIN operations, so take them with a pinch of salt. To perform an INNER JOIN, call pd.merge specifying the left DataFrame, the right DataFrame, and the join key. This returns only rows from left and right which share a common key (in this example, "B" and "D). In more recent versions of pandas (v0.21 or so), merge is now a first order function, so you can call DataFrame.merge. A LEFT OUTER JOIN, or LEFT JOIN  is represented by                                              This can be performed by specifying how='left'. Carefully note the placement of NaNs here. If you specify how='left', then only keys from left are used, and missing data from right is replaced by NaN.And similarly, for a RIGHT OUTER JOIN, or RIGHT JOIN which is...                                             ...specify how='right':Here, keys from right are used, and missing data from left is replaced by NaN.Finally, for the FULL OUTER JOIN, given by                                             specify how='outer'.This uses the keys from both frames, and NaNs are inserted for missing rows in both.  The documentation summarises these various merges nicely:Other JOINs - LEFT-Excluding, RIGHT-Excluding, and FULL-Excluding/ANTI JOINsIf you need LEFT-Excluding JOINs and RIGHT-Excluding JOINs in two steps.For LEFT-Excluding JOIN, represented as                                             Start by performing a LEFT OUTER JOIN and then filtering (excluding!) rows coming from left only,Where,And similarly, for a RIGHT-Excluding JOIN,                                              Lastly, if you are required to do a merge that only retains keys from the left or right, but not both (IOW, performing an ANTI-JOIN),                                              You can do this in similar fashion—Different names for key columnsIf the key columns are named differently—for example, left has keyLeft, and right has keyRight instead of key—then you will have to specify left_on and right_on as arguments instead of on:Avoiding duplicate key column in outputWhen merging on keyLeft from left and keyRight from right, if you only want either of the keyLeft or keyRight (but not both) in the output, you can start by setting the index as a preliminary step.Contrast this with the output of the command just before (thst is, the output of left2.merge(right2, left_on='keyLeft', right_on='keyRight', how='inner')), you'll notice keyLeft is missing. You can figure out what column to keep based on which frame's index is set as the key. This may matter when, say, performing some OUTER JOIN operation. Merging only a single column from one of the DataFramesFor example, considerIf you are required to merge only "new_val" (without any of the other columns), you can usually just subset columns before merging:If you're doing a LEFT OUTER JOIN, a more performant solution would involve map:As mentioned, this is similar to, but faster thanMerging on multiple columnsTo join on more than one column, specify a list for on (or left_on and right_on, as appropriate).Or, in the event the names are different,Other useful merge* operations and functionsMerging a DataFrame with Series on index: See this answer.Besides merge, DataFrame.update and DataFrame.combine_first are also used in certain cases to update one DataFrame with another.pd.merge_ordered is a useful function for ordered JOINs.pd.merge_asof (read: merge_asOf) is useful for approximate joins.This section only covers the very basics, and is designed to only whet your appetite. For more examples and cases, see the documentation on merge, join, and concat as well as the links to the function specs.Index-based *-JOIN (+ index-column merges)SetupTypically, a merge on index would look like this:Support for index namesIf your index is named, then v0.23 users can also specify the level name to on (or left_on and right_on as necessary).Merging on index of one, column(s) of anotherIt is possible (and quite simple) to use the index of one, and the column of another, to perform a merge. For example,Or vice versa (right_on=... and left_index=True). In this special case, the index for left is named, so you can also use the index name with left_on, like this:DataFrame.joinBesides these, there is another succinct option. You can use DataFrame.join which defaults to joins on the index. DataFrame.join does a LEFT OUTER JOIN by default, so how='inner' is necessary here.Note that I needed to specify the lsuffix and rsuffix arguments since join would otherwise error out:Since the column names are the same. This would not be a problem if they were differently named.pd.concatLastly, as an alternative for index-based joins, you can use pd.concat:Omit join='inner' if you need a FULL OUTER JOIN (the default):For more information, see this canonical post on pd.concat by @piRSquared.Generalizing: mergeing multiple DataFramesSetupOftentimes, the situation arises when multiple DataFrames are to be merged together. Naively, this can be done by chaining merge calls:However, this quickly gets out of hand for many DataFrames. Furthermore, it may be necessary to generalise for an unknown number of DataFrames. To do this, one often used simple trick is with functools.reduce, and you can use it to achieve a INNER JOIN like so:Note that every column besides the "key" column should be differently named for this to work out-of-box. Otherwise, you may need to use a lambda.For a FULL OUTER JOIN, you can curry pd.merge using functools.partial:As you may have noticed, this is quite powerful—you can also use it to control column names during merge. Simply add more keyword arguments as needed:The alternative: pd.concatIf your column values are unique, then it makes sense to use pd.concat, this is faster than a two-at-a-time multi-way merge. Multiway merge on unique indexesIf you are merging multiple DataFrames on unique indexes, you should once again prefer pd.concat for better performance.As always, omit join='inner' for a FULL OUTER JOIN.Multiway merge on indexes with duplicatesconcat is fast, but has its shortcomings. It cannot handle duplicates.In this situation, join is the best option, since it can handle non-unique indexes (join calls merge under the hood).


Answer URL
https://docs.python.org/3/library/functools.html#functools.reduce
https://docs.python.org/3/library/functools.html#functools.partial
