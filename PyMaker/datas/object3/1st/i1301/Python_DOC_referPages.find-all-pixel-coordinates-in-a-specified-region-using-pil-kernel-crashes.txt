Natural Text
I have some code find to all the pixels within a region of an image. This region is bounded by two straight lines sharing the same origin and extended until the edge of the image (a wedge shape). I supply the function with a starting point inside this region as a parameter and use recursion to get all the pixels inside it. The problem is that it only works for very small "wedges".I have tried increasing the recursion limit, though depth isn't necessarily the problem. If increased, the kernel just crashes. I tried increasing the stack size, but it made no difference at all. The code actually runs pretty fast, but increasing the size of the region just slightly causes this problem. Ultimately, I would need to use this on large images (.tif).sample small wedge on a 946x710 image
I think you actually want to run a "Connected Component Analysis", or a "labelling" which assigns a unique number (label) to each "blob" of connected (touching) pixels.You can do that with OpenCV's findContours() which is documented here, or you can use scipy's label() which seems like fun to try out.I wanted to be sure my method works with more than one "blob" so I added two more lines of the same colour as your wedge:The code is pretty self-explanatory, but I wanted to draw your attention to a couple of things.The mask image I make is black everywhere except where the image is the same colour as the seed pixel and it is white in those places:The default SE (Structuring Element) to describe which pixels are considered connected to the central pixel is:which is called 4-connected, because the central pixel is connected to the 4 pixels North, East, South and West of it. As your wedge is not rectangular, we need to also consider pixels diagonally touching as neighbours. That means 8-connected and looks like this:Here is the code:Here is the output:You can do this possibly more simply just at the command line with ImageMagick which is installed on most Linux distros and is available for macOS and Windows.Firstly, make everything that is not the same colour red as your wedge into black pixels:Now that you have seen how that works, do the same thing again but this time continue and run a "Connected Component Analysis" as well:Sample OutputThat means 3 red areas were found, namely the last three lines where srgb(255,51,51) and the last one is an area 33x34 pixels located 473,0 pixels across from the top-left corner and it has an area of 530 pixels just the same as we found with Python.
With only that one image, it's hard to tell if this will be fully generalizable for your purposes, but it does work in this case.  IT will need some tweaking if the wedge isn't always on the top edge or if the image content isn't so easily filtered out.  You seem to have a pretty good handle on locating the wedge amongst the image noise though so that part probably doesn't matter to you.  I'll include it just in case, but the important part for you is probably at the bottom of the code block.  The rest is just how I isolated the wedge  You should be able to label the objects in the image, and then use the lines as the bounding point for the pixels.The pixels you want are contained within those slices, no recursion needed...I think.


Answer URL
https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset
