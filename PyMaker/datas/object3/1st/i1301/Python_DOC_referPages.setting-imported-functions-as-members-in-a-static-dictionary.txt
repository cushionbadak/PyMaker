Natural Text
There is a simple class where I want to store some functions statically in a dictionary using different ways:Some example methods:And a little test:All this works provided all these elements are in the same file. As soon as the functionality is split up in 2 files and a main file:Only the first two keep working (setting the function directly), the others - using a function to do the same thing - give a NameError on all the eval calls. For instance: NameError: name 'user_func5' is not defined.What is the logic here for the loss of scope when using the methods versus directly setting the functions? And can I get it to work using imports from other packages so I can place any function in the class with a method rather than directly?
There's a live version of fix #1 from this answer online that you can try out for yourselfThe problemYou're right that the reason this doesn't work is due to scoping issues. You can figure out what's going on by scrutinizing the docs for eval:eval(expression, globals=None, locals=None)...If both dictionaries [ie globals and locals] are omitted, the expression is executed in the environment where eval() is called.Thus, it is reasonable to assume that the issue you're having is down to the contents of globals and locals in the context (ie within the definition (and possibly separate module) of ClassTest) in which eval is getting called. Since the context in which eval is getting called is not, in general, the context in which you have defined and/or imported user_func, user_func2...., these functions are undefined as far as eval is concerned. This line of thinking is backed up by the docs for globals:globals()...This is always the dictionary of the current module (inside a function or method, this is the module where it is defined, not the module from which it is called).The fixYou have a few different options for how you can go about fixing this code. All of them are going to involve passing locals from the context in which you call, eg, ClassTest.registerClassFunc to the context in which that method is defined. Additionally, you should take the opportunity to factor out the use of eval from your code (its use is considered bad practice, it's a massive security hole, yadda yadda yadda). Given that locals is the dict of a scope in which user_func is defined, you can always just do:instead of: fix #1Link to live version of this fixThis'll be the easiest fix to implement, since it only requires a few tweaks to the definitions of the methods of ClassTest (and no changes to any method signatures). It relies on the fact that it is possible to use the inspect package within a function to directly grab the locals of the calling context:If you use the above given definition of ClassTest, the import test you cooked up will now function as expected.ProsProvides exactly the originally intended functionality.Involves no changes to function signatures.ConsCalling inspect.currentframe() can cause a dip in performance, so you may not be able to use this fix if you're planning on calling the methods of ClassTest a million times a second.inspect.currentframe() is only guaranteed to work on CPython. Mileage may vary when running this code with other implementations of Python.fix #2Fix #2 is basically the same as fix #1, except that in this version you explicitly pass locals into the methods of ClassTest at the point of call. For example, under this fix the definition of ClassTest.registerClassFunc would be:and you would call it in your code like this:ProsDoesn't rely on inspect.currentframe(), and so is probably more performant/portable than fix #1.ConsYou have to modify method signatures, so you'll also have to change any existing code that uses those methods.You'll have to add the locals() boilerplate to every invocation of every ClassTest method from here on.


Answer URL
https://docs.python.org/3/library/functions.html#eval
https://docs.python.org/3/library/functions.html#globals
