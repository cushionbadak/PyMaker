Natural Text
I am trying to iterate a number of times over an iterable.  Howver, the issue is that once the iterable is consumed  it no longer can yield. Which means, after my first iteration I no longer can use the iterable.In my case, I have an excel file of 10 000 lines, I am creating a textfilereader to avoid importing all my data into memory. I am fixing a number of iterations which will be used to execute the same opeartions over the lines of the excel file. Because of the fading nature of the iterable, I can't use the operations after the second iteration. So, I tried to create a global iteraton loop where I define the iterable each time: Is there a better way to get around this issueThe main reason of using an iterable in my case is to avoid loading data in memory .Code causing issueMy solution
You could use tee, from the documentation:Return n independent iterators from a single iterable.ExampleOutput
I had an issue very similar to yours. I needed to iterate over a database table many times without keeping it in memory. The above solution didnt satisfy my problem as my code required passing the iterator many times and to many functions at different levels. I came up with a solution that I believe it to be more elegant and general than tee and wanted to share it here.This "looper" class will allow you to iterate over any iterator multiple times simply by regenerating the iterator once the internal iterator has raised StopIteration. The outer looper class does raise the StopIteration exception before regenerating. Meaning it will have similar iterator behavior to a list or tuple when n=None.Example using range:Output:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.tee
