Natural Text
I always thought that if I use a for loop like this:I will never make my list index out of range. However, I am wrong..The purpose of my code is to output all subsets of the input set.Example:Input:Output:Here is the code:So my core concept is use a binary list to create the subset list.For example, when I read 001 in Binary list. I will keep 3 due to the third bit being 1remove 1, 2 due to the first and second bits being 0.So if I use 0-7 (Binary == 000-111) I can get all subset of [1,2,3].  But I always get IndexError: list index out of range. No matter if I use or
The cause of your IndexError is that you got your indices mixed up. In your nested for loops in the subsets function i ranges over the number of subsets and j ranges over the number of elements in the nums set. But you attempt to access nums[i] when you should be doing nums[j], so when i is greater than or equal to len(nums) you will be attempting to access beyond the end of the nums list, hence the IndexError. Your code can be simplified a fair bit. There's no need to muck around with the bin function: you can tell format to format an integer in binary, with the desired length.outputI admit that '{0:0{1}b}'.format(i, bit_len) is a bit cryptic, so I'll try to explain it as simply as I can, freely quoting from the official Python 3 documentation for the Format String Syntax.The expression '{0:0{1}b}'.format(i, bit_len) creates a string containing the binary representation of i. The created string is bit_len characters wide, padded on the left with zeroes, if necessary.The '{0:0{1}b}' part is known as a format string. Format strings contain “replacement fields” surrounded by curly braces {}. This is a complicated example because it has a replacement field nested inside another replacement field.   In a replacement field the item immediately following the { is called the field_name. It's used to specify which argument to .format is associated with this replacement field. The field_name can be the argument's name, its position, or it can be omitted (in Python 2.7 and later) and Python will just use the .format arguments in numerical order when its matching them up with replacement fields.The field_name is optionally followed by a conversion field, which is preceded by an exclamation point !, and a format_spec (format specification), which is preceded by a colon :. These specify a non-default format for the replacement value. This particular format string doesn't have a conversion field, so the default conversion is used. A format_spec ends in a letter which specifies the type of formatting we want. Our format_spec end in a b which says that we want to format an integer as binary. The number immediately preceding the b specifies how wide the resulting bit string should be; by putting a zero in front of that we're saying that we want the string to be padded with zeroes rather than with blank spaces. So a format_spec of 08b would give us bit strings that are 8 chars wide (or wider if necessary to properly represent the argument), with short bit strings padded with zeroes. But we need something fancier than that because we don't have a fixed bit string width - we want our bit strings to be bit_len characters wide. But that's ok, because the format syntax allows us to put a replacement field inside another replacement field! So instead of 08b we have 0{1}b and now the value of the argument in position 1 is used as the bit string width.I mentioned earlier that the field_name can be the argument's name, so our original format expression can also be written as:I guess this form is a bit more readable than the original. :)I also mentioned that the field_name can be omitted (in Python 2.7 and later), which would look like this:but I don't recommend doing that because although it's shorter it's even more cryptic than the original, IMHO.However, we don't really need the bit strings in bin_list: we can just use bitwise operators on the subset's index.outputThis does produce the subsets in a different order, but it's not too hard to change that, and I think this order is more natural.We can make the last version even more compact by using a nested list comprehension:FWIW, here's another way to make subsets. It's a bit inefficient, but it's ok for small input sequences. It generates the subsets in the same order as the previous version.
You are getting an error because of the following:len(nums) == 3size_subset == 2**3 == 8nums[3] is being accessed in the loop where i goes from 0 to len[list_Bin].The solution is probably to access nums[j] instead of nums[i] since j goes from 0 to len(nums).


Answer URL
https://docs.python.org/3/library/string.html#format-string-syntax
