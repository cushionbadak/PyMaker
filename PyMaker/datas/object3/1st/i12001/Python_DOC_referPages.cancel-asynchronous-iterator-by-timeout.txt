Natural Text
I have a process running with asyncio which should run forever.I can interact with that process with a ProcessIterator, which can (left out here) send data to stdin and fetch from stdout.I can access the data with async for fd, data in ProcessIterator(...):.The problem is now that the execution of this async iterator must be timelimited. If the time runs out, the timeout() function is called,but the exception does not originate out of the __anext__ function to notify of the timeout.How can I raise this exception in the async iterator?I found no way of calling awaitable.throw(something) or similar for it.The usage of the async iterator is now roughly:tl;dr: How can I throw a timed exception so it originates from a async iterator?
EDIT: Added solution 2Solution 1:Can the timeout() callback store the ProcTimeoutError exception in an instance variable?  Then __anext__() can check the instance variable and raise the exception if it is set.Solution 2:Put the exception on the process.output_queue.If there may be entries on the queue, use a priority queue.  Assign ProcTimeoutError a higher priority than the other entries, e.g., (0, ProcTimeoutError) vs (1, other_entry).
Please check out timeout context manager from asyncio:It is not released yet but you can copy-paste the implementation from asyncio master branch
You could use get_nowait, which will return entry or throw QueueEmpty immediately. Wrapping it in while loop on self.error with some async sleep should do the trick. Something like:And as a hint approach that is used in Tornado's Queue.get implementation with timeout:
This is the solution I came up with by now.See https://github.com/SFTtech/kevin kevin/process.py for the upstream  version.It also features line counting and output timeouts, which I stripped from this example.The magic function is this:When the timeout occurs, the queue fetching is aborted reliably.


Answer URL
https://docs.python.org/3/library/asyncio-queue.html#asyncio.Queue.get_nowait
