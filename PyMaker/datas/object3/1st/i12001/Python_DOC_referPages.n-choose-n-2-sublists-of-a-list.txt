Natural Text
Is there an efficient way in Python to get all partitions of a list of size n into two subsets of size n/2? I want to get some iterative construct such that each iteration provides two non-overlapping subsets of the original list, each subset having size n/2.For example:The subsets should be non-overlapping, e.g. [[1,2,3], [4,5,6]] is valid but [[1,2,3], [3,4,5]] is not.  The order of the two subsets does not matter, e.g. [[1,2,3], [4,5,6]] does not count as different from [[4,5,6], [1,2,3]] and thus only one of those two should appear in an iteration. The order within each subset also does not matter, so [[1,2,3], [4,5,6]], [[1,3,2], [4,5,6]], [[3,2,1], [6,5,4]], etc. all count as the same and so only one of them should show up in whole iteration.
Here's an itertools-based generator that I think yields exactly the values you want.I avoid near-duplicate outputs in two ways as compared to a permutations based approach in Suever's answer. First, I avoid yielding both [["a", "b"], ["c", "d"]] and [["c", "d"], ["a", "b"]] by forcing all the results to have the first value of the input sequence in the first sublist. I avoid yielding [["a", "b"], ["c", "d"]] and [["a", "b"], ["d", "c"]] by building the second sublist using set-subtraction.Note that yielding nested tuples might be a little more natural than nested lists. To do that, just change the last line to:
You will want to use itertools.combinations to do this. The inputs are the list you want to select items out of and the second is the number of items to select.For an input of [1,2,3,4] this yieldsAs @ShadowRanger pointed out, if order matters in your lists and you want all permutations, you'll want to substitute itertools.permutations into the solution.EditUpon reading your question closer it is unclear if you want all n/2 permutations like I have shown or you want a list of lits where each element is yet another list of the two "halves" of the permutation.To accomplish this, you could do the following (incorporating some indexing help from @Blckknght)In this case, the output of [1,2,3,4] would beEdit2Since order doesn't matter but you want an approach similar to the last one (lists of lists of lists), that's a little tricky with the last approach because of the array slicing. One alternative is to use set and frozenset to construct the initial information (rather than lists), because in a set the ordering doesn't matter when checking for equality. This will automatically allow us to remove duplicates. We can then add an extra step to convert back to a list if that's what you prefer.This will yield
Here's a solution which doesn't use itertools. It uses a trick called Gosper's hack to generate bit permutations. See HAKMEM Item 175 for an explanation of how it works; this hack is also mentioned in the Wikipedia article Combinatorial number system. And it features in the accepted answer to this SO question: Iterating over all subsets of a given size.The parts function is a generator, so you can use it in a for loop, as illustrated in my test.How it works.To partiton a list of length n into pairs of sublists of length n/2 we use a binary number bits consisting of n/2 zero bits and n/2 one bits. A zero bit in a given position indicates that the corresponding list element goes into the left sublist, a one bit in a given position indicates that the corresponding list element goes into the right sublist. Initially, bits is set to 2 ** (n/2) - 1, so if n = 6, bits starts out as 000111.The generator uses Gosper's hack to permute bits in numerical order, stopping when we get a one bit in the highest position, since that's when we start getting the reversed versions of our sublist pairs.The code responsible for converting the pattern in bit into the pair of sublists is:If there's a zero at bit position i in bits then ss[0] gets the current item from lst, otherwise it's appended to ss[1]. This code runs on Python 2 and Python 3.outputI admit that using something inscrutable like Gosper's hack isn't exactly Pythonic. :) Here's how you capture the output of parts into a list of all the sublists. It also illustrates that parts can handle string input, although it produces the output as lists of strings.outputHere's another solution, using itertools to generate the combinations. It generates the pairs in a different order to the earlier version. However, it's shorter and easier to read. More importantly, it's significantly faster, between 50 to 100 percent faster in my timeit tests, depending on the list length; the difference appears to get smaller for longer lists.output
Since none of the orders matter, but we're making a list of lists of lists (where order inherently matters), we can assume some invariants: in all pairs, the first element in the first pair is 1, and both lists in a pair are in sorted order.
Here's some code that performs timeit tests on the various solutions to this problem.To make the comparisons fair, I've commented out the argument-checking test in my functions.I've also added a function parts_combo_set that combines features of my combinations-based answer with that of Blckknght. It appears to be the fastest, except for very small lists.outputstime_test(10000, 3)time_test(1000, 3)time_test(500, 3)time_test(100, 3)time_test(50, 3)time_test(50, 3)time_test(10, 3)time_test(10, 3)These tests were performed on a 2GHz single-core machine with 2 GB of RAM running Python 2.6.6.


Answer URL
https://docs.python.org/3/library/timeit.html?#module-timeit
