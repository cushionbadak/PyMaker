Natural Text
This question already has an answer here:Adding more than one value to dictionary when looping through string                    7 answers                I need to build a function that takes as input a string and returns a dictionary.The keys are numbers and the values are lists that contain the unique words that have a number of letters equal to the keys.For example, if the input function is as follows:The function should return:The code that I have written is as follows:The function is returning a dictionary as follows:The dictionary does not contain all the words with the same number of letters but is returning only the last one in the string.
Since you only want to store unique values in your lists, it actually makes more sense to use a set. Your code is almost right, you just need to make sure that you create a set if words isn't already a key in your dictionary, but that you add to the set if words is already a key in your dictionary. The following displays this:Output
The problem with your code is that you just put the latest word into the dictionary. Instead, you have to add that word to some collection of words that have the same length. In your example, that is a list, but a set seems to be more appropriate, assuming order is not important.You can make this a bit shorter by using a collections.defaultdict(set):Or use itertools.groupby, but for this you have to sort by length, first:Example (same result for each of the three implementations):
With sample_dictionary[words]=word you overwrite the current contents which you have put there so far. You need a list, and to that you can append.Instead of that you need:So if there is a value to this key, I append to it, and else create a new list. 
You can use a defaultdict found in the collections library. You can use it to create a default type for the value portion of your dictionary, in this case a list, and just append to it based on the length of your word.You could still do this without defaultdict's, but would just be a little longer in length.To ensure no duplicated in the values list, without using set(). Be warned though, if your value lists are large, and your input data is fairly unique, you'll experience a performance setback as checking if the value already exists in the list will only early exit once it is encountered.So if you have a high frequency of duplicates and a short list of words to scan through, this approach would be acceptable. If you had for example a list of randomly generated words with just permutations of alphabetic characters, causing the value list to bloat, scanning through them will become expensive.
The shortest solution I came up with uses a defaultdict:Now the algorithm:Now wordsOfLength will hold the desired dictionary.
itertools groupby is the perfect tools for this.print n_letter_dictionary("The way you see people is the way you treat them and the Way you treat them is what they become")



Answer URL
https://docs.python.org/3/library/collections.html#collections.defaultdict
https://docs.python.org/3/library/itertools.html#itertools.groupby
