Natural Text
As of Python 3.4, there is a descriptor called DynamicClassAttribute.  The documentation states:types.DynamicClassAttribute(fget=None, fset=None, fdel=None, doc=None)Route attribute access on a class to __getattr__.This is a descriptor, used to define attributes that act differently when accessed through an instance and through a class. Instance access remains normal, but access to an attribute through a class will be routed to the classâ€™s __getattr__ method; this is done by raising AttributeError.This allows one to have properties active on an instance, and have virtual attributes on the class with the same name (see Enum for an example).New in version 3.4.It is apparently used in the enum module:I realise that enums are a little special, but I don't understand how this relates to the DynamicClassAttribute.  What does it mean that those attributes are dynamic, how is this different from a normal property, and how do I use a DynamicClassAttribute to my advantage?
New Version:I was a bit disappointed with the previous answer so I decided to rewrite it a bit:First have a look at the source code of DynamicClassAttribute and you'll probably notice, that it looks very much like the normal property. Except for the __get__-method:So what this means is that if you want to access a DynamicClassAttribute (that isn't abstract) on the class it raises an AttributeError instead of returning self. For instances if instance: evaluates to True and the __get__ is identical to property.__get__.For normal classes that just resolves in a visible AttributeError when calling the attribute:AttributeError - Traceback (most recent call last)that for itself is not very helpful until you take a look at the "Class attribute lookup" procedure when using metaclasses (I found a nice image of this in this blog). Because in case that an attribute raises an AttributeError and that class has a metaclass python looks at the metaclass.__getattr__ method and sees if that can resolve the attribute. To illustrate this with a minimal example:And here comes the "dynamic" part. If you call the dynprop on the class it will search in the meta and return the meta's dynprop:which prints:So we invoked the metaclass.__getattr__ and returned the original attribute (which was defined with the same name as the new property).While for instances the dynprop of the Fun-instance is returned:we get the overriden attribute:My conclusion from this is, that DynamicClassAttribute is important if you want to allow subclasses to have an attribute with the same name as used in the metaclass. You'll shadow it on instances but it's still accessible if you call it on the class.I did go into the behaviour of Enum in the old version so I left it in here:Old VersionThe DynamicClassAttribute is just useful (I'm not really sure on that point) if you suspect there could be naming conflicts between an attribute that is set on a subclass and a property on the base-class.You'll need to know at least some basics about metaclasses, because this will not work without using metaclasses (a nice explanation on how class attributes are called can be found in this blog post) because the attribute lookup is slightly different with metaclasses.Suppose you have:and then call:property at 0x1b3d9fd19a8and on the instance we get:'Haha, overridden it with 2'bad ... it's lost. But wait we can use the metaclass special lookup: Let's implement an __getattr__ (fallback) and implement the dynprop as DynamicClassAttribute. Because according to it's documentation that's its purpose - to fallback to the __getattr__ if it's called on the class:now we access the class-attribute:which prints:So we invoked the metaclass.__getattr__ and returned the original attribute (which was defined with the same name as the new property).And for instances:we get the overriden attribute:Well that's not too bad considering we can reroute using metaclasses to previously defined but overriden attributes without creating an instance. This example is the opposite that is done with Enum, where you define attributes on the subclass:and want to access these afterwards defined attributes by default.but you also want to allow accessing the name attribute that was defined as DynamicClassAttribute (which returns which name the variable actually has):because otherwise how could you access the name of 28?See the difference? Why does the second one don't return <Fun.name: 'me'>? That's because of this use of DynamicClassAttribute. So you can shadow the original property but "release" it again later. This behaviour is the reverse of that shown in my example and requires at least the usage of __new__ and __prepare__. But for that you need to know how that exactly works and is explained in a lot of blogs and stackoverflow-answers that can explain it much better than I can so I'll skip going into that much depth (and I'm not sure if I could solve it in short order).Actual use-cases might be sparse but given time one can propably think of some...Very nice discussion on the documentation of DynamicClassAttribute: "we added it because we needed it"


Answer URL
https://docs.python.org/3/library/types.html#types.DynamicClassAttribute
https://docs.python.org/3/library/enum.html#how-are-enums-different
https://docs.python.org/3/library/types.html#types.DynamicClassAttribute
