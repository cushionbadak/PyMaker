Natural Text
Is there a way to step between 0 and 1 by 0.1? I thought I could do it like the following, but it failed:Instead, it says that the step argument cannot be zero, which I did not expect.
Rather than using a decimal step directly, it's much safer to express this in terms of how many points you want. Otherwise, floating-point rounding error is likely to give you a wrong result.You can use the linspace function from the NumPy library (which isn't part of the standard library but is relatively easy to obtain). linspace takes a number of points to return, and also lets you specify whether or not to include the right endpoint:If you really want to use a floating-point step value, you can, with numpy.arange.Floating-point rounding error will cause problems, though. Here's a simple case where rounding error causes arange to produce a length-4 array when it should only produce 3 numbers:
Python's range() can only do integers, not floating point. In your specific case, you can use a list comprehension instead:(Replace the call to range with that expression.) For the more general case, you may want to write a custom function or generator.
Building on 'xrange([start], stop[, step])', you can define a generator that accepts and produces any type you choose (stick to types supporting + and <):
Increase the magnitude of i for the loop and then reduce it when you need it.EDIT: I honestly cannot remember why I thought that would work syntacticallyThat should have the desired output. 
scipy has a built in function arange which generalizes Python's range() constructor to satisfy your requirement of float handling. from scipy import arange
NumPy is a bit overkill, I think.Generally speaking, to do a step-by-1/x up to y you would do(1/x produced less rounding noise when I tested).
Similar to R's seq function, this one returns a sequence in any order given the correct step value. The last value is equal to the stop value. Results[1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0][10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0][10, 8, 6, 4, 2, 0][ 1 ]
The range() built-in function returns a sequence of integer values, I'm afraid, so you can't use it to do a decimal step.  I'd say just use a while loop:If you're curious, Python is converting your 0.1 to 0, which is why it's telling you the argument can't be zero.
Here's a solution using itertools:Usage Example:
in Python 2.7x gives you the result of:[0.0, 0.1, 0.2, 0.30000000000000004, 0.4, 0.5, 0.6000000000000001, 0.7000000000000001, 0.8, 0.9]but if you use:gives you the desired:[0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]

And if you do this often, you might want to save the generated list r
My versions use the original range function to create multiplicative indices for the shift. This allows same syntax to the original range function.I have made two versions, one using float, and one using Decimal, because I found that in some cases I wanted to avoid the roundoff drift introduced by the floating point arithmetic.It is consistent with empty set results as in range/xrange.Passing only a single numeric value to either function will return the standard range output to the integer ceiling value of the input parameter (so if you gave it 5.5, it would return range(6).)Edit: the code below is now available as package on pypi: Franges
This is my solution to get ranges with float steps.Using this function it's not necessary to import numpy, nor install it.I'm pretty sure that it could be improved and optimized. Feel free to do it and post it here.The output is:
more_itertools is a third-party library that implements a numeric_range tool:OutputThis tool also works for Decimal and Fraction.
You can use this function:
The trick to avoid round-off problem is to use a separate number to move through the range, that starts and half the step ahead of start.Alternatively, numpy.arange can be used.
For completeness of boutique, a functional solution:
It can be done using Numpy library. arange() function allows steps in float. But, it returns a numpy array which can be converted to list using tolist() for our convenience.
My answer is similar to others using map(), without need of NumPy, and without using lambda (though you could).    To get a list of float values from 0.0 to t_max in steps of dt:
Add auto-correction for the possibility of an incorrect sign on step:
My solution:
Best Solution: no rounding error__________________________________________________________________________________________________________________________________________________________________Or, for a set range instead of set data points (e.g. continuous function), use:To implement a function: replace x / pow(step, -1) with f( x / pow(step, -1) ), and define f.For example:
start and stop are inclusive rather than one or the other (usually stop is excluded) and without imports, and using generatorsPython 3.6.2 (v3.6.2:5fd33b5, Jul  8 2017, 04:57:36) [MSC v.1900 64  bit (AMD64)]
Suprised no-one has yet mentioned the recommended solution in the Python 3 docs:See also:The linspace recipe shows how to implement a lazy version of range    that suitable for floating point applications.Once defined, the recipe is easy to use and does not require numpy or any other external libraries, but functions like numpy.linspace(). Note that rather than a step argument, the third num argument specifies the number of desired values, for example:I quote a modified version of the full Python 3 recipe from  Andrew Barnert below:
To counter the float precision issues, you could use the Decimal module.This demands an extra effort of converting to Decimal from int or float while writing the code, but you can instead pass str and modify the function if that sort of convenience is indeed necessary.Sample outputs -
Here is my solution which works fine with float_range(-1, 0, 0.01) and works without floating point representation errors. It is not very fast, but works fine:    
I am only a beginner, but I had the same problem, when simulating some calculations. Here is how I attempted to work this out, which seems to be working with decimal steps.I am also quite lazy and so I found it hard to write my own range function.Basically what I did is changed my xrange(0.0, 1.0, 0.01) to xrange(0, 100, 1) and used the division by 100.0 inside the loop.I was also concerned, if there will be rounding mistakes. So I decided to test, whether there are any. Now I heard, that if for example 0.01 from a calculation isn't exactly the float 0.01 comparing them should return False (if I am wrong, please let me know).So I decided to test if my solution will work for my range by running a short test:And it printed True for each.Now, if I'm getting it totally wrong, please let me know.
This one liner will not clutter your code. The sign of the step parameter is important.
frange(start, stop, precision)


Answer URL
https://docs.python.org/3/library/stdtypes.html#ranges
https://docs.python.org/3/library/decimal.html
