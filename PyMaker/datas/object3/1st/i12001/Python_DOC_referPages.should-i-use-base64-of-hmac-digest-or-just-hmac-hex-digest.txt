Natural Text
LegendI expose an API which requires client to sign requests by sending two headers:To create a signature part, the client should use a secret key issued by my API service.In Python (Py3k) it could look like:I wondered if I could avoid dealing with encoding digest of bytes to Base64 and just use HMAC.hexdigest() to retrieve a string.So that my function will change to:But then I found that Amazon uses similar approach as in my first code snippet:Seeing that Amazon doesn't use hex digest I stopped myself to move forward with it because maybe they know something I don't.UpdateI've measured a performance and found hex digest to be faster:Results with:Question #1Does someone know why do they stick to Base64 of bytes digest and don't use just hex digest? Is there some solid reason to keep using this approach over hex digest?Question #2According to RFC2716 the format of Authorization header value when using Basic Authenticationis:So basically you wrap with Base64 two values (user's id and password) seprated by colon.As you can see in my code snippet and in Amazon's documentation nor me, nor Amazon do that for own custom value of the Authorization header.Would it be a better style to wrap the whole pair as Base64(access_key:signature) to stick closer to this RFC or it doesn't matter at all?
Amazon does use the hex digest in Signature Version 4.Authorization: AWS4-HMAC-SHA256 Credential=AKIDEXAMPLE/20150830/us-east-1/iam/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature=5d672d79c15b13162d9279b0855cfba6789a8edb4c82c400e06b5924a6f2b5d7http://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.htmlYour example is from Signature Version 2, the older algorithm, which does use Base-64 encoding for the signature (and which also is not supported in the newest AWS regions).So, your concern that AWS knows something you don't is misplaced, since their newer algorithm uses it.In the Authorization: header, it really doesn't make a difference other than a few extra octets.  Where Base-64 gets messy is when the signature is passed in the query string, because + and (depending on who you ask) / and = require special handling -- they need to be url-escaped ("percent-encoded") as %2B, %2F, and %3D respectively... or you have to make accommodations for the possible variations on the server... or you have to require the use of a non-standard Base-64 alphabet, where + / = becomes - _ ~ the way CloudFront does it.  (Personally, I find CloudFront's solution brilliant, but I digress... and this particular non-standard alphabet is only one of multiple non-standard options, all "solving" the same problem of magic characters in URLs with Base-64).Go with hex-encoding.  You will almost inevitably find would-be consumers of your API that find Base-64 to be "difficult." 


Answer URL
https://docs.python.org/3/library/hmac.html#hmac.HMAC.hexdigest
