Natural Text
I'm running the following code in a Cython function:In this code, there are only two numpy array allocations. I would expect there to be 1,000,002 of them. When I replace the numpy arrays with my own class, I see its __mul__ function being called 1,000,000 times, resulting in 1,000,000 object allocations.How does numpy know it doesn't need to allocate temporary objects for storing b * i each iteration?
If you look at the code generated by cython the key line I think isPyNumber_Multiply is the standard c-api function to call the multiplication operator so there's no reason to believe that it doesn't just act the same way as a normal multiplication call. However, we can easily check the type of the intermediate.... I took the compiled C file and inserted the line (this was just obtained by looking at the code generated by print(type(a)) and changing a variable name. Note that I haven't changed the Python code, so I don't believe that this generates a variable where one didn't exist before). I then compiled the file manually (gcc -shared -pthread -fPIC -fwrapv -O2 -Wall -fno-strict-aliasing \   -I/usr/include/python3.4m -o filename.so filename.c on linux).This prints<class 'numpy.ndarray'>which really suggests that it has generated a normal numpy array object as a temporary, as you might expect. Nothing magic is going on.As an interesting side note, I believe that recent versions of Numba can actually eliminate the temporary and do the whole operation genuinely in place. However, actually proving this can happen for the example you've given is slightly beyond me (you can kind of see it by calling inspect_asm() on the function generated, and noticing there's a lot of add/multiply instructions, but not obvious function call).


Answer URL
https://docs.python.org/3/c-api/number.html
