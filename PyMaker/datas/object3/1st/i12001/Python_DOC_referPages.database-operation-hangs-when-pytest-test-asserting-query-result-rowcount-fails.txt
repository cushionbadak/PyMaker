Natural Text
The following test works fine:But if I make it fail by changing assert result.rowcount == 0 to assert result.rowcount == 1, it will hang indefinitely on the last line (where the schema should be dropped) and can't even be aborted by [Ctrl+c]. I have to kill the py.test process (or the python process, depending on how I invoked the test runner) to terminate it. (If I appendand run the file as a normal python script instead of through py.test, I get the expected AssertionError.)However, if I just replace the assertion by assert False (and run with py.test again), the test suit finishes with one failed test, as expected. Thus, I assume that pytest retains a reference to result iff the assertion failed, probably for the error analysis it displays with the stack trace. Is that the case?How can and should I avoid the blocking? Should I only ever make test assertions on data fetched from the result rather than on properties of the ResultProxy itself?
TL;DRCallinstead ofAnswers to your specific questions:I assume that pytest retains a reference to result iff the assertion failed, probably for the error analysis it displays with the stack trace. Is that the case?That is still my working assumption. If someone knows better, please enlighten me.How can and should I avoid the blocking?Instead of deleting the ResultProxy result, explicitly close() it in your finally clause:That will release all row and table locks held by result.To avoid the clutter of nested try clauses move the clutter of nested try clauses somewhere else, you can use with contextlib.closing(...)::Should I only ever make test assertions on data fetched from the result rather than on properties of the ResultProxy itself?That would only work if you fetch all rows, thereby exhausting the ResultProxy, which would implicitly _soft_close() it. If the result had (maybe unexpectedly) more rows than you'd fetch, the result would stay open and continue to potentially hold locks that'd keep the following cleanup from being executed.As you're only interested in the rowcount in your test and not in the actual result's content, explicitly closing is the better choice than fetching results you won't use, except maybe for counting them or computing their length.


Answer URL
https://docs.python.org/3/library/contextlib.html#contextlib.closing
