Natural Text
I am converting a shell script into Python. The shell script supports arguments like this.One or more arguments listed in the 'Commands' section may be mixed andmatched but some of them are mutually exclusive.For example, all of the following are valid command line invocations.However, print, search, remove and convert are mutuallyexclusive. So the following are not valid.Is it possible to handle command line arguments like these usingargparse? Or am I better off looping over sys.argv myself,handling these cases with my own code, which would also mean that I haveto take care of updating the help message and any necessary validationwhenever the list of supported arguments change?Note: I don't want to rely on any internal implementation of argparse module to achieve this. I only want to rely on publicly documented API of argparse. If it is not possible to solve this problem with the publicly documented API of argparse, then that's fine and that would be the answer. In that case, I would handle the command line arguments myself by looping over sys.argv similar to how the shell script is handling the arguments by looping over "$@".
A variation in which --limit and --all are optionals, and the rest are subparsers fits argparse nicely.You can't run multiple subparsers (e.g. print and limit) without some serious convolutions.  Plus limit and all are conceptually very different arguments.  The others are commands - do thus-n-such.  limit and all are modifiers.Do limit and all work with all the others, or just with print and search.  They might make more sense as optionals for those subparsers.Also keep in mind that a big plus to argparse is that it generates usage, helps and error messages.  When you do something unusual, you need to think about those messages.  How do you clearly tell your users that they can use limit with print but not with convert?  Or that they can't use limit and all at the same time; or that one overrides the other.But if you are stuck with these names/flags, and can't add --, then don't bother with argparse.  Don't bother changing something that already works.  The underlying philosophy in argparse (and optparse and getopt) is to use flagged strings ('--') where you want to match content with action, and handle the rest by order.  argparse expects to parse your strings based on position, not content.
It can mostly handle this, just not quite the way you're doing it. You'd use subcommands/subparsers for print, search, remove and convert, and define the other "commands" (really options on the top level commands) as switches, either on the top level parser if they're common to all commands, or on the individual subparsers/subcommands if they're not common.Now, in this particular case, it seems like you don't even have unique behaviors for each subcommand, so you might just get away with a single positional argument and two switches:The positional action argument could be changed to individual subparsers if needed, but in this case, it seems like all of the possible commands would allow all or limit.


Answer URL
https://docs.python.org/3/library/argparse.html#sub-commands
