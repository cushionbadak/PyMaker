Natural Text
I'm having trouble achieving this. What I'm stuck with is trying to expose Modules written in C++ to an embedded python interpreter. I'm using boost::python, but I'm not sure what I'm supposed to do for this, as the documentation seems to be lacking, to say the least. What I want is to expose some C++ code with BOOST_PYTHON_MODULE, and then access that from the same application. However I can't get it to import. What I've got, which seem the closest (just relevant part):But that prints the Error AttributeError: 'NoneType' object has no attribute '__dict__'And I can't import the module later.How should this be structured?EDIT:Ok, so the closest I got was one of the methods in the accepted answer:However, this doesn't seem particularly useful in my case, as I'd like to be able to add/import modules after the Initialize function. I'm going to look into a few things, namely:See if I can get the suggested approach for python 2 working in python 3See if I can nicely structure my game to require naming all of the modules before Py_InitializeI'll update this post with my findings.
Boost.Python uses the BOOST_PYTHON_MODULE macro to define a Python module initializer.  The resulting function is not the module importer.  This difference is similar to that of creating a modthingy.py module and calling import modthingy.When importing a module, Python will first check if the module is a built-in module.  If the module is not there, then Python will then search the module search path trying to find a python file or library based on the module name.  If a library is found, then Python expects the library to provide a function that will initialize the module.  Once found, the import will create an empty module in the modules table, then initialize it.  For statically linked modules, such as modthingy, the module search path will not be helpful, as there is no library for it to find.For embedding, the module table and initialization function documentation states that for static modules, the module initializer function will not be automatically called unless there is an entry in the initialization table.  For Python 2 and Python 3, one can accomplish this by calling  PyImport_AppendInittab() before Py_Initialize():Alternatively, for Python 2, once the interpreter has been initialized, one can create an empty module that is added to the modules dictionary via PyImport_AddModule(), then explicitly initialize the module.This approach is demonstrated in the official Python embedded demo, embed/demo.c. The module initializer created from BOOST_PYTHON_MODULE does not call PyImport_AddModule(), thus it must be explicitly called.Also note that the Python's C API for embedding changed naming conventions for module initialization functions between Python 2 and 3, so for BOOST_PYTHON_MODULE(modthingy), one may need to use &initmodthingy for Python 2 and &PyInit_modthingy for Python 3.Here is a minimal complete example demonstrating importing a module statically linked with the embedded interpreter:Output:


Answer URL
https://docs.python.org/3/tutorial/modules.html#the-module-search-path
https://docs.python.org/3/extending/extending.html#the-module-s-method-table-and-initialization-function
https://docs.python.org/3/c-api/import.html#c.PyImport_AppendInittab
https://docs.python.org/3/c-api/init.html#c.Py_Initialize
