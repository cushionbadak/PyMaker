Natural Text
I have some code like the following in Python:library.py:my_code.py:I want to unit test that when I call party I will get confetti. However, I want to avoid all the side effects that are part of the library class I am subclassing. More specifically, I want to avoid these side effects in the unit tests, but the side effects are needed in the production code.I cannot change the code in library.py because it's a library, and I did not write the code. Obviously I wouldn't want to maintained a forked version of a library just to facilitate a unit test.I've been trying to mock the HasSideEffects superclass. I need to mock __init__ and launch_nukes in the superclass so they no longer perform side effects. I've been having some trouble mocking the __init__ method, apparently the Python mock library does not support it?What's the best way to test that party return confetti, while avoiding side effects?
Maybe you was quite close to a solution:I've been trying to mock the HasSideEffects superclass. I need to mock init and launch_nukes in the superclass so they no longer perform side effects. I've been having some trouble mocking the init method, apparently the Python mock library does not support it?unittest.mock and legacy mock are designed exactly to do this kind of work. When you need to remove dependencies from library or resources mock it and replace by patch is powerful especially when you should play with legacy code that you cannot change.In your case you need to patch either __init__ method: to do it you must take in account two things If the class is subclassed and you need patch it when build a subclass object you must patch __init__ directly instead of class definition.__init__ method MUST return None and your mock too.Now come back to your simple example: I changed it a little bit to make tests more explicit.library.pymy_code.pytest_my_code.pyNote as the decorator version is neat and simple.
This is a pretty tricky question to answer in general.  If the library class that you're mocking is simple enough, then you can provide your functionality as a mixin.Now, for testing you just need to provide a subclass that has the interface that your UtililtySubclassMixin expects (e.g. something with a launch_nukes method).  This isn't ideal, but if you need to mock out a library method that has an __init__ with side-effects it's about the best you can do.  If it's all non-magic methods that have side-effects, unittest.mock can be used to patch the methods on library.HasSideEffects directly.And, FWIW, this is a very good reason why __init__ methods should never have side effects :-).


Answer URL
https://docs.python.org/3/library/unittest.mock.html
