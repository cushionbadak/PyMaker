Natural Text
In this pseudo code, the destructor of o is never called.I see the exception printed on the terminal, but o seems not being garbage-collected. The interpreter does not exit upon the exception (the main thread keeps running). The whole purpose behind this is to be able to do certain cleanup in the destructor when exceptions occur.Another way to explain this is with a different pattern:Exceptions happening in parse will not get caught.Even further:Here manager.__exit__() will get called with all None arguments as if the code completed cleanly, even if there is an exception in do_something.The purpose behind this is because I'm running certain tasks which can fail for too many different reasons, and these tasks can be done partially in the main thread, and partially in a worker thread. It can fail in either.So my initial idea was to keep references to an object while the task was running, so if the task completed by exiting the context or by an exception, references would be lost and eventually the destructor would be run.I'm trying to keep track of these tasks and keep a visual indicator on a GUI of which tasks are still doing their job.
You can catch Exception after it was raised and do what you want to do or use such form if is no difference was exception raised or not:If you need just keep Thread alive, may be, you should use: Thread.sleep()As i understood in Thread is only parse(), so you need to create signal by emit() about deleting and send it in main threadI believe that caughting destructor is not the best decision, it will be better to catch some signal. Please add more info about why you do this all. 


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__del__
