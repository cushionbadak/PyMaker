Natural Text
Let's say that I've got a situation like this in Python:I know that the order of my_dict.keys() is undefined, but what I'm wondering is whether the initialization via a literal like this is guaranteed to happen in a particular order. Will the value of my_dict['key1'] always be 1.0 as asserted?
Dictionary evaluation order should be the same as written, but there is a outstanding bug where values are evaluated before the keys. (The bug was finally fixed in Python 3.5).Quoting from the reference documentation:Python evaluates expressions from left to right.and from the bug report:Running the following code shows "2 1 4 3", but in reference manual  http://docs.python.org/reference/expressions.html#expression-lists the  evaluation order described as {expr1: expr2, expr3: expr4}and Guido stated:I am sticking with my opinion from before: the code should be fixed.  It doesn't look like assignment to me.This bug is fixed in Python 3.5, so on Python 3.4 and earlier the values are still evaluated before the keys:Since your code doesn't require the keys to be evaluated first, your code is guaranteed to work correctly; key-value pairs are still evaluated in order even if the keys are evaluated after each corresponding value. 
According to the Python docs regarding evaluation order, this should have well-defined behavior:In the following lines, expressions will be evaluated in the arithmetic order of their suffixes:So, regardless of what order the items in a dict end up being iterated, the values (and keys!) of a literal dictionary expression will always be evaluated in the same order as they appear in my Python source code.
The current behaviour on Python 3.4.2 can be very clearly seen in the disassembled bytecode: the values are evaluated before keys, not left-to-right.However this also shows the reason why this is also not so straightforward to fix: the values and keys are expected by STORE_MAP in this order; changing the order would either require adding a ROT_TWO opcode after each pair, or STORE_MAP_EX opcode which would expect the pairs to be reversed; the first one would be a performance drop, whereas the second would mean yet another opcode to handle in every piece of code that deals with bytecode.


Answer URL
https://docs.python.org/3/library/dis.html#opcode-STORE_MAP
https://docs.python.org/3/library/dis.html#opcode-ROT_TWO
