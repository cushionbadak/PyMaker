Natural Text
So I've spent the last 5 hours googling DFS, BFS, A*, Bellman-ford and others.  I have roads=[('a', [('b', 5.0), ('c', 8.0)]), ('b', [('a', 5.0), ('d', 6.0)]), ('c', [('a', 8.0), ('d', 2.0)]), ('d', [('b', 6.0), ('c', 2.0), ('e', 12.0), ('f', 2.0)]), ('e', [('d', 12.0), ('g', 3.0)]), ('f', [('d', 2.0), ('g', 7.0)]), ('g', [('e', 3.0), ('f', 7.0)])]weighted dictionary. I found this code: It never finds start in the roads and returns []. I'm so lost. I get what these algorithms do but have no idea how to code them. I just want to find the shortest path. 
The code you've copied won't solve your problem.  Note, for starters, that its name tells you that it does something else.  Also, it doesn't even look at the edge weights.Finally, it isn't designed to work on your graph representation at all.  Note that the start parameter is used as a key in what I assume is a dictionary, and it expects the value to be an iterable of reachable nodes.  But you're not feeding it a dictionary, you're feeding it a list.As for the empty-list return value, if you're calling the function like this:...then it is correct.  'a' is not a node in your graph at all.  Your nodes are tuples, starting with an identifier like 'a', but also containing a list of 2-tuples.  You'd have to type this mess every time:Yuck.As a final insult, those 2-tuples like ('d', 2.0) are also not nodes.  Even if you fixed the rest of it, these would still fail the if start not in graph: test once one of them got passed as the new start argument into the recursive function call.  And if you fixed that, they wouldn't match the designated end node.  This code can't do what you want.My suggestions:Don't plug random data into functions you found lying around the Internet.  Start simple:  Dijkstra's Algorithm will return the shortest path, which is what you want.  It's A* without the heuristic function (you said you've already read up on A*).  Code that, and then worry about getting complex.  (Note that you will probably need an adjustable priority queue --- you can build one using the heapq module.)You need to access arbitrary nodes by an immutable ID, so your graph should be a dictionary, not a list.  The keys are your one-letter strings, and the values are lists (or tuples) of edges.  You can then iterate through all of a node's edges with something like: for edge in graph['a']:.Your life will probably be much easier if you create a collections.namedtuple called Edge with two fields: dest and weight.  (You could do 3 fields if you find you also need the origin:  orig, dest, and weight.)Look for other chunks of data that go together, and consider writing another namedtuple or a class for them, too.  (First contender: Path, with a weight method.)Consider using the pprint.pprint function for displaying large, nested structures like your graph.  It will make print-to-console debugging much easier.PS:  I found that the first couple chapters of Stuart Russell's and Peter Norvig's Artificial Intelligence: A Modern Approach, 3rd Ed were an excellent introduction to graph search algorithms like this...  Unfortunately, the majority of the book would probably be off-topic for you.


Answer URL
https://docs.python.org/3/library/heapq.html
https://docs.python.org/3/library/collections.html#namedtuple-factory-function-for-tuples-with-named-fields
https://docs.python.org/3/library/pprint.html
