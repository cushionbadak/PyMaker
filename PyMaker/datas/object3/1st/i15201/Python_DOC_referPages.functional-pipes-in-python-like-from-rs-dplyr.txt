Natural Text
In R (thanks to dplyr) you can now perform operations with a more functional piping syntax via %>%. This means that instead of coding this: You could also do this: To me this is more readable and this extends to use cases beyond the dataframe. Does the python language have support for something similar? 
One possible way of doing this is by using a module called macropy. Macropy allows you to apply transformations to the code that you have written. Thus a | b can be transformed to b(a). This has a number of advantages and disadvantages.In comparison to the solution mentioned by Sylvain Leroux, The main advantage is that you do not need to create infix objects for the functions you are interested in using -- just mark the areas of code that you intend to use the transformation. Secondly, since the transformation is applied at compile time, rather than runtime, the transformed code suffers no overhead during runtime -- all the work is done when the byte code is first produced from the source code.The main disadvantages are that macropy requires a certain way to be activated for it to work (mentioned later). In contrast to a faster runtime, the parsing of the source code is more computationally complex and so the program will take longer to start. Finally, it adds a syntactic style that means programmers who are not familiar with macropy may find your code harder to understand.Example Code:run.pytarget.pyAnd finally the module that does the hard work. I've called it fpipe for functional pipe as its emulating shell syntax for passing output from one process to another.fpipe.py
Pipes are a new feature in Pandas 0.16.2.Example:NB: The Pandas version retains Python's reference semantics. That's why length_times_width doesn't need a return value; it modifies x in place.
Does the python language have support for something similar? "more functional piping syntax" is this really a more "functional" syntax ? I would say it adds an "infix" syntax to R instead.That being said, the Python's grammar does not have direct support for infix notation beyond the standard operators.If you really need something like that, you should take that code from Tomer Filiba as  a starting point to implement your own infix notation:Code sample and comments by Tomer Filiba (http://tomerfiliba.com/blog/Infix-Operators/) :Using instances of this peculiar class, we can now use a new "syntax"  for calling functions as infix operators:
PyToolz [doc] allows arbitrarily composable pipes, just they aren't defined with that pipe-operator syntax.Follow the above link for the quickstart. And here's a video tutorial:  http://pyvideo.org/video/2858/functional-programming-in-python-with-pytoolz
If you just want this for personal scripting, you might want to consider using Coconut instead of Python.Coconut is a superset of Python. You could therefore use Coconut's pipe operator |>, while completely ignoring the rest of the Coconut language.For example:compiles to
Building pipe with InfixAs hinted at by Sylvain Leroux, we can use the Infix operator to construct a infix pipe.  Let's see how this is accomplished.First, here is the code from Tomer FilibaCode sample and comments by Tomer Filiba (http://tomerfiliba.com/blog/Infix-Operators/) :Using instances of this peculiar class, we can now use a new "syntax"  for calling functions as infix operators:The pipe operator passes the preceding object as an argument to the object that follows the pipe, so x %>% f can be transformed into f(x).  Consequently, the pipe operator can be defined using Infix as follows:A note on partial applicationThe %>% operator from dpylr pushes arguments through the first argument in a function, so corresponds to The easiest way to achieve something similar in Python is to use currying.  The toolz library provides a curry decorator function that makes constructing curried functions easy.Notice that |pipe| pushes the arguments into the last argument position
I missed the |> pipe operator from Elixir so I created a simple function decorator (~ 50 lines of code) that reinterprets the >> Python right shift operator as a very Elixir-like pipe at compile time using the ast library and compile/exec:All it's doing is rewriting a >> b(...) as b(a, ...).https://pypi.org/project/pipeop/https://github.com/robinhilliard/pipes
Adding my 2c. I personally use package fn for functional style programming. Your example translates intoF is a wrapper class with functional-style syntactic sugar for partial application and composition. _ is a Scala-style constructor for anonymous functions (similar to Python's lambda); it represents a variable, hence you can combine several _ objects in one expression to get a function with more arguments (e.g. _ + _ is equivalent to lambda a, b: a + b). F(sqrt) >> _**2 >> str results in a Callable object that can be used as many times as you want. 
You can use sspipe library. It exposes two objects p and px. Similar to x %>% f(y,z), you can write x | p(f, y, z) and similar to x %>% .^2 you can write x | px**2.
One alternative solution would be to use the workflow tool dask. Though it's not as syntactically fun as......it still allows your variable to flow down the chain and using dask gives the added benefit of parallelization where possible.Here's how I use dask to accomplish a pipe-chain pattern:After having worked with elixir I wanted to use the piping pattern in Python. This isn't exactly the same pattern, but it's similar and like I said, comes with added benefits of parallelization; if you tell dask to get a task in your workflow which isn't dependant upon others to run first, they'll run in parallel.If you wanted easier syntax you could wrap it in something that would take care of the naming of the tasks for you. Of course in this situation you'd need all functions to take the pipe as the first argument, and you'd lose any benefit of parallization. But if you're ok with that you could do something like this:Now, with this wrapper, you can make a pipe following either of these syntactical patterns:like this:
There is dfply module. You can find more information athttps://github.com/kieferk/dfplySome examples are:


Answer URL
https://docs.python.org/3/reference/grammar.html
