Natural Text
So using 'php index.php' gives me the output I want in the command line. But will not give the output on the webpage. So first of all I have this python file which basically does everything I want:Secondly I just have a sh executable that will put the output of this python command into another text file: I then have the php file on an apache web server running on the raspberry pi, it reads:So if I'm not wrong, each time the page is refreshed it should execute that, wait for the exec to finish, then display the txt file contents? I have tried both shell_exec and just exec, they both do the same..
There are many rights, you have to ensure:the apache user has to be in the sudoers groupthe apache user must write to /home/pi/whohome.txtthe apache user must write to /var/www/html/website.txt/home/pi/whoishome.shmust be executable for the apache userFor point 1 to 3, it is normally not a good idea, to give the apache users these rights.You can make it easier if you start your python script as CGI:The only point 1 and 4 must be fullfilled.
I suspect your problem is the sudo part of the nmap command line.  If you replace the subprocess.call with subprocess.check_call, I think you will find that command raises a CalledProcessError.Presumably, your user account is in the /etc/sudoers file, but the Web server is not.Since the first thing the shell's output redirect operator (>) does is truncate the output file, that failed attempt to run nmap results in a zero-byte whohome.txt.  The rest of the Python script then does the same to website.txt, and you end up with nothing to display on your Web site.SolutionsNo sudo required.On my Linux desktop, I do not need to run nmap as root to do a local ping scan.  If that's true on your system, then you should be able to just drop the sudo part of your nmap command, and be done with it.There is a difference, though.  nmap will perform a more thorough testing of each target when the -pS ping sweep is run by root.  From an old nmap man page (emphasis added):-sP (Skip port scan) .[...]The -sP option sends an ICMP echo request, TCP SYN to port 443, TCP ACK to port 80, and an ICMP timestamp request by default.  When executed by an unprivileged user, only SYN packets are sent (using a connect call) to ports 80 and 443 on the target.  When a privileged user tries to scan targets on a local ethernet network, ARP requests are used unless --send-ip was specified.  [...]Enable sudo for your Web server.If you need this extra information (and it sounds like you do), you'd need to run nmap (or the Python script that calls it) with super-user privileges.  I've never tried to force a Web server to do this, but I assume you would at least have to add your Web server's user to /etc/sudoers.  Something like:or:...and so on, depending on the user name, where your nmap is located, how strictly you want to limit the arguments to nmap, etc.Create an SUID executable to run nmap for you.Alternatively (and I hate myself for recommending this --- there must be a better way) is to write a tiny SUID (Set User ID) program that executes only the nmap command you want.  Here's a C program that will do it:Save the above as something like nmap_lan.c, and compile with:Then, move it to wherever you keep your Web site's scripts, and as root, change its ownership and permissions:The leading 4 sets the SUID bit.  A color ls of the directory will probably show that file highlighted.  The permissions should look like this:Any user who runs nmap_lan will be temporarily promoted to whoever owns the nmap_lan file (in this case, root) until the program exits.  That's extraordinarily generous, which is why I hard-coded everything in that program...  To change anything it does --- even just the IP range to scan --- you'll have to edit nmap_lan.c file, re-compile, and re-install.I've tested nmap_lan on my command line, and it produces privileged-user nmap output when run by an unprivileged user who normally gets only limited output.Comments on the Python scriptIn general, Python is vastly better at parsing shell arguments than the shell is (the default value for shell is False for a reason), so have your Python script do as much of the job as possible, including parsing the shell command, redirecting input, and redirecting output.A major advantage of doing the work in Python is that failure to open, read, write, or close any of your files will result in an immediate crash and a stack trace --- instead of the silent failure you've been dealing with.I'd rewrite that call command to use a list of explicitly separated arguments.  You can handle the output redirection by passing an opened file stream to the stdout parameter.  You can eliminate your last bit of shell redirection by having Python open your output file and write to it explicitly.Also, unless you need that whohome.txt file for something else, you can eliminate it entirely by using check_output to store the output from the nmap command as a string, and then splitting it into separate lines.  (The universal_newlines parameter also handles converting the bytes object into a str, at least in Python 3.)Note that I used with blocks to get the file closing for free.(Finally, that series of if commands is crying out to be rewritten as a for machine in machines_dict: loop, with the strings you're searching for as the keys in that dictionary, and the output you want to print as the values.)


Answer URL
