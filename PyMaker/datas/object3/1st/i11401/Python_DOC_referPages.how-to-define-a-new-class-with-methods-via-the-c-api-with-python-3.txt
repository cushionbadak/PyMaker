Natural Text
Short version: If we use PyObject_CallFunctionObjArgs with PyType_Type in Python 3 as a replacement for PyClass_New, then the dictionary has to be populated before the creation of the class. However, PyMethod_New requires the class to be known before the creation of the method. How can we add a method to the dictionary of a new class in Python 3?In Python 2, I was used to define new classes with PyClass_New. Here is a minimal working example (for Python 2), where I define a new class example.MyClass with a method hello:PyClass_New was removed from the Python 3 C API. I read that PyObject_CallFunctionObjArgs can be used as replacement, for example in the answer of the following question: What is the PyClass_New equivalent in Python 3?However, it appears that the dictionary that PyObject_CallFunctionObjArgs takes for last argument is copied during the creation of the new class: indeed, the fields that are set to dict before calling PyObject_CallFunctionObjArgs are available in the instances of the class, but not the fields that are set after the call.That prevents us from using PyMethod_New as above because the class has to be known before creating the method, but the method has to be added to dict before creating the class.This dependency loop can be solved by using PyInstanceMethod_new, since the latter does not take a reference for a class. I obtained thus the following working example (for Python 3, I only give the code for main, the preambule and the callback is the same as in the first example).However, I wonder whether I could achieve to write a solution closer to the Python 2 version, using PyMethod_new: it should be possible to dynamically change the class after its creation for adding the new method, but I don't figure out how to do that.
You're not actually using the C API for creating types.The normal way to define a type through the C API is by defining your object's layout as a C struct and declaring a global PyTypeObject with tp_* fields defining its properties. This is documented under Extending and Embedding the Python Interpreter: Defining New Types. PyObject_CallFunctionObjArgs is not involved.Using PyObject_CallFunctionObjArgs with PyType_Type would be analogous to creating a type by calling type manually in Python. In this case, the type's dict should not contain method objects. Just like if you were doing it in Python, the dict should contain Python function objects, and method objects will be created dynamically on attribute access.


Answer URL
https://docs.python.org/3/extending/newtypes.html
