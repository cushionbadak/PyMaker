Natural Text
I want an array X of shape (n_samples,n_cols,n_rows,n_channels). I want an array y with a shape (n_sample,n_cols,n_rows,n_channels)I have tried and I get this error: ValueError: setting an array element with a sequence.I figure this must be a somewhat common operation - any time someone wants to load image data into an array in numpy so there must be something Im missing? 
np.fromiter requires that you state the dtype. If you use dtype=float, then each value from the iterable must be a float. If you yield single NumPy arrays from loadfunc, you could use their flat attribute to obtain iterators over the flatten array values which could be concatenated with itertools.chain.from_iterable and then passed to np.fromiter:Since np.fromiter returns a 1D array, you would then need to reshape it:Note that this relies on each image having the same shape.Finally, to load the L values into X and the ab values into y:Regarding the question in the comments:If I wanted to do extra processing to L and ab, where would I do that?I believe in separating the loading from the processing of the data. By keeping the two functions distinct, you leave open the possibility of passing different data from different sources to the same processing function. If you put both the loading and the processing of the data (such as a KNN classification of the ab values) into loadfunc then there is no way to reuse the KNN classification code without loading the data from files.If you allow us to change the order of the axes from (n_samples, n_cols, n_rows, n_channels) to(n_cols, n_rows, n_channels, n_samples),then the code could be simplified using np.stack:This code is simpler and therefore preferable to the code (using np.fromiter) above. 
numpy.fromiter does not support simultaneous array creation and then return them as a tuple, (to be unpacked into X,y)  It is possible there is a way to do this in np but not to my knowledge, you may need to split the iterator into a tee instead
Usually when we create an array with iteration we either collect the values in a list, and create the array from that.  Or we allocate an empty list and assign values to slots.Here's a way of doing the assignment, where the generator returns a tuple of arrays:I made one an array of ints, the other an array of floats.  That reduces the temptation to concatenate them into one.        Lets allocate target arrays of the right shape; here I put the iteration axis 3rd, but it could be anywhereMy guess this is as fast as any fromiter or stack alternative.  And when the components are generated by reading from files, that step is bound to be the most expensive - more so than the iteration mechanism or array copies.================If the iterator returned a tuple of scalars, we can use fromiter:producing a 1d structured array:which can be reshaped, and arrays separated by field name:================What if I define a more complex dtype, one where each field has an array:This use of a compound dtype with fromiter is also described in https://stackoverflow.com/a/12473478/901925This is, in effect, a variation on the usual way of building a structured array - from a list of tuples.  More than once I've use the expression:In sum we can time two methods of creating 2 arrays:For a wide range of N these 2 functions take nearly the same time.  I have to push run times to 1s before I starting an advantage for foo1.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.tee
