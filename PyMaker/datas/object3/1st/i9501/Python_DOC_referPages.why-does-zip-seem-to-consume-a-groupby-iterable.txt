Natural Text
So splitting a list using itertools.groupby() is a fairly easy.Works as expected. But using a common python idiom of ziping up the iterator multiple times to step through 2 at a time seems to break things.Adding a print(y) shows the expected nested iterable <itertools._grouper object at 0xXXXXXXXX>, but I'm obviously missing something as to why the grouper object is empty. Can anyone shed some light?I get an even weirder result if I have an uneven list and use itertools.zip_longest:Update: Simple fix is to use itertools.islice():
The groupby documentation warns you thatThe returned group is itself an iterator that shares the underlying iterable with groupby(). Because the source is shared, when the groupby() object is advanced, the previous group is no longer visible.When your zip produces a ((key, group), (key, group)) pair, it advances the groupby iterator past the first group, rendering the first group unusable. You need to materialize the group before advancing:
Because as soon as you get to the next item in itertools.groupby it discards any previous encountered _grouper-generators.The latest items they will be visible:The documentation contains a Warning about this behaviour:The returned group is itself an iterator that shares the underlying iterable with groupby(). Because the source is shared, when the groupby() object is advanced, the previous group is no longer visible. So, if that data is needed later, it should be stored as a list.So by using (x, y), _ in zip(iterable, iterable) you actually advanced the iterator by 2 (even if the latest result is dumped in _) and the first one (your x, y) is not avaiable anymore!


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.groupby
