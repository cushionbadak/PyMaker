Natural Text
I would like to understand how to use dis (the dissembler of Python bytecode). Specifically, how should one interpret the output of dis.dis (or dis.disassemble)?.Here is a very specific example (in Python 2.7.3):I see that JUMP_IF_TRUE_OR_POP etc. are bytecode instructions (although interestingly, BUILD_SET does not appear in this list, though I expect it works as BUILD_TUPLE). I think the numbers on the right-hand-side are memory allocations, and the numbers on the left are goto numbers... I notice they almost increment by 3 each time (but not quite).If I wrap dis.dis("heapq.nsmallest(d,3)") inside a function:
You are trying to disassemble a string containing source code, but that's not supported by dis.dis in PythonÂ 2. With a string argument, it treats the string as if it contained byte code (see the function disassemble_string in dis.py). So you are seeing nonsensical output based on misinterpreting source code as byte code.Things are different in Python 3, where dis.dis compiles a string argument before disassembling it:In Python 2 you need to compile the code yourself before passing it to dis.dis:What do the numbers mean? The number 1 on the far left is the line number in the source code from which this byte code was compiled. The numbers in the column on the left are the offset of the instruction within the bytecode, and the numbers on the right are the opargs. Let's look at the actual byte code:At offset 0 in the byte code we find 65, the opcode for LOAD_NAME, with the oparg 0000; then (at offset 3) 6a is the opcode LOAD_ATTR, with 0100 the oparg, and so on. Note that the opargs are in little-endian order, so that 0100 is the number 1. The undocumented opcode module contains tables opname giving you the name for each opcode, and opmap giving you the opcode for each name:The meaning of the oparg depends on the opcode, and for the full story you need to read the implementation of the CPython virtual machine in ceval.c. For LOAD_NAME and LOAD_ATTR the oparg is an index into the co_names property of the code object:For LOAD_CONST it is an index into the co_consts property of the code object:For CALL_FUNCTION, it is the number of arguments to pass to the function, encoded in 16 bits with the number of ordinary arguments in the low byte, and the number of keyword arguments in the high byte.
I am reposting my answer to another question, in order to be sure to find it while Googling dis.dis().To complete the great Gareth Rees's answer, here is just a small column-by-column summary to explain the output of disassembled bytecode.For example, given this function:This may be disassembled into (Python 3.6):Each column has a specific purpose:The corresponding line number in the source codeOptionally indicates the current instruction executed (when the bytecode comes from a frame object for example)A label which denotes a possible JUMP from an earlier instruction to this oneThe address in the bytecode which corresponds to the byte index (those are multiples of 2 because Python 3.6 use 2 bytes for each instruction, while it could vary in previous versions)The instruction name (also called opname), each one is briefly explained in the dis module and their implementation can be found in ceval.c (the core loop of CPython)The argument (if any) of the instruction which is used internally by Python to fetch some constants or variables, manage the stack, jump to a specific instruction, etc.The human-friendly interpretation of the instruction argument


Answer URL
https://docs.python.org/3/library/inspect.html#the-interpreter-stack
