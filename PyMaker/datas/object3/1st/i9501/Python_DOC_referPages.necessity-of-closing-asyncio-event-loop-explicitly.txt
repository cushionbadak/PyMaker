Natural Text
The Story:I am currently looking through the asyncio basic examples, in particular this one - the simplest possible HTTP client. The main function starts an event loop, runs until the data fetching is complete and closes the event loop:But, the code also works if I omit the loop.close():The Question:While there is an example, the question is a generic one - what can potentially go wrong if one would forget to close the asyncio event loop? Is the event loop going to be always implicitly closed?
.close() can be used by different event loop implementations to free up system resources allocated by the loop (or do anything else).  If you'll take a look at the code of _UnixSelectorEventLoop, which is the (default) IOLoop used in Linux, you would find the following code:Here, for example, close() removes signal handlers registered with loop.add_signal_handler().As multiple IOLoops can be started on different threads, or new IOLoops can be created after an old one is closed, (see asyncio.new_event_loop()), closing them should be considered as a good habit.UpdateStarting with Python 3.7 it is recommended to use asyncio.run instead of run_until_complete():Among other things, asyncio.run takes care of finally close()ing the loop. 


Answer URL
https://docs.python.org/3/library/asyncio-task.html#asyncio.run
https://docs.python.org/3/library/asyncio-task.html#asyncio.run
