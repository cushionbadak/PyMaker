Natural Text
My understanding is that when Python parses the source code of a function, it compiles it to bytecode but doesn't run this bytecode before the function is called (which is why illegal variable names in functions does not throw an exception unless you call the function).Default arguments are not instantiated during this initial setup of the function, but only when the function is called for the first time, regardless of whether the arguments are supplied or not. This same instance of the default argument is used for all future calls, which can be seen by using a mutable type as a default argument.If we put the function inside of another function, however, the default argument now seems to be re-instantiated each time the outer function is called, as the following code shows:This prints outDoes this mean that every time f is called, the bytecode of g is rebuild? This behavior seems unnecessary, and weird since the bytecode of f (which include g?) is only build once. Or perhaps it is only the default argument of g which is reinstantiated at each call to f?
First misconception: "when Python parses the source code of a function, it compiles it to bytecode but doesn't run this bytecode before the function is called (which is why illegal variable names in functions does not throw an exception unless you call the function)." To be clear, your misconception is that "illegal variable names in functions does not throw an exception unless you call the function". Unassigned names will not be caught until the function is executed.Check out this simple test:Second misconception: "default arguments are not instantiated during this initial setup of the function, but only when the function is called for the first time...". This is incorrect. As for your example, every time you run f the default argument is reinstantiated because you define g inside f. The best way to think of it is to think of the def statement as a constructor for function objects, and the default arguments like parameters to this constructor. Every time you run def some_function it is like calling the constructor all over again, and the function is redefined as if had written g = function(a=[]) in the body of f.In response to comment
The inner function is rebuilt using existing bytecode for the inner function. It's easy to see using dis.Now if you do:
Just look at the bytecode for f with dis: (snipped for brevity) The code object loaded for g:doesn't contain any mutable structures, it just contains the executable code  and other immutable information. You could take a peek at it too:Every time f is called, MAKE_FUNCTION is called which re-creates the function from the byte code that already exists there.


Answer URL
https://docs.python.org/3/tutorial/controlflow.html#default-argument-values
