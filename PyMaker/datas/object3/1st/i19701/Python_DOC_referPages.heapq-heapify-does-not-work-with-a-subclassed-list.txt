Natural Text
I would like to get callback notification every time heapq.heapify function changes elements in my heap-list (this is, btw, needed to keep track of objects in the list and how their indexes get changed).My plan was to subclass from list and override the __setitem__ method from which I would track changes in my list. So here is the subclass:Then I create an instance of List2 and call heapify for it:The problem is that the overridden __setitem__ is not called from within heapq.heapify. It looks like heapq.heapify treats an instance of List2 as if it's the default list.I guess it has something to do with the fact that heapq.heapify is a built-in function, but I still don't get it.Why the overridden __setitem__ is not called from heapq.heapify?An interesting thing here is that if I copy-paste the heapq's code into my local module (so it's not a built-in function anymore), then it works as expected and I get calls to List2.__settiem__, but it does not work with the default (built-in) heapq.Python 2.7 if it matters
As part of the Python 3.0 project, and again for 3.3, they went through the docs making it more explicitly when something takes a list vs. a general sequence type or mutable sequence type or iterable, and heapq definitely says list in 3.3, which implies that the same is true in 2.7.If you track down into the code, if you have the C implementation, in _heapqmodule.c, heapify explicitly calls PyList_Check to verify that the type is a real list rather than a list-like sequence. This won't catch subclasses of list, but you can see that it directly calls PyList_GETSIZE and (within _siftup)  PyList_GET_ITEM and PyList_SET_ITEM, so it will treat a list subclass as a base list object. (And this isn't changed as of the current trunk.)So, there are a few ways around this.First, as @FogleBird suggests, you can just fork the pure-Python implementation of heapq—just copy the exact same thing into your project, give it a different name, and remove the from _heapq import * bit at lines 318-321.However, this may be a whole lot slower.Switching from CPython to PyPy may solve that automatically (and it also means you'll get the pure Python implementation whether you want it or not).In fact, I ran a quick test with a 1,000,000-item list. After verifying that PyPy actually does use the List2 class, I modified it so that, instead of printing, it stores a string into a global variable. (Otherwise, the printing took 3x longer than the actual work on Mac, 40x longer on Windows…) Then I ran it with various different Pythons:CPython 2.7.2 64-bit Mac: 2.079sCPython 3.3.0 64-bit Mac: 1.997sCPython 3.3.0 32-bit Mac: 2.197sPyPy 2.7.2/1.9.0 64-bit Mac: 1.619sCPython 2.7.3 32-bit Win: 3.997sPyPy 2.7.21.9.0 32-bit Win: 2.334sSo, PyPy blew away everything else, despite actually calling my Python list overrides. (I didn't test Jython or IronPython—partly because the startup and warmup time of the JVM or .NET are so long that you need a much longer test for it to be at all fair… But they must also use the pure Python heapq module.)But that may be a more dramatic change than you want to make. The other alternative is to fork _heapqmodule.c as well. Even if you don't know the C API at all, this is really just a search-and-replace job. For each PyList_FOO function, replace it with the corresponding PySequence_Foo function (PyList_SIZE -> PySequence_Size, PyList_GETITEM -> PySequence->GetItem, etc.). And replace the module name both places it appears. That's it. Then build the module, and have your fork myheapq.py try to import _myheapq instead of import _heapq. This will still not be quite as fast as the built-in implementation, but only because it will be calling your __getitem__ and __setitem__ methods a bunch of times, which is exactly what you want.
heapq uses C implementation if _heapq is available.When you copied heapq module to your local package, _heapq cannot be found, and the Python implementation get used, which indeed uses __setitem__ and __getitem__ as you can find statements like heap[pos] = heap[childpos] in _siftup.
heapq uses native code if available on your platform, which I assume is the problem although I don't fully grok the reason why.Perhaps you can take a different approach, and track the original indicies of the list items.Then you can extract the values and indicies after heapify...Edit: I tried to "trick" heapq by providing a instance of a class not derived from list. It did not work, it requires lists, presumably because the native code uses that as an assumption for performance reasons.Edit 2: Note this code in heapq.py. This overrides the Python implementations.Edit 3: The Python documentation discusses your root issue. Namely, "if a pending task needs to be deleted, how do you find it and remove it from the queue?"http://docs.python.org/2/library/heapq.html#priority-queue-implementation-notesThe idea is to simply mark entries as removed. When you see these items at the top of your priority queue, you ignore them. The documentation has sample code.


Answer URL
