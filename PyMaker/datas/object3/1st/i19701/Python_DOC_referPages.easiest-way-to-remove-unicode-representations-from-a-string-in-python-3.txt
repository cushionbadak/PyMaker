Natural Text
I have a string in python 3 that has several unicode representations in it, for example:and I want to convert t so that it has the proper representation when I print it, ie:However I just get the original string back. I've tried re.sub and some others, but I can't seem to find a way that will change these characters without having to iterate over each one.What would be the easiest way to do so?
You want to use the built-in codec unicode_escape.If t is already a bytes (an 8-bit string), it's as simple as this:If t has already been decoded to Unicode, you can to encode it back to a bytes and then decode it this way. If you're sure that all of your Unicode characters have been escaped, it actually doesn't matter what codec you use to do the encode. Otherwise, you could try to get your original byte string back, but it's simpler, and probably safer, to just force any non-encoded characters to get encoded, and then they'll get decoded along with the already-encoded ones:In case you want to know how to do this kind of thing with regular expressions in the future, note that sub lets you pass a function instead of a pattern for the repl. And you can convert any hex string into an integer by calling int(hexstring, 16), and any integer into the corresponding Unicode character with chr (note that this is the one bit that's different in Python 2—you need unichr instead). So:Or, making it a bit more clear:The unicode_escape codec actually handles \U, \x, \X, octal (\066), and special-character (\n) sequences as well as just \u, and it implements the proper rules for reading only the appropriate max number of digits (4 for \u, 8 for \U, etc., so r'\\u22222' decodes to '∢2' rather than '𢈢'), and probably more things I haven't thought of. But this should give you the idea.
First of all, it is rather confused what you what to convert to.Just imagine that you may want to convert to 'o' and 'i'. In this case you can just make a map:Than you may apply the replacement like:
I apologize for posting as a second answer, I don't have the reputation to comment on abarnert's solution.After using his function to process approximately 50K android strings I noticed that there is yet another small improvement possible for certain use-cases.I changed the + to {1,4} to deal with the case where valid hex characters follow a 4-digit escape. I also changed int(escapesequence) to read int(digits)


Answer URL
