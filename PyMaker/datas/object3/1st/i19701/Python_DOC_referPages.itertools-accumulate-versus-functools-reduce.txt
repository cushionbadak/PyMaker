Natural Text
In Python 3.3, itertools.accumulate(), which normally repeatedly applies an addition operation to the supplied iterable, can now take a function argument as a parameter; this means it now overlaps with functools.reduce(). With a cursory look, the main differences between the two now would seem to be:accumulate() defaults to summing but doesn't let you supply an extra initial condition explicitly while reduce() doesn't default to any method but does let you supply an initial condition for use with 1/0-element sequences, andaccumulate() takes the iterable first while reduce() takes the function first.Are there any other differences between the two? Or is this just a matter of behavior of two functions with initially distinct uses beginning to converge over time?
It seems that accumulate keeps the previous results, whereas reduce (which is known as fold in other languages) does not necessarily.e.g. list(accumulate([1,2,3], operator.plus)) would return [1,3,6] whereas a plain fold would return 6Also (just for fun, don't do this) you can define accumulate in terms of reduce
You can see in the documentation what the difference is.  reduce returns a single result, the sum, product, etc., of the sequence.  accumulate returns an iterator over all the intermediate results.  Basically, accumulate returns an iterator over the results of each step of the reduce operation.
itertools.accumulate is like reduce but returns a generator* instead of a value. This generator can give you all the intermediate step values. So basically reduce gives you the last element of what accumulate will give you. *A generator is like an iterator but can be iterated over only once. 


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.accumulate
