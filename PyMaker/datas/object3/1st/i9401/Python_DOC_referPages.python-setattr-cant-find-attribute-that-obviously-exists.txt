Natural Text
I'm at my wits end.Can't find anything else that helps with this.>>>{'content': '', 'type': ''}>>>AttributeError: 'dict' object has no attribute 'type'
Python's dictionaries aren't JS objects. When you create a dict, you aren't creating a dynamic object whose properties you can change at runtime as in JS. Instead the dictionary knows how to store pairs of keys and values and does so by overriding the operator [] (def __getitem__(self, key)).On a more implementation level - calling getattr / setattr is really a shorthand for data.__getattr__("foo") and since dict uses __getitem__ as opposed to __getattr__ the function call fails.Thus, there's no way to set (or get for that matter) the dict's items using generic attribute functions.However, you can create your custom dict class that does support that operation (although I wouldn't recommend it):
You can assign dict values directly, setattr() is not needed.
'setattr()' refers to something else. When you write setattr(dta, 'type', "Steve") you're trying to access the field dta.type, dict class has no attribute type, so it gives an error.dict_object['key'] is a completely different thing, and it's how dict members should be accessed.More about settatr() Here
Dictionaries are subscriptable, the key:value pairs are items instead of attributes. Items are accessed using a subscript notation:Attributes are accessed using dot notationoperator.itemgetter is similar to getattr:
setattr does not work with a dictionary because it does not have an __dict__.  I can make a simple class and instance:setattr sets an item in the __dict__ of obj, and the resulting attribute can be accessed with .test syntax.But a dict object does not have a __dict__.I add items to the dict with the dictionary indexing notation:The dictionary class inherits from object, but in way that does not give each instance a __dict__.  Thus setattr has nothing to act on.If for some reason the []= syntax is awkward, you can use operator.setitem as a function:Or use the __setitem__ methodActually, a dictionary does have attributes.  For example its .get method can be fetched with getattr.  setattr returns a different error in this example.Without the __dict__ we can't add an attribute to a dictionary.  And many, if not all, of the existing attributes are read only.  I don't know if a dictionary has an attributes that can be changed.Actually a dictionary is an object:I just imported defaultdict.  It too lacks a __dict__.  But I was able to use setattr(ddd,'default_factory', int).  I think that no attribute is the correct error message when the attribute does not already exist, and it cannot add new ones.==============I'd have to double check the documentation on this, but I think setattr(dd,...) delegates to dd.__setattr__(...).So the error message is determined by the dict class, not setattr.Even instances that have a __dict_- might raise errors if setattr is used wrong.  For example a number is not a valid attribute name:But setattr can set attributes that can't be accessed with the . syntax:vars() is another way of accessing the __dict__ of an instance:
docs.python.org/2/library/functions.html#setattrThis is the counterpart of getattr(). The arguments are an object,  a string and an arbitrary value. The string may name an existing  attribute or a new attribute. The function assigns the value to the  attribute, provided the object allows itOBJECT is not a DICTIONARY. And I probably confusing my JS work (syntax) with the Python code I'm always writing at the same timeSo the error message is confusing:AttributeError: 'dict' object has no attribute 'type'It should be more like:'setattr() is for objects not dictionaries'.Thanks everyone.


Answer URL
https://docs.python.org/3/reference/expressions.html?highlight=subscriptable#subscriptions
https://docs.python.org/3/reference/expressions.html#attribute-references
