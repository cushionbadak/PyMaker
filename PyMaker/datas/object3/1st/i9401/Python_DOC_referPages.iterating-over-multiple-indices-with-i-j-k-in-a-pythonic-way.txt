Natural Text
i need to iterate over a tuple of indices. all indices must be in the range[0, N) with the condition i > j. The toy example I present here deals withonly two indices; I will need to extend that to three (with i > j > k) or more.The basic version is this:and it works just fine; the output isI don't want to have one more indentation level for every additional index,therefore I prefer this version:this works perfectly well, does what it should and gets rid of the extraindentation level.I was hoping to be able to have something more elegant (for two indices that isnot all that relevant, but for three or more it becomes more relevant). What I came up with so far is this:This iterates over the same pair of indices just fine. The only thing that isdifferent is the order in which the pairs appear:As the order of what I am doing with these indices is relevant, I therefore cannot use this.Is there an elegant, short, pythonic way to iterate over these indices in the same order that the very first example produces? Keep in mind that N will be large, so sorting is not something I would want to do.
You could solve this generally as follows:In use:
Here's an approach with itertools.combinations to have a generic number of levels -Or a bit twisted one with same method -, where N : number of elements and M : number of levels.Sample run -
You can use product from itertools if you don't mind the inefficiency of throwing out most of the generated tuples. (The inefficiency gets worse as the repeat parameter increases.)Update: Instead of tuple unpacking, using indexing for the filter. This allows the code to be written a little more compactly. Only my_filter needs to be changed for tuples of varying sizes.
This is an approach based on the observation that it is easier to generate the negatives of the indices in the (reverse of) the desired order It is similar to the approach of @Divakar and like that has the drawback of requiring the list to be created in memory:
a somewhat 'hacky' attempt using eval (just adding this for completeness. there are nicer answers here!). the idea is to construct a string likeand return the eval of that:can be used this way and produces the right results.the construction is not very nice - but the result is: it is a regular genexpr and just as efficient as those are.


Answer URL
https://docs.python.org/3/whatsnew/3.3.html#pep-380
