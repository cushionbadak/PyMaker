Natural Text
I'd like to have implement an update method in my class that recreates the class but changes just one constructor argument.My attempt:The problem is, the whole locals() thing, I think, is pretty dodgy, and it means that any class that is Updateable needs to assign self._vars.What would be the correct way to achieve this functionality?  Decorators, metaclasses?  Something simpler?
Please correct me if I misunderstood your question, or if you don't want high level advise and your just question solved.What your __init__ currently does is recalculate the properties of a geometric shape if a (possibly relevant) variable is changed. Step 1 is to take this out of the __init__, and into a seperate def which is called by init. The main thing here is that you do not pass variables to this function, but use the class variables which have been set in either __init__ or one the superclass updating methods.Step 2 is to change your update function.Python has a form of getters and setters called properties allowing you to hook tasks to updating your variables. On the other hand a more generalized way is more similar to your own update, and is listed as option 2 belowExample alternative
Laurens Koppenol suggested using properties (Python's generic support for computed attribute) which is a good idea but his example code is both broken in many ways and more complicated than it has to be, so here's a simpler, working and pythonic example (no Updatable class nor any other extraneous stuff required):If you want to cache the width value (to avoid useless computations) but still make sure it's updated when length or perimeter change, you'll need to make them all properties:or (if you have a lot of such stuff) use some "cached_property with invalidation" implementation as this one: Storing calculated values in an objectedit: wrt/ your question, the call to locals is indeed ugly (and can easily break - you may have local variables that are not supposed to be parts of _vars), as well as the need to explicitely set self._vars in child classes. Also the update() API is itself quite ugly IMHO. Now you don't need anything fancy to make the whole thing more pythonic - here's a solution whose only boilerplate is the need to call Updateable.__init__ with named arguments (won't work with positional ones):As a side note, I personnaly find quite disturbing that your Rectangle class takes a perimeter argument but stores a width instead... Maybe you should consider a perimeter property ? (even if read-only to avoid recomputing etc)
As others have observed, computations like width should be moved to a property or method; they don't belong in an initialiser.If you really want to return a new instance, this would work for the simplest cases, where the instance's attributes are immutable objects like strings or integers:however if your objects contain nested mutable structures such as dictionaries or lists you would need to change copy_and_modify to use copy.deepcopy (but note deep copying is slow)You can define __copy__ and __deepcopy__ methods in your subclasses as described in the docs to fine-tune control over the copying process.


Answer URL
https://docs.python.org/3/library/copy.html
