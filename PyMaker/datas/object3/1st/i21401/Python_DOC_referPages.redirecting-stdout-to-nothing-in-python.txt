Natural Text
I have a large project consisting of sufficiently large number of modules, each printing something to the standard output. Now as the project has grown in size, there are large no. of print statements printing a lot on the std out which has made the program considerably slower.So, I now want to decide at runtime whether or not to print anything to the stdout. I cannot make changes in the modules as there are plenty of them. (I know I can redirect the stdout to a file but even this is considerably slow.)  So my question is how do I redirect the stdout to nothing ie how do I make the print statement do nothing?Currently the only idea I have is to make a class which has a write method (which does nothing) and redirect the stdout to an instance of this class.Is there an inbuilt mechanism in python for this? Or is there something better than this?
Cross-platform:On Windows:On Linux:
A nice way to do this is to create a small context processor that you wrap your prints in. You then just use is in a with-statement to silence all output.Running this code only prints the second line of output, not the first:This works cross-platform (Windows + Linux + Mac OSX), and is cleaner than the ones other answers imho.
(at least on my system) it appears that writing to os.devnull is about 5x faster than writing to a DontPrint class, i.e.gave the following output:
If you're in python 3.4 or higher, there's a simple and safe solution using the standard library:
If you're in a Unix environment (Linux included), you can redirect output to /dev/null:And for Windows:
How about this:This uses the features in the contextlib module to hide the output of whatever command you are trying to run, depending on the result of should_hide_output(), and then restores the output behavior after that function is done running.If you want to hide standard error output, then import redirect_stderr from contextlib and add a line saying stack.enter_context(redirect_stderr(null_stream)).The main downside it that this only works in Python 3.4 and later versions.
Your class will work just fine (with the exception of the write() method name -- it needs to be called write(), lowercase). Just make sure you save a copy of sys.stdout in another variable.If you're on a *NIX, you can do sys.stdout = open('/dev/null'), but this is less portable than rolling your own class.
You can just mock it.
Why don't you try this?
It is OK for print() case. But it can cause an error if you call any method of sys.stdout, e.g. sys.stdout.write().There is a note in docs:Under some conditions stdin, stdout and stderr as well as the original  values stdin, stdout and stderr can be None. It is usually  the case for Windows GUI apps that arenâ€™t connected to a console and  Python apps started with pythonw.


Answer URL
https://docs.python.org/3/library/sys.html#sys.__stderr__
