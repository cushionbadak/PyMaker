Natural Text
I know that Python does not support method overloading, but I've run into a problem that I can't seem to solve in a nice Pythonic way.I am making a game where a character needs to shoot a variety of bullets, but how do I write different functions for creating these bullets? For example suppose I have a function that creates a bullet travelling from point A to B with a given speed. I would write a function like this:But I want to write other functions for creating bullets like:And so on with many variations. Is there a better way to do it without using so many keyword arguments cause its getting kinda ugly fast. Renaming each function is pretty bad too because you get either add_bullet1, add_bullet2, or add_bullet_with_really_long_name.To address some answers:No I can't create a Bullet class hierarchy because thats too slow. The actual code for managing bullets is in C and my functions are wrappers around C API.I know about the keyword arguments but checking for all sorts of combinations of parameters is getting annoying, but default arguments help allot like acceleration=0
Python does support "method overloading" as you present it. In fact, what you just describe is trivial to implement in Python, in so many different ways, but I would go with:In the above code, default is a plausible default value for those arguments, or None. You can then call the method with only the arguments you are interested in, and Python will use the default values. You could also do something like this:Another alternative is to directly hook the desired function directly to the class or instance:Yet another way is to use an abstract factory pattern:
What you are asking for, is called multiple dispatch. See Julia language examples which demonstrates different types of dispatches.However, before looking at that, we'll first tackle why overloading is not really what you want in python.Why Not Overloading?First one needs to understand the concept of overloading and why it's not applicable to python.When working with languages that can discriminate data types at  compile-time, selecting among the alternatives can occur at  compile-time. The act of creating such alternative functions for  compile-time selection is usually referred to as overloading a  function. (Wikipedia)Python is a dynamically typed language, so the concept of overloading simply does not apply to it. However, all is not lost, since we can create such alternative functions at run-time:In programming languages that defer data type identification until  run-time the selection among alternative  functions must occur at run-time, based on the dynamically determined  types of function arguments. Functions whose alternative  implementations are selected in this manner are referred to most  generally as multimethods. (Wikipedia)So we should be able to do multimethods in python or, as it is alternatively called, multiple dispatch.Multiple dispatchThe multimethods are also called multiple dispatch:Multiple dispatch or multimethods is the feature of some  object-oriented programming languages in which a function or method  can be dynamically dispatched based on the run time (dynamic) type of  more than one of its arguments. (Wikipedia)Python does not support this out of the box1. But, as it happens, there is an excellent python package called multipledispatch that does exactly that. SolutionHere is how we might use multipledispatch2 package to implement your methods:1. Python 3 currently supports single dispatch2. Take care not to use  multipledispatch in a multi-threaded environment, or you will get weird behavior.
You can use "roll-your-own" solution for function overloading. This one is copied from Guido van Rossum's article about multimethods (because there is little difference between mm and overloading in python):The usage would beMost restrictive limitations at the moment are:methods are not supported, only functions that are not class members;inheritance is not handled;kwargs are not supported;registering new functions should be done at import time thing is not thread-safe
A possible option is to use the multipledispatch module as detailed here:http://matthewrocklin.com/blog/work/2014/02/25/Multiple-DispatchInstead of doing this:You can do this:With the resulting usage:
In Python 3.4 was added PEP-0443. Single-dispatch generic functions.Here is short API description from PEP.To define a generic function, decorate it with the @singledispatch decorator. Note that the dispatch happens on the type of the first argument. Create your function accordingly:To add overloaded implementations to the function, use the register() attribute of the generic function. This is a decorator, taking a type parameter and decorating a function implementing the operation for that type:
This type of behaviour is typically solved (in OOP languages) using Polymorphism. Each type of bullet would be responsible for knowing how it travels. For instance:Pass as many arguments to the c_function that exist, then do the job of determining which c function to call based on the values in the initial c function. So, python should only ever be calling the one c function. That one c function looks at the arguments, and then can delegate to other c functions appropriately.You're essentially just using each subclass as a different data container, but by defining all the potential arguments on the base class, the subclasses are free to ignore the ones they do nothing with.When a new type of bullet comes along, you can simply define one more property on the base, change the one python function so that it passes the extra property, and the one c_function that examines the arguments and delegates appropriately. Doesn't sound too bad I guess.
By passing keyword args.
I think your basic requirement is to have a C/C++ like syntax in python with the least headache possible.  Although I liked Alexander Poluektov's answer it doesn't work for classes.  The following should work for classes.  It works by distinguishing by the number of non keyword arguments (but doesn't support distinguishing by type):And it can be used simply like this:Output:This is overload 3    Sprite: I'm a Sprite    Start: 0    Direction: Right  This is overload 2    Sprite: I'm another Sprite    Script:    while x == True: print 'hi'  
Either use multiple keyword arguments in the definition, or create a Bullet hierarchy whose instances are passed to the function.
I think a Bullet class hierarchy with the associated polymorphism is the way to go. You can effectively overload the base class constructor by using a metaclass so that calling the base class results in the creation of the appropriate subclass object. Below is some sample code to illustrate the essence of what I mean.UpdatedThe code has been modified to run under both Python 2 and 3 to keep it relevant. This was done in a way that avoids the use Python's explicit metaclass syntax, which varies between the two versions. To accomplish that objective, a BulletMetaBase instance of the BulletMeta class is created by explicitly calling the metaclass when creating the Bullet baseclass (rather than using the __metaclass__= class attribute or via a metaclass keyword argument depending on the Python version).Output:
Use keyword arguments with defaults. E.g.In the case of a straight bullet versus a curved bullet, I'd add two functions: add_bullet_straight and add_bullet_curved.
The @overload decorator was added with type hints (PEP 484). While this doesn't change the behaviour of python, it does make it easier to understand what is going on, and for mypy to detect errors.See: Type hints and PEP 484
overloading methods is tricky in python. However, there could be usage of passing the dict, list or primitive variables.I have tried something for my use cases, this could help here to understand people to overload the methods.Let's take your example:a class overload method with call the methods from different class.pass the arguments from remote class:OR So, handling is being achieved for list, Dictionary or primitive variables from method overloading.try it out for your codes.


Answer URL
https://docs.python.org/3/library/functools.html#functools.singledispatch
https://docs.python.org/3/library/typing.html#typing.overload
https://docs.python.org/3/library/functools.html#functools.singledispatch
