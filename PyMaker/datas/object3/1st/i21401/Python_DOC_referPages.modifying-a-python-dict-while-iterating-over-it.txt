Natural Text
Let's say we have a Python dictionary d, and we're iterating over it like so:(f and g are just some black-box transformations.)In other words, we try to add/remove items to d while iterating over it using iteritems.Is this well defined? Could you provide some references to support your answer?(It's pretty obvious how to fix this if it's broken, so this isn't the angle I am after.)
It is explicitly mentioned on the Python doc page (for Python 2.7) thatUsing iteritems() while adding or deleting entries in the dictionary may raise a RuntimeError or fail to iterate over all entries.Similarly for Python 3.The same holds for iter(d), d.iterkeys() and d.itervalues(), and I'll go as far as saying that it does for for k, v in d.items(): (I can't remember exactly what for does, but I would not be surprised if the implementation called iter(d)).
Alex Martelli weighs in on this here.It may not be safe to change the container (e.g. dict) while looping over the container.So del d[f(k)] may not be safe. As you know, the workaround is to use d.items() (to loop over an independent copy of the container) instead of d.iteritems() (which uses the same underlying container).It is okay to modify the value at an existing index of the dict, but inserting values at new indices (e.g. d[g(k)]=v) may not work.
You cannot do that, at least with d.iteritems(). I tried it, and Python fails withIf you instead use d.items(), then it works.In Python 3, d.items() is a view into the dictionary, like d.iteritems() in Python 2. To do this in Python 3, instead use d.copy().items(). This will similarly allow us to iterate over a copy of the dictionary in order to avoid modifying the data structure we are iterating over.
The following code shows that this is not well defined:The first example calls g(k), and throws an exception (dictionary changed size during iteration).The second example calls h(k) and throws no exception, but outputs:Which, looking at the code, seems wrong - I would have expected something like:
I have a large dictionary containing Numpy arrays, so the dict.copy().keys() thing suggested by @murgatroid99 was not feasible (though it worked).  Instead, I just converted the keys_view to a list and it worked fine (in Python 3.4):I realize this doesn't dive into the philosophical realm of Python's inner workings like the answers above, but it does provide a practical solution to the stated problem.
I got the same problem  and I used following procedure to solve this issue.Python List can be iterate even if you modify during iterating over it.so for following code it will print 1's infinitely.So using list and dict collaboratively you can solve this problem.
Today I had a similar use-case, but instead of simply materializing the keys on the dictionary at the beginning of the loop, I wanted changes to the dict to affect the iteration of the dict, which was an ordered dict.I ended up building the following routine, which can also be found in jaraco.itertools:The docstring illustrates the usage. This function could be used in place of d.iteritems() above to have the desired effect.
Python 3 you should just:or use:You should never modify original dictionary, it leads to confusion as well as potential bugs or RunTimeErrors. Unless you just append to the dictionary with new key names.


Answer URL
https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects
