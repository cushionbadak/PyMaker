Natural Text
I have this try block in my code:Strictly speaking, I am actually raising another ValueError, not the ValueError thrown by do_something...(), which is referred to as err in this case. How do I attach a custom message to err? I try the following code but fails due to err, a ValueError instance, not being callable:
Update: For Python 3, check Ben's answerTo attach a message to the current exception and re-raise it:(the outer try/except is just to show the effect)For python 2.x where x>=6:This will also do the right thing if err is derived from ValueError. For example UnicodeDecodeError. Note that you can add whatever you like to err. For example err.problematic_array=[1,2,3].Edit: @Ducan points in a comment the above does not work with python 3 since .message is not a member of ValueError. Instead you could use this (valid python 2.6 or later or 3.x):Edit2:Depending on what the purpose is, you can also opt for adding the extra information under your own variable name. For both python2 and python3:
I realize this question has been around for awhile, but once you're lucky enough to only support python 3.x, this really becomes a thing of beauty :)raise fromWe can chain the exceptions using raise from.In this case, the exception your caller would catch has the line number of the place where we raise our exception.Notice the bottom exception only has the stacktrace from where we raised our exception. Your caller could still get the original exception by accessing the __cause__ attribute of the exception they catch.with_tracebackOr you can use with_traceback.Using this form, the exception your caller would catch has the traceback from where the original error occurred.Notice the bottom exception has the line where we performed the invalid division as well as the line where we reraise the exception.
prints:
It seems all the answers are adding info to e.args[0], thereby altering the existing error message.  Is there a downside to extending the args tuple instead?  I think the possible upside is, you can leave the original error message alone for cases where parsing that string is needed; and you could add multiple elements to the tuple if your custom error handling produced several messages or error codes, for cases where the traceback would be parsed programmatically (like via a system monitoring tool).orCan you see a downside to this approach?
This code template should allow you to raise an exception with a custom message.
This is the function I use to modify the exception message in Python 2.7 and 3.x while preserving the original traceback. It requires six
Python 3 built-in exceptions have the strerror field:
Either raise the new exception with your error message usingorwithin the place where you want to raise it OR attach (replace) error message into current exception using 'from':
The current answer did not work good for me, if the exception is not re-caught the appended message is not shown.But doing like below both keeps the trace and shows the appended message regardless if the exception is re-caught or not.( I used Python 2.7, have not tried it in Python 3 )
if you want to custom the error type, a simple thing you can do is to define an error class based on ValueError.


Answer URL
https://docs.python.org/3/reference/simple_stmts.html#raise
https://docs.python.org/3/library/exceptions.html#BaseException.with_traceback
