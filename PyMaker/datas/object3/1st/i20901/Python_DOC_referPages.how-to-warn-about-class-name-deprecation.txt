Natural Text
I have renamed a python class that is part of a library. I am willing to leave a possibility to use its previous name for some time but would like to warn user that it's deprecated and will be removed in the future.I think that to provide backward compatibility it will be enough to use an alias like that:I have no idea how to mark the OldClsName as deprecated in an elegant way. Maybe I could make OldClsName a function which emits a warning (to logs) and constructs the NewClsName object from its parameters (using *args and **kvargs) but it doesn't seem elegant enough (or maybe it is?).However, I don't know how Python standard library deprecation warnings work. I imagine that there may be some nice magic to deal with deprecation, e.g. allowing treating it as errors or silencing depending on some interpreter's command line option.The question is: How to warn users about using an obsolete class alias (or obsolete class in general).EDIT: The function approach doesn't work for me (I already gave it a try) because the class has some class methods (factory methods) which can't be called when the OldClsName is defined as a function. Following code won't work:Because of:Is inheritance my only option? To be honest, it doesn't look very clean to me - it affects class hierarchy through introduction of unnecessary derivation. Additionally, OldClsName is not NewClsName what is not an issue in most cases but may be a problem in case of poorly written code using the library.I could also create a dummy, unrelated OldClsName class and implement a constructor as well as wrappers for all class methods in it, but it is even worse solution, in my opinion.
Maybe I could make OldClsName a function which emits a warning (to  logs) and constructs the NewClsName object from its parameters (using  *args and **kvargs) but it doesn't seem elegant enough (or maybe it is?).Yup, I think that's pretty standard practice:The only tricky thing is if you have things that subclass from OldClsName - then we have to get clever. If you just need to keep access to class methods, this should do it:I haven't tested it, but that should give you the idea - __call__ will handle the normal-instantation route, __getattr__ will capture accesses to the class methods & still generate the warning, without messing with your class heirarchy.
Please have a look at warnings.warn.As you'll see, the example in the documentation is a deprecation warning:
Why don't you just sub-class? This way no user code should be broken.
Use inspect module to add placeholder for OldClass, then OldClsName is NewClsName check will pass, and a linter like pylint will inform this as error.deprecate.pytest.pythen run python -W all test.py:
Here is the list of requirements a solution should satisfy:Instantiation of a deprecated class should raise a warningSubclassing of a deprecated class should raise a warningSupport isinstance and issubclass checksSolutionThis can be achieved with a custom metaclass:ExplanationDeprecatedClassMeta.__new__ method is called not only for a class it is a metaclass of but also for every subclass of this class. That gives an opportunity to ensure that no instance of DeprecatedClass will ever be instantiated or subclassed.Instantiation is simple. The metaclass overrides the __new__ method of DeprecatedClass to always return an instance of NewClass.Subclassing is not much harder. DeprecatedClassMeta.__new__ receives a list of base classes and needs to replace instances of DeprecatedClass with NewClass.Finally, the isinstance and issubclass checks are implemented via __instancecheck__ and __subclasscheck__ defined in PEP 3119.Test
In python >= 3.6 you can easily handle warning on subclassing:Overloading __new__ should allow you to warn when the old class constructor is called directly, but I haven't tested that since I don't need it right now.
Since Python 3.7, you can provide a customization of module attribute access using __getattr__ (and __dir__). Everything is explained in PEP 562.In the bellow example, I implemented __getattr__ and __dir__ in order to deprecate the “OldClsName” in favor of “NewClsNam”:In the __getattr__ function, if a deprecated class or function name is found, a warning message is emitted, showing the source file and line number of the caller (with stacklevel=2).In the user code, we could have:When the user run his script your_lib_usage.py, it will get something like this:Note: the stack trace is usually written in STDERR.To see the error warnings, you may need to add a “-W” flag in the Python command line, for instance:


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__new__
