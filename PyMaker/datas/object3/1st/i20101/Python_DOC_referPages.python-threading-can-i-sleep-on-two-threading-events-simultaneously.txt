Natural Text
If I have two threading.Event() objects, and wish to sleep until either one of them is set, is there an efficient way to do that in python?  Clearly I could do something with polling/timeouts, but I would like to really have the thread sleep until one is set, akin to how select is used for file descriptors.So in the following implementation, what would an efficient non-polling implementation of wait_for_either look like?
Here is a non-polling non-excessive thread solution: modify the existing Events to fire a callback whenever they change, and handle setting a new event in that callback:Sample usage:The result of which was:This should be thread-safe. Any comments are welcome.EDIT: Oh and here is your wait_for_either function, though the way I wrote the code, it's best to make and pass around an or_event. Note that the or_event shouldn't be set or cleared manually.
One solution (with polling) would be to do sequential waits on each Event in a loopI think that if you tune the timeout well enough the results would be OK.The best non-polling I can think of is to wait for each one in a different thread and set a shared Event whom you will wait after in the main thread.Pretty interesting, so I wrote an OOP version of the previous solution:
Starting extra threads seems a clear solution, not very effecient though.Function wait_events will block util any one of events is set.
Extending Claudiu's answer where you can either wait for:event 1 OR event 2event 1 AND even 2Example usage will be very similar as before
This is an old question, but I hope this helps someone coming from Google.The accepted answer is fairly old and will cause an infinite loop for twice-"orified" events.  Here is an implementation using concurrent.futuresTesting the function
Not pretty, but you can use two additional threads to multiplex the events...Note, you may have to worry about accidentally getting both events if they arrive too quickly. The helper threads (a_thread and b_thread) should lock synchronize around trying to set flag and then should kill the other thread (possibly resetting that thread's event if it was consumed). 

I think the standard library provides a pretty canonical solution to this problem that I don't see brought up in this question: condition variables. You have your main thread wait on a condition variable, and poll the set of events each time it is notified. It is only notified when one of the events is updated, so there is no wasteful polling. Here is a Python 3 example:Example output:Note that wit no extra threads or unnecessary polling, you can wait for an arbitrary predicate to become true (e.g. for any particular subset of the events to be set). There's also a wait_for wrapper for the while (pred): cond.wait() pattern, which can make your code a bit easier to read.


Answer URL
https://docs.python.org/3/library/threading.html#threading.Condition
