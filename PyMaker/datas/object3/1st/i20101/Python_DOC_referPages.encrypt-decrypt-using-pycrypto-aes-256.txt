Natural Text
I'm trying to build two functions using PyCrypto that accept two parameters: the message and the key, and then encrypt/decrypt the message.I found several links on the web to help me out, but each one of them has flaws:This one at codekoala uses os.urandom, which is discouraged by PyCrypto.Moreover, the key I give to the function is not guaranteed to have the exact length expected. What can I do to make that happen ?Also, there are several modes, which one is recommended? I don't know what to use :/Finally, what exactly is the IV? Can I provide a different IV for encrypting and decrypting, or will this return in a different result?Here's what I've done so far:
Here is my implementation and works for me with some fixes and enhances the alignment of the key and secret phrase with 32 bytes and iv to 16 bytes:
You may need the following two functions to pad(when do encryption) and unpad(when do decryption) when the length of input is not a multiple of BLOCK_SIZE.So you're asking the length of key? You can use the md5sum of the key rather than use it directly.More, according to my little experience of using PyCrypto, the IV is used to mix up the output of a encryption when input is same, so the IV is chosen as a random string, and use it as part of the encryption output, and then use it to decrypt the message.And here's my implementation, hope it will be useful for you:
Let me address your question about "modes." AES256 is a kind of block cipher. It takes as input a 32-byte key and a 16-byte string, called the block and outputs a block. We use AES in a mode of operation in order to encrypt. The solutions above suggest using CBC, which is one example. Another is called CTR, and it's somewhat easier to use:This is often referred to as AES-CTR. I would advise caution in using AES-CBC with PyCrypto. The reason is that it requires you to specify the padding scheme, as exemplified by the other solutions given. In general, if you're not very careful about the padding, there are attacks that completely break encryption! Now, it's important to note that the key must be a random, 32-byte string; a password does not suffice. Normally, the key is generated like so:A key may be derived from a password, too:Some solutions above suggest using SHA256 for deriving the key, but this is generally considered bad cryptographic practice.Check out wikipedia for more on modes of operation.
You can get a passphrase out of an arbitrary password by using a cryptographic hash function (NOT Python's builtin hash) like SHA-1 or SHA-256. Python includes support for both in its standard library:You can truncate a cryptographic hash value just by using [:16] or [:24] and it will retain its security up to the length you specify.
For someone who would like to use urlsafe_b64encode and urlsafe_b64decode, here are the version that're working for me (after spending some time with the unicode issue)
For the benefit of others, here is my decryption implementation which I got to by combining the answers of @Cyril and @Marcus.  This assumes that this coming in via HTTP Request with the encryptedText quoted and base64 encoded.
It's little late but i think this will be very helpful. No one mention about use  scheme like PKCS#7 padding. You can use it instead the previous functions to pad(when do encryption) and unpad(when do decryption).i will provide the full Source Code below.
Another take on this (heavily derived from solutions above) butuses null for padding does not use lambda (never been a fan)tested with python 2.7 and 3.6.5
Grateful for the other answers which inspired but didn't work for me.  After spending hours trying to figure out how it works, I came up with the implementation below with the newest PyCryptodomex library (it is another story how I managed to set it up behind proxy, on Windows, in a virtualenv.. phew)  Working on your implementation, remember to write down padding, encoding, encrypting steps (and vice versa). You have to pack and unpack keeping in mind the order.



Answer URL
