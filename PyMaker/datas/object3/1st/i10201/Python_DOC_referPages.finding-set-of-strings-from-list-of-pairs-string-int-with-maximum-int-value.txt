Natural Text
I have a list of (str,int) pairs list_word = [('AND', 1), ('BECAUSE', 1), ('OF', 1), ('AFRIAD', 1), ('NEVER', 1), ('CATS', 2), ('ARE', 2), ('FRIENDS', 1), ('DOGS', 2)]This basically says how many times each word showed up in a text. What I want to get is the set of words with maximum occurrence along with maximum occurrence number. So, in the above example, I want to get(set(['CATS', 'DOGS','ARE']), 2)The solution I can think of is looping through the list. But is there any elegant way of doing this?
Two linear scans, first to find the maximal element:then a second to pull out the values you care about:If you needed to get the sets for more than just the maximal count, you can use collections.defaultdict to accumulate by count in a single pass:Which can then be followed by allcounts = sorted(sets_by_count.items(), key=itemgetter(0), reverse=True) to get a list of count, set pairs, from highest to lowest count (with minimal sorting work, since it's sorting only a number of items equal to the unique counts, not all words).
Convert list to dict with key as count and value as set of words. Find the max value of key, and it;s corresponding value
While the more pythonic solutions are certainly easier on the eye, unfortunately the requirement for two scans, or building data-structures you don't really want is significantly slower.The following fairly boring solution is about ~55% faster than the dict solution, and ~70% faster than the comprehension based solutions based on the provided example data (and my implementations, machine, benchmarking etc.)This almost certainly down to the single scan here rather than two.To be fair, they are all blazing fast and in your case readability might be more important.


Answer URL
https://docs.python.org/3/library/collections.html#collections.defaultdict
