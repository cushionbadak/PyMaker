Natural Text
I have a variable PyObject that I know is a Python bool. It either is True or False (eg. Py_True or Py_False). Now I would like to convert it to C++ somehow.Doing this with strings isn't so hard, there is a helper function for that - PyBytes_AsString that converts python string into C string. Now I need something like that for boolean (or int as there is no bool in C).Or if there isn't conversion, maybe some function that can compare with true or false? Something like int PyBool_IsTrue(PyObject*)?Here is some example code for easier understanding of what I need:This obviously wouldn't work as there is no such function like PyBool_IsTrue :( how can I do that?Snippet of Python header (boolobject.h):
Every Python object can have its truthiness evaluated with PyObject_IsTrue, and you should use this in preference to direct PyTrue/PyFalse singleton checking unless you absolutely know, for certain, that the object is a PyBool.Usage is:You can just test someobj == Py_True if you know it's definitely a bool, or use PyNumber_AsSsize_t to convert any logical integer type (anything implementing __index__, and bool is a subclass of int, so it's also logically an integer) to a signed size_t value (if __index__ returns a number that doesn't fit in signed size_t, it will return -1 with exception set).The reason not to do someobj == Py_True in general is because it's like doing if someobj is True: at the Python layer. If someobj is 1, or an non-empty str, that will treat it as false, when Pythonic code is rarely concerned about being True or False, but rather, "truthiness" and "falsiness".In addition, this:is flat wrong. That will incref PyTrue and return it; none of the subsequent code will execute. You'd want:for a borrowed reference, adding a subsequent:to make it an owned reference if you intended to return it later (since it's a singleton that won't go away, using a borrowed reference is fine unless you know it will be DECREFed later, e.g. because you returned it and passed ownership to a caller who can't know it's a borrowed reference).
The answer is in Python headers but may not be obvious.Python headers declare 2 somewhat static objects here, with couple of macros:It seems that both True and False are in fact Python objects and all values in Python that are True or False are in fact references to these two global Py_True and Py_False objects. When such object is returned using Py_RETURN_TRUE, the reference count is incremented.This means that every C pointer that points to PyObject of value Py_True in fact points to same memory address. Therefore checking if PyObject is true or false is as simple as:It's generally good idea to use int PyBool_Check(PyObject*) to verify if object in question is Python boolean.


Answer URL
https://docs.python.org/3/c-api/object.html#c.PyObject_IsTrue
https://docs.python.org/3/c-api/number.html#c.PyNumber_AsSsize_t
