Natural Text
I am very very new to Python 3, so please be nice.I have looked at all the documentation I could find regarding this - there does seem to be a lot, it's just I still cannot figure out what to do.This is my code:It is running without any errors but I am getting a return of:generator object perimeter.locals.genexpr at 0x7f47d8671c50How do I make it so that it gives me the value/answer?I am really not sure what is going on.
Wrapping an item for item in iterable construct in parentheses makes it a lazy generator expression, which has the appearance you see. Now, the reason it does this instead of giving you an error that you would get from trying to send a non-iterable to sum() is because it doesn't evaluate anything. If you sent this generator expression to list() to evaluate it, you would get an error.You need to move some parentheses around:Now you have sum(expression for element in parts1(poly)) rather than (sum(expression) for element in parts1(poly)).Small test:
The first problem is that you have your parentheses in the wrong places. You want to call sum() on a generator expression, but instead you have written a generator expression using sum(). So you might try this:(I have also taken out your abs() calls, since squaring a number will make it positive, making abs() irrelevant, and deleted some unnecessary parentheses.)But this still doesn't work: now you get 'float' object is not iterable.This is because you are trying to unpack four values from each element of the list, but each element contains only two. Python unpacks each element to two floats, then tries to unpack each float to two variables. This is where the error message rears its ugly head.So you need to change parts1() to return a list of a list of lists of lists. That is, each item in the list is a list, which contains two lists, each containing the coordinates of a point (a given point and its successor). One way to do this is to use the built-in zip() function with an offset or rotated copy of the list.Finally, you don't really need the separate function parts1()â€”it can go right in the perimeter() function. And you should pass poly into perimeter().You could do this without the extra copy of the list by iterating over the coordinates in poly and keeping track of the last items you saw. But you couldn't write it as a generator expression. Instead you'd use a regular for loop.Not quite as succinct, and not as fast either, but doesn't use as much memory.
Your code has two problems. One is due to parentheses as @TigerhawkT3 pointed out, and the other is you're not iterating through the points properly. The code below addresses both these issues.Also note that you could simplify (and speed up) the calculation you're doing by using the built-in math.hypot() function:
I would try something a bit more explicit like this, this matches your expected answer
I am also a little confused about your question, it seems that you are not intentionally using the generator and just wants to get the perimeter?I think it would be better to clean up the function perimeter() a little bit and not use a generator there, and simply iterate through the list poly and taking every adjacent pair and calculate it this way.I used a generator function for get_pair() function, but you can also do it with a loop or some other way. It basically just returns a new pair in the list every time you call it.


Answer URL
https://docs.python.org/3/library/math.html#math.hypot
