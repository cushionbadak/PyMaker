Natural Text
I have the following code, why the first one doesn't change alist while the second changes it?
This is a somewhat unintuitive behavor of variables. It happens because, in Python, variables are always references to values.Boxes and tagsIn some languages, we tend to think about variables as "boxes" where we put values; in Python, however, they are references, and behave more like tags or "nicknames" to values. So, when you attribute 1 to item, you are changing only the variable reference, not the list it is pointing to.A graphic representation can help. The image below represents the list created by alist = [[1,2], [3,4], [5,6]]Given that, let's see what happens when we execute your first loop.The first loopWhen you execute for item in alist, you are asking the interpreter to take each value from the list, one per time, put it on the variable item and do some operation in it. In the first operation, for example, we have this new schema:Note that we do not copy the sublist to item; instead, we point to it through item. Then, we execute item = 1 — but what does it mean? It mean that we are making item point to the value 1, instead of pointing to the sublist:Note that the old reference is lost (it is the red arrow) and now we have a new. But we just changed a variable pointing to a list — we did not alter the list itself.Then, we enter to the second iteration of the loop, and now item points to the second sublist:When we execute item = 1, again, we just make the variable point to aonther value, without changing the list:Now, what happens when we execute the second loop?The second loopThe second loop starts as the first one: we make item refer to the first sublist:The first difference, however, is that we call item.append(). append() is a method, so it can change the value of the object it is calling. As we use to say, we are sending a message to the object pointed by item to append the value 10. In this case, the operation is not being made in the variable item, but directly in the object it refers! So here is the result of calling item.append():However, we do not only append a value to the list! We also assign the value returned by item.append(). This will sever the item reference to the sublist, but here is a catch: append() returns None.The None valueNone is a value that represents, basically, the unavailability of a relevant value. When a function returns None, it is saying, most of the time, "I have nothing relevant to give you back." append() does change its list directly, so there is nothing it needs to return.It is important because you probably believed item would point to the appended list [1, 2, 10], right? No, now it points to None. So, you would expect the code below...To print something like this:But this does not happen. This is what happens:Yet, as we commented, the append() method changed the lists themselves. So, while the item variable was useless after the assignment, the final list is modified!If you want to use the appended list inside the loop, just do not assign the method returned value to item. Do this:This works because item will still point to the list.ConclusionReferences are somewhat complex to understand at first, let alone master. Yet, they are really powerful and can be learned if you follow examples etc. Your example is a bit complicated because there is more happening here.The Python Tutor can help you understand what is going on, because it executes each step graphically. Check your own code running there!
In the first example item is bound to each element in list alist, and then item is rebound to the integer 1. This does not change the element of the list - it merely rebinds the name item to the int object 1.In the second example the list element (itself a list) is mutated by append(). item is still bound to the sub-list so item.append() mutates the sub-list.
Are you forgetting that list.append() does not return the list itself but actually modifies the list in place?item = 1 does as expected. For the rest of the for-loop, item is now 1, and not the list it originally was. It won't reassign what item is, that's not what for-loops do.However, in your second loop, you're now assigning item = None, because the append function does not return anything but it appends the item to the list in place:Thus, your code is basically saying "go through each sublist in my main list and append 10 to it".
The = operator does not make any change in the second code, using .append causes changes in alist. Use following line as the third line in the second code. You will see the same result:In the first code item point to another object by item=1, so alist does not change. In the second code you make change on alist by calling append method of it.
It's pointer variable in python.The first example:each item is pointing to each _item in alist but suddenly you change the item value, not the of the value of the _item in alist, as a result nothing change to alistThe second example: each item is pointing to each _item in alist and then you append something to the item sharing the same memory location of _item, as a result value of _item in alist are changed and alist is changed too.
Referencing the document: The for-loop makes assignments to the variables(s) in the target list.  This overwrites all previous assignments to those variables including  those made in the suite of the for-loop:So your second example is identical to:That is to say, item is a new variable in every iteration. As a result, assigning values to it in any specific iteration is pointless, because its value will be overridden by the reference to the next item in alist at the very beginning of the next iteration.
When you writeYou are actually creating a copy of each item in liast in the item variable, and you are not getting a reference to item.However, append changes the list in-place and doesn't return a value, and that's why you're getting the values changed to None (due to the assignment - if you remove it you'll get the appending working fine).


Answer URL
https://docs.python.org/3/reference/compound_stmts.html#the-for-statement
