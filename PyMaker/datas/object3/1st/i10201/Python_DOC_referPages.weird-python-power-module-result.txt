Natural Text
This question already has an answer here:Difference between the built-in pow() and math.pow() for floats, in Python?                    3 answers                According to these answers there is not difference between pow(a,b) and a**b. However, math.pow(a,b) returns a float value. Now, when running the following python code something strange happens:These statements should give the same value but don't. Any clue as to why this happens?
The float type looses precision. They are represented by the nearest binary fraction and from the docs Floating Point Arithmetic: Issues and LimitationsInterestingly, there are many different decimal numbers that share the  same nearest approximate binary fraction.You can see the problem clearly with the result of math.pow(19,13) where multiple integers map to the same float.Since python can handle very large integers, try to stay away from floats!
As you say math.pow returns a float value and pow does not.  Calling the modulo operator on a float will round it to an integer. Rounding floating point to integer will cause loss of precision.
math.pow() converts its arguments to float:but the built-in pow does not:Also check: Difference between the built-in pow() and math.pow() for floats, in Python?


Answer URL
https://docs.python.org/3/tutorial/floatingpoint.html#floating-point-arithmetic-issues-and-limitations
