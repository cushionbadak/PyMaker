Natural Text
I'm just trying to grok how exactly Python handles this behind the scenes.  So take this code snippet (from Effective Python by Brett Slatkin):Running the super() call invokes the property check so that you can't instantiate with a zero or negative value.  What is confusing me to me is that I would think that since the the __init__(ohms) call is being ran on the superclass, shouldn't it be in a different scope (the scope of the superclass) and thus exempt from invoking the @property check?  
Scope doesn't come into play when working with object's attributes.  Consider the following:This example code will print 2.  Note that within the scope of bar, there is no way to gain access to the scope of foo or even A.__init__.  The class instance is carrying along all of it's attributes/properties with it (and a reference to it's class which has a reference to it's superclass, etc).In your code, when you call VoltageResistor, an instance of VoltageResistor is created and passed to __init__ as self.  When you call super.__init__(self), that VoltageResistor instance is passed along to Resistor.__init__.  When it does self.ohms = ohms, python sees that self.ohms resolves to a property and you get the error.  The tl;dr; here is that self is an instance of VoltageResistor and when working with attributes, the object on which the attributes are accessed is what is important, not the current scope).
To supplement the above excellent answer, just add the following line in the parent's constructor to get a better idea of what is going on:It will print VoltageResistor and then throw a ValueError. The Python docs confirm this:If c is an instance of C, c.x will invoke the getter, c.x = value will invoke the setter and del c.x the deleter.


Answer URL
https://docs.python.org/3/library/functions.html
