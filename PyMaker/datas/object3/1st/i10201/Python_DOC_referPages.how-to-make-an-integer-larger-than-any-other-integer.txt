Natural Text
Note: while the accepted answer achieves the result I wanted, and @ecatmur answer provides a more comprehensive option, I feel it's very important to emphasize that my use case is a bad idea in the first place. This is explained very well in @Jason Orendorff answer below.Note: this question is not a duplicate of the question about sys.maxint. It has nothing to do with sys.maxint; even in python 2 where sys.maxint is available, it does NOT represent largest integer (see the accepted answer).I need to create an integer that's larger than any other integer, meaning an int object which returns True when compared to any other int object using >. Use case: library function expects an integer, and the only easy way to force a certain behavior is to pass a very large integer.In python 2, I can use sys.maxint (edit: I was wrong). In python 3, math.inf is the closest equivalent, but I can't convert it to int.
Since python integers are unbounded, you have to do this with a custom class:Here I've used a mix-in class NeverSmaller rather than direct decoration of ReallyMaxInt, because on Python 3 the action of functools.total_ordering would have been prevented by existing ordering methods inherited from int.  Usage demo:Note that in python2, sys.maxint + 1 is bigger than sys.maxint, so you can't rely on that.  Disclaimer: This is an integer in the OO sense, it is not an integer in the mathematical sense.  Consequently, arithmetic operations inherited from the parent class int may not behave sensibly.  If this causes any issues for your intended use case, then they can be disabled by implementing __add__ and friends to just error out.
Konsta Vesterinen's infinity.Infinity would work (pypi), except that it doesn't inherit from int, but you can subclass it:Another package that implements "infinity" values is Extremes, which was salvaged from the rejected PEP 326; again, you'd need to subclass from extremes.Max and int.
Use case: library function expects an integer, and the only easy way to force a certain behavior is to pass a very large integer.This sounds like a flaw in the library that should be fixed in its interface. Then all its users would benefit. What library is it?Creating a magical int subclass with overridden comparison operators might work for you. It's brittle, though; you never know what the library is going to do with that object. Suppose it converts it to a string. What should happen? And data is naturally used in different ways as a library evolves; you may update the library one day to find that your trick doesn't work anymore.
It seems to me that this would be fundamentally impossible. Let's say you write a function that returns this RBI ("really big int"). If the computer is capable of storing it, then someone else could write a function that returns the same value. Is your RBI greater than itself?Perhaps you can achieve the desired result with something like @wim's answer: Create an object that overrides the comparison operators to make "<" always return false and ">" always return true. (I haven't written a lot of Python. In most object-oriented languages, this would only work if the comparison puts your value first, IF RBI>x. If someone writes the comparison the other way, IF x>RBI, it will fail because the compiler doesn't know how to compare integers to a user-defined class.)
In Python 3.5, you can do:import math  test = math.infAnd then:test > 1  test > 10000  test > xWill always be true. Unless of course, as pointed out, x is also infinity or "nan" ("not a number").How can I represent an infinite number in Python?Answered by @WilHall
You should not be inheriting from int unless you want both its interface and its implementation.  (Its implementation is an automatically-widening set of bits representing a finite number.  You clearly dont' want that.)  Since you only want the interface, then inherit from the ABC Integral.  Thanks to @ecatmur's answer, we can use infinity to deal with the nitty-gritty of infinity (including negation).  Here is how we could combine infinity with the ABC Integral:This can be run with pytest to verify the required invariants.
Another way to do this (very much inspired by wim's answer) might be an object that isn't infinite, but increases on the fly as needed. Here's what I have in mind: Something like this might avoid a lot of weird behavior that one might not expect. Note that with this kind of approach, if two BiggerThanYou instances are involved in an operation, the LHS would be considered bigger than the RHS. EDIT: currently this is not working- I'll fix it later. it seems I am being bitten by the special method lookup functionality. 


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__radd__
