Natural Text
I am trying to learn to use asyncio in Python to optimize scripts.My example returns a coroutine was never awaited warning, can you help to understand and find how to solve it? The first classic part of the code runs correctly, but the second half only produces: 
You made faire_toutes_les_requetes_sans_bloquer an awaitable function, a coroutine, by usingasync def.When you call an awaitable function, you create a new coroutine object. The code inside the function won't run until you then await on the function or run it as a task:You want to keep that function synchronous, because you don't start the loop until inside that function:However, you are also trying to use a aiophttp.ClientSession() object, and that's an asynchronous context manager, you are expected to use it with async with, not just with, and so has to be run in aside an awaitable task. If you use with instead of async with a TypeError("Use async with instead") exception will be raised.That all means you need to move the loop.run_until_complete() call out of your faire_toutes_les_requetes_sans_bloquer() function, so you can keep that as the main task to be run; you can call and await on asycio.gather() directly then:I used the new asyncio.run() function (Python 3.7 and up) to run the single main task. This creates a dedicated loop for that top-level coroutine and runs it until complete.Next, you need to move the closing ) parenthesis on the await resp.json() expression:You want to access the 'uuid' key on the result of the await, not the coroutine that response.json() produces.With those changes your code works, but the asyncio version finishes in sub-second time; you may want to print microseconds:On my machine, the synchronous requests code in about 4-5 seconds, and the asycio code completes in under .5 seconds.
Do not use loop.run_until_complete call inside async function. The purpose for that method is to run an async function inside sync context. Anyway here's how you should change the code:Note that alone faire_toutes_les_requetes_sans_bloquer() call creates a future that has to be either awaited via explicit await (for that you have to be inside async context) or passed to some event loop. When left alone Python complains about that. In your original code you do none of that.


Answer URL
https://docs.python.org/3/library/asyncio-task.html#asyncio.run
