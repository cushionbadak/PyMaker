Natural Text
I have a method which takes a list of edges, an edge has this form : (v1,v2,capacity) and returns a dictionary of this form: this dico represent a graph I want to define this dico by the comprehension way but I'm really blocked and I'm not even sure that we can do that so can someone tell me if it is possible ?this is my function:
Your code can't take advantage of dict comprehensions easily because it's effectively a multidict (where a key doesn't have one value, but many).You can simplify the code a bit with collections.defaultdict:Using defaultdict(dict) means when a key isn't in the dictionary, it's immediately created with a brand new dict, so you don't need to perform membership testing at all.Note that I also used unpacking to named variables instead of repeated indexing to make the code a bit more self-documenting.The only way to make this work with an actual dict comprehension would be to either:Rescan the edges once for every input to gather all v2/capacity pairs for a given v1 (but that's O(n**2), so it's a bad idea if edges can be large)Pack all the values for each v1 together ahead of time, so each sub-dict can be constructed all at once.Since option #1 is generally pretty wasteful, the only practical way to do this as a dict comprehension without rescanning edges over and over is option #2, which you can do in O(n log n) with sorting followed by itertools.groupby:That requires O(n log n) work to sort edges (if edges is already sorted, Python's TimSort means it's closer to O(n) work), then O(n) work to group the results. Faster than {v1: {v2: capacity for v, v2, capacity in edges if v == v1} for v1, _, _ in edges}, but still slower than the non-comprehension approach with defaultdict (which is O(n) under all circumstances).
This is a little convoluted, but it seems to work:Basically for each v1, it adds every key: value pair in edges with that v1. The outer comprehension doesn't need v2 or cap, so it just uses underscores to ignore those values. The inner loop needs to compare its value of v1 with the outer loop's value, which is why it uses a different name.


Answer URL
https://docs.python.org/3/library/collections.html#collections.defaultdict
https://docs.python.org/3/library/itertools.html#itertools.groupby
