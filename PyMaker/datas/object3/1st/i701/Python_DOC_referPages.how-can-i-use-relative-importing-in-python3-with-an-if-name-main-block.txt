Natural Text
I am making a package, and the modules within this package have code inside if __name__=='__main__': blocks for testing purposes. But my attempts to use relative imports in these modules causes errors. I have read this thread and the billion others:Relative imports for the billionth timeBefore you mark this as a duplicate, if what I want to do is not possible in Python3 then my question is why did it work in Python2 and what motivated the decision to make this such a hassle in Python3?This is my sample Python project:__init__.py and module2.py are emptymodule1.py contains:This works fine in Python2. I am able to import module1 from other projects anywhere on my computer, and I'm also able to run module1 directly and have the code in the if block run.However, this structure doesn't work in Python3. If I try import the module somewhere else it fails:So I tried changing the first line to from . import module2, and that fixed it so I could import the module from anywhere successfully. But then when I try running module1 directly as a script I get this error:I don't want to have to open a console and type python -m myfile every time I'm working on a module and want to run it directly as a script.I want to be able to work on modules without adding their parent folder to PYTHONPATH by using relative imports like in Python2Is there any better workaround or solution to these problems?
According to the Module documentation, for __main__ modules, you have to use absolute imports.Note that relative imports are based on the name of the current module. Since the name of the main module is always "main", modules intended for use as the main module of a Python application must always use absolute imports.So just change the import line in module1.py to:from mypackage import module2Everything else remains the same.
I ended up in similar scenario and it troubled me a alot until I realised how module and package import is supposed to work.Consider the following structureContents of module1 and module2 looks like belowmodule1.pymoudle2.pyfrom . import module1Now if i open a repl outside the package directory and try to make imports it worksTake a note at sys.path, as you can see it contains the current directory I am in as the first item, which means all my imports are going to be first searched in my current directory.Now if i go into the package directory and then open a repl, and try making same imports see what happensAs you can the imports fail, the reason for failure is that when i try to import module from package python searches in sys.path to find any package with name package, since I could not find any , hence import fails. But importing the module1 works because it is found in the current directory.Outside the package i can execute the script as Though I can execute the script but this is not how its supposed to used. Remember packages are library of code that needs to shared across and should not have any code that is directly executable via command line. Packages and modules inside packages are meant to be just imported and then after importing you can write your scripts which execute via command line by putting __name__ clause in it.
A Python package isn't just a folder you stick your code in, and import behavior depends on more than just what folder you've stuck your code in.When you run your file directly, you're not running it as part of a package. Package-level initialization doesn't run, and Python doesn't even recognize the package's existence. On Python 2, the existence of implicit relative imports meant that a bare import module2 would resolve to either an absolute import or an implicit relative import, hiding the problem, but the import structure is still broken. On Python 3, implicit relative imports are gone (for good reason), so the problem is immediately visible.Running a submodule of a package directly by filename just doesn't work very well. These days, I believe the standard is to either use -m, or use a top-level entry point script that invokes the submodule's functionality.There's sort of a way to get run-by-filename working anyway, but it's a lot of boilerplate. The designers of PEP 366 seem to have intended for a __package__ = 'appropriate.value' assignment to make relative imports work properly, but that's not actually enough, even if you fix the import path. You also have to initialize the parent package manually, or you'll get a "SystemError: Parent module 'foo' not loaded, cannot perform relative import" as soon as you try to run a relative import. The full boilerplate looks more likeThis goes after stuff like future imports, but before any import that depends on your package.I would wrap this boilerplate in a reusable function (using stack manipulation to access the caller's globals), except that if you try to put that function somewhere in your project, you won't be able to import the function until you've fixed your import situation, which you need the function to do. It might work as an installable dependency.


Answer URL
https://docs.python.org/3/tutorial/modules.html#intra-package-references
