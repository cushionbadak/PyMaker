Natural Text
I defined the function f asBut f returns a generator no matter what flag is:And if I iterate over the returned object:It looks like f(False) returns a generator which has been iterated over. What's the reason? Thank you.
A function containing a yield statement always returns a generator object.Only when you iterate over that generator object will the code in the function be executed. Until that time, no code in the function is executed and Python cannot know that you'll just return.Note that using return in a generator function has different semantics than in a regular function; return in this case simply is seen as 'exit the generator here'; the return value is discarded as a generator can only produce values via yield expressions.It looks like you want to use yield from instead:yield from requires Python 3.3 or up.See the yield expression documentation:Using a yield expression in a function’s body causes that function to be a generator.When a generator function is called, it returns an iterator known as a generator. That generator then controls the execution of a generator function. The execution starts when one of the generator’s methods is called. At that time, the execution proceeds to the first yield expression, where it is suspended again, returning the value of expression_list to the generator’s caller.Iteration over a generator calls the generator.__next__() method, triggering execution.If you wanted to return a generator some of the time, then don't use yield in this function. You'd produce the generator by other means; using a separate function for example, or by using a generator expression perhaps:Now no yield is used in f and it will no longer produce a generator object directly. Instead, the generator expression (i for i in range(n)) produces it, but only conditionally.
You can work around this by using a nested function that actually uses yield:As Martijn points out, any function containing a yield will always return a generator object, so if in some cases you want the body of f to actually be executed when f() is called, rather than only be executed when iterated over, you have to use this approach.The standard library instance method map from concurrent.Futures.ProcessPoolExecutor/concurrent.Futures.ThreadPoolExecutor uses this to ensure futures are submitted as soon as map is called, rather than only when you try to actually retrieve results from it, for example:


Answer URL
https://docs.python.org/3/reference/expressions.html#yield-expressions
https://docs.python.org/3/reference/expressions.html#generator.__next__
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor.map
