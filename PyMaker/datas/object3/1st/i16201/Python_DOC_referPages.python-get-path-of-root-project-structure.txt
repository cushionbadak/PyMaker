Natural Text
I've got a python project with a configuration file in the project root. The configuration file needs to be accessed in a few different files throughout the project. So it looks something like: <ROOT>/configuration.conf<ROOT>/A/a.py, <ROOT>/A/B/b.py (when b,a.py access the configuration file). What's the best / easiest way to get the path to the project root and the configuration file without depending on which file inside the project I'm in? i.e without using ../../? It's okay to assume that we know the project root's name.
You can do this how Django does it: define a variable to the Project Root from a file that is in the top-level of the project. For example, if this is what your project structure looks like:In definitions.py you can define (this requires import os):Thus, with the Project Root known, you can create a variable that points to the location of the configuration (this can be defined anywhere, but a logical place would be to put it in a location where constants are defined - e.g. definitions.py):Then, you can easily access the constant (in any of the other files) with the import statement (e.g. in utils.py): from definitions import CONFIG_PATH.
To get the path of the "root" module, you can use:But more interestingly if you have an config "object" in your top-most module you could -read- from it like so:
Other answers advice to use file in top-level of the project. This is not necessary if you use pathlib.Path and parent. Consider the following directory structure where all files except README.md and utils.py have been omitted.In utils.py we define the following function.In any module in the project we can now get the project root as follows.Benefits: Any module which calls get_project_root can be moved without changing program behavior. Only when the module utils.py is moved we have to update get_project_root and the imports (use IDE refactoring to automate this).
A standard way to achieve this would be to use the pkg_resources module which is part of the setuptools package.  setuptools is used to create an install-able python package.You can use pkg_resources to return the contents of your desired file as a string and you can use pkg_resources to get the actual path of the desired file on your system.Let's say that you have a package called stackoverflow.Now let's say that you want to access the file Rush from a module app.run. Use pkg_resources.resouces_filename to get the path to Rush and pkg_resources.resource_string to get the contents of Rush; thusly:The output:This works for all packages in your python path. So if you want to know where lxml.etree exists on your system:output:The point is that you can use this standard method to access files that are installed on your system (e.g pip install xxx or yum -y install python-xxx) and files that are within the module that you're currently working on.
All the previous solutions seem to be overly complicated for what I think you need, and often didn't work for me. The following one-line command does what you want:
This worked for me using a standard PyCharm project with my virtual environment (venv) under the project root directory.Code below isnt the prettiest, but consistently gets the project root. It returns the full directory path to venv from the VIRTUAL_ENV environment variable e.g. /Users/NAME/documents/PROJECT/venvIt then splits the path at the last /, giving an array with two elements. The first element will be the project path e.g. /Users/NAME/documents/PROJECT 
I've recently been trying to do something similar and I have found these answers inadequate for my use cases (a distributed library that needs to detect project root). Mainly I've been battling different environments and platforms, and still haven't found something perfectly universal.Code local to projectI've seen this example mentioned and used in a few places, Django, etc.Simple as this is, it only works when the file that the snippet is in is actually part of the project. We do not retrieve the project directory, but instead the snippet's directory Similarly, the sys.modules approach breaks down when called from outside the entrypoint of the application, specifically I've observed a child thread cannot determine this without relation back to the 'main' module. I've explicitly put the import inside a function to demonstrate an import from a child thread, moving it to top level of app.py would fix it.app.pysettings.pyRunning this program produces an attribute error:...hence a threading-based solutionLocation independentUsing the same application structure as before but modifying settings.pyBreaking this down:First we want to accurately find the thread ID of the main thread. In Python3.4+ the threading library has threading.main_thread() however, everybody doesn't use 3.4+ so we search through all threads looking for the main thread save it's ID. If the main thread has already exited, it won't be listed in the threading.enumerate(). We raise a RuntimeError() in this case until I find a better solution.Next we find the very first stack frame of the main thread. Using the cPython specific function sys._current_frames() we get a dictionary of every thread's current stack frame. Then utilizing inspect.getouterframes() we can retrieve the entire stack for the main thread and the very first frame.    current_main_frame = sys._current_frames()[main_id]    base_frame = inspect.getouterframes(current_main_frame)[-1]Finally, the differences between Windows and Linux implementations of inspect.getouterframes() need to be handled. Using the cleaned up filename, os.path.abspath() and os.path.dirname() clean things up.So far I've tested this on Python2.7 and 3.6 on Windows as well as Python3.4 on WSL
Try:
I struggled with this problem too until I came to this solution.This is the cleanest solution in my opinion.In your setup.py add "packages"In your python_script.py


Answer URL
https://docs.python.org/3/tutorial/modules.html#packages
