Natural Text
I need to determine if a string represents a valid python identifier. Since python 3 identifiers support obscure unicode functionality, and python syntax might change across releases, I decided to avoid manual parsing. Unfortunately my attempts at utilizing python's internal interfaces don't seem to work:I. function compileClearly test can't force compile to use ast.Name as the root of the AST.Next I attempt using the modules ast and parser. These modules are intended to derive a string, rather than determining if a string matches a particular derivation, but I figure they might be helpful anyway.II. module astOK, clearly Name isn't parsing '1a' for correctness. Perhaps this step happens earlier, in the parse phase.III. module parserOK, still not being checked... why? Quick check of python's full grammar specification shows that NAME is not defined. If these checks are performed by the bytecode compiler, shouldn't 1a have been caught?I'm starting to suspect python exposes no functionality towards this goal. I'm also curious why some attempts failed.
You don't need to parse, just tokenize, and -- if you care -- test if the returned NAME is a keywordExample, partly adapted from the linked documentation:You'll always get an ENCODING (56) token at the beginning of the input, and an ENDMARKER (0) at the end.  
I'm not sure where you were going with your compile example, but if you compile just the potential identifer for eval, it exposes what is going on.It would require more testing before using for real (for edge cases), but getting a LOAD_NAME opcode back is indicative. Failure states can include both an exception and getting a different opcode so you have to check for both.


Answer URL
https://docs.python.org/3/library/tokenize.html
