Natural Text
I'm writing a preprocessor in python, part of which works with an AST.There is a render() method that takes care of converting various statements to source code.Now, I have it like this (shortened):As you can see, it's tedious, prone to errors and a the code is quite long (I have many more kinds of statements).The ideal solution would be (in Java syntax):Of course, python can't do this, because it has dynamic typing. When I searched for how to mimick method overloading, all answers just said "You don't want to do that in python". I guess that is true in some cases, but here kwargs is really not useful at all.How would I do this in python, without the hideous kilometre-long sequence if type checking ifs, as shown above? Also, preferably a "pythonic" way to do so?Note: There can be multiple "Renderer" implementations, which render the statements in different manners. I can't therefore move the rendering code to the statements and just call s.render(). It must be done in the renderer class.(I've found some interesting "visitor" code, but I'm not sure if it's really the thing I want).
Would something like this work?Keeping a reference to a class object as a key in a dictionary and having it's value be the function object you want to call will make your code shorter and less error prone. The only place an error could occur here would be in the definition of the dictionary. Or one of your internal functions of course.
If you're using Python 3.4 (or are willing to install the backport for Python 2.6+), you can use functools.singledispatch for this*:Output:*Code based on this gist.
The overloading syntax you are looking for can be achieved using Guido van Rossum's multimethod decorator. Here is a variant of the multimethod decorator which can decorate class methods (the original decorates plain functions). I've named the variant multidispatch to disambiguate it from the original:and it can be used like this:The demo code above shows how to overload the Foo.render method based on the types of its arguments.This code searches for exact matching types as opposed to checking for isinstance relationships. It could be modified to handle that (at the expense of making the lookups O(n) instead of O(1)) but since it sounds like you don't need this anyway, I'll leave the code in this simpler form.
To add some performance measurements to the @unutbu 's answer:Returns:


Answer URL
https://docs.python.org/3/library/functools.html#functools.singledispatch
