Natural Text
In my terminal I am running:curl's output is live streaming Twitter data which is being written on to a file raw-data.txtIn python, I am reading the file in python and using json decoder and appending the results to posts.Now, the issue is I don't want my program to end when the python script reaches the end of file. instead I want to continue reading when the curl running on my terminal appends more posts to the file raw-data.txt.
I think this is an XY problem. Because you couldn't think of a way to stream an HTTP request line by line from within Python, you decided to use curl to do a streaming download to a file, and then read that file from within Python. Because you did that, you have to deal with the possibility of running into EOF while the request is still going, just because you've caught up to curl. So you're making things harder on yourself for no reason.While streaming downloads can be done with the stdlib, it's a bit painful; the requests library makes it a lot easier. So, let's use that:And that's the whole program.
I don't know if this is guaranteed anywhere by the language, but I do know that it works with at least CPython 2.x and 3.3+ on Unix. So if you don't care about 3.0-3.2 (or can test it yourself), and don't care about Windows (or can test it yourself)…When you reach EOF, your for line in f loop will finish. But it doesn't close the file or anything; all it does is leave the file pointer sitting at EOF. If you try to loop again, and more data have been written, you'll get the new data.So, you could do this:The problem with this is that when you reach EOF, it will spin as fast as possible, verifying that it's still at EOF. So what you really want to do is block until there's more data. You can do that with select on some Unix platforms, but not all. You can use a platform-specific file notification API, or a cross-platform wrapper around such APIs.If you're using Python 3.4+, you can use the selectors module in the stdlib, which will give you something that works on Solaris, on Linux, on OS X and any other *BSD with kqueue, and on some Unix platforms with only select… but on Windows it will fail, and on some Unix systems it will spin as fast as possible. You can work around that by refusing to start if you can't find a good selector.Or, if worst comes to worst, you can just sleep for a bit at EOF (possibly with some exponential backoff, but only up to a reasonably short limit). This is what tail -f does in ports to platforms that have no way to detect notifications.So:


Answer URL
https://docs.python.org/3/library/selectors.html
