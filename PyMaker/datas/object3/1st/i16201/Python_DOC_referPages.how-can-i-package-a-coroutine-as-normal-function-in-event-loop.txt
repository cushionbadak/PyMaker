Natural Text
I am using asyncio for a network framework.In below code(low_level is our low level function, main block is our program entry, user_func is user-defined function):I want wrap the low_level as normal function rather than coroutine(for compatibility etc.), but low_level is in event loop. How can wrap it as a normal function?
Because low_level is a coroutine, it can only be used by running an asyncio event loop. If you want to be able to call it from synchronous code that isn't running an event loop, you have to provide a wrapper that actually launches an event loop and runs the coroutine until completion:If you want to be able to call low_level() from a function that is part of the running event loop, have it block for two seconds, but not have to use yield from, the answer is that you can't. The event loop is single-threaded; whenever execution is inside one of your functions, the event loop is blocked. No other events or callbacks can be processed. The only ways for a function running in the event loop to give control back to the event loop are to 1) return 2) use yield from. The asyncio.sleep call in low_level will never be able to complete unless you do one those two things.Now, I suppose you could create an entirely new event loop, and use that to run the sleep synchronously from a coroutine running as part of the default event loop:But I'm really not sure why you'd want to do that.If you just want to be able to make low_level act like a method returning a Future, so you can attach callbacks, etc. to it, just wrap it in asyncio.async():Output:Also, in your example code, you should use the @asyncio.coroutine decorator for both low_level and user_func,  as stated in the asyncio docs:A coroutine is a generator that follows certain conventions. For  documentation purposes, all coroutines should be decorated with  @asyncio.coroutine, but this cannot be strictly enforced.Edit:Here's how a user from a synchronous web framework could call into your application without blocking other requests:If a request being handled by Flask calls thr_low_level, it will block until the request is done, but the GIL should be released for all of the asynchronous I/O going on in low_level, allowing other requests to be handled in separate threads.


Answer URL
https://docs.python.org/3/library/asyncio-task.html#asyncio.async
https://docs.python.org/3/library/asyncio-task.html#coroutines
