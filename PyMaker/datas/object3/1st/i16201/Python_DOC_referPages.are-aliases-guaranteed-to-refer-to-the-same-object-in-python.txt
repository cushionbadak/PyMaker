Natural Text
The Python docs mentions the following about names being aliases to objects:Objects have individuality, and multiple names (in multiple scopes) can be bound to the same object. This is known as aliasing in other languages. This is usually not appreciated on a first glance at Python, and can be safely ignored when dealing with immutable basic types (numbers, strings, tuples). However, aliasing has a possibly surprising effect on the semantics of Python code involving mutable objects such as lists, dictionaries, and most other types. This is usually used to the benefit of the program, since aliases behave like pointers in some respects. For example, passing an object is cheap since only a pointer is passed by the implementation; and if a function modifies an object passed as an argument, the caller will see the change â€” this eliminates the need for two different argument passing mechanisms as in Pascal.In some other high-level languages it is often the case that primitive types are special-cased, and are copied instead of referenced, for performance reasons. For example, in Java:The code above will copy the value 20000, instead of the pointer to the value 20000. In this case, a and b will likely occupy different locations in memory. Due to special-casing on == to test for equality instead of identity for primitive types only, I don't believe this behaviour can be introspected in normal code, however.On the other hand, limited testing with types such as int and str in Python 3 shows that indeed, the pointers are copied rather than the values, as specified in the documentation:This is a very nice property that makes the language very consistent, as there is no special-casing for primitive types. All assignments reassign a name to another object. However, for performance reasons, might it be possible for a Python interpreter to special-case types like int?Hence, my question is: Is this property for primitive types guaranteed? In other words, is it always true that after b = a, the comparison a is b will be True, no matter the Python interpreter used?
Yes, it is specified in the documentation:If the target is an identifier (name):If the name does not occur in a global statement in the current code block: the name is bound to the object in the current local namespace.Otherwise: the name is bound to the object in the current global namespace.(In Python 3 there is an additional case related to nonlocal, but the rule is the same; the only difference is what namespace the binding takes place in.)Note, crucially, that this only applies when assigning to a bare name.  If the assignment is something like a.foo = b or a[blah] = b, all bets are off and just about anything can happen.
b = a make the names b and a reference the exact same object. So yes, in Python, a is b will then always be True.
Python doesn't use primitive types in the same way as Java. As you see here, int is a class. Instances of this class are objects with all that means. It just so happens that this is a builtin class rather than one defined in a .py file somewhere.Think about the Java behavior of Integer vs int.When you do a = 1; b = a you are setting b to a reference to the same object that a refers to, so it doesn't copy the value.As far as special casing, CPython does make "small" integers (from -5 to 255) into singletons so they do not have to be recreated, but this is an implementation detail.
All variables and expressions in Python are references (semantically equivalent to pointers to objects). If you are familiar with a C++, it is like the following:Assigning one variable to another will copy the value, a pointer. After the assignment the two pointers will always point to the same object.


Answer URL
https://docs.python.org/3/tutorial/classes.html#a-word-about-names-and-objects
