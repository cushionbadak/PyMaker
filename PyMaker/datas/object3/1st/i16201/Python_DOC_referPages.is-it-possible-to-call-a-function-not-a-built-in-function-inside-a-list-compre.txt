Natural Text
Say we have a list:and we have created a function called add():which runs through a list of numbers X, adding the next element in the list to the previous sum. So for each element X[i], we have:Now, what if I want to put these results in a list again, by making use of a list comprehension. Is it possible to call a function such as add() within a list comprehension,given that it is possible to apply built in functions inside list comprehensions?I have tried the following:which givesinstead ofWhy am I getting NoneType values in this list?
You could do this with yield to keep with your original format:
Yes, it is possible to call functions inside list comprehensions. Your example is fine - it's the add() function that is to be blamed.What you need is make the add() function receive an argument - the list to sum.This way, the list comprehension would look like this:This is equivalent to:Which turns out to be a list of prefix sums - the thing you want.
Your approach won't work, because your add() is stateless.  You need something that maintains state between different invocations of add(), otherwise add() will always produce the same output.One solution to accomplish what you want is itertools.accumulate().  See Equivalent of Haskell scanl in python for a discussion.Other answers here have suggested using a list comprehension that involves a range().  While that would work, it would also be inefficient, as an O(n^2) algorithm that recomputes the cumulative sums from scratch for each entry.
produces this:
Yes, it is possible to call any function in list comprehension.Also note that in Python 2.x you cannot have print in list comprehension because print is not a function (in Python 2).To your example - it could look like this, using an add() function that works with shared state (the s variable):See other answers how to do it without that shared state so you don't get different results when you forget to set s = 0.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.accumulate
