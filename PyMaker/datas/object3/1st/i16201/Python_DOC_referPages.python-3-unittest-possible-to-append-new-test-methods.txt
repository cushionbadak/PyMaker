Natural Text
I'm using Python 3.4.1 and the unittest module to validate another piece of software.The other piece of software needs to be run and its output must be parsed by the python script for validation. The output file is an XML file containing an unknown number of  elements.For now, I've been using subTest() to generate one subtest per XML element. This is not exactly what I want. I would like to create one test_* method for every  element in the XML file. The problem is that I don't know in advance how many elements there will be, so I need a way to automatically add new test_* methods to the unittest. I though of having a setUpClass() method that would call the external software to generate the XML and build an update list of test* methods to be run.But I think the methods are added to the unittest's list of methods to run before anything is executed, so that once I get to the point where I add new methods (using setattr() from inside setUpClass() for example), the list is already built and the new methods are never run...Is it possible to dynamically change the list of methods to run in unittest?Thanks!
Here's a variation of what I came up with:The trick is to do generate and parse the XML file outside of any class and add the resulting methods to the class using setatt(). The problem with this approach is that it run codes outside of the testing suite which I was hoping not to do. So a failure there will break the whole suite (since unittest won't catch the error...)Maybe I could move the XML generation to its own testing class?Any better suggestion?
I came up with this . Tried my hands on the code submitted by @big_gie. In this way, the setUp and tearDown will also run as per unit test rule..import unittestdef generator(test_class, a, b):    def test(self):        self.assertEqual(a, b)    return testdef add_test_methods(test_class):    test_list = [[2,3, 'one'], [5,5, 'two'], [0,0, 'three']]    for case in test_list:        test = generator(test_class, case[0], case[1])        setattr(test_class, "test_%s" % case[2], test)class TestIO(unittest.TestCase):def setUp(self):        print 'Setup'        passdef tearDown(self):        print 'TearDown'        passadd_test_methods(TestIO)if __name__ == '__main__':unittest.main(verbosity=1)Result:


Answer URL
https://docs.python.org/3/library/unittest.html#distinguishing-test-iterations-using-subtests
