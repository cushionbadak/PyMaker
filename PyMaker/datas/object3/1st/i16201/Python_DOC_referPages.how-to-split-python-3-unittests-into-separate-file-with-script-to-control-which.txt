Natural Text
I want to split my Python 3.4 unit tests in separate modules and still be able to control which tests to run or skip from the command line, as if all tests were located in the same file. I'm having trouble doing so.According to the docs, command line arguments can be used to select which tests to run. For example:TestSeqFunc.py:can be controlled with either:to run all tests in the file,to run all tests defined in the TestSequenceFunctions class, and finally:to run the specific test_sample() method.The problem I have is that I cannot find an organization of files that will allow me to:Have multiple modules containing multiple classes and methods in separate filesUse a kind of wrapper script that will give the same kind of control over which tests (module/file, class, method) to run.The problem I have is I cannot find a way to emulate the python3 -m unittest behaviour using a run_tests.py script. For example, I want to be able to do:Run all the tests in the current directorySo ./run_tests.py -v should do do the same as python3 -m unittest -vRun one module (file):./run_tests.py -v TestSeqFunc being equivalent to python3 -m unittest -v TestSeqFuncRun one class:./run_tests.py -v TestSeqFunc.TestSequenceFunctions being equivalent to python3 -m unittest -v TestSeqFunc.TestSequenceFunctionsRun specific methods from a class:./run_tests.py -v TestSeqFunc.TestSequenceFunctions.test_sample being equivalent to python3 -m unittest -v TestSeqFunc.TestSequenceFunctions.test_sampleNote that I want to:be able to pass arguments to unittests, for example the verbose flag used previously;allow running specific modules, classes and even methods.As of now, I use a suite() function in my run_all.py script which loads manually the modules and add their class to a suite using addTest(unittest.makeSuite(obj)). Then, my main() is simple:But using this I cannot run specific tests. In the end, I might just execute python3 -m unittest <sys.argv> from inside the run_all.py script, but that would be inelegant...Any suggestions?!Thanks!
You can pass command-line arguments to unittest.main using the argv parameter:The argv argument can be a list of options passed to the program, with  the first element being the program name. If not specified or None,  the values of sys.argv are used. (my emphasis)So you should be able to usewithout any change and be able to call your script with command-line arguments as desired.
Here's my final run_all.py:Notes:I use exec() to simulate 'import modulename'. The issue is that using importlib (explained here for example) will import the module but will not create a namespace for the module content. When I type import os, an "os" namespace is created and I can then access os.path. By using importlib, I couldn't figure out a way to do create that namespace. Having such a namespace is required for unittest; you get these kind of errors:Hence the use of exec().I have to add defaultTest=module_names or else main() defaults to all test classes inside the current file. Since there is no test class in run_all.py, nothing gets executed. So defaultTest must point to a list of all the modules name.


Answer URL
https://docs.python.org/3/library/unittest.html#command-line-interface
