Natural Text
I am using argparse to parse command line arguments. While going through the documentation for argparse I could only see a provision to use a different program name. I want to be able to use the default program name without having to import sys. There is nothing in argparse, as far as I can see, that will return the program name.And here's the output:['__class__', '__contains__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_get_args', '_get_kwargs']Is there any other way of retrieving the program name without having to import the sys module?
ArgumentParserinstances have aprogattribute which I think is what you want.I discovered this by reading the module's source code in Lib/argparse.pyâ€”specifically looking at the class ArgumentParser definition. Since the attribute's name doesn't start with an underscore character, I assume it's public.UpdateI see that, nowadays at least, that the prog attribute of ArgumentParser instance is (or has been since this question was asked) documented in both Python 2's documentation and Python 3's documentation. So, yes, it's definitely public, and in both versions, if it is not supplied as a keyword argument when creating the ArgumentParser, it defaults to prog = _os.path.basename(_sys.argv[0]) (where _os and _sys are private argparse module attributes that correspond to their non-underscore-prefixed counterparts. Note that because of the use of os.basename(), this will only be the script's filename, not the complete path to it that may (it's OS dependent) have been in sys.argv[0].
Of course the correct way would be:But let's assume for a moment you have a good reason that prevents you to import sys but allows you to import argparse.martineau has done a wonderful job discovering prog, let's try it:As noted by hpaulj, this only has the filename and not the full path like sys.argv[0] because the module argparse.py is using prog = os.path.basename(sys.argv[0]).But argparse must use sys, so it needs to be accessible in argparse namespace. Let's check it:Here it is! Let's try to use _sys:You are using sys! Of course, but I haven't imported it, only argparse, that was the question!Of course this has a number of contraindications:You should not use variables prefixed by _ or __ of other namespaces, they are used internally.You should not rely on imports of other modules, they may change.You should not rely on undocumented api, they may change.tl;drThis was fun, but just stick to import sys until argparse releases an api to access sys.argv[0].
%(prog) from inside argparse help textsThis is a common use case when you want to give an example of how to use the command within the help itself.main.pyThen:gives:One advantage over sys.argv[0] is that the message stays unchanged no matter where you call it from:Documented at: https://docs.python.org/3/library/argparse.html#progNote that the program name, whether determined from sys.argv[0] or from the prog= argument, is available to help messages using the %(prog)s format specifier.Tested on Python 3.5.2.


Answer URL
https://docs.python.org/3/library/argparse.html#module-argparse
https://docs.python.org/3/library/argparse.html#argumentparser-objects
https://docs.python.org/3/library/argparse.html#prog
