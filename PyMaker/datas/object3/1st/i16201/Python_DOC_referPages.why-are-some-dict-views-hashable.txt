Natural Text
In python 3, the keys(), values(), and items() methods provide dynamic views of their respective elements.  These were backported to python 2.7 and are available there as viewkeys, viewvalues, and viewitems.  I'm referring to them interchangeably here.Is there any reasonable explanation for this:I found this rather surprising.The python docs glossary on "hashable" says:An object is hashable if it has a hash value which never changes  during its lifetime (it needs a __hash__() method), and can be  compared to other objects (it needs an __eq__() method). Hashable  objects which compare equal must have the same hash value.Okay, the first part actually checks out; it doesn't appear that the hash of a dict_values object will change over its lifetime - even though its underlying values certainly can.But the part about __eq__()... well, it doesn't have one of those, actually.So... yeah.  Can someone make any sense of this?  Is there a reason for this asymmetry that of the three viewfoo methods, only dict_values objects are hashable?
I believe this occurs because viewitems and viewkeys provide custom rich comparison functions, but viewvalues does not. Here are the definitions of each view type:Notice that tp_richcompare is defined as dictview_richcompare for items and keys, but not values. Now, the documentation for __hash__ says this:A class that overrides __eq__() and does not define __hash__() will have its __hash__() implicitly set to None....If a class that overrides __eq__() needs to retain the implementation  of __hash__() from a parent class, the interpreter must be told this  explicitly by setting __hash__ = <ParentClass>.__hash__.If a class that does not override __eq__() wishes to suppress hash  support, it should include __hash__ = None in the class definition.`So, because items/keys are overriding __eq__() (by providing a tp_richcompare function), they would need to explicitly define __hash__ as being equal to the parent's to retain an implementation for it. Because values doesn't override __eq__(), it inherits the __hash__ from object, because tp_hash and tp_richcompare get inherited from the parent if they're both NULL:This field is inherited by subtypes together with tp_richcompare: a  subtype inherits both of tp_richcompare and tp_hash, when the  subtypeâ€™s tp_richcompare and tp_hash are both NULL.The fact that the impelmentation for dict_values isn't preventing this automatic inheritence would probably be considered a bug.


Answer URL
https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects
https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_hash
