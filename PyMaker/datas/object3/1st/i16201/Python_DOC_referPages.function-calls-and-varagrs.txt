Natural Text
def func(a, b, c, d): print(a, b, c, d)Why does the former call work but the latter not? I mean shouldn't the first return an error too? Doesn't * simply unpack an iterable?
As the docs say:If the syntax *expression appears in the function call, expression must evaluate to an iterable. Elements from this iterable are treated as if they were additional positional arguments; if there are positional arguments x1, ..., xN, and expression evaluates to a sequence y1, ..., yM, this is equivalent to a call with M+N positional arguments x1, ..., xN, y1, ..., yM.A consequence of this is that although the *expression syntax may appear after some keyword arguments, it is processed before the keyword argumentsâ€¦At lot of people are confused by the fact that function definitions have a similar, sometimes misleadingly-similar, syntax.In a function definition, a variable-argument parameter (like *args) comes before any the keyword-only parameters. Of course being keyword-only and having a default value are completely independent, but it's pretty common that the keyword-only parameters all have default values. So, the syntax often looks like def func(a, *args, c=4, **kwargs):. Which can lead you to expect func(1, *(2,), c=3, **{'d': 4} to be the matching call syntax, even though it isn't. Just remember that def func(a=1, *args, c, **kwargs) is perfectly legal, and it still makes a a positional-or-keyword parameter and c a keyword-only parameter.If you're interested how this works specifically in CPython (although other implementations are probably all pretty similar):The function call itself gets compiled to pass the value of the expression on the stack, still separate from the normal arguments. It's inside the interpreter, in the function-call evaluator, where the stack frame for the function body's execution gets built, where that value is exploded into extra arguments.It may help to see how CPython parses and compiles this code:Even if you don't understand ASTs, you should be able to see that the (2,) is still separate at parse time, stored in a field named starargs.This gets compiled to this bytecode:You probably don't understand all that gibberish, but you can see that the tuple (2,) is being loaded onto the stack at offset 12, and it's still on the stack when the opcode CALL_FUNCTION_VAR_KW gets executed. And you can look that opcode up in the docs, where it says:Calls a function. argc is interpreted as in CALL_FUNCTION. The top element on the stack contains the keyword arguments dictionary, followed by the variable-arguments tuple, followed by explicit keyword and positional arguments.So, the "variable-arguments tuple" is still separate.
Positional parameters must always appear before named and unpacked parameters.In the expression:The 2 is a positional parameter while c=3 is a named parameter.  It is invalid written this way.  You have to move the named parameter after all positional parameters.On the other hand, the expression:is valid.  1 is the only positional parameter here.  c=3 is a named parameter and *(2,) and **{'d':4} are unpacked.  It's all valid as long as the positional parameter comes first.


Answer URL
https://docs.python.org/3/reference/expressions.html#calls
https://docs.python.org/3/library/dis.html#opcode-CALL_FUNCTION_VAR_KW
