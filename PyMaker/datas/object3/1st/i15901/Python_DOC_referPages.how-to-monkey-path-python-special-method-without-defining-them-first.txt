Natural Text
Why does the followingPrint the following, but also throw an exception?GamesBrainiac is correct that I'm looking to monkey-patch an instance.  The reason for this is that the standard way to use the logging standard library is a combination of getLoggerClass/setLoggerClass and getLogger.  Using the former pair will override all future behavior (undesireable) and using the latter appears to preclude me from monkey-patching the object to have special behavior.
Apparently context manager functions only work with classes. You're defining them on the instance. From the python docs:Pythonâ€™s with statement supports the concept of a runtime context defined by a context manager. This is implemented using a pair of methods that allow user-defined classes to define a runtime context that is entered before the statement body is executed and exited when the statement ends:However, I did come up with this hack which I think will work for you:The first with works, but not the second.This is rather ugly and I'm not sure if there are side effects of setting __class__.
You have to "monkey-patch" the class of the respective instance:
Updated ResponseYou lambdas are unbound methods. When a is passed, it uses the __exit__ method of the class, not the instance. Since the class has no method, it's an attribute error.To demonstrate:prints:but when we assign an lambda, we still get the bound method:prints:You can mock the class method with the mock library (I had to get it from the Ubuntu repos for python 2 with `sudo apt-get install python-mock), unittest.mock in Python 3's standard lib:prints:Note that the original __exit__ method is no longer called.
Try this out, since __enter__ is bound to __class__:


Answer URL
https://docs.python.org/3/library/stdtypes.html#context-manager-types
