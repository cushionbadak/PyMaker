Natural Text
This is one of the things that happened since we've updated our bash ( due to the Shellshock thing )This is the code that I'm testing:First running the command:The second test, I add the following Python args:Output:My question is,I can't seem to understand why "env = env," mattered here.I tried running several commands such "export" etc to understand the different between with/without it - but the results are the same, also checked the "shell" both uses "sh". so I'm not really sure which part of the environment causing it not to work as example #1.I'm sure it's not really related to the Perforce itself, Perforce just probably needed some environment variables that somehow were affected due to this bash Shellshock thing.EDIT - clarifying @5gon12eder suggestionI tried reviewing the ENV without "env=env," ( which was an os.environ.copy() ), Note, that the P4 variables are configured twice:EDIT 2 - reproducing with Perl as well:The environment ignore the P4CONFIG entry in %ENV.EDIT 3 - There's a difference if I use/don't use >> and |Actually, when thinking about it, the whole problem was introduced when one of my libs had a "> /dev/null" redirect in the subprocess ( Python ) "cmd" example above which caused the script to hang and exit on timeout, I replaced it with "-o file-output" and the problem was gone, but then I fell into this issue so I opened this post.Just wanting to say again, that it was all working before the shellshock thing ( may a realted or maybe a coincidence ) but something is different in the environment of the exec() calls...Any ideas ?
Is your code modifying the environment?  The thing is that(potentially) modifies the environment directly but does not update os.environ whereas does.  From the Python documentation:Calling putenv() directly does not change os.environ, so it's better to modify os.environ.If putenv() is not provided, a modified copy of this mapping may be passed to the appropriate process-creation functions to cause child processes to use a modified environment.What becomes not so clear from this documentation but after reading the somewhat obscure source code of the os Python module and the accompanying posixmodule C module is that if the C library of the underlying platform does not have the putenv(3) C function, then setting keys in os.environ only affects the Python dictionary and os.putenv is a no-op.  From Lib/os.py:And from Modules/posixmodule.c:Therefore, you can observe different behavior in the two situations you show since – much to my surprise – if env=None is passed to the subprocess.Popen constructor, it does not substitute os.environ as a default, but uses the value from the C standard library.The code to set up the environment for the child process (in Lib/subprocess.py) isand did not change recently.  And from the man page of exec(3) (emphasis mine):The execle() and execvpe() functions allow the caller to specify the environment of the executed program via the argument envp.  The envp argument is an array of pointers to null-terminated strings and must be terminated by a null pointer.  The other functions take the environment for the new process image from the external variable environ in the calling process.I went into the source code of Modules/_posixsubprocess.c (for execv / execve) and Modules/posixmodule.c (for putenv) to check that they really call the system functions as described and from what I can tell, they appear to do so.  None of the two C modules has received a recent change that seems related to this functionality.My fist idea after reading your question was that eventually, the Python developers have introduced a sanity-check for the environment passed to subprocesses but it does not seem they have.  Sorry if this is kind of a non-answer but I thought it might still prove useful to others to help them avoid diving into the CPython source code.As a suggestion for further debugging, try runningand various variations to track down what is going on.Footnote: I consider the behavior of subprocess.Popen more a bug than a feature since it makes Python code behave differently on platforms that provide or don't provide the putenv C function for no good reason.
So I wanted to share the findings with everyone, in case someone else will be stuck on this for a while.The issue was, that we've had some exported functions in:Which caused the environment to behave different after the bash patch was implemented.Removing these functions solved the issue in all our scripts... and there were no changes needed for the environment variables anymore ..Thanks everyone for trying to help !


Answer URL
https://docs.python.org/3/library/os.html#os.environ
