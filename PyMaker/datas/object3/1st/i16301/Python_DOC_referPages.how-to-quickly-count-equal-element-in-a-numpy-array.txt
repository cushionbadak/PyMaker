Natural Text
I have a python matrixI would like to compute for each couple of rows the number of time they have the same element. In this case I would get a 4x4 matrix proximity This is the code that I am currently using. I need a faster solutionEDIT: The accepted solution does not work in this example 
Warren Weckesser offered a very beautiful solution using broadcasting. However, even a straightforward approach using a loop can have comparable performance. np.apply_along_axis is slow in your initial solution because it does not take advantage of vectorization. However the following fixes it:You could also use a list comprehension to make the above code more concise. The difference is that np.apply_along_axis would loop through all the rows in a non-optimized manner, while leafs == leafs[i] will take advantage of numpy speed. The solution from Warren Weckesser truly shows numpy's beauty. However, it includes the overhead of creating an intermediate 3-d array of size nrows*nrows*ncols. So if you have large data, the simple loop might be more efficient.Here's an example. Below is code offered by Warren Weckesser, wrapped in a function. (I don't know what are the code copyright rules here, so I assume this reference is enough :))Now let's evaluate the performance on an array of random integers of size 10000 x 100.I ran both examples in an IPython environment on the same machine. 
Here's one way, using broadcasting.  Be warned: the temporary array eq has shape (nrows, nrows, ncols), so if nrows is 4000 and ncols is 1000, eq will require 16GB of memory.Also note that this solution is inefficient: proximity is symmetric, and the diagonal is always equal to ncols, but this solution computes the full array, so it does more than twice as much work as necessary. 


Answer URL
https://docs.python.org/3/library/itertools.html
