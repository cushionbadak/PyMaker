Natural Text
I have something like this:       My problem is: let's assume that i=0. For that case, it is certain that I will have foo[0]. But for indices 1,2,3,4 foo can be empty. For example, if foo is empty for indices greater than 2, I want my text to be like:I thought of using exceptions, but I guess, I will not be able to construct text if I do not have all the indexed elements. (Iteration will stop?) So, what is the best practice to do that? I could not think of a short way to do it. Basically what I need is:ps: Please do not forget I assumed i=0 for the sake of simplicity. But in fact, generally I am going to have more than hundred values.edit: By saying "can be empty", I meant to say that the index might be beyond the size of the list.edit2: Abot foo:
My suggestion would be, do not rely on indices but rather structure your code around your data. If you are not indexing, then you would never have issues in IndexErrorConsider A List L of size N to be divided evenly of size n. This problem has various  accepted solutions and approachesThe one I generally preach (though you are free to accept any of the alternate approaches) isSo Given a List L = [a1, a2, a3 ... aN]This will generate  ⌊N/n⌋ equally sized chunks. The last shorter lists of size Mod(N, n) would be appended by a filler, default in this case is NoneL = [[a1, a2, a3 ... an],[a1, a2, a3 ... an],[a1, a2, a3 ... an],.(N Items)..[a1, a2, .. aN%n],None,None.. (n terms)]Now just iterate through this list of lists ignorining any Nones in the sublistsDemoOutput
You would take a different approach; you'd slice the original list, and use the csv module to handle tab-delimiting and newlines:Slicing on a list always returns a new list object, but if you use slice indices outside the valid range the result is a shorter or empty list:The csv.writer() object, meanwhile, takes care of writing the list as a tab-delimited string, plus a newline, to your file.Instead of using the csv module, you would still use slicing, but make use of other techniques that take arbitrary lists of elements. str.join() for example:would produce one string of tab-delimited values, with a newline appended. This does require that all values in the list passed to str.join() are already strings.
To expand on my comment, you could implement something like:Which you could use like:A demo:However, I suspect this to be an XY problem - if you provide more background information, it is likely that we can help you come up with a different approach that removes this issue entirely.
It depends on what foo is. If it is a list or tuple, there will be no empty indices. If it is a dict, referencing an unknown key will result in a KeyError exception.Assuming foo is a list of tuples, you can easily print it;You can iterate over that list of tuples and print them;


Answer URL
https://docs.python.org/3/library/csv.html
https://docs.python.org/3/library/stdtypes.html#str.join
