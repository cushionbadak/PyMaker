Natural Text
I am having difficulty getting my testing framework to work for a C-extension module for both Python2 and Python3. I like to run my docstrings through doctest to make sure that I am not feeding my users bad information, so I want to run doctest as part of my testing.I don't believe that the source of my problem is the docstrings themselves, but rather how the doctest module is trying to read my extension module.  If I run doctest with Python2 (on the module compiled against Python2), I get the output that I expect:However, when I do the same but with Python3, I get a UnicodeDecodeError:To get some more info, I ran it through pytest with full traceback:It looks like doctest is actually reading the .so file to get the docstrings (rather than importing the module), but Python3 doesn't know how to decode the input.  I can confirm this by replicating the byte string and traceback by trying to read the .so file myself:Has anyone else run into this problem before?  Is there a standard (or not-so-standard) way to get doctest to execute tests on C extension modules on python3?Update: I should also add that I get identical results on Travis-CI (see here), so it's not specific to my local build.
I have found a workaround to this problem so I will post it, but I find it rather unsatisfying.  I am still looking for more elegant/less hacky solutions to this.There are three problems with doctest.py that need to be overcome to make this work:1) Get doctest to consider .so files as python modules.If you look at the doctest.py source, you will notice in the test runner a block that looks similar to this (depending on the python version you are running):What is happening here is doctest.py is checking for the ".py" extension, and if so the file is loaded as a python module, but otherwise the file is read as if it were text (like a README.rst might be).  We need to get doctest.py to acknowledge that a file with ".so" extension is a python module.  To do this, simply add a check for the ".so" extension by modifying this if block to read2) Get doctest to identify the functions in the C-extension moduledoctest.py uses the inspect.isfunction function to determine what objects are functions when recursively searching for docstrings within a module object.  The problem with this function is that it only identifies functions written in python, not in C (python identifies C-extension functions as builtin).  So, to identify our functions when recursing through the module, we need to use inspect.isbuiltin instead.To rectify this, we need to locate the DocTestFinder._find method in doctest.py and change how it looks for functions.  I convertedto 3) Properly remove the version tag on the .so file (Python3 only).On Python3, C-extensions can be tagged with a version identifier (i.e. "myext.cpython-3mu.so", please see PEP 3149).  We need to know how to remove this when doing the initial import in the doctest.py test runner.To do this, I converted the linetoThis is only needed for Python3.After making these modifications, I can get doctest to work as expected on both Python2 and Python3.  Since these modifications are rather annoying, I have made a patch_doctest.py script that does this automatically and puts the patched doctest.py in your current directory.  You can get this file here if you want to use it.  You can then run the tests on the extension modules like thisAs evidence that this works, here are the new Travis-CI results.


Answer URL
https://docs.python.org/3/library/inspect.html#inspect.isfunction
https://docs.python.org/3/library/inspect.html#inspect.isbuiltin
