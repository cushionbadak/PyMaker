Natural Text
Python doc says that slicing a list returns a new list.Now if a "new" list is being returned I've the following doubts related to "Assignment to slices"Now the output would be:How can something that is returning something come on the left side of expression.Yes, I read the docs and it says it is possible, now since slicing a list returns a "new" list,why is the original list being modified, I am not able to understand the mechanics behind it.
You are confusing two distinct operation that use very similar syntax:1) slicing:This makes a copy of the slice of a and assigns it to b.2) slice assignment:This replaces the slice of a with the contents of b.Although the syntax is similar (I imagine by design!), these are two different operations.
When you specify a on the left side of the = operator, you are using Python's normal assignment, which changes the name a in the current context to point to the new value.  This does not change the previous value to which a was pointing.By specifying a[0:2] on the left side of the = operator, you are telling Python you want to use Slice Assignment.  Slice Assignment is a special syntax for lists, where you can insert, delete, or replace contents from a list:Insertion:Deletion:Replacement:Note:The length of the slice may be different from the length of the  assigned sequence, thus changing the length of the target sequence, if  the target sequence allows it. - sourceSlice Assignment provides similar function to Tuple Unpacking.  For example, a[0:1] = [4, 5] is equivalent to:With Tuple Unpacking, you can modify non-sequential lists:However, tuple unpacking is limited to replacement, as you cannot insert or remove elements.Before and after all these operations, a is the same exact list.  Python simply provides nice syntactic sugar to modify a list in-place.
I came across the same question before and it's related to the language specification. According to assignment-statements,If the left side of assignment is subscription, Python will call __setitem__ on that object. a[i] = x is equivalent to a.__setitem__(i, x).If the left side of assignment is slice, Python will also call __setitem__, but with different arguments:a[1:4]=[1,2,3] is equivalent to a.__setitem__(slice(1,4,None), [1,2,3])That's why list slice on the left side of '=' behaves differently.
By slicing on the left hand side of an assignment operation, you are specifying which items to assign to.


Answer URL
https://docs.python.org/3/reference/simple_stmts.html#assignment-statements
https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences
