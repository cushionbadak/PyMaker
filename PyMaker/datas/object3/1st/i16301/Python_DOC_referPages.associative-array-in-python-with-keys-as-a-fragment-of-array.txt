Natural Text
How to better implement such thing:Loop over the numbers. Each number in diapason and belong to one part of associative array.E.g.Edit: Populate whole di with discreet numbers is not my way, because I'm talking about IP addresses,  really big data, such as netmasks 255.255.255.255. Such di will overflow my RAM. 
I would create a custom dict that takes xranges as keys :The drawback is that you have to go through all the keys to find your element. Use like that :See http://repl.it/WAJUpdateUsing bisect and assuming that you can spare some time during initialization to speed up access, you can do something like:the get will be O(logn) where n is the number of keys, but the set will become O(n). As for the next solution, it relies on the ranges being contiguous.Other solutionAn other solution, which could be faster, depending on your range sizes, would be to use as key the first item of the range, and a bisect to find the proper key:This will be much faster. bisect is O(logn) where n is the number of ranges, the rest is O(1)
yieldsNote that xrange(N, M) generates ints starting at N and ending at M-1 (inclusive). So if you want to include 10, 20 in the keys, then the xranges should be xrange(10, 20) and xrange(20, 30).
You could use tuples instead of lists to solve the TypeError (which your code doesn't raise FWIW) but the lookup still wouldn't work. The simplest thing that could possibly work would be to populate you dict with every discrete key for a given value, ie:
If you don't want to populate a dictionary just use a function, Otherwise, if you want to populate a dictionary do the following.  Your current code is generating xrange objects and using them as keys.  However, that is not the same as using the numbers for keys.  Try the following, If you only want a subset of the letters you can slice string.ascii_uppercase.  For example using string.ascii_uppercase[0:3] will just give you A, B, and C. 


Answer URL
https://docs.python.org/3/howto/ipaddress.html
