Natural Text
I'm trying to teach myself about how python bytecode works so I can do some stuff with manipulating functions' code (just for fun, not for real usage) so I started with some simple examples, such as:The bytecode is*:So it makes sense to me that 124 is the LOAD_FAST bytecode, and the name of the object being loaded is f.__code__.co_varnames[0] where 0 is the number after 124. And 100 indicates a LOAD_CONST to load f.__code__.co_consts[1] where 1 is the number after 100. But then there are a bunch of auxiliary zeros, like the second and third and fifth zeros that seem to serve no purpose, at least to me. What do they indicate?Textual bytecode:*Note: In Python 3 (where bytecodes may be different from above), the bytecode can be found via:
A large number of bytecodes take arguments (any bytecode with a codepoint at or over dis.HAVE_ARGUMENT. Those that do have a 2-byte argument, in little-endian order.You can see the definition for what bytecodes Python currently uses and what they mean in the dis module documenation.With 2 bytes you can give any bytecode an argument value between 0 and 65535, for bytecodes than need more, you can prefix the bytecode with the EXTENDED_ARG bytecode, adding 2 more bytes for a value between 0 and 4294967295. In theory you could use EXTENDED_ARG multiple times, but the CPython interpreter uses int for the oparg variable and is thus for practical purposes limited to 4-byte values.As of Python 3.4 the dis module provides you with Instruction instances that make it easier to introspect each bytecode and their arguments. Using this we can walk through the byte codes you found for your function f:So the first opcode, 124 or LOAD_FAST puts the value for first local name on the stack; this is the 0 0 argument, little-endian interpreted as integer 0, an index into the code locals array. dis has filled out the argval attribute, showing us that the first local name is x. In the above session I show how you can introspect the code object to see the list of names.The next instruction pushes a constant onto the stack; the argument is now 1 0, or little-endian for integer 1; the second constant associated with the code object. The f.__code__.co_consts tuple shows that it is 3, but the Instruction object gives it too, as the argval attribute.Next we have another LOAD_FAST, pushing another reference to local name x onto the stack.This is a bytecode without argument, the opcode 27 is below dis.HAVE_ARGUMENT. No argument is needed, because this opcode takes the top two values on the stack, divides them, pushing the floating point result back on the stack. So the last x and the 3 constant are taken, divided and the result is push back on.Another argument-less bytecode; this one adds up the top two stack values, replacing those with the outcome. The outcome of the BINARY_TRUE_DIVIDE is taken, and the value of x that was pushed on first, and the result is put back on the stack.Last instruction, and another that doesn't take arguments. RETURN_VALUE ends the current frame, returning the top value from the stack as the result to the caller.
Before CPython 3.6, CPython bytecode arguments take 2 bytes. The extra zeros are the high bytes of the arguments.


Answer URL
https://docs.python.org/3/library/dis.html#opcode-HAVE_ARGUMENT
https://docs.python.org/3/library/dis.html#opcode-HAVE_ARGUMENT
https://docs.python.org/3/library/dis.html#opcode-EXTENDED_ARG
https://docs.python.org/3/library/dis.html#dis.Instruction
