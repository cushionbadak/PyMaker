Natural Text
In Python 2.x, the built-in round has the following behavior:if two multiples are equally close, rounding is done away from 0 (so. for example, round(0.5) is 1.0 and round(-0.5) is -1.0)In Python 3.x, this has changed to the more common:if two multiples are equally close, rounding is done toward the even choice (so, for example, both round(0.5) and round(-0.5) are 0, and round(1.5) is 2).Is there an easy way to get this behavior in Python 2.x? Unfortunately, the future_builtins module doesn't include this. Maybe there's another similar module I haven't found yet? Or, another way to pull Python 3.x functions into Python 2.x?Obviously, I could write a new function that produces the desired behavior, but I'm more curious if a solution exists that uses the actual Python 3.x function, to avoid adding unnecessary complexity and code to maintain.
Unless you mind a numpy dependency, numpy.around may do the thing:
Python 3 round in Python 2The function can look like this:Let me clarify what round does in bltinmodule.cSo round actually does almost nothing. It depends on the objects passed to it.That leads to floatobject.c function static PyObject *double_round(double x, int ndigits)I used the knowledge of these lines in my function above.Python 2 round in Python 3I think you need to write a new function. The if statement handles the case that i + 0.5 and i + 1.5 are rounded into different directions = to even numbers and halves. In this case the rounding is done away from zero.Do you need a solution with the second argument to round, ndigits?
This response has read the original question, and the answer is "Nope, I can't come up with something that uses the Py3 original code."But for anyone who is wondering what the code would be that would replicate Py3 behavior in Py2 (including the int vs. float behavior), here's an adaptation of the User code above that includes ndigits and the int vs. float distinction for ndigits = None vs 0.
If you're super-paranoid about floating point rounding issues, you can look into the decimal library where you can configure the rounding mode (defaults to ROUND_HALF_EVEN).Otherwise, I think it's more explicit and more maintainable if you just write your own function or use numpy, rather than wish that you could use a py3 function in py2.
Use decimal.Decimal.to_integral_valueFor example:The rounding options are documented here. The two options we are concerned with are:



Answer URL
