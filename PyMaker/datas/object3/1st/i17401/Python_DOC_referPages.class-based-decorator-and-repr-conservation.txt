Natural Text
I was trying to have my class-based decorator keeping the repr() behavior of the original wrapped function (to match the way the functools.wraps decorator works on functions). I am using python 3.3.First I tried functools:But when I call repr() on the decorated function, I get:Very well, so I tried to customize the __repr__ method of my decorator, which is supposed to be called by repr().Using functools again:Doesn't change the output, but something interesting happens:Explicitly setting the __repr__ method of the decorator instance has the same effect.After a little more tests I deduced repr(instance) actually calls instance.__class__.__repr__(instance). Thus the overriden __repr__ method of the instance is never called.So here are my questions:Why does repr(instance) call the instance.__class__.__repr__(instance) instead of instance.__repr__()? Or have I missed something else?How would you fully reproduce what functools.wraps does with function-based decorators to class-based decorators (including altering the result of repr() calls on the decorated function)?
Special methods are always looked up on the type of the instance (here the class object), not on the instance.  Otherwise a __repr__ on a class would be used when you tried to print the representation of the class itself; type(class).__repr__(class) would use the correct magic method, while class.__repr__() would raise an exception because self was not provided.Implement your own __repr__ hooks:e.g. still copy over the __module__, __name__ and __doc__ attributes, and copy over the attributes from the function __dict__, but make any special methods a proxy.


Answer URL
