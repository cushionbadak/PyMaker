Natural Text
Today I'm learning using * and ** to unpack arguments.I find that both list, str, tuple, dict can be unpacked by *.I guess because they are all iterables. So I made my own class.It works! But how to make a mapping object like dict in python so that ** unpacking works on it? Is it possible to do that? And is there already another kind of mapping object in python except dict?PS:I know I can make an object inherit from dict class to make it a mapping object. But is there some key magic_method like __iter__ to make a mapping object without class inheritance?PS2:With the help of @mgilson's answer, I've made an object which can be unpacked by ** without inherit from current mapping object:Be aware, when unpacking using **, the key in your mapping object should be type str, or TypeError will be raised.
Any mapping can be used.  I'd advise that you inherit from collections.Mapping or collections.MutableMapping1.  They're abstract base classes -- you supply a couple methods and the base class fills in the rest.Here's an example of a "frozendict" that you could use:And usage is just:To answer your question about which "magic" methods are necessary to allow unpacking -- just based on experimentation alone -- in Cpython a class with __getitem__ and keys is enough to allow it to be unpacked with **.  With that said, there is no guarantee that works on other implementations (or future versions of CPython).  To get the guarantee, you need to implement the full mapping interface (usually with the help of a base class as I've used above).In python2.x, there's also UserDict.UserDict which can be accessed in python3.x as collections.UserDict -- However if you're going to use this one, you can frequently just subclass from dict.1Note that as of Python3.3, those classes were moved to thecollections.abc module.
First, let's define unpacking:Now, the structure: two built-in options available are collections.abc.Mapping and collections.UserDict. As there's another answer exploring highly-customizable Mapping type,  I will focus on UserDict: UserDict can be easier to start with if all you need is a basic dict structure with some twist. After definition, underlying UserDict dictionary of is also accessible as .data attribute. 1.It can be used inline, like so: Breaking UserDict into key=value pairs:2.If subclassing, all you have to do is to define self.data within __init__. Note that i expanded the class with additional functionality with (self+other) 'magic' methods:Usage is:Adding other dict (or any mapping type) to it will call __add__, returning new object:In-place modification with __iadd__ will return the same object (same id in memory)Btw, i agree with other contributors that you should also be familiar with collections.abc.Mapping and brethren types. For basic dictionary exploration  UserDict has all the same features and does not require from you to override abstract methods before becoming usable.


Answer URL
https://docs.python.org/3/library/collections.abc.html#collections.abc.Mapping
