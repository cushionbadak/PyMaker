Natural Text
The indices of a slice slice(start, stop[, step]) can be often represented by range(start, stop, step) (or range(*slice(start, stop, step).indices(length)) when taking the underlying dimensions into account).Let's say I have even two, multidimensional slices and the second slice could be used as a slice into the result of applying the first slice.Example:I would like to find a general expression for calculating the single slice that does the same job. I know the dimensions of the underlying data structure.So, in getting from [::2, 7, :] and [1, ::-1] to [2, 7, ::-1]  in this example I would need a function like:where outer_slice and inner_slice would both be a tuple of slices. In the example shape=(100, 100, 100) and outer_slice=(slice(None, None, 2), 7, slice(None, None, None)) and inner_slice=(1, slice(None, None, -1)).I'm not sure how to do that efficiently.My objects do something when __getitem__(slice) is called (no intermediate views) and I want to do that only once but still have the possibility to have slices of slices.As an extension (optional) I would like to know what happens if I have ellipses in the slices. How can I then make the combination?
I suspect you just have to go through the tedium of a analyzing each dimension, to build up either a new slice or an array of indices.  I doubt if there's a short cut.To illustrate take your example:The target is (right?):First dimension - make an array of the whole range of indices, and slice them sequentially:Could I deduce that from [::2] and [1]?  I have to reason that it starts at 0, the shape is large enough to yield a 2nd value, etc Now for the 2nd dimension.  That's a scalar, so there's no corresponding inner slice.For the third, let's do that same as with the 1st, but taking into account the offset between outer and inner lists:Or I could deduce that outer_slice[2] does nothing, so I can use inner_slice[1] directly.Of course it would be just as easy and efficient to apply the two slice tuples to the actual array.As long as outer_slice produces a view, combining them into a composite slice is not much of an improvement.With shape and the slice tuples there's enough information to build a new tuple.  But it appears that the required logic will be quite involved, and require an in depth knowledge of slicing, and lots of testing.
Let's start with the simple case: 1-d arrays. We'll need to keep track of the start, stop, and step values for the final slice, which we can update like so:Note that this expects a and b to be slices. You can usually convert other forms into slice objects, though. This even includes Ellipsis objects, assuming you know how many dimensions you have.To extend this to the multidimensional case, we'll need to do some bookkeeping to keep track of which original dimension is getting sliced. For example, if you have data[::2, 7, :][:, 2:-2], you'll have to map the second dimension of the second slice to the third dimension of the first slice.


Answer URL
https://docs.python.org/3/reference/datamodel.html?highlight=slice.indices#slice.indices
