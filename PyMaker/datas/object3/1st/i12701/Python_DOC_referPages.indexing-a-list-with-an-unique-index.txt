Natural Text
I have a list say l = [10,10,20,15,10,20]. I want to assign each unique value a certain "index" to get [1,1,2,3,1,2].This is my code:Which turns out to be very slow. l has 1M elements, and 100K unique elements. I have also tried map with lambda and sorting, which did not help. What is the ideal way to do this?
The slowness of your code arises because a.index(x) performs a linear search and you perform that linear search for each of the elements in l.  So for each of the 1M items you perform (up to) 100K comparisons.The fastest way to transform one value to another is looking it up in a map.  You'll need to create the map and fill in the relationship between the original values and the values you want.  Then retrieve the value from the map when you encounter another of the same value in your list.Here is an example that makes a single pass through l.  There may be room for further optimization to eliminate the need to repeatedly reallocate res when appending to it.
You can do this in O(N) time using a defaultdict and a list comprehension:In Python 3 use __next__ instead of next.If you're wondering how it works?The default_factory(i.e count(1).next in this case) passed to defaultdict is called only when Python encounters a missing key, so for 10 the value is going to be 1, then for the next ten it is not a missing key anymore hence the previously calculated 1 is used, now 20 is again a missing key and Python will call the default_factory again to get its value and so on.d at the end will look like this:
Well I guess it depends on if you want it to return the indexes in that specific order or not. If you want the example to return:then you can look at the other answers submitted. However if you only care about getting a unique index for each unique number then I have a fast solution for youand for this example the output of y is:I tested this for 1,000,000 entries and it was done essentially immediately.
Your solution is slow because its complexity is O(nm) with m being the number of unique elements in l: a.index() is O(m) and you call it for every element in l.To make it O(n), get rid of index() and store indexes in a dictionary:If l contains only integers in a known range, you could also store indexes in a list instead of a dictionary for faster lookups.
You can use collections.OrderedDict() in order to preserve the unique items in order and, loop over the enumerate of this ordered unique items in order to get a dict of items and those indices (based on their order) then pass this dictionary with the main list to operator.itemgetter() to get the corresponding index for each item:
For completness, you can also do it eagerly:  This uses a set to obtain the unique words in list_, pairs  each of those unique words with the next value from count() (which  counts upwards), and constructs a dictionary from the results.Original answer, written by nneonneo.


Answer URL
https://docs.python.org/3/library/stdtypes.html#iterator.__next__
