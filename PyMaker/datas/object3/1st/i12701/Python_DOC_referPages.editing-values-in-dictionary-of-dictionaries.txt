Natural Text
Can someone please explain this to me? This doesn't make any sense to me.I copy a dictionary into another and edit the second and both are changed. Why is this happening?
Python never implicitly copies objects. When you set dict2 = dict1, you are making them refer to the same exact dict object, so when you mutate it, all references to it keep referring to the object in its current state.If you want to copy the dict (which is rare), you have to do so explicitly withor
When you assign dict2 = dict1, you are not making a copy of dict1, it results in dict2 being just another name for dict1.To copy the mutable types like dictionaries, use copy / deepcopy of the copy module.

On python 3.5+ there is an easier way to achieve a shallow copy by using the ** unpackaging operator. Defined by Pep 448.** unpackages the dictionary into a new dictionary that is then assigned to dict2. We can also confirm that each dictionary has a distinct id. If a deep copy is needed then copy.deepcopy() is still the way to go. 
You can also just make a new dictionary with a dictionary comprehension.  This avoids importing copy.Of course in python >= 2.7 you can do:But for backwards compat., the top method is better.
The best and the easiest ways to create a copy of a dict in both Python 2.7 and 3 are... To create a copy of simple(single-level) dictionary:1. Using dict() method, instead of generating a reference that points to the existing dict.2. Using the built-in update() method of python dictionary. To create a copy of nested or complex dictionary:Use the built-in copy module, which provides a generic shallow and deep copy operations. This module is present in both Python 2.7 and 3.*
Assignment statements in Python do not copy objects, they create bindings between a target and an object. so, dict2 = dict1, it results another binding between dict2and the object that dict1 refer to.if you want to copy a dict, you can use the copy module.The copy module has two interface:The difference between shallow and deep copying is only relevant for compound objects (objects that contain other objects, like lists or class instances):A shallow copy constructs a new compound object and then (to the extent possible) inserts references into it to the objects found in the original.A deep copy constructs a new compound object and then, recursively, inserts copies into it of the objects found in the original.For example, in python 2.7.9:and the result is:
In addition to the other provided solutions, you can use ** to integrate the dictionary into an empty dictionary, e.g.,shallow_copy_of_other_dict = {**other_dict}. Now you will have a "shallow" copy of other_dict. Applied to your example:Pointer: Difference between shallow and deep copys
You can copy and edit the newly constructed copy in one go by calling the dict constructor with additional keyword arguments:
This confused me too, initially, because I was coming from a C background.In C, a variable is a location in memory with a defined type. Assigning to a variable copies the data into the variable's memory location.But in Python, variables act more like pointers to objects. So assigning one variable to another doesn't make a copy, it just makes that variable name point to the same object.
Every variable in python (stuff like dict1 or str or __builtins__ is a pointer to some hidden platonic "object" inside the machine.If you set dict1 = dict2,you just point dict1 to the same object (or memory location, or whatever analogy you like) as dict2. Now, the object referenced by dict1 is the same object referenced by dict2.You can check: dict1 is dict2 should be True. Also, id(dict1) should be the same as id(dict2).You want dict1 = copy(dict2), or dict1 = deepcopy(dict2).The difference between copy and deepcopy? deepcopy will make sure that the elements of dict2 (did you point it at a list?) are also copies.I don't use deepcopy much - it's usually poor practice to write code that needs it (in my opinion).
dict2 = dict1 does not copy the dictionary. It simply gives you the programmer a second way (dict2) to refer to the same dictionary.
dict1 is a symbol that references an underlying dictionary object. Assigning dict1 to dict2 merely assigns the same reference. Changing a key's value via the dict2 symbol changes the underlying object, which also affects dict1. This is confusing.It is far easier to reason about immutable values than references, so make copies whenever possible:This is syntactically the same as:
Because python works with reference, so when you did dict2 = dict1 you pass a reference to dict2, that was the same as dict1. So, when you make a change in dict1 or dict2 you change a reference, and both dicts chages. Sorry if I mistake something on English. 
As others have explained, the built-in dict does not do what you want. But in Python2 (and probably 3 too) you can easily create a ValueDict class that copies with = so you can be sure that the original will not change.Please refer to the lvalue modification pattern discussed here: Python 2.7 - clean syntax for lvalue modification. The key observation is that str and int behave as values in Python (even though they're actually immutable objects under the hood). While you're observing that, please also observe that nothing is magically special about str or int. dict can be used in much the same ways, and I can think of many cases where ValueDict makes sense.
There are many ways to copy Dict object, I simply use
because, dict2 = dict1, dict2 holds the reference to dict1. Both dict1 and dict2 points to the same location in the memory. This is just a normal case while working with mutable objects in python. When you are working with mutable objects in python you must be careful as it is hard to debug. Such as the following example.This example intention is to get all the user ids including blocked ids.That we got from ids variable but we also updated the value of my_users unintentionally. when you extended the ids with blocked_ids my_users got updated because ids refer to my_users.
Nice explanations, I want to add the simplest rule you can refer to when thinking of Python variables which you assign equal with =. If the data type is immutable, you don't have to worry about the unexpected behavior you encountered. If the data type is mutable, you want to make sure you make a copy of it to prevent the unexpected behavior your encountered.Immutable data types: string (a tuple of characters), tupleMutable data types: list, array, dictionary
You can use directly:where object dict2 is an independent copy of dict1, so you can modify dict2 without affecting dict1.This works for any kind of object.


Answer URL
https://docs.python.org/3/library/copy.html
