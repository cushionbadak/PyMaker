Natural Text
I would like to remove certain symbols from a string. I only want to remove symbols that are between letters. If my question wasn't clear enough then here are some examples:symbols are @31!InputExpected OutputCan you point me in the right direction? I'm not expecting you to do it for me. I know this can be done with regex and with for loops but regex seems a bit difficult for a beginner like myself. Here's what I'm working on right now: I'm aware that this script replaces all symbols
Regular expressions are definitely scary at first, but it's worth trying to learn them, as they end up being very useful. What you want in this case is:Let's look at what this does.re.sub is similar to str.replace, but it uses regular expressions.[a-zA-Z] matches any letter.[@31!]+ matches one or more of the listed symbols.+  causes the resulting RE to match 1 or more repetitions of the preceding RE.(?=[a-zA-Z]) is a lookahead assertion for a letter. This means that the match is followed by a letter, but the letter is not part of the match.(?=...)  matches if ... matches next, but doesn’t consume any of the string. This is called a lookahead assertion. For example, Isaac (?=Asimov) will match 'Isaac ' only if it’s followed by 'Asimov'.So ([a-zA-Z])[@31!]+(?=[a-zA-Z]) matches a letter followed by one or more symbols from the list. This match is followed by a letter, but the match does not include the letter.\1 is a back-reference to the parenthesized group in the regular expression, in this case [a-zA-Z]. That's what we want to replace what we found with.(the rs before the strings are to make them raw strings, which often helps when using regular expressions.)Edit:As @ctwheels pointed out, you can also use a lookbehind assertion rather than a backreference:
This is tricky to do correctly. Although I generally prefer to avoid regex unless they're necessary, this is definitely a case where they make the job a lot easier. But anyway, here's a non-regex solution. We use the standard groupby function to break the input string up into three kinds of groups: 'A' groups contain letters, 'S' groups contain the special symbols, 'O' groups contain anything else. Then we scan over the groups, copying them to the result list unless the group is an 'S' group and it has an 'A' group immediately before it and immediately following it. Finally, we join the copied groups back into a single string.In order to make it easier to check the following group, we add a "fake" group of ('O', '') to the end of the list of groups. That way every real group has a following group.output
CodeSee this regex in use hereResultsInputOutputExplanation(?<=[a-z]) Positive lookbehind ensuring what precedes is a letter between a and z[@13!]+ Match one or more characters present in the set @13!(?=[a-z]) Positive lookahead ensuring what follows is a letter between a and zUsing i flag makes the pattern case-insensitive, thus a-z also matches A-ZUsageor (flag in the regex as opposed to passed to the function)


Answer URL
https://docs.python.org/3/library/re.html
https://docs.python.org/3/library/re.html#re.sub
https://docs.python.org/3/library/itertools.html#itertools.groupby
https://docs.python.org/3/library/functions.html#enumerate
