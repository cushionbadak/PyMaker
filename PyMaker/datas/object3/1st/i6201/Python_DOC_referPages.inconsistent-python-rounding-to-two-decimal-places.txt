Natural Text
I was just re-reading What’s New In Python 3.0 and it states:The round() function rounding strategy and return type have changed.  Exact halfway cases are now rounded to the nearest even result instead  of away from zero. (For example, round(2.5) now returns 2 rather than  3.)andthe documentation for round:For the built-in types supporting round(), values are rounded to the  closest multiple of 10 to the power minus n; if two multiples are  equally close, rounding is done toward the even choiceSo, under v2.7.3:as I'd have expected. However, now under v3.2.3:This seems counter-intuitive and contrary to what I understand aboutrounding (and bound to trip up people). English isn't my native language butuntil I read this I thought I knew what rounding meant :-/  I am sureat the time v3 was introduced there must have been some discussion ofthis, but I was unable to find a good reason in my search.Does anyone have insight into why this was changed to this?Are there any other mainstream programming languages (e.g., C, C++, Java, Perl, ..) that do this sort of (to  me inconsistent) rounding?What am I missing here?UPDATE: @Li-aungYip's comment re "Banker's rounding" gave me the right search term/keywords to search for and I found this SO question: Why does .NET use banker's rounding as default?, so I will be reading that carefully.
Python 3.0's way is considered the standard rounding method these days, though some language implementations aren't on the bus yet.The simple "always round 0.5 up" technique results in a slight bias toward the higher number. With large numbers of calculations, this can be significant. The Python 3.0 approach eliminates this issue.There is more than one method of rounding in common use. IEEE 754, the international standard for floating-point math, defines five different rounding methods (the one used by Python 3.0 is the default). And there are others.This behavior is not as widely known as it ought to be. AppleScript was, if I remember correctly, an early adopter of this rounding method. The round command in AppleScript actually does offer several options, but round-toward-even is the default as it is in IEEE 754. Apparently the engineer who implemented the round command got so fed up with all the requests to "make it work like I learned in school" that he implemented just that: round 2.5 rounding as taught in school is a valid AppleScript command.  :-)
You can control the rounding you get in Py3000 using the Decimal module:
Just to add here an important note from documentation:https://docs.python.org/dev/library/functions.html#roundNoteThe behavior of round() for floats can be surprising: for example,  round(2.675, 2) gives 2.67 instead of the expected 2.68. This is not a  bug: it’s a result of the fact that most decimal fractions can’t be  represented exactly as a float. See Floating Point Arithmetic: Issues  and Limitations for more information.So don't be surprised to get following results in Python 3.2:
I recently had problems with this, too. Hence, I have developed a python 3 module that has 2 functions trueround() and trueround_precision() that address this and give the same rounding behaviour were are used to from primary school (not banker's rounding). Here is the module. Just save the code and copy it in or import it. Note: the trueround_precision module can change the rounding behaviour depending on needs according to the ROUND_CEILING, ROUND_DOWN, ROUND_FLOOR, ROUND_HALF_DOWN, ROUND_HALF_EVEN, ROUND_HALF_UP, ROUND_UP, and ROUND_05UP flags in the decimal module (see that modules documentation for more info). For the functions below, see the docstrings or use help(trueround) and help(trueround_precision) if copied into an interpreter for further documentation.Hope this helps,Narnie
Python 2 rounding behaviour in python 3.Adding 1 at the 15th decimal places.Accuracy upto 15 digits.
Python 3.x rounds .5 values to a neighbour which is evenhowever, one can change decimal rounding "back" to always round .5 up, if needed :
Some cases:For fix:If you want more decimals, for example 4, you should add (+ 0.0000001).Work for me.
Sample Reproduction:API: https://docs.python.org/3/library/functions.html#roundStates:Return number rounded to ndigits precision after the decimal point. If  ndigits is omitted or is None, it returns the nearest integer to its  input.For the built-in types supporting round(), values are rounded to the  closest multiple of 10 to the power minus ndigits; if two multiples  are equally close, rounding is done toward the even choice (so, for  example, both round(0.5) and round(-0.5) are 0, and round(1.5) is 2).  Any integer value is valid for ndigits (positive, zero, or negative).  The return value is an integer if ndigits is omitted or None.  Otherwise the return value has the same type as number.For a general Python object number, round delegates to  number.round.Note The behavior of round() for floats can be surprising: for  example, round(2.675, 2) gives 2.67 instead of the expected 2.68. This  is not a bug: it’s a result of the fact that most decimal fractions  can’t be represented exactly as a float. See Floating Point  Arithmetic: Issues and Limitations for more information.Given this insight you can use some math to resolve itnow you can run the same test with my_round instead of round.
The round operator will round off the value to nearest integer value. For Example: If value is greater than o.5 than it will round off to 1If value is less than 0.5 than it will round off to 0Edit:Previously mentioned // operator is not used for rounding off, it is used e.g to handle the division's float output.


Answer URL
https://docs.python.org/3/library/functions.html#round
