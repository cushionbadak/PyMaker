Natural Text
I have a list containing strings:where each string is, in fact, a category of a corpus, and I need a list of integers that corresponds to the index of that category.For this purpose, I built a list of tuples where I have each (unique) category and its index, f.ex:I now need to iterate over the first list of strings, and if the element matches any of the second elements of the tuple, return the tuple's first element to an array, like this:for now I have but this clearly doesn't work and I'm failing to get to the solution. Any tips would be appreciated.
You were close, after iterating the inner loop, you should check whether the item from the outer loop is actually equal to the tup[1] (each tup represent (0, 'a') or (1, 'b') for example).if they equal, just append the first element in tup (tup[0]) to the result list.You also can use list comprehension:
During the iteration, i is a direct reference to an element of catlist, not its index. I'm not using i to extract an element from lst, the for ... in ... already takes care of that. As i is a direct reference to a tuple, I can simply extract the relevant fields for matching and appending without the need  to mess with the indexing of lst.
I would recommend using a dictionary for your catlist instead. I think it more naturally fits what you are trying to do:
Condition defines in if block is not correct.Try this..
You can create a dictionary (we call it d) from catlist and reverse it. Now, for each element i of lst, what you're looking for is d[i]:Output:
An efficient way for big lists :step 1 : build  the good dictionary. step 2 : use it.This way the execution time will grow like len(lst) + len(catlist) instead of len(lst) x len(catlist).


Answer URL
https://docs.python.org/3/tutorial/datastructures.html#dictionaries
