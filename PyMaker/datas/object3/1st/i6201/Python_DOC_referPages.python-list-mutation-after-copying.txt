Natural Text
In the top snippet of code, I've made a copy of a list and modified it. I then set the original to the copy and then it works. What confuses me is why doing this process outside of a function works but if I were to do it inside a function (the 2nd snippet of code), it fails?For reference, the code returns:EDIT: I know that calling input_list[0] = 10 works. I just want to know what makes this different from what I showed above all in memory? 
In mutation, input_list starts out pointing at the same object as sample_list, but later you make it point at list_copy.sample_list is not modified. It is still pointing at the original object.When you do it outside of the function you change sample_list to point to the new object before printing it.
I think that using the built-in function id to show the object ID will help here. If the ID of two variable names gives the same result then they refer to the same object; otherwise the objects are different.In the above, we see that after input_list = list_copy, the name input_list refers to identically the same object in memory as list_copy, which means it no longer refers to the list given as the function argument. This is why the mutation you expect does not work - you are modifying an entirely different object.
That's because you sets new value for input_list which is local variable of mutation function.The simplest solution is changing value of first element of list passed as argument:Otherwise you can write function which changes value of global variable called sample_list


Answer URL
https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference
