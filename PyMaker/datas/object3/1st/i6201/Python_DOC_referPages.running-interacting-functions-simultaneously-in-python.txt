Natural Text
So I'm trying to build a robot that can drive autonomously. For that I need the robot to drive forward and check distance at the same time. And if distance is less than preferred distance, stop forward movement. By now I've written this code below, but it doesn't seem to run simultaneously and they also don't interact. How can I make it that these two functions do indeed interact. If there's anymore information needed I'm happy to supply you. Thanks!
So, there's some serious problems with the code you posted. First,  you don't want the distance_check process to finish, because it's running a while loop. You should not do p2.join(), nor should you be starting new processes all the time in your while loop. You're mixing too many ways of doing things here - either the two children run forever, or they each run once, not a mix. However, the main problem is that the original processes can't communicate with the original process, even via global (unless you do some more work). Threads are much more suited to this problem.You also have a return inside your distance_check() function, so no code below that statement gets executed (including the sleep, and the setting of constant1 (which should really have a better name).In summary, I think you want something like this:Since you specified python-3.x in your tags, I've also corrected your print.Obviously I can't check that this will work as you want it to because I don't have your robot, but I hope that this is at least somewhat helpful.
One issue with your multiprocessing solution is that distance_check returns and stopsIt seems like you are trying to exchange information between the processes: which is typically done using Queues or Pipes.I read between the lines of your question and came up with the following specs:a robot moves if its speed is greater than zerocontinually check for obstacles in front of the robotstop the robot if it gets to close to something.I think you can achieve your goal without using multiprocessing. Here is a solution that uses generators/coroutines.  For testing purposes, I have written my own versions of a robot and an obstacle sensor - trying to mimic what I see in your codeDecorator to start a coroutine/generator:A producer to continually check to see if it is safe to moveA generator/coroutine that consumes safe-to-move signals and changes the robot's speed as needed.The robot's speed should change as fast as the obstacle sensor can produce distances.  The robot will move forward till it gets close to something and just stop and it all shuts down.  By tweaking the logic a bit in forward and can_move you could change the behaviour so that the generators/coroutines keep running but send a zero speed command as long as something is in front of it then when the thing gets out of the way (or the robot turns) it will start moving again.Usage:While this works in Python 3.6, it is based on a possibly outdated notion/understanding of generators and coroutines.  There may be a different way to do this with some of the async additions to Python 3+.


Answer URL
https://docs.python.org/3/library/multiprocessing.html#exchanging-objects-between-processes
https://docs.python.org/3/library/queue.html
