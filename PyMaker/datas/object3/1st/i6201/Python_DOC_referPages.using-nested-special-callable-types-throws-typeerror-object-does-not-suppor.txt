Natural Text
Consider the following ClassTo provide an indexed in-place add operator, I defined a Helper class (similar to iterator pattern) and provided the next level operator to be called on the instance of the class.For example, I intended to provide the following operator behaviourUnfortunately, Python did not like it and complainedInterestingly, if I assign the result of getitem, it just worksLooks like, I simply do not understand the behaviourNevertheless, for in-place add, it does invokes the setitem and the only way to get over it is to override the setitem function as inNoteQ1: @vaultah spam[0] += 1 is basically spam[0] = spam[0] + 1I couldn't;t find any documentation to support that python would treat an in-place operator as a binary-op with the first operand as self. Even the disassembly says otherwise
+= is an augmented assignment operator that calls the __iadd__ method of the LHS, if it exists, and then assigns its return value to the LHS:For instance, if x is an instance of a class with an __iadd__()  method, x += y is equivalent to x = x.__iadd__(y).(source)Thusis equivalent toWhile spam[0] succeeds because __getitem__ is implemented, subsequent assignment to spam[0] does not, since it needs __setitem__ to work. At the same time, the spam[0].eggs list is updated, since __iadd__ works as expected:See this for a related FAQ.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__iadd__
https://docs.python.org/3/faq/programming.html#faq-augmented-assignment-tuple-error
