Natural Text
Ok so I've got quite a tricky problem here I just can't seem to implement properly.I have three strings. Let's call them string1, string2, and string3. These strings are coming out of a speech to text API (all of which I already have sorted out). They are very similar but not exactly the same (eg. there may be translation errors... some words might be slightly off and there may be an extra word in string1 that isn't in string2 or string3).In order to compare string1, string2, and string3, I'm printing them out into a text file. The problem is, if these strings are fairly large, its quite difficult to compare them side by side.A much better way to compare them is "line-by-line".I'm looking for a way to print n words of string1, new line, then print m words of string2, up to a point where string1[n] == string2[m], then do the same for string3. Then I need to repeat this process for the rest of string1, string2, and string3, such that they are adequately compared "line-by-line".I've found this to be an incredibly difficult problem. Here's what I've got so far:I've started off by tokenizing the strings via string1.split(). Then it makes sense to have a placeholder to keep track of which word we're working with in each string. I define a batch size of k (lets say 10 words) that represents the length of a line. Then I print k words of string1, setting the placeholder for string2 = string2.index(string1[k]).But from here on I'm absolutely spooked!Any hints/suggestions/theories of how to proceed. Are there any libraries that will do this?Any help would be appreciated!! 
How about using the batch size with a counter. Here, say 'l1', 'l2' and 'l3' are the line numbers respectively for each string.I believe this should do it. Please elaborate on your question if this doesn't help.UPDATE:Based on your comment might I suggest not using the batch size on l2 and l3, instead look for the last word of string1 in string2 and string3.Eg, try this inside the loop:Here, the second string is written till the same word is encountered.Note: The if condition is checking whether the index goes to a huge number. Say that your parser doesn't recognise that particular word and therefore this program would write till that particular word is read or end up writing the entire string. So I have included a batch limit that if the same word isn't recognised in the next 15 words then the program only writes 10 words. The -1 condition is when the word isn't encountered at all.This still isn't the perfect logic as there are still cases where it would fail, eg, when the word is repeated in the sentence, so you could ideally use a case that if k2 doesn't lie in 8 - 12 then it is set to 10 otherwise anything between 8-12. This should be cleared when working with examples and based on results and I cannot confirm what it should be without testing. I believe you should be able to achieve that ideal index value range.
Okay I have an answer. This proved to be more difficult that I originally thought. So, I made a function called find_closest_index that looks like this:Then I used this to write the lines up to the point of similarity between strings:Finally I outputted the rest of the string that remainedIts not perfect. But it does the job. Thanks for your help!


Answer URL
https://docs.python.org/3/library/difflib.html
