Natural Text
I am coding a Caesar cipher. The key is an integer from 1 to 25. This cipher rotates the letters of the alphabet (A to Z). The encoding replaces each letterwith the 1st to 25th next letter in the alphabet (wrapping Z to A). So key 2 encrypts “HI” to “JK”, but key 20 encrypts “HI” to “BC”.But If I put in "I am super" it will output "k kc oouwrgt" when it should be "k co uwrgt" with a key of 2. It will also not go back to the beginning of the alphabet e.g 'x' will not go to 'a' with a key of 2. I use python 3.4.1
When you encounter a space, you append the last letter again, instead of item:This causes k and o to appear twice when the key is 2; you re-appended the encoded i -> k and m -> o results.You need to use the % modulo operator to make your index 'wrap round':I removed the int() call, you already turned Key to an integer earlier.Other tips:You don't need to turn a into a list; strings are sequences too and support indexing and the .index()method directly. The same applies to text; just loop over the string itself.You are not using i in the for i, item in enumerate(text): loop; drop enumerate altogether: for item in text:.You could just print your encoded characters directly in that loop, no need to use an encode list and a separate loop.The str.join() method would let you print your encoded text all on one line:  print(''.join(encode)) instead of your last for loop.The absolute fastest method of encoding a string is to use a translation table, a dictionary mapping input characters to output characters, and the str.translate() method. You can use the str.maketrans() function to make that table:The trick lies in creating the second string for str.maketrans(); using slicing it is easy to create a rotated string, by taking everything from position Key onwards, and the first Key characters at the end:
One obvious solution would be to use modulo for the alphabet index:The % (modulo) operator yields the remainder from the division of the  first argument by the second.As a bonus, you wouldn't need to check the key is lower than 25, and you'll never get an IndexError: list index out of range.A few notes:a string is already an iterable of characters. No need to convert it to a listletter wasn't defined in if item == " "to iterate over a list, you don't need the length or the index.to decode the message, just change the sign of the key. It should work just like encode, thanks to modulo : -2 % 26 # => 24As an example:and


Answer URL
https://docs.python.org/3/reference/expressions.html#binary-arithmetic-operations
https://docs.python.org/3/library/stdtypes.html#str.join
https://docs.python.org/3/library/stdtypes.html#str.translate
https://docs.python.org/3/library/stdtypes.html#str.maketrans
