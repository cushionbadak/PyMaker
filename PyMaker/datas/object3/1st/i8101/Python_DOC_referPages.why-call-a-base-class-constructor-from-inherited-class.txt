Natural Text
I have been trying to understand this use case, where we often call a base class constructor from the inherited class, is the sole purpose of doing that is to just ensure that the base class is initialized? Or, would there be other possible use cases?
is the sole purpose of doing that is to just ensure that the base class is initialized?Well yes, but what do you mean, just?Assuming your base class has a reason to exist, it must do something.Unless it's just a convenient collection of @staticmethod functions, whatever it does might depend on its __init__ having been called, because that's how class objects work.Even if your base class has an empty __init__ today, it's sensible to call it, in case that changes in the future.Or, would there be other possible use cases?The use case is to make sure that the base class part of your object is correctly initialized. Without that, you can't safely call any of its non-static methods.In principle your base class could do something tricksy in its __init__ (starting a background thread, or registering the instance with some singleton, or ... whatever). So yes, there could be effects other than just assigning instance variables, but this is still part of initializing an object of that base class.
In C++ or Java, the compiler will require you to call the base class constructor (either by automatically inserting a zero-argument call or by giving you an error).Python requires you to call it yourself, as it is written:If a base class has an __init__() method, the derived classâ€™s __init__() method, if any, must explicitly call it to ensure proper initialization of the base class part of the instanceThe reason why is a principle of object oriented design. An A "is-a" Base, which could also be written equivalently as an A "has-a" Base. Unless you specifically want to interfere with the implementation of Base, you have to allow the object to be initialized as designed. Skipping the constructor will leave the Base object improperly initialized, disappointing anyone who expects it to behave as a Base object ought to.When overriding a method besides the constructor, it is the programmer's discretion to delegate to the base class implementation or to override it entirely. This can still lead to incorrect behavior --- several API docs I can think of pepper the documentation with "If you override this method, you should call super" for various methods.
The point of this is to initialize all the stuff the base class usually initializes. For example,In this code example it's more obvious. When A calls the base constructor, the base constructor will initialize all of the stuff needed, such as self.number. This way, the rest of A's initialization function can build on top of the base initialization function without any retyping. In this example, A is building on top of Base by adding self.string on top of self.number.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__init__
