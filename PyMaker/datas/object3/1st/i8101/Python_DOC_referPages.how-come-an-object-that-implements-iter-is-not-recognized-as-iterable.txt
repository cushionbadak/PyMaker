Natural Text
Let's say you work with a wrapper object:This object implements __iter__, because it passes any call to it to its member f, which implements it. Case in point:According to the documentation (https://docs.python.org/3/library/stdtypes.html#iterator-types), IterOrNotIter should thus be iterable.However, the Python interpreter does not recognize an IterOrNotIter object as actually being iterable:Whereas this works:I don't understand why.
Basically because your class just doesn't have a real __iter__ method:So it doesn't qualify as iterator because the actual check for __iter__ checks for the existence instead of assuming it's implemented. So workarounds with __getattr__ or __getattribute__ (unfortunatly) don't work.This is actually mentioned in the documentation for __getattribute__:NoteThis method may still be bypassed when looking up special methods as the result of implicit invocation via language syntax or built-in functions. See Special method lookup. The latter section also explains the why:Bypassing the __getattribute__() machinery in this fashion provides significant scope for speed optimisations within the interpreter, at the cost of some flexibility in the handling of special methods (the special method must be set on the class object itself in order to be consistently invoked by the interpreter).Emphasis mine.


Answer URL
https://docs.python.org/3/library/stdtypes.html#iterator-types
