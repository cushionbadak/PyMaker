Natural Text
I've been writing some code to list the Gaussian integer divisors of rational integers in Python. (Relating to Project Euler problem 153)I seem to have reached some trouble with certain numbers and I believe it's to do with Python approximating the division of complex numbers.Here is my code for the function:When I run Divisors(29) I get [1, 29], but this is missing out four other divisors, one of which being (5 + 2j), which can clearly be seen to divide into 29.On running 29 / complex(5, 2), Python gives (5 - 2.0000000000000004j)This result is incorrect, as it should be (5 - 2j). Is there any way to somehow bypass Python's approximation? And why is it that this problem has not risen for many other rational integers under 100?Thanks in advance for your help.
Internally, CPython uses a pair of double-precision floats for complex numbers. The behavior of numerical solutions in general is too complicated to summarize here, but some error is unavoidable in numerical calculations.EG:As such, it is often correct to use approximate equality rather than actual equality when testing solutions of this kind.The isclose function in the  cmath module is available for this exact reason. This kind of question is the domain of Numerical Analysis; this may be a useful tag for further questions on this subject.Note that it is considered 'pythonic' for function identifiers to be in snake_case.
You could define an epsilon, by using round to round to the desired number of decimal places/precision (e.g. 10):Your code has another issue though:This will only give results for n = 0 or n = 1. You probably want to remove the check for equality.     


Answer URL
https://docs.python.org/3/library/cmath.html
