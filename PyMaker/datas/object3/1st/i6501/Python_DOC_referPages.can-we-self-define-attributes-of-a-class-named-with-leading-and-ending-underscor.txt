Natural Text
When we define a class in Python, i.e. we are the authors of the class,are we allowed to create attributes of a class, whose names both begin and end with double underscores, and don't conflict with special attributes e.g. __base__, __class__, __name__, __dict__, and special methods such as __new__, __init__, __str__, __repr__, __hash__, __call__, __get__?If yes, will the lookup for such attributes (e.g. __madeupAttribute__) that we define be the same as the lookup for those special attributes? Note that the  lookup process for those special attributes is different from the lookup process for regular attributes (e.g. attribute1, attribute2), as mentioned in Python in a NutshellA few attribute dunder-names are special,  C.__name__, C.__bases__, x.__class__. When you refer to an attribute with one of  these special names, the attribute reference looks directly into a dedicated slot in the  class or instance object and fetches the value it finds there. You cannot unbind these  attributes. are we allowed to create attributes of a class, whose names begin with a single underscore?are we allowed to create attributes of a class, whose names begin with two underscores?Note that I have read What is the meaning of a single- and a double-underscore before an object name?. My questions in this post are: what kinds of attributes the author of a Python class can create and what not.Thanks.
are we allowed to create attributes of a class, whose names both  begin and end with double underscores, and don't conflict with special  attributes? If yes, will the lookup for such attributes (e.g. __madeupAttribute__) that we define be the same as the lookup for those special attributes? If you create an attribute which name has double underscores on both sides, it gets no special treatment whatsoever. Only the attribute names reserved by the language have a special look-up treatment. Some of those may or may not be directly created by the class author. Most names intended for methods that are responsible to implement operations with the objects of that class, such as __add__, __mul__ can be freely writable. Others, will be overwritten on class creation, but are free to be changed afterwards, such as __name__, while still others are created along with the class and are imutable, such as __mro__. Names not listed on the documentation are just like ordinary names, but may get in conflict with future special names added to the language object model.You will be able to locate most special attribute and method names in the language data model, although some attributes can be used by specific stdlib modules and not be listed there. (They have no special meaning for the language as well, just for that module. One example is __reduce__, used by pickle)are we allowed to create attributes of a class, whose names begin with a single underscore?Yes - single underscore has no special meaning for Python at all, it is just a convention that code outside the class/package that created anything starting with an underscore should not change that directly or rely on its value or on its existence. This convention is what replaces "private" attributes and names in use in other languagesare we allowed to create attributes of a class, whose names begin with two underscores?For attributes of a class prefixed by two underscores, there is a special treatment at compile time that mangles those names, baking the class's name into the attribute name itself. All code written inside a class body (including inside methods, and inside nested functions into those methods) is changed in the same way. This name modification makes it so that classes that inherit from that one, if they use the same attribute name in their code, that attribute will not clash and be independent from the attribute on the parent class. This feature may be used to provide encapsulation for attributes you don't intend derived class to read or write, but again that is more due to convention and convenience, since the name mangling rules are well known. Early Python documentation often implied that this should be used for "private attributes". That is somewhat incorrect: "private" in Python is by convention only, and for readability purposes, often relies on a single prefixed underscore. 


Answer URL
https://docs.python.org/3/reference/datamodel.html
