Natural Text
One of the talked about features in Python 3.5 is said to be type hints.An example of type hints is mentioned in this article and this while also mentioning to use type hints responsibly. Can someone explain more about it and when it should be used and when not?
I would suggest reading PEP 483 and PEP 484 and watching this presentation by Guido on Type Hinting.In a nutshell: Type hinting is literally what the words mean, you hint the type of the object(s) you're using. Due to the dynamic nature of Python, inferring or checking the type of an object being used is especially hard. This fact makes it hard for developers to understand what exactly is going on in code they haven't written and, most importantly, for type checking tools found in many IDEs [PyCharm, PyDev come to mind] that are limited due to the fact that they don't have any indicator of what type the objects are. As a result they resort to trying to infer the type with (as mentioned in the presentation) around 50% success rate. To take two important slides from the Type Hinting presentation:Why Type Hints?Helps Type Checkers: By hinting at what type you want the object to be the type checker can easily detect if, for instance, you're passing an object with a type that isn't expected.Helps with documentation: A third person viewing your code will know what is expected where, ergo, how to use it without getting them TypeErrors. Helps IDEs develop more accurate and robust tools: Development Environments will be better suited at suggesting appropriate methods when know what type your object is. You have probably experienced this with some IDE at some point, hitting the . and having methods/attributes pop up which aren't defined for an object.Why use Static Type Checkers?Find bugs sooner: This is self evident, I believe.The larger your project the more you need it: Again, makes sense. Static languages offer a robustness and control thatdynamic languages lack. The bigger and more complex your application becomes the more control and predictability (froma behavioral aspect) you require.Large teams are already running static analysis: I'm guessing this verifies the first two points.As a closing note for this small introduction: This is an optional feature and, from what I understand, it has been introduced in order to reap some of the benefits of static typing. You generally do not need to worry about it and definitely don't need to use it (especially in cases where you use Python as an auxiliary scripting language). It should be helpful when developing large projects as it offers much needed robustness, control and additional debugging capabilities.Type Hinting with mypy:In order to make this answer more complete, I think a little demonstration would be suitable. I'll be using mypy, the library which inspired Type Hints as they are presented in the PEP. This is mainly written for anybody bumping into this question and wondering where to begin.Before I do that let me reiterate the following: PEP 484 doesn't enforce anything; it is simply setting a direction for functionannotations and proposing guidelines for how type checking can/should be performed. You can annotate your functions andhint as many things as you want; your scripts will still run regardless of the presence of annotations because Python itself doesn't use them.Anyways, as noted in the PEP, hinting types should generally take three forms:Function annotations. (PEP 3107)Stub files for built-in/user modules. Special # type: type comments that complement the first two forms. (See: What are variable annotations in Python 3.6? for a Python 3.6 update for # type: type comments)Additionally, you'll want to use type hints in conjunction with the new typing module introduced in Py3.5. In it, many (additional) ABCs (Abstract Base Classes) are defined along with helper functions and decorators for use in static checking. Most ABCs in collections.abc are included but in a Generic form in order to allow subscription (by defining a __getitem__() method).For anyone interested in a more in-depth explanation of these, the mypy documentation is written very nicely and has a lot of code samples demonstrating/describing the functionality of their checker; it is definitely worth a read.Function annotations and special comments:First, it's interesting to observe some of the behavior we can get when using special comments. Special # type: type commentscan be added during variable assignments to indicate the type of an object if one cannot be directly inferred. Simple assignments aregenerally easily inferred but others, like lists (with regard to their contents), cannot.Note: If we want to use any derivative of Containers and need to specify the contents for that container we must use the generic types from the typing module. These support indexing.If we add these commands to a file and execute them with our interpreter, everything works just fine and print(a) just printsthe contents of list a. The # type comments have been discarded, treated as plain comments which have no additional semantic meaning.By running this with mypy, on the other hand, we get the following responce:Indicating that a list of str objects cannot contain an int, which, statically speaking, is sound. This can be fixed by either abiding to the type of a and only appending str objects or by changing the type of the contents of a to indicate that any value is acceptable (Intuitively performed with List[Any] after Any has been imported from typing).Function annotations are added in the form param_name : type after each parameter in your function signature and a return type is specified using the -> type notation before the ending function colon; all annotations are stored in the __annotations__ attribute for that function in a handy dictionary form. Using a trivial example (which doesn't require extra types from the typing module):The annotated.__annotations__ attribute now has the following values:If we're a complete noobie, or we are familiar with Py2.7 concepts and are consequently unaware of the TypeError lurking in the comparison of annotated, we can perform another static check, catch the error and save us some trouble:Among other things, calling the function with invalid arguments will also get caught:These can be extended to basically any use-case and the errors caught extend further than basic calls and operations. The types youcan check for are really flexible and I have merely given a small sneak peak of its potential. A look in the typing module, thePEPs or the mypy docs will give you a more comprehensive idea of the capabilities offered.Stub Files:Stub files can be used in two different non mutually exclusive cases:You need to type check a module for which you do not want to directly alter the function signaturesYou want to write modules and have type-checking but additionally want to separate annotations from content.What stub files (with an extension of .pyi) are is an annotated interface of the module you are making/want to use. They containthe signatures of the functions you want to type-check with the body of the functions discarded. To get a feel of this, given a setof three random functions in a module named randfunc.py:We can create a stub file randfunc.pyi, in which we can place some restrictions if we wish to do so. The downside is thatsomebody viewing the source without the stub won't really get that annotation assistance when trying to understand what is supposedto be passed where.Anyway, the structure of a stub file is pretty simplistic: Add all function definitions with empty bodies (pass filled) andsupply the annotations based on your requirements. Here, let's assume we only want to work with int types for our Containers.The combine function gives an indication of why you might want to use annotations in a different file, they some times clutter upthe code and reduce readability (big no-no for Python). You could of course use type aliases but that sometime confuses more than ithelps (so use them wisely).This should get you familiarized with the basic concepts of Type Hints in Python. Even though the type checker used has beenmypy you should gradually start to see more of them pop-up, some internally in IDEs (PyCharm,) and others as standard python modules.I'll try and add additional checkers/related packages in the following list when and if I find them (or if suggested).Checkers I know of:Mypy: as described here.PyType: By Google, uses different notation from what I gather, probably worth a look.Related Packages/Projects:typeshed: Official Python repo housing an assortment of stub files for the standard library. The typeshed project is actually one of the best places you can look to see how type hinting might be used in a project of your own. Let's take as an example the __init__ dunders of the Counter class in the corresponding .pyi file: Where _T = TypeVar('_T') is used to define generic classes. For the Counter class we can see that it can either take no arguments in its initializer, get a single Mapping from any type to an int or take an Iterable of any type.  Notice: One thing I forgot to mention was that the typing module has been introduced on a provisional basis. From PEP 411:A provisional package may have its API modified prior to "graduating" into a "stable" state. On one hand, this state provides the package with the benefits of being formally part of the Python distribution. On the other hand, the core development team explicitly states that no promises are made with regards to the the stability of the package's API, which may change for the next release. While it is considered an unlikely outcome, such packages may even be removed from the standard library without a deprecation period if the concerns regarding their API or maintenance prove well-founded.So take things here with a pinch of salt; I'm doubtfull it will be removed  or altered in significant ways but one can never know.** Another topic altogether but valid in the scope of type-hints: PEP 526: Syntax for Variable Annotations is an effort to replace # type comments by introducing new syntax which allows users to annotate the type of variables in simple varname: type statements. See What are variable annotations in Python 3.6?, as previously mentioned, for a small intro on these.
Adding to Jim's elaborate answer:Check the typing module -- this module supports type hints as specified by PEP 484.For example, the function below takes and returns values of type str and is annotated as follows:The typing module also supports:Type aliasing.Type hinting for callback functions.Generics - Abstract base classes have been extended to support subscription to denote expected types for container elements.User-defined generic types - A user-defined class can be defined as a generic class.Any type - Every type is a subtype of Any.
The newly released PyCharm 5 supports type hinting. In their blog post about it (see Python 3.5 type hinting in PyCharm 5) they offer a great explanation of what type hints are and aren't along with several examples and illustrations for how to use them in your code. Additionally, it is supported in Python 2.7, as explained in this comment:PyCharm supports the typing module from PyPI for Python 2.7, Python 3.2-3.4. For 2.7 you have to put type hints in *.pyi stub files since function annotations were added in Python 3.0.


Answer URL
https://docs.python.org/3/library/typing.html
https://docs.python.org/3/library/typing.html
https://docs.python.org/3/library/typing.html#type-aliases
https://docs.python.org/3/library/typing.html#callable
https://docs.python.org/3/library/typing.html#generics
https://docs.python.org/3/library/typing.html#user-defined-generic-types
https://docs.python.org/3/library/typing.html#typing.Any
