Natural Text
What are the names for these different kinds of ascii representations of unicode?\xF0\x9F\x98\xA2\U0001f622And is there a term for the set that they belong to that's more specific than "representation"? And in the context of these, how would I describe the non-ascii representation (ðŸ˜¢)?Since I don't know what to call them it is very hard to search for how to work with them.Thanks!
As Tom Blodget already warned you, this is a somewhat python specific answer.The leading \ shows that it's an escape sequence.\x means that the next two characters will be interpreted as a hex digit.\U means that the next eight characters will be interpreted as a 32-bit hex value.You can read more about that here:https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literalsTo fully answer your question:\xF0\x9F\x98\xA2 are simply four ASCII characters and you have their hex values\U0001f622 is a UNICODE codepoint encoded with a 32-bit hex valueðŸ˜¢ is a glyph or simply a special character.
For Python 3First there seems to be a misunderstanding about the hex escapes:and for completeness (I recall using octal effectively in machine code where some instructions had 3-bit, aligned arguments but I don't see the point in real programming):It appears they are all Unicode codepoint escapes in 2-digit hexadecimal, 4-digit hexadecimal, and 8-digit hexadecimal, with ranges from U+0000 to U+00FF, U+FFFF, and U+10FFFF, respectively. We can confirm that, unlike other languages where the \u for is for a UTF-16 code unit, in Python 3, it is really a codepoint. and for completeness:In other languages (where they would be two UTF-16 code units), "\ud83d\ude22" would equal "ðŸ˜¢".Now, U+D8ED and U+DE22 are Unicode codepoints designated as surrogates. In other words, not characters. They reserve the codepoint codespace for the UTF-16 code units with corresponding values. This is the way the USC-2 encoding of Unicode was transparently extended to UTF-16 when Unicode was expanded from 2^16 codepoints to 2^21 codepoints. For more information see the Unicode FAQ.As @Robáµ© points out, you can have a bytestring literal, too:


Answer URL
https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals
