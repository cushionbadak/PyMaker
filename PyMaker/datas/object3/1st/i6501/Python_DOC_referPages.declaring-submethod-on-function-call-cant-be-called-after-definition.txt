Natural Text
The problem is that upon defining f and its private subfunction __call__- and thence after attempting to call the function (with the thought that it'd call the __call__ override instead) it throws an error that states the function doesn't take any arguments, yet one was passed.And (obviously- in hindsight) trying to call the __call__ method, it gives the exact same error.On this, I'm confused as I thought that firstmostly, f would be defined, then it'll have its basic private methods created (like __str__, __name__, __repr__ etc.) and then the definition of the explicit __call__ method would replace the implicitly generated __call__ method.Can somebody explain either what the order of function definition is and what gets declared first and last, or explain how you would manage to override the hidden __call__ (preferably, if possible, without using a class to mask a function).
The namespace in a function does not produce attributes. __call__ is a local variable inside f(), nothing more.def <identifier>(...): binds the name identifier in the current namespace, and in a function that means it assigns a local name, just like some_name = ... would do.At most, you can return that object:It would be really surprising if all local variables in a function became attributes instead, even before you had actually executed the function!However, even if you gave a function object a __call__ attribute, it still would not be used. You can only use a class to create an object with a __call__ method:That's because __call__ is a special method, and thus subject to the Special method lookup rules, which dictate that Python would look for the method on the type of the object, not the object itself.When Python evaluates foo(...), if foo is not a function object Python will execute type(foo).__call__(foo, ...). Python does this to make sure that the Foo.__call__ method is not used when you create your instance with Foo(); classes are callables too but defining Foo.__call__ should not clash with that.
What you're asking to avoid is what __call__ is for. It allows an object with the method to masquerade as an function. When you're defining a function, you're not creating an object with properties - there simply is no method named __call__ defined (.. that you've defined yourself, at least) on the object representing the function f.However, it turns out you already have a function that handles your call, namely f. You can also use decorators to wrap that function if necessary, or as you've suggested, create a class and instanciate an object instead.


Answer URL
https://docs.python.org/3/reference/datamodel.html#special-lookup
