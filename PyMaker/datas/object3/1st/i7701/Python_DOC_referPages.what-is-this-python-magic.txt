Natural Text
If you do this {k:v for k,v in zip(*[iter(x)]*2)} where x is a list of whatever, you'll get a dictionary with all the odd elements as keys and even ones as their values. woah!I have a basic understanding of how dictionary comprehensions work, how zip works, how * extracts arguments, how [iter(x)]*2 concatenates two copies of the list, and so I was expecting a one-to-one correspondence like {1: 1, "cat": "cat" ...}.What's going on here?
This is an interesting little piece of code for sure! The main thing it utilizes that you might not expect is that objects are, in effect, passed by reference (they're actually passed by assignment, but hey). iter() constructs an object, so "copying" it (using multiplication on a list, in this case) doesn't create a new one, but rather adds another reference to the same one. That means you have a list where l[0] is an iterator, and l[1] is the same iterator - accessing them both accesses the very same object.Every time the next element of the iterator is accessed, it continues where it last left off. Since elements are accessed alternately between the first and second elements of the tuples that zip() creates, the single iterator's state is advanced across both elements in the tuple.After that, the dictionary comprehension simply consumes these pair tuples as they expand to k, v - as they would in any other dictionary comprehension.
This iter(x) creates an iterator over the iterable (list or similar) x.  This iterator gets copied using [iter(x)]*2.  Now you have a list of two times the same iterator.  This means, if I ask one of them for a value, the other (which is the same) gets incremented as well.zip() now gets the two iterators (which are the same) as two parameters via the zip(* ... ) syntax.  This means, it creates a list of pairs of the two arguments it got.  It will ask the first iterator for a value (and receive x[0]), then it will ask the other iterator for a value (and receive x[1]), then it will form a pair of the two values and put that in its output.  Then it will do this repeatedly until the iterators are exhausted.  By this it will form a pair of x[2] and x[3], then a pair of x[4] and x[5], etc.This list of pairs then is passed to the dictionary comprehension which will form the pairs into key/values of a dictionary.Easier to read might be this:But that might not be as efficient.


Answer URL
https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference
