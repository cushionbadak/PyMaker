Natural Text
As mentioned here,Below code,Output:Question:Why __eq__ gets called on accessing jimbut not on bob?
Short answer: a dictionary lookup first does a (cheap) reference equality check (x is y) when searching a bucket, and only if that fails, a (more expensive) equality check (x == y) is done.ScenarioThe __hash__ function does not call __eq__ internally. Given you construct bob and jim, no such methods are called.Next you associate bob with 'tomorrow'. In order to know in which bucket of the dictionary, you have to store bob, you calculate the hash. Now once you have done that we store bob (and the value in the correct bucket).Next we want to obtain jim. In order to know in which bucket jim resides, we calculate the hash. Next we start searching in the bucket. The bucket will contain bob. We first perform a reference check (jim is bob) but that fails, so then we fallback on the equality check. That check succeeds, so we return the value corresponding with bob: 'tomorrow'.The same scenario happens when we want to look for bob: we calculate the hash, fetch the bucket. Perform a reference check on bob is bob, and that one succeeds. So we do not need a (probably more expensive equality check). We simply return the value 'tomorrow'.Reference checksThe fact that a reference check is done first can be proven with the following (unhealthy) code:Here we return always False for equality. So even:bob is not equal to itself (this is actually not good design, since for a dictionary, it is a contract that an object is equal to itself: a good equality relation is reflexive, symmetrical and transitive). Nevertheless, if we associate bob with 'tomorrow', we are still able to fetch the value associated with bob:
To answer the title:When does __eq__ gets called using hash()?Never. The other question:Why __eq__ gets called on accessing jim but not on bob?That's more complicated. To understand that you need to know how a dictionary is implemented. Assuming CPython it will be a table containing a hash column, a key column and a value column:It will have a certain size but it won't be big enough to contain every possible hash value, so it will calculate the position based on the hash. For example if you add bob it could have (string hashes are randomized in certain CPython versions so the actual result will differ) a hash of 7475314405837642385. Assuming the dictionary has an actual size of 2 (in reality it will be bigger, but that would unnecessarily waste space in the answer) it just takes the modulo, so it will place it in 7475314405837642385 % 2 == 1:When you want to look up a key italways calculate the hash of the lookupthen it will calculate the position. Then it compares the hash of the lookup to the hash saved in that positionif the hashes are equal then it will compare the lookup and the saved key with PyObject_RichCompareBool. That will:first check for identity: lookup is keyif that is False it will check lookup == keySo in case you lookup bob:hash: 7475314405837642385position: 7475314405837642385 % 2 -> 1found an entry, so compare the hashes: 7475314405837642385 == 7475314405837642385that was equal so check for identity: bob is bob -> TrueSo it returns 'tomorrow' without an equality check. In the second case it checks for jim:hash: 7475314405837642385position: 7475314405837642385 % 2 -> 1found an entry, so compare the hashes: 7475314405837642385 == 7475314405837642385that was equal so check for identity: jim is bob -> Falsecheck for equality jim == bob -> TrueSo it returns 'tomorrow'.This is just an approximation of the actual implementation (it's missing some details). It gets more complicated if the hashes are not equal or the lookup is not key and lookup != key but these are not really important to understand the observed behavior you questioned.However, I really need to say this: What you're doing is really dangerous because your class isn't immutable. You could accidentally make the saved dictionary entry unavailable to you:(It could still work in case the new hash is equal to the "old" hash, but that would be rather accidental).That's because while you alter the hash of your instance - the dictionary won't update the saved hash because it assumes all keys are immutable! So the dictionary would either assume it would be saved in another position or if the position would (miraculously) be the same then it would fail in the step where it contains the actual hashes.


Answer URL
https://docs.python.org/3/c-api/object.html#c.PyObject_RichCompareBool
https://docs.python.org/3/c-api/object.html#c.PyObject_RichCompareBool
