Natural Text
This question already has an answer here:Python commutative operator override                    1 answer                I have a simple class that helps with mathematical operations on vectors (i.e. lists of numbers). My Vector can be multiplied by other instances of Vector or a scalar (float or int).In other, more strongly typed, languages I would create a method to multiply two vectors and a separate method to multiply a vector by and int/float. I'm still pretty new to Python and am not sure how I would implement this. The only way I can think of doing it is override __mul__() and test the incoming parameter:Even if I do it that way I would be forced to multiply a Vector by a scalar like this:What if I wanted to reverse the order of the operands in the multiplication?What is the right way to do that in Python?
You also need to implement __rmul__. When the initial call to int.__mul__(7, v) fails, Python will next try type(v).__rmul__(v, 7).As Rawing points out, you could simply write __rmul__ = __mul__ for this definition. __rmul__ exists to allow for non-commutative multiplication where simply deferring to __mul__ with the operands reversed isn't sufficient.For instance, if you were writing a Matrix class and wanted to support multiplication by a nested list, e.g.,Here, the list class wouldn't know how to multiple a list by a Matrix instance, so when list.__mul__(n, m) fails, Python would next try Matrix.__rmul__(m, n). However, n * m and m * n are two different results in general, so Matrix.__rmul__(m, n) != Matrix.__mul__(m, n); __rmul__ has to do a little extra work to generate the right answer.
There are special methods for reversed operations:__rmul__ for the reverse of __mul__ and __radd__ for __add__,...These are called when the left hand side operator returns NotImplemented for the normal operation (so the operation 2 + vector_instance will first try: (2).__add__(vector_instance) but if this returns NotImplemented then vector_instance.__radd__(2) is called).However I wouldn't use isinstance checks in the arithmetic special methods, that will lead to a lot of code repetition. You could actually create a special case in __init__ and implement a conversion from scalars to a Vector there:This should work as expected:Note that this was a quick and dirty draft (that could have several bugs). I just wanted to present the "general idea" how it could be solved without special casing the type in each arithmetic operation.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__radd__
