Natural Text
(I am aware that the title of the question might be misleading, but I could not find any other way to formulate it - feel free to edit it)I have two lists, both of the same length:And I want to obtain all possible replacements of the first list with the second list.Please note that this question is NOT answered by the following questions:How to get all possible combinations of a listâ€™s elements?combinations between two lists?Python merging two lists with all possible permutationsAll combinations of a list of listsA possible solution involving the previously linked answers would be to create several lists and then use the itertools.product method on them. For example, instead of having 2 lists of 3 elements, I could create 3 lists of 2 elements; however, that would over-complicate the code and I'd prefer to avoid that if I could.Is there an easy and quick way to do it?
Creating 3 lists of two elements would not over-complicate the code at all. zip can "flip the axes" of multiple lists trivially (making X sequences of Y elements into Y sequences of X elements), making it easy to use itertools.product:Which outputs:Different ordering than your example output, but it's the same set of possible replacements.
Each item may independently be replaced or left alone. This can be modeled by a bit being 1 or 0. If you consider each item to be a separate bit, then iterating over all of the possibilities can be mapped to iterating over all of the combinations of n bits.In other words, iterate from 0 to 2n-1 and look at the bit patterns.Breaking this down, i & (1 << j) != 0 checks if the jth bit of i is set. If it is, use a[j], otherwise b[j].Result:
Okay this is similar to the other answers, but taking a bit from both. You can model your problem as finding all possible bits of a sequence of given length, and replacing only when there is 1, and otherwise not.All combinations of bits are:Which results in:


Answer URL
https://docs.python.org/3/library/functions.html#zip
