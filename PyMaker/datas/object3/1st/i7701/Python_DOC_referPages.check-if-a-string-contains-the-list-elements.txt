Natural Text
How to check if the string 'str1' contains the elements in the list 'lis'?
If no overlap is allowed, this problem becomes much harder than it looks at first.As far as I can tell, no other answer is correct (see test cases at the end).Recursion is needed because if a substring appears more than once, using one occurence instead of the other could prevent other substrings to be found.This answer uses two functions. The first one finds every occurence of a substring in a string and returns an iterator of strings where the substring has been replaced by a character which shouldn't appear in any substring.The second function recursively checks if there's any way to find all the numbers in the string:Here are the test cases:And the corresponding output:
OUTPUT:The value 89 is in the listThe value 90 is in the listIf you want to check if all the values in lis are in str1, the code of cricket_007is what you are looking for
If you want non-overlapping matches I'd do it like this:create a copy of the initial string (as we'll modify it)go through each element of the list and if we find the element in our string, we replace it with xat the same time, if we find the number in our string, we increment a counterat the end, if the variable equals the length of the list, it means that all of its elements are thereMore, we don't really need a counter if we add an extra condition which will return False when an element isn't found in the string. That is, we get to the following, final solution:Which you can test by writing:This might not be the best solution for what you're looking, but I guess it serves the purpose.
You can use all() function
Usage:
You can use the regular expression to search.
It is possible to implement this correctly using regular expressions. Generate all unique permutations of the input, for each permutation connect the terms with ".*" then connect all of the permutations with "|". For example, [89, 90, 8990] gets turned into 89.*8990.*90| 89.*90.*8990| 8990.*89.*90| 8990.*90.*89| 90.*89.*8990| 90.*8990.*89 , where I added a space after each "|" for clarity."The following passes Eric Duminil's test suite.However, and this is a big however, the regular expression size, in the worst case, grows as the factorial of the number of numbers. Even with only 8 unique numbers, that's 40320 regex terms. It takes Python several seconds just to compile that regex.The only time where this solution might be useful is if you have a handful of numbers and you wanted to search a lot of strings. In that case, you might also look into re2, which I believe could handle that regex without backtracking.


Answer URL
https://docs.python.org/3/library/functions.html#all
