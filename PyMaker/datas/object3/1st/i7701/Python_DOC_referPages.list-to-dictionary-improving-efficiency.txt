Natural Text
I am attempting to create a function that takes a 2 dimensional list and return a dictionary. I am wondering if there is a more efficient way instead of what I have written (e.g. list comprehension / itertools?) I am relatively new to python and have read some examples on list comprehension and itertools doc (https://stackoverflow.com/questions/16548668/iterating-over-a-2-dimensional-python-list) but can't seem to implement it to this chunk of code.Any help would be appreciated. Thank you!
Your function is doing way too many things:Trying to find out if it's input is a sequence of key=>value pairs or a pair of keys, values sequences. It's unreliable. Don't try to guess, it's the caller's duty to pass the right structure, because only the caller knows what data he wants to turn into a dict.Cleaning (currently striping) keys and vals. Here again it only makes sense if both are strings, which is not garanteed to be the case (at least not from the function's name nor documention...). You could of course test if your keys and/or values are indeed strings but this adds quite some overhead. Here again it's the caller's duty to do the (eventual) cleaning.To make a long story short, your function should only expect a single data structure (either a sequence of key=>value pairs or a pair of (keys, values) sequence, and not apply any cleanup, leaving on the caller the responsability to provide what's expected.Actually, building a dict from a sequence (or any iterable) of pairs is actually so trivial that you don't need a special function, it's just a matter of passing the sequence to the dict constructor:Or on more recent python versions using a dict comprehension which can faster:So well, your first building block is builtin and dont need any special func.Note that this works with any iterable as long as 1. it yields only pairs and 2. the keys (first items of the pairs) are uniques. So if you want to apply some cleaning before building the dict, you can do it with a generator function or expression, ie if the caller knows all the keys are strings and might need striping and all the values are either strings needing striping or None, you can pass a generator expression instead of the source list, ie:Finally, transposing a pair of keys, values sequences to a sequence of key=>value pairs is what the builtin zip() and it's lazy version itertools.izip() are for:Putting it together, the most "devious" case (building a dict from a sequence of keys and a sequence of values, applying striping to keys and conditionnaly applying striping to values) can be expressed as:If it's for a one-shot use, that actually all you need.Now if you have a use case where you know you will have to apply this from different places in your code with always the same cleaning but either lists of pairs or pairs of lists, you of course want to factor it out as much as possible - but not more:and then leave it to the caller to apply zip() before if needed:As to wether you want to use zip() or itertools.izip(), it mostly depends on your Python version and your inputs. If you're using Python 2.x, zip() will build a new list in memory while itertools.izip() will build it lazily, so there's a slight performance overhead from using itertools.izip() but it will save a lot of memory if you're working large datasets.If you're using Python3.x, zip() has been turned into an iterator, sus replacing itertools.izip() so the question becomes irrelevant ;)



Answer URL
https://docs.python.org/3/library/itertools.html#itertools.zip_longest
