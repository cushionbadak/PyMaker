Natural Text
This question already has an answer here:Generator expression uses list assigned after the generator's creation                    5 answers                I was running a piece of code that unexpectedly gave a logic error at one part of the program. When investigating the section, I created a test file to test the set of statements being run and found out an unusual bug that seems very odd.I tested this simple code:And the output was:Yes, nothing. I was expecting the filter comprehension to get items in the array with a count of 2 and output this, but I didn't get that:When I commented out the third line to test it once again:The output was correct (you can test it for yourself):At one point I outputted the type of the variable f:And I got:Why is updating a list in Python changing the output of another generator variable? This seems very odd to me.
Python's generator expressions are late binding (see PEP 289 -- Generator Expressions) (what the other answers call "lazy"):Early Binding versus Late BindingAfter much discussion, it was decided that the first (outermost) for-expression [of the generator expression] should be evaluated immediately and that the remaining expressions be evaluated when the generator is executed.[...] Python takes a late binding approach to lambda expressions and has no precedent for automatic, early binding. It was felt that introducing a new paradigm would unnecessarily introduce complexity.After exploring many possibilities, a consensus emerged that binding issues were hard to understand and that users should be strongly encouraged to use generator expressions inside functions that consume their arguments immediately. For more complex applications, full generator definitions are always superior in terms of being obvious about scope, lifetime, and binding.That means it only evaluates the outermost for when creating the generator expression. So it actually binds the value with the name array in the "subexpression" in array (in fact it's binding the equivalent to iter(array) at this point). But when you iterate over the generator the if array.count call actually refers to what is currently named array.Since it's actually a list not an array I changed the variable names in the rest of the answer to be more accurate.In your first case the list you iterate over and the list you count in will be different. It's as if you used:So you check for each element in list1 if its count in list2 is two.You can easily verify this by modifying the second list:If it iterated over the first list and counted in the first list it would've returned [2, 2] (because the first list contains two 2). If it iterated over and counted in the second list the output should be [1, 1]. But since it iterates over the first list (containing one 1) but checks the second list (which contains two 1s) the output is just a single 1.Solution using a generator functionThere are several possible solutions, I generally prefer not to use "generator expressions" if they aren't iterated over immediately. A simple generator function will suffice to make it work correctly:And then use it like this:Note that the PEP (see the link above) also states that for anything more complicated a full generator definition is preferrable.A better solution using a generator function with a CounterA better solution (avoiding the quadratic runtime behavior because you iterate over the whole array for each element in the array) would be to count (collections.Counter) the elements once and then do the lookup in constant time (resulting in linear time):Appendix: Using a subclass to "visualize" what happens and when it happensIt's quite easy to create a list subclass that prints when specific methods are called, so one can verify that it really works like that.In this case I just override the methods __iter__ and count because I'm interested over which list the generator expression iterates and in which list it counts. The method bodies actually just delegate to the superclass and print something (since it uses super without arguments and f-strings it requires Python 3.6 but it should be easy to adapt for other Python versions):This is a simple subclass just printing when the __iter__ and count method are called:
As others have mentioned Python generators are lazy. When this line is run:nothing actually happens yet. You've just declared how the generator function f will work. Array is not looked at yet. Then, you create a new array that replaces the first one, and finally when you call the generator now needs the actual values and starts pulling them from the generator f. But at this point, array already refers to the second one, so you get an empty list.If you need to reassign the list, and can't use a different variable to hold it, consider creating the list instead of a generator in the second line:
Others have already explained the root cause of the issue - the generator is binding to the name of the array local variable, rather than its value.The most pythonic solution is definitely the list comprehension:However, if there is some reason that you don't want to create a list, you can also force a scope close over array:What's happening here is that the lambda captures the reference to array at the time the line is run, ensuring that the generator sees the variable you expect, even if the variable is later redefined.Note that this still binds to the variable (reference), not the value, so, for example, the following will print [2, 2, 4, 4]:This is a common pattern in some languages, but it's not very pythonic, so only really makes sense if there's a very good reason for not using the list comprehension  (e.g., if array is very long, or is being used in a nested generator comprehension, and you're concerned about memory).
You are not using a generator correctly if this is the primary use of this code. Use a list comprehension instead of a generator comprehension. Just replace the parentheses with brackets. It evaluates to a list if you don't know.You are getting this response because of the nature of a generator. You're calling the generator when it't contents will evaluate to []
Generators are lazy, they won't be evaluated until you iterate through them. In this case that's at the point you create the list with the generator as input, at the print.
The root cause of the problem is that generators are lazy; variables are evaluated each time:It iterates over the original list and evaluates the condition with the current list. In this case, 4 appeared twice in the new list, causing it to appear in the result. It only appears once in the result because it only appeared once in the original list. The 6s appear twice in the new list, but never appear in the old list and are hence never shown.Full function introspection for the curious (the line with the comment is the important line):To reiterate: The list to be iterated is only loaded once. Any closures in the condition or expression, however, are loaded from the enclosing scope each iteration. They are not stored in a constant.The best solution for your problem would be to create a new variable referencing the original list and use that in your generator expression,.
Generator evaluation is "lazy" -- it doesn't get executed until you actualize it with a proper reference.  With your line:Look again at your output with the type of f: that object is a generator, not a sequence.  It's waiting to be used, an iterator of sorts.Your generator isn't evaluated until you start requiring values from it.  At that point, it uses the available values at that point, not the point at which it was defined.Code to "make it work"That depends on what you mean by "make it work".  If you want f to be a filtered list, then use a list, not a generator:
Generators are lazy and your newly defined array is used when you exhaust your generator after redefining. Therefore, the output is correct. A quick fix is to use a list comprehension by replacing parentheses () by brackets [].Moving on to how better to write your logic, counting a value in a loop has quadratic complexity. For an algorithm that works in linear time, you can use collections.Counter to count values, and keep a copy of your original list:Notice the second version doesn't even require old_array and is useful if there is no need to maintain ordering of values in your original array.


Answer URL
https://docs.python.org/3/library/collections.html#collections.Counter
