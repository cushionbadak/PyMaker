Natural Text
I have two (sorted) arrays, A and B, of different lengths each containing unique labels that are repeated a number of times.The count for each label in A is less than or equal to that in B.All labels in A will be in B, but some labels in B do not appear in A.I need an object the same length as B where, for each label i in A (which occurs k_i times), the first k_i occurrences of label i in B need to be set to False.The remaining elements should be True.The following code gives me what I need, but if A and B are large, this can take a long time:Is there a faster or more efficient way to do this? I feel like I may be missing some obvious broadcasting or vectorized solution.
Here's one with np.searchsorted -We can optimize further to compute A_uniq,A_count using its sorted nature instead of using np.unique, like so -
Example without numpy
This solution is inspired by the one by @Divakar, using itertools.groupby:OutputThe idea is to use np.searchsorted to find the insertion position of each element of A, as equal elements will have the same insertion position you have to shift by one each of them, hence the groupby. Then create an array of True and set the values of the indices to False.If you can use pandas, compute the indices like this:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.groupby
