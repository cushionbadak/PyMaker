Natural Text
I am doing some large number maths in both Java and Python. The sums are the same however the results are different.Python Answers = 10358251994780842724998096890217137953445700726699419360034816Java Answers = 10358251994780842575401275783021915748383652186833068257611776Java is getting the correct result but python is not. I am not using Floating point numbers as far as I know. Whats the issue here.
When you doyou get a big number elevated to a power but using a floating point method, even if arguments are integers. Converting to integer loses precision (the original result is a float: 1.0358251994780843e+61)When you doyou get a big number elevated to a power using a binary power method using only integer multiplication.So the second result is accurate, whereas the first isn'tLet's try a disassembly of both ** and math.pow functions:outputas you see, the functions aren't equivalent. BINARY_POWER is called in the first case. This function has a chance to perform integer multiply accurately when parameters are integer:BINARY_POWER()Implements TOS = TOS1 ** TOSBinary power yields the same value as math.pow when parameters aren't all integer:Note: what probably adds to the confusion is the built-in pow method, which is different from math.pow (and overridden by the latter when using from math import pow), but is equivalent to ** operator when used without modulo argument:pow(x, y[, z])Return x to the power y; if z is present, return x to the power y, modulo z (computed more efficiently than pow(x, y) % z). The two-argument form pow(x, y) is equivalent to using the power operator: x**y.


Answer URL
https://docs.python.org/3/library/dis.html#opcode-BINARY_POWER
https://docs.python.org/3/library/functions.html#pow
https://docs.python.org/3/library/math.html#math.pow
