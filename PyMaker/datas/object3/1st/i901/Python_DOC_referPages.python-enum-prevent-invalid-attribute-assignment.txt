Natural Text
When I use the Functional API to create an enum, I get back an enum object that allows arbitrary assignment (i.e. it has a __dict__):The item does not appear in the list:But it can still be referenced:Now while it seems unlikely to ever occur, one of the reasons I want to use an enum is to prevent spelling mistakes and string literals, and for those things to be caught when a module is imported or as early as possible.Is there a way to dynamically build an enum that behaves more like a __slots__ object that does not allow arbitrary attributes to be assigned?
To make an enum class fully 'read-only', all that is required is a meta class that uses the __setattr__ hook that prevents all attribute assignments. Because the metaclass is attached to the class after it is created, there is no issue with assigning the proper enumerated values.Like Ethan's answer, I'm using the EnumMeta class as a base for the custom metaclass:The above distinguishes between attributes that are already available and new attributes, for ease of diagnosing. It also blocks attribute deletion, which is probably just as important! It also provides both the metaclass and a FrozenEnum base class for enumerations; use this instead of Enum.To freeze a sample Color enumeration:Note that all attribute changes are disallowed, no new attributes permitted, and deletions are blocked too. When names are enum members, we delegate to the original EnumMeta handling to keep the error messages stable.If your enum uses properties that alter attributes on the enum class, you'd either have to whitelist those, or allow for names starting with a single underscore to be set; in __setattr__ determine what names would be permissible to set and use super().__setattr__(name, value) for those exceptions, just like the code now distinguishes between class construction and later alterations by using a flag attribute.The above class can be used just like Enum() to programmatically create an enumeration:Demo:
Not necessarily easy, but possible.  We need to create a new EnumMeta type1, create the Enum normally, then reassign the type after the Enum is created:and in use:Trying to reassign a member still gives the friendlier error:In order to make the class reassignment a little easier, we can write a decorator to encapsulate the process:and in use:Note that it is still possible to overwrite ordinary attributes, such as functions:and in use:Even that can be blocked, but I'll leave that (for now) as an exercise for someone else.1  This is only the second case I have seen where subclassing EnumMeta is required.  For the other, see this question.Disclosure:  I am the author of the Python stdlib Enum, the enum34 backport, and the Advanced Enumeration (aenum)  library.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__setattr__
https://docs.python.org/3/library/enum.html
