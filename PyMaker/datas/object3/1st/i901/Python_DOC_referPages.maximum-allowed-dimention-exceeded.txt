Natural Text
I am attempting to make a painting based on the mass of the universe with pi and the gravitational constant of earth at sea level converted to binary.  i've done the math and i have the right dimentions and it should only be less than a megabyte of ram but im running into maximum allowed dimention exceeded value error.Here is the code:I keep running into the error at D = np.array..., and maybe my reshape is too big but its only a little bigger than 4k.  seems like this should be no problem for gpu enhanced colab.  Doesn't run on my home machine either with the same error.  Would this be fixed with more ram?
Making it WorkThe problem is that artifice = np.binary_repr(genesis) creates a string. The string consists of 1348 * 4117 = 5549716 digits, all of them zeros and ones. If you convert the string to a python integer, A = int(artifice), you will (A) wait a very long time, and (B) get a non-iterable object. The array you create with np.array(A) will have a single element.The good news is that you can bypass the time-consuming step entirely using the fact that the string artifice is already an iterable:The step list(artifice) will take a couple of seconds since it has to split up the string, but everything else should be quite fast.Plotting is easy from there with plt.imsave('hello_world.png', D, cmap=cm.gray):ColormapsYou can easily change the color map to coolwarm or whatever you want when you save the image. Keep in mind that your image is binary, so only two of the values will actually matter:ExplorationYou have an opportunity here to add plenty of color to your image. Normally, a PNG is 8-bit. For example, instead of converting genesis to bits, you can take the bytes from it to construct an image. You can also take nibbles (half-bytes) to construct an indexed image with 16 colors. With a little padding, you can even make sure that you have a multiple of three data points, and create a full color RGB image in any number of ways. I will not go into the more complex options, but I would like to explore making a simple image from the bytes.5549716 bits is 693715 = 5 * 11 * 12613 bytes (with four leading zero bits). This is a very nasty factorization leading to an image size of 55x12613, so let's remove that upper nibble: while 693716's factorization is just as bad as 693715's, 693714 factors very nicely into 597 * 1162.You can convert your integer to an array of bytes using its own to_bytes method:The reason that I use the built-in ceil rather than np.ceil is that it return an integer rather than a float.Converting the huge integer is very fast because the bytes object has direct access to the data of the integer: even if it makes a copy, it does virtually no processing. It may even share the buffer since both bytes and int are nominally immutable. Similarly, you can create a numpy array from the bytes as just a view to the same memory location using np.frombuffer:The [1:] is necessary to chop off the leading nibble, since bytes_genesis must be large enough to hold the entirety of genesis. You could also chop off on the bytes side:The results are identical. Here is what the picture looks like:The result is too large to upload (because it's not a binary image), but here is a randomly selected sample:I am not sure if this is aesthetically what you are looking for, but hopefully this provides you with a place to start looking at how to convert very large numbers into data buffers.More Options, Because this is InterestingI wanted to look at using nibbles rather than bytes here, since that would allow you to have 16 colors per pixel, and twice as many pixels. You can get an 1162x1194 image starting fromHere is one way to unpack the nibbles:With a colormap like jet, you get:Another option, going in the opposite direction in a manner of speaking) is not to use colormaps at all. Instead, you can divide your space by a factor of three and generate your own colors in RGB space. Luckily, one of the prime factors of 693714 is 3. You can therefore have a 398x581 image (693714 == 3 * 398 * 581). How you interpret the data is even more than usual up to you. Side Note Before I ContinueWith the black-and-white binary image, you could control the color, size and orientation of the image. With 8-bit data, you could control how the bits were sampled (8 or fewer, as in the 4-bit example), the endianness of your interpretation, the color map, and the image size. With full color, you can treat each triple as a separate color, treat the entire dataset as three consecutive color planes, or even do something like apply a Bayer filter to the array. All in addition to the other options like size, ordering, number of bits per sample, etc.The following will show the color triples and three color planes options for now.Full Color ImagesTo treat each set of 3 consecutive bytes as an RGB triple, you can do something like this:Notice that there is no colormap in this case.Interpreting the data as three color planes requires an extra step because plt.imsave expects the last dimension to have size 3. np.rollaxis is a good tool for this:
I could not reproduce your problem, because the line A = int(artifice) took like forever. I replaced it with a ,for loop to cast each digit on its own. The code worked then and produced the desired image.


Answer URL
https://docs.python.org/3/library/stdtypes.html#int.to_bytes
https://docs.python.org/3/library/math.html#math.ceil
