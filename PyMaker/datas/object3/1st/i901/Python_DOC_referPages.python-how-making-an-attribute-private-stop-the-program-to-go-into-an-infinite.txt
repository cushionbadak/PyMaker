Natural Text
I am a naive to Object oriented concept in python. While reading the OOP concept from here I encounter an example.If I don't make my variable private (in case of class P2) then I guess it will run into an infinite loop.In order to inspect what actually class P2 is doing I restructured my code to When I tried to run P2(x = 2100) it gives me an unstoppable output like:It appears that my program first called init method and after that it is continuously running back and forth from setter area 3 to setter area 6.Can anyone explainwhat is happening behind the scene ? How the program is running ?Why magic private attribute are making here so that the program is not running into an infinite loopHow @property and @x.setter are related to each other here ? Can't I write @setter without writing @propertyI know these are basic questions but I went through so much of online stuff and I didn't find a better answer to these question. 
"Why magic private attribute are making here so that the program is  not running into an infinite loop"It is actually not a good place to use double-underscore name-mangling. I like that tutorial, except for that one detail. You can use a single underscore, or any valid python identifier except the one occupied by the property, and you will see the same effect. A property is an object that implements the descriptor protocol.  It is a handy descriptor, for a common descriptor use-case. But we can make our own descriptor types.Fundamentally, a descriptor is any python type that implements any combination of __get__, __set__ or __delete__.These will get invoked when you do some_object.some_attribute, some_object.some_attribute = value, and del some_object.some_attribute where some_attribute is a descriptor on some_object.__class__. So, consider a concrete example:Descriptors intercept attribute access and modification, and deletion on the instance of the class that has the descriptor as an attribute to allow for all sorts of fun stuff.Notice, The descriptor belongs to the class:If I set an instance attribute as the same name as the class attribute holding the property, the normal python behavior of shadowing occurs:But we can control this, we can implement __set__:The property object just lets you provide functions that will get delegated to when you use property.__get__, property.__set__, and property.__delete__. The docstrings is quite informative, just use help(property) in a python shell:So whatever you decorate with @property.setter, you can imagine that get's passed to property(fset=<whatever>). So now, whenever your instance tries to set x.some_attribute = value where .some_attribute is a property on class X:, the the property.__set__ is invoked, you can imagine it goes x.some_attribute = value gets translated into X.some_attribute.__set__(x, value) So, to get to the crux of your question, why the infinite recursion, because using obj.x = val where .x is a property, will call fset, but in your fset you use obj.x = val, and fset gets called again, and here is your hidden recursion.The @decorator syntax is for convenience, and always accepts the getter first, but you can simply provide only the setter using the long-form way:I highly recommend reading the descriptor HOWTO. Spoiler alert, classmethod and staticmethod are all descriptors, and so is how Python magically passes instances to methods (that is, all function objects are descriptors who's __get__ method passes the instance as the first argument to the function itself when accessed by an instance on a class!. It also shows Python implementations of all of these things, including how you could implement property in pure Python!


Answer URL
https://docs.python.org/3/howto/descriptor.html
