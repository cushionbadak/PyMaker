Natural Text
I want to use a management command to run a one-time analysis of the buildings in Massachusetts. I have reduced the offending code to an 8 line snippet that demonstrates the problem I encounter. The comments just explain why I want to do this at all. I am running the code below verbatim, in an otherwise-blank management commandWhen I run this exact code, I find that memory usage steadily increases with each iteration outer loop (I use print('mem', process.memory_info().rss) to check memory usage). It seems like the important_buildings list is hogging up memory, even after going out of scope. If I replace important_buildings.append(building) with _ = building.pk, it no longer consumes much memory, but I do need that list for some of the analysis.So, my question is: How can I force Python to release the list of Django models when it goes out of scope?Edit: I feel like there's a bit of a catch 22 on stack overflow -- if I write too much detail, no one wants to take the time to read it (and it becomes a less applicable problem), but if I write too little detail, I risk overlooking part of the problem. Anyway, I really appreciate the answers, and plan to try some of the suggestions out this weekend when I finally get a chance to get back to this!!
You don't provide much information about how big your models are, nor what links there are between them, so here are a few ideas:By default QuerySet.iterator() will load 2000 elements in memory (assuming you're using django >= 2.0). If your Building model contains a lot of info, this could possibly hog up a lot of memory. You could try changing the chunk_size parameter to something lower.Does your Building model have links between instances that could cause reference cycles that the gc can't find? You could use gc debug features to get more detail.Or shortcircuiting the above idea, maybe just call del(important_buildings) and del(buildings) followed by gc.collect() at the end of every loop to force garbage collection?The scope of your variables is the function, not just the for loop, so breaking up your code into smaller functions might help. Although note that the python garbage collector won't always return memory to the OS, so as explained in this answer you might need to get to more brutal measures to see the rss go down.Hope this helps!EDIT:To help you understand what code uses your memory and how much, you could use the tracemalloc module, for instance using the suggested code:
Very quick answer.Memory is being freed, rss is not a very accurate tool for telling where the memory is being consumed, rss gives a measure of the memory the process has used, not the memory the process is using (keep reading to see a demo), you can use the package memory-profiler in order to check line by line, the memory use of your function.So, How to force Django models to be released from memory?,  you can't tell have such problem just using process.memory_info().rss.I can, however, propose a solution for you to optimize your code. And write a demo on why process.memory_info().rss is not a very accurate tool to measure memory being used in some block of code. Proposed solution:As demonstrated later in this same post, applying del to the list is not going to be the solution, optimization using chunk_size for iterator will help (be aware chunk_size option for iterator was added in Django 2.0), that's for sure, but the real enemy here is that nasty list.Said that, you can use a list of just fields you need to perform your analysis (I'm assuming your analysis can't be tackled one building at the time) in order to reduce the amount of data stored in that list.Try getting just the attributes you need on the go and select targeted buildings using the Django's ORM.It's very important to note that if you use a solution like this, you'll be only hitting database when populating data variable. And of course, you will only have in memory the minimum required for accomplishing your analysis.Thinking in advance.When you hit issues like this you should start thinking about parallelism, clusterization, big data, etc ... Read also about ElasticSearch it has very good analysis capabilities.Demoprocess.memory_info().rss Won't tell you about memory being freed.I was really intrigued by your question and the fact you describe here: It seems like the important_buildings list is hogging up memory, even after going out of scope.Indeed, it seems but is not. Look the following example:So even if a memory is freed, the last number is bigger. That's because memory_info.rss() is the total memory the process has used, not the memory is using at the moment, as stated here in the docs: memory_info.The following image is a plot (memory/time) for the same code as before but with range(10000000) I use the script mprof that comes in memory-profiler for this graph generation.You can see the memory is completely freed, is not what you see when you profile using process.memory_info().rss. If I replace important_buildings.append(building) with _ = building use less memoryThat's always will be that way, a list of objects will always use more memory than a single object.And on the other hand, you also can see the memory used don't grow linearly as you would expect. Why?From this excellent site we can read:The append method is “amortized” O(1). In most cases, the memory required to append a new value has already been allocated, which is strictly O(1). Once the C array underlying the list has been exhausted, it must be expanded in order to accommodate further appends. This periodic expansion process is linear relative to the size of the new array, which seems to contradict our claim that appending is O(1).However, the expansion rate is cleverly chosen to be three times the previous size of the array; when we spread the expansion cost over each additional append afforded by this extra space, the cost per append is O(1) on an amortized basis.It is fast but has a memory cost.The real problem is not the Django models not being released from memory. The problem is the algorithm/solution you've implemented, it uses too much memory. And of course, the list is the villain.A golden rule for Django optimization: Replace the use of a list for querisets wherever you can.
Laurent S's answer is quite on the point (+1 and well done from me :D).There are some points to consider in order to cut down in your memory usage:The iterator usage:You can set the chunk_size parameter of the iterator to something as small as you can get away with (ex. 500 items per chunk).That will make your query slower (since every step of the iterator will reevaluate the query) but it will cut down in your memory consumption.The only and defer options: defer(): In some complex data-modeling situations, your models might contain a lot of fields, some of which could contain a lot of data (for example, text fields), or require expensive processing to convert them to Python objects. If you are using the results of a queryset in some situation where you don’t know if you need those particular fields when you initially fetch the data, you can tell Django not to retrieve them from the database.only(): Is more or less the opposite of defer(). You call it with the fields that should not be deferred when retrieving a model. If you have a model where almost all the fields need to be deferred, using only() to specify the complementary set of fields can result in simpler code.Therefore you can cut down on what you are retrieving from your models in each iterator step and keep only the essential fields for your operation.If your query still remains too memory heavy, you can choose to keep only the building_id in your important_buildings list and then use this list to make the queries you need from your Building's model, for each of your operations (this will slow down your operations, but it will cut down on the memory usage).You may improve your queries so much as to solve parts (or even whole) of your analysis but with the state of your question at this moment I cannot tell for sure (see PS on the end of this answer)Now let's try to bring all the above points together in your sample code:If this still hogs too much memory for your liking you can use the 3rd point above like this:and then use that set to query your buildings for the rest of your operations:PS: If you can update your answer with more specifics, like the structure of your models and some of the analysis operations you are trying to run, we may be able to provide more concrete answers to help you!
Have you considered Union? By looking at the code you posted you are running a lot of queries within that command but you could offload that to the database with Union.Tweaking the above could essentially narrow down the queries needed for this function to one.It's also worth looking at DjangoDebugToolbar - if you haven't looked it it already.
To release memory, you must duplicate the important details of each in the buildings in the inner loop into a new object, to be used later, while eliminating those not suitable. In code not shown in the original post references to the inner loop exist. Thus the memory issues. By copying the relevant fields to new objects, the originals can be deleted as intended.


Answer URL
https://docs.python.org/3/library/tracemalloc.html#pretty-top
