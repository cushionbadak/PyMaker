Natural Text
Suppose I read a long bytes object from somewhere, knowing it is utf-8 encoded. But the read may not fully consume the available content so that the last character in the stream may be incomplete. Calling bytes.decode() on this object may result in a decode error. But what really fails is only the last few bytes. Is there a function that works in this case, returning the longest decoded string and the remaining bytes?utf-8 encodes a character into at most 4 bytes, so trying to decode truncated bytes should work, but a vast majority of computation will be wasted, and I don't really like this solution.To give a simple but concrete example:(b0 + b1).decode() is fine, but b0.decode() will raise. The solution should be able to decode b0 for as much as possible and return the bytes that cannot be decoded.
You are describing the basic use-case of io.TextIOWrapper: a buffered text stream over a binary stream. Contrast with reading a bytes stream directly, where it would be possible to read halfway through an encoded pile of poo:Specify encoding="utf-8" if you want to be explicit. The default encoding, i.e. locale.getpreferredencoding(False), would usually be utf-8 anyway.
As I mentioned in the comments under @wim's answer, I think you could use the codecs.iterdecode() incremental decoder to do this. Since it's a generator function, there's no need to manually save and restore its state between iterative calls to it.Here's how how it might be used to handle a situation like the one you described:Sample output:


Answer URL
https://docs.python.org/3/library/io.html#io.TextIOWrapper
https://docs.python.org/3/library/codecs.html#codecs.iterdecode
https://docs.python.org/3/library/io.html#id3
https://docs.python.org/3/library/io.html#io.TextIOBase.tell
