Natural Text
I have the web app. That app has endpoint to push some object data to redis channel.And another endpoint handles websocket connection, where that data is fetched from channel and send to client via ws.  When i connect via ws, messages gets only first connected client.How to read messages from redis channel with multiple clients and not create  a new subscription?Websocket handler.Here i subscribe to channel, save it to app (init_tram_channel). Then run job where i listen channel and send messages(run_tram_listening).    Subscribing and saving channel.Every channel is related to unique object, and in order not to create many channels that related to the same object, i save only one to app. app['tram_producers'] is dict.Running coro for channel listening. I run it via aiojobs:Coro where i listen and send messages:
The following code has been found in some aioredis github issue (I've adopted it to my task).So, how it works? TramProducer wraps the way we get messages.As said @Messa message is received from one Redis subscription only once.    So only one client of TramProducer is retrieving messages from redis, while other clients are waiting for future result that will be set after receiving message from channel.If self._future initialized it means that somebody is waiting for message from redis, so we will just wait for self._future result. TramProducer usage (i've taken an example from my question):TramProducer initialization:I think it maybe helpfull for somebody.Full project here https://gitlab.com/tram-emulator/tram-server
I guess a message is received from one Redis subscription only once, and if there is more than one listeners in your app, then only one of them will get it.So you need to create something like mini pub/sub inside the application to distribute the messages to all listeners (websocket connections in this case).Some time ago I've made an aiohttp websocket chat example - not with Redis, but at least the cross-websocket distribution is there: https://github.com/messa/aiohttp-nextjs-demo-chat/blob/master/chat_web/views/api.pyThe key is to have an application-wide message_subcriptions, where every websocket connection registers itself, or perhaps its own asyncio.Queue (I've used Event in my example, but that's suboptimal), and whenever message comes from Redis, it is pushed to all relevant queues.Of course when websocket connection ends (client unsubscribe, disconnect, failure...) the queue should be removed (and possibly Redis subscription cancelled if it was the last connection listening to it).Asyncio doesn’t mean we should forget about queues :) Also it’s good to get familiar with combining multiple tasks at once (reading from websocket, reading from message queue, perhaps reading from some notification queue...). Using queues can also help you to handle client reconnects more cleanly (without loss of any messages).


Answer URL
https://docs.python.org/3/library/asyncio-queue.html
