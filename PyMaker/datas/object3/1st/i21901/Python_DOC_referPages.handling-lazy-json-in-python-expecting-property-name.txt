Natural Text
Using Pythons (2.7) 'json' module I'm looking to process various JSON feeds. Unfortunately some of these feeds do not conform with JSON standards - in specific some keys are not wrapped in double speech-marks ("). This is causing Python to bug out.Before writing an ugly-as-hell piece of code to parse and repair the incoming data, I thought I'd ask - is there any way to allow Python to either parse this malformed JSON or 'repair' the data so that it would be valid JSON?Working exampleBroken exampleI've written a small REGEX to fix the JSON coming from this particular provider, but I forsee this being an issue in the future. Below is what I came up with.
You're trying to use a JSON parser to parse something that isn't JSON.  Your best bet is to get the creator of the feeds to fix them.I understand that isn't always possible.  You might be able to fix the data using regexes, depending on how broken it is:
Another option is to use the demjson module which can parse json in non-strict mode.
The regular expressions pointed out by Ned and cheeseinvert don't take into account when the match is inside a string.See the following example (using cheeseinvert's solution):The problem is that the expected output is:Since JSON tokens are a subset of python tokens, we can use python's tokenize module.Please correct me if I'm wrong, but the following code will fix a lazy json string in all the cases:So in order to parse a json string, you might want to encapsulate a call to fixLazyJson once json.loads fails (to avoid performance penalties for well-formed json):The only problem I see when fixing lazy json, is that if the json is malformed, the error raised by the second json.loads won't be referencing the line and column from the original string, but the modified one.As a final note I just want to point out that it would be straightforward to update any of the methods to accept a file object instead of a string.BONUS: Apart from this, people usually likes to include C/C++ comments when json is used forconfiguration files, in this case, you can either remove comments using a regular expression, or use the extended version and fix the json string in one pass:
Expanding on Ned's suggestion, the following has been helpful for me:
In a similar case, I have used ast.literal_eval. AFAIK, this won't work only when the constant null (corresponding to Python None) appears in the JSON.Given that you know about the null/None predicament, you can:
In addition to Neds and cheeseinvert suggestion, adding (?!/) should avoid the mentioned problem with urls  


Answer URL
https://docs.python.org/3/library/ast.html#ast.literal_eval
