Natural Text
I want to write a custom class that behaves like dict - so, I am inheriting from dict.My question, though, is: Do I need to create a private dict member in my __init__() method?. I don't see the point of this, since I already have the dict behavior if I simply inherit from dict.Can anyone point out why most of the inheritance snippets look like the one below?Instead of the simpler...Actually, I think I suspect the answer to the question is so that users cannot directly access your dictionary (i.e. they have to use the access methods that you have provided).However, what about the array access operator []? How would one implement that? So far, I have not seen an example that shows how to override the [] operator. So if a [] access function is not provided in the custom class, the inherited base methods will be operating on a different dictionary?I tried the following snippet to test out my understanding of Python inheritance:I got the following error:KeyError:  < built-in function id>What is wrong with the code above?How do I correct the class myDict so that I can write code like this?[Edit]I have edited the code sample above to get rid of the silly error I made before I dashed away from my desk. It was a typo (I should have spotted it from the error message).
Check the documentation on emulating container types. In your case, the first parameter to add should be self.

Like thisNow you can use the built-in functions, like dict.get() as self.get().You do not need  to wrap a hidden self._dict.  Your class already is a dict.
For the sake of completeness, here is the link to the documentation mentioned by @bj√∂rn-pollex for the latest Python 2.x (2.7.7 as of the time of writing):Emulating Container Types(Sorry for not using the comments function, I'm just not allowed to do so by stackoverflow.)
The problem with this chunk of code:...is that your 'add' method (...and any method you want to be a member of a class) needs to have an explicit 'self' declared as its first argument, like:To implement the operator overloading to access items by key, look in the docs for the magic methods __getitem__ and __setitem__.Note that because Python uses Duck Typing, there may actually be no reason to derive your custom dict class from the language's dict class -- without knowing more about what you're trying to do (e.g, if you need to pass an instance of this class into some code someplace that will break unless isinstance(MyDict(), dict) == True), you may be better off just implementing the API that makes your class sufficiently dict-like and stopping there.


Answer URL
https://docs.python.org/3/reference/datamodel.html?emulating-container-types#emulating-container-types
https://docs.python.org/3/reference/datamodel.html#slots
