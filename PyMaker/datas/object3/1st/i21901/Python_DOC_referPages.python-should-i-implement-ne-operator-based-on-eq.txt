Natural Text
I have a class where I want to override the __eq__() operator. It seems to make sense that I should override the __ne__() operator as well, but does it make sense to implement __ne__ based on __eq__ as such?Or is there something that I'm missing with the way Python uses these operators that makes this not a good idea?
Yes, that's perfectly fine.  In fact, the documentation urges you to define __ne__ when you define __eq__:There are no implied relationships  among the comparison operators. The  truth of x==y does not imply that x!=y  is false. Accordingly, when defining  __eq__(), one should also define __ne__() so that the operators will behave as expected.In a lot of cases (such as this one), it will be as simple as negating the result of __eq__, but not always.
Python, should I implement __ne__() operator based on __eq__?Short Answer: No. Use == instead of the __eq__In Python 3, != is the negation of == by default, so you are not even required to write a __ne__, and the documentation is no longer opinionated on writing one. Generally speaking, for Python 3-only code, don't write one unless you need to overshadow the parent implementation, e.g. for a builtin object.That is, keep in mind Raymond Hettinger's comment:The __ne__ method follows automatically from __eq__ only if  __ne__ isn't already defined in a superclass.  So, if you're  inheriting from a builtin, it's best to override both.If you need your code to work in Python 2, follow the recommendation for Python 2 and it will work in Python 3 just fine.In Python 2, Python itself does not automatically implement any operation in terms of another - therefore, you should define the __ne__ in terms of == instead of the __eq__.E.G. See proof that implementing __ne__() operator based on __eq__ and not implementing __ne__ in Python 2 at allprovides incorrect behavior in the demonstration below.Long AnswerThe documentation for Python 2 says:There are no implied relationships among the comparison operators. The  truth of x==y does not imply that x!=y is false. Accordingly, when  defining __eq__(), one should also define __ne__() so that the  operators will behave as expected.So that means that if we define __ne__ in terms of the inverse of __eq__, we can get consistent behavior. This section of the documentation has been updated for Python 3:By default, __ne__() delegates to __eq__() and inverts the result  unless it is NotImplemented.and in the "what's new" section, we see this behavior has changed: != now returns the opposite of ==, unless == returns NotImplemented.For implementing __ne__, we prefer to use the == operator instead of using the __eq__ method directly so that if self.__eq__(other) of a subclass returns NotImplemented for the type checked, Python will appropriately check other.__eq__(self) From the documentation:The NotImplemented objectThis type has a single value. There is a single object with this value. This object is accessed through the built-in name  NotImplemented. Numeric methods and rich comparison methods may return  this value if they do not implement the operation for the operands  provided. (The interpreter will then try the reflected operation, or  some other fallback, depending on the operator.) Its truth value is  true.When given a rich comparison operator, if they're not the same type, Python checks if the other is a subtype, and if it has that operator defined, it uses the other's method first (inverse for <, <=, >= and >). If NotImplemented is returned, then it uses the opposite's method. (It does not check for the same method twice.) Using the == operator allows for this logic to take place.ExpectationsSemantically, you should implement __ne__ in terms of the check for equality because users of your class will expect the following functions to be equivalent for all instances of A.:That is, both of the above functions should always return the same result. But this is dependent on the programmer. Demonstration of unexpected behavior when defining __ne__ based on __eq__:First the setup:Instantiate non-equivalent instances:Expected Behavior:(Note: while every second assertion of each of the below is equivalent and therefore logically redundant to the one before it, I'm including them to demonstrate that order does not matter when one is a subclass of the other.)These instances have __ne__ implemented with ==:These instances, testing under Python 3, also work correctly:And recall that these have __ne__ implemented with __eq__ - while this is the expected behavior, the implementation is incorrect:Unexpected Behavior:Note that this comparison contradicts the comparisons above (not wrong1 == wrong2).and,Don't skip __ne__ in Python 2For evidence that you should not skip implementing __ne__ in Python 2, see these equivalent objects:The above result should be False!Python 3 sourceThe default CPython implementation for __ne__ is in typeobject.c in object_richcompare:Here we seeBut the default __ne__ uses __eq__?Python 3's default __ne__ implementation detail at the C level uses __eq__ because the higher level == (PyObject_RichCompare) would be less efficient - and therefore it must also handle NotImplemented.If __eq__ is correctly implemented, then the negation of == is also correct - and it allows us to avoid low level implementation details in our __ne__.Using == allows us to keep our low level logic in one place, and avoid addressing NotImplemented in __ne__.One might incorrectly assume that == may return NotImplemented.It actually uses the same logic as the default implementation of __eq__, which checks for identity (see do_richcompare and our evidence below)And the comparisons:PerformanceDon't take my word for it, let's see what's more performant:I think these performance numbers speak for themselves:This makes sense when you consider that low_level_python is doing logic in Python that would otherwise be handled on the C level.Response to some criticsAnother answerer writes:Aaron Hall’s implementation not self == other of the __ne__ method is incorrect as it can never return NotImplemented (not NotImplemented is False) and therefore the __ne__ method that has priority can never fall back on the __ne__ method that does not have priority.Having __ne__ never return NotImplemented does not make it incorrect. Instead, we handle prioritization with NotImplemented via the check for equality with ==. Assuming == is correctly implemented, we're done.not self == other used to be the default Python 3 implementation of the __ne__ method but it was a bug and it was corrected in Python 3.4 on January 2015, as ShadowRanger noticed (see issue #21408).Well, let's explain this. As noted earlier, Python 3 by default handles __ne__ by first checking if self.__eq__(other) returns NotImplemented (a singleton) - which should be checked for with is and returned if so, else it should return the inverse. Here is that logic written as a class mixin:This is necessary for correctness for C level Python API, and it was introduced in Python 3, making the __ne__ methods in this patch to close Issue 21408 andthe __ne__ methods in the follow-on cleanup removed hereredundant. All relevant __ne__ methods were removed, including ones implementing their own check as well as ones that delegate to __eq__ directly or via == - and == was the most common way of doing so.ConclusionFor Python 2 compatible code, use == to implement __ne__. It is more:correctsimpleperformantIn Python 3 only, use the low-level negation on the C level - it is even more simple and performant (though the programmer is responsible for determining that it is correct).Again, do not write low-level logic in high level Python.
Just for the record, a canonically correct and cross Py2/Py3 portable __ne__ would look like:This works with any __eq__ you might define:Unlike not (self == other), doesn't interfere with in some annoying/complex cases involving comparisons where one of the classes involved doesn't imply that the result of __ne__ is the same as the result of not on __eq__ (e.g. SQLAlchemy's ORM, where both __eq__ and __ne__ return special proxy objects, not True or False, and trying to not the result of __eq__ would return False, rather than the correct proxy object). Unlike not self.__eq__(other), this correctly delegates to the __ne__ of the other instance when self.__eq__ returns NotImplemented (not self.__eq__(other) would be extra wrong, because NotImplemented is truthy, so when __eq__ didn't know how to perform the comparison, __ne__ would return False, implying that the two objects were equal when in fact the only object asked had no idea, which would imply a default of not equal)If your __eq__ doesn't use NotImplemented returns, this works (with meaningless overhead), if it does use NotImplemented sometimes, this handles it properly. And the Python version check means that if the class is import-ed in Python 3, __ne__ is left undefined, allowing Python's native, efficient fallback __ne__ implementation (a C version of the above) to take over.Why this is neededPython overloading rulesThe explanation of why you do this instead of other solutions is somewhat arcane. Python has a couple general rules about overloading operators, and comparison operators in particular:(Applies to all operators) When running LHS OP RHS, try LHS.__op__(RHS), and if that returns NotImplemented, try RHS.__rop__(LHS). Exception: If RHS is a subclass of LHS's class, then test RHS.__rop__(LHS) first. In the case of comparison operators, __eq__ and __ne__ are their own "rop"s (so the test order for __ne__ is LHS.__ne__(RHS), then RHS.__ne__(LHS), reversed if RHS is a subclass of LHS's class)Aside from the idea of the "swapped" operator, there is no implied relationship between the operators. Even for instance of the same class, LHS.__eq__(RHS) returning True does not imply LHS.__ne__(RHS) returns False (in fact, the operators aren't even required to return boolean values; ORMs like SQLAlchemy intentionally do not, allowing for a more expressive query syntax). As of Python 3, the default __ne__ implementation behaves this way, but it's not contractual; you can override __ne__ in ways that aren't strict opposites of __eq__.How this applies to overloading comparatorsSo when you overload an operator, you have two jobs:If you know how to implement the operation yourself, do so, using only your own knowledge of how to do the comparison (never delegate, implicitly or explicitly, to the other side of the operation; doing so risks incorrectness and/or infinite recursion, depending on how you do it)If you don't know how to implement the operation yourself, always return NotImplemented, so Python can delegate to the other operand's implementationThe problem with not self.__eq__(other)never delegates to the other side (and is incorrect if __eq__ properly returns NotImplemented). When self.__eq__(other) returns NotImplemented (which is "truthy"), you silently return False, so A() != something_A_knows_nothing_about returns False, when it should have checked if something_A_knows_nothing_about knew how to compare to instances of A, and if it doesn't, it should have returned True (since if neither side knows how to compare to the other, they're considered not equal to one another). If A.__eq__ is incorrectly implemented (returning False instead of NotImplemented when it doesn't recognize the other side), then this is "correct" from A's perspective, returning True (since A doesn't think it's equal, so it's not equal), but it might be wrong from something_A_knows_nothing_about's perspective, since it never even asked something_A_knows_nothing_about; A() != something_A_knows_nothing_about ends up True, but something_A_knows_nothing_about != A() could False, or any other return value.The problem with not self == otheris more subtle. It's going to be correct for 99% of classes, including all classes for which __ne__ is the logical inverse of __eq__. But not self == other breaks both of the rules mentioned above, which means for classes where __ne__ isn't the logical inverse of __eq__, the results are once again non-reflexive, because one of the operands is never asked if it can implement __ne__ at all, even if the other operand can't. The simplest example is a weirdo class which returns False for all comparisons, so A() == Incomparable() and A() != Incomparable() both return False. With a correct implementation of A.__ne__ (one which returns NotImplemented when it doesn't know how to do the comparison), the relationship is reflexive; A() != Incomparable() and Incomparable() != A() agree on the outcome (because in the former case, A.__ne__ returns NotImplemented, then Incomparable.__ne__ returns False, while in the latter, Incomparable.__ne__ returns False directly). But when A.__ne__ is implemented as return not self == other, A() != Incomparable() returns True (because A.__eq__ returns, not NotImplemented, then Incomparable.__eq__ returns False, and A.__ne__ inverts that to True), while Incomparable() != A() returns False.You can see an example of this in action here.Obviously, a class that always returns False for both __eq__ and __ne__ is a little strange. But as mentioned before, __eq__ and __ne__ don't even need to return True/False; the SQLAlchemy ORM has classes with comparators that returns a special proxy object for query building, not True/False at all (they're "truthy" if evaluated in a boolean context, but they're never supposed to be evaluated in such a context).By failing to overload __ne__ properly, you will break classes of that sort, as the code:will work (assuming SQLAlchemy knows how to insert MyClassWithBadNE into a SQL string at all; this can be done with type adapters without MyClassWithBadNE having to cooperate at all), passing the expected proxy object to filter, while:will end up passing filter a plain False, because self == other returns a proxy object, and not self == other just converts the truthy proxy object to False. Hopefully, filter throws an exception on being handled invalid arguments like False. While I'm sure many will argue that MyTable.fieldname should be consistently on the left hand side of the comparison, the fact remains that there is no programmatic reason to enforce this in the general case, and a correct generic __ne__ will work either way, while return not self == other only works in one arrangement.
Short answer: yes (but read the documentation to do it right)ShadowRanger's implementation of the __ne__ method is the correct one (in the sense that it behaves exactly like the default Python 3 implementation):Aaron Hall’s implementation not self == other of the __ne__ method is incorrect as it can never return NotImplemented (not NotImplemented is False) and therefore the __ne__ method that has priority can never fall back on the __ne__ method that does not have priority. not self == other used to be the default Python 3 implementation of the __ne__ method but it was a bug and it was corrected in Python 3.4 on January 2015, as ShadowRanger noticed (see issue #21408).Implementation of the comparison operatorsThe Python Language Reference for Python 3 states in its chapter III Data model:object.__lt__(self, other)object.__le__(self, other)object.__eq__(self, other)object.__ne__(self, other)object.__gt__(self, other)object.__ge__(self, other)These are the so-called “rich comparison” methods. The correspondence  between operator symbols and method names is as follows: x<y calls  x.__lt__(y), x<=y calls x.__le__(y), x==y calls x.__eq__(y),  x!=y calls x.__ne__(y), x>y calls x.__gt__(y), and x>=y  calls x.__ge__(y).A rich comparison method may return the singleton NotImplemented if  it does not implement the operation for a given pair of arguments.There are no swapped-argument versions of these methods (to be used  when the left argument does not support the operation but the right  argument does); rather, __lt__() and __gt__() are each other’s  reflection, __le__() and __ge__() are each other’s reflection, and  __eq__() and __ne__() are their own reflection. If the operands  are of different types, and right operand’s type is a direct or  indirect subclass of the left operand’s type, the reflected method of  the right operand has priority, otherwise the left operand’s method  has priority. Virtual subclassing is not considered.Translating this into Python code gives (using operator_eq for ==, operator_ne for !=, operator_lt for <, operator_gt for >, operator_le for <= and operator_ge for >=):Default implementation of the comparison methodsThe documentation adds:By default, __ne__() delegates to __eq__() and inverts the result  unless it is NotImplemented. There are no other implied  relationships among the comparison operators, for example, the truth  of (x<y or x==y) does not imply x<=y.The default implementation of the comparison methods (__eq__, __ne__, __lt__, __gt__, __le__ and __ge__) can thus be given by:So this is the correct implementation of the __ne__ method. And it does not always return the inverse of the __eq__ method because when the __eq__ method returns NotImplemented, its inverse not NotImplemented is False (as bool(NotImplemented) is True) instead of the desired NotImplemented.Incorrect implementations of __ne__As Aaron Hall demonstrated above, not self.__eq__(other) is not the default implementation of the __ne__ method. But nor is not self == other. The latter is demonstrated below by comparing the behavior of the default implementation with the behavior of the not self == other implementation in two cases:the __eq__ method returns NotImplemented;the __eq__ method returns a value different from NotImplemented.Default implementationLet’s see what happens when the A.__ne__ method uses the default implementation and the A.__eq__ method returns NotImplemented:!= calls A.__ne__.A.__ne__ calls A.__eq__.A.__eq__ returns NotImplemented.!= calls B.__ne__.B.__ne__ returns "B.__ne__".This shows that when the A.__eq__ method returns NotImplemented, the A.__ne__ method falls back on the B.__ne__ method.Now let’s see what happens when the A.__ne__ method uses the default implementation and the A.__eq__ method returns a value different from NotImplemented:!= calls A.__ne__.A.__ne__ calls A.__eq__.A.__eq__ returns True.!= returns not True, that is False.This shows that in this case, the A.__ne__ method returns the inverse of the A.__eq__ method. Thus the __ne__ method behaves like advertised in the documentation.Overriding the default implementation of the A.__ne__ method with the correct implementation given above yields the same results.not self == other implementationLet’s see what happens when overriding the default implementation of the A.__ne__ method with the not self == other implementation and the A.__eq__ method returns NotImplemented:!= calls A.__ne__.A.__ne__ calls ==.== calls A.__eq__.A.__eq__ returns NotImplemented.== calls B.__eq__.B.__eq__ returns NotImplemented.== returns A() is B(), that is False.A.__ne__ returns not False, that is True.The default implementation of the __ne__ method returned "B.__ne__", not True.Now let’s see what happens when overriding the default implementation of the A.__ne__ method with the not self == other implementation and the A.__eq__ method returns a value different from NotImplemented:!= calls A.__ne__.A.__ne__ calls ==.== calls A.__eq__.A.__eq__ returns True.A.__ne__ returns not True, that is False.The default implementation of the __ne__ method also returned False in this case.Since this implementation fails to replicate the behavior of the default implementation of the __ne__ method when the __eq__ method returns NotImplemented, it is incorrect.
If all of __eq__, __ne__, __lt__, __ge__, __le__, and __gt__ make sense for the class, then just implement __cmp__ instead. Otherwise, do as you're doing, because of the bit Daniel DiPaolo said (while I was testing it instead of looking it up ;) )


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__ne__
https://docs.python.org/3/c-api/object.html#c.PyObject_RichCompare
