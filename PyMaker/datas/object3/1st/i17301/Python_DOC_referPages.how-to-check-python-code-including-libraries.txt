Natural Text
I'm working on some machine learning code and today I've lost about 6 hours because simple typo.It was this:instead ofAs I'm not really used to numpy, so I forgot the brackets. The code happily crunched the numbers and at the end, just before saving results to disk, it crashed on that line.Just to put things in perspective I code on remote machine in shell, so IDE is not really an option. Also I doubt IDE would catch this.Here's what I already tried:running pylint - well pylint kinda works. After I've disabled everything apart of errors and warnings, it even seem to be usefull. But pylint have serious issue with imported modules. As seen on official bug tracker devs know about it, but cannot/won't do anything about it. There is suggested workaround, but ignoring whole module, would not help in my case.running pychecker - if I create code snippet with the mistake I made, the pychecker reports error - same error as python interpreter. However if I run pychecker on the actual source file (~100 LOC) it reported other errors (unused vars, unused imports, etc.); but the faulty numpy line was skipped.At last I have tried pyflakes but it does even less checking than pychecker/pylint combo.So is there any reliable method which can check code in advance? Without actually running it.
A language with stronger type checking would have been able to save you from this particular error, but not from errors in general. There are plenty of ways to go wrong that pass static type checking. So if you have computations that takes a long time, it makes sense to adopt the following strategies:Test the code from end to end on small examples (that run in a few seconds or minutes) before running it on big data that will consume hours.Structure long-running computations so that intermediate results are saved to files on disk at appropriate points in the computation. This means that when something breaks, you can fix the problem and restart the computation from the last save point.Run the code from the interactive interpreter, so that in the event of an exception you are returned to the interactive session, giving you a chance of being able to recover the data using a post-mortem debugging session. For example, suppose I have some long-running computation:I run this from the interactive interpreter and it raises an exception:Oh no! I forgot to transpose C! Do I have to do the inversion of A again? Not if I call pdb.pm:Now, unlike in Lisp, I can't just set things right and continue the execution. But at least I can recover the intermediate results:
Do you use unit tests? There is really no better way.


Answer URL
