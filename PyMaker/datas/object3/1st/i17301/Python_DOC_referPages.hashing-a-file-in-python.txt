Natural Text
I want python to read to the EOF so I can get an appropriate hash, whether it is sha1 or md5. Please help. Here is what I have so far:
TL;DR use buffers to not use tons of memory.We get to the crux of your problem, I believe, when we consider the memory implications of working with very large files. We don't want this bad boy to churn through 2 gigs of ram for a 2 gigabyte file so, as pasztorpisti points out, we gotta deal with those bigger files in chunks!What we've done is we're updating our hashes of this bad boy in 64kb chunks as we go along with hashlib's handy dandy update method. This way we use a lot less memory than the 2gb it would take to hash the guy all at once!You can test this with:Hope that helps!Also all of this is outlined in the linked question on the right hand side: Get MD5 hash of big files in PythonAddendum!In general when writing python it helps to get into the habit of following pep-8. For example, in python variables are typically underscore separated not camelCased. But that's just style and no one really cares about those things except people who have to read bad style... which might be you reading this code years from now.
For the correct and efficient computation of the hash value of a file (in Python 3):Open the file in binary mode (i.e. add 'b' to the filemode) to avoid character encoding and line-ending conversion issues.Don't read the complete file into memory, since that is a waste of memory. Instead, sequentially read it block by block and update the hash for each block.Eliminate double buffering, i.e. don't use buffered IO, because we already use an optimal block size.Use readinto() to avoid buffer churning.Example:
Open the file in binary mode, the default mode of open() is 'r' which is "open for reading in text mode". In text mode newline conversion is performed on your data, this can cause platform specific bugs too but a possible problem that may happen as a result of text mode is that '\r\n' sequences are replaced to '\n' sequences in the string you get to your hands. Not all files contain '\r\n' sequences especially in case of binary files so the bug wouldn't come all the time and it would be hard to catch it.There is another little problem here, You read the file in one big chunk, by reading it in smaller few kilobyte chunks you would be able to hash very large files even if they wouldn't fit into your available memory.
I have programmed a module wich is able to hash big files with different algorithms.Use the module like this:

I would propose simply:All other answers here seem to complicate too much. Python is already buffering when reading (in ideal manner, or you configure that buffering if you have more information about underlying storage) and so it is better to read in chunks the hash function finds ideal which makes it faster or at lest less CPU intensive to compute the hash function. So instead of disabling buffering and trying to emulate it yourself, you use Python buffering and control what you should be controlling: what the consumer of your data finds ideal, hash block size.


Answer URL
https://docs.python.org/3/library/mmap.html
