Natural Text
I'm teaching myself Python from a book and I'm stuck on a programming exercise. The aim of the exercise is to make a list of objects, and then sort those objects based on some object attribute.The author of my textbook says that using a key to call a class method for every comparison during sorting can slow down sort time for large datasets and that building a 'decorated' list by calling the class method just once for each object as you build the list can make subsequent sorting more efficient. The programming problem stipulates that, instead of a key, I should make a series of tuples, wherein tuple element 0 is the literal value of an object attribute, and tuple element 1 is the object itself. After I have my decorated list, I can use a built-in list sort method (e.g. "sorted()" or ".sort()", etc.) to put it all in order.I get an error when two objects have an identical sort attribute value. This example code will reproduce the error:I would like the program to print something like this:...but instead, it gives me a TypeError:I'm sure I'm getting the error because, after Python encounters two identical values for two tuple elements 0, it looks to elements 1 and finds an unorderable data type (an object). However, the limitation that two Shrubbers can't be the same age makes it seem like I'm missing something.My question: Can I stably sort my tuple list by tuple element 0 and ignore my unorderable tuple element 1?
I don't know a way to make it ignore the second element in these cases. An alternative is to add a method to the object's class that will return the needed information. Doing so will avoid needing to passsort()a key= function. Here's an example of what I mean:Output (wrapped for readability):
You do not have to implement a __lt__ function if you make sure the comparison never gets through to the Shrubber objects. One way to do that is inserting another integer into that tuple:However, this is from all points of view wrong, you should use a key= function. This is harder to read and according to my measurements, it is about four times slower. Still, using __lt__ (or the deprecated cmp=) is even worse, about two more times slower.As a final note, appending to a list this way is not the Pythonic way. You can do this:


Answer URL
https://docs.python.org/3/library/stdtypes.html?highlight=sort#list.sort
https://docs.python.org/3/reference/datamodel.html?highlight=__lt__#object.__lt__
