Natural Text
I have written a Python solution here which solves the following problem: how can a given amount of money n be made with the least number of coins of given the denominations d?While my solution works, it takes a very long time when n is larger than 50 or when the length of d is larger than 5. How can I speed up my code so it will work for considerably larger inputs? Am I missing a trick or something which would drastically speed up my code?
Can we assume that the coin denominations are sensible?  The general case of this problem would allow for strange coin denominations like [100, 90, 1] and a simple "greedy" algorithm won't find optimal solutions (e.g. for 180 the optimal solution is two 90-cent pieces, while the simple greedy algorithm would suggest one 100-cent piece and 80 pennies).If we can assume sensible currency (like any real currency) then I suggest you use a combination of integer division and modulus to find how many of each coin to use.If we cannot assume sensible currency, then this problem is ideal for a dynamic programming solution.  In dynamic programming, you build a table that memoizes intermediate results, which saves a lot of time compared to the simple recursive solution.There is a nice explanation of dynamic programming in the Skiena book The Alogorithm Design Manual.http://www.algorist.com/Here are some links I found online:http://www.avatar.se/molbioinfo2001/dynprog/dynamic.htmlhttp://www.codechef.com/wiki/tutorial-dynamic-programming
Note that you should set up your function to start with the largest coin, loop through for the maximum possible number of largest coins, then repeat with the next largest coin.Thus den should be sorted in decreasing ordernow call the recursion with the next lowest value of denval and the new d valueand increment the count appropriately.Actually, looking at the code, the changecoin function can be somewhat fixed by eliminating the while so that the inline code can be writtenThis returns the count and whatever value is left in d. If d is less than denval, the count increment would be 0 and the remaining d is unchanged. While the for loop is unbroken when d becomes 0, there are few enough entries in den that the test can be left out
This is because it is recursive Read this What is memoization and how can I use it in Python?  (and the top 2 answers)"memoization"  remembers things you have calculated already (eg 10 cents) so you don't recalculate them an exponential number of times. You can copy the Mwmoize class as is, and just "decorate" your function, as explained in the second answerFOR THE LAZY then add the decorator before the definitionthe rest of the function is the samethen you call it 
Here is a faster version of your program. I've changed two things:Implementation detail: all recursive programs can be re-written as equivalent iterative programs (in this case, using a for and a while loop). In most languages, the iterative version is faster as there is no need to maintain a stack.Algorithm: I am using a greedy algorithm that starts off with the largest-value coins first, and then tries the smaller coins. This is not guaranteed to be optimal, as pointed out in other answers, but runs very fast (linear in the number of coins in the returned solution). Have a look at this page for an optimal (but slower) dynamic programming solution.Let's try it out:and again, when it is impossible to get the desired amountand again, when the greedy algorithm finds a sub-optimal solutionbut the optimal solution would have been [90, 90]


Answer URL
