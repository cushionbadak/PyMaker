Natural Text
This is my Python code:Where y could be a list like:Can somebody explain me the difference between these two sentences?Thank you!
Let’s start with the simple one first:The parentheses don’t carry any meaning there, so this is equivalent to this:The in operator checks if something is contained within something else. In your case, you have a list y, so you are checking if something (x) is not contained within (not in) that list y. So '1' not in y would be False because '1' is an element of y, and '4' not in y would be True because '4' is not an element of y.The other one is something completely different though:Here we have a generator expression. Generator expressions are of the format (x for z in y) and are equivalent to this code:You might have heard about list comprehensions before; those are similar but use square brackets instead of parentheses: [x for z in y]. As they return a list, they are a bit easier to understand. They are equivalent to this:Essentially, you are looping over the elements of y, calling each element in an iterationz and return x for that element. In your case, x is an expression itself: x not in z which is basically the same as above: You are checking if x is not contained within z.Now, generator expressions are a bit complicated, because they are evaluated when an element is requested from it, so let’s assume for now that we have a list comprehension insteadSo what this does is calculate x not in z for each element z in y. So for your y, the resulting list would be this:With a real x, this would as such result in a list with three boolean values. Now a non-empty list is always trueish, so regardless of the result in this check, the if-check would succeed.The generator expression will return a generator though, which is a more complex object that a list. It is just as well true-ish though, so your check will also succeed regardless of the individual values.Now imagine, we want to make sure, that for those three elements in the list, we want all checks to result in True. For that, we can use the all() function which essentially checks if a list—or the values in a generator—contains only true values.So this will succeed if x is not contained within any element of the list y. If on the other hand we wanted to check if at least one trueish value is in the list or generator, then we could instead use the any() function.
GeneratorTo begin with, (x not in z for z in y) is a generator statement, and if if is in front of it, it will always return True.This could be used to see if any or all of the nested iterables contain x.e.g. So if y is this:then if x is, for example, 'e', then the any comprehension above would return True, but the all comprehension would return False. ConditionalSo here's what going on inside that generator comprehension: if y is a list, and you test with:the z in y must be an iterable in order to test for inclusion, which strings are, but you're only seeing if something is in a string of length one in this case. A better example would be to use integers:and would fail, because integers are not iterable, but would succeed because you can test for membership in the actual list.When you have a similar level of nesting would be:and with you are testing if x is in one of those tuples.Does that make sense?
Thisis equivalent toBecauseThisIs the same asWhich resolves internally toIn the first case, you might have meant to write:or:
I'll assume this is a general question, and the actual values in the list don't matter much. For:The for in the statement means you have a  "list comprehension" or "generator expression" (inside parens). It will generate a list. This one is a list comprehension with a filter (the x not in z part). But the end result will be a list that may or may not be empty. Now the if statement will evaluate this for "truthiness", where an empty list is considered false, and non-empty is true.  This is a straight "containment test" that tests directly if x is contained (or not) in the iterable y, and returns a Boolean value. This can be a fast test, depending on what kind of object y is.  The first form is probably slower and unnecessary in most cases. The first one has to create and then destroy a temporary list.


Answer URL
