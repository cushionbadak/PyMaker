Natural Text
If I have a function like:Then why does this works:But not this:?EDIT :For information, the original problem was to replace one of the argument in a function wrapper. I wanted to replace a given member of the inputted *args and tried something like:That's where the question arose from. And I know there is other way do do the same thing but only wanted to understand why unpacking one sequence worked but not for more.
Because, as per the Function call syntax, this is how the argument list is definedSo, you can pass only one * expression per function call.
Starting in Python 3.5, this does work.PEP 448 was implemented in Python 3.5.  Quoting from the PEP, it allows, among other things:Arbitrarily positioned unpacking operators:
This would work instead. The reason that doesn't work is that Python implement this using thisOne list unpacks, and following the semantics, any argument after that must be a named keyword argument( or a dictonary passing named keyword arguments through**)By constrast, this would work. 
You can concatenate lists:or use itertools.chain:
It doesn't work because it's invalid syntax - that is to say, it isn't actually Python although it looks like it.Only one starred parameter is allowed in Python 2 function signatures, and it must follow any positional parameters and precede any keyword parameters. Similarly only one double-starred argument is allowed, and it must follow all keyword parameters in the signature. If you have multiple lists of arguments you would like to submit you will indeed have to create a single list from them first.In Python 3 it is also possible to use a star on its own to indicate that any following parameters are so-called keyword-only parameters, but I don't think we need get into that just yet.
The * here isn't acting as an operator. It's more like part of the syntax of function calls, and it only allows for certain limited possibilities. It would have been possible to define the language so that you could do what you want (I've done it!), but that wasn't the choice that was made.
These may help. Note that the analogy is to a variable number of arguments in other languages. This means that once you say you are going to use a variable number of arguments, all following arguments are part of that list (analogy to C or C++ use of varargs).for example    f = [1,2,3,4,5]http://www.python-course.eu/passing_arguments.phpVariable Length of Parameters  We will introduce now functions, which  can take an arbitrary number of arguments. Those who have some  programming background in C or C++ know this from the varargs feature  of these languages. The asterisk "*" is used in Python to define a  variable number of arguments. The asterisk character has to precede a  variable identifier in the parameter list.We learn from the previous example, that the arguments passed to the  function call of varpafu() are collected in a tuple, which can be  accessed as a "normal" variable x within the body of the function. If  the function is called without any arguments, the value of x is an  empty tuple.Sometimes, it's necessary to use positional parameters followed by an  arbitrary number of parameters in a function definition. This is  possible, but the positional parameters always have to precede the  arbitrary parameters. In the following example, we have a positional  parameter "city", - the main location, - which always have to be  given, followed by an arbitrary number of other locations:http://docs.python.org/2.7/reference/expressions.htmlIf the syntax *expression appears in the function call, expression  must evaluate to an iterable. Elements from this iterable are treated  as if they were additional positional arguments; if there are  positional arguments x1, ..., xN, and expression evaluates to a  sequence y1, ..., yM, this is equivalent to a call with M+N positional  arguments x1, ..., xN, y1, ..., yM.A consequence of this is that although the *expression syntax may  appear after some keyword arguments, it is processed before the  keyword arguments (and the **expression argument, if any â€“ see below).  So:>It is unusual for both keyword arguments and the *expression syntax to  be used in the same call, so in practice this confusion does not  arise.If the syntax **expression appears in the function call, expression  must evaluate to a mapping, the contents of which are treated as  additional keyword arguments. In the case of a keyword appearing in  both expression and as an explicit keyword argument, a TypeError  exception is raised.


Answer URL
