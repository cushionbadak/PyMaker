Natural Text
I stumbled upon a question yesterday that involved enumerating over an iterable type and yeilding descending indices accompanied by ascending items in the iterable.  In:Out:Instead of writing a quick and reliable answer applying built-in reverse twice, or simply i = len(letters) - i - 1, I decided to try create a child class of enumerate that redefines __iter__ and __next__ methods.The code for my original working solution was as follows:However, I now realize this code has redundancy as enumerate.__iter__ appears to yield the result of __next__, makes sense.  After deleting the redefined __iter__ I realized that self._data was not being used anywhere, so I removed the last four lines from __init__ leaving me with the following code, which still provides the desired behavior.Now it appears that the iterable argument passed into revenumerate is not for anything except determining the integer self._len.My question is - where is iterable stored and how does super().__next__ access it? A quick look at builtins.py with the PyCharm debugger does not provide a lot of help in figuring this out (or so it seems to me at this stage), and I am not well traversed with the Python source code repository.  My guess is something to do with the __new__ or __init__ method of parent class enumerate, or it's parent object.  
builtins.py is a lie. PyCharm made it up. If you want to look at the real source code for the builtins module, that's Python/bltinmodule.c in the Python Git repository. enumerate itself is implemented in Objects/enumobject.c.enumerate iterators store an iterator over their underlying object in a C-level en_sit struct slot:set in enumerate.__new__:The fact that it's set in __new__ is why it still worked even though you forgot to call super().__init__.Subclassing enumerate for this doesn't make a lot of sense. enumerate is only documented as a callable; the fact that it's a class and supports subclassing is an implementation detail. Also, you're not getting a lot of use out of enumerate, and the relationship between your iterators and enumerate iterators doesn't really sound like "is-a". Implementing your functionality as a generator, like zvone did, is cleaner and clearer.
What enumerate does is more-or-less* this:One thing you can notice is that it does not know how long the iterable is. It can even be infinitely long, but enumerate will still work.The problem with revenumerate is that you first have to count how many items there are before being able to yield the first one, so you actually have to create a list of all enumerated items and then yield them backwards (at least if you want your revenumerate to work with any iterable, like enumerate).Once you accept that limitation as inavoidable, the rest is simple:(*) enumerate is actually a class, but this is its behaviour. See my other answer about how that works and what __next__ does.
Others have answered your specific question about how your code works so here's another way to implement a reverse enumerator using zip():revenumerate() returns a zip object that is very similar to the enumerate object returned by enumerate().By default the items will be enumerated starting at the length of the iterable less one, which requires that the length be finite. You can supply a start value from which to count down which would be useful if you just wanted to start counting from an arbitrary value, or to sort of handle infinite iterables.If you tried to work on an infinite iterable without specifying the start value:Which prevents the interpreter entering an infinite loop. You could handle the exception and raise one of your own if that suited your application.
In my previous answer I wrote how I would do it, but here are some answers to what was actually asked about __iter__ and __next__...IterableIn order for an object to be iterable, it has to implement method __iter__, which has to return an iterator.Here are some simple examples:These can be iterated:IteratorThe object returned from __iter__ is an iterator. An iterator must implement the __next__ method.For example:Custom iteratorEDIT: As others mentioned in the comments, an iterator should always implement __iter__ which returns self (as I did in the examples below). This requirement can be read in PEP-0234 and in Python docs:A class that wants to be an iterator should implement two methods: a  next() method that behaves as described above, and an __iter__()  method that returns self.Iterable iteratorAn iterable iterator? Well if a class implements both __iter__ and __next__, then it is both:enumerateenumerate actually does something like this:So, to answer your question, in your super().__next__(), you are calling this __next__ here, which uses the iterator which it stored in the constructor.


Answer URL
https://docs.python.org/3/library/stdtypes.html#iterator-types
https://docs.python.org/3/library/stdtypes.html#iterator.__iter__
