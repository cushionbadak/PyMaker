Natural Text
I'm working with floating point numbers. If I do:I get:Obviously, this should be 100.05. I know about the existence of IEEE 754 and that the way that floating point numbers are stored is the cause of this rounding error.My question is: how can I avoid this error?
You are partly right, often the cause of this "incorrect rounding" is because of the way floating point numbers are stored. Some float literals can be represented exactly as floating point numbers while others cannot.It's also important to know that there is no way you can restore the literal you used (100.045) from the resulting floating point number. So the only thing you can do is to use an arbitrary precision data type instead of the literal. For example you could use Fraction or Decimal (just to mention two built-in types).I mentioned that you cannot restore the literal once it is parsed as float - so you have to input it as string or something else that represents the number exactly and is supported by these data types:However these don't work well with NumPy and even if you get it to work at all - it will almost certainly be very slow compared to basic floating point operations.In the beginning I said that you're are only partly right. There is another twist! You mentioned that rounding 100.045 will obviously give 100.05. But that's not obvious at all, in your case it is even wrong (in the context of floating point math in programming - it would be true for "normal calculations"). In many programming languages a "half" value (where the number after the decimal you're rounding is 5) isn't always rounded up - for example Python (and NumPy) use a "round half to even" approach because it's less biased. For example 0.5 will be rounded to 0 while 1.5 will be rounded to 2.So even if 100.045 could be represented exactly as float - it would still round to 100.04 because of that rounding rule!This is even mentioned in the NumPy docs for numpy.around:NotesFor values exactly halfway between rounded decimal values, NumPy rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0, -0.5 and 0.5 round to 0.0, etc. Results may also be surprising due to the inexact representation of decimal fractions in the IEEE floating point standard [R1011] and errors introduced when scaling by powers of ten.(Emphasis mine.)The only (at least that I know) numeric type in Python that allows setting the rounding rule manually is Decimal - via ROUND_HALF_UP:SummarySo to avoid the "error" you have to:Prevent Python from parsing it as floating point value and use a data type that can represent it exactlythen you have to manually override the default rounding mode so that you will get rounding up for "halves".(abandon NumPy because it doesn't have arbitrary precision data types)
Basically there is no general solution for this problem IMO, unless you have a general rule for all the difference cases (see Floating Point Arithmetic: Issues and Limitation). However, in this case you can round the decimal part separately:The reason for such behavior is not because separating integer from decimal part makes any difference on round() logic. It's because when you use fmod it gives you a more realistic version of the decimal part of the number which is actually a rounded representation.In this case here is what dec is:And you can check that round gives same result with 0.045:Now if you try with another number like 100.0333, the decimal part is a slightly smaller version which as I mentioned, the result you want depends on your rounding policies.There are also modules like fractions and decimal that provide support for fast correctly-rounded decimal floating point and rational arithmetic, that you can use in situations as such.


Answer URL
https://docs.python.org/3/tutorial/floatingpoint.html#tut-fp-issues
https://docs.python.org/3/library/fractions.html#module-fractions
https://docs.python.org/3/library/decimal.html#decimal.Decimal
