Natural Text
Is there a way to write a replacement rule for a function f with an arbitrary number of arguments that makes it linear in all its arguments?An example for when f has three arguments:f( x1+x4 , x2 , x3 ) = f(x4,x2,x3) + f(x1,x2,x3)f( x1 , x2+x4 , x3 ) = f(x1,x2,x3) + f(x1,x4,x3)f( x1 , x2 , x3+x4 ) = f(x1,x2,x3) + f(x1,x2,x4)Using "Wild" works partially:I know I could iterate in a variety of ways over the arguments of the function while altering the replacement, but I was hoping the functionality was built into "Wild" or "replace" already. Mathematica, for example, has "wildcards" like "a___,b___,A___,B___" which mean that "a___" could be an empty sequence, or  a single argument, or a sequence of multiple arguments. For example, in Mathematica,would correctly simplify both test cases, and for f's with any number of arguments.Is there something similar, or is this is close as sympy gets?Alternatively, might this be possible to do with argument unpacking on a recursive definition starting from something like def f(*args):?
Instead of Wild matching, I would detect which arguments of f are Add and expand those using itertools.productFor example, if expr is f(x1+x2+x4, x2+x4, x3*x1), then term_groups is [(x1, x2, x4), (x2, x4), (x1*x3,)] where the last argument yields a 1-element tuple since it's not an Add. And expanded is 


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.product
