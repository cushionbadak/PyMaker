Natural Text
Currently I am playing with Python performance, trying to speed up my programs (usually those which compute heuristics). I always used lists, trying not to get into numpy arrays.But recently I've heard that Python has 8.7. array â€” Efficient arrays of numeric values so I thought I would try that one.I wrote a piece of code to measure an array.count() vs. a list.count(), as I use it in many places in my code:I was expecting a slight performance improvement when using array. Well, this is what happened:So, according to timeit the list.count() is 2013x faster than the array.count(). I definitely didn't expect that. So I've searched through SO, python docs etc. and the only thing I found was that the objects in array have to be first wrapped into int-s, so this could slow things down, but I was expecting this to happen when creating an array.array-instance, not when random accessing it (which I believe is what .count() does).So where's the catch?Am I doing something wrong?Or maybe I shouldn't use standard arrays and go straight to numpy.arrays?
where's the catch?The initial test, as proposed above does not compare apples to apples:not mentioning the python-2.7, where range() creates indeed a RAM-allocated data-structure, whereas xrange() resembles a python-3 re-formulated object ( as seen below ) a generator-will never be comparable to whatever smart RAM-allocated data-structure.The generator's object intrinsic .__len__() spits out the length, where still no counting takes place, does it? ( glad it did not, it would not fit into even ~ 10^20 [TB] of RAM ..., yet it can "live" in py3+ as an object ) Quantitatively fair testing? Better test engineering details are needed:Go well above a few tens of MB, so as to avoid false expectations from InCACHE-computing artifacts, that will never scale-out to real-world problem sizes:Go into RAM-feasible, yet above InCACHE-horizon sizings:go straight to numpy arrays ?Definitely a wise step to test either. Vectorised internalities may surprise, and often do a lot :o)Depends a lot on your other code, if numpy-strengths may even boost some other parts of your code-base. Last but not least, beware of premature optimisations and scaling. Some [TIME]-domain traps could be coped with if can spend more in [SPACE]-domain, yet most dangerous are lost InCACHE-locality, where no tradeoffs may help. So, better do not prematurely lock on promising detail, at a cost of loosing a global scale performance target.


Answer URL
https://docs.python.org/3/library/array.html
