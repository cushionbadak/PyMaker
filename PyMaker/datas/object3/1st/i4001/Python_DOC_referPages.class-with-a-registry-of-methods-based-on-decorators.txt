Natural Text
I have a class that has several methods which each have certain properties (in the sense of quality). I'd like these methods to be available in a list inside the class so they can be executed at once. Note that the properties can be interchangeable so this can't be solved by using further classes that would inherit from the original one. In an ideal world it would look something like this:When the class is instantiated, it should be easy to simply execute all red and soft rules by combining the sets and executing the methods. The decorators for this are tricky though since a regular registering decorator can fill out a global object but not the class attribute:How do I go about implementing something like this?
You can subclass set and give it a decorator method:Or if you find using the .register method ugly, you can always define the __call__ method to use the set itself as a decorator:This looks better, but it's less explicit, so for other collaborators (or future yourself) it might be harder to grasp what's happening here.To call the stored functions, you can just loop over the set you want and pass in the instance as the self argument:You can also create an utility function to do this for you, for example you can create a MySet.invoke() method:And now just call:Or you could have MyClass handle this instead:And then call this on an instance of MyClass:
Decorators are applied when the function is defined; in a class that's when the class is defined. At this point in time there are no instances yet!You have three options:Register your decorators at the class level. This is not as clean as it may sound; you either have to explicitly pass additional objects to your decorators (red_rules = set(), then @red(red_rules) so the decorator factory can then add the function to the right location), or you have to use some kind of class initialiser to pick up specially marked functions; you could do this with a base class that defines the __init_subclass__ class method, at which point you can iterate over the namespace and find those markers (attributes set by the decorators).Have your __init__ method (or a __new__ method) loop over all the methods on the class and look for special attributes the decorators have put there. The decorator would only need to add a _rule_name or similar attribute to decorated methods, and {getattr(self, name) for for name in dir(self) if getattr(getattr(self, name), '_rule_name', None) == rule_name} would pick up any method that has the right rule name defined in rule_name.Make your decorators produce new descriptor objects; descriptors have their __set_name__() method called when the class object is created. This gives you access to the class, and thus you can add attributes to that class.Note that __init_subclass__ and __set_name__ require Python 3.6 or newer; you'd have to resort to a metaclass to achieve similar functionality in earlier versions.Also note that when you register functions at the class level, that you need to then explicitly bind them with function.__get__(self, type(cls)) to turn them into methods, or you can explicitly pass in self when calling them. You could automate this by making a dedicated class to hold the rule sets, and make this class a descriptor too:Then just use:and you can access self.red_rules, etc. as a set with bound methods:The same rules are accessible on the class; normal functions remain unbound:Containment testing works as expected:You can use these rules to register classmethod and staticmethod objects too:


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__init_subclass__
https://docs.python.org/3/reference/datamodel.html#descriptors
https://docs.python.org/3/reference/datamodel.html#object.__set_name__
https://docs.python.org/3/reference/datamodel.html#metaclasses
