Natural Text
a follow-up question on this question: i ran the code below on python 3.5 and python 3.6 - with very different results:as stated in the previous question this raisesTypeError: type object got multiple values for keyword argument 'b'on python 3.6. but on python 3.5 i get the exception:KeyError: 0moreover if i do not raise KeyError but just print out the key and return in __getitem__:this will print out the int sequence 0, 1, 2, 3, 4, .... (python 3.5)so my questions are:what has changed between the releases that makes this behave so differently? where are these integers coming from?UPDATE : as mentioned in the comment by Î»user: implementing __iter__ will change the behavior on python 3.5 to match what python 3.6 does:
This is actually a complicated conflict between multiple internal operations during unpacking a custom mapping object and creating the caller's arguments. Therefore, if you wan to understand the underlying reasons thoroughly I'd suggest you to look into the source code. However, here are some hints and starting points that you can look into for greater details.Internally, when you unpack at a caller level, the byte code BUILD_MAP_UNPACK_WITH_CALL(count) pops count mappings from the stack, merges them into a single dictionary and pushes the result. In other hand, the stack effect of this opcode with argument oparg is defined as following:With that being said lets look at the byte codes of an example (in Python-3.5) to see this in action: As you can see, at offset 15 we have BUILD_MAP_UNPACK_WITH_CALL byte code which is responsible for the unpacking.Now what happens that it returns 0 as the key argument to the __getitem__ method?Whenever the interpreter encounters an exception during unpacking, which in this case is a KeyError, It stops continuing the push/pop flow and instead of returning the real value of your variable it returns the stack effect which is why the key is 0 at first and if you don't handle the exception each time you get an incremented result (due to the stack size).Now if you do the same disassembly in Python-3.6 you'll get the following result:Before creating the local variables (LOAD_FAST) and after LOAD_GLOBAL there is a BUILD_TUPLE which is responsible for creating a tuple and consuming count items from the stack.BUILD_TUPLE(count)Creates a tuple consuming count items from the stack, and pushes the >resulting tuple onto the stack.And this is, IMO, why you don't get a key error and instead you get TypeError. Because during the creation of a tuple of arguments it encounters a duplicate name and therefore, properly, returns the TypeError.


Answer URL
https://docs.python.org/3/library/dis.html#opcode-BUILD_MAP_UNPACK_WITH_CALL
https://docs.python.org/3/library/dis.html#opcode-BUILD_TUPLE
