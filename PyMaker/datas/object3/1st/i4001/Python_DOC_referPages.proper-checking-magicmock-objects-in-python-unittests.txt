Natural Text
I have this code under test:In my unittest I want to assert that exactly this is done with the passed x and the result returned, so I pass a MagicMock object as x:Then I check the result for being what I expect:After importing unittest.mock I need to patch the internal structure of the mock module in order to be able to properly magic-mock the round() function (see https://stackoverflow.com/a/50329607/1281485 for details on that):So, now, as I said, this works.  But I find it extremely unreadable.  Furthermore I needed to play around a lot to find the things like _mock_new_parent etc.  The underscore also indicates that this is a "private" attribute and shouldn't be used.  The documentation doesn't mention it.  It also does not mention another way of achieving what I try to.Is there a nicer way to test returned MagicMock objects for being created the way they should have been?
You are going overboard. You are testing the implementation, not the result. Moreover, you are reaching into internals of the mock implementation that you do not need to touch.Test that you get the right result, and test that the result is based on the inputs you want to be used. You can set up the mock such that round() is passed an actual numeric value to round:x.a + x.b results in a call to m.a.__add__, passing in m.b.m.a.__add__().c() is called, so we can test that it was called if that's needed.Just set the result of c() to a number for round() to round off. Getting the correct round(number) result from the function means .c() was called.Passing in a number to round() is sufficient here, because you are not testing the round() function. You can rely on the Python maintainers to test that function, focus on testing your own code.This is what I'd test:If you must assert that m.a + m.b took place, then you can addbut the mock_c call assert passing is already proof that at least a (m.a + <whatever>) expression took place and that c was accessed on the result.If you must validate that round() was used on an actual mock instance, you'll have to stick to patching the MagicMock class to include __round__ as a special method and remove the mock_c.return_value assignment, after which you can assert that the return value is the correct object withSome further notes:There is no point in trying to make everything a mock object. If the code under test is supposed to work on standard Python types, just have your mocks produce those types. E.g. if some call is expected to produce a string, have your mock return a test string, especially when you are then passing stuff to other standard-library APIs.Mocks are singletons. You do not need to work back from a given mock to test that they have the right parent, because you can reach the same object by traversing the parent attributes and then use is. E.g. if a function returns the a mock object somewhere, you can assert that the right mock object was returned by testing assertIs(mock_object.some.access.return_value.path, returned_object).When a mock is called, that fact is recorded. You can assert this with the assert_called* methods, the .called and .call_count attributes, and traverse the result of calls with the .return_value attributesWhen in doubt, inspect the .mock_calls attribute to see what the code-under-test has accessed. Or do so in an interactive session. For example, it's easier to see what m.a + m.b does in a quick test with:


Answer URL
https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types
