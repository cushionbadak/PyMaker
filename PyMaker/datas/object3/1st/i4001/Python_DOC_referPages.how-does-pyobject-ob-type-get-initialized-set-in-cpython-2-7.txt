Natural Text
I am investigating how isinstance() func works for CPython 2.7Now I have an example with two Python files: lib1.py lib2.pyThe results print: TrueThen I dig into CPython source code tohttps://github.com/python/cpython/blob/ad65d09fd02512b2ccf500f6c11063f705c9cd28/Objects/abstract.c#L2945where CPython did this check:where Py_TYPE() is macroDoes anyone know the clues how CPython inits or sets the ob_type during the program starting?
Normally, this happens in PyObject_Init (or PyObject_InitVar, which I won't mention again, but there are equivalent variations across the board), or the PyObject_INIT macro (which does the same thing in a faster way, but one that isn't guaranteed to be binary-compatible with other interpreter builds on the same platform). The docs for PyObject_Init say:Initialize a newly-allocated object op with its type and initial reference. Returns the initialized object. If type indicates that the object participates in the cyclic garbage detector, it is added to the detector’s set of observed objects. Other fields of the object are not affected.You can see the source in object.c:For more details, see the comments in objimpl.h.When an object is constructed from Python (or via the high-level C API):The type's __new__ method or tp_new slot gets called.This usually inherits from or supers to object_new, which calls PyType_GenericNew.… or it delegates to some other constructor (which ultimately gets you back here)… or returns some already existing object… but if not, it must call tp_alloc manually.PyType_GenericNew calls the type's tp_alloc slot (there's no Python special method for this).This usually inherits from or supers to PyType_GenericAlloc, which calls the PyObject_INIT macro.… but if not, tp_alloc must call one of the PyObject_Init-family functions or macros, or do the same thing itself.Code in C extension modules, and internal interpreter code may:Use the same high-level API… or call PyObject_New, which allocates the object and calls PyObject_Init on it, and casts the result pointer… or just call PyObject_Init directly (when it knows the type it's constructing doesn't customize tp_new, tp_alloc, or tp_init)… or construct objects manually, but at some point it must call one of the PyObject_Init family directly or indirectly, or do the same thing itself, just as with custom tp_alloc… or allocate constant objects statically rather than on the heap, like PyNone and many builtin and extension type objects, in which case the type (which also has to be a static constant, of course) is just specified in the struct initializer.


Answer URL
https://docs.python.org/3/c-api/allocation.html#c.PyObject_Init
https://docs.python.org/3/reference/datamodel.html#object.__new__
https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_new
https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_alloc
