Natural Text
I am writing web endpoints that take a JSON Web Token (JWT) and have to check the signature on the token. Since I am going to check the signature every time it makes the most sense to me that I should break this step out into a function because DRY. However, the only way to check whether a JWT is signed correctly is to decode it with its secret key and catch an error. This leads me to the following function:This works fine in terms of validating the tokens, however it seems really wasteful that I have this function that will check if the token is valid by decoding and then immediately after this function I am going to have to decode again. That is to say I would do:In this case I am decoding to check if it's valid and then if it is I'm decoding again. In C/C++ I would pass a variable by reference to capture the decoded data and then return true or false. Is there any way to do such a thing in Python? It occurred to me that I might be able to get away with this by passing in an empty list to capture the decoded data but that seems really inelegant. Is there a Pythonic way to do this?
After discussing with Nullman we've come to the following solution
Your method is already using a good Pythonic EAFP idiom, but it then shoehorns it into a C style LBYL return code checking pattern. Don't do that, keep using exceptions.In this case is_valid_token is kind of pointless; it doesn't actually save anything when you still need the if/else based on its return value. Don't test at all, just do the parsing inline and handle the exception if it occurs:It's not meaningfully more verbose (you could make it shorter by putting the contents of the else block in the try if nothing else could raise a jwt.DecodeError and it would be exactly as verbose as the if/else).If this is in more deeply nested code, you might not even catch the exception here, but let it bubble up the stack until someone who knows how to respond to the client receives it.Again, to reiterate, your problem is trying to use LBYL idioms to see if you're allowed to do something, then do it, when the simplest approach is to just do it and handle the exception if it occurs. You didn't actually avoid DRY, because instead of RY on the parsing, you end up RY on checking the return and using the result.
EDIT: as @ShadowRanger points out, the code below should work, but it doesn't actually improve anything, the exception needs to be reraise from __init__ and the caller needs to check for it. So this wrapper doesn't really help. I'll leave the answer in for reference, but the right way to do it is probably @ShadowRanger's answer.Maybe you can leverage class inheritance here:and then in your code, you can use the class like:This way you don't even need to call is_valid() at all, but how you actually implement this may depend on the framework you're using, if any.


Answer URL
https://docs.python.org/3/glossary.html#term-eafp
https://docs.python.org/3/glossary.html#term-lbyl
