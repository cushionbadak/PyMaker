Natural Text
I was trying to implement a (prototype, not production) version of a persistent dictionary that uses pickle on disk as persistent storage. However, pickle.load calls __setitem__ for its own purposes, and that's the method that is (of course) overridden to ensure changes to the dictionary are propagated back to the persistent storage -- and so it calls pickle.dump. Of course, it's not ok to call pickle.dump as every item is being set during unpickling.Is there any way to solve this, other than by brute force (as below)? I tried reading Pickling Class Instances in search of a solution using of special methods, but didn't find any.The code below monitors whether unpickling is in progress, and skips pickle.dump in that case; while it works fine, it feels hacky.
Inheriting directly from dict is not advised when trying to get to fancy dictionary implementations. For one thing, Python's ABI takes some shortcuts on dict class that might eventually skip some calls tos certain dunder methods - and also, as you can perceive when pikcling and unpickling - dictionaries and direct subclasses of it will be treated in a different way than ordinary objects (which have their __dict__ attribute pickled, not their keys set with __setitem__.So, for one thing, start with inheriting from collections.UserDict - this is a different implementation of dict which ensures all data access is done through a proper Python side call to the dunder special methods. You might even want to implement it as an implementation of collections.abc.MutableMapping - that ensures you have to implement a minimal number of methods in your code to have your class working like if it were a real dictionary. Second thing: the Pickle protocol will do "its thing" by default - which in mapping classes is (I haven't checked, but apparently is), pickling the (key, value) pairs and calling __setitem__ for each of those on unpicling.  But the pickling behavior is fully customizable-  as you can see on the documentation - you can simply implement explict __getstate__ and __setstate__ methods on your class to have full control over the pickling/unpickling code.Example using MutableMapping, and storing the dictionary contents in an associated internal dictionary:BTW, a big advantage of using the MutableMapping super class is that it is guarranteed that if you implement properly the methods described in the documentation, your code is ready for production (so, no need to worry about missing exquisite corner cases).   
The strategy employed in this recipe by Raymond Hettinger is to:and inside __init__ (you therefore don't need to implement __new__)


Answer URL
https://docs.python.org/3/library/pickle.html#pickling-class-instances
https://docs.python.org/3/library/pickle.html#object.__setstate__
https://docs.python.org/3/library/collections.abc.html
