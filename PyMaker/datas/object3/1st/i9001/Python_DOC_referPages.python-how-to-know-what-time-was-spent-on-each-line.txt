Natural Text
Project Euler and other coding contests often have a maximum time to run or people boast of how fast their particular solution runs.  With python, sometimes the approaches are somewhat kludgey - i.e., adding timing code to __main__.What is a good way to profile how long a python program takes to run?
Python includes a profiler called cProfile. It not only gives the total running time, but also times each function separately, and tells you how many times each function was called, making it easy to determine where you should make optimizations.You can call it from within your code, or from the interpreter, like this:Even more usefully, you can invoke the cProfile when running a script:To make it even easier, I made a little batch file called 'profile.bat':So all I have to do is run:And I get this:EDIT: Updated link to a good video resource from PyCon 2013 titled Python ProfilingAlso via YouTube.
A while ago I made pycallgraph which generates a visualisation from your Python code. Edit: I've updated the example to work with 3.3, the latest release as of this writing.After a pip install pycallgraph and installing GraphViz you can run it from the command line:Or, you can profile particular parts of your code:Either of these will generate a pycallgraph.png file similar to the image below:
It's worth pointing out that using the profiler only works (by default) on the main thread, and you won't get any information from other threads if you use them.  This can be a bit of a gotcha as it is completely unmentioned in the profiler documentation.If you also want to profile threads, you'll want to look at the threading.setprofile() function in the docs.You could also create your own threading.Thread subclass to do it:and use that ProfiledThread class instead of the standard one.  It might give you more flexibility, but I'm not sure it's worth it, especially if you are using third-party code which wouldn't use your class.
The python wiki is a great page for profiling resources:http://wiki.python.org/moin/PythonSpeed/PerformanceTips#Profiling_Codeas is the python docs:http://docs.python.org/library/profile.htmlas shown by Chris Lawlor cProfile is a great tool and can easily be used to print to the screen:or to file:PS> If you are using Ubuntu, make sure to install python-profileIf you output to file you can get nice visualizations using the following toolsPyCallGraph : a tool to create call graph images   install:run:view:You can use whatever you like to view the png file, I used gimpUnfortunately I often get dot: graph is too large for cairo-renderer bitmaps. Scaling by 0.257079 to fitwhich makes my images unusably small.  So I generally create svg files:PS> make sure to install graphviz (which provides the dot program):Alternative Graphing using gprof2dot via @maxy / @quodlibetor :
@Maxy's comment on this answer helped me out enough that I think it deserves its own answer: I already had cProfile-generated .pstats files and I didn't want to re-run things with pycallgraph, so I used gprof2dot, and got pretty svgs:and BLAM!It uses dot (the same thing that pycallgraph uses) so output looks similar. I get the impression that gprof2dot loses less information though:
I ran into a handy tool called SnakeViz when researching this topic. SnakeViz is a web-based profiling visualization tool. It is very easy to install and use. The usual way I use it is to generate a stat file with %prun and then do analysis in SnakeViz.The main viz technique used is Sunburst chart as shown below, in which the hierarchy of function calls is arranged as layers of arcs and time info encoded in their angular widths.The best thing is you can interact with the chart. For example, to zoom in one can click on an arc, and the arc and its descendants will be enlarged as a new sunburst to display more details.
I think that cProfile is great for profiling, while kcachegrind is great for visualizing the results. The pyprof2calltree in between handles the file conversion.To install the required tools (on Ubuntu, at least):The result:
Also worth mentioning is the GUI cProfile dump viewer RunSnakeRun.  It allows you to sort and select, thereby zooming in on the relevant parts of the program.  The sizes of the rectangles in the picture is proportional to the time taken.  If you mouse over a rectangle it highlights that call in the table and everywhere on the map.  When you double-click on a rectangle it zooms in on that portion.  It will show you who calls that portion and what that portion calls.The descriptive information is very helpful.  It shows you the code for that bit which can be helpful when you are dealing with built-in library calls.  It tells you what file and what line to find the code.Also want to point at that the OP said 'profiling' but it appears he meant 'timing'.  Keep in mind programs will run slower when profiled.
A nice profiling module is the line_profiler (called using the script kernprof.py).  It can be downloaded here.My understanding is that cProfile only gives information about total time spent in each function.  So individual lines of code are not timed.  This is an issue in scientific computing since often one single line can take a lot of time.  Also, as I remember, cProfile didn't catch the time I was spending in say numpy.dot.
pprofileline_profiler (already presented here) also inspired  pprofile, which is described as:Line-granularity, thread-aware deterministic and statistic pure-python  profilerIt provides line-granularity as line_profiler, is pure Python, can be used as a standalone command or a module, and can even generate callgrind-format files that can be easily analyzed with [k|q]cachegrind.vprofThere is also vprof, a Python package described as:[...] providing rich and interactive visualizations for various Python program characteristics such as running time and memory usage.
Simplest and quickest way to find where all the time is going.Draws a pie chart in a browser. Biggest piece is the problem function. Very simple.
I recently created tuna for visualizing Python runtime and import profiles; this may be helpful here.Install withCreate a runtime profileor an import profile (Python 3.7+ required)Then just run tuna on the file
Following Joe Shaw's answer about multi-threaded code not to work as expected, I figured that the runcall method in cProfile is merely doing self.enable() and self.disable() calls around the profiled function call, so you can simply do that yourself and have whatever code you want in-between with minimal interference with existing code.
There's a lot of great answers but they either use command line or some external program for profiling and/or sorting the results.I really missed some way I could use in my IDE (eclipse-PyDev) without touching the command line or installing anything. So here it is.Profiling without command lineSee docs or other answers for more info.
In Virtaal's source there's a very useful class and decorator that can make profiling (even for specific methods/functions) very easy. The output can then be viewed very comfortably in KCacheGrind.
cProfile is great for quick profiling but most of the time it was ending for me with the errors. Function runctx solves this problem by initializing correctly the environment and variables, hope it can be useful for someone:
My way is to use yappi (https://code.google.com/p/yappi/). It's especially useful combined with an RPC server where (even just for debugging) you register method to start, stop and print profiling information, e.g. in this way: Then when your program work you can start profiler at any time by calling the startProfiler RPC method and dump profiling information to a log file by calling printProfiler (or modify the rpc method to return it to the caller) and get such output:It may not be very useful for short scripts but helps to optimize server-type processes especially given the printProfiler method can be called multiple times over time to profile and compare e.g. different program usage scenarios. 
Ever want to know what the hell that python script is doing? Enter the  Inspect Shell. Inspect Shell lets you print/alter globals and run  functions without interrupting the running script. Now with  auto-complete and command history (only on linux).Inspect Shell is not a pdb-style debugger.https://github.com/amoffat/Inspect-ShellYou could use that (and your wristwatch).
To add on to https://stackoverflow.com/a/582337/1070617,I wrote this module that allows you to use cProfile and view its output easily. More here: https://github.com/ymichael/cprofilevAlso see: http://ymichael.com/2014/03/08/profiling-python-with-cprofile.html on how to make sense of the collected statistics.
A new tool to handle profiling in Python is PyVmMonitor: http://www.pyvmmonitor.com/It has some unique features such asAttach profiler to a running (CPython) programOn demand profiling with Yappi integrationProfile on a different machineMultiple processes support (multiprocessing, django...)Live sampling/CPU view (with time range selection)Deterministic profiling through cProfile/profile integrationAnalyze existing PStats resultsOpen DOT filesProgramatic API accessGroup samples by method or linePyDev integrationPyCharm integrationNote: it's commercial, but free for open source.
It would depend on what you want to see out of profiling. Simple time metrics can be given by (bash). Even '/usr/bin/time' can output detailed metrics by using '--verbose' flag.To check time metrics given by each function and to better understand how much time is spent on functions, you can use the inbuilt cProfile in python. Going into more detailed metrics like performance, time is not the only metric. You can worry about memory, threads etc.Profiling options:1. line_profiler is another profiler used commonly to find out timing metrics line-by-line.2. memory_profiler is a tool to profile memory usage.3. heapy (from project Guppy) Profile how objects in the heap are used. These are some of the common ones I tend to use. But if you want to find out more, try reading this bookIt is a pretty good book on starting out with performance in mind. You can move onto advanced topics on using Cython and JIT(Just-in-time) compiled python. 
There's also a statistical profiler called statprof. It's a sampling profiler, so it adds minimal overhead to your code and gives line-based (not just function-based) timings. It's more suited to soft real-time applications like games, but may be have less precision than cProfile.The version in pypi is a bit old, so can install it with pip by specifying the git repository:You can run it like this:See also https://stackoverflow.com/a/10333592/320036
When i'm not root on the server, I use lsprofcalltree.py and run my program like this:Then I can open the report with any callgrind-compatible software, like qcachegrind


Answer URL
https://docs.python.org/3/library/profile.html#module-cProfile
