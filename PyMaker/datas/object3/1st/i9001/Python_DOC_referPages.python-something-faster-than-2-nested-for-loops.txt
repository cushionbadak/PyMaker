Natural Text
I'm trying to improve on the idea of the above code.  It works, but if personlist becomes very large (say millions) I feel there must be something faster than 2 for loops.What the code is doing is taking a list of dictionaries and running a fancy fuzzy matching function on the values of each dictionary against each other dictionary.  So it's not as simple as just comparing all the dictionaries to the other ones.  I'd like a way to run a function on each dictionary, maybe 2 for loops is the right way to do this?  Any suggestions would be helpful!
You can use itertools.combinations which is essentially the same double loop but it iterates faster because it's written in C (that only reduces the constant factor, you still have the O(n**2) runtime behaviour) and you don't need the if person1['pid'] >= person2['pid']: continue anymore (that's built into the combinations function already).which prints:However if your fancymatching allows it then you could also group (O(n) runtime) your values. For example in your case you only match identical 'fname'-values.But that's only possible if your fancymatching allows such a grouping. Which is True for your case but if it's more complicated it might not be.
Adding to MSeifert's answer, if your matching depends on fname1 == fname2 then you can sort and then group your list: ie:Obviously if you change your matching function you will need to change your key function so that it returns the same value for any elements that match and returns a different value for any elements that don't. This does rely on the fact that such a key function exists, which will not always be the case for an arbitrary matching function.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.combinations
