Natural Text
I'm trying to do the following expression with dict comprehension and a ternary operation in python:I tried this:and several permutations thereof, but I keep getting syntax errors. Is it possible to do what I want?UPDATEThis is the correct syntax, but not my dict only comes back with 1's:seen_dict = { num: (seen_dict[num] + 1) if num in seen_dict else 1 for num in ar }Can someone explain why this doesn't function the same way as the for loop? Thank you.
Don't. It seems like using dict comprehensions for this should be a good idea, but it's actually a horrible trap. Use collections.Counter:or if you don't want to do that, then stick with the loop.The problem with trying to use a dict comprehension is that a dict comprehension has no good way to maintain state or interleave the computation of the values of each key. Each value must be computed in a single expression. In contrast, the best way to solve your counting problem is to make a single pass over ar and update each element's count as you go.The restrictions of a comprehension lead to horribly inefficient attempts likewhich makes a number of passes over ar equal to the length of ar, or the slightly more efficient but still horribly suboptimalwhich only needs to make len(set(ar)) passes, or for people a bit more familiar with the standard library,which at least isn't quadratic time, but is still O(nlogn) for a length-n ar.If we run a timing of these four snippets with input list(range(10000)):We get the following output:Counter finishes in half a millisecond, while the count snippets both take over a second. (The set version seems to have a lower runtime due to some sort of first-run effect slowing down the other version; swapping the order of the set and non-set version usually reverses the relative timing of those versions. The deduplication of set doesn't help in this test, since the input has no duplicates.)For a longer input, relying on count would be even more prohibitively expensive. Relying on count could easily take days for an input that Counter would still finish in under a second.
Here, it was actually way simpler than I thought. Basically what you want is the amount of times something occurs in the list, which you can do by saying ar.count(num). You can easily do this without ternary operators like so: 
It seems like you're trying to get the appearances of all values in a list. (If it's not, please let me know.) Here's how I would approach that:An explanation:arr.count(num): the list.count(element) method returns the number of appearances of element in listset(arr): creates a set object, which when converted back to a list removes all duplicates, or in other words, gets all distinct values of a listlist(set(arr)): the distinct values in arrThe dictionary return would have key-value pairs of number-# of appearances of number in arr.


Answer URL
https://docs.python.org/3/library/collections.html#collections.Counter
https://docs.python.org/3/library/itertools.html#itertools.groupby
