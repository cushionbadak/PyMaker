Natural Text
I have a class which represents a mathematical model. Within this class, I have methods to solve the model, methods to print the results, etc.The model can be solved for different functions. I am wondering what is the best way to pass a method when I initialize a python object.To give an example, suppose I had the class Foo and the method f1. My goal is that instead of being defined inside the class definition, f1 would be passed as a parameter.So, I know I can do this:But is there a way to do this:The last code example does not work. The error is: missing 1 required positional argument: 'self'
Yes, you can do that, because methods are just bound functions.When you look up a method on an instance (such as bar.f1, note, no call yet) and Python finds a function by the name f1 on the class (not the instance itself), then the function is bound, resulting in a method object. Python uses the __get__ method for this; functions define that method, and calling it with the right arguments produces a method.When you store a function on an instance however, that doesn't happen. It's already part of an instance, it doesn't need to be bound, right? So when you use self.f1 = f1, no binding takes place. Calling bar.f1() will then fail to pass in self so you get an error.But nothing stops you from binding the function yourself:Now bar.f1() works, because f1 has been bound to bar:There are other ways of achieving the same thing; you could store a function created with lambda to explicitly pass in self:or you could use a functools.partial() object to have it pass in self:or you could create a method instance from by using the type object for methods directly; there is a reference to the type via typing.MethodType:but that last one is going to achieve the exact same thing as f1.__get__(self).If you want to dive into the deep end and learn more about binding, then you want to read the descriptor HOWTO.
You hopefully have better names in production code. Also, it'd probably make more sense to pass "x1" to the call, not to the initializer.You can make your second thing work if you pass self to the callable as in self.f1(self) (again, design wise that'd be possibly on the smelly side).For a better overall structure, look into the "template method" design pattern.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__get__
https://docs.python.org/3/library/functools.html#functools.partial
https://docs.python.org/3/library/types.html#types.MethodType
https://docs.python.org/3/howto/descriptor.html
