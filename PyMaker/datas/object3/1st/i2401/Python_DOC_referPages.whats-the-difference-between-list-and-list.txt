Natural Text
This is a question rotating a matrix 90 degrees clockwise, i don't understand why i cannot use:but:
In Python, all assignments bind a reference to a name. Operators call a method of an existing reference1. In your case, the statementis purely an assignment2. It computes the right hand side, and binds it to the name matrix in the local function scope. Whatever object matrix referred to when you passed it in remains untouched.This is why you don't see the changes you made. It's not that the function doesn't work this way, it's that it doesn't do anything with the rotated list. The data is discarded as soon as the function exits.The operationon the other hand is not an assignment in the semantic sense, despite the = symbol3. It's a call to matrix.__setitem__(...)4. The__setitem__ method, like any other method, operates directly on the object without changing it's name bindings.As far as indexing goes, [:] is equivalent to [::]. They are shorthand for [0:len(matrix)] and [0:len(matrix):1], respectively. In both cases, the default step size will be used. In general, any index with colons in it will be converted to a slice object. Missing elements are set to None and replaced by the sequence-specific defaults shown here.1 Some operators, like += perform an assignment after calling a method. These are called augmented assignments. But that's not a case we're interested in right now.2 Besides literal assignment statements (=), some other types of assignments are def (which binds a function object to its name), class (which does the same for a class object), import (which binds a module or element of a module to a name), passing arguments to a function (which binds objects to the local argument names or kwarg dictionary keys), and for (which binds an element from an iterator to the loop variable at each iteration).3 It's still an assignment from the point of view of the parser, but the statement is handled completely differently. A similar statement that is not actually an assignment is using the = operator on an attribute implemented as a descriptor, such as a property.4 Technically, it's more of an equivalent to type(matrix).__setitem__(matrix, ...), but with some additional optimizations. For example, the metaclass of type(matrix) won't ever be searched.
matrix in your method is a reference to a matrix object.  Assignment to matrix will change matrix to reference your newly created object, but not change the contents of the original object.  matrix[::] = invokes __setitem__ on the object referenced by matrix which changes the contents of the object accordingly.


Answer URL
https://docs.python.org/3/library/functions.html#slice
https://docs.python.org/3/reference/simple_stmts.html#augmented-assignment-statements
https://docs.python.org/3/reference/simple_stmts.html#assignment-statements
https://docs.python.org/3/reference/simple_stmts.html#assignment-statements
