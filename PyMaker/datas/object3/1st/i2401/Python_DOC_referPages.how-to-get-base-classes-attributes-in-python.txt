Natural Text
So I'm writing an interface framework that allow people to write a collection of commands. What I am trying to do here is that, for each subclass of Base, find all of its methods that has a description, then collect all those functions and generate a collective description out of them (plus something else, but its not relevant to this question)Here is MCVENow the problem with my current method is that it doesn't detect method overrides. Suppose I add this snippet into the definition of class BNow the generated descriptions will be completely wrong. What I want is that when a method got overridden, it's collected description also got overridden. So the description should always point to the method that Python would normally resolve to if people do it with usual ways (e.g. B.a.description)So the expected output would then change to I suppose I can make a special case out of word descriptions and fix the first description method. But is there a more elegant and Pythonic way to achieve that? To be honest, self.__class__.__mro__ looks pretty horrible. 
When you iterate over self.__class__.__mro__, you are iterating over the resolution order, which would be <class '__main__.B'> <class '__main__.A'> <class '__main__.Base'> <class 'object'> in your example.As a result, you are looking at the description properties of each of these classes subsequently. When you declare a.description = 'B.a' inside class B, you are not actually overriding it in the parent class A, you are just overriding it in the child class B.So, instead, you could do something like this:That way, you are only inspecting the actual child and not its parents. However, Base.descriptions cannot be a property in this case, because properties get evaluated upon declaration, which would make inspect.getmembers keep inspecting itself infinitely long.
I think you can fix your first implementation of descriptions, which may be easier than messing with the MRO. The reason you are getting a RecursionError is that "descriptions" will show up in the list of attribute names. When you do getattr(self, name) on it, it recursively calls itself, since it's a property. You can easily avoid that by only looking up the name if it is not "descriptions". You also have an issue that when you lookup a method by name on an instance, you'll get a bound method object, rather than a function. Perhaps you should be calling getattr on type(self) instead of on self? That would look something like this:Another way to avoid the issue would be to get rid of the property decorator, and leave descriptions as a normal method. That way looking it up won't cause any recursion, it will just get a bound method.
We're not quite sure exactly what behavior you would like to have happen, but the inspect module almost certainly has what you need. E.g.


Answer URL
https://docs.python.org/3/library/stdtypes.html#class.__mro__
https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers
