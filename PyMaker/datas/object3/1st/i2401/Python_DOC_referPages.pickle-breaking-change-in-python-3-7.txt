Natural Text
I have custom list and dictionary classes that no longer work while unpickling in Python 3.7. Works fine on Python 2.6 through 3.6: But is no longer setting the self.option properly in 3.7.If I were to remove the extend function, it works as expected though.I have tried adding __setstate__ as well, but it is not called before extend so the option is still undefined at that point. I do have to inherit directly from dict and list, and I do need to overwrite both the append and extend function in my code. Is there a way to set option beforehand or another fix?  Is this change in behavior documented and the rational for it? Thank you for your time
Unpickling list objects switched from using list.update() to list.extend(), because that can be way faster for some list subclasses.However, with that change, the way that the unpickling code tested for list objects also changed, fromto It is that change that affects your code. The above test looks for a fast path, saying if we have a list class, then use PyList_SetSlice() to load the data, rather than a slower path of explicitly calling either the .extend() or .append() method on the new instance. The old version (Python 3.6 and older) accepted lists and subclasses, the new version only accepts list itself, not subclasses!So for Python 3.6 and older, when unpickling your custom MyList.append() method is not called. In Python 3.7, when unpickling your custom MyList.extend() method is called. This is very much intentional, subclasses should be allowed to provide a custom .extend() method that gets to be called when unpickling.And the work-around is simple. Your data is already wrapped when unpickling, you don't need to re-apply that wrapper. When you do not have self.option set, simply skip applying it:This all does mean you can't rely on any instance attributes having been restored yet. If that's a big problem (you still need to consult instance state while unpickling), then you'll have to provide a different __reduce_ex__ method, one that doesn't return the data as an iterator in index 3 of the resulting tuple. list().__reduce_ex__() for protocol versions 2, 3 and 4 returns (copyreg.__newobj__, type(self), self.__dict__, iter(self), None).A custom version would have to use (type(self), (tuple(self), self.option), None, None, None), for example. That does come with some additional overhead (that tuple(self) there will take additional memory when pickling and unpickling).


Answer URL
https://docs.python.org/3/library/pickle.html#object.__reduce_ex__
