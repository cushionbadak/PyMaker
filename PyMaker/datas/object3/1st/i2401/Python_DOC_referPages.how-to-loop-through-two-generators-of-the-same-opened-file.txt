Natural Text
I have a medium-size file (25MB, 1000000 rows), and I want to read every row except every third row.FIRST QUESTION: Is it faster to load the whole file into memory and then read the rows (method .read()), or load and read one row at the time (method .readline())?Since I'm not an experienced coder I tried the second option with islice method from itertools module.Although looping through single generator (inp_atomtype or inp_atomdata) prints correct data, looping through both of them simultaneously (as in this code) prints wrong data.SECOND QUESTION: How can I reach desired rows using generators?
yield is perfect for this.This functions yields pairs from an iterable and skip every third item:You will lose half pairs, which means that two_thirds(range(2)) will stop iterating immediately.https://repl.it/repls/DullNecessaryCronYou can also use the grouper recipe from itertools doc and ignore the third item in each tuple generated:
You don't need to slice the iterator, a simple line counter should be enough:As for turning it into a generator, just yield the line instead of printing. When it comes to speed, given that you'll be reading your lines anyway the I/O part will probably take the same but you might benefit a bit (in total processing time) from fast list slicing instead of counting lines if you have enough working memory to keep the file contents and if loading the whole file upfront instead of streaming is acceptable.
FIRST QUESTION: I am pretty sure that .readline() is faster than .read(). Plus, the fastest way based my test is to do lopping like: SECOND QUESTION: I am not quite sure abut this. you may consider to use yield. There is a code snippet you may refer:
q2: here's my generator:sample.txt was generated with a bash shell (it's just lines counting to 100)regarding q1: if you're reading the file multiple times, you'd be better off to have it in memory. otherwise you're fine reading it line by line.Regarding the problem you're having with the wrong results:both itertools.islice(inp, 0, 40, 3) statements will use inp as generator. Both will call next(inp), to provide you with a value.Each time you call next() on an iterator, it will change its state, so that's where your problems come from.
You can use a generator expression:enumerate adds line numbers to each line, and the if clause ignores line numbers divisible by 3 (default numbering starts at 0, so you have to specify start=1 to get the desired pattern).Keep in mind that you can only use the generator while the file is still open.


Answer URL
https://docs.python.org/3/library/itertools.html
