Natural Text
People including me know there is something in Python called __future__ and it appears in quite a few modules I read. And the dull people like me don't know why it's there, and how/when to use it , even after reading the Python's __future__ doc. So any explains with examples to demonstrate it?I have got a few answers quickly, which look all correct, in terms of the basic usage.However and also for further understanding how __future__ works:I just realized one key thing that was confusing me when I tried to understand it, that is, how a current python release include something that will be released in future release?and how can a program using a new feature in a future python release be compiled successfully by the current python release?So, I guess now that, the current release has already packaged some potential features that will be included in future releases - is this right? but the features are available only by __future__, that is because it doesn't become standard yet - am I right?
With __future__ module's inclusion, you can slowly be accustomed to incompatible changes or to such ones introducing new keywords.E.g., for using context managers, you had to do from __future__ import with_statement in 2.5, as the with keyword was new and shouldn't be used as variable names any longer. In order to be able to use a program which uses variables named with, the above import statement is needed.Another example isWithout the __future__ stuff, both print statements would print 1.The internal difference is that without that import, / is mapped to the __div__() method, while with it, __truediv__() is used. (In any case, // calls __floordiv__().)A propos print: print becomes a function in 3.x, losing its special property as a keyword. So it is the other way round.
When you doYou're not actually using an import statement, but a future statement. You're reading the wrong docs, as you're not actually importing that module.Future statements are special -- they change how your Python module is parsed, which is why they must be at the top of the file. They give new -- or different -- meaning to words or symbols in your file. From the docs:A future statement is a directive to the compiler that a particular module should be compiled using syntax or semantics that will be available in a specified future release of Python. The future statement is intended to ease migration to future versions of Python that introduce incompatible changes to the language. It allows use of the new features on a per-module basis before the release in which the feature becomes standard.If you actually want to import the __future__ module, just doand then access it as usual.
__future__ is a pseudo-module which programmers can use to enable new language features which are not compatible with the current interpreter. For example, the expression 11/4 currently evaluates to 2. If the module in which it is executed had enabled true division by executing:from __future__ import divisionthe expression 11/4 would evaluate to 2.75. By importing the __future__ module and evaluating its variables, you can see when a new feature was first added to the language and when it will become the default:
It can be used to use features which will appear in newer versions while having an older release of Python.For examplewill allow you to use print as a function:
Or is it like saying "Since this is python v2.7, use that different 'print' function that has also been added to python v2.7, after it was added in python 3. So my 'print' will no longer be statements (eg print "message" ) but functions (eg, print("message", options). That way when my code is run in python 3, 'print' will not break."In print_function is the module containing the new implementation of 'print' as per how it is behaving in python v3.This has more explanation: http://python3porting.com/noconv.html
There are some great answers already, but none of them address a complete list of what the __future__ statement currently supports.Put simply, the __future__ statement forces Python interpreters to use newer features of the language. The features that it currently supports are the following:nested_scopes:Prior to Python 2.1, the following code would raise a NameError:The from __future__ import nested_scopes directive will allow for this feature to be enabled.generators:Introduced generator functions such as the one below to save state between successive function calls:division:Classic division is used in Python 2.x versions. Meaning that some division statements return a reasonable approximation of division ("true division") and others return the floor ("floor division"). Starting in Python 3.0, true division is specified by x/y, whereas floor division is specified by x//y. The from __future__ import division directive forces the use of Python 3.0 style division.absolute_import:Allows for parenthesis to enclose multiple import statements. For example:Instead of:Or:with_statement:Adds the statement "with" as a keyword in Python to eliminate the need for try/finally statements. Common uses of this are when doing file I/O such as:print_function:Forces the use of Python 3 parenthesis-style print function call instead of the print MESSAGE style print statement.unicode_literals:Introduces the literal syntax for the bytes object. Meaning that statements such as bytes('Hello world', 'ascii') can be simply expressed as b'Hello world'.generator_stop:Replaces the use of the StopIteration exception used inside generator functions with the RuntimeError exception.One other use not mentioned above is that the __future__ statement also forces the use of Python 2.1+ interpreters since using an older version will throw a runtime exception.References:https://docs.python.org/2/library/future.htmlhttps://docs.python.org/3/library/future.htmlhttps://docs.python.org/2.2/whatsnew/node9.htmlhttps://www.python.org/dev/peps/pep-0255/https://www.python.org/dev/peps/pep-0238/https://www.python.org/dev/peps/pep-0328/https://www.python.org/dev/peps/pep-3112/https://www.python.org/dev/peps/pep-0479/
One of the uses which I found to be very useful is the print_function from __future__ module.In Python 2.7, I wanted chars from different print statements to be printed on same line without spaces.It can be done using a comma(",") at the end, but it also appends an extra space.The above statement when used as : This will print the value of v_num from each iteration in a single line without spaces.
After Python 3.0 onward, print is no longer just a statement, its a function instead. and is included in PEP 3105. Also I think the Python 3.0 package has still these special functionality. Lets see its usability through a traditional "Pyramid program" in Python:If we use normal print function, we won't be able to achieve the same output, since print() comes with a extra newline. So every time the inner for loop execute, it will print * onto the next line.


Answer URL
https://docs.python.org/3/library/__future__.html
