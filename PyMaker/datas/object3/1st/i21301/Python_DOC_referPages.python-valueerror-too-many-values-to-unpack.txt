Natural Text
This question already has an answer here:'too many values to unpack', iterating over a dict. key=>string, value=>list                    8 answers                I am getting that exception from this code:The for line is the one throwing the exception. The ms are Material objects. Anybody have any ideas why?
self.materials is a dict and by default you are iterating over just the keys (which are strings).Since self.materials has more than two keys*, they can't be unpacked into the tuple "k, m", hence the ValueError exception is raised.In Python 2.x, to iterate over the keys and the values (the tuple "k, m"), we use self.materials.iteritems().However, since you're throwing the key away anyway, you may as well simply iterate over the dictionary's values:In Python 3.x, prefer dict.values() (which returns a dictionary view object):
example:
Iterating over a dictionary object itself actually gives you an iterator over its keys. Python is trying to unpack keys, which you get from m.type + m.purity into (m, k).My crystal ball says m.type and m.purity are both strings, so your keys are also strings. Strings are iterable, so they can be unpacked; but iterating over the string gives you an iterator over its characters. So whenever m.type + m.purity is more than two characters long, you have too many values to unpack. (And whenever it's shorter, you have too few values to unpack.)To fix this, you can iterate explicitly over the items of the dict, which are the (key, value) pairs that you seem to be expecting. But if you only want the values, then just use the values.(In 2.x, itervalues, iterkeys, and iteritems are typically a better idea; the non-iter versions create a new list object containing the values/keys/items. For large dictionaries and trivial tasks within the iteration, this can be a lot slower than the iter versions which just set up an iterator.)


Answer URL
