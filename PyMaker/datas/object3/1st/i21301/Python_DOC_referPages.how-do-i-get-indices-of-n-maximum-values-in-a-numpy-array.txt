Natural Text
NumPy proposes a way to get the index of the maximum value of an array via np.argmax.I would like a similar thing, but returning the indexes of the N maximum values.For instance, if I have an array, [1, 3, 2, 4, 5], function(array, n=3) would return the indices [4, 3, 1] which correspond to the elements [5, 4, 3].
The simplest I've been able to come up with is:This involves a complete sort of the array. I wonder if numpy provides a built-in way to do a partial sort; so far I haven't been able to find one.If this solution turns out to be too slow (especially for small n), it may be worth looking at coding something up in Cython.
Newer NumPy versions (1.8 and up) have a function called argpartition for this. To get the indices of the four largest elements, doUnlike argsort, this function runs in linear time in the worst case, but the returned indices are not sorted, as can be seen from the result of evaluating a[ind]. If you need that too, sort them afterwards:To get the top-k elements in sorted order in this way takes O(n + k log k) time.
Simpler yet:where n is the number of maximum values.
Use:For regular Python lists:If you use Python 2, use xrange instead of range.Source: heapq â€” Heap queue algorithm
If you happen to be working with a multidimensional array then you'll need to flatten and unravel the indices:For example:
If you don't care about the order of the K-th largest elements you can use argpartition, which should perform better than a full sort through argsort.Credits go to this question.I ran a few tests and it looks like argpartition outperforms argsort as the size of the array and the value of K increase.
For multidimensional arrays you can use the axis keyword in order to apply the partitioning along the expected axis.And for grabbing the items:But note that this won't return a sorted result. In that case you can use np.argsort() along the intended axis:Here is an example:
This will be faster than a full sort depending on the size of your original array and the size of your selection:It, of course, involves tampering with your original array.  Which you could fix (if needed) by making a copy or replacing back the original values.  ...whichever is cheaper for your use case.
bottleneck has a partial sort function, if the expense of sorting the entire array just to get the N largest values is too great.I know nothing about this module; I just googled numpy partial sort.
Use:Now the result list would contain N tuples (index, value) where value is maximized.
Method np.argpartition only returns the k largest indices, performs a local sort, and is faster than np.argsort(performing a full sort) when array is quite large. But the returned indices are NOT in ascending/descending order. Let's say with an example:We can see that if you want a strict ascending order top k indices, np.argpartition won't return what you want.Apart from doing a sort manually after np.argpartition, my solution is to use PyTorch, torch.topk, a tool for neural network construction, providing NumPy-like APIs with both CPU and GPU support. It's as fast as NumPy with MKL, and offers a GPU boost if you need large matrix/vector calculations.Strict ascend/descend top k indices code will be:Note that torch.topk accepts a torch tensor, and returns both top k values and top k indices in type torch.Tensor. Similar with np, torch.topk also accepts an axis argument so that you can handle multi-dimensional arrays/tensors.
Use:It also works with 2D arrays. For example,
The following is a very easy way to see the maximum elements and its positions. Here axis is the domain; axis = 0 means column wise maximum number and axis = 1 means row wise max number for the 2D case. And for higher dimensions it depends upon you.
I found it most intuitive to use np.unique. The idea is, that the unique method returns the indices of the input values. Then from the max unique value and the indicies, the position of the original values can be recreated.
I think the most time efficiency way is manually iterate through the array and keep a k-size min-heap, as other people have mentioned.And I also come up with a brute force approach:Set the largest element to a large negative value after you use argmax to get its index. And then the next call of argmax will return the second largest element.And you can log the original value of these elements and recover them if you want.


Answer URL
