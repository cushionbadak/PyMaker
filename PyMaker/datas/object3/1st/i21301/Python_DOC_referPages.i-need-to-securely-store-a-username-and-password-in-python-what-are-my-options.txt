Natural Text
I'm writing a small Python script which will periodically pull information from a 3rd party service using a username and password combo. I don't need to create something that is 100% bulletproof (does 100% even exist?), but I would like to involve a good measure of security so at the very least it would take a long time for someone to break it. This script won't have a GUI and will be run periodically by cron, so entering a password each time it's run to decrypt things won't really work, and I'll have to store the username and password in either an encrypted file or encrypted in a SQLite database, which would be preferable as I'll be using SQLite anyway, and I might need to edit the password at some point. In addition, I'll probably be wrapping the whole program in an EXE, as it's exclusively for Windows at this point. How can I securely store the username and password combo to be used periodically via a cron job?
I recommend a strategy similar to ssh-agent.  If you can't use ssh-agent directly you could implement something like it, so that your password is only kept in RAM.  The cron job could have configured credentials to get the actual password from the agent each time it runs, use it once, and de-reference it immediately using the del statement.The administrator still has to enter the password to start ssh-agent, at boot-time or whatever, but this is a reasonable compromise that avoids having a plain-text password stored anywhere on disk.
The python keyring library integrates with the CryptProtectData API on Windows (along with relevant API's on Mac and Linux) which encrypts data with the user's logon credentials.Simple usage:Usage if you want to store the username on the keyring:Later to get your info from the keyringItems are encrypted with the user's operating system credentials, thus other applications running in your user account would be able to access the password.  To obscure that vulnerability a bit you could encrypt/obfuscate the password in some manner before storing it on the keyring.  Of course, anyone who was targeting your script would just be able to look at the source and figure out how to unencrypt/unobfuscate the password, but you'd at least prevent some application vacuuming up all passwords in the vault and getting yours as well.
After looking though the answers to this and related questions, I've put together some code using a few of the suggested methods for encrypting and obscuring secret data. This code is specifically for when the script has to run without user intervention (if the user starts it manually, it's best to have them put in the password and only keep it in memory as the answer to this question suggests). This method isn't super-secure; fundamentally, the script can access the secret info so anyone who has full system access has the script and its associated files and can access them. What this does do id obscures the data from casual inspection and leaves the data files themselves secure if they are examined individually, or together without the script.My motivation for this is a project that polls some of my bank accounts to monitor transactions - I need it to run in the background without me re-entering passwords every minute or two.Just paste this code at the top of your script, change the saltSeed and then use store() retrieve() and require() in your code as needed:The security of this method would be significantly improved if os permissions were set on the secret files to only allow the script itself to read them, and if the script itself was compiled and marked as executable only (not readable). Some of that could be automated, but I haven't bothered. It would probably require setting up a user for the script and running the script as that user (and setting ownership of the script's files to that user).I'd love any suggestions, criticisms or other points of vulnerability that anyone can think of. I'm pretty new to writing crypto code so what I've done could almost certainly be improved.
I think the best you can do is protect the script file and system it's running on.Basically do the following:Use file system permissions (chmod 400)Strong password for owner's account on the systemReduce ability for system to be compromised (firewall, disable unneeded services, etc)Remove administrative/root/sudo privileges for those that do not need it
There's not much point trying to encrypt the password: the person you're trying to hide it from has the Python script, which will have the code to decrypt it.  The fastest way to get the password will be to add a print statement to the Python script just before it uses the password with the third-party service.So store the password as a string in the script, and base64 encode it so that just reading the file isn't enough, then call it a day.
There are a few options for storing passwords and other secrets that a Python program needs to use, particularly a program that needs to run in the background where it can't just ask the user to type in the password.Problems to avoid:Checking the password in to source control where other developers or even the public can see it.Other users on the same server reading the password from a configuration file or source code.Having the password in a source file where others can see it over your shoulder while you are editing it.Option 1: SSHThis isn't always an option, but it's probably the best. Your private key is never transmitted over the network, SSH just runs mathematical calculations to prove that you have the right key.In order to make it work, you need the following:The database or whatever you are accessing needs to be accessible by SSH. Try searching for "SSH" plus whatever service you are accessing. For example, "ssh postgresql". If this isn't a feature on your database, move on to the next option.Create an account to run the service that will make calls to the database, and generate an SSH key.Either add the public key to the service you're going to call, or create a local account on that server, and install the public key there.Option 2: Environment VariablesThis one is the simplest, so it might be a good place to start. It's described well in the Twelve Factor App. The basic idea is that your source code just pulls the password or other secrets from environment variables, and then you configure those environment variables on each system where you run the program. It might also be a nice touch if you use default values that will work for most developers. You have to balance that against making your software "secure by default".Here's an example that pulls the server, user name, and password from environment variables.Look up how to set environment variables in your operating system, and consider running the service under its own account. That way you don't have sensitive data in environment variables when you run programs in your own account. When you do set up those environment variables, take extra care that other users can't read them. Check file permissions, for example. Of course any users with root permission will be able to read them, but that can't be helped.Option 3: Configuration FilesThis is very similar to the environment variables, but you read the secrets from a text file. I still find the environment variables more flexible for things like deployment tools and continuous integration servers. If you decide to use a configuration file, Python supports several formats in the standard library, like JSON, INI, netrc, and XML. You can also find external packages like PyYAML and TOML. Personally, I find JSON and YAML the simplest to use, and YAML allows comments.Three things to consider with configuration files:Where is the file? Maybe a default location like ~/.my_app, and a command-line option to use a different location.Make sure other users can't read the file.Obviously, don't commit the configuration file to source code. You might want to commit a template that users can copy to their home directory.Option 4: Python ModuleSome projects just put their secrets right into a Python module.Then import that module to get the values.One project that uses this technique is Django. Obviously, you shouldn't commit settings.py to source control, although you might want to commit a file called settings_template.py that users can copy and modify.I see a few problems with this technique:Developers might accidentally commit the file to source control. Adding it to .gitignore reduces that risk.Some of your code is not under source control. If you're disciplined and only put strings and numbers in here, that won't be a problem. If you start writing logging filter classes in here, stop!If your project already uses this technique, it's easy to transition to environment variables. Just move all the setting values to environment variables, and change the Python module to read from those environment variables.
operating systems often have support for securing data for the user.  in the case of windows it looks like it's http://msdn.microsoft.com/en-us/library/aa380261.aspxyou can call win32 apis from python using http://vermeulen.ca/python-win32api.htmlas far as i understand, this will store the data so that it can be accessed only from the account used to store it.  if you want to edit the data you can do so by writing code to extract, change and save the value.
I used Cryptography because I had troubles installing (compiling) other commonly mentioned libraries on my system. (Win7 x64, Python 3.5)My script is running in a physically secure system/room. I encrypt credentials with an "encrypter script" to a config file. And then decrypt when I need to use them."Encrypter script" is not on the real system, only encrypted config file is. Someone who analyses the code can easily break the encryption by analysing the code, but you can still compile it into an EXE if necessary.


Answer URL
https://docs.python.org/3/library/json.html
https://docs.python.org/3/library/configparser.html
https://docs.python.org/3/library/netrc.html
https://docs.python.org/3/library/xml.etree.elementtree.html
