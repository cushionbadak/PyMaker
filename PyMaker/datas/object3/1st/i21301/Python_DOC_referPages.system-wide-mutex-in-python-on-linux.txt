Natural Text
Is there any easy way to have a system-wide mutex in Python on Linux? By "system-wide", I mean the mutex will be used by a group of Python processes; this is in contrast to a traditional mutex, which is used by a group of threads within the same process.EDIT: I'm not sure Python's multiprocessing package is what I need. For example, I can execute the following in two different interpreters:When I execute these commands simultaneously in two separate interpreters, I want one of them to hang. Instead, neither hangs; it appears they aren't acquiring the same mutex.
The "traditional" Unix answer is to use file locks. You can use lockf(3) to lock sections of a file so that other processes can't edit it; a very common abuse is to use this as a mutex between processes. The python equivalent is fcntl.lockf. Traditionally you write the PID of the locking process into the lock file, so that deadlocks due to processes dying while holding the lock are identifiable and fixable.This gets you what you want, since your lock is in a global namespace (the filesystem) and accessible to all processes. This approach also has the perk that non-Python programs can participate in your locking. The downside is that you need a place for this lock file to live; also, some filesystems don't actually lock correctly, so there's a risk that it will silently fail to achieve exclusion. You win some, you lose some.
The POSIX standard specifies inter-process semaphores which can be used for this purpose.  http://linux.die.net/man/7/sem_overviewThe multiprocessing module in Python is built on this API and others.  In particular, multiprocessing.Lock provides a cross-process "mutex".  http://docs.python.org/library/multiprocessing.html#synchronization-between-processesEDIT to respond to edited question:In your proof of concept each process is constructing a Lock().  So you have two separate locks.  That is why neither process waits.  You will need to share the same lock between processes.  The section I linked to in the multiprocessing documentation explains how to do that.
Try ilock library:
For a system-wide mutex that enables the synchronization of absolutely separate processes (i.e., to INCLUDE Linux processes that do NOT belong to the same processes tree), simply use fcntl.flock. I suppose that using a memory file under Linux' /run/shm folder may make it perform faster.See more here.


Answer URL
https://docs.python.org/3/library/fcntl.html#fcntl.lockf
https://docs.python.org/3/library/fcntl.html
