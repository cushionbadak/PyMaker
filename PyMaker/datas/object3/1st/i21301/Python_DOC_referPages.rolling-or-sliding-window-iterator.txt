Natural Text
I need a rolling window (aka sliding window) iterable over a sequence/iterator/generator.  Default Python iteration can be considered a special case, where the window length is 1.  I'm currently using the following code.  Does anyone have a more Pythonic, less verbose, or more efficient method for doing this?
There's one in an old version of the Python docs with itertools examples:The one from the docs is a little more succinct and uses itertools to greater effect I imagine.
This seems tailor-made for a collections.deque since you essentially have a FIFO (add to one end, remove from the other). However, even if you use a list you shouldn't be slicing twice; instead, you should probably just pop(0) from the list and append() the new item.Here is an optimized deque-based implementation patterned after your original:In my tests it handily beats everything else posted here most of the time, though pillmuncher's tee version beats it for large iterables and small windows. On larger windows, the deque pulls ahead again in raw speed.Access to individual items in the deque may be faster or slower than with lists or tuples. (Items near the beginning are faster, or items near the end if you use a negative index.) I put a sum(w) in the body of my loop; this plays to the deque's strength (iterating from one item to the next is fast, so this loop ran a a full 20% faster than the next fastest method, pillmuncher's).  When I changed it to individually look up and add items in a window of ten, the tables turned and the tee method was 20% faster. I was able to recover some speed by using negative indexes for the last five terms in the addition, but tee was still a little faster. Overall I would estimate that either one is plenty fast for most uses and if you need a little more performance, profile and pick the one that works best.
I like tee():gives:
Here's a generalization that adds support for step, fillvalue parameters:It yields in chunks size items at a time rolling step positions per iteration padding each chunk with fillvalue if necessary. Example for size=4, step=3, fillvalue='*':For an example of use case for the step parameter, see Processing a large .txt file in python efficiently.
Just a quick contribution.Since the current python docs don't have "window" in the itertool examples  (i.e., at the bottom of http://docs.python.org/library/itertools.html), here's an snippet based on the code for grouper which is one of the examples given:Basically, we create a series of sliced iterators, each with a starting point one spot further forward.  Then, we zip these together.  Note, this function returns a generator (it is not directly a generator itself).Much like the appending-element and advancing-iterator versions above, the performance (i.e., which is best) varies with list size and window size.  I like this one because it is a two-liner (it could be a one-liner, but I prefer naming concepts).It turns out that the above code is wrong.  It works if the parameter passed to iterable is a sequence but not if it is an iterator.  If it is an iterator, the same iterator is shared (but not tee'd) among the islice calls and this breaks things badly.  Here is some fixed code:Also, one more version for the books.  Instead of copying an iterator and then advancing copies many times, this version makes pairwise copies of each iterator as we move the starting position forward.  Thus, iterator t provides both the "complete" iterator with starting point at t and also the basis for creating iterator t + 1:
Just to show how you can combine itertools recipes, I'm extending the pairwise recipe as directly as possible back into the window recipe using the consume recipe:The window recipe is the same as for pairwise, it just replaces the single element "consume" on the second tee-ed iterator with progressively increasing consumes on n - 1 iterators. Using consume instead of wrapping each iterator in islice is marginally faster (for sufficiently large iterables) since you only pay the islice wrapping overhead during the consume phase, not during the process of extracting each window-ed value (so it's bounded by n, not the number of items in iterable).Performance-wise, compared to some other solutions, this is pretty good (and better than any of the other solutions I tested as it scales). Tested on Python 3.5.0, Linux x86-64, using ipython %timeit magic.kindall's the deque solution, tweaked for performance/correctness by using islice instead of a home-rolled generator expression and testing the resulting length so it doesn't yield results when the iterable is shorter than the window, as well as passing the maxlen of the deque positionally instead of by keyword (makes a surprising difference for smaller inputs):Same as previous adapted kindall solution, but with each yield win changed to yield tuple(win) so storing results from the generator works without all stored results really being a view of the most recent result (all other reasonable solutions are safe in this scenario), and adding tuple=tuple to the function definition to move use of tuple from the B in LEGB to the L:consume-based solution shown above:Same as consume, but inlining else case of consume to avoid function call and n is None test to reduce runtime, particularly for small inputs where the setup overhead is a meaningful part of the work:(Side-note: A variant on pairwise that uses tee with the default argument of 2 repeatedly to make nested tee objects, so any given iterator is only advanced once, not independently consumed an increasing number of times, similar to MrDrFenner's answer is similar to non-inlined consume and slower than the inlined consume on all tests, so I've omitted it those results for brevity).As you can see, if you don't care about the possibility of the caller needing to store results, my optimized version of kindall's solution wins most of the time, except in the "large iterable, small window size case" (where inlined consume wins); it degrades quickly as the iterable size increases, while not degrading at all as the window size increases (every other solution degrades more slowly for iterable size increases, but also degrades for window size increases). It can even be adapted for the "need tuples" case by wrapping in map(tuple, ...), which runs ever so slightly slower than putting the tupling in the function, but it's trivial (takes 1-5% longer) and lets you keep the flexibility of running faster when you can tolerate repeatedly returning the same value.If you need safety against returns being stored, inlined consume wins on all but the smallest input sizes (with non-inlined consume being slightly slower but scaling similarly). The deque & tupling based solution wins only for the smallest inputs, due to smaller setup costs, and the gain is small; it degrades badly as the iterable gets longer.For the record, the adapted version of kindall's solution that yields tuples I used was:Drop the caching of tuple in the function definition line and the use of tuple in each yield to get the faster but less safe version.
I use the following code as a simple sliding window that uses generators to drastically increase readability.  Its speed has so far been sufficient for use in bioinformatics sequence analysis in my experience.I include it here because I didn't see this method used yet.  Again, I make no claims about its compared performance.
a slightly modified version of the deque window, to make it a true rolling window. So that it starts being populated with just one element, then grows to it's maximum window size, and then shrinks as it's left edge comes near the end:this gives

There is a library which does exactly what you need:
Multiple iterators!next(it) raises StopIteration when the sequence is finished, and for some cool reason that's beyond me, the yield statement here excepts it and the function returns, ignoring the leftover values that don't form a full window.Anyway, this is the least-lines solution yet whose only requirement is that seq implement either __iter__ or __getitem__ and doesn't rely on itertools or collections besides @dansalmo's solution :)
Made this for a rolling average function
why notIt is documented in Python doc .You can easily extend it to wider window. 
"""
Let's make it lazy!

How about using the following:Output:
This is an old question but for those still interested there is a great implementation of a window slider using generators in this page (by Adrian Rosebrock). It is an implementation for OpenCV however you can easily use it for any other purpose. For the eager ones i'll paste the code here but to understand it better I recommend visiting the original page. Tip: You can check the .shape of the window when iterating the generator to discard those that do not meet your requirementsCheers
Modified DiPaolo's answer to allow arbitrary fill and variable step size


Answer URL
https://docs.python.org/3/library/itertools.html#itertools-recipes
https://docs.python.org/3/library/itertools.html
https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists
