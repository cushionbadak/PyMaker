Natural Text
Given a pair of str objects representing an ISO 8601 time and time zone:How can these 2 strings be parsed into a time (not datetime) object?Note: It's obviously possible to split the time_str by ':' and use the time constructor but then the parsing would be a little tricky to count the number of elements in the resulting list to know the resolution (minute, second, microsecond) of the str.  This is because ISO 8601 allows for different representations:Thank you in advance for your consideration and response.
A timezone without a date is meaningless, so no, you can't use both to produce a time object. While the standard library time object does support having a tzinfo attribute, the 'timezone' object is not really a timezone, but merely a time offset.A timezone is more than just an offset from UTC. Timezone offsets are date-dependent, and because such details as the Daylight Savings winter / summer time distinction is partly the result of political decisions, what dates the timezone offset changes is also dependent on the year. To be explicit, America/New_York is a timezone, not a time offset. The exact offset from UTC depends on the date; it'll be minus 4 hours in summer, 5 hours in winter!So for a timezone such as America/New_York, you need to pick a date too. If you don't care about the date, pick a fixed date so your offset is at least consistent. If you are converting a lot of time stamps, store the timezone offset once as a timedelta(), then use that timedelta to shift time() objects to the right offset.To parse just a timestring, pretend there is a date attached by using the datetime.strptime() method, then extract the time object:To update the time given a timezone, get a timezone database that supports your timezone string first; the pytz library is regularly updated.How you use it depends on what you are trying to do. If the input time is not in UTC, you can simply attach the timezone to a datetime() object with the datetime.combine()method, after which you can move it to the UTC timezone:This assumes that 'today' is good enough to determine the correct offset.If your time is a UTC timestamp, combine it with the UTC timezone, then use the pytz timezone; effectively the reverse:To store just the offset for bulk application, pass in a reference date to the timezone.utcoffset() method:after which you can add this to any datetime object as needed to move from UTC to local time, or subtract it to go from local to UTC. Note that I said datetime, as time objects also don't support timedelta arithmetic; a timedelta can be larger than the number of seconds left in the day or the number of seconds since midnight, after all, so adding or subtracting could shift days as well as the time:For completion sake, you can't pass in a pytz timezone to a time object; it just doesn't have any effect on the time. The timezone object returns None for the UTC offset in that case, because it can't give any meaningful answer without a date:So for all intents an purposes, time_with_zone is just another naive time object as the tzinfo object attached doesn't actually have any effect.Moreover, because there is no date to determine the correct timezone information, pytz selects the earliest known 'New York' timezone, and that's not exactly a recent one; look closely at that tzinfo representation:That's the timezone introduced in 1883 by the railroads; the 'modern' EST timezone was not introduced until the 20th century. This is why timezone objects are usually passed in a date when determining the offset:
The answer to "can I do this?" (with a timezone) is both yes and no. Firstly let's convert the string to a time object. As one commenter mentioned, you can do this in python 3.7 with the fromisoformat method:If you are not using 3.7, you can do this by creating a datetime and then converting to a time object:Now to deal with the timezone. As the timezone is a name, we can use the very convenient pytz module to convert it to a tzinfo object:At this point you're probably tempted to just pass it to the time constructor as the tzinfo argument, but unfortunately that does not work with pytz:Unfortunately using the tzinfo argument of the standard datetime constructors ‘’does not work’’ with pytz for many timezones.  ~ http://pytz.sourceforge.net/So we will have to use the localize method of the newly created tzinfo object. But unfortunately we will still not be able to successfully localize the time object with this timezone. The reason for this is that pytz needs to know the date in order to determine if this timezone is in daylight savings time or not. As we have not provided the date, achieving this is quite impossible and you will get odd results like:Note the -04:56 offset, which is gibberish. There are a few options for getting to what you ultimately want.One option is to assume the time is a time today:The other option is to use naive timezone offsets rather than timezone names:But I would not recommend this method as it's quite brittle and would require some intermediate steps to derive from the TZ location name that are non-trivial.
Hope it works for you,Thanks


Answer URL
https://docs.python.org/3/library/datetime.html#datetime.time
https://docs.python.org/3/library/datetime.html#datetime.datetime.combine
https://docs.python.org/3/library/datetime.html#datetime.timezone.utcoffset
https://docs.python.org/3/library/datetime.html#datetime.time.fromisoformat
