Natural Text
I've very recently started learning how to write multi-threaded programs in python and for starters, began experimenting without using queues.In the code below, loadFunction is just a sample target function for the threads. It's supposed to wait until all of the threads provided in the wait (list) argument have finished executing (and I'm trying to achieve this using join()). Then afterwards start printing out the specified number range.This is the desired behavior.In the main program, I created two threads which do not wait for any other threads to begin counting. Then I created a third thread, which is supposed to wait for the first two threads to finish executing before it begins counting.However that is not happening. On testing, I find that the three threads start executing simultaneously and the third thread does not wait for the first two to finish executing like I intended.So my question here is, what knowledge am I missing about the Thread.join() function, and what changes can I make to my code to achieve the desired result?Code:part of the result (in one run):Here are a two things that were going through my mind when I was writing this code (as quoted from the official documentation):join(timeout=None)Wait until the thread terminates. This blocks the calling   thread until the thread whose join() method is called terminates ... In reference to my example code, would the "calling thread" be whichever thread called the loadFunction function? I have a slight suspicion that this isn't the case and that the process itself called the function and not the thread hence the thread won't be the one waiting but the process waits instead. If this is the case, how would I fix it? I have a feeling that queues would be involved... if this is the reason in the first place.and:A thread can be join()ed many times.is what lead me to use join for the same thread twice.P.S. I'm learning about threading for the first time in python, but this is after learning forking processes in C, so maybe I might have gotten something confused here due to this. If the two aren't related, then I apologize, I'm under the impression that the two are similar (though clearly not the same since one splits the process but the other creates threads within the process itself).Thank you. 
would the "calling thread" be whichever thread called the loadFunction function?The calling thread is whichever thread called join. so t1.join() and t2.join() and t3.join() cause the main thread to block, and the join inside loadFunction would cause t3 to block, if map was not lazily evaluated.how would I fix it? Your joins inside loadFunction aren't executing because map does not execute any code until you iterate over it. As MaxNoe suggests, you should use an ordinary for loop instead.
if you want to wait for the two first threads to finish before starting the third, don't call start() on the third thread before join()ing the other two:


Answer URL
https://docs.python.org/3/library/threading.html
