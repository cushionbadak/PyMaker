Natural Text
I recently wrote this Python 3 code that is supposed to alternate among all iterables given to it. That is, if the function is given as arguments (first, second, third) then it yields first[0], second[0], third[0], first[1], .... If second runs out before the others, then it is skipped: second[15], third[16], first[16], third[16], ... until all iterables are exhausted.Here it is. It is functional, but it doesn't look very "pythonic". I especially don't like having to keep an array of flags that tell me if the generators are empty.
You are basically re-implementing the roundrobin() function documented in the itertools documentation recipes section:This cycles through iterators and slicing off the last one each time a StopIteration exception is raised; that last iterator is always the one that just got exhausted.Specifically, for the input example, nexts starts as a circular list of <iter('ABC'), iter('D'), iter('EF')>, in those positions, and num_active is 3, after which the algorithm then progresses through:yielding A and leaving <iter('D'), iter('EF'), iter('BC')>yielding D and leaving <iter('EF'), iter('BC'), <iter('')>yielding E and leaving <iter('BC'), <iter(''), iter('F')>yielding B and leaving <iter(''), iter('F'), iter('C')>trying to yield but hitting a StopIteration exception; the cycle is then at <iter('F'), iter('C'), iter(*stopped*)>, so num_active becomes 2, cycle(islice(nexts, 2)) sets the cycle to <iter('F'), iter('C')> and while loop continues toyielding F and leaving <iter('C'), iter('')>yielding C and leaving <iter(''), iter('')>after which the final two empty iterators trigger further StopIteration exceptions, and num_active goes from 2 to 1 to 0 and the while loop ends.You could implement the same with a collections.deque() object, and manual rotation:but this approach is slower than the cycle variant, as rotation is done 'manually', incurring a cost every iteration, outweighing the simpler 'exhausted' exception case implementation.Like your approach, this saves you having to repeatedly attempt to iterate over any already-exhausted iterators, and unlike the zip_longest() approaches posted by others, doesn't require you to test for a sentinel value (item is not None or not item or item is not unique_sentinel_singleton) each iteration.
You zip the iterables and chain them together


Answer URL
https://docs.python.org/3/library/itertools.html#itertools-recipes
https://docs.python.org/3/library/itertools.html#itertools-recipes
https://docs.python.org/3/library/itertools.html#itertools-recipes
