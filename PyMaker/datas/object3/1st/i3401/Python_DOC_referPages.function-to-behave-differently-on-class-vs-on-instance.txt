Natural Text
I'd like a particular function to be callable as a classmethod, and to behave differently when it's called on an instance. For example, if I have a class Thing, I want Thing.get_other_thing() to work, but also thing = Thing(); thing.get_other_thing() to behave differently.I think overwriting the get_other_thing method on initialization should work (see below), but that seems a bit hacky.  Is there a better way?
Great question! What you seek can be easily done using descriptors.Descriptors are Python objects which implement the descriptor protocol, usually starting with __get__().They exist, mostly, to be set as a class attribute on different classes. Upon accessing them, their __get__() method is called, with the instance and owner class passed in.And now for the result:That was easy!By the way, did you notice me using __get__ on the class and instance function? Guess what? Functions are also descriptors, and that's the way they work!Upon accessing a function attribute, it's __get__ is called, and that's how you get function binding.For more information, I highly suggest reading the Python manual and the "How-To" linked above. Descriptors are one of Python's most powerful features and are barely even known.Why not set the function on instantiation?Or Why not set self.func = self._func inside __init__?Setting the function on instantiation comes with quite a few problems:self.func = self._funccauses a circular reference. The instance is stored inside the function object returned by self._func. This on the other hand is stored upon the instance during the assignment. The end result is that the instance references itself and will clean up in a much slower and heavier manner.Other code interacting with your class might attempt to take the function straight out of the class, and use __get__(), which is the usual expected method, to bind it. They will receive the wrong function.Will not work with __slots__.Although with descriptors you need to understand the mechanism, setting it on __init__ isn't as clean and requires setting multiple functions on __init__.Takes more memory. Instead of storing one single function, you store a bound function for each and every instance.Will not work with properties.There are many more that I didn't add as the list goes on and on.
Here is a bit hacky solution:If we are on class, staticmethod is executed. If we are on instance, __getattribute__ is first to be executed, so we can return not Thing.get_other_thing but some other function (lambda in my case)


Answer URL
https://docs.python.org/3/howto/descriptor.html
https://docs.python.org/3/reference/datamodel.html#implementing-descriptors
https://docs.python.org/3/howto/descriptor.html
https://docs.python.org/3/library/functions.html#property
