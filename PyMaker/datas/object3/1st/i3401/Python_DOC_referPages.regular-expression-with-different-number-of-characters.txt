Natural Text
I need to create a regular expression to validate strings. The strings can have only few characters and each character can be repeated only a few number of times.The regular expression should check below conditions.The string can have only a, b, c, d, e as characters.The character 'a' can appear a maximum of 2 times.The character 'b' can appear maximum of 3 times.The character 'c' can appear maximum of 3 times.The character 'd' can be appear maximum of 1 time.The character 'e' can be appear maximum of 1 time.I know that this can be achieved by string functions. But I am trying to do it with regular expressions.Any help on this is highly appreciated. 
Likely, performance wise, the best way to do this is with Python native string operations.I would write like so:This relies on str.count(sub[, start[, end]]) to count the occurrence of a sub string in a string and any function to test if any condition is true. Since you are interested in performance, you can time how long processing 100,000 strings might take with timeit:On my computer, takes:
A regex checking multiple conditions can be constructed the following way:^ - Start of the source string.A series of positive lookups, for any "required" condition.A series of negative lookups, for any "forbidden" condition..+ - If all previous lookups succeeded, match the whole (usuallynon-empty) source string.If either positive or negative lookup refers to a char locatedanywhere in the source string, it should start with .*,stating that before what we actually check, there can occur anynumber of any (other) chars, possibly none.Your case contains actually only "forbidden" conditions, stating thatit is not allowed:(?!.*[^a-e]) - Any char other than a-e.(?!(?:.*a){3}) - a occurs 3 times (or more).(?!(?:.*b){4}) - b occurs 4 times (or more).(?!(?:.*c){4}) - c occurs 4 times (or more).(?!(?:.*d){2}) - d occurs 2 times (or more).(?!(?:.*e){2}) - e occurs 2 times (or more).So the whole regex should be:
if your strings are already sorted, like all a characters are already in front of all b characters and so on, the simple regular expression like this will do:If characters in your strings are unsorted, well, sort them first =)And if the meaning of your "can appear a maximum of 2 times" is 1 or 2 times (not 0, 1 or 2, as I expected), replaces all 0 with 1 in the reg.expression.
Since you are using pandas, it's probably best to use vectorised operations. These are supposed to be faster, although I am not willing to check. Here is one possible approach, a pandas or numpy expert may have a better method:Example output:


Answer URL
https://docs.python.org/3/library/functions.html#any
