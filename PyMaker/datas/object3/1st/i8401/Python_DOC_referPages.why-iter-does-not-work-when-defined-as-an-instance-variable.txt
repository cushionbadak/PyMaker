Natural Text
If I define the __iter__ method as follows, it won't work:Result:As you can see, calling A().__iter__() works, but A() is not iterable.However if I define __iter__ for the class, then it will work:Does anyone know why python has been designed like this? i.e. why __iter__ as instance variable does not work? Don't you find it unintuitive?
It is done by design. You can find the thorough description here: https://docs.python.org/3/reference/datamodel.html#special-method-lookupShort answer: the special method must be set on the class object itself in order to be consistently invoked by the interpreter. Long answer: the idea behind this is to speed up well-known constructions. In your example: How often are you going to write a code like this in real life? So, what Python does - it skips a dictionary lookup of the instance, i.e. iter(A()) simply does not "see" that self.__iter__, which is actually self.__dict__['__iter__'] in this case. It also skips all the __getattribute__ instance and metaclass lookup gaining a significant speedup.


Answer URL
https://docs.python.org/3/reference/datamodel.html#special-method-lookup
