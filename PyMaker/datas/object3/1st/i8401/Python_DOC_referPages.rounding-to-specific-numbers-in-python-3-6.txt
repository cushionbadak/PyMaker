Natural Text
I'm trying to make a dive table that has some numbers that aren't in a pattern that I can see so I have to manually add all the values, but I need to grab the input and round it to the nearest number in the dictionary.I'll need to convert the input back to string for the output to be correct:CODE:So when the "player" inputs the number 15 for time, I need to round it UP to 19 (Always up even if it's 13 or something like that.) I don't see how I can do this with round() or I might have to make a function that checks EVERY number..
Using your idea of a "function that checks EVERY number", an instance variable keys can be used to get the key if it exists, or the next highest key:Demo:
Convert the d35 dictionary to a sorted list and step through it:Modifying your method gives this. I added an else to the for loop to handle times not covered by any group.
You can try using cut from the pandas module.More or less, it is made to separate continuous variables into discrete categories, like depths into pressure groups.You need to specify an array of bins to cut your data into, which you can then label.So, as an example:giving:You can see the bins has -1, so we include 0, and np.inf to catch anything up to infinite.Integrating this into your code is up to you - personally I would remove the dict and use this mapping.
For large lists use standard bisect module or any other dichotomy package.Check the friendly python docs for excact instructions how to solve your task with bisecthttps://docs.python.org/2/library/bisect.html#other-examplesIf you have numpy, try digitize, seems easier than pandas cutPython: Checking to which bin a value belongsYet for such short list, I would just use simple branching Or, for greater speed build case by case array or a dictionary { "1":"19", "2":"19" ... "20": "25" ...} programmatically,Say with an activestate dictionary inversion snippethttp://code.activestate.com/recipes/415100-invert-a-dictionary-where-values-are-lists-one-lin/
While bisect and pandas.cut (as mentioned in other answers) will work, you could do it with just vanilla Python (no imported modules) by looping through the cutoff values. (This is the approach in @Harvey's answer, just presented as a program rather than an interactive session.)This is a little more verbose than using the modules mentioned, but perhaps easier to follow and understand what's going on, because you're doing it all yourself (which I think is often a good idea, especially if you are trying to learn programming).Each time through the loop, cutoff is a pair from the d35 dictionary. Since the pairs are sorted from lowest to highest, you can just stop at the first one which is greater or equal to the input. If the loop finishes (because the input is higher than the highest cutoff), I chose to return None, but you could return some other value, or raise an exception.


Answer URL
https://docs.python.org/3/library/bisect.html
https://docs.python.org/3/library/bisect.html
