Natural Text
I’m iterating through a file’s lines with enumerate(), and sometimes would need to start the iterating at a specific file line, so I attempted testfile.seek(), e.g. if I want to start iterating the file again at line 10 then testfile.seek(10):Yet the test_file always keep iterating starting at the very first line 0. What could I be doing wrong? Why isn’t the seek() working? Any better implementations would be appreciated as well.Thank you in advance and will be sure to upvote/accept answer
Ordinary files are sequences of characters, at the file system level and as far as Python is concerned; there's no low-level way to jump to a particular line. The seek() command counts the offset in bytes, not lines. (In principle, an explicit seek offset should only be used if the file was opened in binary mode. Seeking on a text file is "undefined behavior", since logical characters can take more than one byte.)Your only option if you want to skip a number of lines is to read and discard them. Since iterating over a file object fetches it one line at a time, a compact way to get your code to work is with itertools.islice():
Personally i would just use an if statement. rudimentary perhaps but it is atleast very easy to understand.Edit: islice:The comparisons done here: Python fastest access to line in file are better than i am capable of. combined with the itertools manual: https://docs.python.org/2/library/itertools.html i doubt you'd need much more
A native Python way of doing this would  be use zip to iterate over unnecessary lines.
You can't use seek() to got to a beginning of a particular line unless you know the byte-offset of the first character of the desired line.One simple way to do it would be to use the islice() iterator in the itertools module.For example, say you had a very test input file that looked like this:Sample code:Output:Note islice() counts from zero, which is why it's first argument was 9 and not 10. Also this is not as fast as seek() would be because islice() actually reads all the lines up until it gets to the one you want to start at.
The only way the seek method is going to help you is if all the lines in the file are of the same length, which you know ahead of time and your file is either binary or at least ascii-only text (i.e. no unicode characters allowed). Then you really could doThis is because seek will move the internal file pointer by a fixed number of bytes, not lines. The +1 above is to account for newline characters. You would likely have to make it +2 on a windows machine.This will not work if your file is non-ascii because some lines may be the same length in characters but actually contain a different number of bytes, making the call to seek yield undefined results.There are a few legitimate ways you can skip the first 10 lines:Read the whole file into a list and discard the first 10 lines:Now test_data contains all the lines in your file besides the first 10.Discard lines from the file as you read it in a for loop using enumerate:This method has the advantage of stripping the trailing newlines from each line before handing them off to you. This is functionally similar to using itertools.islice as some of the other answers suggest.Use some really arcane low-level stuff to actually read 10 newline characters from the file before proceeding normally. You may have to specify the encoding of the file up-front for this to work correctly with text I/O, but it should work out-of-the-box for ASCII files (see here for more details):This option is not particularly robust. It does not handle the case where there are fewer than 10 lines gracefully, and it re-implements the internal machinery of the built-in file iterator very crudely. The only possible advantage it offers is that it does not buffer entire lines like the iterator does.


Answer URL
https://docs.python.org/3/library/io.html#io.IOBase.seek
https://docs.python.org/3/library/io.html#io.TextIOBase.seek
https://docs.python.org/3/library/io.html#io.TextIOBase.seek
