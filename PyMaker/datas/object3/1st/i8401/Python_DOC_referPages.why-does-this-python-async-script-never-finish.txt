Natural Text
I created a MCVE example of a much larger code base that I am working on, so some things look to be a funky way of doing things, but they are just the minimal versions, so not everything makes sense as far as WHY I am doing it this way. I already know some work-arounds, and at this point am mostly just curious as to why I am seeing this behaviour. I have the following script which has an async function that waits for a future. The script then intercepts a signal to set the future result:This script correctly gets the interrupt, and appears to set the future correctly, but for some reason the script never terminates.To reproduce for you, just run the script, then hit ctrl+c. For some reason it never stops.Now here is where it gets weird. If you add the following to the top of the script (after defining the loop), then the script stops just fine.Why is the coroutine not getting the future in the first case, but it gets it correctly in the second case?Also, another weird thing is that if you set the send_stop function to be async, and add it as a task, it never gets called. (This follows the same behaviour as above. If the do_nothing_useful() function is on the loop, everything works fine, but without it, it doesnt)Here is the version where the send_stop is never called:and the script never prints stopping.I have tried this on python 3.5.3 and 3.6 on linux
The correct method to add a signal handler that wakes up a loop is by using loop.add_signal_handler. This will make sure select() wakes up to handle the signal.


Answer URL
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.add_signal_handler
