Natural Text
(Nota bene: This is heavily modified from the original question, to include details I erroneously elided.)This is the (summarized) file (common.py) I'm testing. It contains a decorator (derived from the Decorum library) that calls a class method on another object(A): I want to patch out A, because that code makes an external call I'm not testing.I'd like to @patch class A in my unittest, to isolate and check B.d()'s functionality. This is my unittest (located in test/test_common.py):Debugging the above, I see that A is never actually mocked: the code proceeds into A's code, so it makes sense that mock_a is never called, and thus the assertion fails. However, I'd like to properly monkey patch A. This approach works if I'm monkey patching an import that exists in common.py, but apparently not if the class is defined there?Note that I think this is likely an issue of where I'm patching, that is @patch('common.A', autospec=True) should more likely be something like @patch('where.python.actually.finds.A.when.B.calls.A', autospec=True). But I'm very unclear on how to determine if that is the case, and if so, what the correct path is. For instance, @patch('BDecorated.common.A', autospec=True) does not work.
Thanks to @user2357112, I arrived at this solution. Caveat: I don't know if this is standard or 'best' practice, but it seems to work.First, move the BDecoratedClass to it's own file in test/dummy.py. Then change the test to this:This forces the patch to execute prior to the import of the dummy class being decorated. It's a little weird because the import is inside the function, but for a test that seems fine.Bigger Caveat:This only works for the first test that imports something from the module where, in this case BDecoratedClass imports from. At that juncture everything else in the class has been loaded and cannot be patched.


Answer URL
https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch
