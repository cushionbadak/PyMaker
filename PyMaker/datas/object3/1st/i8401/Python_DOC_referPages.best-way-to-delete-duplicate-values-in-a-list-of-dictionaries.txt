Natural Text
I have a list of dictionaries, and those dictionaries have another nested dictionary. Here is an example:So each dict in the list has a unique id and values associated with it.I need a way to iterate through these dictionaries and if any of them have an exact match in the 'subject' field then I want to delete/remove the entire dict with the latest date.So, using the example above, after iterating through the list and de-duping, I need the result to look like this.It deletes the first instance of 'dupe1' because it is the later date.
The problem is made more difficult because you don't know the key values (unique ids) of the dictionaries in reports. Since each one consists of only one item, you can use next(iter(dict.values())) with Python 3 to get the single nested dictionary associated with it—which I called checkout in the code below to give it a name.Given that, the approach I would use would be to first create a dictionary that groups the elements in reports by subject—which then gives you something like this to work with (note: I changed the sample reports data so the first has more than one with a duplicate 'subject'):The lists of reports associated with each subject can then be sorted by date (using a lambda based on the same next(iter(dict.values())) trick), and given the now ordered contents of that, it's easy to update the list and remove any duplicates in accordance to your desires.Output:
Since you're completely stuck, here's a start. One problem is that for each dict, the key is different and unknown. It looks like there's only one pair in each dict, so you can get items() and take the first one:reports is now sorted by subject. You can then use groupby to get reports grouped by subject.For each group, you can use sort again, this time with due_date. You'll have to take care though, you cannot sort dates alphabetically, you'll need to extract year,month,day in this order or convert the string to a datetime object with strptime.Once your results are grouped by subject and sorted by due_date, just get the first element of each group. Done!
This is the final solution that I went with. Based off @martineau's answer, but I'm guessing its only because im using Python3.     


Answer URL
https://docs.python.org/3/tutorial/datastructures.html
https://docs.python.org/3/library/itertools.html#itertools.groupby
