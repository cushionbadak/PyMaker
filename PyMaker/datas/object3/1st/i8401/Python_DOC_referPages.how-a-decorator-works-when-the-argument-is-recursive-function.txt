Natural Text
this is the decorator.the parts of result is:how this decorator works when the argument is recursive function? why the decorator can be executed for many times. how it works?
In your example, the clock decorator is executed once, when it replaces the original version of factorial with the clocked version. The original factorial is recursive and therefore the decorated version is recursive too. And so you get the timing data printed for each recursive call - the decorated factorial calls itself, not the original version, because the name factorial now refers to the decorated version.It's a good idea to use functools.wraps in decorators. This copies various attributes of the original function to the decorated version.For example, without wraps:outputWith wraps:outputwhich is what we'd get if we did print(factorial.__name__, factorial.__doc__) on the undecorated version.If you don't want the clock-decorated recursive function to print the timing info for all of the recursive calls, it gets a bit tricky. The simplest way is to not use the decorator syntax and just call clock as a normal function so we get a new name for the clocked version of the function:outputAnother way is to wrap the recursive function in a non-recursive function and apply the decorator to the new function.outputAnother way is to modify the decorator so that it keeps track of whether it's executing the top level of the recursion or one of the inner levels, and only print the timing info for the top level. This version uses the nonlocal directive so it only works in Python 3, not Python 2.outputThe rclock function can be used on non-recursive functions, but it's a little more efficient to just use the original version of clock.Another handy function in functools that you should know about if you're using recursive functions is lru_cache. This keeps a cache of recently computed results so they don't need to be re-computed. This can enormously speed up recursive functions. Please see the docs for details.We can use lru_cache in conjunction with clock or rclock.outputAs you can see, even though we used the plain clock decorator only a single line of timing info gets printed for the factorials of 4, 5, and 6 because the smaller factorials are read from the cache instead of being re-computed.
When you apply a decorator to a function, the function is passed as a parameter to the decorator. Whether the function is recursive or not does not matter.The codeis equivalent to
Maybe it helps to assume the "syntactic sugar" point of view.This is from PEP 318 with modifications (I simplified the example)The current syntax for function decorators as implemented in Python 2.4a2 is:This is equivalent to:As you can see the decorator function is called only once and the wrapper it returns is assigned to the name of the decorated function.Thus whenever the original function is called by its name (for example in a recursion) the wrapper (but not the decorator function) is called instead.
The decorated function is passed to the decorator as an argument and returned another function to replace the original one, the returned function is no recursive function, but when you call it, it'll call the original recursive function:When you call your decorated function factorial, what you actually called is clocked, and it actually call factorial in the following line:The decorator is executed only once.For understanding, you can think your function becomes to the following one after @clock:


Answer URL
https://docs.python.org/3/library/functools.html#functools.wraps
https://docs.python.org/3/library/functools.html#functools.lru_cache
