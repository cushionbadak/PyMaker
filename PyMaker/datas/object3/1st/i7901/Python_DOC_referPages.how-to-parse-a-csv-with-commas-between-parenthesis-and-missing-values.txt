Natural Text
I tried using pyparsing to parse a CSV with:Commas between parenthesis (or brackets, etc): "a(1,2),b" should return the list ["a(1,2)","b"]Missing values: "a,b,,c," should return the list ['a','b','','c','']I worked a solution but it seems "dirty". Mainly, the Optional inside only one of the possible atomics. I think the optional should be independent of the atomics. That is, I feel it should be put somewhere else, for example in the delimitedList optional arguments, but in my trial and error that was the only place that worked and made sense. It could be in any of the possible atomics so I chose the first. Also, I don't fully understand what originalTextFor is doing but if I remove it it stops working.Working example:Prints:Is this the right way to do this? Is there a "cleaner" way to use the Optional inside the first atomic?
Working inside-out, I get this:originalTextFor recombines the original input text within the leading and trailing boundaries of the matched expressions, and returns a single string. If you leave this out, then you will get all the sub-expressions in a nested list of strings, like ['a',['2,3']]. You could rejoin them with repeated calls to ''.join, but that would collapse out whitespace (or use ' '.join, but that has the opposite problem of potentially introducing whitespace).To optionalize the elements of the list, just say so in the definition of the delimited list:Be sure to add the default value, else the empty slots will just get dropped.With these changes I get:
What you can do is using regex re, for instance:
Output:Modified from this answer.I also like this answer, which suggests modifying the input slightly and using quotechar of the csv module.


Answer URL
https://docs.python.org/3/library/csv.html#csv.Dialect.quotechar
