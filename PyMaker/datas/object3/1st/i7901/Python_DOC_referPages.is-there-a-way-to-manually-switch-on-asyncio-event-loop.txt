Natural Text
I want to use the event loop to monitor any inserting data into my asyncio.Queue(you can find its source code here https://github.com/python/cpython/blob/3.6/Lib/asyncio/queues.py), but I run into some problems. Here is the following code:The program has started and we can see the following resultBut now if we manually add data into q by using q.put_nowait('test'), we would get the following result:As you can see, the future is already finished, yet we still haven't print out the newly added string 'test'. In other words, msg = await q.get() is still waiting even though the Future related to q.get() is done and there are no other tasks running. This confuses me because in the official documentation(https://docs.python.org/3/library/asyncio-task.html), it saysresult = await future or result = yield from future – suspends the coroutine until the future is done, then returns the future’s resultIt seemed that even though the Future is done, we still need some sort of await in other async function to make the event loop keep processing tasks.I found a workaround to this problem, which is adding a checking_task(), and also add that coroutine into the event loop; then it will work as intended.But adding a checking_task() coroutine is very costly for CPU since it just runs a while loop. I am wondering if there is some manual way for us to trigger that await event without using a async function. For example, something magical likeHelps will be greatly appreciated! Thanks.
So I ended up with usingand it will work as intended. After figure this out, I searched some information about . It turned out this post (Scheduling an asyncio coroutine from another thread) has the same problem. And @kfx's answer would also work, which isNotice asyncio.Queue.put() is a coroutine but asyncio.Queue.put_nowait() is a normal function. 


Answer URL
https://docs.python.org/3/library/asyncio-task.html
