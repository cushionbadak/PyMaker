Natural Text
After some research about recursive functions i am facing contradiction: On one side solving problems in recursive way is elegant while on the other side in practice performance seems to be horrible and number of recursive calls is limited.I understand by default Pythons recursive depth is limited to 1000, however even in a simple application i get very bad performmance as early as 40 - 50 calls.Let me give an example:This simple recursive function on my PC takes huge amount of time to solve even for low n. For testing i also wrote another function:Non recursive way is very fast even on big numbers, so definitivly problem cannot be operations involved or size of numbers. So my question is why the recursive way is so slow and is there any way to make it faster? Is there any way to expand resursive depth?EDIT Since answers suggested using memoization i looked into it and implemented it on my example:Same mem(f) can be used with other recursive functions f. The @mem part must be included for f to be passed as argument to mem() (see "decorators")It is slightly advanced way to code but i didnt find an easier was to implement memoization for given example. If there is simpler way of implementation pls correct me.
Ignoring the fact that fibonacci() is a textbook case for memoization (which would make it much faster), "deep and cheap" recursion simply is not a thing in plain Python.In many languages there is tail-call elimination.  Python doesn't have this.  In many languages, pushing an additional stack frame is very cheap.  Not so in Python.It's not so easy to find real-world code where this is a problem, which may go some way toward explaining why the Python folks have kept it  simple and always create bona fide stack frames with full debugging ability.  There's just not a lot of demand for cheap and deep recursion in most Python applications.
The problem with recursive functions is that you call the same method with the same parameter a certain number of times. For example, in fibrecursive(7), fibrecursive(2) is called 4 times. Each time you redo the same thing.You can improve performance using dynamic programming. In short, you store your result in an array and when you call fibrecursive(2) you check in your array if it already exists.Here is the pseudo code from the article:


Answer URL
https://docs.python.org/3/library/functools.html#functools.lru_cache
