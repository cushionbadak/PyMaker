Natural Text
I'm trying to have a class act in every way like a tuple that's an attribute of the class, so len(instance) would be the same as len(instance.tup), instance[3] would return instance.tup[3], etc. Here's the class:I canBut if I try to:mt does in fact have a __len__ that I can call:(I even renamed it __len__). As near as I can tell, this should look just as if I did:But python won't let me len(mt) (or mt[2] or mt [1:5] for that matter).
The reason this isn't working as you have hoped is because doing:Is not equivalent to In the latter case, your method is a property of the class because it is defined in class scope. It would be the equivlanet of setattr(cls, nm, f). If you check MyTup.__dict__ you will see it there. However, in the former case, __len__ is a property of the instance. So it will be in my_instance.__dict__. len checks the class for a __len__ method, and doesn't find one. Hence the error. Your __getattr__ is never actually called, and even if it were, it wouldn't allow you to use len. You can use an_instanec.__len__ diretly, though.
New-style classes look-up "special methods"—those that start and end with two underscore characters—on an instance's class not the instance involved, so when len() is called it tries to call typeof(mt).__len__(). So the proper way to do what you want would be to use one of the Abstract Base Classes for Containers in the collections module (since Python 3.3)
len does not use __getattr__ to get the __len__ function - it calls __len__ directly.Calling x.__len__ is like calling getattr(x, '__len__') - which will return the x.__len__ method object.len works behind the scene, so it can access this method directly, without invoking the __getattr__ helper.Try to add a print statement in your __getattr__ to see what is printed when calling len (hint: nothing). 


Answer URL
https://docs.python.org/3/library/collections.abc.html#module-collections.abc
