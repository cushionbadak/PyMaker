Natural Text
I've been gong through the tutorials about multithreading and queue in python3. As the official tutorial goes, "The Queue class in this module implements all the required locking semantics". But in another tutorial, I've seen an example as following:
I believe the tutorial you're following is a bad example of how to use Python's threadsafe queue. In particular, the tutorial is using the threadsafe queue in a way that unfortunately requires an extra lock. Indeed, this extra lock means that the threadsafe queue in the tutorial could be replaced with an old-fashioned non-threadsafe queue based on a simple list.The reason that locking is needed is hinted at by the documentation for Queue.empty():If empty() returns False it doesn't guarantee that a subsequent call to get() will not block.The issue is that another thread could run in-between the call to empty() and the call to get(), stealing the item that empty() otherwise reported to exist. The tutorial probably uses the lock to ensure that the thread has exclusive access to the queue from the call to empty() until the call to get(). Without this lock, two threads could enter into the if-statement and both issue a call to get(), meaning that one of them could block, waiting for an item that will never be pushed.Let me show you how to use the threadsafe queue properly. Instead of checking empty() first, just rely directly on the blocking behavior of get():The queue's internal locking will ensure that two threads do not interfere for the duration of the call to get(), and no queueLock is needed. Note that the tutorial's original code would check exitFlag periodically every 1 second, whereas this modified queue requires you to push a dummy object into the queue after setting exitFlag to True -- otherwise, the flag will never be checked.The last part of the controller code would need to be modified as follows:There is another issue with the tutorial's use of the threadsafe queue, namely that a busy-loop is used in the main thread when waiting for the queue to empty:To wait for the queue to empty it would be better to use Queue.task_done() in the threads and then call Queue.join() in the main thread. At the end of the loop body in process_data(), call q.task_done(). In the main controller code, instead of the while-loop above, call q.join().See also the example in the bottom of Python's documentation page on the queue module.Alternatively, you can keep the queueLock and replace the threadsafe queue with a plain old list as follows:Replace workQueue = queue.Queue(10) with workQueue = []Replace if not workQueue.empty() with if len(workQueue) > 0Replace workQueue.get() with workQueue.pop(0)Replace workQueue.put(word) with workQueue.append(word)Note that this doesn't preserve the blocking behavior of put() present in the original version.


Answer URL
https://docs.python.org/3/library/queue.html#queue.Queue.empty
https://docs.python.org/3/library/queue.html#queue.Queue.task_done
https://docs.python.org/3/library/queue.html#queue.Queue.join
https://docs.python.org/3/library/queue.html#queue.Queue.join
