Natural Text
In working on some optimizations for my code in Python 2.7, I stumbled upon the following phenomenon:It's no surprise to me that preallocating is faster than appending, or that comprehension is faster than anything else, but why is using __setitem__ three times slower than using []?Initially, I had a theory that using my_list[x] = x either merely reassigned the reference stored in my_list[x] to the address of the new object, or maybe that the interpreter even noticed that both were of the same type and used an overloaded assignment operator, whereas a setitem call actually copied the memory over, BUT some experimenting proved me wrong: Does someone know what's going on under the hood? 
Generic method dispatch has extra overhead over syntax based dispatch; the latter can directly call the C level equivalent of the __setitem__ method, while the former must repeatedly look up and create a bound method, and dispatch the call through the generic method dispatch mechanism (more general == slower). Generic dispatch also means constructing a tuple of arguments to pass (where syntax based calls just read the values off the Python stack without constructing a tuple).In addition, the Python level name is actually a thin wrapper, so calling __setitem__ means one additional layer of calling before it reaches the C API, as it has to traverse one additional layer before it reaches sq_ass_item (the C layer slot that is the ultimate call that implements the assignment). METH_COEXIST can be used to limit the slot wrapper overhead according to the docs, but it looks like that was only used for __getitem__ on list.You can eliminate the method lookup and binding overhead by storing off the bound method, which might save a little work, but fundamentally, for CPython, syntax beats method calls; if the syntax is equally clear and not error prone, use syntax.  A prebinding example that might reduce some of the discrepancy would be:
You have extra property lookup + a function call in the second function:def fill_preallocated_1():def fill_preallocated_2():


Answer URL
https://docs.python.org/3/c-api/structures.html#METH_COEXIST
