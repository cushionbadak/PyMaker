Natural Text
In python 3, you can add member variables to a custom object after the class declaration:However, doing the same for a list object throws an exception:Can someone explain why this is happening? 
Not all objects support arbitrary attribute assignment.Most built-in types don't, including lists, tuples, strings, bytes, dictionaries, sets, booleans, numeric types, etc. On the other hand, function objects do, as do module objects (you are adding new globals to that module when you do).In other words, just because custom classes and instances support assignment, doesn't mean other types do too. To support arbitrary attributes these types would need to have a __dict__ dictionary per instance, a non-trivial memory cost for very little advantage, especially when a typical Python program creates a lot of instances of these types.Note that when you use the __slots__ feature to save per-instance memory for custom classes, you cannot assign attributes to those instances either:Vice versa, you can subclass the built-in types, at which point the subclass does support arbitrary attribute assignment (as the subclass instances will have a __dict__ attribute):That is, unless you use __slots__ of course.
As Martijn Pieters have said, We can't add attribute to them. But you may inherit them and override setattribute() method to accomplish this.


Answer URL
https://docs.python.org/3/reference/datamodel.html#slots
https://docs.python.org/3/reference/datamodel.html#object.__setattr__
