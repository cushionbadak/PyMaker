Natural Text
I'm trying to make a list with numbers 1-1000 in it. Obviously this would be annoying to write/read, so I'm attempting to make a list with a range in it. In Python 2 it seems that:would have worked, but in Python 3 the range is similar to the xrange of Python 2?Can anyone provide some insight into this?
You can just construct a list from the range object:This is how you do it with generators in python2.x as well.  Typically speaking, you probably don't need a list though since you can come by the value of my_list[i] more efficiently (i + 1), and if you just need to iterate over it, you can just fall back on range.Also note that on python2.x, xrange is still indexable1.  This means that range on python3.x also has the same property21print xrange(30)[12] works for python2.x2The analogous statement to 1 in python3.x is print(range(30)[12]) and that works also.
in Python 3.x, the range() function got its own type. so in this case you must use iteratorlist(range(1000))
In Pythons <= 3.4 you can, as others suggested, use list(range(10)) in order to make a list out of a range (In general, any iterable).Another alternative, introduced in Python 3.5 with its unpacking generalizations, is by using * in a list literal []:Though this is equivalent to list(r), it's literal syntax and the fact that no function call is involved does let it execute faster. It's also less characters, if you need to code golf :-)
You really shouldn't need to use the numbers 1-1000 in a list. But if for some reason you really do need these numbers, then you could do:List Comprehension in a nutshell:The above list comprehension translates to:This is just the list comprehension syntax, though from 2.x. I know that this will work in python 3, but am not sure if there is an upgraded syntax as wellRange starts inclusive of the first parameter; but ends Up To, Not Including the second Parameter (when supplied 2 parameters; if the first parameter is left off, it'll start at '0')  
The reason why Python3 lacks a function for directly getting a ranged list is because the original Python3 designer was quite novice in Python2. He only considered the use of range() function in a for loop, thus, the list should never need to be expanded. In fact, very often we do need to use the range() function to produce a list and pass into a function.Therefore, in this case, Python3 is less convenient as compared to Python2 because:In Python2, we have xrange() and range(); In Python3, we have range() and list(range())Nonetheless, you can still use list expansion in this way:
Actually, if you want 1-1000 (inclusive), use the range(...) function with parameters 1 and 1001: range(1, 1001), because the range(start, end) function goes from start to (end-1), inclusive.
In fact, this is a retro-gradation of Python3 as compared to Python2. Certainly, Python2 which uses range() and xrange() is more convenient than Python3 which uses list(range()) and range() respectively. The reason is because the original designer of Python3 is not very experienced, they only considered the use of the range function by many beginners to iterate over a large number of elements where it is both memory and CPU inefficient; but they neglected the use of the range function to produce a number list. Now, it is too late for them to change back already.If I was to be the designer of Python3, I will:use irange to return a sequence iteratoruse lrange to return a sequence listuse range to return either a sequence iterator (if the number of elements is large, e.g., range(9999999) or a sequence list (if the number of elements is small, e.g., range(10))That should be optimal.
Use Range in Python 3.Here is a example function that return in between numbers from two numbersResult


Answer URL
https://docs.python.org/3/library/stdtypes.html#range
