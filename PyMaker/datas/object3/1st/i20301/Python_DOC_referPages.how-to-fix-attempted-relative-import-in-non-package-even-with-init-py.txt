Natural Text
I'm trying to follow PEP 328, with the following directory structure:In core_test.py I have the following import statementHowever, when I run, I get the following error:Searching around I found "relative path not working even with __init__.py" and "Import a module from a relative path" but they didn't help.Is there anything I'm missing here?
Yes. You're not using it as a package.
To elaborate on Ignacio Vazquez-Abrams's answer:The Python import mechanism works relative to the __name__ of the current file.  When you execute a file directly, it doesn't have its usual name, but has "__main__" as its name instead.  So relative imports don't work.You can, as Igancio suggested, execute it using the -m option.  If you have a part of your package that is meant to be run as a script, you can also use the __package__ attribute to tell that file what name it's supposed to have in the package hierarchy. See http://www.python.org/dev/peps/pep-0366/ for details.
You can use import components.core directly if you append the current directory to sys.path:
It depends on how you want to launch your script.If you want to launch your UnitTest from the command line in a classic way, that is:Then, since in this case 'components' and 'tests' are siblings folders, you can import the relative module either using the insert or the append method of the sys.path module.Something like:Otherwise, you can launch your script with the '-m' argument (note that in this case, we are talking about a package, and thus you must not give the '.py' extension), that is:In such a case, you can simply use the relative import as you were doing:You can finally mix the two approaches, so that your script will work no matter how it is called.For example:
In core_test.py, do the following:
If your use case is for running tests, and it seams that it is, then you can do the following. Instead of running your test script as python core_test.py use a testing framework such as pytest. Then on the command line you can enterThat will run the tests in your directory. This gets around the issue of __name__ being __main__ that was pointed out by @BrenBarn. Next, put an empty __init__.py file into your test directory, this will make the test directory part of your package. Then you will be able to doHowever, if you run your test script as a main program then things will fail once again. So just use the test runner. Maybe this also works with other test runners such as nosetests but i haven't checked it. Hope this helps.  
My quick-fix is to add the directory to the path:
Old thread. I found out that adding an __all__= ['submodule', ...] to the __init__.py file and then using the from <CURRENT_MODULE> import * in the target works fine.
You can use from pkg.components.core import GameLoopEvents, for example I use pycharm, the below is my project structure image, I just import from the root package, then it works:
If someone is looking for a workaround, I stumbled upon one.  Here's a bit of context.  I wanted to test out one of the methods I've in a file.  When I run it from within it always complained of the relative imports.  I tried to apply the above solutions, but failed to work, since there were many nested files, each with multiple imports.Here's what I did.  I just created a launcher, an external program that would import necessary methods and call them.  Though, not a great solution, it works.
Try this
As Paolo said, we have 2 invocation methods:One difference between them is sys.path[0] string. Since the interpret will search sys.path when doing import, we can do with tests/core_test.py:And more after this, we can run core_test.py with other methods:Note, py36 tested only.


Answer URL
https://docs.python.org/3/using/cmdline.html
