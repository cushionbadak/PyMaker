Natural Text
i need to get consecutive numbers while an input number doesnt change. so i get give(5)->1, give(5)->2, and so on, but then: give(6)->1 again, starting the count.So far I solved it with an iterator function count() and a function give(num) like this:It works, but its ugly: I have two globals and have to set them before I call give(num). I'd like to be able to call give(num) without setting previously the 'a=count()' and 'last=999' variables. I'm positive there's better way to do this...edit: ty all for incredibly fast and varied responses, i've got a lot to study here.. 
The obvious thing to do is to make give into an object rather than a function.* Any object can be made callable by defining a __call__ method.While we're at it, your code can be simplified quite a bit, so let's do that.So:This also lets you create multiple separate givers, each with its own, separate current state, if you have any need to do that.If you want to expand it with more state, the state just goes into the instance variables. For example, you can replace last and a with a dictionary mapping previously-seen values to counters:And now:* I sort of skipped a step here. You can always remove globals by putting the variables and everything that uses them (which may just be one function) inside a function or other scope, so they end up as free variables in the function's closure. But in your case, I think this would just make your code look "uglier" (in the same sense you thought it was ugly). But remember that objects and closures are effectively equivalent in what they can do, but different in what they look like—so when one looks horribly ugly, try the other.
Just keep track of the last returned value for each input. You can do this with an ordinary dict:The standard library has a Counter class that makes things a bit easier:collections.defaultdict(int) works too.
You can achieve this with something like this:Which produces:The two key points are using a dict to keep track of multiple iterators simultaneously, and setting a variable on the function itself. You can do this because functions are themselves objects in python. This is the equivalent of a static local variable in C. 
You can basically get what you want via combination of defaultdict and itertools.count:If you need the counter to start at one, you can get that via functools.partial:
Adding a second answer because this is rather radically different from my first.What you are basically trying to accomplish is a coroutine - a generator that preserves state that at arbitrary time, values can be sent into.  PEP 342 gives us a way to do that with the "yield expression".  I'll jump right into how it looks:If the _counters line is confusing, see my other answer.With a coroutine, you can send data into the generator.  So you can do something like the following:Notice how the generator preserves state and can switch between counters at will.
In my first answer, I suggested that one solution was to transform the closure into an object. But I skipped a step—you're using global variables, not a closure, and that's part of what you didn't like about it.Here's a simple way to transform any global state into encapsulated state:Or, adapting my final version of Giver:If you're curious how this works:Those cell objects are essentially references into the stack frame of the make_give call that created the give function.This doesn't always work quite as well in Python 2.x as in 3.x. While closure cells work the same way, if you assign to a variable inside the function body and there's no global or nonlocal statement, it automatically becomes local, and Python 2 had no nonlocal statement. So, the second version works fine, but for the first version, you'd have to do something like state = {'a': None, 'last': None} and then write state['a'] = count instead of a = count.This trick—creating a closure just to hide local variables—is very common in a few other languages, like JavaScript. In Python (partly because of the long history without the nonlocal statement, and partly because Python has alternatives that other languages don't), it's less common. It's usually more idiomatic to stash the state in a mutable default parameter value, or an attribute on the function—or, if there's a reasonable class to make the function a method of, as an attribute on the class instances. There are plenty of cases where a closure is pythonic, this just isn't usually one of them.


Answer URL
