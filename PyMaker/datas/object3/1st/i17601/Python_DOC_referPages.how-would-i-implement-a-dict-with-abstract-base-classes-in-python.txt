Natural Text
This question already has an answer here:How to “perfectly” override a dict?                    5 answers                I attempted to implement a mapping in Python by using the abstract base class, MutableMapping, but I got an error on instantiation. How would I go about making a working version of this dictionary that would emulate the builtin dict class, in as many ways as possible, to be clear, with Abstract Base Classes?A good answer will demonstrate how to make this work, specifically without subclassing dict (a concept that I am quite familiar with).
How would I implement a dict with Abstract Base Classes?A good answer will demonstrate how to make this work, specifically  without subclassing dict.Here's the error message: TypeError: Can't instantiate abstract class D with abstract methods __delitem__, __getitem__, __iter__, __len__, __setitem__It turns out that one must implement them to use the Abstract Base Class (ABC), MutableMapping.ImplementationSo I implement a mapping that works like a dict in most respects that uses the object's attribute reference dict for the mapping. (Delegation is not the same as inheritance, so we'll just delegate to the instance __dict__, we could use any other ad-hoc mapping, but you don't seem to care about that part of the implementation. It makes sense to do it this way in Python 2, because MutableMapping doesn't have __slots__ in Python 2, so you're creating a __dict__ either way. In Python 3, you could avoid dicts altogether by setting __slots__.)DemonstrationAnd to demonstrate the usage:And for ensuring the dict API, lesson learned is that you can always check for collections.MutableMapping:And while a dict is always going to be an instance of a MutableMapping due to registration on collections import, the reverse is not always true:After performing this exercise, it is clear to me that using Abstract Base Classes provides only the guarantee of a standard API for users of the class. In this case, users assuming a MutableMapping object will be guaranteed the standard API for Python.Caveats:The fromkeys class constructor method is not implemented.One could mask the builtin dict methods like get or setdefaultIt's fairly simple to unmask again:But I wouldn't use this code in production.Demonstration without a dict, Python 3:
At the LeastYou need to implement in your subclass, all the abstract methods that you inherit from MutableMappingMoreoverYou need to provide a data structure to store your mapping (hash, AVL, Red Black), and a way to construct your Dictionary
The best way to demonstrate this without actually using a dict anywhere is probably to implement something dead simple, very different from dict, and not completely useless. Like a fixed-sized mapping of fixed-size bytes to same-fixed-size bytes. (You might use this for, e.g., a routing table—it'll be much more compact than a dict mapping unpacked keys to unpacked values, although obviously at the cost of speed and flexibility.)A hash table is just an array of (hash, key, value) tuples. Since the whole point of this is packing data in, we cram those into a struct, meaning we can just use a big bytearray for storage. To mark a slot empty, we set its hash value to 0—which means we need to "escape" any real 0 by turning it into a 1, which is stupid, but simpler to code. We'll also use the dumbest possible probe algorithm for simplicity.As the error message says, you need to provide implementations for the abstract methods __delitem__, __getitem__, __iter__, __len__, and __setitem__. However, a better place to look is the docs, which will tell you that if you implement those five methods (plus any other methods required by the base classes, but as you can see from the table there are none), you'll get all the other methods for free. You may not get the most efficient possible implementations of all of them, but we'll come back to that.First, let's deal with __len__. Normally people expect this to be O(1), which means we need to keep track of it independently, updating it as needed. So:Now, __getitem__ just probes until it finds the desired key or reaches the end:And __delitem__ does the same thing, except it empties out the slot if found, and updates len.__setitem__ is a bit trickier—if found, we have to replace the value in the slot; if not, we have to fill an empty slot. And here we have to deal with the fact that the hash table may be full. And of course we have to take care of len:And that leaves __iter__. Just as with a dict, we don't have any particular order, so we can just iterate the hash table slots and yield all the non-empty ones:While we're at it, we might as well write a __repr__. Note that we can use the fact that we get items for free:However, note that the default items just creates an ItemsView(self), and if you track that through the source, you'll see that it iterates self and looks up each value. You can obviously do better if the performance matters:And likewise for values, and possibly other methods.
The whole idea of an abstract base class is that it has some members, (pure virtual members in C++ terms), that your code has to supply - in C++ these are the Pure Virtual members and other Virtual members you may override.Python differs from C++ in that all members of all classes are Virtual and may be overridden, (and you can add members to all classes and instances) but Abstract Base classes have some required missing classes these are the equivent to the C++ pure virtual.Having got that out of the way you just need to supply the missing members to be able to create an instance of your derived class.  For an example of the sort of thing you are trying to do see the accepted answer here but rather than use a dict within the class you will have to provide the methods that it provides yourself.
With MutableMapping as base class you should create this methods yourself in your class: __delitem__, __getitem__, __iter__, __len__, __setitem__.To create custom dict class you can derive it from dict:


Answer URL
