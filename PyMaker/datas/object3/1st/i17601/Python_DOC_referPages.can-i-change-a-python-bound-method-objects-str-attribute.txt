Natural Text
I would like to change the __str__() attribute of one of my class's methods.(Note: Not to be confused with "trying to change the method __str__()".)I have a class, MyClass, which has a method 'some_method'.  I can change the way MyClass displays itself by:When I instantiate and print MyClass:I get:I'm an instance of MyClass!When II get:<bound method my_class.some_method of <gumble margle object at mumble-jumble>>I would like to see instead:some_method in the instance my_class you Dope!I've tried overriding the str method of some_method:But no love.Attempting to brute-force it in IPython proved no better:gaveAttributeError: 'method' object attribute '__str__' is read-onlyIs there an easy way to do this programmatically (preferrably in Python 3)?
You'll need to use a custom class instead of a class function:then use this in your class:Demo:This works because functions are descriptors; they return methods when their __get__ method is called.
Just add @toStr("This is %s You Dope! :P") above the method.Output:Add the following somewhere above the class (perhaps a separate file) to create the annotation:Note that self.some_method.real_self = self is needed in __init__ to ensure that the right self gets passed to the wrapped method.
I faced this same problem and I wasn't happy with either of the solutions here.  Martijn's solution using descriptors is the right approach, but it is not as elegant as a solution that provides a decorator (and some of the choices of argument names as well as the structure of his solution is unnecessarily confusing).  Navin's solution is not a good approach as it requires manually setting "real_self"; this is precisely the purpose of descriptors.  Here I wanted to override __repr__ instead of __str__, but that's just a detail, the solution is the same.Here is my decorator which returns a descriptor solution:Output:The key to understanding all of this is that when you write a method in a class declaration in python, you are not doing anything special - merely defining a function in the namespace of that class.  However, then some syntactic sugar kicks in (or at least I believe this happens): Python then wraps that method inside a descriptor, which handles calling that function with the instance of the class as the self argument.  So, all we need to do is take this step ourselves; rather than let Python convert our class-level function into a method, just wrap it ourselves in a descriptor whose __get__ method returns a callable whose __call__ method calls the function we want as our method, but which has a __repr__ method of our choosing.


Answer URL
