Natural Text
I am wondering if there is a more succinct method for doing the following:When h, t, r are numpy arrays, I want to do the following:which computes the number of non-repeated items in the individual arrays. However, the lambda expression sticks out like a sore thumb. If the non-repeated thing weren't a problem, I would have written:Which is so much cooler. We have dispensed of the lambda expression in its entirety. Having dabbled in Haskell for a couple of months, I am really beginning to believe that Python should be able to provide a chaining operator like . in Haskell so that the first expression can be simply reduced to the following:Which is so much better!!I saw something that uses the reduce method for doing this, but that is simply more ugly than the previous method. I wonder if anyone has something that they know about that can solve the problem? I am aware that there are problems with non-strict evaluation that may make programs unstable, but when we are working on simple things like this, that should not be a concern?
To compute the number of unique elements in a numpy array, you can use unique(x).size or len(unique(x)) (see numpy.unique).  If you really want to make the calculation of the three lengths a "one-liner", you could write:In case it matters: for moderate to large arrays, unique(x) can be a lot faster than set(x), but for small arrays, set(x) is faster.  (I haven't explored the performance over a wide range of array sizes and data types, so I'll leave "large" and "small" undefined.  Test it yourself--but only if this code is a performance bottleneck.)
Python does not provide composition operator.How about using list comprehension?


Answer URL
