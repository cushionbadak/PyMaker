Natural Text
I need to determine the download or upload speed of a client PC during a FTP using ftp.retrbinary command.  How do I determine the speed in Mbps of each block download?
You can get the time at which the transfers starts by calling, e.g., datetime.datetime.now() before the transfer.You can get the time at which the transfer ends by calling it again after the transfer.If you subtract these, you get the time the download took. If you're using datetime objects, this is a timedelta.And you can get the number of bytes downloaded or uploaded either by, e.g., stating the file after transfer.So:If you want to get the speed while the transfer is still ongoing, you can't use the simple "upload a whole file in one go" commands, but almost any FTP library—including the stdlib's ftplib—will have a callback-driven or yield-driven API, or a way to supply your own file-like object, or some other way to "hook" the reading/writing of the local file. So, you can just do this exact same computation each time your hook gets called, using the current time and the total bytes so far (which you can keep track of) instead of at the end.If you want that, your next question will probably be, "how do I get the % done?" You can ask the server for the file size before download (via your favorite FTP library's wrapper around the SIZE command), and stat the local file before upload, and then each time your hook gets called, you just divide bytes so far by total size. (You may also want to write fallback code for servers that don't handle SIZE by doing a LIST and attempting to parse the two most typical formats. Or your FTP library may already have a way to do that.)Based on your example code, you've almost got things right, but there's a problem:You're just counting the time since the start of writing the current block of data to the disk. If you want time for each chunk, count from the end of one block to the end of the next; if you want average time so far, count from the start of the entire process. Either way, that means you need somewhere to store start_time between calls. Since you're already using a global variable for sizeWritten, you can just do the same here:If you want time/block, just add another start_time = time.mktime(time.localtime()) at the end of the callback function. If you want both, just create two variables, block_start_time and overall_start_time and only reset block_start_time at the end of the callback function.As a side note: You never close the file. This means there's no guarantee that the last block of data will ever get flushed to disk. It will usually work (at least with CPython), but occasionally you'll end up with truncated files. Always close anything you open, especially in write mode—or, better yet, use a with statement, as explained in the tutorial.Also, hiding the details of exceptions makes your code hard to debug, and harder for an end user to use. For example, whether your internet connection is down, the remote file is missing, or you don't have write access to the local file, it's all going to just show up as "Error". At least print the Exception or its repr, like this:


Answer URL
