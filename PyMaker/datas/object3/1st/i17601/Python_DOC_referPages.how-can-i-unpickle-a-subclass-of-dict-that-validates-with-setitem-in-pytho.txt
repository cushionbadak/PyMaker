Natural Text
I'm using python3.3. It's possible this problem doesn't exist in 2.x's pickle protocol, but I haven't actually verified.Suppose I've created a dict subclass that counts every time a key is updated. Something like this:You might use it like this:Now let's pickle and unpickle it:I think the print() in __setitem__ shows the problem: pickle.loads attempts to write the dictionary's keys before it writes the object's attributes... at least I think that's what's happening. It's pretty easy to verify if you remove the self.counter reference in Foo.__setitem__():Is this just a byproduct of the pickle protocol? I've tried variations on __setstate__ to let it unpickle correctly, but as far as I can tell, it hits the __setitem__ error before __setstate__ is even called. Is there any way I can modify this object to allow unpickling?
As stated by pickle documentation:When a pickled class instance is unpickled, its __init__() method is  normally not invoked.In your case you do want to invoke __init__. However since your class is a new-style class you cannot use __getinitargs__ (which isn't supported in python3 anyway). You could try to write your custom __getstate__ and __setstate__ methods:However this still doesn't work, because since you are subclassing dict and dict has a special handler for pickling, the __getstate__ method is called, however the __setstate__ method is not.You can work around this defining the __reduce__ method:
You are subclassing dict, and the pickle protocol will use the dedicated dict handler to store the keys and values in the resulting pickle data, using a different set of opcodes to restore these to your object again.As a result, __setstate__ is going only going to be called after restoring the dictionary keys, and the state contains only the counter attribute.There are two work-arounds here:Make your counter code resilient in the face of __init__ not being called:Here counter is a class attribute and thus always present. You could also use:to ensure there is a default value for the missing attribute.Provide a __newargs__ method; it can return an empty tuple, but specifying it ensures that __new__ is called when unpickling, which in turn could call __init__:Note that after __init__ is called, the unpickler still will set all the keys, then restore __dict__. self.counter will reflect the correct value in the end.Demos:1st approach:2nd approach:
You can add pickle support to your dictionary subclass by adding a__reduce__()method which will be used to get arguments to pass to a user defined function to reconstitute the object when it's unpickled. Although, since your class is adictsubclass,  not wasn't quite as trivial to implement as I originally thought, but it's fairly simple once I figured out what needed to be done. Here's what I came up with -- note that the _Foo_unpickle_helper()function can't be a regular, class, or static method ofFoo, so that's why it was defined at the module level:Output:


Answer URL
