Natural Text
I have a python class A with with statement and class B with with statement. Now it works like:How can I build a class C that wrap class A and class B so that I can call it like:   has the identical funtions
I'd like to suggest an alternative. You can initialise both a and b on the same line:This is more concise and reduces the amount of indentation in deeply nested code. However, if you absolutely must use a class, then override the __enter__ and __exit__ methods:And then use C inside a context manager like this:If you don't want to reference a and b, or if you don't plan on doing anything with them, thenWill also work. This should be enough to get started, but please note there are drawbacks as kindly mentioned by users in the comments. The main one being that if self._b.__enter__ throws errors, self._a.__enter__ will need to be cleaned up (this can be done using try-except-finally). Furthermore, some context managers may need to be treated differently based on what resource is being managed.
Short answer: it is possible. But context-managers allow to implement some logic, which makes it "tricky" to implemented it exactly the right way. Below you see a "Proof of Concept", but I do not guarantee that it has exactly the same behavior. Therefore I really advise to work with nested withs.What is not covered here: the __init__, or __enter__ can raise exceptions as well, and these are then handled by the "outer" context managers. This makes it of course rather complicated. You basically would need to "build" a stack in the __enter__, and then "pop" the stack in case one of the __enter__s fails. This scenario is not covered here.We can make a "composite" context manager:The __exit__ part is tricky. First of all, we need to exit in reverse order. But the exception handling is even more complicated: if an __exit__ silenced an exception, by returning a "truthful" value, then we should pass (None, None, None) as (exception_type, exeption_value, traceback), but a problem that can occur is that an __exit__ on the other hand triggers an exception itself, and thus then introduces a new exception.We can then use the context processor like:The above thus allows to implement a context manager for an arbitrary number of "sub-contextmanagers". We can subclass this to generate a specific one, like:and then use this as:But long story short: use nested with statements. It also makes it more explicit what is going on here. Right now the C encapsulate all sorts of logic, which are better made explicit. If entering B fails, then this should result in an exception that is handled by the __exit__ of A, etc. This makes it very cumbersome to get the "details" completely equivalent to the semantics of the with statement.
If your reason for doing this is to reduce indentation or merge the with statements, you don't need to. You can just doentering multiple context managers on a single line.If your C has other reasons to exist, you need to be careful about handling the case where one context manager fails after another context manager has been created and/or entered. contextlib.ExitStack can help you implement this robustly, or contextlib2.ExitStack if you're still on Python 2:


Answer URL
https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack
