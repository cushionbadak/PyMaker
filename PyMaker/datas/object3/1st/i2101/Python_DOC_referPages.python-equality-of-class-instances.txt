Natural Text
When writing custom classes it is often important to allow equivalence by means of the == and != operators. In Python, this is made possible by implementing the __eq__ and __ne__ special methods, respectively. The easiest way I've found to do this is the following method:Do you know of more elegant means of doing this? Do you know of any particular disadvantages to using the above method of comparing __dict__s?Note: A bit of clarification--when __eq__ and __ne__ are undefined, you'll find this behavior:That is, a == b evaluates to False because it really runs a is b, a test of identity (i.e., "Is a the same object as b?").When __eq__ and __ne__ are defined, you'll find this behavior (which is the one we're after):
Consider this simple problem:So, Python by default uses the object identifiers for comparison operations:Overriding the __eq__ function seems to solve the problem:In Python 2, always remember to override the __ne__ function as well, as the documentation states:There are no implied relationships among the comparison operators. The  truth of x==y does not imply that x!=y is false. Accordingly, when  defining __eq__(), one should also define __ne__() so that the  operators will behave as expected.In Python 3, this is no longer necessary, as the documentation states:By default, __ne__() delegates to __eq__() and inverts the result  unless it is NotImplemented. There are no other implied  relationships among the comparison operators, for example, the truth  of (x<y or x==y) does not imply x<=y.But that does not solve all our problems. Let’s add a subclass:Note: Python 2 has two kinds of classes:classic-style (or old-style) classes, that do not inherit from object and that are declared as class A:, class A(): or class A(B): where B is a classic-style class;new-style classes, that do inherit from object and that are declared as class A(object) or class A(B): where B is a new-style class. Python 3 has only new-style classes that are declared as class A:, class A(object): or class A(B):. For classic-style classes, a comparison operation always calls the method of the first operand, while for new-style classes, it always calls the method of the subclass operand, regardless of the order of the operands. So here, if Number is a classic-style class:n1 == n3 calls n1.__eq__;n3 == n1 calls n3.__eq__;n1 != n3 calls n1.__ne__;n3 != n1 calls n3.__ne__.And if Number is a new-style class:both n1 == n3 and n3 == n1 call n3.__eq__;both n1 != n3 and n3 != n1 call n3.__ne__.To fix the non-commutativity issue of the == and != operators for Python 2 classic-style classes, the __eq__ and __ne__ methods should return the NotImplemented value when an operand type is not supported. The documentation defines the NotImplemented value as:Numeric methods and rich comparison methods may return this value if  they do not implement the operation for the operands provided. (The  interpreter will then try the reflected operation, or some other  fallback, depending on the operator.) Its truth value is true.In this case the operator delegates the comparison operation to the reflected method of the other operand. The documentation defines reflected methods as:There are no swapped-argument versions of these methods (to be used  when the left argument does not support the operation but the right  argument does); rather, __lt__() and __gt__() are each other’s  reflection, __le__() and __ge__() are each other’s reflection, and  __eq__() and __ne__() are their own reflection.The result looks like this:Returning the NotImplemented value instead of False is the right thing to do even for new-style classes if commutativity of the == and != operators is desired when the operands are of unrelated types (no inheritance).Are we there yet? Not quite. How many unique numbers do we have?Sets use the hashes of objects, and by default Python returns the hash of the identifier of the object. Let’s try to override it:The end result looks like this (I added some assertions at the end for validation):
You need to be careful with inheritance:Check types more strictly, like this:Besides that, your approach will work fine, that's what special methods are there for.
The way you describe is the way I've always done it. Since it's totally generic, you can always break that functionality out into a mixin class and inherit it in classes where you want that functionality.
Not a direct answer but seemed relevant enough to be tacked on as it saves a bit of verbose tedium on occasion. Cut straight from the docs...functools.total_ordering(cls)Given a class defining one or more rich comparison ordering methods, this class decorator supplies the rest. This simplifies the effort involved in specifying all of the possible rich comparison operations:The class must define one of lt(), le(), gt(), or ge(). In addition, the class should supply an eq() method.New in version 2.7
You don't have to override both __eq__ and __ne__ you can override only __cmp__ but this will make an implication on the result of ==, !==, < , > and so on.is tests for object identity. This means a is b will be True in the case when a and b both hold the reference to the same object. In python you always hold a reference to an object in a variable not the actual object, so essentially for a is b to be true the objects in them should be located in the same memory location. How and most importantly why would you go about overriding this behaviour?Edit: I didn't know __cmp__ was removed from python 3 so avoid it.
From this answer: https://stackoverflow.com/a/30676267/541136 I have demonstrated that, while it's correct to define __ne__ in terms __eq__ - instead of you should use:
I think that the two terms you're looking for are equality (==) and identity (is). For example:
The 'is' test will test for identity using the builtin 'id()' function which essentially returns the memory address of the object and therefore isn't overloadable.However in the case of testing the equality of a class you probably want to be a little bit more strict about your tests and only compare the data attributes in your class:This code will only compare non function data members of your class as well as skipping anything private which is generally what you want. In the case of Plain Old Python Objects I have a base class which implements __init__, __str__, __repr__ and __eq__ so my POPO objects don't carry the burden of all that extra (and in most cases identical) logic.
Instead of using subclassing/mixins, I like to use a generic class decoratorUsage:


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__ne__
