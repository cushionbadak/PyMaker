Natural Text
It seems they canceled in Python 3 all the easy way to quickly load a script by removing execfile() Is there an obvious alternative I'm missing?
According to the documentation, instead of UseSee:Whatâ€™s New In Python 3.0
You are just supposed to read the file and exec the code yourself. 2to3 current replacesas(The compile call isn't strictly needed, but it associates the filename with the code object making debugging a little easier.)See:http://docs.python.org/release/2.7.3/library/functions.html#execfilehttp://docs.python.org/release/3.2.3/library/functions.html#compilehttp://docs.python.org/release/3.2.3/library/functions.html#exec
While exec(open("filename").read()) is often given as an alternative to execfile("filename"), it misses important details that execfile supported.The following function for Python3.x is as close as I could get to having the same behavior as executing a file directly. That matches running python /path/to/somefile.py.Notes:Uses binary reading to avoid encoding issuesGuaranteed to close the file (Python3.x warns about this)Defines __main__, some scripts depend on this to check if they are loading as a module or not for eg. if __name__ == "__main__"Setting __file__ is nicer for exception messages and some scripts use __file__ to get the paths of other files relative to them.Takes optional globals & locals arguments, modifying them in-place as execfile does - so you can access any variables defined by reading back the variables after running.Unlike Python2's execfile this does not modify the current namespace by default. For that you have to explicitly pass in globals() & locals().
As suggested on the python-dev mailinglist recently, the runpy module might be a viable alternative. Quoting from that message:https://docs.python.org/3/library/runpy.html#runpy.run_pathThere are subtle differences to execfile:run_path always creates a new namespace. It executes the code as a module, so there is no difference between globals and locals (which is why there is only a init_globals argument). The globals are returned.execfile executed in the current namespace or the given namespace. The semantics of locals and globals, if given, were similar to locals and globals inside a class definition.run_path can not only execute files, but also eggs and directories (refer to its documentation for details).
You could write your own function:If you really needed to...
This one is better, since it takes the globals and locals from the caller:
If the script you want to load is in the same directory than the one you run, maybe "import" will do the job ?If you need to dynamically import code the built-in function __ import__ and the module imp are worth looking at.test.py:If you're using Python 3.1 or later, you should also take a look at importlib.
Here's what I had (file is already assigned to the path to the file with the source code in both examples):Here's what I replaced it with:My favorite part: the second version works just fine in both Python 2 and 3, meaning it's not necessary to add in version dependent logic.
Note that the above pattern will fail if you're using PEP-263 encoding declarationsthat aren't ascii or utf-8. You need to find the encoding of the data, and encode it correctly before handing it to exec().
Also, while not a pure Python solution, if you're using IPython (as you probably should anyway), you can do:Which is equally easy.
I'm just a newbie here so maybe it's pure luck if I found this :After trying to run a script from the interpreter prompt >>> with the commandfor which I got a "NameError: name 'execfile' is not defined" I tried a very basic it worked well :-)I hope this can be helpful and thank you all for the great hints, examples and all those masterly commented pieces of code that are a great inspiration for newcomers ! I use Ubuntu 16.014 LTS x64.  Python 3.5.2 (default, Nov 17 2016, 17:05:23) [GCC 5.4.0 20160609] on linux


Answer URL
https://docs.python.org/3/library/runpy.html
https://docs.python.org/3/library/runpy.html#runpy.run_path
