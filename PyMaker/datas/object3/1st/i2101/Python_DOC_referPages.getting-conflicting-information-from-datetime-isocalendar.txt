Natural Text
I have a list that gives me the weekday (1-7 as if Monday-Sunday) and the week number for a given year. I need to convert that info to a given date.So, I wrote a simple script that takes three arguments:1. year2. weekday3. weeknumberand then finds out the date.My script basically iterates over all days of the given year, and creates a datetime object where I then extract isocalendar()[1] to compare it to the weeknumber.I found that if I give the input 2017 7 52 I get two outputs!In its most basic essence this is what happens:And the output is the same:How's that possible? That would mean that week 52 in year 2017 has two day #6, i.e., two different Sundays. This situation is causing problems for my script. Any idea on how to get around this? My original problem is that I have events given in YYYYMMDD and I need to group them by week# by year. So, that I can say that X number of events occurred on week#4 of year 2017. With the situation above it doesn't work when it comes down to week 52 since there's more than one solution to a YYYYMMDD.
You are mixing up ISO calendar years and Gregorian calendar years.  The date 2017-1-1 is day 7 of week 52 of year 2016 in the ISO calendar.  The ISO calendar defines the first week of an ISO calendar year to be the one containing the first Thursday of the corresponding Gregorian calendar year.  This could be anywhere from 1st to 7th January.  As ISO numbers days with Monday = 1 to Sunday = 7, this means that for up to three days around each New Year the Gregorian calendar year and ISO calendar year of a date do not agree. January 1st 2015 fell on a Thursday, so the Monday, Tuesday and Wednesday before it have ISO calendar year 2015 despite being in December 2014.  Similarly, January 7th 2016 fell on a Thursday, and Friday January 1st to Sunday January 3rd 2016 have ISO calendar year 2015 despite being in 2016.Your script appears to be taking a year in the Gregorian calendar, iterating through all days of this Gregorian calendar year and looking for the day with the matching day-of-week and ISO week-number.  What you have found out is that the three values (Gregorian year, ISO week-number ISO day-of-week) do not uniquely identify a date.  Your script needs to take into account the fact that ISO calendar years and Gregorian calendar years do not always agree and match on ISO calendar year instead of Gregorian calendar year.  One way to do this is to:include the last three days of the previous Gregorian calendar year and the first three days of the next Gregorian calendar year in the range of dates you search through, andas well as matching on ISO week number and ISO day of week, ensure that the ISO year matches too.  The ISO year is in dt.isocalendar()[0].Or, as an alternative, you could avoid the ISO calendar system altogether and instead consider something like the following:Given a year, month and day this will return the week-of-the-year and day-of-week, with weeks starting on Monday (as per time.struct_time) and week 1 being the week that January 1 falls in.  Weeks normally go up to 53 but if December 31 of a leap year falls on a Monday (as it did in 2012) this day will have week number 54.This works by using the date.timetuple() method to get the weekday and day-of-year of a date, plus also the day-of-the-week of January 1 of that year.  In the calculation of week, we:Subtract 1 from the day-of-the-year of the given date (daytuple.tm_yday), so that January 1 is 0, January 2 is 1 and so on.Add to this the day-of-the-week of January 1.  We do this because the day-of-the-week of January 1 is also the number of days in the first week of the year that are 'lost' to the previous year.  For example, if January 1 falls on a Wednesday, wday_of_jan_1 will be 2, the Monday and Tuesday before it will be missing from week 1 and hence the first week will only have 5 days in it.The calculations so far give us number of days between the given date and the first Monday on or before January 1.  We can then divide this by 7 to get the number of whole weeks since this Monday, and finally add 1 so that January 1 is in week 1 rather than week 0.This approach also avoids looping over an entire year's worth of dates and performing calculations on them.


Answer URL
https://docs.python.org/3/library/time.html#time.struct_time
https://docs.python.org/3/library/datetime.html#datetime.date.timetuple
