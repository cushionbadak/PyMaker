Natural Text
I've been reading about magic methods in python, and I've found a lot of info about overriding them   and what purpose they serve, but I haven't been able to find where in the language specific operators and actions are mapped to those methods (+ looks for __add__, += looks for __iadd__, creating a new object from a class might call __new__ and __init__, etc.)  Is there somewhere I can see what happens when the python interpreter (or whatever lower level mechanism) encounters a plus sign?  
Your question is a bit generic. There is a comprehensive list of "special methods", even though it misses some stdlib specific methods(e.g. __setstate__ and __getstate__ used by pickle etc. But it's a protocol of the module pickle not a language protocol).If you want to know exactly what the interpreter does you can use the dis module to disassemble the bytecode:You can see that the intereper executes a BINARY_ADD byte code when doing addition.If you want to see exactly the operations that BINARY_ADD does you can download Python's source code and check the ceval.c file:So here we can see that python special cases int and string additions, and eventually falls back to PyNumber_Add, which checks if the first operand implements __add__ and calls it, eventually it tries __radd__ of the right hand side and if nothing works raises a TypeError.Note that the byte codes are version-specific, so dis will show different results on different versions:Also the same byte code may be optimized in future versions, so even if the byte code is the same different versions of python will actually perform different instructions.If you're interested in learning how python works behind the scenes I'd advise you to write some C extensions, following the tutorials and documentation that you can find on the official python's website.
dis module can somewhat help you on this:let's take an example of simple list:
It's non-trivial to pinpoint the single place in CPython sources mapping operator + to special method __add__ because of the levels of abstraction involved.As other responded, + is implemented with the BINARY_ADD operand, which calls PyNumber_Add (except for some specially optimizedd cases). PyNumber_Add, on the other hand, looks at the tp_as_number member of the type object to get to the PyNumberMethods struct whose nb_add member points to the C function that implements addition.This is all clear for built-in types which define their own nb_add, but how does your __add__, defined in Python, translate to a function pointer stored in nb_add? This part is handled by typeobject.c: when you define a class that implements __add__, the machinery in typeobject.c installs into object->type->tp_as_number->nb_add a generic function that looks up __add__ on the object and calls it to implement the addition. For the case of __add__, this generic function is called slot_nb_add and is defined using the SLOT1BIN macro.As for __new__ and __init__, they are invoked from the __call__ operator of the type object itself (tp_call in CPython-implementation lingo). This is only logical, since in Python you are calling the type to construct an object.
http://docs.python.org/2/library/dis.htmlwhich returns something like thats the closest you will come to "low level"
You may want to check out this portion of the documentation:http://docs.python.org/3/reference/datamodel.html#special-method-names


Answer URL
