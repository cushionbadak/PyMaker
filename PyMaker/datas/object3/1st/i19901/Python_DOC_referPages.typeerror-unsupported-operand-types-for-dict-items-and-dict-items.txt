Natural Text
I try to sum two dictionaries like that:but recieve error What I do wrong?
In python3, dict.items() returns an object with type dict_items which apparently can't be added.  (in python 2, it returned a list which could be added).An alternative way to add a pair of dictionaries which works on py2k and py3k:Of course, there's some ambiguity about what you want to happen in the case of key collisions.  e.g. if both dicts have key1, whose key1 should be preserved in the output?  Or should you use some combination of both of their values?  In the latter case, you'll probably want something from the collections module (either defaultdict or Counter)
Since PEP 448 (Python 3.5), there is a very simple and readable solution I would recommend:You can now provide unpackings into literals and multiple unpackings, which means this works. One problem is the behavior you want is ambiguous - dictionaries can't have duplicate keys, so it is unclear what you want to happen if both contain the same key. The spec is explicit about what should happen when using this method:In dictionaries, later values will always override earlier onesIf you want the reverse behaviour, you can simply swap the order of the dictionaries in the literal. If you want to throw an exception, you can use the dict() method which won't accept duplicate arguments, i.e:In older versions of Python 3, your approach is valid, but the issue here is that dictionary views are set-like, so they don't have addition implemented.What you probably want is the union: d1.items() | d2.items(), which will give you a set of tuples of (key, value). If you then pass it to dict() and there are duplicates, the "last" value will be the one used, however sets (unlike the views themselves) are unordered, so there is no guarantee about which item will end up "first" in the combined set, meaning that which one "wins" will be arbitrary.So, in short, as long as order/duplicate selection isn't important:Note that in Python 2, dict.items() simply returns a list, where your approach will work.
Another approach to the other suggested answers is:dict(list(d1.items()) + list(d2.items()))If there are keys present in both d1 and d2, the value in d2 will be used in the final dictionary.


Answer URL
https://docs.python.org/3/library/stdtypes.html#frozenset.union
