Natural Text
I am creating a class in which I want to generate a temporary workspace of folders that will persist for the life of the object and then be removed.  I am using tempfile.mkdtemp() in the def init to create the space, but I have read that I can't rely on del being called.I am wanting something like this:Is there another/better way to handle this clean up?  I was reading about 'with' but it appears to only be helpful within a function.
Caveat: you can never guarantee that the temp folder will be deleted, because the user could always hard kill your process and then it can't run anything else.That said, doSince this is a very common operation, Python has a special way to encapsulate "do something, execute code, clean up": a context manager. You can write your own as follows:and use it as(Note that this uses the @contextlib.contextmanager shortcut to make a context manager. If you want to implement one the original way, you need to make a custom class with __enter__ and __exit__ methods; the __enter__ would create and return the temp directory and the __exit__ delete it.
A nice way to deal with temporary files and directories is via a context manager. This is how you can use tempfile.TemporaryFile or tempfile.NamedTemporaryFile -- once you've exited the with statement (via normal exit, return, exception, or anything else) the file/directory and it's contents will be removed from the filesystem.For Python 3.2+, this is built in as tempfile.TemporaryDirectory:For earlier Python versions you can easily create your own context manager to do exactly the same thing. The differences here from @katrielalex answer are the passing of args to mkdtemp() and the try/finally block to make sure the directory gets cleaned up if an exception is raised.Note that if your process is hard-killed (eg. kill -9) then the directories won't get cleaned up.
As stated by Bluewind you have to make sure to wrap the yield portion of the context manager inside of a try: finally statement otherwise any exceptions will not really be handled correctly inside of the context manager.From Python 2.7 docsAt the point where the generator yields, the block nested in the with statement is executed. The generator is then resumed after the block is exited. If an unhandled exception occurs in the block, it is reraised inside the generator at the point where the yield occurred. Thus, you can use a try...except...finally statement to trap the error (if any), or ensure that some cleanup takes place. If an exception is trapped merely in order to log it or to perform some action (rather than to suppress it entirely), the generator must reraise that exception. Otherwise the generator context manager will indicate to the with statement that the exception has been handled, and execution will resume with the statement immediately following the with statement.Also if you are using Python 3.2+ you should check out this little gem which has all of the above wrapped up nicely for youtempfile.TemporaryDirectory(suffix='', prefix='tmp', dir=None)This function creates a temporary directory using mkdtemp() (the supplied arguments are passed directly to the underlying function). The resulting object can be used as a context manager (see With Statement Context Managers). On completion of the context (or destruction of the temporary directory object), the newly created temporary directory and all its contents are removed from the filesystem.The directory name can be retrieved from the name attribute of the returned object.The directory can be explicitly cleaned up by calling the cleanup() method.New in version 3.2.
Another alternative using contextlib is to make your object closable, and use the closing context manager.Then with the context manager:
Other answers have noted that you can use a contextmanager or require your users to explicitly call some type of clean up function. These are great to do if you can. However, sometimes there's no where to hook up this cleanup because you are inside a large application and you are nested multiple layers down, and no one above you has cleanup methods or context managers.In that case, you can use atexit: https://docs.python.org/2/library/atexit.html


Answer URL
https://docs.python.org/3/library/tempfile.html
