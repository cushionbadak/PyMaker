Natural Text
I've defined a class with 5 instance variablesI want to ensure:rating is an intname is a strlat, long, elev are floatsWhen reading my input file, everything works creating a list of objects based on my class. When I start comparing values I got weird results since the instance variables were still strings.Is the "most Pythonic way" to cast the values as the object is being created using int(string) and float(string) when calling the constructor or should this casting be done with logic inside the class?
If you type import this in the Python interpreter, you will get "The Zen of Python, by Tim Peters". The first three lines seem to apply to your situation:I would recommend implementing your class like this:This is the implementation you mention in your question. It is simple and explicit. Beauty is in the eye of the beholder.Responses to CommentsThe implementation is explicit to the writer of the class versus some other solution that hides the type conversion behind some opaque mechanism.There is a valid argument that it is not obvious from the function signature what the expected parameter types are. However, the question implies that all parameters are passed as strings. In that case, the expected type is str for all the constructor parameters. Perhaps the question title does not clearly describe the problem. Maybe a better title would be "Enforce Instance Variable Types When Passing Strings as Parameters to Constructor".
Personally, I would do any string parsing before passing the values to the constructor, unless parsing is one (or the) explicitly stated responsibility of the class. I prefer my program to fail because I didn't explicitly cast a value than to be too flexible and end up in a Javascript-like 0 == "0" situation. That said, if you want to accept strings as parameters you can just call int(my_parameter) or float(my_parameter) as needed in the constructor and that will make sure this are numbers not matter you pass a number, a string or even a Boolean.In case you want to know more about type safety in Python, you can take a look at type annotations, which are supported by type checkers like mypy, and the traits package for type safety in class attributes.
EDIT: (edit because the topic of the question changed) I would not recommend convert type of parameters at init time. For example:In my opinion, This type of Implicit conversion is dangerous for few reasons. Implicitly converts parameter type to another without giving warning is very misleading It won't raise any exceptions if users pass in undesired type. This goes hand in hand with the implicit casting. This could be avoided using explicit type checking.Silently convert type violates duck-typingInstead of convert type of parameters, it is better to check the parameter type at init time. This approach would avoid the above three issues. To accomplish this you may use the strong type checking from typedecorator I like it because it is simple and very readableFor Python2 [edit: leaving this as a reference as OP requested]For Python3 you can use the annotation syntax:throws an error:TypeError: argument name = 5 doesn't match signature str
Seems like there's a million ways to do this, but here's the formula I use:A thing that's nice about this: you can directly use a re.groupdict() to produce your dict (as an example):parsed = re.search('(?P<name>\w): Latitude: (?P<lat>\d+), Longitude: (?P<long>\d+), Elevation: (?P<elev>\d+) meters. (?P<rating>\d)', some_string).groupdict()
Define custom field typesOne way is to define your own field types and do the conversion and error handling in them. The fields are going to be based on descriptors. This is something you're going to find in Django models, Flask-SQLAlchemy, DRF-Fields etcHaving such custom fields will allow you to cast them, validate them and this will work not just in __init__, but anywhere we try to assign a value to it.Demo:Use a static analyzerAnother option is to use static analyzers like Mypy and catch the errors before the program gets executed. The code below is using Python 3.6 syntax, but you can make it work with other versions as well by making some changes.When we run Mypy on this we get:
In Python 3.5+ you can use type hints and the typing module.Note that these are just hints. Python doesn't actually do anything with them like showing an error if the wrong type is used.
You said that you cannot use 3rd-party libraries, but others finding this question might. The typeguard is worth mentioning here.BTW. by default the decorator is disabled when Python is run in optimized mode (-O)! And it is easy to disable the checks when you're sure they're not needed. BTW. Perhaps the lat, long, elev should be numbers.Real with cast inside the constructor to float ;)
Even without relying on external libraries you can define your own simple typechecking decorator in just a few lines. This uses the inspect module from Core-Python to get the parameter names, but even without it you could just zip the args with a list of types, although this will make using kwargs difficult.Instead of printing a warning, you could of course also raise an exception.  Or, using the same approach, you could also just (try to) cast the parameters to the expected type:Or a simpler version, without inspect, but not working for kwargs and requiring to provide the type for each parameter, including self (or None for no type cast):


Answer URL
https://docs.python.org/3/library/typing.html
https://docs.python.org/3/howto/descriptor.html
https://docs.python.org/3/library/typing.html
