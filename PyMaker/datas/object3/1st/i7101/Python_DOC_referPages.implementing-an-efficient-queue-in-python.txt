Natural Text
I have been trying to implement a queue in Python, and I've been running into a problem. I am attempting to use lists to implement the Queue data structure, however I can't quite figure out how to make enqueue and dequeue O(1) operations. Every example I have seen online, seems to just append the enqueue operation and remove the first element from the list for the dequeue operation. But this would make the dequeue operation O(n) (where n is the size of the list) correct?Is there something basic I have missed? Or do you have to use LinkedLists to implement a Queue efficiently? 
As Uri Goren astutely noted above, the Python stdlib already implemented an efficient queue on your fortunate behalf: collections.deque.What Not to DoAvoid reinventing the wheel by hand-rolling your own:Linked list implementation. While doing so reduces the worst-case time complexity of your dequeue() and enqueue() methods to O(1), the collections.deque type already does so. It's also thread-safe and presumably more space and time efficient, given its C-based heritage.Python list implementation. As I note below, implementing the enqueue() methods in terms of a Python list increases its worst-case time complexity to O(n). Since removing the last item from a C-based array and hence Python list is a constant-time operation, implementing the dequeue() method in terms of a Python list retains the same worst-case time complexity of O(1). But who cares? enqueue() remains pitifully slow.To quote the official deque documentation:Though list objects support similar operations, they are optimized for fast fixed-length operations and incur O(n) memory movement costs for pop(0) and insert(0, v) operations which change both the size and position of the underlying data representation.More critically, deque also provides out-of-the-box support for a maximum length via the maxlen parameter passed at initialization time, obviating the need for manual attempts to limit the queue size (which inevitably breaks thread safety due to race conditions implicit in if conditionals).What to DoInstead, implement your Queue class in terms of the standard collections.deque type as follows:The proof is in the hellish pudding:It Is Dangerous to Go AloneActually, don't do that either.You're better off just using a raw deque object rather than attempting to manually encapsulate that object in a Queue wrapper. The Queue class defined above is given only as a trivial demonstration of the general-purpose utility of the deque API.The deque class provides significantly more features, including:...iteration, pickling, len(d), reversed(d), copy.copy(d), copy.deepcopy(d), membership testing with the in operator, and subscript references such as d[-1].Just use deque anywhere a single- or double-ended queue is required. That is all.
You can keep head and tail node instead of a queue list in queue class
Queue implementation using list in Python, handling enqueue and dqueue as per inbuild queue data structure:
In dequeue method there is no any loop. You only have to do list operations. Therefore the time complexity for dequeue is also O(n)(linear).


Answer URL
https://docs.python.org/3/library/collections.html#deque-objects
https://docs.python.org/3/library/collections.html#deque-objects
https://docs.python.org/3/library/collections.html#deque-objects
