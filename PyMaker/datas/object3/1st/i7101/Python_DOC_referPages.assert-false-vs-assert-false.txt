Natural Text
A recent coding error of mine has made me think...I have been using assert false instead of assert False in one of my functions.This function is invoked only inside try/except clauses.So I never noticed this "compilation error", until I actually printed the details of the exception.Then it made me wonder if there were any runtime differences between the two.Of course, the "false" here can be replaced with any other undefined symbol.Obviously, the printouts themselves would be different.Here's a simple test that I conducted:The printout of this test is:So my question is, are there any other runtime differences here? In particularly, I am interested to know if using assert(false) over assert(False) could somehow hinder the performance of my program.
Both versions are wrong and should never be used.assert false, ...: the assert statement is never reached, because the false expression raises a NameError exception. That smells of a bug in your code, and not of a deliberate act on your behalf.Never use deliberate errors to raise an exception. You'd have to add a comment explaining why you did this to future maintainers of the code, but there never should be a reason to use this, because better alternatives exist.assert False, ...: this is a deliberate assertion failure, and looks like an attempt at debugging and not production code. Make your assertions before code that could fail if the assertion doesn't hold instead. If you need to have an exception exit your code at that point, raise an exception.Be explicit. Raise an exception. Even raising an AssertionError exception is better:From the two versions you should never ever use, in Python 3 assert(False, ...) is 'faster' because at least doesn't trigger a global name search. That's because in Python 3, False is a keyword and the compiler can thus optimise it by referencing a constant. However, there is little actual difference between the two. Since a deliberately failing assertion should by design never be reached, or reached at most once, worrying about how they perform is rather a moot point.
It's not a compilation error, both are runtime errors, and obviously there are differences: Evaluating false produced a NameError, meaning you referred to an undefined name. It's possible for another code path to cause the name to be defined, in which case the assertion might not fail. The trivial example would be a false = True statement above it (which obviously would be horrible in another way, with such a poor variable name). Either way it is a logic error that a code path that doesn't define the name can reach the expression. Asserting False is a way to force an AssertionError to be thrown. It's a pretty bad technique because you've added explicit code to fail without any sort of explanation why; we can't interpret the error and have to locate it in the code to figure out why it happened. Assertions should have both logical expressions and descriptions to assist in the debugging they're for. Either way, the way you've handled any exception loses lots of information. In particular, anything about where within the try the error occurred. A normal exception traceback (which can be accessed with traceback.print_exception and its ilk) contains this information in detail. In effect, this style of handling both assert and try-catch is preventing you from receiving useful information on any error except compilation time errors like SyntaxError and ImportError. The only sensible use of assert False I can think of it to test the assert statement itself. In all normal use we include the condition for failure. 


Answer URL
https://docs.python.org/3/library/exceptions.html#AssertionError
https://docs.python.org/3/library/traceback.html#traceback.print_exception
https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement
