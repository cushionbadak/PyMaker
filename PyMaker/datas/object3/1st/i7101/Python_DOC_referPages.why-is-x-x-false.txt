Natural Text
The title is a bit misleading, because it's not exactly x and x, it's x and 0.3; however, the values should be the same.I have:and I receive:The correct result should be:I have not yet stumbled upon this problem. I know it is related to floating point precision ... but what can I do here?
Don't rely on comparing floats for equality (unless you know exactly what floats you are dealing with).Since you know the stepsize used to generate the array is 0.1,you could increase the threshold value, 0.3, by half the stepsize to find a new threshold which is safely between values in arr:By the way, the 1.1 in np.arange(0, 1.1, 0.1) is an application of the same idea -- given the vagaries of floating-point arithmetic, we couldn't be sure that 1.0 would be included if we wrote np.arange(0, 1.0, 0.1), so the right endpoint was increased by the stepsize.Fundamentally, the problem boils down to floating-point arithmetic being inaccurate:So the fourth value in the array is a little bit greater than 0.3.Note that rounding may not be a viable solution. For example,if arr has dtype float128:Although making the dtype float128 made arr[3] closer to the decimal 0.3,now rounding does not produce a number less than 0.3:
Unutbu points out the main problem. You should avoid comparing floating point numbers, as they have a round off error.However this is a problem many people come across, therefore there is a function that helps you getting around this problem; np.isclose in your case this would lead to:In this case this might not be the best option, but it might be helpful to know about this function.Sidenote:In case nobody has ever explained to you, why this happens. Basically computer save everything in binary, however 0.1 is a periodic number in binary, this means that the computer can't save all the digits (as there are infinitely many). The equivalent in decimal would be:1/3+1/3+1/3 = 0.33333 + 0.33333 + 0.33333 = 0.99999Which is not 1


Answer URL
https://docs.python.org/3/faq/design.html#why-are-floating-point-calculations-so-inaccurate
