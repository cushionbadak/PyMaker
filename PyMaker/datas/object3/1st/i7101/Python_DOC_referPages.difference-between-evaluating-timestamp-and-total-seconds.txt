Natural Text
When I evaluate the number of seconds between two dates using two different methods (either using timestamp() or total_seconds()) in datetime in python, I get different results. Why is this? Or what am I doing wrong? Here is an example of what I mean.The answers I get are:13993200.013996800.0
The discrepancy is caused by Daylight Savings Time. If one of your dates falls in your timezone's DST range, and the other does not, you end up with an off-by-one hour error in your calculation.From 1966 to 1973, DST in the United States ran from the last Sunday in April to the last Sunday in October, which explains @JoshuaRLi's findings.It looks like, when subtracting two dates, it's not paying attention to DST discrepancies; t1 - t2 produces datetime.timedelta(162), a difference of 162 days, even though technically, the difference in hours would be 162 * 24 - 1 hours (the - 1 accounting for the DST skip). timestamp is handling this (both timestamps are relative to UTC, so the DST timestamp correctly shows as one hour earlier, because there was an hour skipped to produce it).
Daylight Savings TimeThe subtraction magic method of two dt.datetime objects creates a dt.timedelta that is not concerned with Daylight Savings Time.The epoch timestamp conversion function takes Daylight Savings Time into account, which explains the 3600 second (1 hour) difference.See my detective post below. This was fun!Whipped up a quick script, since this seemed interesting to me.This was run on both 3.5.4 and 3.6.2 with the same output.I got this output. Looks like it starts on 4/27, and the difference is consistently an hour, meaning that the jump only happens once (actually never mind, keep reading)I wrote a second script:Output:When you remove the exit(1), the output becomes interesting:Looks like epoch timestamp conversion t.timestamp() - prev.timestamp() isn't reliable. What's more, it appears to oscillate from minus to plus one hour at what appears to be a somewhat irregular but spaced out date interval (EDIT: realized these were historical Daylight Savings Time dates). If you keep the script running, the oscillation holds forever until we reach the end times:This behavior prompted me to take a closer look at the output of my first script:Wow, so there are no AssertionErrors between 1970-10-25 and 1971-04-26 noninclusive. This matches the oscillation found with the second script. This is getting really weird...Wait a moment... DAYLIGHT SAVINGS TIME
.timestamp only works in Python 3 (New in version 3.3). There is no such method in Python 2.Changed in version 3.6: The timestamp() method uses the fold attribute to disambiguate the times during a repeated interval.Note: There is no method to obtain the POSIX timestamp directly from a naive datetime instance representing UTC time. If your application uses this convention and your system timezone is not set to UTC, you can obtain the POSIX timestamp by supplying tzinfo=timezone.utc:  timestamp = dt.replace(tzinfo=timezone.utc).timestamp()  or by calculating the timestamp directly:  timestamp = (dt - datetime(1970, 1, 1)) / timedelta(seconds=1)


Answer URL
https://docs.python.org/3/library/datetime.html#datetime.datetime.timestamp
https://docs.python.org/3/library/datetime.html#datetime.datetime.timestamp
