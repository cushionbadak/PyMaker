Natural Text
The following never prints anything in Python 3.6Instead, it just sits there and burns CPU. The issue seems to be that product never returns an iterator if it's over an infinite space because it evaluates the full product first. This is surprising given that the product is supposed to be a generator.I would have expected this to start counting up (to infinity), something like the behavior of this generator (taken directly from the docs):But whereas my generator starts counting immediately, the one using product never counts at all.Other tools in itertools do what I'd expect. For example, the following:will print a stream of numbers because takewhile is lazy.
itertools.product generates its results lazily, but this is not true for the arguments. They are evaluated eagerly. Each iterable argument is first converted to a tuple:The evaluation of the arguments (not the production of results) is very similar to the Python implementation shown in the docs:Whereas, in the CPython implementation, pools is a tuple of tuples:This is so since product sometimes needs to go over an iterable more than once, which is not possible if the arguments were left as iterators that can only be consumed once.You practically cannot build a tuple from an itertools.count object. Consider slicing to a reasonable length with itertools.islice before passing to product.
The issue seems to be that product never returns an iteratorNo, product is already "lazy".The issue is thatcount() counts to infinity. From count's docs:Equivalent to:You code is basically the same as doing:
I found that does what I expect. This is odd given that it is listed as equivelent in the docs. This seems like a bug in itertools.product, but it seems unlikely given how standard it is.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.product
