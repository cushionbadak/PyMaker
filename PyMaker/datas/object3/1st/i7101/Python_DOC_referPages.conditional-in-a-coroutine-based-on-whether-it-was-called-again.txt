Natural Text
I am trying to translate this key "debouncing" logic from Javascript to Python. The idea is that subsequent key presses extend the timeout. The Javascript version prints:I don't want to translate the JS timeout functions, I'd rather have idiomatic Python using asyncio. My attempt in Python (3.5) is below, but it doesn't work as global_state is not actually updated when I expect.It prints: I have looked into asyncio Event, Queue and Condition but it isn't clear to me how to use them for this. How would you implement the desired behavior using Python's asyncio? EDITSome more details on how I'd like to use handle_keys. I have an async function that checks for key presses.Which in turn is scheduled along with other program tasksQeek's use of asyncio.create_task and asyncio.gather makes sense. But how would I use it within a loop like this? Or is there another way to schedule the async tasks that would allow handle_keys calls to "overlap"? Actual code on GitHub if you are interested.
What's wrongBasically the yield from xy() is very similar to the normal function call. The difference between function call and yield from is that the function call immediately start processing called function. The yield from statement insert called coroutine into queue inside event loop and give control to event loop and it decide which coroutine in it's queue will be processed.Here is the explanation of what you code does:It adds the main into event loop's queue.The event loop start processing coroutine in the queue.The queue contains only the main coroutine so it starts that.The code hits the yield from handle_key('a').It adds the handle_key('a') in the event loop's queue.The event loop now contains the main and handle_key('a') but the main cannot be started because it is waiting for the result of the handle_key('a').So the event loop starts the handle_key('a').It will do some stuff until it hits the yield from asyncio.sleep(0.5).Now the event loop contains main(), handle_key('a') and sleep(0.5).The main() is waiting for result from handle_key('a').The handle_key('a') is waiting for result from sleep(0.5).The sleep has no dependency so it can be started.The asyncio.sleep(0.5) returns None after 0.5 second.The event loop takes the None and return it into the handle_key('a') coroutine.The return value is ignored because it isn't assign into anythingThe handle_key('a') prints the key (because nothing change the state)The handle_key coroutine at the end return None (because there isn't return statement).The None is returned to the main.Again the return value is ignored.The code hits the yield from handle_key('b') and start processing new key.It run same steps from step 5 (but with the key b).How to fix itThe main coroutinr replace with this:The loop.create_task adds into the event loop's queue the handle_key('a') and handle_key('b') and then the yield from asyncio.gather(a_task, b_task) give control to the event loop. The event loop from this point contains handle_key('a'), handle_key('b'), gather(...) and main().The main() wiating for result from gather()The gather() waiting until all tasks given as parameters are finishedThe handle_key('a') and handle_key('b') has no dependencies so they can be started. The event loop now contains 2 coroutine which can start but which one will it pick? Well... who knows it is implementation depended. So for better simulation of pressed keys this one replace should be a little better:Python 3.5 bonusFrom the documentation:Coroutines used with asyncio may be implemented using the async def statement.The async def type of coroutine was added in Python 3.5, and is recommended if there is no need to support older Python versions.It means that you can replace: with newer statementIf you start using the new syntax then you have to also replace yield from with await.
Why your code doesn't work now?Both handle_key javascript functions don't block execution. Each just clear timeout callback and set new one. It happens immediately.Coroutines work another way: using yield from or newer syntax await on coroutine means that we want to resume execution flow only after this coroutine if fully done:asyncio.sleep(0.5) in your code - is not setting callback by timeout, but code that should be done before handle_key finsihed.Let's try to make code workYou can create task to start execution some coroutine "in background". You can also cancel task (just like you do with clearTimeout(this.timeout)) if you don't want it to be finished.Python version that emulates your javascript snippet:Idiomatic?While code above works, it is not how asyncio should be used. Your javascript code based on callbacks, while asyncio usually is about to avoid using of callbacks.It's hard to demonstrate difference on your example since it's callback based by nature (key handling - is some sort of global callback) and doesn't have more async logic. But this understanding would be important later when you'll add more async operations.Right now I advice you to read about async/await in modern javascript (it's similar to Python's async/await) and look at examples comparing it to callbacks/promises. This article looks good.It'll help you understand how you can use coroutine-based approach in Python.Upd:Since buttons.check needs to periodically call driver.get_buttons() you'll have to use loop. But it can be done as task along with your event loop.If you had some sort of button_handler(callback) (this is usually how different libs allow to handle user input) you could use it to set some asyncio.Future directly and avoid loop.Consider possibility write some little gui app with asyncio from the beginning. I think it may help you to better understand how you can adapt your existing project.Here's some pseudo-code that shows background task to handlebuttons and using asyncio to handle some simple UI events/states logic:.


Answer URL
https://docs.python.org/3/reference/compound_stmts.html#async-def
https://docs.python.org/3/library/asyncio-task.html#task
https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.cancel
