Natural Text
I am looking for an algorithm that takes 2 inputs (#1: a number, #2: an array of numbers [that may be duplicated]):Output should be the desired groups (with the individual numbers from the original list in them). The groups should be as close in length/size. Note that if a number is in one group, all other items in the list with the same number would be put in that same group. (e.g. so you would not have the number 3 say in multiple output groups).NOTE that elements in returned groups MUST not overlap in their range of numbersSo you cannot have two output groups like this [[1,1,1,2,2,4,4,4], [3,3,5,5,6,7,8,16]] because the range of numbers in each subgroup is [1-4] and [3-16], which have an overlap. You can only have groups like [1-3][4-16] (note there is no overlap in this case).Sample #1 Input/OutputOutput: Sample #2 Input/OutputInput 2 desired groups/subarrays to be output, and the following list of numbers:Output are two subarrays that contain the following:Note #1: Output two subarrays/groups of [[1,1,1,2,2,3,3] [4,4,4,5,5,6,7,8,16]] would also be valid given that there is no way to output equal groups.Note #2: While subgroups of: [[1,1,1,2,2,4,4,4], [3,3,5,5,6,7,8,16]] would be equal in length, it violates the rule of "no overlapping ranges between returned subgroups", meaning the range of numbers in each subgroup cannot overlap with each other. (e.g. In this note, the ranges of the subgroups returned are [1-4] and [3-16], if you took a ruler and drew a line from the numbers 1-4 and draw another line from 3-16, you would see that 3-4 would have overlapping lines, which is not what we want in this case). In the sample output of this example, the ranges of the two groups are [1-4] and [5-16], which if you took a ruler/tape measure and drew lines where the numbers are, the lines would not overlap with each other, which is what we want.Sample #3 Input/OutputInput 3 desired groups/subarrays to be output, and the following list of numbers:Output:Note in this case, since there is no way to achieve the same # of items, algorithm outputs the best it can do where one group is only 1 bigger than the others.Sample #4 Input/OutputInput: "4 desired groups", and the following list:[1, 1, 1, 2, 2, 3, 3, 4, 4, 4, 5, 5, 6, 7, 8, 16] Possible Output:Note: Preferrably, the output should contain more than 1 unique number when possible. While an output of [[1, 1, 1], [2, 2, 3, 3], [4, 4, 4, 5, 5], [6, 7, 8, 16]] does provide approximately similar groupings, it is preferred that there is more than 1 unique number in a single subgroup. In this "Note", 1 is the only number in group 1, while in the sample output of this example, group 1 contains unique numbers 1 and 2, which is preferred.What is a good way to perform this?
Grouping common numbers then using a recursive functionMy last solution didn't give the right results, so this is a different algorithm. It follows:group the list into sub-lists of common numberscheck if this list has the required number of groups (sub-lists)if it does then add it to a list of possible solutions and endelse, create a list of all the different pairs of common numbers in the current list merged togetherfor each list in (4), go back to (2)If you followed the algorithm, you can see that it will work by branching off down the differently merged lists until it reaches one of the required length where that branch will end. This is a perfect opportunity to write a recursive function.But before that, we needed a small method for grouping common numbers from the original list. To do this, a small for-loop goes through each number and check if it belongs as part of the previous common numbers. If it does, add it to them, or else it creates its own common numbers.This may look something like:now groups is:so we are ready for the recursive funtion:the function is self-explanatory, but the list-comprehension is the important part which controls the branching:It is essentially saying: for each number up to the length of the current list, take the common number groups before it grps[:i], add them onto its common numbers grps[i] merged with the next common numbers grps[i+1] and then add that onto the rest of the common numbers grps[i+2:]. From there, we just set the function going with each of the different merged common number combinations along with its target number of groups.The final codeThe final code put together would be:which outputs:SortingNow that you have ALL the possible solutions, you can sort them any way you want. So for example, if you wanted to select the one with the most even spread in length in the group, you would calculate each groups length and the difference between smallest and biggest lengths would be the score on which you rank them.Even though there are other ways of sorting them, as we have seen in the comment section, the one described above seems to be what most people want so here it is:and for my example with list:we have the result:which I would consider to be the best solution in this case. And finally, to check with the examples given in the question:Sample 1gives output of:Sample 2gives output of:So it is clear this algorithm works and I hope this helps.
You can use .map() and .filter() to create an array of arrays containing the same elements, collect values of arrays where there is single element to a single array, if they exist, .splice() expected number of arrays (groups) from collected array, reinsert original single values into to groups, return result
We can use itertools.groupby to group the duplicated items together, and then use a simple "greedy"  algorithm to assign each group to a sublist. If we have any leftover items at the end of the main loop, we put them in a new sublist unless we've already reached the desired number of sublists, in which case we simply add the leftovers to the last existing sublist.The result isn't perfect: depending on the data, it may not even create enough sublists, but with well-behaved data the results are reasonable, IMHO. ;)output


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.groupby
