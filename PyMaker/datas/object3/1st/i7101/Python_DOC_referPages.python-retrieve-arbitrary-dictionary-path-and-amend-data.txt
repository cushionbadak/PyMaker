Natural Text
Simple Python question, but I'm scratching my head over the answer!I have an array of strings of arbitrary length called path, like this:I also have a dictionary, data, and a string, unwanted_property. I know that the dictionary is of arbitrary depth and is dictionaries all the way down, with the exception of the items property, which is always an array. [CLARIFICATION: The point of this question is that I don't know what the contents of path will be. They could be anything. I also don't know what the dictionary will look like. I need to walk down the dictionary as far as the path indicates, and then delete the unwanted properties from there, without knowing in advance what the path looks like, or how long it will be.]I want to retrieve the parts of the data object (if any) that matches the path, and then delete the unwanted_property from each. So in the example above, I would like to retrieve:and then delete unwanted_property from each of the items in the array. I want to amend the original data, not a copy. (CLARIFICATION: By this I mean, I'd like to end up with the original dict, just minus the unwanted properties.)How can I do this in code? I've got this far:The problem is that this doesn't amend the original data. It also relies on items always being the last string in the path, which may not always be the case.CLARIFICATION: I mean that I'd like to end up with:Whereas what I have available in data is only [{'name': '114th Street'}, {'name': '8th Avenue'}].I feel like I need something like XPath for the dictionary. 
The problem you are overwriting the original data reference. Change your processing code toIn this version, you set temp to point to the same object that data was referring to. temp is not a copy, so any changes you make to it will be visible in the original object. Then you step temp along itself, while data remains a reference to the root dictionary. When you find the path you are looking for, any changes made via temp will be visible in data.I also removed the line data = [i for i in data[p]]. It creates an unnecessary copy of the list that you never need, since you are not modifying the references stored in the list, just the contents of the references.The fact that path is not pre-determined (besides the fact that items is going to be a list) means that you may end up getting a KeyError in the first loop if the path does not exist in your dictionary. You can handle that gracefully be doing something more like:
The problem you are facing is that you are re-assigning the data variable to an undesired value. In the body of your for loop you are setting data to the next level down on the tree, for instance given your example data will have the following values (in order), up to when it leaves the for loop:Then when you delete the items from your dictionaries at the end you are left with data being a list of those dictionaries as you have lost the higher parts of the structure. Thus if you make a backup reference for your data you can get the correct output, for example:

You need to remove the key unwanted_property.This will remove the key. The second parameter None is returned if the key unwanted_property does not exist.EDIT:You can use pop even without the second parameter. It will raise KeyError if the key does not exist. EDIT 2: Updated to recursively go into depth of data dict until it finds the items key, where it pops the unwanted_property as desired and append into the names_list list to get the desired output.
Using operator.itemgetter you can compose a function to return the final key's value.Then use it like this:Of course if the path contains non-existent keys it will throw a KeyError - you probably should account for that:
You can try this:Output:


Answer URL
https://docs.python.org/3/library/operator.html#operator.itemgetter
