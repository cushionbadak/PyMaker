Natural Text
I have a list like this:    #[YEAR, DAY, VALUE1, VALUE2, VALUE3]and I need to group by years and days, to obtain something like:How can I do that with itertool?, I can't use pandas or numpy because my system doesn't support it. Thanks a lot for your help.
itertools.groupby doesn't work like SQL's GROUPBY. It groups in-order. This means that if you have a list of elements that are not sorted, you may get multiple groups on the same key. So, let's say you want to group a list of integers based on their parity (even vs odd), then you might do this:Now, if you come from an SQL world, you might think that this gives you two groups - one for the even numbers, and one for the odd numbers. While this makes sense, it is not how Python does things. It considers each element in turn and checks if it belongs to the same group as the previous element. If so, both elements are added to the group; else, each element gets its own group. So with the above list, we get:So if you're looking to make a grouping like in SQL, then you'll want to sort the list before hand, by the key (criteria) with which you want to group:
I've tried to make a short and concise answer but I didn't suceed but I've managed to get a lot of python builtin modules involved:I'll use functools.reduce to do the sums but it needs a custom function:This function has a counter because you want to calculate the average it's more intuitive than a running mean implementation.Now the fun part: I'll group by the first two elements (assuming these are sorted otherwise one would need something like lst = sorted(lst, key=operator.itemgetter(0,1)) before:The calc[2]/calc[3] is the average of value3. Remember the last element in the reduce function was a counter! And a sum divided by the counts is the average.Giving me a result:just using those values you've given.


Answer URL
https://docs.python.org/3/library/functools.html#functools.reduce
