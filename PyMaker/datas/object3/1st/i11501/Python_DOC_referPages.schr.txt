Natural Text
There's a surprise here:It seems like the mere mention of __class__ is explicitly checked by the parser? Otherwise we should get something likeIndeed, if you modify to only check the key instead, i.e. check for '__class__' in locals(), then we only have self in scope as expected.  How does it happen that this variable gets magically injected into scope?  My guess is this is something to do with super - but I didn't use super, so why does the compiler create an implicit closure reference here if it isn't needed?
This is a weird interaction in Python 3's implementation of no-argument super. An access to super in a method triggers the addition of a hidden __class__ closure variable referring to the class that defines the method. The parser special-cases a load of the name super in a method by also adding __class__ to the method's symbol table, and then the rest of the relevant code all looks for __class__ instead of super. However, if you try to access __class__ yourself, all the code looking for __class__ sees it and thinks it should do the super handling!Here's where it adds the name __class__ to the symbol table if it sees super:Here's drop_class_free, which sets ste_needs_class_closure:The compiler section that checks ste_needs_class_closure and creates the implicit cell:There's more relevant code, but it's too much to include all of it. Python/compile.c and Python/symtable.c are where to look if you want to see more.You can get some weird bugs if you try to use a variable named __class__:Output:The assignment to __class__ means __class__ is a local variable instead of a closure variable, so the closure cell super() needs isn't there.Output:Even though there's an actual __class__ variable in the enclosing scope, the special-casing of __class__ means you get the class instead of the enclosing scope's variable value.
https://docs.python.org/3/reference/datamodel.html#creating-the-class-object__class__ is an implicit closure reference created by the compiler if any methods in a class body refer to either __class__ or super. This allows the zero argument form of super() to correctly identify the class being defined based on lexical scoping, while the class or instance that was used to make the current call is identified based on the first argument passed to the method.


Answer URL
https://docs.python.org/3/reference/datamodel.html#creating-the-class-object
