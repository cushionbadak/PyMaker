Natural Text
In Python, in an operation of numbers of mixed type, the narrower type is widened to that of the other, such as int + float → float:But for datetime.date, we have datetime.date + datetime.timedelta → datetime.date, not datetime.datetime:Why is the widening reasoning applied to numbers, but not to date/datetime/timedelta?(Background: I'm writing a reading routine for a file format where one field is year, one field is day-of-year, one field is milliseconds-since-midnight.  Of course, the simple and explicit solution is datetime.datetime(2013, 1, 1, 0, 0, 0) + datetime.timedelta(seconds=42), but one could equally reason that one should rewrite 3 + 0.1 as 3.0 + 0.1)
The behaviour is documented:date2 is moved forward in time if timedelta.days > 0, or backward if timedelta.days < 0. Afterward date2 - date1 == timedelta.days. timedelta.seconds and timedelta.microseconds are ignored.(My emphasis. This behaviour has remained unchanged since date objects were added in Python 2.3.)I haven't been able to find any evidence as to why the module is designed like this. Certainly there are use cases like yours where you want to represent the point in time corresponding to the midnight at the start of a day. In these cases it is annoying to have to convert back and forth. But there are other use cases in which you want to represent a whole day (and not just some point in time on that day), in which case you don't want to accidentally end up with partial days when you add timedeltas.Chris Withers suggested that the behaviour be changed, in issue 3249, but Tim Peters noted that:an incompatible change to documented always-worked-this-way behavior is unlikely to be accepted.If you want an object that behaves like a datetime.date, but where arithmetic operations return datetime.datetime objects, then it shouldn't be not too hard to write one:(This is untested, but it's shouldn't be hard to get it working from here.)
The timedelta object doesn't store any information on whether or not it just concerns dates, or also times. (The fact that the number of hours/minutes/seconds/micros is 0 may just be a coincidence!)Hence, suppose we have someone who just wants to manipulate dates, ignoring times, she'd do something like my_new_date = my_old_date + timedelta(days=1). She'd be very surprised and possibly annoyed to find that my_new_date is now a datetime object rather than a date object.
A date is not a subclass of datetime; datetime is a compound type, combining a date and a time object into one. You can't decide to produce a compound type from operations on date here; the time component is not a fraction of a date.On the other hand, the Python numeric hierarchy defines integers as a type of specialised float (numbers.Integral is an indirect subclass of numbers.Real), and as such mixing operations between integers and floats results in the base type being produced. And a float is not a compound type, there is no separate type for the decimal portion of the value.If you want to produce the compound type from operations on dates, you'll have to be explicit (and explicit is better than implicit). Add a time component yourself:where yourdate could be produced from a date.strptime('%Y %j') parsing of your year plus day-of-the-year input.The alternatives (either producing a datetime object sometimes based on the timedelta.seconds value, or always) require the programmer to unwrap the date component again if that is all that they expected.
The likely technical reason is that builtin types in Python do not return subclasses from its operators  as a rule i.e., date.__add__ won't return datetime. And the consistent behavior would require date and datetime to be interchangeable (they are not).date + timedelta behavior is documented and won't change.  If you want datetime as a result; create datetime from date d:Technically, date.__add__ could have delegated the work to timedelta.__radd__. timedelta stores days separately and therefore it simple and efficient to find out whether it represents whole number of days i.e., we could if we wanted to get date or datetime from date + timedelta (it doesn't mean we should).The issue is that 1 and 1.0 are the same timedelta(1) in this case i.e., if we were to allow date + timedelta to return datetime then it should return datetime for all values if we consider only types.There was a precedent when int + int returned either int or long depending on the result i.e., the operation with the same types may return values of different types depending only on the input values. Though date and datetime are not as much interchangeable as int and long were.date + timedelta returning date for some values of timedelta and datetime for others would create confusion unless we introduce date(y,m,d) == datetime(y,m,d) too (like 1 == 1.0) or date.today() < datetime.now() from the related Python issue mentioned by @Gareth Rees (like 1 < 1.1). datetime being a subclass suggest this route though I heard an argument that it was a mistake to make datetime a date subclass.The desired behavior is implemented in dateutil package:time() + timedelta is invalid, so combine() doesn't help me here.combine() works datetime.combine(d, time()) + timedelta_obj. Though, you could write it as: datetime(d.year, d.month, d.day) + timedelta_obj.Of course, the simple and explicit solution is datetime(2013, 1, 1, 0, 0, 0) + timedelta(seconds=42), but one might as well rewrite 3 + 0.1 as 3.0 + 0.1)int + float is always float:unlike 1.0 and 1; type(timedelta(1.0)) == type(timedelta(1)) (same type in addition to being equal).I'm writing a reading routine for a file format where one field is year, one field is day-of-year, one field is milliseconds-since-midnight.
When you sum a timedelta to a date, python will only look for the days attribute of the timedelta. So if if add 42 seconds, the day will be 0 and it will not affect your date.


Answer URL
https://docs.python.org/3/library/datetime.html
