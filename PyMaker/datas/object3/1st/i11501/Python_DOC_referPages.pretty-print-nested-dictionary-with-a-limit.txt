Natural Text
What is the idiomatic Python equivalent of this C/C++ code?specifically, how does one implement the static member at the function level, as opposed to the class level? And does placing the function into a class change anything?
A bit reversed, but this should work:If you want the counter initialization code at the top instead of the bottom, you can create a decorator:Then use the code like this:It'll still require you to use the foo. prefix, unfortunately.EDIT (thanks to ony): This looks even nicer:
You can add attributes to a function, and use it as a static variable.Alternatively, if you don't want to setup the variable outside the function, you can use hasattr() to avoid an AttributeError exception:Anyway static variables are rather rare, and you should find a better place for this variable, most likely inside a class.
One could also consider:Reasoning:much pythonic (ask for forgiveness not permission)use exception (thrown only once) instead of if branch (think StopIteration exception)
Other answers have demonstrated the way you should do this. Here's a way you shouldn't:Default values are initialized only when the function is first evaluated, not each time it is executed, so you can use a list or any other mutable object to store static values.
Many people have already suggested testing 'hasattr', but there's a simpler answer:No try/except, no testing hasattr, just getattr with a default.
Python doesn't have static variables but you can fake it by defining a callable class object and then using it as a function. Also see this answer.Note that __call__ makes an instance of a class (object) callable by its own name. That's why calling foo() above calls the class' __call__ method. From the documentation:Instances of arbitrary classes can be made callable by defining a __call__() method in their class.
Here is a fully encapsulated version that doesn't require an external initialization call:In Python, functions are objects and we can simply add, or monkey patch, member variables to them via the special attribute __dict__. The built-in vars() returns the special attribute __dict__.   EDIT: Note, unlike the alternative try:except AttributeError answer, with this approach the variable will always be ready for the code logic following initialization. I think the try:except AttributeError alternative to the following will be less DRY and/or have awkward flow:   EDIT2: I only recommend the above approach when the function will be called from multiple locations. If instead the function is only called in one place, it's better to use nonlocal:
Use a generator function to generate an iterator.Then use it likeIf you want an upper limit:If the iterator terminates (like the example above), you can also loop over it directly, likeOf course, in these simple cases it's better to use xrange :)Here is the documentation on the yield statement.
Python customarily uses underscores to indicate private variables. The only reason in C to declare the static variable inside the function is to hide it outside the function, which is not really idiomatic Python.
Using an attribute of a function as static variable has some potential drawbacks:Every time you want to access the variable, you have to write out the full name of the function. Outside code can access the variable easily and mess with the value.Idiomatic python for the second issue would probably be naming the variable with a leading underscore to signal that it is not meant to be accessed, while keeping it accessible after the fact. An alternative would be a pattern using lexical closures, which are supported with the nonlocal keyword in python 3.Sadly I know no way to encapsulate this solution into a decorator.
Much like vincent's code above, this would be used as a function decorator and static variables must be accessed with the function name as a prefix. The advantage of this code (although admittedly anyone might be smart enough to figure it out) is that you can have multiple static variables and initialise them in a more conventional manner.
A little bit more readable, but more verbose:
All of previous solutions attach a counter attribute to the function, usually with convoluted logic to handle the initialization. This is inappropriate for new code.In Python 3, the right way is to use a nonlocal statement:See PEP 3104 for the specification of the nonlocal statement.
The idiomatic way is to use a class, which can have attributes.  If you need instances to not be separate, use a singleton.There are a number of ways you could fake or munge "static" variables into Python (one not mentioned so far is to have a mutable default argument), but this is not the Pythonic, idiomatic way to do it.  Just use a class.Or possibly a generator, if your usage pattern fits.
Prompted by this question, may I present another alternative which might be a bit nicer to use and will look the same for both methods and functions:If you like the usage, here's the implementation:
Instead of creating a function having a static local variable, you can always create what is called a "function object" and give it a standard (non-static) member variable.Since you gave an example written C++, I will first explain what a "function object" is in C++. A "function object" is simply any class with an overloaded operator(). Instances of the class will behave like functions. For example, you can write int x = square(5); even if square is an object (with overloaded operator()) and not technically not a "function." You can give a function-object any of the features that you could give a class object.In Python, we can also overload operator() except that the method is instead named __call__:Here is a class definition:Here is an example of the class being used:The output printed to the console is:If you want your function to take input arguments, you can add those to __call__ as well:
After trying several approaches I end up using an improved version of @warvariuc's answer:
I personally prefer the following to decorators. To each their own.
A static variable inside a Python method
Another (not recommended!) twist on the callable object like https://stackoverflow.com/a/279598/916373, if you don't mind using a funky call signature, would be to do
Sure this is an old question but I think I might provide some update.It seems that the performance argument is obsolete. The same test suite appears to give similar results for siInt_try and isInt_re2.Of course results vary, but this is one session on my computer with python 3.4.4 on kernel 4.3.01 with Xeon W3550.I have run it several times and the results seem to be similar.I moved the global regex into function static, but the performance difference is negligible. With performance issue out of the way, it seems that try/catch would produce the most future- and cornercase- proof code so maybe just wrap it in function
This answer shows that setdefault does not truly satisfy the OPs question of how to create static local variables.It works as long as fn. is prefixed  to each variable name. If you remove them like so:there are no errors but counter is always 0 and that tells me the vars(fn) is NOT accessing local variables but rather a global, probably a decorator or attribute stash.Had this worked it would have been my preferred solution. However since it doesn't, I'm inclined to go with a fully encapsulated class definition to create such static vars. IMHO that is the most straightforward. Of course it depends on if you are more familiar with functional vs. OOP coding styles.
Soulution n +=1 
A global declaration provides this functionality. In the example below (python 3.5 or greater to use the "f"), the counter variable is defined outside of the function. Defining it as global in the function signifies that the "global" version outside of the function should be made available to the function. So each time the function runs, it modifies the value outside the function, preserving it beyond the function.
This answer builds on @claudiu 's  answer.I found that my code was getting less clear when I always had to prepend the function name, whenever I intend to access a static variable.Namely, in my function code I would prefer to write:instead ofSo, my solution is to :add a statics attribute to the  functionin the function scope, add a local variable statics as an alias to my_function.staticsRemarkMy method uses a class named Bunch, which is a dictionary that supports attribute-style access, a la JavaScript (see the original article about it, around 2000)It can be installed via pip install bunchIt can also be hand-written like so:
Building on Daniel's answer (additions):The reason why I wanted to add this part is , static variables are used not only for incrementing by some value, but also check if the static var is equal to some value, as a real life example.The static variable is still protected and used only within the scope of the function use_foo()In this example, call to foo() functions exactly as(with respect to the corresponding c++ equivalent) :if class Foo is defined restrictively as a singleton class, that would be ideal. This would make it more pythonic.


Answer URL
https://docs.python.org/3/reference/datamodel.html
