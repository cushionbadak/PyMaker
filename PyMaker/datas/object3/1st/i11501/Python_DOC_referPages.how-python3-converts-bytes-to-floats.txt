Natural Text
I’d like to understand how python converts bytes to floats, in detail.Let’s create a binary file containing just one float 23.0:Let’s now write a python3 code 23.py:  Execute the code:  So, I am wondering how python converts the bytes '\x00\x00\xb8A' into float 23.0? This has something to do with the DEC-BIN-HEX-ASCII representation, but I have already broken my brain trying to understand this.  How do we get '\x00\x00\xb8A' from it? Or vice-versa, how '\x00\x00\xb8A' transforms into 23.0?Could anyone explain me step by step? Thanks.
This is clearly documented in the format table:For the 'f' and 'd' conversion codes, the packed representation uses the IEEE 754 binary32 (for 'f') or binary64 (for 'd') format, regardless of the floating-point format used by the platform.So to understand that format, reference the IEEE floating point standard; you used the f code, so look for the binary32, or single precision format.This format consists of 32 bits, divided over:Sign bit: 1 bitExponent width: 8 bitsSignificand precision: 24 bits (23 explicitly stored)Looking at your binary data as bits, (which you treat as little endian, so I'm reversing these to match the Wikipedia big-endian ordering):we see that the sign is 0, the exponent width is 131 (in 2's complement, so minus 127 makes 4), and the significand precision or mantissa is 1.4375 (1 + 1/4 + 1/8 + 1/16, each binary fraction is an enabled bit).Together these form the actual floating point value:To go the other way, express the whole integer number and the value after the decimal point in binary; you may have to approximate the non-integer portion as binary fractions can't express all possible real numbers. 23.0 has no non-integer component, so that is easy here, we only have to convert the integer component to binary:So the binary representation for the real number is 10111.0. You then shift the decimal point up or down to get 1 and a fraction; here you need to shift the decimal point up 4 spots to 1.0111. This gives you the exponent (4), and the significant (0111 plus another 19 zeros for the unused fractions). The value is positive, so you encode the sign as 0, the exponent as a signed value (add 127 == 131, encode 131 to binary == 10000011), and add the significant:Chopping that into 4 groups of 8 bits (4 bytes) gives you 0x41 0xB8 0x00 0x00. Python's repr() output for a byte gives you printable ASCII characters for bytes where possible, and 0x41 is the letter A in the ASCII table:Reverse those bytes for a little-endian representation:You can visualise how the IEEE binary32 format works with this online converter.


Answer URL
https://docs.python.org/3/library/struct.html#format-characters
