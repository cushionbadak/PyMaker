Natural Text
So the question is pretty simple:If we have a random class, let's say an int and we try to access a non defined attribute: We will get this error:But if we try to access an index of it (in which case Python will do a lookup for a __getitem__ attribute):We get:What is the logic behind the change in exception type? It seems weird to me that a TypeError is raised, complaining about a missing attribute (AttributeError seems like a much better candidate for that)
It depends on your intention. When you use . you implicitly call the getattr function, that naturally raises the AttributeError if the attribute doesn't exist.Update 2. Let's look at the bytecode.As you see, the [] has a special virtual-machine instruction. From the docsBINARY_SUBSCR: Implements TOS = TOS1[TOS].Hence it's quite natural to raise a TypeError, when you fail at executing an instruction. Update 1: Looking at the getattr sources, it's clear that this function can never raise such a TypeError, hence the [] operator doesn't call it under the hood (for the built-in types at least, though it's better to find the sources to clarify this bit). 
An AttributeError for my_int[0] may be misleading because you aren't trying to access an attribute of my_int, you are trying to access an item. The TypeError is raised because int doesn't support subscripting, and this exception message was updated in Python 3.X.That being said, it wouldn't be inappropriate to throw an AttributeError that there is no __getitem__. I suspect that this may be a TypeError because numbers (int, float, long) are the only built-in data-types that do not support subscripting. When this error comes up, it will be due to you thinking that my_int contains an object of a different type, hence the TypeError.


Answer URL
https://docs.python.org/3/library/dis.html
