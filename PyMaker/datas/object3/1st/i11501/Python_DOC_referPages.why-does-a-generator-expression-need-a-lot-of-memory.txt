Natural Text
ProblemLet's assume that I want to find n**2 for all numbers smaller than 20000000.General setup for all three variants that I test:Three options to calculate these numbers:1. Creating a list of via comprehension:It is really slow and time consuming:2. Creating a generator using '()':It is much faster than option 1, but still uses a lot of memory:3. Defining a generator function (most efficient):Its consumption:The questions are:What's the difference between the first and second solutions? Using () creates a generator, so why does it need a lot of memory?Is there any built-in function equivalent to my third option?
As others have pointed out in the comments, range creates a list in Python 2. Hence, it is not the generator per se that uses up the memory, but the range that the generator uses:This also explains why your second version (the generator expression) uses around half the memory of the first version (the list comprehension) as the first one builds two lists (for the bases and the squares) while the second only builds one list for the bases.xrange(20000000) thus, greatly improves memory usage as it returns a lazy iterable. This is essentially the built-in memory efficient way to iterate over a range of numbers that mirrors your third version (with the added flexibility of start, stop and step):In Python 3, range is essentially what xrange used to be in Python 2. However, the Python 3 range object has some nice features that Python 2's xrange doesn't have, like O(1) slicing, contains, etc.Some references:Python2 xrange docsPython3 range docsStack Overflow - "Should you always favor xrange() over range()?"Martijn Pieters excellent answer to "Why is 1000000000000000 in range(1000000000000001) so fast in Python 3?"
1.- The object must be created in memory, so in your second solution, the generator is created but not computed, but still has memory, python probably reserve some memory for its computation to be efficient, we don't know about the interpreter magic, also notice that range funtion creates the full list from 0 to 200000, so in fact you are still building that list in memory.2.- You can use itertool.imap:


Answer URL
https://docs.python.org/3/library/stdtypes.html#ranges
