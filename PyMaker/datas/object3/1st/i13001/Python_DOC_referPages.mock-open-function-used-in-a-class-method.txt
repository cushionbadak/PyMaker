Natural Text
I tried to mock the open function used in a method of my class.I found this thread How do I mock an open used in a with statement (using the Mock framework in Python)? but could not solve my issue. Also the unittest documention shows a solution which also didn't mock my open https://docs.python.org/3/library/unittest.mock-examples.html#patch-decoratorsThis is my class with the method where the open function is used:Now I found a little different solution. This is my test:I'm not sure if this is the best way to test the content which should be written to a file.When I test the mock_calls (call_args_list is the same) this are the arguments which are passed to the file handle.Any advice, improvements and suggestions are welcome.
TL;DRThe heart of your problem is that you should be also mocking json.dump to be able to properly test the data that is going to be written to your file. I actually had a hard time running your code until a few important adjustments were made to your test method. Mock with builtins.open and not mymmodule.openYou are in a context manager, so you should be checking m.return_value.__enter__.write, however you are actually calling the write from json.dump which is where the write will be called. (Details below on a suggested solution) You should also mock json.dump to simply validate it is called with your dataIn short, with the issues mentioned above, the method can be re-written as: Details about all this belowDetailed ExplanationTo focus on the problems I see in your code, the first thing I strongly suggest doing, since open is a builtin, is to mock from builtins, furthermore, you can save yourself a line of code by making use of new_callable and as, so you can simply do this:The next problem that I see with your code as I had trouble running this until I actually made the following adjustment when you started looping over your calls:To dissect that, what you have to keep in mind is that your method is using a context manager. In using a context manager, the work of your write will actually be done inside your __enter__ method. So, from the return_value of your m, you want to then get the return_value of __enter__. However, this brings us to the heart of the problem with what you are trying to test. Because of how the json.dump works when writing to the file, your mock_calls for your write after inspecting the code, will actually look like this: That is not going to be fun to test. So, this brings us to the next solution you can try out; Mock json.dump. You shouldn't be testing json.dump, you should be testing calling it with the right parameters. With that being said, you can follow similar fashion with your mocking and do something like this: Now, with that, you can significantly simplify your test code, to simply validate that the method gets called with your data that you are testing with. So, with that, when you put it all together, you will have something like this:If you're interested in further refactoring to make your test method a bit cleaner, you could also set up your patching as a decorator, leaving your code cleaner inside the method: Inspecting is your best friend here, to see what methods are being called at what steps, to further help with the testing. Good luck. 


Answer URL
https://docs.python.org/3/library/unittest.mock-examples.html#patch-decorators
