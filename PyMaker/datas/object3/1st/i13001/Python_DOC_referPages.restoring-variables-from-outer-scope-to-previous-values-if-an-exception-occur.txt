Natural Text
Is it possible to call a function in a kind of protected environment with the following feature: if calling function f raises an exception, then make sure all (outer) variables are restored to their previous values.For instance, the following code:will obviously set a to 43 before raising the exception. I would like to build some try/except structure for calling f() where the exception would restore local variables to their previous state.Of course I thought to something related to sys._getframe(1).f_locals. Is it possible? Would it be portable accross different versions of Python? etc.No major goal right now; just curious about that idea.
Short answer is no, there's no snapshot feature to these executions and thus no way of reverting the variables.However there are some things you can do. One of them being:(And I'm writing this as I go so this will be resource exhausting way to solve your problem if you use it on large variables.)If this were a class with initated values, you could also snapshot the entire class or peak inside it and pull out certain variables. But there's no way to automatically do these things for you.Of course this requires you to know a head of time what variables will be affected, I'm not sure there is a way to "peak inside" a function and see what variable names will be used, and even then you'd have to use a traceback call to see on which row your got the error and restored based on that.One way I would solve it, is to store all my critical variables in a dictionary and snapshot branches of that dictionary or the entire dictionary itself.


Answer URL
https://docs.python.org/3/whatsnew/2.5.html?highlight=contextmanager#pep-343-the-with-statement
https://docs.python.org/3/whatsnew/2.5.html?highlight=contextmanager#writing-context-managers
