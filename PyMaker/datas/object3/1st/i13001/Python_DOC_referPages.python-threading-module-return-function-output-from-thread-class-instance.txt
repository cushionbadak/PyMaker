Natural Text
How to get the value 'foo' which is returned from the thread's target?  The "one obvious way to do it", shown above, doesn't work: thread.join() returned None.
FWIW, the multiprocessing module has a nice interface for this using the Pool class.  And if you want to stick with threads rather than processes, you can just use the multiprocessing.pool.ThreadPool class as a drop-in replacement.
One way I've seen is to pass a mutable object, such as a list or a dictionary, to the thread's constructor, along with a an index or other identifier of some sort. The thread can then store its results in its dedicated slot in that object.  For example:If you really want join() to return the return value of the called function, you can do this with a Thread subclass like the following:That gets a little hairy because of some name mangling, and it accesses "private" data structures that are specific to Thread implementation... but it works.For python3
Jake's answer is good, but if you don't want to use a threadpool (you don't know how many threads you'll need, but create them as needed) then a good way to transmit information between threads is the built-in Queue.Queue class, as it offers thread safety.I created the following decorator to make it act in a similar fashion to the threadpool:Then you just use it as:The decorated function creates a new thread each time it's called and returns a Thread object that contains the queue that will receive the result.UPDATEIt's been quite a while since I posted this answer, but it still gets views so I thought I would update it to reflect the way I do this in newer versions of Python:Python 3.2 added in the concurrent.futures module which provides a high-level interface for parallel tasks.  It provides ThreadPoolExecutor and ProcessPoolExecutor, so you can use a thread or process pool with the same api.One benefit of this api is that submitting a task to an Executor returns a Future object, which will complete with the return value of the callable you submit.This makes attaching a queue object unnecessary, which simplifies the decorator quite a bit:This will use a default module threadpool executor if one is not passed in.The usage is very similar to before:If you're using Python 3.4+, one really nice feature of using this method (and Future objects in general) is that the returned future can be wrapped to turn it into an asyncio.Future with asyncio.wrap_future.  This makes it work easily with coroutines:If you don't need access to the underlying concurrent.Future object, you can include the wrap in the decorator:Then, whenever you need to push cpu intensive or blocking code off the event loop thread, you can put it in a decorated function:
Another solution that doesn't require changing your existing code:It can be also easily adjusted to a multi-threaded environment:
Parris / kindall's answer join/return answer ported to Python 3:Note, the Thread class is implemented differently in Python 3.
I stole kindall's answer and cleaned it up just a little bit.The key part is adding *args and **kwargs to join() in order to handle the timeoutUPDATED ANSWER BELOWThis is my most popularly upvoted answer, so I decided to update with code that will run on both py2 and py3.Additionally, I see many answers to this question that show a lack of comprehension regarding Thread.join(). Some completely fail to handle the timeout arg. But there is also a corner-case that you should be aware of regarding instances when you have (1) a target function that can return None and (2) you also pass the timeout arg to join().  Please see "TEST 4" to understand this corner case.ThreadWithReturn class that works with py2 and py3:Some sample tests are shown below:Can you identify the corner-case that we may possibly encounter with TEST 4?The problem is that we expect giveMe() to return None (see TEST 2), but we also expect join() to return None if it times out.returned is None means either:(1) that's what giveMe() returned, or(2) join() timed outThis example is trivial since we know that giveMe() will always return None. But in real-world instance (where the target may legitimately return None or something else) we'd want to explicitly check for what happened.Below is how to address this corner-case:
Using Queue :
My solution to the problem is to wrap the function and thread in a class. Does not require using pools,queues, or c type variable passing. It is also non blocking. You check status instead. See example of how to use it at end of code.
You can define a mutable above the scope of the threaded function, and add the result to that. (I also modified the code to be python3 compatible)This returns {'world!': 'foo'}If you use the function input as the key to your results dict, every unique input is guaranteed to give an entry in the results 
You can use Pool as a pool of worker processes as below:
Taking into consideration @iman comment on @JakeBiesinger answer I have recomposed it to have various number of threads:Cheers,Guy.
join always return None, i think you should subclass Thread to handle return codes and so.
I'm using this wrapper, which comfortably turns any function for running in a Thread - taking care of its return value or exception. It doesn't add Queue overhead. Usage ExamplesNotes on threading moduleComfortable return value & exception handling of a threaded function is a frequent "Pythonic" need and should indeed already be offered by the threading module - possibly directly in the standard Thread class. ThreadPool has way too much overhead for simple tasks - 3 managing threads, lots of bureaucracy. Unfortunately Thread's layout was copied from Java originally - which you see e.g. from the still useless 1st (!) constructor parameter group.
As mentioned multiprocessing pool is much slower than basic threading. Using queues as proposeded in some answers here is a very effective alternative. I have use it with dictionaries in order to be able run a lot of small threads and recuperate multiple answers by combining them with dictionaries:
Define your target to1) take an argument q2) replace any statements return foo with q.put(foo); returnso a functionwould becomeand then you would proceed as suchAnd you can use function decorators/wrappers to make it so you can use your existing functions as target without modifying them, but follow this basic scheme.
One usual solution is to wrap your function foo with a decorator likeThen the whole code may looks like thatNoteOne important issue is that the return values may be unorderred.(In fact, the return value is not necessarily saved to the queue, since you can choose arbitrary thread-safe data structure )
Why don't just use global variable?
Very simple way to get this done for such dummies like me:main thing here - is queue module. We create queue.Queue() instance and include it in our function. We feed it with our result which later we get beyond the thread.Please see one more example with arguments passed to our test function:
GuySoft's idea is great, but I think the object does not necessarily have to inherit from Thread and start() could be removed from interface:
Kindall's answer in Python3
If only True or False is to be validated from a function's call, a simpler solution I find is updating a global list. This is more helpful where you want to find if any one of the threads had returned a false status to take the necessary action. 


Answer URL
https://docs.python.org/3/library/concurrent.futures.html
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future
https://docs.python.org/3/library/asyncio-task.html#asyncio.Future
https://docs.python.org/3/library/asyncio-task.html#asyncio.wrap_future
