Natural Text
I'm using argparse to take input and pass it to a function that takes as arguments two variables and **kwargs.Here's my function: Given this function and its use of **kwargs, how should I setup the subparsers? Here's how I've setup the command line parser thus far:Obviously, the above main() function works fine with the location_by_coordinate() function when I call it at the command line like this: But with the code the way it is currently, if I try: Obviously, I get: But I'm not sure how to setup a subparser for **kwargs. If I try to setup a subparser like this: and then try that command again: That doesn't work because the arguments object (which is a dictionary), becomes this:{'LAT': '40.5949799', 'LNG': '-73.9495148', 'command': 'location_by_coordinate', '**kwargs': 'DISTANCE=3000'}And this Traceback is returned: How can I enable argparse to handle/to parse what is entered at the command line that is intended to be passed to the function via **kwargs? 
Do you understand what is going on with the arguments dictionary?  You defined a 'positional' argument with the name ('dest') of '**kwargs'.  You could just as well named it 'foobar'.  The parser assigned the string 'DISTANCE=3000' to that attribute in the args namespace, which turned into a dictionary key:value pair in arguments.You could, of course, look for arguments['**kwargs'], and parse the value for yourself:It could be generalized to handle multiple pairs (defined with `nargs='*').argparse does not handle arguments the same way as Python functions, so there's nothing exactly analogous the **kwargs.The normal way to accept something like distance is with 'optionals' or flagged arguments.which will acceptIt could also be setup to use --DISTANCE or other names.  In the last case args namespace will have a default value for distance.  The default default is None.That's the straight forward way of adding kwarg like arguments to argparse.Accepting arbitrary dictionary like pairs, distance:3000, distance=3000, has been asked before on SO.  The answers have always been some variation of the parsing that I sketched above.  It could be done in a custom Action class, or post parsing as I suggest.oops, this answer is nearly a clone of one I wrote a few days ago:https://stackoverflow.com/a/33639147/901925A similar 2011 question: Using argparse to parse arguments of form "arg= val"Python argparse dict arg=================================(edit)Example with a function that takes *args:So I have 2 positional arguments, one with a single string value, the other with a list (due to the + nargs).Call foo with these args attributes:I defined 'positionals', but it would have worked just as well with 'optionals'.  The distinction between positionals and optionals disappears in the namespace.  If I convert the namespace to a dictionary, I can pass values to foo in various ways, either through the *args or through **kwargs.  It's all in how I call foo, not in how they appear in args or arguments.  None of this is unique to argparse.
How can I enable argparse to handle/to parse what is entered at the  command line that is intended to be passed to the function via  **kwargs?This command:does NOT execute the function call:That is easy to prove:Go ahead and parse the args, and you'll see that the function isn't called.  As a result, all your work setting up a subparser with the name location_by_coordinate was in vain.  The argparse module just examines sys.argv, which is a simple list of strings.  Each string is one of the 'words' entered on the command line after the python command. By default, the argument strings are taken from sys.argv,...https://docs.python.org/3/library/argparse.html#the-parse-args-methodYeah, sys.argv is a scary name, but a list of strings is just a list of strings.  If you look at the argparse docs, all the examples do this:A list of strings you create with split() is no different than some list of strings that sys.argv refers to.You need to call your location_by_coordinate() function yourself.  In order to do that, you need to get the args from the command line, assemble the args that should be kwargs in a dictionary, and call your function like this:If you have these values:then the function call above will be equivalent to:Here is an example:You can also get a dict from the parser:If you want to make the user type:on the command line, first of all I would not make them type all caps, so lets make the goal:Add another mandatory argument to the parser:Then after you parse the following:you can do this:The args_dict will contain the key/value pair 'distance': 'distance=3000'.  You can change that dict entry to 'distance': '3000' by doing the following:Or, you can set things up so that the parser will automatically execute that code by creating a custom action that executes when the distance arg is parsed: You can use the action like this:And if you want to get fancy, you can collect all the name=val args specified on the command line into one dictionary named, say, keyword_args, which will allow you to call your method like this:Here's the parser configuration:Example:


Answer URL
https://docs.python.org/3/library/argparse.html#the-parse-args-method
