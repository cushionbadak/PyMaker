Natural Text
In Python, I am implementing the A* search algorithm for solving the Tile Problem.I have the following Node class which holds the state as a tuple of tuple. For example the initial state is:Below is the Node class,I also have a TileProblem class which holds the heuristics that will be used by A* as the following,The priority Queue Class as the following,my A* algorithm,Finally, in my main,When I run the code, I get the following error:I do not understand the cause of this problem. Why should the insort care about the items. I only expect it to push the item and sort by the "priority" value which is an integer in my case (the accumulated Manhattan Distance). How can I solve this problem? Thanks.
You have nodes with equal priority in the queue. Python then tries to order the (priority, node) tuple by comparing the nodes. That's because tuples are compared in lexicographical order, just like you'd sort names. With two names, if the first letters match, you compare the second letter, etc, until you have different letters and can order those, comparing tuples works the same way. If the priorities match, the nodes are compared.Either make your nodes orderable (you can use the functools.total_ordering() decorator plus an __eq__ and a __lt__ method) or insert a counter value into the priority queue tuples to break the tie:and update the rest of the PriorityQueue() class to look for the item at index 2 (or better still, at index -1). Update the list comprehension in the updatePriorityValue() method to unpack the queue items to (v, c, i) and to include those again in the left-hand-side expression.The counter (produced by itertools.count()) inserts an ever increasing integer, so there will never be two tuples with (priority, counter, item) where both the priority and the counter are equal; thus the items are never compared.This means that for equal priority, items that were inserted later win the tie. Use -next(self._counter) instead if you want items inserted earlier to win instead.


Answer URL
https://docs.python.org/3/library/functools.html#functools.total_ordering
https://docs.python.org/3/library/itertools.html#itertools.count
https://docs.python.org/3/reference/datamodel.html#object.__lt__
