Natural Text
I have client and server module, each one can be started by a function. I just need to find a way to run booth in parallel which:in case of an exception in the client/server would stop the other so the test runner would not stay stuckin case of an exception in client/server would print the exception or propagate it to the runner so I could see it and debug the client/server using the test suitewould preferably use threads for performance reasonsThe first tentative with simple threads ended with an ugly os._exit(1) when catching a exception in the run method of the thread (which kills the test runner...) Edit: with the threading packageThe second tentative (to try to avoid os._exit()) was with concurrent.futures.ThreadPoolExecutor. It allows to get the exception out of the thread but I still can't find a way to abort the other thread.Is there a way to achieve this with threads?If not with threads, is there a simple way to test a client server app at all? (I think the two first requirements are enough to have a usable solution)Edit: The client or the server would be blocked on an accept() or a receive() call so I can't periodically pool a flag a decide to exit.(one of classic method to stop a thread)
You can use the threading package. Be aware though that force killing thread is not a good idea, as discussed here. It seems there is no official way to kill Thread in Python, but you can follow one of the example given on the linked post. Now you need to wait for one thread to exit before stopping the other one, avoiding your test runner to be stuck. You can use Threads wrapping your server/client launch, and have your main Thread waiting for either client/server Thread to exit before killing the other one.You can define your client/server Thread like this:Then, start both client and server thread, and wait for one of them to exit. Once one of them is not alive anymore, you can kill the other and continue on testing. The central piece of code is the join() function:Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates – either normally or through an unhandled exception –, or until the optional timeout occurs.So in our case, it will wait 5 seconds for the client and 5 seconds for the server, and if both of them are still alive afterward it will loop again. Whenever one of them exit, the loop will stop, and the remaining thread will be killed.


Answer URL
https://docs.python.org/3/library/threading.html
https://docs.python.org/3/library/threading.html#threading.Thread.join
