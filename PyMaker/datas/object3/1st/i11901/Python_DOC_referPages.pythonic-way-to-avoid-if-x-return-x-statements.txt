Natural Text
I have a method that calls 4 other methods in sequence to check for specific conditions, and returns immediately (not checking the following ones) whenever one returns something Truthy.This seems like a lot of baggage code. Instead of each 2-line if statement, I'd rather do something like:But that is invalid Python. Am I missing a simple, elegant solution here? Incidentally, in this situation, those four check methods may be expensive, so I do not want to call them multiple times.
You could use a loop:This has the added advantage that you can now make the number of conditions variable.You could use map() + filter() (the Python 3 versions, use the future_builtins versions in Python 2) to get the first such matching value:but if this is more readable is debatable.Another option is to use a generator expression:
Alternatively to Martijn's fine answer, you could chain or. This will return the first truthy value, or None if there's no truthy value:Demo:
Don't change itThere are other ways of doing this as the various other answers show. None are as clear as your original code.
In effectively the same answer as timgeb, but you could use parenthesis for nicer formatting:
According to Curly's law, you can make this code more readable by splitting two concerns:What things do I check?Has one thing returned true?into two functions:This avoids:complicated logical structuresreally long linesrepetition...while preserving a linear, easy to read flow.You can probably also come up with even better function names, according to your particular circumstance, which make it even more readable.
This is a variant of Martijns first example. It also uses the "collection of callables"-style in order to allow short-circuiting.Instead of a loop you can use the builtin any. Note that any returns a boolean, so if you need the exact return value of the check, this solution will not work. any will not distinguish between 14, 'red', 'sharp', 'spicy' as return values, they will all be returned as True.
Have you considered just writing if x: return x all on one line?This isn't any less repetitive than what you had, but IMNSHO it reads quite a bit smoother.
I'm quite surprised nobody mentioned the built-in any which is made for this purpose:Note that although this implementation is probably the clearest, it evaluates all the checks even if the first one is True.If you really need to stop at the first failed check, consider using reduce which is made to convert a list to a simple value:reduce(function, iterable[, initializer]) : Apply function of two  arguments cumulatively to the items of iterable, from left to right,  so as to reduce the iterable to a single value. The left argument, x,  is the accumulated value and the right argument, y, is the update  value from the iterable. If the optional initializer is present, it is  placed before the items of the iterable in the calculationIn your case:lambda a, f: a or f() is the function that checks that either the accumulator a or the current check f() is True. Note that if a is True, f() won't be evaluated.checks contains check functions (the f item from the lambda)False is the initial value, otherwise no check would happen and the result would always be Trueany and reduce are basic tools for functional programming. I strongly encourage you to train these out as well as map which is awesome too!
If you want the same code structure, you could use ternary statements!I think this looks nice and clear if you look at it.Demo:
For me, the best answer is that from @phil-frost, followed by @wayne-werner's.What I find interesting is that no one has said anything about the fact that a function will be returning many different data types, which will make then mandatory to do checks on the type of x itself to do any further work.So I would mix @PhilFrost's response with the idea of keeping a single type:Notice that x is passed as an argument, but also all_conditions is used as a passed generator of checking functions where all of them get an x to be checked, and return True or False. By using func with all_conditions as default value, you can use assessed_x(x), or you can pass a further personalised generator via func.That way, you get x as soon as one check passes, but it will always be the same type.
A slight variation on Martijns first example above, that avoids the if inside the loop:
Ideally, I would re-write the check_  functions to return True or False rather than a value. Your checks then becomeAssuming your x is not immutable, your function can still modify it (although they can't reassign it) - but a function called check shouldn't really be modifying it anyway. 
This way is a little bit outside of the box, but I think the end result is simple, readable, and looks nice. The basic idea is to raise an exception when one of the functions evaluates as truthy, and return the result. Here's how it might look: You'll need a assertFalsey function that raises an exception when one of the called function arguments evaluates as truthy: The above could be modified so as to also provide arguments for the functions to be evaluated. And of course you'll need the TruthyException itself. This exception provides the object that triggered the exception: You can turn the original function into something more general, of course: This might be a bit slower because you are using both an if statement and handling an exception. However, the exception is only handled a maximum of one time, so the hit to performance should be minor unless you expect to run the check and get a True value many many thousands of times. 
The pythonic way is either using reduce (as someone already mentioned) or itertools (as shown below), but it seems to me that simply using short circuiting of the or operator produces clearer code
I like @timgeb's. In the meantime I would like to add that expressing None in the return statement is not needed as the collection of or separated statements are evaluated and the first none-zero, none-empty, none-None is returned and if there isn't any then None is returned whether there is a None or not!So my check_all_conditions() function looks like this:Using timeit with number=10**7 I looked at the running time of a number of the suggestions. For the sake of comparison I just used the random.random() function to return a string or None based on random numbers. Here is the whole code:And here are the results:
I'm going to jump in here and have never written a single line of Python, but I assume if x = check_something(): return x is valid?if so:
I have seen some interesting implementations of switch/case statements with dicts in the past that led me to this answer. Using the example you've provided you would get the following. (It's madness using_complete_sentences_for_function_names, so check_all_conditions is renamed to status. See (1))The select function eliminates the need to call each check_FUNCTION twice i.e. you avoid check_FUNCTION() if check_FUNCTION() else next by adding another function layer. This is useful for long running functions. The lambdas in the dict delay execution of it's values until the while loop.As a bonus you may modify the execution order and even skip some of the tests by altering k and s e.g. k='c',s={'c':'b','b':None} reduces the number of tests and reverses the original processing order.The timeit fellows might haggle over the cost of adding an extra layer or two to the stack and the cost for the dict look up but you seem more concerned with the prettiness of the code.Alternatively a simpler implementation might be the following :I mean this not in terms of pep8 but in terms of using one concise descriptive word in place of a sentence. Granted the OP may be following some coding convention, working one some existing code base or not care for terse terms in their codebase.


Answer URL
https://docs.python.org/3/library/functions.html#map
https://docs.python.org/3/library/functions.html#filter
https://docs.python.org/3/library/functions.html
https://docs.python.org/3/library/stdtypes.html#iterator-types
