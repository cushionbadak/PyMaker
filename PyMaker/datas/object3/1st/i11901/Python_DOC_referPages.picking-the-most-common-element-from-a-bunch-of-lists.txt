Natural Text
I have a list l of lists [l1, ..., ln] of equal lengthI want to compare the l1[k], l2[k], ..., ln[k] for all k in len(l1) and make another list l0 by picking the element that appears most frequently.So, if l1 = [1, 2, 3], l2 = [1, 4, 4] and l3 = [0, 2, 4], then l = [1, 2, 4]. If there is a tie, I will look at the lists that make up the tie and choose the one in the list with higher priority. Priority is given a priori, each list is given a priority.Ex. if you have value 1 in lists l1 and l3, and value 2 in lists l2 and l4, and 3 in l5, and lists are ordered according to priority, say l5>l2>l3>l1>l4, then I will pick 2, because 2 is in l2 that contains an element with highest occurrence and its priority is higher than l1 and l3.How do I do this in python without creating a for loop with lots of if/else conditions?
You can use the Counter module from the collections library.  Using the map function will reduce your list looping.  You will need an if/else statement for the case that there is no most frequent value but only for that:list0 is the answer you are looking for.  I just hate using l because it's easy to confuse with the number 1 Edit (based on comments):Incorporating your comments, instead of the if/else statement, use a while loop: So the whole thing is now:You throw in one more tiny loop but on the bright side there's no if/else statements at all!
Just transpose the sublists and get the Counter.most_common element key from each group:If they are individual lists just zip those:Not sure how taking the first element from the grouping if there is a tie makes sense as it may not be the one that tied but that is trivial to implement, just get the two most_common and check if their counts are equal:We also need if len(comm) == 1 in case all the elements are the same or we will get an IndexError.If you are talking about taking the element that comes from the earlier list in the event of a tie i.e l2 comes before l5 then that is just the same as taking any of the elements that tie.For a decent number of sublists:
Solution is:
That's what you're looking for:
If you are OK taking any one of a set of elements that are tied as most common, and you can guarantee that you won't hit an empty list within your list of lists, then here is a way using Counter (so, from collections import Counter):Doing this in IPython and printing the result:
Try this:


Answer URL
https://docs.python.org/3/library/collections.html#collections.Counter
