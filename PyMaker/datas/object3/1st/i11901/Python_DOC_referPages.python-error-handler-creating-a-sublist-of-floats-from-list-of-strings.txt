Natural Text
I have a list of strings as followsHow to get the first 'n' float values? For example the code below gets me the last value of float. How to modify it to get the first n values
Updating to n=4 since people seem to be getting thrown off by the output.Here's an approach with map/filter that only prints the first n float elements:Prints:EDITTo elaborate a bit as requested in comment:map takes in a function, and an iterable, and applies that function to every element in the iterable, in our case we are trying to map get_float to every element, x.Now if x is a float, get_float succeeds and returns x cast into a float value. If x cannot be cast to a float, the function will throw a ValueError, which we don't really need to do anything with - so we pass, and since there is no return statement, we end up returning None.However, after initial pass of our map, the Nones that we got as result of all ValueErrors end up in the output of the map, so if you printed list(map(get_float, list1)) would see something like: [None, None, 13.0, None, 0.01, None, 42.35, None, 5.0], with all those extra Nones.filter takes in a function that returns True if you want to keep an element, and False if you want to get rid of it, and an iterable, and results in another iterable with only the elements you want to keep. filter(None, iterable) just uses the default filter where everything where bool(x) evaluates to False is discarded. Thus, after applying the filter, we only end up with the floats inside our filter iterable, which we cast into a list, and slice the outcome of that ([:n]) to only keep the first n elements.
Option 1Building on Tgsmith61591's solution: simply get a boolean array to use as index for the list.Where you vectorize the function so it accepts an entire vector as input, and then simply use the function applied to your list as index to get the desired elements.Option 2You convert your entire array to floats and placeholder values and then filter out the placeholders.map applies the function floatify to each element in list1. It produces an array of floats and np.nan for values that couldn't be converted. The np.isnan() function gives an array of booleans that are true for np.nan values. The inverse of this boolean array (so only the values that aren't nan) is then used as an index to generate the new array.Option 3If you aren't concerned with speed (if your arrays aren't that long) and want a quick and dirty solution, you can stick to a for loop that appends:OutputNotice I changed the input slightly and added a 0 value, this value is a difficult one to filter.All the above methods give the following output:Getting the first n values can be achieved by simply getting the first n values of the floats array:which gives:
This is kind of kludgey... but, if you want to do it in a comprehension:Then to get the first n...
I think this way is quite similar to yours. I have just added the condition len (floats) < max_floats:So this code produces the following output:
Here is another one with regex


Answer URL
https://docs.python.org/3/library/functions.html#map
https://docs.python.org/3/library/functions.html#filter
