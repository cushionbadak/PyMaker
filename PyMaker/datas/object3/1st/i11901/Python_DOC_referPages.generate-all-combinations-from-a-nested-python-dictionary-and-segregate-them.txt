Natural Text
My sample dict is:   Its a "follow-on" question to-> Split python dictionary to result in all combinations of valuesI would like to get a segregated list of combinations like belowValid combinations:[generate only out of valid list of data] COMPLETE OUTPUT for VALID CATEGORY : Negative combinations : [Here its bit tricky because, negative combinations should be combined with "valid" pool as well with atleast only value being negative] Complete output expected for NEGATIVE category : =>[Basically, excluding combinations where all values are valid - ensuring atleast one value in the combination is from negative group]In the above output, in the first line, grade is tested for negative value AB by keeping remaining all valid. So its not necessary to generate the same with age as 30 as the intent is to test only negative set. We can supply the remaining parameters with any valid data. Boundary Combinations is similar to valid -> Combinations for all values within the boundary pool only Explore : Similar to negative - Mix with valid pool and always atleast one explore value in all combinations.Sample dict  - revised versionThe sample_dict2 contains list of dicts. Here "employee" the whole hierarchy is a list element and also leaf node "grade" is a listAlso, except "valid" and "boundary" other data set can be empty - [] and we need to handle them as well.VALID COMBINATIONS will be likeplus combinations of age=30 and name =tom in employee index 0
Calling generate_combinations(sample_dict) returns:Calling generate_invalid_combinations(sample_dict) returns:Calling generate_boundary_combinations(sample_dict) returns:Calling generate_explore_combinations(sample_dict) returns:REVISED SOLUTION (To match revised problem)generate_invalid_combinations() and generate_explore_combinations() are the same as before.  Subtle differences:Instead of grabbing the first item out of the valid array in a negative evaluation, it now grabs a random item from the valid array.Values for items like 'age': [30] come back as lists as that's how they were specified:If you instead want 'age': 30 like the earlier output examples, then modify the definition accordingly:The boundary property is now treated like one of the 'negative' values.Just for reference, I don't plan to generate all the outputs this time: calling generate_combinations(sample_dict2) returns results like:
This is an open-ended hornet's nest of a question.Look at the whitepapers for Agitar other tools by Agitar to see if this what you are thinking about.Look at Knuth's work on combinationals.  It's a tough read.Consider just writing a recursive descent generator that uses 'yield '.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.combinations
