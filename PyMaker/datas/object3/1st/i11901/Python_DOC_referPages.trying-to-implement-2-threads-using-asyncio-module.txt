Natural Text
I've played around with threading before in Python, but decided to give the asyncio module a try, especially since you can cancel a running task, which seemed like a nice detail. However, for some reason, I can't wrap my head around it.Here's what I wanted to implement (sorry if I'm using incorrect terminology):a downloader thread that downloads the same file every x seconds, checks its hash against the previous download and saves it if it's different.a webserver thread that runs in the background, allowing control (pause, list, stop) of the downloader thread.I used aiohttp for the webserver.This is what I have so far:This class is called by:This doesn't work of course, and I feel that this is a horrible piece of code.What's unclear to me:I stop the downloader in the stop() method, but how would I go about stopping the webserver (e.g. in a shutdown() method)?Does the downloader need a new event loop, or can I use the loop returned by asyncio.get_event_loop()?Do I really need something like the supervisor for what I'm trying to implement? This seems so clunky. And how do I get supervisor to keep running instead of ending after a single execution as it does now?One last, more general question: is asyncio supposed to replace the threading module (in the future)? Or does each have its own application?I appreciate all the pointers, remarks and clarifications!
Why current code is not working:You're running event loop until self._supervisor() is complete. self._supervisor() creates task (it happens immediately) and finishes immediately.You're trying to run event loop until _supervisor complete, but how and when are you going start server? I think event loop should be running until server stopped. _supervisor or other stuff can be added as task (to same event loop). aiohttp already has function to start server and event loop - web.run_app, but we can do it manually.Your questions:Your server will run until you stop it. You can start/stop differentcoroutines while your server working.You need only one event loop for different coroutines.I think you don't need supervisor.More general question: asyncio helps you to run differentfunctions parallel in single thread in single process. That's whyasyncio is so cool and fast. Some of your sync code with threads youcan rewrite using asyncio and it's coroutines. Moreover: asyncio caninteract with threads and processes.It can be useful in case you still need threads and processes: here's example.Useful notes:It's better to use term coroutine instead of thread while we talk about asyncio coroutines that are not threadsIf you use Python 3.5, you can use async/await syntaxinstead of coroutine/yield fromI rewrote your code to show you idea. How to check it: run program, see console, open http://localhost:8080/stop, see console, open http://localhost:8080/start, see console, type CTRL+C.


Answer URL
https://docs.python.org/3/library/asyncio-subprocess.html#subprocess-and-threads
