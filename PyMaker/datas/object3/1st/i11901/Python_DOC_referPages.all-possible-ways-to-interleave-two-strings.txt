Natural Text
I am trying to generate all possible ways to interleave any two arbitrary strings in Python.For example: If the two strings are 'ab' and 'cd', the output I wish to get is:See a is always before b (and c before d). I am struggling to find a solution to this. I have tried itertools as shown below:But as expected, this returns all possible permutations disregarding order of a and b (and c and d).
The IdeaLet the two strings you want to interleave be s and t. We will use recursion to generate all the possible ways to interleave these two strings. If at any point of time we have interleaved the first i characters of s and the first j characters of t to create some string res, then we have two ways to interleave them for the next step-Append the i+1 th character of s to resAppend the j+1 th character of t to resWe continue this recursion till all characters of both the strings have been used and then we store this result in a list of strings lis as in the code below.The CodeOutput This implementation is as efficient as we can get (at least asymptotically) since we never generate the same string twice.
Several other solutions have already been posted, but most of them generate the full list of interleaved strings (or something equivalent to it) in memory, making their memory usage grow exponentially as a function of the input length.  Surely there must be a better way.Enumerating all ways to interleave two sequences, of length a and b respectively, is basically the same as enumerating all a+b bit integers with exably b bits set.  Each such integer corresponds to a distinct way to interleave the sequences, obtained by replacing every 0 bit with an element of the first sequence, and every 1 bit with an element of the second sequence.Conveniently, there's a clever and efficient way to calculate the next integer with the same number of bits set, which we can use to generate all such integers.  So let's do that first:Now we can use this generator to generate all ways to interleave any two sequences:Note that, in order to try to be as generic as possible, this code takes arbitrary sequence types and returns lists.  Strings are sequences in Python, so you can pass them in just fine; to convert the generated lists back into strings, you can concatenate their elements e.g. with "".join(), like this:There we go: a fully non-recursive efficient generator-based solution that uses very little memory even for long inputs, and only generates each output once (thus requiring no inefficient duplicate elimination step).  And it even works in both Python 2 and 3.
Highly inefficient but working:
You only need to compare the index of a to b and c to d then filter out those elements where index of a is greater than index of b and index of c is greater than index of d.Demo:
Just for sportsa solution without explicit conditionals or predicates(i.e., without any if keywords):We need a helper function for this:If the number of non-unique permutations is large, this is probably rather inefficient, due to the call to sorted. For alternatives to obtain unique permutations of non-unique values, see permutations with unique values.TL;DR?No problem. We can boil this approach down to this abomination:(Using a set comprehension on the result instead of ensuring uniqueness earlier.)


Answer URL
