Natural Text
I have two strings in Python3.x, which are defined to be the same length:I am also given an integer which is meant to represent the "starting index" of string2. In this case, start_pos = 51. The goal is to create a dictionary based on the indices. So, string1 begins at 0, string2 begins at 51. The dictionary "converting" these coordinates is as follows:which can be constructed (give the variables above) with:I currently have this data in the form of a pandas DataFrame:There are multiple entries of the same string in column column1. In this case, the dictionary for the coordinates with LJNVTJOY should be:I would like to take this DataFrame and calculate similar dictionaries of the coordinates. Such a .groupby('column1') statement looks like one should somehow use .apply()? I'm not sure how to populate dictionary lists like this...Here is the correct output (keeping the DataFrame structure). Here the DataFrame df2 has the column 'new_column' such that it looks like the following:
Use - OutputExplanationThe dict_op reuses your code to create the dict for every row and then the .apply(list) zips the dicts together to form a list of dicts.The zip_dict() then creates the output dict out of the interim output.The last piece that I haven't included is the part where if the length of the list is 1 then you can include the first element only, taking the output from {0: [79], 1: [80], 2: [81], 3: [82], 4: [83], ... to {0: 79, 1: 80, 2: 81, 3: 82, 4: 83, ... 
First apply groupby function to aggregate the "start" column as a listNow, you can write a function to create the new dictionary columnFinally, apply this function to all the rows of df2 
Here's a slightly different approach using a lambda and two zips. The truncated output of that can be seen here (note that it returns tuples rather than lists):First, to cut down on the length of the apply step, create a DataFrame with the column1 values and the associated starting positions. In addition, add a column with the length of column1 (assuming that the equal length assertion holds). After that, it's a matter of combining the range of column1 letter indices (0 through len(column1), which serves as the keys, and the same range offset by the start value(s). Things get a little dicey with the second zip because [range(s, s + x['l'] + 1) for s in x['s']] returns something that looks like this (for 'LJNVTJOY'):When we really want to group the elements aligned vertically, so we use the 'splat' or 'unpacking' operator to feed these lists into zip. Once we've combined those lists, we have a list of keys and a list (of tuples) of values, which can be zipped into a dict.


Answer URL
https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists
