Natural Text
I'm trying to create a Python function that uses the Caesar cipher to encrypt a message.   So far, the code I have isWhen I try to run my code, it will ask for the letter but it doesn't return anything after that Please help if you have any suggestions.
you would need to access your dictionary in a different way:and then you can finally call the function.
You can define two dictionaries, one the reverse of the other. You need to be careful on a few aspects:Whether case is important. If it's not, use str.casefold as below.What happens when you roll off the end of the alphabet, e.g. 13th letter after "z". Below we assume you start from the beginning again.Don't type out the alphabet manually. You can use the string module.Here's a demo:
If you need a entirely new encoded dictOutput:
The code you have only maps letters to a position.  We'll rewrite it and make a rotate function.CodeTestsDemoHere we rotated the letter "h" 13 positions, got a letter and then determined the position of this resultant letter in the normal string of abc's.Detailsabc_position()This function was rewritten to lookup the position of a letter.  It merges two dictionaries:one that enumerates a lowercase ascii lettersone that enumerates a uppercase ascii lettersThe string module has this letters already.rotate()This function only rotates lowercase letters; uppercase letters are translated from the lowercase position. The string of letters is rotated by making an infinite cycle (an iterator) of lowercase letters.The cycle is first advanced to start at the desired letter.  This is done by dropping all letters that don't look like the one passed in.  Then it is advanced in a loop some number of times equal to shift.  The loop is just one way to consume or move the iterator ahead.  We only care about the last letter, not the ones in between.  This letter is returned, either lower or uppercase.  Since a letter is returned (not a position), you can now use your abc_position() function to find it's normal position.AlternativesOther rotation functions can substitute rotate():However, these options are constrained to rot13, while rotate() can be shifted  by any number.  Note: rot26 will cycle back to the beginning, e.g. rotate("a", 26) -> a.See also this post on how to make true rot13 cipher.See also docs on itertools.cycle and itertools.dropwhile.
You can do it with quick calculations from ord and chr functions instead:so that:outputs:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.cycle
https://docs.python.org/3/library/itertools.html#itertools.dropwhile
