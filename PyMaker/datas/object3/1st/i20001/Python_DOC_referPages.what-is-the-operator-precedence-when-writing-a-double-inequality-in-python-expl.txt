Natural Text
What is the specific code, in order, being executed when I ask for something likeIf both have equal precedence and it's just the order of their evaluation, why does the second inequality function as (3 >= 2) instead of (True >= 2)Consider for example the difference between theseIs it just a pure syntactical short-cut hard-coded into Python to expand the second as the and of the two statements?Could I change this behavior for a class, such that a <= b <= c gets expanded to something different? It's looking like the following is the casebut the real question is how this gets implemented in code.I'm curious so that I can replicate this kind of __lt__ and __gt__ behavior in some of my own classes, but I am confused about how this is accomplished holding the middle argument constant.Here's a specific example:It would be nice to override this so that it "just works" with arrays too, like this:Added for clarificationIn the comments it is indicated that I did a poor job of explaining the question. Here's some clarifying remarks:1) I am not looking for a simple explanation of the fact that the interpreter pops an and in between the two chained inequalities. I already knew that and said so above.2) For an analogy to what I want to do, consider the with statement (link). The following:unpacks into So by writing MyClass appropriately, I can do many special things inside of the with statement.I am asking whether there is a similar code unpacking of the chained inequality by which I can intercept what it's doing and redirect it to use array-style logical operators instead just for the classes I care about.I feel this is very clear from my question, especially the example, but hopefully this makes it more clear.
I'm not totally sure what you're looking for, but a quick disassembly shows that a < b < c is not compiled to the same bytecode as a < b and b < cEdit 1: Digging further, I think this is something weird or wrong with numpy. Consider this example code, I think it works as you would expect.Edit 2: Actually this doesn't work "properly"...I think it's comparing boolean values to numbers in the second comparison of 1 < x < 3.Edit 3: I don't like the idea of returning non-boolean values from the gt, lt, gte, lte special methods, but it's actually not restricted according to the Python documentation.http://docs.python.org/reference/datamodel.html#object.ltBy convention, False and True are returned for a successful  comparison. However, these methods can return any value...
Both have the same precedence, but are evaluated from left-to-right according to the documentation. An expression of the form a <= b <= c gets expanded to a <= b and b <= c.
but the real question is how this gets implemented in code.Do you mean how the interpreter transforms it, or what? You already saidso I'm not sure what you're asking hereOK, I figured it out: no, you cannot override the expansion from a < b < c into (a < b) and (b < c) IIUC.I'm curious so that I can replicate this kind of __lt__ and __gt__ behavior in some of my own classes, but I am confused about how this is accomplished holding the middle argument constant.It depends which of a, b and c in the expression a < b < c are instances of your own class. Implementing your __lt__ and __gt__ and methods gets some of the way, but the documentation points out that:There are no swapped-argument versions of these methods (to be used when the left argument does not support the operation but the right argument does)So, if you want Int < MyClass < Int, you're out of luck. You need, at a minimum, MyClass < MyClass < Something (so an instance of your class is on the LHS of each comparison in the expanded expression).


Answer URL
https://docs.python.org/3/reference/expressions.html#comparisons
