Natural Text
This question already has an answer here:Removing duplicates in lists                    44 answers                I want to get the unique values from the following list:The output which I require is:This code works:is there a better solution I should use?
First declare your list properly, separated by commas. You can get the unique values by converting the list to a set.If you use it further as a list, you should convert it back to list by doing:Another possibility, probably faster would be to use a set from the beginning, instead of a list. Then your code should be:As it has been pointed out, the sets do not maintain the original order. If you need so, you should look up about the ordered set.
To be consistent with the type I would use:
what type is your output variable?Python sets are what you just need. Declare output like this:and you're ready to go adding elements with output.add(elem) and be sure they're unique.Warning: sets DO NOT preserve the original order of the list.
The example you provided does not correspond to lists in Python. It resembles a nested dict, which is probably not what you intended.A Python list:To get unique items, just transform it into a set (which you can transform back again into a list if required):
If we need to keep the elements order, how about this:And one more solution using reduce and without the temporary used var.UPDATE - March, 2019And a 3rd solution, which is a neat one, but kind of slow since .index is O(n).UPDATE - Oct, 2016Another solution with reduce, but this time without .append which makes it more human readable and easier to understand.NOTE: Have in mind that more human-readable we get, more unperformant the script is.ANSWERING COMMENTS Because @monica asked a good question about "how is this working?". For everyone having problems figuring it out. I will try to give a more deep explanation about how this works and what sorcery is happening here ;)So she first asked:I try to understand why unique = [used.append(x) for x in mylist if x  not in used] is not working.Well it's actually workingThe problem is that we are just not getting the desired results inside the unique variable, but only inside the used variable. This is because during the list comprehension .append modifies the used variable and returns None.So in order to get the results into the unique variable, and still use the same logic with .append(x) if x not in used, we need to move this .append call on the right side of the list comprehension and just return x on the left side.But if we are too naive and just go with:We will get nothing in return. Again, this is because the .append method returns None, and it this gives on our logical expression the following look: This will basically always:evaluates to False when x is in used,evaluates to None when x is not in used.And in both cases (False/None), this will be treated as falsy value and we will get an empty list as a result.But why this evaluates to None when x is not in used? Someone may ask. Well it's because this is how Python's short-circuit operators works.The expression x and y first evaluates x; if x is false, its value is  returned; otherwise, y is evaluated and the resulting value is  returned.So when x is not in used (i.e. when its True) the next part or the expression will be evaluated (used.append(x)) and its value (None) will be returned. But that's what we want in order to get the unique elements from a list with duplicates, we want to .append them into a new list only when we they came across for a fist time. So we really want to evaluate used.append(x) only when x is not in used, maybe if there is a way to turn this None value into a truthy one we will be fine, right? Well, yes and here is where the 2nd type of short-circuit operators come to play.The expression x or y first evaluates x; if x is true, its value is  returned; otherwise, y is evaluated and the resulting value is  returned.We know that .append(x) will always be falsy, so if we just add one or next to him, we will always get the next part. That's why we write:so we can evaluate used.append(x) and get True as a result, only when the first part of the expression (x not in used) is True.Similar fashion can be seen in the 2nd approach with the reduce method.where we:Append x to l and return that l when x is not in l. Thanks to the or statement .append is evaluated and l is returned after that.Return l untouched when x is in l
Maintaining order:Order doesn't matter:   
This is simple solution-
Getting unique elements from ListUsing Simple Logic from Sets - Sets are unique list of itemsUsing Simple LogicUsing pop method  ->pop removes the last or indexed item and displays that to user. videoUsing NumpyReference
set - unordered collection of unique elements. List of elements can be passed to set's constructor. So, pass list with duplicate elements, we get set with unique elements and transform it back to list then get list with unique elements. I can say nothing about performance and memory overhead, but I hope, it's not so important with small lists.Simply and short.
If you are using numpy in your code (which might be a good choice for larger amounts of data), check out numpy.unique:(http://docs.scipy.org/doc/numpy/reference/generated/numpy.unique.html)As you can see, numpy supports not only numeric data, string arrays are also possible. Of course, the result is a numpy array, but it doesn't matter a lot, because it still behaves like a sequence:If you really want to have a vanilla python list back, you can always call list().However, the result is automatically sorted, as you can see from the above code fragments. Check out numpy unique without sort if retaining list order is required.
Same order unique list using only a list compression.enumerates gives the index i and element e as a tuple.my_list.index returns the first index of e. If the first index isn't i then the current iteration's e is not the first e in the list.EditI should note that this isn't a good way to do it, performance-wise. This is just a way that achieves it using only a list compression.
By using basic property of Python Dictionary:Output will be:
First thing, the example you gave is not a valid list.Suppose if above is the example list. Then you can use the following recipe as give the itertools example doc  that can return the unique values and preserving the order as you seem to require. The iterable here is the example_list 

set can help you filter out the elements from the list that are duplicates. It will work well for str, int or tuple elements, but if your list contains dict or other list elements, then you will end up with TypeError exceptions.Here is a general order-preserving solution to handle some (not all) non-hashable types:
As a bonus, Counter is a simple way to get both the unique values and the count for each value:

In addition to the previous answers, which say you can convert your list to set, you can do that in this way toooutput will bethough order will not be preserved. Another simpler answer could be (without using sets)
To get unique values from your list use code below:IMPORTANT:Approach above won't work if any of items in a list is not hashable which is case for mutable types, for instance list or dict.That means that you have to be sure that trends list would always contains only hashable items otherwise you have to use more sophisticated code:
I am surprised that nobody so far has given a direct order-preserving answer:It will generate the values so it works with more than just lists, e.g. unique(range(10)). To get a list, just call list(unique(sequence)), like this:It has the requirement that each item is hashable and not just comparable, but most stuff in Python is and it is O(n) and not O(n^2), so will work just fine with a long list.
At the begin of your code just declare your output list as empty: output=[]Instead of your code you may use this code trends=list(set(trends))
You can use sets. Just to be clear, I am explaining what is the difference between a list and a set. sets are unordered collection of unique elements.Lists are ordered collection of elements.So,But: Do not use list/set in naming the variables. It will cause error: EX: Instead of use list instead of unicode_list in the above one. 
Alternatively in Python 3.6+:
use set to de-duplicate a list, return as list
Set is a collection of ordered and unique elements. So, you can use set as below to get a unique list:
If you want to get unique elements from a list and keep their original order, then you may employ OrderedDict data structure from Python's standard library:In fact, if you are using Python â‰¥ 3.6, you can use plain dict for that:It's become possible after the introduction of "compact" representation of dicts. Check it out here. Though this "considered an implementation detail and should not be relied upon".
My solution to check contents for uniqueness but preserve the original order:Edit:Probably can be more efficient by using dictionary keys to check for existence instead of doing a whole file loop for each line, I wouldn't use my solution for large sets. 
I know this is an old question, but here's my unique solution: class inheritance!:Then, if you want to uniquely append items to a list you just call appendunique on a UniqueList. Because it inherits from a list, it basically acts like a list, so you can use functions like index() etc. And because it returns true or false, you can find out if appending succeeded (unique item) or failed (already in the list).To get a unique list of items from a list, use a for loop appending items to a UniqueList (then copy over to the list).Example usage code:Prints:Copying to list:Prints:
For long arrays
Try this function, it's similar to your code but it's a dynamic range.


Answer URL
https://docs.python.org/3/library/collections.html#collections.OrderedDict
