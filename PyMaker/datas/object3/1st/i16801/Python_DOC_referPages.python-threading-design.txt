Natural Text
I'm trying to write a mini-game that allows me to practice my python threading skill. The game itself involves with timed bombs and citys that have them. Here is my code:I currently don't know what is a good way for the City class to effectively keep track of the bomb status.The first thought I had was to use a for loop to have the City to check all the bombs in the City, but I found it being too stupid and inefficientSo here is the question:What is the most efficient way of implementing the bomb and City so that the city immediately know the state change of a bomb without having to check it every second?PS: I do NOT mean to use this program to set off real bomb, so relax :D
A good case to use queue. Here is an example of the so-called producer - consumer pattern.The work threads will run forever till your main program is done (that is what the daemon part and the "while True" is for). They will diligently monitor the in_queue for work packages. They will process the package until none is left. So when the in_queue is joined, your work threads' jobs are done. The out_queue here is an optional downstream processing step. So you can assemble the pieces from the work threads to a summary form. Useful when they are in a function.If you need some outputs, like each work thread will print the results out to the screen or write to one single file, don't forget to use semaphore! Otherwise, your output will stumble onto each other.Good luck!
The standard way of doing something like this is to use a queue - one thread watches the queue and waits for an object to handle (allowing it to idle happily), and the other thread pushes items onto the queue.Python has the queue module (Queue in 2.x). Construct a queue in your listener thread and get() on it - this will block until something gets put on.In your other thread, when a relevant event occurs, push it onto the queue and the listener thread will wake up and handle it. If you do this in a loop, you have the behaviour you want.
The easiest way would be to use a scheduler library.  E.g. https://docs.python.org/2/library/sched.html. Using this you can simply schedule bombs to call a function or method at the time they go off.  This is what I would recommend if you did not wanted to learn about threads.E.g.However, that way you will not learn about threads.If you really want to use threads directly, then you can simply let the bombs call sleep until it is their time to go off. E.g. However, this is not a nice way to handle threads, since the threads will block your application. You will not be able to exit the application until you stop the threads. You can avoid this by making the thread a daemon thread. bomb.daemon = True. In some cases, the best way to handle this is to actually "wake up" each second and check the status of the world. This may be the case when you need to perform some cleanup actions when the thread is stopped. E.g. You may need to close a file. Checking each second may seem wasteful, but it is actually the proper way to handle such problems. Modern desktop computers are mostly idle. To be interrupted for a few milliseconds each second will not cause them much sweat.
Before you start "practising threading with python", I think it is important to understand Python threading model - it is Java threading model, but comes with a more restrictive option:https://docs.python.org/2/library/threading.htmlThe design of this module is loosely based on Java’s threading model.  However, where Java makes locks and condition variables basic behavior  of every object, they are separate objects in Python. Python’s Thread  class supports a subset of the behavior of Java’s Thread class;  currently, there are no priorities, no thread groups, and threads  cannot be destroyed, stopped, suspended, resumed, or interrupted. The  static methods of Java’s Thread class, when implemented, are mapped to  module-level functions.Locks being in separate objects, and not per-object, following the diagram below, means less independent scheduling even when different objects are accessed - because possibly even same locks are necessary.For some python implementation - threading is not really fully concurrent:http://uwpce-pythoncert.github.io/EMC-Python300-Spring2015/html_slides/07-threading-and-multiprocessing.html#slide-5A thread is the entity within a process that can be scheduled for  executionThreads are lightweight processes, run in the address space of an OS  process.These threads share the memory and the state of the process. This  allows multiple threads access to data in the same scope.Python threads are true OS level threadsThreads can not gain the performance advantage of multiple processors  due to the Global Interpreter Lock (GIL)http://uwpce-pythoncert.github.io/EMC-Python300-Spring2015/html_slides/07-threading-and-multiprocessing.html#slide-6And this (from above slide):


Answer URL
https://docs.python.org/3/library/queue.html
