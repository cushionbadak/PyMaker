Natural Text
I have multiple tests run by py.test that are located in multiple classes in multiple files.  What is the simplest way to share a large dictionary - which I do not want to duplicate - with every method of every class in every file to be used by py.test? In short, I need to make a "global variable" for every test. Outside of py.test, I have no use for this variable, so I don't want to store it in the files being tested. I made frequent use of py.test's fixtures, but this seems overkill for this need.  Maybe it's the only way?
Update: scroll down to a better approach.Aside from a better pytest-specific option suggested by @flub, you can create a base TestCase class, define a class variable and subclass the base class in every test you have:
Update: pytest-namespace hook is deprecated/removed. Do not use. See #3735 for details.You mention the obvious and least magical option: using a fixture.  You can apply it to entire modules using pytestmark = pytest.mark.usefixtures('big_dict') in your module, but then it won't be in your namespace so explicitly requesting it might be best.Alternatively you can assign things into the pytest namespace using the hook:And now you have pytest.my_big_dict. The fixture is probably still nicer though.
There are tons of things I love about py.test, but one thing I absolutely HATE is how poorly it plays with code intelligence tools. I disagree that an autouse fixture to declare a variable is the "most clear" method in this case because not only does it completely baffle my linter, but also anyone else who is not familiar with how py.test works. There is a lot of magic there, imo.So, one thing you can do that doesn't make your linter explode and doesn't require TestCase boilerplate is to create a module called globals. Inside this module, stub the names of the things you want global to {} or None and import the global module into your tests. Then in your conftest.py file, use the py.test hooks to set (or reset) your global variable(s) as appropriate. This has the advantage of giving you the stub to work with when building tests and the full data for the tests at runtime.For example, you can use the pytest_configure() hook to set your dict right when py.test starts up. Or, if you wanted to make sure the data was pristine between each test, you could autouse a fixture to assign your global variable to your known state before each test.One other advantage to this approach is you can use type hinting in your globals module to give you code completion on the global objects in your test, which probably isn't necessary for a dict but I find it handy when I am using an object (such as webdriver). :)
Having a big dictionary of globals that every test uses is probably a bad idea. If possible, I suggest refactoring your tests to avoid this sort of thing.That said, here is how I would do it: define an autouse fixture that adds a reference to the dictionary in the global namespace of every function.Here is some code. It's all in the same file, but you can move the fixture out to conftest.py at the top level of your tests.Here is the output from when I run this code:Note that you can't use a session-scoped fixture because then you don't have access to each function object. Because of this, I'm making sure to define my big global dictionary once and use references to it -- if I defined the dictionary in that assignment statement, a new copy would be made each time.In closing, doing anything like this is probably a bad idea. Good luck though :)
I'm suprised no answer mentioned caching yet: since version 2.8, pytest has a powerful cache mechanism.Usage exampleAccess the data dict in tests via builtin request fixture:Sharing the data between test runsThe cool thing about request.cache is that it is persisted on disk, so it can be even shared between test runs. This comes handy when you running tests distributed (pytest-xdist) or have some long-running data generation which does not change once generated:Now the tests won't need to recalculate the value on different test runs unless you clear the cache on disk explicitly. Take a look what's currently in the cache:Rerun the tests with the --cache-clear flag to delete the cache and force the data to be recalculated. Or just remove the .pytest_cache directory in the project root dir.Where to go from hereThe related section in pytest docs: Cache: working with cross-testrun state.
You can add your global variable as an option inside the pytest_addoption hook. It is possible to do it explicitly with addoption or use set_defaults method if you want your attribute be determined without any inspection of the command line, docs When option was defined, you can paste it inside any fixture with request.config.getoption and then pass it to the test explicitly or with autouse.Alternatively, you can pass your option into almost any hook inside the config object.


Answer URL
https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.set_defaults
