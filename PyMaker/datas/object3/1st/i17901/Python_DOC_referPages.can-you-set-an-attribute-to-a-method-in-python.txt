Natural Text
This question already has an answer here:Why does setattr fail on a bound method                    2 answers                I'm wondering if it is possible to use setattr to set an attribute to a method within a class like so because when I try I get an error which is going to be shown after the code:Which errors AttributeError: 'method' object has no attribute 'string' so I tried it without putting .string and just tried test.getString("myString") Same error, but then I tried it without the using the class just like thisIt returned "myString" like I wanted it to, so how would I do this within a class and why does it work outside of one but inside of one? 
type( test.getString ) is builtins.method and from the documentations ( methods ), since method attributes are actually stored on the underlying function  object (meth.__func__), setting method attributes on bound methods is  disallowed. Attempting to set an attribute on a method results in an  AttributeError being raised.There are (at least) two possible solutions depending on which behaviour you are looking for. One is to set the attribute on the class method:and the other is to use function objects:
Functions are like most other objects in that you can freely add attributes to them. Methods, on the other hand... conceptually they're just functions, but they behave slightly differently (implicity pass self) and therefore are implemented with a bit of extra glue around functions.Every time self.getString is evaluated, a new (bound) method object is created, which is a thin wrapper around the underlying function (which you can access as Test.getString). These method objects don't allow adding attributes, and even if they did, your code would not work because it juggles multiple distinct method objects (though they all wrap the same function).You can't make this work with bound methods. Since you presumably want the string to be attached to the Test object (indirectly, by being attached to its method), you can make it an attribute of Test. You could even create your own object that behaves like a method but allows attributes (you'd have to explicitly add it in __init__), but honestly there's probably a better way that keeps data and methods separated. If, on the other hand, you want to attach this attribute to the underlying function (which would mean it's shared by all Test instances), you can just set the attribute on Test.getString.
So, I found a way but it's not really how I wanted to do it personally. If anyone does find another way to do the following code feel free to comment on how to do it. Like I said, I don't feel like I accomplished anything by doing it that way, but it works for what I need and if you do find another way comment below.


Answer URL
