Natural Text
I solved the project euler problem 21 using the following approach using python.It took around 35 seconds. I was wondering whether there is a better approach. How can I improve my algorith
To get more speed you need a better algorithm. Let's start with a function that finds the factors of n using a prime wheel, which is faster than naive trial division and suitable when n is small:Then we use the factors of n to compute the sum of the divisors of n, without computing the divisors themselves; note the sum includes n itself:Now it's just a matter of computing all the sums of divisors less than the limit, saving them in an array. If the sum of divisors of n is less than n, we check the previously-computed sum of divisors of the sum of divisors, and report those that are equal:Now we can run it:I didn't time it, but it obviously takes less than a second. There are five amicable pairs less than ten thousand, including 220 and 284 which were used in the example.An even faster approach uses a sieve, similar to the Sieve of Eratosthenes, to accumulate the divisors of a range of numbers:That computes the sumDiv array, which can be used in the solution:And here is the solution, which appears instantly when my finger presses the Enter button:If you want to know more, I explain wheel factorization, the sum of divisors computation, and the sieving method at my blog.
You can improve the algorithm by noting that you need not loop through all possible numbers smaller than i to find an amicable pair.Note that the problem of finding amicable pairs can be reformulated to the following 2 conditions:sum(factors(sum(factors(i)))) = isum(factors(i)) != iI don't claim the following is the fastest possible, but it's an improvment over 35 seconds:Note: we need to subtract i from sum(factorize(i)) - i due to my factorize function also including the number itself in the list of factors, while amicable numbers only require 'proper divisors'
The other answers work great, but here is yet another algorithm that touches on a topic you might find useful later in the PE series. This is an optimization on the sieve that user448810 posted. Here's the algorithm outline.Find prime factors of all numbers using a sieveCalculate the multiplicity of each factor using a Ruler FunctionSum the divisors using this formula.The initial code would look like thisSo far so good, except how do we calculate v which is defined as the number of times p divides into m. The naive solution would be to write:But this greatly increases the time complexity of our program. Instead we take advantage of the fact that we are calculating this for all multiples of p in order.Really, I want how many powers of p are in p, 2p, 3p, 4p... Which is sometimes referred to as a generalized ruler function. For example with p = 2 we want to find the v's below.Thankfully, generating this sequence is much easier than counting how many times we can divide a number. So we define a ruler generator as followsSo the final code becomes:Which gives the output


Answer URL
