Natural Text
im trying to rewrite every character in a file with rot 13 and im stuck, im not sure how to go through the file and look at every character and not worry about the spaces between paragraphs
If you just want to do this as easily as possible, use the rot_13 codec, as described in Joran Beasley's answer.If you want to know how to do it manually, or what was wrong with your existing code, I can explain. You're actually very close.If f is a file, for char in f: iterates over the lines of the file, not the characters. If you want to iterate over the characters one by one, either loop around f.read(1), or read the whole thing into a string with s = f.read() and then iterate over s.If you fix that, your program now works as written. However, it's more complicated than necessary.First, char = char.replace(char, chr(x + 13)) is unnecessary. str.replace searches the string, substitutes the replacement character for all instances of the search character, and returns the resulting string. But you don't need any of that—you're searching all one character, replacing the one instance of the search character with the resulting character, and returning the resulting character as a one-character string—in other words, the same string you already had. All you want to do here is char = chr(x + 13).Also, you can remove the three separate result = result + char and continue; all three conditions lead to the same thing.Also, instead of comparing x to ordinal values (which are hard to read, and easy to get wrong), you can just compare char to character values. So:You can simplify your comparisons further by using str.lower:(This replaces the if 'a'… line in the above code, and you do the same thing for the elif 'n'… line.)You can simplify things even further by using the collections in the string class:(This replaces the whole if/elif block.)Or, if you know that the % (mod/remainder) operator does, you can simplify it even further: rot13(ch) is just (ch+13) % 26 (where ch is a letter number from 0 to 25, which you can get with ord(char) % 32). The usual C implementations take advantage of this, and you can write them more clearly with the divmod function in Python. But I'll leave that as an exercise for the reader.
See the documentation on the codecs module, or the built-in help in the interactive interpreter, for an explanation of these functions. See the documentation on the Standard Encodings (and following sections), or import the encodings module and use the built-in help, to see a list of encodings you can use with these functions.


Answer URL
