Natural Text
Consider a sequence of coin tosses: 1, 0, 0, 1, 0, 1 where tail = 0 and head = 1.The desired output is the sequence: 0, 1, 2, 0, 1, 0Each element of the output sequence counts the number of tails since the last head.I have tried a naive method:Question: Is there a better method?
Using NumPy:yieldsWhy arr - np.maximum.accumulate(arr * seq)? The desired output seemed related to a simple progression of integers:So the natural question is, if seq = np.array([1, 0, 0, 1, 0, 1]) and the expected result is expected = np.array([0, 1, 2, 0, 1, 0]), then what value of x makesSinceit looks like x should be the cumulative max of arr * seq:
Step 1: Invert l:Step 2: List comp; add previous value to current value if current value is 1.This gets rid of windy ifs by zipping adjacent elements.
Using itertools.accumulate:accumulate is only defined in Python 3. There's the equivalent Python code in the above documentation, though, if you want to use it in Python 2.It's required to invert a because the first element returned by accumulate is the first list element, independently from the accumulator function:
The required output is an array with the same length as the input and none of the values are equal to the input. Therefore, the algorithm must be at least O(n) to form the new output array. Furthermore for this specific problem, you would also need to scan all the values for the input array. All these operations are O(n) and  it will not get any more efficient. Constants may differ but your method is already in O(n) and will not go any lower.
Using reduce:time = reduce(lambda l, r: l + [(l[-1]+1)*(not r)], seq, [0])[1:]
I try to be clear in the following code and differ from the original in using an explicit accumulator. 


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.accumulate
