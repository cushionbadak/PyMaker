Natural Text
I want to match a string to a specific pattern or set of words, like below:the apple is red is the query andthe apple|orange|grape is red|orange|violet is the pattern to match.The pipes would represent words that would substitute each other. The pattern could also be grouped like [launch app]|[start program]. I would like the module to return True or False whether the query matches the pattern, naturally.What is the best way to accomplish this if there is not a library that does this already? If this can be done with simple regex, great; however I know next to nothing about regex. I am using Python 2.7.11
please let me know if this correctly answers your question.Here's an example of it running:If there are no matches then re.search() will return nothing.You may know "next to nothing about regex" but you nearly wrote the pattern.The sections within the parentheses can also have their own regex patterns, too. So you could match "apple" and "apples" withr'the (apple[s]*|orange|grape)
The re based solutions for this kind of problem work great. But it would sure be nice if there were an easy way to pull data out of strings in Python without have to learn regex (or to learn it AGAIN, which what I always end up having to do since my brain is broken). Thankfully, someone took the time to write parse. parseparse is a nice package for this kind of thing. It uses regular expressions under the hood, but the API is based on the string format specification mini-language, which most Python users will already be familiar with. For a format spec you will use over and over again, you'd use parse.compile. Here is an example: parmatterI have put a package I created for my own use on pypi  in case others find it useful. It make things just a little bit nicer. It makes heavy usage of parse. The idea is to combine the functionality of a string.Formatter and a parse.Parser into a single object, which I have called a parmatter (also the package name). The package contains a number of useful custom parmatter types. StaticParmatter has a precompiled parsing specification (similar to the object from parse.compile above). Use it like this: Note that for "unformatting", the parse package uses the method name parse. However, my package uses unformat. The reason for this is that parmatter classes are subclassed from string.Formatter, and string.Formatter already has a .parse() method (which provides different functionality). Additionally, I think unformat is a more  intuitive method name, anyway. EDIT: see also my previous answer to another question, which discusses these packages as well. 


Answer URL
https://docs.python.org/3/library/string.html#format-specification-mini-language
