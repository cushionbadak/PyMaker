Natural Text
I'm having trouble using SyncManager.Lock correctly. I read the official doc, but it offers no working example. I also have no idea how to use SyncManager.Event correctly.Below is the minimal code to illustrate my problem. client1 and client2 both need to update a shared object Struct. However, I want client1 to acquire the lock first, update Struct, and then pass control to client2. If you run the code below as-is, the print statements are all mixed up.Sample output:
I figured out a workaround. Don't use the builtin SyncManager.Lock() for the following reasons:It's creating a new Lock object every time instead of sharing.It wraps around threading.Lock(), NOT multiprocess.Lock(). Looks like it doesn't work with multiprocessing!Solution is to register your own lock manager:


Answer URL
https://docs.python.org/3/library/multiprocessing.html#multiprocessing.managers.SyncManager.Lock
