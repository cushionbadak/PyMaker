Natural Text
This question already has an answer here:python class instance variables and class variables                    4 answers                How to avoid having class data shared among instances?                    8 answers                The following code troubles me:-The output is:- meaning that the list tricks is shared by the two instances t1 and t2, which has been explained in the section 9.3.5 of https://docs.python.org/3/tutorial/classes.html However, if I execute the following code:-The output is the following:-Now it seems that the list tricks is no longer shared by those two instances t1 and t2. My question is, what are the mechanics here? 
The difference is that in your second example you are creating a new list, self.tricks, as an attribute of the object:The first example works because of Python's way of resolving the names: If self.tricks cannot be found in the object (because it hasn't been created), then it tries to find it as a member of the class. Since tricks is there, then you can access it.It may become clear to you if you try to use mytest.tricks in your second example:That will output what you are actually expecting.
In the first case, you didn't create a tricks attribute on the object scope, so Python used the one from the class; in the second case, you created a new list and associated it with the object itself, so Python used that.For a way more thorough explanation, please, take a look at: Python Class Attributes: An Overly Thorough Guide
In your first example, the class mytest has a tricks member, shared by all its instances:In your second example, however, mytest instances additionnally have a tricks member:The self.tricks = [name] statement gives an attribute named tricks to self, that is, the mytest instance.The class still has a common tricks member.When calling instance.tricks, Python first looks for a tricks member in instance.__dict__. If it does not find any, it looks for a tricks member in type(instance).__dict__.Therefore, instances of your first example have no tricks attribute, but Python will give you the mytest.tricks they all share.On the other hand, instances of your second example do have their own tricks attribute, and Python will return this one.
Your first case creates a class variable, and the second creates an instance variable.When you do refer self.foo, Python first checks for a  foo element in the instance's namespace dictionary, and then checks for a foo element in the class's namespace dictionary.In the first case, since you created a class variable named tricks with a mutable type (a list), and didn't re-assign it specifically on the method, modifications to that list are available to every instance of the class.In your second case, things are identical except that you hid the class variable with an instance variable of the same name, so from that point on, all references to self.tricks refer to the instance variable instead of the class variable.The second case illustrated:
There's a little thing to note here in this problem.When you pass in the name and append it to the existing shared tricks list, it is, as you saw, shared by all the values, because it is that list.However, when you do self.tricks=[name] in your second example, you are erasing that objects instance of self.tricks and are replacing it with the list [name]This is similar to having a parent and child class; when the child class doesn't give a different definition for an existing function, calling it calls the parent's function. But if you do, it calls the child's function.
In the both case, you replacing the self.name to a new value.In the first case you're mutating the self.tricks list, mutating a list don't replace it. so during the whole execution you have a single list, being mutated.In the second case, the line self.tricks=[name] is changing the list, creating a new list object.You can easily introspect this like:Giving:


Answer URL
https://docs.python.org/3/tutorial/classes.html
