Natural Text
Why print(A()._m()) prints None, but print(B()._m()) raises AttributeError: 'B' object has no attribute '_B__get'?I thought that double underscore prevents method overriding.UPDATEYou write that __get is private.Then why does the following work?Why does this code doesn't raise AttributeError and prints None two times?
Leading double underscore names are private (meaning not available to derived classes)This is not foolproof.  It is implemented by mangling the name.  Python Documentation says:Any identifier of the form __spam (at least two leading underscores,  at most one trailing underscore) is textually replaced with  _classname__spam, where classname is the current class name with leading underscore(s) stripped. This mangling is done without regard  to the syntactic position of the identifier, so it can be used to  define class-private instance and class variables, methods, variables  stored in globals, and even variables stored in instances. private to  this class on instances of other classes.Thus __get is actually mangled to _A__get in class A.  When class B attempts to reference __get, it gets mangled to _B__get which doesn't match.In other words __plugh defined in class Xyzzy means "unless you are running as class Xyzzy, thou shalt not touch the __plugh."
For _ _methodName() member function of class A, Call this member function from outside of class A, you can only call _A__methodName() (trying call __methodName() will generate error.)If Calling this member function inside class A, you can use both _A__methodName() and __methodName().


Answer URL
https://docs.python.org/3/tutorial/classes.html#private-variables-and-class-local-references
https://docs.python.org/3/tutorial/classes.html#private-variables
