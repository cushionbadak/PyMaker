Natural Text
From here:Return a proxy object that delegates method calls to a parent or sibling class of type. This is useful for accessing inherited methods that have been overridden in a class. The search order is same as that used by getattr() except that the type itself is skipped.If the second argument is omitted, the super object returned is  unbound. If the second argument is an object, isinstance(obj, type) must be  true. If the second argument is a type, issubclass(type2, type) must be  true (this is useful for classmethods).If I am correct, a type is a class, and a class is a type. A classis an object, so a type is also an object.  Why does the quotedistinguish the two cases when the second argument being an object when it is a type?When the second argument is a type, why is issubclass(type2, type)required to be true?What is the type of the super object    returned by super in each of the three cases respectively? Or how do you determine the type of the super object returned by super?When the second argument is an object, because "The search order is same as that used by getattr() except that the type itself is skipped", I guessed that the type of the superobject returned by super function should be a subclass of any ancestry class of the first argument type, but I found that it is actually not by testing with issubclass. So did I misunderstand something?
You seem to be confusing the word type with the type() built-in. Here they simply references the first argument passed into super().What the documentation tells you is that if you pass in two arguments, then the second argument either has to be an instance of the first argument, or it has to be a subclass. In other words, either isinstance(first_argument, second_argument) or issubclass(first_argument, second_argument) must be true. There is no other meaning here.Just like int() or str() or any of the other built-in types, the type of the object returned by calling super() is that type. There are no separate types returned for different arguments. See the C source code defining the object.The super() object implements a __getattribute__ hook that implements specific attribute behaviour. The documentation tells you that the rules for attribute lookups are the same as for getattr() (but with the documented MRO skip), but that does not mean that super() returns an ancestor class.What actually happens is that super().__getattribute__ takes the MRO of the second argument (either type(instance).__mro__ or cls.__mro__, depending on wether isinstance() or issubclass() was true), find the first argument in that sequence and start testing for attributes after that. Because the MRO is scanned for the (type of) the second argument first, it does have to be findable, which is why the constraints are what they are. In Pure Python, this is what super() does (simplified to focus on just the two argument behaviour):
just for the point 3 about the type super in the 3 cases (2 first are similar):


Answer URL
https://docs.python.org/3/library/functions.html#type
