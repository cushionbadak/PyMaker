Natural Text
I have a 2 dictionaries: the values in each dictionary should all be equal.BUT I don't know what that number will be...N.B. A does not equal BN.B. Both A and B are actually strings of decimal numbers (e.g. '-2.304998') as they have been extracted from a text file  I want to create another dictionary - that effectively summarises this data - but only if all the values in each dictionary are the same.i.e.  Is there a neat way of doing this in one line?   I know it is possible to create a dictionary using comprehensionssummary = {k:v for (k,v) in zip(iterable1, iterable2)}but am struggling with both the underlying for loop and the if statement...Some advice would be appreciated. I have seen this question, but the answers all seem to rely on already knowing the value being tested (i.e. are all the entries in the dictionary equal to a known number) - unless I am missing something. 
sets are a solid way to go here, but just for code golf purposes here's a version that can handle non-hashable dict values:all terminates early on a mismatch, but the set constructor is well enough optimized that I wouldn't say that matters without profiling on real test data. Handling non-hashable values is the main advantage to this version.
While we can use set for this, doing so has a number of inefficiencies when the input is large. It can take memory proportional to the size of the input, and it always scans the whole input, even when two distinct values are found early. Also, the input has to be hashable.For 3-key dicts, this doesn't matter much, but for bigger ones, instead of using set, we can use itertools.groupby and see if it produces multiple groups:
One way to do this would be to leverage set. You know a set of an iterable has a length of 1 if there is only one value in it:This of course, only works if the values of your dictionary are hashable.
Except for readability, I don't care for all the answers involving set or .values. All of these are always O(N) in time and memory. In practice it can be faster, although it depends on the distribution of values.Also because set employs hashing operations, you may also have a hefty large constant multiplier to your time cost. And your values have to hashable, when a test for equality is all that's needed.It is theoretically better to take the first value from the dictionary and search for the first example in the remaining values that is not equal to.set might be quicker than the solution below because its workings are may reduce to C implementations.In the above:is equivalent to:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.groupby
