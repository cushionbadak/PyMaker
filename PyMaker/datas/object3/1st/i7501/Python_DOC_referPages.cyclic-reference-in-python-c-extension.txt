Natural Text
I have the following C++ class :.H.CPPI exposed it as follows with Cython :My problem is that I can't figure out how to get the destructor called from Python. The following does exactly nothing :I can't find similar issues on the web. Does any of you has an idea of is appening to me here ?I'm I missing something about reference counting management, or ...Thanks a lot
del a_set removes a reference to the object (the local variable). There's still another reference, in the C++ object. This is known as a reference cycle. The cycle GC could collect this after a while. However, there is no guarantee when (or even if) this happens, so you should not rely on it1.For example, reference cycles containing pure Python objects with a __del__ special method are documented to not be freed at all:Changed in version 3.4: Following PEP 442, objects with a __del__() method donâ€™t end up in gc.garbage anymore.I don't know whether Cython's implementation of __dealloc__ triggers this behavior, but as outlined before, destruction isn't deterministic anyway. If you want to free some resource (e.g. a block of memory that isn't a Python object, a file, a connection, a lock, etc.) you should expose an explicit way of doing so manually (cf. the close methods of various objects). Context managers can simplify client code doing this.Disclaimer: Almost all of this is CPython-specific.1 Some people prefer thinking of GC as an abstraction that simulates availability of infinite memory, rather than something that destroys unreachable objects. With this approach, it becomes quite obvious that destruction is not deterministic and not even guaranteed.


Answer URL
https://docs.python.org/3/library/gc.html#gc.garbage
