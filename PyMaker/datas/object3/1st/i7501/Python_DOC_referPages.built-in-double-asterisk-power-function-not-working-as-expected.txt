Natural Text
This question already has an answer here:Calculation error with pow operator                    4 answers                This prints -2.4:But this prints an imaginary number...?I can't figure out what is causing this and this problem is breaking my program. How do you make it so that the second statement outputs the same as the first in a general case that works for positive and negative values for a?
Per the Python 3.6 documentation: 6.5. The power operatorThe power operator binds more tightly than unary operators on its left; it binds less tightly than unary operators on its right. The syntax is:Thus, in an unparenthesized sequence of power and unary operators, the operators are evaluated from right to left (this does not constrain the evaluation order for the operands): -1**2 results in -1.Thus, in the first example:It's evaluated right to left as ** has higher precedence than unary -, binding tighter -- so here, 3 ** 0.8 is evaluated first, then the unary - operator is applied for a negative value. In the second example however, the expression is equivalent (-3) ** 0.8 as -3 is stored in a name, and evaluation results is an imaginary number:A solution would be to calculate the result without unary operators, then applying a sign as necessary, per Shakar Bhattarai's answer:The first part, int(a / abs(a)) evaluates to either -1.0 or 1.0 depending on if a is negative or not, basically applying the sign. It then multiplies that by the result of a ** b regardless of a's sign. That will first compute a ** b disregarding it's sign, then applying the sign as necessary. This will get rid of the discrepancy. You could apply the same concept with math.copysign:This will just copy the sign from a to 1, which will give -1.0 or 1.0 based on negativity.
This is because of the precedence of the power operator. The power operator binds tighter than unary operators. So:is evaluated asYou can see how Python parses your code using the ast module:In the above, the 3 ** 0.8 is treated as one expression with ** being the operator. The unary minus is then applied to the value of the inner expression.However, in your second example the values are stored in variables, so the precedence does not affect the expression. So a ** b is equivlent to (-3) ** 0.8The solution is to bind the unary minus to the three using parenthesis:
The ** operator has the highest precedence over all other operators. Hence when you usepython first evaluates the exponential and then negates it.But when you runa has implicitly been negated first. Hence the result is effectively a imaginary number (a negative number raised to a fractional exponent)To solve your issue, you could do something like


Answer URL
https://docs.python.org/3/reference/expressions.html#the-power-operator
