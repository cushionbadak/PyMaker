Natural Text
Can anyone explain why g and h are not equivalent to f? I think they should be equivalent because x in g and h should bind to the x in the environment that they are defined in (see this question on closures)
Here g and h return function object, but filter waits an function which returns a boolean or object wich will convert as boolean . With f it is correct for your expected output, but for g and h, the condition is always true because bool(function object) is always true see here, a python function is a callable object.Take:I advise to do:Output:To call g to do:Do:Output:To call h to do:or Do:Output:See documentation to use filter:Construct a list from those elements of iterable for which function returns true. iterable may be either a sequence, a container which supports iteration, or an iterator. If iterable is a string or a tuple, the result also has that type; otherwise it is always a list. If function is None, the identity function is assumed, that is, all elements of iterable that are false are removed.Note that filter(function, iterable) is equivalent to [item for item in iterable if function(item)] if function is not None and [item for item in iterable if item] if function is None.See documentation to use lambda expression:lambda arguments: expression with :
g(x) and h(x) are returning the lambda function itself (<function __main__.<lambda>>), but not executing it.Try for example: g(3)() that will return the desired value.Therefore running g(x)() or h(x)() will work:While running only g(x) or h(x) will return the lambda function itself per each value, which is equivalent to True statement in filter function, and therefore no value is filtered.and of course, in this case you can just run:or even a better list comprehension approach:


Answer URL
https://docs.python.org/3/library/functions.html#filter
https://docs.python.org/3/reference/expressions.html#lambda
