Natural Text
From https://docs.python.org/3.6/library/functions.html#getattrReturn the value of the named attribute of object. name must be a  string. If the string is the name of one of the objectâ€™s attributes,  the result is the value of that attribute. For example, getattr(x,  'foobar') is equivalent to x.foobar. If the named attribute does  not exist, default is returned if provided, otherwise  AttributeError is raised.How is getattr related to object.__getattribute__ and to object.__getattr__?Does getattr call object.__getattribute__ or object.__getattr__? I would guess the former? 
Summary AnswerIn general, a dotted lookup invokes __getattribute__.If the code in __getattribute__ doesn't find the attribute, it looks to see if __getattr__ is defined.  If so, it is called.  Otherwise, AttributeError is raised.The getattr() function is just an alternative way to call the above methods.  For example getattr(a, 'x') is equivalent to a.x.  The getattr() function is mainly useful when you don't know the name of an attribute in advance (i.e. when it is stored in a variable).  For example, k = 'x'; getattr(a, k) is equivalent to a.x.Analogy and high level point-of-viewThe best way to think of it is that __getattribute__ is the first called primary method and __getattr__ is the fallback which is called when attributes are missing.  In this way, it is very much like the relationship between __getitem__ and __missing__ for square bracket lookups in dictionaries.Demonstration codeHere is a worked-out example:Official DocumentationHere are the relevant parts of the docs:object.__getattr__(self, name) Called when an attribute lookup has  not found the attribute in the usual places (i.e. it is not an  instance attribute nor is it found in the class tree for self). name  is the attribute name. This method should return the (computed)  attribute value or raise an AttributeError exception.Note that if the attribute is found through the normal mechanism,  __getattr__() is not called. (This is an intentional asymmetry between __getattr__() and __setattr__().) This is done both for efficiency reasons and because otherwise __getattr__() would have no way to  access other attributes of the instance. Note that at least for  instance variables, you can fake total control by not inserting any  values in the instance attribute dictionary (but instead inserting  them in another object). See the __getattribute__() method below for a  way to actually get total control over attribute access.object.__getattribute__(self, name) Called unconditionally to  implement attribute accesses for instances of the class. If the class  also defines __getattr__(), the latter will not be called unless  __getattribute__() either calls it explicitly or raises an AttributeError. This method should return the (computed) attribute  value or raise an AttributeError exception. In order to avoid infinite  recursion in this method, its implementation should always call the  base class method with the same name to access any attributes it  needs, for example, object.__getattribute__(self, name).
getattr(foo, 'bar')(which is basically foo.bar) calls __getattribute__ and from there __getattr__ can be called(if it exists) when:AttributeError is raised by __getattribute____getattribute__ calls it explicitlyFrom docs:If the class also defines __getattr__(), the latter will not be called  unless __getattribute__() either calls it explicitly or raises an  AttributeError.Defining __getattr__ can be useful if you don't want to throw attribute errors on random attribute access. Mock library is great example of that.If you don't want to define __getattr__ all the time nor want to handle AttributeError all the time then you could either use the 3 argument form of getattr() to return default value if attribute wasn't found or use hasattr to check for its existence.Demo:outputs:Note that the data model documentation points it out as object.__getattr__, but that doesn't mean they exists on builtin object type. Instead they can exist on any object in general. And object in this case is a type as dunder methods are looked up on an object's type.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__getattribute__
https://docs.python.org/3/reference/datamodel.html#object.__getattr__
https://docs.python.org/3/library/functions.html#getattr
https://docs.python.org/3/reference/datamodel.html#object.__getitem__
https://docs.python.org/3/reference/datamodel.html#object.__missing__
https://docs.python.org/3/reference/datamodel.html#object.__getattribute__
https://docs.python.org/3/library/unittest.mock.html
https://docs.python.org/3/reference/datamodel.html#object.__getattr__
