Natural Text
Can anyone amend namedtuple or provide an alternative class so that it works for mutable objects?Primarily for readability, I would like something similar to namedtuple that does this:It must be possible to pickle the resulting object.  And per the characteristics of named tuple, the ordering of the output when represented must match the order of the parameter list when constructing the object.
There is a mutable alternative to collections.namedtuple - recordclass.It has the same API and memory footprint as namedtuple and it supports assignments (It should be faster as well). For example:For python 3.6 and higher recordclass (since 0.5) support typehints:There is a more complete example (it also includes performance comparisons).Since 0.9 recordclass library provides another  variant -- recordclass.structclass factory function. It can produce classes, whose instances occupy less memory than __slots__-based instances. This is can be important for the instances with attribute values, which has not intended to have reference cycles. Here is an illustrative example.
It seems like the answer to this question is no.Below is pretty close, but it's not technically mutable. This is creating a new namedtuple() instance with an updated x value:On the other hand, you can create a simple class using __slots__ that should work well for frequently updating class instance attributes:To add to this answer, I think __slots__ is good use here because it's memory efficient when you create lots of class instances. The only downside is that you can't create new class attributes.Here's one relevant thread that illustrates the memory efficiency -  Dictionary vs Object - which is more efficient and why? The quoted content in the answer of this thread is a very succinct explanation why __slots__ is more memory efficient - Python slots 
The latest namedlist 1.7 passes all of your tests with both Python 2.7 and Python 3.5 as of Jan 11, 2016. It is a pure python implementation whereas the recordclass is a C extension. Of course, it depends on your requirements whether a C extension is preferred or not.Your tests (but also see the note below):Output on Python 2.7The only difference with Python 3.5 is that the namedlist has become smaller, the size is 56 (Python 2.7 reports 64).Note that I have changed your test 10 for in-place replacement. The namedlist has a _replace() method which does a shallow copy, and that  makes perfect sense to me because the namedtuple in the standard library behaves the same way. Changing the semantics of the _replace() method would be confusing. In my opinion the _update() method should be used for in-place updates. Or maybe I failed to understand the intent of your test 10?
types.SimpleNamespace was introduced in Python 3.3 and supports the requested requirements.
As a very Pythonic alternative for this task, since Python-3.7, you can use dataclasses module that not only behaves like a mutable NamedTuple because they use normal class definitions they also support other classes features.From PEP-0557:Although they use a very different mechanism, Data Classes can be thought of as "mutable namedtuples with defaults". Because Data Classes use normal class definition syntax, you are free to use inheritance, metaclasses, docstrings, user-defined methods, class factories, and other Python class features.A class decorator is provided which inspects a class definition for variables with type annotations as defined in PEP 526, "Syntax for Variable Annotations". In this document, such variables are called fields. Using these fields, the decorator adds generated method definitions to the class to support instance initialization, a repr, comparison methods, and optionally other methods as described in the Specification section. Such a class is called a Data Class, but there's really nothing special about the class: the decorator adds generated methods to the class and returns the same class it was given.This feature is introduced in PEP-0557 that you can read about it in more details on provided documentation link.Example:Demo:
The following is a good solution for Python 3: A minimal class using __slots__ and Sequence abstract base class; does not do fancy error detection or such, but it works, and behaves mostly like a mutable tuple (except for typecheck).Example:If you want, you can have a method to create the class too (though using an explicit class is more transparent):Example:In Python 2 you need to adjust it slightly - if you inherit from Sequence, the class will have a __dict__ and the __slots__ will stop from working.The solution in Python 2 is to not inherit from Sequence, but object. If isinstance(Point, Sequence) == True is desired, you need to register the  NamedMutableSequence as a base class to Sequence:
Let's implement this with dynamic type creation:This checks the attributes to see if they are valid before allowing the operation to continue.So is this pickleable?  Yes if (and only if) you do the following:The definition has to be in your namespace, and must exist long enough for pickle to find it.  So if you define this to be in your package, it should work.Pickle will fail if you do the following, or make the definition temporary (goes out of scope when the function ends, say):And yes, it does preserve the order of the fields listed in the type creation.
Tuples are by definition immutable.You can however make a dictionary subclass where you can access the attributes with dot-notation;
If you want similar behavior as namedtuples but mutable try namedlistNote that in order to be mutable it cannot be a tuple.
Provided performance is of little importance, one could use a silly hack like:


Answer URL
https://docs.python.org/3/library/types.html#types.SimpleNamespace
