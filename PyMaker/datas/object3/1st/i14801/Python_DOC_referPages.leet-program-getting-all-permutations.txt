Natural Text
I wrote a straightforward function that converts letters in words to their 'leet' numerical counterparts.so when I input 'zit', the program will return '217'. My question is, how can I change it to give me every possible permutation ('217', '2it', 'z1t', 'zi7', '21t', etc.)? I've read about itertools but I am stumped as to how to apply it to my function.
First observation is that you can shorten the lookup, like this:REPLACE looks like:And the REPLACE.get(l,l) gives you back either the replacement letter, or the original letter if there is no replacement.The second observation is that you don't really want permutations, which are shifts in ordering. The permutations of '217' are:What you really need is the product of a list that encodes all the possible choices for a given character position:How this works might be clearer if I also show a possibility list with some characters for which there is no valid replacement. For 'red' for example:Now we need the string-joined product of those options. Putting it all together:Gives:
Use itertools.product. Also, I would suggest using a dict for the mapping instead of a cascade of if/elif.Note that LEET.get(c, c) will get the "leet" letter from the dict, or use the original letter as a default. The {...} is used to make those pairs sets, so there are no duplicates for letters with no replacement. In older versions of Python, you might have to use set([...]) instead.That rather complex product(*...) line works roughly like this:which produces the cartesian product of all those letters and their replacements.
One way to do it is to use itertools.product, as you mentionned, which will perform a cartesian product of a list.The problem will be to have this list, of every combinaison e.g for zit the list should be:My code:Note that using list of list (or tuples) instead of Dict allows you to have several replacements for one letter, e.g. "i" can become "1" or "!"


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.product
