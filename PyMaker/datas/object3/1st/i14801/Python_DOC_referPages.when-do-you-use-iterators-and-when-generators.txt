Natural Text
I read some question and answers about differences between iterators and generators. But I don't understand when you should choose one over other? Do you know any examples (simple, real life ones) when one is better than the other? Thank you.
Iterators provide efficient ways of iterating over an existing data structure.Generators provide efficient ways of generating elements of a sequence on the fly.Iterator ExamplePython's file readers can be used as iterators.  So what you might use to process one line of a file:You can implement more efficiently using iteratorsThe advantage is in the fact that in the second example, you're not reading the entire file into memory, then iterating over a list of lines.  Instead, the reader (BufferedReader in Python3) is reading a line at a time, every time you ask for one.Generator ExampleGenerators generate elements of a sequence on the fly.  Consider the following:This is an example of a generator.  In this case, every time it's "called" it produces the next number in the Fibonacci sequence.I put "called" in scare quotes because the method of getting successive values from generators is different than a traditional function.We have two main ways to get values from generators:Iterating over itHere we use the in syntax to iterate over the generator, and print the values that are returned, until we get a value that's greater than 100.Output:Calling next()We could also call next on the generator (since generators are iterators) and (generate and) access the values that way:There are more persuasive examples of generators however.  And these often come in the form of "generator expressions", a related concept (PEP-289).Consider something like the following:Here, we're creating a generator expression:And passing it to the any built-in function.  any will return True as soon as an element of the iterable is determined to be True.  So when you pass a generator function to any, it will only call expensive_thing(i) as many times as necessary to find a True-ish value.Compare this with using a list comprehension passed to any:In this case, expensive_thing(i) will be called for all values of i, first, then the 100-element list of True/False values will be given to any which will return True if it finds a True-ish value.But if expensive_thing(0) returned True, clearly the better approach would only be to evaluate that, test it, and stop there.  Generators allow you to do this, whereas something like a list comprehension do not.Consider the following example, illustrating the advantage of using a generator expression over list comprehension:The function expensive_thing introduces an artificial delay to illustrate the difference between the two approaches.  The second (list comprehension) approach takes significantly longer, because expensive_thing is evaluated at all 100 indices, whereas the first only calls expensive_thing until it finds a True values (i=11).


Answer URL
https://docs.python.org/3/library/functions.html#next
https://docs.python.org/3/glossary.html#term-generator-expression
https://docs.python.org/3/glossary.html#term-generator
