Natural Text
I'm trying to get a handle on python Parallelism.  This is the code i'm usingI was under the assumption that because i'm using two cores my the speed be be close to double. However when i run this code most of the time the nocore output is faster than the core output. This is true even if I changetoIn fact in some runs the no core run is faster.  Could someone shed some light on the issue?  I'm is my setup correct? I'm I doing something wrong?
You're using pool.map() incorrectly. Take a look at the pool.map documentation. It expects an iterable argument, and it will pass each of the items from the iterable to the pool individually. Since your function only returns None, there is nothing for it to do. However, you're still incurring the overhead of spawning extra processes, which takes time.Your usage of pool.map should look like this:Notice a couple of things:    Since you're using the print statement rather than a function, I'm assuming you're using some Python2 variant. In Python2, pool.map returns a list anyway. No need to convert it to a list again.The first argument should be the function name without parentheses. This identifies the function that the pool workers should execute. When you include the parentheses, the function is called right there, instead of in the pool.   pool.map is intended to call a function on every item in an iterable, so your test cases needs to create some iterable for it to consume, instead of a function that takes no arguments like your current example.Try to run your trial again with some actual input to the function, and retrieve the output. Here's an example:Results:Total time, no core, 0.047  Total time core, 0.009The text files are 150,000 lines of gibberish each. Notice how much work had to be done before the parallel processing was worth it. When I ran the trial with 10,000 lines in each file, the single process approach was still faster because it didn't have the overhead of spawning extra processes. But with that much work to do, the extra processes become worth the effort.And by the way, this functionality is available with multiprocessing pools in Python2, so you can avoid importing anything from futures if you want to.


Answer URL
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor.map
