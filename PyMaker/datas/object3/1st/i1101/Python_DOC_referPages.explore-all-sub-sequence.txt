Natural Text
I'm trying already for some days to solve this problem without any success.About this problem:Given a sequence '2 2 4 4'. We take consecutively 2 numbers from the sequence, For example: 2 2 ,2 4, 4 4.If the sum of the 2 numbers is an number divisible by 2 we replace the 2 numbers and put the result of the 2 numbers for example: (2+2 = 4, 4/2 = 2) so the new sequence is (2 4 4), but here I should find all possible sequences.If no possible to find an even number that is dividable by 2, so we return the sequence.A picture of how should it beThe red rectangles are the sequence that I cannot get :(my code:What I did here is ,converted the sequence to integers , sent them to a new function. That I should receive all sequences recursively.I iterated on the sequence and taking the first number by n[i] and the second n[i+1] (and controlling if I can have the second number to not get out of range).The final result should be ordered in increasing mode of the size sequence, if the length of the 2 sequence is that same so we order by the first number of the sequence.At the end I should receive ['3', '2 3', '3 4', '2 3 4']
Below is my recursive solution, based on your diagram, which can handle '30 20 10 30 6 6' without stack issues.  Data conversion, sorting and redundancy reduction are handled by the main() routine.  The sub_sequence() function takes an array and returns an array of arrays that match the logic of your diagram:OUTPUT
I created a few functions to accomplish the goal:least_check that give a True/False as to whether or not the sequence is a "least" (e.g. '2 4' would return False, while '3 4' would return True)find_leasts which is the recursive function that breaks a sequence down to the the next level in the tree shown in the question (e.g. '2 2 4 4' would break down to '2 4 4', '2 3 4', and '2 2 4') until it reaches all "leasts" main which creates a list of all the "leasts" yielded from the find_leasts function, and removes any duplicates (e.g. example sequence has '3' twice) and returns the list of unique "leasts"Answer:Result:Update:The above solution has many split()s and ' '.join()s in order to avoid the recursive function modifying a list reference (a list name is a pointer to its memory address - if needed, see this site for further explanation) from a depth other than the current scope. When looking at the error received on a '30 20 10 30 6 6' sequence and considering that playing with the max recursion via sys.setrecursionlimit is not recommended, I re-evaluated whether or not recursion was even necessary - and determined it is not.Here are the functions used in the iterative solution:least_check - same as original answerbreak_down - takes a list and breaks it down to all lists down one level in the tree (e.g. '2 2 4 4' would break down to '2 4 4', '2 3 4', and '2 2 4')least_lister - iterates through the queue of lists that are potential leasts, until all lists in least_lists are leastsmain - does all split() and ' '.join() operations and removes duplicates before returning resultsIterative Solution:Iterative Result:List Reference ExampleList Reference Example Output:
Let's see this problem step by step.First :Sum the first number of the array with the second one, divide by two the result, create a new array with the new values, if it's even  then call recursive on the new arreyElse put the new arrey in a static data structureSecond :At the first point we need to see all the index,Put everything in a cycle starting with index I = 0 to length-2Third : work on the static array, sort it as you want and print the result.I'm not good with python but I hope this pseudo code will help you. 


Answer URL
https://docs.python.org/3/library/sys.html#sys.setrecursionlimit
