Natural Text
Objective and MotivationThe MultiIndex API has been gaining popularity over the years, however, not everything about it is fully understood in terms of the structure, working, and associated operations. One important operation is filtering. Filtering is a common requirement, but the use cases are diverse. Accordingly, certain methods and functions will be more applicable to some use cases than others. In summary, the aim of this post is to touch upon some common filtering problems and use cases, demonstrate various different methods to solve these problems, and discuss their applicability. Some of the high-level questions this post seeks to address areSlicing based on a single value/labelSlicing based on multiple labels from one or more levelsFiltering on boolean conditions and expressionsWhich methods are applicable in what circumstancesThese problems have been broken down into 6 concrete questions, enumerated below. For simplicity, the example DataFrames in the setup below only have two levels, and do not have duplicate index keys. Most solutions presented to the problems can generalize to N levels. This post will not go through how to create MultiIndexes, how to perform assignment operations on them, or any performance related discussions (these are separate topics for another time). QuestionsQuestion 1-6 will be asked in context to the setup below.Question 1: Selecting a Single ItemHow do I select rows having "a" in level "one"? Additionally, how would I be able to drop level "one" in the output?Question 1bHow do I slice all rows with value "t" on level "two"?Question 2: Selecting Multiple Values in a LevelHow can I select rows corresponding to items "b" and "d" in level "one"?Question 2bHow would I get all values corresponding to "t" and "w" in level "two"?Question 3: Slicing a Single Cross Section (x, y)How do I retrieve a cross section, i.e., a single row having a specific values for the index from df? Specifically, how do I retrieve the cross section of ('c', 'u'), given byQuestion 4: Slicing Multiple Cross Sections [(a, b), (c, d), ...]How do I select the two rows corresponding to ('c', 'u'), and ('a', 'w')?Question 5: One Item Sliced per LevelHow can I retrieve all rows corresponding to "a" in level "one" and "u" in level "two"?Question 6: Arbitrary SlicingHow can I slice specific cross sections? For "a" and "b", I would like to select all rows with sub-levels "u" and "v", and for "d", I would like to select rows with sub-level "w".Question 7 will use a unique setup consisting of a numeric level:Question 7: Inequality-based filtering on Numeric LevelsHow do I get all rows where values in level "two" are greater than 5?
MultiIndex / Advanced IndexingNote  This post will be structured in the following manner: The questions put forth in the OP will be addressed, one by oneFor each question, one or more methods applicable to solving this problem and getting the expected result will be demonstrated.Notes (much like this one) will be included for readers interested in learning about additional functionality, implementation details,  and other info cursory to the topic at hand. These notes have been  compiled through scouring the docs and uncovering various obscure  features, and from my own (admittedly limited) experience.All code samples have created and tested on pandas v0.23.4, python3.7. If something is not clear, or factually incorrect, or if you did not  find a solution applicable to your use case, please feel free to  suggest an edit, request clarification in the comments, or open a new  question, ....as applicable.Here is an introduction to some common idioms (henceforth referred to as the Four Idioms) we will be frequently re-visitingDataFrame.loc - A general solution for selection by label (+ pd.IndexSlice for more complex applications involving slices) DataFrame.xs - Extract a particular cross section from a Series/DataFrame.DataFrame.query - Specify slicing and/or filtering operations dynamically (i.e., as an expression that is evaluated dynamically. Is more applicable to some scenarios than others. Also see this section of the docs for querying on MultiIndexes.Boolean indexing with a mask generated using MultiIndex.get_level_values (often in conjunction with Index.isin, especially when filtering with multiple values). This is also quite useful in some circumstances.It will be beneficial to look at the various slicing and filtering problems in terms of the Four Idioms to gain a better understanding what can be applied to a given situation. It is very important to understand that not all of the idioms will work equally well (if at all) in every circumstance. If an idiom has not been listed as a potential solution to a problem below, that means that idiom cannot be applied to that problem effectively.Question 1How do I select rows having "a" in level "one"? You can use loc, as a general purpose solution applicable to most situations:At this point, if you getThat means you're using an older version of pandas. Consider upgrading! Otherwise, use df.loc[('a', slice(None)), :].Alternatively, you can use xs here, since we are extracting a single cross section. Note the levels and axis arguments (reasonable defaults can be assumed here). Here, the drop_level=False argument is needed to prevent xs from dropping level "one" in the result (the level we sliced on).Yet another option here is using query:If the index did not have a name, you would need to change your query string to be "ilevel_0 == 'a'".Finally, using get_level_values:Additionally, how would I be able to drop level "one" in the output?This can be easily done using eitherOr,Notice that we can omit the drop_level argument (it is assumed to be True by default).Note  You may notice that a filtered DataFrame may still have all the levels, even if they do not show when printing the DataFrame out. For example,You can get rid of these levels using MultiIndex.remove_unused_levels:Question 1bHow do I slice all rows with value "t" on level "two"?Intuitively, you would want something involving slice(): It Just Works!â„¢ But it is clunky. We can facilitate a more natural slicing syntax using the pd.IndexSlice API here.This is much, much cleaner.Note  Why is the trailing slice : across the columns required? This is because, loc can be used to select and slice along both axes (axis=0 or  axis=1). Without explicitly making it clear which axis the slicing  is to be done on, the operation becomes ambiguous. See the big red box in the documentation on slicing.If you want to remove any shade of ambiguity, loc accepts an axis  parameter:Without the axis parameter (i.e., just by doing df.loc[pd.IndexSlice[:, 't']]), slicing is assumed to be on the columns,  and a KeyError will be raised in this circumstance. This is documented in slicers. For the purpose of this post, however, we will explicitly specify all axes.    With xs, it is With query, it is And finally, with get_level_values, you may doAll to the same effect.Question 2How can I select rows corresponding to items "b" and "d" in level "one"?Using loc, this is done in a similar fashion by specifying a list.To solve the above problem of selecting "b" and "d", you can also use query:Note  Yes, the default parser is 'pandas', but it is important to highlight this syntax isn't conventionally python. The  Pandas parser generates a slightly different parse tree from the  expression. This is done to make some operations more intuitive to  specify. For more information, please read my post on  Dynamic Expression Evaluation in pandas using pd.eval().And, with get_level_values + Index.isin:Question 2bHow would I get all values corresponding to "t" and "w" in level "two"?With loc, this is possible only in conjuction with pd.IndexSlice.The first colon : in pd.IndexSlice[:, ['t', 'w']] means to slice across the first level. As the depth of the level being queried increases, you will need to specify more slices, one per level being sliced across. You will not need to specify more levels beyond the one being sliced, however. With query, this is With get_level_values and Index.isin (similar to above):Question 3How do I retrieve a cross section, i.e., a single row having a specific values  for the index from df? Specifically, how do I retrieve the cross  section of ('c', 'u'), given byUse loc by specifying a tuple of keys:Or,Note  At this point, you may run into a PerformanceWarning that looks like this:This just means that your index is not sorted. pandas depends on the index being sorted (in this case, lexicographically, since we are dealing with string values) for optimal search and retrieval. A quick fix would be to sort your  DataFrame in advance using DataFrame.sort_index. This is especially desirable from a performance standpoint if you plan on doing  multiple such queries in tandem:You can also use MultiIndex.is_lexsorted() to check whether the index  is sorted or not. This function returns True or False accordingly.  You can call this function to determine whether an additional sorting  step is required or not.With xs, this is again simply passing a single tuple as the first argument, with all other arguments set to their appropriate defaults:With query, things become a bit clunky:You can see now that this is going to be relatively difficult to generalize. But is still OK for this particular problem.With accesses spanning multiple levels, get_level_values can still be used, but is not recommended:Question 4How do I select the two rows corresponding to ('c', 'u'), and ('a', 'w')?With loc, this is still as simple as:With query, you will need to dynamically generate a query string by iterating over your cross sections and levels:100% DO NOT RECOMMEND! But it is possible. Question 5How can I retrieve all rows corresponding to "a" in level "one" and  "u" in level "two"?This is actually very difficult to do with loc while ensuring correctness and still maintaining code clarity. df.loc[pd.IndexSlice['a', 't']] is incorrect, it is interpreted as df.loc[pd.IndexSlice[('a', 't')]] (i.e., selecting a cross section). You may think of a solution with pd.concat to handle each label separately:But you'll notice one of the rows is duplicated. This is because that row satisfied both slicing conditions, and so appeared twice. You will instead need to doBut if your DataFrame inherently contains duplicate indices (that you want), then this will not retain them. Use with extreme caution.With query, this is stupidly simple:With get_level_values, this is still simple, but not as elegant:Question 6How can I slice specific cross sections? For "a" and "b", I would like to select all rows with sub-levels "u" and "v", and  for "d", I would like to select rows with sub-level "w".This is a special case that I've added to help understand the applicability of the Four Idiomsâ€”this is one case where none of them will work effectively, since the slicing is very specific, and does not follow any real pattern. Usually, slicing problems like this will require explicitly passing a list of keys to loc. One way of doing this is with:If you want to save some typing, you will recognise that there is a pattern to slicing "a", "b" and its sublevels, so we can separate the slicing task into two portions and concat the result:Slicing specification for "a" and "b" is slightly cleaner (('a', 'b'), ('u', 'v')) because the same sub-levels being indexed are the same for each level.Question 7How do I get all rows where values in level "two" are greater than 5?This can be done using query,And get_level_values.Note  Similar to this example, we can filter based on any arbitrary condition using these constructs. In general, it is useful to remember that loc and xs are specifically for label-based indexing, while query and  get_level_values are helpful for building general conditional masks  for filtering.Bonus QuestionWhat if I need to slice a MultiIndex column?Actually, most solutions here are applicable to columns as well, with minor changes. Consider:These are the following changes you will need to make to the Four Idioms to have them working with columns.To slice with loc, use Or,To use xs as appropriate, just pass an argument axis=1.You can access the column level values directly with df.columns.get_level_values. You will then need to do something like Where {condition} represents some condition built using columns.get_level_values.To use query, your only option is to transpose, query on the index, and transpose again:Not recommended, use one of the other 3 options.


Answer URL
https://docs.python.org/3/library/functions.html#slice
