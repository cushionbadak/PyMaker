Natural Text
I have two tasks. When one task raises an error, I wish to restart them both. Is the following the appropriate way to catch an exception propagated by one task, and restart the gather for the two tasks?Basically asyncio intentionally doesn't cancel the other tasks in a gather when one task raises an error. So, since I can't think of anything better, I manually cancel the other task(s) with task.cancel() and handle the asyncio.CancelledError myself.I'm just not convinced this is the intended use of the api, insights appreciated.Edit:-In the asyncio-3.7 docs it reads If gather() is cancelled, all submitted awaitables (that have not completed yet) are also cancelled.But the behaviour I observe when I replace footask.cancel() with bothtasks.cancel() is that for every iteration of the while loop, an additional foo is awaited, i.e. the foo appears not to be cancelled by cancelling the gather. The output looks something like this:
The standard idiom to ensure that the tasks have processed their cancelation is to add a gather(*tasks, return_exceptions=True) following the cancellation. For example:Note that you might want to do that for all exceptions, not just ValueError, because otherwise a task completing with a non-ValueError exception will still cause other tasks to continue running.
When exceptions happens footask is not cancelled because as you can read in doc:If return_exceptions is False (default), the first raised exception is  immediately propagated to the task that awaits on gather(). Other  awaitables in the aws sequence wonâ€™t be cancelled and will continue to  run.So we should manually cancel footask and await it was cancelled:Upd:I wrote advanced_gather that acts like gather, but has additional kawrg cancel_on_exception to cancel every task on exception in one of them. Full code:Different cases of what can happen:


Answer URL
https://docs.python.org/3/library/asyncio-task.html#asyncio.gather
