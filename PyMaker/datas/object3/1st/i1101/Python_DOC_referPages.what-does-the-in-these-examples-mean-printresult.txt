Natural Text
In the following method definitions, what does the * and ** do for param2?
The *args and **kwargs is a common idiom to allow arbitrary number of arguments to functions as described in the section more on defining functions in the Python documentation.The *args will give you all function parameters as a tuple:The **kwargs will give you all keyword arguments except for those corresponding to a formal parameter as a dictionary.Both idioms can be mixed with normal arguments to allow a set of fixed and some variable arguments:Another usage of the *l idiom is to unpack argument lists when calling a function.In Python 3 it is possible to use *l on the left side of an assignment (Extended Iterable Unpacking), though it gives a list instead of a tuple in this context:Also Python 3 adds new semantic (refer PEP 3102):Such function accepts only 3 positional arguments, and everything after * can only be passed as keyword arguments.
It's also worth noting that you can use * and ** when calling functions as well. This is a shortcut that allows you to pass multiple arguments to a function directly using either a list/tuple or a dictionary. For example, if you have the following function:You can do things like:Note: The keys in mydict have to be named exactly like the parameters of function foo. Otherwise it will throw a TypeError:
The single * means that there can be any number of extra positional arguments. foo() can be invoked like foo(1,2,3,4,5). In the body of foo() param2 is a sequence containing 2-5.The double ** means there can be any number of extra named parameters. bar() can be invoked like bar(1, a=2, b=3). In the body of bar() param2 is a dictionary containing {'a':2, 'b':3 }With the following code:the output is
What does ** (double star) and * (star) do for parametersThey allow for functions to be defined to accept and for users to pass any number of arguments, positional (*) and keyword (**).Defining Functions*args allows for any number of optional positional arguments (parameters), which will be assigned to a tuple named args. **kwargs allows for any number of optional keyword arguments (parameters), which will be in a dict named kwargs.You can (and should) choose any appropriate name, but if the intention is for the arguments to be of non-specific semantics, args and kwargs are standard names.Expansion, Passing any number of argumentsYou can also use *args and **kwargs to pass in parameters from lists (or any iterable) and dicts (or any mapping), respectively.The function recieving the parameters does not have to know that they are being expanded. For example, Python 2's xrange does not explicitly expect *args, but since it takes 3 integers as arguments:As another example, we can use dict expansion in str.format:New in Python 3: Defining functions with keyword only argumentsYou can have keyword only arguments after the *args - for example, here, kwarg2 must be given as a keyword argument - not positionally:Usage:Also, * can be used by itself  to indicate that keyword only arguments follow, without allowing for unlimited positional arguments.Here, kwarg2 again must be an explicitly named, keyword argument:And we can no longer accept unlimited positional arguments because we don't have *args*:Again, more simply, here we require kwarg to be given by name, not positionally:In this example, we see that if we try to pass kwarg positionally, we get an error:We must explicitly pass the kwarg parameter as a keyword argument.Python 2 compatible demos*args (typically said "star-args") and **kwargs (stars can be implied by saying "kwargs", but be explicit with "double-star kwargs") are common idioms of Python for using the * and ** notation. These specific variable names aren't required (e.g. you could use *foos and **bars), but a departure from convention is likely to enrage your fellow Python coders. We typically use these when we don't know what our function is going to receive or how many arguments we may be passing, and sometimes even when naming every variable separately would get very messy and redundant (but this is a case where usually explicit is better than implicit).Example 1The following function describes how they can be used, and demonstrates behavior. Note the named b argument will be consumed by the second positional argument before :We can check the online help for the function's signature, with help(foo), which tells us Let's call this function with foo(1, 2, 3, 4, e=5, f=6, g=7) which prints:Example 2We can also call it using another function, into which we just provide a:bar(100) prints:Example 3: practical usage in decoratorsOK, so maybe we're not seeing the utility yet. So imagine you have several functions with redundant code before and/or after the differentiating code. The following named functions are just pseudo-code for illustrative purposes.We might be able to handle this differently, but we can certainly extract the redundancy with a decorator, and so our below example demonstrates how *args and **kwargs can be very useful:And now every wrapped function can be written much more succinctly, as we've factored out the redundancy:And by factoring out our code, which *args and **kwargs allows us to do, we reduce lines of code, improve readability and maintainability, and have sole canonical locations for the logic in our program. If we need to change any part of this structure, we have one place in which to make each change.
Let us first understand what are positional arguments and keyword arguments.Below is an example of function definition with Positional arguments.So this is a function definition with positional arguments.You can call it with keyword/named arguments as well:Now let us study an example of function definition with keyword arguments:You can call this function with positional arguments as well:So we now know function definitions with positional as well as keyword arguments.Now let us study the '*' operator and '**' operator.Please note these operators can be used in 2 areas:a) function callb) function definitionThe use of '*' operator and '**' operator in function call. Let us get straight to an example and then discuss it.So remember when the '*' or '**' operator is used in a function call -'*' operator unpacks data structure such as a list or tuple  into arguments needed by function definition.'**' operator unpacks a dictionary into arguments needed by function definition.Now let us study the '*' operator use in function definition.Example:In function definition the '*' operator packs the received arguments into a tuple.Now let us see an example of '**' used in function definition:In function definition The '**' operator packs the received arguments into a dictionary.So remember:In a function call the '*' unpacks data structure of tuple or list into positional or keyword arguments to be received by function definition.In a function call the '**' unpacks data structure of dictionary into positional or keyword arguments to be received by function definition.In a function definition the '*' packs positional arguments into a tuple.In a function definition the '**' packs keyword arguments into a dictionary.
* and ** have special usage in the function argument list. *implies that the argument is a list and ** implies that the argumentis a dictionary. This allows functions to take arbitrary number ofarguments
For those of you who learn by examples!The purpose of *  is to give you the ability to define a function that can take an arbitrary number of arguments provided as a list (e.g. f(*myList) ).The purpose of ** is to give you the ability to feed a function's arguments by providing a dictionary (e.g. f(**{'x' : 1, 'y' : 2}) ).Let us show this by defining a function that takes two normal variables x, y, and can accept more arguments as myArgs, and can accept even more arguments as myKW. Later, we will show how to feed y using myArgDict.Caveats** is exclusively reserved for dictionaries.Non-optional argument assignment happens first.You cannot use a non-optional argument twice.If applicable, ** must come after *, always.
From the Python documentation:If there are more positional arguments than there are formal parameter slots, a TypeError exception is raised, unless a formal parameter using the syntax "*identifier" is present; in this case, that formal parameter receives a tuple containing the excess positional arguments (or an empty tuple if there were no excess positional arguments). If any keyword argument does not correspond to a formal parameter name, a TypeError exception is raised, unless a formal parameter using the syntax "**identifier" is present; in this case, that formal parameter receives a dictionary containing the excess keyword arguments (using the keywords as keys and the argument values as corresponding values), or a (new) empty dictionary if there were no excess keyword arguments. 
While uses for the star/splat operators have been expanded in Python 3, I like the following table as it relates to use of these operators with functions.  The splat operator(s) can be used both within function construction and in the function call:This really just serves to summarize Lorin Hochstein's answer but I find it helpful.
In Python 3.5, you can also use this syntax in list, dict, tuple, and set displays (also sometimes called literals). See PEP 488: Additional Unpacking Generalizations.It also allows multiple iterables to be unpacked in a single function call.(Thanks to mgilson for the PEP link.)
I want to give an example which others haven't  mentioned* can also unpack a generatorAn example from Python3 Documentunzip_x will be [1, 2, 3], unzip_y will be [4, 5, 6]The zip() receives multiple iretable args, and return a generator. 
In addition to function calls, *args and **kwargs are useful in class hierarchies and also avoid having to write __init__ method in Python. Similar usage can seen in frameworks like Django code.For example,A subclass can then beThe subclass then be instantiated as Also, a subclass with a new attribute which makes sense only to that subclass instance can call the Base class __init__ to offload the attributes setting.This is done through *args and **kwargs. kwargs mainly used so that code is readable using named arguments. For example,which can be instatiated asThe complete code is here
* means receive variable arguments as list** means receive variable arguments as dictionaryUsed like the following:1) single *Output:2) Now **Output:
A good example of using both in a function is:
This example would help you remember *args, **kwargs and even super and inheritance in Python at once.
*args and **kwargs: allow you to pass a variable number of arguments to a function. *args: is used to send a non-keyworded variable length argument list to the function:Will produce:**kwargs***kwargs allows you to pass keyworded variable length of arguments to a function. You should use **kwargs if you want to handle named arguments in a function. Will produce:
def foo(param1, *param2): is a method can accept arbitrary number of values for *param2,def bar(param1, **param2): is a method can accept arbitrary number of values with keys for *param2param1 is a simple parameter.For example, the syntax for implementing varargs in Java as follows:
TL;DRIt packs arguments passed to the function into list and dict respectively inside the function body. When you define a function signature like this:it can be called with any number of arguments and keyword arguments. The non-keyword arguments get packed into a list called args inside the the function body and the keyword arguments get packed into a dict called kwds inside the function body.now inside the function body, when the function is called, there are two local variables, args which is a list having value ["this", "is a list of", "non-keyword", "arguments"] and kwds which is a dict having value {"keyword" : "ligma", "options" : [1,2,3]}This also works in reverse, i.e. from the caller side. for example if you have a function defined as:you can call it with by unpacking iterables or mappings you have in the calling scope:


Answer URL
https://docs.python.org/3/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations
https://docs.python.org/3/tutorial/controlflow.html#keyword-arguments
https://docs.python.org/3/whatsnew/3.6.html
