Natural Text
Cpython optimizes string increment operations,When initializing memory for a string, the program leaves extra expansion space for it,so, when incrementing, the original string is not copied to the new location.my question is why the id of string variable changes.why the id of string variable changes.
The optimization you are trying to trigger is an implementation detail of CPython and is a quite subtle thing:  there are many details (e.f. one you are experiencing) which can be preventing it.For a detailed explanation, one needs to dive into the CPython's implementation, so first I will try to give a hand-waving explanation, which should give at least the gist of what is going on. The gory details will be in the second part which highlights the important code-parts.Let's take a look at this function, which exhibits the desired/optimized behaviorCalling it, leads to the following output:I.e. a new string is created only every 8 addition, otherwise the old string (or as we will see the memory) is reused. The first id is printed only 6 times because it starts printing when the size of the unicode-object is 2 modulo 8 (and not 0 as in the later cases).The first question is, if a string is immutable in CPython, how (or better when) can it be changed? Obviously, we can't change the string if it is bound to different variables - but we could change it, if the current variable is the only one reference - which can be checked pretty easily due to reference counting of CPython (and it is the reason why this optimization isn't available for other implementation which don't use reference counting).Let's change the function above by adding a additional reference: Calling it leads to:This actually explains your observation:Your string s is interned (see for example this SO-answer for more information about string interning and integer pool), and thus s is not only one "using" this string and thus this string cannot be changed.If we avoid the interning, we can see, that the string is reused:But how does this optimization works? CPython uses its own memory management - the pymalloc allocator, which is optimized for small objects with short lifetimes. The used memory-blocks are multiple of 8 bytes, that means if allocator is asked for only 1 byte, still 8 bytes are marked as used (more precise because of the 8-byte aligment of the returned pointers the the remaining 7 bytes cannot be used for other objects). There is however the function PyMem_Realloc: if the allocator is asked to reallocate a 1byte-block as a 2byte-block, there is nothing to do - there were some reserved bytes anyway.This way, if there is only one reference to the string, CPython can ask the allocator to reallocate the string and require a byte more. In 7 cases of 8 there is nothing to do for allocator and the additional byte becomes available almost free.However, if the size of the string changes by more than 7 bytes, the copying becomes mandatory:Furthermore, pymalloc falls back to PyMem_RawMalloc, which is usually the memory manager of the C-runtime, and the above optimization for strings is no longer possible:Actually, whether the addresses are different after each reallocation depends on the memory allocator of the C-runtime and its state. If memory isn't defragmented, the chances are high,  that realloc manages to extend memory without copying (but it was not the case on my machine as I did these experiments), see also this SO-post.For the curious, here is the whole traceback of the str1+=str2 operation, which can be easily followed in a debugger:That is what going on: The += is compiled to BINARY_ADD-optcode and when evaluated in ceval.c, there is a hook/special handling for unicode objects (see PyUnicode_CheckExact):unicode_concatenate ends up calling PyUnicode_Append, which checks whether the left-operand is modifiable (which basically checks that there is only one reference, string isn't interned and some further stuff) and resizes it or creates a new unicode-object otherwise:unicode_resize ends up calling resize_compact (mostly because in our case we have only ascii-characters), which ends up calling PyObject_REALLOC:which basically will be calling pymalloc_realloc:Where INDEX2SIZE just rounds up to the nearest multiple of 8:qed. 
Strings are immutabale.  Using += on a str is not an in-place operation; it creates a new object with a new memory address, which is what id() gives under CPython's implementation.For str specifically, __iadd__ is not defined, so the operation falls back to a either __add__ or __radd__.  See the data model section of the Python docs for some detail.


Answer URL
https://docs.python.org/3/library/sys.html#sys.intern
https://docs.python.org/3/c-api/memory.html#the-pymalloc-allocator
https://docs.python.org/3/c-api/memory.html#c.PyMem_Realloc
https://docs.python.org/3/reference/datamodel.html#object.__iadd__
