Natural Text
I just started learning python so I'm not familiar with the various tricks or tools, or the proper way to word my question. Because of that, I was unable to find previous questions that do what I am looking for.I have a working code outlined here:The example output is shown below:As I have written it, the code performs as expected. However, I am concerned about the way that I've implemented the fight() method inside the Battle class. I don't think the large sequence of if statements is the proper way to say "user with higher speed attacks first". Logically, I just need a statement that is like self.attacker = max(self.user1.speed, self.user2.speed) but the attacker is set to the user, not the user's speed. However, I don't know how to accomplish this in one or two lines of code in python.
Creating small methods that concentrate logic is no "overhead". They are easy to understand, and do not need to change for lots of reasons - hence they are done, testet and unchanged most of the time.If you like a brain teaser you could as well do:which leverages tuple-sorting that sorts based on the 1st element, and when the 1st ones are equal on the 2nd element of the tuple. If both are equal the order stays as is (stable sorting with Timsort).Doku:Does Python have a ternary conditional operator? (for return .. if ... else ...)sorted(... with key and reversed ...)Why are Python lambdas useful?
The min and max functions accept a key function that tells them how to compare the inputs. The key accepts each input and returns the actual value to compare:For a large number of comparisons, this can be rewritten asIf you have equal speeds, you can decide to compare using a different attribute. This is done by understanding that Python sequences are compared in lexicographixal order. This is easiest to understand with strings, since it's basically just dictionary order: e.g. 'abc' > 'abb' because each element is compared in order. The same applies to lists and tuples: [1, 2, 3] > [1, 2, 2].So to use the dexterity attribute as a fallback for equal speeds, doOR
If you want to use max with your objects, you can implement __gt__ com compare them (and __eq__ for consistency). So your User class could look like this:This implementation would allow you to use max and min to define the attacker and defender in the Battle class.
I just need a statement that is like self.attacker =  max(self.user1.speed, self.user2.speed) but the attacker is set to the  user, not the user's speed.You can use This will return the user (not speed) has max speedIf you have more than 2 users, you can also pass listMore information about attrgetter
You can indeed use max() to get the user with most speed.The way of doing it is with the keyargument which you use to pass a custom scoring function that takes each object and returns a orderable value like a float or int.The most common is to pass an anonymous lambda function which you define with the syntax:So the code would look like:
Here is an answer that separates the logic as was mentioned above, and uses your original max desire. The benefit to this solution is that logic to determine first attack could be easily refactored. Simply change the order (or add attributes to) attribute_priority_orderWith a little extra abstraction, _compare_attributes method could be recycled to determine the winner as well maybe with an optional second attribute. The return from this method is optionally a user if there is no tie.
How about using the fact that python lists compare so your ability measure is:Your winning criteria is:And the fight becomes:


Answer URL
https://docs.python.org/3/library/functions.html#sorted
https://docs.python.org/3/library/operator.html#operator.attrgetter
