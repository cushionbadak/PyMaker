Natural Text
I'm making a program that has different control flows depending on whether  anything was written to sys.stdout or not. I made this program first in my Mac and I could do thisBut it turns out that I could not use tell() method on Linux and that's a problem for me. How can I tell if sys.stdout has been touched or not in this case?One think I can come up with is to make a wrapper class for both sys.stdout and sys.stdout.buffer to monitor all writing calls, although I'm not sure it's robust way of doing it.Or I think I may can give contextlib.redirect_stdout a try. But I am not sure how can I make use of it..EDIT:I'm working on this utility https://github.com/bombs-kim/pythonp. The feature I'm trying to implement is to automatically write the last expression of some_code in exec(some_code, globals) to stdout when there was no output to stdout.
How can I tell if sys.stdout has been touched or not in this case?You cannot, because stdout might have been redirected or in a pipeline (by the command used in your shell to run your Python script). For example, your user could have redirected stdout to /dev/null (see null(4)) by running your script.py as script.py > /dev/null for example, and then your question don't even make any sense. And your stdout might even be a socket, a fifo, a device, etc. Also, the exec-ution of some_code might change stdout (e.g. close it, redirect it using os.dup2, redefine itself the stdout Python object, etc...)Also, your program might not even be run in a terminal (think of a crontab(5) job, or running your program with at or ssh). See also the tty demystified page.The stdout standard stream is (conventionally) set up by the invoking process (usually, but not always, some shell) which has fork(2)-ed and execve(2)-ed your script.And that is not Linux specific, it is the Unix philosophy. You may want to read some Unix or Linux programming book (such as ALP).You might detect the case when your stdout is a terminal, by using isatty(3). But that certainly does not cover all the possible use-cases.Linux has /proc/ (see proc(5) for more) and the stdout is also /dev/stdout a.k.a. /proc/self/fd/1 on which you might do a stat(2) (and of course you could directly do fstat on STDOUT_FILENO which is 1). But even that won't cover all the possible use-cases.Have you thought of the case when your program monitors itself (e.g. pythonp pythonp ...) ?I am not sure to understand your real goals, but they ring the Rice's theorem in my head and your problem could be undecidable.
I solved it on my own by wrapping both sys.stdout.write, sys.stdout.buffer.write in python3.By my observation on cpython's standard library code, python's convention is that all writes to standard output should done by calling sys.stdout.write or sys.stdout.buffer.write, not directly calling something like os.fdopen(1, 'w').write. This is my temporary conclusion and I would like anyone who knows python better than me confirm this. Thank you everybody!


Answer URL
https://docs.python.org/3/library/functions.html#exec
https://docs.python.org/3/library/os.html?highlight=dup2#os.dup2
