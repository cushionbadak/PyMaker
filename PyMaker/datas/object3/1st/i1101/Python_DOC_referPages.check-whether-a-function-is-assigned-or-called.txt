Natural Text
I want to define a function that behaves differently depending on if it's calledor assignedIt seems to be possible, as shown in this question, but the method there described throws an error:and the trivial solution to use str() on the ord() argument clearly does not work.My particular reason for this is so that foo() creates a global variable baz if it's called, and does not if it's assigned.After reviewing the question's answer, I decided to go with using a global "private" variable _baz that gets assigned anyway.
Ultimately, if you need two different effects for when a function's value is stored and when not, you more likely need two different functions and just document then accordingly.You commented that "function is a data (file) reader. If function is called upon a filename, a global data variable is created, else it is assigned. " - no, silently creating a global variable "sometimes", is not a good design. If you want too, just create the global variable everytime. You'd be better using a global thread-local variable, so that a distinct value for the variable is used in each thread. Or, if you are using async-code, a context-local variable. Doing these would mitigate any unexpected changes to your global variable on the code expectng it to have the correct values after you call your function. And, as you can see, better yet, is just document that the function returns the read value, and leave it to the caller whether to assign that value to a global variable or not.Back to the question:Although there are far-off ways to detect if a return value is stored, it is not trivial, nor a thing expected to be done. The linked question, for example, uses advanced resources of the Python language to inspect the compiled code of the called function - this kind of resource is almost never used in code suitable for production, even in advanced library or frameworks, as its prone to be either too slow, or to break in sudden and unexpected ways. (For example, if in your production deployment, you configure some logging/traceback saving extension that would insert an a wrapper in your functions, it would mistake the callee function for the one in the framework - but just in production, not on the development machine). But more important than that, the linked code does not even start to check for corner cases, like, if the value is transformed prior to being stored (one might call a 'replace' method on it, or any other string method), or stored in a list or dictionary instead of in a local variable. Covering all possible use cases using that approach to the point of it being reliable is not possible at all.But I am taking some time to elaborate an answer to clarify this should not be useful at all - if you understand how objects work in Python, you might find a better way to implement whatever you have in mind, without needing to know if the object is "stored" or not:Any function in Python will return an object. Even if the object is "None". The fact is in Python, objects can be considered like "black boxes" until the point when they are used for something. When they are in fact used - not just stored in a variable, list, as a value in a dictionary, etc... when that happens, it is just a "black box" being stored, and the object can't be aware of being assigned a name or added to a list at all (maybe it is possible to code hooks in native code to check for increases in the reference counting of an object - but you'd need to do that at least in Cython if not in C - it very, very iffy, enough to say "it can't be aware").But when an object is "used", that is another story. When you want to check what an object "is", even in the interactive terminal, or by printing it, the object's __repr__ or __str__ methods will be called. If you are making an operation with an object  - trying to add it with another object with the "+" operator, or any other operator, special methods in the object are called.If you are trying to save the object state to a file, it will be serialized - that will call methods used by the pickle protocol, or even __str__ itself, depending on the serialization used, and so on.So, you can specialize a class and wrap all the desired "magic" methods, the ones defined in the language Data Model with names surrounded by  __, to perform the action you'd like to do for when the object is "not stored" for example. By the way, there is even a very simple method in the object that is called if it is not stored at all after the function call: the object's __del__ method will be called.So, for simply having an effect when the object is not stored, you could dynamically create a subclass of whatever is the result of your function with a custom __del__ method, and perform your action there. This is still code that could have some objections in a production environment, but it is much more straightforward than interpreting the opcode of the calling function. But, of course, if the object is stored, when it is finally deleted in a later point in the code, the __del__ method would be triggered nonetheless. You can devise a mechanism to change an attribute in the object if any other special method is called before __del__, and if so, disable the side-effect - but as you can see, this is not trivial as well. 
There isn't a simple way for a function to know what will be done with its result.  Writing functions that change behavior like this would be a good way to confuse people.  Better to use Python's features in a simple straightforward way.


Answer URL
https://docs.python.org/3/library/threading.html#threading.local
https://docs.python.org/3/reference/datamodel.html
https://docs.python.org/3/library/inspect.html#the-interpreter-stack
