Natural Text
I have the following package (and working directory):In __init__.py I have:If I try to import MyPackage into my notebook:I will get ModuleNotFoundError: No module named 'module1'. But import works fine if I execute the script outside a notebook: if I create test.py in the same directory and do the same as in the notebook the import would work properly. It will work inside the notebook if I use fully qualified name in __init__.py (import MyPackage.module1).What's the reason for different import behavior?I have confirmed the working directory of the notebook is WorkingDirectory.---Update---------Exact error is:My problem differs from the possible duplicate:The notebook was able to find the package, but only unable to load the module. This was inferred from substituting module1 with MyPackage.module1 worked well and suggests it may not be a problem related with PATH.I cded into WorkingDirectory and started the server there. The working directory should be the folder containing my package.
I'm pretty sure this issue is related and the answer there will help you: https://stackoverflow.com/a/15622021/7458681tl;dr the cwd of the notebook server is always the base path where you started the server, no matter was running import os os.getcwd() says. Use import sys sys.path.append("/path/to/your/module/folder"). I ran it with some dummy modules in the same structure as you had specified, and before modifying sys.path it wouldn't run and after it would
The reason is that your MyPackage/__init__.py is ran from the current working directory. E.g. from WorkingDirectory in this case. It means, that interpreter cannot find the module named module1 since it is not located in either current or global packages directory.There are few workarounds for this. For example, you can temporarily override a current working directory like thisand then, after all a package initialization actions like import module1 are done, restore "caller's" working directory with os.chdir(cwd).This is quite a bad approach as for me, since, for example, if an exception is raised on initialization actions, a working directory would not be restored. You'll need to play with try..except statements to fix this. Another approach would be using relative imports. Refer to the documentation for more details.Here is an example of MyPackage/__init__.py that will work for your example:But it has few disadvantages that are found rather empirically then through the documentation. For example, you cannot write something like import .module1.Upd:I've found this exception to be raised even if import MyPackage is ran from usual python console. Not from IPython or Jupyter Notebook. So this seems to be not an IPython itself issue.


Answer URL
https://docs.python.org/3/tutorial/modules.html#intra-package-references
