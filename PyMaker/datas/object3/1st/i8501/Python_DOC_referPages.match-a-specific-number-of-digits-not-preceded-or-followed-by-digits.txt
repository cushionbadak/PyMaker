Natural Text
I have a string:I want to find all k consecutive chunks of digits where n <= k <= m. Using regular expression only:say for example n=2 and m=3    using (?:\D|^)(\d{2,3})(?:\D|$)Gives this output:Desired output:I know there are alternate solutions like:which gives the desired output, but I want to know what's wrong with the first approach? It seems re.findall goes in sequence and skips the previous part when matched, so what can be done?
Note: The result you show in your question is not what I'm getting:It's still missing some of the matches you want, but not the same ones.The problem is that even though non-capturing groups like (?:\D|^) and (?:\D|$) don't capture what they match, they still consume it.This means that the match which yields '22' has actually consumed:e, with (?:\D|^) – not captured (but still consumed)22 with (\d{2,3}) – capturedb with (?:\D|$) – not captured (but still consumed)… so that b is no longer available to be matched before 333.You can get the result you want with lookbehind and lookahead syntax:Here, (?<!\d) is a negative lookbehind, checking that the match is not preceded by a digit, and (?!\d) is a negative lookahead, checking that the match is not followed by a digit. Crucially, these constructions do not consume any of the string.The various lookahead and lookbehind constructions are described in the Regular Expression Syntax section of Python's re documentation.
lookaround regex,\d{2,3} means 2 or 3 digits, (?=[a-z]) means letter after digits. 
You could even generalize it with a function:


Answer URL
https://docs.python.org/3/library/re.html#regular-expression-syntax
