Natural Text
I need a way to compute the nth root of a long integer in Python. I tried pow(m, 1.0/n), but it doesn't work:OverflowError: long int too large to convert to floatAny ideas?By long integer I mean REALLY long integers like:11968003966030964356885611480383408833172346450467339251  196093144141045683463085291115677488411620264826942334897996389  485046262847265769280883237649461122479734279424416861834396522  819159219215308460065265520143082728303864638821979329804885526  557893649662037092457130509980883789368448042961108430809620626  059287437887495827369474189818588006905358793385574832590121472  680866521970802708379837148646191567765584039175249171110593159  305029014037881475265618958103073425958633163441030267478942720  703134493880117805010891574606323700178176718412858948243785754  898788359757528163558061136758276299059029113119763557411729353  915848889261125855717014320045292143759177464380434854573300054  940683350937992500211758727939459249163046465047204851616590276  724564411037216844005877918224201569391107769029955591465502737  961776799311859881060956465198859727495735498887960494256488224  613682478900505821893815926193600121890632
You can make it run slightly faster by avoiding the while loops in favor of setting low to 10 ** (len(str(x)) / n) and high to low * 10.  Probably better is to replace the len(str(x)) with the bitwise length and using a bit shift.  Based on my tests, I estimate a 5% speedup from the first and a 25% speedup from the second.  If the ints are big enough, this might matter (and the speedups may vary).  Don't trust my code without testing it carefully.  I did some basic testing but may have missed an edge case.  Also, these speedups vary with the number chosen.If the actual data you're using is much bigger than what you posted here, this change may be worthwhile.Norm 0.626754999161Alt 0.566340923309
If it's a REALLY big number. You could use a binary search.For example:
Gmpy is a C-coded Python extension module that wraps the GMP library to provide to Python code fast multiprecision arithmetic (integer, rational, and float), random number generation, advanced number-theoretical functions, and more.Includes a root function:x.root(n): returns a 2-element tuple (y,m), such that y is the  (possibly truncated) n-th root of x; m, an ordinary Python int,  is 1 if the root is exact (x==y**n), else 0.  n must be an ordinary  Python int, >=0.For example, 20th root:
If you are looking for something standard, fast to write with high precision. I would use decimal and adjust the precision (getcontext().prec) to at least the length of x.Code (Python 3.0)Answerx is the cubic number of 228739187861856353290568639617255215830231334114514523493181096276535406707619622159719944036700456144859737227246037981077199788136588570141900477426804900885328956669636985517099785027459017044337235675487994631296527067058736942742097287850418176190327742484882965377218610139128882473918261696612098418
Oh, for numbers that big, you would use the decimal module.ns: your number as a stringand the answer is: 2.287391878618402702753613056E+305TZ pointed out that this isn't accurate... and he's right.  Here's my test.It's off by about 10**891
Possibly for your curiosity:http://en.wikipedia.org/wiki/Hensel_LiftingThis could be the technique that Maple would use to actually find the nth root of large numbers.Pose the fact that x^n - 11968003.... = 0 mod p, and go from there...
In older versions of Python, 1/3 is equal to 0.  In Python 3.0, 1/3 is equal to 0.33333333333 (and 1//3 is equal to 0).So, either change your code to use 1/3.0 or switch to Python 3.0 .
I came up with my own answer, which takes @Mahmoud Kassem's idea, simplifies the code, and makes it more reusable:I tested it in Python 3.5.1 and Python 2.7.8, and it seemed to work fine.The result will have as many digits as specified by the decimal context the function is run in, which by default is 28 decimal places. According to the documentation for the power function in the decimal module, "The result is well-defined but only “almost always correctly-rounded”.". If you need a more accurate result, it can be done as follows:
Try converting the exponent to a floating number, as the default behaviour of / in Python is integer divisionn**(1/float(3))
Well, if you're not particularly worried about precision, you could convert it to a sting, chop off some digits, use the exponent function, and then multiply the result by the root of how much you chopped off.E.g. 32123 is about equal to 32 * 1000, the cubic root is about equak to cubic root of 32 * cubic root of 1000.  The latter can be calculated by dividing the number of 0s by 3.This avoids the need for the use of extension modules.


Answer URL
https://docs.python.org/3/library/decimal.html#decimal.Context.power
