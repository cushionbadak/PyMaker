Natural Text
If I create a list in python, and assign a different list to it, changes of the first list are reflected in the second list:Is it possible to achieve this behavior when creating a numpy array from a list?What I want:But what actually happens is that b is [ 1 2 3 ]. I realize that this is difficult due to dynamic resizing of the list. But if I could tell numpy that this list is never resized, it should work somehow.Is this behavior achievable? Or am I missing some really bad drawbacks?
Fundamentally the issue is that Python lists are not really arrays. OK, CPython lists are ArrayLists, but they are arrays of Py_Object pointers, so they can hold heterogenous data. See here for an excellent exposition on the implementation details of CPython lists. Also, they are resizable, and all the malloc and realloc gets taken care of under the hood. However, you can achieve something like what you want if you use vanilla Python arrays available in the array module.Let's make a real array:We can use numpy.frombuffer if we want our np.array to share the underyling memory of the buffer:EDIT: WARNINGAs stated by @user2357112 in the comments:Watch out - numpy.frombuffer is still using the old buffer protocol  (or on Python 3, the compatibility functions that wrap the new buffer  protocol in an old-style interface), so it's not very memory-safe. If  you create a NumPy array from an array.array or bytearray with  frombuffer, you must not change the size of the underlying array.  Doing so risks arbitrary memory corruption and segfaults when you  access the NumPy arrayNote, I had to explicitly pass dtype='int32' because I initialized my array.array with the i signed int typecode, which on my system corresponds to a 32 bit int. Now, presto:Now, if we use dtype=object, we actually can share the underlying objects. However, with numerical types, we can't mutate, only replace. However, we can wrap a Python int in a class to make a mutable object:Now, we create an array that consists of the same objects:Now, we can mutate the int wrapper in the list:And the effects are visible in the numpy array!:Note, though, you've now essentially created a less useful version of a Python list, one that isn't resizable, and doesn't have the nice O(1) amortized append behavior. We also lose any memory efficiency gains that a numpy array might give you!Also, note that in the above the obj_list and obj_array are not sharing the same underlying buffer, they are making *two different arrays of holding the same Py_Obj pointer values:We cannot access the underlying buffer to a python list because this is not exposed. Theoretically, they could if they exposed the buffer protocol: https://docs.python.org/3/c-api/buffer.html#bufferobjectsBut they don't. bytes and bytearray objects do expose the buffer protocol. bytes are essentially Python 2 str, and bytearray is a mutable version of bytes, so they are essentially mutable char arrays like in C:Now, let's make a numpy array that shares the underlying buffer:Now, we will see changes reflected across both objects:Now, before you think you can use this to subvert the immutability of Python bytes objects, think again:
A list contains pointers to objects (in this case integers) elsewhere in memory.b points to the same list as a.  It's just another namec is new, but it contains the same pointers as aarr has the same numeric values as a, but it stores those values in its own databuffer.  It has, in effect, evaluated a, and made a new object.  There is no connection, other than by value, with a.a new array, but with a shared data buffer, a view.a new array with its own data buffer.is a number, created from arr.  It's equal in value to a[0] but does not reference the same numeric object.


Answer URL
https://docs.python.org/3/library/array.html
https://docs.python.org/3/c-api/buffer.html#bufferobjects
