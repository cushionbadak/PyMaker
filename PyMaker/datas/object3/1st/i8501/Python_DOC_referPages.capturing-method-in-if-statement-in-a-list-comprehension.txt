Natural Text
I have a following use case:Above list comprehension, I think makes a f(x) call twice? How do I avoid that and capture value of f(x) so that f(x) is called only once.I guess, easy fix is to convert above list comprehension into a for loop, but am curious if it can be done efficiently using a list comprehension.
You can use a nested generator expression to call the function only once:The generator expression is iterated in lockstep to produce the (x, fx) tuples for the list comprehension.If you find this easier on the reader, you can split out the generator expression into a separate name first:To re-iterate this point: the generator expression is executed lazily; the for loop in the expression is advanced step by step for each step in the for ... in mapped_x loop.Demo:Note how f(x) is called just once, and the condition is checked immediately.How efficient this is depends on how costly the f(x) call is; a generator expression is executed as a separate function frame, and the interpreter will switch between the two frames (the loop for the list comprehension is also a frame object). If f(x) is a Python function, you'll already have won, as you now halved the number of function frame objects that are created (each f(x) call creates a frame object too, and creating these is relatively costly). For C functions, you should create some trial runs with the timeit module to see what is faster for your expected list size.
If you do not want to call f twice, you can apply f to the list first[a for a in map(lambda x: (x, f(x)), list_x) if a[1] == cond(x)]
Filter would be a clean way of doing this.  It will evaluate the function passed and if it returns true, it will keep the element, otherwise, no.


Answer URL
https://docs.python.org/3/library/timeit.html
