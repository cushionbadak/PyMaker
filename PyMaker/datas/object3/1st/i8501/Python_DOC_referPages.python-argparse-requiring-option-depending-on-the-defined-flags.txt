Natural Text
I have a small python script, which uses argparse to let the user define options. It uses two flags for different modes and an argument to let the user define a file. See the simplified example below:Method A requires the file.Method B does not.If I run the script with method A, I either use the default file or one that is defined with -f/--file. The script checks if the file exists and everything is fine.Now, if I run the script with method B, it shouldn't require the file, but the default option is checked and if it doesn't exist the argparse function raises the exception and the script exits.How can I configure argparse to make -f optional, if -b is defined and require it, if -a is defined? edit: I just realized that it would be enough for me to make -f and -b mutually exclusive. But then, if I run -b only, the check_file is executed anyways. Is there a way to prevent that?Output:
You can defined subparser with ay/be as subcommand or alternatively declare a second parser instance for a. Something like:
Your problem lies with how argparse handles defaults.  You'd get this behavior even if -f was the only argument.  If the default is a string value, it will be 'evaluated' if the Action isn't seen.At the start of parsing defaults are put into the args namespace. During parsing it keeps track of whether Actions have been seen.  At the end of parsing it checks Namespace values for Actions which haven't been seen.  If they match the default (the usual case) and are strings, it passes the default through the type function.In your -f case, the default is probably a file name, a string.  So it will be 'evaluated' if the user doesn't provide an alternative.  In earlier argparse versions defaults were evaluate regardless of whether they were used or not.  For something like a int or float type that wasn't a problem, but for FileType it could result in unneeded file opening/creation.Ways around this?write check_file so it gracefully handles aFile.make sure aFile is valid so check_file runs without error.  This the usual case.use a non-string default, e.g. an already open file.use the default default None, and add the default value after parsing.if args.file is None:     args.file = aFileCombining this with -a and -b actions you have to decide whether:if -a, is a -f value required?  If -f isn't provided, what's the right default.if -b, does it matter whether -f has a default or whether the user provides this argument?  Could you just ignore it?If -f is useful only when -a is True, why not combine them?With ?, this works in 3 ways. (docs on const)no -a, args.a = defaultbare -a, args.a = const-a afile,args.a = afileAn even simpler example of this behavior The string default is passed through int resulting in an error.  If I'd set default to something else like a list, default=[1,2,3], it would have run even though int would have choked on the default.


Answer URL
https://docs.python.org/3/library/argparse.html#const
