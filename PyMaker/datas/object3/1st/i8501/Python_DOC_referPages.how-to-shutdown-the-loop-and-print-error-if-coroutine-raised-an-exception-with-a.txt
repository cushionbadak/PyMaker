Natural Text
Suppose I have a few coroutines running in a loop. How to make so that if some of them failed with exception the whole program would fail with this exception? Because right now asyncio doesn't even prints the error messages from coroutines unless I use logging level "DEBUG".
A graceful way is using error handling api.https://docs.python.org/3/library/asyncio-eventloop.html#error-handling-apiExample:
Here are some notes that you might want use to craft your solution:The easiest way to retrieve a couroutine's exception (or result!) is to await for it.  asyncio.gather() will create tasks from coroutines and wrap all of them in one encompassing task that will fail if one of the subtasks fails:This however does not shutdown the loop. To stop a running loop, use loop.stop().  Use this instead:Stopping the loop while some long-running coroutines are running is probably not what you want. You might want to first signal some your coroutines to shut down using an event:If you don't want to await for your tasks, you might want to use an asyncio.Event (or asyncio.Queue) to signal a global error handler to stop the loop:(Used here with run_until_complete() for simplicity, but can be used with loop.stop() as well)
Okay, I've found the solution that doesn't require rewriting any existing code. It may seem hacky, but I think I like it.Since I already catch KeyboardInterrupt like so.How about sending KeyboardInterrupt to itself from a coroutine? I thought that this would hang the application, because os.kill would wait for application to close and because the application it would wait is the same application it would make kind of a deadlock, but thankfully I was wrong. And this code actually works and prints clean up before exiting.


Answer URL
https://docs.python.org/3/library/asyncio-eventloop.html#error-handling-api
