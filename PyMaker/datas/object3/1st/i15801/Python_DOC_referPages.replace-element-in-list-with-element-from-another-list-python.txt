Natural Text
I have a list named rule.start. In this list, all elements are equal to an element from another list called com.empty. I want the element from rule.start to be replaced by the element that comes AFTER the same element from com.empty. How would I do this?rule.start looks like this:['F', 'L', 'G', 'L', 'F', 'R', 'F', 'R', 'F', 'L', 'G', 'L', 'F', 'L', 'F', 'L', 'G', 'L', 'F', 'L',........]com.empty looks like this:['F', ['fd'], 'G', ['fd'], 'L', ['lt', '60'], 'R', ['rt', '60']]I have tried this:But it just replaces all element of rule.start with ['fd']In the end, I want to evaluate all elements as commands, that looks like this: fd(var, scale)and this: rt(var, 60)   # 60 is from the list.
First, this would be much easier to write, and a lot more efficient, if you had a dictionary, mapping keys to values, instead of a list of alternating keys and values. You can do that as a one-liner:But if you don't understand how that works, you can do this, which you should be able to understand (based on your code).Or, even better, if possible, change your code to build a dict instead of a list of alternating values in the first place.Now, once you have this, your loop becomes dead simple, and very hard to get wrong:I'm using enumerate so you don't have to keep track of wut manually, and I'm using the dict.get method instead of looping over all the keys and values, which is the tricky part that you got lost in.Or, even more simply:But, if you want to know what's wrong with your attempt:You start off v = 1. For each mel, you increment v by 2 if elem == mel. Otherwise, it stays at 1. So, the first time elem == mel, you're going to have v = 1, so you're going to assign com.empty[1] to rule.start[wut]. If you move the v + 2 outside the loop, that will fix this problem.You also have a similar problem with wut += 1 being in the wrong place. It should be updated for every elem; instead, it's updated for every elem and mel that match, which could be 0 times or (theoretically) 3 times.Getting this stuff right is a big source of errors, which is exactly why enumerate exists.
I would be tempted to start by rewriting com.empty as a dict, which is what you really want here. Then it's pretty easy:of course, this fails if you have a key in rule.start which is not in com.empty - I'll let you dot the i's and cross the t's to make it safe for your use


Answer URL
https://docs.python.org/3/library/functions.html#enumerate
https://docs.python.org/3/library/stdtypes.html#dict.get
