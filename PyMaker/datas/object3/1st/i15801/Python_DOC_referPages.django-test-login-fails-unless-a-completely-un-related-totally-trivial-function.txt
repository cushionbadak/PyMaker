Natural Text
I'm getting a strange error in my Django testing code.Full code:Continued. This is the login line I'm talking about. This _test_one_logged_in_user function is called by the second to last line (_test_one_logged_in_user(self, 0)) below:This works fine. Everything passes. But change the name of test_true_is_true to test_content_not_logged_inand test_instance.client.login now returns False...which results in the assertion below itto fail: AssertionError: False is not true. If you comment out the entire function, though, it succeeds (login returns True).If you uncomment it and rename it to any of the following, it works:test_xcontent_not_logged_intest__content_not_logged_intest_not_logged_inAny of these, and it fails:test_ctrue_is_truetest_cxontent_not_logged_intest_contentnot_logged_intest_contennot_logged_intest_contenot_logged_intest_contnot_logged_intest_connot_logged_intest_cnot_logged_intest_c(I've searched for test_c and found something but nothing that indicates anything particularly special.)This seems to imply that the setUp function runs once for test_content_not_logged_in (the trivial function), and then again for test_logged_in_users. And this running twice is causing problems. So I changed it so the users are only created if the TEST_USER array is empty:But it's still failing, and I can confirm it's failing with the user having an id of 1:models.py:
When you change the name of the test, you change the order in which the tests run. The test_logged_in_users method runs BEFORE test_true_is_true but runs AFTER test_c_whatever (presumably because it's running them in alpha or some sort of order). This is why you're seeing the weirdness with the name changes.As you figured out, your setUp method runs for each test case.  When your setUp runs the first time, Users are created and saved to both the DB and TEST_USERS. When your second test runs, your DB is refreshed, and all your users are deleted. The users represented by TEST_USERS (which are still in your list, because your globals persist across test cases) no longer exist in the DB.You can make your test pass in your original code by resetting TEST_USERS, like this:Now, TEST_USERS represents new, real users that match users in the DB. Generally speaking, though, globals are a bad idea (for several reasons, the confusion you're experiencing being among them). Creating them on-the-fly (as you're working toward in your latest update) is a much better solution.
TestCase will recognize all the tests by looking for methods that start with testFrom documentation:The individual tests are defined with methods whose names start  with the letters test. This naming convention informs the test runner  about which methods represent tests.So when you rename a_trivial_function it changes whether it is considered a test or not.
The original code stores TEST_USERS locally, and it seems that statically-held object was causing problems when shared among the tests. I naively thought it was important to store the objects locally, in order to compare the database values against it. That implies I don't trust Django or Factory Boy to correctly insert them into the database, and they can handle that just fine.Here's the updated code, which only stores the objects in the database. I also moved the contents sub-function containing login directly into the bottom function.Continued:


Answer URL
https://docs.python.org/3/library/unittest.html#unittest.TestCase
