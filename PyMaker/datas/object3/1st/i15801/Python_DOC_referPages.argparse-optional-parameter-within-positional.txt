Natural Text
With argparse I would like to be able to mix optional parameters with multiple positional parameters, e.g., like svn allows:At the moment, this is not officially supported by Python (c.f. http://bugs.python.org/issue14191). I wrote this workaround and I am now wondering, if a) there is a better/easier/more elegant way to do it, and b) if someone can see something in the code that might break it under certain cirumstances:Usage example:Output:
You could use parse_known_args instead of including a remainder:yields
Do you want files=[['a', 'b'], ['c', 'd']] or files=['a', 'b', 'c', 'd']?  In other words shouldgive different files lists of lists.append with a * positional usually doesn't make sense, since you can't repeat a positional argument.  But with this recursive application, it does work.  But if the sublists are important, why not use multiple positional arguments.On the other hand, to get a flat list of 'files', you could do several things:You could flatten the list after parsing (e.g. args.files=list(itertools.chain(*args.files)))You could use p.add_argument('files', nargs='?', action='append').  This iterates over each file string.You could replicate the http://bugs.python.org/issue14191 patch by removing the positional from the initial parse.  In this case the extras can be simply inserted into args.A disadvantage of this is that the usage and help known nothing about the positional, requiring a custom usage and/or description parameter.unutbu's answer does not preserve the groupings.  They are lost the first time through:    Namespace(files=[['a', 'b'], ['c', 'd', 'e', 'f']], l=True, v=True)It could be changed to give a flat list:The iteration isn't needed, since optionals are handled the first time through.  All that is left in unknown are files.In sum - to preserve the groupings, your solution appears to be the best.


Answer URL
https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.parse_known_args
