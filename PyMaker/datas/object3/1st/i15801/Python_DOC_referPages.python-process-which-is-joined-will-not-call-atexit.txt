Natural Text
I thought Python Processes call their atexit functions when they terminate. Note that I'm using Python 2.7. Here is a simple example:I'd expect this to print "atexit function ran" but it does not.Note that this question:Python process won't call atexit is similar, but it involves Processes that are terminated with a signal, and the answer involves intercepting that signal. The Processes in this question are exiting gracefully, so (as far as I can tell anyway) that question & answer do not apply (unless these Processes are exiting due to a signal somehow?).
I did some research by looking at how this is implemented in CPython. This is assumes you are running on Unix. If you are running on Windows the following might not be valid as the implementation of processes in multiprocessing differs.It turns out that os._exit() is always called at the end of the process. That, together with the following note from the documentation for atexit, should explain why your lambda isn't running.Note: The functions registered via this module are not called when the  program is killed by a signal not handled by Python, when a Python  fatal internal error is detected, or when os._exit() is called.Here's an excerpt from the Popen class for CPython 2.7, used for forking processes. Note that the last statement of the forked process is a call to os._exit().In Python 3.4, the os._exit() is still there if you are starting a forking process, which is the default. But it seems like you can change it, see Contexts and start methods for more information. I haven't tried it, but perhaps using a start method of spawn would work? Not available for Python 2.7 though.


Answer URL
https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods
