Natural Text
Let's have a class that has function that fails from time to time but after some actions it just works perfectly.Real life example would be Mysql Query that raises _mysql_exceptions.OperationalError: (2006, 'MySQL server has gone away') but after client reconnection it works fine.I've tried to write decorator for this:And if client loses connection it just silently reconnect and everybody is happy.But what if I want to transform get_data() to generator (and use yield statement):Well, previous example won't work because inner function already returned generator and it will break after calling first next().As I understand it if python sees yield inside method it just yields control immediately (without executing one single statement) and waits for first next().I've managed to make it work by replacing:With:But I'm curious whether there is more elegant (more pythonic) way to do this. Is there a way to make python run all the code up to first yield and then wait?I'm aware of possibility of just calling return tuple(func(self, *args, **kwargs)) but I want to avoid loading all records at once.
First, I think the solution you're currently using is fine. When you decorate a generator, the decorator is going to need to at least behave like an iterator over that generator. Doing that by making the decorator a generator, too, is perfectly ok. As x3al pointed out, using yield from func(...) instead of for row in func(...): yield row is a possible optimization.If you want to avoid actually making the decorator a generator, too, you can do that by using next, which will run until the first yield, and return the first yielded value. You'll need to make the decorator somehow capture and return that first value, in addition to the rest of the values to be yielded by the generator. You could do that with itertools.chain:You could also make the decorator work with both generator and non-generator functions, using inspect to determine if you're decorating a generator:I would favor the yield/yield from-based solution, unless you have a requirement to decorate regular functions in addition to generators.
Is there a way to make python run all the code up to first yield and then wait?Yes and it's called next(your_generator). Call next() once and the code will wait exactly after first yield. You can place another yield right before the loop if you don't want to lose first value.If you're using python 3.3+, you can also replacewith yield from func(self, *args, **kwargs).


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.chain
https://docs.python.org/3/library/inspect.html
