Natural Text
I'm using HTTPServer for a basic HTTP server using SSL. I would like to log any time a client initiates an SSL Handshake (or perhaps any time a socket is accepted?) along with any associated errors. I imagine that I'd need to extend some class or override some method, but I'm not sure which or how to properly go about implementing it. I'd greatly appreciate any help. Thanks in advance!Trimmed down sample code:
From looking at the ssl module, most of the relevant magic happens in the SSLSocket class.ssl.wrap_socket() is just a tiny convenience function  that basically serves as a factory for an SSLSocket with some reasonable defaults, and wraps an existing socket.Unfortunately, SSLSocket does not seem to do any logging of its own, so there's no easy way to turn up a logging level, set a debug flag or register any handlers.So what you can do instead is to subclass SSLSocket, override the methods you're interested in with your own that do some logging, and create and use your own wrap_socket helper function. Subclassing SSLSocketFirst, copy over ssl.wrap_socket() from your Python's .../lib/python2.7/ssl.py into your code. (Make sure that any code you copy and modify actually comes from the Python installation you're using - the code may have changed between different Python versions).Now adapt your copy of wrap_socket() tocreate an instance of a LoggingSSLSocket (which we'll implement below) instead of SSLSocketand use constants from the ssl module where necessary (ssl.CERT_NONE and ssl.PROTOCOL_SSLv23 in this example)Now change your linetoin order to use your own wrap_socket().Now for subclassing SSLSocket. Create a class LoggingSSLSocket that subclasses SSLSocket by adding the following to your code:Here we override the accept() and do_handshake() methods of ssl.SSLSocket - everything else stays the same, since the class inherits from SSLSocket.Generic approach to overriding methodsI used a particular pattern for overriding these methods in order to make it easier to apply to pretty much any method you'll ever override:*args, **kwargs makes sure our method accepts any number of positional and keyword arguments, if any. accept doesn't actually take any of those, but it still works because of Python's packing / unpacking of argument lists.Here you get the opportunity to do your own thing before calling the superclass' method.This is the actual call to the superclass' method. See the docs on super() for details on how this works, but it basically calls .methodname() on LoggingSSLSocket's superclass (SSLSocket). Because we pass *args, **kwargs to the method, we just pass on any positional and keyword arguments our method got - we don't even need to know what they are, the method signatures will always match.Because some methods (like accept()) will return a result, we store that result and return it at the end of our method, just before doing our post-call work:Logging more detailsIf you want to include more information in your logging statements, you'll likely have to completely overwrite the respective methods. So copy them over and modify them as required, and make sure you satisfy any missing imports.Here's an example for accept() that includes the IP address and local port of the client that's trying to connect:(Make sure to include from socket import socket in your imports at the top of your code - refer to the ssl module's imports to determine where you need to import missing names from if you get a NameError. An good text editor with PyFlakes configured is very helpful in pointing those missing imports out to you).This method will result in logging output like this:Because it involves quite a few changes scattered all over the place, here's a gist containing all the changes to your example code.


Answer URL
https://docs.python.org/3/tutorial/controlflow.html#arbitrary-argument-lists
https://docs.python.org/3/library/functions.html#super
