Natural Text
The problem is that I'm losing a value after the zip call. This would be a bigger issue had it not been for the fact that gen is pure code.I don't know whether or not it would be possible to create a function that behaves like this, it's definitely possible if only one of the arguments to the zip function is a generator and the rest are "normal" iterators where all the values are known, and stored in memory. If that were the case you could just check the generator last.Basically what I am wondering is if there is any function in the python standard library that will act like I need it to in this case.Of course, in some cases one could just do something likeThen you only have to deal with a list.I could also add, that getting the last value that zip got from gen would also be a solution to this problem.
No, there are no built-in functions that avoid this behaviour.What happens is that the zip() function tries to get the next value for all inputs, so that it can produce the next tuple. It has to do this in a order, and it is only logical that that order is the same as the arguments passed in. In fact, the order is guaranteed by the documentation:The left-to-right evaluation order of the iterables is guaranteedBecause the function needs to support arbitrary iterables, zip() does not make any attempts at determining the length of all parameters. It doesn't know that your second parameter only has 3 elements. It simply tries to get the next value for each of the parameters, builds a tuple and returns that. If any of the parameters cannot produce a next value, the zip() iterator is done. But that does mean that it'll ask your generator for the next element first before asking the list.Apart from altering the order of your inputs, you can build your own zip() function instead, that does try to take length into account, where available:So this version of the zip() function tries to get a bead on the minimal length of any sequences you passed in. This does not protect you from using a shorter iterable in the mix, but does work for your test case:Demo:
Problem is that zip(gen,[1,2,3]) generates 0,1,2, and 3 also but finds that second argument is of length three only. So if you do it in reverse, you can generate 3 in next(gen) code line:
The problem is that when zip reaches StopIteration on one of its iterables, it forgets the values returned from the preceding iterables.Here's a solution using zip_longest and groupby from itertools to partition the zip sequence into before and after the shortest iterable terminates:
You can use a wrapper class around your generator to give you access to the most recent element. I took most of this code from the Python Wiki at https://wiki.python.org/moin/Generators.


Answer URL
https://docs.python.org/3/library/functions.html#zip
