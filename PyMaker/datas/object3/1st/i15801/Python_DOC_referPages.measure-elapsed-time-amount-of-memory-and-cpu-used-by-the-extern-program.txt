Natural Text
I'm executing an external program through Python. I want to know what is the best choice for calling the outside program, with subprocess.Popen() or with subprocess.call(). Also, I need to measure elapsed time, the amount of memory and CPU used by the external program. I've heard of psutil, but I don't really know which to choose.
also I need to measure elapsed time, amount of memory and cpu used by the extern program(I'm going to assume you only need the information available in your platform's rusage. And, since Windows has no such thing at all, I'm also going to assume you don't care about Windows. If you need additional information that's only available in some platform-specific way (reading out of Linux's proc filesystem, or calling AIX's monitor APIs, or whatever), you pretty much can't do this with the stdlib, and the psutil answer is the only one.)The subprocess library wraps up calling fork, then an execv-family function in the child and a waitpid-family function in the parent. (You can see this by starting with the source to call and tracing down into the other calls from there.)Unfortunately, the easy way to get resource usage from a child is to call wait3 or wait4, not wait or waitpid. So subprocess gets you maddeningly close to what you want, but not quite there.But you've got a few options:If you only have one child process, getrusage(RUSAGE_CHILDREN) is all you need.You can launch the process, then use psutil (or platform-specific code) to get resource information from proc.pid before reaping the child.You can use psutil to do everything, leaving subprocess behind.You can subclass subprocess.Popen to override its wait method.The last one is a lot simpler than it sounds. If you look at the source, there are only 3 places where os.waitpid is actually called, and only one of them will be the one that affects your code; I think it's the one in _try_wait. So (untested):And now:Compare that to using a hybrid with psutil (which won't even work when used this way on many platforms…):Of course the latter isn't more complex for not good reason, it's more complex because it's a whole lot more powerful and flexible; you can also get all kinds of data that rusage doesn't include, and you can get information every second while the process is running instead of waiting until it's done, and you can use it on Windows, and so on…


Answer URL
https://docs.python.org/3/library/os.html#os.fork
https://docs.python.org/3/library/os.html#os.execv
https://docs.python.org/3/library/os.html#os.waitpid
https://docs.python.org/3/library/os.html#os.wait4
https://docs.python.org/3/library/resource.html#resource.getrusage
