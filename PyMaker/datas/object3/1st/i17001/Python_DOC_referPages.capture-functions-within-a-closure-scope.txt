Natural Text
Python3 added a __prepare__ so that you could substitute the type of dictionary used to gather items from a class declaration (see here.) Using __prepare__ I can set up the class to allow multiple definitions of the same member function.At the module level, I could play some tricks using a decorator:However, if I do this within a closure, I could potentially add things scoped at the module level which should not be.Is there a way to identify and capture the functions declared within the scope of a closure so that I can handle these differently than functions declared at module scope without having to reference the closed over function (i.e. @some_awesome_deco(foo)?)
If all you need to support is CPython, then your decorator could look at the sys._getframe(1) frame object, which represents the execution frame for the code executing the decorator. If the frame.f_locals dictionary is the same object as the frame.f_globals dictionary you are at module level. If not, you are in a nested scope.You'll have to generate some kind of scope key however; you may get away with storing something in f_locals (which won't actually affect the actual locals). Just remember that locals (as well as the frame) are cleared when a function exits. I'd return a special callable instead, one that is mutable, so you can refer to it on subsequent decorator calls. You'd be able to retrieve that object with frame.f_locals[decorated_function.__name__], for example.See the inspect module documenation for an overview of what attributes you can expect to find on a frame object.Demo:As such, you could use a function attribute on the returned wrapper function to store your functions:and it'll work in any scope:


Answer URL
https://docs.python.org/3/reference/datamodel.html#customizing-class-creation
https://docs.python.org/3/library/sys.html#sys._getframe
https://docs.python.org/3/library/inspect.html#types-and-members
