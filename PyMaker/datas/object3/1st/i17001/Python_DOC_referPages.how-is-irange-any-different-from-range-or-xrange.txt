Natural Text
I was going through Python Generators Wiki when I came across this RangeGenerator page which talks about irange()  -This will let us iterator over large spans of numbers without  resorting to xrange, which is a lazy list as opposed to a generator.I can't seem to understand the test suite and the implementation described on that page. I know that range() creates a list in the memory (from Python 2.7 point of view) and xrange() is a generator. How is irange() any different?
irange() returns a generator type, which can only be iterated over. Nothing else. Once you iterated over it, the generator is exhausted and can not be iterated over again.The Python 2 xrange() type and Python 3 range() type are sequence types, they support various operations that other sequences support as well, such as reporting on their length, test for containment, and indexing:You can iterate over these objects more than once:You can even use the reversed() function to iterate over them in reverse, efficiently:The Python 3 range() type is an improved version of xrange(), in that it supports more sequence operations, is more efficient still, and can handle values beyond sys.maxint (what would be a long integer in Python 2).It supports slicing, for example, which results in a new range() object for the sliced values:You can use negative indices just like you can with other Python sequences, to get elements counting from the end:and the type supports testing for equality; two range() instances are equal if they'd yield the same values:In Python 2, the only advantage the generator irange() might have is that it doesn't suffer from the limitation to non-long integers that xrange() is subjected to:
irange provides an generator which does not loads entire result into memory. Say you have range(1, 1000000) in case a list of 1000000 numbers would be loaded into memory, whereas in case of xrange(1, 1000000), just one number would be in memory at a time.


Answer URL
https://docs.python.org/3/library/stdtypes.html#ranges
