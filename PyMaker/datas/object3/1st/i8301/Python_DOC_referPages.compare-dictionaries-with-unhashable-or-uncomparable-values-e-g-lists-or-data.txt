Natural Text
TL;DR: How can you compare two python dictionaries if some of them have values which are unhashable/mutable (e.g. lists or pandas Dataframes)?I have to compare dictionary pairs for equality. In that sense, this question is similar to these two, but their solutions only seem to work for immutable objects...Is there a better way to compare dictionary valuesComparing two dictionaries in PythonMy problem, is that I'm dealing with pairs of highly nested dictionaries where the unhashable objects could be found in different places depending on which pair of dictionaries I'm comparing. My thinking is that I'll need to iterate across the deapest values contained in the dictionary and can't just rely on the dict.iteritems() which only unrolls the highest key-value pairs. I'm not sure how iterate across all the possible key-value pairs contained in the dictionary and compare them either using sets/== for the hashable objects and in the cases of pandas dataframes, running df1.equals(df2). (Note for pandas dataframe, just running df1==df2 does a piecewise comparison and NA's are poorly handled. df1.equals(df2) gets around that does the trick.)So for example:At a minimum, and this would be pretty awesome already,  the solution would yield TRUE/FALSE as to whether their values are the same and would work for pandas dataframes.Moderately better: the solution would point out what key/values would be different across the dictionaries.In the ideal case: the solution could separate the values into 4 groupings:added, removed,modifiedsame
Well, there's a way to make any type comparable: Simply wrap it in a class that compares like you need it:So when you wrap your "uncomparable" values you can now simply use ==:Of course wrapping your values has it's disadvantages but if you only need to compare them that would be a very easy approach. All that may be needed is a recursive wrapping before doing the comparison and a recursive unwrapping afterwards:Sample case:If you feel really adventurous you could use wrapper classes that depending on the comparison result modify some variable that holds the information what wasn't equal.This part of the answer was based on the original question that didn't include nestings:You can seperate the unhashable values from the hashable values and do a set-comparison for the hashable values and a "order-independant" list-comparison for the unhashables:It got a bit longer than expected. For your test-cases it definetly works:The set-operations can also be used to find differences (see set.difference). It's a bit more complicated with the lists, but not really impossible. One could add the items where no match was found to a seperate list instead of instantly returning False.


Answer URL
https://docs.python.org/3/library/stdtypes.html#set.difference
