Natural Text
I recently came across a syntax I never seen before when I learned python nor in most tutorials, the .. notation, it looks something like this:I figured it was exactly the same as (except it's longer, of course):But my questions are: How can it do that?  What does it actually mean with the two dots? How can you use it in a more complex statement (if possible)? This will probably save me many lines of code in the future...:)
What you have is a float literal without the trailing zero, which you then access the __truediv__ method of.  It's not an operator in itself; the first dot is part of the float value, and the second is the dot operator to access the objects properties and methods.You can reach the same point by doing the following.Another exampleHere we add 1.0 to 2.0, which obviously yields 3.0.
The question is already sufficiently answered (i.e. @Paul Rooneys answer) but it's also possible to verify the correctness of these answers.Let me recap the existing answers: The .. is not a single syntax element!You can check how the source code is "tokenized". These tokens represent how the code is interpreted:So the string 1. is interpreted as number, the second . is an OP (an operator, in this case the "get attribute" operator) and the __truediv__ is the method name. So this is just accessing the __truediv__ method of the float 1.0.Another way of viewing the generated bytecode is to disassemble it. This actually shows the instructions that are performed when some code is executed:Which basically says the same. It loads the attribute __truediv__ of the constant 1.0.Regarding your questionAnd how can you use it in a more complex statement (if possible)?Even though it's possible you should never write code like that, simply because it's unclear what the code is doing. So please don't use it in more complex statements. I would even go so far that you shouldn't use it in so "simple" statements, at least you should use parenthesis to separate the instructions:this would be definetly more readable - but something along the lines of:would be even better!The approach using partial also preserves python's data model (the 1..__truediv__ approach does not!) which can be demonstrated by this little snippet:This is because 1. / (1+2j) is not evaluated by float.__truediv__ but with complex.__rtruediv__ - operator.truediv makes sure the reverse operation is called when the normal operation returns NotImplemented but you don't have these fallbacks when you operate on __truediv__ directly. This loss of "expected behaviour" is the main reason why you (normally) shouldn't use magic methods directly.
Two dots together may be a little awkward at first:But it is the same as writing:Because float literals can be written in three forms:
What is f = 1..__truediv__?f is a bound special method on a float with a value of one. Specifically,in Python 3, invokes:Evidence:and:If we do:We retain a name bound to that bound methodIf we were doing that dotted lookup in a tight loop, this could save a little time.Parsing the Abstract Syntax Tree (AST)We can see that parsing the AST for the expression tells us that we are getting the __truediv__ attribute on the floating point number, 1.0:You could get the same resulting function from:OrDeductionWe can also get there by deduction.Let's build it up.1 by itself is an int:1 with a period after it is a float:The next dot by itself would be a SyntaxError, but it begins a dotted lookup on the instance of the float:No one else has mentioned this - This is now a "bound method" on the float, 1.0:We could accomplish the same function much more readably:PerformanceThe downside of the divide_one_by function is that it requires another Python stack frame, making it somewhat slower than the bound method:Of course, if you can just use plain literals, that's even faster:


Answer URL
https://docs.python.org/3/library/dis.html
https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types
