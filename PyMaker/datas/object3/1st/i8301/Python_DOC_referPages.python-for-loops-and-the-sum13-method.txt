Natural Text
I'm a native C++ programmer who is just beginning to learn python and I've been given the following method to write:Return the sum of the numbers in the array, returning 0 for an empty array. Except the number 13 is very unlucky, so it does not count and numbers that come immediately after a 13 also do not count.My solution is:Those who are familiar with other C-based languages would find the loop here analogous to the (quite cleaner)Please note that I began learning Python only a few days ago so I'm still very new to the language. I'm hoping someone can offer some advice on how to write this loop the "Python" way or perhaps offer a cleaner solution using some language features I may be unaware of. In my previous attempt (which did not work) I had:
How about a comprehension with sum and zip:Code:Results:How does this work?Working from the inside out we start with zip.  zip takes multiple iterables, and returns the first element of each iterable on the first iteration, and then the second element of each on the second iteration, etc.So we want to evaluate the current element of data, plus the previous element, so we pass data, and data offset by one element by padding data at the front (in this case a 0)These two lists are expanded, one element at a time, in to i, j.  Then, as a comprehension, we return i if 13 is not in either of i, j.  The comprehension is then evaluated by sum, which oddly enough sums all of the elements returned.
You could do this in a normal for loop:
Just trying to think outside the (explicit) loop...If the eval(...) bothers you, substitute sum(map(int, (...).split('+'))) instead.
You can use the same idea as the while loop and save some bookkeeping with code like the following (I've revised it to handle multiple 13's in a row):This one-liner should also work fine:The next one is fairly pedestrian and a little confusing, but workable (only left here because you commented on it):Or, finally a nice, simple, explicit version:
Below is a solution that I believe to be in the Python idiom, in a script. I added some test data.Why the for loop in the question doesn't workModifying the index in a for loop in C or C++  is kind of OK because C in effect rewrites this:as this:Python doesn't do that. Python code like for INDEX in LIST takes a value from LIST every iteration and assigns it to INDEX. So modifying INDEX within the loop has no effect as soon as the top of the loop is reached. (A detail point is the LIST doesn't have to be a list; it can be something that produces a list, like an iterator or a generator.)Solution using zipTOTH @stephen-rauch for the zip solution, to which I made a couple of changes.[0] + data creates a whole list on the fly, which would consume memory. In the code below, it's replaced with a generator.i for i, j in ... if 13 not in (i, j) unpacks the two-tuple returned by the zip, then repacks it into a two-tuple for the in test. In the code below, the whole tuple is assigned and in-tested without unpacking, then the first element is extracted at the outside of the list comprehension.Code ExtractI wrote a script with five solutions, including one that shows the same bug as the loop in the question. The zip solution is the best, so I omitted the others from the answer.OutputHappy coding!


Answer URL
https://docs.python.org/3/tutorial/controlflow.html
