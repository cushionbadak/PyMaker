Natural Text
Is there a simple way to determine if a variable is a list, dictionary, or something else? I am getting an object back that may be either type and I need to be able to tell the difference.
To get the type of an object, you can use the built-in type() function. Passing an object as the only parameter will return the type object of that object:This of course also works for custom types:Note that type() will only return the immediate type of the object, but won’t be able to tell you about type inheritance.To cover that, you should use the isinstance function. This of course also works for built-in types:isinstance() is usually the preferred way to ensure the type of an object because it will also accept derived types. So unless you actually need the type object (for whatever reason), using isinstance() is preferred over type().The second parameter of isinstance() also accepts a tuple of types, so it’s possible to check for multiple types at once. isinstance will then return true, if the object is of any of those types:
You can do that using type():
It might be more Pythonic to use a try...except block. That way, if you have a class which quacks like a list, or quacks like a dict, it will behave properly regardless of what its type really is.To clarify, the preferred method of "telling the difference" between variable types is with something called duck typing: as long as the methods (and return types) that a variable responds to are what your subroutine expects, treat it like what you expect it to be. For example, if you have a class that overloads the bracket operators with getattr and setattr, but uses some funny internal scheme, it would be appropriate for it to behave as a dictionary if that's what it's trying to emulate.The other problem with the type(A) is type(B) checking is that if A is a subclass of B, it evaluates to false when, programmatically, you would hope it would be true. If an object is a subclass of a list, it should work like a list: checking the type as presented in the other answer will prevent this. (isinstance will work, however).
On instances of object you also have the:attribute. Here is a sample taken from Python 3.3 consoleBeware that in python 3.x and in New-Style classes (aviable optionally from Python 2.6) class and type have been merged and this can sometime lead to unexpected results. Mainly for this reason my favorite way of testing types/classes is to the isinstance built in function.
Determine the type of a Python objectDetermine the type of an object with typeAlthough it works, avoid double underscore attributes like __class__ - they're not semantically public, and, while perhaps not in this case, the builtin functions usually have better behavior.type checkingIs there a simple way to determine if a variable is a list, dictionary, or something else? I am getting an object back that may be either type and I need to be able to tell the difference.Well that's a different question, don't use type - use isinstance:This covers the case where your user might be doing something clever or sensible by subclassing str - according to the principle of Liskov Substitution, you want to be able to use subclass instances without breaking your code - and isinstance supports this. Use AbstractionsEven better, you might look for a specific Abstract Base Class from collections or numbers:Or Just Don't explicitly Type-checkOr, perhaps best of all, use duck-typing, and don't explicitly type-check your code. Duck-typing supports Liskov Substitution with more elegance and less verbosity. ConclusionUse type to actually get an instance's class. Use isinstance to explicitly check for actual subclasses or registered abstractions. And just avoid type-checking where it makes sense.
You can use type() or isinstance().Be warned that you can clobber list or any other type by assigning a variable in the current scope of the same name.Above we see that dict gets reassigned to a string, therefore the test:...fails.To get around this and use type() more cautiously:
While the questions is pretty old, I stumbled across this while finding out a proper way myself, and I think it still needs clarifying, at least for Python 2.x (did not check on Python 3, but since the issue arises with classic classes which are gone on such version, it probably doesn't matter).Here I'm trying to answer the title's question: how can I determine the type of an arbitrary object? Other suggestions about using or not using isinstance are fine in many comments and answers, but I'm not addressing those concerns.The main issue with the type() approach is that it doesn't work properly with old-style instances:Executing this snippet would yield:Which, I argue, is not what most people would expect.The __class__ approach is the most close to correctness, but it won't work in one crucial case: when the passed-in object is an old-style class (not an instance!), since those objects lack such attribute.This is the smallest snippet of code I could think of that satisfies such legitimate question in a consistent fashion:
As an aside to the previous answers, it's worth mentioning the existence of collections.abc which contains several abstract base classes (ABCs) that complement duck-typing.For example, instead of explicitly checking if something is a list with: you could, if you're only interested in seeing if the object you have allows getting items, use collections.abc.Sequence:if you're strictly interested in objects that allow getting, setting and deleting items (i.e mutable sequences), you'd opt for collections.abc.MutableSequence.Many other ABCs are defined there, Mapping for objects that can be used as maps, Iterable, Callable, et cetera. A full list of all these can be seen in the documentation for collections.abc.
be careful using isinstance but type


Answer URL
https://docs.python.org/3/library/collections.abc.html
https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence
https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes
