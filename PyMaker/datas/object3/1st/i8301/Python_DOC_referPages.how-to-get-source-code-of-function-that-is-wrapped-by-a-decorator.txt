Natural Text
I wanted to print the source code for my_func, that is wrapped by my_decorator:However, it returns source for wrapper instead:Is there a way for it to print the following instead?Note that the above is abstracted from a larger program. Of course we can just get rid of the decorator in this example, but that's not what I am looking for. 
In Python 2, the @functools.wraps() decorator does not set the convenience __wrapped__ attribute that the Python 3 version adds (new in Python 3.2).This means you'll have to resort to extracting the original function from the closure. Exactly at what location will depend on the exact decorator implementation, but picking the first function object should be a good generalisation:Usage:Demo using your sample:Another option is to update the functools library to add a __wrapped__ attribute for you, the same way Python 3 does:Run that code before importing the decorator you want to see affected (so they end up using the new version of functools.update_wrapper()). You'll have to manually unwrap still (the Python 2 inspect module doesn't go looking for the attribute); here's a simple helper function do that:This will unwrap any level of decorator wrapping. Or use a copy of the inspect.unwrap() implementation from Python 3, which includes checking for accidental circular references.
As Martijn Pieters points out in his answer, the Python 2 @functool.wraps() decorator doesn't define a __wrapped__ attribute, which would make doing what you want to do very easy. According to the documentation I read, even though it was added in Python 3.2, there was a bug in the ways it was sometimes handled until version 3.4 was releasedâ€”so the code below uses v3.4 as the cut-off for defining a custom wraps() decorator.Since from its name it sounds like you have control over my_decorator(), you can workaround the issue by defining you're own wraps-like function, rather than extracting the original function from the closure, as shown in his answer. Here's how to do it (which works in Python 2 and 3):(As Martijn also points out, you could monkey-patch the change in by overwriting the functools.wraps module attribute, which would make the change also affect other modules that use functools instead of only the one where it's defined.)Output:


Answer URL
https://docs.python.org/3/library/functools.html#functools.wraps
https://docs.python.org/3/library/functools.html?highlight=__wrapped__#functools.update_wrapper
