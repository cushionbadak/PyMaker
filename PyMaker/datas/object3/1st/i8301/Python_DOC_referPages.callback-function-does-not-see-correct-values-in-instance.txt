Natural Text
I'm having a strange phenomena in Python with callback functions and handlers. I use ZMQ to handle my communication and use a stream for the socket. I have the base class:And I have a class that inherits from it:Additionally, I have a class that I want to use as storage. And here is where the trouble starts:The idea is that that class stores some global information that it receives. It is all started in a file to test:I simplified it to reduce clutter. Instead of just adding it, it is usually send and then a response comes back. The response, the client sending, should be processed by the correct callback, remove(), and it should remove something out of the list. The problem that occurs is, that the remove() function sees an empty list, although there should be an element in the list. If I check from the testing file, I can see the element after it was added, and if I call remove() from there, I see a non-empty list and can remove it. My question is, why does the callback sees an empty list and how can I make sure it does see the correct elements in the list?Kind regardsPatrick
I believe the problem lays in the fact that the ZmqProcess class inherits from multiprocessing.Process. Multiprocessing does not allow to share objects among different processes, except by using a shared memory map using Value or Array ( as can be seen in the documentation: https://docs.python.org/3/library/multiprocessing.html#sharing-state-between-processes )If you want to use your custom object, you can use a Server process / proxy object, which can be found in on the same page of the documentation. So you can, for instance, define a manager in the init function of the Storage class like:  self.manager = Manager() Afterwards you put self.list = self.manager.list(). This should do the trick.


Answer URL
https://docs.python.org/3/library/multiprocessing.html#sharing-state-between-processes
