Natural Text
This works almost fine but the number starts with 0 sometimes:I've found a lot of examples but none of them guarantee that the sequence won't start with 0.
We generate the first digit in the 1 - 9 range, then take the next 3 from the remaining digits:The generated numbers are equiprobable, and we get a valid number in one step.
Just loop until you have something you like:
This is very similar to the other answers but instead of sample or shuffle you could draw a random integer in the range 1000-9999 until you get one that contains only unique digits:As @Claudio pointed out in the comments the range actually only needs to be 1023 - 9876 because the values outside that range contain duplicate digits.Generally random.randint will be much faster than random.shuffle or random.choice so even if it's more likely one needs to draw multiple times (as pointed out by @karakfa) it's up to 3 times faster than any shuffle, choice approach that also needs to join the single digits.
I do not know Python well, but something likeA more useful iteration, actually creating a number:After stealing pieces from other solutions, plus applying the tip from @DavidHammen:
[Fixed] Shift all four digits on one position is not right. Swap leading zero with fixed position is not right too. But random swap of the leading zero with any of nine positions is correct and gives equal probability:
rejection sampling method.  Create a 4 digit random combination from 10 digits and resample if it doesn't match the criteria.noticed that this is essentially the same as @Austin Haskings's answer
You could use full range for 3 numbers, then choose the leading number among the remaining numbers:Another way if the choice needs to be repeated (and if you remain reasonable on the number of digits), is to pre-compute the list of the possible outputs using itertools.permutations, filtering out the ones with a leading zero, and building a list of integers from it:That's some computation time, but after than you can call:as many times you want. It's very fast and provides an evenly distributed random.
I don't know Python so I will post a pseudo-code-ish solution for this specific problem:Create a lookup variable containing a 0-based list of digits:Generate four 0-based random numbers as follows:Use the lookup variable to convert random numbers to digits one-by-one. After each lookup, mutate the lookup variable by removing the digit that has been used:Print the result:It is possible to generalize this idea a little. For example you can create a function that accepts a list (of digits) and a number (desired length of result); the function will return the number and mutate the list by removing used-up digits. Below is a JavaScript implementation of this solution:
Here's how I'd do itMore generally, given a generator, you can use the built-ins filter and next to take the first element that satisfies some test function.
Combine generators with nextA Pythonic way to write would be to use 2 nested generators and next:It's basically a one-liner variant of @MSeifert's answerPreprocess all the acceptable numbersIf you need many random numbers, you could invest some time and memory for preprocessing all the acceptable numbers:1023 and 9877 are used as boundaries because no int lower than 1023 or greater than 9876 can have 4 unique, distince numbers.Then, you'd just need random.choice for a very fast generation:
Disclaimer: this is a terrible anti-Python approach, strictly for the benchmarking part (see @DavidHammen's comments around, and http://ideone.com/qyopLF)The idea is to generate the sequence numbers of the digits in one step, and then fix any collisions:Now we have d1=0..8, d2=0..8, d3=0..7, d4=0..6, it can be tested via running the snippet with rnd=4535 (4535=9*9*8*7-1, by the way)First, d1 has to be patched upThen d2 has to "skip" d1 if necessaryThen the same has to be done with the remaining digits, getting ugly fast:And the final part is the catastrophic one:For longer numbers, it might work faster with bitfields, but I do not see a trivial way.(Checking the >= relations once is not enough, because the collision can easily occur after doing an incrementation.e.g. d1=1, d2=2, d3=1: d3 collides with d1, but it does not collide with d2 initially. However after "puching the hole" at 1, d3 becomes 2 and now it collides with d2. There is no trivial way to spot this collision in advance)As the code stinks as hell, I put a verification step at the endIt is already faster than the other really fast code (the commented verification displayed the original digits preserved after the divmod-s, for debugging purposes. This is not the kind of code which works immediately...). Commenting both verifications makes it even faster.EDIT: about checking this and thatThis is an approach maintaining an 1:1 relation between the minimal set of valid inputs (0...4535) and valid outputs (the 9*9*8*7 possible 4-digit numbers with distinct digits, not-starting-with-0). So a simple loop can and should generate all the numbers, they can be checked one-by-one and they can be collected into a set for example in order to see if they are all distinct resultsPractically:1) It will not print anything in the loop (all results are 4-digit numbers with distinct digits)2) It will print 4536 at the end (all results are distinct)One can add a verification for the first digit (d1), here and now I just assume that"(something mod 9)+1" will not be 0.
This will allow zeros after the first digit - 


Answer URL
https://docs.python.org/3/library/functions.html#filter
https://docs.python.org/3/library/functions.html#next
