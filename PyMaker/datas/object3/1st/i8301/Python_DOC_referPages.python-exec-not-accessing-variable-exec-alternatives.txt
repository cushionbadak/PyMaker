Natural Text
I am writing a command line calculator. I have all the math down but I want to add my own functions, like solve("x^3 = 8", x). My math works fine but the way I'm using exec() is preventing it from writing the result to the local variable finalAnswer.I included foo() to show what I wantOn execution my output is:The first three lines of the output tell me that every part of the script executes, but finalAnswer isn't getting initialized. Have I missed some nuance of using exec().Also, bonus points if you help me remove exec without changing the format of the string input calling a parameterized function and storing the returned value locally.
You may not need exec or eval here. If your expressions are all simple, like in your example code, then we can get away with using ast.literal_eval which (as the name suggests) can evaluate strings that contain valid Python literals. This makes it far safer than plain eval or exec. Of course, your code only attempts to execute approved functions, so it should be safe, but still...Anyway, here's a solution. We store the approved functions in a dict, keyed by the function name. And we pretend that the string containing the function argument list is a tuple, and get literal_eval to build that tuple for us, so we can pass the args to the function using * sequence unpacking.outputThis is safe because ast.literal_eval is very strict about what it'll accept in a string. From the docs:Safely evaluate an expression node or a string containing a Python  literal or container display. The string or node provided may only  consist of the following Python literal structures: strings, bytes,  numbers, tuples, lists, dicts, sets, booleans, and None.A container display is a list, tuple, set, or dict literal, eg (2,3,4) or {'one':1, 'two': 2}. If you try to pass ast.literal_eval something containing a function call or even an arithmetic expression, egorit will raise ValueError: malformed node or stringThere's a minor exception to this. ast.literal_eval will accept arithmetic expressions that only use + or -. That's because it needs to be able to evaluate complex number literals, and those literals contain + or -. The implementers decided that the easy way to handle that is to simply allow .literal_eval to evaluate arithmetic expressions containing + or -; doing so doesn't create a security risk. That only applies to arithmetic expressions though, you cannot do string concatenation with +, sowill raise ValueError; OTOH, it does accept the usual automatic concatenation of adjacent string literals, so this is ok:



Answer URL
https://docs.python.org/3/library/ast.html#ast.literal_eval
