Natural Text
I have an expression/formula like thisI have done some research and it seems that if A,B,C values are known, by embedding Lua or Python in a C++ program, there are eval functions that can substitute A,B and C and return true or false.But what happens when I don't know all the values? Let's say that A is known and it is -1. If A is -1 then the formula will evaluate to "false" irrespective of the values of B or C. Can I evaluate a formula without knowing all the variables in advance? For example if A is 10, it makes sense to lookup for the value of B and re-evaluate again. How can we solve these problems? Ideas?
It sounds like you have two challenges: It is expensive to calculate some variable values, so you want to avoid calculating values that aren't needed to evaluate the expression; andYour expression exists as a string, composed at runtime, so you can't use C++'s built-in short-circuiting logic.This means you need some way to evaluate an expression at runtime, and you would like to take advantage of short-circuit logic if possible. Python could be a good choice for this, as shown in the example below.There is a short Python script (evaluate.py), which defines an evaluate() function which can be called from your C or C++ program. The evaluate() function will attempt to evaluate the expression you give it (translating "&&" and "||" to "and" and "or" if needed). If it requires a variable which hasn't been defined yet, it will retrieve a value for that variable by calling a get_var_value() function defined in the C/C++ program (and then cache the value for later use). This approach will use normal short-circuit behavior, so it will only request the variable values needed to finish evaluating the expression. Note that this won't rearrange the expression to choose the minimal set of variables needed to evaluate it; it just uses the standard short-circuiting behavior.UPDATE: I've added an example at the end that defines the Python script using a multiline string literal in the .cpp file. This could be useful if you don't want to install a separate evaluate.py file along with your executable. It also simplifies the Python initialization a little bit.The C/Python interaction in the scripts below is based on code in https://docs.python.org/2/extending/embedding.html and https://docs.python.org/2/c-api/arg.html. Here are the files:evaluate.py (Python script)evaluate.c (your main program; could also be evaluate.cpp, compiled with g++)Results:As an alternative, you can combine all this code into a single .cpp file, as shown below. This uses the multi-line string literal capability in C++11.Self-contained evaluate.cpp
I don't know of any existing available library for handling this.The usual approach would be to build an expression-tree and evaluate what is possible - similarly to constant folding in compilers:https://en.wikipedia.org/wiki/Constant_foldingOne of the important aspects for that is to know the allowed values for variables, and thus the allowed partial evaluations, e.g. x*0 (and 0*x) is 0 if x is an integer, or finite floating point number, but cannot be evaluated if x is an IEEE floating number (since it could be Nan or infinity), or if x could be matrix since [1,1]*0 is [0,0] not the scalar 0.
One way is to parse the expression into a tree and evaluate the tree. Subexpressions for which all variables are known will be fully evaluated. The effect will be to simplify the tree.In your example, the tree has && at the top with two subtrees, the left one being the tree for A>0. To evaluate the tree, we evaluate the left subtree, which returns -1, and so we don't need to evaluate the right subtree, because the operator is &&. The whole tree evaluates to false.
I don't understand exactly what you want to do or understand but I am OK with ivan_pozdeev about short-circuit evaluation and lazy evaluation. A boolean expression is evaluate from the left to the right and when the result is known the evaluation stop and ignore what is on the right.With Python:givesButgives the error "name 'B' is not defined".
So from what I understand of your question, you want something likeie your expression must be split up so that you are only ever working with known values.
You can do it like this:More details later...
It seems to me that the answer is yes, yes you can try to evaluate the expression with missing information.  You will need to define what happens though when a symbol lookup fails.In you case, you will need a boolean expression evaluator and a symbol table so the evaluator can lookup the symbols to execute the expression.If you succeed in looking up all the symbols, the result would be true or false.  If you fail to look up a symbol, then handle that case, perhaps returning None, nullptr, or raising / throwing an exception.I believe you can embed the python interpreter in your c++ program and call a function to evaluate the expression, more importantly, you can give it the dict to use as the symbol table.  If the call returns a result, it was able to find enough symbols or shortcut to a result, otherwise it will raise an exception which your c++ code can detect.You can prototype the function in python the evaluate if the approach works they way you want, then embed.Or you can do it all in c++, with a grammar, lexer, parser, and elevator.
While this is a very crude implementation of your solution, but it suits your situation perfectly although using a lot of if else and Exception Handling.Now explaining my code, main_func returns another function which is used to evaluate the given expression in a string. While here the string has been hardcoded, you can always pass it as a parameter to the function and replace the string inside eval with the parameter.In doer, the function returned by main_func is invoked and if a NameError is thrown, which happens in case of the previous conditions being false and new values to be calculated then it returns the specific variable which needs to be calculated. All of that is checked in the actual_evaluator where the values of the variables are fetched via some function get_variable_name which you can define in your getter dict. In my code, I'd used random numbers to check the validity, but like you said you'd have to evaluate the various variables by other means so you can call the respective functions.
Due to the short-circuit behaviour, Python can evaluate an expression even without all the contained values defined if it's possible. If not, it raises an exception:But the expression is evaluated left to right:
I have done a "roll-my-own" approach for this in the past.  It's not that difficult for simple things; you simply create your own objects that implement magic math methods and that keep track of other objects.If you need something more full-featured, the sympy project is designed to do symbolic math...
I'd take a look at sympy or other computer algebra systems.  I believe that algebraic simplification of the pxeression plus short circuit evaluation will allow you to evaluate all the cases where it is possible to get a result.  There are some cases where you need to know the value of some variable.  For example if you have a simple expression like a == b, you are going to make no progress without knowing the value of a  and b.  However something like (a >= 0) ||(a <= 0), algebraic simplification will result in true assuming that a is not NAN or some other value that is not equal to itself.
I am assuming from this question that you have a logical expression that depends on the result of various functions; you use the values of some of those functions more than once (possibly before evaluating this expression, or possibly within this expression), so you want to store their results to avoid calling them twice; and you would like to evaluate the logical expression, and along the way you would like to retrieve and store values for functions that haven't previously been run, but only enough of them to evaluate the expression (using normal short-circuit behavior).I mentioned in a different answer that you might do best just to use the built-in short-circuit behavior in C++. To do that and achieve objective 2, you would need to use functions instead of variables in the logical expression. That way you can trigger the calculation of a missing value when the expression needs it. Below are two approaches to doing that. The first one wraps your slow functions with a general-purpose caching wrapper. The second defines a custom, caching helper for each of your slow functions. After compiling, either of these should be called with your A, B and C values for testing, e.g. evaluate_cached 10 9 -1. They will both behave the way you want.evaluate_cached.cppevaluate_helpers.c


Answer URL
https://docs.python.org/3/library/stdtypes.html#boolean-operations-and-or-not
