Natural Text
I want to define constants, e.g. A = 10; B = 20, with these properties:'Normal' access: e.g. A.value + B.value == 30 (or even A + B == 30)Allow duplicate values: e.g. A = 10; B = 10Associated string for each variable: e.g. A.name == "A"Listing: e.g. [v.name for v in CONSTANTS]IDE support: auto-complete names, re-factorizations, etc.Adding a new constant requires one changeImportable: e.g. from config import CONSTANTSIn the end, the property #6 is the problem. Something likewould basically be the solution. But I would like to avoid this verbose code (if possible).This attempt comes very close:but fails when two constants have the same value (property #2). One could also define a sub-class of Enum with a constructor taking value. But again, A = 10; B = 10 would be mapped to the same instance, even though the name differs. One could now also add a name (or any other unused, but distinctive parameter to the constructor) to make this problem go away. But I would consider this approach unclean. For instance, A = ("A", 10); B = ("B", 10); def __init__(self, _, value): ....
You can make the CONSTANTS dict thing less verbose by using globals() to copy the dict contents into global variables:
Have you considered using the namedtuple collection?They meet your "Normal Access" by field....They won't complain when multiple IntConst have the same value...They will give an associated string ...They will allow listing ...Your IDE probably already has support for namedtuple. Adding more constants simply requires you to create an instance of the IntConst namedtuple. As for importing, you'd simply create a list of those IntConst values in your namespace and they'd become valid targets for the import statement.The only thing they don't give that you requested is the ability to duck type an integer value out of them. Instead, you'll get a tuple containing both IntConst instances.
Disclaimer: Accessing a hidden attribute is discouraged and should thus not be considered a 'clean' solution!The standard Enum module can be tweaked to provide the desired behavior.Padding the _value_ attribute with the name of the member, renders the alias lookup mechanism unable to find other members with the same value. The only drawback is that the value attribute of the produced members all refer to their internal _value_ attribute. In fact, value is defined as a DynamicClassAttribute. Hence, without further modifications we face: Const1.A.value == ('A', 42).If desired, a property can be used to overwrite this behavior.


Answer URL
https://docs.python.org/3/library/types.html#types.DynamicClassAttribute
