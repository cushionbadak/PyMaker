Natural Text
I am trying to write code for a super-fast factorial function. I have experimented a little and have come up with the following three candidates (apart from math.factorial):I have timed these functions. These are the results:Clearly, f3() takes the cake. I have tried implementing this. To be verbose, I have tried writing code that generates a string like this:"1*2*3*4*5*6*7*8*9*10*11*12*13*14........" and then using eval to evaluate this string. (Acknowledging that 'eval' is evil). However, this method gave me no gains in time, AT ALL. In fact, it took me nearly 150 microseconds to finish.Please advise on how to generalize f3().
f3 is only fast because it isn't actually computing anything when you call it. The whole computation gets optimized out at compile time and replaced with the final value, so all you're timing is function call overhead.This is particularly obvious if we disassemble the function with the dis module:It is impossible to generalize this speedup to a function that takes an argument and returns its factorial.
f3() takes the cake because when the function is def'ed Python just optimizes the string of multiplications down to the final result and effective definition of f3() becomes:which, because no computation need occur when the function is called, runs really fast!One way to produce all the effect of placing a * operator between the list of numbers is to use reduce from the functools module.  Is this sometime like what you're looking for?
I would argue that none of these are good factorial functions, since none take a parameter to the function. The reason why the last one works well is because it minimizes the number of interpreter steps, but that's still not a good answer: all of them have the same complexity (linear with the size of the value). We can do better: O(1).This scales constantly with the input value, at the sacrifice of some accuracy. Still, way better when performance matters.We can do a quick benchmark:A 30 fold increase for a factorial of 50. Not bad.https://docs.scipy.org/doc/scipy-0.19.0/reference/generated/scipy.misc.factorial.html
As others have stated f3() isn't actually computing anything that's why you get such fast results. You can't achieve the same by giving it to a function.Also you maybe wondering why math.factorial() is so fast it's becausethe math module's functions are implemented in C:This module is always available. It provides access to the mathematical functions defined by the C standardBy using an efficient algorithm in C, you get such fast results.Here your best bet would be would using the below function, but using math.factorial is what I prefer if you're purely in need of performance


Answer URL
https://docs.python.org/3/library/math.html
