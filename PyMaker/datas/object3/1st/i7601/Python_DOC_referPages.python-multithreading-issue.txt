Natural Text
Code:run function:I am trying to read from fifo file and storing data into a dictionary.This run function will execute almost infinitely.get_packet or len_dict function:I am trying to get the details of the dictionary but unable to do so.My doubt is when run function is storing data from fifo file to dictinary, while suppose will go on infinitely, using get_packet or len_dict i want to access this dictionary data structure, but unable to access itI am new to threading, so any other approach is also appreciated.
I think the problem might be that you did not figure out how multiple threads work. After calling fb.start(), two threads(the main thread and the run() thread which read from fifo file and store data into a dictionary) work concurrently. The KeyError you got while calling print "get_packet(2): " + fb.get_packet(2) is because when the main thread called get_packet(2), the run() thread has not append data into the dictionary yet.  so only after calling the join() , the dictionary data can be accessed ?? Not exactly. Please continue reading.Is their any way to access the dictionary while the run() thread is executing infinitely ? You could process/access the dictionary in run() thread while run() thread is executing, but obviously this dictionary changes over time, and you could only access the lines that run() thread has already processed. You could also process/access the dictionary in main thread while run() thread is executing, but as I said before, the run() thread might have not appended data into the dictionary(you could only access the lines that run() thread has already processed as well). I have tested the code, added a new method and made some modifications. It worked well. The modified code is as follows.
As I stated in one of my comments, this example (especially the main function) does not make much sense from the multithreading's PoV. Here's the code "slightly"  modified:Now, the main thread can be seen interacting with the inner(FifoBufferThread) thread.Changes:main function is now a loop (after starting the fbt thread) to better illustrate what the thread is doing in the background (and how fbt is affecting the main thread). It involves user interaction (a key needs to be hit), if that key is lower-case x, the program will exit.Important note: while the program waits for user input, the inner thread will continue doing its work, so it will read lines from the file!!! Important one !!!: fbt.daemon = True: the thread is marked as daemonic. As [Python]: Thread objects states:A thread can be flagged as a “daemon thread”. The significance of this flag is that the entire Python program exits when only daemon threads are left.get_packet: I modified it to use [Python]: dict.get (and return None instead of raising an exception and terminating the program)Added get_dict_len function (which is now used by len_dict). It's good to get data, and only then, format it for printing purposesI'm not sure of the reading rate from the file, or the other program's rate in terms of writing to it, nor to its initial content, but one of the following will happen (assuming that once the file is open for reading, it will "update" its contents as other processes write to it):Your app, will "eat" everything that's in the file and eventually reach EOF, and the the thread will stop (normal case)The other app that reads from TCP, will write fast enough (not very probable) so that your app that reads the file contents (and stores it in the dict: IN MEMORY) will eventually run out of memory2.1. A flavor: RAM won't run out, but disk (/media) willNote: there are more things that could get improved as well


Answer URL
https://docs.python.org/3/library/threading.html#thread-objects
https://docs.python.org/3/library/stdtypes.html#dict.get
https://docs.python.org/3/library/threading.html#threading.Thread.join
