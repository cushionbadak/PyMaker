Natural Text
Iâ€™m using Python 3.6.1, mypy, and the typing module. I created two custom types, Foo and Bar, and then used them in a dict I return from a function. The dict is described as mapping str to a Union of Foo and Bar. Then I want to use values from this dict in a function that names only one argument each:I tried using the values as-is:Or using the types:How do I cast the Union to one of its subtypes?
You'd have to use cast():From the Casts section of PEP 484:Occasionally the type checker may need a different kind of hint: the programmer may know that an expression is of a more constrained type than a type checker may be able to infer.There is no way to spell what specific types of value go with what specific value of a dictionary key. You may want to consider returning a named tuple instead, which can be typed per key:Now the type hinter knows exactly what each attribute type is:
Although I think casts are probably the right option to use in your case, I just briefly want to mention one additional option which might be applicable in similar scenarios, to round things out:It's actually possible to type your dict more precisely using the new, experimental TypedDict feature, which is available latest versions of mypy (if you clone from the github repo) and will likely be available in the next pypi release.In order to use TypedDict, you'll need to install the mypy_extensions from pypi by running pip install mypy_extensions.TypedDict lets you assign individual types to each item in your dict:You can also define FooBarData using a class-based syntax in Python 3.6+:You also mentioned that your dict can have a dynamic number of elements. If it genuinely is dynamic, then TypedDict won't help for the same reasons that NamedTuple won't help, but if your TypedDict will ultimately have a finite and number of elements, and you're just progressively adding items to it instead of all at once, you can try using non-total TypedDicts, or try constructing TypeDicts that mix required and non-required items.It's also worth noting that unlike pretty much every other type, TypedDicts are checked using structural typing, rather then nominal typing. This means that if you define a completely unrelated TypedDict named, say, QuxData that also has foo and bar fields with the same type as FooBarData, then QuxData will actually be a valid subtype of FooBarData. This may open up some interesting possibilities with a little bit of cleverness.


Answer URL
https://docs.python.org/3/library/typing.html#typing.cast
https://docs.python.org/3/library/typing.html#typing.NamedTuple
