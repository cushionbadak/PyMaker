Natural Text
Is there a way to make a user defined class that operates like int in that any equal instances have the same referent?E.g:But with a user defined class like this one: we have the following:
Is there a way to make a user defined class that operates like int in that any equal instances have the same referent?First of all, only a limited number of integers behave that way; small integers are interned for performance and memory efficiency reasons (see "is" operator behaves unexpectedly with integers).What you are asking for is how to ensure your own instances are interned, in that there is only ever one copy of an instance for a given 'value'. You can do that by controlling when a new instance is created, by implementing your own __new__ method:For a given letter and index combo, just one instance is created:This is essentially how integer interning works too.
Martijn Pieters' answer is as close as you're going to get to an answer useful for practical purposes (got my upvote), but I was interested in johnrsharpe's point about mutability. For instance, using Martijn's solution, the following fails:We want equal instances to always refer to the same object in memory. This is very tricky, requires some black magic, and should never ever ever be used in a real application, but is in some sense possible. So, if you're in it for the laughs, come along for the ride.My first thought was that we need to overload __setattr__ for Variable so that when an attribute changes, a new instance with the appropriate attribute values is created and all references (Footnote 1) to the original instance are updated to point to this new instance. This is possible with pyjack, but it turns out not to give us quite the right solution. If we do the following:and in the process of that last assignment update all references to the object referred to as a, then b will also end up with b.letter == 'y' since a and b (obviously) refer to the same instance.So, it's not a matter of updating all references to the Variable instance. It's a matter of updating the one reference we just changed. That is to say, for the namespace in which the attribute assignment was called, we need to update the locals to point to the new instance. This is not straightforward, but here is a method that works with all tests I could come up with. Note that this code does not have so much of a code smell as a full-on corpse-in-the-closet-for-three-days code reek about it. Again, do not use it for anything serious:So, basically what we do here is use dis to analyze the bytecode for the frame in which the assignment occurred (as reported by inspect). Using this, we extract the name of the variable referencing the MutableVariable instance undergoing attribute assignment, and update the locals dictionary for the corresponding namespace so that that variable references a new MutableVariable instance. None of this is a good idea.The code shown here is almost certainly implementation specific and may be the most fragile piece of code I've ever written, but it does work on standard CPython 3.5.2.Footnote 1: Note that here, I am not using reference in the formal (e.g. C++) sense (since Python is not pass by reference) but in the sense of a variable referring to a particular object in memory. i.e. in the sense of "reference counting" not "pointers vs. references."


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__new__
