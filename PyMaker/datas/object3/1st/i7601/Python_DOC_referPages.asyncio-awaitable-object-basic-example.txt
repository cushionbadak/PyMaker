Natural Text
I'm trying to understand how to make an awaitable object. The definition from the documentation states:An object with an __await__ method returning an iterator.Guided by that definition I wrote the sample code:The flow that I expected was:Event loop gives control to produce_list(). produce_list() gives up execution on num = await Customer().Customer() is executed and returns an iterator. Which because returns the first value in the iterator. Q1: am not clear here why num isn't becoming the iterator itself. Also what is doing a send here?
__await__ returns an iterator because the underlying mechanism for coroutines is originally based on the yield from syntax. In practice, __await__ returns either iter(some_future) or some_coroutine.__await__(). It can be used to create objects that produce different values every time they are awaited. See this simple example:  To answer your comments:Does every coroutine eventually ends up calling asyncio.sleep? No, and asyncio.sleep is actually not the end of the chain. At the very bottom, it's always a future that is being yielded: the coroutine chain asks the event loop "please wake me up when this future has a result". In the case of asyncio.sleep, it uses loop.call_later to set the result of the future after a given amount of time. The loop provides more methods for scheduling callbacks: loop.call_at, loop.add_reader, loop.add_writer, loop.add_signal_handler, etc. An asyncio library such as aiohttp. I'm assuming there is some code somewhere that doesn't rely on existence of previous coroutines.All the IO operations have to end up delegating to the event loop in order to achieve single-threaded concurrency.For instance, aiohttp relies on the loop.create_connection coroutine to manage the TCP connection.


Answer URL
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.create_connection
