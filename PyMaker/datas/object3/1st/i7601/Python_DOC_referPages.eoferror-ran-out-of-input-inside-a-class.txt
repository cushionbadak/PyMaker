Natural Text
I have the following code where I need to read multiple sensors at a time. I have set up threading and multiprocessing to do this task for me. When the threading and mutliprocessing code is outside of the main class, it works fine but the class can't use the data it retrives. When I put the mutlithreading code insdie the class, I run into an EOFError: Ran out of input error.Here is the code:With some debugging, the problem happens at proc.start() but proc has data. The lists have data too, which is why I am confused why it is running out of input. Note: in my code there are six entries in the gas_list
You cannot use multiprocessing like that (well, you can, but the result will be unpredictable) - when you create a new process your minimalmodbus.Instrument object from the list doesn't get passed as a reference but as a whole new object. Python essentially runs a completely new Python interpreter instance whenever you start() a multiprocess.Process instance and since different processes get different stacks they don't get to share the internal memory so Python actually pickles the passed arguments, sends them to the Process and then unpickles them there creating an illusion that both processes (the parent and the child) have the same data.You can observe it yourself if instead of creating a new multiprocessing.Process you call self.main_reader(pickle.loads(pickle.dumps(sen)), val) (val also gets pickled but as a generic it's not of any importance here).The very same process happens to the Application.main_reader() method (although weirdly defined), too - the way you have it set up is that your whole Application instance actually gets recreated in the sub-process so that Python can call its main_reader() method.  What you can do instead is to pass needed arguments to recreate your original object to the sub-process function, and then have your object created when your function starts. For example, if you modify your Application.all_process() method as:And then have your main_reader() function defined outside of the Application class as:It should stop throwing errors. Also, you've used threading.Lock in your original code - I don't know what you were trying achieve with it, but it most certainly doesn't do what you think it does.


Answer URL
https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue
https://docs.python.org/3/library/multiprocessing.html#multiprocessing.sharedctypes.multiprocessing.Manager
