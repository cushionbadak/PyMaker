Natural Text
Backgroud:Let's say I have a function (of course in reality that would be a more complex function):If I want to store values to avoid unnecessary recomputation, I can create a dict like this:But then if I don't know in advance which values I may need, for example 10,  my_dict[10] obviously generates a KeyError.One way around this could be:Question:This seems very similar to defaultdict: is there a way to make the intuitive (but broken) my_dict = defaultdict(f) work, i.e. when a key x doesn't exist, it should call f(x) instead of f() to create the default value?
you can build your own dict data type. in your case, __missing__ will help. if there is no key, __missing__ method triggers your custom work. below is a simple example.also note that UserDict is a wrapper around dictionary objects, making you comfortable to subclassing the dictionary data types.check the official docs.defaultdict__missing__UserDict
Based on the docs, you might be able to get the behavior you want by subclassing defaultdict and overriding __missing__:Now, you'd want to flesh that out with a little extra logic, eg throw KeyError if self.default_factory is None, stuff like that which they mention in the docs. Hope this points you in the right direction.Here's a quick demo


Answer URL
https://docs.python.org/3/library/collections.html#defaultdict-objects
https://docs.python.org/3/library/collections.html#collections.defaultdict.__missing__
https://docs.python.org/3/library/collections.html#userdict-objects
