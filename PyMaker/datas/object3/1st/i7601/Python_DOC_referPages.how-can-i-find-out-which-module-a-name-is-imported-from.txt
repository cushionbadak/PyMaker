Natural Text
In a Python program, if a name exists in the namespace of the program, is it possible to find out if the name is imported from some module, and if yes, which module it is imported from?
You can see which module a function has been defined in via the __module__ attribute. From the Python Data model documentation on __module__:The name of the module the function was defined in, or None if unavailable.Example:The Data model later mentions that classes have the same attribute as well:__module__ is the module name in which the class was defined.You can also do this with builtin names such as int and list. You can accesses them from the builtins module.I can use int and list without from builtins import int, list. So how do int and list become available in my program?That is because int and list are builtin names. You don't have to explicitly import them for Python to be able to find them in the current namespace. You can see this for yourself in the CPython virtual machine source code. As @user2357112 mentioned, builtin names are accessed when global lookup fails. Here's the relevant snippet:In the code above, CPython first searches for a name in the global scope. If that fails, then it falls back and attempts to get the name from a mapping of builtin names in the current frame object its executing. That's what f->f_builtins is.You can observe this mapping from the Python level using sys._getframe():sys._getframe() returns the frame at the top of the call stack. In this case, its the frame for the module scope. And as you can see from above, the f_builtins mapping for the frame contains both the int and list classes, so Python has automatically made those names available to you. In other words, it's "built" them into the scope; hence the term "builtins".
If for some reason the source is unavailable, you could use getmodule from inspect which tries its best to find the module by grabbing __module__ if it exists and then falling back to other alternatives. If everything goes o.k, you get back a module object. From that, you can grab the __name__ to get the actual name of the module:If it doesn't find anything, it returns None so you'd have to special case this. In general this encapsulates the logic for you so you don't need to write a function yourself to actually grab __module__ if it exists.This doesn't work for objects that don't have this information attached. You can, as a fall-back, try and pass in the type to circumvent it:but that won't always yield the correct result:
Some objects (but far from all) have an attribute __module__.
Unless code is doing something unusual like updating globals directly, the source code should indicate where every variable came from:
You can also look at globals(), it will output a dict with all the names python uses BUT also the variable, modules and functions you declared inside the namespace.Therefore, you can test if variable were declared like this:Works also with modules:


Answer URL
https://docs.python.org/3/reference/datamodel.html
https://docs.python.org/3/reference/datamodel.html#index-48
https://docs.python.org/3/library/sys.html#sys._getfram
https://docs.python.org/3/library/inspect.html#inspect.getmodule
https://docs.python.org/3/reference/datamodel.html
https://docs.python.org/3/library/functions.html#globals
