Natural Text
I've been wondering recently if there's a way to detect whether a context manager is nested.I've created Timer and TimerGroup classes:This code prints timings in a readable format:However, when I nest TimerGroups, it messed things up:All I need is to do is to indent the nested Timers and TimerGroups somehow. Should I pass any parameters to their constructors? Or can I detect that from inside the class?
If all you need to do is adjust an indentation level based on how many nested context managers you're executing in, then have a class attribute called indent_level and adjust it each time you enter and exit a context manager.  Something like the following:And use it as:
There are no special facilities to detect nested context managers, no. You'd have to handle this on your own. You could do this within your own context manager:You can then use the TimerGroup._active_group attribute elsewhere to grab the currently active group. I used a thread-local object to ensure that this can be used across multiple threads of execution.Alternatively, you could make that a stack counter and just increment and decrement in nested __enter__ calls, or a stack list and push self onto that stack, popping it again when you __exit__:
import this:Explicit is better than implicitA cleaner design would explicitly allow to specify a group:On the other hand, you can always use traceback.extract_stack and look for invocations of a particular function upstream. It is very useful for logging and error reporting, and can be moderately useful to ensure that particular functions are only invoked in a certain context. But it tends to create dependencies that are very hard to track. I would avoid it for grouping timers, though you can try. If you badly need automatic grouping, @Martijn-Pieters's approach is far superior.


Answer URL
https://docs.python.org/3/library/threading.html#thread-local-data
https://docs.python.org/3/library/traceback.html#traceback.extract_stack
