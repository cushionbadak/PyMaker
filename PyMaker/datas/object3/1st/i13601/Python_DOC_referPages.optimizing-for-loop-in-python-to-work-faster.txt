Natural Text
I am working to optimize Python code. The goal is to take a list of integers and calculate and output how many pairs there are in the list. A pair is considered to be 2 numbers with the difference of K ( 2 in this case)For example: The pairs here will be (1,3), (5,3), (2,4)The answer is: 3I want to increase efficiency of the code, current version takes 8 second or more.cProfile tells me that for number in sorted_array: is the only line that takes all the time. But I cannot seem to figure out how to optimize for loop.Does anyone have any experience or suggestions? Thank you so much.The code:cProfile:
If [1,3,3,3,3,3,6] results in five pairs (k=2), you could use numpy's broadcasting feature to eliminate the Python for loops.Create a new array that contains all the integers that would make pairsCreate a boolean array by broadcasting b across a: this results in a 2-d array with True's everywhere there is a pair.Sum all the True'sOr just:If, as the example input suggests, the list only contains unique values the numpy solution would be:Which is much faster.In fact if the values are NOT unique, numpy.in1d is much faster than the broadcasting solution, above.  By switching the order of the arguments, you count five pairs for [1,3,3,3,3,3,6].Now for a bit of crow eating:  turning the list to a set (assuming unique values), a pure Python solution is faster than the numpy solutions.Using sum to consume a generator expression doesn't require making any intermediate objects - probably one reason for its speed/efficiency.
Use a better algorithm.  In your codeyou are checking the entire array for the_pair, so you have gained nothing by sorting the list.  Since all the elements are integers, after the list is sorted `the_pair, if it occurs in the list can only be in one of the next two positions.  Try something like
@saulspatz is correct that you are making sorting irrelevant in your code, however I would suggest you skip the sorting instead of generating thousands of list slices. The in operation is in fact extremely fast provided you are comparing to an immutable type (ex:tuple()). I therefore would propose the following code: output:


Answer URL
https://docs.python.org/3/tutorial/classes.html#generator-expressions
https://docs.python.org/3/tutorial/index.html
