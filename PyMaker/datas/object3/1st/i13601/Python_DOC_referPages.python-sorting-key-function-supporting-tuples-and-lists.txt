Natural Text
In Python you can for example sort tuples sorted([(2,2),(1,2),(2,1),(1,1)]) and get [(1, 1), (1, 2), (2, 1), (2, 2)].You can also use custom key functions sorted([x, y, z], key=custom_key) to implement special sorting criteria.For example:Could sort any list of strings normally, and also gold/silver/bronze according to my custom ordering.But it does not "correctly" handle tuples anymore: sorted([('Gold', 2), ('Bronze', 1), ('Gold', 1)], key=custom_key) results in [('Bronze', 1), ('Gold', 1), ('Gold', 2)] as item is not a basestring.But I would like to get [('Gold', 1), ('Gold', 2), ('Bronze', 1)] by somehow applying the custom logic to each item in the tuple.What's the best way to "map" the custom key logic over any tuples (that may or may not appear) in the list like the default key function does?Edit: More examples:sorted(['Silver', 'Bronze', 'Gold'], key=custom_key)['Gold', 'Silver', 'Bronze']sorted([['Silver', 2], ['Silver', 1], ['Gold', 1]], key=custom_key)[['Gold', 1], ['Silver', 1], ['Silver', 2]]sorted([(2, 'Gold'), (2, 'Bronze'), (1, 'Gold')], key=custom_key)[(1, 'Gold'), (2, 'Gold'), (2, 'Bronze')]sorted([('Silver', 'Bronze'), ('Gold', 'Bronze'), ('Silver', 'Gold')], key=custom_key)[('Gold', 'Bronze'), ('Silver', 'Gold'), ('Silver', 'Bronze')]
Output:
You could create a mapper function, that takes your key function and returns another function, applying the key function to each element of some iterable.Example:Or similar, using functools.partial with map:
The key function can return a tuple:Prints [('Gold', 1), ('Gold', 2), ('Bronze', 1)]. Essentially this makes the sorting behave the same as your first example, i.e. sorted([(1, 2), (3, 1), (1, 1)]).Edit: you can also make a custom key that returns a tuple, which may be prettier.
You don't need a extra function. You can also do it:Output:


Answer URL
https://docs.python.org/3/library/functools.html#functools.partial
