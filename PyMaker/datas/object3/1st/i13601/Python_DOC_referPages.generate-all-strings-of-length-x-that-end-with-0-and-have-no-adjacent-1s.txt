Natural Text
I need to generate all possible strings of certain length X that satisfies the following two rules:Must end with '0'There can't be two or more adjacent '1'For example, when X = 4, all 'legal' strings are [0000, 0010, 0100, 1000, 1010].I already wrote a piece of recursive code that simply append the newly found string to a list.However this method won't work while X reaches 100+ because the memory complexity. I am not familiar with the generator method in Python, so could anyone here help me figure out how to re-write it into a generator? Thanks so much!P.S. I am working on a Project Euler problem, this is not homework.Update 1:Grateful to the first 3 answers, I am using Python 2.7 and can switch to python 3.4. The reason I am asking for the generator is that I can't possibly hold even just the final result list in my memory. A quick mathematical proof will show that there are Fibonacci(X) possible strings for the length X, which means I have to really use a generator and filter the result on the fly.
Lame string-based testing whether "11" is contained in the formatted string and yield if it's not (for every even number up to 2^maxlen):Superior mathematical approach (M xor M * 2 = M * 3):Here's a benchmark for 6 different implementations (Python 3!):Some numbers for string length = 24 (in seconds):shx2's algorithm is clearly the winner, followed by math. Pythonic code makes quite a difference if you compare the results of both math approaches (note: ranges are also generators).Noteworthy: the itertools_* functions perform almost equally slow, but itertools_list needs a lot more memory to store the list in (~6 MB spike in my test). All other generator-based solutions have a minimal memory footprint, because they only need to store the current state and not the entire result.None of the shown functions blows up the stack, because they do not use actual recursion. Python does not optimize tail recursion, thus you need loops and generators.//edit: naive C++ implementation of math_range (MSVS 2013):It takes 0.08 seconds(!) for maxlen = 24 (/Ox).An implementation of shx2's algorithm in C++ is non-trivial, because a recursive approach would lead to stack overflow (ha ha), and there's no yield. See:Why wasn't yield added to C++0x?http://www.chiark.greenend.org.uk/~sgtatham/coroutines.htmlhttp://blog.think-async.com/2009/08/secret-sauce-revealed.htmlhttp://www.codeproject.com/Articles/418776/How-to-replace-recursive-functions-using-stack-andBut if you want raw speed, then there's no way around it.
You can use a filter with itertools.productThis uses generators the entire time until the return which finally creates a list. The filter will act on each of the strings created by itertools.product as they are produced.Edit To use this function as a generator expression, just drop the list and switch filter to itertools.ifilter
Assuming you're using python version >= 3.4, where yield from is available, you can yield instead of accumulating+returning. You don't need to pass around a container.If you're using a python version where yield from is not available, replace those lines with:
If you were doing it in Python 3, you would adapt it as follows:Remove the container parameter.Change all occurrences of container.append(some_value) to yield some_value.Prepend yield from to all recursive calls.To do it in Python 2, you do the same, except that Python 2 doesn’t support yield from. Rather than doing yield from iterable, you’ll need to use:You’ll then also need to change your call site, removing the container argument and instead storing the return value of the call. You’ll also need to iterate over the result, printing the values, as print will just give you <generator object at 0x...>.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.product
