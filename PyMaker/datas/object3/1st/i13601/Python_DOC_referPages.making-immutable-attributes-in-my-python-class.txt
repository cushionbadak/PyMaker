Natural Text
Although I have never needed this, it just struck me that making an immutable object in Python could be slightly tricky. You can't just override __setattr__, because then you can't even set attributes in the __init__. Subclassing a tuple is a trick that works:But then you have access to the a and b variables through self[0] and self[1], which is annoying.Is this possible in Pure Python? If not, how would I do it with a C extension?(Answers that work only in Python 3 are acceptable).Update: So subclassing tuple is the way to do it in Pure Python, which works well except for the additional possibility of accessing the data by [0], [1] etc. So, to complete this question all that is missing is howto do it "properly" in C, which I suspect would be quite simple, by just not implementing any geititem or setattribute, etc. But instead of doing it myself, I offer a bounty for that, because I'm lazy. :)
Yet another solution I just thought of:  The simplest way to get the same behaviour as your original code isIt does not solve the problem that attributes can be accessed via [0] etc., but at least it's considerably shorter and provides the additional advantage of being compatible with pickle and copy.namedtuple creates a type similar to what I described in this answer, i.e. derived from tuple and using __slots__.  It is available in Python 2.6 or above.
The easiest way to do this is using __slots__:Instances of A are immutable now, since you can't set any attributes on them.If you want the class instances to contain data, you can combine this with deriving from tuple:Edit: If you want to get rid of indexing either, you can override __getitem__():Note that you can't use operator.itemgetter for the properties in thise case, since this would rely on Point.__getitem__() instead of tuple.__getitem__().  Fuerthermore this won't prevent the use of tuple.__getitem__(p, 0), but I can hardly imagine how this should constitute a problem.I don't think the "right" way of creating an immutable object is writing a C extension.  Python usually relies on library implementers and library users being consenting adults, and instead of really enforcing an interface, the interface should be clearly stated in the documentation.  This is why I don't consider the possibility of circumventing an overridden __setattr__() by calling object.__setattr__() a problem.  If someone does this, it's on her own risk.
..howto do it "properly" in C..You could use Cython to create an extension type for Python:It works both Python 2.x and 3.TestsIf you don't mind indexing support then collections.namedtuple suggested by @Sven Marnach is preferrable:
Another idea would be to completely disallow __setattr__ and use object.__setattr__ in the constructor:Of course you could use object.__setattr__(p, "x", 3) to modify a Point instance p, but your original implementation suffers from the same problem (try tuple.__setattr__(i, "x", 42) on an Immutable instance).You can apply the same trick in your original implementation: get rid of __getitem__(), and use tuple.__getitem__() in your property functions.
You could create a @immutable decorator that either overrides the __setattr__ and change the __slots__ to an empty list, then decorate the __init__ method with it.Edit: As the OP noted, changing the __slots__ attribute only prevents the creation of new attributes, not the modification.Edit2: Here's an implementation:Edit3: Using __slots__ breaks this code, because if stops the creation of the object's __dict__. I'm looking for an alternative.Edit4: Well, that's it. It's a but hackish, but works as an exercise :-)
I don't think it is entirely possible except by using either a tuple or a namedtuple. No matter what, if you override __setattr__() the user can always bypass it by calling object.__setattr__() directly. Any solution that depends on __setattr__ is guaranteed not to work.The following is about the nearest you can get without using some sort of tuple:but it breaks if you try hard enough:but Sven's use of namedtuple is genuinely immutable.UpdateSince the question has been updated to ask how to do it properly in C, here's my answer on how to do it properly in Cython:First immutable.pyx:and a setup.py to compile it (using the command setup.py build_ext --inplace:Then to try it out:
In addition to the excellent other answers I like to add a method for python 3.4 (or maybe 3.3). This answer builds upon several previouse answers to this question.In python 3.4, you can use properties without setters to create class members that cannot be modified. (In earlier versions assigning to properties without a setter was possible.)You can use it like this:which will print "constant"But calling instance.a=10 will cause:Explaination: properties without setters are a very recent feature of python 3.4 (and I think 3.3). If you try to assign to such a property, an Error will be raised.Using slots I restrict the membervariables to __A_a (which is __a).Problem: Assigning to _A__a is still possible (instance._A__a=2). But if you assign to a private variable, it is your own fault...This answer among others, however, discourages the use of __slots__. Using other ways to prevent attribute creation might be preferrable.
Here's an elegant solution:Inherit from this class, initialize your fields in the constructor, and you'e all set.
I've made immutable classes by overriding __setattr__, and allowing the set if the caller is __init__:This isn't quite enough yet, since it allows anyone's ___init__ to change the object, but you get the idea.
If you are interested in objects with behavior, then namedtuple is almost your solution.  As described at the bottom of the namedtuple documentation, you can derive your own class from namedtuple; and then, you can add the behavior you want.For example (code taken directly from the documentation):This will result in:This approach works for both Python 3 and Python 2.7 (tested on IronPython as well).The only downside is that the inheritance tree is a bit weird; but this is not something you usually play with.
I needed this a little while ago and decided to make a Python package for it. The initial version is on PyPI now:To use:Full docs here: https://github.com/theengineear/immutableHope it helps, it wraps a namedtuple as has been discussed, but makes instantiation much simpler.
This way doesn't stop object.__setattr__ from working, but I've still found it useful:you may need to override more stuff (like __setitem__) depending on the use case.
As of Python 3.7, you can use the @dataclass decorator in your class and it will be immutable like a struct! Though, it may or may not add a __hash__() method to your class. Quote:hash() is used by built-in hash(), and when objects are added to hashed collections such as dictionaries and sets. Having a hash() implies that instances of the class are immutable. Mutability is a complicated property that depends on the programmerâ€™s intent, the existence and behavior of eq(), and the values of the eq and frozen flags in the dataclass() decorator.By default, dataclass() will not implicitly add a hash() method unless it is safe to do so. Neither will it add or change an existing explicitly defined hash() method. Setting the class attribute hash = None has a specific meaning to Python, as described in the hash() documentation.If hash() is not explicit defined, or if it is set to None, then dataclass() may add an implicit hash() method. Although not recommended, you can force dataclass() to create a hash() method with unsafe_hash=True. This might be the case if your class is logically immutable but can nonetheless be mutated. This is a specialized use case and should be considered carefully.Here the example from the docs linked above:      
Classes which inherit from the following Immutable class are immutable, as are their instances, after their __init__ method finishes executing.  Since it's pure python, as others have pointed out, there's nothing stopping someone from using the mutating special methods from the base object and type, but this is enough to stop anyone from mutating a class/instance by accident.It works by hijacking the class-creation process with a metaclass.
The third party attr module provides this functionality.Edit: python 3.7 has adopted this idea into the stdlib with @dataclass.attr implements frozen classes by overriding __setattr__ and has a minor performance impact at each instantiation time, according to the documentation.If you're in the habit of using classes as datatypes, attr may be especially useful as it takes care of the boilerplate for you (but doesn't do any magic). In particular, it writes nine dunder (__X__) methods for you (unless you turn any of them off), including repr, init, hash and all the comparison functions.attr also provides a helper for __slots__.
You can override setattr and still use init to set the variable. You would use super class setattr. here is the code.
An alternative approach is to create a wrapper which makes an instance immutable.This is useful in situations where only some instances have to be immutable (like default arguments of function calls).Can also be used in immutable factories like:Also protects from object.__setattr__, but fallable to other tricks due to Python's dynamic nature.
I used the same idea as Alex: a meta-class and an "init marker", but in combination with over-writing __setattr__:Note: I'm calling the meta-class directly to make it work both for Python 2.x and 3.x.It does work also with slots ...:... and multiple inheritance:Note, however, that mutable attributes stay to be mutable:
One thing that's not really included here is total immutability... not just the parent object, but all the children as well. tuples/frozensets may be immutable for instance, but the objects that it's part of may not be. Here's a small (incomplete) version that does a decent job of enforcing immutability all the way down:
You can just override setAttr in the final statement of init. THen you can construct but not change. Obviously you can still override by usint object.setAttr but in practice most languages have some form of reflection so immutablility is always a leaky abstraction. Immutability is more about preventing clients from accidentally violating the contract of an object. I use:=============================The original solution offered was incorrect, this was updated based on the comments using the solution from hereThe original solution is wrong in an interesting way, so it is included at the bottom.===============================Output :======================================Original Implementation:It was pointed out in the comments, correctly, that this does not in fact work, as it prevents the creation of more than one object as you are overriding the class setattr method, which means a second cannot be created as self.a = will fail on the second initialisation.
The basic solution below addresses the following scenario:__init__() can be written accessing the attributes as usual. AFTER that the OBJECT is frozen for attributes changes only:The idea is to override __setattr__ method and replace its implementation each time the object frozen status is changed.So we need some method (_freeze) which stores those two implementations and switches between them when requested.This mechanism may be implemented inside the user class or inherited from a special Freezer class as shown below:


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__setattr__
https://docs.python.org/3/reference/datamodel.html#object.__init__
https://docs.python.org/3/library/dataclasses.html
https://docs.python.org/3/reference/datamodel.html#object.__hash__
https://docs.python.org/3/library/dataclasses.html
