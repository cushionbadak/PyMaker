Natural Text
I came across this behavior that surprised me in Python 2.6 and 3.2:However, dict comprehensions in 3.2 show a more polite demeanor:Why does fromkeys behave like that?
Your Python 2.6 example is equivalent to the following, which may help to clarify:Each entry in the resulting dictionary will have a reference to the same object. The effects of mutating that object will be visible through every dict entry, as you've seen, because it's one object.Use a dict comprehension, or if you're stuck on Python 2.6 or older and you don't have dictionary comprehensions, you can get the dict comprehension behavior by using dict() with a generator expression:
In the first version, you use the same empty list object as the value for both keys, so if you change one, you change the other, too.Look at this:In the second version, a new empty list object is created in every iteration of the dict comprehension, so both are independent from each other.As to "why" fromkeys() works like that - well, it would be surprising if it didn't work like that. fromkeys(iterable, value) constructs a new dict with keys from iterable that all have the value value. If that value is a mutable object, and you change that object, what else could you reasonably expect to happen?
To answer the actual question being asked: fromkeys behaves like that because there is no other reasonable choice. It is not reasonable (or even possible) to have fromkeys decide whether or not your argument is mutable and make new copies every time. In some cases it doesn't make sense, and in others it's just impossible.The second argument you pass in is therefore just a reference, and is copied as such. An assignment of [] in Python means "a single reference to a new list", not "make a new list every time I access this variable". The alternative would be to pass in a function that generates new instances, which is the functionality that dict comprehensions supply for you.Here are some options for creating multiple actual copies of a mutable container:As you mention in the question, dict comprehensions allow you to execute an arbitrary statement for each element:The important thing here is that this is equivalent to putting the assignment k = [] in a for loop. Each iteration creates a new list and assigns it to a value.Use the form of the dict constructor suggested by @Andrew Clark:This creates a generator which again makes the assignment of a new list to each key-value pair when it is executed.Use a collections.defaultdict instead of a regular dict:This option is a little different from the others. Instead of creating the new list references up front, defaultdict will call list every time you access a key that's not already there. You can there fore add the keys as lazily as you want, which can be very convenient sometimes:Since you've set up the factory for new elements, this will actually behave exactly as you expected fromkeys to behave in the original question.Use dict.setdefault when you access potentially new keys. This does something similar to what defaultdict does, but it has the advantage of being more controlled, in the sense that only the access you want to create new keys actually creates them:The disadvantage is that a new empty list object gets created every time you call the function, even if it never gets assigned to a value. This is not a huge problem, but it could add up if you call it frequently and/or your container is not as simple as list.


Answer URL
https://docs.python.org/3/library/collections.html#collections.defaultdict
https://docs.python.org/3/library/stdtypes.html#dict.setdefault
