Natural Text
I am working on a Python project that mainly returns closures instead of the traditional class-based approach. For example:As you can imagine, debugging and testing closures are a nightmare especially if I use the same name for the closure throughout my code. For example:So I tried wrapping it in a class to get the special __repr__ handling from a namedtuple:Such that:As you can imagine this takes probably a hit on performance. My question is if this kind of wrapping is preferrable, if at all more Pythonic than just returning the "ugly" closure?
A lighter approach is to simply modify the closure's func_name attribute. The result isn't as pretty as what your code produces, but it will have minimal impact on RAM and performance.typical outputFor Python 3 you need to do something slightly different.becomes:
I understood from your question that you were still using Python 2.In Python 3 (3.3+ as we're using inspect.getclosurevars) here one can do some serious magic to do an almost-no-overhead decorator that will (for this case) produce the desired output; this is harder to do in Python 2, since Python 2 functions do not know their fully-qualified name:prints outHow this works is that the __call__ can be assigned for an instance; so we do not need to have a dummy __call__ trampoline; we also use the __slots__ to decrease runtime overhead.The real magic lies in the __repr__ method, wherein the function/closure that was decorated is carefully dissected. The free variables that the function uses from the outer scope can be inspected with the help of inspect.getclosurevars which returns a named tuple; we're especially interested in the nonlocals since these are the values used from the outer scopes; this is a simple dictionary of variable name to value. We make this into a nice string of variable=value, variable=value. These are not strictly the function arguments, but are the values that are seen and used in the inner closure. We also clean the function name a bit; in Python 3 the name of the function is in __name__, and the fully qualified name is in __qualname__; the __qualname__ for closures looks like foo.<locals>.bar.<locals>.baz, so we remove all .<locals>, to get foo.bar.baz; we then remove the last dotted part if it matches the __funcname__ of our wrapped function, and append the nicely formatted arguments at the end, for truly nice results.


Answer URL
https://docs.python.org/3/library/inspect.html#inspect.getclosurevars
