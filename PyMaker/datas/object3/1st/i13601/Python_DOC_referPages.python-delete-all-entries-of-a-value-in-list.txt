Natural Text
Why isn't this for loop working? My goal is to delete every 1 from my list.
You should not change the content of list while iterating over it But you could iterate over the copy of the list content and change it in your caseCode:Output:As @metatoaster stated you could use filterCode:You could use filter to remove multiple things exampleCode:
Never change a list while iterating over it. The results are unpredictable, as you're seeing here. One simple alternative is to construct a new list:If for some reason you absolutely have to edit the list in place rather than constructing a new one, my off-the-cuff best answer is to traverse it finding the indices that must be deleted, then reverse traverse that list of indices removing them one by one:Because that removes elements from the end of the list first, the original indices computed remain valid. But I would generally prefer computing the new list unless special circumstances apply.
Consider this code:Result:For short, your code get some undesirable result because of "size" and "index positions" of your list are changed every times you cut the number 1 off and your code is clearly proved that for each loop in Python can not handle a list with a dynamic size.
This doesn't work because you are modifying the list as it is iterating, and the current pointer moves past one of the 1 you check against.  We can illustrate this:I added _ to the element being compared.  Note how there was only 6 passes in total and with one of the 1s actually skipped over from being ever looked at.  That ends up being the element that was removed because list.remove removes the first occurrence of the element specified, and it is an O(n) operation on its own which gets very expensive once your list gets big - this is O(n) even if the item is in the beginning, as it has to copy every single item from everything after the item one element forward as python lists are more like C styled arrays than Java linked-lists (if you want to use linked-lists, use collections.deque). O(n) towards the end because it has to iterate through the entire list to do its own comparison too. Your resulting code can result in a worst case runtime complexity of O(n log n) if you make use of remove.See Python's data structure time complexityPeter's answer already covered the generation of a new list, I am only answering why and how your original code did not work exactly.


Answer URL
https://docs.python.org/3/library/collections.html#collections.deque
