Natural Text
I am using NetworkX's simple_cycles to generate all cycles, and I iterate through on the condition of breaking if a cycle of size k is found (k being supplied by the user).Depending on the graph, simple_cycles may take basically forever to try to find a cycle of size k.  I would like to stop checking after a certain amount of time.  I can't stop based on the amount of cycles found, because that is unreliable.  Sometimes 1 cycle may be found in a full minute, and 100000 cycles may be found in 30 seconds.My question is if there is a way to stop the generator based on a certain amount of time passing, from OUTSIDE of the generator.. or if the only way would be to modify the code of the generator itself.(Also any general advice about what I am trying to do would be appreciated.)
The trouble is that there are pathological corner cases ... for example, a huge, huge graph with zero cycles, such that it requires too much time before even the first iteration of nx.simple_cycles(G) can complete.As a result, there won't be a way to do it from outside the generator unless you place the execution into another context that you are able to terminate, like a separate Process from multiprocessing, or running the coroutine with asyncio.Then for each cycle that is asynchronously obtained (either from the process or thread), you can check the length condition and a condition on the overall amount of elapsed time, and choose to terminate the other process / thread if you exceed the time limit.On the other hand, if you don't care about this type of corner case and you're reasonably sure that the values yielded by nx.simple_cycles(G) will return in reasonable amounts of time, then you could wrap that generator to make your own time-limited generator:With the above, you can replace your original usage of nx.simple_cycles with a call to time_limited_cycles instead (with your desired time limit), and the rest of your code will work the same, because time_limited_cycles yields the same cycle results that nx.simple_cycles would yield, up to the point that it stops.
The part where you check the length looks like a good place to start. Using time is also a good idea for timing things. At the top of your code, insert:Before the for loop, insert:In your for loop, change the if statement to:You might want to make another if instead of merging it because a timeout will still set checkval to True, which you may not want. In that case, just leave the first if alone, and make another one:


Answer URL
https://docs.python.org/3/library/asyncio-dev.html#concurrency-and-multithreading
