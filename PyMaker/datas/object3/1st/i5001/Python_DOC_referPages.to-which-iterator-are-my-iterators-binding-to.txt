Natural Text
Here is my python code for this question.From above definitions, I wrote the following code to understand the concept iterator bindingWhen I run the above code, I will get the above messages, which indicates that iterators obtained from iter function invoking on data are not the same, but iterators obtained from iter function invoking on my iterable are the same. Can anyone explain to me what is going on? I would appreciate any help on this. Thank you.
You have incorrectly implemented the protocol, from the data-model, the __iter__ method:This method is called when an iterator is required for a container.  This method should return a new iterator object that can iterate over  all the objects in the container.You always return the same old iterator:Which is only ever set here:...Iterator objects also need to implement this method; they are required  to return themselves.You implemented your iterator correctly in that regard.Your iterable implementation should be like this:
You misimplemented iterable. The __iter__ of an iterable non-iterator should return a new iterator on each call, so a proper implementation would be:This preserves an important attribute of iterators and iterables. iter(iterator) should always return iterator, but iter(iterable) should not only return a new object, but it should be a different object each time (because the idea is that non-iterators can be iterated separately and repeatably, only iterators are stateful); that is iter(iterable) is not iter(iterable).


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__iter__
