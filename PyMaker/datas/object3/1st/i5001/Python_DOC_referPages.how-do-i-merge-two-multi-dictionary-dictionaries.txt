Natural Text
I need to merge multiple dictionaries, here's what I have for instance:With A B C and D being leaves of the tree, like {"info1":"value", "info2":"value2"}There is an unknown level(depth) of dictionaries, it could be {2:{"c":{"z":{"y":{C}}}}}In my case it represents a directory/files structure with nodes being docs and leaves being files.I want to merge them to obtain:I'm not sure how I could do that easily with Python.
this is actually quite tricky - particularly if you want a useful error message when things are inconsistent, while correctly accepting duplicate but consistent entries (something no other answer here does....)assuming you don't have huge numbers of entries a recursive function is easiest:note that this mutates a - the contents of b are added to a (which is also returned).  if you want to keep a you could call it like merge(dict(a), b).agf pointed out (below) that you may have more than two dicts, in which case you can use:where everything will be added to dict1.[note - i edited my initial answer to mutate the first argument; that makes the "reduce" easier to explain]ps in python 3, you will also need from functools import reduce
Here's an easy way to do it using generators:This prints:
One issue with this question is that the values of the dict can be arbitrarily complex pieces of data. Based upon these and other answers I came up with this code:My use case is merging YAML files where I only have to deal with a subset of possible data types. Hence I can ignore tuples and other objects. For me a sensible merge logic meansreplace scalarsappend listsmerge dicts by adding missing keys and updating existing keysEverything else and the unforeseens results in an error.
Dictionaries of dictionaries mergeAs this is the canonical question (in spite of certain non-generalities) I'm providing the canonical Pythonic approach to solving this issue.Simplest Case: "leaves are nested dicts that end in empty dicts":This is the simplest case for recursion, and I would recommend two naive approaches:I believe I would prefer the second to the first, but keep in mind that the original state of the first would have to be rebuilt from its origin. Here's the usage:Complex Case: "leaves are of any other type:"So if they end in dicts, it's a simple case of merging the end empty dicts. If not, it's not so trivial. If strings, how do you merge them? Sets can be updated similarly, so we could give that treatment, but we lose the order in which they were merged. So does order matter? So in lieu of more information, the simplest approach will be to give them the standard update treatment if both values are not dicts: i.e. the second dict's value will overwrite the first, even if the second dict's value is None and the first's value is a dict with a lot of info.And nowreturnsApplication to the original question:I've had to remove the curly braces around the letters and put them in single quotes for this to be legit Python (else they would be set literals in Python 2.7+) as well as append a missing brace:and rec_merge(dict1, dict2) now returns:Which matches the desired outcome of the original question (after changing, e.g. the {A} to 'A'.)
Based on @andrew cooke. This version handles nested lists of dicts and also allows the option to update the values
If you have an unknown level of dictionaries, then I would suggest a recursive function:
Based on answers from @andrew cooke.It takes care of nested lists in a better way.
This simple recursive procedure will merge one dictionary into another while overriding conflicting keys:Output:
This version of the function will account for N number of dictionaries, and only dictionaries -- no improper parameters can be passed, or it will raise a TypeError. The merge itself accounts for key conflicts, and instead of overwriting data from a dictionary further down the merge chain, it creates a set of values and appends to that; no data is lost.It might not be the most effecient on the page, but it's the most thorough and you're not going to lose any information when you merge your 2 to N dicts.output: {1: [1, 2], 2: {1: 2, 3: 1}, 4: 4}
There's a slight problem with andrew cookes answer: In some cases it modifies the second argument b when you modify the returned dict. Specifically it's because of this line:If b[key] is a dict, it will simply be assigned to a, meaning any subsequent modifications to that dict will affect both a and b.To fix this, the line would have to be substituted with this:Where clone_dict is:Still. This obviously doesn't account for list, set and other stuff, but I hope it illustrates the pitfalls when trying to merge dicts.And for completeness sake, here is my version, where you can pass it multiple dicts:
Since dictviews support set operations, I was able to greatly simplify jterrace's answer.Any attempt to combine a dict with a non dict (technically, an object with a 'keys' method and an object without a 'keys' method) will raise an AttributeError. This includes both the initial call to the function and recursive calls. This is exactly what I wanted so I left it. You could easily catch an AttributeErrors thrown by the recursive call and then yield any value you please.
This should help in merging all items from dict2 into dict1:Please test it and tell us whether this is what you wanted.EDIT:The above mentioned solution merges only one level, but correctly solves the example given by OP. To merge multiple levels, the recursion should be used.
I had two dictionaries (a and b) which could each contain any number of nested dictionaries. I wanted to recursively merge them, with b taking precedence over a.Considering the nested dictionaries as trees, what I wanted was:To update a so that every path to every leaf in b would be represented in aTo overwrite subtrees of a if a leaf is found in the corresponding path in bMaintain the invariant that all b leaf nodes remain leafs.The existing answers were a little complicated for my taste and left some details on the shelf. I hacked together the following, which passes unit tests for my data set.Example (formatted for clarity):The paths in b that needed to be maintained were:1 -> 'b' -> 'white'2 -> 'd' -> 'black'3 -> 'e'.a had the unique and non-conflicting paths of:1 -> 'a' -> 'red' 1 -> 'c' -> 'orange' -> 'dog'so they are still represented in the merged map.
OverviewThe following approach subdivides the problem of a deep merge of dicts into: A parameterized shallow merge function merge(f)(a,b) that uses afunction f to merge two dicts a and bA recursive merger function f to be used together with mergeImplementationA function for merging two (non nested) dicts can be written in a lot of ways. I personally likeA nice way of defining an appropriate recurrsive merger function f is using multipledispatch which allows to define functions that evaluate along different paths depending on the type of their arguments.ExampleTo merge two nested dicts simply use merge(f) e.g.:Notes:The advantages of this approach are:The function is build from smaller functions that each do a single thingwhich makes the code simpler to reason about and testThe behaviour is not hard-coded but can be changed and extended as needed which improves code reuse (see example below). CustomizationSome answers also considered dicts that contain lists e.g. of other (potentially nested) dicts. In this case one might want map over the lists and merge them based on position. This can be done by adding another definition to the merger function f:
The code will depend on your rules for resolving merge conflicts, of course. Here's a version which can take an arbitrary number of arguments and merges them recursively to an arbitrary depth, without using any object mutation. It uses the following rules to resolve merge conflicts:dictionaries take precedence over non-dict values ({"foo": {...}} takes precedence over {"foo": "bar"})later arguments take precedence over earlier arguments (if you merge {"a": 1}, {"a", 2}, and {"a": 3} in order, the result will be {"a": 3})
I've been testing your solutions and decided to use this one in my project:Passing functions as parameteres is key to extend jterrace solution to behave as all the other recursive solutions.
Easiest way i can think of is :Output:
I have another slightly different solution here:By default it resolves conflicts in favor of values from the second dict, but you can easily override this, with some witchery you may be able to even throw exceptions out of it. :).

hey there I also had the same problem but I though of a solution and I will post it here, in case it is also useful for others, basically merging nested dictionaries and also adding the values, for me I needed to calculate some probabilities so this one worked great:by using the above method we can merge:target = {'6,6': {'6,63': 1}, '63,4': {'4,4': 1}, '4,4': {'4,3': 1}, '6,63': {'63,4': 1}}src = {'5,4': {'4,4': 1}, '5,5': {'5,4': 1}, '4,4': {'4,3': 1}}and this will become:{'5,5': {'5,4': 1}, '5,4': {'4,4': 1}, '6,6': {'6,63': 1}, '63,4': {'4,4': 1}, '4,4': {'4,3': 2}, '6,63': {'63,4': 1}}also notice the changes here:target = {'6,6': {'6,63': 1}, '6,63': {'63,4': 1}, '4,4': {'4,3': 1}, '63,4': {'4,4': 1}}src = {'5,4': {'4,4': 1}, '4,3': {'3,4': 1}, '4,4': {'4,9': 1}, '3,4': {'4,4': 1}, '5,5': {'5,4': 1}}merge = {'5,4': {'4,4': 1}, '4,3': {'3,4': 1}, '6,63': {'63,4': 1}, '5,5': {'5,4': 1}, '6,6': {'6,63': 1}, '3,4': {'4,4': 1}, '63,4': {'4,4': 1}, '4,4': {'4,3': 1, '4,9': 1}}dont forget to also add the import for copy:
Short-n-sweet:This works like (and is build on) Python's dict.update method. It returns None (you can always add return d if you prefer) as it updates dict d in-place. Keys in v will overwrite any existing keys in d (it does not try to interpret the dict's contents). It will also work for other ("dict-like") mappings.


Answer URL
https://docs.python.org/3/library/copy.html?highlight=deepcopy#copy.deepcopy
