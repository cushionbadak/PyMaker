Natural Text
Suppose I have a Python array a=[3, 5, 2, 7, 5, 3, 6, 8, 4]. My goal is to iterate through this array 3 elements at a time returning the mean of the top 2 of the three elements.Using the above array, during my iteration step, the first three elements are [3, 5, 2] and the mean of the top 2 elements is 4. The next three elements are [5, 2, 7] and the mean of the top 2 elements is 6. The next three elements are [2, 7, 5] and the mean of the top 2 elements is again 6. ...Hence, the result for the above array would be [4, 6, 6, 6, 5.5, 7, 7].What is the nicest way to write such a function?
SolutionYou can use some fancy slicing of your list to manipulate subsets of elements. Simply grab each three element sublist, sort to find the top two elements, and then find the simple average (aka. mean) and add it to a result list.CodeExampleYou can see your example input (and desired result) like so:And more...There are some other great answers that get into more performance directed answers, including one using a generator to avoid large in memory lists: https://stackoverflow.com/a/49001728/416500
I believe in splitting the code in 2 parts. Here that would be getting the sliding window, getting the top 2 elements, and calculating the mean. cleanest way to do this is using generatorsSliding windowSlight variation on evamicur's answer using tee, islice and zip to create the window:top 2 elementsto calculate the mean of the 2 highest you can use any of the methods used in the other answers, I think the heapq on is the clearestor equivalentlymean
The following code does what you need:Given your a=[3, 5, 2, 7, 5, 3, 6, 8, 4], returns:
itertools has a neat recipe to extract pairs of items from any iterable, not only indexable. You can adapt it slightly to extract triplets instead:Using that, you can simplify iterating over all triplets:
As a vectorized approach using Numpy you can do the following:Demo:
Iterator-only solutionfoslok's solution is definitely fine, but I wanted to play around and make a version of this with generators. It only stores a deque of length(window_size)as it iterates through the original list, then finds the n_largest values and calculates the mean thereof. result:Thus to change both the number of elements (window size) or the n largest elements just change the arguments to the respective functions. This approach also avoids the use of slicing so it can be more easily applied to iterables that you can't or don't want to slice. TimingsSo apparently the itertools tee vs deque doens't matter much. 
You can try this!That is,

You can look at it from generators perspective too: 
You need a sliding window iterator along with the mean of max two elements. I will try to produce a generic solution which can be used with sliding window of size n where n is any positive real number.
For the record, here is a functional version:
Using sliding window algorithm and the third-party more_itertools.windowed tool:See also @Maarten Fabr√©'s related post.
Use list comprehension    yields [4.0, 6.0, 6.0, 6.0, 5.5, 7.0, 7.0]
Don't sort your sub-lists, that operation is nlog(n)! Instead, find the largest two numbers with an O(n) algorithm. This will increase the efficiency of your solution. The efficiency gain will be more visible if you work on a larger problem of "find sum of top m out of a moving window of k items" for large m and k.Here is the generator version:
To sort three numbers, we need a maximum of three comparisons. To find the lowest of three numbers we only need two by quickselect. We also don't need to make any sublist copies:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools-recipes
