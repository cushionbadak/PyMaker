Natural Text
I'm trying to understand how to change an object's attribute temporarily when it is called and have the original value persist when the object is not called.Let me describe the problem with some code:In the event where a user calls getday method while passing another value  i.e 2/2/2002, self.day is set to 2/2/2002. However I want to be able to revert self.day to the original value of 1/1/2001 after the method call:returnsBut when I run the followingreturnsI was wondering what's the right way to revert the value, without needing to include code at every method call. Secondly, this should also be true when the object is called. For example:should returnI thought a decorator on the call magic method would work here, but I'm not really sure where to start.Any help would be much appreciated
Since you probably don't really want to modify the attributes of your object for a poorly defined interval, you need to return or otherwise create a different object.The simplest case would be one in which you had two separate objects, and no __call__ method at all:If you know where you want to use d_obj vs d_obj() in the original case, you clearly know where to use d1_obj vs d2_obj in this version as well.This may not be adequate for cases where DateCalc actually represents a very complex object that has many attributes that you do not want to change. In that case, you can have the __call__ method return a separate object that intelligently copies the portions of the original that you want.For a simple case, this could be justIf the object becomes complex enough, you will want to create a proxy. A proxy is an object that forwards most of the implementation details to another object. super() is an example of a proxy that has a very highly customized __getattribute__ implementation, among other things.In your particular case, you have a couple of requirements:The proxy must store all overriden attributes.The proxy must get all non-overriden attributes from the original objects.The proxy must pass itself as the self parameter to any (at least non-special) methods that are invoked.You can get as complicated with this as you want (in which case look up how to properly implement proxy objects like here). Here is a fairly simple example:The proxy would work exactly as you would want: it forwards any values that you did not override in __call__ from the original object. The interesting thing is that it binds instance methods to the proxy object instead of the original, so that getday gets called with a self that has the overridden value in it:Keep in mind that the proxy object shown here has very limited functionality implemented, and will not work properly in many situations. That being said, it likely covers many of the use cases that you will have out of the box. A good example is if you chose to make day a property instead of having a getter (it is the more Pythonic approach):The catch here is that the proxy's version of day is just a regular writable attribute instead of a read-only property. If this is a problem for you, implementing __setattr__ appropriately on the proxy will be left as an exercise for the reader.
It seems that you want a behavior like a context manager: to modify an attribute for a limited time, use the updated attribute and then revert to the original. You can do this by having __call__ return a context manager, which you can then use in a with block like this:There are a couple of ways of creating such a context manager. The simplest would be to use a nested method in __call__ and decorate it with contextlib.contextmanager:You could also use a fully-fledged nested class for this, but I would not recommend it unless you have some really complex requirements. I am just providing it for completeness:Also, you should consider making getday a property, especially if it is really read-only.Another alternative would be to have your methods accept different values:This is actually a fairly common idiom.


Answer URL
https://docs.python.org/3/library/functions.html#super
https://docs.python.org/3/reference/datamodel.html#object.__getattribute__
https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager
