Natural Text
I see patterns likequite frequently, often with a lot more parameters. Is there a good way to avoid this type of tedious repetitiveness? Should the class inherit from namedtuple instead?
A decorator solution that keeps the signature:
Disclaimer: It seems that several people are concerned about presenting this solution, so I will provide a very clear disclaimer. You should not use this solution. I only provide it as information, so you know that the language is capable of this. The rest of the answer is just showing language capabilities, not endorsing using them in this way.There isn't really anything wrong with explicitly copying parameters into attributes. If you have too many parameters in the ctor, it is sometimes considered a code smell and maybe you should group these params into a fewer objects. Other times, it is necessary and there is nothing wrong with it. Anyway, doing it explicitly is the way to go.However, since you are asking HOW it can be done (and not whether it should be done), then one solution is this:
As others have mentioned, the repetition isn't bad, but in some cases a namedtuple can be a great fit for this type of issue. This avoids using locals() or kwargs, which are usually a bad idea. I've found limited use for it, but you can inherit a namedtuple as with any other object (example continued):
explicit is better than implicit ... so sure you could make it more concise:The better question is should you?... that said if you want a  named tuple I would recommend using a namedtuple (remember tuples have certain conditions attached to them) ... perhaps you want an ordereddict or even just a dict ...
To expand on gruszczys answer, I have used a pattern like:I like this method because it:avoids repetitionis resistant against typos when constructing an objectworks well with subclassing (can just super().__init(...))allows for documentation of the attributes on a class-level (where they belong) rather than in X.__init__Prior to Python 3.6, this gives no control over the order in which the attributes are set, which could be a problem if some attributes are properties with setters that access other attributes.It could probably be improved upon a bit, but I'm the only user of my own code so I am not worried about any form of input sanitation.  Perhaps an AttributeError would be more appropriate.
You could also do:Of course, you would have to import the inspect module.
This is a solution without any additional imports.Helper functionA small helper function makes it more convenient and re-usable:ApplicationYou need to call it with locals():TestOutput:Without changing locals()If you don't like to change locals() use this version:
An interesting library that handles this (and avoids a lot of other boilerplate) is attrs. Your example, for instance, could be reduced to this (assume the class is called MyClass):You don't even need an __init__ method anymore, unless it does other stuff as well. Here's a nice introduction by Glyph Lefkowitz.
My 0.02$. It is very close to Joran Beasley answer, but more elegant:Additionally, Mike MÃ¼ller's answer (the best one to my taste) can be reduced with this technique:And the just call auto_init(locals()) from your __init__
It's a natural way to do things in Python. Don't try to invent something more clever, it will lead to overly clever code that no one on your team will understand. If you want to be a team player and then keep writing it this way.
Python 3.7 onwardsIn Python 3.7, you may (ab)use the dataclass decorator, available from the dataclasses module.  From the documentation:This module provides a decorator and functions for automatically adding generated special methods such as __init__() and __repr__() to user-defined classes. It was originally described in PEP 557.The member variables to use in these generated methods are defined using PEP 526 type annotations. For example this code:Will add, among other things, a __init__() that looks like:Note that this method is automatically added to the class: it is not directly specified in the InventoryItem definition shown above.If your class is large and complex, it may be inappropriate to use a dataclass.  I'm writing this on the day of release of Python 3.7.0, so usage patterns are not yet well established.


Answer URL
https://docs.python.org/3/reference/datamodel.html#slots
