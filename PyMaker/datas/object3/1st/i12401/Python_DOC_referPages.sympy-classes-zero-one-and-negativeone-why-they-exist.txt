Natural Text
Today I found thisI looked the documentation from sympy about those types, but it doesn't say anything about why they exist. Is there a reason to have 3 special singleton classes for -1, 0 and 1? Edit: I saw this at the SymPy online shell
Every number in SymPy is represented by an instance of the classNumber.Floats, Integers and Rationals are subclasses of Number. Zero is asubclass of Integer.You can inspect the full class lineage of an object by calling its class's mro (method resolution order) method:These subclasses "teach" SymPy how to manipulate and simplify expressions symbolically. As aexample, instances of the Rational class are negated thisway:That is to say, if x is an instance of Rational, then -x causes x.__neg__() to be called. Meanwhile, instances of the Integer class, are negated byAnd if the object is, in particular, an instance of Zero, then its negation isdefined by:Zero, One and MinusOne also implement a _eval_power method which"teaches" these objects how to evaluate x raised to a power (where x isZero, One or MinusOne). For example, Zero raised to a positiveexpression equals itself:One raised to anything equals itself: If you peruse the source code for the sympy.core.numbers module, you'll findloads of definitions which are in effect teaching SymPy how to do symbolicarithmetic. It's not too different from what children are taught in math class, except that it is expressed in computer-ese.You might be wondering why there isn't a special class for every integer.Integers besides Zero, One and MinusOne are treated as instances of thegeneral Integer class. Their rules of addition and multiplication and so on are laid out there. Unlike Zero, One and MinusOne which are instantated when the module is loaded, other Integers are cached only as needed:
First, note that type(1) gave you type(Integer(1)) because SymPy Live wraps integer literals in Integer() automatically (this is to avoid a gotcha where 1/2 evaluates to 0.5 instead of Rational(1, 2)). But note that in a regular Python session type(1) is int. There are several objects in SymPy which are implemented as singletons, meaning only one instance will ever exist. You can see these all on the S object(ignore the ones that start with _; those are Python internal methods)The reason this is done is that these objects are used a lot. 0, 1, and -1 are very common objects. Every time you write 1/x it is represented internally as Pow(x, -1). x - y is represented as Add(x, Mul(-1, y)). For 0, it appears quite often in all sorts of symbolic calculations. 1 is also common. By having a single instance, SymPy enables two optimizations. First, it saves memory. Second, you can compare against these objects using is comparison, like x is S.One. Because only one instance can ever exist Integer(1) is always the same as S.One. (also, I should note that some of the objects in S aren't actually that common, like Catalan and EulerGamma. I guess they were added more for convenience than anything)


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__neg__
