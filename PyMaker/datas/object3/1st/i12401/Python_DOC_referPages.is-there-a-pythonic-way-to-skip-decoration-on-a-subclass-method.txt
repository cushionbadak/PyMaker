Natural Text
I have an class which decorates some methods using a decorator from another library. Specifically, the class subclasses flask-restful resources, decorates the http methods with httpauth.HTTPBasicAuth().login_required(), and does some sensible defaults on a model service. On most subclasses I want the decorator applied; therefore I'd rather remove it than add it in the subclasses.My thought is to have a private method which does the operations and a public method which is decorated. The effects of decoration can be avoided by overriding the public method to call the private one and not decorating this override. Mocked example below.I am curious to know if there's a better way to do this. Is there a shortcut for 'cancelling decorators' in python that gives this effect? Or can you recommend a better approach?Some other questions have suitable answers for this, e.g. Is there a way to get the function a decorator has wrapped?. But my question is about broader design - i am interested in any pythonic way to run the operations in decorated methods without the effects of decoration. E.g. my example is one such way but there may be others. 
Flask-HTTPAuth uses functools.wraps in the login_required decorator:From Python 3.2, as this calls update_wrapper, you can access the original function via __wrapped__:To allow access to the original function for introspection and other  purposes (e.g. bypassing a caching decorator such as lru_cache()),  this function automatically adds a __wrapped__ attribute to the  wrapper that refers to the function being wrapped.If you're writing your own decorators, as in your example, you can also use @wraps to get the same functionality (as well as keeping the docstrings, etc.).See also Is there a way to get the function a decorator has wrapped?
Another common option is to have the decorated function keep a copy of the original function that can be accessed:Now, for any function that has been decorated, you can access its original_fn attribute to get a handle to the original, un-decorated function.In that case, you could define some type of dispatcher that either makes plain function calls (when you are happy with the decorator behavior) or makes calls to thing.original_fn when you prefer to avoid the decorator behavior.Your proposed method is also a valid way to structure it, and whether my suggestion is "better" depends on the rest of the code you're dealing with, who needs to read it, and other kinds of trade-offs.
I am curious to know if there's a better way to do this. Is there a  shortcut for 'cancelling decorators' in python that gives this effect?Use the undecorated library. It digs through all the decorators and returns just the original function. The docs should be self-explanatory, basically you just call: undecorated(your_decorated_function)


Answer URL
https://docs.python.org/3/library/functools.html#functools.wraps
https://docs.python.org/3/library/functools.html#functools.update_wrapper
