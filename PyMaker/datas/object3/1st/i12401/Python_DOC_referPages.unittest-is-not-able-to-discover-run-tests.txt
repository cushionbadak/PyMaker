Natural Text
There are some related questions, but none apply.This is my directory tree:unittest is not able to find anything:Not even from within abc_backend:What I have already verified:my test methods are properly named (test_whatever)my testcases extend unittest.TestCasethe abc_backend and the abc_backend/tests directories have an (empty) __init__.pyall test modules are importable (see below)unittest discover finds the tests, but has problems with relative imports (see below)nose is able to discover and run the tests, no problemsI would like to understand:why do I need to pass discover to unittest to force it to discover the tests? What does unittest do without the discover sub-command? (I thought unittest does test discovery by default). According to the documentation: python -m unittest is the equivalent of python -m unittest discoveronce the tests are discovered (by forcing the discover sub-command), why do I have import issues?Test modules are importableunittest discover has problems with relative importsIf I run it from the top dir:If I run it from within abc_backend:
I reproduced all the problems with CPython 3.5, so my answer shouldbe relevant to both 3.4 and 3.5.Relative import issuesThe reason why there are issues with relative imports is that due tospecifics of invocations you really do not import abc_backend package.First, let’s take a look at When you run tests from top that way, abc_backend is just not imported.That is because /home/user/top/abc_backend is added to sys.path insteadof /home/user/top. To solve this problem, doNow, about the in-abc_backend invocation. When you doabc_backend is not importable, as /home/user/top/abc_backend/testsdir does not contain abc_backend package. This too can be solved withthat will correctly put /home/user/top dir (pun intended) into sys.path.The -t (or --top-level-directory) option sets top level directoryof project and defaults to start directory (which is . by default).So, what is in sys.path is important, as that affects imports, whichaffect test loading, as discovery loads tests using import machinery.Difference between -m unittest and -m unittest discoverWhen you doin reality you are running unittest/__main__.py file. Theremain(module=None) is invoked, and eventually you get toloadTestsFromModule that doesAs abc_backend/__init__.py does not contain any test cases,isinstance(obj, type) and issubclass(obj, case.TestCase) returnsFalse for all module members (so tests is empty).To make this particular way of invocation work, you’ll have to dowhat people usually did in pre-discover times (aside from non-stdlibframeworks): manually import cases from test modules (ormaybe construct test suite according to load_tests protocol).So, how differs?Basically, differences may be expressed as following conditional:When argv is ['python3 -m unittest', 'discover', 'abc_backend'],actual discovery mechanism is used. When argv is ['python3 -m unittest', 'abc_backend'],loadTestsFromNames is used, which calls loadTestsFromModule at some point, and no tests are found.That’s the way things are in unittest/main.py.
I encountered similar problem today, actually the solution was written in the Python API document:If a package (a directory containing a file named init.py) is found, the package will be checked for a load_tests function. If this exists then it will be called package.load_tests(loader, tests, pattern). Test discovery takes care to ensure that a package is only checked for tests once during an invocation, even if the load_tests function itself calls loader.discover.Hence, all you need to do is write a load_tests function and register your TestCase classes in __init__.py


Answer URL
https://docs.python.org/3/library/unittest.html#unittest.TestLoader.discover
