Natural Text
This is a convoluted example, but it shows what I'm attempting to do. Say I have a string:I would like to replace all values in s that appear in ascii_uppercase with "L" for capital letter, all values that appear in ascii_lowercase with "l" for lowercase letter, and those in digits with "n" for a number.I'm currently doing:However, this is tedious with several more lists to replace. I'm usually better at finding map-type algorithms for things like this, but I'm stumped. I can't have it replace anything that was already replaced. For example, if I run the digits one and replace it with "n", the next iteration might replace that with "l" because "n" is a lowercase letter.
You can create a translation table that maps all upper case letters to 'L', all lower case letters to 'l' and all digits to 'n'. Once you have such a map, you can pass it to str.translate().Note that in Python 3 there is no string.maketrans function. Instead, you get the method from the str object str.maketrans(). Read more about this here and the documentation hereI'm not exactly certain of the internals of str.translate(), but my educated guess is the mapping creates a length 256 string for each string character. So as it passes over your string, it'll translate \x00 to \x00, \x01 to \x01, etc, but A to L. That way you don't have to check whether each character is in your translation dictionary. I presume blindly translating all characters with no branches would result to better performance. Print ''.join(chr(i) for i in range(256)) in comparison to see this.
They're in different 32-blocks of ASCII, so you can do this:Your example suggests that you don't have other characters, but if you do, this should work:
Just in case you need to process unicode data:


Answer URL
https://docs.python.org/3/library/stdtypes.html#str.maketrans
