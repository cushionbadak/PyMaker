Natural Text
So, I'm foraying into the world of plasma simulation. Now, while I'm aware that top-level simulations are written in fortran and have ultra-memory efficient subroutines and specialized code, I'm hoping to just run some low-level simulations.My problem is that, when simulating a large number of particles in a time-varying environment (well, time-stepped), keeping track of all that data is a trick. I've used multi-dimensional arrays before - using the column number for the particle, and the row number for the attribute, however this feels rather clumsy. It does, however, seem to be more quickly executed.I recently tried defining my own class, however being a python newbie, I probably did it in a very inefficient way. For each particle in 3 dimensions, I needed to be able to store the particle's position, velocity and Force (with the potential to add more variables once the code becomes more complex). Using what I knew of classes, I defined a particle object (I think) that make my code much easier to read and follow:So, I can easily initialize an array containing lots of these objects, and modify each value in a reasonably straightforward way. However as I mentioned, this ran slower for simulations involving only a few particles. I will be playing with my code to compare it to a purely matrix-oriented method to see which one scales better with large simulations.My question I suppose then is this: Is defining a "particle" in this way the most efficient? Or is there a more CPU/memory efficient way to define such an object. I would like to keep it's method ability (i.e. particle[i].pos = [1,2,3] or particle[2].vx[1] = 3) so I can set values for each particle, as well as pass them through functions. Keep in mind I'm a Python newbie, so I probably won't have great success with large, complex code.
Save memory with __slots__One way to save memory is using slots:From the docs:This class variable can be assigned a string, iterable, or sequence of strings with variable names used by instances. __slots__ reserves space for the declared variables and prevents the automatic creation of __dict__ and __weakref__ for each instance.Side note: I fixed the mutable default argument problem by setting them to None and creating a new NumPy array in the __init__() for None values.Cannot add new attributes to instanceOne important difference is that you cannot add attributes after instantiation that are not listed in __slots__:Compare to a class without __slots__:No exception is raised.
It sounds like you want the flyweight pattern. Maybe store one integer in the object as an index into an array with rows of 9 elements?


Answer URL
https://docs.python.org/3/reference/datamodel.html?highlight=__slots__#object.__slots__
https://docs.python.org/3/reference/datamodel.html?highlight=__slots__#object.__slots__
