Natural Text
I don't quite understand how iterators have memory in Python.We still require O(min(l1, l2)) memory as we need to load the lists l1 and l2 in memory.I thought one of the main uses of iterators was to save memory - yet it does not seem to be useful here. Similarly, the code below is unclear to me:We need to load the lists before converting them into generators, right? This means we'll waste memory. So - what is the point of generators here as well. This is the only case that makes sense to me:None of the arrays is being loaded into memory. Hence we're in O(1) memory.How does the memory usage of the iterator functions in Python work? The first two cases seem to use O(min(l1, l2)) memory. I thought the main point of iterators was to save memory, which makes the first two cases seem useless.
Your examples are too simplistic. Consider this:nums_it is a generator that returns all items unmodified from nums. Clearly you do not have any advantage. But consider this:and compare it with:With squares_it, we are generating the squares of nums on the fly only when requested. With squares_lst, we are generating all of them at once and storing them in a new list.So, when you do:it's like if you were doing:But when you do:it's like if you were doing:If you don't need (or don't have) the list nums, then you can save even more space by using:Generators and iterators also provide another significant advantage (which may actually be a disadvantage, depending on the situation): they are evaluated lazily.Also, generators and iterators may yield an infinite number of elements. An example is itertools.count() that yields 0, 1, 2, 3, ... without never ending.
We still require O(min(l1, l2)) memory as we need to load the lists l1 and l2 in memory.With zip you need storage for the two original lists plus the zipped list. With izip you don't store the zipped list.Big O notation isn't particularly helpful here if you have to work with a real physical machine instead of some abstract concept of a machine. There's a hidden constant multiplier on your O(n) calculations that could influence the practicality of the code well before n tends to infinity.We need to load the lists before converting them into generators, right? This means we'll waste memory. So - what is the point of generators here as well.No point to generators here. Any time you see n for n in <expr> without either a more complex expression before the for or an if <expr> filter after it, that's a code smell as you could just have used the original sequence directly. The generators only become useful when you transform the input values into something else or filter them.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.count
