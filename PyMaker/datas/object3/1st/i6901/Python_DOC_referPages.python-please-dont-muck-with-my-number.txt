Natural Text
I'm writing a testing tool in python that downloads REST data, tosses the return value through json.loads() and then compares the value returned from the DB with an expected value.  Unfortunately trying to print out that value or compare that value fails.  Even though the pretty print of the JSON / Rest data is correct and has the full value.  So something as simple as the example below prints lesser precision Example:Note the reduced precision. Running an equal compare does not work either.  In both cases I'm coercing the value to a string since comparing two numbers such as 1.13337 and 1.133333333333337 compare as the same number.  Although technically correct we want to be sure that the output from the DB is at the promised precision.  I would be grateful for any solutions out there.  Thanks in advance.
First, you're not actually losing the precision you think you are in your example. print just truncates more aggressively than you expected on Python 2. Comparisons should work fine on that number, as long as you're not losing more precision somewhere else.If you have an actual precision limits problem - for example, JSON with 20-digit numbers - you can address that. json.loads defaults to parsing numbers as floats, and floats have limited precision. If you don't want that, change how json.loads parses numbers:
I would do as user2357112 suggested.Not enough info to tell exactly the procedure you're going through to compare with the DB, but for future reference, you could use format such as:Edit: Looks like Zinki beat me to it.
Python (and many other programming languages) inherently have problems representing decimal numbers as floats and floating point arithmetic (including comparing floating point numbers). Please see these pages for an extensive explanation as to why: Floating Point Arithmetic: Issues and Limitations, What Every Computer ScientistShould Know About Floating PointArithmetic. If you require high levels of precision in Python, using the Decimal class can help. From the Python docs: "The decimal module provides support for fast correctly-rounded decimal floating point arithmetic". Please see Decimal fixed point and floating point arithmetic for more detail.Here is an example (from Python docs) showing the user-alterable level of precision:EDIT:As per discussion in comments, I was looking further into floating point comparison and it is possible to use math.isclose in Python if you desire comparisons to a specific precision. See What is the best way to compare floats for almost-equality in Python? for more details. For an analysis of floating point comparisons, please see: Comparing Floating Point Numbers
This is complete coded up answer that will correctly print any arbitrarily large decimal number.  Unfortunately, you must use the DecimalEncoder class to return the value as a string.  When I run this code stand alone I get exactly what I want.  (remember this is being used for testing and I want to be sure that python isn't changing the value somehow).  So when I get the value back from the database I can compare the value correctly without python rounding or clipping the value.  This solution in my testing environment, for some reason, rounds the last digit but no longer clips to 11 digits of precision.  Swapping the json.loads calls will show the original issue.  Unfortunately this changes the type of the data to a string and I still have to figure out why my code is rounding the value for the comparison but I can figure that out on the weekend :).  Thanks for everybody's help!!Output:


Answer URL
https://docs.python.org/3/tutorial/floatingpoint.html
