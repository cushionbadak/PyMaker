Natural Text
From the Google Style Guide on lexical scoping:A nested Python function can refer to variables defined in enclosing  functions, but can not assign to them.Both of these seem to check out at first:So why, then, does a combination of both reference and assignment in the nested function lead to an exception?
In first case, you are referring to a nonlocal variable which is ok because there is no local variable called a.In the second case, you create a local variable a which is also fine (local a will be different than the nonlocal one thats why the original a wasn't changed). In the third case, you create a local variable but you have print(a+2) before that and that is why the exception is raised. Because print(a+2) will refer to the local variable a which was created after that line.To achieve what you want, you need to use nonlocal a inside your inner function:
For anyone stumbling across this question, in addition to the accepted answer here, it is answered concisely in the Python docs:This code:works, but this code:results in an UnboundLocalError.This is because when you make an assignment to a variable in a scope,  that variable becomes local to that scope and shadows any similarly  named variable in the outer scope. Since the last statement in foo  assigns a new value to x, the compiler recognizes it as a local  variable. Consequently when the earlier print(x) attempts to print the  uninitialized local variable and an error results.In the example above you can access the outer scope variable by  declaring it global:You can do a similar thing in a nested scope using the nonlocal  keyword:


Answer URL
https://docs.python.org/3/faq/programming.html#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value
