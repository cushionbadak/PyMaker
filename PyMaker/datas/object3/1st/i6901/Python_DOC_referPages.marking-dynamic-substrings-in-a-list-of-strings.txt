Natural Text
Assume these two sets of strings:I need to run a function on both these sets separately and receive the following output respectively:The dataset can be any set of strings. It doesn't have to match the format. Here's another example for instance:For which the expected output would be:Basically, I need a function to analyze a set of strings and replace the uncommon substring with an asterisk(*)
you could use os.path.commonprefix to compute the common prefix. It is used to compute shared directories in a list of filepaths, but it can be used in a generic context.Then reverse the strings, and apply common prefix again, then reverse, to compute common suffix (adapted from https://gist.github.com/willwest/ca5d050fdf15232a9e67)result:EDIT: as wim noted:when all strings are equal, common prefixes & suffixes are the same, but it should return the string itself instead of prefix*suffix: should check if all strings are the samewhen common prefix & suffixes overlap/have shared letters, this confuses the computation as well: should compute common suffix on the string minus the common prefixSo a all-in-one method is required to test the list beforehand to make sure that at least 2 strings are different (condensing the prefix/suffix formula in the process), and compute common suffix with slicing to remove common prefix:now let's test this:result:(when dataset is empty, code returns *, maybe that should be another edge case)
This problem is trickier than it seems at face value.As currently specified, the question remains poorly constrained, i.e. there is not a unique solution.  For input ['spamAndEggs', 'spamAndHamAndEggs'], both spam*AndEggs and spamAnd*Eggs are valid answers.  For input ['aXXXXz', 'aXXXz'] there are four possible solutions.  In the code given above, we prefer choosing the longest possible prefix in order to make the solution unique.Credit to JFF's answer for pointing out the existence of os.path.commonprefix. Inverse glob - reverse engineer a wildcard string from file names is a related and more difficult generalisation of this question.


Answer URL
https://docs.python.org/3/library/os.path.html#os.path.commonprefix
