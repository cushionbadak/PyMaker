Natural Text
I have two threads. The first one (update_ds()) gets data from server and store in a global variable(ds). The second thread (ldk_modes()) uses the data from the first thread and do things accordingly. It's something like this:My first question is, my print out from update_ds() does not print every second. The do_something() or do_something_else() also do not respond to server data update quickly (I guess it's ultimately the result that the update_ds() thread did not update every second). Why?Earlier, I have another version of the code:I have the same problem that print(ds) does not execute every second. However, if I do "ctrl+c", although I wasn't able to terminate the program, I was able to get print(ds) to print every second! Why? and what's the proper way of terminating the program? For now, I'm use sudo kill processID, and it is a little inconvenient.Lastly, what's the difference betweenandBoth will create a thread that runs infinitely, is one better than the other? Thanks!
I'm not sure Timer is appropriate here.  Better to just use two different Thread instances, and include a time.sleep(1) when you want a 1-second pause before a recursive call. (Or, use a loop instead of recursion, where you build and take down a new Thread on each iteration.)Even given this setup, race conditions may play havoc with synchronization.  It's not exactly clear what kind of guarantees you need, but if you want to ensure one Thread has control, consider using a Lock or Condition.Here's a short demonstration showing the unreliability of threaded processes, using a similar invocation of global as in your original example.  Brief description:The foo() thread will stop when new_x crosses a given threshold.  The bar() thread will also stop upon reaching a certain inequality.     bar() makes its comparison using new_x, a value updated in foo().  foo() notes the time elapsed since its last run (to address you concern about running once every second).While the output will differ on each run, below is some example output, where you can see that, without any kind of lock in place, it's not at all clear which function has control at any given point in time.  Now run:Output:Incidentally, note that with Timer you're not guaranteed to get exactly a one-second interval, even if you specify it!  From the docs:The interval the timer will wait before executing its action may not be exactly the same as the interval specified by the user.


Answer URL
https://docs.python.org/3/library/threading.html#thread-objects
https://docs.python.org/3/library/threading.html#threading.Lock
https://docs.python.org/3/library/threading.html#condition-objects
https://docs.python.org/3/library/threading.html#timer-objects
https://docs.python.org/3/library/queue.html#module-queue
