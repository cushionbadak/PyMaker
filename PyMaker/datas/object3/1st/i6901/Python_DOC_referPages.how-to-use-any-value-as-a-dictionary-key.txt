Natural Text
I'd like to use instances of any type as a key in a single dict.The above won't work because my_list and my_object can't be hashed.My first thought was to just pass in the id value of the object using the id() function.However, that won't work because id('some string') == id('some string') is not guaranteed to always be True.My second thought was to test if the object has the __hash__ attribute. If it does, use the object, otherwise, use the id() value.However, since hash() and id() both return int's, I believe I will eventually get a collision.How can I write add_to_dict(obj, d) above to ensure that no matter what obj is (list, int, str, object, dict), it will correctly set the item in the dictionary and do so without collision?
We could make some kind of dictionary that allows us to insert mutable objects as well:This works as follows: the DictionaryMutable consists out of a dictionary and a list. The dictionary contains the hashable immutable keys, the list contains sublists where each sublist contains two elements: a key and a value.For each lookup we first attempt to perform a lookup on the dictionary, in case the key name is unhashable, a TypeError will be thrown. In that case we iterate through the list, check if one of the keys matches and return the corresponding value if it does. If no such element exists, we raise a KeyError.Setting elements works approximately the same way: first we attempt to set the element in the dictionary. If it turns out the key is unhashable, we search linearly through the list and aim to add the element. If that fails, we add it at the end of the list.This implementation has some major disadvantages:if the dictionary lookup fails due to the key being unhashable, we will perform linear lookup, this can siginificantly slow down the lookup; andif you alter an object that is in the dictionary, then the key will be updated, and thus a search for that object will fail. It thus can result in some unpredicted behavior.This is only a basic implementation. For instance __iter__, etc. need to be implemented as well.
Instead of the id() of the object, you could use the pickled byte stream representation of the object pickle.dumps() returns for it. pickle works with most built-in types, and there are ways to extend it to work with most values it doesn't know how to do automatically. Note: I used the repr() of the object as its "arbitrary value" in an effort to make it easier to identify them in the output displayed.Output:


Answer URL
https://docs.python.org/3/library/pickle.html#pickle.dumps
