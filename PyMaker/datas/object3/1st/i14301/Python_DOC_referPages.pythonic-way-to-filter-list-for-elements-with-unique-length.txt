Natural Text
I want to filter a list, leaving only first elements with unique length.I wrote a function for it, but I believe there should be a simpler way of doing it:
If you just want any arbitrary string for each length, in arbitrary order, the easy way to do this is to first convert to a dict mapping lengths to strings, then just read off the values:If you want the first for each length, and you need to preserve the order, then that's just unique_everseen from the itertools recipes, with len as the key:(If you pip install more-itertools, it includes all of the recipes from the itertools docs, plus a bunch of other helpful things.)
Getting the first item of the list with unique length (not necessarily in the same order as they appear in the list).Respecting the order of the original list, you can use an auxiliary set:For the above expression to work properly in succession, you have to make sure you reset seen to an empty set each time.
A not very elegant way would be:As you can see the, interpreter prints [None, None, None] because the line where we append to filtered actually produces a list of None values (the append method always returns None), which is then discarded. But that line has the side effect of populating filtered with the right values.
Simple way, using just built-ins:This will give you O(n * log(n)) complexity.As the sorted is stable, the ordering between equal-length strings will be the same as it was before sorting. Then the reduce function will leave only the first occurrence from each length.
List comprehensions are a good way to make your code more pythonic. Here's a good explanation of how they work:  List Comprehensions. So an example for how to do the above might be something like:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools-recipes
