Natural Text
I'm having headache trying to understand the cyclic relationship that exit between the metaclass type, the object class, and the class type.I'm trying to understand how python makes everything an object.is it because everything is an instance of the metaclass type or is it because everything is a subclass of object class.if its because of being subclass of object class, does that mean if the class object was named class pyobj. Would that mean that everything in Python starts with pyobj?I know objects created by metaclass are types/classes, this types are then used to create other object.From this:Is it safe to say that python creates the class object first using the type metaclass (I'm simplifying the metaclass for brevity).which implies class object is a class of class type and it does not inherit any attributes other class.Then it creates the class type:implying type class is class of class type and it inherits attributes from the object class.Then creates the other classes by inheriting from the class objectwhich similar to creating an Animal class as :Does this mean the metaclass used to create the class object is still the one used to create this Animal class or is the metaclass type used by default ? Which type is being used, is it the metaclass type or the type class that was created after object was created ? Where does the class type created with the base class object come into play ?I have also tried to understand what really is going on between the object and the class from all he responses above and in this article http://www.cafepy.com/article/python_types_and_objects/python_types_and_objects.htmlI'm still getting confused. What is the relation between this two class in terms of object creation?Will I ever get this or is it a chicken and egg situation?
Python's core types really do have a chicken and egg situation going on. type inherits from object, but object is an instance of type.You can't really reason about which of object or type is defined first in Python, because in regular Python code you could not set up their relationship. The Python interpreter gets to do it by fiddling with the internals before the environment is set up, so it doesn't matter if the types are not completely defined up front.In your example where you call type to create new object and type types, you're not actually getting objects that are equivalent to the real type and object, as your new object type is an instance of the builtin type metaclass, not the hand-made type metaclass you create later.Here's an illustration of roughly how the interpreter goes about it. The code doesn't actually work, since you can't create a new-style class without inheriting from object, nor can you reassign a type object's __class__ attribute (to make object an instance of type). If you could, you could start up your own independent type system!


Answer URL
https://docs.python.org/3/reference/datamodel.html#customizing-class-creation
