Natural Text
I'm trying to write a program to look for a number, n, between 0 and 100 such that n! + 1 is a perfect square. I'm trying to do this because I know there are only three so it was meant as a test of my Python ability - I failed because I really can't do it.
For very large numbers it's better to avoid using floating point square roots altogether because you will run into too many precision issues and you can't even guarantee that you will be within 1 integer value of the correct answer. Fortunately Python natively supports integers of arbitrary size, so you can write an integer square root checking function, like this:Then you can run through the integers from 0 to 100 like this:
math.sqrt always returns a float, even if that float happens to be, say, 4.0. As the docs say, "Except when explicitly noted otherwise, all return values are floats."So, your test for type(math.sqrt(x)) == int will never be true.You could try to work around that by checking whether the float represents an integer, like this:There's even a built-in method that does this as well as possible:But keep in mind that float values are not a perfect representation of real numbers, and there are always rounding issues. For example, for a too-large number, the sqrt might round to an integer, even though it really wasn't a perfect square. For example, if math.sqrt(10000000000**2 + 1).is_integer() is True, even though obviously the number is not a perfect square.I could tell you whether this is safe within your range of values, but can you convince yourself? If not, you shouldn't just assume that it is.So, is there a way we can check that isn't affected by float roading issues? Sure, we can use integer arithmetic to check:But, as Stefan Pochmann points out, even if this check is safe, does that mean the whole algorithm is? No; sqrt itself could have already been rounded to the point where you've lost integer precision.So, you need an exact sqrt. You could do this by using decimal.Decimal with a huge configured precision. This will take a bit of work, and a lot of memory, but it's doable. Like this:But how many digits is ENOUGH_DIGITS? Well, how many digits do you need to represent 100!+1 exactly?So:If you think about it, there's a way to reduce the needed precision to 79 digits, but I'll leave that as an exercise for the reader.The way you're presumably supposed to solve this is by using purely integer math. For example, you can find out whether an integer is a square in logarithmic time just by using Newton's method until your approximation error is small enough to just check the two bordering integers.
Here's another version working only with integers, computing the square root by adding decreasing powers of 2, for example intsqrt(24680) will be computed as 128+16+8+4+1.
The number math.sqrt returns is never an int, even if it's an integer.How to check if a float value is a whole number


Answer URL
https://docs.python.org/3/library/math.html#math.sqrt
https://docs.python.org/3/library/stdtypes.html#float.is_integer
