Natural Text
This question already has an answer here:How to use timeit module                    14 answers                I'd like to measure the time of running for two codes, I tried looking up the python documentation for timeit, but I didn't really understand. Could someone explain in a more beginner-level vocabulary? 
Note: Copied to How to use timeit module.I'll let you in on a secret: the best way to use timeit is on the command line.On the command line, timeit does proper statistical analysis: it tells you how long the shortest run took. This is good because all error in timing is positive. So the shortest time has the least error in it. There's no way to get negative error because a computer can't ever compute faster than it can compute!So, the command-line interface:That's quite simple, eh?You can set stuff up:which is useful, too!If you want multiple lines, you can either use the shell's automatic continuation or use separate arguments:That gives a setup ofand timesIf you want to have longer scripts you might be tempted to move to timeit inside a Python script. I suggest avoiding that because the analysis and timing is simply better on the command line. Instead, I tend to make shell scripts:This can take a bit longer due to the multiple initialisations, but normally that's not a big deal.But what if you want to use timeit inside your module?Well, the simple way is to do:and that gives you cumulative (not minimum!) time to run that number of times.To get a good analysis, use .repeat and take this min:You should normally combine this with functools.partial instead of lambda: ... to lower overhead. Thus you could have something like:You can also do:which would give you something closer to the interface from the command-line, but in a much less cool manner. The "from __main__ import ..." lets you use code from your main module inside the artificial environment created by timeit.It's worth noting that this is a convenience wrapper for Timer(...).timeit(...) and so isn't particularly good at timing. I personally far prefer using Timer as I've shown above.WarningsThere are a few caveats with timeit that hold everywhere.Overhead is not accounted for. Say you want to time x += 1, to find out how long addition takes:Well, it's not 0.0476 Âµs. You only know that it's less than that. All error is positive.So try and find pure overhead:That's a good 30% overhead just from timing! This can massively skew relative timings. But you only really cared about the adding timings; the look-up timings for x also need to be included in overhead:The difference isn't much larger, but it's there.Mutating methods are dangerous.But that's completely wrong! x is the empty list after the first iteration. You'll need to reinitialize:But then you have lots of overhead. Account for that separately.Note that subtracting the overhead is reasonable here only because the overhead is much a small-ish fraction of the time.
I find IPython's %timeit and %%timeit magic functions to be easier to use than timeit.timeit (particularly when using the ipython notebook). A couple of examples here.
Suppose that's the command you'd like to run.Import timeit. Make the command a string, add how many times you'd like to run it.  DocumentationIs this doc really incomprehensible? I find it lucid clear.


Answer URL
