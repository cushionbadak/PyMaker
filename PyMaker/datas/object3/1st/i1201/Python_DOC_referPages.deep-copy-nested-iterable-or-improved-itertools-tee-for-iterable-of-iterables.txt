Natural Text
PrefaceI have a test where I'm working with nested iterables (by nested iterable I mean iterable with only iterables as elements). As a test cascade considerE.g. foo may be simple identity functionand contract is simply checks that flattened iterables have same elementsBut if some of nested_iterable elements is an iterator, it may be exhausted since tee is making shallow copies, not deep ones, i.e. for given foo and is_contract_satisfied next statementleads to predictableProblemHow to deep copy an arbitrary nested iterable?NoteI'm aware of copy.deepcopy function, but it won't work for file objects.
Naive solutionStraightforward algorithm would be Perform elementwise copying of original nested iterable.Make n copies of elementwise copy.Obtain coordinates related to each independent copy.which may be implemented likePros:quite easy to read & explain.Cons:if we wanted to extend our approach for iterables with greater nesting level (like iterable of nested iterables and so on) this approach doesn't look helpful.We can do better.Improved solutionIf we look at itertools.tee function documentation, it contains Python recipe, which with help of functools.singledispatch decorator can be rewritten likePros:handles nesting on deeper levels or even mixed elements like both iterables and non-iterables on the same level,may be extended for user-defined structures (e.g. for making independent deep copies of them).Cons:less readable (but as we know "practicality beats purity"),provides some overhead related to dispatching (but it's ok since it is based on dictionary lookup which has O(1) complexity).TestPreparationLet's define our nested iterable as followsSince iterators creation says nothing about underlying copies performance, let's define function for iterators exhausting (described here)TimeUsing timeit packageI have on my laptop with Windows 10 x64 in Python 3.5.4MemoryUsing memory_profiler packagefor "naive" approach andfor "improved" one.Note: I've made different runs of script because making them at once won't be representative since second statement will reuse previously created under-the-hood int objects.ConclusionAs we can see both functions have similar performance, but the last one supports deeper levels of nesting and looks pretty extensible.AdvertisementI've added "improved" solution to lz package from 0.4.0 version which can be used likeIt is property-based tested using hypothesis framework, so we may be sure that it works as expected.
Addressing your question: How to deep copy a nested iterable?You can use deepcopy from the standard library:Update@Azat Ibrakov said: you are working with sequences, try to deepcopy a file object for example (hint: it will fail)No, deepcopy on a file object, won't fail, you can deep copy a file object, demonstration:Prints:The problem is in the concept.According to Python Iterator protocol, the items contained by some container are obtained executing the next function see the docs here.You won't have all items of an object that implements the iterator protocol (as file objects) until you traverse the whole iterator (execute next() until StopIteration exception is raised).That's because there is no way you can tell for sure the result of executing the next (__next__ for Python 2.x) method of an iteratorSee the following example:Again you could:A file object is an especial case here, there are file handlers involved, before, you see you can deepcopy a file object, but it will have closed state.Alternative.You could call list on your iterables, that will automatically evaluate iterables an then you will be able to test again THE ITERABLE'S CONTENT. Returning to files:So, resumingYou can deepcopy nested iterables but, you can't evaluate iterables while they are being copied, it just has no sense (remember RandomNumberIterator). If you need to test on the iterables CONTENT you need to evaluate them.


Answer URL
https://docs.python.org/3/library/copy.html#copy.deepcopy
https://docs.python.org/3/library/itertools.html#itertools.tee
https://docs.python.org/3/library/functools.html#functools.singledispatch
