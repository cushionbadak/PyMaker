Natural Text
I come across this code from one of my friends. It is a test for overiding comparison methods in Python. When i ran the code i got this: TrueTrueTrueand this: "TypeError: '<' not supported between instances of 'A' and 'B'"If that is the case, why the same error did not happen with "a1 == b1"? 
You don't need to implement __lt__ on A if comparison doesn't make sense for A normally; B can do all the heavy lifting for comparisons between A and B, but you need to implement the reflected comparison operators for this to work.The problem here is that A doesn't implement __lt__, so Python will execute a3 < b3 by using the reflected operator from B, making the line test b3 > a3. But you didn't implement __gt__ in B, so there is no way to reflect the operation.The simplest fix (recommended in general if you implement any of the comparison operations) is to use functools.total_ordering to expand the single implemented operator to the whole rich comparison suite:That's it; your code will just work, as that decoration will ensure __gt__ is defined in terms of __lt__/__eq__, so the attempt to flip the comparison will succeed.You could equivalently define each of the operations one by one, e.g.:but that's tedious and error-prone; use functools.total_ordering.The == test worked just fine because equality is reflexive, so the same overload works in either direction when the other operand doesn't implement it; Python tries a.__eq__(b) and finds it doesn't work, so it tries b.__eq__(a), since a == b is logically equivalent to b == a. It's only rich comparisons where the reflected operation uses a different method.
You need to define __lt__ in class A too:And, of course, the same will remain true for the rest of operators. The reason of why that happens is because in b < a the method called is B.__lt__ and in a < b the method called is A.__lt__. The former method is defined but not the latter.Btw, you were calling A's contructor in B's constructor. I assume that you want a B to be also an A, so B inherits from A. Thats the reason why my code says class B(A).
So I changed you code to add print statements to the __eq__ method, like so:and the results were this:So even though you only wrote a __eq__ method for the B class, it was used when comparing in the reversed order, a == b. This (I believe) is a feature of the Python language that assumes equality operators are reflexive, i.e. a == b and b == a should have the same result.However, this property does not apply to the __lt__ operator in this case, because a < b is different from b < a.


Answer URL
https://docs.python.org/3/library/functools.html#functools.total_ordering
