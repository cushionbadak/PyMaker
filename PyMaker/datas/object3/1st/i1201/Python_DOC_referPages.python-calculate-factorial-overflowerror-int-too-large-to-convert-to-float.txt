Natural Text
I want to write a function that calculate (1 / n!) * (1! + 2! + 3! + ... + n!) with n as the parameter of the function, also the result is truncated to 6 decimals (not rounded).Below is my code:When I passed the argument 171 into the function, I got the following traceback:How can I fix this problem? Thanks a lot for help!--update--Sorry that I didn't clarify: I'm doing this problem in Codewars and I don't think I can import any libraries to use. So, I need a solution that can avoid using any libraries.Original problem from Codewars:Consider the following numbers (where n! is factorial(n)):Which will win: 1 / n! or (1! + 2! + 3! + ... + n!)?Are these numbers going to 0 because of 1/n! or to infinity due to the sum of factorials?TaskCalculate (1 / n!) * (1! + 2! + 3! + ... + n!) for a given n, where n is an integer greater or equal to 1.To avoid discussions about rounding, return the result truncated to 6 decimal places, for example:1.0000989217538616 will be truncated to 1.0000981.2125000000000001 will be truncated to 1.2125RemarkKeep in mind that factorials grow rather rapidly, and you need to handle large inputs.
@PaSTE's suggestion to use gmpy2 is great, and should work fine.The library mpmath is built on top of gmpy2 and provides the function ff (falling factorial) that makes the implementation a little more concise:For example,(I left out the truncating of the digits.  That's something that you can add as you see fit.)Another standard technique for handling very large numbers is to work with the logarithms of the numbers instead of the numbers themselves.  In this case, you can use math.lgamma to compute k!/n! as exp(lgamma(k+1) - lgamma(n+1)).  This will allow you to compute the value using just the standard math library.For example,Finally, if you don't want to use even the standard library, you could avoid the large numbers another way.  Rewrite the expression asThat leads to this implementation:For example,
And going(170) works as intended, right?What you are seeing is a fundamental limitation of how your computer represents floating point numbers, and not a problem with Python per se.  In general, most modern computers use  IEEE 754 to represent and perform math with non-integer numbers.  Specifically, numbers using IEEE 754's "binary64" (double-precision) floating point representation has a maximum value of 2^1023 × (1 + (1 − 2^−52)), or approximately 1.7976931348623157 × 10^308.  It turns out that 170! ≈ 7.2 × 10^306, which is just under the maximum value.  However, 171! ≈ 1.2 × 10^309, so you are out of luck.The best chance you have of actually performing calculations with numbers that large without running into these overflow errors or losing precision is to use a large number library like gmpy2 (see this previous answer).  A possible solution would be:


Answer URL
https://docs.python.org/3/library/math.html#math.lgamma
