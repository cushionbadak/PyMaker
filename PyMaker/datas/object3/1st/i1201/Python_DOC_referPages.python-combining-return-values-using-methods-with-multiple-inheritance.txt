Natural Text
I have the following two superclasses:I would like to have a child class that inherits from both be able to call super for both parents.What is the Pythonic way to do this? Thanks.
Exec summary:Super only executes one method based on the class hierarchy's __mro__. If you want to execute more than one method by the same name, your parent classes need to written to cooperatively do that (by calling super implicitly or explicitly) or you need to loop over __bases__ or the __mro__ values of the child classes.The job of super is to delegate part or all of a method call to some existing method in the classes ancestor tree. The delegation may go well outside of classes that you control. The method name delegated needs to exist in the group of base classes.The method presented below using __bases__ with try/except is closest to a complete answer to your question of how to call each parent's method of the same name.super is useful in the situation where you want to call one of your parent's methods, but you don't know which parent:In this case, Child has three immediate parents. Only one, Parent3, has an on_start method. Calling super resolves that only Parent3 has on_start and that is the method that is called. If Child inherits from more than one class that has an on_start method, the order is resolved left to right (as listed in the class definition) and bottom to top (as logical inheritance). Only one of the methods is called and the other methods of the same name in the hierarchy of classes have been superseded.So, more commonly:If you want to call multiple parents methods by method name, you can use __bases__ instead of super in this case and iterate over the base classes of Child without knowing the classes by name:If there is a possibility one of the base classes does not have on_start you can use try/except:Using __bases__ will act similar to super but for each class hierarchy defined in the Child definition. ie, it will go though each forbearer class until on_start is satisfied once for each parent of the class:Now imagine a more complex inheritance structure:If you want each and every forbearer's on_start method, you could use __mro__ and filter out the classes that do not have on_start as part of their __dict__ for that class. Otherwise, you will potentially get a forbearer's on_start method. In other words, hassattr(c, 'on_start') is True for every class that Child is a descendant from (except object in this case) since Ghengis has an on_start attribute and all classes are descendant classes from Ghengis. ** Warning -- Demo Only ** But this also has a problem -- if Child is further subclassed, then the child of Child will also loop over the same __mro__ chain. As stated by Raymond Hettinger:super() is in the business of delegating method calls to some class in  the instance’s ancestor tree. For reorderable method calls to work,  the classes need to be designed cooperatively. This presents three  easily solved practical issues:1) the method being called by super() needs to exist 2) the caller and callee need to have a matching argument signature and 3) every occurrence of the method needs to use super()The solution is to write cooperative classes that uniformly use super through the ancestor list or creative use of the adapter pattern to adapt classes you cannot control. These methods are discussed more completely in the article Python’s super() considered super! by Raymond Hettinger. 
Or without super:
In your case, since both of the parents implements the same method, super will just be the same as the first parent inherited, from left to right (for your code, Parent1). Calling two functions with super is impossible. To do what you want, you must simply call the method from the parent class, as follows:


Answer URL
https://docs.python.org/3/library/functions.html#super
