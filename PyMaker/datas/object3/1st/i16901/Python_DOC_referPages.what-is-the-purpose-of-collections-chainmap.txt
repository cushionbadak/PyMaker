Natural Text
In Python 3.3 a ChainMap class was added to the collections module:A ChainMap class is provided for quickly linking a number of mappings  so they can be treated as a single unit. It is often much faster than  creating a new dictionary and running multiple update() calls.Example:It was motivated by this issue and made public by this one (no PEP was created).As far as I understand, it is an alternative to having an extra dictionary and maintaining it with update()s.The questions are:What use cases does ChainMap cover?Are there any real world examples of ChainMap? Is it used in third-party libraries that switched to python3?Bonus question: is there a way to use it on Python2.x?I've heard about it in Transforming Code into Beautiful, Idiomatic Python PyCon talk by Raymond Hettinger and I'd like to add it to my toolkit, but I lack in understanding when should I use it. 
I like @b4hand's examples, and indeed I have used in the past ChainMap-like structures (but not ChainMap itself) for the two purposes he mentions: multi-layered configuration overrides, and variable stack/scope emulation.I'd like to point out two other motivations/advantages/differences of ChainMap, compared to using a dict-update loop, thus only storing the "final" version":More information: since a ChainMap structure is "layered", it supports answering question like: Am I getting the "default" value, or an overridden one? What is the original ("default") value? At what level did the value get overridden (borrowing @b4hand's config example: user-config or command-line-overrides)? Using a simple dict, the information needed for answering these questions is already lost.Speed tradeoff: suppose you have N layers and at most M keys in each, constructing a ChainMap takes O(N) and each lookup O(N) worst-case[*], while construction of a dict using an update-loop takes O(NM) and each lookup O(1). This means that if you construct often and only perform a few lookups each time, or if M is big, ChainMap's lazy-construction approach works in your favor.[*] The analysis in (2) assumes dict-access is O(1), when in fact it is O(1) on average, and O(M) worst case. See more details here.
I could see using ChainMap for a configuration object where you have multiple scopes of configuration like command line options, a user configuration file, and a system configuration file. Since lookups are ordered by the order in the constructor argument, you can override settings at lower scopes. I've not personally used or seen ChainMap used, but that's not surprising since it is a fairly recent addition to the standard library.It might also be useful for emulating stack frames where you push and pop variable bindings if you were trying to implement a lexical scope yourself.The standard library docs for ChainMap give several examples and links to similar implementations in third-party libraries. Specifically, it names Djangoâ€™s Context class and Enthought's MultiContext class.
I'll take a crack at this:Chainmap looks like a very just-so kind of abstraction.  It's a good solution for a very specialized kind of problem.  I propose this use case. If you have:multiple mappings (e.g, dicts)some duplication of keys in those mappings (same key can appear in multiple mappings, but not the case that all keys appear in all mappings)a consuming application which wishes to access the value of a key in the "highest priority" mapping where there is a total ordering over all the mappings for any given key (that is, mappings may have equal priority, but only if it is known that there are no duplications of key within those mappings) (In the Python application, packages can live in  the same directory (same priority) but must have different names, so, by definition, the symbol names in that directory cannot be duplicates.)the consuming application does not need to change the value of a keywhile at the same time the mappings must maintain their independent identity and can be changed asynchronously by an external forceand the mappings are big enough, expensive enough to access, or change often enough between application accesses, that the cost of computing the projection (3) each time your app needs it is a significant performance concern for your application...Then, you might consider using a chainmap to create a view over the collection of mappings. But this is all after-the-fact justification.  The Python guys had a problem, came up with a good solution in the context of their code, then did some extra work to abstract their solution so we could use it if we choose.  More power to them.  But whether it's appropriate for your problem is up to you to decide.
To imperfectly answer your:Bonus question: is there a way to use it on Python2.x?However keep in mind that this isn't a real ChainMap, it inherits from DictMixin and only defines:Its implementation also doesn't seem particularly efficient.


Answer URL
https://docs.python.org/3/library/collections.html#collections.ChainMap
https://docs.python.org/3/library/collections.html
https://docs.python.org/3/library/stdtypes.html#dict.update
