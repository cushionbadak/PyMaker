Natural Text
This program:prints this:It is a result of the difference between container.__iter__ and iterator.__iter__. Both are documented here: https://docs.python.org/3/library/stdtypes.html#typeiter. If the __iter__ returns a new iterator each time, we see two repeating lines. And if it returns the same iterator each time, we see just one line, beacuse the iterator is exhausted after that.My question is why it was decided to implement generator expressions not similar to other objects that seem to be equivalent or at least very similar?Here is another example that generator expressions are different than other similar types which may lead to unexpected outcome.output:
A generator runs arbitrary code, and returns a lazy sequence with the items yielded by that code.That code could be providing an infinite sequence.That code could be reading contents off a network connection.That code could be modifying external variables every time it iterates.Thus, you can't cache the results safely in the general case: If it's an infinite sequence, you'd run out of memory.You also can't simply rerun the code when it's read from again: If it's reading off a network connection, then the connection may no longer be there again in the future (or may be in a different state). Similarly, if the code is modifying variables outside the genexp's scope, then that state would be changed in hard-to-predict ways based on the readers' behavior -- an undesirable propery for a language that values predictability and readability.Some other languages (notably Clojure) do implement generators (there, generalized as "lazy sequences") that cache results if and only if a reference to the beginning of the sequence is retained. This gives the programmer control, but at a cost of complexity: You need to know exactly what is and is not referenced for the garbage collector.The decision not to do this for Python is entirely reasonable and in keeping with the language's design goals.
My question is why it was decided to implement generator expressions not similar to other objects that seem to be equivalent or at least very similar?Because that's exactly what a generator is, if you make it similar to other iterables you have to preserve all the items in memory and then what you have is not a generator any more.The main benefit of using generators is that they doesn't consume the memory and just generate the items on demand, and this makes them to be one shot iterables, because otherwise if you want to be able to iterate over them multiple times you have to preserve them in memory. 


Answer URL
https://docs.python.org/3/library/stdtypes.html#typeiter
