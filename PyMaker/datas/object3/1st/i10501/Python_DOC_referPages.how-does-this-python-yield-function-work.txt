Natural Text
output:0  None  None  What i thought is:genr=func() return a generator, but does not actually run it.First print(next(genr)) run from the begining of func to yield output, but not yet assign back to new,so output 0 make sense.  Second print(next(genr)) start from assigning output back to newï¼Œand next line output = new make both output and new to 0, next execute yield output should return 0, but why it return None actually?
A yield statement is used like return to return a value but it doesn't destroy the stack frame (the part of a function that knows the current line, local variables, and pending try-statements).  This allows the function to be resumed after the yield.When you call a function containing yield, it returns a "generator" that allows you to run code up to a yield and then to resume it from where it left off.Interestingly, a generator can accept values using the send() method.  To prime the pump for such a generator the first call should be next().What you've figured-out in your example is that next(g) is really the same as g.send(None).Here's what the docs have to say:The value of the yield expression after resuming depends on the method  which resumed the execution. If __next__() is used (typically via  either a for or the next() builtin) then the result is None.  Otherwise, if send() is used, then the result will be the value passed  in to that methodHere's a session that makes all of that visible:Hope that explains all the mysteries from first principles :-)
The result of a yield expression is the value sent in by the generator.send() function, and next(gen) is equivalent to gen.send(None). So new receives the value None each time you call next(). If you do this instead:you'll get this output:


Answer URL
https://docs.python.org/3/reference/expressions.html#yieldexpr
https://docs.python.org/3/reference/expressions.html#generator.send
