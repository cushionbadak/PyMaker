Natural Text
The function glib.spawn_async allows you to hook three callbacks which are called on event on stdout, stderr, and on process completion.How can I mimic the same functionality with subprocess with either threads or asyncio?I am more interested in the functionality rather than threading/asynio but an answer that contains both will earn a bounty.Here is a toy program that shows what I want to do:I should add that since readlines() is blocking, the above will buffer all the output and send it at once. If this is not what one wants, then you have to use readline() and make sure that on end of command you finish reading all the lines you did not read before.
asyncio has subprocess_exec, there is no need to use the subprocess module at all:With subprocess and threading, it's simple as well. You can just spawn a thread per pipe, and one to wait() for the process:However, mind that glib does not use threads to asynchroneously execute your callbacks. It uses an event loop, just as asyncio does. The idea is that at the core of your program is a loop that waits until something happens, and then synchronously executes an associated callback. In your case, that's "data becomes available for reading on one of the pipes", and "the subprocess has exited". In general, its also stuff like "the X11-server reported mouse movement", "there's incoming network traffic", etc. You can emulate glib's behaviour by writing your own event loop. Use the select module on the two pipes. If select reports that the pipes are readable, but read returns no data, the process likely exited - call the poll() method on the subprocess object in this case to check whether it is completed, and call your exit callback if it has, or an error callback elsewise.


Answer URL
https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.AbstractEventLoop.subprocess_exec
https://docs.python.org/3/library/select.html?highlight=select#module-select
