Natural Text
(Note: The background for this problem is pretty verbose, but there's an SSCCE at the bottom that can be skipped to)BackgroundI'm trying to develop a Python-based CLI to interact with a web service. In my codebase I have a CommunicationService class that handles all direct communication with the web service. It exposes a received_response property that returns an Observable (from RxPY) that other objects can subscribe to in order to be notified when responses are received back from the web service.I've based my CLI logic on the click library, where one of my subcommands is implemented as below:What's happening here (in the case that response_handler is not None) is that the subcommand is behaving as a coroutine that awaits responses from the web service (self.on_response ==  CommunicationService.received_response) and returns some processed value from the first response it can handle.I'm trying to test the behaviour of my CLI by creating test cases in which CommunicationService is completely mocked; a fake Subject is created (which can act as an Observable) and CommunicationService.received_response is mocked to return it. As part of the test, the subject's on_next method is invoked to pass mock web service responses back to the production code:I use a click 'result callback' function that gets invoked at the end of the CLI invocation and blocks until the coroutine (the subcommand) is done:ProblemAt the start of the test, I run CliRunner.invoke to fire off the whole shebang. The problem is that this is a blocking call and will block the thread until the CLI has finished and returned a result, which isn't helpful if I need my test thread to carry on so it can produce mock web service responses concurrently with it.What I guess I need to do is run CliRunner.invoke on a new thread using ThreadPoolExecutor. This allows the test logic to continue on the original thread and execute the @when step posted above. However, notifications published with mock_received_response_subject.on_next do not seem to trigger execution to continue within the subcommand.I believe the solution would involve making use of RxPY's AsyncIOScheduler, but I'm finding the documentation on this a little sparse and unhelpful.SSCCEThe snippet below captures what I hope is the essence of the problem. If it can be modified to work, I should be able to apply the same solution to my actual code to get it to behave as I want.Current BehaviourThe program hangs when run, blocking at result = loop.run_until_complete(task).Acceptance CriteriaThe program terminates and prints foo on stdout.Update 1Based on Vincent's help I've made some changes to my code.Relay.enabled (the subcommand that awaits responses from the web service in order to process them) is now implemented like this:I wasn't quite sure how await would behave with RxPY observables - would they return execution to the caller on each element generated, or only when the observable has completed (or errored?). I now know it's the latter, which honestly feels like the more natural choice and has allowed me to make the implementation of this function feel a lot more elegant and reactive.I've also modified the test step that generates mock web service responses:Unfortunately, this will not work as it stands, since the CLI is being invoked in its own thread...And the CLI creates its own thread-private event loop when invoked...What I think I need is a way to allow my test steps to invoke the CLI on a new thread and then fetch the event loop it's using:Update 2There doesn't seem to be an easy way to get the event loop that a particular thread creates and uses for itself, so instead I took Victor's advice and mocked asyncio.new_event_loop to return an event loop that my test code creates and stores:I change my 'mock web response received' test step to do the following:The great news is that I'm actually getting the Relay.enabled coroutine to trigger when this step gets executed!The only problem now is the final test step in which I await the future I got from executing the CLI in its own thread and validate that the CLI is sending this on stdout:I've tried playing around with this but I can't seem to get context.async_result (which stores the future from loop.run_in_executor) to transition nicely to done and return the result. With the current implementation, I get an error for the first test (1.1) and indefinite hanging for the second (1.2):Chapter 3: FinaleScrew all this asynchronous multi-threaded stuff, I'm too dumb for it.First off, instead of describing the scenario like this...We describe it like this:Implement the new given step:BOOM
I can see two problems with your code:asyncio is not thread-safe, unless you use call_soon_threadsafe or run_coroutine_threadsafe. RxPy doesn't use any of those in Observable.to_future, so you have to access RxPy objects in the same thread that runs the asyncio event loop.RxPy sets the result of the future when on_completed is called, so that awaiting for an observable returns the last object emitted. This means you have to call both on_next and on_completed to get await to return.Here is a working example:


Answer URL
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.call_soon_threadsafe
https://docs.python.org/3/library/asyncio-task.html?highlight=run_coroutine#asyncio.run_coroutine_threadsafe
