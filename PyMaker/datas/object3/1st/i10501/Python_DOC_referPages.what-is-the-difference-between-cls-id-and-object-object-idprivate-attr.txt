Natural Text
Can someone please explain the exact meaning of having leading underscores before an object's name in Python? Also, explain the difference between a single and a double leading underscore. Also, does that meaning stay the same whether the object in question is a variable, a function, a method, etc.?
Single UnderscoreNames, in a class, with a leading underscore are simply to indicate to other programmers that the attribute or method is intended to be private.  However, nothing special is done with the name itself.To quote PEP-8:_single_leading_underscore: weak "internal use" indicator. E.g. from M import * does not import objects whose name starts with an underscore.Double Underscore (Name Mangling)From the Python docs:Any identifier of the form __spam (at least two leading underscores, at most one trailing underscore) is textually replaced with _classname__spam, where classname is the current class name with leading underscore(s) stripped. This mangling is done without regard to the syntactic position of the identifier, so it can be used to define class-private instance and class variables, methods, variables stored in globals, and even variables stored in instances. private to this class on instances of other classes. And a warning from the same page:Name mangling is intended to give classes an easy way to define “private” instance variables and methods, without having to worry about instance variables defined by derived classes, or mucking with instance variables by code outside the class. Note that the mangling rules are designed mostly to avoid accidents; it still is possible for a determined soul to access or modify a variable that is considered private.Example
Excellent answers so far but some tidbits are missing. A single leading underscore isn't exactly just a convention: if you use from foobar import *, and module foobar does not define an __all__ list, the names imported from the module do not include those with a leading underscore. Let's say it's mostly a convention, since this case is a pretty obscure corner;-).The leading-underscore convention is widely used not just for private names, but also for what C++ would call protected ones -- for example, names of methods that are fully intended to be overridden by subclasses (even ones that have to be overridden since in the base class they raise NotImplementedError!-) are often single-leading-underscore names to indicate to code using instances of that class (or subclasses) that said methods are not meant to be called directly.For example, to make a thread-safe queue with a different queueing discipline than FIFO, one imports Queue, subclasses Queue.Queue, and overrides such methods as _get and _put; "client code" never calls those ("hook") methods, but rather the ("organizing") public methods such as put and get (this is known as the Template Method design pattern -- see e.g. here for an interesting presentation based on a video of a talk of mine on the subject, with the addition of synopses of the transcript).
__foo__: this is just a convention, a way for the Python system to use names that won't conflict with user names._foo: this is just a convention, a way for the programmer to indicate that the variable is private (whatever that means in Python).__foo: this has real meaning: the interpreter replaces this name with _classname__foo as a way to ensure that the name will not overlap with a similar name in another class.No other form of underscores have meaning in the Python world.There's no difference between class, variable, global, etc in these conventions.
._variable is semiprivate and meant just for convention.__variable is often incorrectly considered superprivate, while it's actual meaning is just to namemangle to prevent accidental access[1].__variable__ is typically reserved for builtin methods or variablesYou can still access .__mangled variables if you desperately want to. The double underscores just namemangles, or renames, the variable to something like instance._className__mangledExample:t._b is accessible because it is only hidden by conventiont.__a isn't found because it no longer exists due to namemanglingBy accessing instance._className__variable instead of just the double underscore name, you can access the hidden value
Single underscore at the beginning:Python doesn't have real private methods. Instead, one underscore at the start of a method or attribute name means you shouldn't access this method, because it's not part of the API.(This code snippet was taken from django source code: django/forms/forms.py). In this code, errors is a public property, but the method this property calls, _get_errors, is "private", so you shouldn't access it.Two underscores at the beginning:This causes a lot of confusion. It should not be used to create a private method. It should be used to avoid your method being overridden by a subclass or accessed accidentally. Let's see an example:Output: Now create a subclass B and do customization for __test methodOutput will be....As we have seen, A.test() didn't call B.__test() methods, as we might expect. But in fact, this is the correct behavior for __. The two methods called __test() are automatically renamed (mangled) to _A__test() and _B__test(), so they do not accidentally override.  When you create a method starting with __ it means that you don't want to anyone to be able to override it, and you only intend to access it from inside its own class.Two underscores at the beginning and at the end:When we see a method like __this__, don't call it. This is a method which python is meant to call, not you. Let's take a look:There is always an operator or native function which calls these magic methods. Sometimes it's just a hook python calls in specific situations. For example __init__() is called when the object is created after __new__() is called to build the instance...Let's take an example...For more details, see the PEP-8 guide. For more magic methods, see this PDF.
Sometimes you have what appears to be a tuple with a leading underscore as in In this case, what's going on is that _() is an alias for a localization function that operates on text to put it into the proper language, etc. based on the locale. For example, Sphinx does this, and you'll find among the importsand in sphinx.locale, _() is assigned as an alias of some localization function.
If one really wants to make a variable read-only, IMHO the best way would be to use property() with only getter passed to it. With property() we can have complete control over the data.I understand that OP asked a little different question but since I found another question asking for 'how to set private variables' marked duplicate with this one, I thought of adding this additional info here.
Single leading underscores is a convention. there is no difference from the interpreter's point of view if whether names starts with a single underscore or not. Double leading and trailing underscores are used for built-in methods, such as __init__, __bool__, etc.Double leading underscores w/o trailing counterparts are a convention too, however, the class methods will be mangled by the interpreter. For variables or basic function names no difference exists.
Your question is good, it is not only about methods. Functions and objects in modules are commonly prefixed with one underscore as well, and can be prefixed by two.But __double_underscore names are not name-mangled in modules, for example. What happens is that names beginning with one (or more) underscores are not imported if you import all from a module (from module import *), nor are the names shown in help(module).
Here is a simple illustrative example on how double underscore properties can affect an inherited class. So with the following setup:if you then create a child instance in the python REPL, you will see the belowThis may be obvious to some, but it caught me off guard in a much more complex environment
“Private” instance variables that cannot be accessed except from inside an object don’t exist in Python. However, there is a convention that is followed by most Python code: a name prefixed with an underscore (e.g. _spam) should be treated as a non-public part of the API (whether it is a function, a method or a data member). It should be considered an implementation detail and subject to change without notice.referencehttps://docs.python.org/2/tutorial/classes.html#private-variables-and-class-local-references
Getting the facts of _ and __ is pretty easy; the other answers express them pretty well. The usage is much harder to determine. This is how I see it:Should be used to indicate that a function is not for public use as for example an API. This and the import restriction make it behave much like internal in c#.Should be used to avoid name collision in the inheritace hirarchy and to avoid latebinding. Much like private in c#.==> If you want to indicate that something is not for public use, but it should act like protected use _.If you want to indicate that something is not for public use, but it should act like private use __.This is also a quote that I like very much:The problem is that the author of a class may legitimately think "this  attribute/method name should be private, only accessible from within  this class definition" and use the __private convention. But later on,  a user of that class may make a subclass that legitimately needs  access to that name. So either the superclass has to be modified  (which may be difficult or impossible), or the subclass code has to  use manually mangled names (which is ugly and fragile at best).But the problem with that is in my opinion that if there's no IDE that warns you when you override methods, finding the error might take you a while if you have accidentially overriden a method from a base-class.
Since so many people are referring to Raymond's talk, I'll just make it a little easier by writing down what he said:The intention of the double underscores was not about privacy. The intention was to use it exactly like thisIt's actually the opposite of privacy, it's all about freedom. It makes your subclasses free to override any one method without breaking the others.Say you don't keep a local reference of perimeter in Circle. Now, a derived class Tire overrides the implementation of perimeter, without touching area. When you call Tire(5).area(), in theory it should still be using Circle.perimeter for computation, but in reality it's using Tire.perimeter, which is not the intended behavior. That's why we need a local reference in Circle.But why __perimeter instead of _perimeter? Because _perimeter still gives derived class the chance to override:Double underscores has name mangling, so there's a very little chance that the local reference in parent class get override in derived class. thus "makes your subclasses free to override any one method without breaking the others".If your class won't be inherited, or method overriding does not break anything, then you simply don't need __double_leading_underscore.
Great answers and all are correct.I have provided simple example along with simple definition/meaning. Meaning:some_variable --► it's public anyone can see this._some_variable --► it's public anyone can see this but it's a convention to indicate private...warning no enforcement is done by Python.__some_varaible  --► Python replaces the variable name with _classname__some_varaible (AKA name mangling) and it reduces/hides it's visibility and be more like private variable.Just to be honest here According to Python documentation "“Private” instance variables that cannot be accessed except from  inside an object don’t exist in Python"The example:


Answer URL
https://docs.python.org/3/tutorial/classes.html#private-variables
https://docs.python.org/3/tutorial/classes.html#tut-private
