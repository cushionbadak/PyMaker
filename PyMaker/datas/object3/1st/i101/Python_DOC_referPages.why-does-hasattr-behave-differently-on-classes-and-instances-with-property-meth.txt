Natural Text
I implemented a write-only property in my class with @property. The weird thing is that hasattr behaves differently on the class and corresponding instance with this property.From the result of getattr, getattr(u1, 'password') tries to execute the method and raises an error, while getattr(User, 'password') doesn't execute the @property method. Why do they behave differently?
Adding to what @timgeb mentioned, there is lot happening in the background than what it appears.Properties are implemented as Descriptors and the way attribute lookup happens is different when you access an attribute with object and class. When you access the attribute with object like obj.attr basically the rules for attribute lookup are as followsLooks inside __class__.__dict__ and see if this attribute is a data descriptor, if yes then the call the __get__, this translates to type(obj).__dict__['attr'].__get__(obj, type(obj)).Look in the __dict__ of the object and return obj.__dict__['attr']If the attribute is a non-data descriptor, call its __get__, this again translates to type(obj).__dict__['attr'].__get__(obj, type(obj)).Fetch the attribute from __dict__ of the class.Call the default implementation of getattr.Now when you try to access the same attribute with class.attr the same rules apply with a slight difference that this time metaclass of the class is also involved, so here it looksDoes the metaclass has data descriptor defined for this attribute, if yes then call return type(class).__dict__['attr']__get__(class, type(class)) on it.Look inside __dict__ of the class and see if this attribute is a descriptor of any type, if yes then fetch the attribute calling the __get__, if it is not a descriptor fetch the value from __dict__ of the class.If the attribute is a non-data descriptor in the metalcass, call its __get__.Fetch the attribute from __dict__ of the metaclass.Call the default implementation of getattr. Further the default implementation of __get__ for properties has a check that when you access the attribute with the class, it returns the descriptor instance itself, however when you access the attribute with object it actually fires the code inside the __get__. This also explains why hasattr(User, 'password') returns True because since you are calling the attribute with class the else is not getting executed and hence exception is not being raised and hasattr(u1, 'password') returns False as it encounters exception.
Properties are descriptors.Regarding getattr:When you access an attribute via getattr or the dot-notation on an object (u1) and the class of that object (User) happens to have a descriptor going by the name you are trying to access, that descriptor's __get__ method is called1, as happens when you issue getattr(u1, 'password'). In your specific case, the logic you defined in your getter (raising the AttributeError) will be executed.With getattr(User, 'password') the instance passed to the __get__ method is None, in which case __get__ just returns the descriptor itself instead of executing the getter logic you implemented.1There are some special rules depending on whether you have a data or a non-data descriptor, as explained in the Descriptor HowTo.Regarding hasattr:hasattr(u1, 'password') returns False because getattr(u1, 'password') raises an error. See this question.


Answer URL
https://docs.python.org/3/howto/descriptor.html
