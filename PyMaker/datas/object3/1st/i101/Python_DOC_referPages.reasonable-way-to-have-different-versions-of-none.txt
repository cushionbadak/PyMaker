Natural Text
Working in Python3. Say you have a million beetles, and your task is to catalogue the size of their spots. So you will make a table, where each row is a beetle and the number in the row represent the size of spots;Also, you decide to store this in a numpy array, for which you pad the lists with None (numpy will convert this to np.nan).But there is a problem, values represented as None can be None for one of 3 reasons;The beetle dosn't have many spots; that quantity does not exist.The beetle won't stay still and you can't measure the spot.You haven't got round to measuring that beetle yet, so the value is unassigned.My problem doesn't actually involve beetles, but the principles are the same.I want 3 different None values so I can keep these missing value causes distinct. My current solution is to use a value so large that it is physically improbable, but this is not a very safe solution.Assume you cannot use negative numbers - in reality the quantity I am measuring could be negative.The data is big and read speed is important.Edit; comments rightly point out that saying speed is important without saying what operations is a bit meaningless. Principle component analysis is probably going to be used for variable decorrilation, Euclidean distance squared calculations for a clustering algorithm (but the data is sparse in that variable) possibly some interpolation. Eventually a recursive neural network, but that will come from a library so I will just have to but the data into an input form. So maybe nothing worse than linear algebra, it should all fit in the RAM if I am careful I think.What is a good strategy?
It was suggested to create three different object instances for each of your case.Since your want those objects to have the properties of NaN, you may try creating three different NaN instances.This is at the limit of being a hack, so use at your own risk, but I don't believe any Python implementation optimizes NaN to always reuse the same object. You can nonetheless add a sentinel condition to check that before running.If this works this has the advantage of allowing you to compare the NaN id to check its meaning.Meanwhile, it preserves any optimization numpy may do with its array.Disclosure: this is a hacky suggestion, I am eager to hear from others about this.
The simplest way to go would be with strings: 'not counted', 'unknown' and 'N/A'. However if you want to process quickly in numpy, arrays with mixed numbers/objects are not your friend. My suggestion would be to add several arrays of the same shape as your data, consisting of 0 and 1. So the array missing = 1 where spot is missing else 0, and so on, same with array not_measured, etc..Then you can use NaNs everywhere, and later mask your data with, say, np.where(missing == 1) to easily find the specific NaNs you need.
If you just want an object that is not any known value, and is also not None, just make a new object:Now you can just use those values exactly like you would use None:etc.If you need a value that can be represented as a float (e.g. in a numpy array), you can create a NaN value with "extra" data encoded in the mantissa. It may not be safe to do so, however, because there is no guarantee that those bits are preserved through various operations on the values.
Here is a solution (disclaimer: HACK!) that avoids speed bumps such as object dtype or separate masks: There appears to be quite a bit of "dead space" around the fp representation of nan:We have created ten distinct nans. Please note that this is different from creating multiple instances using float("nan"). Such instances will all map to the same value in numpy and hence be indiscriminable once put in a non object array.Even though our ten nans have distinct representations, at the float level they are difficult to tell apart (because per definition nan != nan even for unique nan). So we need a little helper:Example:Perhaps surprisingly, this appears to survive at least some basic numpy operations:
In the comment below question I ask why not use np.inf, -np.inf and np.nan and author response that this is what he need. So I add post, because people more often look on responses, not comments.   


Answer URL
https://docs.python.org/3/library/enum.html#creating-an-enum
