Natural Text
I'm currently using the following set up to manage a variable set of methods that could be applied to data, but when I try and mock the method to make sure it is returning any list (I have already set up tests of the methods themselves), I end up with KeyErrors. Is there something I'm missing here in my understanding of how mocking works in Python? I had figured if I mock a method, it shouldn't matter if I pass in an empty dictionary or not; that it should just return True at that point. File 1File 2Test FileError
Your patch should read @patch('module.file2.f1.method_1')I'll walk you through why:test_determine_failure_modes.py imports file1 as f1. Then file1 is read and it defines method1 in it's locals. That becomes available on the symbol f1.So the symbol tables look like:Then you patch file1.method1 and you get this symbol tableThen you call f1.method1 and get the actual function.It looks like you use method_dict to reference the function, so you still need to go a little deeper. Fortunately, unittest.mock.patch has a utility for mocking dict contents like so:One other way is to defer resolving the method name until after it's mocked.Here, the lookup for f1.method1 doesn't happen until after it has been mocked. In the earlier case, you put a reference to the function when file2 was read. Here the reference isn't resolved until the method is actually called.


Answer URL
https://docs.python.org/3/library/unittest.mock.html#patch-dict
