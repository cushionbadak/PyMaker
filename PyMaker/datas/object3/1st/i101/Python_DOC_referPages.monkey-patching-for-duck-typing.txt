Natural Text
I patched A with __iter__, so isinstance(a, Iterable) should returns True, since it hehaves like an iterable now for having __iter__ defined. From the source, Iterable determines only based on whether the class has __iter__ implemented.So why does this monkey patch not working as I expected?
Dynamically implementing (or un-implementing) abstract methods isn't supported. The abc machinery does a lot of caching to speed up isinstance and issubclass checks, and there's no option to manually reset the cache. The fact that A isn't a subclass of Iterable is cached after the first isinstance call, causing a False result for the second call.The closest the docs come to describing the caching behavior is the following line:Dynamically adding abstract methods to a class, or attempting to modify the abstraction status of a method or class once it is created, are not supported.
you add variable __iter__ to a. you must add it as a method like this:UPDATE: this answer is accidentally returns True. this just returns True because I set iter and then call isinstance. If I first call isinstance and then set iter it always returns False because of python caching system (read the answer of user2357112)


Answer URL
https://docs.python.org/3/library/abc.html
