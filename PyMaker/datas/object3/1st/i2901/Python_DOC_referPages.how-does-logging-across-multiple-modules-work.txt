Natural Text
According to the logging module's cookbook:Using logging in multiple modulesMultiple calls to logging.getLogger('someLogger') return a reference to the same logger object. This is true not only within the same module, but also across modules as long as it is in the same Python interpreter process. It is true for references to the same object; additionally, application code can define and configure a parent logger in one module and create (but not configure) a child logger in a separate module, and all logger calls to the child will pass up to the parent. How does this work? (I tried looking at the module source code, but could not figure it out.) So far I did not know that I could define 'super-global' objects that are accessible across modules.To help me understand how logging does it, could you show me how to get the following to work:In a foo.py, doand in a 'bar.py', do
First, to do what you want is trivial. When you import a module, there’s only a single instance of that module object shared by anyone else who imports it,1 and that module object’s attributes are just the module’s globals. So:If you run script.py, it will print 10, then 20.You do of course have to be careful with top-level module code, which gets run in the order the modules are first imported (which can be tricky to work out),2 and with code in the script (which should never be imported as a module by anyone else)3, but otherwise, it just works, without needing any special getter and setter functions.(If you do for some reason need getter and setter functions, the same getattr and setattr that work for any object work just fine on module objects.)And now, how does logging do its magic? Simple; it just stores a dict in its globals. Since there’s only one instance of the module, there’s only one instance of its globals, and therefore only one instance of the dict.1. If you want to know how that works under the covers… When you execute import cheese, what Python does (by default, assuming you haven't installed any weird import hooks) is: first, is there a sys.modules['cheese']? If not, find the spec for cheese, use it to find a loader, use the loader to load the code, exec the code, and store the result as sys.modules['cheese']. Then just return sys.modules['cheese']. This is why each module only gets its top-level code run once, no matter how many times you import it, and it's also why everyone who imports it shares the same copy of the module object.2. Your example just works with my_module.my_value = 42 and print(my_module.myvalue)—if foo gets imported before bar. But if bar gets imported first, it will get an AttributeError, because obviously nobody has set my_module.my_value yet.3. The main reason is that when you run script.py, it's not run as a module named script, but as a module named __main__. This is why the if __name__ == '__main__': guard idiom works. But if someone else does an import script, script isn't in sys.modules, so Python will load and execute a separate copy of script.py, with its own separate globals.


Answer URL
https://docs.python.org/3/howto/logging-cookbook.html#using-logging-in-multiple-modules
