Natural Text
I try to update a key in a dictionary. I use .aapend() method but i get following error:Here is the code:
First, yes, strings don't have an append method. You can see a list of all the methods in the docs, or by typing help(str) in the interactive interpreter, or even just printing out dir(str).The reason strings don't have an append method is that they're immutable—you cannot change a string value. You can only create a brand-new string value, e.g., by adding two strings together:However, you can still use augmented assignment on a variable or other target holding a string value:This doesn't change the value 'abc', it makes a brand-new 'abcdef' value and assigns that to s. But that's fine for you.So, if you want to update a dict value that's a string, you can do the same:But really, you don't seem to want to append to a string in the first place; what you want is to have a dict with lists of strings for the values.So, just create it that way in the first place:… and now the rest of your code will work.Or, maybe, you wanted files to be a dict with (single) string values, and only final to be a dict with lists of string values. In that case, instead of this:… do this:Since I can't figure out what your code is intended to do, I don't know which fix you want. But I do know that, if you want to append to the values in final, those values have to be lists (of strings), not strings.Meanwhile, this line of code is overcomplicated for no obvious reason:If you just want to replace a value in a dict, just assign to it:Or, since it seems like you're expecting j will always be in files, why are you even using get?Finally, you have at least one other major problem: once you fix the problem with the values from files all being lists, you're trying to use those values as keys in final. But lists can't be used as dict keys.The reason comes back to mutability again. Imagine you did this:Now, should d[[1]] find that value, even though [1] != lst anymore? Or maybe d[[1, 2]] should find that value, even though what the dict hashed was [1]? Really, no option makes sense. Which is why mutable types in Python either aren't hashable, or don't consider their mutable values in their hashing and comparison functions.Presumably you're actually trying to use the list as just "some kind of sequence"; when the list is mutated, you don't want final to change in any way.If that's true, you can use a tuple of those same values as a key:But, after all of that, it seems like what you're really trying to do is a whole lot simpler:I'm not sure what the nested loop over the cartesian square of the files keys was meant to do, or what all those temporary objects are for, so it's hard to say how to fix them—but you can just get rid of them, so you don't have to fix them.
the error is with final.setdefault(files.get(j), []).append(i).setdefault is getting the j value (if possible) and returning that. since the value for j is Input.txt it returns 'Randy' which is a string and has no append functionAdditionally, you cannot have a list as a key in a dictionary so this line will always break.


Answer URL
https://docs.python.org/3/library/stdtypes.html#string-methods
