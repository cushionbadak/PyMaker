Natural Text
I'm not sure what I'm doing wrong here, I'm trying to have a class which contains a queue and uses a coroutine to consume items on that queue.  The wrinkle is that the event loop is being run in a separate thread (in that thread I do loop.run_forever() to get it running).What I'm seeing though is that the coroutine for consuming items is never fired:Output:
There are several issues with this code.First, check the warnings:That means queue.put is a coroutine, so it has to be run using run_coroutine_threadsafe:You could also use queue.put_nowait which is a synchronous method. However, asyncio objects are generally not threadsafe so every synchronous call has to go through call_soon_threadsafe:Another issue is that the loop gets stopped before the consumer task can start processing items. You could add a join method to the Foo class to wait for the consumer to finish:Then make sure to call this method before stopping the loop:This should be enough to get the program to work as you expect. However, this code is still problematic on several aspects.First, the loop should not be set both in the main thread and the extra thread. Asyncio loops are not meant to be shared between threads, so you need to make sure that everything asyncio related happens in the dedicated thread. Since Foo is responsible for the communication between those two threads, you'll have to be extra careful to make sure every line of code runs in the right thread. For instance, the instantiation of asyncio.Queue has to happen in the asyncio thread.See this gist for a corrected version of your program.Also, I'd like to point out that this is not the typical use case for asyncio. You generally want to have an asyncio loop running in the main thread, especially  if you need subprocess support:asyncio supports running subprocesses from different threads, but there are limits:An event loop must run in the main threadThe child watcher must be instantiated in the main thread, before executing subprocesses from other threads. Call the get_child_watcher() function in the main thread to instantiate the child watcher.I would suggest designing your application the other way, i.e. running asyncio in the main thread and use run_in_executor for the synchronous blocking code. 


Answer URL
https://docs.python.org/3/library/asyncio-queue.html#asyncio.Queue.put
https://docs.python.org/3/library/asyncio-task.html#asyncio.run_coroutine_threadsafe
https://docs.python.org/3/library/asyncio-queue.html#asyncio.Queue.put_nowait
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.call_soon_threadsafe
https://docs.python.org/3/library/asyncio-subprocess.html#subprocess-and-threads
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.run_in_executor
