Natural Text
First time trying to use descriptors.The goal: any integer from 0 to 100 (inclusive) will be a legal value for this descriptor. Non-integers and numbers higher than 100 or lower than 0 should result in an exception being thrown, indicating that the type and/or value is wrong.My code:For this line: if self.pct_min <= int(self.value) <= self.pct_max:I get this error:I am running it through PythonTutor and it appears I am not passing in the integer, but I do not understand where I am failing.I am also using this as a guide:  https://www.blog.pythonlibrary.org/2016/06/10/python-201-what-are-descriptors/
This isn't really a problem with descriptors! You've merely set the initial self.value attribute on the descriptor to None:You then try to convert that self.value attribute value, set to None, to an integer:You probably want to apply this to the initial_value argument to __set__!Your descriptor implementation does have several more problems:The __set__ setter method should not return anything. It should set the new value for the bound object, and that's it. Python ignores anything returned by __set__.You are storing the data on the descriptor instance itself. Your class has only a single copy of the descriptor object, so when you use the descriptor between different instances of Foo() you see the exact same data. You want to store the data on the object the descriptor is bound to, so in the __set__ method, on obj, or at the very least, in a place that lets you associate the value with obj. obj is the specific instance of Foo() the descriptor is bound to. The __get__ getter method doesn't take an 'initial value', it takes the object you are being bound to, and the type (class) of that object. When accessed on a class, obj is None and only the type is set.Don't mix print() and creating an exception instance. ValueError(print(...)) doesn't make much sense, print() writes to the console then returns None. Just use ValueError(...).I'm making the following assumptions:You want to raise an exception when setting an invalid value.You don't want to do any validation when getting the value.The initial value set on the descriptor should be used when no value is present on the bound object.The value itself can be stored on the instance directly.Then the following code would work:Demo:Note that the above uses a specific attribute name on the instance to set the value. If you have multiple instances of the descriptor on the same class, that will be an issue!If you want to avoid that, your options are:use some kind of mapping storage that uses some other unique identifier in the key to track what descriptor stored what value on the bound object.store data on the descriptor instance, keyed by a unique identifier for the instance.store the name of the attribute on the class where this descriptor is stored, on the descriptor instance itself and base your instance attribute name on that. You can do this by implementing the descriptor.__set_name__() hook method, which is called by Python when a class is created that uses your descriptor. This hook requires Python 3.6 or newer. For the Foo class example, that'll by called with Foo and 'participation'.Note that you should not use the attribute name (participation in your Foo example), at least not directly. Using obj.participation will trigger the descriptor object itself, so Percentage.__get__() or Percencage.__set__(). For a data descriptors (descriptors that implementing either a __set__ or __delete__ method), you could use vars(obj) or obj.__dict__ directly to store attributes, however.
That's not a problem with the descriptor itself. The problem is that, in the __set__, instead of checking the value that you get, you check the existing self.value. Since this is initialized to None, you will always fail on the first assignment.There's also an (unrelated) problem with the descriptor itself. The getter and setters are supposed to read/write from the obj.__dict__, not from the descriptor object itself. Otherwise, all the instances will share a common value


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__set__
https://docs.python.org/3/reference/datamodel.html#object.__get__
https://docs.python.org/3/reference/datamodel.html#object.__set_name__
