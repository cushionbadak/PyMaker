Natural Text
I am looking for a code to copy the generator and then continue with the new generator. It is like a bifurcation of a generator. this code gives as output:whereas the disiered output should be: (The bifurcated generator needs to be a new instance, but continue at the same point as the old generator stopped.)The application itself is much more complicated, this here is just a code example.Important (only for myself) is a semanticly beautiful solution which is nicely readable to third parties.Efficiency is not so important
Why not use a generator with a start parameter (and a stop one while you are at it)?Also gives the output:
Some people will tell you to use itertools.tee. Do not use itertools.tee.Use a listTo keep track of the previous states of your generator, you need to store previously yielded values in a list. This is what the function itertools.tee does when it copies a generator.Unfortunately, this removes all memory-advantage of using a generator. So you are better to use a list.Output:Why not using itertools.tee then?It is still possible to use itertools.tee, but you should not.The reason the previous code works is subtle and is actually linked to the fact that itertools.tee returns the same tee object as first output value when given a tee object. This is why the second generator should be used.This, coupled to the fact that the doc explicitly specifies that a list is better in this situation, demonstrates that the first solution must be preferred:This itertool may require significant auxiliary storage (depending on  how much temporary data needs to be stored). In general, if one  iterator uses most or all of the data before another iterator starts,  it is faster to use list() instead of tee().


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.tee
