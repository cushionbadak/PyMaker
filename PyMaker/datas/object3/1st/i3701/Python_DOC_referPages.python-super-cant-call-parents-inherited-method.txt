Natural Text
I have a question in Python that seems very complex to me, that combines inheritance, recursion, and the super() function.First of all, I am using Python 3, and I have a structure of deep inheritance.In the very first parent class I declare a method, and I want that method to be called from each child class in the hierarchy, but with different inputs for each of them. The use of that structure seems very pythonic to me and it really saves me from a lot of code repetition.A simplified sample of my code is shown below:I expect that code to print Instead it raises an attribute error:I know that it is a complex problem, but I have tried to divide it. I tried to remove the recursion part, but I do not get any better.Based on the various attempts I have done, I believe that I am very close to the cause of the problem, and it seems to me like a syntax problem or something that simple.Thanks!!
I'm afraid you have built up the wrong mental model on how Python instances and classes relate. Classes only provide a series of attributes for instances to 'inherit', not separate namespaces for instance attributes to live in. When you look up an attribute on an instance and the attribute doesn't exist on the instance itself, a search is done of the classes that back the instance, with the 'nearest' class with that attribute winning over others. super() just lets you reach attributes with the same name but defined on a next class in that same layered search space.In order for super() to work correctly, Python records what class the method1 function was defined on. Here that's ClassA, and super() will only find attributes on the parent classes of ClassA. In your example, ClassC and ClassB had already been searched and they didn't have a method1 attribute, so ClassA.method1 is being used, but there is no further method1 attribute in the rest of the layers that are searched (only object remains, and there is no object.method1).You don't need to use super() when subclasses are not overriding a method, nor can you do what you want with super() anyway. Note that the ClassB and ClassC subclasses do not get a copy of the method at all, there is no ClassC.method1 direct attribute that needs to account for ClassB.method1 to exist, etc. Again, what happens when looking up attributes on an instance is that all class objects in the inheritance hierarchy of the instance are inspected for that attribute, in a specific order.Take a look at your subclasses:The __mro__ attribute gives you the method resolution order of your ClassC class object; it is this order that attributes are searched for, and that super() uses to further search for attributes. To find inst1.method, Python will step through each of the objects in type(inst1).__mro__ and will return the first hit, so ClassA.method1.In your example, you used super() in the ClassA.method1() definition. Python has attached some information to that function object to help further searches of attributes:When you call super() the closure I show above is used to start a search along the type(self).__mro__ sequence, starting at the next object past the one named in the closure. It doesn't matter that there are subclasses here, so even for your inst1 object everything is skipped an only object is inspected:At no point are ClassB or ClassC involved here anymore. The MRO depends on the class hierarchy of the current instance, and you can make radical changes when you start using multiple inheritance. Adding in extra classes into a hierarchy can alter the MRO enough to insert something between ClassA and object:ClassD inherits from ClassA and from Mixin. Mixin inherits from object too. Python follows some complicated rules to put all classes in the hierarchy into a logical linear order, and Mixin ends up between ClassA and object because it inherits from the latter, and not the former.Because Mixin is injected into the MRO after ClassA, calling Class().method1() changes how super().method1() behaves, and suddenly calling that method will do something different:Remember, it helps to see classes as a layered search space for attributes on instances! instance.attribute is searched for along the classes if the attribute doesn't exist on the instance itself. super() just let you search for the same attribute along the remainder of that search space.This lets you reuse method implementations when implementing a method with the same name in a subclass. That's the whole point of super()!There are other problems with your code.When looking up methods, they are bound to the object they were looked up on. instance.method binds the method to instance, so that when you call instance.method(), Python knows what to pass into the method as self.  For classmethod objects, self is replaced with type(self), unless you did ClassObject.attribute, at which point ClassObject is used.So your _classname method will always be producing ClassC for inst1, as the cls object that is passed in is that of the current instance. super() doesn't change what class classmethods are bound to when accessed on an instance! It'll always be type(self).You also forgot to call super() in the ClassB and ClassC __init__ methods, so for inst1, only ClassC.__init__ is ever actually used. The ClassB.__init__ and ClassC.__init__ implementations are never called. You'd have to add a call to super().__init__() in both for that to happen, at which point there are three self.attr = ... assignments on the same instance, and only the one that executes last will remain. There is no separate self for each of the classes that make up the code for the instance, so there are no separate self.attr attributes with different values.Again, that's because inst1.__init__() is called, __init__ is bound to inst for the self argument, and even if you used super().__init__() the self that is passed on remains inst1.What you want to achieve is something entirely different from an attribute search across all of the classes. Printing all class names can be done with a loop over __mro__ instead:This then produces:If you have to print 'c', 'b', 'a' you can add extra attributes to each class:and you'll getprinted.
Thats because you're trying to access Method1() on Object_classYou've written an if-else which satisfies when you're instantialize with Class C and access method1().To print a,b,c, you will need override the method in every class.. and calling super from them. However, this will still have a problem. Because the self attribute carries the instance of Class C, not Class B or A. So, they can't access the attribute that you're initializing in the init func. Final code looks like this


Answer URL
https://docs.python.org/3/howto/descriptor.html
