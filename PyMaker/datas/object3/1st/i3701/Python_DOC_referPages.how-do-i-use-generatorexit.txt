Natural Text
I have the following mcve:And here is sample use:I would like logging.error to report the ValueError, but instead it reports GeneratorExit:When I catch GeneratorExit in __iter__:nothing is logged (of course) because __exit__ is called with exc_type=None. Why do I see GeneratorExit instead of ValueError in __exit__?What do I do to get the desired behavior, i.e., ValueError in __exit__?
Just a quick note that you could "bring the context manager out" of the generator, and by only changing 3 lines get:A context manager that could also act as an iterator -- and would catch caller code exceptions like your ValueError.
The basic problem is that you are trying to use a with statement inside the generator to catch an exception that is raised outside the generator. You cannot get __iter__ to see the ValueError, because __iter__ is not executing at the time the ValueError is raised.The GeneratorExit exception is raised when the generator itself is deleted, which happens when it is garbage collected.  As soon as the exception occurs, the for loop terminates; since the only reference to the generator (the object obtained by calling __iter__) is in the loop expression, terminating the loop removes the only reference to the iterator and makes it available for garbage collection.  It appears that here it is being garbage collected immediately, meaning that the GeneratorExit exception happens between the raising of the ValueError and the propagation of that ValueError to the enclosing code.  The GeneratorExit is normally handled totally internally; you are only seeing it because your with statement is inside the generator itself.In other words, the flow goes something like this:Exception is raised outside the generatorfor loop exitsGenerator is now available for garbage collectionGenerator is garbage collectedGenerator's .close() is calledGeneratorExit is raised inside the generatorValueError propagates to calling codeThe last step does not occur until after your context manager has seen the GeneratorExit.  When I run your code, I see the ValueError raised after the log message is printed.You can see that the garbage collection is at work, because if you create another reference to the iterator itself, it will keep the iterator alive, so it won't be garbage collected, and so the GeneratorExit won't occur.  That is, this "works":The result is that the ValueError propagates and is visible; no GeneratorExit occurs and nothing is logged.  You seem to think that the GeneratorExit is somehow "masking" your ValueError, but it isn't really; it's just an artifact introduced by not keeping any other references to the iterator.  The fact that GeneratorExit occurs immediately in your example isn't even guaranteed behavior; it's possible that the iterator might not be garbage-collected until some unknown time in the future, and the GeneratorExit would then be logged at that time.Turning to your larger question of "why do I see GeneratorExit", the answer is that that is the only exception that actually occurs within the generator function.  The ValueError occurs outside the generator, so the generator can't catch it.  This means your code can't really work in the way you seem to intend it to.  Your with statement is inside the generator function.  Thus it can only catch exceptions that happen in the process of yielding items from the generator; there generator has no knowledge of what happens between the times when it advances.  But your ValueError is raised in the body of the loop over the generator contents.  The generator is not executing at this time; it's just sitting there suspended.You can't use a with statement in a generator to magically trap exceptions that occur in the code that iterates over the generator.  The generator does not "know" about the code that iterates over it and can't handle exceptions that occur there.  If you want to catch exceptions within the loop body, you need a separate with statement enclosing the loop itself.
The GeneratorExit is raised whenever a generator or coroutine is closed.  Even without the context manager, we can replicate the exact condition with a simple generator function that prints out the exception information when it errors (further reducing the provided code to show exactly how and where that exception is generated).Usage:Note there was also an exception that was raised inside the generator itself, as noted that the except block was executed.  Note that the exception was also further raise'd after the print statement but note how that isn't actually shown anywhere, because it is handled internally.We can also abuse this fact to see if we can manipulate the flow by swallowing the GeneratorExit exception and see what happens.  This can be done by removing the raise statement inside the dummy_gen function to get the following output:Note how there is an internal RuntimeError that was raised that complained about the generator ignoring the GeneratorExit function.  So we from this we can clearly see that this exception is produced by the generator itself inside the generator function, and the ValueError that is raised outside that scope is never present inside the generator function.Since a context manager will trap all exceptions as is, and the context manager is inside the generator function, whatever exception raised inside it will simply be passed to __exit__ as is.  Consider the following:Modify the dummy_gen to the following:Running the resulting code:The same GeneratorExit that is raised is now presented to the context manager, because this is the behavior that was defined.


Answer URL
https://docs.python.org/3/library/exceptions.html#GeneratorExit
