Natural Text
Say you want to optimize a (byte) string compare intensive algorithm implemented in Python. Since a central code path contains this sequence of statementsit would be great to optimize it to something likewhere (the hypothetical) bytes_compare() ideally would just call the three-way comparison C function memcmp() which is usually quite well optimized. This would reduce the number of string comparisons by half. A very feasible optimization unless the strings are ultra short.But how to get there with Python 3?PS:Python 3 has removed the three way comparison global function cmp() and the magic method __cmp__(). And even with Python 2, the bytes class doesn't had a  __cmp__() member.With the ctypes package it's straight forward to call memcmp() but the foreign function call overhead with ctypes is prohibitively high.
Python 3 (including 3.6) simply doesn't include any three-way comparison support for strings. Although the internal implementation of the rich comparison operator __lt__(), __eq__() etc. do call memcmp() (in the C implementation of bytes - cf. Objects/bytesobject.c) there is no internal three-way comparison function that could be leveraged.Thus, writing a C extension that provides a three-way comparison function by calling memcmp() is the next best thing:Compile with:Test:In contrast to calling memcmp via the ctypes package, this foreign call has the same overhead as the builtin bytes comparison operators (as they also are implemented as C extension with the standard Python version).


Answer URL
https://docs.python.org/3/c-api/buffer.html#c.PyObject_GetBuffer
