Natural Text
why this question ?I was trying to answer this question: Check if All Values Exist as Keys in Dictionary with something better than a generator comprehension fed to all (python loops, even in comprehensions, slow down execution compared to implicit loops that some functions perform):where bar is a dictionary and foo is a list by using set.issubset (with a conversion to set of foo to be able to use foo.issubset(bar)), and didn't succeed to beat the times of the all solution (unless both containers are converted to sets).my question:From the documentation of set:Note, the non-operator versions of union(), intersection(), difference(), and symmetric_difference(), issubset(), and issuperset() methods will accept any iterable as an argument. In contrast, their operator based counterparts require their arguments to be sets. This precludes error-prone constructions like set('abc') & 'cbs' in favor of the more readable set('abc').intersection('cbs').Okay but the performance really depends on the type of argument, even if the complexity does not (The complextiy of Python issubset()):my results (Python 3.4):So if a set is passed as the argument, the result is very fast.Using a list is much slower. I figured out that it was because of the hash that must be done on the strings is costly. So I changed my test inputs with integers like this:and the results were globally faster but still a huge time difference:I also tried to change dict by dict.keys() as in python 3 the keys is said to be (https://www.python.org/dev/peps/pep-3106/) "a set-like or unordered container object".But in that case, the result is even worse than with dict or list.So why does passing a set beats passing a list or a dict or a dict_keys object? I don't see anything mentionned in the documentation about this.
The set.issubset algorithm requires a set to work with (frozensets and subclasses count); if you pass it something else, it will make a set. It's basically all(elem in other for elem in self), and it needs to know that elem in other is efficient and means what it means for sets. The only way it knows how to guarantee that is to ensure other is a set. Making a set is expensive.(I've glossed over some details. If you want to know exactly what's going on, particularly if you have a weird set subclass, read the source code in the link.)


Answer URL
https://docs.python.org/3/library/stdtypes.html#set
