Natural Text
I have a dictionary likeHow can I remove elements from this dictionary without creating gaps in values, in case the dictionary is not ordered? An example:I have a big matrix, where rows represent words, and columns represent documents where these words are encountered. I store the words and their corresponding indices as a dictionary. E.g. for this matrixthe dictionary would look like:If I remove the words 'apple' and 'banana', the matrix would contain only two rows. So the value of 'orange' in the dictionary should now equal 0 and not 1, and the value of 'pear' should be 1 instead of 3. In Python 3.6+ dictionaries are ordered, so I can just write something like this to reassign the values:or, alternativelyI think, this is far from being the most efficient way to change the values, and it wouldn't work with unordered dictionaries. How to do it efficiently? Is there any way to easily reassign the values in case the dictionary is not ordered?
Turn the dict into a sorted list and then build a new dict without the words you want to remove:This has a runtime of O(n) because manually ordering the list  with indexing operations is a linear operation, as opposed to sorted which would be O(n log n).See also the documentation for itertools.count and next.
You can use your existing logic, using a representation of the dictionary that is sorted:
Initially we havewords = {'apple': 0, 'orange': 1, 'banana': 2, 'pear': 3}To reorder based on from minimum to maximum, you may use sorted and dictionary comprehension.std = sorted(words, key=lambda x: words[x])newwords = { word : std.index(word) for word in std }Does this okay..? 
You could always keep an inverted dictionary that maps indices to words, and use that as a reference for keeping the order of the original dictionary. Then you could remove the words, and rebuild the dictionary again:Which Outputs:Note: Like the accepted answer, this is also O(n). 
You are using the wrong tool (dict) for the job, you should use a listA note on complexityI had several comments mentioning that a dict is more efficient because it's lookup time is O(1) and the lookup time of a list is O(n).This is simply not true in this case.The O(1) guarantee of a hash table (dict in python), is a result of an amortised complexity, meaning, that you average a common usage of lookup table that is generated once, assuming that your hash function is balanced.This amortised calculation does not take into account deleting the entire dictionary and regenerating it every time you remove an item, as some of the other answers suggest.The list implementation and the dict implementation have the same worst-case complexity of O(n).Yet, the list implementation could be optimised with two lines of python (bisect) to have a worst-case complexity of O(log(n))


Answer URL
https://docs.python.org/3/library/functions.html#sorted
https://docs.python.org/3/library/itertools.html#itertools.count
https://docs.python.org/3/library/functions.html#next
