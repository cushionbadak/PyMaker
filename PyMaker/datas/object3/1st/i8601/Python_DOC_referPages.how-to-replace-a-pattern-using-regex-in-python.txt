Natural Text
I have a dataset that looks like this:I want to the change the list so it looks like this:Each name has to be changed to the class they belong to. I noticed that in the dataset, each new class in the list is denoted by a ‘###’. So I can split the data set into blocks by ‘###’ and count the instances of ###. Then use regex to look for the names, and replace them by the count of ###. My code looks like this: This doesn’t seem to do the job - no replacements are made. 
When running the code you provided, I got the following traceback output:The error happens because type(match) evaluates to a list. When I inspect this list in PDB, it's an empty list. This is because match has gone out of scope by having two for-loops. So let's combine them as such:Now you're getting content in match, but there's still a problem: the return type of re.findall is a list of strings. str.replace(...) expects a single string as its first argument.You could cheat, and change the offending line to print(line.replace(match[0], prefix + str(triple_hash_count))) -- but that presumes that you're sure you're going to find a regular expression match on every line that isn't ###. A more resilient way would be to check to see that you have the match before you try to call str.replace() on it.The final code looks like this:Two more things:On line 11, you mistook the variable name. It's triple_hash_count, not hash_count. This code won't actually change the text file provided as input on line 1. You need to write the result of line.replace(match, prefix + str(triple_hash_count)) back to the file, not just print it.
The problem is rooted in the use of a second loop (as well as a mis-named variable).  This will work.
While you already have your answer, you can do it in just a couple of lines with regular expressions (it could even be a one-liner but this is not very readable):What it does:First, it looks for ### in a single line with the anchors ^ and $ in MULTILINE mode.Second, it looks for a possible number after the Name, capturing it into group 1 (but made optional as not all of your names have it).Third, it splits your string by ### and iterates over it with enumerate(), thus having a counter for the numbers to be inserted.Lastly, it joins the resulting list by ### again.As a one-liner (though not advisable):DemoA demo says more than thousands words.


Answer URL
https://docs.python.org/3/library/re.html#re.findall
https://docs.python.org/3/library/stdtypes.html#str.replace
