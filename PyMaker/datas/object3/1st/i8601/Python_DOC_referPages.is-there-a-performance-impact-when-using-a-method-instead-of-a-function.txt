Natural Text
I like to work with classes and methods instead of bare functions. I am wondering if there is a specific performance impact to do so (either in execution speed, or memory usage or in other aspects).A quick test shows that both perform equally well:In other tests I did not see the RAM being used more in one case than in the other.Are there specific cases where performance will be degraded when using a class/method instead of a function?Note: I would like to focus exclusively on code performance, not aesthetical aspects
The overhead of method invocation is really just the transformation of the function object to a method object when attribute access (.) on a function attribute it made from an instance. Apart from that, the calling of the function is similar, with one extra argument (self) inserted implicitly for the method.So, no, there aren't really any concerns to have here, the overhead is small and can be completely eliminated by assigning the method to a local variable:(Edit: In Python 3.7 new op-codes where introduced that basically negate the benefit of assigning h.hello to a local name, the look-up for methods just got quite faster :-)If you're looking for bottlenecks, you should be looking elsewhere. Python's dynamic interpretation really makes these sort of concerns pedantic.As for the memory aspect, methods should be bit larger than the functions due to a method essentially containing a function as one of its members:Despite this, I can't imagine a scenario where your application would choke due to the slight memory overhead methods introduce.In CPython, for example, approximately 64 bytes are are added for a bound method object according to getsizeof:This isn't counting the __func__ attribute, which contains the function objects:
Calling a method obj.method(...) involves attribute access (the obj.method part) which can be a non-trivial and therefore quite costly operation. A brief description of a possible attribute access scenario is found in the documentation of the descriptor protocol:The default behavior for attribute access is to get, set, or delete  the attribute from an objectâ€™s dictionary. For instance, a.x has a  lookup chain starting with a.__dict__['x'], then  type(a).__dict__['x'], and continuing through the base classes of  type(a) excluding metaclasses.However, if the looked-up value is an object defining one of the  descriptor methods, then Python may override the default behavior and  invoke the descriptor method instead. Where this occurs in the  precedence chain depends on which descriptor methods were defined and  how they were called.Only after the attribute access is complete, invoking the resultant callable object is little different from calling a free function. Note, however, that in your benchmark the overhead of attribute access, i.e. the operations behind the seemingly innocuous expression h.hello, is not measured (though in your example it should be quite small).


Answer URL
https://docs.python.org/3/reference/datamodel.html#invoking-descriptors
