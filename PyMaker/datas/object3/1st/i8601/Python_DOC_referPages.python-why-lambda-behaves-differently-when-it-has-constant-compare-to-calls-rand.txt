Natural Text
I probably don't understand python's lambda very much. So it confuses me evry time. For example if I have this simple lambda construction with constant, everything works perfect:But if I substitute  random number generator instead of constant 0.5, it would stuck and never returns back....Why?! And what to do to avoid it?
Here are some ways to achieve what you want. First, some code-golf:I'll leave you to deciphering that as an exercise (a great way to explore itertools!). And also as a good lesson on why you shouldn't write cryptic one-liners...However, I would probably just do:See how much more readable and straight-forward that is? 6 months from now, I'll re-read that and know exactly what I was trying to do.Here it is in action:OK, here is a reward for reading this far... the one-liner works thusly:itertools.takewhile takes a function and an iterable. The takewhile will yield from the iterable as long as the function returns True. The function I use is functools.partial(operator.gt, stop), which is the partial-application of the operator.gt, op.gt(a, b) is equivalent to a > b, so we take while stop is greater than the value returned by the iteterable. Finally, the iterable is itertools.accumulate(iter(random.random, object()). accumulate (only on Python 3) takes an iterable and keeps adding the iterables values to it... i.e. accumulating. So, e.g:The iterable I pass to accumulate is iter(random.random, object()) which just calls random.random until the value is == object(), which is never.
iter(lambda: x+0.5,max+1.) stops when the lambda function returns exactly max+1.. The function does return max+1., so the iterator stops there, but that could have gone differently by a fluke of floating-point rounding.iter(lambda: x+random.random(),max+1.) only stops if the lambda function returns exactly max+1., but this time, it is extremely unlikely that the function will ever return that value. Your list comprehension filters iterator elements forever.Note that both of your code snippets rely on Python 2 list comprehension variable scope behavior, where the x in the comprehension's for clause is the same as the x from the function the comprehension appears in. That changed in Python 3, so neither of your code snippets work on Python 3.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.accumulate
