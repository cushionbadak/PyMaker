Natural Text
I have created a class with a number of methods. One of the methods is very time consuming, my_process, and I'd like to do that method in parallel. I came across Python Multiprocessing - apply class method to a list of objects but I'm not sure how to apply it to my problem, and what effect it will have on the other methods of my class.
I'm going to go against the grain here, and suggest sticking to the simplest thing that could possibly work ;-)  That is, Pool.map()-like functions are ideal for this, but are restricted to passing a single argument.  Rather than make heroic efforts to worm around that, simply write a helper function that only needs a single argument:  a tuple.  Then it's all easy and clear.Here's a complete program taking that approach, which prints what you want under Python 2, and regardless of OS:A big of magicI should note there are many advantages to taking the very simple approach I suggest.  Beyond that it "just works" on Pythons 2 and 3, requires no changes to your classes, and is easy to understand, it also plays nice with all of the Pool methods.However, if you have multiple methods you want to run in parallel, it can get a bit annoying to write a tiny worker function for each.  So here's a tiny bit of "magic" to worm around that.  Change worker() like so:Now a single worker function suffices for any number of methods, with any number of arguments.  In your specific case, just change one line to match:More-or-less obvious generalizations can also cater to methods with keyword arguments.  But, in real life, I usually stick to the original suggestion.  At some point catering to generalizations does more harm than good.  Then again, I like obvious things ;-)
Generally the easiest way to run the same calculation in parallel is the map method of a multiprocessing.Pool (or the as_completed function from concurrent.futures in Python 3).However, the map method applies a function that only takes one argument to an iterable of data using multiple processes.So this function cannot be a normal method, because that requires at least two arguments; it must also include self! It could be a staticmethod, however. See also this answer for a more in-depth explanation.
If your class is not "huge", I think process oriented is better.Pool in multiprocessing is suggested.This is the tutorial -> https://docs.python.org/2/library/multiprocessing.html#using-a-pool-of-workersThen seperate the add_to from my_process since they are quick and you can wait util the end of the last process.
Based on the answer of Python Multiprocessing - apply class method to a list of objects and your code: add MyClass object into simulation objectrun what you want in run functionTry this:
If you don't absolutely need to stick with Multiprocessing module then,it can easily achieved using concurrents.futures libraryhere's the example code:here executor returns future for every task it submits. keep in mind that if you use add_done_callback() finished task from thread returns to the main thread (which would block your main thread) if you really want true parallelism then you should wait for future objects separately. here's the code snippet for that.hope this helps.


Answer URL
https://docs.python.org/3/library/concurrent.futures.html
