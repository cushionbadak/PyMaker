Natural Text
Is it possible to set all values in a Python list of lists to 0 without iterating through the lists and values one by one? I have a list of lists [[0, 2, 4, 5], [0, 2, 4, 5]] which I would like to change to [[0, 0, 0, 0], [0, 0, 0, 0]]. Is there a way to achieve this without looping through all the values and would that lead to performance improvements? What would be the fastest method to achieve this since this piece of code will be executed a large number of times? It also does not matter whether the lists are modified in place or replaced altogether. The length of the outer list would be quite large while the length of the inner list would be small.
No, there is no way to avoid looping, because lists have an arbitrary size. You also want to avoid ending up with a shared single nested list, so multiplication of the outer list is out.The following is reasonably efficient and produces a sane result:This'll produce the right result for any length of outer, and even if the lengths of the nested lists vary.This is also the fastest method across different scenarios, as the following time trials show. First a setup to test with:I'm testing with the timeit module on Python 3.6.1rc1, on a MacBook Pro (Retina, 15-inch, Mid 2015) running OS X 10.12.3Then each scenario. Short fixed is a list of 10 nested lists each 5 elements long. The test times are the total for 1 million repetitions:Long fixed tests 1 million elements, 10 repetitions to keep waiting manageable:Varying list sizes are between 0 and 25 elements long. Short lists:and finally 1 million ranging lists:In all scenarios the explicit loop is faster (up to a factor of 2), because it doesn't have to use lambda functions.If you are prepared to switch to numpy arrays, then that option blows everything out of the water, easily. Broadcasting a multiplication by 0 across all (native) values in an array moves all iteration to C without a need to call functions or execute Python bytecode at all:(Because this approach alters objects in-place you need to create enough copies for each individual repeated test to alter a unique array, hence the whole next(copies) dance).To use numpy arrays to their full strength also means that you can only realistically use them for fixed-length sublists. For variable-length sublists you have to use single-dimension arrays of type object (meaning that they only are used to reference Python lists), at which point you can no longer broadcast the multiplication to all numeric elements anymore either.Take into account that you'd have to retool your whole project to take advantage of numpy arrays in that case. If you need to access individual values from such an array a lot, then take into account that that'll be slower as accessing individual values requires boxing the C native value in a Python object each time.
Without explicitly looping, here is a functional approach using itertools.repeat() and map():Or if your sub-lists are all in same length you can just use two repeat():Note that this methods are using loops for creating the repeated objects and converting the generators to lists. This means that there is no way to create separate objects like this without a loop. Another way to change the items in-place is using Numpy. You can do this with a simply multiplying with 0:
As far as I know,it's impossible to avoid looping, but you said explicitly looping  I suppose you want a way without for loop.So you can try this:Python 3.x,it should be:Map:Apply function to every item of iterable and return a list of the  results.
You can update your list with the following approach (no explicit for-loops):Let's try it:


Answer URL
https://docs.python.org/3/library/timeit.html
