Natural Text
The problemThere seems to be a conflict on the use of kur.engine.Engine._evaluate. When I ran kur dump mnist.yml under kur/example/ directory, and look inside the running details, I got: However, when I ran eng = kur.engine.Engine() and then eng._evaluate('mnist-defaults.yml'), I got the following error: What does the source code say?My reading of this function doc:1. take a string as arg named expression2. return an python object or classMy reading of this code:1. I give the function a string arg2. it returns an error named 'Not Implemented Error'However, in fact it works as the doc says when run in console kur dump mnist.yml. So, where my understanding went wrong?  Thanks!
Engine is an abstract base class. This means that it is not intended to be directly instantiated. Instead, its derived classes use the base class as a "template" (so-to-speak) for extending its functionality. This is a classic pattern in object-oriented programming, especially in languages like Java and C++. Python is an extremely flexible language, though, and there are lots of ways to accomplish similar design patterns (e.g., the abc module, duck-typing, or classic inheritance plus good documentation and NotImplementedError).In your particular case, when you actually run Kur, the instantiated (run-time) type of your engine is not Engine; it's JinjaEngine. So when the _evaluate() call is made, it is actually the JinjaEngine which is handling it, not the base class (which, as you correctly point out, raises an exception). Try instantiating a JinjaEngine instead, and you should get the expected results.
Based on @ajsyp comment above: You definitely are instantiating Engine, which, being an abstract base class, shouldn't be done. When Kur is actually running, or if you want to get the intended behavior, then instantiate a JinjaEngine instead. Abstract base classes are a way of saying, "This is how this type of objects acts" without actually creating one of the objects; instead, derived classes are responsible for implementing the behavior of the base class. It's a standard OOP patternIf I understand it correctly, when running kur -vv build mnist.yml and when I use logger to display the functions at work under kur.Kurfile.parse_source, I noticed a few things below:when codes run at kur.Kurfile.parse, it parses on different sections like settings, train, validate ...when doing kur.Kurfile._parse_section, most section require to run a lot of kur.engine.engine.Engine.evaluate and a few if not none of kur.engine.jinjiaEngine.JinjaEngine._evaluateShould I understand the comment and the observations in the following way: kur.engine.engine.Engine.evaluate, kur.engine.engine.Engine._evaluate are base class methods, practically I don't need to understand the inside of them; is it right?kur.engine.jinja_engine.JinjaEngine._evaluate is the derived method from the base methods above, I need to understand its practical meaning for it; is it right?my understanding of kur.engine.jinja_engine.JinjaEngine._evaluate: it is to convert a yaml string expression to a python object. Is it correct? If not, could you explain with an example? (don't have to be working code, just an example we can picture in the mind would be ok too)Thanks@ajsyp further answers and explanations are very helpful1.) All of the functions defined in the Engine class are, by definition, base-class methods. This does not imply that they are not important. They are incredibly important! To be specific, Engine.evaluate() actually does work, trying to figure out how to process your data, what types it is, if recursion is necessary, etc. And Engine._evaluate defines the API that the derived classes must implement (although, from a pure code standpoint, Engine._evaluate() does not do anything, since its job is to define the API, and all implementation is delegated to the derived classes).  2.) Yes, JinjaEngine._evaluate() is a derived class method. In this particular case, it implements the logic defined by the parent class's API.  3.) Kind of. JinjaEngine._evaluate() is responsible for using the current values of the Kurfile to evaluate a Jinja2 expression (not a YAML expression; the YAML parser already did that; in fact, you could have used a JSON Kurfile instead, and this entire answer is still true). The evaluated result of the Jinja2 expression is a string representation of a Python expression. So the function also needs to interpret that string, if necessary, to construct the underlying Python type (e.g., the integer 4 versus the string "4").


Answer URL
https://docs.python.org/3/glossary.html#term-abstract-base-class
https://docs.python.org/3/library/abc.html
