Natural Text
I have a Python script that does multiple  calls. Asserting against the series of them as a list of strings will be easy (and relatively elegant).What isn't so easy is intercepting (and blocking) the actual calls. In the script in question, I could abstract os.system in the SUT (*) like so:My test invokes  instead of  of course (leaving a tiny amount of untested code).Alternate option: I could leave the SUT untouched and replace  globally in the test method before invoking  in the SUT.That leaves me with new problems in that that's a global and lasting change. Fine, so I'd use a  in the same test method, and replace the original before leaving the test method.  That'd work whether the test method passes or fails.Is there a safe and elegant setup/teardown centric way of doing this for PyTest, though?Additional complications: I want to do the same for stdout and stderr.  Yes, it really is a  script that I am testing.SUT == System Under Test
The Python 3 (>= 3.3) standard library has a great tutorial about Mock in the official documentation. For Python 2, you  can use the backported library: Mock on PyPi.Here is a sample usage. Say you want to mock the call to  in this function:To do that, you can use the  decorator, like this:This test function will patch the  call during its execution.  is restored at the end.Then, there are several "assert" method to check the calls, the parameters, and the results. You can also check that an exception is raised in certain circonstances.


Answer URL
https://docs.python.org/3/library/unittest.mock.html#module-unittest.mock
