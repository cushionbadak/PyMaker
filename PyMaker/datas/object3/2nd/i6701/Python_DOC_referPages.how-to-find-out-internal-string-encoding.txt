Natural Text
From PEP 393 I understand that Python can use multiple encodings internally when storing strings: , , . Is it possible to find out what encoding is used to store a particular string, e.g. in the interactive interpreter?
The only way you can test this from the Python layer (without resorting to manually mucking about with object internals via  or Python extension modules) is by checking the ordinal value of the largest character in the string, which determines whether the string is stored as ASCII/latin-1, UCS-2 or UCS-4. A solution would be something like:You can't actually rely on  because, for non-ASCII strings (even one byte per character strings that fit in the  range), the string might or might not have populated the UTF-8 representation of the string, and tricks like adding an extra character to it and comparing sizes could actually show the size decrease, and it can actually happen "at a distance", so you're not directly responsible for the existence of the cached UTF-8 form on the string you're checking. For example:
There is a CPython C API function for the kind of the unicode object: .In case you have Cython and IPython1 you can easily access that function:Where  represents  and  and  represent  and  respectively.You could then use a dictionary to map these numbers into a string that represents the encoding.1 It's also possible without Cython and/or IPython, the combination is just very handy, otherwise it would be more code (without IPython) and/or require a manual installation (without Cython).
One way of finding out which exact internal encoding CPython uses for a specific unicode string is to peek in the actual (CPython) object.According to PEP 393 (Specification section), all unicode string objects start with :Character size is stored in the  bit-field, as described in the PEP, as well as in the code comments in :After we get the address of the string with , we can use the  module to read the object's bytes (and the  field):The offset from the object's start to  is  +  + , which in turn is  + pointer to  +  + size of another pointer for the hash type:(which is  on x64)All put together:Gives:Note we had to handle the special case of , because than the character type is exactly  (which is 16 or 32 bits, depending on the platform).


Answer URL
https://docs.python.org/3/c-api/unicode.html#c.PyUnicode_KIND
https://docs.python.org/3/library/ctypes.html
