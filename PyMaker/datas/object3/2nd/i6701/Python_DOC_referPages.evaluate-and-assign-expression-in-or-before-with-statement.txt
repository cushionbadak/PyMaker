Natural Text
If I am correct,  statement doesn't introduce a local scope for the  statement.These are  examples from Learning Python:andIs the second example equivalent to the following rewritten in a way similar to the first example?What are their differences?Is the first example equivalent to the following rewritten in a way similar to the second example?What are their differences? 
When  enters a context, it calls a hook on the context manager object, called , and the return value of that hook can optionally be assigned to a name using . Many context managers return  from their  hook. If they do, then you can indeed take your pick between creating the context manager on a separate line or capturing the object with .Out of your two examples, only the file object returned from  has an  hook that returns . For ,  returns the same value as , so a boolean, not the lock object itself.You'll need to look for explicit documentation that confirms this; this is not always that clear however. For  objects, the relevant section of the documentation states:All of the objects provided by this module that have  and  methods can be used as context managers for a  statement. The  method will be called when the block is entered, and release() will be called when the block is exited.and for file objects, the  documentation is rather on the vague side and you have to infer from the example that the file object is returned.The main thing to take away is that returning  is not mandatory, nor is it always desired. Context managers are entirely free to return something else. For example, many database connection objects are context managers that let you manage the transaction (roll back or commit automatically, depending on whether or not there was an exception), where entering returns a new cursor object bound to the connection.To be explicit:for your  example, the two examples are for all intents and purposes exactly the same. Both call , and if that does not raise an exception, you end up with a reference to that file object named . In both cases the file object will be closed after the  statement is done. The name continues to exist after the  statement is done.There is a difference, but it is mostly technical. For , the file object is created, has it's  method called and then  is bound. For the  case,  is bound first,  called later.For your  example, using  will set  to a  (locking always either succeeds or blocks indefinitely this way).  This differs from the  case, where  is bound to the lock object.
Here's a good explanation.  I'll paraphrase the key part:The  statement could be thought of like this code:Here, “set things up” could be opening a file, or acquiring some sort of external resource, and “tear things down” would then be closing the file, or releasing or removing the resource. The try-finally construct guarantees that the “tear things down” part is always executed, even if the code that does the work doesn’t finish.


Answer URL
https://docs.python.org/3/library/threading.html#threading.Lock.acquire
https://docs.python.org/3/library/threading.html#using-locks-conditions-and-semaphores-in-the-with-statement
https://docs.python.org/3/library/io.html#io.IOBase
