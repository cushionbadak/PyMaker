Natural Text
Trying to parse XML, with ElementTree, that contains undefined entity (i.e. ) raises:  In Python 2.x XML entity dict can be updated by creating parser (documentation):but how to do the same with Python 3.x?Update: There was misunderstanding from my side, because I overlooked that I was calling  before trying to update XML entity dict, which was causing error with the parser. Luckily, @m.brindley was patient and pointed that XML entity dict still exists in Python 3.x and can be updated the same way as in Python 2.x
The issue here is that the only valid mnemonic entities in XML are , , ,  and . This means that almost all (X)HTML named entities must be defined in the DTD using the entity declaration markup defined in the XML 1.1 spec. If the document is to be standalone, this should be done with an inline DTD like so:The  in  uses an  to do the actual parsing. In the init arguments for , there is a space for 'predefined HTML entities' but that argument is not implemented yet. An empty dict named  is created in the init method and this is what is used to look up undefined entities.I don't think expat (by extension, the ET XMLParser) is able to handle switching namespaces to something like XHMTL to get around this. Possibly because it will not fetch external namespace definitions (I tried making  the default namespace for the data element but it did not play nicely) but I can't confirm that. By default, expat will raise an error against non XML entities but you can get around that by defining an external DOCTYPE - this causes the expat parser to pass undefined entity entries back to the 's  method.The  method does a look up of the  dict in the  instance and if it finds a matching key, it will replace the entity with the associated value. This maintains the Python-2.x syntax mentioned in the question.Solutions:If the data does not have an external DOCTYPE and has (X)HTML mnemonic entities, you are out of luck. It is not valid XML and expat is right to throw an error. You should add an external DOCTYPE.If the data has an external DOCTYPE, you can just use your old syntax to map mnemonic names to characters. Note: you should use  in py3k -  is not a valid name anymoreAlternatively, you could update  with  to map all valid HTML5 mnemonic entities to their characters.If the data is XHTML, you could subclass  to handle mnemonic entities but this won't return an  as desired.Here is the snippet I used - it parses XML with an external DOCTYPE through  (to demonstrate how to add entity handling by subclassing),  with entity mappings and  (which will just silently ignore undefined entities due to the external DOCTYPE). There is a valid XML entity () and an undefined entity () which I map to  with the .
I was having a similar issue and got around it by using lxml. Its  has a  keyword argument which forces it to try to ignore broken XML.


Answer URL
