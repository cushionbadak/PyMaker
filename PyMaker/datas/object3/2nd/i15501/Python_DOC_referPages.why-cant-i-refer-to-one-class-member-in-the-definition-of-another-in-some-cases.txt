Natural Text
How do you access other class variables from a list comprehension within the class definition?  The following works in Python 2 but fails in Python 3:Python 3.2 gives the error:Trying  doesn't work either.  Any ideas on how to do this in Python 3?A slightly more complicated motivating example:In this example,  would have been a decent workaround, but it is sadly removed from Python 3.
Class scope and list, set or dictionary comprehensions, as well as generator expressions do not mix.The why; or, the official word on thisIn Python 3, list comprehensions were given a proper scope (local namespace) of their own, to prevent their local variables bleeding over into the surrounding scope (see Python list comprehension rebind names even after scope of comprehension. Is this right?). That's great when using such a list comprehension in a module or in a function, but in classes, scoping is a little, uhm, strange.This is documented in pep 227:Names in class scope are not accessible.  Names are resolved in      the innermost enclosing function scope.  If a class definition      occurs in a chain of nested scopes, the resolution process skips      class definitions.and in the  compound statement documentation:The class’s suite is then executed in a new execution frame (see section Naming and binding), using a newly created local namespace and the original global namespace. (Usually, the suite contains only function definitions.) When the class’s suite finishes execution, its execution frame is discarded but its local namespace is saved. [4] A class object is then created using the inheritance list for the base classes and the saved local namespace for the attribute dictionary.Emphasis mine; the execution frame is the temporary scope.Because the scope is repurposed as the attributes on a class object, allowing it to be used as a nonlocal scope as well leads to undefined behaviour; what would happen if a class method referred to  as a nested scope variable, then manipulates  as well, for example? More importantly, what would that mean for subclasses of ? Python has to treat a class scope differently as it is very different from a function scope.Last, but definitely not least, the linked Naming and binding section in the Execution model documentation mentions class scopes explicitly:The scope of names defined in a class block is limited to the class block; it does not extend to the code blocks of methods – this includes comprehensions and generator expressions since they are implemented using a function scope. This means that the following will fail:So, to summarize: you cannot access the class scope from functions, list comprehensions or generator expressions enclosed in that scope; they act as if that scope does not exist. In Python 2, list comprehensions were implemented using a shortcut, but in Python 3 they got their own function scope (as they should have had all along) and thus your example breaks. Other comprehension types have their own scope regardless of Python version, so a similar example with a set or dict comprehension would break in Python 2.The (small) exception; or, why one part may still workThere's one part of a comprehension or generator expression that executes in the surrounding scope, regardless of Python version. That would be the expression for the outermost iterable. In your example, it's the :Thus, using  in that expression would not throw an error:This only applies to the outermost iterable; if a comprehension has multiple  clauses, the iterables for inner  clauses are evaluated in the comprehension's scope:This design decision was made in order to throw an error at genexp creation time instead of iteration time when creating the outermost iterable of a generator expression throws an error, or when the outermost iterable turns out not to be iterable. Comprehensions share this behavior for consistency.Looking under the hood; or, way more detail than you ever wantedYou can see this all in action using the  module. I'm using Python 3.3 in the following examples, because it adds qualified names that neatly identify the code objects we want to inspect. The bytecode produced is otherwise functionally identical to Python 3.2.To create a class, Python essentially takes the whole suite that makes up the class body (so everything indented one level deeper than the  line), and executes that as if it were a function:The first  there loads a code object for the  class body, then makes that into a function, and calls it. The result of that call is then used to create the namespace of the class, its . So far so good.The thing to note here is that the bytecode contains a nested code object; in Python, class definitions, functions, comprehensions and generators all are represented as code objects that contain not only bytecode, but also structures that represent local variables, constants, variables taken from globals, and variables taken from the nested scope. The compiled bytecode refers to those structures and the python interpreter knows how to access those given the bytecodes presented.The important thing to remember here is that Python creates these structures at compile time; the  suite is a code object () that is already compiled.Let's inspect that code object that creates the class body itself; code objects have a  structure:The above bytecode creates the class body. The function is executed and the resulting  namespace, containing  and  is used to create the class (except that it doesn't work because  isn't defined as a global). Note that after storing  in , it loads another code object; that's the list comprehension; it is wrapped in a function object just like the class body was; the created function takes a positional argument, the  iterable to use for its looping code, cast to an iterator. As shown in the bytecode,  is evaluated in the class scope.From this you can see that the only difference between a code object for a function or a generator, and a code object for a comprehension is that the latter is executed immediately when the parent code object is executed; the bytecode simply creates a function on the fly and executes it in a few small steps.Python 2.x uses inline bytecode there instead, here is output from Python 2.7:No code object is loaded, instead a  loop is run inline. So in Python 3.x, the list generator was given a proper code object of its own, which means it has its own scope.However, the comprehension was compiled together with the rest of the python source code when the module or script was first loaded by the interpreter, and the compiler does not consider a class suite a valid scope. Any referenced variables in a list comprehension must look in the scope surrounding the class definition, recursively. If the variable wasn't found by the compiler, it marks it as a global. Disassembly of the list comprehension code object shows that  is indeed loaded as a global:This chunk of bytecode loads the first argument passed in (the  iterator), and just like the Python 2.x version uses  to loop over it and create its output.Had we defined  in the  function instead,  would be a cell variable (cells refer to nested scopes):The  will indirectly load  from the code object cell objects:The actual referencing looks the value up from the current frame data structures, which were initialized from a function object's  attribute. Since the function created for the comprehension code object is discarded again, we do not get to inspect that function's closure. To see a closure in action, we'd have to inspect a nested function instead:So, to summarize:List comprehensions get their own code objects in Python 3, and there is no difference between code objects for functions, generators or comprehensions; comprehension code objects are wrapped in a temporary function object and called immediately.Code objects are created at compile time, and any non-local variables are marked as either global or as free variables, based on the nested scopes of the code. The class body is not considered a scope for looking up those variables.When executing the code, Python has only to look into the globals, or the closure of the currently executing object. Since the compiler didn't include the class body as a scope, the temporary function namespace is not considered.A workaround; or, what to do about itIf you were to create an explicit scope for the  variable, like in a function, you can use class-scope variables for a list comprehension:The 'temporary'  function can be called directly; we replace it when we do with its return value. Its scope is considered when resolving :Of course, people reading your code will scratch their heads over this a little; you may want to put a big fat comment in there explaining why you are doing this.The best work-around is to just use  to create an instance variable instead:and avoid all the head-scratching, and questions to explain yourself. For your own concrete example, I would not even store the  on the class; either use the output directly (don't store the generated class at all), or use a global:
In my opinion it is a flaw in Python 3. I hope they change it.Old Way (works in 2.7, throws  in 3+):NOTE: simply scoping it with  would not solve itNew Way (works in 3+): Because the syntax is so ugly I just initialize all my class variables in the constructor typically 
The accepted answer provides excellent information, but there appear to be a few other wrinkles here -- differences between list comprehension and generator expressions. A demo that I played around with:
This is a bug in Python. Comprehensions are advertised as being equivalent to for loops, but this is not true in classes. At least up to Python 3.6.6, in a comprehension used in a class, only one variable from outside the comprehension is accessible inside the comprehension, and it must be used as the outermost iterator. In a function, this scope limitation does not apply.To illustrate why this is a bug, let's return to the original example. This fails:But this works:The limitation is stated at the end of this section in the reference guide.
Since the outermost iterator is evaluated in the surrounding scope we can use  together with  to carry the dependencies over to the comprehension's scope:One can also use nested  loops in the comprehension and include the dependencies in the outermost iterable:For the specific example of the OP:


Answer URL
https://docs.python.org/3/reference/executionmodel.html#resolution-of-names
https://docs.python.org/3/library/functions.html#zip
https://docs.python.org/3/library/itertools.html#itertools.repeat
