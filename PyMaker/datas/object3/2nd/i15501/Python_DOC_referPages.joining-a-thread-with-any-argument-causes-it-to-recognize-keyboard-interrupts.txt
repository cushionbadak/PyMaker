Natural Text
Is there any way to wait for termination of a thread, but still intercept signals? Consider the following C program:It ends after one second and prints:In contrast, here's my attempt to write it in Python:It prints:How do I make it behave like the C version?
Threads in Python are somewhat strange beasts given the global interpreter lock. You may not be able to achieve what you want without resorting to a join timeout and isAlive as eliben suggests.There are two spots in the docs that give the reason for this (and possibly more).The first:From http://docs.python.org/library/signal.html#module-signal:Some care must be taken if both  signals and threads are used in the  same program. The fundamental thing to  remember in using signals and threads  simultaneously is: always perform  signal() operations in the main thread  of execution. Any thread can perform  an alarm(), getsignal(), pause(),  setitimer() or getitimer(); only the  main thread can set a new signal  handler, and the main thread will be  the only one to receive signals (this  is enforced by the Python signal  module, even if the underlying thread  implementation supports sending  signals to individual threads). This  means that signals can’t be used as a  means of inter-thread communication.  Use locks instead.The second, from http://docs.python.org/library/thread.html#module-thread:Threads interact strangely with interrupts: the KeyboardInterrupt exception will be  received by an arbitrary thread. (When the signal module is available, interrupts  always go to the main thread.)EDIT: There was a decent discussion of the mechanics of this on the python bug tracker here: http://bugs.python.org/issue1167930. Of course, it ends with Guido saying: " That's unlikely to go away, so you'll just have to livewith this.  As you've discovered, specifying a timeout solves the issue(sort of)."  YMMV :-)
Jarret Hardie already mentioned it: According to Guido van Rossum, there's no better way as of now: As stated in the documentation,  blocks (and that means no signals). The alternative - calling with a huge timeout ( or so) and checking  looks great. However, the way Python handles timers is disastrous, as seen when running the python test program with  instead of :I.e., Python wakes up every 50 ms, leading to a single application keeping the CPU from sleeping.
Poll on  before calling . This polling can be interrupted, of course, and once the thread isn't ,  is immediate.An alternative would be polling on  with a timeout, checking with  whether the timeout occurred. This can spend less CPU than the previous method.
As far as I understand, a similar question is solved in The Little Book of Semaphores (free download), appendix A part 3…
I know I'm a bit late to the party, but I came to this question hoping for a better answer than joining with a timeout, which I was already doing. In the end I cooked something up that may or may not be a horrible bastardisation of signals, but it involves using  instead of  and signalling the current process when the thread reaches the end of its execution:If you want to see the SIGTERMs in action, extend the length of the sleep time in  and issue a  command from another terminal, where  is the pid id printed at the start.I post this as much in the hope of helping others as being told that this is crazy or has a bug. I'm not sure if the lock on threadcount is still necessary - I put it in there early in my experimentation and thought I should leave it in there in case.


Answer URL
https://docs.python.org/3/library/_thread.html#_thread.lock.acquire
