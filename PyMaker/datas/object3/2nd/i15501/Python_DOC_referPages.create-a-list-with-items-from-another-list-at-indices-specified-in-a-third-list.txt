Natural Text
Consider two lists:I want a resulting list  whereis a list of length  with values taken from  defined by indices specified in  and zeros elsewhere.What is the most elegant way of doing this?
Use a list comprehension with the conditional expression and .This LC will iterate over the index and the value of the list  and if the index  is found within  then it will set the element to , otherwise it'll set it to 0.Note: If  is large then you may be best converting to a set first, before using . The time complexity for using  with a list is O(n) whilst for a set it is O(1) (in the average case for both).The list comprehension is roughly equivalent to the following code (for explanation):As you have the option of using  I've included a simple method below which uses initialises an array filled with zeros and then uses list indexing to replace the elements.When timing the three methods (my list comp, my numpy, and Jon's method) the following results are given for , , and .This is to be expected. The numpy function is fastest, but both Jon's function and the numpy are much faster than a list comprehension. If I increased the number of elements to 100,000 then the gap between numpy and Jon's method gets even larger. Interestingly enough though, for small  Jon's function is the best! I suspect this is to do with the overhead of creating numpy arrays being trumped by the overhead of lists. Moral of the story: large N? Go with numpy. Small N? Go with Jon.
The other option is to pre-initialise the target list with s - a fast operation, then over-write the value to the suitable index, eg:


Answer URL
https://docs.python.org/3/reference/expressions.html#conditional-expressions
