Natural Text
I frequently need to sort a collection of files that contain headers. Because sorting depends on the contents of the header, this use case is more complicated that similar questions (e.g., Is there a way to ignore header lines in a UNIX sort?).I was hoping to use Python to read files, output the header of the first file, then pipe the tails into sort. I've tried this as a proof of concept:When called as , with fileA and fileB containing lines likeI get:The problem is communicate takes a string and the pipe is closed after writing. This means that the content must be read fully into memory. communicate doesn't take a generator (I tried).An even simpler demonstration of this is:So, the question is, what's the right way (with Popen or otherwise) to stream data into a pipe in Python?
Just write to the pipe directly:
For your specific case, if you only passed  for a single standard handle (in your case, ), then in your example, you can safely call  over and over. When you're finished writing output, call  so  knows the input is finished, and it can perform the actual sort and output work ( with no argument would probably work too; otherwise, after closing  you'd probably want to call  to let it finish).If you need to deal with more than one piped standard handle, the right way is either  with a dedicated thread for each pipe that must be handled beyond the first (relatively simple in concept, but heavyweight and introduces all the headaches of threading), or using the  module (or in Python 3.4+, the  module), which is quite tricky to get right, but can (under some circumstances) be more efficient. Lastly, there is creating temporary files for output, so you can write directly to the process's  while the process writes to a file (and therefore won't block); you can then read the file at your leisure (note that the subprocess won't necessarily have flushed it's own output buffers until it exits, so the output may not arrive promptly in response to your input until further inputs and outputs have filled and flushed the buffer).'s  method uses either threads or  module primitives itself (depending on OS support; the implementation is under the various  methods here) whenever you pass  for more than one of the standard handles; it's how you have to do it.
You can use writing/reading from  and , however depending on your subprocess, you need a "flushing mechanism" for the subprocess to process your input. The below code works for the first part, but since it closes , it also kills the subprocess. If you change it with  or if you can add some trailing characters to push your subprocess, then you can use it. Else, I would recommend to take a look at Multithreading in Python, especially .


Answer URL
https://docs.python.org/3/library/threading.html
https://docs.python.org/3/library/select.html
https://docs.python.org/3/library/selectors.html
https://docs.python.org/3/library/tempfile.html
