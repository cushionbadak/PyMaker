Natural Text
How do I mock async call from one native coroutine to other one using ?I currently have quite an awkward solution:Then This works but looks ugly. Is there more pythonic way to do this?
Subclassing  will propagate your custom class for all the mocks generated from your coroutine mock. For instance,  will also become an  which is probably not what you're looking for.Instead, you might want to define a factory that creates a  (or a ) with custom arguments, for instance . Also, it might be a good idea to separate the coroutine function from the coroutine (as explained in the documentation). Here is what I came up with:An explanation of the different objects:: the coroutine function mock: the coroutine, generated for each call: the mock used by the coroutine to get the result: the value returned by the coroutine: might be used to raise an exceptionExample:
The solution was actually quite simple:I just needed to convert  method of mock into coroutine:This works perfectly, when mock is called, code receives native coroutine
Everyone's missing what's probably the simplest and clearest solution:remember a coroutine can be thought of as just a function which is guaranteed to return a future which can, in turn be awaited.
Another way of mocking coroutine is to make coroutine, that returns mock. This way you can mock coroutines that will be passed into  or .This makes more universal coroutines though makes setup of tests more cumbersome:
Based on @scolvin answer I created this (imo) cleaner way:That's it, just use it around whatever return you want to be async, as in
One more variant of "simplest" solution to mock a async object, which is just a one liner.In source:In test:


Answer URL
https://docs.python.org/3/library/asyncio-task.html#coroutines
