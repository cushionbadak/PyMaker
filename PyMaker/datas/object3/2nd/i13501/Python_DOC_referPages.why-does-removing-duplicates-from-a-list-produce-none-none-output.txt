Natural Text
I am new to Python and I'm not able to understand why I am getting the results with None values.When I print the result it shows the following: [None, None]PS: I've seen other solutions and also aware of the list(set(list)) but I am trying to understand why the above result with integers gives [None, None] output.
Although using a set is the proper way, the problem with your code, as the comments indicated, is that you are not actually returning  from your function, you are returning the result of the list comprehension.Here I simply made a throwaway variable  that is useless, it just "runs" the comprehension. Understand?That comprehension is storing a value each time you call  ... and that value is the result of the  method, which is ! So  equals .However, your  is in fact being populated correctly, so we can return that and now your function works as expected.Of course, this is not a normal use for a list comprehension and really weird.
The problem with your code is that the method  returns None. You can test this easily with the following code:So, a solution for you would issue would beThe idea is that you will begin with an empty list of aldeady included elements and you will loop over all the elements in list, including them in the  list. The  is necessary because the  will return  and  is , so the if will not be affected by the inclusion.You were including a list of the result of the appends (always ), but what you need is a list of the elements that passed the  test.I hope it helps.
As the other answers have explained, the reason you're getting a list of  values is because  returns , and you're calling it in a list comprehension. That means you're building a list full of  values along side your list of unique values.I would like to suggest that you ditch the list comprehension. Because you need to access outside state (the list of unique values seen so far), a comprehension can't easily do what you want. A regular  loop is much more appropriate:A more Pythonic approach however would be to use a  to handle the unique items, and to make your function a generator:The  function from the standard library can help improve this even further, as shown in the recipe in the docs (you'll have to scroll down a little to find the specific recipe):


Answer URL
https://docs.python.org/3/library/itertools.html#itertools-recipes
