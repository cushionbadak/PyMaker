Natural Text
Say there's a function that I need to examine.As a part of the examination I want to "retrieve" source code or objects of all nested classes and functions (if any). However I do realize that they don't exist yet and there's no direct/clean way of accessing them without running  or definingthem outside (before) . Unfortunately, the most I can do is import a module containing  to obtain the  function object.I discovered that functions have the  attribute containing the  object, which has the  attribute so I wrote this:Those  objects look awfully similar and I don't think they contain data necessary to help me distinguish between types of objects they represent (e.g.  and ).Q1: Am I right?Q2: Is there any way to access classes/functions (ordinary and lambdas) defined within the function body?
A1: Things that can help you are -Constants of the code objectFrom the documentation:If a code object represents a function, the first item in co_consts is  the documentation string of the function, or None if undefined.Also, if a code object represents a class, the first item of  is always the qualified name of that class. You can try to use this information.The following solution will correctly work in most cases, but you'll have to skip code objects Python creates for list/set/dict comprehensions and generator expressions:printsCode flagsThere's a way to get the required information from . Citing the documentation I linked above:The following flag bits are defined for co_flags: bit 0x04 is set if  the function uses the *arguments syntax to accept an arbitrary number  of positional arguments; bit 0x08 is set if the function uses the  **keywords syntax to accept arbitrary keyword arguments; bit 0x20 is set if the function is a generator.Other bits in co_flags are reserved for internal use.Flags are manipulated in  (Python/compile.c):There're 2 code flags ( and ) that won't be set for classes. You can use them to check the type (doesn't mean you should - poorly documented implementation details may change in the future):The output is exactly the same.Bytecode of the outer functionIt's also possible to get object type by inspecting the bytecode of the outer function.Search bytecode instructions to find blocks with , it  signifies the creation of a class ( - Pushes builtins.__build_class__() onto the stack. It is later called by CALL_FUNCTION to construct a class.)The output is the same (again).A2: Sure.Source codeIn order to get the source code for code objects, you'd use  or equivalent:For instance  (see below)must yield source code for the first , ,  (including ) and :Function and type objectsIf you still need a function/class object, you can / the source code. Examplefor  functions:for regular functionsfor classes
https://docs.python.org/3/library/dis.html#dis.dis


Answer URL
https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy
https://docs.python.org/3/library/dis.html
https://docs.python.org/3/library/inspect.html#inspect.getsource
https://docs.python.org/3/library/functions.html#eval
https://docs.python.org/3/library/functions.html#exec
https://docs.python.org/3/library/dis.html#dis.dis
