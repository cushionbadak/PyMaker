Natural Text
I'm trying to run this:with:However, Python returns: struct.error: unpack requires a string argument of length 4According to python  documentation : The string must contain exactly the amount of data required by the format (len(string) must equal calcsize(fmt)).So if the length of my string is 2 and calcsize of  is also 2, why does python say "unpack requires a string argument of length 4" ??EDIT : Thanks for all your answers. Here is the full code:http://qtwork.tudelft.nl/gitdata/users/guen/qtlabanalysis/analysis_modules/general/lecroy.pySo as you can see in the  function,  is set to  or  in a  statement. Printing it confirmes that.But you should also know that I'm working on windowsx64 (for work).EDIT2Here's the full traceback, sorry for the mistake.EDIT3:I replaced  by  and add : to  function.Here's the new traceback : 
FWIW, you should be using , not . And if the  string really is  you should not be getting that error. Here's a short demo that performs as expected.outputBTW,  always returns a tuple, even if the return value is a single item.Using  on a binary file can give unexpected results. In my test file in the above code there's a (Linux-style) newline  in the file. So if you change  to  everything works fine at first, but on line 10 it crashes because it only reads a single byte, due to that newline char:outputpostscriptYou have several functions in your code that almost do the same thing. That breaks the DRY principle: Don't Repeat Yourself. Here's one way to fix that, using partial function application. See the functools docs for more info.You need to use keywords to call these new functions. Eg,True, that's slightly more long-winded, but it makes the code a little more readable.
The length of the format is rather unimportant on its own. Whatâ€™s important is what kind of formats you specify there. There are for example format specifications which specify one byte or even eight bytes. So it really depends on the format how many characters there should be in .For example:If  is really  as you say, then it should work fine:So I assume that when the error appears,  is not just , but something else that would consume an additional 2 bytes. Try printing  before the .
As  = 1, it means that  has value.  If  = 'h', then  will be 'hh'.  Therefore, unpack() will expect 4 bytes data as each 'h' required a short integer (2 bytes).


Answer URL
https://docs.python.org/3/library/functools.html?module-functools#functools.partial
