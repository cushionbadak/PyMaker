Natural Text
I have a list of tuples similar to A:In each row of this list, there might be tuples which their second and third elements are the same. For example in A[0]:(90, 1, 5), (1000, 1, 5) and (176, 1, 5) have the same second and third elements. Among these, I need to keep the one which has the max value for the first element and remove the other two. So, I should be able to keep (1000, 1, 5) and remove (90, 1, 5) and (176, 1, 5) from A[0].It would be better to keep the ordering of the list.Is there any way to do that iteratively for all the rows in A? Any help would be appreciated!
If I understand correctly, here's an  solution. I'm assuming order in the final result does not matter.In action:
This solution keeps the original ordering of the tuples assuming each tuple (as a whole) is unique; in the case there are duplicates tuples this will return the last appearance of each tuple:Output
If you can afford to ignore ordering, you can use  to group elements by the 2nd and 3rd elements on a list sorted by ascending order of 2nd and 3rd elements and descending order of the first element. Then the first element of each group is your desired choice:Output
You can do this by using a hashmap as follows:
Using dictionaries:Using this, your dict will transform A[0] fromto and can then be converted back to an array using iteritemsThis way, the order will also be preserved.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.groupby
