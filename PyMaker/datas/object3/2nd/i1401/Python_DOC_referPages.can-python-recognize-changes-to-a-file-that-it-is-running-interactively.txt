Natural Text
I was doing some trouble shooting and I was curious if it is possible to run a python script interactively, change a function defined in the script, save the file, then have the interactive shell recognize the changes. Here is an example of what I am doing currently:my_script.py:I go to my terminal and run:If I go back to my_script.py in my editor and make the following change:Then go back to the terminal (which is still open) and re-run the updated function:Is it possible to do something to instead get the following behavior?:I know it is possible to reload modules using importlib and reload but as far as I can tell that does not apply here since I am not importing anything. I am fairly new to stackoverflow so please let me know if I need to provide more details or ask in a different way. Thanks.  Edit; I think this may be distinct from How do I unload (reload) a Python module?.I am asking if there is a way to reload the current file you are running interactively through the python shell, while that question is asking about reloading a module you have imported into another python script. I edited my answer to include a reference to this question.
From what I can find, the short answer is:No, normally the Python interpreter does not recognize changes to a file once that file has been parsed, analyzed, and fed into the interpreter.What you should do instead apparently is use your .py file as a module, import that as a module into another .py file, then run that new file. This allows your first file to be reloaded through the interactive interpreter. Here's an example:I am still a little fuzzy on the details, but maybe someone can help fill those in. As far as I can tell from the sources I linked below, the interpreter basically takes some steps to load your program from the saved python file into memory (glossing over a lot of details). Once this process has been performed, the interpreter does not perform it again unless you explicitly ask it to do so, for example by using the importlib's reload() function to again perform the process.Sources:How do I unload (reload) a Python module? (quoted above)A Python Interpreter Written in Python:This link has a lot more information about how the interpreter works, and I found this section particularly helpful:Real Python Bytecode  At this point, we'll abandon our toy instruction  sets and switch to real Python bytecode. The structure of bytecode is  similar to our toy interpreter's verbose instruction sets, except that  it uses one byte instead of a long name to identify each instruction.  To understand this structure, we'll walk through the bytecode of a  short function. Consider the example below:Python exposes a boatload of its internals at run time, and we can access them right  from the REPL. For the function object cond, cond.code is the code  object associated it, and cond.code.co_code is the bytecode.  There's almost never a good reason to use these attributes directly  when you're writing Python code, but they do allow us to get up to all  sorts of mischief—and to look at the internals in order to understand  them.When we just print the bytecode, it  looks unintelligible—all we can tell is that it's a series of bytes.  Luckily, there's a powerful tool we can use to understand it: the dis  module in the Python standard library.dis is a bytecode disassembler. A disassembler takes low-level code  that is written for machines, like assembly code or bytecode, and  prints it in a human-readable way. When we run dis.dis, it outputs an  explanation of the bytecode it has passed.What does all this mean? Let's look at the first instruction LOAD_CONST as an example. The number in the  first column (2) shows the line number in our Python source code. The  second column is an index into the bytecode, telling us that the  LOAD_CONST instruction appears at position zero. The third column is  the instruction itself, mapped to its human-readable name. The fourth  column, when present, is the argument to that instruction. The fifth  column, when present, is a hint about what the argument means.How does the Python Runtime actually work?:  With Python, it uses an interpreter rather than a compiler. An  interpreter works in exactly the same way as a compiler, with one  difference: instead of code generation, it loads the output in-memory  and executes it directly on your system. (The exact details of how  this happens can vary wildly between different languages and different  interpreters.)importlib — The implementation of import:  When reload() is executed:Python module’s code is recompiled and the module-level code  re-executed, defining a new set of objects which are bound to names in  the module’s dictionary by reusing the loader which originally loaded  the module. The init function of extension modules is not called a  second time.Again, please let me know if I need to edit this answer to follow etiquette.


Answer URL
https://docs.python.org/3/library/importlib.html
