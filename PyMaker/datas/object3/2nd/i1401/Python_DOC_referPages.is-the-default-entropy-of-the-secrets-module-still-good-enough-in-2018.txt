Natural Text
In the documentation it says:As of 2015, it is believed that 32 bytes (256 bits) of randomness is sufficient for the typical use-case expected for the secrets module.and below there is a note:Note: That default is subject to change at any time, including during maintenance releases. And you can see in the source of Python 3.7 that 32 bytes is still the default value. Is it safe? Is there any schedule to change it or reevaluating this setting?
The answer to the entropy question is, yes, 256-bit secrets can't be brute forced and won't become practical to brute force any time soon. However you will need to use larger keys with asymmetric cryptographic algorithms. It's also harder to predict how strong those types of keys are. Key strength and key length are not always the same. (256-bit RSA does not have 256-bit strength.) The world of asymmetric algorithms has more of an arms-race quality than symmetric algorithms.I frequently see brute force effort related to Bitcoin hash rates or DES cracking hardware. You can't directly translate performance metrics for these two purposes into brute force performance metrics targeting other algorithms, but we can use them for the purpose of estimation.It looks like the peak estimated hash rate for Bitcoin 2018 is about 60 million terra-hashes per second. Let's round 60 * 106+12 hashes per second up to the next power of two, 266, for ease of calculation.Let's now assumeWe improve efficiency of our hardware. Say some new technology does one million times as much work as modern day hardware while using the same amount of energy.Humanity manages to  generate a million times as much electricty somehow. (Maybe using fusion or magic.)Say we get new technology and our computer clock speed increases by a factor of one million.Our GPUs have one million times as many cores or we can shrink computer sizes by the same factor.Humanity populates other star systems and we increase our population by a factor of one million.Every human can afford one million times as many computers as they can now and they all want to guess your 256-bit secret.Let's pretend that each improvement is orthogonal and that our brute force power scales linearly with all of those improvements. Lets round each one-million to 220. Our new performance measure is 266+6(20) = 2186 guesses per second. How long would it take to test every possible 256-bit value?It takes 2256 / 2186 = 2256-186 = 270 seconds. That's over 37 trillion years. Thousands of times longer than the time elapsed since the Big Bang. So using 256-bits of entropy is fairly conservative. (And with what technology and resources we currently have in the real world we can't even brute force 128-bit secrets.)Quantum computers aren't a huge concern regarding symmetric algorithms. If we use 256-bit symmetric keys then it will still take 2128 function evaluations using Grover's algorithm. However it would be reasonable to assume that the cost of n evaluations on a quantum computer is at least the cost of n evaluations on a classical computer.If you generate many random values and expect each one to be unique you need to use twice as many bits as you might think you would need due to the birthday problem. Generic collision attacks on a k-bit hash function cost about the equivalent of 2k/2 hash function evaluations. For quantum computers it could be 2k/3. (So don't mix up key length and hash function output lengths.)These generic attacks assume an ideal function. Specific algorithms may be "cracked", meaning that an attack better than brute force is discovered.It's important that whatever secrets you generate are derived using unpredictable inputs. If you want an n-bit security level you need to have n-bits of entropy. (So you can't use Mersenne Twister or PCG and you can't initialize your RNG using system time or a password.)256 bits of entropy is good in 2018 and, barring inconceivable sci-fi-like technological advances or magic, will still be secure in the year 3018.Also, see Landauer's principle, which limits how efficiently we can make calculations. I'm not even going to try to translate this time-based argument to a dollar amount for obvious reasons.
Yes, 256 bits is still considered enough.See the section from an article by Bruce Schneier - "Warning Sign #5: Ridiculous key lengths":Longer key lengths are better, but only up to a point. AES will have 128-bit, 192-bit, and 256-bit key lengths. This is far longer than needed for the foreseeable future. In fact, we cannot even imagine a world where 256-bit brute force searches are possible. It requires some fundamental breakthroughs in physics and our understanding of the universe. For public-key cryptography, 2048-bit keys have same sort of property; longer is meaningless.For more detailed info, read RFC 4086 - Randomness Requirements for Security:3.1.  Volume RequiredFor AES, the key can be 128 bits, and, as we show in an example in Section 8, even the highest security system is unlikely to require strong keying material of much over 200 bits.Also, entropy - you still need a good source of randomness. It's a different factor than the length of the key.


Answer URL
https://docs.python.org/3/library/secrets.html#how-many-bytes-should-tokens-use
https://docs.python.org/3/library/os.html#os.urandom
