Natural Text
I have a metaclass that defines a class level attribute which should be unique for each subclass but shared across instances of each subclass.Now I'd like to implement a decorator that appends the decorated class method to valid_funcs within the derived class. However because the derived class is still being defined I don't have a reference to the derived decorator so I end up appending to the base class. Here's my code:This prints:I want:
There is no class object yet when decorators on functions in the class body are executed. The class body is executed first, then the class is created.Instead of having the decorator look for a class attribute to mutate, add an attribute to a decorated function object. The metaclass, or the  implementation then looks for any objects with this attribute and adds them to the list once the class object has been created.I'm going to assume you'd want to retain the order in which the decorators would have added the decorated items to the list:and in the metaclass:Note that if you are using Python 3.6 or newer, then you don't need a metaclass at all any more. You can put the same logic into the  method.Note that this registers unbound objects. For  objects, that means the call will fail with:You perhaps want to register the  attribute in that case, or use  to 'bind' the object to something (a  ignores the binding context anyway)`.If you bind explicitly, in the  method, then you don't actually have to use  objects:Now  will work with ,  and regular functions.And if you have the  method look for the methods, then binding can be done for you. You can choose to support inheritance here by just using  and : gives you a bound object, no further binding necessary.
While having the metaclass  handle adding functions to  is an option, another option would be to inject  into the namespace of the class body before the class even exists, using :I'd probably skip all the metaclass stuff and require classes to do  themselves, though. The additional complexity of a metaclass isn't worth it just to save one line of boilerplate per class.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__init_subclass__
https://docs.python.org/3/reference/datamodel.html#preparing-the-class-namespace
