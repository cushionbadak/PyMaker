Natural Text
Tried to write a process-based timeout (sync) on the cheap, like this:But it seems the  argument passed to future.result doesn't really work as advertised.OK.Not OK - unblocked after 5 seconds, not 3 seconds.Related questions show how to do this with thread pools, or with signal. How to timeout a process submitted to a pool after n seconds, without using any _private API of multiprocessing? Hard kill is fine, no need to request a clean shutdown.
You might want to take a look at . Its  was designed to solve this exact issue: enable timeout and cancellation of running tasks without the need of shutting down the entire pool.When a future times out or is cancelled, the worker gets actually terminated effectively stopping the execution of the scheduled function.Timeout:Example:
The timeout is behaving as it should.  stops after the given timeout. Shutting down the pool still waits for all pending futures to finish executing, which causes the unexpected delay.You can make the shutdown happen in the background by calling , but the overall Python program won't end until all pending futures finish executing anyway:The Executor API offers no way to cancel a call that's already executing.  can only cancel calls that haven't started yet. If you want abrupt abort functionality, you should probably use something other than .


Answer URL
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future.result
https://docs.python.org/3/library/signal.html#signal.alarm
