Natural Text
I have a program that loads data and processes it.  Both loading and processing take time, and I'd like to do them in parallel.  Here is the synchronous version of my program (where the "loading" and "processing" are done in sequence, and are trivial operations here for the sake of the example):When I run this, I get output: The loop runs every 2s, with 1s for loading and 1s for processing.  Now, I'd like to make an asynchronous version, where the loading and processing are done concurrently (so the loader gets the next data ready while the processor is processing it).  It should then take 2s for the first statement to be printed, and 1s for each statement after that.  Expected output would be similar to: Ideally, only contents of the  function would have to change (as the  code should not care that it may be used in an asynchronous way).
The  module's utilities may be what you want.This outputsDepending on your requirements, you may find  to be faster, and it's also worth knowing that there's a thread-based version of  available as  â€“ this may be useful to avoid IPC overhead if your data is large, and your processing is not done in Python (so you can avoid the GIL).
The key of your problem is in the actual processing of the data. I don't know what you're doing with the data in your real program, but it must be an asynchronous operation to use asynchronous programming. If you're doing active, blocking CPU-bound processing, you might be better offloading to a separate process, instead, to be able to use multiple CPU cores and do things concurrently. If the actual processing of the data is in fact just the consumption of some asynchronous service, then it can be wrapped in a single asynchronous concurrent thread very effectively.In your example, you're using  to simulate the processing. Since that example operation can be done asynchronously (by using  instead) then the conversion is simple:The results, as you expect:Remember that it only works because  has an asynchronous alternative in the form of . Check the operation you're using, to see if it can be written in asynchronous form.
Here is a solution that allows you to wrap the dataloader with an  function.  It solves the problem for now.  (Note however that there is still the problem that if the dataloader is faster than the processing loop, the queue will grow indefinitely.  This could easily be solved by adding a wait in  if the queue gets to big (but sadly  is not supported on Mac!))The output is now as desired:


Answer URL
https://docs.python.org/3/library/multiprocessing.html
