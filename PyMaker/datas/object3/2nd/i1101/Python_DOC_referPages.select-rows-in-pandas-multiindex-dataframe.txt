Natural Text
Objective and MotivationThe  API has been gaining popularity over the years, however, not everything about it is fully understood in terms of the structure, working, and associated operations. One important operation is filtering. Filtering is a common requirement, but the use cases are diverse. Accordingly, certain methods and functions will be more applicable to some use cases than others. In summary, the aim of this post is to touch upon some common filtering problems and use cases, demonstrate various different methods to solve these problems, and discuss their applicability. Some of the high-level questions this post seeks to address areSlicing based on a single value/labelSlicing based on multiple labels from one or more levelsFiltering on boolean conditions and expressionsWhich methods are applicable in what circumstancesThese problems have been broken down into 6 concrete questions, enumerated below. For simplicity, the example DataFrames in the setup below only have two levels, and do not have duplicate index keys. Most solutions presented to the problems can generalize to N levels. This post will not go through how to create MultiIndexes, how to perform assignment operations on them, or any performance related discussions (these are separate topics for another time). QuestionsQuestion 1-6 will be asked in context to the setup below.Question 1: Selecting a Single ItemHow do I select rows having "a" in level "one"? Additionally, how would I be able to drop level "one" in the output?Question 1bHow do I slice all rows with value "t" on level "two"?Question 2: Selecting Multiple Values in a LevelHow can I select rows corresponding to items "b" and "d" in level "one"?Question 2bHow would I get all values corresponding to "t" and "w" in level "two"?Question 3: Slicing a Single Cross Section How do I retrieve a cross section, i.e., a single row having a specific values for the index from ? Specifically, how do I retrieve the cross section of , given byQuestion 4: Slicing Multiple Cross Sections How do I select the two rows corresponding to , and ?Question 5: One Item Sliced per LevelHow can I retrieve all rows corresponding to "a" in level "one" and "u" in level "two"?Question 6: Arbitrary SlicingHow can I slice specific cross sections? For "a" and "b", I would like to select all rows with sub-levels "u" and "v", and for "d", I would like to select rows with sub-level "w".Question 7 will use a unique setup consisting of a numeric level:Question 7: Inequality-based filtering on Numeric LevelsHow do I get all rows where values in level "two" are greater than 5?
MultiIndex / Advanced IndexingNote  This post will be structured in the following manner: The questions put forth in the OP will be addressed, one by oneFor each question, one or more methods applicable to solving this problem and getting the expected result will be demonstrated.Notes (much like this one) will be included for readers interested in learning about additional functionality, implementation details,  and other info cursory to the topic at hand. These notes have been  compiled through scouring the docs and uncovering various obscure  features, and from my own (admittedly limited) experience.All code samples have created and tested on pandas v0.23.4, python3.7. If something is not clear, or factually incorrect, or if you did not  find a solution applicable to your use case, please feel free to  suggest an edit, request clarification in the comments, or open a new  question, ....as applicable.Here is an introduction to some common idioms (henceforth referred to as the Four Idioms) we will be frequently re-visiting - A general solution for selection by label (+  for more complex applications involving slices)  - Extract a particular cross section from a Series/DataFrame. - Specify slicing and/or filtering operations dynamically (i.e., as an expression that is evaluated dynamically. Is more applicable to some scenarios than others. Also see this section of the docs for querying on MultiIndexes.Boolean indexing with a mask generated using  (often in conjunction with , especially when filtering with multiple values). This is also quite useful in some circumstances.It will be beneficial to look at the various slicing and filtering problems in terms of the Four Idioms to gain a better understanding what can be applied to a given situation. It is very important to understand that not all of the idioms will work equally well (if at all) in every circumstance. If an idiom has not been listed as a potential solution to a problem below, that means that idiom cannot be applied to that problem effectively.Question 1How do I select rows having "a" in level "one"? You can use , as a general purpose solution applicable to most situations:At this point, if you getThat means you're using an older version of pandas. Consider upgrading! Otherwise, use .Alternatively, you can use  here, since we are extracting a single cross section. Note the  and  arguments (reasonable defaults can be assumed here). Here, the  argument is needed to prevent  from dropping level "one" in the result (the level we sliced on).Yet another option here is using :If the index did not have a name, you would need to change your query string to be .Finally, using :Additionally, how would I be able to drop level "one" in the output?This can be easily done using eitherOr,Notice that we can omit the  argument (it is assumed to be  by default).Note  You may notice that a filtered DataFrame may still have all the levels, even if they do not show when printing the DataFrame out. For example,You can get rid of these levels using :Question 1bHow do I slice all rows with value "t" on level "two"?Intuitively, you would want something involving : It Just Works!™ But it is clunky. We can facilitate a more natural slicing syntax using the  API here.This is much, much cleaner.Note  Why is the trailing slice  across the columns required? This is because,  can be used to select and slice along both axes ( or  ). Without explicitly making it clear which axis the slicing  is to be done on, the operation becomes ambiguous. See the big red box in the documentation on slicing.If you want to remove any shade of ambiguity,  accepts an   parameter:Without the  parameter (i.e., just by doing ), slicing is assumed to be on the columns,  and a  will be raised in this circumstance. This is documented in slicers. For the purpose of this post, however, we will explicitly specify all axes.    With , it is With , it is And finally, with , you may doAll to the same effect.Question 2How can I select rows corresponding to items "b" and "d" in level "one"?Using loc, this is done in a similar fashion by specifying a list.To solve the above problem of selecting "b" and "d", you can also use :Note  Yes, the default parser is , but it is important to highlight this syntax isn't conventionally python. The  Pandas parser generates a slightly different parse tree from the  expression. This is done to make some operations more intuitive to  specify. For more information, please read my post on  Dynamic Expression Evaluation in pandas using pd.eval().And, with  + :Question 2bHow would I get all values corresponding to "t" and "w" in level "two"?With , this is possible only in conjuction with .The first colon  in  means to slice across the first level. As the depth of the level being queried increases, you will need to specify more slices, one per level being sliced across. You will not need to specify more levels beyond the one being sliced, however. With , this is With  and  (similar to above):Question 3How do I retrieve a cross section, i.e., a single row having a specific values  for the index from ? Specifically, how do I retrieve the cross  section of , given byUse  by specifying a tuple of keys:Or,Note  At this point, you may run into a  that looks like this:This just means that your index is not sorted. pandas depends on the index being sorted (in this case, lexicographically, since we are dealing with string values) for optimal search and retrieval. A quick fix would be to sort your  DataFrame in advance using . This is especially desirable from a performance standpoint if you plan on doing  multiple such queries in tandem:You can also use  to check whether the index  is sorted or not. This function returns  or  accordingly.  You can call this function to determine whether an additional sorting  step is required or not.With , this is again simply passing a single tuple as the first argument, with all other arguments set to their appropriate defaults:With , things become a bit clunky:You can see now that this is going to be relatively difficult to generalize. But is still OK for this particular problem.With accesses spanning multiple levels,  can still be used, but is not recommended:Question 4How do I select the two rows corresponding to , and ?With , this is still as simple as:With , you will need to dynamically generate a query string by iterating over your cross sections and levels:100% DO NOT RECOMMEND! But it is possible. Question 5How can I retrieve all rows corresponding to "a" in level "one" and  "u" in level "two"?This is actually very difficult to do with  while ensuring correctness and still maintaining code clarity.  is incorrect, it is interpreted as  (i.e., selecting a cross section). You may think of a solution with  to handle each label separately:But you'll notice one of the rows is duplicated. This is because that row satisfied both slicing conditions, and so appeared twice. You will instead need to doBut if your DataFrame inherently contains duplicate indices (that you want), then this will not retain them. Use with extreme caution.With , this is stupidly simple:With , this is still simple, but not as elegant:Question 6How can I slice specific cross sections? For "a" and "b", I would like to select all rows with sub-levels "u" and "v", and  for "d", I would like to select rows with sub-level "w".This is a special case that I've added to help understand the applicability of the Four Idioms—this is one case where none of them will work effectively, since the slicing is very specific, and does not follow any real pattern. Usually, slicing problems like this will require explicitly passing a list of keys to . One way of doing this is with:If you want to save some typing, you will recognise that there is a pattern to slicing "a", "b" and its sublevels, so we can separate the slicing task into two portions and  the result:Slicing specification for "a" and "b" is slightly cleaner  because the same sub-levels being indexed are the same for each level.Question 7How do I get all rows where values in level "two" are greater than 5?This can be done using ,And .Note  Similar to this example, we can filter based on any arbitrary condition using these constructs. In general, it is useful to remember that  and  are specifically for label-based indexing, while  and   are helpful for building general conditional masks  for filtering.Bonus QuestionWhat if I need to slice a  column?Actually, most solutions here are applicable to columns as well, with minor changes. Consider:These are the following changes you will need to make to the Four Idioms to have them working with columns.To slice with , use Or,To use  as appropriate, just pass an argument .You can access the column level values directly with . You will then need to do something like Where  represents some condition built using .To use , your only option is to transpose, query on the index, and transpose again:Not recommended, use one of the other 3 options.


Answer URL
https://docs.python.org/3/library/functions.html#slice
