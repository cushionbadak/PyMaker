Natural Text
I have the following code: is a set of tuples, and  is a list of tuples.There is a noticeable dip in the performance of the method this is in as the lengths of  and  increase, because of course there is; that's just sheer math!  It goes from effectively instantaneous from the user perspective to taking a noticeable amount of time (though less than a second, at least on my machine).I need to add a new element to the  list only when I can match the first element of a tuple in  as the same object as the first element of a tuple in .  (These tuple elements are unique within their respective lists, as in,  is unique among all other members of , and the same for , and so on.)  The only way I can think of to accomplish this is to loop through each set/list as in the code above and compare the tuple elements.Is there a more efficient way to do this?  Ideally I'd like some way to quickly construct a list of only the members of  which share their first element with one of the members of , in the same order as , so that I can just compare the lists side-by-side.  But I have no idea how to begin solving this issue.Edit:  Some examples of expected input and output:To be clear, this is actual input and output as printed from the console in the working code.  I'm looking for a way to achieve this same result more efficiently than the current code.The tuples in  and  are of the form:The purpose of the code is to produce , a list of old and new values for replacing substrings throughout a series of strings (the page contents in a hierarchical notebook).  's content has to be narrowed to cases where the same  object in memory has two different associated "links" (string representations of integer index paths wrapped in some markdown syntax) across  and .The difference between  and  is obtained with  as , but then I need to associate the changed strings with each other in .The  integer is just an intermediate step so that I can guarantee unique parameters for  and not muck things up when two objects swap link strings.Edit:  Thanks to @ParitoshSingh, the following code is noticeably faster:
EDIT: For users looking at a similar problem to this, please refer to a more generic solution below. This edit only addresses this specific scenario for the OP.To the OP, The lookups can be sped up by using hashable values. For this specific use case, try the id() functionWarning: The caveats should be kept in mind. id function is guaranteed to produce unique values for objects that coexist at the same time, but is only guaranteed to be linked to memory address in CPython, other implementations may differ. If you're curious, this demonstration only works because python caches the int objects for small numbers. [-5 to 256]Generalized SolutionYou can see very good gains by changing your datatype of OldLinkData to a dictionary if your comparison objects are hashables. Link to Docs. Because dictionary keys are hashables, the dictonary lookups are a constant time operation , and do not require iteration in the dictionary. Some comparison. Note that ideally you should only do the dictionary creation once, but i kept it included in the time comparison in case you can't get away with changing the datatype of OldLinkData permanently. In that case, you just would want to create the dictionary for comparison as needed.BaseLineNewCodeBaseLine: NewCode: 


Answer URL
https://docs.python.org/3/library/functions.html#id
https://docs.python.org/3/library/stdtypes.html#mapping-types-dict
