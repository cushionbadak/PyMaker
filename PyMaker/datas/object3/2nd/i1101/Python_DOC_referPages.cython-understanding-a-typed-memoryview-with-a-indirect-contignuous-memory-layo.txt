Natural Text
I want to understand more about Cython's awesome typed-memoryviews and the memory layout .According to the documentation  is used when "the list of pointers is contiguous".There's also an example usage:So pls correct me if I'm wrong but I assume a "contiguous list of pointers to contiguous lists of ints" means something like the array created by the following c++ dummy-code:So if I understand correctly then in my Cython code it should be possible to get a memoryview from a  like this:But I get Compile-errors:  what did I do wrong?Am I missing any casts or did I misunderstand the concept of indirect_contiguous?
Let's set the record straight: typed memory view can be only used with objects which implement buffer-protocol.Raw C-pointers obviously don't implement the buffer-protocol. But you might ask, why something like the following quick&dirty code works:Here, a pointer () is used to construct a typed memory view (). There is however more, going under the hood (as can be seen in the cythonized c-file):a cython-array (i.e. ) is constructed, which wraps the raw pointer and can expose it via buffer-protocolthis array is used for the creation of typed memory view.Your understanding what  is used for is right - it is exactly what you desire. However, the problem is , which just cannot handle this type of data-layout.  and  correspond to   in protocol-buffer parlance and for this the field  must contain some meaningful values (i.e  for some dimensions). However, as can be see in the source-code  doesn't have this member at all - there is no way it can represent the complex memory layout at all!Where does it leave us? As pointed out by @chrisb and @DavidW in your other question, you will have to implement a wrapper which can expose your data-structure via protocol-buffer.There are data structures in Python, which use the indirect memory layout - most prominently the PIL-arrays. A good starting point to understand, how  are supposed to work is this piece of documenation:In your case  and  would be (i.e.  on usual  machines), i.e. only the first dimension is indirect.Getting the address of element  would then happen as follows:in the line ,  is set to , let's assume .first dimension:in line ,  becomes , and points to the location of the pointer to x-th row.because , we dereference the pointer in line  and thus it shows to address  - the start of the x-th row.second dimension:in line  we get the address of the  element using , i.e. second dimension is direct (signaled by ), so no dereferencing is needed.we are done,  points to the desired address and is returned in line .


Answer URL
https://docs.python.org/3/c-api/buffer.html#buffer-protocol
https://docs.python.org/3/c-api/buffer.html#c.PyBUF_INDIRECT
https://docs.python.org/3/c-api/buffer.html#c.Py_buffer.suboffsets
https://docs.python.org/3/c-api/buffer.html#pil-style-shape-strides-and-suboffsets
