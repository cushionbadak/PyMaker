Natural Text
If you execute the following statement in Python 3.7, it will (from my testing) print :However,  evaluates to .Naturally,  evaluates to , and  evaluates to .I initially discovered this when testing the return value of a function, but didn't return anything in the second case -- so, the function returned .What's going on here?
This is a great example of why the  methods should not be used directly as they are quite often not appropriate replacements for their equivalent operators; you should use the  operator instead for equality comparisons, or in this special case, when checking for , use  (skip to the bottom of the answer for more information). You've done Which returns  since the types being compared are different. Consider another example where two objects with different types are being compared in this fashion, such as  and . Doing  is also not correct, and will return . The right way to compare these two values for equality would be  What happens here isFirst,  is tried, which returns . This indicates that the operation is not supported, so  is called, which also returns the same . So, The objects are treated as if they are not the same, and  is returned.Here's a nice little MCVE using some custom classes to illustrate how this happens:Of course, that doesn't explain why the operation returns true. This is because  is actually a truthy value:Same as,For more information on what values are considered truthy and falsey, see the docs section on Truth Value Testing, as well as this answer. It is worth noting here that  is truthy, but it would have been a different story had the class defined a  or  method that returned  or  respectively.If you want the functional equivalent of the  operator, use :However, as mentioned earlier, for this specific scenario, where you are checking for , use :The functional equivalent of this is using : is a special object, and only 1 version exists in memory at any point of time. IOW, it is the sole singleton of the  class (but the same object may have any number of references). The PEP8 guidelines make this explicit:Comparisons to singletons like  should always be done with  or  , never the equality operators.In summary, for singletons like , a reference check with  is more appropriate, although both  and  will work just fine.
The result you are seeing is caused by that fact thatevaluates to , and 's truth value is documented to be :https://docs.python.org/3/library/constants.htmlSpecial value which should be returned by the binary special methods (e.g. eq(), lt(), add(), rsub(), etc.) to indicate that the operation is not implemented with respect to the other type; may be returned by the in-place binary special methods (e.g. imul(), iand(), etc.) for the same purpose. Its truth value is true.If you call the  method manually rather than just using , you need to be prepared to deal with the possibility it may return  and that its truth value is true. 
As you already figured  evaluates to  however if you try something likethe result isyesthis mean that the truth value of  Therefor the outcome of the question is obvious: yields And  evaluates to TrueSo  is always True
Why?It returns a , yeah:But if you look at this: is actually a truthy value, so that's why it returns , anything that is  will pass, anything that is  wouldn't.How to solve it?You have to check if it is , so be more suspicious, as you see:So you would do:And as you see, it wouldn't return anything.


Answer URL
https://docs.python.org/3/library/stdtypes.html#truth-value-testing
https://docs.python.org/3/library/operator.html#operator.eq
https://docs.python.org/3/library/operator.html#operator.is_
https://docs.python.org/3/library/constants.html
https://docs.python.org/3/library/stdtypes.html#truth-value-testing
