Natural Text
How can I write a function "fmap", with this properties :(I search a kind of "fmap" in haskell, but in python3).I have a very ugly solution, but there is certainly a solution more pythonic and generic ? :
Using the type of the input as a converter is not necessarily working in all occasions.   is just using the "iterability" of its input to produce its output.  In Python3 this is why  returns a generator instead of a list (which is just more fitting).So a cleaner and more robust version would be one which explicitly expects the various possible inputs it can handle and which raises an error in all other cases:You could add a case for all other iterable values in the  clause of cause:But that would e. g. return an iterable for a subclass of  which might not be what you want.Mind that I'm deliberately not using  because that would make a list out of a subclass of , for instance.  I figure that this is explicitly not wanted in this case.One could argue that anything which is a  (i. e. is a subclass of ) needs to comply to have a constructor which returns a thing of this type for an iteration of elements.  And likewise for subclasses of ,  (which must work for an iteration of pairs), etc.  Then the code might look like this:
Instantiate directly rather than via  can also be used to instantiate new instances:This removes the need for , use of which is considered poor practice. As per @EliKorvigo's comment, you may prefer built-in  to a magic method:As explained here and in the docs:The return value is a type object and generally the same object as returned by ."Generally the same" should be considered "equivalent" in the case of new-style classes.Testing for an iterableYou can check/test for an iterable in a couple of ways. Either use  /  to catch :Or use :This works specifically because built-in classes commonly used as containers such as , , , , etc, can be used to instantiate instances via a lazy iterable. Exceptions exist: for example,  will not work as you might expect even though  instances are iterable.
I search a kind of "fmap" in haskell, but in python3First, let's discuss Haskell's  to understand, why it behaves the way it does, though I assume you are fairly familiar with Haskell considering the question.  is a generic method defined in the  type-class:Functors obey several important mathematical laws and have several methods derived from , though the latter is sufficient for a minimal complete functor instance. In other words, in Haskell types belonging to the  type-class implement their own  functions (moreover, Haskell types can have multiple  implementations via  definitions). In Python we don't have type-classes, though we do have classes that, while less convenient in this case, allow us to simulate this behaviour. Unfortunately, with classes we can't add functionality to an already defined class without subclassing, which limits our ability to implement a generic  for all builtin types, though we can overcome it by explicitly checking for acceptable iterable types in our  implementation. It's also literally impossible to express higher-kinded types using Python's type system, but I digress.To summarise, we've got several options:Support all  types (@jpp's solution). It relies on constructors to convert an iterator returned by Python's  back into the original type. That is the duty of applying a function over the values inside a container is taken away from the container. This approach differs drastically from the functor interface: functors are supposed to handle the mapping themselves and handle additional metadata crucial to reconstruct the container.Support a subset of readily mappable builtin iterable types (i.e. builtins that don't carry any important metadata). This solution is implemented by @Alfe, and, while less generic, it is safer.Take solution #2 and add support for proper user-defined functors.This is my take on the third solutionHere is a demo                                                                       This solution allows us to define multiple functors for the same type via  subclassing:


Answer URL
https://docs.python.org/3/library/functions.html#type
https://docs.python.org/3/library/functions.html#type
https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable
