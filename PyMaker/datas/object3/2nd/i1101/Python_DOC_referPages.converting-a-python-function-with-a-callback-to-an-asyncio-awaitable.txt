Natural Text
I want to use the  library in an async context, but the main entry point for the library only has a callback-based API:How I'm hoping to use it is something like this:The problem is, I'm not sure how to convert this callback syntax to a future that completes when the callback fires. In JavaScript I would use , but Python doesn't seem to have anything like that.
An equivalent of  wouldn't work for this use case for two reasons:PyAudio's async API doesn't use the asyncio event loop - the documentation specifies that the callback is invoked from a background thread. This requires precautions to correctly communicate with asyncio.The callback cannot be modeled by a single future because it is invoked multiple times, whereas a future can only have one result. Instead, it must be converted to an async iterator, just as shown in your sample code.Here is one possible implementation: returns a pair of <async iterator, put-callback>. The returned objects hold the property that invoking the callback causes the iterator to produce its next value (the arguments passed to the callback). The callback may be called to call from an arbitrary thread and is thus safe to pass to , while the async iterator should be given to  in an asyncio coroutine, which will be suspended while waiting for the next value:Note that, according to the documentation, the callback must also return a meaningful value, a tuple of frames and a Boolean flag. This can be incorporated in the design by changing the  function to also receive the data from the asyncio side. The implementation is not included because it might not make much sense without an understanding of the domain.
You may want to use a Futureclass asyncio.Future(*, loop=None)Â¶A Future represents an eventual result of an asynchronous operation. Not thread-safe.Future is an awaitable object. Coroutines can await on Future objects until they either have a result or an exception set, or until they are cancelled.Typically Futures are used to enable low-level callback-based code (e.g. in protocols implemented using asyncio transports) to interoperate with high-level async/await code.The rule of thumb is to never expose Future objects in user-facing APIs, and the recommended way to create a Future object is to call loop.create_future(). This way alternative event loop implementations can inject their own optimized implementations of a Future object.A silly example:I assume that  runs in a thread or a subprocess. If not, you may also need to wrap the call to  with asyncio.loop.run_in_executor


Answer URL
https://docs.python.org/3/library/asyncio-future.html#asyncio.Future
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.run_in_executor
