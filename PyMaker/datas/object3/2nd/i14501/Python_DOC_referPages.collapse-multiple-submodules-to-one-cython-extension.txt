Natural Text
This setup.py:Doesn't have the intended effect. I want it to produce a single , which it does; but when I invoke it viaI get:due to the fact that  attempts to refer to .Any idea how to get this working?
First off, I should note that it's impossible to compile a single  file with sub packages using Cython. So if you want sub packages, you're going to have to generate multiple  files, as each  can only represent a single module.Second, it doesn't appear that you can compile multiple Cython/Python files (I'm using the Cython language specifically) and link them into a single module at all.I've tried to compile multiply Cython files into a single  every which way, both with  and with manual compilation, and it always fails to import at runtime.It seems that it's fine to link a compiled Cython file with other libraries, or even other C files, but something goes wrong when linking together two compiled Cython files, and the result isn't a proper Python extension.The only solution I can see is to compile everything as a single Cython file. In my case, I've edited my  to generate a single  file which in turn s every  file in my source directory:Then I just compile . Of course this breaks incremental and parallel compilation, and you could end up with extra naming conflicts since everything gets pasted into the same file. On the bright side, you don't have to write any  files.I certainly wouldn't call this a preferable build method, but if everything absolutely has to be in one extension module, this is the only way I can see to do it.
This answer provides a prototype for Python3 (which can be easily adapted for Python2) and shows how several cython-modules can be bundled into single extension/shared-library/pyd-file. I keep it around for historical/didactical reasons - a more concise recipe is given in this answer, which present a good alternative to @Mylin's proposal of putting everything into the same pyx-file.When bundling multiple Cython-extension (let's call them  and ) into one single shared object (let's call it ), the main problem is the  operation, because of the way the loading of modules works in Python (obviously simplified):Look for  and load it, if not successful...Look for  (or similar), use  for loading the shared library and call  which would initialize/register the module.Now, the issue is that there is no  to be found and albeit the initialization function  can be found in , Python doesn't know where to look and gives up on searching.Luckily, there are hooks available, so we can teach Python to look in the right places.When importing a module, Python utilizes finders from , which return the right loader for a module (for simplicity I'm using the legacy workflow with loaders and not module-spec). The default finders return , i.e. no loader and it results in the import error.That means we need to add a custom finder to , which would recognize our bundled modules and return loaders, which in their turn would call the right -function.The missing part: How should the custom finder finds its way into the ? It would be pretty inconvenient if the user would have to do it manually. When a submodule of a package is imported, first the package's -module is loaded and this is the place where we can inject our custom finder.After calling  for the setup presented further below, there is a single shared library installed and the submodules can be loaded as usual:Putting it all together:Folder structure:__init__.py:bootstrap.pyx:bar_a.pyx:bar_b.pyx:setup.py:NB: This answer was the starting point for my experiments, however it uses  and I cannot see a way how can this be plugged in into the normal python.
This answer is follows the basic pattern of @ead's answer, but uses a slightly simpler approach, which eliminates most of boilerplate code.The only difference is the simpler version of :Essentially, I look to see if the name of the module being imported starts with , and if it does I reuse the standard  approach to loading an extension module, passing the current  filename as the path to look in - the right name of the init function (there are multiple ) will be deduced from the package name.Obviously, this is just a prototype - one might want to do some improvements. For example, right now  would lead to a somewhat unusual error message: , one could return  for all submodule names that are not on a white list.


Answer URL
https://docs.python.org/3/glossary.html#term-finder
https://docs.python.org/3/library/sys.html#sys.meta_path
https://docs.python.org/3/glossary.html#term-loader
https://docs.python.org/3/glossary.html#term-module-spec
https://docs.python.org/3/library/importlib.html#importlib.machinery.ExtensionFileLoader
