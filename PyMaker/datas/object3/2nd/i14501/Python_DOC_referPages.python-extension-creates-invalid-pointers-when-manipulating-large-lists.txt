Natural Text
I managed to implement a Fisher–Yates shuffle function for python lists as an exercise for getting used to extending python. It works perfectly for relatively small lists, unless I run the function several times.Whenever the list size goes over about 100, I get all kinds of memory problems:Or, when trying to operate on a list with 1000 elements:Or,Here's my code for the module that produces the error:I feel like I should be able to solve this either with free() or with Py_DECREF() somewhere, but I don't see where. I don't think I'm creating any objects, just moving them around. So where is the memory problem coming from?
You need to  both objects before passing them to . Further, catch the special case where : returns a borrowed reference, i.e. it doesn't  the object it returns. If you don't hold any other references, the refcount will be  (as it is only referenced from the list). When you call , the list 's the object previously stored at  (which you keep in ). At that point, the refcount reaches  and the object is freed. Whoops.Similarly, you can't just call , because  steals the reference you pass to it. You don't own the reference, however, the 'old' list does. So you need an  here as well.See the list API documentation for more details.As a further suggestion, you might consider not programming directly against the Python extension API. It takes a lot of code to get anything done and it's subtly difficult to keep the refcounts correct. By now, there are multiple other ways to interface Python with C or C++. CFFI seems to be the low-level interface the Python ecosystem will standardize on. SIP and SWIG may offer better support for C++, though. For a SIP example, see this answer.
There are more problems in your extension function beyond the reference counting errors, more of them below:While the  with  proper reference counting is the preferred way, an (ugly) option is to use the  macro that gets away with doing INCREFs:Macro form of  without error checking. This is normally only used to fill in new lists where there is no previous  content.NoteThis macro “steals” a reference to item, and, unlike , does not discard a reference to any item that is  being replaced; any reference in list at position  will be leaked.Thus the  neither increments nor decrements any reference counters, which is suitable for us since both initially and finally the elements are in the same list.Notice that this does not do any error checking at all, so you need to ensure that your index is within the bounds (which the  loop takes care of).Your code has another bad problem that is not discussed yet - total lack of error checking. For example, when passed in a non-list object, you ought to raise a . Now the code will fail at , returning -1 and setting an internal exception, this can lead to erroneous behaviour of all future C extensions:Likewise  can and will fail if incorrect number of arguments is passed in, thus you must check its return value; in this case the  can be uninitialized and your code will have totally undefined behaviour.The C-API documentation states the following:When a function must fail because some function it called failed, it  generally doesn’t set the error indicator; the function it called  already set it. It is responsible for either handling the error and  clearing the exception or returning after cleaning up any resources it  holds (such as object references or memory allocations); it should not  continue normally if it is not prepared to handle the error. If  returning due to an error, it is important to indicate to the caller  that an error has been set. If the error is not handled or carefully  propagated, additional calls into the Python/C API may not behave as  intended and may fail in mysterious ways.Thus here is the correct way to write your extension function:


Answer URL
https://docs.python.org/3/c-api/list.html#c.PyList_SET_ITEM
https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
https://docs.python.org/3/c-api/exceptions.html#exception-handling
