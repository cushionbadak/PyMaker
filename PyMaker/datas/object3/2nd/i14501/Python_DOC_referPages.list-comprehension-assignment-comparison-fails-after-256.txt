Natural Text
This question already has an answer here:“is” operator behaves unexpectedly with integers                    11 answers                I tried to find the performance difference between slice assignment and regular assignment for lists. Here is the code:My expectation is that, for each list  and , this will remove one element at a time, so that  and  both print empty lists. Instead, they seem to always print the starting lists, but with the first  elements missing.They both print:What is happening?I'm using Python 2.7.6.
The problem is that you're using  instead of .The former checks for object identity, not equality. There's no reason to believe that evaluating, say,  twice will give you the same  object, just that they'll both give you  objects whose value is .This happens to "work" for numbers up to 256 because your particular Python implementation* happens to intern integers up to 256. At startup, it creates a singleton object for the number , a singleton object for , and so on. Any time an expression evaluates to the number , it gives you that object, instead of a new one.**Needless to say, you should not rely on that optimization.* IIRC, every version of CPython from the 1.x days to 3.5 defaults to this behavior for all integers from -5 to 256, but you can change those limits, or turn off the feature, at build time, and a different implementation might do something different.** If you're wondering how this works in CPython, at the C API level,  does this by looking up numbers from -5 to 256 in an array of singleton values. You can see the 3.4 version of the code, for example, here; the macro  and the actual function  that it calls, and the static array that function uses, are all are in the same file, up near the top.


Answer URL
https://docs.python.org/3/c-api/long.html#c.PyLong_FromLong
