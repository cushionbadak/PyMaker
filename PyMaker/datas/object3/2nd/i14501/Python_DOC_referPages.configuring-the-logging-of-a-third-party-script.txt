Natural Text
I have a third party python console script, which source I don't want to modify.But I want to configure the logging which is done by the script and its libraries. The script uses the standard python logging, but does not support configuration of it.The script uses this pattern:Use cases: I want INFO messages of file foo.py to be ignored.I want to include the PID in the loggings messages.How can I configure the logging, if I don't want to modify the sources of the console script?The script gets called via .How can I configure the logging if this script?ImportantCreating a wrapper script like in this answer is not a solution for me.The linux process hierarchy looks like this:There should be any "glue", "wrapping" or "dirty-hack" script between cron and .Why obtrusive/netpicking?I want to practice "separation of concerns". I want to be able to configure logging one time and in one place. This configuration should get used by all python code of a virtualenv. Writing a wrapper would be a work-around. I want a solution.
A library isn't supposed to configure logging - that's up to the application developer. Inbar Rose's answer isn't quite right. If the module you're referring to is called , then the reference to  in its  call will be passing in . So in your configuration code, you would need to do the equivalent ofTo include the PID in the logs, just ensure that you use an appropriate format string for your Formatters, i.e. one which includes . A simple example would be:Note that you can't write to the same log file from multiple processes concurrently - you may need to consider an alternative approach if you want to do this.Update: An application developer is someone who writes Python code which is not the library, but is invoked by e.g. a user or another script via a command line or other means of creating a Python process.To use the code I posted above, there is no need to wrap or modify the third-party code, as long as it's a library. For example, in the main script which invokes the third-party library:If the third party code runs via cron, it's not library code - it's an application, and you are probably out of luck.
I asked this question several months ago. Unfortunately I got no answer which satisfied me.The distinction between using logging and setting it up is important for me.This is my solution: In our context we set up logging in a method which gets called in .This way the optional plugins can use the logging without the need to set it up. This almost solved all my needs.Up to now I found no better way than . My perfect solution would be something I would call : Some initialization code which gets run if the interpreter loads virtualenv. Up to now I could not find such a hook. Please let me know if you have a solution.
Several possibilities:WrapperIf you can edit your cron table you could create a small script in python that get the lib logger, remove the existing log handler and hook your custom handler on it:Also keep in mind this suppose the lib does not re-declare the logger on the way.Dynamic code editIf you do not have the possibility to modify the cron call, you might be able to do dynamic code edit but that is equivalent to editing the file by hand (hacky): get the third party file containing the logger configurationmodify that and save back the modified versionthe cron job starts the task using third party codeafter execution of the cron job, you restore the file to their original state.
You can change the minimum log level of that logger.Now, only WARNING and above will be shown. No INFO and no DEBUG.Addionally, you could also change the format.  being the PID.All together:Note: You should replace  in your code with the relevant log handler.
tl;drIn a nutshell, what we want to do is to inject code that gets executed by the python interpreter before our main code gets executed.The best way to achieve this is to create a virtualenv and add in the virtualenv's site-packages.DemonstrationLet's assume that the application we want to run is called  and that itslogger has the same name.Running  should only show the messages whose severity is >  (whichis the default behavior in python's logging).Now let's create a virtual environmentAnd let's add  to the virtualenv's site packages.Now let's try to run  using the virtualenv:And that was all)We got proper logging without having to modify  or write a wrapper!Now if you want to know why this is the optimal approach, keep on reading.(Really) long answerBefore understanding why using a virtualenv +  is the correct approachto this problem, we need to make a not so short introduction.Note: I am going to assume that you create virtual environments using the module which usesstdlib's .  The library, uses its ownand  might be doing things slighly differently. Nevertheless, after reading this answeryou should be able to examine if there are any differences between  and and understand how to handle them.What are The short answer is that  is the place where python installs 3rd partycode (as in non-stdlib code). For more info readthisand the provided links.How to inject code?Python does allow you to customize the python interpreter while it starts up, i.e.before our main code/script/whatever gets executed.  This can be useful for e.g.:code-coverageprofilersand to generally inject code, as we need to do for this question.The way you achieve the injection is by creating/modyfing either  or.  You can also use a "path configuration file" (i.e. ) filewith an import statement but I will not cover this case here since:These import statements feel like a terrible hackI am not convinced that it offers any real advantage compared to/.I would like to keep things simpleAnyway, if you need more info WRT to path configuration files you can checkPyMOTW and if you wantan example of using them with import statement check this blogpost. & So,  and  are special files that don't exist by default,but if we create them python will automatically import them before it starts to executeour code.  We can create these files:either on the global site-packages (e.g. )or on the user site-packages (e.g. ) is always imported before .  If either file is missing,the  is silently ignored.As a security precaution, if there is a mismatch between user or group id and theeffective id, then user site-packages are disabled(source).Moreover, the python interpreter has CLI arguments that either completely disablesite-packages (both system and userones) or disable usersite-packages. Assuming thatwe don't have an id mismatch and that we don't use any CLI flags, then usersite-packages have higher priority than system site-packages. So if we have both:the first one is the one that will be imported.  We can actually check the sys.pathpriority by executing the  module:The important information here is the value of . If it is  thenuser site-packages are enabled. If it  then we can only use global site-packages.E.g. if we use :Note that in this case  is .Just for completeness, let's completely disable the site-packages:ExperimentIn order to better understand this, let's do an experiment. First let's create  modules in both system and user site-packages.WARNING: We will be creating files in system site-packages. This will beinterfering with your python distribution. Be careful and REMEMBER to removethem when we are done.Let's also create a python module:Now let's execute :As we can see:both  and  are being importedthey are being imported from user site-packagesNow what will happen if we disable user site-packages?This time we see that we:only  is being imported. Even though  exists insystem site-packages python does not import it! This is important! Keep it mind for whenwe discuss virtualenvs! (TIP: this has to do with ; do you rememberwhat value does it have in this case?) is being imported from system site-packagesFinally, if we completely disable site-packages, obviously  and will be ignored:What about virtualenvs?OK, now let's bring virtualenv's into the game too. There are two types of virtualenvs:the normal onesthose created with .Let's create virtualenvs of both typesLet's also create  and  modules into thevirtualenv's site-packages:and let's see the differences:What do we see here? That on normal virtualenv's  is ,which means that:user site-packages are being ignoredonly  is being imported! I.e. we can't use  toinject code!!!We can also see that instead of our global site-packages, the virtualenv is using itsown one (i.e. ).Now let's repeat this but this time with the virtualenv that uses the systemsite-packages:In this case, the behavior is different... is  which means:that user site-packages are being enabledthat  is being imported normally.But there is also one more difference. In this case we have 3 site-packagesdirectories.  The virtualenv one is the one with the higher priority followed by theuser site-packages while the system site-packages is the last one.So what to use?I think that there are three options:use the system python installationuse a normal virtualenvuse a virtualenv with system site-packagesI think that in the majority of the cases, e.g. on normal servers/desktops, modifyingthe system python installation should generally be avoided. At least on *nix, too manythings depend on Python. I would be really reluctant to change its behavior. Possibleexceptions are ephemeral or static "systems" (e.g.  inside a container).As far as virtual environments go, unless we know we are going to need systemsite-packages, I think it makes sense to stick with the current practise and use normalones.  If we adhere to this, then in order to inject code before our script getsexecuted we only have one option:To add a  in the virtuaelenv's site packages.Cleaning up


Answer URL
https://docs.python.org/3/library/site.html#site.ENABLE_USER_SITE
https://docs.python.org/3/using/cmdline.html#id3
https://docs.python.org/3/using/cmdline.html#cmdoption-s
