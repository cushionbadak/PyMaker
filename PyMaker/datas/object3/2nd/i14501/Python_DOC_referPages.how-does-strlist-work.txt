Natural Text
Why does  returns how we see list on the console? How does  work? (any reference to the CPython code for )?To get the original list back from the  I have to:Why doesn't  turns the  back to the original list?Or I could use:Is  the same as ? Is  safe to use?How many times can I do the following? Does the code break if it keep on doing ? E.g.
Well you have a total of 4 questions, let us go one by one. 1. Why does  returns how we see  on the console? How does  work?What is  and ?The  callable is to return a printable form of the object only! From the docs does not always attempt to return a string that is  acceptable to ; its goal is to return a printable string.The  function in a class is called whenever you call  on an object. Again from the documentationCalled by the  built-in function and by the  statement to compute the “informal” string representation of an object.What is the  callable?The  callable is to create a list from an iterable passed as an argument. Again from the docsReturn a  whose items are the same and in the same order as  iterable‘s itemsThus,  gives you a printable form and  will iterate over the string. That is  will give you a list of the individual characters of the printable form of the argument passed.A small walk-through between the nested calls,Given list,  (Apologies for taking a smaller example than that in your question). When you call , it returns a printable form of the list , that is .Now you can see clearly that  is a string and is indeed an iterable. Now when you call  on this i.e.  you get a weird list like . Why does this happen? This happens because the string iterates over its characters, you can test this by using a dummy string,Thus when you call the  on a string you get a list of character. Note that again here, when you call  on , you will not get back your original string , so again you will have to use ! Thus recalling the same function will NOT get you back your original object!So, Calling  over a list calls the builtin  method of the list?The answer is NO!What happens internally when you call  on a list?Whenever you call  on an list object, the steps followed are Call the  of each of the list element.Add a fancy  at the front and another  at the end of the list. Join all of them with a comma. As you can see from the source code of the list object in cpython on github. Going through the source code of cpython in hg.python, which is more clear, you can see the following three comments. (Thanks to Ashwini for the link on that particular code)These correspond to the points I mentioned above.Now what is ? prints the string representation of all the objects. Again from the documentationReturn a string containing a printable representation of an object.and also note this sentence!For many types, this function makes an attempt to return a string  that would yield an object with the same value when passed to ,  otherwise the representation is a string enclosed in angle brackets  that contains the name of the type of the object together with  additional information often including the name and address of the  object.And now your second question here,2. Why doesn't  turns the  back to the original list?Internally,  actually creates the  representation of the list object. So to get back the list after calling  on the list, you actually need to do  on it and not a  call. WorkaroundsBut we all know that  is evil, so what is/are the workaround(s)? 1. Using The first work-around would be to use . That brings us to your 3rd question,3. Is  the same as ? Is  safe to use? is safe unlike the  function. The docs themselves mention that it is safe -- Safely evaluate an expression node or a string containing a Python literal or container display2. Using string functions and builtinsAnother workaround can be done using This is just a simple way to do that for a list of strings. For a list of integers you will need . Thus unlike  these are simple hacks given that you know the  elements of the list. If they are heterogeneous in nature like  then you will have to loop through the split list and discover the element type and then convert it and append the converted element to a final list. Another place where this fails is when the string itself contains quote characters. As mentioned by nneonneo in a commentThe  solution is very fragile and will break if the input contains e.g. strings that contain , or tuples, or other lists, ... It is much better to use  because that will deal with all the subtleties of the syntax.And for your final question,4. Does the code break if you do  again and again?Not really. The output will grow longer and longer as each time you are creating a  of a  and then again getting the printable version of it. The limitation is your physical machine's limitation only. (which will be soon reached as each step the string length is multiplied by 5.)
You appear to have the expectation that creating a string from a list is round-trippable. It is not meant to be; lists are not end-user presentable objects and you get the same output as ; debug information for developer consumption only.The  callable creates a new list object from any arbitrary iterable object; Python strings are iterable producing individual characters when you do so,  always produces a list with individual characters.As such,  will never attempt to interpret a string argument as Python syntax; and doing so would not even work if the original list contained objects without a Python literal notation. Take for example:You cannot take that debug string output and turn that back into the original list, especially if you run this in a Python interpreter where there is not even such a function defined.
The  function in python is used to turn a value into a string. The simple answer to what the  does to a  is that it creates a string representation of the list (square brackets and all).As for the , all you are doing is telling python to convert the original list to a string then you are splitting that string and putting it into a list so that each index has one character. So you could nest  and  calls as many times as you want (assuming your computer is has enough memory).


Answer URL
https://docs.python.org/3/library/functions.html#str
https://docs.python.org/3/reference/datamodel.html#object.__str__
https://docs.python.org/3/library/functions.html#str
https://docs.python.org/3/reference/datamodel.html#object.__str__
https://docs.python.org/3/library/functions.html#list
https://docs.python.org/3/library/functions.html#list
https://docs.python.org/3/library/functions.html#join
https://docs.python.org/3/library/functions.html#repr
https://docs.python.org/3/library/functions.html#repr
https://docs.python.org/3/library/functions.html#eval
https://docs.python.org/3/library/ast.html#ast.literal_eval
https://docs.python.org/3/library/ast.html#ast.literal_eval
https://docs.python.org/3/library/ast.html#ast.literal_eval
https://docs.python.org/3/library/stdtypes.html#str.split
https://docs.python.org/3/library/functions.html#map
