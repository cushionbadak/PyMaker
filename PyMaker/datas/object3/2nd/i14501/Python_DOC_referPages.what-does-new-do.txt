Natural Text
I'm just trying to streamline one of my classes and have introduced some functionality in the same style as the flyweight design pattern.However, I'm a bit confused as to why  is always called after . I wasn't expecting this. Can anyone tell me why this is happening and how I can implement this functionality otherwise? (Apart from putting the implementation into the  which feels quite hacky.)Here's an example:Outputs:Why?
Use __new__ when you need to control  the creation of a new instance. Use  __init__ when you need to control initialization of a new instance.__new__ is the first step of instance creation.  It's called first, and is  responsible for returning a new  instance of your class.  In contrast,  __init__ doesn't return anything; it's only responsible for initializing the  instance after it's been created.In general, you shouldn't need to  override __new__ unless you're  subclassing an immutable type like  str, int, unicode or tuple.From: http://mail.python.org/pipermail/tutor/2008-April/061426.htmlYou should consider that what you are trying to do is usually done with a Factory and that's the best way to do it. Using __new__ is not a good clean solution so please consider the usage of a factory. Here you have a good factory example.
 is static class method, while  is instance method.  has to create the instance first, so  can initialize it. Note that  takes  as parameter. Until you create instance there is no .Now, I gather, that you're trying to implement singleton pattern in Python. There are a few ways to do that.Also, as of Python 2.6, you can use class decorators. 
In most well-known OO languages, an expression like  will allocate a new instance, initialise the instance's attributes, and then return it.In most well-known OO languages, the "initialise the instance's attributes" part can be customised for each class by defining a constructor, which is basically just a block of code that operates on the new instance (using the arguments provided to the constructor expression) to set up whatever initial conditions are desired. In Python, this corresponds to the class'  method.Python's  is nothing more and nothing less than similar per-class customisation of the "allocate a new instance" part. This of course allows you to do unusual things such as returning an existing instance rather than allocating a new one. So in Python, we shouldn't really think of this part as necessarily involving allocation; all that we require is that  comes up with a suitable instance from somewhere.But it's still only half of the job, and there's no way for the Python system to know that sometimes you want to run the other half of the job () afterwards and sometimes you don't. If you want that behavior, you have to say so explicitly.Often, you can refactor so you only need , or so you don't need , or so that  behaves differently on an already-initialised object. But if you really want to, Python does actually allow you to redefine "the job", so that  doesn't necessarily call  followed by . To do this, you need to create a metaclass, and define its  method.A metaclass is just the class of a class. And a class'  method controls what happens when you call instances of the class. So a metaclass'  method controls what happens when you call a class; i.e. it allows you to redefine the instance-creation mechanism from start to finish. This is the level at which you can most elegantly implement a completely non-standard instance creation process such as the singleton pattern. In fact, with less than 10 lines of code you can implement a  metaclass that then doesn't even require you to futz with  at all, and can turn any otherwise-normal class into a singleton by simply adding !However this is probably deeper magic than is really warranted for this situation!
To quote the documentation:Typical implementations create a new instance of the class by invoking  the superclass's __new__() method using "super(currentclass,  cls).__new__(cls[, ...])"with appropriate arguments and then  modifying the newly-created instance as necessary before returning it....If __new__() does not return an instance of cls, then the new  instance's __init__() method will not be invoked.__new__() is intended mainly to allow subclasses of immutable  types (like int, str, or tuple) to customize instance creation.
I realize that this question is quite old but I had a similar issue.The following did what I wanted:I used this page as a resource http://infohost.nmt.edu/tcc/help/pubs/python/web/new-new-method.html
I think the simple answer to this question is that, if  returns a value that is the same type as the class, the  function executes, otherwise it won't. In this case your code returns  which is the same class as , so  will be executed.
When  returns instance of the same class,  is run afterwards on returned object. I.e. you can NOT use  to prevent  from being run. Even if you return previously created object from , it will be double (triple, etc...) initialized by  again and again.Here is the generic approach to Singleton pattern which extends vartec answer above and fixes it:Full story is here.Another approach, which in fact involves  is to use classmethods:Please pay attention, that with this approach you need to decorate ALL of your methods with , because you'll never use any real instance of .
outputs:NB As a side effect  property automatically becomes accessible from  as  so take care not to overwrite it incidentally.
__new__ should return a new, blank instance of a class. __init__ is then called to initialise that instance. You're not calling __init__ in the "NEW" case of __new__, so it's being called for you. The code that is calling  doesn't keep track of whether __init__ has been called on a particular instance or not nor should it, because you're doing something very unusual here.You could add an attribute to the object in the __init__ function to indicate that it's been initialised. Check for the existence of that attribute as the first thing in __init__ and don't proceed any further if it has been.
An update to @AntonyHatchkins answer, you probably want a separate dictionary of instances for each class of the metatype, meaning that you should have an  method in the metaclass to initialize your class object with that dictionary instead of making it global across all the classes.I have gone ahead and updated the original code with an  method and  changed the syntax to Python 3 notation (no-arg call to  and metaclass in the class arguments instead of as an attribute).Either way, the important point here is that your class initializer ( method) will not execute either  or  if the key is found. This is much cleaner than using , which requires you to mark the object if you want to skip the default  step.
Referring to this doc: When subclassing immutable built-in types like numbers and strings,  and occasionally in other situations, the static method new comes  in handy. new is the first step in instance construction, invoked  before init. The new method is called with the class as its  first argument; its responsibility is to return a new instance of that  class. Compare this to init: init is called with an instance  as its first argument, and it doesn't return anything; its  responsibility is to initialize the instance. There are situations  where a new instance is created without calling init (for example  when the instance is loaded from a pickle). There is no way to create  a new instance without calling new (although in some cases you can  get away with calling a base class's new).Regarding what you wish to achieve, there also in same doc info about Singleton patternyou may also use this implementation from PEP 318, using a decorator
Digging little deeper into that!The type of a generic class in CPython is  and its base class is  (Unless you explicitly define another base class like a metaclass). The sequence of low level calls can be found here. The first method called is the  which then calls  and then . The interesting part here is that  will call the 's (base class) new method  which does a  () which allocates the memory for the object :)At that point the object is created in memory and then the  method gets called. If  is not implemented in your class then the  gets called and it does nothing :)Then  just returns the object which binds to your variable.
One should look at  as a simple constructor in traditional OO languages. For example, if you are familiar with Java or C++, the constructor is passed a pointer to its own instance implicitly. In the case of Java, it is the  variable. If one were to inspect the byte code generated for Java, one would notice two calls. The first call is to an "new" method, and then next call is to the init method (which is the actual call to the user defined constructor). This two step process enables creation of the actual instance before calling the constructor method of the class which is just another method of that instance.Now, in the case of Python,  is a added facility that is accessible to the user. Java does not provide that flexibility, due to its typed nature. If a language provided that facility, then the implementor of  could do many things in that method before returning the instance, including creating a totally new instance of a unrelated object in some cases. And, this approach also works out well for especially for immutable types in the case of Python.    
The  is called after  so that when you override it in a subclass, your added code will still get called.If you are trying to subclass a class that already has a , someone unaware of this might start by adapting the  and forwarding the call down to the subclass .  This convention of calling  after  helps that work as expected.The  still needs to allow for any parameters the superclass  needed, but failing to do so will usually create a clear runtime error.  And the  should probably explicitly allow for  and '**kw', to make it clear that extension is OK.It is generally bad form to have both  and  in the same class at the same level of inheritance, because of the behavior the original poster described.
However, I'm a bit confused as to why init is always called after new.I think the C++ analogy would be useful here:(A)    new simply allocates memory for the object. The instance variables of an object needs memory to hold it, and this is what the step new would do.(B)    init initialize the internal variables of the object to specific values (could be default).
However, I'm a bit confused as to why  is always called after .Not much of a reason other than that it just is done that way.  doesn't have the responsibility of initializing the class, some other method does (, possibly-- I don't know for sure).I wasn't expecting this. Can anyone tell me why this is happening and how I implement this functionality otherwise? (apart from putting the implementation into the  which feels quite hacky).You could have  do nothing if it's already been initialized, or you could write a new metaclass with a new  that only calls  on new instances, and otherwise just returns .
The simple reason is that the new is used for creating an instance, while init is used for initializing the instance. Before initializing, the instance should be created first. That's why new should be called before init.
Now I've got the same problem, and for some reasons I decided to avoid decorators, factories and metaclasses. I did it like this:Main fileExample classesIn useWarning: You shouldn't initialize Parent, it will collide with other classes - unless you defined separate cache in each of the children, that's not what we want.Warning: It seems a class with Parent as grandparent behaves weird. [Unverified]Try it online!


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__new__
