Natural Text
I understand that threads in Python use the same instance of Python interpreter. My question is it the same with process created by ? Or does each process created by  has its own interpreter?
Whenever you fork, the entire Python process is duplicated in memory (including the Python interpreter, your code and any libraries, current stack etc.) to create a second process - one reason why forking a process is much more expensive than creating a thread.This creates a new copy of the python interpreter.One advantage of having two python interpreters running is that you now have two GIL's (Global Interpreter Locks), and therefore can have true multi-processing on a multi-core system.Threads in one process share the same GIL, meaning only one runs at a given moment, giving only the illusion of parallelism.
While  does indeed create a copy of the current Python interpreter rather than running with the same one, it usually isn't what you want, at least not on its own. Among other problems:There can be problems forking multi-threaded processes on some platforms. And some libraries (most famously Apple's Cocoa/CoreFoundation) may start threads for you in the background, or use thread-local APIs even though you've only got one thread, etc., without your knowledge.Some libraries assume that every process will be initialized properly, but if you  after initialization that isn't true. Most infamously, if you let  seed its PRNG in the main process, then fork, you now have potentially predictable random numbers, which is a big hole in your security.Open file descriptors are inherited (as dups) by the children, with details that vary in annoying ways between platforms.POSIX only requires platforms to implement a very specific set of syscalls between a  and an . If you never call , you can only use those syscalls. Which basically means you can't do anything portably.Anything to do with signals is especially annoying and nonportable after .See POSIX  or your platform's manpage for details on these issues.The right answer is almost always to use , or  (which wraps up ), or a similar third-party library.With 3.4+, you can even specify a start method. The  method basically just calls . The  method runs a single "clean" process (no threads, signal handlers, SSL initialization, etc.) and forks off new children from that. The  method calls  then , or an equivalent like , to get you a brand-new interpreter instead of a copy. So you can start off with , ut then if there are any problems, switch to  or  and nothing else in your code has to change. Which is pretty nice.
 is equivalent to the  syscall in many UNIC(es). So yes your sub-process(es) will be separate from the parent and have a different interpreter (as such).:FORK(2)NAME         fork - create a child processSYNOPSIS         #include DESCRIPTION         fork()  creates  a new process by duplicating the calling process.  The new process, referred to as the child,         is an exact duplicate of the calling process, referred to as the parent, except for the following points:: Fork a child process. Return 0 in the child and the  childâ€™s process id in the parent. If an error occurs OSError is  raised.Note that some platforms including FreeBSD <= 6.3, Cygwin and OS/2 EMX  have known issues when using fork() from a thread.See also: Martin Konecny's response as to the why's and advantages of "forking" :)For brevity; other approaches to concurrency which don't involve a separate process and therefore a separate Python interpreter include:Green or Lightweight threads; ala greenletCoroutines ala Python generators and the new Python 3+ Async I/O ala asyncio, Twisted, circuits, etc.


Answer URL
https://docs.python.org/3/library/multiprocessing.html
https://docs.python.org/3/library/concurrent.futures.html
https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods
https://docs.python.org/3/library/asyncio.html
