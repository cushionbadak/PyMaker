Natural Text
I am debugging method  that has no  in it. I need to see how this method modifies variable  right after it is called. To do that, I insert a  at the end of the method, and set the breakpoint there:That way, as soon as the method reaches its , I can see the value of my variable . This does the job, but I am pretty sure there is a better way. Editing a method or function every time I need to debug it seems silly.Question:Is there a different way (e.g. an option in the debugger) to set a breakpoint at the end of a method that does not have a ?(Note that setting a breakpoint at the function call and using Step Over would not display  when mouseovering, since the function is called from a different module.)
You can add a conditional breakpoint on the last line and set the condition to be something that occurs only in the last iteration.In this instance the condition is very easy since it's just , but it may be a lot more complex depending on your loop condition so sometimes adding a statement at the end will be the easier solution.That screenshot is from IntelliJ IDEA and your screenshot looks like it's from the same IDE, so just right-click the breakpoint to show the dialog and enter your condition.If you're using some other IDE I'm sure there is capability to make a breakpoint conditional.Update:There is no support for breaking at the end of a method in the Python debugger, only at the start of a method:b(reak) [[filename:]lineno | function[, condition]]With a lineno argument, set a break there in the current file. With a function argument, set a break at the first executable statement within that function. The line number may be prefixed with a filename and a colon, to specify a breakpoint in another file (probably one that hasn't been loaded yet). The file is searched on sys.path. Note that each breakpoint is assigned a number to which all the other breakpoint commands refer.If a second argument is present, it is an expression which must evaluate to true before the breakpoint is honored.Without argument, list all breaks, including for each breakpoint, the number of times that breakpoint has been hit, the current ignore count, and the associated condition if any.
There is a quick&dirty solution that works on any language that supports monkeypatching (Python, Ruby, ObjC, etc.). I honestly can't remember ever needing it in Python, but I did it quite a bit in both SmallTalk and ObjC, so maybe it'll be useful for you.Just dynamically wrap  in a function, like this:In most scriptable debuggers, you should be able to write a script that does this automatically for a method by name. In pdb, which lets you execute normal Python code right in the debugger, it's especially simple.Now you can put a breakpoint on that , and it's guaranteed to hit immediately after the real  returns (even if it returns in the middle or falls off the end without a  statement).A few things you may want to add:If you also want to catch  raising, put a  and  around the code, and add a breakpoint on the .For Python 2.x, you may want to wrap that up with types.MethodType to make a real unbound method.If you only want a breakpoint on a specific  instance, you can either use a conditional breakpoint that checks , or use  to create a bound instance and store that as .You may want to use  if you want to hide the wrapper from the rest of the code (and from your debugging, except in the cases where you really want to see it).Since pdb lets you execute dynamic code right in the live namespace, you can put a  function somewhere in your project that does this, and then, at the prompt, write . But if you wrap multiple methods this way, they're going to share the same breakpoints (inside the wrapper function defined inside ). Here I think a conditional breakpoint is the only reasonable option.If you want access to the real A.f's locals from the wrapper's breakpoint, that's a lot harder. I can think of some very hacky options (e.g., , but nothing I'd be happy with.
Your IDE is hiding what's under the hood.That is, something likeis prepended to your script andis inserted before the line onto which your placed your breakpoint.From what you say I deduce that PyCharm does not like placing breakpoints on empty lines. However  can perfectly be placed at the end of a method.So you could insert those yourself (or write a macro) and run  to start debugging. (Edit) exampleDebug with can be used instead of .                                                                                                                     
With  you can use nice combination of  and :Without argument, continue execution until the line with a number  greater than the current one is reached.With a line number, continue execution until a line with a number  greater or equal to that is reached. In both cases, also stop when the  current frame returns.Changed in version 3.2: Allow giving an explicit line number.You can achieve what you needed.I modified your example a bit (so you would see that instruction gets executed although pdb reports it as "next instruction"):And result from running with  goes like this:Start debugging and run it just after class declaration (so you can add named breakpoint):Now, break at the beginning of function:Just continue with execution until it hits breakpoint:Take advantage of "also stop when the current frame returns":As you can see, both pre exec and post exec were printed, but when executing  you are still in :And all context variables are intact:Now with your real life example:Start the similar fashion as before:Now... Breakpoint in  actually means breakpoint at first statement of  which is unfortunately  so it would break on it every time.If you don't actually start your real code with loop, you can skip this part.Again, use the :And again, all frame variables are available:The sad thing here is, that I wanted to try this piece of automation:Which would do everything you need automatically (again,  not needed when you have at least one pre-loop statement), but according to documentation on :Specifying any command resuming execution (currently continue, step, next, return, jump, quit and their abbreviations) terminates the command list (as if that command was immediately followed by end). This is because any time you resume execution (even with a simple next or step), you may encounter another breakpoint–which could have its own command list, leading to ambiguities about which list to execute.So  just doesn't seem to work (at least for Python 3.2.5 under windows) and you have to do this by hand.
You have a few options here.Add a break point to the last line in the function.In this case, the last line is within a loop, so you would have to iterate over each item in the loop.Add a break point where the function is being called.This will stop the debugger prior to the function being called, but you can "Step Over" the function to see the value of  after  is called.Add a temporary statement the end of the function to break atThis trick would work if your function ends in a loop and there are multiple places the function is called or you don't want to track down the function call.You can add a simple statement to the end of the function for debugging purposes and add a break point there.
Why not just leave the return in there? Or a . It's implicit anyway, the interpreter/compiler will do the same thing regardless:In fact, even functions without a return statement do return a value, albeit a rather boring one. This value is called None (it’s a built-in name).[source: Python Tutorial 4.6].


Answer URL
https://docs.python.org/3/library/pdb.html
