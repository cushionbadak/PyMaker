Natural Text
I am working on a project in BGE and I want to make an object slowly accelerate to its max speed when I press the button. When I press another button it should decelerate and then again slowly accelerate to the top speed in the other direction.Here is the code:I have an object with the  property which I'm using to controll the speed of the object. When I hold W key it accelerates. But instead of stopping at -0.05, it runs one more time and it stops at -0.055. If I then hold S button, it deccelerates and then again accelerates and stops at 0.05.The confusing thing is that if I hold S key first, it Will accelerate to 0.055, and it will work fine the other way around.So actuali, the direction, which will reach the top speed firs will be broken and the other will be fine and it will stay that way, so one side will always have max speed 0.055 and the other 0.05.I can't understand what's wrong. I suspect it has to do something wit game properties, but I realy don't Know. Also if there's another way of doing what I did, please let me know.Thanks!
The reason for the problems are rounding-errors with floating-points. Unfortunately, for floating-points addition and multiplication introduce small errors that can lead to problems with comparisons.Instead, you should use "clamping", which means you prevent over/undershooting by comparing with a threshold, and then setting the value to the threshold itself:Thus speed will never exceed the boundaries of [0..max_speed]
It's hard to be sure without more information, but I'm almost certain this is just a typical floating-point rounding error.Consider this code (which is effectively doing the same thing as your code, but without all the user interaction stuff in the middle):You'd think the result would be , right? But it's not. It's . Why did it go one step too far?If you print out all the values along the way, the reason is obvious:There is no floating-point double exactly equal to all of these numbers, so you accumulate rounding error. When you get to the 10th one, it's not , it's , which is still less than , so it goes one more step.There are two solutions to problems like this.First, you can use  instead of . Of course  is just as inexact and subject to rounding errors as  in general; the difference is that any number that has an exact decimal string representation (like  and all of your other values) also has an exact  representation. So:And now you get  instead of .Alternatively, you can use absolute or relative epsilon comparisons. For example:Now you get  instead of  at the end.
round off your property. The 2 is the round point.


Answer URL
https://docs.python.org/3/library/decimal.html
