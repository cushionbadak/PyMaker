Natural Text
How to get the value  which is returned from the thread's target?  The "one obvious way to do it", shown above, doesn't work:  returned .
FWIW, the  module has a nice interface for this using the  class.  And if you want to stick with threads rather than processes, you can just use the  class as a drop-in replacement.
One way I've seen is to pass a mutable object, such as a list or a dictionary, to the thread's constructor, along with a an index or other identifier of some sort. The thread can then store its results in its dedicated slot in that object.  For example:If you really want  to return the return value of the called function, you can do this with a  subclass like the following:That gets a little hairy because of some name mangling, and it accesses "private" data structures that are specific to  implementation... but it works.For python3
Jake's answer is good, but if you don't want to use a threadpool (you don't know how many threads you'll need, but create them as needed) then a good way to transmit information between threads is the built-in Queue.Queue class, as it offers thread safety.I created the following decorator to make it act in a similar fashion to the threadpool:Then you just use it as:The decorated function creates a new thread each time it's called and returns a Thread object that contains the queue that will receive the result.UPDATEIt's been quite a while since I posted this answer, but it still gets views so I thought I would update it to reflect the way I do this in newer versions of Python:Python 3.2 added in the  module which provides a high-level interface for parallel tasks.  It provides  and , so you can use a thread or process pool with the same api.One benefit of this api is that submitting a task to an  returns a  object, which will complete with the return value of the callable you submit.This makes attaching a  object unnecessary, which simplifies the decorator quite a bit:This will use a default module threadpool executor if one is not passed in.The usage is very similar to before:If you're using Python 3.4+, one really nice feature of using this method (and Future objects in general) is that the returned future can be wrapped to turn it into an  with .  This makes it work easily with coroutines:If you don't need access to the underlying  object, you can include the wrap in the decorator:Then, whenever you need to push cpu intensive or blocking code off the event loop thread, you can put it in a decorated function:
Another solution that doesn't require changing your existing code:It can be also easily adjusted to a multi-threaded environment:
Parris / kindall's answer / answer ported to Python 3:Note, the  class is implemented differently in Python 3.
I stole kindall's answer and cleaned it up just a little bit.The key part is adding *args and **kwargs to join() in order to handle the timeoutUPDATED ANSWER BELOWThis is my most popularly upvoted answer, so I decided to update with code that will run on both py2 and py3.Additionally, I see many answers to this question that show a lack of comprehension regarding Thread.join(). Some completely fail to handle the  arg. But there is also a corner-case that you should be aware of regarding instances when you have (1) a target function that can return  and (2) you also pass the  arg to join().  Please see "TEST 4" to understand this corner case.ThreadWithReturn class that works with py2 and py3:Some sample tests are shown below:Can you identify the corner-case that we may possibly encounter with TEST 4?The problem is that we expect giveMe() to return None (see TEST 2), but we also expect join() to return None if it times out. means either:(1) that's what giveMe() returned, or(2) join() timed outThis example is trivial since we know that giveMe() will always return None. But in real-world instance (where the target may legitimately return None or something else) we'd want to explicitly check for what happened.Below is how to address this corner-case:
Using Queue :
My solution to the problem is to wrap the function and thread in a class. Does not require using pools,queues, or c type variable passing. It is also non blocking. You check status instead. See example of how to use it at end of code.
You can define a mutable above the scope of the threaded function, and add the result to that. (I also modified the code to be python3 compatible)This returns If you use the function input as the key to your results dict, every unique input is guaranteed to give an entry in the results 
You can use Pool as a pool of worker processes as below:
Taking into consideration @iman comment on @JakeBiesinger answer I have recomposed it to have various number of threads:Cheers,Guy.
 always return , i think you should subclass  to handle return codes and so.
I'm using this wrapper, which comfortably turns any function for running in a  - taking care of its return value or exception. It doesn't add  overhead. Usage ExamplesNotes on  moduleComfortable return value & exception handling of a threaded function is a frequent "Pythonic" need and should indeed already be offered by the  module - possibly directly in the standard  class.  has way too much overhead for simple tasks - 3 managing threads, lots of bureaucracy. Unfortunately 's layout was copied from Java originally - which you see e.g. from the still useless 1st (!) constructor parameter .
As mentioned multiprocessing pool is much slower than basic threading. Using queues as proposeded in some answers here is a very effective alternative. I have use it with dictionaries in order to be able run a lot of small threads and recuperate multiple answers by combining them with dictionaries:
Define your target to1) take an argument 2) replace any statements  with so a functionwould becomeand then you would proceed as suchAnd you can use function decorators/wrappers to make it so you can use your existing functions as  without modifying them, but follow this basic scheme.
One usual solution is to wrap your function  with a decorator likeThen the whole code may looks like thatNoteOne important issue is that the return values may be unorderred.(In fact, the  is not necessarily saved to the , since you can choose arbitrary thread-safe data structure )
Why don't just use global variable?
Very simple way to get this done for such dummies like me:main thing here - is  module. We create  instance and include it in our function. We feed it with our result which later we get beyond the thread.Please see one more example with arguments passed to our test function:
GuySoft's idea is great, but I think the object does not necessarily have to inherit from Thread and start() could be removed from interface:
Kindall's answer in Python3
If only True or False is to be validated from a function's call, a simpler solution I find is updating a global list. This is more helpful where you want to find if any one of the threads had returned a false status to take the necessary action. 


Answer URL
https://docs.python.org/3/library/concurrent.futures.html
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future
https://docs.python.org/3/library/asyncio-task.html#asyncio.Future
https://docs.python.org/3/library/asyncio-task.html#asyncio.wrap_future
