Natural Text
I am somewhat puzzled about reasoning in difference in implementation of ES6 Promises and PEP3148 Futures. In Javascript, when Promise is resolved with another Promise, "outer" promise inherits the value of "inner" promise once it's resolved or rejected. In Python, "outer" future is instead immediately resolved with "inner" future itself, not with it's eventual value, and that is the problem.To illustrate this, I had provided two code snippets for both platforms. In Python, code looks like this:In Javascript, fully equivalent code is this: function provided for the sake of completeness.Javascript code prints , as expected. Python code prints  and complaints about "coroutine 'foo' was never awaited".This way, JS allows you to choose the point when the control will be passed away of your current context of execution, by immediately ing promises, or letting caller to await them. Python literally leaves you no other option than always  the Future/coroutine, because otherwise you will have to unwind the Future chain in a loop yourself with an ugly wrapper function like this:So, the question: Is there any reasoning behind this decision? Why Python disallows chained Futures? Were there any discussions about it? Is there anything that can be done to make behavior match Promises closer?
Let me show a quick comparison of JavaScript's Promises, and Python's futures, where I can point out the main usecases and reveal the reasons behind decisions.I will use the following dummy example to demonstrate the use of async functions:Asynchronous JavaScriptBack in the day, before the concept of Promises emerged, people wrote their code using callbacks. There are still various conventions aboutwhich argument should be the callback, how errors should be handled, etc... At the end, our function looks something like this:This does the same as the example, and yes, I used 4 indentation spaces intentionally to magnify the problem with the so called callback hell orpyramid of doom. People using JavaScript were writing code like this for many years! Then Kris Kowal came with his flaming Q library and saved the disappointed JavaScript community by introducing the concept of Promises.The name is intentionally not "future" or "task". The main goal of the Promise concept is to get rid of the pyramid. To achieve this promiseshave a  method which not only allows you to subscribe to the event that is fired when the promised value is obtained, but will also return another promise, allowing chaining. That is what make Promises and futures a different concept. Promises are a bit more.See? It is essential to unwrap promises returned from  callbacks to build a clean, transparent chain. (I myself wrote this kind of asynchronouoscode for over a year.)However, things get complicated when you need some control flow like conditional branching or loops.When the first compilers/transpilers (like 6to5) for ES6 appeared, people slowly started to use generators. ES6 generators are two directional, meaningthe generator not only produces values, but can receive supplied values on each iteration. This allowed us to write the following code:Still using promises,  makes an async function from a generator. There is no black magic there, this wrapper function is implemented usingnothing but  (more or less). We are nearly there.Today, since the ES7 specification for async-await is pretty mature, anyone can compile asynchronous ES7 code to ES5 using BabelJS.Returning promise from an async functionSo this works:and so does this:This kind of weak/dynamic/duck typing fits well in JavaScript's view of the world.You are right that you can return a promise from an async function without await, and it gets unwinded.It is not really a decision, but is a direct consequence of how  works, as it unwinds the promises to make chaining comfortable. Still, I think it is a good practice to write await before everyasync call to make it clear you are aware of the call being asynchronous. We do have multiple bugsevery day because of missing await keywords, as they will not cause instantaneous errors, just a bunchof random tasks running in parallel. I love debugging them. Seriously.Asynchronous PythonLet's see what Python people did before async-await coroutines were introduced in python:Wait what? Where are the futures? Where is the callback pyramid? The point is that Python peopledo not have any of the problems JavaScript people had. They just use blocking calls.The big difference between JavaScript and PythonSo why didn't JavaScript people use blocking calls? Because they couldn't! Well, they wanted to. Believe me.Before they introduced WebWorkers all JavaScript code ran on the gui thread, and any blocking call causedthe ui to freeze! That is undesireable, so people writing the specifications did everything to prevent such things.As of today, the only ways to block the UI thread in a browser I am aware of:Using XMLHttpRequest with the deprecated  optionUsing a spin-wait(Or do actual heavy computation)Currently you cannot implement spin-locks and similar things in JavaScript, there is just no way.(Until browser vendors start to implement things like Shared Array Buffers, which I am afraid of will bringa special kind of hell upon us as soon as enthusiast amateurs will start to use them)On the other hand there is nothing wrong with blocking calls in Python as usually there is no such thing as a 'gui thread'. If you still need some parallelism, you can start a new thread, and work on that. This is useful whenyou want to run multiple SOAP requests at once, but not as useful when you want to utilize the computational powerof all the cpu cores in your laptop, as the Global Interpreter Lock will prevent you to do so. (This wasworked around by the multiprocessing module, but that's another story)So, why do Python people need coroutines? The main answer is that reactive programming got really popular nowadays.There are of course other aspects, like not wanting to start a new thread for every restful query you make, (some Python libraries are known to leak thread ids until they eventually crash) or just wanting to get rid of all theunnecessary multithreading primitives like mutexes and semaphores. (I mean those primitives can be omitted if yourcode can be rewritten to coroutines. Sure they are needed when you do real multithreading.) And that is why futureswere developed.Python's futures do not allow chaining in any form. They are not intended to be used that way. Remember, JavaScript's promises were to change the pyramid scheme to a nice chain scheme, so unwinding was necessary. But automaticunwinding needs specific code to be written, and needs the future resolution to make distinction between suppliedvalues by their types or properties. That is, it would be more complex (=== harder to debug), and would be alittle step towards weak typing, which is against the main principles of python. Python's futures are lightweight,clean and easy to understand. They just don't need automatic unwinding.


Answer URL
https://docs.python.org/3/library/asyncio-task.html#example-chain-coroutines
