Natural Text
I'm writing code in python 3.5 that uses hashlib to spit out MD5 encryption for each packet once it is is given a pcap file and the password. I am traversing through the pcap file using pyshark. Currently, the values it is spitting out are not the same as the MD5 encryptions on the packets in the pcap file. One of the reasons I have attributed this to is that in the hex representation of the packet, the values are represented with leading 0s. Eg: Protocol number is shown as b'06'. But the value I am updating the hashlib variable with is b'6'. And these two values are not the same for same reason:The way I am encoding integers is:I am doing this encoding because otherwise it would result in this error: "TypeError: Unicode-objects must be encoded before hashing"I was wondering if I could get some help finding a python encoding library that ignores leading 0s or if there was any way to get the inbuilt hex method to ignore the leading 0s.Thanks!
Hashing  and  gives different results because, in this context, '06' and '6' are different.The  string prefix in Python tells the Python interpreter to convert each character in the string into a byte. Thus,  will be converted into the two bytes , whereas  will be converted into the single byte . Just as hashing  and  (note the space) produces different results, hashing  and  will similarly produce different results.If you don't understand why this happens, I recommend looking up how bytes work, both within Python and more generally - Python's handling of bytes has always been a bit counterintuitive, so don't worry if it seems confusing! It's also important to note that the way Python represents bytes has changed between Python 2 and Python 3, so be sure to check which version of Python any information you find is talking about. You can comment here, too, 


Answer URL
https://docs.python.org/3/library/stdtypes.html#str.zfill
