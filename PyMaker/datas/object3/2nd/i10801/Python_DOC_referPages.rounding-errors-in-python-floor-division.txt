Natural Text
I know rounding errors happen in floating point arithmetic but can somebody explain the reason for this one:This happens on both Python 2 and 3 on x64.As far as I see it this is either a bug or a very dumb specification of  since I don't see any reason why the last expression should evaluate to .Why isn't  simply defined as  ?EDIT:  also evaluates to . At least this is consequent since then  evaluates to EDIT: This is not a duplicate of Is floating point math broken? since I am asking why this specific operation is subject to (maybe avoidable) rounding errors, and why  isn't defined as / equal to REMARK: I guess that the deeper reason why this doesn't work is that floor division is discontinuous and thus has an infinite condition number making it an ill-posed problem. Floor division and floating-point numbers simply are fundamentally incompatible and you should never use  on floats. Just use integers or fractions instead.
As you and khelwood already noticed,  cannot be exactly represented as a float. Why? It is two fifth () which does not have a finite binary fraction representation.Try this:HoweverHere,  is interpreted as a float literal (and thus a floating point binary number) which requires (binary) rounding, and only then converted to the rational number , which is almost but not exactly 4 / 10. Then the floored division is executed, and because and the result is 19, not 20.The same probably happens forI.e., it seems floored division is determined atomically (but on the only approximate float values of the interpreted float literals).So why doesgive the "right" result? Because there, two rounding errors cancel each other out. First 1) the division is performed, yielding something slightly smaller than 20.0, but not representable as float. It gets rounded to the closest float, which happens to be . Only then, the  operation is performed, but now acting on exactly , thus not changing the number any more.1) As Kyle Strand points out, that the exact result is determined then rounded isn't what actually happens low2)-level (CPython's C code or even CPU instructions). However, it can be a useful model for determining the expected 3) result.2) On the lowest 4) level, however, this might not be too far off. Some chipsets determine float results by first computing a more precise (but still not exact, simply has some more binary digits) internal floating point result and then rounding to IEEE double precision.3) "expected" by the Python specification, not necessarily by our intuition.4) Well, lowest level above logic gates. We don't have to consider the quantum mechanics that make semiconductors possible to understand this.
@jotasi explained the true reason behind it.However if you want to prevent it, you can use  module which was basically designed to represent decimal floating point numbers exactly in contrast to binary floating point representation.So in your case you could do something like:Reference: https://docs.python.org/2/library/decimal.html
Ok after a little bit of research I have found this issue. What seems to be happening is, that as @khelwood suggested  evaluates internally to , which when dividing  yields something slightly smaller than . The  operator then rounds to the nearest floating point number, which is , but the  operator immediately truncates the result, yielding .This should be faster and I suppose its "close to the processor", but I it still isn't what the user wants / is expecting.
That's because there is no 0.4 in python (floating-point finite representation) it's actually a float like  which makes the floor of division to be 19.But the true division () returns a reasonable approximation of the division result if the arguments are floats or complex. And that's why the result of  is 20. It actually depends on the size of arguments (in C double arguments). (not rounding to nearest float)Read more about pythons integer division floors by Guido himself.Also for complete information about the float numbers you can read this article https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.htmlFor those who have interest, the following function is the  that does the true division task for float numbers, in Cpython's source code:Which the final result would be calculated by function :
After checking the semi-official sources of the float object in cpython on github (https://github.com/python/cpython/blob/966b24071af1b320a1c7646d33474eeae057c20f/Objects/floatobject.c) one can understand what happens here.For normal division  is called (line 560) which internally converts the python s to c-s, does the division and then converts the resulting  back to a python . If you simply do that with  in c you get:For the floor division, something else happens. Internally,  (line 654) gets called, which then calls , a function that is supposed to return a tuple of python s containing the floored division, as well as the mod/remainder, even though the latter is just thrown away by . These values are computed the following way (After conversion to c-s):The remainder is computed by using .The numerator is reduced by  to get a integral value when you then do the division.The result for the floored division is calculated by effectively computing Afterwards, the check already mentioned in @Kasramvd's answer is done. But this only snaps the result of  to the nearest integral value.The reason why this gives a different result is, that  due to floating-point arithmetic gives  instead of . Therefore, the result that is computed is actually  and snapping  to the nearest integral value does not fix the error made introduced by the "wrong" result of . You can easily chack that in c as well:I would guess, that they chose this way of computing the floored division to keep the validity of  (as mentioned in the link in @0x539's answer), even though this now results in a somewhat unexpected behavior of .


Answer URL
https://docs.python.org/3/library/decimal.html#decimal-objects
