Natural Text
I'd like to create a class in Python that takes a single argument in the constructor, another Python class. The instance of the Copy class should have all the attributes and methods of the original class, without knowing what they should be beforehand. Here's some code that almost works:The print statement in the constructor prints 'a', but the final one gives the error .
I am unsure why you would wish to do this, but you probably have your reasons.You can leverage off normal inheritance:eg:
You need to copy the :
This is an interesting question to point out a pretty cool feature of Python's pass-by-value semantics, as it is intimately tied to why your original code doesn't work correctly and why @martineau's solution works well.Why Your Code As Written Doesn't WorkPython doesn't support pure pass-by-reference or pass-by-value semantics - instead, it does the following:To see this in action,What happens? Assignment creates a local  which is then assigned a value. Once this happens, the original parameter that was passed in as an argument is inaccessible.However, so long as the name  is bound to the object that's passed in, you can modify attributes and it will be reflected in the object you passed in. The minute you 'give away' the name  to something else, however, that name is no longer bound to the original parameter you passed in.Why is this relevant here? If you pay careful attention to the signature for , you'll notice it takes  as a parameter. What is ? Ordinarily,  refers to the object instance. So the name  is bound to the object instance. This is where the fun starts. By assigning to  in your code, this property no longer holds true!The minute you leave , this new local variable  goes out of scope. That is why doing  yields an error outside of the constructor - you never actually assigned to the object in the first place!Why @martineau's Solution Works@martineau simply took advantage of this behaviour to note that the  attribute exists on the  object, and assigns to it:This now works because the  attribute is what Python calls when Python needs to lookup a method signature or attribute when it sees the namespace operator , and also because  has not been changed but still refers to the object instance. By assigning to , you obtain an almost exact copy of the original class ('almost exact' because even  has limits).The moral of the story should be clear: never assign anything to  directly. Instead, only assign to attributes of  if you ever need to. Python's metaprogramming permits a wide degree of flexibility in this regard, and you should always consult the documentation in this regard.


Answer URL
https://docs.python.org/3/library/stdtypes.html#special-attributes
