Natural Text
I know that bisect is using binary search to keep lists sorted. However I did a timing test that the values are being read and sorted. But, on the contrary to my knowledge, keeping the values and then sorting them win the timing by high difference. Could more experienced users please explain this behavior ? Here is the code I use to test the timings.In the first process I take values one-by-one instead of just sorting  to obtain a behavior like file reading. And it beats bisect very hard.
Your algorithmic complexity will be worse in the bisect case ...In the  case, you have  operations (each at an average cost of  to find the insertion point and then an additional  step to insert the item).  Total complexity:  .With , you have a single  step (plus   steps to build the list in the first place).  Total complexity: Also note that  is implemented in very heavily optimized C code ( isn't quite as optimized since it ends up calling various comparison functions much more frequently...)
Sorting a list takes about  time. Appending N items to a list takes  time. Doing these things consecutively takes about  time.Bisecting a list takes  time. Inserting an item into a list takes  time. Doing both N times inside a for loop takes  time. is worse than , so your  is faster than your .
To understand the time difference, let’s look at what you are actually doing there.In your first example, you are taking an empty list, and append items to it, and sorting it in the end.Appending to lists is really cheap, it has an amortized time complexity of O(1). It cannot be really constant time because the underlying data structure, a simple array, eventually needs to be expanded as the list grows. This is done every so often which causes a new array to be allocated and the data being copied. That’s a bit more expensive. But in general, we still say this is O(1).Next up comes the sorting. Python is using Timsort which is very efficient. This is O(n log n) at average and worst case. So overall, we get constant time following  so the sorting is the only thing that matters here. In total, this is pretty simple and very fast.The second example uses . This utilizes a list and binary search to ensure that the list is sorted at all times.Essentially, on every insert, it will use binary search to find the correct location to insert the new value, and then shift all items correctly to make room at that index for the new value. Binary search is cheap, O(log n) on average, so this is not a problem. Shifting alone is also not that difficult. In the worst case, we need to move all items one index to the right, so we get O(n) (this is basically the insert operation on lists).So in total, we would get linear time at worst. However, we do this on every single iteration. So when inserting  elements, we have O(n) each time. This results in a quadratic complexity, O(n²). This is a problem, and will ultimately slow the whole thing down.So what does this tell us? Sorted inserting into a list to get a sorted result is not really performant. We can use the  module to keep an already sorted list ordered when we only do a few operations, but when we actually have unsorted data, it’s easier to sort the data as a whole.
Insertion and deletion operations in a data structure can be surprisingly expensive sometimes, particularly if the distribution of incoming data values is random. Whereas, sorting can be unexpectedly fast.A key consideration is whether-or-not you can "accumulate all the values," then sort them once, then use the sorted result "all at once." If you can, then sorting is almost always very-noticeably faster.If you remember the old sci-fi movies (back when computers were called "giant brains" and a movie always had spinning tape-drives), that's the sort of processing that they were supposedly doing: applying sorted updates to also-sorted master tapes, to produce a new still-sorted master. Random-access was not needed. (Which was a good thing, because at that time we really couldn't do it.) It is still an efficient way to process vast amounts of data.


Answer URL
https://docs.python.org/3/library/bisect.html#bisect.insort
