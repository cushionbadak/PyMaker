Natural Text
I have a file named example_dict.pyThen I read this file and transform dict:But this "dict_from_file" not have the same order key1, key2, key3.How I can get this dict in same order.
You can write a custom parser using the  module, for a starter:Note that although this works with your example data - this needs a bit more work to make it more robust, but should serve as a starting point.
@JonClements' solution is beautiful and simple—but, as he points out, it's not that robust, because you're depending on the fact that each element of the dictionary display will evaluate to itself—and that you've got some arbitrary code of which the first valid dict literal is the only thing you care about.A related idea would be to use  transform the dict literal AST into an OrderedDict constructor AST, then just  that.Pros:Once you get it working for trivial cases, it automatically works properly for more complex cases.It's trivial to extend it from parsing single dict literals to converting all dict literals in an entire module (which you can then install as part of an import hook). You get to learn more about how Python ASTs work.Cons:There's a lot more (and uglier) code to write to get it working for trivial cases.Since you're not parsing the elements manually, it's not as easy to add in restrictions for, e.g., safely processing potentially malicious or incompetent input (e.g., by using  on each element).You have to learn more about how Python ASTs work.However, it's worth stepping back and asking whether you really want to write and use all this code. You might be a lot happier using something like , which automates a lot of the clunky stuff being done here, and a lot of the stuff I'm not doing here (like installing import hooks), to let you concentrate on just the part of the transformation that's interesting to you. (Actually, I think MacroPy even comes with an odict literal as one of its builtin examples…)Anyway, the transformer looks like this:This is a little uglier than usual, because dict literals don't have to have a context (because they can't be used as assignment targets), but tuples do (because they can), so we can't just copy the context the way we do the line numbers.To use it:That assumes you want to evaluate exactly one expression at a time, and that you want to do so within the current global/local environment, and that you don't mind inserting the  module into that environment; if you look at the docs for , , and  it should be obvious how to change any of those assumptions.So:If you want to learn more, without digging through the source code yourself, Green Tree Snakes is a great resource for understanding Python's ASTs and its  module that I wish had been written a few years earlier. :)
Python dictionaries do not have any inherent order. You probably already know this, since you're trying to put your data into an instance of , which does maintain the order its values are added in.However, the problem you're having is that your  expression is producing an ordinary  instance first, and only after the order has already been lost does it get passed on to .There's no direct way around this. If you use  to parse a file with a dictionary literal in it, it's going to give you a regular .There are other options though. You could write your own parsing code, and create the values to put in the  directly without creating a regular  first. This would be somewhat complicated, and you should probably pick a better file format if this is the approach you go for.If in fact you can change the file's contents, you could simply have the  call create some other data structure which you can pass to  without losing the ordering information. A list of  2-tuples would be a good option, requiring no other changes to your code:Note that in some future version of Python, keyword arguments passed in function calls may get put into an  rather than a  (as described in PEP 468). If that happens, you could change your file contents to the following, and get an  directly from :Alas, if you try this today you'll run into the same issue your current code does (the keyword arguments are packed into a regular  which discards their ordering before the  code gets a look at them). The keyword arguments to the  constructor are not terribly useful.


Answer URL
https://docs.python.org/3/library/ast.html#ast.NodeTransformer
