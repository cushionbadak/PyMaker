Natural Text
A callable object is supposed to be so by defining . A class is supposed to be an object… or at least with some exceptions. This exception is what I'm failing to formally clarify, thus this question posted here.Let  be a simple class:The first function is purposely named “call”, to make clear the purpose is the comparison with the other.Let's instantiate it and forget about the expression it implies:Now what's worth:Result in:The output (third statement not running ) does not come as a surprise, but when I think every where it is said “Python class are objects”…This, more explicit, however run All of this is just to show how finally  may looks strange.There are exception in Python rules, but the documentation about “object.call” does not say a lot about … not more than that:3.3.5. Emulating callable objectsCalled when the instance is “called” as a function; […]But how do Python tell “it's called as a function” and honour or not the  rule?This could be a matter of type, but even type has  as its base class.Where can I learn more (and formally) about it?By the way, is there any difference here between Python 2 and Python 3?----- %< ----- edit ----- >% -----Conclusions and other experiments after one answer and one commentUpdate #1After @Veedrac's answer and @chepner's comment, I came to this other test, which complete the comments from both:The result is:So it seems that's the meta‑class which drives the “call” operations. If I understand correctly, the meta‑class does not matter only with class, but also with classes instances.Update #2Another relevant test, which shows this is not an attribute of the object which matters, but an attribute of the type of the object:As expected, it prints:Now this:It prints:The same a before the attribute was assigned. It does not print , it's still . That's important to note and also explain why that's the  of the meta‑class which was invoked (keep in mind the meta‑class is the type of the class object). The  used to call as function, is not from the object, it's from its type.
 is the same as .So you haveand it all makes sense.chepner points out in the comments that . This is kind-of wierd, because  just gives  again! But remember that we're instead using  which is not the same.So this resolves to . This is the constructor function for classes, which builds the data-structures and does all the construction magic.The same is true of most dunder (double underscore) methods, such as . This is partially an optimisation in those cases.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__call__
