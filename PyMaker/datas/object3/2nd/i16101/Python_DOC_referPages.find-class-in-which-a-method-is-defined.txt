Natural Text
I want to figure out the type of the class in which a certain method is defined (in essence, the enclosing static scope of the method), from within the method itself, and without specifying it explicitly, e.g.Is this possible?
If you need this in Python 3.x, please see my other answer—the closure cell  is all you need.If you need to do this in CPython 2.6-2.7, RickyA's answer is close, but it doesn't work, because it relies on the fact that this method is not overriding any other method of the same name. Try adding a  method in his answer, and it will print out , not The way to solve that is to find the method whose code object is identical to the current frame's code object:(Note that the  could be raised either by  not having something named , or by  having something named  that isn't a function, and therefore doesn't have a . But we don't care which; either way,  is not the match we're looking for.)This may work in other Python 2.6+ implementations. Python does not require frame objects to exist, and if they don't,  will return . And I'm pretty sure it doesn't require code objects to exist either, which means  could be .Meanwhile, if you want to use this in both 2.7+ and 3.0+, change that  to , but that will break compatibility with earlier 2.x.If you need CPython 2.5 or earlier, you can just replace the  calls with the implementation-specific CPython attributes:Note that this use of  will not work on classic classes; if you really want to handle those (which you really shouldn't want to…), you'll have to write your own  function that just walks the hierarchy old-school… or just copy it from the 2.6  source.This will only work in Python 2.x implementations that bend over backward to be CPython-compatible… but that includes at least PyPy.  should be more portable, but then if an implementation is going to define  and  objects with the same attributes as CPython's so it can support all of , there's not much good reason not to make them attributes and provide  in the first place…
First, this is almost certainly a bad idea, and not the way you want to solve whatever you're trying to solve but refuse to tell us about…That being said, there is a very easy way to do it, at least in Python 3.0+. (If you need 2.x, see my other answer.)Notice that Python 3.x's  pretty much has to be able to do this somehow. How else could  mean , where that  is exactly what you're asking for?*Now, there are lots of ways that  could be implemented… but PEP 3135 spells out a specification for how to implement it:Every function will have a cell named  that contains the class object that the function is defined in.This isn't part of the Python reference docs, so some other Python 3.x implementation could do it a different way… but at least as of 3.2+, they still have to have  on functions, because Creating the class object explicitly says:This class object is the one that will be referenced by the zero-argument form of .  is an implicit closure reference created by the compiler if any methods in a class body refer to either  or . This allows the zero argument form of  to correctly identify the class being defined based on lexical scoping, while the class or instance that was used to make the current call is identified based on the first argument passed to the method.(And, needless to say, this is exactly how at least CPython 3.0-3.5 and PyPy3 2.0-2.1 implement  anyway.)Of course this gets the actual class object, not the name of the class, which is apparently what you were after. But that's easy; you just need to decide whether you mean  or  (in this simple case they're identical) and print that.* In fact, this was one of the arguments against it: that the only plausible way to do this without changing the language syntax was to add a new closure cell to every function, or to require some horrible frame hacks which may not even be doable in other implementations of Python. You can't just use compiler magic, because there's no way the compiler can tell that some arbitrary expression will evaluate to the  function at runtime…
If you can use @abarnert's method, do it.Otherwise, you can use some hardcore introspection (for python2.7):Obviously, this is likely to raise an error if:called from a regular function / staticmethod / classmethodthe calling function has a different name for  (as aptly pointed out by @abarnert, this can be solved by using )
You can either do what @mgilson suggested or take another approach.This makes  the base class for .When you normally try to get the  then it will refer to derived class rather than the parent.  When you call , it's really passing  as self, which is why you are most likely getting  being printed.  Instead, try this:Edit:After reading your question a few more times I think I understand what you want.
[Edited]A somewhat more generic solution:This fails when some other class in the stack has attribute "do_it", since this is the signal name for stop walking the mro.
Sorry for writing yet another answer, but here's how to do what you actually want to do, rather than what you asked for:this is about adding instrumentation to a code base to be able to generate reports of method invocation counts, for the purpose of checking certain approximate runtime invariants (e.g. "the number of times that method ClassA.x() is executed is approximately equal to the number of times that method ClassB.y() is executed in the course of a run of a complicated program).The way to do that is to make your instrumentation function inject the information statically. After all, it has to know the class and method it's injecting code into.I will have to instrument many classes by hand, and to prevent mistakes I want to avoid typing the class names everywhere. In essence, it's the same reason why typing super() is preferable to typing super(ClassX, self).If your instrumentation function is "do it manually", the very first thing you want to turn it into an actual function instead of doing it manually. Since you obviously only need static injection, using a decorator, either on the class (if you want to instrument every method) or on each method (if you don't) would make this nice and readable. (Or, if you want to instrument every method of every class, you might want to define a metaclass and have your root classes use it, instead of decorating every class.)For example, here's an easy way to instrument every method of a class:The output:Exactly what you wanted, right?


Answer URL
https://docs.python.org/3/library/functions.html#super
https://docs.python.org/3/reference/datamodel.html#creating-the-class-object
