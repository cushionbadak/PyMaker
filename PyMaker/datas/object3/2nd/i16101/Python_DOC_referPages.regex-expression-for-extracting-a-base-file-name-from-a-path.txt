Natural Text
I would like to get the alphabetic parts of a file from some file paths.Currently I do this:strip end slashesos.path.split()[1] to get filenametwo  to remove a possible 2 file extensionslose the numberslose the underscoresCode:Result:Is there a faster or more pythonic way, using a compiled regex function? Or is trying to use the library  very reasonable? I also do not have to do this more than 100 times, so it's not a speed problem, this is just for clarity.
You can simplify this by using the appropriate functions from .First, f you call  you no longer have to worry about both kinds of path separators, just  (note that this is a bad thing if you're trying to, e.g., process Windows paths on Linux… but if you're trying to process native paths on any given platform, it's exactly what you want). And it also removes any trailing slashes.Next, if you call  instead of , you no longer have to throw in those trailing s.Unfortunately, there's no equivalent of  vs.  for … but you can write one easily, which will make your code more readable in the exact same way as using .As for the rest of it… regexp is the obvious way to strip out any digits (although you really don't need the  there). And, since you've already got a regexp, it might be simpler to toss the  in there instead of doing it separately.So:Of course the whole thing is probably more readable if you wrap if up as a function:Especially since you can now turn your loop into a list comprehension or generator expression or  call:I'm simply curious about the speed, as I'm under the impression compiled regex functions are very fast.Well, yes, in general. However, uncompiled string patterns are also very fast.When you use a string pattern instead of a compiled regexp object, what happens is this:The  module looks up the pattern in a cache of compiled regular expressions.If not found, the string is compiled and the result added to the cache.So, assuming you don't use many dozens of regular expressions in your app, either way, your pattern gets compiled exactly once, and run as a compiled expression repeatedly. The only additional cost to using the uncompiled expressions is looking it up in that cache dictionary, which is incredibly cheap—especially when it's a string literal, so it's guaranteed to be the exact same string object every time, so its hash will be cached as well, so after the first time the dict lookup turns into just a  and an array lookup.For most apps, you can just assume the  cache is good enough, so the main reason for deciding whether to pre-compile regular expressions or not is readability. For example, when you've got, e.g., a function that runs a slew of complicated regular expressions whose purpose is hard to understand, it can definitely help to give each one of them a name, so you can write , in which case it would be almost silly not to compile them.
Without using regular expressions:Do whatever approach is more readable. I usually avoid regular expressions if the problem doesn't require it. In this case, regular string operations can do everything you want to do.If you want to remove extra spaces (as indicated in your Result), use . If you are likely to have other kinds of whitespace, it can be removed by Note: If you are using Python 3, replace  with , and  with . This change was made as part of improving unicode language support. See more: How come string.maketrans does not work in Python 3.1?Here's the Python 3 code:


Answer URL
https://docs.python.org/3/library/os.path.html#os.path.normpath
https://docs.python.org/3/library/os.path.html#os.path.basename
https://docs.python.org/3/library/os.path.html#os.path.split
https://docs.python.org/3/library/os.path.html#os.path.basename
