Natural Text
I would like to have a function pointer  that can point to either: a function, the method of an object instance, or the constructor of the object. In the latter case, the execution of  should instantiate the class.This produces as output:showing that the first two ptr() calls worked, but the last did not.
The reason this doesn't work is that the  method isn't a constructor, it's an initializer.*Notice that its first argument is —that  has to be already constructed before its  method gets called, otherwise, where would it come from.In other words, it's a normal instance method, just like  is, but you're trying to call it as an unbound method—exactly as if you'd tried to call  instead of .Python does have a special method for constructors,  (although Python calls this a "creator" to avoid confusion with languages with single-stage construction). This is a static method that takes the class to construct as its first argument and the constructor arguments as its other arguments. The default implementation that you've inherited from  just creates an instance of that class and passes the arguments along to its initializer.** So:Or, if you prefer:However, it's incredibly rare that you'll ever want to call  directly, except from a subclass's . Classes themselves are callable, and act as their own constructors—effectively that means that they call the  method with the appropriate arguments, but there are some subtleties (and, in every case where they differ,  is probably what you want, not ).So:As user2357112 points out in a comment:In general, if you want a  that does  when you call , you should set That's a great, simple rule of thumb, and Python has been carefully designed to make that rule of thumb work whenever possible.Finally, as a side note, you can assign  to anything callable, not just the cases you described:a function,a bound method (your ),a constructor (that is, a class),an unbound method (e.g., —which you can call just fine, but you'll have to pass  as the first argument),a bound classmethod (e.g., both  and , if you defined  as a ),an unbound classmethod (harder to construct, and less useful),a staticmethod (e.g., both  and , if you defined  as a ),various kinds of implementation-specific "builtin" types that simulate functions, methods, and classes.an instance of any type with a  method,And in fact, all of these are just special cases of the last one—the  type has a  method, as do  and , and so on.* If you're familiar with other languages like Smalltalk or Objective-C, you may be thrown off by the fact that Python doesn't look like it has two-stage construction. In ObjC terms, you rarely implement , but you call it all the time: . In Python, you can pretend that  means the same thing (although really it's more like , where  automatically calls  for you).** Actually, this isn't quite true; the default implementation just returns an instance of , and Python automatically calls the  method if .
I had a hard time finding the answer to this problem online, but I figured it out, so here is the solution.Instead of pointing  at , you can just point it at , like this.which produces as output:


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__init__
https://docs.python.org/3/reference/datamodel.html#object.__new__
