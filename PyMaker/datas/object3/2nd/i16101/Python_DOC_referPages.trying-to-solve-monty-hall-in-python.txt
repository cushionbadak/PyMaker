Natural Text
I'm trying to understand this solution of the Monty Hall problem, I understand most of the code, but am stuck on two pieces. Below is the code, but specifically I'm stuck on these two partsand the entire  function.If anyone could explain in plain English for me that would be awesome.
… specifically I'm stuck on these two partsLet's break this down into pieces. It may help to reduce that  to something small, like , so you can print out the values (either with  calls, or in the debugger) and see what's going on.When we start this function,  is going to have 5 random values from  to , like , and  will have 5 values, all 0, like .  will therefore start off with 5 random values from 0 to 2, like .Each first time through the loop,  will be a list of 5  values, which are each  if the corresponding value in  matches the corresponding value in either  or . So, in this example, , because guess #1 matches , and guesses #0 and #3 match .Unfortunately, we're just going to go around that loop forever, because there's nothing inside the loop that modifies , and therefore  is going to be the same forever, and doing the same check forever is always going to return the same values.But if you indent that  line so it's inside the loop, that changes everything. So, let's assume that's what you were supposed to do, and you just copied it wrong.When treated as numbers,  and  have values  and , respectively. So,  is a count of how many matches there were in —in this case, .So,  picks 3 random values from  to , let's say .Now,  selects all of the elements of  for which the corresponding value in  is True, so in this example it's , , and .So we end up assigning that  to those three selected locations, so  is now .So, next time through the loop,  is now . We've still got at least one  value, so we run that  line again. This time,  is , so we pick 1 random value, let's say , and we then assign that 1 value to , so  is now .The next time through,  is now , so  is , so we're done.In other words, each time through, we take all the values that don't match either the prize door or the goat door, and pick a new door for them, until finally there are no such values.
It also confused me, until 5 mins ago when I finally figured it out.Since the first question has been solved, I will only talk about the second one.The intuition goes like this : given a sequence of (guesses, goatdoors),in the (i,j) loop, there are always some simulation (e.g., simulation[0] and simulation[5]) that 'hit' by the (i,j), that is the say, the 0th and 5th simulation have guess i and goatdoor j. Variable  record 0 and 5 in this example. Then result in 0th and 5th can be decided, because in these simulation, the only possible door to switch to is determined by i and j. So  refreshes result in these simulation, leave other simulations unchanged.Intuition is above. You need to know how  work if you want to know what I'm talking about. Good luck.


Answer URL
