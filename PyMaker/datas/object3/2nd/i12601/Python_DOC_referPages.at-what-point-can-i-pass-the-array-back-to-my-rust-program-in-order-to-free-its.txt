Natural Text
I'm having difficulty figuring out at what point I can pass the  returned by my Rust program back to it, in order to free the memory that it's allocated.My ctypes setup is as follows:This is all working correctly, but I'm not sure at what point I'm supposed to return the data initially allocated by my call to  back across the FFI boundary in order to free its associated memory, by calling .Here's my Rust struct and function.
There are two ways to manage resources in Python, both of which involve creating an object that either:has a finalizer, the  methodor acts as a context manager for the  statementBoth of these involve having a manager object that controls/provides access to the resource, which will run any clean-up code necessary when the object is no longer needed. For this case, I think the first one works best, but I'll demonstrate both.For my examples, I'll use this Rust code,, where  is a stand-in for any resource that needs managing (e.g. your  type):Which can be compiled with, say,  to create  (or similar, depending on platform). This is the start of the Python code I'm using for the two cases (the  call may need to be adjusted):(Note that by interfacing via pointers, I don't have to tell Python any info about the internals of .)You can check everything's working by adding the following, for instance, to the end:which prints something like(The  is to ensure the s from the two languages appear in the right order, since they have different buffers.) To use  just make an Python object (not a ) that serves as the interface to the Rust one, likeThis can then be used as a normal object:This will print:That is, Python can tell when object definitely no longer have any references (e.g. when the two handles  and  are both overwritten for , or when the program ends, for ).Context managersIf the resource is heavily scoped (which it probably isn't, in this case), it may make sense to instead use a context manager, which will allow something like:This is somewhat error-prone because a handle to an object can be kept outside the  statement, so it has to check for this or else it may access deallocated memory. For instance,Anyway, implementation:The first example above gives output like:And the second gives:This approach does have the advantage of makes the region of code where the resource is valid/allocated clearer, effectively a manual form of the RAII/scope-based resource management of Rust.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__del__
https://docs.python.org/3/library/stdtypes.html#typecontextmanager
