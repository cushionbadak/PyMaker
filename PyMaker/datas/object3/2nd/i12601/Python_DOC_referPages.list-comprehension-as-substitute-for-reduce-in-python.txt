Natural Text
The following python tutorial says that:List comprehension is a complete substitute for the lambda function as well as the functions ,  and .http://python-course.eu/python3_list_comprehension.phpHowever, it does not mention an example how a list comprehension can substitute a  and I can't think of an example how it should be possible.Can please someone explain how to achieve a reduce-like functionality with list comprehension or confirm that it isn't possible?
Ideally, list comprehension is to create a new list. Quoting official documentation,List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition.whereas  is used to reduce an iterable to a single value. Quoting ,Apply function of two arguments cumulatively to the items of sequence, from left to right, so as to reduce the sequence to a single value.So, list comprehension cannot be used as a drop-in replacement for .
I was surprised at first to find that Guido van Rossum, creator of Python, was against . His reasoning was that beyond summing, multiplying, and-ing, and or-ing, using  yields an unreadable solution that is better suited by a function which iterates through and updates an accumulator. His article on the matter is here. So no, there isn't a list comprehension alternative to , instead the "pythonic" way is to implement an accumulating function the old fashioned way: Instead of: Use:Of course nothing stops you from continuing to use  (python 2) or  (python 3)
List comprehensions are supposed to return lists. If your reduce is supposed to return a list, then yes, you can replace it with a list comprehension.But this is no obstacle to providing "reduce-like functionality". Python lists can contain any object. If you'll accept your result contained in a single-item list, then there is a  list comprehension form that can replace any  whatsoever.This should be obvious, but that form isfor some binary  and and some iterable  and some  value. Or, if you want the  from the first of the iterable,Arguably, the above is cheating, and also pointless, since you could just use  without the comprehension. So let's try it without .This produces a list of all the intermediate values, and we want the last one.  is just as easy as . We need an accumulator to reduce, but can't use assignment statements in a comprehension, hence the  (which is just a list), but we could have used many other data structures here. The  always returns , so we use  to put the value so far in the resulting list.It's a little more difficult without ,Really, you might as well use a  statement at this point.But this takes up memory for the list of intermediate values. For a very long sequence, that might be a problem. But we can avoid that too by using generator expressions.Doing this is tricky, so let's start with an easier example and work up to it.It computes the answer, but also creates a useless list of s. We can avoid that by converting it to a generator expression inside a list comprehension.The list comprehension exhausts the generator that updates the stack, but returns an empty list itself. This is possible because the inner loop always has zero iterations, because  is always an empty tuple.We can move the  inside if the last  has one element. It doesn't matter what that element is though. So we chain on a  as the final .Again, we have a single-item list comprehension. We can also implement  as a generator expression. And you've already seen how to move the  variable inside using a single-item list.And we can also get the initial from the sequence for the two-argument .This is insane. But it works. So yes, it's possible to get "reduce-like functionality" with comprehensions. That doesn't mean you should. Seven s is too hard!
You could accomplish something like a reduce with a comprehension by using a couple of helper functions that I've named  and :This is functionally equivalent toNote that unlike  the comprehension didn't use a .The trick is to use a generator with a callback to "return" the result of the operator.  is the corecursive dual of the reduce (or fold) function.Here's  in a list comprehension.The elements represent each step in the dual reduction. The last one is our answer. The  function is trivial.Unlike ,  is a lazy generator, so it can safely act on infinite iterables when used in a generator expression.


Answer URL
https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions
https://docs.python.org/3/library/functools.html#functools.reduce
