Natural Text
A simple recursive factorial method works perfectly:But I wanted to experiment a little and use a  instead. Logically, this should work, but a bunch of print statements tell me that , instead of stopping at , glides down across the negative numbers until the maximum recursion depth is reached:Why is that?
Python doesn't lazily evaluate parameters.The default value passed to  call will also be evaluated before calling the .So, in your case, the default value has a recursive call and since your condition is never met, it does infinite recursion.You can confirm this, with this programEven though the key  exists in the dictionary, since all parameters passed to functions in Python will be evaluated,  is also invoked, before the actual  is made.If all you want to do is to avoid multiple recursive evaluations when the values are already evaluated, then you use , if you are using Python 3.2+This decorator simply caches the results for the parameters passed and if the same call is made again, it will simply return the value from the cache.If you want to fix your custom caching function to work, then you need to define the  outside the function, so that it will not be created whenever the function is called.Otherwise you can use the default parameter, like this


Answer URL
https://docs.python.org/3/library/functools.html#functools.lru_cache
