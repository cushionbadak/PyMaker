Natural Text
I noticed the following odd behaviour when timing  with the default  parameter specified:So, approximately a 2x slowdown for the case where  is specified.The byte code issued for each case doesn't really indicate anything that would contribute to the significant difference in speed. Case in point, after examining the different calls with  the additional commands issued are:These, along with the  having 1 keyword, are the only differences. I tried tracing through the calls made in s  with  and both seem to use  in  and not some other optimization I could detect.Now, I understand  just creates an enumerate iterator, so we're dealing with object creation here (right?). I looked in  trying to spot any differences if  was specified. The only thing that (I believe) differs is when  in which the following happens:  Which doesn't look like something which would introduce a 2x slowdown. (I think, not sure.)The previous code segments have been executed on Python , similar results are present in  too, though.This is where I'm stuck and can't figure out where to look. This might just be a case of overhead from additional calls in the second case accumulating, but again, I'm not really sure. Does anybody know what might be the reason behind this? 
One reason might be because of calling the  while you specify a start in following part :And If you take a look at  function in  module you'll see the following comment at the top level of function:So this function has to check if the object cannot be interpreted as an index and will returns the relative errors. And if you look at the source carefully you'll see the all of this checking and referencing, specially in following part which has to do a nested structure dereference in order to checking the index type:Would takes much time to check and return a desire result.But as @ user2357112 mentioned, another and most important reason is because of the python keyword argument matching.If you time-it the function without keyword argument you'll see the difference time will decrease approximately ~2X time: The difference with positional argument is:Which seems that is because of .
It probably is just is a combination of factors contributing to the overall slowdown. Keyword args:When Python sees the  argument it will call  as you already pointed out. After going through some  clauses the call issued is . Notice  here which holds the total count of keyword arguments (so in the case of ). In  you'll see the following  clause:If the number of keyword args is not zero (), call .Now,  does what you would expect,  is  (which it is, look at the call to ) create a new dictionary:and then populate the dictionary with all values present in the value stack:These probably contribute significant to the overall delay.Creating the  object:You're right about , if called with  the variable  inside  will have a value and therefore be . As a result the  clause will evaluate to  and the code inside it will execute, adding time to the call.What is performed inside the  clause is not really heavy work, but it does contribute to the overall time required.Additionally: you also have the two additional byte code commands to consider, they might just be two but they add to the overall time taken due to the fact that we're timing really quick things (in the range of ). Again, insignificant from an overall standpoint, but, parsing a call with  requires as before, a wee bit more time.Finally:I might be missing some stuff but overall these are some of the factors that, in conjunction, create overhead when creating a new enumerate object with  specified. 


Answer URL
https://docs.python.org/3/library/functions.html#enumerate
https://docs.python.org/3/library/dis.html#dis.dis
