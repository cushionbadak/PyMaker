Natural Text
So, I am interested in timing some of the code I am setting up. Borrowing a timer function from the 4th edition of Learning Python, I tried:Then, I paste in whatever I want to time, and put:When I run it on my code, I do get an answer, but it's nonsense. Suspecting something was wrong, I put a  call in my code, and got a result of Does anybody know why this might be the case or how to fix it? I suspect that the  call might be at fault.
According to the help docs for :Return the CPU time or real time since the start of the process or since the first call to clock().  This has as much precision as the system records.The second call to  already returns the elapsed time between it and the first  call. You don't need to manually subtract .Changeto
If you want to timer a function perhaps give decorators a try(documentation here):Then when you write a function you just use the decorator, here:This will print out the time the function took to execute:func:'my_example_function' args:[(), {}] took: 0.4220 sec
After fixing the typo in the first intended use of , your code works fine with either  or  (or Py3's  for that matter) on my Linux system.The difference would be in the (OS specific) behavior for ; on most UNIX-like OSes it will return the processor time used by the program since it launched (so time spent blocked, on I/O, locks, page faults, etc. wouldn't count), while on Windows it's a wall clock timer (so time spent blocked would count) that counts seconds since first call.The UNIX-like version of  is also fairly unreliable if used in a long running program when  is only 32 bits; the value it returns will wrap roughly every 72 minutes of processor time.Of course,  isn't perfect either; it follows the system clock, so an NTP time update (or any other change to the system clock) occurring between calls will give erroneous results (on Python 3.3+, you'd use  to avoid this problem). It's also not guaranteed to have granularity finer than 1 second, so if your function doesn't take an awfully long time to run, on a system with low res  you won't get particularly useful results.Really, you should be looking at the Python batteries designed for this (that also handle issues like garbage collection overhead and the like). The  module already has a function that does what you want, but handles all the edge cases and issues I mentioned. For example, to time some global function named  for 100 reps, you'd just do:It fixes most of the issues I mention by selecting the best timing function for the OS you're on (and also fixes other sources of jitter, e.g. cyclic garbage collection, which is disabled during the test and reenabled at the end).Even if you don't want to use that for some reason, if you're using Python 3.3 or higher, take a look at the replacements for , e.g.  (includes time spent sleeping) or  (includes only CPU time), both of which are portable, reliable, fast, and high resolution for better accuracy.
The  will terminate for any signal. read about it here ...http://www.tutorialspoint.com/python/time_sleep.htm


Answer URL
https://docs.python.org/3/library/timeit.html
https://docs.python.org/3/library/time.html#time.perf_counter
https://docs.python.org/3/library/time.html#time.process_time
