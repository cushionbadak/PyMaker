Natural Text
It is about financial data. I have a list of the 70% percentiles of return data at 72 dates:Furthermore I have a list of lists which contains the 72 returns at the different dates for 500 companies (= 500 lists and 72 entries per list):What I want to do now is compare the first entry of my list () to all the entries in my first list in the list of lists. If the entry in the first list exceeds the  threshold (so in this case the  above) I want to add this number to a new list. Then I want to do the same with the second entry in  () and the second list in . In the end I basically want to obtain 72 lists (or a new list of lists) which contain the returns that are above the respective 70% percentile.
You could do this with list comprehension I think:I made some real lists out of the given ones (omitting the ) such that this is an example that compiles.The list comprehension works as follows: we iterate over the  from  (and also obtain the corresponding index , which is used to obtain the threshold). Next we perform a  operation on the  and only allow elements that are larger than the  (the threshold for that timestamp).Running this with  gives:which seems to be what you want.EDIT In python-3.x, this should work as well, although the filter is "delayed":If you want to materialize the lists straight away, you can slightly alter the list comprehension to:Which results in:
If I understand your question correctly, you have 500 lists of 72 values and 72 threshold values. You want to compare the nth value of each list with the nth value of your list of thresholds. In other words, you want to proceed column-wise. It's easiest to first transpose  using this one cool trick, so that each column in  becomes a row:Now we can work with rows. Pair each number in your list of thresholds with its corresponding row in .Each item in  is a pair containing a cutoff point and the values to which we want to compare it. The ducks are lined up in a row; we just have to find the values in the second part of the pair which exceed the corresponding cutoff point.Or, squishing the nested  loops up into a nested list comprehension:These two versions are exactly equivalent - they compile into the same byte code, for all intents and purposes - but I like the list comprehension better because it's shorter and it has a more functional feel.
I think this is what you want:
You could use a list comprehension:[[6, 3, 7], [6, 8], [3, 7, 6]]This will remove all entries in your lists in  that are less or equal to the corresponding element of .


Answer URL
https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions
