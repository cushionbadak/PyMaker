Natural Text
I'm writing something in Python 3 to get proxies from sites and check if the proxies are valid.I used queue and threading module to make the check procedure faster.However, the consequence was weird.This is an example from queue document. My code is based on this example.So, my question is: When will the while loop in worker() end?When the number of item in queue more than 200, the q keeps block code and 1 item in the queue can't get processed and 1 thread keeps doing q.get(), while other threads say that q was empty.Please help me out. Thanks.And sorry about my poor English. I'm still working on it.----Update ---------------------------------------------------------------------I tried ThreadPoolExecutor, and it worked, like threading and queue. But the blocking situation didn't change.After a 20 min game, one trial running of the code ended and printed the expected output.I found that the check procedure ends in 2 or 3 minutes (for 100 proxies), and the code just kept blocking for about 10 minutes before it ended.And the second question: What may cause this? Thank you! :)----Update----------------------------------------------------------------------Problem solved!!I thought it was the thread thing that cause the block, but it turns out that the connection and transfer time is the causation.Since I use pycurl for proxy check, and pycurl's default TIMEOUT is 300.I only set CONNECTTIMEOUT to 5 and ignored TIMEOUT which limits the whole transfer time.And this is the new code I use for proxy check:However, setting TIMEOUT to 5 reduced the number of valid proxies significantly. I will keep trying for the best TIMEOUT value.
A  loop without like that will never end, and your threads will never quit. You have to tell explicitly your threads when to exit.A way of doing this is by using a sentinel, like this:What I've done here is adding a few  elements to your queue, one for each thread. When a thread sees this  object, it means it has to quit and can break out of the loop.If you prefer a different approach, you can consider using an  object to notify the threads when they have to quit, like this:The drawback of this solution is that you have to  with a timeout.Last but not least, your code seems could benefit from using a thread pool, like this:(For the reference,  uses the  approach, the only two differences are that  is  and each thread is responsible for notifying the other ones.)
just another example of using thread, queue and loop from a class


Answer URL
https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor-example
