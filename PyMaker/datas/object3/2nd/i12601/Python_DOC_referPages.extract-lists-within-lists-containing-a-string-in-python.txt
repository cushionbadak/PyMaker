Natural Text
I'm trying to divide a nested list into two nested lists using list comprehensions. I am unable to do so without converting the inner lists to strings, which in turn ruins my ability to access/print/control the values later on.  I tried this::What happens is that the whole of paragraphs3 = [] ends up in therest = [], unless i do something like this:If I then feed paragraphs4 to the list comprehension, I get two lists, just like I want. But they are not nested lists anymore since this: Writes each !character! in therest = [] in a separate line:Thus I'm looking for a better way to split paragraphs3 ... Or maybe the solution lies elsewhere? The end result/output I'm looking for is: 
This code separates the sublists based on whether they contain a string that starts with . outputThe most important part of this code isThis iterates over the individual strings in  (the current paragraph), and returns  as soon as it finds a string that starts with .  FWIW, that  loop can be condensed down to:because  and  evaluate to 0 and 1 respectively, so they can be used to index the  tuple. However, many people would consider that verging on unreadable. :) 
The code you've written is almost correct. You need to check if  is present in the 3rd element of the list.  basically contains the first element of So all you have to do is change the condition to .
SolutionDetailed explanationCopying the entire list:Copying list with condition:Function  is not implemented yet, so let's implement it.Retrieve only items which match the :Since  can be expressed as a lambda function:Converting result to boolean (will be True if at least one item is found matching the condition):And replacing  with resulting inline code:
It seems like your inner list has structure; the list itself is one value, not just a list of unrelated values. With that in mind, you could write a class to represent that data.You can then use the partition recipe from itertools to split that one list into two iterators.
This seems to me like the most straight-forward way of doing it: However, if you'd like, you can get a lot fancier, and pull this off in a single line (though it will be more complicated than necessary). This produces a  with  and  as keys. Now you can do this: 


Answer URL
https://docs.python.org/3/library/itertools.html
