Natural Text
Is it possible to make the result from  be assigned as a variable? What I have so far is , however i'm not sure if this actually does anything. My code below is attempting to take an integer 'r' and represent 'r' in the form (2^k)*t+1. This part of the code below is dealing with finding this product of powers of two and some other odd integer (2^k)*t.It could be that I am going about this the wrong way, but from my research and trial and error, I have finally got this to work so far. But now more issues arise when extracting certain values.For example an input of 29 yields the following:So in this instance, t=7, k=2, so we would have 29=(2^2)*7+1.What I want to do is now take the third lines values, namely the '2', and use this for further calculations. But the commented out line # k = eval(2**h) throws the error as follows:So from what I can understand, the thing I am trying to evaluate is not in the correct form. I also wonder if the problem arises due to the nature of the while loop that keeps feeding values back in and creating multiples lists, as shown, and hence multiple values of h .How would one print only the results of the 'final' iteration in the while loop? i.e. 
Here this should fulfil your requirement,I don't think you really need to evaluate .Also this addresses the second part of your question too, to print the final result of the loop.And it is as Gregory pointed out that convert explicitly to int only when needed and eval is for strings, your expression was already in integer terms.
First of all, you don't need to explicitly convert a value to an  just to use it in an expression in general. You do need it when processing the input since  returns a string.It is more idiomatic to use integer division  instead of  in python 3.Finally,  is for evaluating strings, not expressions. Expressions are always evaluated.
As others have said you don't need  here. In fact, you should generally avoid using  since it can be dangerous. And in most situations where you do need to evaluate an expression in string form you can generally get by with the much safer ast.literal_eval. However, at this stage of your learning it's unlikely that you will encounter many situations where you need to work with such advanced features of the language.Anyway, here are a few more improvements to your code.You don't need to import the  module since you aren't using any of the functions or constants defined in it. But when you do need to import a module it's best to avoid the  form since that pollutes your namespace with all of the names defined in the module.You don't need to store those 2s in a list - just count them.It's better to do your input (and input validation) in the outer layers of your program rather than doing it deep in the functions that perform your calculations.Python provides various augmented assignment operators that you can use when you want to perform a simple operation on a value and store the result back under the original name. Eg  adds  to , saving the result in .Python allows you to return multiple objects as a tuple, so you can return the final value of  and the count of the number of factors of 2 that you've found.The  prevents infinite looping if  is zero. I've also added a (commented-out) test at the end. It's a good idea to do simple tests like that to make sure we're getting what we expect. Writing useful tests is an important part of program development.Typical output:


Answer URL
https://docs.python.org/3/library/ast.html#ast.literal_eval
