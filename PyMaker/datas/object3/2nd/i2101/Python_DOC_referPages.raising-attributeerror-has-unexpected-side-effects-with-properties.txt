Natural Text
Given a contrived Python class:Calling  produces the expected output:However, I really want , , and  to be properties. So, if I change my code to:and call , I get an unexpected result:Uh-oh... the  output appears to be the reverse of the execution order, and the message for  is for , which does exist.During my experimentation to figure this out, I discovered that changing  to a plain old  makes everything work ok:So, it seems  itself doesn't play well with , possibly because it's being caught somewhere by the  object. But  appears to be the most appropriate exception for  to raise, and it's not ideal to raise an  without subclassing.Is anyone able to shed some light on this problem, and know of a way to have  and  with  work together in harmony?I've tried this in Python 2.7 and 3.6.EDIT: Added (contrived) logic for  to respond to if  starts with . I do want it to fail for , but I want it to raise  at the correct time with the correct .
The missing piece to the puzzle is that  is a descriptor (an object which implements  /  /  to participate in attribute lookup).Implementation of descriptors is done via the  magic method.The important bit of the implementation here from the docs (emphasis mine):Called unconditionally to implement attribute accesses for instances of the class. If the class also defines , the latter will not be called unless  either calls it explicitly or raises an AttributeError.To illustrate with your example a little further:The call sequence goes:The calls to  are in response to s during descriptor resolution in .Here's the output of the above python snippet:


Answer URL
https://docs.python.org/3/howto/descriptor.html
https://docs.python.org/3/reference/datamodel.html#object.__getattribute__
