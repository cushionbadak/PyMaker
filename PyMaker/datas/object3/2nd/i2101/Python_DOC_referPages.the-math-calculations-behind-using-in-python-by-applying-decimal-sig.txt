Natural Text
I was trying to understand the math behind calculations using / and // and % operators by doing some trials and found the results are similar to calculator only when using Decimal() but without it the results kinda confusing, i tried to add comments to my code to mark the points i don't understand,for example:in this trial for % operator by applying signed and unsigned number the results and with and without Decimal() the results are :in this trial for // operator and using signed and unsigned number with and without Decimal() the results are :Please consider that this question is not a duplicate and i have done some research to get an answer but i found some answered questions that explain only about // operator using only positive signed numbers and doesn't include information about negative signed numbers or using the Decimal() and doesn't have answer about % operator.so,It will be helpful if someone knows why the results are different and how they are calculated.
As I understand the question, the OP is asking about the different behavior between Python integers and s. I don't think there is any good reason for it. Both choices are possible, but it is a bit confusing for the user that they differ.Let's call the numerator , the denominator  and split the result in the interger result  and the remainder . This means thatFor the operations to make sense, we needFor  and  we see that this is uphold for both  and for  as can be seen byNow, in Python integer division is defined as always truncate towards minus infinity (down) and the  implementation has chosen to round towards zero. That means that positive values are truncated/rounded down, whereas negative values are rounded up.Rounding towards zero is the choice made also made in the C language. However, my personal opinion is that the Python choice is much more sane, specifically coming from a hardware background. And given that this is the choice made in Python, I think it is strange (and bad) that  has chosen to do as in the C language.
Explanation for the  behaviour of integersFrom python documentation:Division of integers yields a float, while floor division of integers  results in an integer; the result is that of mathematical division  with the ‘floor’ function applied to the result.Therefore, an integer division () of negative negative and positive number works as follows:The modulo operator is the remainder of the integer division, i.e. . In your example:The documentation also says:The modulo operator always yields a result with the same sign as its  second operand (or zero); the absolute value of the result is strictly  smaller than the absolute value of the second operand.But that comes naturally from the formula above, e.g.: is differentThe documentation explains the difference well:There are some small differences between arithmetic on Decimal objects  and arithmetic on integers and floats. When the remainder operator   is applied to Decimal objects, the sign of the result is the sign of  the dividend rather than the sign of the divisor:The integer division operator  behaves analogously, returning the  integer part of the true quotient (truncating towards zero) rather  than its floor, so as to preserve the usual identity :


Answer URL
https://docs.python.org/3/reference/expressions.html#binary-arithmetic-operations
https://docs.python.org/3/reference/expressions.html#binary-arithmetic-operations
