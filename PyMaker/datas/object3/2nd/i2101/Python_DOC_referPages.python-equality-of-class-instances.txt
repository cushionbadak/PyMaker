Natural Text
When writing custom classes it is often important to allow equivalence by means of the  and  operators. In Python, this is made possible by implementing the  and  special methods, respectively. The easiest way I've found to do this is the following method:Do you know of more elegant means of doing this? Do you know of any particular disadvantages to using the above method of comparing s?Note: A bit of clarification--when  and  are undefined, you'll find this behavior:That is,  evaluates to  because it really runs , a test of identity (i.e., "Is  the same object as ?").When  and  are defined, you'll find this behavior (which is the one we're after):
Consider this simple problem:So, Python by default uses the object identifiers for comparison operations:Overriding the  function seems to solve the problem:In Python 2, always remember to override the  function as well, as the documentation states:There are no implied relationships among the comparison operators. The  truth of  does not imply that  is false. Accordingly, when  defining , one should also define  so that the  operators will behave as expected.In Python 3, this is no longer necessary, as the documentation states:By default,  delegates to  and inverts the result  unless it is . There are no other implied  relationships among the comparison operators, for example, the truth  of  does not imply .But that does not solve all our problems. Let’s add a subclass:Note: Python 2 has two kinds of classes:classic-style (or old-style) classes, that do not inherit from  and that are declared as ,  or  where  is a classic-style class;new-style classes, that do inherit from  and that are declared as  or  where  is a new-style class. Python 3 has only new-style classes that are declared as ,  or . For classic-style classes, a comparison operation always calls the method of the first operand, while for new-style classes, it always calls the method of the subclass operand, regardless of the order of the operands. So here, if  is a classic-style class: calls ; calls ; calls ; calls .And if  is a new-style class:both  and  call ;both  and  call .To fix the non-commutativity issue of the  and  operators for Python 2 classic-style classes, the  and  methods should return the  value when an operand type is not supported. The documentation defines the  value as:Numeric methods and rich comparison methods may return this value if  they do not implement the operation for the operands provided. (The  interpreter will then try the reflected operation, or some other  fallback, depending on the operator.) Its truth value is true.In this case the operator delegates the comparison operation to the reflected method of the other operand. The documentation defines reflected methods as:There are no swapped-argument versions of these methods (to be used  when the left argument does not support the operation but the right  argument does); rather,  and  are each other’s  reflection,  and  are each other’s reflection, and   and  are their own reflection.The result looks like this:Returning the  value instead of  is the right thing to do even for new-style classes if commutativity of the  and  operators is desired when the operands are of unrelated types (no inheritance).Are we there yet? Not quite. How many unique numbers do we have?Sets use the hashes of objects, and by default Python returns the hash of the identifier of the object. Let’s try to override it:The end result looks like this (I added some assertions at the end for validation):
You need to be careful with inheritance:Check types more strictly, like this:Besides that, your approach will work fine, that's what special methods are there for.
The way you describe is the way I've always done it. Since it's totally generic, you can always break that functionality out into a mixin class and inherit it in classes where you want that functionality.
Not a direct answer but seemed relevant enough to be tacked on as it saves a bit of verbose tedium on occasion. Cut straight from the docs...functools.total_ordering(cls)Given a class defining one or more rich comparison ordering methods, this class decorator supplies the rest. This simplifies the effort involved in specifying all of the possible rich comparison operations:The class must define one of lt(), le(), gt(), or ge(). In addition, the class should supply an eq() method.New in version 2.7
You don't have to override both  and  you can override only  but this will make an implication on the result of ==, !==, < , > and so on. tests for object identity. This means a  b will be  in the case when a and b both hold the reference to the same object. In python you always hold a reference to an object in a variable not the actual object, so essentially for a is b to be true the objects in them should be located in the same memory location. How and most importantly why would you go about overriding this behaviour?Edit: I didn't know  was removed from python 3 so avoid it.
From this answer: https://stackoverflow.com/a/30676267/541136 I have demonstrated that, while it's correct to define  in terms  - instead of you should use:
I think that the two terms you're looking for are equality (==) and identity (is). For example:
The 'is' test will test for identity using the builtin 'id()' function which essentially returns the memory address of the object and therefore isn't overloadable.However in the case of testing the equality of a class you probably want to be a little bit more strict about your tests and only compare the data attributes in your class:This code will only compare non function data members of your class as well as skipping anything private which is generally what you want. In the case of Plain Old Python Objects I have a base class which implements __init__, __str__, __repr__ and __eq__ so my POPO objects don't carry the burden of all that extra (and in most cases identical) logic.
Instead of using subclassing/mixins, I like to use a generic class decoratorUsage:


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__ne__
