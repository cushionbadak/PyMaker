Natural Text
I have two versions of the same Python package. I need from a module in a subpackage in the current version to be able to call a function inside the old version of the package (which copied itself in the past)Where I am now:The old version:I need to import in  the "old"  and run it. Ideally the function  should live its life inside the old package without knowing anything about the new version of the packagethe module in the new package should call it, let it live its life, get the results and then forget altogether about the existence of the old package (so calling "import package.subpackage2" after letting  do her thing should run the "new" version)doing that should not be terribly complexThe underlying idea is to improve reproducibility by saving the code that I used for some task along with the output data, and then being able to run parts of it.Sadly, I understood this is not a simple task with Python 3, so I am prepared to accept some sort of compromise. I am prepared to accept, for example that after running the old  the name  in the "new" code will be bound to the old.EDITI tried in two ways using . The idea was to create an object  and then doing , but it doesn't workChanging  to  and then calling   . The problem is that it will load the one in "now" even with the changed , probably because the name  is already in  In that case relative imports () won't work, giving the error "attempted relative import with no known parent package"
There is one way this could work quite simply, but you will have to make a few modifications to your old package.You can simply create a file in  containing:In the new package, you can then do:The catch here is that the old package tries to import its own packages using absolute import, it is going to load stuff from the new packages instead. So the old package will have to only use relative imports when importing stuffs from its own package or you'll have to prepend package.old to all absolute imports that the old package was doing.If you are fine with modifying the old packages in this way, then that should be fine. If that limitation would not work for you, then read on.If you are really, really sure that for some reasons don't want to modify the old packages. Then let's do some black magic, you'd want to replace  with your own version that returns different modules depending on who is doing the importing. You can figure out who is doing the importing by inspecting the call stack.For example, this is how you might do it (tested on Python 3.6): gets called on any import statements encountered by the interpreter, and the call is not cached so you can return different things every time it is called even when they use the same name.The following is my old answer, here for historical purpose onlyI don't quite get what you're trying to do, but this is likely possible to do in Python 3 by using importlib. You would just create a module loader that loads your module from an explicit filepath.There's also an  and  function which may be useful, though you may not need them.


Answer URL
https://docs.python.org/3/library/importlib.html
