Natural Text
Python 3.4.0a1Windows 8.1Class Created:  Command entered in IDLE  with the following results:Expected output:I expected a.bankrupt to change to True when I changed b.bankrupt since the variable bankrupt is defined for the entire class and not for a single instance (with ) Why is this not happening?
You assigned to a new attribute to the instance instead. To change a class attribute, assign directly to the class.When looking up an attribute on an instance, look-up 'falls through' to the class, then to the base classes. This is how all class attributes, including methods, are found.But when assigning, this happens directly on the instance. Otherwise you could never assign per-instance values, you'd only ever assign back to the class. Assigning to  or  will add an attribute to the instance, if it wasn't already there to begin with. To Python, there is no difference between using  in a method, or to using  from the 'outside' to assign to an attribute.Just assign to the class attribute directly (from a method or from 'outside'):Note that the same fall-through on read, assignment on write rules apply to base classes; looking up an attribute on a class looks to the base classes if the attribute is not found on the class directly, but setting an attribute on a class do so directly, and not affect attributes on the bases.For the nitty gritty details, see the Custom classes and Class instances sections of the Python datamodel.
With  you create an instance variable that shadows the class-level variable.If you want to change the class variable use
After assignment to instance variable it is created if it was not before. And next time You try to access it You got it from instance . This is why You have different values for  and Meanwhile If You modify variable (not reassign it) You will got result which You have described.In this case instance variable was not created.


Answer URL
https://docs.python.org/3/reference/datamodel.html
