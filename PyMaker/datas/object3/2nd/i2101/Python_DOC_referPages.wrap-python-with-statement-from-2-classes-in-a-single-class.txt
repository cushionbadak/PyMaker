Natural Text
I have a python class A with  statement and class B with  statement. Now it works like:How can I build a class C that wrap class A and class B so that I can call it like:   has the identical funtions
I'd like to suggest an alternative. You can initialise both  and  on the same line:This is more concise and reduces the amount of indentation in deeply nested code. However, if you absolutely must use a class, then override the  and  methods:And then use  inside a context manager like this:If you don't want to reference  and , or if you don't plan on doing anything with them, thenWill also work. This should be enough to get started, but please note there are drawbacks as kindly mentioned by users in the comments. The main one being that if  throws errors,  will need to be cleaned up (this can be done using try-except-finally). Furthermore, some context managers may need to be treated differently based on what resource is being managed.
Short answer: it is possible. But context-managers allow to implement some logic, which makes it "tricky" to implemented it exactly the right way. Below you see a "Proof of Concept", but I do not guarantee that it has exactly the same behavior. Therefore I really advise to work with nested s.What is not covered here: the , or  can raise exceptions as well, and these are then handled by the "outer" context managers. This makes it of course rather complicated. You basically would need to "build" a stack in the , and then "pop" the stack in case one of the s fails. This scenario is not covered here.We can make a "composite" context manager:The  part is tricky. First of all, we need to exit in reverse order. But the exception handling is even more complicated: if an  silenced an exception, by returning a "truthful" value, then we should pass  as , but a problem that can occur is that an  on the other hand triggers an exception itself, and thus then introduces a new exception.We can then use the context processor like:The above thus allows to implement a context manager for an arbitrary number of "sub-contextmanagers". We can subclass this to generate a specific one, like:and then use this as:But long story short: use nested  statements. It also makes it more explicit what is going on here. Right now the  encapsulate all sorts of logic, which are better made explicit. If entering  fails, then this should result in an exception that is handled by the  of , etc. This makes it very cumbersome to get the "details" completely equivalent to the semantics of the  statement.
If your reason for doing this is to reduce indentation or merge the  statements, you don't need to. You can just doentering multiple context managers on a single line.If your  has other reasons to exist, you need to be careful about handling the case where one context manager fails after another context manager has been created and/or entered.  can help you implement this robustly, or  if you're still on Python 2:


Answer URL
https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack
