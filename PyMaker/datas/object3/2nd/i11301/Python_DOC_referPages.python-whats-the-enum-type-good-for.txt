Natural Text
This question already has an answer here:Python enum, when and where to use?                    2 answers                In Python 3.4, we got an Enum lib in the standard library: . We can get a backport for  that works with Python 2.4 to 2.7 (and even 3.1 to 3.3), enum34 in pypi.But we've managed to get along for quite some time without this new module - so why do we now have it?I have a general idea about the purpose of enums from other languages. In Python, it has been common to use a bare class as follows and refer to this as an enum:This can be used in an API to create a canonical representation of the value, e.g.:If this has any criticisms, it's mutable, you can't iterate over it (easily), and how are we to know the semantics of the integer, ?Then I suppose I could just use something like a namedtuple, which would be immutable?The creation of the namedtuple is a little redundant (we have to write each name twice), and so somewhat inelegant. Getting the "number" of the color is also a little inelegant (we have to write  twice). Value checking will have to be done with strings, which will be a little less efficient.So back to enums.What's the purpose of enums? What value do they create for the language? When should I use them and when should I avoid them?
What's the purpose of enums? What value do they create for the language? When should I use them and when should I avoid them?The Enum type got into Python via PEP 435. The reasoning given is:The properties of an enumeration are useful for defining an immutable, related set of constant values that may or may not have a semantic meaning.When using numbers and strings for this purpose, they could be characterized as "magic numbers" or "magic strings". Numbers rarely carry with them the semantics, and strings are easily confused (capitalization? spelling? snake or camel-case?)Days of the week and school letter grades are examples of this kind of collections of values. Here's an example from the docs:Like the bare class, this is much more readable and elegant than the namedtuple example, it is also immutable, and it has further benefits as we'll see below.Strictly dominant: The type of the enum member is the enumThis allows you to define functionality on the members in the Enum definition. Defining functionality on the values could be accomplished with the other prior methods, but it would be very inelegant.Improvement: String coercionThe string representation is human readable, while the repr has more information:I find this to be an improvement over the magic numbers and even possibly better than strings from the namedtuple.Iteration (parity):The enum supports iteration (like the namedtuple, but not so much the bare class) too:The  attribute is an  mapping the names of the enums to their respective enum objects (similar to namedtuple's  function).Supported by pickle (parity)You can serialize and deserialize the enum (in case anyone was worried about this):Improvement: AliasesThis is a nice feature that the bare class doesn't have, and it would be difficult to tell the alias was there in the .The alias comes after the canonical name, but they are both the same:If aliases should be prohibited to avoid value collisions, use the  decorator (a strictly dominant feature).Strictly dominant: comparisons done with The enum is intended to be tested with , which is a fast check for a single object's identity in the process.Tests for equality work as well, but tests for identity with  are optimal.Different semantics from other Python classesEnum classes have different semantics from regular Python types. The values of the Enum are instances of the Enum, and are singletons in memory for those values - there is no other purpose for instantiating them.This is important to keep in mind, perhaps it is a downside, but comparing on this dimension is comparing apples with oranges.Enums not assumed to be orderedWhile the Enum class knows what order the members are created in, enums are not assumed to be ordered. This is a feature because many things that may be enumerated have no natural order, and therefore order would be arbitrary. However, you can give your enums order (see the next section).SubclassingYou can't subclass an Enum with members declared, but you can subclass an Enum that doesn't declare members to share behavior (see the OrderedEnum recipe in the docs). This is a feature - it makes little sense to subclass an Enum with members, but again, the comparison is apples and oranges.When should I use ?This is the new canonical enumeration in Python. Collaborators will expect your enums to behave like these enums.Use it anywhere you have a canonical source of enumerated data in your code where you want explicitly specified to use the canonical name, instead of arbitrary data. For example, if in your code you want users to state that it's not , , 2, or , but  - use the enum.Enum object. It's both explicit and specific.There are a lot of examples and recipes in the documentation.When should I avoid them?Stop rolling your own or letting people guess about magic numbers and strings. Don't avoid them. Embrace them. However, if your enum members are required to be integers for historic reasons, there's the  from the same module, which has the same behavior, but is also an integer because it subclasses the builtin  before subclassing . From 's help:we can see that the IntEnum values would test as an instance of an .


Answer URL
https://docs.python.org/3/library/enum.html#creating-an-enum
https://docs.python.org/3/library/enum.html#orderedenum
https://docs.python.org/3/library/enum.html#interesting-examples
