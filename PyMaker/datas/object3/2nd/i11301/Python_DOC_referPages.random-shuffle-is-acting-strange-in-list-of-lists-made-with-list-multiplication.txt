Natural Text
My  function is trying to take a list of lists of lists called , and then add members of a global list variable () to it randomly. The code is:I ran this function a bunch of times, trying to get lots of copies with different results. However, each time it created the exact same results for the  variable within each individual. The results differed between runs of the program, but were the same within a single run.An example value of the  argument would be:The innermost "lists" are actually  classes, which have a  value defined, but in all other ways act like lists. The  attribute of each  is 3.The list of  would be:The first  created was:The second  created was:These continue with apparent randomness, but each  in the  is always identical to the other s within the same , regardless of how I change the parameters. 
This question really needs more detail to answer it with confidence, but since there's a common error that could produce this weird result (and since I wasn't able to reproduce it any other way)...I think the problem is not in your  function, but in the data structure you're feeding it.  Here's a bit of my  function that produced exactly the random output you expected:Output:To reproduce your problem, I had to create  using the list-multiplication syntax, which doesn't do what most beginners (and some tutorials) think it does:4.6.1. Common Sequence Operations[table omitted]Notes:[...]  Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; [...]Further explanation is available in the FAQ entry How do I create a multidimensional list?.I'm guessing somewhere in your code, you did something like this:Output using the aliased lists:Since both  and  point to the same list, two weird things happen.  First, the contents of the "two" s will be the same, as you've already noticed.  Each update seems to add a pair of identical s to two different lists, although it's really just adding one  to one list... and then printing that list twice...  You can see this in action by adding an extra  to :Second, notice how the last three "updates" don't actually change anything?  Something should have failed when you tried to add 18 values to only 9 slots.  Unfortunately, the  field that protects you from over-filling a  also saves you from the error that could have tipped you off earlier.  From :After the "first" (really, the only) three s are filled, they're all at  length, so neither  or  will change again.Contrast the list-comprehension version in my , which creates six different  objects, like you'd expect:
You have to use  because your lists store another lists and you have to copy them too. Look for examples: http://www.python-course.eu/deep_copy.php


Answer URL
https://docs.python.org/3/library/stdtypes.html#typesseq-common
https://docs.python.org/3/faq/programming.html#faq-multidimensional-list
https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types
