Natural Text
All is in the title. I'd like to create a class method and a class attribute, both constructed only once, when the class is created, using the first in the second's definition.With my best try, I just get a .Here is my code :EDIT 1 :'classmethod' object is not callable is a problem raising the same error, but with a lot of workarounds. My question is meant to go straight to the point and have a clear idea of how to use  without a scope giving access to .Another try that I made was the following :
s are implemented as a special object that gets processed using the descriptor protocol when looked up on the class; inside the definition, as a raw name (unqualified), it's a special  object, not a normal function and it's not bound to the class properly. If you check the pure Python definition of , you'll note it's just a normal object that implements  (for construction) and  (for descriptor lookup), but not , meaning that if you have the raw  object, it's not actually a callable at all.The trick is to qualify the reference so the "magic" happens to bind it to the class, and move the qualified reference outside the  definition (so  is a defined name and can be referenced for binding) changing:to:Note that since you're using a , I suspect you may eventually be interested in subclassing and overriding . As written, you'd need to explicitly redefine  after defining each subclass, or it would use the inherited , based on , even if the subclass defines its own  . Explicitly redefining  each time is an option, but the other approach is to use metaclasses to implicitly define  when a class redefines :No need to define  explicitly at all, and  seamlessly uses the most local classes' definition of  available at class definition time, so unless  is redefined after class definition, it always works, and it works as efficiently as possible. To make it use  live, you'd need to resort to more extreme measures that perform dynamic lookup and (barring a cache) reconstruction of the  object on each use, which is suboptimal to say the least.For completeness, a dynamic caching based solution (hat tip to Tadhg McDonald-Jensen's answer) that uses a dynamically populating cache that adds minimal overhead (and more importantly in my opinion, abstracts out the boilerplate code that's irrelevant to the work) for the case where the cache entry already exists by using a  subclass defining :Subclasses don't need to (and should not) override  (and can't accidentally access  because it's name mangled such that only methods defined by  will see it; change name to , one underscore, if it should be accessible to subclasses), they just override  and 's  will create/cache vectorized accessors when  is first accessed on the subclass (or an instance thereof).
Your confusion to why this is not an easy work around is understandable, let me elaborate on to why using  in this way isn't going to work...The way  works is that it creates a descriptor, an object that implements  when it is retrieved as an attribute on an object.So when you do  it basically loads the  classmethod and calls:Where the  represents the instance (there is None because it is on the class itself) and the second argument represents the class, a classmethod is not callable because then it would not have a class to bind it too!Not only this but the class object to bind it too doesn't exist until the  definition block has ended (and the metaclass  actually puts it together) so the bare minimum is to create  after the class is actually defined:This will work sure, but then you break the functionality of subclasses, what if you wanted to change ?The only way to make it work in this case is to recreate the  at least one for each subclass, the simplest version is to just do it every time you call :This is obviously undesirable because it calls  every time  is used, however you could make a record of all the classes and only make it when a new class is used:
You real problem is that you try to use  before the class if fully constructed, so you do not get the expected object.Here is a simplified example:gives:That shows that until the class is fully constructed, the methods identifier are only bound to the method definitions and not to the real methods.If you want achieve what you want, you must define the class variable outside of class definition (after last line), as explained by @ShadowRanger


Answer URL
https://docs.python.org/3/howto/descriptor.html
https://docs.python.org/3/howto/descriptor.html#static-methods-and-class-methods
https://docs.python.org/3/library/functions.html?highlight=callable#callable
