Natural Text
I want to make a shallow copy of an  object, but I don't know how because it has no builtin copy method. I want to achieve something like the following, where I create a copy of the cycle, iterate through it a few times, then copy the original again, and iterate a few more times starting from the beginning of the cycle.
It may require some refactoring, but a factory would work well here.Otherwise, I'm not sure you're going to be able to satisfy the criteria of starting at the beginning of the cycle each time. The class-based approached will also work, but requires a lot more overhead. One of the issues with the  approach is that it will resume iteration where the tee-d iterator left off instead of starting from the beginning. Thus, you have to tee it at the beginning. This may be the only option if you do not have control over how the cycle is generated.
Copying the cycle itself is going to run into problems. For example, ing it doesn't produce independent copies.Instead of trying to copy the cycle, I recommend recreating it from your original object:If the object you made your original cycle from is an iterator, you can't just call  on it repeatedly. Instead, make a list before you call  the first time, and keep the list:If the object you made your original cycle from is an iterator that might or might not be infinite, you can't safely call  on it. Instead, you can  it before creating the cycle and  the unadvanced tee when you need to make a new cycle. ( supports copying.)All this assumes you control the creation of the cycle. If you're receiving a cycle from elsewhere, you might not have access to the object it cycles over. In that case, your best option is to  the cycle itself. This could be expensive if you need to go through many loops of the cycle:
You could create a custom class to do what you want:Outputs:
 should do the trick:    
Method 1: making two  objects[Preferred Solution] Method 2: split into n iterators by using Warning using  module using the  function will not create a copy of the iterator as expected. Workaround using  module: a possible solution for this can be to use  function.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.tee
