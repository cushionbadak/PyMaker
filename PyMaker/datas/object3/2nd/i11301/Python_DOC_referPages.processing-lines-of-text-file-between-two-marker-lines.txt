Natural Text
My code processes lines read from a text file (see "Text Processing Details" at end).  I need to amend my code so that it carries out the same task, but only with words in between certain points.Code should not bother about this text. Skip it.*****This is the marker to say where to start working with text. Don't do anything until after these last three asterisks.>***Work with all of the code in this section*****Stop working with the text when the first three asterisks are seen*****Code should not bother about this text. Skip it.The markers for all situations are three asterisks. Markers only count when they appear at the beginning and the end of the line.What should I use to make my code only work in between the second and third set of asterisks?Text Processing DetailsMy code reads a text file, makes all the words lowercase, and splits the words, putting them into a list:It then strips that list of all grammatical symbols in the words:Finally, for each word in that list, if it only contains alphabetic symbols, it gets appended to a new list. That list is then returned:
What appears to be one task, "count the words between two marker lines", is actually several.  Separate the different tasks and decisions into separate functions and generators, and it will be vastly easier.Step 1:  Separate the file I/O from the word counting.  Why should the word-counting code care where the words came from?Step 2:  Separate selecting the lines to process from the file handling and the word counting.  Why should the word-counting code be given words it's not supposed to count?  This is still far too big a job for one function, so it will be broken down further.  (This is the part you're asking about.)Step 3:  Process the text.  You've already done that, more or less.  (I'll assume your text-processing code ends up in a function called ).1.  Separate file I/OReading text from a file is really two steps: first, open and read the file, then strip the newline off each line.  These are two jobs.Not a hint of your text processing here.  The  generator just yield whatever strings were found in the file... after stripping their trailing newline.  (Note that a plain  would also remove leading and trailing whitespace, which you have to preserve to identify marker lines.)2.  Select only the lines between markers.This is really more than one step.  First, you have to know what is and isn't a marker line.  That's just one function.Then, you have to advance past the first marker (while throwing away any lines encountered), and finally advance to the second marker (while keeping any lines encountered).  Anything after that second marker won't even be read, let alone processed.Python's generators can almost solve the rest of Step 2 for you.  The only sticking point is that closing marker...  details below.2a.  What is and is not a marker line?Identifying a marker line is a yes-or-no question, obviously the job of a Boolean function:Note that a marker line need not (from my reading of your requirements) contain any text between the start and end markers --- six asterisks () is a valid marker line.2b.  Advance past the first marker line.This step is now easy: just throw away every line until we find a marker line (and junk it, too).  This function doesn't need to worry about the second marker line, or what if there are no marker lines, or anything else.2c.  Advance past the second marker line, saving content lines.A generator could easily yield every line after the "start" marker, but if it discovers there is no "end" marker, there's no way to go back and un- those lines.  So, now that you've finally encountered lines you (might) actually care about, you'll have to save them all in a list until you know whether they're valid or not.2d.  Gluing Step 2 together.Advance past the first marker, then yield everything until the second marker.Testing functions like this with a bunch of input files is annoying.  Testing it with lists of strings is easy, but lists are not generators or iterators, they're iterables.  The one extra  line was worth it.3.  Process the selected lines.Again, I'm assuming your text processing code is safely wrapped up in a function called .  The only change is that, instead of opening a file and reading it to produce a list of lines, you're given the lines:...except that  should probably be a generator, too.Now, calling  is easy:To get the  , you yield the  found in the , selected from the ...  Not quite English, but close.4. Call  from your program.Wherever you already have  defined --- presumably inside  somewhere --- call  to get one word at a time:Or, if you really need those words in a :ConclusionThat this would have been much harder trying to squeeze it all into one or two functions.  It wasn't just one task or decision, but many.  The key was breaking it into tiny jobs, each of which was easy to understand and test.The generators got rid of a lot of boilerplate code.  Without generators, almost every function would have required a  loop just to , like in .If you have Python 3.3+, the  construct, erases even more boilerplate.  Every generator containing a loop like this:Could be re-written as:I counted four of them.For more on the subject of iterables, generators, and functions that use them, see Ned Batchelder's "Loop Like a Native", available as a 30-minute video from PyCon US 2013.
I recommend using regular expressions.
You can get only the text between your asterisks with regex:


Answer URL
https://docs.python.org/3/whatsnew/3.3.html#pep-380
