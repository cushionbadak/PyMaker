Natural Text
So the example code is very basic:This works well. But adding autospec keyword to the mock:causes additional argument to be passed to the  callable, which obviously results in error:What I don't uderstand, is why autospeccing gives additional argument. I've read the docs, but still can't find the explanation of this behaviour.Theoretically, it's written that In addition mocked functions / methods have the same call signature as the original so they raise a TypeError if they are called incorrectly.so it'd be okay ( has  argument, which is probably what is being passed here), but on the other hand it's also written about  thatThe function is called with the same arguments as the mock, and unless it returns DEFAULT, the return value of this function is used as the return value.So as far as I understand,  should be called with the  argument even without autospeccing. But it is not.is called with the same arguments as the mockSo if someone could explain it to me, preferably quoting the docs, I'd be thankful.
You are misunderstanding the documentation.  Without , the  that is being called is literally as is without inspecting the original declaration.  Let's create a better minimum example to demonstrate this issue.Now your original test should work about the same with some adjustmentsRunning the test as is will cause  be printed to stdout, even though we haven't gone through the dance to set the Book.valid flag to true, as the  being called in  is replaced with the lambda which is invoked.  We can see this through a debugger:Also within the frame of the  method call, it's not a bound method (we will get back to this later)So hmm, we might have a problem here: the  could literally be any callable that could be different to what reality is, in our case the  function signature (that is the argument list) could be different to the mock we provide.  What if the  method was modified to take in an additional argument:Rerun our test... and you will see that our test has passed, even though  is still calling  without any arguments.  Your product will fail in production even though your test has passed.  This is why  argument is introduced, and we will apply that in our second test without replacing the callable through side_effect:This now happens when calling the functionWhich is what you want and what  intends to provide - a check before the mocks are called, andIn addition mocked functions / methods have the same call signature as the original so they raise a TypeError if they are called incorrectly.So we have to fix the  method by providing an authcode greater than .Since our test didn't mock the  function via the  callable, the method will end up printing .Now if we want to provide the , it will have to match the same signature will now be printed again.  Going through the debugger to inspect that 'd and mocked  object within the frame of the  method callAh, somehow the method signature is not a simple  object (recall the  noted previously) and is a properly bound method, which means the  argument is now passed into the mock, solving this:side_effect: A function to be called whenever the Mock is called. See the  attribute. Useful for raising exceptions or dynamically changing return values. The function is called with the same arguments as the mock...The "same arguments as the mock" in this case means the same as whatever that was passed into the mock. To reiterate, the first case the  was replaced with a naked, unbounded callable so  is never passed; and in the second case the callable is now bound to , both the  AND  will be passed into the  callable - just as what would happen in the real call. This should reconciled the perceived misbehavior of interactions with  for  and manually defined  callable for a mock.


Answer URL
https://docs.python.org/3/library/unittest.mock.html
https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.side_effect
