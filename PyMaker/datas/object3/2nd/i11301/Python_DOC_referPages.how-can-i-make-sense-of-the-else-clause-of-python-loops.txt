Natural Text
Many Python programmers are probably unaware that the syntax of  loops and  loops includes an optional  clause:The body of the  clause is a good place for certain kinds of clean-up actions, and is executed on normal termination of the loop: I.e., exiting the loop with  or  skips the  clause; exiting after a  executes it. I know this only because I just looked it up (yet again), because  I can never remember when the  clause is executed.Always? On "failure" of the loop, as the name suggests? On regular termination? Even if the loop is exited with ? I can never be entirely sure without looking it up.I blame my persisting uncertainty on the choice of keyword: I find  incredibly unmnemonic for this semantics. My question is not "why is this keyword used for this purpose" (which I would probably vote to close, though only after reading the answers and comments), but how can I think about the  keyword so that its semantics make sense, and I can therefore remember it?I'm sure there was a fair amount of discussion about this, and I can imagine that the choice was made for consistency with the  statement's  clause (which I also have to look up), and with the goal of not adding to the list of Python's reserved words. Perhaps the reasons for choosing  will clarify its function and make it more memorable, but I'm after connecting name to function, not after historical explanation per se.The answers to this question, which my question was briefly closed as a duplicate of, contain a lot of interesting back story. My question has a different focus (how to connect the specific semantics of  with the keyword choice), but I feel there should be a link to this question somewhere.
(This is inspired by @Mark Tolonen's answer.)An  statement runs its  clause if its condition evaluates to false.Identically, a  loop runs the else clause if its condition evaluates to false.This rule matches the behavior you described:In normal execution, the while loop repeatedly runs until the condition evaluates to false, and therefore naturally exiting the loop runs the else clause.When you execute a  statement, you exit out of the loop without evaluating the condition, so the condition cannot evaluate to false and you never run the else clause.When you execute a  statement, you evaluate the condition again, and do exactly what you normally would at the beginning of a loop iteration.So, if the condition is true, you keep looping, but if it is false you run the else clause.Other methods of exiting the loop, such as , do not evaluate the condition and therefore do not run the else clause. loops behave the same way. Just consider the condition as true if the iterator has more elements, or false otherwise.
Better to think of it this way: The  block will always be executed if everything goes right in the preceding  block such that it reaches exhaustion. Right in this context will mean no , no , no . Any statement that hijacks control from  will cause the  block to be bypassed.A common use case is found when searching for an item in an , for which the search is either called off when the item is found or a  flag is raised/printed via the following  block:A  does not hijack control from , so control will proceed to the  after the  is exhausted.
When does an  execute an ? When its condition is false. It is exactly the same for the /.  So you can think of / as just an  that keeps running its true condition until it evaluates false.  A  doesn't change that.  It just jumps of of the containing loop with no evaluation.  The  is only executed if evaluating the / condition is false.The  is similar, except its false condition is exhausting its iterator.  and  don't execute .  That isn't their function.  The  exits the containing loop.  The  goes back to the top of the containing loop, where the loop condition is evaluated.  It is the act of evaluating / to false (or  has no more items) that executes  and no other way.
This is what it essentially means:It's a nicer way of writing of this common pattern:The  clause will not be executed if there is a  because  leaves the function, as it is meant to. The only exception to that which you may be thinking of is , whose purpose is to be sure that it is always executed. has nothing special to do with this matter. It causes the current iteration of the loop to end which may happen to end the entire loop, and clearly in that case the loop wasn't ended by a . is similar:
If you think of your loops as a structure similar to this (somewhat pseudo-code):it might make a little bit more sense. A loop is essentially just an  statement that is repeated until the condition is . And this is the important point. The loop checks its condition and sees that it's , thus executes the  (just like a normal ) and then the loop is done.So notice that the  only get's executed when the condition is checked. That means that if you exit the body of the loop in the middle of execution with for example a  or a , since the condition is not checked again, the  case won't be executed.A  on the other hand stops the current execution and then jumps back to check the condition of the loop again, which is why the  can be reached in this scenario.
My gotcha moment with the loop's  clause was when I was watching a talk by Raymond Hettinger, who told a story about how he thought it should have been called . Take a look at the following code, what do you think it would do?What would you guess it does? Well, the part that says  would only be executed if a  statement wasn't hit in the loop.
Usually I tend to think of a loop structure like this:To be a lot like a variable number of  statements:In this case the  statement on the for loop works exactly like the  statement on the chain of s, it only executes if none of the conditions before it evaluate to True. (or break execution with  or an exception)  If my loop does not fit this specification usually I choose to opt out of using  for the exact reason you posted this question: it is non-intuitive.
Others have already explained the mechanics of , and the Python 3 language reference has the authoritative definition (see while and for), but here is my personal mnemonic, FWIW. I guess the key for me has been to break this down into two parts: one for understanding the meaning of the  in relation to the loop conditional, and one for understanding loop control.I find it's easiest to start by understanding : you have more items, do stuff,  if you run out, do thisThe  mnemonic is basically the same: every item, do stuff, but  if you run out, do thisIn both cases, the  part is only reached once there are no more items to process, and the last item has been processed in a regular manner (i.e. no  or ). A  just goes back and sees if there are any more items. My mnemonic for these rules applies to both  and :when ing or ing, there's nothing  to do,  and when I say , that's "loop back to start" for you– with "loop back to start" meaning, obviously, the start of the loop where we check whether there are any more items in the iterable, so as far as the  is concerned,  really plays no role at all.
In Test-driven development (TDD), when using the Transformation Priority Premise paradigm, you treat loops as a generalization of conditional statements.This approach combines well with this syntax, if you consider only simple  (no ) statements:generalizes to:nicely.In other languages, TDD steps from a single case to cases with collections require more refactoring.Here is an example from 8thlight blog:In the linked article at 8thlight blog, the Word Wrap kata is considered: adding line breaks to strings (the  variable in the snippets below) to make them fit a given width (the  variable in the snippets below). At one point the implementation looks as follows (Java):and the next test, that currently fails is:So we have code that works conditionally: when a particular condition is met, a line break is added. We want to improve the code to handle multiple line breaks. The solution presented in the article proposes to apply the (if->while) transformation, however the author makes a comment that:While loops can’t have  clauses, so we need to eliminate the  path by doing less in the  path. Again, this is a refactoring.which forces to do more changes to the code in the context of one failing test:In TDD we want to write as less code as possible to make tests pass. Thanks to Python's syntax the following transformation is possible:from:to:
The way I see it,  fires when you iterate past the end of the loop.If you  or  or  you don't iterate past the end of loop, you stop immeadiately, and thus the  block won't run. If you  you still iterate past the end of loop, since continue just skips to the next iteration. It doesn't stop the loop. 
Think of the  clause as being part of the loop construct;  breaks out of the loop construct entirely, and thus skips the  clause.But really, my mental mapping is simply that it's the 'structured' version of the pattern C/C++ pattern:So when I encounter  or write it myself, rather than understand it directly, I mentally translate it into the above understanding of the pattern and then work out which parts of the python syntax map to which parts of the pattern.(I put 'structured' in scare quotes because the difference is not whether the code is structured or unstructured, but merely whether there are keywords and grammar dedicated to the particular structure)
The way I think about it, the key is to consider the meaning of  rather than .The other keywords you mention break out of the loop (exit abnormally) whilst  does not, it just skips the remainder of the code block inside the loop. The fact that it can precede loop termination is incidental: the termination is actually done in the normal way by evaluation of the loop conditional expression.Then you just need to remember that the  clause is executed after normal loop termination.
If you try to pair  with  in your mind, it could be confusing. I don't think the keyword  was a great choice for this syntax, But if you pair  with , you can see it actually makes sense.Let me demonstrate it in human language. each person in a group of suspects  anyone is the criminal   the investigation.  report failure. is barely useful if there weren't  in the  loop anyway.



Answer URL
https://docs.python.org/3/reference/compound_stmts.html#the-for-statement
https://docs.python.org/3/reference/
https://docs.python.org/3/reference/compound_stmts.html#the-while-statement
https://docs.python.org/3/reference/compound_stmts.html#the-for-statement
