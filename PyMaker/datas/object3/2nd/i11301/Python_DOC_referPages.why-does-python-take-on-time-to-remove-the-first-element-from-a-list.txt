Natural Text
The Python wiki page on time complexity says that deleting an item takes O(n) time. The description of the deque class in the documentation of the collections module says that " objects [...] incur O(n) memory movement costs for  and  operations which change both the size and position of the underlying data representation".Why do lists need O(n) time? Isn't a list just a bunch of elements, or pointers to elements, physically next to each other in memory, along with a pointer to where the list starts? If so, why can't the  type have a  method, similar to the one in , that removes the first element in O(1) time by appropriately incrementing the start pointer of the list?I am not trying to solve any specific problem. I just want to satisfy my curiosity as to why it is designed that way.EDIT: Here is a diagram of how my  method would work:Before calling :After calling :Before the call to , the first element of the list is , the 2nd is , etc. After the call, the place where the first element was is now unused memory (which may be left empty or claimed by the garbage collector), the new first element is , the new 2nd element is , etc. No large amount of data needs to be moved, and nothing needs to happen that takes O(n) time.
The pointer to where the list really starts must be retained for the purpose of freeing the memory appropriately.Indeed,  could be made faster by having a second pointer which is increased in this case. And if an  happens afterwards, this could be made faster by decrementing this "data start timer" as long as it is bigger than the "memory start timer".But all other operations, i. e. insertions and deletions to other indexes, would still be , so that wouldn't change much.Just know what your operations will be and thus which data structure to pick.
Python  is actually an array.  is a real linked list. It is Python's fault for using the wrong term (for which I do not have an explanation).  for insertion and deletion is normal for arrays (as following elements need to be shifted up or down), which is a tradeoff for the  speed for get and set. Linked lists make a similar tradeoff in the opposite direction:  for operations at ends, but  for any access in the middle.
There's no reason it couldn't be, it just hasn't been. It is, however, a complication to the code, and the problem you're facing is usually an indicator that you're taking the wrong approach.You could just implement this behavior yourself in a wrapper class, and use that in the cases where you know it will be worth it.That said, something similar has been submitted to PyPy.


Answer URL
https://docs.python.org/3/library/collections.html#collections.deque
https://docs.python.org/3/library/collections.html#collections.deque.popleft
