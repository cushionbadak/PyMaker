Natural Text
Let's say I have a couple of Python packages.What's the best way to utilize the utilites package? Say shiny_stuff.py needs to import important.py, what's the best way to go about that?Currently I'm thinkingBut is that the best way? Would it make more sense to add utilities to the path and import it that way?That seems clunky to add to each of my files. 
I think the safest way is always to use absolute import, so in you case:This way you won't have to change your code if you decide to move your shiny_stuff.py in some other package (assuming that package_name will still be in your sys.path).
According to Nick Coghlan (who is a Python core developer):"“Never add a package directory, or any directory inside a package, directly to the Python path.” (Under the heading "The double import trap")Adding the package directory to the path gives two separate ways for the module to be referred to.  The link above is an excellent blog post about the Python import system.  Adding it to the path directly means you can potentially have two copies of a single module, which you don't want.  Your relative import  is fine, and an absolute import  is also fine.
A "best" out-of-context choice probably doesn't exist, but you can have some criteria choosing which is better for your use cases, and for such a judgment one should know are the different possible approaches and their characteristics. Probably the best source of information is the PEP 328  itself, which contains some rationale about declaring distinct possibilities for that.A common approach is to use the "absolute import", in your case it would be something like:This way, you can make this file it a script. It is somewhat independent from other modules and packages, fixed mainly by its location. If you have a package structure and need to change one single module from its location, having absolute path would help this single file to be kept unchanged, but all the ones which uses this module it should change. Of course you can also import the  files as:And these imports have the same characteristics. Be careful that  try to find a variable  within , not from important.py, so having a "import important"  would help avoiding a mistake due to the distinction between file structure and namespace structure.Another way to do that is the relative approach, by using:The first dot ( or ) says "the module in this [sub]package", or  when there's only the dot. From the second dot we are talking about parent directories. Generally, starting with dots in any import isn't allowed in a script/executable, but you can read about explicit relative imports (PEP 366) if you care about scripts with relative imports.A justification for relative import can be found on the PEP 328 itself:With the shift to absolute imports, the question arose whether relative imports should be allowed at all. Several use cases were presented, the most important of which is being able to rearrange the structure of large packages without having to edit sub-packages. In addition, a module inside a package can't easily import itself without relative imports.Either case, the modules are tied to the subpackages in the sense that  is imported first no matter which the user tried to import first, unless you use sys.path to search for subpackages as packages (i.e., use the package root inside sys.path)...but that sounds weird, why would one do that?The  can auto-import module names, for that one should care about its namespace contents. For example, say  has an object called , which is a dictionary. To find it from anywhere you would needPerhaps you want be less specific:That would be done with an  with the following line inside it:That's perhaps mixing the relative and absolute imports, but for a  you probably know that subpackage makes sense as a subpackage, i.e., as an abstraction by itself. If it's just a bunch of files located in the same place with the need for a explicit module name, probably the  would be empty (or almost empty). But for avoiding explicit module names for the user, the same idea can be done on the root , withCompletely indirect, but the namespace gets flat this way while the files are nested for some internal organization. For example, the  package (wxPython) do that: everything can be found  directly.You can also use some metaprogramming for finding the contents if you want to follow this approach, for example, using  to detect all names a module have, or looking for the file location to know which modules/subpackages are available there to import. However, some simpler code completion utilities might get lost when doing that.For some contexts you might have other kind of constraints. For example, macropy makes some "magic" with imports and doesn't work on the file you call as a script, so you'll need at least 2 modules just to use this package.Anyhow, you should always ask whether nesting into subpackages is really needed for you code or API organization. The PEP 20 tells us that "Flat is better than nested", which isn't a law but a point-of-view that suggests you should keep a flat package structure unless nesting is needed for some reason. Likewise, you don't need a module for each class nor anything alike.
Use absolute import in case you need to move to a different location.


Answer URL
https://docs.python.org/3/distutils/introduction.html?highlight=distutils
