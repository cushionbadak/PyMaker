Natural Text
I am trying to create a  which contains only a limited number of MRU entries (for helping in caching the output of a costly C function I call via ctypes). Here is the code:... and here is the testing code:Now from the output it seems I am being kind of naive in implementing the  function because both  and  (which, I'm guessing here, call  and then ) causes the first item to be moved to the last as MRU, but cannot proceed further because there is no "next" item for the iterator since it now points to the last element. But I am not sure what I can do to fix the situation. Should I reimplement ?I am not sure how to distinguish between the user's calling  and an internal call to the same. Of course, a workaround is to make the user to use a  method which would do the move-to-end thing, but I'd really like to be able to use the regular syntax .Please advise on how to fix this. Thanks!
For complex changes of behaviour like these, it pays to study the  source code.The actual  method loops directly over the internal structure, the doubly linked list that maintains the item order. It'll never directly use , instead just returning the keys from the linked list.The actual problem that you are having is that you are directly accessing the items while looping:There is a  in there; it is that access that moves item 5 from start to end. This updates the linked list, so when asking for the next item the  reference is now the root and iteration stops.The work-around would be to not do that. Add a dedicated method to access items without triggering the MRU update. Or you could re-use  for example:You will have a problem with the  method;  reuses 's  method, which returns a  instance; see the  source code.You'll have to replace that behaviour:You'd have to do the same for the  and  methods.


Answer URL
https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableMapping
https://docs.python.org/3/library/collections.abc.html#collections.abc.ItemsView
