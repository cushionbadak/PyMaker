Natural Text
I am trying to implement python-to-c binding via  for .I have a structure, here is a wrong variant:At some moment during debug session it looks like that:The problem here is that I want  to be 64-bit unsigned integer equal to 7. More precisely, it must match  from . So i tried an obvious variant and changed  to  and it doesn't work:What am I missing here?
The issue here is that the C struct you're trying to map is packed, as (tersely) explained in the Structure/union alignment and byte order section of the docs:By default, Structure and Union fields are aligned in the same way the C compiler does it. It is possible to override this behavior be specifying a  class attribute in the subclass definition. This must be set to a positive integer and specifies the maximum alignment for the fields. This is what  also does in MSVC.That only makes sense if you already know about packing and alignment in C, but it's not that complicated.By default, C structure elements are aligned to start on nice boundaries. For example, a 32-bit int following an 8-bit int doesn't run from bytes 1-4, it runs from bytes 4-7 (and bytes 1-3 are unused padding). So,  follows the same rules.That means that, while  runs from bytes 3-10 when it's defined as an array of 8-bit ints, it gets aligned to bytes 8-15 (or 4-11, depending on your compiler) when it's defined as a 64-bit int. You can see this by printing out .So, the first one gets the bytes , which is little-endian int64 for , while the second one gets the bytes , where  are the first 5 bytes of the next field, which is little-endian int64 for some huge number (unless the next field happens to be 0).Of course you don't want to just guess that this is the problem. If you based your  on a  from a C header, this can only be true if the header or the compile flags specify some non-default packing, like the  used by MSVC. If you based your  on something like an RFC packet description, the alignment is not even according to C rules, but is defined somewhere in the documentation you're reading (although protocol RFCs almost always use 1-byte alignment).Anyway, the docs don't explain the problem very well, but they explain the solution:Now  runs from bytes 3-10, but it's interpreted as a 64-bit int instead of an array of 8-bit ints.
and go aheadYou may need to specify  too (if your compiler generates code that way) before defining .Update: There is ready made  (and ) type in .Note:  is not equal to  or  because of possible alignment issues ( fields are not aligned).  may give you a hint on how c_type is aligned:


Answer URL
https://docs.python.org/3/library/ctypes.html#structure-union-alignment-and-byte-order
