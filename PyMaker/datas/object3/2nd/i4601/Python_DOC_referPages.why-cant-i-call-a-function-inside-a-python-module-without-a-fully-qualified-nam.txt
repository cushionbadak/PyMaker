Natural Text
I have been using Python more and more, and I keep seeing the variable  set in different  files.  Can someone explain what this does?
It's a list of public objects of that module, as interpreted by . It overrides the default of hiding everything that begins with an underscore.
Linked to, but not explicitly mentioned here, is exactly when  is used. It is a list of strings defining what symbols in a module will be exported when  is used on the module.For example, the following code in a  explicitly exports the symbols  and :These symbols can then be imported like so:If the  above is commented out, this code will then execute to completion, as the default behaviour of  is to import all symbols that do not begin with an underscore, from the given namespace.Reference: https://docs.python.org/3.5/tutorial/modules.html#importing-from-a-packageNOTE:  affects the  behavior only. Members that are not mentioned in  are still accessible from outside the module and can be imported with .
I'm just adding this to be precise:All other answers refer to modules. The original question explicitely mentioned  in  files, so this is about python packages.Generally,  only comes into play when the  variant of the  statement is used. This applies to packages as well as to modules.The behaviour for modules is explained in the other answers. The exact behaviour for packages is described here in detail.In short,  on package level does approximately the same thing as for modules, except it deals with modules within the package  (in contrast to specifying names within the module). So  specifies all modules that shall be loaded and imported into the current namespace when us use .The big difference is, that when you omit the declaration of  in a package's , the statement  will not import anything at all (with exceptions explained in the documentation, see link above). On the other hand, if you omit  in a module, the "starred import" will import all names (not starting with an underscore) defined in the module.
Explain __all__ in Python?I keep seeing the variable  set in different  files.What does this do?What does  do?It declares the semantically "public" names from a module. If there is a name in , users are expected to use it, and they can have the expectation that it will not change. It also will have programmatic affects: in a module, e.g. :means that when you  from the module, only those names in the  are imported:Documentation toolsDocumentation and code autocompletion tools may (in fact, should) also inspect the  to determine what names to show as available from a module. makes a directory a Python packageFrom the docs:The  files are required to make Python treat the directories as containing packages; this is done to prevent directories with a common name, such as string, from unintentionally hiding valid modules that occur later on the module search path.In the simplest case,  can just be an empty file, but it can also execute initialization code for the package or set the  variable.So the  can declare the  for a package.Managing an API:A package is typically made up of modules that may import one another, but that are necessarily tied together with an  file. That file is what makes the directory an actual Python package. For example, say you have the following:in the  you write:and in  you have:and in  you have:And now you have presented a complete api that someone else can use when they import your package, like so: And they won't have all the other names you used when creating your modules cluttering up the  namespace. in After more work, maybe you've decided that the modules are too big and need to be split up. So you do the following:And in each  you declare an , e.g. in module_1:And module_2's :And you can easily add things to your API that you can manage at the subpackage level instead of the subpackage's module level. If you want to add a new name to the API, you simply update the , e.g. in module_2:And if you're not ready to publish  in the top level API, in your top level  you could have:and if your users are aware of the availability of , they can use it:but if they don't know about it, other tools (like pydoc) won't inform them.You can later change that when  is ready for prime time:Prefixing  versus :By default, Python will export all names that do not start with an . You certainly could rely on this mechanism. Some packages in the Python standard library, in fact, do rely on this, but to do so, they alias their imports, for example, in :Using the  convention can be more elegant because it removes the redundancy of naming the names again. But it adds the redundancy for imports (if you have a lot of them) and it is easy to forget to do this consistently - and the last thing you want is to have to indefinitely support something you intended to only be an implementation detail, just because you forgot to prefix an  when naming a function.I personally write an  early in my development lifecycle for modules so that others who might use my code know what they should use and not use.Most packages in the standard library also use .When avoiding  makes senseIt makes sense to stick to the  prefix convention in lieu of  when:You're still in early development mode and have no users, and are constantly tweaking your API.Maybe you do have users, but you have unittests that cover the API, and you're still actively adding to the API and tweaking in development.An  decoratorThe downside of using  is that you have to write the names of functions and classes being exported twice - and the information is kept separate from the definitions. We could use a decorator to solve this problem.I got the idea for such an export decorator from David Beazley's talk on packaging. This implementation seems to work well in CPython's traditional importer. If you have a special import hook or system, I do not guarantee it, but if you adopt it, it is fairly trivial to back out - you'll just need to manually add the names back into the So in, for example, a utility library, you would define the decorator:and then, where you would define an , you do this:And this works fine whether run as main or imported by another function.And API provisioning with  will work too:
It also changes what pydoc will show:module1.pymodule2.py$ pydoc module1$ pydoc module2I declare  in all my modules, as well as underscore internal details, these really help when using things you've never used before in live interpreter sessions.
From (An Unofficial) Python Reference Wiki:The public names defined by a module are determined by checking the module's namespace for a variable named ; if defined, it must be a sequence of strings which are names defined or imported by that module. The names given in  are all considered public and are required to exist. If  is not defined, the set of public names includes all names found in the module's namespace which do not begin with an underscore character ("_").  should contain the entire public API. It is intended to avoid accidentally exporting items that are not part of the API (such as library modules which were imported and used within the module).
 customizes the asterisk in  customizes the asterisk in A module is a  file meant to be imported.A package is a directory with a  file. A package usually contains modules.MODULES lets humans know the "public" features of a module.[@AaronHall]  Also, pydoc recognizes them.[@Longpoke]from module import *See how  and  are brought into the local namespace, but not :Without , any symbol (that doesn't start with an underscore) would have been available. Imports without  are not affected by import modulefrom module import namesimport module as localnamePACKAGESIn the  file of a package  is a list of strings with the names of public modules or other objects. Those features are available to wildcard imports. As with modules,  customizes the  when wildcard-importing from the package.[@MartinStettner] Here's an excerpt from the Python MySQL Connector :The default case, asterisk with no  for a package, is complicated, because the obvious behavior would be expensive: to use the file system to search for all modules in the package. Instead, in my reading of the docs, only the objects defined in  are imported:If  is not defined, the statement  does not import all submodules from the package  into the current namespace; it only ensures that the package  has been imported (possibly running any initialization code in ) and then imports whatever names are defined in the package. This includes any names defined (and submodules explicitly loaded) by . It also includes any submodules of the package that were explicitly loaded by previous import statements. Wildcard imports ... should be avoided as they [confuse] readers and many automated tools.[PEP 8, @ToolmakerSteve]
Short answer affects  statements.Long answerConsider this example:In :(Implicit) If we don't define , then  will only import names defined in .(Explicit) If we define , then  will import nothing.(Explicit) If we define , then  will only import those names.Note that in the implicit case, python won't import names starting with . However, you can force importing such names using .You can view the Python document here.
 is used to document the public API of a Python module. Although it is optional,  should be used.Here is the relevant excerpt from the Python language reference:The public names defined by a module are determined by checking the module’s namespace for a variable named ; if defined, it must be a sequence of strings which are names defined or imported by that module. The names given in  are all considered public and are required to exist. If  is not defined, the set of public names includes all names found in the module’s namespace which do not begin with an underscore character ('_').  should contain the entire public API. It is intended to avoid accidentally exporting items that are not part of the API (such as library modules which were imported and used within the module).PEP 8 uses similar wording, although it also makes it clear that imported names are not part of the public API when  is absent:To better support introspection, modules should explicitly declare the names in their public API using the  attribute. Setting  to an empty list indicates that the module has no public API.[...]Imported names should always be considered an implementation detail. Other modules must not rely on indirect access to such imported names unless they are an explicitly documented part of the containing module's API, such as  or a package's  module that exposes functionality from submodules.Furthermore, as pointed out in other answers,  is used to enable wildcard importing for packages:The import statement uses the following convention: if a package’s  code defines a list named , it is taken to be the list of module names that should be imported when  is encountered.
In addition to the existing answers,  doesn't have to be a list. As per the documentation on the  statement, if defined,  must be a sequence of strings which are names defined or imported by the module. So you may as well use a tuple to save some memory and CPU cycles. Just don't forget a comma in case the module defines a single public name:


Answer URL
https://docs.python.org/3/tutorial/modules.html#importing-from-a-package
https://docs.python.org/3/reference/simple_stmts.html#the-import-statement
https://docs.python.org/3/tutorial/modules.html#importing-from-a-package
https://docs.python.org/3/reference/simple_stmts.html#the-import-statement
