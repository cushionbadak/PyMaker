Natural Text
This code outputs "foo". I'm pretty sure I understand why this is happening, but I'm wondering if there is a straightforward way to implement what I want (inheritable aliases that behave according to MRO, so it outputs "bar") or a reason why this is bad programming practice.
There is no way to directly do what you want. To understand why, you need to understand the way method lookup works. It's explained in detail in the Descriptor HOWTO, and I tried to write a less expert-level explanation here, so I'll assume you read both of those and just show the effects:Notice that  is , not . Which explains why  ends up as a bound method around , even though the  ends up as a  instance. Why? Well, obviously  is not in  (or we wouldn't need an MRO). And in , it can't be anything but .So, what are the workarounds?You could make  into a  that forwards to , as Patrick Haugh suggested. Or you can just do this:This solution has the benefit of being dead simple—anyone who can Python will understand why it works.But Patrick's solution has the advantage of making not just , but also  (as an object you can pass around, compare for identity, etc.) work the way you want it to.Meanwhile, there is an idiom closely related to what you're asking for, where a set of public methods that you don't expect to override call a "protected" implementation method that you do. For example, a simple 1D array-math class might do this:And now there's no asymmetry between  and , only between the "public" interface ( and ) and the "protected" one ().
Here's a very straightforward way—that's perfectly OK:
You could have  be a property that returns 


Answer URL
https://docs.python.org/3/howto/descriptor.html
