Natural Text
Looking at this question, I realised that it is kind of awkward to use 's  if you want is to run a list of functions in parallel:I'm not saying it is exactly cryptic, but I think I expected some conventional name for this, even if only within  or something, similarly to / in JavaScript (yes, I know JavaScript didn't have lambdas at the time those functions were defined, and no, I'm not saying JavaScript is an exemplary programming language, just an example). In fact, I definitely think something like this should be present in , but (unless my eyes deceive me) it seems to be absent. I read that in the case of the identity function the resolution was to let people define their own trivial functions, and I understand it better in that case because there are a couple of different variations you may want, but this one feels like a missing bit to me.EDIT: As pointed out in the comments, Python 2 used to have an  function for this purpose.
First, let's look at the practical question.For any Python from 2.3 on, you can trivially write not just your no-argument , but a perfect-forwarding , as a one-liner, as explained in the 2.x docs for :The use of  is equivalent to In other words:… or, as an inline lambda:Of course the C implementation was a bit faster, but this is almost never relevant.1If you're going to be using this more than once, I think defining the function out-of-line and reusing it by name is probably clearer, but the lamdba version is simple and obvious enough (even more so for your no-args use case) that I can't imagine anyone complaining about it.Also, notice that this is actually more trivial than  if you understand what you're doing, not less. With , it's ambiguous what you should return with multiple arguments (or keyword arguments), so you have to decide which behavior you want; with , there's only one obvious answer, and it's pretty much impossible to get wrong.As for the history: Python, like JavaScript, originally had no . It's hard to dig up linkable docs for versions before 2.6, and hard to even find them before 2.3, but I think  was added in 1.5, and eventually reached the point where it could be used for perfect forwarding around 2.2. Before then, the docs recommended using  for forwarding, but after that, the docs recommended using  in place of . In fact, there was no longer any recommended use of .So in 2.3, the function was deprecated.2During the Python-3000 discussions that led to 3.0, Guido suggested that all of the "functional programming" functions except maybe  and  were unnecessary.3 Others made good cases for  and .4 But a big part of the case was that they're actually not trivial to write (in fully-general form), and easy to get wrong. That isn't true for . Also, people were able to find relevant uses of  and  in real-world codebases, but the only uses of  anyone could find were old pre-2.3 code. In fact, it was so rare that it wasn't even worth making the  tool transform calls to .The final rationale for removing it was summarized in PEP 3100:: use  instead [2]That footnote links to an essay by Guido called "Python Regrets", which is now a 404 link. The accompanying PowerPoint presentation is still available, however, or you can view an HTML flipbook of the presentation he wrote it for. But all it really says is the same one-liner, and IIRC, the only further discussion was "We already effectively got rid of it in 2.3."1. In most idiomatic Python code that has to apply a function, the work inside that function is pretty heavy. In your case, of course, the overhead of calling the functions (pickling arguments and passing them over a pipe) is even heavier. The one case where it would matter is when you're doing "Haskell-style functional programming" instead of "Lisp-style"—that is, very few function definitions, and lots of functions made by transforming functions and composing the results. But that's already so slow (and stack-heavy) in Python that it's not a reasonable thing to do. (Flat use of decorators to apply a wrapper or three works great, but a potentially unbounded chain of wrappers will kill your performance.)2. The formal deprecation mechanism didn't exist yet, so it was just moved to a "Non-essential Built-in Functions" section in the docs. But it was retroactively considered to be deprecated since 2.3, as you can see in the 2.7 docs.3. Guido originally wanted to get rid of even them; the argument was that list comprehensions can do the same job better, as you can see in the "Regrets" flipbook. But promoting  in place of  means it could be made lazy, like the new , and therefore better than comprehensions. I'm not sure why Guido didn't just make the same argument with generator expressions.4. I'm not sure Guido himself was ever convinced for , but the core devs as a whole were.
It sort of is in  if you do one line of extra work:Of course,  is only one line as well...


Answer URL
https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.map
https://docs.python.org/3/library/functools.html
https://docs.python.org/3/library/operator.html
https://docs.python.org/3/library/functools.html
