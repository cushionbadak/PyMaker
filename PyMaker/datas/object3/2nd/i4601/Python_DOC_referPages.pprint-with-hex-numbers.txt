Natural Text
I work with a number of json-like dicts.  is handy for structuring them. Is there a way to cause all ints in a pprint output to be printed in hex rather than decimal?For example, rather than:I'd rather see:I have tried customizing , but to no avail, was I able to cause the above, having  handle integers only seems to work for some of the integers:the above class producesThe list contents are not correctly formatted.
You can alter the output of , but you need to re-implement the  function, not just subclass the  class.What happens is that (an internal version of) the  function is used for all objects, and that function itself then recursively handles turning objects into representations (using only itself, not the  instance), so any customisation has to happen there. Only when the result of  becomes too large (too wide for the configured width) will the  class start breaking up container output into components to put on separate lines; the process of calling  is then repeated for the component elements.So  is only responsible for handling the top-level object, and every recursive object that is a) inside a supported container type (dict, list, tuple, string and the standard library subclasses of these) and b) where the representation of the parent container produced by  exceeded the display width.To be able to override the implementation, we need to understand how the  method and the  implementation interact, what arguments they take and what they need to return. is passed additional arguments, ,  and : is used to detect recursion (the default implementation returns the result of  if  is true.when  is set and  is true, the default implementation returns  as the contents of a container.The method is also supposed to return a tuple of 3 values; the representation string and two flags. You can safely ignore the meaning of those flags, they are actually never used in the current implementation. They are meant to signal if the produced representation is 'readable' (uses Python syntax that can be passed to ) or was recursive (the object contained circular references). But the   and  methodsactually completely bypass ; these return values seem to be a hold-over from a refactoring that broke the relationship between  and those two methods. So just return a representation string and whatever two boolean values you like. really just delegates to an internal implementation of  that then does several thingshandle recursion detection with , and depth handling for  and recurse over dictionaries, lists and tuples (and their subclasses, as long as their  method is still the default implementation)for dictionaries, sort the key-value pairs. This is trickier than it appears in Python 3, but this is solved with a custom  sorting key that approximates Python 2's sort everything behaviour. We can re-use this.To implement a recursive replacement, I prefer to use  to delegate handling of different types. Ignoring custom  methods, handling depth issues, recursion, and empty objects, can also be handled by a decorator:This hand-full can handle anything the base  implementation can, and it will produce hex integers in any supported container. Just create an instance of the  class and call  on that:Side note: as of Python 3.7 you can drop the  call part of the  decorators; the type is picked up from the annotations instead.


Answer URL
https://docs.python.org/3/library/pprint.html#pprint.saferepr
https://docs.python.org/3/library/pprint.html#pprint.PrettyPrinter.format
https://docs.python.org/3/library/functools.html#functools.singledispatch
