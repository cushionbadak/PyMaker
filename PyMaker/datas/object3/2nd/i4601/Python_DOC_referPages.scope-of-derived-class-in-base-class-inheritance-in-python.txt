Natural Text
I know that by inheriting the base class. All the functions in base class would be accessible in the derived class as well. But how does it work the other way, meaning can a function that is defined in the child class be accessible in the base class. I tried the above out with an example. And it works just fine. But how can that be. I am not able to get the logic behind the working. I understand that the instance is being passed and all through self, but the details of the child class should logically not be accessible in the base class, correct?!
You are accessing attributes on an instance, not on a class. Your  reference is never an instance of the  class, only of one of the two derived classes, and those derived classes set the  attribute.If you created an instance of  itself, you'd get an attribute error, because that instance will not have the attribute set.You may perhaps think that in base classes,  becomes an instance of the base class; that's not the case.Instead, attributes on an instance are looked up on the instance directly, and on its class and base classes. So  looks at the instance, at  and at all further objects in the , the Method Resolution Order that sets all classes in a hierarchy in a linear order.You could print out the  of your object:The  references are instances of the derived classes, passed into an inherited method. So  will first look at the attributes directly set on , then at , and there  is found.Perhaps it would help to see how Python methods work. Methods are just thin wrappers around functions, created when you look up the attribute on an instance:Look closely at the names of the objects I access, and what happens when I call the  method on a function. Python uses a process called binding when you access certain attributes on an instance; when you access an attribute this way, and that points to an object with a  method, then that object is called a descriptor, and  is called to bind the object to whatever you looked the object up on. See the descriptor howto.Accessing  on the instance, produces a bound method object, but the description of the object tells us it came from , it's named a *bound method  of instance reference. Accessing the same name on the class gives us the  function, and I can manually bind it to create a method again.Finally, the method has an attribute , which is the original instance, and  which is the original function. And there's the magic, when you call a bound method, the method object just calls , so passing in the instance it was bound to.When that function was inherited, (found on the  class, so ), it is still passed an instance of the derived class, and still has everything the derived class has.Python is very dynamic, and very flexible. You can take any old function and put it on a class, and it can be bound into a method. Or you can take any unbound function, and manually pass in an object with the right attributes, and it'll just work. Python doesn't care, really. So you can pass in a new, indepdent type of object and still have the  function work:So even passing in a class object, completely unrelated to the  hierarchy, but with the expected attribute, still works.To most Python code, if it walks like a duck, and quacks like a duck, the code will accept it as a duck. Call it duck typing.
The methods of a derived class are not available in the base class.  However, the fields are shared for any function operating on a particular object.   refers to the value of  in the object on which you are calling , regardless of how  was set.Edit because you are setting  directly in the class, outside of a function, any  will have  and any  will have .  Those values, although set on the class, are available in every instance.  That is why  works even though you never directly said .  If you wanted fish-specific colors, you would need to set  in  or .


Answer URL
https://docs.python.org/3/howto/descriptor.html
