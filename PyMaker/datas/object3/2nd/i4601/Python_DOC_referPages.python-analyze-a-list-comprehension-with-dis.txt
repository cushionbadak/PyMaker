Natural Text
Recently, I had a discussion on SO (see it for the context) about the two following pieces of code:And:Both iterate through strings  in a list  and look for  in a dict . If  is found, then the associated value is returned, else  is returned. I'm pretty sure the second piece of code is faster than the first, because (for each ) there is no lookup in the dictionary, just an iteration on the (key, value) pairs. The question is:How to check that this is really what happens under the hood?I tried, for the first time, the  module, but the result was disappointing (python 3.6.3):How do I get a more detailed information?EDITAs suggested by @abarnert in the first comment, I tried to  both solutions. I played around with the following code:Maybe I missed something but, to my surprise, the first piece of code () was always faster than the second (). Hence the secondary question: does anyone have an explanation?EDIT 2 Here are the most interesting parts of the disassembled code (with a little formatting to insert the inner loop).For :For :One can see that (again as suggested by @abarnert) the inner loop of  contains some extra cost:(hidden) the construction of the 2-uples by the iterator on an  which unpacks those 2-uples and then puts  and  on the stacktwo  which pop  and  from the stack to store them in .Before it finally loads  to compare it with  as in . This inner loop is iterated  and It seems that those operations make the difference.If this was optimized as I thought it was, the  iterator would have put first  on the stack to test , and then, only if  was true, put  on the stack for the .
You've already got all the detailed information there is about the code that evaluates the list comprehension.But list comprehensions are equivalent to creating and then calling a function. (This is how they have their own scope, so they don't, e.g., leak loop variables into the outer scope.) So that automatically-generated function named  is what you really want to see the code for.If you want to disassemble it—well, notice that  says it's loading a ? That's what you want. But we can't get to it, because all we did was compile a string for the sake of disassembling it, then throw the result away, so the listcomp function isn't around anymore. But it's pretty easy to see with real code:There's that code object const again—but now it's not just a const we compiled and immediately threw away, it's part of a function we can access.How do we access it? Well, this is documented in the  module docs, which probably isn't the first place you'd look. Functions have a code object in their  member, code objects have a sequence of constants in their  member, and we're looking for constant #1, so:Of course you have a generator expression nested inside your list comprehension, and, as you can probably guess, that's also equivalent to creating and then calling a generator function. But that generator function's code is just as easy to find (if even more tedious to type out): .


Answer URL
https://docs.python.org/3/library/inspect.html
