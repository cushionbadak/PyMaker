Natural Text
We're trying to build a wrapper script over a command line tool we're using. We would like to set some tool arguments based on options in our wrapper scripts. We would also like to have the possibility to pass native arguments to the command line tool directly as they are written on the command line.Here is what we came up with: is mandatory. Based on the options  and  we would add some extra options to our tool call. Anything that is left afterwards (if anything) should be treated as a native tool argument and given to the tool directly. Calling our script with  produces the following usage:The trick is that these native arguments are themselves options for the tool and contain leading dashes, for example  and . We already know about the trick with the double dash to stop argparse from looking for more options. The following call:produces the expected parsed arguments:Trying to add an option after the first positional argument doesn't work, though. More specifically, the following call:produces the following output:Putting the optional arguments before the positionals:seems to work, as the following is printed:Even stranger, changing the value of  for  to  works in all the above situations (with the caveat, of course, that at least one  is expected).Are we doing something wrong in our Python code or is this some kind of argparse bug?
 does have a hard time when you mix non-required positional arguments with optional arguments (see https://stackoverflow.com/a/47208725/1399279 for details into the bug report).  Rather than suggesting a way to solve this issue, I am going to present an alternative approach.You should check out the  method, which was created for the situation you describe (i.e. passing options to a wrapped tool).Unlike , the output of  is a two-element tuple. The first element is the  instance you would expect to get from , and it contains all the attributes defined by calls to . The second element is a list of all the arguments not known to the parser.I personally prefer this method because the user does not need to remember any tricks about how to call your program, or which option order does not result in errors.
This is a known issue (https://bugs.python.org/issue15112, argparse: nargs='*' positional argument doesn't accept any items if preceded by an option and another positional)The parsing alternates handling positionals and optionals.  When dealing with positionals it tries to handle as many as the input strings require.  But an  or  positional is satisfied with , an empty list of strings.   on the other hand requires at least one stringThe parser gives 'pos' to , and  to .  Then it gives '--foo' to its optional.  There aren't anymore  left to hand the remaining strings, so it raises the error.The allocation of input strings is done with a stylized form of  string matching.  Imagine matching a pattern that looks like .To correct this, parser would have to look ahead, and delay handling .  We've suggested patches but they aren't in production.@SethMMorton's suggestion of using  is a good one.Earlier parsers (e.g. Optparse) handle all the flagged arguments, but return the rest, the positionals, as a undifferentiated list.  It's up to the user to split that list.   has added the ability to name and parse , but the algorithm works best with fixed , and gets flaky with too many variable .


Answer URL
https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.parse_known_args
