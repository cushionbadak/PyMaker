Natural Text
I'm trying to calculate the area of skyline (overlapping rectangles with same baseline)sample input would be:and output is .The issue is memory efficiency, when there are lots of values, the script simply throws . Anyone have some ideas for optimizing memory usage?
The reason for getting  is huge size of the dictionary being created. In the worst case, the dict can have 10^10 keys, which would end up taking all your memory. If there really is a need,  is a possible solution to make use of such large dict.Let's say there is a building with  and another with , then that list might have info like . As you come across more buildings, you can add more entries in this list. This will be .This might help you further.
You are allocating a separate key-value pair for every single integer value in your range. Imagine the case where  and . Your  dictionary will be filled with 1000000 items. Your basic idea of processing/removing overlaps is is sound, but the way you do it is massive overkill.Like so much else in life, this is a graph problem in disguise. Imaging the vertices being the rectangles you are trying to process and the (weighted) edges being the overlaps. The complication is that you can not just add up the areas of the vertices and subtract the areas of the overlaps, because many of the overlaps overlap each other as well. The overlap issue can be resolved by applying a transformation that converts two overlapping rectangles into non-overlapping rectangles, effectively cutting the edge that connects them. The transformation is shown in the image below. Notice that in some cases one of the vertices will be removed as well, simplifying the graph, while in another case a new vertex is added:Green: overlap to be chopped out.Normally, if we have  rectangles and  overlaps between them, constructing the graph would be an  operation because we would have to check all vertices for overlaps against each other. However, we can bypass a construction of the input graph entirely to get a  traversal algorithm, which is going to be optimal since we will only analyze each rectangle once, and construct the output graph with no overlaps as efficiently as possible.  assumes that your input rectangles are sorted according to their left edges in ascending order. If that is not the case, the algorithm will be  to account for the initial sorting step. Note that as the graph density increases,  will go from  to . This confirms the intuitive idea that the fewer overlaps there are, them more you would expect the process will run in  time, while the more overlaps there are, the closer you will run to  time.The space complexity of the proposed algorithm will be : each rectangle in the input will result in at most two rectangles in the output, and .Enough about complexity analysis and on to the algorithm itself. The input will be a sequence of rectangles defined by , ,  as you have now. I will assume that the input is sorted by the leftmost edge . The output graph will be a linked list of rectangles defined by the same parameters, sorted in descending order by the rightmost edge. The head of the list will be the rightmost rectangle. The output will have no overlaps between any rectangles, so the total area of the skyline will just be the sum of  for each of the  output rectangles.The reason for picking a linked list is that the only two operations we need is iteration from the head node and the cheapest insertion possible to maintain the list in sorted order. The sorting will be done as part of overlap checking, so we do not need to do any kind of binary searches through the list or anything like that.Since the input list is ordered by increasing left edge and the output list is ordered by decreasing right edge, we can guarantee that each rectangle added will be checked only against the rectangles it actually overlaps1. We will do overlap checking and removal as shown in the diagram above until we reach a rectangle whose left edge is less than or equal to the left edge of the new rectangle. All further rectangles in the output list are guaranteed not to overlap with the new rectangle. This check-and-chop operation guarantees that each overlap is visited at most once, and that no non-overlapping rectangles are processed unnecessarily, making the algorithm optimal.Before I show code, here is a diagram of the algorithm in action. Red rectangles are new rectangles; note that their left edges progress to the right. Blue rectangles are ones that are already added and have overlap with the new rectangle. Black rectangles are already added and have no overlap with the new one. The numbering represents the order of the output list. It is always done from the right. A linked list is a perfect structure to maintain this progression since it allows cheap insertions and replacements:Here is an implementation of the algorithm which assumes that the input coordinates are passed in as an iterable of objects having the attributes , , and . The iteration order is assumed to be sorted by the left edge. If that is not the case, apply  or  to the input first:Computing the total area is now trivial:Notice the altered order of the input parameters ( moved to the end). The resulting  is . This matches with what I get by doing the computation by hand. You can also doThis is to be expected from the diagram of the inputs/output shown below:As an additional verification, I added a new building,  to the start of the list. It overlaps all the others and adds three units to , or a final result of .  comes out as:Note:While I am sure that this problem has been solved many times over, the solution I present here is entirely my own work, done without consulting any other references. The idea of using an implicit graph representation and the resulting analysis is inspired by a recent reading of Steven Skiena's Algorithm Design Manual, Second Edition. It is one of the best comp-sci books I have ever come across.1 Technically, if a new rectangle does not overlap any other rectangles, it will be checked against one rectangle it does not overlap. If that extra check was always the case, the algorithm would have an additional  comparisons to do. Fortunately,  even if we always had to check one extra rectangle (which we don't).


Answer URL
https://docs.python.org/3/library/functions.html#sorted
https://docs.python.org/3/library/stdtypes.html#list.sort
https://docs.python.org/3/library/shelve.html#module-shelve
