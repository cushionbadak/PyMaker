Natural Text
I have a list of tuples, where each  contains a  and a number in the form of:The strings are nonunique, and so are the numbers, e.g.  or  are likely to exist in the list.I'm attempting to create a dictionary with the string as the key and a set of all numbers occurring with that string as the value:I've done this somewhat successfully with the following dictionary comprehension with nested set comprehension:There's only one issue:  is 18,000 items long. This snippet of code takes less than ten seconds to run for a list of 500 tuples, but over twelve minutes to run for the full 18,000 tuples. I have to think this is because I've nested a set comprehension inside a dict comprehension.Is there a way to avoid this, or a smarter way to it?
You have a double loop, so you take O(N**2) time to produce your dictionary. For 500 items, 250.000 steps are taken, and for your 18k items, 324 million steps need to be done.Here is a O(N) loop instead, so 500 steps for your smaller dataset, 18.000 steps for the larger dataset:This uses the  method to ensure that for a given key (your string values), there is at least an empty set available if the key is missing, then adds the current  value to that set.You can do the same with a  object:The  uses the factory passed in to set a default value for missing keys.The disadvantage of the  approach is that the object continues to produce default values for missing keys after your loop, which can hide application bugs. Use  to disable the factory explicitly to prevent that.
Why are you using two loops when you could do in one loop like this:output:


Answer URL
https://docs.python.org/3/library/stdtypes.html#dict.setdefault
https://docs.python.org/3/library/collections.html#collections.defaultdict
