Natural Text
I can see two very similar ways of having properties in Python(a) Property class(b) Property decoratorQuestionAre those two pieces of code identical (e.g. bytecode wise)? Do they show the same behavior? Are there any official guides which "style" to use?Are there any real advantages of one over the other?What I've triedpy_compile + uncompyle6I've compiled both:and then decompiled both with uncompyle6. But that just returned exactly what I started with (with a bit different formatting)import + disI triedI'm super confused by the output of :whereas the first one was way bigger:Where does that difference come from? Where is the value range check for the first example?
You want to use the decorator, always. There is no advantage to the other syntax, and only disadvantages.The point of decoratorsThat's because the decorator syntax was invented specifically to avoid the other syntax. Any examples you find of the  variety is usually in code that predates decorators.Decorator syntax is syntactic sugar; the formis executed a lot likewithout  being assigned to twice (the  part creates a function object and assigns to  normally, but with a decorator the function object is created and passed directly to the decorator object).Python added this feature because when your function body is long, you can't easily see that the function has been wrapped with a decorator. You'd have to scroll down past the function definition to see that, and that's not very helpful when almost everything else you'd want to know about a function is right at the top; the arguments, the name, the docstring are right there.From the original PEP 318 â€“ Decorators for Functions and Methods specification:The current method of applying a transformation to a function or method places the actual transformation after the function body. For large functions this separates a key component of the function's behavior from the definition of the rest of the function's external interface.[...]This becomes less readable with longer methods. It also seems less than pythonic to name the function three times for what is conceptually a single declaration.and under Design Goals:The new syntax should[...]move from the end of the function, where it's currently hidden, to the front where it is more in your faceSo usingis far more readable and self documenting than No namespace pollutionNext, because the  decorator replaces the function object you decorate with the decoration result (a  instance), you also avoid namespace pollution. Without  and  and , you have to add 3 extra, separate names to your class definition that then no-one will ever use:Imagine a class with 5, or 10 or even more property definitions. Developers less familiar with the project and an auto-completing IDE will surely get confused by the difference between ,  and , and you end up with code that mixes styles and makes it harder to now move away from exposing these methods at the class level.Sure, you can use  right after the  assignment, but that's yet more extra code to execute for no real purpose.Confusing method namesAlthough you can avoid having to prefix the accessor names with  and  or otherwise differentiate between the names to create a  object from them, that's still how almost all code that doesn't use the  decorator syntax ends up naming the accessor methods.And that can lead to some confusion in tracebacks; an exception raised in one of the accessor methods leads to a traceback with  or  in the name, while the preceding line used . It may not always be clear to the Python property novice how the two are connected, especially if they missed the  line further down; see above.Accessing to the accessors, how to inheritYou may point out that you may need access to those functions anyway; for example when overriding just the getter or a setter of for the property in a subclass, while inheriting the other accessor.But the  object, when accessed on the class, already gives you references to the accessors, via the ,  and  attributes:and you can reuse the  /  /  syntax in a subclass without having to remember to create a new  object!With the old syntax, it was commonplace to try to override just one of the accessors:and then wonder why it would not be picked up by the inherited  object.With the decorator syntax, you'd use:and the  subclass then is given a new  instance with the getter inherited from , and with a new setter.TLDRUse the decorator syntax. It is self-documentingIt avoids namespace pollutionIt makes inheriting accessors from properties cleaner and more straightforward
The results of the two versions of your code will be almost exactly the same. The property descriptor you have at the end will be functionally identical in both cases. The only difference in the descriptors will be in the function names you can access if you really try (via ), and that you might see in an exception traceback, if something goes wrong.The only other difference is the presence of the  and  methods after you're done. When you use , you won't have those methods cluttering up the namespace. If you build the  object yourself manually, they will remain in the class namespace, and so you can call them directly if you really want to instead of using normal attribute access via the  object.Unusually the  syntax is better since it hides the methods, which you usually don't need. The only reason I can think of that you might want to expose them is if you expect to pass the methods as callbacks to some other function (e.g. ). You could just use a  though for the callback though (), so I don't think it's worth polluting a nice API with extraneous getter and setter methods just for this corner case.


Answer URL
https://docs.python.org/3/library/timeit.html#module-timeit
