Natural Text
Have a bunch of lists that are converted from a .txt file that have been read as a collection of strings that look like:These lists have differing numbers of side-by-side words (the first has 2 the second has 3, etc..)I want to output a new list (then into a compiled dataframe) that joins the words together that are side-by-side like:Which will make the new list (and dataframe) of the same length.It's easy to just  into a new list for each string but can't figure out the if-statement and .join() needed to join all words and append each number separately.
Using , you can group by , join strings conditionally, and then chain the results:
I am basically looping through the strings in list1. If it happens to be a word I append it to list2, or else it's appended to list3. The method isdigit() returns true if the string consists of only digits. And finally append all the contents of list2 to answer as a single string using 'join', and use extend to add all elements of list3 to the end of answer[].

You can write you own function to make concatenation, for example:output:
You can use :This outputs:
I suggest the following steps:1) Find the indeces for word entrees 2) If you have two or more consecutive indeces that are not numeric, append themCase:At this point I'm stumped on a way to do this without a for loop, so I'll just use a for loop:This will get you through any given list. You can put it into a function and apply it to many lists. The code above will work as is, so you can copy to Python (I'm using 2.7) to see for yourself. 
Use list comprehension and join non-digit items in one index, and then unpack a list comprehension for the digits. 


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.groupby
