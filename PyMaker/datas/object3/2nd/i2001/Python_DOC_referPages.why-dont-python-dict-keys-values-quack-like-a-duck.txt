Natural Text
Python is duck typed, and generally this avoids casting faff when dealing with primitive objects.The canonical example (and the reason behind the name) is the duck test: If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.However one notable exception is dict keys/values, which look like a duck and swim like a duck, but notably do not quack like a duck.Can someone enlighten me as to why this is?
There is an explicit check for  type (or its children) in python source code (so even  doesn't qualify):so python can compute size very quickly and reallocate the result without trying all containers or iterate on the right hand to find out, providing very fast list addition.One way to workaround this is to use in-place extension/addition:because in that case, in-place add iterates on the right hand side: so every collection qualifies.(or of course force iteration of the right hand: )So it could accept any type but I suspect that the makers of python didn't find it worth it and were satisfied with a simple & fast implementation which is used 99% of the time.
Dict keys actually implements the set's interface rather than the list's, so you can perform set operations with dict keys directly with other sets:But it doesn't implement the , , , and  methods, which are required to "quack" like a list, so it cannot perform any of the list operations without being explicitly converted to a list first:
If you go into the definition of  the you can see the following. Or use this statement:It clearly mentions that the output is  object. Now you are trying to append a set to a list. You need to convert the set into list and then append it.


Answer URL
https://docs.python.org/3/library/collections.abc.html#module-collections.abc
