Natural Text
If a module is imported from a script without a main guard (), doing any kind of parallelism in some function in the module will result in an infinite loop on Windows. Each new process loads all of the sources, now with  not equal to , and then continues execution in parallel. If there's no main guard, we're going to do another call to the same function in each of our new processes, spawning even more processes, until we crash. It's only a problem on Windows, but the scripts are also executed on osx and linux.I could check this by writing to a special file on disk, and read from it to see if we've already started, but that limits us to a single python script running at once. The simple solution of modifying all the calling code to add main guards is not feasible because they are spread out in many repositories, which I do not have access to. Thus, I would like to parallelize, when main guards are used, but fallback to single threaded execution when they're not.How do I figure out if I'm being called in an import loop due to a missing main guard, so that I can fallback to single threaded execution?Here's some demo code:lib with parallel code:Good importer (with guard):Bad importer (without guard):where the bad importer fails with this RuntimeError, over and over again:
Since you're using , you can also use it to detect if you're the main process or a child process. However, these features are not documented and are therefore just implementation details that could change without warning between python versions. Each process has a ,  and . You can check any of them to see if you're in the main process or not. In the main process  will be ,  will be , and  will be ).My solution allows you to continue using , but just modifies child processes so they can't keep creating child processes forever. It uses a decorator to change  to a no-op in child processes, but returns  unchanged in the main process. This means when the spawned child process tries to execute  nothing will happen (as if it had been executed inside a  guard.


Answer URL
https://docs.python.org/3/library/os.html#os.spawnl
