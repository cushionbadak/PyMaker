Natural Text
I'm developing packages and uploading development/testing/etc versions of my packages to a local devpi server.  In order to prevent an accidental upload to PyPi, I'm adopted the common practice of:which works great, but what about when I'm finally ready to upload the package to PyPi?I've come up with a totally ugly, but simple hack which requires that I define the classifiers as a global variable outside of the setup() call which looks like:Another, and perhaps simpler option is to merely comment out the "Private :: Do not Upload", but that doesn't seem any more professional than my hack.What I'd like to do is create a proper subclass of the upload command called  and have it check for the  cmd-line option. Perhaps, as a build may exist prior to uploading,  might be a better option.Unfortunately, I'm having trouble understanding the setuptools documentation on creating custom commands.Does anyone have any idea how to implement this?  It's not clear to me if a custom command has access to the parameters passed to , i.e. could it directly manipulate the  passed to , or would if it require that a user of the command follow the convention of defining of CLASSIFIERS as a global variable yuck?
Going backwards on your questions; while it's really broad, the topic is still constrained enough.I can tell you that the classifiers are not manipulated, but rather read from the  and then written to  file by the  command, which in turn looks for all  entry_points which the  function will do the actual writing.  As far as I can tell, trying to leverage that Classifier outside will not be a great way, however you can override everything and anything you want through  so you can make your own  function, figure out how to read the metadata (which you can see in the main  method) and manipulate that further before upload_file finally reads it.  At this point you probably are thinking that manipulating and working with this system is going to be rather annoying.As I mentioned though, everything can be overridden.  You can make an upload command that take the public flag, like so:The accompanied  might look something like this.Install that as a package into your environment and the upload command will be replaced by your version.  Example run:Try again with the public flagWhich is fine, since I didn't create any dist files at all.  You could of course further extend that command by rewriting the  method (make a copy in your code) and change the parts to do what you want in your subclass (like injecting the private classifier there), up to you.You might also be wondering why the class names are in lower case (violation of pep8), this is due to legacy stuff and how the help for a given command is generated.Using a "properly" named class (e.g. ; remember to also update the  in the  to point to this new class name)of course if this output is the intent, the standard class naming convention can be used instead.Though to be perfectly honest, you should not specify upload at all on your production, but rather do this on your build servers as part of post-push hook, so when the project is pushed (or tagged), build is done and the file is loaded onto your private servers, and then only further manual intervention (or automatic if specific tags are pushed) will then get the package up to pypi.  However the above example should get you started in what you originally set out to do.One last thing: you can just change  to your private devpi location, if the  flag is not set.  You could either override this before calling the  method (through your customized version), or do it in ; so rather than quitting, your code could just verify that the repository url is not the public PyPI instance.  Or alternatively, manipulate the distribution metadata (i.e. the classifiers) via  ( being the  instance).  You can of course create a completely new command to play with this to your hearts content (by creating a new  subclass, and add a new entry_point for that).


Answer URL
https://docs.python.org/3/distutils/examples.html#reading-the-metadata
