Natural Text
I've been hunting for something that could be relatively stupid to some people, but to me very interesting! :-)Input and output errors have been merged with  in Python 3.3, so there's a change in the exception class hierarchy. One interesting feature about the builtin class  is that, it returns a subclass of it when passed  and As you can see passing  and  to the constructor of  returns  instance which is a subclass of .Python Doc: The constructor often actually returns a subclass of OSError, as described in OS exceptions below. The particular subclass depends on the final errno value. This behaviour only occurs when constructing OSError directly or via an alias, and is not inherited when subclassing.I wanted to code a subclass that would behave in this way. It's mostly curiosity and not real world code. I'm also trying to know, where's the logic that creates the subclass object, is it coded in  for example? If  contains the logic for creating the instances of the subclasses, then inheriting from  would typically return this behavior, unless if there's some sort of type checking in :There must be type checking then: I've been digging through C code to find out where's this code is placed exactly and since I'm not an expert in C, I suspect this is really the logic and (I'm quite skeptical about that to be frank): exceptions.cNow I'm wondering about the possibility of expanding  from Python itself without playing with C code, so that  can make instances of user-defined classes, if you ask me why would you do that? I would say, just for fun. 
You're correct that  is the variable that holds the mapping from errno values to  subclasses, but unfortunately it's not exported outside the  source file, so there's no portable way to modify it.It is possible to access it using highly non-portable hacks, and I present one possible method for doing so (using a debugger) below purely in a spirit of fun. This should work on any x86-64 Linux system.Quick explanation of how this works:Attach a debugger to the current Python process (), in unattended mode (), discarding output () and in the background (), allowing Python to continue running.When the Python program accesses any dictionary, break if the key is an  with a magic value (used as  later); if it isn't an int, we've just raised , so suppress it.When this happens, we know the dictionary being looked up in is the ; store it as an attribute on the  module.
You can't change the behavior of  from Python because it's not implemented in Python.For classes implemented in Python, you can write  so it only returns a subclass if it's being called on the base class. Then the behavior won't be inherited.


Answer URL
https://docs.python.org/3/library/exceptions.html#os-exceptions
https://docs.python.org/3/c-api/dict.html#c.PyDict_GetItem
https://docs.python.org/3/c-api/long.html#c.PyLong_AsLongLong
https://docs.python.org/3/c-api/exceptions.html#c.PyErr_Clear
https://docs.python.org/3/c-api/sys.html#system-functions
