Natural Text
I'm using Python to split a string of 2 bytes . The string of bytes is stored in a variable called .Why when I say  do I get  but when I say  I get the expected answer of .Should both of these operations not be exactly the same?What I did:
In Python 3,  is a sequence type containing integers (each in the range 0 - 255) so indexing to a specific index gives you an integer.And just like slicing a list produces a new list object for the slice, so does slicing a  object produce a new  instance. And the representation of a  instance tries to show you a  literal syntax with the integers represented as either printable ASCII characters or an applicable escape sequence when the byte isn't printable. All this is great for developing but may hide the fact that bytes are really a sequence of integers.However, you will still get the same piece of information;  is a one-byte long  value with the  byte in it, and  will give you the integer :What you really did was not use , you used  instead. Passing in a single integer to the  type creates a new  object of the specified length, pre-filled with  bytes:Since  produces the integer 1, you told  to return a new bytes value of length 1, filled with  bytes.From the  documentation:Bytes objects are immutable sequences of single bytes.[...]While bytes literals and representations are based on ASCII text, bytes objects actually behave like immutable sequences of integers, with each value in the sequence restricted such that .[...]In addition to the literal forms, bytes objects can be created in a number of other ways:A zero-filled bytes object of a specified length: Bold emphasis mine.If you wanted to create a new  object with that one byte in it, you'll need to put the integer value in a list first:
Yes, you should get the same thing. In both cases .  is probably not what you think it is.


Answer URL
https://docs.python.org/3/library/stdtypes.html#bytes
