Natural Text
I'm trying to create a Python-based CLI that communicates with a web service via websockets. One issue that I'm encountering is that requests made by the CLI to the web service intermittently fail to get processed. Looking at the logs from the web service, I can see that the problem is caused by the fact that frequently these requests are being made at the same time (or even after) the socket has closed:In my CLI I define a class  that is responsible for handling all direct communication with the web service. Internally, it uses the  package to handle communication, which itself is built on top of . contains the following method for sending requests:...where  is a websocket opened earlier in another method:What I want is to be able to await the future returned by  and, if necessary, sleep for a short while after in order to give the web service time to process the request before the websocket is closed.However, since  is a synchronous method, it can't simply  these futures. Making it asynchronous would be pointless as there would be nothing to await the coroutine object it returned. I also can't use  as the loop is already running by the time it is invoked.I found someone describing a problem very similar to the one I have at mail.python.org. The solution that was posted in that thread was to make the function return the coroutine object in the case the loop was already running:This is not possible for me, as I'm working with PyRx (Python implementation of the reactive framework) and  is only called as a subscriber of an Rx observable, which means the return value gets discarded and is not available to my code:On a side note, I'm not sure if this is some sort of problem with  that's commonly come across or whether I'm just not getting it, but I'm finding it pretty frustrating to use. In C# (for instance), all I would need to do is probably something like the following:Meanwhile, 's version of "wait" unhelpfully just returns another coroutine that I'm forced to discard.UpdateI've found a way around this issue that seems to work. I have an asynchronous callback that gets executed after the command has executed and before the CLI terminates, so I just changed it from this......to this:I'd still be happy to receive any answers to this problem for future reference, though. I might not be able to rely on workarounds like this in other situations, and I still think it would be better practice to have the delay executed inside  so that clients of  do not have to concern themselves with timing issues.In regards to Vincent's question:Does your loop run in a different thread, or is send_request called by some callback?Everything runs in the same thread - it's called by a callback. What happens is that I define all my commands to use asynchronous callbacks, and when executed some of them will try to send a request to the web service. Since they're asynchronous, they don't do this until they're executed via a call to  at the top level of the CLI - which means the loop is running by the time they're mid-way through execution and making this request (via an indirect call to ).Update 2Here's a solution based on Vincent's proposal of adding a "done" callback.A new boolean field  is added to  to represent if comms activity is occurring or not. is modified to set  true before sending the request, and then provides a callback to  to reset  once done: is now implemented to wait for this flag to be set false before progressing:This seems to work too, and at least this way all communication timing logic is encapsulated within the  class as it should be.Update 3Nicer solution based on Vincent's proposal.Instead of  we have .New  implementation:New  implementation:
You could use a  of tasks:Schedule the tasks using  and clean up using :And wait for the  of tasks to complete:
Given that you're not inside an asynchronous function you can use the  keyword to effectively implement  yourself. The following code will block until the future returns:


Answer URL
https://docs.python.org/3/library/asyncio-task.html
