Natural Text
Why does this code work with threads but not processes?The docs do warn:Calling Executor or Future methods from a callable submitted to a ProcessPoolExecutor will result in deadlock.The docs don't seem to mention raising an exception, so does it mean  somehow discovered the deadlock and resolved it by killing both processes?More importantly, why is this deadlock unavoidable with processes (and avoidable with threads), and what is the workaround if I want to use multiple processes with futures, without being so restricted?
When using threads the memory is shared between all threads and that's why wait_on_b can access b.Using processes, A new memory space is created for each process (copy of the old one in fork mode) so You will get a copy of b with a broken PIPE since it is not the real b (just a copy)BTW: on windows there is no fork, so b (the memory is totally new) does not exists and you'll get a 


Answer URL
https://docs.python.org/3/library/concurrent.futures.html#processpoolexecutor
