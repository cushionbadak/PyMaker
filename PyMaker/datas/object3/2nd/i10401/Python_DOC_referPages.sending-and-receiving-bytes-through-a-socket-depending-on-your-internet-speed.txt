Natural Text
I made a quick program that sends a file using sockets in python.Server:Client:From experience a learn that send can send an amount of bytes that your networkspeed is capble of sending them. If you give for example: sock.send(20 gb) you are going to lose bytes because most network connections can't send 20 gb atonce. You must send them part by part.So my question is: How can i know the maximum amount of bytes that socket.send()can send over the internet? How can i improve my program to send the file as quick as possible depending on my internet speed?
 makes no guarantees that all the data is sent (it's not directly tied to network speed; there are multiple reasons it could send less than requested), just that it lets you know how much was sent. You could explicitly write loops to  until it's all really sent, per Dunno's answer.Or you could just use  and avoid the hassle.  is basically the wrapper described in the other answer, but Python does all the heavy lifting for you.If you don't care about slurping the whole file into memory, you could use this to replace your whole loop structure with just:If you're on modern Python (3.5 or higher) on a UNIX-like OS, you could optimize a bit to avoid even reading the file data into Python using  (which should only lead to partial  on error):If the Python doesn't support  on your OS, this is just a effectively a loop that s and s repeatedly, but on a system that supports it, this directly copies from file to socket in the kernel, without even handling file data in Python (which can improve throughput speeds significantly by reducing system calls and eliminating some memory copies entirely).
Just send those bytes in a loop until all were sent, here's an example from the docsIn your case,  would be 1024, and since you're not using a class, you don't need the self argument
There are input/output buffers at all steps along the way between your source and destination.   Once a buffer fills, nothing else will be accepted on to it until space has been made available.As your application attempts to send data, it will fill up a buffer in the operating system that is cleared as the operating system is able to offload that data to the network device driver (which also has a buffer).   The network device driver interfaces with the actual network and understands how to know when it can send data and how receipt will be confirmed by the other side (if at all).   As data is sent, that buffer is emptied, allowing the OS to push more data from its buffer.   That, in turn, frees up room for your application to push more of its data to the OS.There are a bunch of other things that factor into this process (timeouts, max hops are two I can think off offhand), but the general process is that you have to buffer the data at each step until it can be sent to the next step.
From experience a learn that send can send an amount of bytes that  your network speed is capble of sending them.Since you are using a TCP Socket (i.e. SOCK_STREAM), speed-of-transmission issues are handled for you automatically.  That is, once some bytes have been copied from your buffer (and into the socket's internal send-buffer) by the send() call, the TCP layer will make sure they make it to the receiving program, no matter how long it takes (well, within reason, anyway; the TCP layer will eventually give up on resending packets if it can't make any progress at all over the course of multiple minutes).If you give for example: sock.send(20 gb) you are going to lose bytes  because most network connections can't send 20 gb at once. You must  send them part by part.This is incorrect; you are not going to "lose bytes", as the TCP layer will automatically resend any lost packets when necessary.  What might happen, however, is that send() might decide not to accept all of the bytes that you offered it.  That's why it is absolutely necessary to check the return value of send() to see how many bytes send() actually accepted responsibility for -- you cannot simply assume that send() will always accept all the bytes you offered to it.So my question is: How can i know the maximum amount of bytes that  socket.send() can send over the internet?You can't.  Instead, you have to look at the value returned by send() to know how many bytes send() has copied out of your buffer.  That way, on your next call to send() you'll know what data to pass in (i.e. starting with the next byte after the last one that was sent in the previous call)How can i improve my program to send the file as quick as possible  depending on my internet speed?Offer send() as many bytes as you can at once; that will give it the most flexibility to optimize what it's doing behind the scenes.  Other than that, just call send() in a loop, using the return value of each send() call to determine what bytes to pass to send() the next time (e.g. if the first call returns 5, you know that send() read the first 5 bytes out of your buffer and will make sure they get to their destination, so your next call to send() should pass in a buffer starting at the 6th byte of your data stream... and so on).  (Or if you don't want to deal with that logic yourself, you can call sendall() like @ShadowRanger suggested; sendall() is just a wrapper containing a loop around send() that does that logic for you.  The only disadvantage is that e.g. if you call sendall() on 20 gigabytes of data, it might be several hours before the sendall() call returns!  Whether or not that would pose a problem for you depends on what else your program might want to accomplish, if anything, while sending the data).That's really all there is to it for TCP.If you were sending data using a UDP socket, on the other hand, things would be very different; in the UDP case, packets can simply be dropped, and it's up to the programmer to manage speed-of-transmission issues, packet resends, etc, explicitely.  But with TCP all that is handled for you by the OS.
@Jeremy FriesnerSo I can do something like that:Is this correct?Also, from this example i undestood one more think. The data you can send in every loop, can't be bigger in size than your memory. Because you are bringing bytes from the disk on the memory. So theoretically even if your network speed is infinity, you can't send all the bytes at once if the file is bigger than your memory.


Answer URL
https://docs.python.org/3/library/socket.html#socket.socket.sendall
https://docs.python.org/3/library/socket.html#socket.socket.sendfile
