Natural Text
I have a list of integers as follows:What I want is to have this as a list os strings, indexed and 'compressed', that is, with each element indicated by its position in the list and with each successive duplicate element indicated as a range, like this:EDIT: The expected output should indicate that list elements 0 to 3 have the number 2, element 3, the number 3, element 5, the number 4, elements 6 and 7, the number 2, elements 8 and 9, number 4, and element 10, number 3. EDIT 2: The output list need not (indeed cannot) be a list of integers, but a list of strings instead.I could find many examples of finding (and deleting) duplicated elements from lists, but nothing along the lines of what I need.Could someone point out a relevant example or suggest an algorithm for solving this?Thanks in advance!
Like most problems involving cascading consecutive duplicates, you can still use groupby() for this. Just group indices by the value at each index.Output:
Here is a lazy version that works on any sequence, and yields slices. Thus it's generic and memory efficient.Usage :Why slices? Because it's convenient (can be used as-is for indexing) and the semantics (upper bound not included) are more "standard". Changing that to tuples or string with upper bound is easy btw.
You could use enumerate with a generator functionOutput:I was going to use  groupby but will be faster.
Construct the list with number of consecutive occurences with the item. Then iterate the list and get the list with the range of index of each item.
First off, your requested results are not valid python.  I'm going to assume that the following format would work for you:Given that, you can first transform  into a list of  tuples, then use  to gather that into ranges:This does the following:transform the list into  tuples:use  to merge adjacent items with the same value:  If the list being built has at least 1 item and the last item in the list has the same value as the item being processed, reduce it to the list minus the last item, plus a new item consisting of the first index from the last list item plus the second index of the current item and the value of the current item.  If the list being built is empty or the last item in the list is not the same value as the item being processed, just add the current item to the list.Edited to use  instead of  as my lambda parameter; using  as a parameter or variable name is bad form
Here's a generator-based solution similar to Padraic's.  However it avoids -based index tracking and thus is probably faster for huge lists.  I didn't worry about your desired output formatting, either.It would be used like this:Resulting in output of:
Some good answers here, and thought I would offer an alternative. We iterate through the list of numbers and keep an updating  value, associated with a list of indicies for that value . We then look-ahead one element to see if the consecutive number differs from , if it does we go ahead and add it as a 'compressed number'. Sample Output:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.groupby
