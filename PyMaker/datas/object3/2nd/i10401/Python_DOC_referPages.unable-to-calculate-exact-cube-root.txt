Natural Text
This question already has an answer here:Is floating point math broken?                    28 answers                I'm solving some cryptographic problem,I need the  cube root of , which gives me usingI thought it was weird at first, so I did try:but got I have even tried somewhere else. But i got the same result. Is there something wrong? How can I calculate the true cube root?
Due to floating-point arithmetic, this is hard to represent.Using decimal somewhat resolves it but is still problematic in certain numbers, and allows rounding only to integrals. Try using a decimal like so:
This is normal when dealing with floating-point numbers on a computer. No decimal fraction can be represented precisely in binary, which deals in negative powers of 2, so you need to get used to getting very close approximations.In this specific case, if you know your result is supposed to be an integer, simply use .
Both answers are correct within the accuracy of the hardware's numerical representation.  1/3 is a repeating "decimal" in binary: 0.010101010101...It can't be represented precisely.If you want a "true" cube root, you need to implement an algorithm that handles the round-off problems and corner cases you find useful.  Given the representation problem, you could certainly cover integer cubes.  However, noting even simple cases, such as cube_root(1.728) => 1.2, would be problematic: neither decimal number converts precisely to binary.
As discussed in other answers, this is due to the limited precision of floating point numbers. It's just not possible to exactly represent values, unless your math is done symbolically. If you are fine with limited precision but just need more precision than the built in datatypes give you, I suggest an arbitrary precision arithmetic library, such as this one.


Answer URL
https://docs.python.org/3/library/decimal.html
