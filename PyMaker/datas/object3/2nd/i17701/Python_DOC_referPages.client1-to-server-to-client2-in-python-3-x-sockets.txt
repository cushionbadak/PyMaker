Natural Text
I've been working with a project that involves sending information to a public server (to demonstrate how key-exchange schemes work) and then sending it to a specific client. There is only two clients. I'm hoping to get pushed in the right direction on how to get information from client(1) to the server, then have the server redirect that information to client(2). I've messed with the code somewhat, getting comfortable with how to send and recieve information from the server, but I have no idea (~2 hours of research so far) how to differentiate clients and send information to specific clientsMy current server code (pretty much unchanged from the python3 docs:My client code (pretty much unchanged from the python3 docs:
First, a base  can't even talk to two clients at the same time. As the docs explain:These four classes process requests synchronously; each request must be completed before the next request can be started.As the same paragraph tells you, you can solve that problem by using a forking or threading mix-in. That's pretty easy.But there's a bigger problem. A threaded  server creates a separate, completely independent, object for each connected client, and has no means of communicating between them, or even letting them find out about each other. So, what can you do?You can always build it yourself. Put some kind of shared data somewhere, and some kind of synchronization on it, and all of the threads can talk to each other the same way any threads can,  or otherwise.For your design, a  has all the magic built in for everything we need: client 1 can  a message on the queue (whether client 2 has shown up yet or not), and client 2 can  a message off the same queue (automatically waiting around if the message isn't there yet), and it's all automatically synchronized.The big question is: how does the server know who's client 1 and who's client 2? Unless you want to switch based on address and port, or add some kind of "login" mechanism, the only rule I can think of is that whoever connects first is client 1, whoever connects second is client 2, and anyone who connects after that, who cares, they don't belong here. So, we can use a simple shared flag with a  on it.Putting it all together:If you want to build a more complicated chat server, where everyone talks to everyone… well, that gets a bit more complicated, and you're stretching  even farther beyond its intended limits.I would suggest either (a) dropping to a lower level and writing a threaded or multiplexing server manually, or (b) going to a higher-level, more-powerful framework that can more easily handle interdependent clients.The stdlib comes with a few alternatives for writing servers, but all of them suck except for —which is great, but unfortunately brand new (it requires 3.4, which is still in beta, or can be installed as a back-port for 3.3). If you don't want to skate on the bleeding edge, there are some great third-party choices like  or . All of these options have a higher learning curve than , but that's only to be expected from something much more flexible and powerful.


Answer URL
