Natural Text
This question already has an answer here:What do (lambda) function closures capture?                    6 answers                I wanted to play around with anonymous functions so I decided to make a simple prime finder. Here it is:What I find however, is that the  in the  is accessed each time, while i want it to be a literal number. how can I get it to become  instead?
You can "capture" the  when creating the lambdaThis will set the  in the lambda's context equal to whatever  was when it was created.  you could also say  if you wanted, it's not exactly capture, but it gets you what you need.Without this, as you've seen, it's going to look for an  in the enclosing scopeIt's an issue of lookup that's analogous to the following with defined functions:
The problem is that each of those functions in  is referring to the variable .More commonly, you do this inside a function, in which case you have a local-to-the-defining-scope variable , which gets stored in a closure, as nicely explained in These Nasty Closures.But here, it's even simpler:  is a global variable, so there is no closure. The functions are compiled to look up  as a global variable when run. Since  has changed, the functions will see the changed value when they run. Simple as that.The traditional way around this (which works for both closures and globals) is fondly known as "the default-value hack", even though it's not really a hack. (See the explanation in the FAQ.) Ryan Haining's answer explains how to do this:This creates a parameter named , with a default value equal to the value of  at the time the function is created. Then, inside the function, when you access parameter , and you get that value.A different way around this, which may seem more familiar if you're using to languages like JavaScript, is to create a function-creating function, and pass the value of  as an argument to that function-creating function, as in user2864740's answer:This avoids "polluting" the signature of the function with an extra parameter (that someone could accidentally pass an argument to), but at the cost of creating and calling a function for no good reason.A third way around this is to use . In cases where all you're trying to do is partially apply a function, using  instead of defining a wrapper function as a  can be cleaner.Unfortunately, in this case, the function is hidden inside an operator, and the function  that exposes it doesn't take keyword arguments, so you can't usefully partial its second operand. So, this is a bad solution in this case. If you really wanted to, you could just write a wrapper that behaves better and  that:In this case, I think you're better off with the other solutions; just keep this one in your head for cases where it is appropriate.
Create a new function that returns the lambda. Then call that, passing in  as an argument. This will create a new binding scope.


Answer URL
https://docs.python.org/3/faq/programming.html#why-are-default-values-shared-between-objects
https://docs.python.org/3/faq/programming.html#why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result
