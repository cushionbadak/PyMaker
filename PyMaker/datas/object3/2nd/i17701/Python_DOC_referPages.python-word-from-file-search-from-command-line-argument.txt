Natural Text
I've a text file(test.txt) which has 6-7 lines. 3-4 of them has the word "exception" in them. Also among these 3-4 lines, 2 of them also has the word "abc" in them. My task is to write a program by whose output I will be able to separate the lines containing any word the user inputs(word1) but not those lines which have both (word1) and (word2-e.g "abc": this will also be an input from the user) in it and write it in a new file(test_mod.txt). I have to do this from command line argument. So this is my command from the command prompt:"fileinput4.py test.txt test_mod.txt abc exception"Here the lines containing both "abc" and "exception" will be excluded and the lines containing only the word "exception" will be included and copied in test_mod.txt.So far I've exception handled the following things:1. Showing error message if two words are same.2.Showing error message if less than 5 parameters.3.Showing error message if the first filename is misspelled4. Showing error message if input filename and output filename are same.I also want to exception handle if somebody enters some words which are not at all in the text file. But some bug is there in my code and this thing is not happening. Please help.Whenever I am typing any word that is not in the file, nothing is getting printed and a new file is getting created without any error message which I want to prevent.Here's my code:
An elaboration on my comment:The code  doesn't mean what you think it does. You think it means "if  is in  or  is in ". However, this isn't correct.Let's look at a simple example:The line  doesn't mean "if  is in  or  is in ." It means TrueFalse[0, 1, 2, 3, 4]`".In other words, the code means - .  is always true, so during execution of the code, the intepreter never bothers to check if . It just sees the , and proceeds to the body of the  statement.The same thing happens in your code. However, it is less obvious. What you need to know is that Python inteprets all sorts of values as  or  in certain contexts, not just the Booleans  and , which are what an expression like  or  evaluates to.For the builtin types, such as lists, integers, floats and strings, every value evaluates to a  when a Boolean is needed (you can do this explicitly by calling the function  an object), except for "empty" values. So , and . In your code,  is almost always a non-empty string (or at least you haven't tested the program with it as an empty string and  not in . This shows the importance of thorough testing.To fix this, you could replace that line with  (parentheses added for readability). But better (IMHO) would be to do this - . This worth knowing as it is much quicker if you are doing similar tests but with larger amounts of variables (e.g. a 3, 4, 5 and 6).Also, as mentioned in the comments, you should take a look at the argparse module. This would make what you want much more simple to achieve.Edit:Try this:Although you should really rewrite your code so you don't open the file for each line in the first file.Example file handling:Example file:Example code:Here is a tutorial for file-handling, and here is a tutorial for argparse.


Answer URL
