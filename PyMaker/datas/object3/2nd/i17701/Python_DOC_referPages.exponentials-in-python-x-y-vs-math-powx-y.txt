Natural Text
Which one is more efficient using math.pow or the ** operator? When should I use one over the other?So far I know that  can return an  or a  if you use a decimalthe function  will return a float
Using the power operator  will be faster as it won’t have the overhead of a function call. You can see this if you disassemble the Python code:Note that I’m using a variable  as the exponent here because constant expressions like  are actually evaluated at compile time.Now, in practice, this difference does not matter that much, as you can see when timing it:So, while  and  are about twice as slow, they are still fast enough to not care much. Unless you can actually identify the exponentiation as a bottleneck, there won’t be a reason to choose one method over the other if clarity decreases. This especially applies since  offers an integrated modulo operation for example.Alfe asked a good question in the comments above: shows that  is slower than  in all cases. What is  good for anyway? Has anybody an idea where it can be of any advantage then?The big difference of  to both the builtin  and the power operator  is that it always uses float semantics. So if you, for some reason, want to make sure you get a float as a result back, then  will ensure this property.Let’s think of an example: We have two numbers,  and , and have no idea if they are floats or integers. But we want to have a float result of . So what options do we have?We can convert at least one of the arguments to a float and then do .We can do  and convert the result to a float (float exponentation is automatically used when either  or  are floats, so the result is the same).We can use .So, let’s test this:As you can see,  is actually faster! And if you think about it, the overhead from the function call is also gone now, because in all the other alternatives we have to call .In addition, it might be worth to note that the behavior of  and  can be overridden by implementing the special  (and ) method for custom types. So if you don’t want that (for whatever reason), using  won’t do that.
Just for the protocol: The  operator calls the built-in  function which accepts an optional third argument (modulus) if the first two arguments are integer types.So, if you intend to calculate remainders from powers, use the built-in function. The  may give you false results:When I ran this, I got  in the first case which obviously cannot be true, because 13 is odd (and therefore all of it's integral powers). The  version uses limited accuracy which causes an error. For sake of fairness, we must say,  can be much faster:Here is what I'm getting as output:Some online exampleshttp://ideone.com/qaDWRd (wrong remainder with )http://ideone.com/g7J9Un (lower performance with  on int values)http://ideone.com/KnEtXj (slightly lower performance with  on float values)
Well, they are for different tasks, really.  Use  (equivalent to  with two arguments) when you want integer arithmetic.  And use  if either argument is float, and you want float output.  For a discussion on the differences between  and , see this question.
 is indeed faster then , but if you want a simple quadratic function like in your example it is even faster to use a product.will be faster then The difference is not big and not noticable with one operation (using ), but with a large number of operations it can be significant.


Answer URL
