Natural Text
I'm using Python 3.3, testing this on Windows. I don't understand something. Why when I do:I'm getting errorandThere is no request, so it looks solid. However when importing submodule request:It seems to workAnd now automagically  shows:Why I don't see after  all submodules? According to http://docs.python.org/3.3/library/urllib.html#urllib.urlopen it should be , , , . Does it differ in other OSes?
When you arewhat you are really doing is looking for name  defined in . So if someone explicitly put some names there you can use it. Otherwise you can't.Look at the Python  library for example (github). You canIt's here because in  there is an explicit  or similar statement.It's not a Python 3 issue actually. You run into it in Python 3 because it uses packages for standard library not just a plain modules like Python 2. And  is currently empty for some reason so you need to explicitly  exact modules like  to use them. For some standard packages Python 3  some of the "submodules" in corresponding  files. Maybe it's just for backward compatibility though.Another question is why after just  your  shows other modules like . Looks like all the modules from the same package used internally by  become available after . If you just  you don't get  because  not uses it. All of this become more understandable if you check the source code of Python importing system - it's full of side effects (e.g. "caching" imported modules using global  dictionary).
 is a package. Importing a package won't automatically import the modules the package contains; you need to explicitly import the  module.
Lets have a look at . As stated in documentation, it lists names defined in module - and packages module is its .  is not defined in s , so it won't be listed.And now, for "how packages work" - package is some kind of directory-based module. It is loaded from its , but allows for submodules and subpackages (being files and directories in the same directory as ). Now, when you load package (e.g. ) you don't load ("load" meaning "execute its code") all files and directories in it, but only it's "initializer" (think of  as  method of the class, but for module - in the end module and class are both objects, right?).Comparison to class is quite good - when you create object, you call only it's , method, not all of its attributes (methods are attributes too). Also, attributes can be functions or fields. Fields can also have attributes. To clarify: is for package what  is for objectsubmodule is for package what method (function attribute) is for objectsubpackage is for package what field (non-function attribute) is for object.Why?  takes care of setting objects up, submodules/methods are ways of storing logic in one place, and subpackages/fields are ways of organizing other submodules/methods or sub-subpackages/fields.To be frank: it doesn't work like this in CPython implementation, but it is quite good model for understanding how it will behave.


Answer URL
