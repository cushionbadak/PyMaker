Natural Text
Say I import a module as follows:and then wanted to find the working directory is now a stand in for , and using  won't work.  This is all dandy, and works for me. However, I noticed something a little odd.  If I import  as I do above, and then get a list of all imported modules, here's what happens:This is not what I expected.  According to the docs .  To me, this means it should list .  Why doesn't  contain  instead of ?Additionally, is there an equivalent list to  which would contain ?EDIT: I guess the larger question here is the rationale.  If Python is going to keep  as the module, why delete the reference? (ie, why don't both  and  work?)Or, more simply put, why doesn't  behave the same as  followed by ?
You seem to be confused about the module object and the references to that object.  is one reference to the module object, and  is another.When you use the statement , Python makes sure the  module is loaded into memory (using the  dictionary as a cache) then creates a reference to the module object in your current namespace. Because you used  Python sees that you want to use the name  and binds the module to that name.Had you used , then Python would have defaulted to the same name as the module, so it binds the object to  in your local namespace.You are in no way restricted here. You can still bind the same object to other names too:would give you another reference to the same module object.Remember that your module global namespace is only global to the module; other modules don't see the same names. As such you want to control what names are defined in it. Perhaps you wanted use the name  for something else entirely. The following is legal:and I would expect  to still be bound to the string, not the module.At the same time, another module in my Python project can still use  and have  refer to the module; it won't see the string bound to  in the first module.
Because the name of the module is . You did .  just tells Python to assign that module to the name  in your module's namespace. is a cache of imported modules to prevent modules from being imported more than once. If it stored the imported module under , another module that did  would import the module again.
From the documentation:The basic import statement (no from clause) is executed in two steps:find a module, loading and initializing it if necessarydefine a name or names in the local namespace for the scope where the import statement occurs.In particular, the second step means:If the requested module is retrieved successfully, it will be made available in the local namespace in one of three ways:If the module name is followed by as, then the name following as is bound directly to the imported module.This implies that the name under which your module is available will be present in  or :
 contains the true names of the imported modules.  However, it does not contain the names they were imported under using .In other words, when you do:the  module is in fact imported.  However, it is imported under the name of .  Nevertheless, the name  is still added to  because that is the true name of the imported module.   though is not added because it is not a module.  Instead, it is an alternate name for the  module that was imported.
You imported . Then you put it to the name . Here is a simple illustration of what's happening:The module imported is still , not , so it will be the one listed in .And yes,  is a module since it's bound to a module object.


Answer URL
