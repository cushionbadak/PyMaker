Natural Text
Can I extend syntax in python for dict comprehensions for other dicts, like the OrderedDict in  module or my own types which inherit from ?  Just rebinding the  name obviously doesn't work, the  comprehension syntax still gives you a plain old dict for comprehensions and literals.  So, if it's possible how would I go about doing that?  It's OK if it only works in CPython.  For syntax I guess I would try it with a  prefix like we have on the .note:  Of course we can use a generator expression instead, but I'm more interested seeing how hackable python is in terms of the grammar.
There is no direct way to change Python's syntax from within the language. A dictionary comprehension (or plain display) is always going to create a , and there's nothing you can do about that. If you're using CPython, it's using special bytecodes that generate a dict directly, which ultimately call the  API functions and/or the same underlying functions used by that API. If you're using PyPy, those bytecodes are instead implemented on top of an RPython  object which in turn is implemented on top of a compiled-and-optimized Python . And so on.There is an indirect way to do it, but you're not going to like it. If you read the docs on the import system, you'll see that it's the importer that searches for cached compiled code or calls the compiler, and the compiler that calls the parser, and so on. In Python 3.3+, almost everything in this chain either is written in pure Python, or has an alternate pure Python implementation, meaning you can fork the code and do your own thing. Which includes parsing source with your own PyParsing code that builds ASTs, or compiling a dict comprehension AST node into your own custom bytecode instead of the default, or post-processing the bytecode, or…In many cases, an import hook is sufficient; if not, you can always write a custom finder and loader.If you're not already using Python 3.3 or later, I'd strongly suggest migrating before playing with this stuff. In older versions, it's harder, and less well documented, and you'll ultimately be putting in 10x the effort to learn something that will be obsolete whenever you do migrate.Anyway, if this approach sounds interesting to you, you might want to take a look at MacroPy. You could borrow some code from it—and, maybe more importantly, learn how some of these features (that have no good examples in the docs) are used.Or, if you're willing to settle for something less cool, you can just use  to build an "odict comprehension macro" and use that. (Note that MacroPy currently only works in Python 2.7, not 3.x.) You can't quite get , but you can get, say, , which isn't too bad. Download , , and , and run  to see it working. The key is this code, which takes a  AST, converts it to an equivalent  on key-value s, and wraps it in a  to :A different alternative is, of course, to modify the Python interpreter.I would suggest dropping the  syntax idea for your first go, and just making normal dict comprehensions compile to odicts. The good news is, you don't really need to change the grammar (which is beyond hairy…), just any one of:the bytecodes that dictcomps compile to,the way the interpreter runs those bytecodes, orthe implementation of the  typeThe bad news, while all of those are a lot easier than changing the grammar, none of them can be done from an extension module. (Well, you can do the first one by doing basically the same thing you'd do from pure Python… and you can do any of them by hooking the .so/.dll/.dylib to patch in your own functions, but that's the exact same work as hacking on Python plus the extra work of hooking at runtime.)If you want to hack on CPython source, the code you want is in , , and , and the dev guide tells you how to find everything you need. But you might want to consider hacking on PyPy source instead, since it's mostly written in (a subset of) Python rather than C.As a side note, your attempt wouldn't have worked even if everything were done at the Python language level.  creates a binding named  in your module's globals, which shadows the name in builtins, but doesn't replace it. You can replace things in builtins (well, Python doesn't guarantee this, but there are implementation/version-specific things-that-happen-to-work for every implementation/version I've tried…), but what you did isn't the way to do it.
Sorry, not possible. Dict literals and dict comprehensions map to the built-in dict type, in a way that's hardcoded at the C level. That can't be overridden.You can use this as an alternative, though:Addendum: as of Python 3.6, all Python dictionaries are ordered. As of 3.7, it's even part of the language spec. If you're using those versions of Python, no need for OrderedDict: the dict comprehension will Just Work (TM).
Slightly modifying the response of @Max Noel, you can use list comprehension instead of a generator to create an OrderedDict in an ordered way (which of course is not possible using dict comprehension).


Answer URL
https://docs.python.org/3/whatsnew/3.7.html#what-s-new-in-python-3-7
