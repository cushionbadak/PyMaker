Natural Text
i have a multithreaded program (about 20 threads; a mixture of producer/consumers with many queues)in one of the threads, it pops strings from a queue and send it to a remote programintermittently, my program will just hang, none of the threads are doing any workafter trial and error, i found that my program only hangs with this thread runningmy only guess is that sendall() is hogging the GIL and my whole program hangs1) is this even a plausible theory?2) if my theory is correct, what can i do so that sendall() doesnt hog the GIL? make it a nonblock send?
You're wrong. No network activities hold GIL and sendall() is not an exception!Because sendall() may take long time and other threads which use workQ can not take turn to run before you call task_done() ==> this is why it seems that your whole program is in hang.
GIL-hogging will not cause a program to hang.  It may harm the performance of the program, but this is a far cry from hanging.  It is much more likely that you are experiencing some form of deadlock.  The GIL cannot participate in a deadlock because the interpreter is constantly releasing and re-acquiring it, acquiring or releasing the GIL is generally not dependent on acquiring or releasing any other resources, and other locks do not depend on the GIL either.Your use of the  lock is rather peculiar.  It would be more common for the master to simply put a series of "we're done, go home" objects into the queue, and for the workers to detect these objects and return when they are recognized.  This also ties into the rule of thumb that the only correct values for  are zero and infinity (i.e. no timeout).  In the current case, your worker is waiting for one second, checking the event, waiting for one second, etc., and polling is a Bad Thing.Now, if by "hang" you mean the program occasionally freezes up for short periods of time before resuming, that is poor performance, so perhaps the GIL could be to blame.  But the socket is not the problem.  The problem is that you may have a large number of threads contending for the GIL (because they're all trying to poll once per second), and if you're still on 2.x, you don't have the new GIL.  Eliminating the polling will help with this.


Answer URL
https://docs.python.org/3/whatsnew/3.2.html#multi-threading
