Natural Text
I have the following problem. It starts with a list which I get. Let's say for example I got the list:  (The list can be longer or even shorter e.g. ). It can also have more entries than four or less. Now I first have to sort for the rank. The rank is defined as the number of digits, that you see.In A I have one string of rank two  and one of rank three . (In B I have three of rank three) Now I need to get the number of four binary digits numbers which I get with all of the lowest rank strings first. Here I have only one rank two string I can produce: . So I get 4 binary numbers for rank two. With  I get  and . But I already got the second one by the rank two string. So the number I should get is 5 for rank three. That is the number of distinct strings I get with rank two and rank three.I think its a tough problem but guess there are some commands which I don't know that could help. Hope you can give me some hints :) 
If I understand your question, you want to sort by the number of fixed digits ("rank") first, then compute the total number of unique possible bit strings at or below each rank. So for , you'd want it sorted to  (putting lower rank first), and you'd want to get the number of unique patterns for all rank 2 and lower patterns (in this case, there is only one), then for all rank 3 and lower patterns (again, in this case, only one), etc.If that understanding is correct, the first step is sorting:After that, you process by ranks using , generating unique outputs with  and storing them in a  so you remove duplicates:Which for your  would output:If you want to avoid gaps, and output for all ranks out to the maximum length of the patterns, it's slightly more complicated (since  only produces groups when there is at least one input with that "key", in this case, at least one input of a given rank):


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.groupby
https://docs.python.org/3/library/itertools.html#itertools.product
