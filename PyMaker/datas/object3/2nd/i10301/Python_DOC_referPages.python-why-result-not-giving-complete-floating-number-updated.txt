Natural Text
This question already has an answer here:Why does the floating-point value of 4*0.1 look nice in Python 3 but 3*0.1 doesn't?                    4 answers                I am newbie to python.I have one surprise result after executing following mathematical operation:= then  =  should be  as per above operation.but python return .i am not understanding why this difference is?i am using Python 2.7.6 Please see attached image.i know that if i use ) then it will give My question are1. why all digits of second operation is not displayed but all digit of first one's displayed?how can we compare floating variables those values are dynamic for accurate result?
Python uses a minimalist  for s when possible. That is, it prints a value that is as precise as necessary to reproduce the exact value of the original  if you typed it in directly.For , the imprecision means it doesn't actually produce  precisely ( will evaluate to ). By contrast,  is exact enough that  represents it precisely, ( evaluates to ) so it doesn't include a whole bunch of s that aren't required to reproduce the value.If you want to explicitly print a certain number of places after the decimal, use  formatting to specify, e.g.:If you formatted it with additional digits, you'd see the , but that value is still exactly the same as ;  evaluates to , so Python avoids the verbosity and just gives you shortest of many equivalent representations.The What's new in Python 3.1 docs (scroll to end of linked section, just before "New, Improved and Deprecated Modules") are a useful explanation for why/when Python 2.7/3.1+ have much shorter  s for some values. Straight from the horse's mouth, so to speak.


Answer URL
https://docs.python.org/3/whatsnew/3.1.html#other-language-changes
