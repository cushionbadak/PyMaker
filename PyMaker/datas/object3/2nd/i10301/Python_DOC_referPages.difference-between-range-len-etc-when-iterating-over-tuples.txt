Natural Text
One thing upfront: I am fairly now to the coding world so maybe my question is a bit stupid ... I was trying to write a function that returns the every other element of a tuple. The easiest way obviously is I tried to solve it differently by using the following codeBut that doesn't give me back anything at all.I thought I (if used over ) gives back the position, so if  the return would be .What's the  iterating over when used with ,  or -in that case- while iterating over ?
Python's  loop is a foreach construct; it'll loop over a sequence or iterable and bind the target variable ( in your case) to each element in that sequence one by one.So for , with each iteration,  is bound to the next value from the tuple. If you used a  object, then looping over that object would produce integers in the range, from start (defaulting to ) up to the end value minus 1 (the end value is excluded).Your code, however, doesn't loop over ; you try to loop over the result of , which will be a single integer. That gives a  exception.If you want to use the  type, that's fine, but then you'll have to translate the index back into a value from  by using indexing:Here  produces the value at index ; where  is so index , , etc, so you get every odd element. Note that this differs from , which starts at  and includes every even-numbered element! Python starts counting at , so take that into account when counting out elements.You can avoid having to index back in by using the  function; for every element in a sequence it'll produce a tuple with an ever-increasing index number. Let's use that to fix the odd-even issue, mixing in some  augmented assignment too:You don't really need the  parentheses here either, tuples are formed by commas (except for the empty tuple, and use parentheses when the comma could mean something else, like in a function call).
Try that on for size.  The  statement gives us the tuple values one by one, and the  b lets us skip every other one.  The best way to do this is the way you put at the top of your post. If you don't understand what it's doing, then I suggest researching list slicing.
Will raise an error because  returns an integer which can not be iterated over in a  loop.In the case of:In each iteration of the loop  will be an integer starting from 0 and up to the length of your tuple - 1.In the case of:Each  will be a member of the tuple. The best way to get used to how these things work is to just pop open an interactive interpreter and do some experiments!
The  will not give you the index instead it will return the value.You can solve your problem simply by defining a local variable that can be incriminated for each iteration and use that to get the odd indexed values.Summery: Use a local variable to act as an index as Python for will return the value.
Here is an example you can use to finish the program.len -> gives you the length of a object ; eg. if you say len(myTup). That will be 8Range -> is like a range, (number of elements) you will be iterating over. i -> is the index. Here is the output You can get the same output above by running the code without using range and len.


Answer URL
https://docs.python.org/3/library/stdtypes.html#ranges
https://docs.python.org/3/library/functions.html#enumerate
