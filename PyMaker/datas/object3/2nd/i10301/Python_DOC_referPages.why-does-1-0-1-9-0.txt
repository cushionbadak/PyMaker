Natural Text
This question already has an answer here:Integer division compared to floored quotient: why this surprising result?                    1 answer                In Python  and , why does integer division give me a non-correct number when dividing by a number ?Negative numbers  even work correctly:I understand that integer division with a negative (or positive) number rounds toward negative infinity, however I would have thought  should result in  since  can be divided by  without remainder.
What you’re seeing here is essentially the effect of the difference between “normal” division using  and flooring division with .What’s also always important to keep in mind is the general issue with floating point arithmetic which is a certain imprecision just because of how they work. In those situations, it’s always good to use the  module to check what’s actually going on. So let’s look at what you are doing here:First of all,  is already not precise:So, let’s look at the actual result of the divisions:As you can see, the normal division using  does not exactly give you  with floating point arithmetic. But it’s really close. That’s why, when you use normal floats, you actually get back 10 (since the division imprecision is immediately lost in the imprecision of the number type).When using flooring division, the result is floored before the imprecision is corrected, so that’s why you get :With negative numbers, the flooring effect is the opposite direction, as explained in that other question:


Answer URL
https://docs.python.org/3/library/decimal.html
