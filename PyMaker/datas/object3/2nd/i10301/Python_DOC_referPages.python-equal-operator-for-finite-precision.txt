Natural Text
I have been asked to test a library provided by a 3rd party. The library is known to be accurate to n significant figures. Any less-significant errors can safely be ignored. I want to write a function to help me compare the results:The purpose of this function is to determine if two floating-point numbers (a and b) are approximately equal. The function will return True if a==b (exact match) or if a and b have the same value when rounded to sigfig significant-figures when written in decimal. Can anybody suggest a good implementation? I've written a mini unit-test. Unless you can see a bug in my tests then a good implementation should pass the following:Additional notes:Values a and b might be of type int, float or numpy.float64. Values a and b will always be of the same type. It's vital that conversion does not introduce additional error into the function.Lets keep this numerical, so functions that convert to strings or use non-mathematical tricks are not ideal. This program will be audited by somebody who is a mathematician who will want to be able to prove that the function does what it is supposed to do.Speed... I've got to compare a lot of numbers so the faster the better.I've got numpy, scipy and the standard-library. Anything else will be hard for me to get, especially for such a small part of the project.
There is a function  in  (source here) which may be a good starting point. 
As of Python 3.5, the standard way to do this (using the standard library) is with the  function.It has the following signature:An example of usage with absolute error tolerance:If you want it with precision of n significant digits, simply replace the last line with:
Here's a take.
I believe your question is not defined well enough, and the unit-tests you present prove it:If by 'round to N sig-fig decimal places' you mean 'N decimal places to the right of the decimal point', then the test  should fail, because even when you round 1000000000 and 1000000001 to 0.00001 accuracy, they are still different.And if by 'round to N sig-fig decimal places' you mean 'The N most significant digits, regardless of the decimal point', then the test  should fail, because 0.000000001 and -0.000000001 are totally different when viewed this way.If you meant the first definition, then the first answer on this page (by Triptych) is good.If you meant the second definition, please say it, I promise to think about it :-)
There are already plenty of great answers, but here's a think:
"Significant figures" in decimal is a matter of adjusting the decimal point and truncating to an integer.  
This is a fairly common issue with floating point numbers. I solve it based on the discussion in Section 1.5 of Demmel[1]. (1) Calculate the roundoff error. (2) Check that the roundoff error is less than some epsilon. I haven't used python in some time and only have version 2.4.3, but I'll try to get this correct.Step 1. Roundoff errorStep 2. Floating point equalityThere are a couple obvious deficiencies with this code.Division by zero error if the exact value is Zero.Does not verify that the arguments are floating point values.Revision 1.That's a little better. If either the exact or the approximate value is zero, than the error is equal to the value of the other. If something besides a floating point value is provided, a TypeError is raised.At this point, the only difficult thing is setting the correct value for epsilon. I noticed in the documentation for version 2.6.1 that there is an epsilon attribute in sys.float_info, so I would use twice that value as the default epsilon. But the correct value depends on both your application and your algorithm.[1] James W. Demmel, Applied Numerical Linear Algebra, SIAM, 1997.
Oren Shemesh got part of the problem with the problem as stated but there's more:assert nearlyequal( 0.0, 1e-15, 5 ) also fails the second definition (and that's the definition I learned in school.)No matter how many digits you are looking at, 0 will not equal a not-zero.  This could prove to be a headache for such tests if you have a case whose correct answer is zero.
There is a interesting solution to this by B. Dawson (with C++ code)at "Comparing Floating Point Numbers".  His approach relies on strict IEEE representation of two numbers and the enforced lexicographical ordering when said numbers are represented as unsigned integers.
There are lots of ways of comparing two numbers to see if they agree to N significant digits. Roughly speaking you just want to make sure that their difference is less than 10^-N times the largest of the two numbers being compared. That's easy enough.But, what if one of the numbers is zero? The whole concept of relative-differences or significant-digits falls down when comparing against zero. To handle that case you need to have an absolute-difference as well, which should be specified differently from the relative-difference.I discuss the problems of comparing floating-point numbers -- including a specific case of handling zero -- in this blog post:http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/
I have been asked to test a library provided by a 3rd partyIf you are using the default Python  framework, you can use 


Answer URL
https://docs.python.org/3/library/math.html#math.isclose
https://docs.python.org/3/library/unittest.html#module-unittest
https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertAlmostEqual
