Natural Text
I am currently trying to understand where the difference between using  and  is when it comes to custom classes. There are numerous websites that say that using the '+'-operator results in using the special method  - which is fine so far.But when i run the following example I get two different results.Result:Now from what I understood, when executing  Python checks/executes the int  method - finds that there is no implementation for adding int and C objects - returns NotImplemented - which lets Python know to check object C for  and executes the code within.Why does  result in executing the  code but the other two version are just returning  without checking  ??
 is equivalent to . It starts by calling  and then, if necessary, . But , then  is called first.Based on the docs on "special" methods:Regarding : is called to implement the binary arithmetic "+" operation. For instance, to evaluate the expression x + y, where x is an instance of a class that has an  method,  is called. If one of those methods does not support the operation with the supplied arguments, it should return NotImplemented.Regarding :These functions are only called if the left operand does not support the corresponding operation and the operands are of different types. For instance, to evaluate the expression x + y, where y is an instance of a class that has an  method,  is called if  returns NotImplemented.If the right operand’s type is a subclass of the left operand’s type and that subclass provides the reflected method for the operation, this method will be called before the left operand’s non-reflected method. This behavior allows subclasses to override their ancestors’ operations.Explanation with the examples based on the behaviour:Case 1:These functions  are only called if the left operand does not support the corresponding operation and the operands are of different types. In this case,  does not support addition of the class hence, it falls back to the  function of the  class. In case  was not implement in  class, it would have fallen back to Case2: gives  as  is of  type and  of  class do not supports  with C class object. But  run because  class supports that.Case 3:Similar to . But here, the call is made via class with first argument as object of that class. Behaviour would be same.Case 4: Vice-versa of . As is cleared from the stack-trace,  expected the object of the calling class as the first argument, failing which resulted in exception.


Answer URL
https://docs.python.org/3/reference/datamodel.html#special-method-names
https://docs.python.org/3/reference/datamodel.html#object.__add__
https://docs.python.org/3/reference/datamodel.html#object.__radd__
