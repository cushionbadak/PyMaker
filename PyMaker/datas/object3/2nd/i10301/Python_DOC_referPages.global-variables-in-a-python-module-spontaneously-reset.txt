Natural Text
I have part of a program written in Python 3.5 and started by testing the first two modules. I managed to isolate a problem in one of the modules where it appears that two global variables are switching back to their original values for no reason that I can understand. One of these global variables () is used in only a single function (grep shows the string "event_count" doesn't appear anywhere else in any of my *.py files), yet the value of the variable changes between calls to the function. If I add print statements for the other global variable in this module, it also reverts to it's original value at the same moment. Moving  to another module (replacing it with  in  and moving the initialization to the other module) makes the behavior go away, so I have a fix but no understanding.Here is all of the code that uses , in module :If I run the following code segment:(the last action in  is a call to ) it produces this output:I have tried trimming down the two modules to something of reasonable size, but the problem keeps going away when I do so. I'll keep working on that. Since I've never used Python 3 before, and only have a little Python 2.7 experience I assume I'm doing something stupid, I just have no idea what.I believe that my example is different from some of the related posts that have been pointed out in that the variable  is global only so it will be static. It is used only in this single function. The string "event_count" doesn't appear anywhere else in this or any other module.After many edit/rerun iterations, I have a managably small example that demonstrates what is happening. It involves two modules with a total of 8 lines of code. The first module, , is :The second module is :Running  produces the output:I expected  to still be 1 from the  in .Also, I tried to reduce this further by deleting the  from , but then the example no longer runs:I can't explain that, either, but it seems likely to be related.Following Mata's lead, I believe that the following code shows what's going on. There are three modules involved. :::You can see the problem by running , giving the result:Running  so that  isn't part of the import cycle results in:
Let's take a look at your two-module example step-by-step. The behavior there is expected, but initially confusing and probably explains what is going on pretty well in the other cases.If you run  as a script, it is not imported as  into , but rather as . The first statement is , which creates an empty module object  and begins initializing it.The first line of  imports  again. Normally, a module object under  would be found, but in this case, you are running  as a script, so the initial import happened under a different name. Since the name of  is  and not  this time,  is set to zero and nothing else happens.Now execution returns to . It now creates a function , which sets  to one. I wrote out the reference to the  module very explicitly because this is the root cause of your discrepancy.Once  is imported, execution returns back to , but not . The next line,  actually sets  to zero. Hopefully you see the problem at this point. The next line calls , which sets  to one. Then you print , which is zero, as expected.To verify the correctness of this exposition, try adding a print statementYou will get . Also,  will be . The easiest way to get around this is not to initialize members of other modules in a given module's import.Your specific case is documented here: http://effbot.org/zone/import-confusion.htm#using-modules-as-scripts.Additional ResourcesYou can get a lot more information on the gritty details of the import system here: https://docs.python.org/3/reference/import.html. Various traps and caveats of imports are described here: http://python-notes.curiousefficiency.org/en/latest/python_concepts/import_traps.html.


Answer URL
https://docs.python.org/3/reference/import.html
