Natural Text
I recently attempted Googles  foo.bar challenge. After my time was up I decided to try find a solution to the problem I couldn't do and found a solution here  (includes the problem statement if you're interested). I'd previously been making a dictionary for every function I wanted to cache but it looks like in this solution any function/input can be cached using the same syntax. Firstly I'm confused on how the code is even working, the *args variable isn't inputted as an argument (and prints to nothing). Heres an modified minimal example to illustrate my confusion:Here I use the same memoize function but with a print. The function example returns memoize(n, a lambda function,). The function longrun is just an identity function with lots of useless computation so it's easy to see if the cache is working (example(2) will take ~5 seconds the first time and be almost instant after). Here are my confusions:Why is the third argument of memoize empty? When args is printed in memoize it prints (). Yet somehow mem[key] stores func(*args) as func(key)?Why does this behavior only work when using the lambda function (example will cache but example2 won't)? I thought lambda: longrun(n) is just a short way of giving as input a function which returns longrun(n).As a bonus, does anyone know how you could memoize functions using a decorator?Also I couldn't think of a more descriptive title, edits welcome. Thanks.
The notation  stands for a variable number of positional arguments. For example,  can be used as , ,  and so on. Similarly,  stands for a variable number of keyword arguments.Note that the names  and  are just a convention - it's the  and  symbols that make them variadic.Anyways,  uses this to accept basically any input to func. If the result of func isn't cached, it's called with the arguments. In a function call,  is basically the reverse of  in a function definition. For example, the following are equivalent:If  is empty, then calling  is the same as calling  - no arguments are passed to it.Functions and lambda functions are the same in python. It's simply a different notation for creating a function object.The problem is that in , you are not passing a function. You call a function, then pass on its result. Instead, you have to pass on the function and its argument separately.Now, some implementation details: why is  empty and why is there a separate key?The empty  comes from your definition of the lambda. Let's write that as a function for clarity:Note how  takes no arguments. The parameter  is bound from the containing scope as a closure, bound from the containing scope. As such, you don't have to pass it to memoize - it is already bound inside the . Thus,  is empty in memoize, even though  does receive a parameter, because the two don't interact directly.Now, why is it , not ? That's actually slightly the wrong question; the right question is "why isn't it ?".Memoization works because the same input to the same function leads to the same output. That is,  identifies your output. Ideally, your  would be  as that's the only relevant information.The problem is you need a way to look up  and  inside . If you ever tried putting a  inside a , you know there are some types which don't work in mappings (or any other suitable lookup structure, for that matter). So if you define , you cannot memoize functions taking mutable/unhashable types. Python's  actually has this limitation.Defining an explicit  is one way of solving this problem. It has the advantage that the caller can select an appropriate key, for example taking  without any modifications. This offers the best optimization potential. However, it breaks easily - using just  misses out the actual function called. Memoizing a second function with the same input would break your cache.There are alternative approaches, each with pros and cons. Common is the explicit conversion of types:  to ,  to , and so on. This is slow, but the most precise. Another approach is to just call  or  as in , but it relies on every value having a proper .


Answer URL
https://docs.python.org/3/tutorial/controlflow.html#arbitrary-argument-lists
https://docs.python.org/3/tutorial/controlflow.html#defining-functions
https://docs.python.org/3/library/functools.html#functools.lru_cache
https://docs.python.org/3/tutorial/controlflow.html#arbitrary-argument-lists
