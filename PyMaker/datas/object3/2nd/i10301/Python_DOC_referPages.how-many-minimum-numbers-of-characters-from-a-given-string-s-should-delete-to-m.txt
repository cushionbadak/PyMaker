Natural Text
This question already has an answer here:How to determine the longest increasing subsequence using dynamic programming?                    14 answers                I need to find the minimum number of deletions required to make string sorted.Sample Test case:I tried the following but it gives time limit exceeded error. Any other approach to this problem?
Your current algorithm will give incorrect results for many strings.I suspect that there's a more efficient way to solve this problem, but here's a brute-force solution. It generates subsets of the input string, ordered by length, descending. The elements in the subsets retain the order from the original string. As soon as  finds an ordered subset it returns it (converted back into a string), as well as the number of deletions. Thus the solution it finds is guaranteed to be no shorter than any other sorted selection of the input string.Please see the  docs for info about the various  functions I've used; the algorithm for generating subsets was derived from the  example in the Recipes section.outputThat data set is not really adequate to fully test algorithms designed to solve this problem, but I guess it's an ok starting point. :)UpdateHere's a Python 3 implementation of the algorithm mentioned by Salvador Dali on the linked page. It's much faster than my previous brute-force approach, especially for longer strings.We can find the longest sorted subsequence by sorting a copy of the string and then finding the Longest Common Subsequence (LCS) of the original string & the sorted string. Salvador's version removes duplicate elements from the sorted string because he wants the result to be strictly increasing, but we don't need that here.This code only returns the number of deletions required, but it's easy enough to modify it to return the actual sorted string.To make this recursive function more efficient it uses the  decorator from functools.output
Hope it works for all cases :)


Answer URL
https://docs.python.org/3/library/itertools.html
https://docs.python.org/3/library/itertools.html#itertools-recipes
https://docs.python.org/3/library/functools.html#functools.lru_cache
