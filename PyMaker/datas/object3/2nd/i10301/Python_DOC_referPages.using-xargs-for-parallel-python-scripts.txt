Natural Text
I currently have a bash script, script.sh, with two nested loops. The first enumerates possible values for a, and the second enumerates possible values for b, likeSo this spawns off 100 Python processes running script.py, one for each (a,b) pair. However, my machine only has 5 cores, so I want to cap the number of processes at 5 to avoid thrashing/wasteful switching. The goal is that I am always running 5 processes until all 100 processes are done.xargs seems to be one way to do this, but I don't know how to pass these arguments to xargs. I've checked other similar questions but don't understand the surrounding bash jargon well enough to know what's happening. For example, I triedbut this doesn't seem to do anything - script.sh runs as before and still spawns off 100 processes.I assume I'm misunderstanding how xargs works.Thanks!
This would actually look more like:Note that there's no , nor any  -- to track the number of concurrent invocations,  needs to be directly executing the Python script, and that process can't exit until it's complete.The non-standard (but widely available)  extension requires input to be in NUL-delimited form (as created with ); this ensures correct behavior with arguments having spaces, quotes, backslashes, etc.The likewise non-standard  sets the maximum number of processes (in a way slightly more portable than , which is supported on GNU but not modern BSD xargs).The  indicates that each instance of the Python script receives only two arguments, thus starting one per pair of inputs.The  (used in conjunction with ) indicates that if a single Python instance can't be given two arguments (for instance, if the arguments are so long that both can't fit on a single command line), this should be treated as a failure, rather than invoking a Python instance with only one argument.
If you use bash, then the following should work:
GNU Parallel is made for exactly these kinds of jobs:If you need $a and $b placed differently you can use {1} and {2} to refer to the two input sources:GNU Parallel is a general parallelizer and makes is easy to run jobs in parallel on the same machine or on multiple machines you have ssh access to. It can often replace a  loop.If you have 32 different jobs you want to run on 4 CPUs, a straight forward way to parallelize is to run 8 jobs on each CPU:GNU Parallel instead spawns a new process when one finishes - keeping the CPUs active and thus saving time:InstallationIf GNU Parallel is not packaged for your distribution, you can do a personal installation, which does not require root access. It can be done in 10 seconds by doing this:For other installation options see http://git.savannah.gnu.org/cgit/parallel.git/tree/READMELearn moreSee more examples: http://www.gnu.org/software/parallel/man.htmlWatch the intro videos: https://www.youtube.com/playlist?list=PL284C9FF2488BC6D1Walk through the tutorial: http://www.gnu.org/software/parallel/parallel_tutorial.htmlSign up for the email list to get support: https://lists.gnu.org/mailman/listinfo/parallel


Answer URL
https://docs.python.org/3/library/multiprocessing.html
