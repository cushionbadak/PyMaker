Natural Text
http://docs.python.org/2/reference/expressions.html#operator-precedenceMy guess is that it falls into one of the buckets above dict lookups sincedoes the dictionary lookup first.Is there a better chart than my initial link that goes into more detail regarding order of operations in python?
The unpacking  is not an operator; it's part of the call syntax. It's defined under Calls, where you can see that:… can be part of an  in two different places. (The semantics are described in the paragraphs starting "If there are more positional…" and "If the syntax…".)So it takes any . You can see that no operator takes a full  as its direct argument. So, if you want to loosely consider  an operator, it binds more loosely than any operator. But just remember that it isn't actually an operator.Also keep in mind that this was all changed in Python 3.x. But the basic idea is the same—both argument unpacking and assignment unpacking take an , not just a , and therefore loosely-speaking bind more loosely than any operator, which all take a  or something more specific.Meanwhile, you might want to try running the parser on your code to see what it does:You can see that the entire  expression ends up as the  to the .The  module uses the Abstract Grammar rather than the one described in the reference manual. It has different names for things, and doesn't handle some things that are considered part of the grammar but actually done at a higher level than the parser, and so on—but, on the other hand, it's a lot easier to take in all at once. You can see that an  used for  can be a .
As BrenBarn mentioned in the comments, the unpacking is defined as part of function calls (Python 2 and 3) and assignment statements (Python 3).So no, it will never take part of the operator precedence because it isn’t an operator.How do I know that this won't try to unpack "mydict" in this example? Or is this something that the language parser handles.In your example, , the specification for the function call applies. So let’s try to parse that manually.The base part is matched by the definition of , so  is the . And in the argument list, it will be parsed as , with  being the expression. As such, the parser will never apply the unpacking first, because the grammar simply doesn’t specify a case where after  another part in brackets follows.


Answer URL
