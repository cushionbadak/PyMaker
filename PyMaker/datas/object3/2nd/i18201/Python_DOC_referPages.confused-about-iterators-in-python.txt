Natural Text
I am studying python with the book Beginning Python: From Novice to Professional, and I get confused about the section discussing . There is an example in this section:To be honest, I only know that  is an object with methods  and , but have no idea about what happens in each step of the loop. And I made a test:This makes me much more confused! Why the boolean value of  is ? And why  become 1597 after the execution of the loop?(Is the method  automatically called in the loop?) Thanks in advance.
Line 1 creates a Fibs() object, calling . Line 2 calls , which returns an iterator object (in this case, just fibs itself). The interpreter will then begin calling the  method repeatedly; it returns , a plain number, which is assigned to the loop variable  (so of course it's not a Fibs() object and certainly not the one named fibs). When that value reaches 1000, the if clause will fire, print the result, and break out of the loop.
And why fibs.a become 1597 after the execution of the loop?Well this is because it is going through the Fibonacci sequence and this is the first number over 1000 in the sequence.0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987,  1597, 2584 ...
On enter to the loop interpreter calls  method. On every loop step interpreter calls  method of .
implicitly calls  and binds  to all the objects that it yields, in turn. None of these objects are instances of , let alone equal to . The whole is (roughly) equivalent to( and  are the clean ways to call  and , respectively.)
Yes, the loop automatically calls .The  loop does this to the given object:The  function calls , and the  function calls ; these functions offer some extra functionality and are the proper way of calling into the iterator API.So, in each loop iteration,  is assigned the value that the  method returned.You can also see that  is its own iterator;  returns . Other types can return a dedicated iterator object; lists do, for example:Returning dedicated iterators lets you create multiple 'views' on an object where each iterator maintains its own position, like nested loops:or you can explicitly reuse the iterator:


Answer URL
