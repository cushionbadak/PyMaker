Natural Text
Let's say we have a dict that will always have keys first_name and last_name but they may be equal to None. We want to save the first name if it is passed in or save it as an empty string if None is passed in. vsBoth of these work, however, what is the difference behind the scenes? Is one more efficient than the other?
What is the difference between the two following expressions?vsThe primary difference is that the first, in Python, is the conditional expression, The expression  first evaluates the condition,  rather  than . If  is true,  is evaluated and its value is returned;  otherwise,  is evaluated and its value is returned.while the second uses the boolean operation:The expression  first evaluates ; if  is true, its value is  returned; otherwise,  is evaluated and the resulting value is  returned.Note that the first may require two key lookups versus the second, which only requires one key lookup.This lookup is called subscript notation:Subscript notation exercises the  method of the object referenced by .It requires both the name and the subscript argument to be loaded.Now, in the context of the question, if it tests as  in a boolean context (which a non-empty string does, but  does not) it will require a second (redundant) loading of both the dictionary and the key for the conditional expression, while simply returning the first lookup for the boolean  operation.Therefore I would expect the second, the boolean operation, to be slightly more efficient in cases where the value is not .Abstract Syntax Tree (AST) breakdownOthers have compared the bytecode generated by both expressions.However, the AST represents the first breakdown of the language as parsed by the interpreter.The following AST demonstrates that the second lookup likely involves more work (note I have formatted the output for easier parsing):versusBytecode analysisHere we see that the bytecode for the conditional expression is much longer. This usually bodes poorly for relative performance in my experience.For the boolean operation, it's almost half as long:Here I would expect the performance to be much quicker relative to the other. Therefore, let's see if there's much difference in performance then.PerformancePerformance is not very important here, but sometimes I have to see for myself:We see that when the name is in the dictionary, the boolean operation is about 10% faster than the conditional.However, when the name is not in the dictionary, we see that there is almost no difference:A note on correctnessIn general, I would prefer the  boolean operation to the conditional expression - with the following caveats:The dictionary is guaranteed to only have non-empty strings or .Performance here is critical.In the case where either the above is not true, I would prefer the following for correctness:The upsides are that the lookup is done one time, the check for  is quite fast,the code is explicitly clear, andthe code is easily maintainable by any Python programmer.This should also not be any less performant:We see that we get quite competitive performance when the key is there: when the key is not in the dictionary, it is not quite as good though:ConclusionThe difference between the conditional expression and the boolean operation is two versus one lookups respectively on a  condition, making the boolean operation more performant.For correctness's sake, however, do the lookup one time, check for identity to  with , and then reassign to the empty string in that case.
Owing to its greater flexibility, there is more going on behind the scenes in the first version. After all,  is an expression with 3 possibly distinct input variables/expressions, while  is binary. You can disassemble the expressions to get a better idea:
TLDR: It does not matter. If you care about correctness, you should instead compare against .There is a notable impact from whether  is mostly  or an actual value - however, this is at the nanosecond scale. It is negligible unless run in a very tight loop.If you seriously require better performance, you should consider using a JIT or static compiler such as PyPy, Cython, or similar.A look at what happensPython makes many guarantees that what you write is what is executed. That means the  case evaluates  at most twice. In contrast,  evaluates  exactly once.In their disassembly, you can see that the ,  and  happen twice for the first case - but only if the value is true-ish. If it is false-ish, the number of lookups is the same!Technically, the statements also perform a different check: boolean false-ness () versus boolean truth-ness (). Since this is a single operation, it is optimised inside the interpreter and the difference is negligible.For builtin types, you can generally assume that operations are "fast" - meaning that any non-trivial control flow takes significantly more time. Unless you run this in a tight loop over thousands of accounts, it will not have a notable impact.While in your case it does not make an observable difference, it is usually better to explicitly test . This lets you distinguish between  and other false-ish values, such as ,  or , that may be valid.Strictly speaking, it is the least efficient. On top of the added lookup, there is an additional lookup for  and comparison for .Note that this test can actually be faster. An  test compares for identity - that is builtin pointer comparison. Especially for custom types, this is faster than looking up and evaluating a custom  or even  method.In practice, the added lookup will not have a noticeable performance difference. It is up to you whether you prefer the shorter  or the more robust . Using  gets you neither terseness nor correctness, so it should be avoided.Here are the numbers from Python 3.6.4, :As you can see, there is an impact from the value of  - if you care about tens of nanoseconds. The terser statement with fewer underlying instructions is faster, and more importantly stable. There is no significant penalty for the added  check.Either way, if you care about performance - do not optimise for CPython! If you need speed, taking a JIT/static compiler gives significantly more gain. However, their optimisations make instruction counts as performance metrics misleading.For pure-Python code, as in your case, the PyPy interpreter is an obvious choice. On top of being faster in general, it seems to optimise the  test. Here are the numbers from from PyPy 5.8.0-beta0, :Bottom line, do not try to gain performance by optimising for byte code instructions. Even if you are sure that this is a bottleneck (by profiling your application), such optimisations are generally not worth it. A faster runtime gives significantly more gain, and may not even have the same penalties for byte code instructions.
I know this doesn't answer your question about efficiency or the difference behind the scenes, but I'd like to point out that I think the following code is preferable:This way you don't have to access the  twice. Another side effect of this solution (obviously it depends if you want this behavior or not) is you'll never get a , even if  is not in the  dict. Obviously if you prefer to see the KeyError that’s fine too.The documentation for 's  is here: https://docs.python.org/3/library/stdtypes.html#dict.get
Conditional operatorThis is the ternary conditional operator and basically equivalent to the following if statement:It is very explicit and allows you to describe exactly what condition you require. In this case, it just looks at the truthy value of , but you could easily expand this to make a strict test against  for example:This would for example retain falsy values like  or .or operatorThis uses the boolean  operator:The expression  first evaluates ; if  is true, its value is returned; otherwise,  is evaluated and the resulting value is returned.So this is basically a way to get the first truthy value (defaulting to the right operand). So this does the same as the . Unless the conditional operator, it does not support other checks though, so you can only check for truthiness here.ComparisonIn your case, where you want to just check against  and fall back to an empty string, there’s no difference at all. Just choose what is most understandable to you. From a “pythonic” point of view, one would probably prefer the  operator, as that’s also a bit shorter.From a performance standpoint, the conditional operator is slightly more expensive in this case, as this needs to evaluate the dictionary access twice. In practice that won’t be noticeable though, especially not for a dictionary access.If you do believe that this could have an impact on your application performance, then you should not believe in numbers you get from isolated benchmarks of a single statement; instead, you should profile your application and then try to identify bottlenecks which you can then improve on. I’ll guarantee you that it will be a long way before a second dictionary access will have any impact.So yes, you can totally ignore the performance arguments for this. Just choose whatever you prefer, what makes the most sense to you. Also consider whether you just want a truthiness check, or whether a strict check against  would be better.
For your specific case, the boolean  operator looks more pythonic, and also a very simple benchmark shows that it is slightly more efficient:Output:Taking into account that the numbers above are the total execution times in seconds (1000000 evaluations per each statement), in practice, there is no significant difference in efficiency at all.


Answer URL
https://docs.python.org/3/reference/expressions.html#conditional-expressions
https://docs.python.org/3/reference/expressions.html#boolean-operations
https://docs.python.org/3/reference/expressions.html#subscriptions
https://docs.python.org/3/library/dis.html
https://docs.python.org/3/library/stdtypes.html#dict.get
https://docs.python.org/3/reference/expressions.html#conditional-expressions
https://docs.python.org/3/reference/expressions.html#boolean-operations
