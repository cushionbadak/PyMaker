Natural Text
I cannot produce example in Python which shows Boolean operator precedence rules combined with short circuit evaluation. I can show operator precedence using:But the issue with short circuiting shows up when I change it to this:For each of 4 possibilities when expression before  is  it is the only evaluated expression. If operator precedence works this should print  or , with short circuiting, because  should be evaluated 1st.What comes to mind from this example is that Python reads boolean expression from left to right and ends it when result is known regardless of operator precedence.Where is my error or what am I missing? Please give an example where it's visible that  is evaluated 1st and it isn't due to code being interpreted from left to right.
You are confusing operator precedence and evaluation order.The expression  is not evaluated as , but just as . This expression is evaluated from left to right, and if the result of the  is already decided, then  will not be evaluated at all.Note that it would be different if  and  were functions; in this case, the parameters of the functions would be evaluated before the function itself is called. Hence,  prints ,  and  i.e. it prints all three, but still in order from left to right.You can generalize this to other operators, too. The following two expressions will yield different results due to the different operator precedence (both implicit and explicit by using ), but the functions are called from left to right both times.As pointed out in comments, while the terms in between operations are evaluated from left to right, the actual operations are evaluated according to their precedence.This way, the expression  is evaluated as , , , , , , , i.e. terms are evaluated left-to-right (and pushed on a stack) and expressions are evaluated as soon as their parameters are evaluated.
The first value returned from  is  so python will not even run the rest of the expression. This is for efficiency, as the rest of the expression will not impact the result.Take the following example where I have changed the order:Output:What is happening here?  returns  which is falsy so we already know that it doesn't matter what  returns (because it is an  condition and the first part is already ) - so we don't run it. We then run the  because it could change the already  value of the expression - which returns .
Actually, your code returns  not because  is evaluated 2nd but because 1 is true and no further evalution is necessary. Which makes the behaviour consistent. 
 has lower precedence than  so that  is interpreted as .In addition, the logical operators are evaluated "lazily" so that if  is ,  will not cause the evaluation of .
Python evaluates expression from left to right and stops as soon as the result is known.For ex, in case of an or operator, if the entity of left side is True then it is for sure that the operator will return true do the expression on right will not be evaluated in this case.In case of  operator, if the expression on the left side is False, it is sure that the operator should return False. So the expression to the right is not evaluated here.This is what is happening in your example.


Answer URL
https://docs.python.org/3/reference/expressions.html#conditional-expressions
