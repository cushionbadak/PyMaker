Natural Text
According to the  module's cookbook:Using logging in multiple modulesMultiple calls to  return a reference to the same logger object. This is true not only within the same module, but also across modules as long as it is in the same Python interpreter process. It is true for references to the same object; additionally, application code can define and configure a parent logger in one module and create (but not configure) a child logger in a separate module, and all logger calls to the child will pass up to the parent. How does this work? (I tried looking at the module source code, but could not figure it out.) So far I did not know that I could define 'super-global' objects that are accessible across modules.To help me understand how  does it, could you show me how to get the following to work:In a , doand in a 'bar.py', do
First, to do what you want is trivial. When you  a module, there’s only a single instance of that module object shared by anyone else who s it,1 and that module object’s attributes are just the module’s globals. So:If you run , it will print 10, then 20.You do of course have to be careful with top-level module code, which gets run in the order the modules are first imported (which can be tricky to work out),2 and with code in the script (which should never be imported as a module by anyone else)3, but otherwise, it just works, without needing any special getter and setter functions.(If you do for some reason need getter and setter functions, the same  and  that work for any object work just fine on module objects.)And now, how does  do its magic? Simple; it just stores a dict in its globals. Since there’s only one instance of the module, there’s only one instance of its globals, and therefore only one instance of the dict.1. If you want to know how that works under the covers… When you execute , what Python does (by default, assuming you haven't installed any weird import hooks) is: first, is there a ? If not, find the spec for , use it to find a loader, use the loader to load the code,  the code, and store the result as . Then just . This is why each module only gets its top-level code run once, no matter how many times you  it, and it's also why everyone who s it shares the same copy of the module object.2. Your example just works with  and —if  gets ed before . But if  gets ed first, it will get an , because obviously nobody has set  yet.3. The main reason is that when you run , it's not run as a module named , but as a module named . This is why the  guard idiom works. But if someone else does an ,  isn't in , so Python will load and execute a separate copy of , with its own separate globals.


Answer URL
https://docs.python.org/3/howto/logging-cookbook.html#using-logging-in-multiple-modules
