Natural Text
First time trying to use descriptors.The goal: any integer from 0 to 100 (inclusive) will be a legal value for this descriptor. Non-integers and numbers higher than 100 or lower than 0 should result in an exception being thrown, indicating that the type and/or value is wrong.My code:For this line: if self.pct_min <= int(self.value) <= self.pct_max:I get this error:I am running it through PythonTutor and it appears I am not passing in the integer, but I do not understand where I am failing.I am also using this as a guide:  https://www.blog.pythonlibrary.org/2016/06/10/python-201-what-are-descriptors/
This isn't really a problem with descriptors! You've merely set the initial  attribute on the descriptor to :You then try to convert that  attribute value, set to , to an integer:You probably want to apply this to the  argument to !Your descriptor implementation does have several more problems:The  setter method should not return anything. It should set the new value for the bound object, and that's it. Python ignores anything returned by .You are storing the data on the descriptor instance itself. Your class has only a single copy of the descriptor object, so when you use the descriptor between different instances of  you see the exact same data. You want to store the data on the object the descriptor is bound to, so in the  method, on , or at the very least, in a place that lets you associate the value with .  is the specific instance of  the descriptor is bound to. The  getter method doesn't take an 'initial value', it takes the object you are being bound to, and the type (class) of that object. When accessed on a class,  is  and only the type is set.Don't mix  and creating an exception instance.  doesn't make much sense,  writes to the console then returns . Just use .I'm making the following assumptions:You want to raise an exception when setting an invalid value.You don't want to do any validation when getting the value.The initial value set on the descriptor should be used when no value is present on the bound object.The value itself can be stored on the instance directly.Then the following code would work:Demo:Note that the above uses a specific attribute name on the instance to set the value. If you have multiple instances of the descriptor on the same class, that will be an issue!If you want to avoid that, your options are:use some kind of mapping storage that uses some other unique identifier in the key to track what descriptor stored what value on the bound object.store data on the descriptor instance, keyed by a unique identifier for the instance.store the name of the attribute on the class where this descriptor is stored, on the descriptor instance itself and base your instance attribute name on that. You can do this by implementing the  hook method, which is called by Python when a class is created that uses your descriptor. This hook requires Python 3.6 or newer. For the  class example, that'll by called with  and .Note that you should not use the attribute name ( in your  example), at least not directly. Using  will trigger the descriptor object itself, so  or . For a data descriptors (descriptors that implementing either a  or  method), you could use  or  directly to store attributes, however.
That's not a problem with the descriptor itself. The problem is that, in the , instead of checking the value that you get, you check the existing . Since this is initialized to , you will always fail on the first assignment.There's also an (unrelated) problem with the descriptor itself. The getter and setters are supposed to read/write from the , not from the descriptor object itself. Otherwise, all the instances will share a common value


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__set__
https://docs.python.org/3/reference/datamodel.html#object.__get__
https://docs.python.org/3/reference/datamodel.html#object.__set_name__
