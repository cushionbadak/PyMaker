Natural Text
Suppose we have a list of numbers, . I need to COUNT all tuples of length 3 from ,  such that  evenly divides , and  evenly divides . With the stipulation that the indices  have the relationship  I.e.;If , then the tuples would be , so the  would be 3.If , then the only tuple would be , so the  would be 1.Here's what I've done so far, using list comprehensions:This works, but as  gets longer (and it can be as large as 2000 elements long), the time it takes increases too much. Is there a faster/better way to do this?
We can count the number of triples with a given number in the middle by counting how many factors of that number are to its left, counting how many multiples of that number are to its right, and multiplying. Doing this for any given middle element is O(n) for a length-n list, and doing it for all n possible middle elements is O(n^2).Incidentally, the code in your question doesn't actually work. It's fallen into the common newbie trap of calling  instead of using  to get iteration indices. More than just being inefficient, this is actually wrong when the input has duplicate elements, causing your  to return 0 instead of 1 on the  example input.
Finding all tuples in O(n2)You algorithm iterates over all possible combinations, which makes it O(n3).Instead, you should precompute the division-tree of your list of numbers and recover triples from the paths down the tree.Division treeA division tree is a graph which nodes are numbers and children are the multiples of each number.By example, given the list , the division tree looks like this.Computing the division tree requires to compare each number against all others, making its creation O(n2).Here is a basic implementation of a division-tree that can be used for your problem.UsageOnce we built a , it suffices to iterate over all paths down the graph and select only those which have length 3.ExampleOutputThis solution assumes that the list of number is initially sorted, as in your example. Although, the output could be filtered with regard to the condition on indices  to provide a more general solution.Time complexityGenerating the division-tree is O(n2).In turn, there can be up to n! different paths, although stopping the iteration whenever we go deeper than 3 prevents traversing them all. This makes us iterate over the following paths:the paths corresponding to three tuples, say there are m of them;the paths corresponding to two tuples, there are O(n2) of them;the paths corresponding to one tuples, there are O(n) of them.Thus this overall yields an algorithm O(n2 + m).
I suppose this solution without list comprehension will be faster (you can see analogue with list comprehension further):Output:In your solution  method is too expensive (requires O(n) operations). Also you don't need to iterate over full list for each ,  and  (, , ). Notice how I use indexes in my loops for  and  because I know that  is always satisfied.You can write it as one liner too:P.S.Please, don't use  letter for variables names because it's very similar to :)
There is a way to do this with itertools combinations:Since combinations generates the tuples in list order, you do not then need to check the index of .Then your  function becomes:This is a known problem.Here are some timing for the solutions here:And the results:You can see that  are clearly O(n^3) or worse and  are O(n^2).  took more than 90 minutes for what  and  did in 1.3 seconds. 
Solution in O(M*log(M)) for a sorted list containing positive numbersAs user2357112 has answered, we can count the number of triplets in O(n^2) by calculating for every number the number of its factors and multiples. However, if instead of comparing every pair we go over its multiples smaller than the largest number and check whether they are in the list, we can change the efficiency to O(N+M*log(N)), when M is the largest number in the list.Code:While this solution will work quickly for lists containing many small numbers, it will not work for lists containing large numbers:Fast solution with unknown efficiency for unsorted listsAnother method to count the number of multiples and factors of every number in the list would be to use a binary tree data structure, with leaves corresponding to numbers. The data structure supports three operations:1) Add a number to every position which is a multiple of a number.2) Add a number to every position which is specified in a set.3) Get the value of a position.We use lazy propagation, and propagate the updates from the root to lower nodes only during queries.To find the number of factors of every item in the list, we iterate over the list, query the number of factors of the current item from the data structure, and add 1 to every position which is a multiple of the item.To find the number of multiples of every item, we first find for every item in the list all its factors using the algorithm described in the previous solution.We then iterate over the list in the reverse order. For every item, we query the number of its multiples from the data structure, and add 1 to its factors in the data structure.Finally, for every item, we add the multiplication of its factors and multiples to the answer.Code:This solution worked for a list containing the numbers 1..10000 in six seconds on my computer, and for a list containing the numbers 1..100000 in 87 seconds.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.combinations
