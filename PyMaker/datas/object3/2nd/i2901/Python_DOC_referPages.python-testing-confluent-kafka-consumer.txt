Natural Text
Ruby can add methods to the Number class and other core types to get effects like this:But it seems like Python cannot do this. Is this true? And if so, why? Does it have something to do with the fact that type can't be modified?Update: Rather than talking about different definitions of monkey patching, I would like to just focus on the example above. I have already concluded that it cannot be done as a few of you have answered. But I would like a more detailed explanation of why it cannot be done, and maybe what feature, if available in Python, would allow this.To answer some of you: The reason I might want to do this is simply aesthetics/readability. This reads more like English and clearly indicates which is the tested value and which is the expected value, as supposed to:This concept is what Rspec and some other Ruby frameworks are based on.
What exactly do you mean by Monkey Patch here?  There are several slightly different definitions.If you mean, "can you change a class's methods at runtime?", then the answer is emphatically yes:If you mean, "can you change a class's methods at runtime and make all of the instances of that class change after-the-fact?" then the answer is yes as well.  Just change the order slightly:But you can't do this for certain built-in classes, like  or .  These classes' methods are implemented in C and there are certain abstractions sacrificed in order to make the implementation easier and more efficient.I'm not really clear on why you would want to alter the behavior of the built-in numeric classes anyway.  If you need to alter their behavior, subclass them!!
No, you cannot. In Python, all data (classes, methods, functions, etc) defined in C extension modules (including builtins) are immutable. This is because C modules are shared between multiple interpreters in the same process, so monkeypatching them would also affect unrelated interpreters in the same process. (Multiple interpreters in the same process are possible through the C API, and there has been some effort towards making them usable at Python level.)However, classes defined in Python code may be monkeypatched because they are local to that interpreter.
Have fun ;)
You can do this, but it takes a little bit of hacking. Fortunately, there's a module now called "Forbidden Fruit" that gives you the power to patch methods of built-in types very simply. You can find it at http://clarete.github.io/forbiddenfruit/?goback=.gde_50788_member_228887816or https://pypi.python.org/pypi/forbiddenfruit/0.1.0With the original question example, after you write the "should_equal" function, you'd just doand you're good to go! There's also a "reverse" function to remove a patched method. 
Python's core types are immutable by design, as other users have pointed out:You certainly could achieve the effect you describe by making a subclass, since user-defined types in Python are mutable by default.There's no need to make the  subclass public, either; one could just as well define it inline directly in the function or method that constructs the instance.There are certainly a few situations where Python programmers who are fluent in the idiom consider this sort of subclassing the right thing to do.  For instance,  returns a  subclass that adds named members, precisely in order to address the sort of readability concern you refer to in your example.That said, in the specific example you give, I don't believe that subclassing  in  (or elsewhere) would be very likely to be considered the Pythonic thing to do.  I can easily imagine somebody deciding to add a  method to  if that were the primary use case; if one were looking for something more general, perhaps it might make more sense to use named arguments to make the intended meaning clearer, as inor something along those lines.  It's a bit verbose, but no doubt it could be improved upon.  A possible advantage to such an approach over Ruby-style monkey-patching is that  could easily perform its comparison on any type, not just  or .  But perhaps I'm getting too caught up in the details of the particular example that you happened to provide.
You can't patch core types in python. However, you could use pipe to write a more human readable code:  
Here's an example of implementing , although I'd use Decimal instead of float in a real program:
If you really really really want to do a monkey patch in Python, you can do a (sortof) hack with the "import foo as bar" technique.If you have a class such as TelnetConnection, and you want to extend it, subclass it in a separate file and call it something like TelnetConnectionExtended.Then, at the top of your code, where you would normally say:change that to be:and then everywhere in your code that you reference TelnetConnection will actually be referencing TelnetConnectionExtended.Sadly, this assumes that you have access to that class, and the "as" only operates within that particular file (it's not a global-rename), but I've found it to be useful from time to time.
No but you have UserDict UserString and UserList which were made with exactly this in mind.If you google you will find examples for other types, but this are builtin.In general monkey patching is less used in Python than in Ruby.
No, sadly you cannot extend types implemented in C at runtime.You can subclass int, although it is non-trivial, you may have to override .You also have a syntax issue:However
No, you can't do that in Python. I consider it to be a good thing.
What does  do?  Is it a boolean returning  or ?  In that case, it's spelled:There's no accounting for taste, but no regular python developer would say that's less readable than your version.Does  instead set some sort of validator? (why would a validator be limited to one value? Why not just set the value and not update it after that?)  If you want a validator, this could never work anyway, since you're proposing to modify either a particular integer or all integers. (A validator that requires  to equal  will always fail.) Instead, you could spell it like this:or this:and define appropriate methods on item's class or superclasses.
It seems what you really wanted to write is:(Of course comparing floats for equality, or using floats for prices, is a bad idea, so you'd write  or whatever numeric class you were using for the price.)You could also use a testing framework like py.test to get more info on failing asserts in your tests.
Here's how I achieve the .should_something... behavior:orI included a decorator method for extending this behavior at runtime on a stand-alone method:You have to know a bit about the internals but it works.Here's the source:https://github.com/mdwhatcott/pyspecsIt's also on PyPI under pyspecs.


Answer URL
https://docs.python.org/3/c-api/init.html#sub-interpreter-support
