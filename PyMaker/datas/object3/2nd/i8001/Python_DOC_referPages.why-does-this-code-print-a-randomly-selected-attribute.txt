Natural Text
Today while writing some especially terrible code, I stumbled across this mysterious behavior. The Python 3 program below prints a randomly selected attribute of . How does this happen?An obvious suspect for the nondeterminism is the random ordering of the  dictionary, but I can't see how that causes the observed behavior. One hypothesis I had was that it was caused by the ordering of  being overridden, but this is disproved by the fact that the lambda is always called only once (checked by print debugging).N.B. The above program is not attempting to do anything useful; it is heavily reduced from the original.
Andrei Cioara's answer is largely correct:The randomness comes from Python 3.3 and later randomizing hash order by default (see Why is dictionary ordering non-deterministic?).Accessing  calls the lambda function that has been bound to .See Difference between __getattr__ vs __getattribute__ and the Python3 datamodel reference notes for .We can make this whole thing far less obfuscated with:which is sort of what happens with the lambda.  Note that in the loop, we don't bind / save the current value of .1  This means that we get the last value that  has in the function.  With the original code, we do all this work at the time we create object , rather than later when  gets calledâ€”but it still boils down to: Of <name, value> pairs in vars(object), find the last one that meets our criteria: the value must be callable, while the value's type is not itself .Using  makes  a new-style class object even in Python2, so that this code now "works" in Python2 as well as Python3.  Of course, in Py2k, dictionary ordering is not randomized, so we always get the same thing every time:vs:Setting the environment variable  to  makes the order deterministic in Python3 as well:1To see what this is about, try the following:Note that it says , not .  Then replace the lambda line with:and run it again.  Now the function returns 0.  This is because we saved the current value of  here.If we did this same sort of thing to the sample program, it would return the first  that meets the criteria, rather than the last one.
Non-determinism comes from the randomness in the  returned by The print is a bit suspicious, since your TypeUnion does not have an 'x'  The reason why something is returned is because your for loop overwrites  and hence hijacks the dot. Adding this line would show that.Once the  is compromised, the  is dead as well. Think of it like thisIs conceptually the same as  But the  now always returns the same reference, irrespective of the value of , which is then overwritten. Therefore the final answer will be the last item in this iteration, which is random, since the for loop goes through the random order of the initial Also, bear in mind that if your aim is to make a copy of the object, then the  is wrong. Calling the lambda would just return the original function but would not call the original function you would need something along the lines of 
Yes, torek is correct in that your code doesn't bind the current value of , so you get the last value assigned to . Here is a version that "correctly" binds the value with a closure:This will consistently output , proving that the problem is that  is hijacked.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__getattribute__
