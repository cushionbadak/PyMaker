Natural Text
The python documentation for  states: connection_made() and connection_lost() are called exactly once per successful connection.Further down there's also the following state machine:start -> connection_made() [-> data_received() *] [-> eof_received() ?] -> connection_lost() -> endAlso, the documentation for  states:After all buffered data is flushed, the protocol’s connection_lost() method will be called with None as its argument.and the documentation for  states:The protocol’s connection_lost() method will eventually be called with None as its argument.This seems to me to indicate the following responsibilities:The transport must, if it has called , later also call  on the protocol (regardless of whether the connection is lost because of a call to , a call to  or an issue with the underlying connection).The protocol must not assume that I/O has finished when a call to  or  returns. It must wait for the call to . In particular, after  or  returns, there may be work relating to the transport still scheduled on the event loop.With that in mind, consider the following trivial aiohttp client program, using SSL:Running this on my (windows) machine appears to workcorrectly. However, if I put breakpoints or print statements into the and  methods of aiohttp's class (a protocol implementation), I see that is called but  is not.The transport used is , defined in asyncio's file. Its  method is called, and it sets offa shutdown process. Due to the nature of SSL this shutdown process isnecessarily asynchronous, and the expectation appears to be that oncethe shutdown is complete the  underlying the would, from its  method, closeits underlying transport. This would then cause a call to to bubble up the stack. However, none of thisasynchronous stuff actually happens. aiohttp appears to just call and immediately discard the  (themethod where it does this is not even a coroutine), and the transportnever progresses with its shutdown sequence and never calls.So my question is: is this a bug in aiohttp and/or aysncio's SSLprotocol/transport, or am I misinterpreting the documentation asregards the responsitilities of the transport and protocol?Why I'm Asking ThisThe reason for this question is that I have written an SSL transportof my own, to allow me to use PyOpenSSL with asyncio, instead of thestandard library  module. In my implementation, after the call tomy  method returns, there are still callbacks queued on theevent loop (scheduled with ). This is necessary in orderfor the asynchronous shutdown sequence to be performed correctly, andI expect the protocol to give my transport a chance to complete theprocess and call .When I use my transport with aiohttp, the  method of the created in the code above calls its own method (not a coroutine), which causes my transport to be closed,without waiting for . The event loop is then closedand the module finalised while the transport is still alive andperforming I/O, resulting in a variety of errors.I'm trying to figure out whether this is my fault or a bug in aiohttp(and perhaps also asyncio's SSL transport). If it's my fault, I needto know how I'm supposed to perform this asynchronous shutdown. Icould in principle handle it at the top level by running the eventloop until it's empty before calling loop.close(), but I don't see anyway to do that (there's  but that doesn't work forthings scheduled with ). Even if I can do that somehow, itwould seem exceptionally ugly and is certainly not described as astandard requirement for shutting down after such work in anydocumentation I've seen for asyncio or aiohttp.
I suggest you to create an issue in aiohttp bug tracker and copy your question into it.IMHO Stack Overflow is not the best place for discussing questions like this.


Answer URL
https://docs.python.org/3/library/asyncio-protocol.html#asyncio.BaseProtocol.connection_lost
https://docs.python.org/3/library/asyncio-protocol.html#asyncio.BaseTransport.close
https://docs.python.org/3/library/asyncio-protocol.html#asyncio.WriteTransport.abort
