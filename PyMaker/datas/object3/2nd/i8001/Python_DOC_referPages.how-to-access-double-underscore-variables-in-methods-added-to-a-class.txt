Natural Text
BackgroundI wish to use a meta class in order to add helper methods based on the original class. If the method I wish to add uses  I get an  (because of name mangling) but for an existing identical method this isn't a problem.Code exampleHere is a simplified exampleQuestionIs there a way of adding  that could use ?(Without renaming  to .)And maybe something more fundamental, why isn't  being treated in the same way for both cases since  is now part of ?
Name mangling happens when the methods in a class are compiled. Attribute names like  are turned in to , where  is the name of the class the method is defined in. Note that you can use name mangling for attributes of other objects!In your code, the name mangling in  doesn't work because when the function is compiled, it's not part of the class. Thus the lookups of  don't get turned into  the way they did in . You could explicitly look up the mangled version of the attribute name if you want, but it sounds like you want  to be generic, and able to be added to multiple classes. Unfortunately, that doesn't work with name mangling.Indeed, preventing code not defined in your class from accessing your attributes is the whole reason to use name mangling. Usually it's only worth bothering with if you're writing a proxy or mixin type and you don't want your internal-use attributes to collide with the attributes of the class you're proxying or mixing in with (which you won't know in advance).
To answer both of your questions:You will need to change  when you need to call it from  to  thanks to the name mangling rule. Python documentation:This mangling is done without regard to the syntactic position of the  identifier, as long as it occurs within the definition of a class.Let me brake it down for you, it's saying that it doesn't matter where your interpreter is reading when it encounters a name mangled name. The name will only be mangled if it occurs in the definition of a class, which in your case, it's not. Since it's not directly "under" a class definition. So when it reads , it's keeping it at , not going to textually replace it with  since it isn't defined inside the class.
You can use  to access the  attribute from the  class. (where  is replaced by  or any other instance of the  class)learn more in the Python doc


Answer URL
https://docs.python.org/3/tutorial/classes.html#private-variables
