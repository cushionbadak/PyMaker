Natural Text
So i started a project, mainly to test how quickly a PC can compute these sorts of things. The idea was that the user inputted a word and the computer will systematically run all possibilities until it guesses the word. e.g. a-z and once it hits z it starts aa, ab, ac... etc. Obviously getting it to work with just one letter is not an issue but with two letters it is proving to be very difficult. Any help would be appreciated. 
Have a look at Return r length subsequences of elements from the input iterable  allowing individual elements to be repeated more than once.Combinations are emitted in lexicographic sort order. So, if the input  iterable is sorted, the combination tuples will be produced in sorted  order.Elements are treated as unique based on their position, not on their  value. So if the input elements are unique, the generated combinations  will also be unique.So to get all 2-letter-combinations:Wrapping that in a loop starting with  and increasing  should lead you to the word to crack eventually.Hint: right now you are only producing combinations of lower letters, but allow any input as a word. This can lead to an infinite loop. You should consider sanitizing the input before starting to "crack" it.
Here's another approach:You can change the  and  length of your words by changing these values: Output:
The method that popped into my head-Store your guess letters in an array as ascii values. Increment arr[0] from 97-122, then increment arr[1] once, and repeat. Convert from ascii to string for the success check. I believe that conversion is inexpensive.Word="hello"arr{104,101,108,108,111,0,0,0,0,0}There are likely faster computational methods out there, but I thought this keeps it simple.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.combinations_with_replacement
