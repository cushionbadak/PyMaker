Natural Text
I am probably missing something obvious but anyway:When you import a package like  in python, you can use any submodules/subpackages off the bat. For example this works:However I have my own package which is structured as follows:and here the same logic does not work:What am I doing wrong?
You need to import the submodule:What you're doing is looking for  in . You could solve it by putting  (or ) in ,  then Python will be able to find  there. But I recommend using my first suggestion.
When you import , Python searches the directories on PYTHONPATH until it finds a file called  or a directory called  containing a file called . However, having found the package directory,  it does not then scan that directory and automatically import all .py files.There are two reasons for this behaviour. The first is that importing a module executes Python code which may take time, memory, or have side effects. So you might want to import  without necessarily importing all of a huge package . It's up to the package designer to decide whether a's  explicitly imports its modules and subpackages so that they are always available, or whether or leaves the client program the ability to pick and choose what is loaded.The second is a bit more subtle, and also a showstopper. Without an explicit import statement (either in  or in the client program), Python doesn't necessarily know what name it should import  as. On a case insensitive file system (such as used in Windows), this could represent a module named , ,  , , , , , or . All of these are valid, distinct Python identifiers, so Python just doesn't have enough information from the file alone to know what you mean. Therefore, in order to behave consistently on all systems, it requires an explicit import statement somewhere to clarify the name, even on file systems where full case information is available.
You need to add  to the  file in your package. 
There are some important misconceptions that need to be addressed, specifically with terminology. First, usually, when you think that you are importing  a  in python, what you are actually importing is a .  You should use the term  when you are thinking in terms of file system substructure that helps you organize your code.  But from the code perspective, whenever you import a , Python treats it as a module.  All packages are modules.  Not all modules are packages.  A module with the  attribute is considered a package.You can check that  is a module.  To confirm this you can do:In your example, when you do ,  is treated and considered to be a module too, and its attributes (functions, classes, etc.) are supposedly defined in . Since your  is empty, it cannot find .Outside of  statements you cannot use  notation to address modules inside of modules.  The only exception happens if a  is imported in the intended parent's package  file.  To make it clear, let's do some examples here:Consider your original structure:Case 1: __init__.py is an empty fileCase 2: __init__.py has line  in it:Now, suppose that foo is no longer a , but a  that you define in . if you do , it will throw an error saying that  is not a module.
You can import a package from library using import statement. syntax :    import module_nameYou can import only a specific method form a package by using blow syntaxsyntax :    from module_name import function_name


Answer URL
https://docs.python.org/3/tutorial/modules.html#intra-package-references
