Natural Text
After spending a lot of time trying to wrap my head around multiprocessing I came up with this code which is a benchmark test:Example 1:This completes in 2 seconds (half the time of multithreading). Out of curiosity I decided to run this next:Example 2:To my horror this ran in less than half a second!What is going on here? I expected multiprocessing to run faster - shouldn't it complete in half Example 2's time given that Example 1 is Example 2 split into two processes?Update:After considering Chris' feedback, I have included the 'actual' code consuming the most process time, and lead me to consider multiprocessing:
ETA: Now that you've posted your code, I can tell you there is a simple way to do what you're doing MUCH faster (>100 times faster).I see that what you're doing is adding a frequency in parentheses to each item in a list of strings. Instead of counting all the elements each time (which, as you can confirm using cProfile, is by far the largest bottleneck in your code), you can just create a dictionary that maps from each element to its frequency. That way, you only have to go through the list twice- once to create the frequency dictionary, once to use it to add frequency.Here I'll show my new method, time it, and compare it to the old method using a generated test case. The test case even shows the new result to be exactly identical to the old one. Note: All you really need to pay attention to below is the new_method.When I run this, it gets times of (15.963812112808228, 0.05961179733276367), meaning it's about 250 times faster, though this advantage depends on both how long the lists are and the frequency distribution within each list. I'm sure you'll agree that with this speed advantage, you probably won't need to use multiprocessing :)(My original answer is left in below for posterity)ETA: By the way, it is worth noting that this algorithm is roughly linear in the length of the lists, while the code you used is quadratic. This means it performs with even more of an advantage the larger the number of elements. For example, if you increase the length of each list to 1000000, it takes only 5 seconds to run. Based on extrapolation, the old code would take over a day :)It depends on the operation you are performing. For example:On my machine, the multiprocessed operation takes up only ~60% the time of the singlethreaded one.
This example is too small to benefit from multiprocessing.There's a LOT of overhead when starting a new process. If there were heavy processing involved, it would be negligable. But your example really isn't all that intensive, and so you're bound to notice the overhead.You'd probably notice a bigger difference with real threads, too bad python (well, CPython) has issues with CPU-bound threading.
Multiprocessing could be useful for what you're doing, but not in the way you're thinking about using it. As you're basically doing some computation on every member of a list, you could do it using the  method, to do the computation on the list members in parallel.Here is an example that shows your code's performance using a single process and using :Output:
This thread has been very useful!Just a quick observation over the good second code provided by David Robinson above (answered Jan 8 '12 at 5:34), which was the code more suitable to my current needs.In my case I had previous records of the running times of a target function without multiprocessing. When using his code to implement a multiprocessing function his timefunc(multi) didn't reflect the actual time of multi, and it rather appeared to reflect the time expended in the parent.What i did was to externalise the timing function and the time that I got looked more like expected:In my case with a double core the total time carried out by 'x' workers using the target function was twice faster than running a simple for-loop over the target function with 'x' iterations.I am new to multiprocessing so please be cautious with this observation though.


Answer URL
https://docs.python.org/3/library/timeit.html
