Natural Text
I have renamed a python class that is part of a library. I am willing to leave a possibility to use its previous name for some time but would like to warn user that it's deprecated and will be removed in the future.I think that to provide backward compatibility it will be enough to use an alias like that:I have no idea how to mark the  as deprecated in an elegant way. Maybe I could make  a function which emits a warning (to logs) and constructs the  object from its parameters (using  and ) but it doesn't seem elegant enough (or maybe it is?).However, I don't know how Python standard library deprecation warnings work. I imagine that there may be some nice magic to deal with deprecation, e.g. allowing treating it as errors or silencing depending on some interpreter's command line option.The question is: How to warn users about using an obsolete class alias (or obsolete class in general).EDIT: The function approach doesn't work for me (I already gave it a try) because the class has some class methods (factory methods) which can't be called when the  is defined as a function. Following code won't work:Because of:Is inheritance my only option? To be honest, it doesn't look very clean to me - it affects class hierarchy through introduction of unnecessary derivation. Additionally,  what is not an issue in most cases but may be a problem in case of poorly written code using the library.I could also create a dummy, unrelated  class and implement a constructor as well as wrappers for all class methods in it, but it is even worse solution, in my opinion.
Maybe I could make OldClsName a function which emits a warning (to  logs) and constructs the NewClsName object from its parameters (using  *args and **kvargs) but it doesn't seem elegant enough (or maybe it is?).Yup, I think that's pretty standard practice:The only tricky thing is if you have things that subclass from  - then we have to get clever. If you just need to keep access to class methods, this should do it:I haven't tested it, but that should give you the idea -  will handle the normal-instantation route,  will capture accesses to the class methods & still generate the warning, without messing with your class heirarchy.
Please have a look at .As you'll see, the example in the documentation is a deprecation warning:
Why don't you just sub-class? This way no user code should be broken.
Use  module to add placeholder for , then  check will pass, and a linter like pylint will inform this as error.deprecate.pytest.pythen run :
Here is the list of requirements a solution should satisfy:Instantiation of a deprecated class should raise a warningSubclassing of a deprecated class should raise a warningSupport  and  checksSolutionThis can be achieved with a custom metaclass:Explanation method is called not only for a class it is a metaclass of but also for every subclass of this class. That gives an opportunity to ensure that no instance of  will ever be instantiated or subclassed.Instantiation is simple. The metaclass overrides the  method of  to always return an instance of .Subclassing is not much harder.  receives a list of base classes and needs to replace instances of  with .Finally, the  and  checks are implemented via  and  defined in PEP 3119.Test
In python >= 3.6 you can easily handle warning on subclassing:Overloading  should allow you to warn when the old class constructor is called directly, but I haven't tested that since I don't need it right now.
Since Python 3.7, you can provide a customization of module attribute access using  (and ). Everything is explained in PEP 562.In the bellow example, I implemented  and  in order to deprecate the “OldClsName” in favor of “NewClsNam”:In the  function, if a deprecated class or function name is found, a warning message is emitted, showing the source file and line number of the caller (with ).In the user code, we could have:When the user run his script , it will get something like this:Note: the stack trace is usually written in STDERR.To see the error warnings, you may need to add a “-W” flag in the Python command line, for instance:


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__new__
