Natural Text
This question already has an answer here:Python generator that groups another iterable into groups of N [duplicate]                    9 answers                Can you think of a nice way (maybe with itertools) to split an iterator into chunks of given size?Therefore  with  becomes an iterator I can think of a small program to do that but not a nice way with maybe itertools.
The   recipe from the  documentation's recipes comes close to what you want:It will fill up the last chunk with a fill value, though.A less general solution that only works on sequences but does handle the last chunk as desired isFinally, a solution that works on general iterators an behaves as desired is
Although OP asks function to return chunks as list or tuple, in case you need to return iterators, then Sven Marnach's solution can be modified:Some benchmarks: http://pastebin.com/YkKFvm8bIt will be slightly more efficient only if your function iterates through elements in every chunk. 
This will work on any iterable. It returns generator of generators (for full flexibility). I now realize that it's basically the same as @reclosedevs solution, but without the fluff. No need for  as the  propagates up, which is what we want.  The  call is needed to raise the  when the iterable is empty, since  will continue spawning empty generators forever if you let it.It's better because it's only two lines long, yet easy to comprehend. Note that  is put into a tuple. Otherwise, if  itself were iterable, then  would flatten it out. Thanks to Jeremy Brown for pointing out this issue.
I was working on something today and came up with what I think is a simple solution. It is similar to jsbueno's answer, but I believe his would yield empty s when the length of  is divisible by . My answer does a simple check when the  is exhausted.
Here's one that returns lazy chunks; use  if you want lists.
A succinct implementation is:This works because  is a list containing the same iterator n times; zipping over that takes one item from each iterator in the list, which is the same iterator, with the result that each zip-element contains a group of  items.  is needed to fully consume the underlying iterable, rather than iteration stopping when the first exhausted iterator is reached, which chops off any remainder from . This results in the need to filter out the fill-value. A slightly more robust implementation would therefore be:This guarantees that the fill value is never an item in the underlying iterable. Using the definition above:This implementation almost does what you want, but it has issues:(The difference is that because  does not raise StopIteration or anything else on calls that go beyond the end of  this will yield forever; there is also the slightly tricky issue that the  results must be consumed before this generator is iterated).To generate the moving window functionally:So this becomes:But, that still creates an infinite iterator. So, you need takewhile (or perhaps something else might be better) to limit it:
"Simpler is better than complex" -a straightforward generator a few lines long can do the job. Just place it in some utilities module or so:
I forget where I found the inspiration for this.  I've modified it a little to work with MSI GUID's in the Windows Registry: doesn't apply to your question, but it's something I use extensively with this function.
Here you go.Examples:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools-recipes
