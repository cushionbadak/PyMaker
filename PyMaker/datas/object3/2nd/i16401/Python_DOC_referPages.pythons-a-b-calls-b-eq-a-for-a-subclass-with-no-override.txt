Natural Text
This question already has an answer here:How is __eq__ handled in Python and in what order?                    2 answers                In python 2.7.6, suppose that I have a class that defines  and a subclassthereof:Now I create an object of each class, and want to compare them:The result I get:This shows that the interpreter is calling , instead of  asexpected.The documentation states (emphasis added):For objects  and , first  is tried. If this is not implemented or returns ,  is tried. If this is also not implemented or returns , a  exception is raised. But see the following exception:Exception to the previous item: if the left operand is an instance of a built-in type or a new-style class, and the right operand is an instance of a proper subclass of that type or class and overrides the base’s  method, the right operand’s  method is tried before the left operand’s  method.This is done so that a subclass can completely override binary operators. Otherwise, the left operand’s  method would always accept the right operand: when an instance of a given class is expected, an instance of a subclass of that class is always acceptable.Since the subclass  does not override the  operator, shouldn't be called instead of ? Is this expected behavior, or a bug?  It is contrary to the documentation as I read it: am I misreading the documentation or missing something else?Some related questions: This answer quotes the documentation that I quoted above.  In that case the final question involved a comparison between an object of built in type (1) and an an instanceof a new style class.  Here, I'm specifically comparing an instance of a parent classwith an instance of a subclass which does not override the  method of itsparent (in this case,  is both  and ).In this case, python actually does call  instead of  first, even though class  does not explicitly override .  
Here's the code that implements the described logic:Python 2.7:Python 3.x:The two version are similar, except that the Python 2.7 version uses a RICHCOMPARE macro that checks  instead of .In both versions, the first  block is evaluating to true. The specific piece that one would perhaps expect to be false, going by the description in the docs, is this:  (for Py3) / . However, the docs say that  is inherited by child classes:richcmpfunc PyTypeObject.tp_richcompareAn optional pointer to the rich comparison function...This field is inherited by subtypes together with tp_compare and tp_hash...With the 2.x version,  will also evaluate to true, because the   flag is true if , , and  are true, and all of those are inherited from the parent.So, even though  doesn't provide its own rich comparison method, it still returns a non-NULL value because its parent class provides it. As others have stated, this seems to be a doc bug; the child class doesn't actually need to override the  method of the parent, it just needs to provide one, even via inheritance.
It appears that a subclass is considered to "override" the superclass behavior even if all it does is inherit the superclass behavior.  This is difficult to see in the  case because  is its own reflection, but you can see it more clearly if you use different operators, such as  and , which are each other's reflections:Then:Note that  was not called; instead,  was called.The Python 3 documentation is illustrative, in that it states the rule in different words that are technically more accurate (emphasis added):If the right operand’s type is a subclass of the left operand’s type and that subclass provides the reflected method for the operation, this method will be called before the left operand’s non-reflected method. This behavior allows subclasses to override their ancestors’ operations.The subclass does indeed "provide" the reflected method, it just provides it via inheritance.  If you actually remove the reflected method behavior in the subclass (by returning NotImplemented), the superclass method is correctly called (after the subclass one):So basically this appears to be a documentation bug.  It should say that the subclass reflected method is always tried first (for comparison operators), regardless of whether the subclass explicitly overrides the superclass implementation.  (As noted by Mark Dickinson in a comment, though, it only works this way for comparison operators, not for the mathematical operator pairs like /.)In practice, this is unlikely to matter, since the only time you notice it is when the subclass doesn't override the superclass.  But in that case, the subclass behavior is by definition the same as the superclass's anyway, so it doesn't really matter which one is called (unless you're doing something dangerous like mutating the object from within the comparison method, in which case you should have been on your guard anyway).


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__ror__
