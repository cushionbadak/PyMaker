Natural Text
I'm trying to write a function that helps me with debugging. Instead of inserting several print statements every now and then, I'd like to insert a one-liner debug statement. And what I'd expect to accomplish is that such function can be reused: I'd like to use it in several functions, in order to print different sets of variables.In particular what I want to do is this:So that when I set  and call foo, the output is:And then, if I set  and call foo, the output is:In order to do that, I need to get, on runtime, the names of the variables I'm passing to  as arguments, and print it along with their values.I've searched through other posts and unable to find a direct answer.How to get a variable name as a string in Python?retrieving a variable's name in python at runtime?From what I can actually understand, people are told to use the logging module. I've looked at it and tried to implement as much as a tiny piece of it, but I'm unable to log anything yet (will not surrender, though).I've also read that people get pointed to , , or , but just can't understand how to use them. Moreover: if I try to apply them to my variables I only get errors, or meaningless (to me ;) outputs.Is there a way to do this? Is this TOO bad practice? If that's the case: what would be good practice?PS: Perhaps there's no point in wasting efforts trying to implement this, but rather spend that time understanding how to properly use the logging module.
I've also read that people get pointed to dict(), vars(), or dir(), but just can't understand how to use them. Have you tried looking at the docs for these function? For example, :… Without an argument, vars() acts like locals(). Note, the locals dictionary is only useful for reads since updates to the locals dictionary are ignored.OK, so what does  do? Look at the docs: it gives you a dictionary that maps each local name in your function to its value. So, if you don't want to pass both names and values, pass the  dictionary, and the names:That's it. Except I might change the interface a little to either use  or, even simpler, a string that I can , and, to make it simpler to use in simple cases, default to printing all the locals:Now you can do this:Or just:
What you want is almost possible, for CPython only… but a really, really bad idea. Here's the code:The first problem here is that it only handles locals, not globals. That's easy to fix with, e.g.,  or just .The second problem is that if you pass it a value that isn't bound any name (like, say, , it's going to raise an exception. You can fix that with, e.g., .The third problem is that if you pass a value that's bound to two or more names, it's going to pick one arbitrarily. So this code is going to print 'x: 0' twice:You can even fix that one by looking into the frame's  and  to find the bytecode it was executing when it called your function, from which you can tell where each argument came from—e.g., if the first argument came from a , then the name is . (Alternatively, you can decompile it to an AST, which may be easier to process, but that requires third-party code.) This is even hackier—it relies on the fact that the CPython compiler never optimizes the argument passing in function calls in any way—which is almost always true, although I think there are two edge cases where it's not in Python 3.4. I'll leave the code, and discovering and working around those edge cases, as an exercise for the reader.Of course turning it around and passing the names and using the frame hack just to get the values associated with those names is a lot simpler. Still a bad idea, and still hacky, but no so much that I think I should refuse to show the code:


Answer URL
https://docs.python.org/3/library/functions.html#vars
https://docs.python.org/3/library/functions.html#locals
