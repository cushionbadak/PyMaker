Natural Text
This question already has an answer here:Boolean operators vs Bitwise operators                    8 answers                This is a pretty trivial question that I haven't been able to find the answer to. Here is the problem. I have the following array:And I want to check whether  or  is greater than 0. If either is true, then I should output True.My immediate thought was to use;  but I'm finding that  is False where  is TrueAny clarification would be much appreciated. 
What is the difference between  and ? is a logical or and  is a bitwise or logical inclusive or.The logical orThe logical or in python returns the first value that is true.Example:The bitwise or logical inclusive orThe bitwise or logical inclusive or is represented by the  operator in python and creates a number where all bits are set that are set in at least one of the given numbers.Example:2 is in binary 4 is in binary A logical or between the two results in  which is 6.How a negative number is stored is generally implementation specific. However on most systems a negative number is stored by creating the two's complement of the positive number by inverting each bit and adding 1.That number in bitwise ore two any other number still results in a negative number:Neither of the two solves your problemWhile using seems to work, it fails when you flip the values:You should check both values seperatlyFor a larger input this may be inconvenient. You should use any with a generator expression:
You want the  function: computes the bitwise  of the two values, while  evaluates to the first "truthy" value. In both cases, the result is then compared to :  and .What you want to compare each value to zero (as necessary), withIf you had three values, you'd writeThe  function generalizes this to a list of any size, without the need to decide how many terms to  together based on the size of the list.
To answer this question, I have to explain about Two's Complement.BINARY REPRESENTATION OF NUMBERSSo you know how internally, an integer like 5 is represented as a binary stringHow do you imagine you'd represent a negative number?Well, here's what we want to do:Addition should work the same with negative numbers and positive numbers; i.e. you do the same  steps to add 4 + 9 as 4 + -9.Integer overflow shouldn't break mathematics; i.e. , So what we do is called "Two's Complement."TWO'S COMPLEMENTTo represent a negative number, take its absolute value, bitflip every bit, and add 1.So if the positive number is 5the negative number -5 isEssentially, this means we pick the number  to be the largest positive number, and all numbers after that are negative.SO WHAT DOES (5 | -2) MEAN?The  is the bitwise or operator. Given two numbers, it takes every bit and or's them together, constructing a new number where a digit is 1 if the digit in that position in wither or both of the two original numbers is 1, and 0 otherwise. The calculation looks like this:So as you can see, 5 | -2 = -1 < 0.WHAT ABOUT (5 or -2)?The "or" operator takes two values, casts them to booleans and or's them together. This is important: it doesn't or the values, it returns the first value that is "truthy" -- in other words, if you put it in an if statement, it would run.The only integer that isn't "truthy" is 0. Therefore (5 or -2) returns the first non-zero integer of 5 and 2, which is 5 > 0. So 5 or -2 = 5 > 0.
 is a bitwise OR, and Python uses two's complement representation for integers.  Evaluating  gives:And -1 is not greater than zero, so  is false. is a logical OR.  Unlike in other languages where this operator returns a Boolean (True/False) value, Python defines  as being equivalent to  (except that x is evaluated only once).  Note that any nonzero numeric value is “truthy” in Python, so if x≠0, then  evaluates to .That  evaluates to True was a stroke of luck from having the positive number first.  In the other order, you would have gotten False.In general  is not equivalent to , which is what you meant.
When you do , you're doing a bitwise-OR. That will preserve the negation bit in the numbers. Therefore, you'll still have a negative number.The  is a logical-OR, to the Python interpreter will extend that to the next logical operator (the greater-than).
They are two completely different operations so that is expected.To illustrate, here's a small shell log:The  operator returns the first non-zero (non-, non-, etc.) value.The  operator does a bitwise or. To illustrate:


Answer URL
https://docs.python.org/3/library/stdtypes.html#boolean-operations-and-or-not
https://docs.python.org/3/library/stdtypes.html#bitwise-operations-on-integer-types
https://docs.python.org/3/library/functions.html#any
https://docs.python.org/3/reference/expressions.html#unary-arithmetic-and-bitwise-operations
https://docs.python.org/3/library/stdtypes.html
