Natural Text
I calculate the first derivative using the following code:For example, for  this works fine. But when I set  to around  or below,  starts to get values that are really far away from the expected value  and the relative error between the expected value and  becomes huge.Why is that? What is happening here?
The evaluation of  has, at best, a rounding error of  where  is the machine constant of the floating point type. The total error of the central difference formula is thus approximatelyIn the present case, the exponential function is equal to all of its derivatives, so that the error is proportional to which has a minimum at , which for the double format with  is around .The precision is increased if instead of  the actual difference  between the evaluation points is used in the denominator. This can be seen in the following loglog plot of the distance to the exact derivative.
You are probably encountering some numerical instability, as for x = 10 and h =~ 1E-13, the argument for np.exp is very close to 10 whether h is added or subtracted, so small approximation errors in the value of np.exp are scaled significantly by the division with the very small 2 * h.
In addition to the answer by @LutzL I will add some info from a great book Numerical Recipes 3rd Edition: The Art of Scientific Computing from chapter 5.7 about Numerical Derivatives, especially about the choice of optimal  value for given :Always choose  so that  and  differ by an exactly representable number. Funny stuff like  should be avoided, except when  is equal to something along the lines of .Round-off error is approximately , where epsilon is floating point accuracy, Python represents floating point numbers with double precision so it's . It may differ for more complicated functions (where precision errors arise further), though it's not your case.Choice of optimal : Not getting into details it would be  for simple forward case, except when your  is near zero (you will find more information in the book), which is your case. You may want to use higher  values in such cases, complementary answer is already provided. In the case of  as in your example it would amount to , so approximately  times , which choice might be a little difficult in case of small values like yours. Quite close (if one can say so bearing in mind floating point arithmetic...) to practical results posted by @LutzL though.You may use other derivative formulas, except the  one you are using. You may want to use the  or  evaluation(if the function is costly to evaluate and you have calculated  beforehand. If your function is cheap to evaluate, you may want to evaluate it multiple times using higher order methods to make the precision error smaller (see five-point stencil on wikipedia as provided in the comment to your question).
This Python tutorial explains the reason behind the limited precision. In summary, decimals are ultimately represented in binary and the precision is about 17 significant digits. So, you are right that it gets fuzzy beyond 10E-14.


Answer URL
https://docs.python.org/3/tutorial/floatingpoint.html
