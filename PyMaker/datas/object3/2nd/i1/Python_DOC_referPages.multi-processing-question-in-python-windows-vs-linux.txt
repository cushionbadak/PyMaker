Natural Text
The above code shows the basic usage of creating a process. If I run this script in the windows environment, the variable num is different in the parent process and child process. However, the variable num is the same when the script run between the Linux environment.I understand their mechanism of creating process is different. For example, the windows system doesn't have fork method.But, Can someone give me a more detailed explanation of their difference?Thank you very much.  
The difference explaining the behavior described in your post is exactly what you mentioned: the start method used for creating the process. On Unix-style OSs, the default is . On Windows, the only available option is .forkAs described in the Overview section of this Wiki page (in a slightly different order):The fork operation creates a separate address space for the child. The  child process has an exact copy of all the memory segments of the  parent process.The child process calls the exec system call to overlay itself with the  other program: it ceases execution of its former program in favor of  the other.This means that, when using fork, the child process already has the variable  in its address space and uses it.  is not called again.spawnAs the multiprocessing docs describe:The parent process starts a fresh python interpreter process.In this fresh interpreter process, the module from which the child is spawned is executed. Oversimplified, this does  a second time. Hence, a new variable  is created in the child process by assigning the return value of another call to  to it. Therefore it is very likely, that the content of  differs between the processes.This is, by the way, also the reason why you absolutely need to safeguard the instantiation and start of a process with the  idiom when using  as start method, otherwise you end up with:You can use  in POSIX OSs as well, to mimic the behavior you have seen on Windows:Output:


Answer URL
https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods
