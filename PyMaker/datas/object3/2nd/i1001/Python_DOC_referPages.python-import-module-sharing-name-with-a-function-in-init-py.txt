Natural Text
My tree looks likeAnd the content of  isWhen I open up a Python at the top level and , I would get the string instead of module. For example .So I think OK probably  is importing the name from the  namespace, and it's now overridden. So I figure I can go . But this doesn't work as there is "No module named _a".This is very confusing. A function can override a module with the same name, but a module cannot take on a new name and "reexport".Is there any explanation I'm not aware of? Or is this documented feature?Even more confusing, if I remove the  statement in , everything is back normal again (). But why is this different? The  name in  namespace is still a string.(I ran on Python 3.5.3 and 2.7.13 with the same results)
In an  statement, the module reference never uses attribute lookups. The statementsandwill always look for  in the  namespace before trying to further initiate module loading from disk.However, for  statements, Python does look at attributes of the resolved module to find , before looking for submodules.Module globals and the attributes on a module object are the same thing. On import, Python adds submodules as attributes (so globals) to the parent module, but you are free to overwrite those attributes, as you did in your code. However, when you then use an import with the  module path, attributes do not come into play.From the Submodules section of the Python import system reference documentation:When a submodule is loaded using any mechanism [...] a binding is placed in the parent moduleâ€™s namespace to the submodule object. For example, if package  has a submodule , after importing ,  will have an attribute  which is bound to the submodule.Your  statement adds two names to the  namespace; first  is added pointing to the  submodule, and then  is also set, pointing to the same object.Your next line replaces the name  with a binding to the  object.The Searching section of the same details how Python goes about finding a module when you import:To begin the search, Python needs the fully qualified name of the module [...] being imported.[...]This name will be used in various phases of the import search, and it may be the dotted path to a submodule, e.g. . In this case, Python first tries to import , then , and finally . If any of the intermediate imports fail, a  is raised.then further onThe first place checked during import search is . This mapping serves as a cache of all modules that have been previously imported, including the intermediate paths. So if  was previously imported,  will contain entries for , , and . Each key will have as its value the corresponding module object.During import, the module name is looked up in  and if present, the associated value is the module satisfying the import, and the process completes. [...]  If the module name is missing, Python will continue searching for the module.So when trying to import  all that matters is that  exists.  is not consulted.Only  would ever look at attributes. From the  statement documentation:The  form uses a slightly more complex process:find the module specified in the from clause, loading and initializing it if necessary;for each of the identifiers specified in the import clauses:    check if the imported module has an attribute by that nameif not, attempt to import a submodule with that name and then check the imported module again for that attribute[...]So  would work, as would , and you'd get the  submodule and the  object, respectively.Note that  is writable, if you must have  work, you can always just alter  directly:


Answer URL
https://docs.python.org/3/reference/import.html#submodules
https://docs.python.org/3/reference/import.html#searching
https://docs.python.org/3/reference/simple_stmts.html#the-import-statement
https://docs.python.org/3/tutorial/modules.html#more-on-modules
