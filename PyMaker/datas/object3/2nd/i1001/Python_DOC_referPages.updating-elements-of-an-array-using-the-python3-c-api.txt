Natural Text
I have a module method which takes in a python list, and then outputs the same list with all items multiplied by 100.I've attemped to follow the C intro here as close as possible but still running into issues.The above complies fine, however when I run in ipython, I get the below error.If I take away the error handling I get a seg fault.Any help is appreciated.
So you have a number of issues that all need to be corrected. I've listed them all under separate headings so you can go through them one at a time.Always returning When you get an error in your for loop, you would  the error label, which was still returning the list. By returning this list you hide that there was an error in your function. You must always return  when you expect your function to raise an exception.Does not increment  ref count on returnWhen your function is invoked you are given a borrowed reference to your arguments. When you return one of those arguments you are creating a new reference to your list, and so must increment its reference count. Otherwise the interpreter will have a reference count that is one lower than the number of actual references to the object. This will end up with a bug where the interpreter deallocates your list when there is only 1 reference rather than 0! This could result in a seg fault, or it could in the worst case scenario result in random parts of the program access the that has since been deallocated and allocated for some other object.Uses  with primitive can be used with dicts and other class that implements . So you cannot supply it with an argument of type . Instead, use  which only accepts  as its index argument.Bad memory handling of  and  and  both handle decreasing the reference count of the object that was already at the position that was being set. So we don't need to worry about managing the reference count of  as we are only working with a reference borrowed from the list. These pair of functions also steal a reference to , and so we don't need to worry about managing its reference count either.Memory leak on incorrect argumentsFor example, when you call your function with an int. You will create a new reference to the 100 int object, but because you  rather than , this reference will be lost. As such you need to handle such scenarios differently. In my solution, I move the  call to after the arg and type checking. In this way we are only create this new* object once we are guaranteed it will be used.Working codeSide note: I removed the goto statements as there was only one left, and so it made more sense to do the error handling at that point rather than later.Footnote:*  doesn't actually create a new object, but rather returns a new reference to an existing object. Integers with low values ( I think) are all cached and this same object is returned when needed. This is an implementation detail that is meant to avoid high levels of allocating and deallocating integers for small values, and so improve the performance of Python.


Answer URL
https://docs.python.org/3/c-api/intro.html
https://docs.python.org/3/c-api/object.html#c.PyObject_SetItem
https://docs.python.org/3/c-api/list.html#c.PyList_SetItem
https://docs.python.org/3/c-api/long.html#c.PyLong_FromLong
