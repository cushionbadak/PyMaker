Natural Text
I'm using the list.count() method to check if a relationship has an element.While it works pretty well in a test code, it doesnt anymore when the counted class inherits the flask_login UserMixin class.Why , and how to fix it ?I should get the number of elements in the list (1 or 0 ).Instead I get the whole list length (2, even if I append more integers).It is as if it was counting class occurrences in the list, not the object.
First of all lets understand how  works. From the cpython source code the  has the following definition.So when you perform , Python will iterate over every object in the list, and perform a rich comparison(ie, ). From the C-API documentation the rich comparison(ie, ) will Compare the values of  and  using the operation specified by , which must be one of , , , , , or , corresponding to , , , , , or  respectively. Returns  on error,  if the result is false,  otherwise.So if the value is (ie, ) a counter will be incremented. After the iteration the counter will be return back to the caller. in CPython roughly equivalent to the following in python layer,Now lets get back to your question.While it works pretty well in a test code, it doesnt anymore when the  counted class inherits the flask_login UserMixin class.Lets take a sample class(Without inheriting from )This will print  as we expected. But how does python perform the comparison here???. By default python will compare the (ie, memory address of the object) of  with ids of , , . Since each new object have different ids , count method will return .Ok, So what if we want to count the person as one if there names are equal???Let take the same example.But This still return  as python still comparing with its object ids. So how can I customize this?. You can override  of the object.  ie,Wow now it return  as expected.Now lets consider the class which inherit from   .This will print . Why?. If the comparison was performed based on  it would have been . So there will be an   implemented somewhere. So if you look at the  class implementation it implement  method.As you can see the comparison is performed based on its  attribute. In this case  class set the  attribute on the class level hence it will be same for all instances.How to fix this,From the logical perspective every object will have unique ids. Hence  should be a instance level attribute. See one example from the  code base itself.
This 'id' issue is the key point. Back to the sqlalchemy context, the list holds objects with an id as primarykey ... set to 'None' at first for all objects.And it will be updated only after a session.add() and session.commit(), the final fix. Thanks.


Answer URL
https://docs.python.org/3/c-api/object.html#c.PyObject_RichCompare
