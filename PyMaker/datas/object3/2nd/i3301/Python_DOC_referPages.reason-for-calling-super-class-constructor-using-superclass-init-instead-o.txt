Natural Text
I am a beginner in Python and using Lutz's book to understand OOPS in Python. This question might be basic, but I'd appreciate any help. I researched SO and found answers on "how", but not "why."As I understand from the book, if  inherits  then one need not call superclass' ('s)  method.Example:Above code does assign attribute  to the object . It also prints the  as expected. However, if I modify the code as:The above code doesn't work fine. By fine, I mean that although  does get called (as seen from the print statements), there is no attribute attached to . When I run , I get an error, I researched this topic on SO, and found the fix on Chain-calling parent constructors in python and Why aren't superclass __init__ methods automatically invoked?These two threads talk about how to fix it, but they don't provide a reason for why. Question: Why do I need to call 's  using  OR  instead of a direct call ? In  and  , we see that Super's  gets called, (as seen from print statements), but only in  we see that the attribute gets attached to  class.Wouldn't  automatically pass  (child) object to ? Now, you might ask that how do I know that  is automatically passed? If I modify  to , I get an error message that . As I understand from the book,  is automatically passed. So, effectively, we end up passing  twice. I don't know why  doesn't attach  attribute to  even though  is run. I'd appreciate any help. For reference, here's the working version of the code based on my research from SO:PS: I am using  under Anaconda Distribution.
As I understand from the book, if Sub inherits Super then one need not call superclass' ('s)  method.This is misleading. It's true that you aren't required to call the superclass's  method—but if you don't, whatever it does in  never happens. And for normal classes, all of that needs to be done. It is occasionally useful, usually when a class wasn't designed to be inherited from, like this:Imagine that you want all the behavior of this class, but with a string rather than a file. The only way to do that is to skip the :Here, we wanted to avoid the  assignment in the superclass. In your case—as with almost all classes you're ever going to write—you don't want to avoid the  assignment in the superclass. That's why, even though Python allows you to not call the superclass's , you almost always call it.Notice that there's nothing special about  here. For example, we can override  to call the base class's version and then do extra stuff:… or we can override  and intentionally not call the base class:The only difference is that good reasons to avoid calling the base class tend to be much more common in normal methods than in .Question: Why do I need to call  using  OR  instead of a direct call ?Because these do very different things. constructs a new  instance, calls  on it, and returns it to you. And you then ignore that value.In particular,  does get called one time either way—but the  it gets called with is that new  instance, that you're just going to throw away, in the  case, while it's your own  in the  case.So, in the first case, it sets the  attribute on some other object that gets thrown away, and nobody ever sets it on your object, which is why  later raises an .It might help you understand this if you add something to both class's  methods to show which instance is involved:If that last line is , , or , you will see something like this:Notice that it's the same object, the  at address 0x10f7a9e80, in both cases.… but if that last line is :Now we have two different objects, at different addresses 0x10f7a9ea0 and 0x10f7a9ec0, and with different types.If you're curious about what the magic all looks like under the covers,  does something like this (oversimplifying a bit and skipping over some steps1):… while  does something like this:As a side note, if a book is telling you to use  or , it's probably an obsolete book written for Python 2.In Python 3, you just do this:: Calls the correct next superclass by method resolution order. You almost always want this.: Calls the correct next superclass—unless you make a mistake and get  wrong there. You only need this if you're writing dual-version code that has to run in 2.7 as well as 3.x.: Calls , whether it's the correct next superclass or not. You only need this if the method resolution order is wrong and you have to work around it.2If you want to understand more, it's all in the docs, but it can be a bit daunting: (also see Raymond Hettinger's blog post)method invocation (also see the HOWTO)The original introduction to , , and all the related features was very helpful to me in understanding all of this. I'm not sure if it'll be as helpful to someone who's not coming at this already understanding old-style Python classes, but it's pretty well written, and Guido (obviously) knows what he's talking about, so it might be worth reading.1. The biggest cheat in this explanation is that  actually returns a proxy object that acts like  bound to  in the same way methods are bound, which can be used to bind methods, like . This is useful/interesting knowledge if you know how methods work, but probably just extra confusion if you don't.2. … or if you're working with old-style classes, which don't support  (or proper method-resolution order). This never comes up in Python 3, which doesn't have old-style classes. But, unfortunately, you will see it in lots of tkinter examples, because the best tutorial is still Effbot's, which was written for Python 2.3, when Tkinter was all old-style classes, and has never been updated.
 is not a "direct call" to the superclass . After all, you called , not . takes an uninitialized  instance and initializes it.  creates and initializes a new, completely separate instance from the one you wanted to initialize (and then you immediately throw the new instance away). The instance you wanted to initialize is untouched.
 instantiates a new instance of super. Think of this example:In order to explicitly call The 's constructor on the current instance, you'd have to use the following syntax:Now, maybe you don't want read further if you are a beginner.If you do, you will see that there is a good reason to use  (or  in Python 3) instead of  . works fine, as long as you are certain that  is in fact your superclass. But in fact, you don't know ever that for sure.You could have the following code:You would now expect that  ends up calling all of the above constructors, but it does not:To correct it, you'd have to do:Now it works:The reason is that the super class of  is declared to be , in case of multiple inheritance in class , Python's MRO establishes the inheritance as:  inherits from , which inherits from , which inherits from , which inherits from .You can test that:Now, the  call in constructors of each of the classes finds the next class in the MRO so that the constructor of that class can be called.See https://www.python.org/download/releases/2.3/mro/


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__new__
https://docs.python.org/3/reference/datamodel.html#object.__init__
https://docs.python.org/3/library/functions.html#super
https://docs.python.org/3/reference/datamodel.html#invoking-descriptors
https://docs.python.org/3/howto/descriptor.html
