Natural Text
I have written some code in python to delete unique numbers from a list so given the input:It should returnBut my program returnsMy code is:I found the error occurs at the . It says  when clearly there are 2 occurrences of the number 2 in the list. I do not understand why this is giving the wrong answer
Try appending to a new list rather than changing your old one:It's bad practice to change list size during iteration, and  will do that. This returns 
If you have a long list, you should put all numbers into a Counter(iterable) - dictionary.This will count all occurences with one pass of your list () and the lookup how often it occurs inside the created dictionary is . Together this is much faster then use a list comprehension like  for a list of 100 values it will go through your 100 values 100 times, to count each single one of them wich is O(n^2) - bad thing to have.Output:
Solution using list comprehensionI believe a more pythonic answer could be, using list comprehension:Solutions time comparison for example listI have moved C.Nivis and Patrick Artner answers inside a function to run timeit more easily on it.To account for the time required to call the function, I have also wrapper the list comprehension into a function call.SetupSolution with loopsSolution with list comprehensionSolution with Solution with ConclusionsIt appears that list comprehension is slightly but consistently faster than looping and quite faster than  with small lists. Numpy, for small lists, is the slower one.Solutions time comparison for large listsSuppose that we have a large list of n random elements, from [0, n]Solution with loopsSolution with list comprehensionSolution with Solution with Conclusions for large listsFor large lists the undisputed winner is , followed just behind by .Final conclusionsFor small lists list comprehension seems to do the trick, but for larger lists the  approach works best.
This is a recursive problem. You misunderstood . It takes an index not a specific element. Therefore, you're not removing what you expect.the thing to do here is to use ,this way you're popping the item a the right index.EDITI edited, thanks to @wim for his comment. I'm now iterating over a copy () of the original list not to iterate and mutate the original list at the same time.Also, I created a copy explicity for the sake of explanation. But you could use a shorter version of the code, Note that I added a comment because this syntax can be confusing for some people.  
Do not modify a list while iterating over it. Behavior will most likely not be the desired one. with One more option is to use For big arrays this is way faster than list comprehension and Then
You could use list comprehension to build a new list:Also, the  method takes the index of the element as an argument, not the value.


Answer URL
https://docs.python.org/3/library/collections.html#collections.Counter
https://docs.python.org/3/library/collections.html#collections.Counter
https://docs.python.org/3/library/collections.html#collections.Counter
https://docs.python.org/3/library/functions.html#enumerate
