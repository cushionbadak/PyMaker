Natural Text
I'd like to be able to saybut I get the . Key thing here is that the return type is a function of a function parameter.  I have glanced through the https://www.python.org/dev/peps/pep-3107/, but I don't see any precise description of what comprises a valid annotation expression.I would accept an answer which explains why exactly is this not possible at the moment, i.e., does it not fit into current annotation paradigm or is there a technical problem with this?
Let's take a glance at PEP-484 - Type Hints # Acceptable type hints.Annotations must be valid expressions that evaluate without raising exceptions at the time the function is defined (but see below for forward references).Annotations should be kept simple or static analysis tools may not be able to interpret the values. For example, dynamically computed types are unlikely to be understood. (This is an intentionally somewhat vague requirement, specific inclusions and exclusions may be added to future versions of this PEP as warranted by the discussion.)I'd say that your approach is quite interesting and may be useful for static analysis. But if we accept PEPs as a source of an explanation for the current annotation paradigm, the highlighted text explains why return type can't be defined dynamically at the time the function is called.
There are a few issues with the  method.First off, as Oleh mentioned in his answer, all annotations must be valid at the time of the function's definition. In an example like yours, you could potentially have problems due to variable shadowing.Since the variable  is of type , the function's annotation is essentially read as . So when you pass in the argument  with the value , which means  will return a , this makes it inconsistent with the annotation. Admittedly this example is contrived, but from a language design stand point, it is something to be careful.Instead, as jonrsharpe mentioned, often the best way to reference the generic types of parameters (as jonrsharpe) mentioned is with type variables.This can be done using the  class.This means that static checkers won't need to actually access the type of , just check that at check-time that there is a way to consider both  and the return value of the same type. I say consider the same type because you will sometimes only assert that they both implement the same abstract base class/interface, like .And then can use typevars in generic typesUsing type variables and generics can be better because it adds additional information and allows for a little bit more flexibility (as explained in the example with ). For instance, the ability to use  is really important. In your case of using , it would only return , not list of  like  would. So using  would actually lose information, not add it.Therefore, it is a better idea to stick to using type variables and generic types instead.TL;DR:Due to variable shadowing,  could lead to inconsistent annotations.Since sometimes when thinking of the types of your system you are thinking in terms of interfaces (abstract base classes in Python) instead of concrete types, it can be better to rely on ABC's and type variables Using  could lose information that would be provided by generics.


Answer URL
https://docs.python.org/3/library/typing.html#user-defined-generic-types
https://docs.python.org/3/library/typing.html#typing.TypeVar
https://docs.python.org/3/library/typing.html#typing.TypeVar
https://docs.python.org/3/library/typing.html#user-defined-generic-types
https://docs.python.org/3/library/typing.html#typing.TypeVar
https://docs.python.org/3/library/typing.html#generics
