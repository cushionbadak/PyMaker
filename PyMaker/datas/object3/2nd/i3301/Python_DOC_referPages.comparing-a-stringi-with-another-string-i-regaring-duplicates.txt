Natural Text
so the program asks for two strings then. the program should return text1 where each letter of the secret has been put in brackets.  So that if you read out only the letters of text1 that are in brackets you get the secret text.Examples codeerror in code I've tried a couple different ways but this is the closest code I can come up with that gets me closer to the answer. all the others I have tried end up with more letters or repeats. 
The root problem here is that you're thinking in terms of sets.First, either a letter is a member of , or it isn't. So, each letter that's in  is a member of  no matter how many times it appears, so you end up with too many duplicates— and  will give you  instead of just .You attempt to fix that by using another set, the set of letters used so far, but that has the same problem: either a letter has been used so far, or it hasn't. So now you end up using each letter only once, even if it appears multiple times in , and you have no duplicates at all:  and  gives you  instead of .The key is that  is not a set, it's a multiset: letters don't just appear or not appear, they appear a certain number of times. You want to use each letter in  as many times as it appears—not infinite times, not just once. The only way to do this is to keep track of how many times it appears, and how many times you've used it.The smallest change that would fix this is to just remove each letter as you find it. Like this:But a much nicer solution is to actually store the secret letters as a multiset. That's exactly what  does:This doesn't look much different on the surface, but if you look at what's happening under the covers, it's a lot simpler.When  is a string,  actually has to search every character of the string and compare it to . And then,  has to search the string all over again to find the same letter, and then it has to copy the whole string minus that letter into a new string to return to you.When  is a Counter,  just looks up  in the hash table and checks the number there. And then,  just decrements the number. Instead of two linear searches and a linear copy, we're just doing a direct lookup and subtraction.Of course the performance is unlikely to matter in this case. And Python wraps up all that linear searching and copying so it looks easy, even if what happens under the covers isn't. So, if you're having a hard time understanding how Counter works, or what a multiset is, don't feel too bad about sticking with the string, but make a note to come back later and see if you can see the differences once you've learned a bit more.However, although this solves all of your examples correctly, I'm still not sure you're describing the problem correctly. You can only "read out the secret text" if all of the letters in  happen to appear in the same order as in . That happens to be true in all of your examples, but what's the right answer for, say,  and ? Should it be , or should it be ? If it's the latter, and the order of  matters, then we don't want a set, or a multiset, we want a list. And we only want to check the first letter of it each time.The smallest change, then, is:Notice that I'm checking  before checking . This is because, after we've used up all the letters in , there is no more , so that would give us an .There's no more double-linear-searching, of course, but we're still copying the string each time. A cleaner solution would be to use a list, where just popping the last value off is instantaneous:


Answer URL
https://docs.python.org/3/library/collections.html#collections.Counter
