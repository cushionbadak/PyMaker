Natural Text
I have a few classes with almost identical contents, so I tried two methods to copy the classes and their attributes over. The classes copy correctly, but the randint function is only invoked in the main class, so the same number is output every time. Is there any way to recalculate the random number for each class?For example if a.exampleData = 50, b.exampleData and c.exampleData would be the same. Is there any way around this?Edit --  Part of my program displays characters with random stats each time, and the class contains the stats associated with each character. The random numbers pick the stats out of a list, but the same stats are being chosen, instead of being random in each class. I may not be explaining this right, so basically:
While my other answer covers the question as asked, I suspect it's all completely unnecessary to the OP's actual problem.If you just want to create a bunch of separate objects, which each have a separate value for , you just want a bunch of instances of a single class, not a bunch of separate classes.A class is a special kind of object that, in addition to doing all the normal object stuff, also works as a factory for other objects, which are instances of that class. You don't need , , and  to all be factories for for different kinds of objects, you just need them to be different objects of the same type. So:… or, if you want to make sure  is the same type of thing as  but don't know what type that is:That's as fancy as you need to get here.See the official tutorial on Classes (or maybe search for a friendlier tutorial, because there are probably better ones out there).
When you write this:… you're just copying  . Since  is just , the new copy that ends up as  is also going to be .There are many ways you could get a new random number. The simplest is to just create a new random number for  explicitly:If you want to create a bunch of classes this way, you can wrap that up in a function:You can make that factory function more complicated if you want to be (see  for a pretty extreme example).You could wrap that behavior up in a decorator:Notice that I had to call the decorator with normal function-call syntax here, because there's no declaration statement to attach an  to.Or you can wrap it up in a metaclass:Notice that we have to call  here, the same way a  definition statement does, not the base metaclass .Also notice that I'm not taking  in the  method, and I'm calling  directly. This means that if you try to use  together with another metaclass (besides ), you should get an immediate , rather than something that may or may not be correct.Meanwhile, I have a suspicion that what you're really trying to do here is build a prototype-based inheritance system, a la Self or JavaScript on top of Python's class-based system. While you can do that by using a special  metaclass and a bunch of class objects, it's a whole lot simpler to just have a  class and a bunch of instance objects. The only advantage to the metaclass approach is that you can use  statements (misleadingly, but conveniently) to clone prototypes, and you're explicitly not doing that here.


Answer URL
https://docs.python.org/3/tutorial/classes.html
