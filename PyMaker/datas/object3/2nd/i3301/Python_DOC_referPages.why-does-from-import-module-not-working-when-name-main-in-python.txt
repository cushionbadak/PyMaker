Natural Text
I want to import a function from another file in the same directory.Sometimes it works for me with  but sometimes I get a:Sometimes it works with , but sometimes I also get a:I don't understand the logic here, and I couldn't find any explanation. This looks completely random.Could someone explain to me what's the logic behind all this?
unfortunately, this module needs to be inside the package, and it also  needs to be runnable as a script, sometimes. Any idea how I could  achieve that?It's quite common to have a layout like this......with a  like this......a  like this......and a  like this......which works fine when you run  or , but fails with , due to the relative import...The way you're supposed to run it is......but it's somewhat verbose, and doesn't mix well with a shebang line like .The simplest fix for this case, assuming the name  is globally unique, would be to avoid using relative imports, and just use......although, if it's not unique, or your package structure is more complex, you'll need to include the directory containing your package directory in , and do it like this......or if you want it to work "out of the box", you can frob the  in code first with this...It's kind of a pain, but there's a clue as to why in an email written by a certain Guido van Rossum...I'm -1 on this and on any other proposed twiddlings of the   machinery. The only use case seems to be running scripts that happen  to be living inside a module's directory, which I've always seen as an  antipattern. To make me change my mind you'd have to convince me that  it isn't.Whether running scripts inside a package is an antipattern or not is subjective, but personally I find it really useful in a package I have which contains some custom wxPython widgets, so I can run the script for any of the source files to display a  containing only that widget for testing purposes.
ExplanationFrom PEP 328Relative imports use a module's __name__ attribute to determine that  module's position in the package hierarchy. If the module's name does  not contain any package information (e.g. it is set to '__main__')  then relative imports are resolved as if the module were a top level  module, regardless of where the module is actually located on the file  system.At some point PEP 338 conflicted with PEP 328:... relative imports rely on __name__ to determine the current  module's position in the package hierarchy. In a main module, the  value of __name__ is always '__main__', so explicit relative imports  will always fail (as they only work for a module inside a package)and to address the issue, PEP 366 introduced the top level variable :By adding a new module level attribute, this PEP allows relative  imports to work automatically if the module is executed using the -m  switch. A small amount of boilerplate in the module itself will allow  the relative imports to work when the file is executed by name. [...] When it [the attribute] is present, relative imports will be based on this attribute  rather than the module __name__ attribute. [...] When the main module is specified by its filename, then the __package__ attribute will be set to None. [...] When the import system encounters an explicit relative import in a  module without __package__ set (or with it set to None), it will  calculate and store the correct value (__name__.rpartition('.')[0]  for normal modules and __name__ for package initialisation modules)(emphasis mine)If the  is ,  returns empty string. This is why there's empty string literal in the error description:The relevant part of the CPython's  function:CPython raises this exception if it was unable to find  (the name of the package) in  (accessible as ). Since  is "a dictionary that maps module names to modules which have already been loaded", it's now clear that the parent module must be explicitly absolute-imported before performing relative import.Note:  The patch from the issue 18018 has added another  block, which will be executed before the code above:If  (same as above) is empty string, the error message will beHowever, you will only see this in Python 3.6 or newer.Solution #1: Run your script using -mConsider a directory (which is a Python package):All of the files in package begin with the same 2 lines of code:I'm including these two lines only to make the order of operations obvious. We can ignore them completely, since they don't affect the execution.__init__.py and module.py contain only those two lines (i.e., they are effectively empty).standalone.py additionally attempts to import module.py via relative import:We're well aware that  will fail. However, we can run the module with the  command line option that will "search  for the named module and execute its contents as the  module": does all the importing stuff for you and automatically sets , but you can do that yourself in theSolution #2: Set __package__ manuallyPlease treat it as a proof of concept rather than an actual solution. It isn't well-suited for use in real-world code.PEP 366 has a workaround to this problem, however, it's incomplete, because setting  alone is not enough. You're going to need to import at least N preceding packages in the module hierarchy, where N is the number of parent directories (relative to the directory of the script) that will be searched for the module being imported.Thus,Add the parent directory of the Nth predecessor of the current module to Remove the current file's directory from Import the parent module of the current module using its fully-qualified nameSet  to the fully-qualified name from 2Perform the relative importI'll borrow files from the Solution #1 and add some more subpackages:This time standalone.py will import module.py from the package package using the following relative importWe'll need to precede that line with the boilerplate code, to make it work.It allows us to execute standalone.py by filename:A more general solution wrapped in a function can be found here. Example usage:Solution #3: Use absolute imports and setuptoolsThe steps are -Replace explicit relative imports with equivalent absolute importsInstall  to make it importableFor instance, the directory structure may be as followswhere setup.py isThe rest of the files were borrowed from the Solution #1.Installation will allow you to import the package regardless of your working directory (assuming there'll be no naming issues).We can modify standalone.py to use this advantage (step 1):Change your working directory to  and run  ( installs the package in your site-packages directory) (step 2):Let's verify that it's now possible to run standalone.py as a script:Note: If you decide to go down this route, you'd be better off using virtual environments to install packages in isolation.Solution #4: Use absolute imports and some boilerplate codeFrankly, the installation is not necessary - you could add some boilerplate code to your script to make absolute imports work.I'm going to borrow files from Solution #1 and change standalone.py:Add the parent directory of package to  before attempting to import anything from package using absolute imports:Replace the relative import by the absolute import:standalone.py runs without problems:I feel that I should warn you: try not to do this, especially if your project has a complex structure.As a side note, PEP 8 recommends the use of absolute imports, but states that in some scenarios explicit relative imports are acceptable:Absolute imports are recommended, as they are usually more readable  and tend to be better behaved (or at least give better error  messages). [...] However, explicit relative imports are an acceptable  alternative to absolute imports, especially when dealing with complex  package layouts where using absolute imports would be unnecessarily  verbose.
I ran into this issue.  A hack workaround is importing via an if/else block like follows:
Put this inside your package's __init__.py file:Assuming your package is like this:Now use regular imports in you package, like:This works in both python 2 and 3.
Hopefully, this will be of value to someone out there - I went through half a dozen stackoverflow posts trying to figure out relative imports similar to whats posted above here. I set up everything as suggested but I was still hitting Since I was just developing locally and playing around, I hadn't created/run a  file. I also hadn't apparently set my . I realized that when I ran my code as I had been when the tests were in the same directory as the module, I couldn't find my module:However, when I explicitly specified the path things started to work:So, in the event that anyone has tried a few suggestions, believes their code is structured correctly and still finds themselves in a similar situation as myself try either of the following if you don't export the current directory to your PYTHONPATH:Run your code and explicitly include the path like so: To avoid calling , create a  file with contents like the following and run  to add packages to the path:
if both packages are in your import path (sys.path), and the module/class you want is in example/example.py, then to access the class without relative import try:
To obviate this problem, I devised a solution with the repackage package, which has worked for me for some time. It adds the upper directory to the lib path:Repackage can make relative imports that work in a wide range of cases, using an intelligent strategy (inspecting the call stack).
I needed to run python3 from the main project directory to make it work.For example, if the project has the following structure:SolutionI would run python3 inside folder project_demo/ and then perform a


Answer URL
https://docs.python.org/3/reference/import.html#__package__
https://docs.python.org/3/library/sys.html#sys.modules
https://docs.python.org/3/glossary.html#term-package
https://docs.python.org/3/using/cmdline.html?highlight=#cmdoption-m
https://docs.python.org/3/library/sys.html#sys.path
https://docs.python.org/3/library/site.html#site.USER_SITE
https://docs.python.org/3/library/venv.html
https://docs.python.org/3/library/importlib.html#importing-a-source-file-directly
