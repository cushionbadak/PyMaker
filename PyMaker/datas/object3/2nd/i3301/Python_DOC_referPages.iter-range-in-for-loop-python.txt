Natural Text
I thought the "for in" statement takes in iterables not iterators, but somehow the following codes works fine. I am confused. Actually, I was looking at the generator example at :https://www.python.org/dev/peps/pep-0289/Anyone can explain what happened when using iter(range(10)) in the for loop?
Iterators are iterables too.  calls  on the object it iterates over, and if you already have an iterator, then that produces a reference to the same object. This is by design.From the  entry in the Python glossary:Iterators are required to have an  method that returns the iterator object itself so every iterator is also iterable and may be used in most places where other iterables are accepted.Bold emphasis mine.From the same document, on the term :When using iterables, it is usually not necessary to call  or deal with iterator objects yourself. The  statement does that automatically for you, creating a temporary unnamed variable to hold the iterator for the duration of the loop.and from the Iterator types section of the standard types document:The iterator objects themselves are required to support the following two methods, which together form the iterator protocol:Return the iterator object itself. This is required to allow both containers and iterators to be used with the  and  statements. Bold emphasis mine.So when you use  instead of , you make an extra call to  that's basically redundant, as  already makes that call itself.But you can use  before you use a  loop to keep a reference to the iterator; so you could use it to advance to the next value elsewhere, in coordination with the  loop:In the PEP, in the detail section, the code example there uses an  call before calling the generator function, because that  call could potentially raise an exception. You'd want that exception to be raised when defining the generator expression, not later on when you try to iterate over the generator expression.Or put concretely, the following code fails on the first line, not during looping:If the implementation did not call  first, then only when the  loop executes would there be an exception, and that would be confusing because the  reference could have been created in any number of places in the code, really.


Answer URL
https://docs.python.org/3/glossary.html#term-iterator
https://docs.python.org/3/glossary.html#term-iterable
https://docs.python.org/3/library/stdtypes.html#typeiter
