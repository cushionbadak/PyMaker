Natural Text
I am trying to have a list returned when I call  on a class. What's the best way to do this. I want when  is called for it to run the  function and ideally I'd like to implement  that works when  is called I'd like to be able to do this with ,  and all other type casts
Unlike many other languages you might be used to (e.g., C++), Python doesn't have any notion of "type casts" or "conversion operators" or anything like that.Instead, Python types' constructors are generally written to some more generic (duck-typed) protocol.The first thing to do is to go to the documentation for whichever constructor you care about and see what it wants. Start in Builtin Functions, even if most of them will link you to an entry in Builtin Types.Many of them will link to an entry for the relevant special method in the Data Model chapter.For example,  says:… If x defines ,  returns . If x defines , it returns  …You can then follow the link to , although in this case there's not much extra information:Called to implement the built-in functions complex(), int() and float(). Should return a value of the appropriate type.So, you want to define an  method, and it should return an :The sequence and set types (like , , , ) are a bit more complicated. They all want an iterable:An object capable of returning its members one at a time. Examples of iterables include all sequence types (such as , , and ) and some non-sequence types like , file objects, and objects of any classes you define with an  method or with a  method that implements Sequence semantics.This is explained a bit better under the  function, which may not be the most obvious place to look:… object must be a collection object which supports the iteration protocol (the  method), or it must support the sequence protocol (the  method with integer arguments starting at 0) …And under  in the Data Model:This method is called when an iterator is required for a container. This method should return a new iterator object that can iterate over all the objects in the container. For mappings, it should iterate over the keys of the container.Iterator objects also need to implement this method; they are required to return themselves. For more information on iterator objects, see Iterator Types.So, for your example, you want to be an object that iterates over the elements of , which means you want an  method that returns an iterator over those elements. The easiest way to do that is to just call  on —or, if you want that  method for other reasons, maybe call  on what that method returns:Notice that, as Edward Minnix explained, Iterator and Iterable are separate things. An Iterable is something that can produce an Iterator when you call its  method. All Iterators are Iterables (they produce themselves), but many Iterables are not Iterators (Sequences like , for example). (and , etc.) is also a bit complicated. Check the docs, and you'll see that it wants either a mapping (that is, something like a ) or an iterable of key-value pairs (those pairs themselves being iterables). In this case, unless you're implementing a full mapping, you probably want the fallback:Almost everything else is easy, like —but notice that , , and  are sequences.Meanwhile, if you want your object to be convertible to an  or to a  or to a , you might want it to also act a lot like one in other ways. If that's the case, look at  and , which not provide helpers that are not only abstract base classes (used if you need to check whether some type meets some protocol), but also mixins (used to help you implement the protocol).For example, a full  is expected to provide most of the same methods as a —about 7 of them—but if you use the mixin, you only need to define 2 yourself:Now you can use a  almost anywhere you could use a —including constructing a  from it, of course.For some types, like , the shortcuts help even more—you get 17 methods for the price of 5.If you want the same object to be list-able and dict-able… well, then you run into a limitation of the design.  wants an iterable.  wants an iterable of pairs, or a mapping—which is a kind of iterable. So, rather than infinite choices, you only really have two:Iterate keys and implement  with those keys for , so  gives a list of those keys.Iterate key-value pairs for , so  gives a list of those key-value pairs.Obviously if you want to actually act like a , you only have one choice, the first one.The fact that the sequence and mapping protocols overlap has been part of Python from the beginning, inherent in the fact that you can use the  operator on both of them, and has been retained with every major change since, even though it's made other features (like the whole ABC model) more complicated. I don't know if anyone's ever given a reason, but presumably it's similar to the reason for the extended-slicing design. In other words, making dicts and other mappings a lot easier and more readable to use is worth the cost of making them a little more complicated and less flexible to implement.
This can be done with overloading special methods. You will need to define the  method for your class, making it iterable. This means anything expecting an iterable (like most collections constructors like , , etc.) will then work with your object.Note: You will need to wrap the returned object with  so that it is an iterator (there is a difference between iterable and iterator). A list is iterable (can be iterated over), but not an iterator (supports , raises  when done etc.)


Answer URL
https://docs.python.org/3/library/functions.html
https://docs.python.org/3/library/stdtypes.html
https://docs.python.org/3/reference/datamodel.html
https://docs.python.org/3/library/functions.html#func-int
https://docs.python.org/3/reference/datamodel.html#object.__int__
https://docs.python.org/3/glossary.html#term-iterable
https://docs.python.org/3/library/functions.html#iter
https://docs.python.org/3/reference/datamodel.html#object.__iter__
https://docs.python.org/3/library/collections.abc.html
https://docs.python.org/3/library/numbers.html
https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence
https://docs.python.org/3/library/functions.html
https://docs.python.org/3/reference/datamodel.html#special-method-names
