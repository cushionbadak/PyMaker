Natural Text
The problem is that upon defining  and its private subfunction - and thence after attempting to call the function (with the thought that it'd call the  override instead) it throws an error that states the function doesn't take any arguments, yet one was passed.And (obviously- in hindsight) trying to call the  method, it gives the exact same error.On this, I'm confused as I thought that firstmostly,  would be defined, then it'll have its basic private methods created (like , ,  etc.) and then the definition of the explicit  method would replace the implicitly generated  method.Can somebody explain either what the order of function definition is and what gets declared first and last, or explain how you would manage to override the hidden  (preferably, if possible, without using a class to mask a function).
The namespace in a function does not produce attributes.  is a local variable inside , nothing more. binds the name  in the current namespace, and in a function that means it assigns a local name, just like  would do.At most, you can return that object:It would be really surprising if all local variables in a function became attributes instead, even before you had actually executed the function!However, even if you gave a function object a  attribute, it still would not be used. You can only use a class to create an object with a  method:That's because  is a special method, and thus subject to the Special method lookup rules, which dictate that Python would look for the method on the type of the object, not the object itself.When Python evaluates , if  is not a function object Python will execute . Python does this to make sure that the  method is not used when you create your instance with ; classes are callables too but defining  should not clash with that.
What you're asking to avoid is what  is for. It allows an object with the method to masquerade as an function. When you're defining a function, you're not creating an object with properties - there simply is no method named  defined (.. that you've defined yourself, at least) on the object representing the function .However, it turns out you already have a function that handles your call, namely . You can also use decorators to wrap that function if necessary, or as you've suggested, create a class and instanciate an object instead.


Answer URL
https://docs.python.org/3/reference/datamodel.html#special-lookup
