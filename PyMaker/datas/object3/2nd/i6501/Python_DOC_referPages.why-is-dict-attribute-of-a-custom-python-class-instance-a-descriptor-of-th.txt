Natural Text
From https://stackoverflow.com/a/44880260/156458Note that the  attribute of custom Python class instances is  a descriptor; the  instance itself doesn't have the attribute, it is the class that  provides it (so   is returned).   may exist, but  does  not.Why is  attribute of a custom Python class instance   a descriptor of the class, instead of an actual attribute of the instance?
It's tempting to say that  has to be a descriptor because implementing it as a  entry would require you to find the  before you can find the , but Python already bypasses normal attribute lookup to find  when looking up other attributes, so that's not quite as compelling as it initially sounds. If the descriptors were replaced with a  key in every ,  would still be findable.There's some space savings by not having a key for  in every , but that's not the big reason. There's also time saved by not having to set a  key, and time and space saved by not creating a circular reference, and these benefits are all really nice, but they're still probably smaller than the next thing.The big thing requiring  to be a descriptor is handling attempts to reassign or delete an object's . If attribute lookup for  went through a  key, then reassigning  would reassign the dict key without changing what dict Python actually looks in to find 's attributes.  needs to be a descriptor so it stays in sync with the actual C-level struct slot Python looks in to find an object's dict.
Because it's the attribute that allows instances to have custom attributes.  It's where new custom attributes of an instance are typically be stored.  Some magic is required to avoid circular references (you wouldn't want to look up  on an instance to find  on that instance).  Class descriptors are one of two  Python mechanisms to have this sort of magic for instance attribute lookup.


Answer URL
https://docs.python.org/3/howto/descriptor.html
