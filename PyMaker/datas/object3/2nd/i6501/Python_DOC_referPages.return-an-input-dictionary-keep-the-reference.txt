Natural Text
I have a program where a dictionary of some properties must be copied for each year in my simulation, and some few keys have to be updated. But, when I sent a dictionary to a function, change it inside the function and than return it, the returned dictionary keep as a reference to the original one. Let me show a simple example with the code below.However as one can see above, the property 'value' was changed in the first dict too.When I use the copy.deepcopy function than it works as expected:But is this the only way to make it work!?
 approach does not return the result, it modifies  in order to include  values. That's why I first create a new empty  and copy the input values into it. approachSimilar to the previous version but using the  constructor comprehension approachAnd another copy method using  comprehensions. approachThe  notation before a function formal parameter (in the  line) means that the keyword arguments that are not explicitely specified will be stored as a .  is a common name for this variable. A single  works similar for positional arguments storing them in a .The  notation when calling a function means the opposite, extract the  values into keyword arguments. Same with  and lists.This way we are extracting  which is the original  into a set of keyword arguments and creating a new  with . I actually like this approach as you let Python handle the new  creation but you have to remember to use the  when calling change.
If the problem you see with  and  is that a copy of the dictionary will be created after each iteration of your simulation, you could consider using an immutable dictionary type. Unfortunately, immutable dicts are not supplied by the python standard library. However, the data structure is available in libraries such as pyrsistent. From the pyristent docs of pmap:
If it fits into your program, you can divide the data into two parts: the constant base which remains the same (and which you are now copying from one simulation round to the next) and the rest, i.e. the changes or updates. You can join the two parts using the ChainMap. It is available on Python 3, but it might be worth to backport it if you are using Python 2.Here is an example.


Answer URL
https://docs.python.org/3/library/collections.html#chainmap-objects
