Natural Text
In the constructor of my class under test a socket object is instantiated and assigned to a class member. I mocked the socket class and set a mocked socket object as return value to the socket constructor call. I then want to assert that connect() and sendall() is called on that object. I always get the assert error that the functions are not called when I assert on the original mocked class object or the one that I set to return on constructor call.I know I canâ€™t mock the class that is under test (and its members) because that would defeat the purpose here. Pseudo code:Test:The purpose of this test is:ensure the constructor of socket library is called with the right arguments.ensure that connect() is called with right arguments.ensure that sendall() is called with exactly what I want it to be called, when I pass message into mySocketHandler.write() method.
The complete answer derived from hints given by @ryanh119 and this post linkI will fix the example given above by ryanh119 and refrain from editing original question which i messed up, so for completeness:I also did some research and there would have been two more solutions that I want to mention. They are not as pythonicaly correct like the above ones but here it is:Make use of dependency injection by changing the  of socketHandler to take in a socket object and only instantiate it if not supplied in the args. That way i could have passed in a mock or MagicMock object and used that to do the asserts on.Make use of a extremely powerful mocking/patching tool called MonkeyPatch which actually can patch/mock instance variables of classes. This approach would have been like trying to kill a fly with a rocket launcher.
You're on the right track, but there are a couple things that need to change for this test to work.Part of your problem right off the bat is that the mock that  passes into your test method is called , but your test code is referring to something called .Also, 's first argument, the thing you want to patch, should be a string representation of the path to the module where you want to patch something. If your file structure looks like this:and you run your tests from the root directory, you'd want to call patch like this: Constructor is called - The most important thing to realize is that  is a  object representing the socket class. So to test that the constructor was called, you need to check . That will pass if your production calls .You may also want to assert that  is the same object as , to test that mySocketHandler not only calls the constructor, but assigns it to the right attribute.and 3.  and  are called properly - You should never call your mock in a test, because it can lead to falsely-passing assertions. In other words, you want your production code to be the only thing calling mocks. This means you shouldn't use the line , because then your previous assertion about the constructor will pass no matter what your production code does, and I think it's causing your other assertions to fail.is already an instance of , so it's return value will automatically be another, different  instance. Therefore, you don't need the first 2 lines of your test code above, and you only need one of the assertions on . The same ideas apply to .That's a lot to take in, here's what your test would look like if I wrote it:Bonus Round! s behave like s, except that they implement some default values for some magic methods. I don't use them unless I absolutely need them. Here's an example:


Answer URL
https://docs.python.org/3/library/unittest.mock.html?highlight=magicmock#unittest.mock.MagicMock
