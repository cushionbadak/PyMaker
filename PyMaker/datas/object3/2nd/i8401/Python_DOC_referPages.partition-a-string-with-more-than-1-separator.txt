Natural Text
I think what I want to do is a fairly common task but I've found no reference on the web. I have text with punctuation, and I want a list of the words. should beBut Python's  only works with one argument, so I have all words with the punctuation after I split with whitespace. Any ideas?
A case where regular expressions are justified:
re.split()re.split(pattern, string[, maxsplit=0])Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the list. (Incompatibility note: in the original Python 1.5 release, maxsplit was ignored. This has been fixed in later releases.)
Another quick way to do this without a regexp is to replace the characters first, as below:
So many answers, yet I can't find any solution that does efficiently what the title of the questions literally asks for (splitting on multiple possible separators—instead, many answers remove anything that is not a word, which is different). So here is an answer to the question in the title, that relies on Python's standard and efficient  module:where:the  matches one of the separators listed inside,the  in the regular expression is here to prevent the special interpretation of  as a character range indicator (as in ),the  skips one or more delimiters (it could be omitted thanks to the , but this would unnecessarily produce empty strings between matched separators), and removes the empty strings possibly created by leading and trailing separators (since empty strings have a false boolean value).This  precisely "splits with multiple separators", as asked for in the question title.This solution is furthermore immune to the problems with non-ASCII characters in words found in some other solutions (see the first comment to ghostdog74's answer).The  module is much more efficient (in speed and concision) than doing Python loops and tests "by hand"!
Another way, without regex
Pro-Tip: Use  for the fastest string operations Python has.Some proof...First, the slow way (sorry pprzemek):Next, we use  (as given by the suggested answer). MUCH faster:Finally, we use :Explanation: is implemented in C and unlike many string manipulation functions in Python,  does not produce a new string. So it's about as fast as you can get for string substitution.It's a bit awkward, though, as it needs a translation table in order to do this magic. You can make a translation table with the  convenience function. The objective here is to translate all unwanted characters to spaces. A one-for-one substitute. Again, no new data is produced. So this is fast!Next, we use good old .  by default will operate on all whitespace characters, grouping them together for the split. The result will be the list of words that you want. And this approach is almost 4x faster than !
Kinda late answer :), but I had a similar dilemma and didn't want to use 're' module.
Then this becomes a three-liner:ExplanationThis is what in Haskell is known as the List monad. The idea behind the monad is that once "in the monad" you "stay in the monad" until something takes you out. For example in Haskell, say you map the python  function over a List. If the result is a List, it will be append to the List in-place, so you'd get something like . This is known as map-append (or mappend, or maybe something like that). The idea here is that you've got this operation you're applying (splitting on a token), and whenever you do that, you join the result into the list.You can abstract this into a function and have  by default. Advantages of this approach:This approach (unlike naive regex-based approaches) can work with arbitrary-length tokens (which regex can also do with more advanced syntax).You are not restricted to mere tokens; you could have arbitrary logic in place of each token, for example one of the "tokens" could be a function which splits according to how nested parentheses are.
First, I want to agree with others that the regex or  based solutions are most performant.  For my use case the performance of this function wasn't significant, so I wanted to add ideas that I considered with that criteria.My main goal was to generalize ideas from some of the other answers into one solution that could work for strings containing more than just regex words (i.e., blacklisting the explicit subset of punctuation characters vs whitelisting word characters).Note that, in any approach, one might also consider using  in place of a manually defined list.Option 1 - re.subI was surprised to see no answer so far uses re.sub(...).  I find it a simple and natural approach to this problem.In this solution, I nested the call to  inside  — but if performance is critical, compiling the regex outside could be beneficial — for my use case, the difference wasn't significant, so I prefer simplicity and readability.Option 2 - str.replaceThis is a few more lines, but it has the benefit of being expandable without having to check whether you need to escape a certain character in regex.It would have been nice to be able to map the str.replace to the string instead, but I don't think it can be done with immutable strings, and while mapping against a list of characters would work, running every replacement against every character sounds excessive. (Edit: See next option for a functional example.)Option 3 - functools.reduce(In Python 2,  is available in global namespace without importing it from functools.)
try this:this will print 
Use replace two times:results in: 
I like re, but here is my solution without it:sep.__contains__ is a method used by 'in' operator. Basically it is the same asbut is more convenient here.groupby gets our string and function. It splits string in groups using that function:  whenever a value of function changes - a new group is generated. So, sep.__contains__ is exactly what we need.groupby returns a sequence of pairs, where pair[0] is a result of our function and pair[1] is a group. Using 'if not k' we filter out groups with separators (because a result of sep.__contains__ is True on separators). Well, that's all - now we have a sequence of groups where each one is a word (group is actually an iterable so we use join to convert it to string).This solution is quite general, because it uses a function to separate string (you can split by any condition you need). Also, it doesn't create intermediate strings/lists (you can remove join and the expression will become lazy, since each group is an iterator)
Instead of using a re module function re.split you can achieve the same result using the series.str.split method of pandas. First, create a series with the above string and then apply the method to the series.parameter pat takes the delimiters and returns the split string as an array. Here the two delimiters are passed using a | (or operator).The output is as follows: 
I'm re-acquainting myself with Python and needed the same thing.The findall solution may be better, but I came up with this:
In Python 3, your can use the method from PY4E - Python for Everybody.We can solve both these problems by using the string methods , , and . The  is the most subtle of the methods. Here is the documentation for :Replace the characters in  with the character in the same position in  and delete all characters that are in . The  and  can be empty strings and the  parameter can be omitted.Your can see the "punctuation":For your example:For more information, you can refer:PY4E - Python for Everybodystr.translatestr.maketransPython String maketrans() Method
using maketrans and translate you can do it easily and neatly
Another way to achieve this is to use the Natural Language Tool Kit (nltk).This prints: The biggest drawback of this method is that you need to install the nltk package.The benefits are that you can do a lot of fun stuff with the rest of the nltk package once you get your tokens.
First of all, I don't think that your intention is to actually use punctuation as delimiters in the split functions.  Your description suggests that you simply want to eliminate punctuation from the resultant strings.I come across this pretty frequently, and my usual solution doesn't require re.One-liner lambda function w/ list comprehension:(requires ):Function (traditional)As a traditional function, this is still only two lines with a list comprehension (in addition to ):It will also naturally leave contractions and hyphenated words intact. You can always use  to turn hyphens into spaces before the split.General Function w/o Lambda or List ComprehensionFor a more general solution (where you can specify the characters to eliminate), and without a list comprehension, you get:Of course, you can always generalize the lambda function to any specified string of characters as well.
First of all, always use re.compile() before performing any RegEx operation in a loop because it works faster than normal operation.so for your problem first compile the pattern and then perform action on it.
Here is the answer with some explanation.or in one line, we can do like this:updated answer
Create a function that takes as input two strings (the source string to be split and the splitlist string of delimiters) and outputs a list of split words:
got same problem as @ooboo and find this topic@ghostdog74 inspired me, maybe someone finds my solution usefullinput something in space place and split using same character if you dont want to split at spaces.
Here is my go at a split with multiple deliminaters:
I think the following is the best answer to suite your needs : maybe suitable for this case, but may not be suitable for other cases.
Heres my take on it....
I like the  way the best. The following procedure changes all separators defined in a string  to the first separator in  and then splits the text on that one separator. It also accounts for if  happens to be an empty string. It returns a list of words, with no empty strings in it.
Here is the usage:
If you want a reversible operation (preserve the delimiters), you can use this function:
You want Python's RegEx module's  method:http://www.regular-expressions.info/python.htmlExample


Answer URL
https://docs.python.org/3/library/re.html#re.sub
