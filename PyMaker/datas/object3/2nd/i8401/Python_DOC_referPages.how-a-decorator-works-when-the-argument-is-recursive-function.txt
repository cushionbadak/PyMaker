Natural Text
this is the decorator.the parts of result is:how this decorator works when the argument is recursive function? why the decorator can be executed for many times. how it works?
In your example, the  decorator is executed once, when it replaces the original version of  with the clocked version. The original  is recursive and therefore the decorated version is recursive too. And so you get the timing data printed for each recursive call - the decorated  calls itself, not the original version, because the name  now refers to the decorated version.It's a good idea to use  in decorators. This copies various attributes of the original function to the decorated version.For example, without :outputWith :outputwhich is what we'd get if we did  on the undecorated version.If you don't want the -decorated recursive function to print the timing info for all of the recursive calls, it gets a bit tricky. The simplest way is to not use the decorator syntax and just call  as a normal function so we get a new name for the clocked version of the function:outputAnother way is to wrap the recursive function in a non-recursive function and apply the decorator to the new function.outputAnother way is to modify the decorator so that it keeps track of whether it's executing the top level of the recursion or one of the inner levels, and only print the timing info for the top level. This version uses the  directive so it only works in Python 3, not Python 2.outputThe  function can be used on non-recursive functions, but it's a little more efficient to just use the original version of .Another handy function in  that you should know about if you're using recursive functions is . This keeps a cache of recently computed results so they don't need to be re-computed. This can enormously speed up recursive functions. Please see the docs for details.We can use  in conjunction with  or .outputAs you can see, even though we used the plain  decorator only a single line of timing info gets printed for the factorials of 4, 5, and 6 because the smaller factorials are read from the cache instead of being re-computed.
When you apply a decorator to a function, the function is passed as a parameter to the decorator. Whether the function is recursive or not does not matter.The codeis equivalent to
Maybe it helps to assume the "syntactic sugar" point of view.This is from PEP 318 with modifications (I simplified the example)The current syntax for function decorators as implemented in Python 2.4a2 is:This is equivalent to:As you can see the decorator function is called only once and the wrapper it returns is assigned to the name of the decorated function.Thus whenever the original function is called by its name (for example in a recursion) the wrapper (but not the decorator function) is called instead.
The decorated function is passed to the decorator as an argument and returned another function to replace the original one, the returned function is no recursive function, but when you call it, it'll call the original recursive function:When you call your decorated function , what you actually called is , and it actually call  in the following line:The decorator is executed only once.For understanding, you can think your function becomes to the following one after :


Answer URL
https://docs.python.org/3/library/functools.html#functools.wraps
https://docs.python.org/3/library/functools.html#functools.lru_cache
