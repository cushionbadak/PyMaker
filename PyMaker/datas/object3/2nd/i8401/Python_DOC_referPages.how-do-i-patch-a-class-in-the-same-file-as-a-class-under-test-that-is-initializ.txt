Natural Text
(Nota bene: This is heavily modified from the original question, to include details I erroneously elided.)This is the (summarized) file () I'm testing. It contains a decorator (derived from the  library) that calls a class method on another object(): I want to patch out , because that code makes an external call I'm not testing.I'd like to  class  in my unittest, to isolate and check 's functionality. This is my unittest (located in ):Debugging the above, I see that  is never actually mocked: the code proceeds into 's code, so it makes sense that  is never called, and thus the assertion fails. However, I'd like to properly monkey patch . This approach works if I'm monkey patching an import that exists in , but apparently not if the class is defined there?Note that I think this is likely an issue of where I'm patching, that is  should more likely be something like . But I'm very unclear on how to determine if that is the case, and if so, what the correct path is. For instance,  does not work.
Thanks to @user2357112, I arrived at this solution. Caveat: I don't know if this is standard or 'best' practice, but it seems to work.First, move the  to it's own file in . Then change the test to this:This forces the patch to execute prior to the import of the dummy class being decorated. It's a little weird because the import is inside the function, but for a test that seems fine.Bigger Caveat:This only works for the first test that imports something from the module where, in this case  imports from. At that juncture everything else in the class has been loaded and cannot be patched.


Answer URL
https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch
