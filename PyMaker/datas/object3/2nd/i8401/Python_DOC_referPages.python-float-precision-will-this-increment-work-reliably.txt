Natural Text
I use the following code to dynamically generate a list of dictionaries of every combination of incremental probabilities associated with a given list of items, such that the probabilities sum to 1. For example, if the  were  (leading to increment of  or ), and the list contained 3 items , then the function should returnThe code is as follows. The script generates the incrementer by calculating  and then iteratively adds the incrementer to  until the value is . I already know that python s are imprecise, but I want to be sure that the last value in  will be something very close to 1.0.How large can the  be before the imprecision of  breaks the reliability of the script? (specifically,  and )This is a small example, but real use will involve much larger permutation space. Is there a more efficient/effective way to achieve this goal? (I already plan to implement a cache.) Would  datatypes be useful here for speed or precision?
The script generates the incrementer by calculating  and then iteratively adds the incrementer to  until the value is .No, no, no. Just make a list of  by dividing each integer from 0 to x by x:The list will always have exactly the right number of elements, no matter what rounding errors occur.With NumPy, this would be :As for your overall problem, working in floats at all is probably a bad idea. You should be able to do the whole thing with integers and only divide by  at the end, so you don't have to deal with floating-point precision issues in . Also,  doesn't do what you want, since it doesn't allow repeated items in the same permutation.Instead of filtering permutations at all, you should use an algorithm based on the stars and bars idea to generate all possible ways to place  separators between  outcomes, and convert separator placements to probability dicts.
Thanks to @user2357112 for......pointing out the approach to work with s until the last step....directing me to stars and bars approach.I implemented  as a generator as follows:


Answer URL
https://docs.python.org/3/library/math.html#math.fsum
