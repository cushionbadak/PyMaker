Natural Text
My task is to remove all instances of one particular element ('6' in this example) and move those to the end of the list. The requirement is to traverse a list making in-line changes (creating no supplemental lists). Input example:  [6,4,6,2,3,6,9,6,1,6,5]Output example: [4,2,3,9,1,5,6,6,6,6,6]So far, I have been able to do this only by making supplemental lists (breaking the task's requirements), so this working code is not allowed:I've also tried  and  but have gotten into trouble with the indexing (which moves when I  then move the element to the end): For example - Additionally, I have tried to use the enumerate() function as follows, but run into problems on the right hand side of the b[idx] assigment line:Have read other stackoverflow entries here, here and here, but they do not tackle the movment of the element to one end.Would appreciate any help on this list traversal / inplace switching issue. Many thanks. EDIT@eph  - thank you. this is indeed an elegant response. I am sure it will pass my 'no new list' requirement?  I surely intend to learn more about lambda and its uses@falsetru - thank you for the reminder of the append/pop combination (which I tried to do in my original query via list.remove() and list.insert()@tdelaney - thank you as well. somehow your response is closest to what I was attempting, but it seems not to pass the test for [0, 0, 5]. 
Iterating the list reverse way, pop the element if it's 6, then append it.
It is a bad idea to modify list while traverse. You can either make a copy to traverse, or generate a new list during traverse.In fact, the question can be done in many ways, such as:
Why not try something like this?Basically, the approach is to first count the number of values.If 0, then returns (since Python produces a ValueError if the list.index method is called for an element not in the list).We can then set the first acceptable index for the value to be the length of the list minus the number of occurrences it exists in the list.We can then combine list.pop/list.append to then traverse the list until all the values desired occur at the end of the list.EDIT: This is horribly inefficient, better answer suggested above.This requires O(n^2) time, rather than O(n) time.
The key term here is "In Line". The way you do that is move  for each  to the end of the list. 
Use two runners. First from front to end checking for 6s, second from end to front pointing to last item that's not a 6. Keep swapping () until they meet.Catch: this is not stable like in a stable sort. But I don't see that as a requirement.Will try to write working code when in front of a python interpreter with a keyboard.
In case you need a stable sort (i.e. order of elements that are not 6 should remain the same), then the solution is:Note that this solution retains the order of not only non-matching elements, but of matching elements as well. So for example, if you change the check condition from "equal to 6" to "is an even number", all elements matching the condition will be moved to the end of list while retaining their order among themselves.
Why not keep it simple?


Answer URL
https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types
https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types
