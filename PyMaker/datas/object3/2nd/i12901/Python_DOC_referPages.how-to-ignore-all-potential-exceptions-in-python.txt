Natural Text
I'm writing a custom backup script in Python. Sometimes the mkdir function or the print function or whatever function are failing for diverse reasons. Such exceptions stop the whole script and halt the backup in the middle, which is very frustrating. So far, I've managed these problems by adding try: ... except: ... statements and properly managing these exceptions. However, one day some other statement or function might raise an exception as well because of some other reason that hasn't been triggered yet.Is there a way to tell a script to proceed anyway? An equivalent of wrapping every single statement of the code in a try: ... except: pass clause? A log would be better of course.I've noticed that when programming with GUI toolkits like Tkinter, the application keeps running even if exceptions are raised. Is it possible to accomplish this type of thing with the console?
Python has no way of doing that, and for good reasons.It seems you're confused about what does it mean to write "robust" software: a robust program is not a program that is hard to kill and that will keep running no matter what, but a program that will handle edge cases properly. Keeping running is NOT enough... keeping running doing sensible things is the key point.Unfortunately there's no way to do reasonable things automatically and you've to think on a case-by-case basis how to handle the error.Beware that if a program has a lot of  it's rarely a good program. Exceptions are meant to be raised in a lot of places and caught almost nowhere.Note also that every  is potentially a source of bugs... for example:cannot distinguish if the  is coming for accessing a non-existing key in  or if instead escaped from . Rarely the two cases should be handled the same way...Better is to write:so that only the side case of missing key in  is handled and instead a  exception will stop the program (stopping a program when you're not sure of what it's doing is the only reasonable thing to do).
There actually is a module that is supposed to do exactly that: https://github.com/ajalt/fuckitpy.Although it was obviously written as a joke. I cannot imagine a situation where doing something like that is a good idea. God, I can't believe I'm even suggesting that as a solution.What you should do instead is identify what lines of code can produce what kind of errors, and handle those errors properly. There is only so much places where errors can actually happen - mostly while interfacing with outside systems, including filesystem, network, user input etc. And remember that actually failing is often better than continuing "work" and messing up your data, files and so on. Exceptions are there for a reason, they are not a result of Guido's malice.
Python has 'BaseException' as the base class for Exception classes. You can catch and ignore the base class Exception and that will cover all exceptions.
Normally, this one should catch everything:Only problem is, that you don't get the exception object with this syntax, but that was not asked for in this case.
You can add a general except block like @Kanwar Saad proposed. The question is, can you continue with your program in a valid state after the exception has been raised?From the Zen of Python:Trying to catch all exceptions you know is in my opinion is the best way to go here. If you can not explicitly catch an exception you should not try to work around it. You (and your users) should know what exactly went wrong, otherwise your code might become a nightmare to debug.If you are worried about losing backup data maybe you could do something like this:This way you get both: A chance to fend of data loss and the exact error to debug it.I hope this helps!On a funny note: You could also use the fuckit module. Which silences ALL errors, including syntax errors. Do not, ever, use this in productive code though.This should work perfectly. It will not print the "foo", but you will reach the  without a crash.
pass keyword will ignore all the exceptions


Answer URL
https://docs.python.org/3/library/exceptions.html#exception-hierarchy
