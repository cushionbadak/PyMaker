Natural Text
tldr; see the final line; the rest is just preamble.  I am developing a test harness, which parses user scripts and generates a Python script which it then runs. The idea is for non-techie folks to be able to write high-level test scripts.I have introduced the idea of variables, so a user can use the  keyword in his script. E.g. , which I simply expand to . They can then use X later in their scripts - But what if someone writes ? That's going to generate invalid Python. If I have that  in a variable , then how can I check whether  is a valid Python variable?
In Python 3 you can use  to test whether a given string is a valid Python identifier/name.The last example shows that you should also check whether the variable name clashes with a Python keyword:So you could put that together in a function:Another option, which works in Python 2 and 3, is to use the  module:This will parse the assignment statement without actually executing it. It will pick up invalid identifiers as well as attempts to assign to a keyword. In the above code  is an arbitrary value to assign to the given name - it could be any valid expression for the RHS.
You could use exceptions handling and catch actually  and . Test it inside  block and inform user if there is some invalid input.
You could try a test assignment and see if it raises a :
In Python 3, as above, you can simply use . But in Python 2, this does not exist.The  module has a regex for names (identifiers): . But I couldn't find any documentation for it, so it may not be available everywhere. It is simply . A single  after it will let you test strings with .The docs say that an identifier is defined by this grammar:Which is equivalent to the regex above. But we should still import  in case this ever changes. (Which is very unlikely, but maybe in older versions of Python it was different?)And to filter out keywords, like ,  and , use . There is one caveat:  is not a keyword in Python 2, but still can't be assigned to. ( in Python 2 is ).So:
You can just let Python (works on any version in use today, as far as I know) do the check for you they way it normally would internally, and catch the exception:Notably,  is consistently raised whenever a  undergoes keyword argument expansion and has a key which isn't a valid function argument, and whenever a  literal is being constructed with an invalid key.The advantage over the accepted answer is that it is both compatible across both Python 3 and 2, and not as fragile as the / approach (which would count strings like  as valid).I haven't thoroughly audited this solution or written Hypothesis tests for it to fuzz it, so there might be some corner case, but it seems to generally work on Python 3.7, 3.6, 2.7, and 2.5 (not that anyone ought to be using 2.5 nowadays, but it's still out in the wild and you might be one of the few poor sods stuck having to write code that works with 2.6/2.5).
I don't think you need the exact same naming syntax as python itself.Would rather go for a simple regexp like:to make sure it's something alphanumeric, and then add a prefix to keep away from python's own syntax. So the non-techie user's declaration:should probably become after your parsing:


Answer URL
https://docs.python.org/3/library/stdtypes.html?highlight=identifier#str.isidentifier
https://docs.python.org/3/library/stdtypes.html#str.isidentifier
