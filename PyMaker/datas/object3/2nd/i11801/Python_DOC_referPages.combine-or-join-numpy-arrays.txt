Natural Text
How can I join two numpy ndarrays to accomplish the following in a fast way, using optimized numpy, without any looping?
Let's walk through a prospective solution to handle generic cases involving different shaped arrays with some inlined comments to explain the method involved. (1) First off, we store shapes of input arrays.(2) Next up, initialize a 3D array with number of columns being the sum of number of columns in input arrays and . Use  for this task.(3) Then, set the first axis of the 3D array for the first "na" columns with the rows from  with . So, if we assign it to , that second colon would indicate to NumPy that we need a broadcasted setting, if possible as always happens with singleton dims in NumPy arrays. In effect, this would be same as tiling/repeating, but possibly in an efficient way.(4) Repeat for setting elements from  into output array. This time we would broadcast along the first axis of  with , with that first colon helping us do that broadcasting.(5) Final step is to reshape the output to a 2D shape. This could be done with simply changing the shape with the required 2D shape tuple. Reshaping just changes view and is effectively zero cost.Condensing everything, the full implementation would look like this -
Not the prettiest, but you could combine , , and :Or for a 3x3 case:
What you want is, apparently, the cartesian product of  and , stacked horizontally. You can use the  module to generate the indices for the numpy arrays, then  to stack them:This results in a  of:Breaking down the indices thing: will generate something that looks like this if you convert it to a list:You want something like this: , , so you need to transpose the generator. The idiomatic way to do this is with . However, if you just directly assign these, you'll get , like this:But numpy arrays interpret tuples as multi-dimensional indexes, so you want to turn them to lists, which is why I mapped the  constructor onto the result of the  function.
You can use  and :
All arrays are indexable, so you can merge the by just calling:or you can use core numpy stacking functions, should look something like this:


Answer URL
https://docs.python.org/3/library/itertools.html
