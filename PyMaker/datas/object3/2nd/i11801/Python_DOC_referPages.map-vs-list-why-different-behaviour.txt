Natural Text
In the course of implementing the "Variable Elimination" algorithm for a Bayes' Nets program, I encountered an unexpected bug that was the result of an iterative map transformation of a sequence of objects.For simplicity's sake, I'll use an analogous piece of code here:This is definitely the wrong result.  Since [4, 5, 6] contains two even numbers,  should be added to each element at most twice.  I was getting unexpected behaviour with this in the VE algorithm as well, so I modified it to convert the  iterator to a  after each iteration.From my understanding of iterables, this modification shouldn't change anything, but it does.  Clearly, the  transform for the  case is applied one fewer times in the -ed version.My Bayes Nets program worked as well after finding this bug, but I'm looking for an explanation as to why it occurred.
The answer is very simple:  is a lazy function in Python 3, it returns an iterable object (in Python 2 it returns a ). Let me add some output to your example:Note the  - the value of  is 6. We could also transform the  function, passed to  in order to track the value of :Because  is lazy, it evaluates when  is being called. However, the value of  is  and that is why it produces confusing output. Evaluating  inside the loop produces expected output.
The issue has to do with how the  variable is accessed by the lambda functions you are creating. The way Python's scoping works, the lambda functions will always use the latest version of  from the outside scope when they're called, not the value that it had when they were defined.Since  is lazy, the lambda functions don't get called until after the loop (when you consume the nested s by passing them to ) and so, they all use the last  value.To make each lambda function save the value  has when they are defined, add  like this:This specifies an argument and its default value. The default will be evaluated at the time the lambda is defined, so when the lambda gets called later (without a second argument), the  inside the expression will be that saved default value.
If you want to use the lazy version, you need to fix  in each loop.functools.partial does exactly that:


Answer URL
https://docs.python.org/3/library/functions.html#map
https://docs.python.org/3/library/functools.html#functools.partial
