Natural Text
I am reading python source code:https://hg.python.org/cpython/file/2.7/Lib/collections.py#l621form the doc:This is right as i think,But why  is right? 
Why Strings Have  implements the behaviour of the  operator in Python. For strings, the  operator is overloaded to give us string formatting options. Where usually  would force the evaluation of  if  and  are numbers, for strings, we can change the behaviour of  so that  actually inserts the elements of  into  if  is a string.The way operator overloading works in Python is that each infix operator symbol - ,,,, etc. (and, as of Python 3.5, the matrix multiplication operator ) - corresponds to a specific method in the base definition of the class it's being called on. For , it is , for example. For , it is . We can overload these methods by simply redefining them within a class. If I have class , and  implements a member function , I can potentially make  behave very differently than what the usual definition of  is.In other words, the string formatting technique in Python actually callsunder the hood, where  is defined for objects belonging to class . The way  is implemented for strings yields, in this case, just , rather than the ridiculous interpretation of Why  in  and not In the specific case of , what's happening is that the function pointer (for want of a better word - note that Python doesn't have pointers, but it doesn't hurt to think in that way for a moment)  is being applied to each of the elements in , rather than the function .This is no different than doing, say, . We don't pass the function invocation , we pass a reference to the function as  and expect the function to be invoked by  with the second arguments to . i.e. that  will be invoked over each element of "52".We can't do  for exactly this reason. The function  would be invoked without the appropriate parameters passed in and return an error - what we want instead is a reference to the function  than we can deference and invoke whenever we like, which is accomplished by calling . A C++ AnalogyThe behaviour of  versus  is really no different than how function pointers work in C++: a function pointer for  is denoted by just  i.e. without the parentheses. Something analogous - but not quite the same - happens here. I introduce this here because it may make the distinction clearer, because on the surface pointers look very similar to what is happening and introducing pointers leads to a fairly familiar mode of thinking which is good enough for this specific purpose.In C++, we can pass function pointers to other functions and introduce a form of currying - you can then invoke the function pointer on elements through regular  syntax inside another function, for example. In Python, we don't have pointers - we have wrapper objects that can reference the underlying memory location (but prevent raw access to it). For our purposes, though, the net effect is the same. @Bukuriu explores the difference in the comments.Basically,  forces an evaluation with no parameters;  returns a pointer to  than can then be invoked by another function on suitable parameters. Internally, that is what  does: take a function pointer (again, this is an analogy), and then deference and evaluate it on another element.You can see this yourself: calling  returnsi.e. a wrapper object with a reference to the memory address to the function. Meanwhile, calling  returns an error:because the extra parentheses invoked an evaluation of  and found there were no arguments. 
As in http://rafekettler.com/magicmethods.html saysThis means when you do string formating  you do 
Let's break this case down.Essential parts of this complex line are:First line calls s method to retrieve top counts from dictionary. Third line joins string representations to single comma-separated string. Both are fairly trivial.Second line:- calls  - which tells us it calls some function for each element in - first argument of map defines function as We know that operator overloading is done by redefining  in class declaration. Strings happens to define  as interpolation operation.Also, we know that most of operations are just syntactic sugars around those magic methods.What happens here is magic method being referred explicitly instead of via  syntactic sugar. Or, from different perspective, underlining implementation detail is used perform operation instead of standard form.Second line is roughy equivalent to:


Answer URL
https://docs.python.org/3/whatsnew/3.5.html#pep-465-a-dedicated-infix-operator-for-matrix-multiplication
