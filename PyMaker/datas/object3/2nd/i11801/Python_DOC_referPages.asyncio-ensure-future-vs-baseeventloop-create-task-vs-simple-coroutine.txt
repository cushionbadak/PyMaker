Natural Text
I've seen several basic Python 3.5 tutorials on asyncio doing the same operation in various flavours.In this code:All the three variants above that define the  variable achieve the same result; the only difference I can see is  that with the third variant the execution is out of order (which should not matter in most cases). Is there any other difference? Are there cases where I can't just use the simplest variant (plain list of coroutines)?
Actual info:Starting from Python 3.7  high-level function was added for this purpose. You should use it instead other ways of creating tasks from coroutimes. However if you need to create task from arbitrary awaitable, you should use .Old info: vs  is a method to create  from . It creates tasks in different ways based on argument (including using of  for coroutines and future-like objects). is an abstract method of . Different event loops can implement this function different ways.You should use  to create tasks. You'll need  only if you're going to implement your own event loop type.Upd:@bj0 pointed at Guido's answer on this topic:The point of  is if you have something that could  either be a coroutine or a  (the latter includes a  because  that's a subclass of ), and you want to be able to call a method  on it that is only defined on  (probably about the only useful  example being ). When it is already a  (or ) this  does nothing; when it is a coroutine it wraps it in a .If you know that you have a coroutine and you want it to be scheduled,  the correct API to use is . The only time when you should  be calling  is when you are providing an API (like most  of asyncio's own APIs) that accepts either a coroutine or a  and  you need to do something to it that requires you to have a .and later:In the end I still believe that  is an appropriately  obscure name for a rarely-needed piece of functionality. When creating  a task from a coroutine you should use the appropriately-named  . Maybe there should be an alias for that  ?It's surprising to me. My main motivation to use  all along was that it's higher-level function comparing to loop's member  (discussion contains some ideas like adding  or ).I can also point that in my opinion it's pretty convenient to use universal function that can handle any  rather than coroutines only.However, Guido's answer is clear: "When creating a task from a coroutine you should use the appropriately-named "When coroutines should be wrapped in tasks?Wrap coroutine in a Task - is a way to start this coroutine "in background". Here's example:Output:You can replace  with just  to feel the difference.
accepts coroutines, returns Task, it is invoked in context of the loop.accepts Futures, coroutines, awaitable objects,returns Task (or Future if Future passed). if the given arg is a coroutine it uses ,loop object can be passed. As you can see the create_task is more specific. function without create_task or ensure_futureSimple invoking  function returns coroutineAnd since the  under the hood ensures () that args are futures, explicitly  is redundant.Similar question What's the difference between loop.create_task, asyncio.async/ensure_future and Task?
Note: Only valid for Python 3.7 (for Python 3.5 refer to the earlier answer).From the official docs: (added in Python 3.7) is the preferable way for spawning new tasks instead of . Detail:So now, in Python 3.7 onwards, there are 2 top-level wrapper function (similar but different):: which simply call  directly. (see source code) which also call  if it is coroutine or else it is simply to ensure the return type to be a asyncio.Future. (see source code). Anyway,  is still a  due to its class inheritance (ref). Well, utlimately both of these wrapper functions will help you call . The only difference is  accept any  object and help you convert it into a Future. And also you can provide your own  parameter in . And depending if you need those capability or not, you can simply choose which wrapper to use.
for your example, all the three types execute asynchronously. the only difference is that, in the third example, you pre-generated all 10 coroutines, and submitted to the loop together. so only the last one gives output randomly.


Answer URL
https://docs.python.org/3/library/asyncio-task.html#creating-tasks
https://docs.python.org/3/library/asyncio-task.html#asyncio.Task
https://docs.python.org/3/library/asyncio-task.html#coroutines
https://docs.python.org/3/library/asyncio-future.html#asyncio.Future
https://docs.python.org/3/library/asyncio-eventloops.html#asyncio.AbstractEventLoopPolicy.get_event_loop
https://docs.python.org/3/library/asyncio-task.html#asyncio.ensure_future
