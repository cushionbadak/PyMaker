Natural Text
I am using json.dumps to dump a class I created.  There are two list data members, one is never used but one is used to manage the building of another data member list.  The never used lists are not present in the generated JSON, but the used list is added even when I clear it from every instance of the object in a list of those objects.  I do not want this empty list in the JSON.Before I return the list to be passed to dumps, I do thisI tried clearing in my own JSONEncoder too.  The attributeNameList members are cleared when I look at them in the debugger, but they are emitted by dumps as an empty array.  The other untouched, empty lists never show.The other difference is the empty lists that do not show are declared in the same way, but attributeNameList is initialized in  method of my class.Is there a way to prevent this particular empty list from being converted to attributeList is never added to the JSON output.The never used lists and the cleared list look exactly the same in the debugger--empty.  Python may have a dirty bit on the list and uses it to decide when to emit as JSON.Thanks.Here is the encoder code (as requested)
Your class has two attributes which are lists -  and .Instances of the class have  as an attribute, because it's initialised in the __ init __ method.  This instance attribute overrides the class attribute.Your encoder is serialising everything in an instance's __ dict __, which will include .  If you don't want to serialise  when it's empty then you'll need to add some logic in the encoder to handle this: for example:EDIT: more on class attributesWhen you try to access an attribute  on an instance Python first looks in the instance's __ dict __.  If the attribute isn't found there, Python will look in the instance's class's __ dict __.  If it finds the attribute there it will return it. This means that class attributes are shared across all instances of the class.  See the tutorial for more on this.As class attributes are shared across instances, changes to a class attribute will be visible to all instances.  This can result in surprising or undesirable behaviour:In cases like the above example you can take a copy of the attribute in your __ init __ method to mitigate this.As @blackjack observed, mutable class attributes are usually a code smell, but they do have some uses: for example, if a class wants to keep track of its instances.


Answer URL
https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables
