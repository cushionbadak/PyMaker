Natural Text
This question might superficially look like a duplicate,but it is not about the usual mutable surprise with lists.More details later, but in a nutshell, just aftersometimes  and  were not identical.The app is single-threaded, and the difference lasts,so it does not seem to be a race condition or buffer delay.I did clear the cache:I tried to come up with an mcve,but could not reproduce the bug. Here is an attempt.A snapshot and steps to reproduce can be found in this issue.As soon as the  was expanded to check also fields that did change, both  and  held elements that were equal (in the sense of ), so good enough, but not identical, which is still weird.Is that something known ? here is my python version:What could be happening ?
Such behavior can be caused by many things, all of which control how an object's attributes are accessed.In that sense  is very much different from . The former attempts to set the attribute  with on the object  while the latter binds the name  to the object  in the local scope.DescriptorsDescriptors can control how attributes aredealt with by defining the special methods , , . An example:Properties is probably one of the most prominent usage scenarios fordata descriptors. Hence the workings are very similar: and By defining the methods  and a class can control the attribute accessof its instances. For example:How can I find out what intercepts the attribute access?You can check  in order to find out whether  is defined to be a descriptor.Similarly you can check  to see whether any of the base classes definesthis special method. Worth noting here is that any of the above described methods also works if it is definedon any of the classes sitting in the method resolution order (, i.e. the parent classes).So you would need to check for example:The OP's specific exampleThe class you linked inherits fromthis class which definesin a way that it checksfor equality (; not identity ()) with an existing value and returns if they compare equal.That means especially if you have two lists that compare equal, i.e. , thendoing  will just return and not set the attribute. Hence nothing changedand the two objects ( and ) are still distinct. The code basically comes down to this:


Answer URL
https://docs.python.org/3/reference/datamodel.html#descriptors
https://docs.python.org/3/library/functions.html#property
https://docs.python.org/3/reference/datamodel.html#object.__getattribute__
https://docs.python.org/3/reference/datamodel.html#object.__setattr__
