Natural Text
I am doing a simple comparison between a string value and floats minValue and maxValue to check if value is outside of a certain range It works fine unless value and minValue are the same. So when  and , it goes inside the if statement because for some reason  evaluates to .My workaround is to use Decimal But  looks a little messy so I'm wondering if there is a better way of comparing two floats that won't fail when they are the same value without having to do float to string to decimal conversion first.EDIT comes from a csv file, so there is no truncation there. What you see is what you get.  is, however, a result of a polynomial function, but I don't believe there is any truncation or rounding there.Here's the function to calculate minValue
Note that in general, this isn't going to be solvable without ; floating point math is inherently imprecise across many calculations, and what should logically arrive at  can easily become  or  (only for illustration, your computer may differ, but those are the closest values to  on either side on my machine that don't end up rounding off to the canonical representation of ; your calculation might be that close, or it might be off by a bit more, but likely still an error of less than ).That said, if you happen to know, with certainty, that your values should never need more than  decimal places of precision, you can often get away with using the faster , via the  function, to ensure your values are really the closest representable value to what they should be logically. Since it appears  and  are computed once up front, just change the last step to round them off as well, e.g.:which removes any spurious excess precision. Heck, if you're not sure how precise you need to be, just double your best guess; the imprecision you're likely to see in most cases is usually well past 10 digits past the decimal point, so if you only think you need three digits, but you're worried you might still remove valid data (e.g. maybe you've got a division by  that might leave an extra, valid  at the end), just go up a bit more, rounding to , or even  decimal places.Similarly, change the code that performs the comparison to normalize  as well, e.g.:or even better (avoids doubling up the conversion code):which takes advantage of Python's chained comparison operators (it's equivalent to typing , except  is only computed once).
The reason it is not working is becasue  is not greater or less than .  is false and is also false. If you want to also make it true if they are equal you would need to use  or  which means "greater then or equal to" 


Answer URL
https://docs.python.org/3/library/functions.html#round
