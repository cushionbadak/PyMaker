Natural Text
I am curious to understand how Python  loops work under the hood. I tried to implement it somewhat like the following code snippet, is that how the for loop has been implemented?
Yes, that's a good approximation of how the  loop construct is implemented. It certainly matches the  loop statement documentation:The expression list is evaluated once; it should yield an iterable object. An iterator is created for the result of the . The suite is then executed once for each item provided by the iterator, in the order returned by the iterator. Each item in turn is assigned to the target list using the standard rules for assignments (see Assignment statements), and then the suite is executed. When the items are exhausted (which is immediately when the sequence is empty or an iterator raises a  exception), the suite in the  clause, if present, is executed, and the loop terminates.You only missed the assigned to the target list using the standard rules for assignments part; you'd have to use  and  rather than print the result of the  call directly.Python source code is compiled to bytecode, which the interpreter loop then executes. You can look at the bytecode for a  loop by using the  module:The various opcodes named are documented in the same  module, and their implementation can be found in the CPython evaluation loop (look for the  switch targets); the above opcodes break down to: marks the start of the suite, a block of statements, so the interpreter knows where to jump to in case of a , and what cleanup needs to be done in case of an exception or  statement; the clean-up opcode is located 12 bytes of bytecode after this opcode (so  here). loads the  variable value, putting it on the top of the stack (TOS in opcode descriptions). calls  on the object on the TOS, then replaces the TOS with the result. calls  on the TOS iterator. If that gives a result, then that's pushed to the TOS. If there is a  exception, then the iterator is removed from TOS, and 4 bytes of bytecode are skipped to the  opcode. takes the TOS and puts it in the named variable, here that's . marks the end of the loop body; it tells the interpreter to go back up to bytecode offset 6, to the  instruction above. If we did something interesting in the loop, then that would happen after , before the . removes the block bookkeeping set up by  and removes the iterator from the stack.The  markers are jump targets, there as visual cues to make it easier to spot those when reading the opcode line that jumps to them.


Answer URL
https://docs.python.org/3/reference/compound_stmts.html#the-for-statement
https://docs.python.org/3/library/dis.html
https://docs.python.org/3/library/dis.html#opcode-SETUP_LOOP
https://docs.python.org/3/library/dis.html#opcode-LOAD_NAME
https://docs.python.org/3/library/dis.html#opcode-GET_ITER
https://docs.python.org/3/library/dis.html#opcode-FOR_ITER
https://docs.python.org/3/library/dis.html#opcode-STORE_NAME
https://docs.python.org/3/library/dis.html#opcode-JUMP_ABSOLUTE
https://docs.python.org/3/library/dis.html#opcode-POP_BLOCK
