Natural Text
I am trying to make the below code asynchronous:Currently it will work synchronously.Is it because the  function is lacking  statement?I have tried reworking the function to include :and it will start asynchronously (both  and  will get printed one after another), but then I get an error:TypeError: object int can't be used in 'await' expressionI understand that the error happened because the result of  is not an awaitable (a coroutine), but I don't know how to fix this without running in circles. Do I need to somehow refactor the for loop into a couroutine on its own?
Is it because the count function is lacking  statement?In short, yes, you have identified the issue correctly. To get parallel execution of tasks, you need not only to specify , but also to await something that suspends execution, thus returning control to the event loop. In asyncio that is typically the kind of call that would block a synchronous program, such as a sleep or a read from a socket that is not yet ready for reading.To force a temporary suspension, you can add  inside the loop in . Adding  in front of an ordinary function such as , doesn't work because  requires an object that implements the awaitable interface, and in your code  just returns an integer.
Your code calls a  that runs both  and  concurrently. Then you call an await on  in each function. But this will   on that subroutine to finish. So the overall subroutine will still finish before the next subroutine begins. You need a function to suspend the entire task. I created two ways to circumvent this. Both involve creating new tasks. Creating a new subroutine: You could also keep your  function the same as the original code and change your  like this to make  a new task:You can also use  if you have python 3.7. Source: https://docs.python.org/3/library/asyncio-task.html
For asyncio to work properly, you should not have any cpu intensive task (tight big for loop) in the event loop. As there is no way to get out of the for loop. If you use an explicit  inside the loop, you are just going in and out of the coroutine unnecessarily and slowing the entire thing. If your goal is just to see how asyncio works, it is fine. But in real world, if you have a cpu intensive task, you have two optionsUse multiprocessing and delegate the task to a different process.Use a native code binding that releases GIL and uses threads.As the name suggests, the library is for asynchronous io. 


Answer URL
https://docs.python.org/3/library/asyncio-task.html
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.run_in_executor
