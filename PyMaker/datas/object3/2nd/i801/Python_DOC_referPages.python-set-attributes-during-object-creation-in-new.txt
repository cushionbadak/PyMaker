Natural Text
When using __new__ to customize the creation of a metaclass, we can pass attributes to the type().__new__ method which will be set on the object before it is returned, e.g.So that:However I don't know how to do the same for a normal (non-meta) class, which causes a problem when using __setattr__:So that unfortunately:In the __new__ of Bar I get back a fully fledged class instance from object() and any attribute access goes through normal lookup rules, in this case invoking __setattr__. Metaclass Foo avoids this as type() will set attributes before returning the instance during low-level creation whereas object() will not.Is there a way of passing attributes to object() or is another another type I can use as the instance returned from __new__ that does allow attributes to be set before it becomes a full class instance? I am not interesting in solutions like setting __class__ after instance creation.
You have to explictly bypass your own class's  by calling the  or root  . So you'd change:to:A less general approach (doesn't apply to  based classes) is to directly assign to  using  operations:The first approach is what the newly -ed  now uses; before it became -ed, it used the second approach. In both cases this was needed because they used the same  trick to make the type as immutable as possible (without going to the trouble of subclassing , a la ).


Answer URL
https://docs.python.org/3/library/typing.html#typing.NamedTuple
