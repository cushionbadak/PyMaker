Natural Text
When reading source code of python logging module, I found code like this:why? Is it equals this?
Obvious - there is no  (exception info) until some exception arises. So we need to rise exception to access its info and get call stack from it.This seems to be the easiest way to access current call stack.
According to the official docs for , you need an exception in any stack frame to get a tuple of . If there is no exception handled, you get a tuple with  values. The stack frame could be: the current stack, or the calling stack for a function or the caller(function) itself. In logging, we are concerned with the  for the current stack(notice ) only and therefore will have to raise an Exception in order to access the tuple values. Here's an excerpt from the docs:This function returns a tuple of three values that give information about the exception that is currently being handled. The information returned is specific both to the current thread and to the current stack frame. If the current stack frame is not handling an exception, the information is taken from the calling stack frame, or its caller, and so on until a stack frame is found that is handling an exception. Here, “handling an exception” is defined as “executing an except clause.” For any stack frame, only information about the exception being currently handled is accessible.If no exception is being handled anywhere on the stack, a tuple  containing three None values is returned. Otherwise, the values  returned are (type, value, traceback). Their meaning is: type gets the  type of the exception being handled (a subclass of BaseException);  value gets the exception instance (an instance of the exception type);  traceback gets a traceback object (see the Reference Manual) which  encapsulates the call stack at the point where the exception  originally occurred.sys._getframe([depth]) returns the frame object from the call stack. If optional integer depth is given, return the frame object that many calls below the top of the stack. The default for depth is zero, returning the frame at the top of the call stack. Another important point to consider is that this function is not guaranteed to exist in all implementations of Python. We know that CPython has it. The following piece of code from  performs this check. Note that  is a lambda function.:This means: if sys._getframe() exists in the Python implementation, return the 3rd frame object from the top of the call stack.  If  does not have this function as an attribute, the  statement below raises an Exception to capture the frame object from the .To understand this concept better, I've used the above  code to frame an example(no pun intended). This is inspired by the excellent explanation here. The following example contains 3 functions which were saved in a file called .On running this code with , we get the following output:Explanation:Function get_current_frame(x): This function contains the same code from the  statement from . The only difference is that we are passing the depth argument  to the function which is used by the  function to grab the frame object at that depth: .Function show_frame(num, frame): This function s the frame object, the frame function call with its depth, , the caller function name eg. ..etc. , the file name of the file that executes the calling function code along with the current line no. in the code of the calling function.  is an attribute of the frame object returned by  and is a code object.  is an attribute of this code object and returns the name with which the code object was defined(you can print  to check this). Similarly,  retrieves the filename and  retrieves the current line no. You can find an explanation of these attributes in the inspect docs which is also used to get frame objects interestingly. You can also write some isolated code to understand how these attributes work. For eg. the below code gets the current frame (i.e.: the frame object at the top of the stack, depth 0(default)) and prints the filename of the code object for that frame(I'm running this code in ). The calling stack is not too deep because there is just one function call to . If we change the code to get the frame at depth 1, we get an error:Function test(): This function gets the current frame object for depth  in some range and then calls  for that  and frame object.When  is called, the calling stack is: test --> get_current_frame --> show_frame. In subsequent calls, the stack is get_current_frame ---> show_frame until the  loop completes for the range(4) in . If we examine the output from the top, the frame at the top of the stack has depth 0:  and the calling function is the lambda function itself. The line no. 74 in  is the current line no. when this function was called(imagine it like the last cursor position for that frame). Finally, we look at the frame at the bottom of the stack. This is also the frame object(with depth 3) that is used in logging:In logging, we need a depth of 3 to reach the stack frame of the caller function. We can also use our previous toy example to understand this concept. As the stack is not too deep, we get the current frame at depth 0.Now, what if my Python implementation does not have  attribute for ? In this case, the code in  will execute and raise an Exception to get the current frame from the . The following function does this and the calling function here is  again(notice the output): returns the frame object for the traceback frame  returned by the current Exception . We can check this by printing the return statement:  and we get something like: This explains how the logging module captures the current frame.So, where is  later used in the logging source code? You will find it here:The above function gets the current frame of the caller function and uses this information later to get the same attributes(file name etc.) that we accessed earlier.


Answer URL
https://docs.python.org/3/library/sys.html#sys._getframe
