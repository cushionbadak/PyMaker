Natural Text
I'm reading from a named pipe in a blocking manner.I want my python script to react to SIGTERM signals.This is what i've got so far:When the script receives a SIGTERM signal, it closes the pipe as expected but raises a RuntimeError.Is there another way to get out of the foor loop and close the fifo gently?
TL;DR You need a non-blocking read in order to be able to control termination; asyncio using aiofiles is probably the most elegant solution, but they all have their quirks.Sample ProducerI'm going to start with how one would go about writing a well-behaved producer of data to a named pipe, because it's an easier vehicle to introduce some APIs.This writes the current date out to the named pipe as a string once a second.  and  will both shut the pipe down gracefully, writing  as the last line to the pipe before closing down. It uses a  to communicate between the  method (which will be run on a background thread) and  (which waits for at most one second before advancing to the next iteration of the loop).  immediately returns  if the signal is set, or  after waiting at most one second without the signal being set.Sample (Buggy) ConsumerIt would be tempting to use a similar technique to write the consumer:Unfortunately this won't work great in practice because  opens files in blocking mode. This means  calls block the calling thread, which essentially prevent "nice" aborts unless you check in-between  calls. Concretely, if the producer stops producing but kept the pipe open, the consumer would sit forever at  and would never get around to checking the signal for "nice" termination.Sample (Less Buggy) ConsumerThis example avoids the problem of a misbehaving producer trapping the consumer in a blocking read call, but it's considerably more complicated and forces you to use lower-level APIs that are not nearly as friendly:A proper implementation would be FAR more complicated, because this code naively assumes that:each  call from the pipe is a single, complete "message"; this is the worst assumption. You could speed up the producer and see that this less buggy consumer starts reading multiple "lines" as a single line.a line never spans more than 1000 bytes; a more advanced implementation would need to buffer "partial" messages, look for newlines, and split accordinglyIn all but the most simplistic and slow-moving use cases (like, say, a once-a-second ticking clock), this implementation would need a TON of work in order to be practically useful.Sample Consumer ()The challenge in writing this properly is that there are multiple unpredictable sources of events (signals, incoming data from a pipe).  allows you to express your code as coroutines, and they can be suspended and resumed when Python feels like it, but with you specifying the rules.The  method kicks off two threads streams things of work: one which reads lines one-by-one as they come in, and the other which essentially hangs until a signal is received. It proceeds when EITHER of these two things finishes.Unfortunately I noticed that ultimately  relies on a blocking implementation under the hood, because the  method still hangs if a  is in progress. But at least there is a spot to place your code.Wrapping it upUltimately there isn't a super great out-of-the-box solution to solving your problem, but hopefully one of these variations can help you solve your problem.


Answer URL
https://docs.python.org/3/library/asyncio.html
