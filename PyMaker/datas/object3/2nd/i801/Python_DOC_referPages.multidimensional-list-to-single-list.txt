Natural Text
Yes, I know this subject has been covered before (here, here, here, here), but as far as I know, all solutions, except for one, fail on a list like this:Where the desired output isOr perhaps even better, an iterator. The only solution I saw that works for an arbitrary nesting is found in this question:Is this the best model? Did I overlook something? Any problems?
Using generator functions can make your example a little easier to read and probably boost the performance.Python 2I used the Iterable ABC added in 2.6.Python 3In Python 3, the  is no more, but you can use a tuple of  and  to get the same effect there.The  operator returns an item from a generator one at a time. This syntax for delegating to a subgenerator was added in 3.3
My solution:A little more concise, but pretty much the same.
Generator version of @unutbu's non-recursive solution, as requested by @Andrew in a comment:Slightly simplified version of this generator:
Generator using recursion and duck typing (updated for Python 3):
This version of  avoids python's recursion limit (and thus works with arbitrarily deep, nested iterables). It is a generator which can handle strings and arbitrary iterables (even infinite ones).Here are some examples demonstrating its use:Although  can handle infinite generators, it can not handle infinite nesting:
Here is my functional version of recursive flatten which handles both tuples and lists, and lets you throw in any mix of positional arguments. Returns a generator which produces the entire sequence in order, arg by arg:Usage:
Here's another answer that is even more interesting...Basically, it converts the nested list to a string, uses a regex to strip out the nested syntax, and then converts the result back to a (flattened) list.

You could use  from the 3rd party package :It's an iterator so you need to iterate it (for example by wrapping it with  or using it in a loop). Internally it uses an iterative approach instead of an recursive approach and it's written as C extension so it can be faster than pure python approaches:I'm the author of the  library.
It was fun trying to create a function that could flatten irregular list in Python, but of course that is what Python is for (to make programming fun). The following generator works fairly well with some caveats:It will flatten datatypes that you might want left alone (like , , and  objects). Also, the code relies on the fact that requesting an iterator from a non-iterable raises a .Edit:I disagree with the previous implementation. The problem is that you should not be able to flatten something that is not an iterable. It is confusing and gives the wrong impression of the argument.The following generator is almost the same as the first but does not have the problem of trying to flatten a non-iterable object. It fails as one would expect when an inappropriate argument is given to it.Testing the generator works fine with the list that was provided. However, the new code will raise a  when a non-iterable object is given to it. Example are shown below of the new behavior.
I prefer simple answers.  No generators.  No recursion or recursion limits.  Just iteration:This works with two lists: an inner for loop and an outer while loop.  The inner for loop iterates through the list.  If it finds a list element, it (1) uses list.extend() to flatten that part one level of nesting and (2) switches keepChecking to True.  keepchecking is used to control the outer while loop.  If the outer loop gets set to true, it triggers the inner loop for another pass.  Those passes keep happening until no more nested lists are found.  When a pass finally occurs where none are found, keepChecking never gets tripped to true, which means listIsNested stays false and the outer while loop exits.  The flattened list is then returned.Test-run   
Although an elegant and very pythonic answer has been selected I would present my solution just for the review:Please tell how good or bad this code is?
Here's a simple function that flattens lists of arbitrary depth. No recursion, to avoid stack overflow.
Here's the  implementation in 2.7.5:There are better, faster methods (If you've reached here, you have seen them already)Also note:Deprecated since version 2.6: The compiler package has been removed in Python 3.
I'm surprised no one has thought of this. Damn recursion I don't get the recursive answers that the advanced people here made. anyway here is my attempt on this. caveat is it's very specific to the OP's use caseoutput:
I didn't go through all the already available answers here, but here is a one liner I came up with, borrowing from lisp's way of first and rest list processing here is one simple and one not-so-simple case -
totally hacky but I think it would work (depending on your data_type)
Here is another py2 approach, Im not sure if its the fastest or the most elegant nor safest ...It can ignore any specific (or derived) type you would like, it returns an iterator, so you can convert it to any specific container such as list, tuple, dict or simply consume it in order to reduce memory footprint, for better or worse it can handle initial non-iterable objects such as int ...Note most of the heavy lifting is done in C, since as far as I know thats how itertools are implemented, so while it is recursive, AFAIK it isn't bounded by python recursion depth since the function calls are happening in C, though this doesn't mean you are bounded by memory, specially in OS X where its stack size has a hard limit as of today (OS X Mavericks) ...there is a slightly faster approach, but less portable method, only use it if you can assume that the base elements of the input can be explicitly determined otherwise, you'll get an infinite recursion, and OS X with its limited stack size, will throw a segmentation fault fairly quickly ...here we are using sets to check for the type so it takes O(1) vs O(number of types) to check whether or not an element should be ignored, though of course any value with derived type of the stated ignored types will fail, this is why its using ,  so use it with caution ...tests:
Using :Or without chaining:
I used recursive to solve nested list with any depthSo after i define function combine_nlist, it is easy to use this function do flatting. Or you can combine it into one function. I like my solution because it can be applied to any nested list.result
The easiest way is to use the morph library using .The code is:
I am aware that there are already many awesome answers but i wanted to add an answer that uses the functional programming method of solving the question. In this answer i make use of double recursion :output:
I'm not sure if this is necessarily quicker or more effective, but this is what I do:The  function here turns the list into a string, takes out all of the square brackets, attaches square brackets back onto the ends, and turns it back into a list. Although, if you knew you would have square brackets in your list in strings, like , you would have to do something else.
When trying to answer such a question you really need to give the limitations of the code you propose as a solution. If it was only about performances I wouldn't mind too much, but most of the codes proposed as solution (including the accepted answer) fail to flatten any list that has a depth greater than 1000.When I say most of the codes I mean all codes that use any form of recursion (or call a standard library function that is recursive). All these codes fail because for every of the recursive call made, the (call) stack grow by one unit, and the (default) python call stack has a size of 1000. If you're not too familiar with the call stack, then maybe the following will help (otherwise you can just scroll to the Implementation).Call stack size and recursive programming (dungeon analogy)Finding the treasure and exitImagine you enter a huge dungeon with numbered rooms, looking for a treasure. You don't know the place but you have some indications on how to find the treasure. Each indication is a riddle (difficulty varies, but you can't predict how hard they will be). You decide to think a little bit about a strategy to save time, you make two observations: It's hard (long) to find the treasure as you'll have to solve (potentially hard) riddles to get there. Once the treasure found, returning to the entrance may be easy, you just have to use the same path in the other direction (though this needs a bit of memory to recall your path). When entering the dungeon, you notice a small notebook here. You decide to use it to write down every room you exit after solving a riddle (when entering a new room), this way you'll be able to return back to the entrance. That's a genius idea, you won't even spend a cent implementing your strategy.You enter the dungeon, solving with great success the first 1001 riddles, but here comes something you hadn't planed, you have no space left in the notebook you borrowed. You decide to abandon your quest as you prefer not having the treasure than being lost forever inside the dungeon (that looks smart indeed).Executing a recursive programBasically, it's the exact same thing as finding the treasure. The dungeon is the computer's memory, your goal now is not to find a treasure but to compute some function (find f(x) for a given x). The indications simply are sub-routines that will help you solving f(x). Your strategy is the same as the call stack strategy, the notebook is the stack, the rooms are the functions' return addresses: The problem you encountered in the dungeon will be the same here, the call stack has a finite size (here 1000) and therefore, if you enter too many functions without returning back then you'll fill the call stack and have an error that look like "Dear adventurer, I'm very sorry but your notebook is full": . Note that you don't need recursion to fill the call stack, but it's very unlikely that a non-recursive program call 1000 functions without ever returning. It's important to also understand that once you returned from a function, the call stack is freed from the address used (hence the name "stack", return address are pushed in before entering a function and pulled out when returning). In the special case of a simple recursion (a function  that call itself once -- over and over --) you will enter  over and over until the computation is finished (until the treasure is found) and return from  until you go back to the place where you called  in the first place. The call stack will never be freed from anything until the end where it will be freed from all return addresses one after the other. How to avoid this issue?That's actually pretty simple: "don't use recursion if you don't know how deep it can go". That's not always true as in some cases, Tail Call recursion can be Optimized (TCO). But in python, this is not the case, and even "well written" recursive function will not optimize stack use. There is an interesting post from Guido about this question: Tail Recursion Elimination.There is a technique that you can use to make any recursive function iterative, this technique we could call bring your own notebook. For example, in our particular case we simply are exploring a list, entering a room is equivalent to entering a sublist, the question you should ask yourself is how can I get back from a list to its parent list? The answer is not that complex, repeat the following until the  is empty:push the current list  and  in a  when entering a new sublist (note that a list address+index is also an address, therefore we just use the exact same technique used by the call stack);every time an item is found,  it (or add them in a list);once a list is fully explored, go back to the parent list using the  return  (and ).Also note that this is equivalent to a DFS in a tree where some nodes are sublists  and some are simple items:  (for ). The tree looks like this:The DFS traversal pre-order is: L, 0, A, 1, 2, 3, 4. Remember, in order to implement an iterative DFS you also "need" a stack. The implementation I proposed before result in having the following states (for the  and the ): In this example, the stack maximum size is 2, because the input list (and therefore the tree) have depth 2.ImplementationFor the implementation, in python you can simplify a little bit by using iterators instead of simple lists. References to the (sub)iterators will be used to store sublists return addresses (instead of having both the list address and the index). This is not a big difference but I feel this is more readable (and also a bit faster):Also, notice that in  I have , which could be changed to handle more input types, here I just wanted to have the simplest version where (iterable) is just a list. But you could also do that:This considers strings as "simple items" and therefore  will return  and not . Remark that in that case,  is called twice on each item, let's pretend it's an exercise for the reader to make this cleaner. Testing and remarks on other implementationsIn the end, remember that you can't print a infinitely nested list  using  because internally it will use recursive calls to  (). For the same reason, solutions to  involving  will fail with the same error message. If you need to test your solution, you can use this function to generate a simple nested list:Which gives:  >>> .
If you like recursion, this might be a solution of interest to you:I actually adapted this from some practice Scheme code that I had written a while back. Enjoy!
I'm new to python and come from a lisp background. This is what I came up with (check out the var names for lulz):Seems to work. Test:returns:
I don't see anything like this posted around here and just got here from a closed question on the same subject, but why not just do something like this(if you know the type of the list you want to split):You would need to know the type of the elements but I think this can be generalised and in terms of speed I think it would be faster.
Without using any library:
Shamelessly taken from my own answer to another question.This functionDoes not use , because it's evil and breaks duck typing.Uses  recursively.  There has to be an answer using .Works with arbitrary nested-lists whose elements are either nested-lists, or non-nested lists of atoms, or atoms (subjected to recursion limit).Does not LBYL.But not with nested-lists that contain strings as atoms.Code below:
We can also use the 'type' function of python. When iterating the list we check if the item is a list or not. If not we 'append' it else we 'extend' it. Here is a sample code - Output:For more info on append() and extend() check this website :https://docs.python.org/2/tutorial/datastructures.html


Answer URL
https://docs.python.org/3/whatsnew/3.3.html#pep-380
