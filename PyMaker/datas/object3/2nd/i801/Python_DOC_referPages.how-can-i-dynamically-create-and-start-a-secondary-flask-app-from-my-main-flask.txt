Natural Text
I have a flask application that I would like to be able to use to start another flask application (unknown at runtime of the main application) on a different port. These child applications are intended to be very simple and be spun up/spun down as needed, however, it's preferable that this gets accomplished from within the main flask app. I don't believe that DispatcherMiddleware is the solution since the child app is undetermined when the main app starts.This question about using flask inside of a class is the route I began down. Here is the slightly modified file I'm using:However, when I try calling run from my main app's routes file I get warning that  is being ignored.I am currently starting the main application using  in development mode.Is this the right path to go down or is there a better way? If a similar class implementation is the suggested solution, how can I get around the app.run() warning?EDIT: Background on what I'm trying to accomplish. This main app is like an admin panel, running on a port with a firewall limiting who can access it. One part of the main app's functionality is to accept and store configs for the secondary app. So a user will be able to POST HTML and 1-4 basic routes (among other configs) that the secondary app will serve. Within the main app, I'm trying to allow a flask app to run based off the configs specified by the user. So when the user chooses to temporarily serve that app, the secondary flask app with start on a separate port that can be seen externally.
I'd think about the time-effort tradeoff here.  Instead of building an app which builds apps, it may be easier to train your users to build the apps themselves, possibly even providing basic templates for them to get productive quickly.Also you mention custom HTML being submited through your portal, which sounds like you want to have users submit Jinja2 templates through the portal, which in turn would need to be written to the filesystem and loaded by the child applications.  This will no doubt create issues if the users submit buggy templates, which cause the application to crash, taking all the other child apps with them, because everything's running from the same python interpreter.However, I understand the difficulty of training potentially non-technical staff to use flask.  If you still want to stick with the portal idea, it might be worth defining the configuration values which you want to make user configurable, and implementing a CRUD system to validate these inputs and store them in a database.When the child app launches (in a separate python process) you could pull these values from the database and use them to construct the application.  davidism from the flask team has an answer which talks about pulling config from the database.I'd also have a look at docker. The Flask mega tutorial has a whole section on docker which should give you an idea of the capabilities.There's also a Python SDK for Docker which gives you all the capabilites of the docker terminal commands within python. So in theory you could have:A parent app which presents a portal to the users, allowing them to define a requried config which is validated and stored in the database.A child application which will read a config from the database, and initilize the Flask application object based on this config.  This can be manually configured to run within a docker container. The ability to launch the child app containers from within the parent app, using the python docker sdk to do this.  Should be easy once you've already made the child app docker-capable.This would have the advantage of isolating all of the components, but may involve more development time than you'd hoped for.Of course you could find some middle ground between user-training and automation which would serve your purpose.


Answer URL
https://docs.python.org/3/library/subprocess.html#subprocess.run
