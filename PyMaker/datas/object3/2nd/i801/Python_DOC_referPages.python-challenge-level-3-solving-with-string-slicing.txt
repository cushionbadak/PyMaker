Natural Text
apologies to posting the question, as has been answered in other questions as well. However, couldn't figure out what's wrong with this solution. The question requires to find the lower-cased characters bordered by 3 upper-cased characters on each side.  The code i've writting:The string i'm getting is 'lgvcaaginbkvsoezhtlnldslyitlooqfgiksudtm'   vs 'linkedlist'Thanks for the help. Edit: for some reason the following code seems to work:
What you are trying to do is match a pattern : Not Upper, Upper, Upper, Upper, Not Upper, Upper, Upper, Upper, Not Upper. This is easier to catch if you use a signature for your string:You are looking for the  substrings in the  string. Python has no builtin for , but you can to iterate over the results of :You may also use  with a regex pattern, but is more complicated.
This would be a slicing solution:It slices the text into parts of 9 characters (you need 9 to assure not to have XXXXyXXXX - you need exactly three uppers around your lowers.It checks the sliced text for  on positions 0,8 and 4:by pulling this function from the -dictionary. All indexes of  that have no matching key in  are tested with  using the default param of  makes sure all tests need to evaluate to true to enter the if-condition.Spaces evaluate to  for isupper and islower().Readup:all()dict.get(key,default) and Why dict.get(key) instead of dict[key]?enumerate(iterable)You can replace the  part by:if that is too complicated for your current level of python.


Answer URL
https://docs.python.org/3/library/functions.html#all
https://docs.python.org/3/library/stdtypes.html#dict.get
https://docs.python.org/3/library/functions.html#enumerate
