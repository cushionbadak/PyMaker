Natural Text
This is the task:Problem 23A perfect number is a number for which the sum of its proper divisors is exactly equal to the number. For example, the sum of the proper divisors of 28 would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect number.A number n is called deficient if the sum of its proper divisors is less than n and it is called abundant if this sum exceeds n.As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the smallest number that can be written as the sum of two abundant numbers is 24. By mathematical analysis, it can be shown that all integers greater than 28123 can be written as the sum of two abundant numbers. However, this upper limit cannot be reduced any further by analysis >even though it is known that the greatest number that cannot be expressed as the sum of two abundant numbers is less than this limit.Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.This is my code:If it looks inefficient, i know, I'm new to coding. Python is my first programming language. I noticed a weird problem for my non_abun_list, where when retrieving the difference for set(all_num_list) and set(abundant_sum_list), the first and second index of abundant_sum_list is 2 and 30, so in my mind, non_abun_list shoud look like[1, 2, 3, 4... ,22, 23, 25, 26, 27, 28, 29, 31, 32]instead i got this[1, 2, 3, 4... ,22, 23, 8209 ,25, 26, 27, 28, 29, 8219, 31, 32]and i don't know how I got this list instead.Can someone explain to me what's wrong with my code?My result is 4352518 in ~25 secondsAnswer is 4179871
This is not an answer(OP cannot participate in chat due to rep requirement)You should consider your coding style. If you write concise functions to perform a task and have those functions return a value(s) then you can easily test those functions to see if they work. This makes it easier to determine what IS working.For example when checking for abundancy you have to do two things: find the divisors of a number and compare their sum to that number.Now you can easily test both functions against known inputs and outputs if you start having problems. Once you know they work you don't have to consider them as a source of errors.usage:Test a couple of numbers:Yep, that looks right :).
For this specific part of checkAbundant(), i should include "== i " at line 3 because I only want the factor that will repeat twice to only count once for square numbersFor example, the pair factor as I would like to call for 36 is 1 x 36, 2 x 18, 3, 12, 4 x 9, 6 x 6.For efficiency, I only find the first half of the factor pair, the other half is obtained through n // i. So in order to have the sum of proper factors of a number, I can't have repeated factors.Without adding " ==i " I have made it so that for any square abundant numbers, their other half of the factor is not accounted for when summing the total factors up.Another mistake i fixed in checkAbundant() is in line 8, where factor_sum += (i + other_pair_factor + 1)This resulted in for every loop, factor_sum would have an additional 1, which will ruin the result. To fix that, i added 1 after the for loopOverall, I would say it was a pretty rookie mistake. >.<


Answer URL
https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset
