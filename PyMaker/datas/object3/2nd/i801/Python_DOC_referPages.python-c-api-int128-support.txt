Natural Text
In python one can handle very large integers (for instance  gives 128), but the largest  datastructure the C-API documentation offers is , and it is a 64-bit .I would love to be able to get a C  from a , but it seems there is no tooling for this. PyLong_AsLongLong for instance cannot handle python integers biggers than .Is there some documentation I missed, and it is actually possible?Is there currently not possible, but some workaround exist? (I would love to use the tooling available in the python C-API for  with int128, for instance a  function).Is it a planed feature in an forthcoming python release?
There are a couple of different ways you can access the level of precision you want.Systems with 64-bit s often have 128-bit s. Notice that the article you link says "at least 64 bits". It's worth checking  in case there's nothing further to do.Assuming that is not what you are working with, you'll have to look closer at the raw , which is actually a  of the private  structure.The raw bits are accessible through the  field, with the length given by . The data type of the digits, and the actual number of boots they hold is given by the   and the macro . The latter must be smaller than , larger than 8, and a multiple of 5 (so 30 or 15, depending on how your build was done).Luckily for you, there is an "undocumented" method in the C API that will copy the bytes of the number for you: . The comment in  reads:You should be able to get a UUID with something like


Answer URL
https://docs.python.org/3/c-api/long.html
https://docs.python.org/3/c-api/long.html#c.PyLong_AsLongLong
