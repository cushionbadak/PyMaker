Natural Text
I would like to get callback notification every time  function changes elements in my heap-list (this is, btw, needed to keep track of objects in the list and how their indexes get changed).My plan was to subclass from  and override the  method from which I would track changes in my list. So here is the subclass:Then I create an instance of  and call heapify for it:The problem is that the overridden  is not called from within . It looks like  treats an instance of List2 as if it's the default list.I guess it has something to do with the fact that  is a built-in function, but I still don't get it.Why the overridden  is not called from ?An interesting thing here is that if I copy-paste the heapq's code into my local module (so it's not a built-in function anymore), then it works as expected and I get calls to , but it does not work with the default (built-in) .Python 2.7 if it matters
As part of the Python 3.0 project, and again for 3.3, they went through the docs making it more explicitly when something takes a  vs. a general  or  or , and  definitely says  in 3.3, which implies that the same is true in 2.7.If you track down into the code, if you have the C implementation, in ,  explicitly calls  to verify that the type is a real  rather than a -like sequence. This won't catch subclasses of , but you can see that it directly calls  and (within )   and , so it will treat a  subclass as a base  object. (And this isn't changed as of the current trunk.)So, there are a few ways around this.First, as @FogleBird suggests, you can just fork the pure-Python implementation of —just copy the exact same thing into your project, give it a different name, and remove the  bit at lines 318-321.However, this may be a whole lot slower.Switching from CPython to PyPy may solve that automatically (and it also means you'll get the pure Python implementation whether you want it or not).In fact, I ran a quick test with a 1,000,000-item list. After verifying that PyPy actually does use the  class, I modified it so that, instead of printing, it stores a string into a global variable. (Otherwise, the printing took 3x longer than the actual work on Mac, 40x longer on Windows…) Then I ran it with various different Pythons:CPython 2.7.2 64-bit Mac: 2.079sCPython 3.3.0 64-bit Mac: 1.997sCPython 3.3.0 32-bit Mac: 2.197sPyPy 2.7.2/1.9.0 64-bit Mac: 1.619sCPython 2.7.3 32-bit Win: 3.997sPyPy 2.7.21.9.0 32-bit Win: 2.334sSo, PyPy blew away everything else, despite actually calling my Python list overrides. (I didn't test Jython or IronPython—partly because the startup and warmup time of the JVM or .NET are so long that you need a much longer test for it to be at all fair… But they must also use the pure Python  module.)But that may be a more dramatic change than you want to make. The other alternative is to fork  as well. Even if you don't know the C API at all, this is really just a search-and-replace job. For each  function, replace it with the corresponding  function ( -> ,  -> , etc.). And replace the module name both places it appears. That's it. Then build the module, and have your fork  try to  instead of . This will still not be quite as fast as the built-in implementation, but only because it will be calling your  and  methods a bunch of times, which is exactly what you want.
 uses C implementation if  is available.When you copied  module to your local package,  cannot be found, and the  get used, which indeed uses  and  as you can find statements like  in .
heapq uses native code if available on your platform, which I assume is the problem although I don't fully grok the reason why.Perhaps you can take a different approach, and track the original indicies of the list items.Then you can extract the values and indicies after heapify...Edit: I tried to "trick" heapq by providing a instance of a class not derived from list. It did not work, it requires lists, presumably because the native code uses that as an assumption for performance reasons.Edit 2: Note this code in heapq.py. This overrides the Python implementations.Edit 3: The Python documentation discusses your root issue. Namely, "if a pending task needs to be deleted, how do you find it and remove it from the queue?"http://docs.python.org/2/library/heapq.html#priority-queue-implementation-notesThe idea is to simply mark entries as removed. When you see these items at the top of your priority queue, you ignore them. The documentation has sample code.


Answer URL
