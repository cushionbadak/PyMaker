Natural Text
I have a big dictionary(28 MB) 'MyDict' stored in a  file.If I execute the statement:A  exception is thrown.How can I access this dictionary using  or  modules.How can I write this  file to  or  without accessing MyDict.This MyDict is generated by writing into a file.Here is a key-value pair from the dictionary:
 is actually a pretty good choice here. It acts just like a dictionary, but it's backed by a BDB (or similar) key-value database file, and Python will handle all the caching, etc., so it doesn't need to load the whole thing into memory at once.Here's how to create the shelve file. Note that shelf keys have to be strings. Also note that I'm creating the shelf in-place, rather than first creating a  and shelving it. That way you avoid the cost of having to build that giant in-memory  that was causing problems in the first place.And to use it, don't actually read it in; leave it as an on-disk shelf:If your dictionary-using code doesn't fit easily into a scope, replace the  statement with a plain , and explicitly  it when you're done. is probably not as good of an idea, because you still have to read the whole thing into memory. It will probably use a lot less transient memory, and maybe disk space, than importing a module that defines a giant literal, but still, having an in-memory hash table that huge could still be a problem. But you can always test it and see how well it works.Here's how to create the pickle file. Note that you can use (nearly) anything you want as a key, not just strings. However, you have to build the whole  before you can  it.This creates a 47MB file.Now, to use it in your main app:The same basic problems with  go for any other persistence format that has to be saved and loaded—whether something custom that you write yourself, or something standard like JSON or YAML. (Of course if you need interoperability with other programs, especially in other languages, something like JSON is the way to go.) You're better off with a database; the only question is, what kind of database.The advantage of an  type database is that you can use it as if it were a , without worrying about how to load/save/access it (other than the  and  lines). The problem with  is that it only lets you map strings to strings.The  module effectively wraps , with pickling of each value. Your keys still have to be strings, but your values can be almost anything. So as long as your keys are strings, and you don't have any references from the values to external objects, it's a pretty transparent drop-in replacement for a .The other options—, various modern nosql databases, etc.—require you to change the way you access data, and even the way you organize it. (A "list of lists" isn't a clear ER model.) Of course in the long run, this might result in a better design, so if you think you really should be using a relational model, consider this idea.From the comments, @ekta wanted me to explain why some of the restrictions on  and  exist.First,  goes back to the 70s. A database that could map 8-bit strings to strings simply and efficiently was a pretty huge deal back then. It was also pretty common for values of all kinds to be stored as their string representation—or, if not that, then just storing the bytes that happen to represent the value natively on the current machine. (XML, JSON, or even endianness-swapping may have been too expensive for the machines of the day, or at least the thinking of the day.)Extending  to handle other data types for the values isn't hard. They never need to be hashed or compared, just stored and retrieved losslessly. Since  can handle a very wide variety of types, isn't too horribly inefficient, and comes with Python, it makes sense to use  for that, so  does exactly that.But the keys are a different story. You need an encoding that's not only losslessly reversible, but also ensures that two values will encode to equal bytes if and only if they're actually equal. Keep in mind that in Python, , but obviously , , etc.There are plenty of types that can be losslessly and equality-preservingly converted to bytes if you only care about that type. For example, for Unicode strings, just use UTF-8. (Actually,  takes care of that one for you.) For 32-bit signed integers, use . For tuples of three strings, encode to UTF-8, backslash-escape, and join them with newlines. And so on. For many specific domains, there's an easy answer; there's just no general-purpose answer that works for most domains.So, if you want to use a  to use, say, tuples of three UTF-8 strings as keys, you can write your own wrapper around  (or ). As with many modules in the stdlib,  is intended to be helpful sample code as well as a usable feature, which is why the docs have a link to the source. It's simple enough that a novice should be able to figure out how to either fork it, subclass it, or wrap it to do his own custom key encoding. (Note that if you wrap , you will have to encode your custom values to  just so it can encode that  to ; if you fork it, or subclass it and override the relevant methods, you can instead encode directly to —e.g., that  call above. This may be better for both simplicity/readability and performance.)


Answer URL
https://docs.python.org/3/library/shelve.html
