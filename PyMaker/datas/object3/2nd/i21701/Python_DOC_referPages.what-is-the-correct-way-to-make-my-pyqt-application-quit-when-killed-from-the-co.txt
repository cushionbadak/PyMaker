Natural Text
What is the correct way to make my PyQt application quit when killed from the console (Ctrl-C)?Currently (I have done nothing special to handle unix signals), my PyQt application ignores SIGINT (Ctrl+C). I want it to behave nicely and quit when it is killed. How should I do that?
17.4. signal — Set handlers for asynchronous eventsAlthough Python signal handlers are called asynchronously as far as the Python user is concerned, they can only occur between the “atomic” instructions of the Python interpreter. This means that signals arriving during long calculations implemented purely in C (such as regular expression matches on large bodies of text) may be delayed for an arbitrary amount of time.That means Python cannot handle signals while the Qt event loop is running. Only when the Python interpreter run (when the QApplication quits, or when a Python function is called from Qt) the signal handler will be called.A solution is to use a QTimer to let the interpreter run from time to time.Note that, in the code below, if there are no open windows, the application will quit after the message box regardless of the user's choice because QApplication.quitOnLastWindowClosed() == True. This behaviour can be changed.Another possible solution, as pointed by LinearOrbit, is , but it doesn't allow custom handlers.
If you simply wish to have ctrl-c close the application - without being "nice"/graceful about it - then from http://www.mail-archive.com/pyqt@riverbankcomputing.com/msg13758.html, you can use this:Apparently this works on Linux, Windows and OSX - I have only tested this on Linux so far (and it works).
18.8.1.1. Execution of Python signal handlersA Python signal handler does not get executed inside the low-level (C) signal handler. Instead, the low-level signal handler sets a flag which tells the virtual machine to execute the corresponding Python signal handler at a later point(for example at the next bytecode instruction). This has consequences:  [...]  A long-running calculation implemented purely in C (such as regular expression matching on a large body of text) may run uninterrupted for an arbitrary amount of time, regardless of any signals received. The Python signal handlers will be called when the calculation finishes.The Qt event loop is implemented in C(++). That means, that while it runs and no Python code is called (eg. by a Qt signal connected to a Python slot), the signals are noted, but the Python signal handlers aren't called.But, since Python 2.6 and in Python 3 you can cause Qt to run a Python function when a signal with a handler is received using .This is possible, because, contrary to the documentation, the low-level signal handler doesn't only set a flag for the virtual machine, but it may also write a byte into the file descriptor set by . Python 2 writes a NUL byte, Python 3 writes the signal number.So by subclassing a Qt class that takes a file descriptor and provides a  signal, like e.g. , the event loop will execute a Python function every time a signal (with a handler) is received causing the signal handler to execute nearly instantaneous without need for timers:
I found a way to do this. The idea is to force qt to process events often enough and in a python callabe to catch the SIGINT signal.
You can use the standard python unix signals handling mechanism:where in  you can free all resources (close all db sessions etc) and gently close your appliction.Code example taken from here
I think I have a simpler solution:This just tells the application to try to close all windows if ctrl+c is pressed. If there is an unsaved document, your app should pop up a save or cancel dialog box as if it were exited.You may also need to connect the QApplication signal lastWindowClosed() to the slot quit() to get the application to actually exit when the windows are closed.
The answer from Artur Gaspar worked for me when the terminal window was in focus, but would not work when the GUI was in focus.  In order to get my GUI to close (which inherits from QWidget) I had to define the following function in the class:Checking to make sure that the event key is 67 makes sure that 'c' was pressed.  Then checking the event modifiers determines whether ctrl was being pressed when 'c' was released.


Answer URL
https://docs.python.org/3/library/signal.html
https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd
https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd
