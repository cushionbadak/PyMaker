Natural Text
Currently, I have an inefficient synchronous generator that makes many HTTP requests in sequence and yields the results. I'd like to use  and  to parallelise the requests and thereby speed up this generator, but I want to keep it as an ordinary generator (not a PEP 525 async generator) so that the non-async code that calls it doesn't need to be modified. How can I create such a generator?
, currently barely documented, takes an iterable of coroutines or futures and returns an iterable of futures in the order that the input futures complete. Normally, you'd loop over its result and  the members from inside an  function...... but for the purpose of this question, what we want is to be able to yield these results from an ordinary generator, so that normal synchronous code can consume them without ever knowing that  functions are being used under the hood. We can do that by calling  on the futures yielded by our  call...In this way, we've exposed our async code to non-async-land in a manner that doesn't require callers to define any functions as , or to even know that  is using  under the hood.As an alternative implementation of  that offers more flexibility in some circumstances, we can repeatedly call  with the  flag instead of looping over :This approach, maintaining a list of  jobs, has the advantage that we can adapt it to add jobs to the  list on the fly. This is useful in use cases where our async jobs can add an unpredictable number of further jobs to the queue - like a web spider that follows all links on each page that it visits.


Answer URL
https://docs.python.org/3/library/asyncio.html
https://docs.python.org/3/library/asyncio-task.html#asyncio.as_completed
https://docs.python.org/3/library/asyncio-task.html#asyncio.wait
