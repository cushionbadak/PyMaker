Natural Text
I have a script, that prints colored output if it is on tty. A bunch of them executes in parallel, so I can't put their stdout to tty. I don't have control over the script code either (to force coloring), so I want to fake it via pty. My code:And I can't figure out, what should be in . For now, I have something like It works, but that number  looks strange . I think output can be quiet large, and any number there could be not sufficient. I tried a lot of solutions from stack overflow, but none of them works (it prints nothing or hanging forever).I am not very familiar with file descriptors and all that, so any clarification if I'm doing something wrong would be much appreciated.Thanks!
This won't work for long outputs:  will block once the PTY's buffer is full. That's why  exists, but that won't work with a PTY.The standard/easiest solution is to use the external module pexpect, which uses PTYs internally: For example,will give you the  output with color codes.If you'd like to stick to , then you must use  for the reason stated above. You are right in your assumption that by passing , you read at most 1000 bytes, so you'll have to use a loop.  blocks if there is nothing to read and waits for data to appear. The catch is how to recognize when the process terminated: In this case, you know that no more data will arrive. The next call to  will block forever. Luckily, the operating system helps you detect this situation: If all file descriptors to the pseudo terminal that could be used for writing are closed, then  will either return an empty string or return an error, depending on the OS. You can check for this condition and exit the loop when this happens. Now the final piece to understanding the following code is to understand how open file descriptors and  go together:  internally calls , which duplicates the current process including all open file descriptors, and then within one of the two execution paths calls , which terminates the current process in favour of a new one. In the other execution path, control returns to your Python script. So after calling  there are two valid file descriptors for the slave end of the PTY: One belongs to the spawned process, one to your Python script. If you close yours, then the only file descriptor that could be used to send data to the master end belongs to the spawned process. Upon its termination, it is closed, and the PTY enters the state where calls to  on the master end fail.Here's the code:


Answer URL
https://docs.python.org/3/library/subprocess.html?highlight=subprocess#subprocess.Popen.communicate
