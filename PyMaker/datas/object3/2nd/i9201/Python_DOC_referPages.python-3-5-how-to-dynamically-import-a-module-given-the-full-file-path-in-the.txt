Natural Text
QuestionThe standard library clearly documents how to import source files directly (given the absolute file path to the source file), but this approach does not work if that source file uses implicit sibling imports as described in the example below.How could that example be adapted to work in the presence of implicit sibling imports?I already checked out this and this other Stackoverflow questions on the topic, but they do not address implicit sibling imports within the file being imported by hand.Setup/ExampleHere's an illustrative exampleDirectory structure::::Running  with the  block commented out yields  in Python 3.6.But running  yields:WorkaroundIf I add  to ,  yields  as intended, but I would like to avoid munging the  if possible.Answer requirementsI'd like  to print  and I'd like to accomplish this by modifying the  function.I'm not sure of the implications of mangling . Eg. if there was  and I added the path to  to the , I wouldn't want  to start importing  instead of importing the requests library that I installed with .The solution MUST be implemented as a python function that accepts the absolute file path to the desired module and returns the module object.Ideally, the solution should not introduce side-effects (eg. if it does modify , it should return  to its original state). If the solution does introduce side-effects, it should explain why a solution cannot be achieved without introducing side-effects.If I have multiple projects doing this, I don't want to have to remember to set  every time I switch between them. The user should just be able to  my project and run it without any additional setup.The  flag is the recommended/pythonic approach, but the standard library also clearly documents How to import source files directly. I'd like to know how I can adapt that approach to cope with implicit relative imports. Clearly, Python's internals must do this, so how do the internals differ from the "import source files directly" documentation?
The easiest solution I could come up with is to temporarily modify  in the function doing the import:This should not cause any problems unless you do imports in another thread concurrently. Otherwise, since  is restored to its previous state, there should be no unwanted side effects.Edit:I realize that my answer is somewhat unsatisfactory but, digging into  the code reveals that, the line  basically results in  getting called. Here  is simply the code contained in lib.py. Thus a better answer to the question would have to find a way to make the  statement behave differently by simply injecting one or more global variables through the second argument of the exec-statement. However, "whatever you do to make the import machinery look in that file's folder, it'll have to linger beyond the duration of the initial import, since functions from that file might perform further imports when you call them", as stated by @user2357112 in the question comments.Unfortunately the only way to change the behavior of the  statement seems to be to change  or in a package .  already contains  so that doesn't seem to work which leaves  (Or trying to figure out why exec does not treat the code as a package even though it has  and  ... - But I don't know where to start - Maybe it has something to do with having no  file).Furthermore this issue does not seem to be specific to  but rather a general problem with sibling imports.Edit2: If you don't want the module to end up in  the following should work (Note that any modules added to  during the import are removed):
add to the  environment variable the path your application is onAugment the default search path for module files. The format is the same as the shellâ€™s PATH: one or more directory pathnames  separated by os.pathsep (e.g. colons on Unix or semicolons on  Windows). Non-existent directories are silently ignored.on bash its like this:or run directly:
Make sure your root is in a folder that is explicitly searched in the PYTHONPATHUse an absolute import:from root.folder import implicit_sibling_import #called from app.py
The OP's idea is great, this work only for this example by adding sibling modules with proper name to the sys.modules, I would say it is the SAME as adding PYTHONPATH. tested and working with version 3.5.1.
Try:or run directly:Make sure your root is in a folder that is explicitly searched in the . Use an absolute import:


Answer URL
https://docs.python.org/3/library/importlib.html#importing-a-source-file-directly
https://docs.python.org/3/using/cmdline.html#cmdoption-m
https://docs.python.org/3/library/importlib.html#importing-a-source-file-directly
https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH
https://docs.python.org/3/reference/import.html#the-module-cache
