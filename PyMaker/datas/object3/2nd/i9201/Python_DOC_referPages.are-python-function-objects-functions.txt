Natural Text
We all know that functions are objects as well. But how do function objects compare with functions? What are the differences between function objects and functions? By function object I mean g so defined:By function I mean this: 
Python creates function objects for you when you use a def statement, or you use a lambda expression:So whenever you are defining a function in python an object like this is created. There is no plain way of function definition.
TL;DR any object that implements  can be called eg: functions, custom classes, etc..Slightly longer version: (walloftext)The full answer to your question on what's the difference sits within the implementation of the python virtual machine, so we must take a look at python under the hood. First comes the concept of a code object. Python parses whatever you throw at it into it's own internal language that is the same across all platforms known as bytecode. A very visual represnetation of this is when you get a .pyc file after importing a custom library you wrote. These are the raw instructions for the python VM. Ignoring how these instructions are created from your source code, they are then executed by  in Python/ceval.c. The source code is a bit of a beast, but ultimately works like a simple processor with some of the complicated bits abstracted away. The bytecode is the assembly language for this processor. In particular one of the "opcodes" for this "processor" is (aptly named) . The callback goes through a number of calls eventually getting to . This function takes a pointer to a  and extracts the  attribute from it's type and directly calls it (technically it checks if it's there first): Any object that implements  is given a  attribute with a pointer to the actual function. I believe that is handled by the  difinition from Objects/typeobject.c:The  method itself for functions is defined in the cpython implementation and it defines how the python VM should start executing the bytecode for that function and how data should be returned (if any). When you give an arbitrary class a  method, the attribute is a function object that again refers back to the cpython implementation of . Therefore when you call a "normal" function  is referenced. when you call a callable class, the  is equivalent to  and the actual cpython reference called is .disclaimerThis has been a journey into somewhat uncharted waters for me, and it's entirely possible I have misrepresented some of the finer points of the implementation. I mainly took from this blog post on how python callables work under the hood, and some digging of my own through the python source code


Answer URL
https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_call
