Natural Text
Performance of quicksort implemented with mutlithreading is lower than normal quicksort although my processor is dual core.Please provide suggestion to improve performance of multithreading.I am uploading both versions of quicksort and also sample testcase generator written in python3(3.5.2)Multithread QuicksortHere's also the normal versionNormal QuicksortBelow is the test code generatortestcase generatorI'm also uploading screenshots of CPU performance graphs during running the programs on a testcase of 10000 unsorted random numbersCPU graph during normal quicksortsee the 100% usage of CPU-3CPU graph during multithread quicksortNo CPU is utilized properlyNormal Quicksort finishes the task in 20.041423797607422 seconds.Multithread Quicksort finishes it in 27.749499320983887 seconds.
You see the famous GIL in action: "mutex that prevents multiple native threads from executing Python bytecodes at once".Guido's recommendation was to use multiprocessing with IPC messaging instead of threads with shared state.If there is no special requirements for stability, you can try PyPy-STM, it was the most complete attempt to remove GIL.
Python uses a Global Interpreter Lock, which means that at any time only one thread can be running. So you won't be able to fully utilize a multicore machine with threads in Python. The reason it runs slower is likely the added communication overhead in your multithreaded example.I suggest writing a multithreaded solution in C or another language that allows real multithreading and forking it from your Python program.


Answer URL
https://docs.python.org/3/faq/library.html#can-t-we-get-rid-of-the-global-interpreter-lock
https://docs.python.org/3/glossary.html#term-global-interpreter-lock
