Natural Text
I understand that  may be too close from , but in no way the result of floor after a  operation should be 2 (0 or 1)!
It is not a bug in floor.Check the result of You may read What Every Computer Scientist Should Know About Floating-Point Arithmetic to know more on why  is behaving so. The decimal module provides support for decimal floating point arithmetic. It offers several advantages over the foat datatype. So for precise math on floating point valuessys.float_infoFor detailed information about float type one may use . shows  maximum number of decimal digits that can be faithfully represented in a float; For calculations that includes values with more digits you may not expect accurate results with the given precisionThis is what i have got
You're right that the result of  should not be , but floats are weird, and infamously less than precise.  The specification of the  operator states:While abs(x%y) < abs(y) is true mathematically, for floats it may not be true numerically due to roundoff. For example, and assuming a platform on which a Python float is an IEEE 754 double-precision number, in order that -1e-100 % 1e100 have the same sign as 1e100, the computed result is -1e-100 + 1e100, which is numerically exactly equal to 1e100. The function math.fmod() returns a result whose sign matches the sign of the first argument instead, and so returns -1e-100 in this case. Which approach is more appropriate depends on the application.


Answer URL
https://docs.python.org/3/reference/expressions.html#id17
