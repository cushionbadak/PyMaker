Natural Text
In my high school class I have been assigned the task of creating a keyword cipher. However when I run it through a python visualizer I still can not see what it is doing wrong.Here is my code so far:When I run it with the following inputenter your sentence: computingisfunenter keyword: gcseit should print , because it gets the place in the alphabet for each letter adds them up and print that letter.For example:prints out  because a = 1 and b = 2 and a+b = 3 (which is (c))But it prints out , which is not at all what I expected.
I understand that you're in high school so I replace some piece of code that you write unnecessarily, you'll do better with experience ;)First of all, you must know that it isn't a good idea programming based in an exception, is better if you add a condition and you reinitialize your  value so the exception it isn't necessary; Then, you have a little problem with the scope of the variables, you set  at the start of your script but when call the function the  inner the function has a different scope so when you  at the end you have an empty string value, so, the values that you use into the function like ,  and  it's better if you define inside the function scope and finally return the desired value (calculated (cipher) string)So, the code it's something like this:Read and initialize your required data:Define your function:Call and print the return value at the same time ;)
You've got quite a few problems with what you're doing here. You're mixing recursion, iteration, and exceptions in a bundle of don't do that.I think you may have had a few ideas about what to do, and you started down one track and then changed to go down a different track. That's not surprising, given the fact that you're a beginner. But you should learn that it's a good idea to be consistent. And you can do this using recursion, iteration, slicing, or driven with exceptions. But combining them all without understanding why you're doing it is a problem.DesignLet's unwind your application into what you actually are trying to do. Without writing any code, how would you describe the steps you're taking? This is what I would say:For every letter in the message:take the next letter from the keywordcombine the numeric value of the two lettersif the letter is beyond Z(ebra), start back at A and keep countingwhen we reach the last letter in the keyword, loop back to the beginningThis gives us a hint as to how we could write this. Indeed the most straightforward way, and one that you've got partially done.IterativelyHere's another pointer - rather than starting of with a dynamic problem, let's make it pretty static:You'll see that this prints out the message - one character per line. Great! We've got the first part of our problem done. Now the next step is to take letters from the key. Well, let's put a key in there. But how do we iterate over two strings at a time? If we search google for , the very first result for me was How can I iterate through two lists in parallel?. Not bad. It tells us about the handy dandy  function. If you want to learn about it you can search  or just run  in your REPL.So here's our code:Now if we run this... uh oh!Where's the rest of our string? It's stopping after we get to the end of the shortest string. If we look at the help for zip, we see:continues until the shortest iterable in the argument sequence is exhausted So it's only going to go until the shortest thing. Well that's a bummer. That means we need to have a key and message the same length, right? Or does it? What if our key is longer than the message? Hopefully by now you know that you can do something like this:If we make sure that our key is at least as long as our message, that will work. So we can just multiply the key times the number of letters in our message. I mean, we'll have way more than we need, but that should work, right? Let's try it out:Sweet! It worked!So now let's try just adding the  values and let's see what we get:Oh.. dear. Well those aren't ASCII letters. As you've already found out, you need to subtract 96 from each of those. As it turns out because math, you can actually just subtract 96*2 from the sum that we've already got.But we've still got non-alpha characters here. So if we make sure to just bring that value back around:Now we're good. The only thing that we have left to do is combine our message into a string instead of print it out, and stick this code into a function. And then get our input from the user. We're also going to stick our key-length-increasing code into the function:RecursionSo we've got it working using iteration. What about recursion? You're definitely using recursion in your solution. Well, let's go back to the beginning, and figure out how to print out our message, letter by letter:That works. Now we want to add our key. As it turns out, we can actually do the same thing that we did before - just multiply it:Well that was surprisingly simple. Now let's print out the converted value:Again we need to handle a space character:Now the only thing that's left is to combine the result. In recursion you usually pass some kind of value around, and we're going to do that with our result:SlicingWe used some slicing in our recursive approach. We even could have passed in the index, rather than slicing off parts of our string. But now we're going to slice and dice. It's going to be pretty similar to our recursive solution:def change(message, keyword):    if len(keyword) < len(message):        keyword = keyword*len(message)When you see that, it shouldn't be much of a stretch to realize that you can just put in the code from our recursive solution:And then we just combine the characters into the result:Further ReadingYou can do some nicer things. Rather than the silly multiplication we did with the key, how about itertools.cycle?What happens when you use modulo division instead of subtraction?


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.cycle
