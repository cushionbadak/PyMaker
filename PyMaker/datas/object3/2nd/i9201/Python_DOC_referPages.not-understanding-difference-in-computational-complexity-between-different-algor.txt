Natural Text
I am currently doing some coding problems on leetcode.com and am stumped by the difference in computational time between two algorithms that output the same result.The problem:Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0.At a bare minimum, one needs to compare every combination of pairs of strings in order to compute the answer. I realize bitwise is much faster/more efficient, but I am choosing to ignore it for the sake of this question.You can find the test case word list I am using at the bottom of this post.Algorithm 1:This algorithm essentially is a nested for loop that compares every possible combination of words, and would include double counts and counts against itself if not for the "if iAlgorithm 2:This algorithm essentially compares the first word in the list to all the others, then deletes it from the list and repeats the process. It takes approximately 0.02 seconds, making it about 4 times faster. I am having a hard time understanding why exactly the difference is so large. Thanks in advance for all the help!The input I am using to compare the times is this:Updating OP to help the people assisting me with this question!I am now generating words using this:I am performing the first algorithm as so:The results I am seeing are in the 0.1 seconds range.The second algorithm I am using this:I am seeing results in the 0.04-0.05 seconds range. Can anyone replicate this?
Both algorithms look as if they the same amount of work. Both re-create the  function. However, the first method re-creates the sets more often, and executes an additional n**2 of  tests (for n words)!You are creating len(n) over 2 combinations, so n! / (n - 2)! (see Wikipedia), which is quite a lot less than n**2:So algorithm #1 executes more than twice as many loops as algorithm #2 for your specific case. As n increases, the product divided by the number of  combinations approaches 2, so it'll always do at least double the work.Next, you create a set of  in algorithm #2 only once, but you do it for every inner loop for algorithm #1:It's those differences that causes it to be slower; creating (N over 2) sets vs. just N sets is probably costing you most of the performance here.To make a proper comparison, you should use the  module, which repeats tests many times, makes sure to use the most accurate clock for measuring time spent and disables the Python garbage collector (so it won't interfere). I've included a randomised word list, and for the destructive algorithm (your #2), I had to clone the list each time, for which I compensate by subtracting the time for the same number of bare list copies.The script I ran:and the results:So moving the  call in  dramatically improves the first version already. Reducing the number of loops by replacing  with a  loop further reduces the gap:What I find surprising is that your destructive loop is faster than using  however:We could possible make your algorithm #2 faster by using set disjunctions, rather than test each character individually. Because we'll be testing words repeatedly, it makes sense to create the sets up-front, in a dictionary, acting as a cache we can draw from when testing.Finally, we can make a non-destructive version by storing lengths in the dictionary too and just looping over the values (we destroy the dictionary instead):This is the fastest I've been able to make this:shaving off another 20%.So, in conclusion, it is faster to iterate directly over a list, vs. generating indices from a , then indexing into the list. The difference is large enough that it is worth your while destroying the list (or dictionary)!This is also what makes  slower; it has to use indices, as it has to support combinations greater than 2 (which means you can't just delete from the input sequence).


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.combinations
https://docs.python.org/3/library/timeit.html
https://docs.python.org/3/library/stdtypes.html#set.isdisjoint
