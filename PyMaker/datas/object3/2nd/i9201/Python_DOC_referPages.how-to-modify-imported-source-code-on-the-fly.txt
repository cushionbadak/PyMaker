Natural Text
Suppose I have a module file like this:Then I have a simple script:This will print . Let's say I want to "override" the  function so it returns  instead. How could I do this programmatically (without manually modifying )?What I thought is that I need somehow to modify the source code of  before or while importing it. Obvisouly, I cannot do this after importing it so solution using  are impossible.I also thought I could read the file , perform modification, then load it. But this is ugly, as it will not work if the module is located somewhere else.The good solution, I think, is to make use of .I read the doc and found a very intersecting method: . I thought I could just override it:Unfortunately, I am a bit lost with all these abstract classes and I do not know how to perform this properly.I tried vainly:Any help would be welcome, please.
Here's a solution I hacked together based on the content of this great talk. It allows any arbitrary modifications to be made to the source before importing the specified module. It should be reasonably correct as long as the slides did not omit anything important. This will only work on Python 3.5+.So, using this you can do
This doesn't answer the general question of dynamically modifying the source code of an imported module, but to "Override" or "monkey-patch" its use of the  function can be done (since it's a built-in function in PythonÂ 3.x). Here's how:
If importing the module before the patching it is okay, then a possible solution would beIf you're after a more general solution, then you can also take a look at the approach I used in another answer a while ago.
I first needed to better understand the  operation. Fortunately, this is well explained in the  documentation and scratching through the source code helped too.This  process is actually split in two parts. First, a finder is in charge of parsing the module name (including dot-separated packages) and instantiating an appropriate loader. Indeed, built-in are not imported as local modules for example. Then, the loader is called based on what the finder returned. This loader get the source from a file or from a cache, and executed the code if the module was not previously loaded.This is very simple. This explains why I actually did not need to use abstract classes from : I do not want to provide my own import process. Instead, I could create a subclass inherited from one of the classes from  and override  from  for example. However, this is not the way to go because the loader is instantiated by the finder so I do not have the hand on which class is used. I cannot specify that my subclass should be used.So, the best solution is to let the finder do its job, and then replace the  method of whatever Loader has been instantiated.Unfortunately, by looking trough the code source I saw that the basic Loaders are not using  (which is only used by the the  module). So my whole idea could not work.In the end, I guess  should be called manually, then the returned source should be modified, and finally the code should be executed. This is what Martin Valgur detailed in his answer.If compatibility with Python 2 is needed, I see no other way than reading the source file:
Not elegant, but works for me (may have to add a path):


Answer URL
https://docs.python.org/3/library/importlib.html
https://docs.python.org/3/library/importlib.html
https://docs.python.org/3/glossary.html#term-finder
https://docs.python.org/3/glossary.html#term-loader
