Natural Text
In Java:This prints In Python 2.7, if I run this codeI getHuh? It looks like the precision (.2) argument is treated totally differently in Python's  than in Python's , Python's , or Java's . Here's the doc (my emphasis):General format. For a given precision p >= 1, this rounds the number to p significant digits and then formats the result in either fixed-point format or in scientific notation, depending on its magnitude.The precise rules are as follows: suppose that the result formatted with presentation type 'e' and precision p-1 would have exponent exp. Then if -4 <= exp < p, the number is formatted with presentation type 'f' and precision p-1-exp. Otherwise, the number is formatted with presentation type 'e' and precision p-1. In both cases insignificant trailing zeros are removed from the significand, and the decimal point is also removed if there are no remaining digits following it.Positive and negative infinity, positive and negative zero, and nans, are formatted as inf, -inf, 0, -0 and nan respectively, regardless of the precision.A precision of 0 is treated as equivalent to a precision of 1. The default precision is 6.WTF? Is there any way to prevent those trailing zeros from being removed? The whole point of string formatting is to achieve some consistency, e.g. for text alignment.Is there any way to get the Java behavior (essentially the number of significant digits to the right of the decimal point) without having to rewrite the whole thing from scratch?
The formatting that python does is more consistent with C's  style formatting, which also drops trailing zeros for the  conversion. Since python's reference implementation is in C, why should it be consistent with Java in this case?When using the  operator for string formatting, the relevant documentation is String Formatting Operations, which has some differences to the one you linked to, notably that it allows the  alternate form for :The alternate form causes the result to always contain a decimal point, and trailing zeroes are not removed as they would otherwise be.The precision determines the number of significant digits before and after the decimal point and defaults to 6.So in your case:This is different from what is allowed by , where  is used to enable prefixes for binary, octal or hexadecimal output (at least in python2, this was changed in python3).
With the  method, you can do something like this:Output:There are two parts to it that might not be so well known.1. Parametrizing the string formattingIn addition to simple formatting:and formatting with more detailed specification of the result:you can use keyword arguments in that you can access in the string :You can use these also for the format specification itself:2. The  expressionIn addition to the  statement there is an  expression, a.k.a. ternary operator.So, this expression:is equivalent to this statement:Putting both together yields something like this:


Answer URL
https://docs.python.org/3/reference/expressions.html#conditional-expressions
