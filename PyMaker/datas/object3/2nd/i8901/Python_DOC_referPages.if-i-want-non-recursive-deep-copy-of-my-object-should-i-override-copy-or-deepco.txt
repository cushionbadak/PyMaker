Natural Text
An object of my class has a list as its attribute. That is,When this object is copied, I want a separate list , but a shallow copy of the content of the list (e.g.  and ). Therefore I decide to implement my own copy method, which will recreate the list but not the items in it. But should I call this  or ? Which one is the right name for what I do, according to Python semantics?My guess is . If I call , I would expect the clone to be totally decoupled from the original. However, the documentation says:A deep copy constructs a new compound object and then, recursively,  inserts copies into it of the objects found in the original.It is confusing by saying "inserts copies into it" instead of "inserts deep copies into it", especially with the emphasis.
The correct magic method for you to implement here is .  The behaviour you've described is deeper than what the default behaviour of copy would do (i.e. for an object which hasn't bothered to implement ), but it is not deep enough to be called a deepcopy.  Therefore you should implement  to get the desired behaviour.  Do not  make the mistake of thinking that simply assigning another name makes a "copy":That just binds another name to the same instance.  Rather, the  method is hooked into by a function:
It actually depends on the desired behaviour of your class that factor into the decision what to override ( or ). In general  works mostly correctly, it just copies everything (recursivly) so you only need to override it if there is some attribute that must not be copied (ever!).On the other hand one should define  only if users (including yourself) wouldn't expect changes to propagate to copied instances. For example if you simply wrap a mutable type (like ) or use mutable types as implementation detail.Then there is also the case that the minimal set of attributes to copy isn't clearly defined. In that case I would also override  but maybe raise a  in there and possible include one (or several) dedicated public  methods.However in my opinion the  counts as implementation detail and thus I would override :Just to show it works as expected:Just a quick note about expectations:Users generally expect that you can pass an instance to the constructor to create a minimal copy (similar or identical to ) as well. For example:Some Python types have an explicit  method, that (if present) should do the same as . That would allow to explicitly pass in parameters (however I haven't seen this in action yet):If your class should be used by others you probably need to consider these points, however if you only want to make your class work with  then just overwrite .
I think overwriting  is a good idea, as explained by the other answers with great detail. An alternative solution might be to write an explicit copy method to be absolutely clear on what is called:When any future reader sees  he then immediately knows that a custom copy method has been implemented. The disadvantage is of course that it might not play well with third-party libraries that use .


Answer URL
https://docs.python.org/3/library/copy.html
