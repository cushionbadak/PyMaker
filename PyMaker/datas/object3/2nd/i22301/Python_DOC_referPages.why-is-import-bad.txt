Natural Text
It is recommended to not to use  in Python. Can anyone please share the reason for that, so that I can avoid it doing next time?
Because it puts a lot of stuff into your namespace (might shadow some other object from previous import and you won't know about it). Because you don't know exactly what is imported and can't easily find from which module a certain thing was imported (readability). Because you can't use cool tools like  to statically detect errors in your code.
According to the Zen of Python:Explicit is better than implicit.... can't argue with that, surely?
You don't pass  to functions, do you?Since Python lacks an "include" statement, and the  parameter is explicit, and scoping rules are quite simple, it's usually very easy to point a finger at a variable and tell where that object comes from -- without reading other modules and without any kind of IDE (which are limited in the way of introspection anyway, by the fact the language is very dynamic).The  breaks all that.Also, it has a concrete possibility of hiding bugs.Now, if the bar module has any of the "", "", etc... attributes, they will override the explicitly imported ones, and possibly point to very different things. Defining  in bar is often wise -- this states what will implicitly be imported - but still it's hard to trace where objects come from, without reading and parsing the bar module and following its imports. A network of  is the first thing I fix when I take ownership of a project.Don't misunderstand me: if the  were missing, I would cry to have it. But it has to be used carefully. A good use case is to provide a facade interface over another module.Likewise, the use of conditional import statements, or imports inside function/class namespaces, requires a bit of discipline.I think in medium-to-big projects, or small ones with several contributors, a minimum of hygiene is needed in terms of statical analysis -- running at least pyflakes or even better a properly configured pylint -- to catch several kind of bugs before they happen.Of course since this is python -- feel free to break rules, and to explore -- but be wary of projects that could grow tenfold, if the source code is missing discipline it will be a problem.
That is because you are polluting the namespace. You will import all the functions and classes in your own namespace, which may clash with the functions you define yourself.Furthermore, I think using a qualified name is more clear for the maintenance task; you see on the code line itself where a function comes from, so you can check out the docs much more easily.In module foo:In your code:
It is OK to do  in an interactive session.
http://docs.python.org/tutorial/modules.htmlNote that in general the practice of importing  from a module or package is frowned upon, since it often causes poorly readable code. 
Say you have the following code in a module called foo:and then in your own module you have:You now have a difficult-to-debug module that looks like it has lxml's etree in it, but really has ElementTree instead.
These are all good answers. I'm going to add that when teaching new people to code in Python, dealing with  is very difficult. Even if you or they didn't write the code, it's still a stumbling block.I teach children (about 8 years old) to program in Python to manipulate Minecraft. I like to give them a helpful coding environment to work with (Atom Editor) and teach REPL-driven development (via bpython). In Atom I find that the hints/completion works just as effectively as bpython. Luckily, unlike some other statistical analysis tools, Atom is not fooled by .However, lets take this example... In this wrapper they  a bunch modules including this list of blocks. Let's ignore the risk of namespace collisions. By doing  they make this entire list of obscure types of blocks something that you have to go look at to know what is available. If they had instead used , then you could type  and then an autocomplete list would pop up.
Understood the valid points people put here. However, I do have one argument that, sometimes, "star import" may not always be a bad practice:When I want to structure my code in such a way that all the constants go to a module called :If I do , then for every constant, I have to refer it as , which is probably not the most convenient way.If I do , then obviously it's way too verbose and defeats the purpose of the structuring.Thus I feel in this case, doing a  may be a better choice.
It is a very BAD practice for two reasons:Code ReadabilityRisk of overriding the variables/functions etcFor point 1:Let's see an example of this:Here, on seeing the code no one will get idea regarding from which module ,  and  actually belongs. On the other way, if you do it like:It is much cleaner for you, and also the new person joining your team will have better idea.For point 2: Let say both  and  have variable as . When I do:Here the value from  is lost. It will be hard to debug why the code is not working even if  is declared in  and I have written the code expecting my code to use If you have same variables in different modules, and you do not want to import entire module, you may even do:
As a test, I created a module test.py with 2 functions A and B, which respectively print "A 1" and "B 1". After importing test.py with:. . . I can run the 2 functions as test.A() and test.B(), and "test" shows up as a module in the namespace, so if I edit test.py I can reload it with:But if I do the following:there is no reference to "test" in the namespace, so there is no way to reload it after an edit (as far as I can tell), which is a problem in an interactive session. Whereas either of the following:will add "test" or "tt" (respectively) as module names in the namespace, which will allow re-loading.If I do:the names "A" and "B" show up in the namespace as functions. If I edit test.py, and repeat the above command, the modified versions of the functions do not get reloaded.And the following command elicits an error message.If someone knows how to reload a module loaded with "from module import *", please post. Otherwise, this would be another reason to avoid the form:
As suggested in the docs, you should never use  in production code.One more reason to avoid it is that importing * from a package works differently than  from a module, which can lead to bugs. Basically,  imports whatever names are defined  by , but it also includes any submodules of the package that were explicitly loaded by previous import statements. Consider this code:In this example, the  and  modules are imported in the current namespace (possibly overriding previous definitions) because they are defined in the  package when the  statement is executed.


Answer URL
https://docs.python.org/3/tutorial/modules.html#importing-from-a-package
