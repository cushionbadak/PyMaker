Natural Text
i want to write a decorator that enables methods of classes to become visible to other parties; the problem i am describing is, however, independent of that detail. the code will look roughly like this:my problem here is that the very moment that the decorator, , gets to see the method, it is not yet callable; instead, it gets to see an unbound version of it. maybe this can be resolved by using another decorator on the class that will take care of whatever has to be done to the bound method. the next thing i will try to do is to simply earmark the decorated method with an attribute when it goes through the decorator, and then use a class decorator or a metaclass to do the postprocessing. if i get that to work, then i do not have to solve this riddle, which still puzzles me: can anyone, in the above code, fill out meaningful lines under  so that the decorator can actually print out the class where  is defined, the moment it gets defined? or is that possibility precluded in python 3?
When the decorator is called, it's called with a function as its argument, not a method -- therefore it will avail nothing to the decorator to examine and introspect its method as much as it wants to, because it's only a function and carries no information whatsoever about the enclosing class.  I hope this solves your "riddle", although in the negative sense!Other approaches might be tried, such as deep introspection on nested stack frames, but they're hacky, fragile, and sure not to carry over to other implementations of Python 3 such as pynie; I would therefore heartily recommend avoiding them, in favor of the class-decorator solution that you're already considering and is much cleaner and more solid.
This is a very old post, but introspection isn't the way to solve this problem, because it can be more easily solved with a metaclass and a bit of clever class construction logic using descriptors.The key to making this work is the metaclass - it searches through the attributes defined on the classes it creates to find  descriptors. Once it does, it passes them information about the classes they are involved in through the descriptor's  and  methods. is called only for the class which the descriptor is defined on. This is where modifications to  should be made, because the method is only called once. While  is called for all classes which have access to the decorated method. This is where modifications to the classes  can be referenced by should be made.example
As I mentioned in some other answers, since Python 3.6 the solution to this problem is very easy thanks to  which gets called with the class object that is being defined.We can use it to define a decorator that has access to the class in the following way:Which can then be used as a normal decorator:


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__set_name__
