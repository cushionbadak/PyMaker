Natural Text
I recently developed a class named  around some ORM document object in Python to transparently add some features to it without changing its interface in any way.I just have one issue with this. Let's say I have some  object wrapped in it. Calling  will return  because  indeed is an instance of .Is there any way to fake the type of an object in Python to have the same call return ?
Testing the type of an object is usually an antipattern in python.  In some cases it makes sense to test the "duck type" of the object, something like:But even that's undesirable, for instance there are reasons why that expression might return false, even though a wrapper uses some magic with  to correctly proxy the attribute.  It's usually preferred to allow variables only take a single abstract type, and possibly .  Different behaviours based on different inputs should be achieved by passing the optionally typed data in different variables.  You want to do something like this:Of course, this all assumes you have some level of control of the code that is doing the type checking.  Suppose it isn't.  for "isinstance()" to return true, the class must appear in the instance's bases, or the class must have an .   Since you don't control either of those things for the class, you have to resort to some shenanigans on the instance.  Do something like this:What we're doing is creating a new class dynamically at the time we need to wrap the instance, and actually inherit from the wrapped object's .  We also go to the extra trouble of overriding the , in case the original had some extra behaviors we don't actually want to encounter (like looking for a database table with a certain class name).  A nice convenience of this style is that we never have to create any instance attributes on the wrapper class, there is no , since that value is present at class creation time.  Edit: As pointed out in comments, the above only works for some simple types, if you need to proxy more elaborate attributes on the target object, (say, methods), then see the following answer:  Python - Faking Type Continued
You can use the  magic method to override the default  behaviour:This is only if you want your object to be a transparent wrapper; that is, if you want a  to behave like a . Otherwise, just expose the wrapped class as an attribute.This is a Python 3 addition; it came with abstract base classes. You can't do the same in Python 2.
Override  in your wrapper class :This way no modifications to the wrapped class  are needed.Python Mock does the same (see mock.py:612 in mock-2.0.0, couldn't find sources online to link to, sorry).
Here is a solution by using metaclass, but you need to modify the wrapped classes:
It sounds like you want to test the type of the object your  wraps, not the type of the  itself. If that's right, then the interface to  needs to expose that type. You might add a method to your  class that returns the type of the wrapped object, for instance. But I don't think that making the call to  ambiguous, by making it return True when it's not, is the right way to solve this.
The best way is to inherit DocumentWrapper from the User itself, or mix-in pattern and doing multiple inherintance from many classes You can also fake isinstance() results by manipulating  but this is deep level magic and should not be done.


Answer URL
https://docs.python.org/3/howto/descriptor.html
