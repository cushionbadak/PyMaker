Natural Text
I'm having trouble understanding . From what I understand,  returns the absolute path from which the module was loaded. I'm having problem producing this: I have a  with one statement , running from   returns . running from  returns . Any reasons why?
From the documentation: is the pathname of the file from which the module was loaded, if it was loaded from a file. The  attribute is not present for C modules that are statically linked into the interpreter; for extension modules loaded dynamically from a shared library, it is the pathname of the shared library file.From the mailing list thread linked by @kindall in a comment to the question:I haven't tried to repro this particular example, but the reason is  that we don't want to have to call getpwd() on every import nor do we  want to have some kind of in-process variable to cache the current  directory. (getpwd() is relatively slow and can sometimes fail  outright, and trying to cache it has a certain risk of being wrong.)What we do instead, is code in site.py that walks over the elements of  sys.path and turns them into absolute paths. However this code runs  before '' is inserted in the front of sys.path, so that the initial  value of sys.path is ''.For the rest of this, consider  not to include .So, if you are outside the part of  that contains the module, you'll get an absolute path. If you are inside the part of  that contains the module, you'll get a relative path.If you load a module in the current directory, and the current directory isn't in , you'll get an absolute path.If you load a module in the current directory, and the current directory is in , you'll get a relative path.
 is absolute since Python 3.4, except when executing a script directly using a relative path:Module  attributes (and related values) should now always contain absolute paths by default, with the sole exception of  when a script has been executed directly using a relative path. (Contributed by Brett Cannon in bpo-18416.)Not sure if it resolves symlinks though.Example of passing a relative path:
Late simple example:Under Python-2.*, the second call incorrectly determines the  based on the current directory:As noted by @techtonik, in Python 3.4+, this will work fine since  returns an absolute path.
With the help of the of Guido mail provided by @kindall, we can understand the standard import process as trying to find the module in each member of , and file as the result of this lookup (more details in PyMOTW Modules and Imports.). So if the module is located in an absolute path in  the result is absolute, but if it is located in a relative path in  the result is relative.Now the  startup file takes care of delivering only absolute path in , except the initial , so if you don't change it by other means than setting the PYTHONPATH (whose path are also made absolute, before prefixing ), you will get always an absolute path, but when the module is accessed through the current directory.Now if you trick sys.path in a funny way you can get anything.As example if you have a sample module  in  with the code:If you go in /tmp you get:When in  in , if you add  your  you get:Even if you add , it will be normalized and the result is the same.But if instead of using  you use directly some funny pathyou get a result as funny as the cause.Guido explains in the above cited thread, why python do not try to transform all entries in absolute paths:we don't want to have to call getpwd() on every import ....  getpwd() is relatively slow and can sometimes fail outright,So your path is used as it is.


Answer URL
https://docs.python.org/3/reference/datamodel.html
