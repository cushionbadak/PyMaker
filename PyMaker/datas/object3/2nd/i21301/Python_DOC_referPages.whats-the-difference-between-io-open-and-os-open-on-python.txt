Natural Text
I realised that the  function I've been using was an alias to  and that importing  from  would overshadow that. What's the difference between opening files through the  module and  module?
 is the preferred, higher-level interface to file I/O.  It wraps the OS-level file descriptor in an object that you can use to access the file in a Pythonic manner. is just a wrapper for the lower-level POSIX syscall.  It takes less symbolic (and more POSIX-y) arguments, and returns the file descriptor (a number) that represents the opened file.  It does not return a file object; the returned value will not have  or  methods.From the  documentation:This function is intended for low-level I/O. For normal usage, use the built-in function , which returns a “file object” with  and  methods (and many more). 
Absolutely everything: takes a filename as a string, the file mode as a bitwise mask of attributes, and an optional argument that describes the file permission bits, and returns a file descriptor as an integer. takes a filename as a string or a file descriptor as an integer, the file mode as a string, and optional arguments that describe the file encoding, buffering used, how encoding errors and newlines are handled, and if the underlying FD is closed when the file is closed, and returns some descendant of .
 is very similar to  from C in Unix. You're unlikely to want to use it unless you're doing something much more low-level. It gives you an actual file descriptor (as in, a number, not an object). is your basic Python  and what you want to use just about all the time.
 method opens the file file and set various flags according to flags and possibly its mode according to mode.The default mode is 0777 (octal), and the current unmask value is first masked out.This method returns the file descriptor for the newly opened file.While, method opens a file, in the mode specified in the string mode. It returns a new file handle, or, in case of errors, nil plus an error message. Hope this helps
To add to the existing answers:I realised that the open() function I've been using was an alias to io.open() ==  in Python 3 only. In Python 2 they are different.While with  in Python we can obtain an easy-to-use file object with handy  and  methods, on the OS level files are accessed using file descriptors (or file handles in Windows). Thus,  should be used implicitly under the hood. I haven't examined Python source code in this regard, but the documentation for the  parameter, which was added for  in Python 3.3, says:A custom opener can be used by passing a callable as opener. The  underlying file descriptor for the file object is then obtained by  calling opener with (file, flags). opener must return an open file  descriptor (passing  as opener results in functionality similar  to passing ).So  is the default opener for , and we also have the ability to specify a custom wrapper around it if file flags or mode need to be changed. See the documentation for  for an example of a custom opener, which opens a file relative to a given directory. 


Answer URL
https://docs.python.org/3/library/functions.html#open
