Natural Text
NumPy proposes a way to get the index of the maximum value of an array via .I would like a similar thing, but returning the indexes of the  maximum values.For instance, if I have an array, ,  would return the indices  which correspond to the elements .
The simplest I've been able to come up with is:This involves a complete sort of the array. I wonder if  provides a built-in way to do a partial sort; so far I haven't been able to find one.If this solution turns out to be too slow (especially for small ), it may be worth looking at coding something up in Cython.
Newer NumPy versions (1.8 and up) have a function called  for this. To get the indices of the four largest elements, doUnlike , this function runs in linear time in the worst case, but the returned indices are not sorted, as can be seen from the result of evaluating . If you need that too, sort them afterwards:To get the top-k elements in sorted order in this way takes O(n + k log k) time.
Simpler yet:where n is the number of maximum values.
Use:For regular Python lists:If you use Python 2, use  instead of .Source: heapq â€” Heap queue algorithm
If you happen to be working with a multidimensional array then you'll need to flatten and unravel the indices:For example:
If you don't care about the order of the K-th largest elements you can use , which should perform better than a full sort through .Credits go to this question.I ran a few tests and it looks like  outperforms  as the size of the array and the value of K increase.
For multidimensional arrays you can use the  keyword in order to apply the partitioning along the expected axis.And for grabbing the items:But note that this won't return a sorted result. In that case you can use  along the intended axis:Here is an example:
This will be faster than a full sort depending on the size of your original array and the size of your selection:It, of course, involves tampering with your original array.  Which you could fix (if needed) by making a copy or replacing back the original values.  ...whichever is cheaper for your use case.
 has a partial sort function, if the expense of sorting the entire array just to get the N largest values is too great.I know nothing about this module; I just googled .
Use:Now the  list would contain N tuples (, ) where  is maximized.
Method  only returns the k largest indices, performs a local sort, and is faster than (performing a full sort) when array is quite large. But the returned indices are NOT in ascending/descending order. Let's say with an example:We can see that if you want a strict ascending order top k indices,  won't return what you want.Apart from doing a sort manually after np.argpartition, my solution is to use PyTorch, , a tool for neural network construction, providing NumPy-like APIs with both CPU and GPU support. It's as fast as NumPy with MKL, and offers a GPU boost if you need large matrix/vector calculations.Strict ascend/descend top k indices code will be:Note that  accepts a torch tensor, and returns both top k values and top k indices in type . Similar with np, torch.topk also accepts an axis argument so that you can handle multi-dimensional arrays/tensors.
Use:It also works with 2D arrays. For example,
The following is a very easy way to see the maximum elements and its positions. Here  is the domain;  = 0 means column wise maximum number and  = 1 means row wise max number for the 2D case. And for higher dimensions it depends upon you.
I found it most intuitive to use . The idea is, that the unique method returns the indices of the input values. Then from the max unique value and the indicies, the position of the original values can be recreated.
I think the most time efficiency way is manually iterate through the array and keep a k-size min-heap, as other people have mentioned.And I also come up with a brute force approach:Set the largest element to a large negative value after you use argmax to get its index. And then the next call of argmax will return the second largest element.And you can log the original value of these elements and recover them if you want.


Answer URL
