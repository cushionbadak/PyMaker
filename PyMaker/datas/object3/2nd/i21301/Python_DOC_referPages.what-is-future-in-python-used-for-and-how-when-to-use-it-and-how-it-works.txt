Natural Text
People including me know there is something in Python called  and it appears in quite a few modules I read. And the dull people like me don't know why it's there, and how/when to use it , even after reading the Python's  doc. So any explains with examples to demonstrate it?I have got a few answers quickly, which look all correct, in terms of the basic usage.However and also for further understanding how  works:I just realized one key thing that was confusing me when I tried to understand it, that is, how a current python release include something that will be released in future release?and how can a program using a new feature in a future python release be compiled successfully by the current python release?So, I guess now that, the current release has already packaged some potential features that will be included in future releases - is this right? but the features are available only by , that is because it doesn't become standard yet - am I right?
With  module's inclusion, you can slowly be accustomed to incompatible changes or to such ones introducing new keywords.E.g., for using context managers, you had to do  in 2.5, as the  keyword was new and shouldn't be used as variable names any longer. In order to be able to use a program which uses variables named , the above import statement is needed.Another example isWithout the  stuff, both  statements would print .The internal difference is that without that import,  is mapped to the  method, while with it,  is used. (In any case,  calls .)A propos :  becomes a function in 3.x, losing its special property as a keyword. So it is the other way round.
When you doYou're not actually using an  statement, but a future statement. You're reading the wrong docs, as you're not actually importing that module.Future statements are special -- they change how your Python module is parsed, which is why they must be at the top of the file. They give new -- or different -- meaning to words or symbols in your file. From the docs:A future statement is a directive to the compiler that a particular module should be compiled using syntax or semantics that will be available in a specified future release of Python. The future statement is intended to ease migration to future versions of Python that introduce incompatible changes to the language. It allows use of the new features on a per-module basis before the release in which the feature becomes standard.If you actually want to import the  module, just doand then access it as usual.
 is a pseudo-module which programmers can use to enable new language features which are not compatible with the current interpreter. For example, the expression  currently evaluates to . If the module in which it is executed had enabled true division by executing:the expression  would evaluate to . By importing the  module and evaluating its variables, you can see when a new feature was first added to the language and when it will become the default:
It can be used to use features which will appear in newer versions while having an older release of Python.For examplewill allow you to use  as a function:
Or is it like saying "Since this is python v2.7, use that different 'print' function that has also been added to python v2.7, after it was added in python 3. So my 'print' will no longer be statements (eg print "message" ) but functions (eg, print("message", options). That way when my code is run in python 3, 'print' will not break."In print_function is the module containing the new implementation of 'print' as per how it is behaving in python v3.This has more explanation: http://python3porting.com/noconv.html
There are some great answers already, but none of them address a complete list of what the  statement currently supports.Put simply, the __future__ statement forces Python interpreters to use newer features of the language. The features that it currently supports are the following::Prior to Python 2.1, the following code would raise a NameError:The  directive will allow for this feature to be enabled.:Introduced generator functions such as the one below to save state between successive function calls::Classic division is used in Python 2.x versions. Meaning that some division statements return a reasonable approximation of division ("true division") and others return the floor ("floor division"). Starting in Python 3.0, true division is specified by , whereas floor division is specified by . The  directive forces the use of Python 3.0 style division.:Allows for parenthesis to enclose multiple  statements. For example:Instead of:Or::Adds the statement "with" as a keyword in Python to eliminate the need for  statements. Common uses of this are when doing file I/O such as::Forces the use of Python 3 parenthesis-style  function call instead of the  style print statement.:Introduces the literal syntax for the  object. Meaning that statements such as  can be simply expressed as .:Replaces the use of the  exception used inside generator functions with the  exception.One other use not mentioned above is that the  statement also forces the use of Python 2.1+ interpreters since using an older version will throw a runtime exception.References:https://docs.python.org/2/library/future.htmlhttps://docs.python.org/3/library/future.htmlhttps://docs.python.org/2.2/whatsnew/node9.htmlhttps://www.python.org/dev/peps/pep-0255/https://www.python.org/dev/peps/pep-0238/https://www.python.org/dev/peps/pep-0328/https://www.python.org/dev/peps/pep-3112/https://www.python.org/dev/peps/pep-0479/
One of the uses which I found to be very useful is the  from  module.In Python 2.7, I wanted chars from different print statements to be printed on same line without spaces.It can be done using a comma(",") at the end, but it also appends an extra space.The above statement when used as : This will print the value of  from each iteration in a single line without spaces.
After Python 3.0 onward, print is no longer just a statement, its a function instead. and is included in PEP 3105. Also I think the Python 3.0 package has still these special functionality. Lets see its usability through a traditional "Pyramid program" in Python:If we use normal print function, we won't be able to achieve the same output, since print() comes with a extra newline. So every time the inner for loop execute, it will print * onto the next line.


Answer URL
https://docs.python.org/3/library/__future__.html
