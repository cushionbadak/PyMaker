Natural Text
I'd think this has already been asked, but I can't find itHow can one check for non-builtin types in Python 3.6?For example, let's say I want to have a function foo() that takes a numpy array as an arg, and returns an instance of my class BahCan I do something like this?  How do I add those types to checking?
You can specify anything you want, as a type annotation if the type’s name is in scope (e.g., you’ve defined  in the current file, or done a Bob`).In general, the type checker doesn’t need any special knowledge of the type to know whether a value is that type. If it sees you store the result of this function in a variable whose type is , or a supertype of  (which includes  and , and also includes unannotated variables), that’s legal; if it sees you store it in a variable whose type is  or some other unrelated type, it’s not. Similarly, if you pass the result on to some other function whose parameter is  or  or unannotated, or you append it to a , etc.But  is a different problem. That isn’t actually a type, it’s just a constructor function that usually returns a value of type , which is a type you don’t normally think about anywhere. So, a type checker can’t handle that without some kind of special information that  should be treated as a synonym for .Plus, many NumPy functions—and, implicitly, functions that you write yourself—actually take an “array-like”, which can be an , or usually a , but also often any sequence. In which case you probably really want to either annotate then with something closer to accurate, like —or maybe with a custom  type.While we’re at it, you often want to specify the dtype—your function doesn’t want an array, it wants an array of floats, or it wants an array of  and wants to return a  whose values are that same . So, you probably want a generic type like  or  to some typevar .And you may even want to require a certain number of dimensions, or even a shape for those dimensions, or even a partial shape, or even that parameters  and  have to be broadcastable together or multiplyable. You can push this information into a generic type, but you’ll have to think it through pretty carefully.Anyway, for your own types, you rarely have to think that deep. Either  is a simple type that only needs the standard inheritance rules, so you don’t have to do anything, or it’s a generic collection type, where you just need to inherit/register it as a  or a  or whatever and it automatically gets the appropriate generic rules, or it’s a specific collection type, where you just inherit/register as a  and it automatically gets the approprIate rules.
You could use typing. It is a Python library https://docs.python.org/3/library/typing.html
Basically, just look at the output of type(a) if you know that a is a numpy array. This will tell you that the class is called "numpy.ndarray". Then check for that by using isinstance(). Like this:


Answer URL
https://docs.python.org/3/library/typing.html
