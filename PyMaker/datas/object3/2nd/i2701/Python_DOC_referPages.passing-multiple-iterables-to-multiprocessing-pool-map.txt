Natural Text
Consider the following function:If I use , I get the following timings:Now if I use  instead of using a default value:Why is the version using  so much slower?
Using  requires sending the worker processes information about the function to run, not just the arguments to pass.  That information is transferred by pickling that information in the main process, sending it to the worker process, and unpickling it there.This leads to the primary issue:Pickling a function with default arguments is cheap; it only pickles the name of the function (plus the info to let Python know it's a function); the worker processes just look up the local copy of the name. They already have a named function  to find, so it costs almost nothing to pass it.But pickling a  function involves pickling the underlying function (cheap) and all the default arguments (expensive when the default argument is a 10M long ). So every time a task is dispatched in the  case, it's pickling the bound argument, sending it to the worker process, the worker process unpickles, then finally does the "real" work. On my machine, that pickle is roughly 50 MB in size, which is a huge amount of overhead; in quick timing tests on my machine, pickling and unpickling a 10 million long  of  takes about 620 ms (and that's ignoring the overhead of actually transferring the 50 MB of data).s have to pickle this way, because they don't know their own names; when pickling a function like ,  (being -ed) knows its qualified name (in an interactive interpreter or from the main module of a program, it's ), so the remote side can just recreate it locally by doing the equivalent of . But the  doesn't know its name; sure, you assigned it to , but neither  nor the  itself know it available with the qualified name ; it could be named  or a million other things. So it has to  the info necessary to recreate it entirely from scratch. It's also -ing for each call (not just once per worker) because it doesn't know that the callable isn't changing in the parent between work items, and it's always trying to ensure it sends up to date state.You have other issues (timing creation of the  only in the  case and the minor overhead of calling a  wrapped function vs. calling the function directly), but those are chump change relative to the per-call overhead pickling and unpickling the  is adding (the initial creation of the  is adding one-time overhead of a little under half what each pickle/unpickle cycle costs; the overhead to call through the  is less than a microsecond).


Answer URL
https://docs.python.org/3/library/pickle.html
