Natural Text
ScenarioLet  be the module we run as . This module contains one global variable named , which is initialized in the module with the following assignment.The module also contains a function named , which alters this global variable:I then want to time said function using the builtin  module. I want to use the  function and get the minimum value of the timing, as a way of improving the measurement's accuracy (instead of measuring just one time, which may be subject to slow-down due to unrelated processes).The problem is that the  function behaves differently depending on the value of : I expected that, for each repetition, the  statement in the  parameter would re-run the  statement in the , thus 'resetting'  so that the code being executed would be identical for each repetition. But, instead, the value of  that resulted from the previous execution is used, so I had to add the statement  to the  parameter:QuestionThis leads me to the question: is there a direct way (i.e. in one statement) to 'reset' the values of all the global variables to what they were when they were first assigned in the module?In this specific scenario adding that one statement to manually 'reset'  works fine, but consider a case in which there are a lot of global variables, and you want to 'reset' all of them.Side quest ionWhy doesn't the statement  re-run the initial  assignment?
Let's start with your side question, because it turns out that it's actually central to everything:Why doesn't the statement  re-run the initial  assignment?" Because, as explained in the docs on the import system and the  statement, what  does is, loosely, this pseudocode:OK, but why does it do that?If you have two modules that both import the same module, they expect to see the same globals. And remember that types, functions, etc. defined at the top level of a function are all globals. For example, if  imports  to , and  imports  to , you'd want a  to pass that test—but it won't if those are two completely independent types because they came from two different module objects that happen to have the same name,If you have 12 modules that all , you'd be running all the Pandas initialization code 12 times. Except that some of your modules also probably import each other, so they'd each be run multiple times, and import Pandas each time. How long do you think it would take to run all the Pandas initialization 60 times?So, reusing existing modules is almost always what you want.And when you don't, that's usually a sign that there's something wrong with your design (which may well be the case here).But "almost always" isn't "always". So there are ways around it. None of them are usually a good idea for live code, but for things like unit tests and benchmarking, there are three basic options that are all fine, as long as the tradeoffs are the ones you want:. This is obviously pretty hacky, but it actually does exactly what you want here. Any existing references to the old module are completely untouched, but the next time anyone does , they're going to get a brand-new  module.. This sounds great, but it may on the one hand be overkill (notice that it forces the module source to be recompiled, which you don't need), while on the other it may not be sufficient (it doesn't actually reset the globals—if your code does  at the top level, that line gets executed, so who cares, but if your code instead does, say,  inside the  function, you care).Instead of , manually do all the steps up through executing the module (see the examples in the  docs), but don't store it in  or in , just store it in a local variable you discard after each test. This is probably the cleanest, although it does mean 6 lines of code instead of 1.


Answer URL
https://docs.python.org/3/reference/import.html
https://docs.python.org/3/reference/simple_stmts.html#the-import-statement
https://docs.python.org/3/library/sys.html#sys.modules
https://docs.python.org/3/library/importlib.html#importlib.reload
https://docs.python.org/3/library/importlib.html#examples
