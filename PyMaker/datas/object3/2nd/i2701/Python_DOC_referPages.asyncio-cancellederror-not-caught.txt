Natural Text
Why is the  not caught in this example?I excpected to get the "getter cancelled" message, but received a stack trace instead:Task.cancel states:This arranges for a CancelledError to be thrown into the wrapped  coroutine on the next cycle through the event loop. The coroutine then  has a chance to clean up or even deny the request using  try/except/finally.
The problem is that  didn't even start executing, which you can confirm by adding a print at its beginning. Since the  block was never entered, the  didn't run either.This happens because, in contrast to ,  doesn't start executing the coroutine right away, it just schedules it to run at the next event loop iteration, like  does for ordinary functions. Since you cancel the task immediately, it gets removed from the runnable set and its coroutine gets closed without ever having started.Add an  before  and you should observe the behavior you expect. I suspect you don't need to make such change in your actual code - in the unlikely case that the task gets cancelled before it ran, as in the example, it won't get a chance to acquire the resources that try/except cleans up in the first place.Two tangential remarks:You probably want to re-raise  after handling it, otherwise it will be suppressed. That's not a problem in  as shown in the question, but it could be an issue if the code were buried in a function call. Even better, consider using  or , which propagate the exception and ensure that the resources are released regardless of exception type.When you need to create a task and run a coroutine,  is preferred to . In short, although both do the same thing for coroutines,  makes the intention clearer;  is designed to accept a wider range of objects and procure a future of an unspecified type.


Answer URL
https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.cancel
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.create_task
