Natural Text
I need to output any repeated character to refer to the previous character. For example:  or This is my code so far:Output: The second  is not recognised. And I'm not sure how to include brackets in my print.
By updating the text in-place each time you find a back-reference, you muck up your indices (your text gets longer each time) and you never process the last characters properly. You stop checking when you find the first repeat of the 'current' character, so the 3rd  is never processed. This applies to every 3rd repeat in an input string.  In addition, if your input text contains any  characters or digits they'll end up being tested against the  references you inserted before them too!For your specific example of , a string with 8 characters, what happens is this:You find the second  and set  to . The text is now 9 characters long, so the last  will never be checked (you loop to  at most); this would be a problem if your test string ended in a double letter. You break out of the loop, so the   loop never comes to the 3rd , and the second  can't be tested for anymore as it has already been replaced.Your code finds  (not repeated),  (not repeated) and then  (repeated once), so now you replace  with . Now you have a string of 10 characters, so , and  will never be tested. Not a big problem anymore, but what if there was a repeat in just the last 3 positions of the string?Build a new object for the output (adding both letters you haven't seen before and backreferences). That way you won't cause the text you are looping over to grow, and you will continue to find repeats; for the parentheses you could use more string concatenation. You'll need to scan the part of the string before , not after, for this to work, and go backwards! Testing , , etc, down to 0. Naturally, this means your  loop should then range up to the full length:I kept the fix to a minimum here, but ideally I'd also make some more changes:Add all processed characters and references to a new list instead of a string, then use  to join that list into the output afterwards. This is far more efficient than rebuilding the string each iteration.Using two loops means you check every character in the string again while looping over the text, so the number of steps the algorithm takes grows exponentially with the length of the input. In Computer Science we talk about the time complexity of algorithms, and yours is a O(N^2) (N squared) exponential algorithm. A text with 1000 letters would take up to 1 million steps to process! Rather than loop an exponential number of times, you can use a dictionary to track indices of letters you have seen. If the current character is in the dictionary you can then trivially calculate the offset. Dictionary lookups take constant time (O(1)), making the whole algorithm take linear time (O(N)), meaning that the time the process takes is directly proportional to the length of the input string.Use  to add a counter to the loop so you can just loop over the characters directly, no need to use .You can use string formatting to build a  string; Python 3.6 and newer have formatted string literals, where  strings take  placeholders that are just expressions. ()str.format()'({})'.format(some - calculation + or * other)`.Put together, that becomes:Demo:
Output:


Answer URL
https://docs.python.org/3/library/functions.html#enumerate
https://docs.python.org/3/reference/lexical_analysis.html#f-strings
