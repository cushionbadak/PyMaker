Natural Text
I am learning multithreading in python, what I am trying to achieve is a stack class that append(v) wait until size is not full, and a pop() wait until stack is not empty. My implementation is as follows, does it seems correct?
The first problem in your  here:Never  a condition and hold it when you're going to block on another sync object, or you're going to deadlock. Move this until after the other condition's  has succeeded.Next:Trying to  on a condition that you haven't acquired is a race that's roughly equivalent to not having a condition in the first place. You need to  this condition before the loop.Also, if there's an exception anywhere, you're going to leak locks, which will deadlock your program. You can fix this with careful / work, but it's much simpler to just use a  statement, as shown in the docs.So:The issues with  are the same in reverse.However, for most usage patterns, it's going to be more efficient to make both conditions share the same mutex, like this:â€¦ and that also makes things simpler.Plus, the check before the  isn't necessary. It will probably make things more efficient for certain cases (only a single producer, or only a single consumer), but it may make other cases slower, and it makes things more complicated, and also makes races harder to detect during debugging. So, I'd leave it off for now. Once you have everything working, write some benchmarks with whatever you actual usage patterns are and test it both ways (and with just the append-check and with just the pop-check, of course).As a side note, if you're not doing this to learn about conditions, but just because you need a self-synchronizing stack,  already provides that.And, even if it didn't, you could write it like this:For that matter, now that I think about it, the  docs link to the source, which should provide solid example code. It's a bit more complicated than you need, what with all the block-vs.-try-vs.-timeout options, and the whole / feature, but it's still pretty clear and readable.


Answer URL
https://docs.python.org/3/library/queue.html#queue.LifoQueue
https://docs.python.org/3/library/queue.html
