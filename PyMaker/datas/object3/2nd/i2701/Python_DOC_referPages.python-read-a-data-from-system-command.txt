Natural Text
I want to write a function that will execute a shell command and return its output as a string, no matter, is it an error or success message. I just want to get the same result that I would have gotten with the command line.What would be a code example that would do such a thing?For example:
The answer to this question depends on the version of Python you're using. The simplest approach is to use the  function: runs a single program that takes only arguments as input.1 It returns the result exactly as printed to . If you need to write input to , skip ahead to the  or  sections. If you want to execute complex shell commands, see the note on  at the end of this answer.The  function works on almost all versions of Python still in wide use (2.7+).2 But for more recent versions, it is no longer the recommended approach.Modern versions of Python (3.5 or higher): If you're using Python 3.5 or higher, and do not need backwards compatibility, the new  function is recommended. It provides a very general, high-level API for the  module. To capture the output of a program, pass the  flag to the  keyword argument. Then access the  attribute of the returned  object:The return value is a  object, so if you want a proper string, you'll need to  it. Assuming the called process returns a UTF-8-encoded string:This can all be compressed to a one-liner:If you want to pass input to the process's , pass a  object to the  keyword argument:You can capture errors by passing  (capture to ) or  (capture to  along with regular output). When security is not a concern, you can also run more complex shell commands by passing  as described in the notes below.This adds just a bit of complexity, compared to the old way of doing things. But I think it's worth the payoff: now you can do almost anything you need to do with the  function alone.Older versions of Python (2.7-3.4): If you are using an older version of Python, or need modest backwards compatibility, you can probably use the  function as briefly described above. It has been available since Python 2.7.It takes takes the same arguments as  (see below), and returns a string containing the program's output. The beginning of this answer has a more detailed usage example. You can pass  to ensure that error messages are included in the returned output -- but don't pass  to . It can cause deadlocks. When security is not a concern, you can also run more complex shell commands by passing  as described in the notes below.If you need to pipe from  or pass input to the process,  won't be up to the task. See the  examples below in that case. Complex applications & legacy versions of Python (2.6 and below): If you need deep backwards compatibility, or if you need more sophisticated functionality than  provides, you'll have to work directly with  objects, which encapsulate the low-level API for subprocesses. The  constructor accepts either a single command without arguments, or a list containing a command as its first item, followed by any number of arguments, each as a separate item in the list.  can help parse strings into appropriately formatted lists.  objects also accept a host of different arguments for process IO management and low-level configuration. To send input and capture output,  is almost always the preferred method. As in:Or If you set ,  also allows you to pass data to the process via :Note Aaron Hall's answer, which indicates that on some systems, you may need to set , , and  all to  (or ) to get  to work at all.In some rare cases, you may need complex, real-time output capturing. Vartec's answer suggests a way forward, but methods other than  are prone to deadlocks if not used carefully.As with all the above functions, when security is not a concern, you can run more complex shell commands by passing .Notes1. Running shell commands: the  argumentNormally, each call to , , or the  constructor executes a single program. That means no fancy bash-style pipes. If you want to run complex shell commands, you can pass , which all three functions support.However, doing so raises security concerns. If you're doing anything more than light scripting, you might be better off calling each process separately, and passing the output from each as an input to the next, viaOrThe temptation to directly connect pipes is strong; resist it. Otherwise, you'll likely see deadlocks or have to do hacky things like this.2. Unicode considerations returns a string in Python 2, but a  object in Python 3. It's worth taking a moment to learn about unicode if you haven't already.
This is way easier, but only works on Unix (including Cygwin).it returns a tuple with the (return_value, output)This only works in : it is not available on . For a solution that works in both, use the  module instead:
Something like that: Note, that I'm redirecting stderr to stdout, it might not be exactly what you want, but I want error messages also.This function yields line by line as they come (normally you'd have to wait for subprocess to finish to get the output as a whole).For your case the usage would be:
Vartec's answer doesn't read all lines, so I made a version that did:Usage is the same as the accepted answer:
This is a tricky but super simple solution which works in many situations:A temporary file(here is tmp) is created with the output of the command and you can read from it your desired output.Extra note from the comments:You can remove the tmp file in the case of one-time job. If you need to do this several times, there is no need to delete the tmp.
In Python 3.5:
I had the same problemBut figured out a very simple way of doing thisfollow thisHope it helps outNote: This solution is python3 specific as  don't work in python2
You can use following commands to run any shell command. I have used them on ubuntu.
Modern Python solution (>= 3.1): 
Your Mileage May Vary, I attempted @senderle's spin on Vartec's solution in Windows on Python 2.6.5, but I was getting errors, and no other solutions worked. My error was: . I found that I had to assign PIPE to every handle to get it to return the output I expected - the following worked for me.and call like this, ( gets the first element of the tuple, ):After learning more, I believe I need these pipe arguments because I'm working on a custom system that uses different handles, so I had to directly control all the std's.To stop console popups (with Windows), do this:
I had a slightly different flavor of the same problem with the following requirements:Capture and return STDOUT messages as they accumulate in the STDOUT buffer (i.e. in realtime). @vartec solved this Pythonically with his use of generators and the 'yield'keyword abovePrint all STDOUT lines (even if process exits before STDOUT buffer can be fully read)Don't waste CPU cycles polling the process at high-frequencyCheck the return code of the subprocessPrint STDERR (separate from STDOUT) if we get a non-zero error return code.I've combined and tweaked previous answers to come up with the following:This code would be executed the same as previous answers:
If you need to run a shell command on multiple files, this did the trick for me.Edit: Just saw Max Persson's solution with J.F. Sebastian's suggestion.  Went ahead and incorporated that.
Splitting the initial command for the  might be tricky and cumbersome.Use  to help yourself out.Sample commandThe code
eg, execute('ls -ahl')differentiated three/four possible returns and OS platforms:no output, but run successfullyoutput empty line, run successfullyrun failedoutput something, run successfullyfunction below


Answer URL
https://docs.python.org/3/library/subprocess.html#subprocess.check_output
https://docs.python.org/3/library/subprocess.html#using-the-subprocess-module
https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess
https://docs.python.org/3/library/shlex.html
https://docs.python.org/3/library/subprocess.html#subprocess.Popen
https://docs.python.org/3/library/subprocess.html#security-considerations
https://docs.python.org/3/howto/unicode.html
