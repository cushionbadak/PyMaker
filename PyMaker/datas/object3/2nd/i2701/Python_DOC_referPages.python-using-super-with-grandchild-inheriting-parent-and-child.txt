Natural Text
[using Python3.6]I have a design where Grandchild inherits a Parent and Child (of Parent).the result is -Calling a function from Parent causes the aux_func to resolve from the Child class. I tried to go through MRO process but can't explain functions being called from different classes. Could someone help me withWhy this is happening ?What would be a workaround to achieve [parent main][parent aux] ?  
You are misunderstanding what  does.  does not alter the type of the  reference.  will still pass in that  reference to the method being called, so  is, in all three cases, the  instance.That means that in all cases,  follows the normal attribute resolution order, and for  instances,  will always find  and call that.Put differently, the only lookup that is altered, is the attribute you look up on the  object itself. If you need more such alterations, you need to use  again, or you need to give your  functions different names per class. One way to do that is to make the methods class private.The latter can be done by naming your function with two underscores at the start (but not at the end). Such names are then altered at compile time to inject the class names in all places that it is referenced:See the Reserved classes of identifiers documentation:  Class-private names. Names in this category, when used within the context of a class definition, are re-written to use a mangled form to help avoid name clashes between “private” attributes of base and derived classes.and the Identifiers (Names) section:Private name mangling: When an identifier that textually occurs in a class definition begins with two or more underscore characters and does not end in two or more underscores, it is considered a private name of that class. Private names are transformed to a longer form before code is generated for them. The transformation inserts the class name, with leading underscores removed and a single underscore inserted, in front of the name. For example, the identifier  occurring in a class named  will be transformed to . This transformation is independent of the syntactical context in which the identifier is used.By using class private naming for , any reference to it from methods defined on  will look up and find , and any reference to the same name in  will look up and find . The two names are distinct and thus don't clash:A different way to achieve this is to use distinct names, explicitly; say  and . Class private names are really only intended in APIs that are meant to be subclassed by third-party code without too many restrictions on what names the subclass can use.


Answer URL
https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers
https://docs.python.org/3/reference/expressions.html#atom-identifiers
