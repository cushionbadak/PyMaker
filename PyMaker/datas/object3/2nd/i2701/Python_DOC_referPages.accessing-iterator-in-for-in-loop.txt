Natural Text
From my understanding, when code like the following is run:MyObject's  function is run, and the for loop uses the iterator it returns to run the loop.is it possible to access this iterator object mid-loop? Is it a hidden local variable, or something like that?I would like to do the following:I want to do this because I am building a debugger, and I need to modify the iterator after it has been instantiated (adding an object to be iterated during this loop, mid-execution). I am aware that this a hack and should not be done conventionally. Modifying MyObject.items (which is what the iterator is iterating over) directly doesn't work, sicne the iterator only evaluates once. So I need to modify the iterator directly.
It is possible to do what you want to do, as long as you're willing to rely on multiple undocumented internals of your Python interpreter (in my case, CPython 3.7)—but it isn't going to do you any good.The iterator is not exposed to , or anywhere else (not even to a debugger). But as pointed out by Patrick Haugh, you can get at it indirectly, via . For example:Of course if you have two different iterators to the same list, I don't know if there's any way you can decide between them, but let's ignore that problem.Now, what do you do with this? You've got an iterator over , and… now what? You can't replace it with something useful, like an . There's no public API for mutating list, set, etc. iterators, much less arbitrary iterators.if you happen to know it's a list iterator… well, the CPython 3.x  does happen to be mutable. The way they're pickled is by creating an empty iterator and calling  with a reference to a list and an index:But this is all kind of silly, because you could get the same effect by just mutating the original list. In fact:So:… will print out:… without having to monkey with the iterator at all.You can't do the same thing with a set.Mutating a set while you're in the middle of iterating it will affect the iterator, just as mutating a list will—but what it does is indeterminate. After all, sets have arbitrary order, which is only guaranteed to be consistent as long as you don't add or delete. What happens if you add or delete in the middle? You may get a whole different order, meaning you may end up repeating elements you already iterated, and missing ones you never saw. Python implies that this should be illegal in any implementation, and CPython does actually check it:This will just immediately raise:So, what happens if we use the same trick to go behind Python's back, find the , and try to change it?What you'll see in this case will be something like:In other words, when you pickle a , it creates a list of the remaining elements, and gives you back instructions to build a new listiterator out of that list. Mutating that temporary list obviously has no useful effect.What about a tuple? Obviously you can't just mutate the tuple itself, because tuples are immutable. But what about the iterator?Under the covers, in CPython,  shares the same structure and code as  (as does the  type that you get from calling  on an "old-style sequence" type that defines  and  but not reduce` it.But once you do,  is going to be true again—in other words, it's a tuple, the same tuple you already had, and still immutable.
No, it is not possible to access this iterator (unless maybe with the Python C API, but that is just a guess). If you need it, assign it to a variable before the loop.Keep in mind that manually advancing the iterator can raise a  exception.The use of  is discussable. In this case it has the same semantics as  but you may just use  if you want to keep going until the end of the for-block.
If you want to insert an additional object into a loop mid-iteration in a debugger, you don't need to do it by modifying the iterator. Instead, after the end of the loop, jump to the first line of the loop body, then set the loop variable to the object you want. Here's a PDB example. With the following file:I've recorded a debugging session that inserts a  into the loop:(Due to a PDB bug, you have to jump, then set the loop variable. PDB will lose the change to the loop variable if you jump immediately after setting it.)
If you are not aware of the  debugger in python, please give it a try. It's a very interactive debugger I have ever come across.python debuggerI am sure we can control the loop iterations manually with pdb. But altering list mid way, not sure. Give it a try. 
To access the iterator of a given object, you can use the iter() built-in function.


Answer URL
https://docs.python.org/3/library/gc.html#gc.get_referrers
https://docs.python.org/3/library/functions.html?#iter
https://docs.python.org/3/library/gc.html#gc.get_referrers
