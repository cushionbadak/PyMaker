Natural Text
I'll illustrate my question with a couple of overly simple functions that just square numbers. But it is the general best practice for writing functions that I want to know about.Suppose I have a number that I want to square, I could write the following function.If I had a list of numbers and wanted to get the list in which each element is squared, I could useBut I want to write just one function that will handle both of these cases. It will see whether the input is a number or a list, and act accordingly. I could do this using  to detect type, but I'd like to know what the most pythonic way to do it is.
It's very simple if you use numpy. For multiple elements make it as an array. For single element ,the function is applied as it.
I would agree with @Bryan Oakley's answer, that it's best to write the code to only accept a single argument type. With that being said, I figured I would present an example of a function that handles a variable number of input arguments:Note that this will always return a list:Yields:
You can check for the type of the passed in argument and act accordingly:Output:
Treat the argument as list input and handle the exception if it's not.EAFP  Easier to ask for forgiveness than permission. This common Python coding style assumes the existence of valid keys or attributes and catches exceptions if the assumption proves false. This clean and fast style is characterized by the presence of many try and except statements. The technique contrasts with the LBYL style common to many other languages such as C. docs
As other answers have explained, this probably isn't a great design. First, a "number" could be an , or some user-defined subclass of , or a , or some user-defined  type. Normally, you just use duck-typing: it  works, then  is quacking like a number, and that's good enough.But a list of ints doesn't quack like an int. So, what can you do?Well, usually, you'll want to explicitly loop over them:… or write a function that does that:… or use a type that knows how to vectorize mathematical operators:In fact, even when you do want to handle two different types, you can often rely on duck typing:This will square anything that's number-like enough to be squarable, and iterate over squaring all of the elements of anything that isn't, and raise a reasonable exception for anything that fails (either because it's not iterable, or because its elements aren't squarable).Occasionally, you really do need to type-switch. But you still want to keep as close to duck-typing as possible, and that means using  (so that, e.g., a user subtype of  still counts as a number) and, usually, using abstract base classes (so that, e.g., a user  type still counts as a number).In this case, that means either treating numbers specially and assuming anything else is an iterable:… or treating iterables specially and assuming everything else is a number:Or maybe treating both specially and calling everything else an error:
You can write one line return but using type:


Answer URL
https://docs.python.org/3/library/abc.html
https://docs.python.org/3/library/numbers.html#numbers.Number
https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable
