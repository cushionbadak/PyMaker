Natural Text
It is a well-known problem in python that recursion involves a lot of overhead.  So much so, that even relatively shallow recursive calls cause programs to crash.  One possible workaround would be to implement fancy recursive algorithms in C, and provide python hooks.  However, it is also well-known that a recursive implementation of an algorithm is more expensive than, say, a loop almost no matter what, unless your compiler recognizes some very specific opportunities (such as tail recursion) to loop-ify the whole business.Anyhoo, since recursion involves the overhead of a function call, I was wondering what the relative expense of function calls (and thus recursion) is in python vs C?  I realize I could , but I was hoping for a principled explanation.  What all goes into a python function call vs a C one?  Also, are there a difference in the function call stack between python and C that would affect performance for deep call stacks?
You’re starting from a set of faulty premises:It is a well-known problem in python that recursion involves a lot of overhead. No it isn’t. The overhead for recursive function calls is essentially the same as for any other function calls. There’s probably a small difference in that you keep allocating new stack frames and loading them into the cache, whereas the same thing implemented with a loop with a non-recursive call inside would be able to reuse the same stack frame. But it’s going to be pretty minor.So much so, that even relatively shallow recursive calls cause programs to crash. No they don’t. Recursion beyond a depth of 1000 cleanly fails with an exception. This is in part to prevent such crashes, but also to make it easier to detect accidental infinite recursion.One possible workaround would be to implement fancy recursive algorithms in CThat’s not going to help anything. Most C implementations handle recursion essentially the same way most Python implementations do (in fact. In CPython, recursion can just be a matter of C-recursing the main eval loop). There’s still no tail call elimination, no special handling for keeping only live variables from a frame alive, etc. While C stack frames are a little smaller than Python ones, this is just a small multiplicative factor.And, meanwhile, unlike Python programs,, C programs actually will crash if you recurse too deeply.Of course C code does tend to be an order of magnitude or two faster than Python code when what you’re doing is low-level computation, and that will help you here the same way it well anywhere else (although maybe not as much as usual, because function calls in C are, while not as slow as Python, still far from free). Plus, C does force you to be more explicit about some things—e.g., there are no closures, so if you want the effect of  you’ll need to pass down pointers to locals—which could lead to you optimizing things you wouldn’t think to in Python.But in general, there is if anything less benefit here than there is in non-recursive code.There are also some cases where a good C optimizer can see that the whole frame is useless and drop it. In some cases, it can even completely eliminate a tail call. This isn’t as good as universal tail call elimination that you can rely on for correctness, but it’s certainly helpful.But a good JIT optimizer can sometimes do the same thing. And running your existing code in PyPy or Jython is certainly a lot simpler than rewriting it in C.(I’m sure there will be some cases where, e.g., LLVM’s AOT optimizer can help but PyPy’s JIT cannot, but I also suspect that anyone who could reliably guess what those cases are wouldn’t have asked this question in the first place.)There are languages that handle recursion better than Python and C.If you code your algorithm in, say, Haskell, and then wrap it in a C API that you can call via  or via a simple extension written on C (or maybe even just compile it as a program and subprocess it, if you’re talking about something that takes many seconds to run); that would work.But if you instead rewrite your recursion as a loop with an explicit stack, you will eliminate all of the problems associated with using recursion in a language that wasn’t designed to encourage it (that’s both Python and C), and open the doors for other optimizations.For example, you (or LLVM’s optimizer, or PyPy’s JIT) can inline a function call in the middle of an inner loop, which you obviously can’t do with a recursive call.Also, it generally becomes easier to pull out pieces of your code without having to call back and forth across the Python boundary, so you can port the bottleneck to a C extension module without having to port the whole thing.


Answer URL
https://docs.python.org/3/library/sys.html#sys.setrecursionlimit
