Natural Text
In Python, both  method and  built-in function accepts an optional parameter named , which is a function that, given an element from the list returns his sorting key.Older Python versions used a different approach using the  parameter instead, which is a function that, given two elements from the list returns a negative number if the first is less than the second, zero if there are equals and a positive number if the first is greater. At some point, this parameter was deprecated and wasn't included in Python 3.The other day I wanted to sort a list of elements in a way that a  function was much more easier to write than a  one. I didn't wanted to use a deprecated feature so I read the documentation and I found that there is a funtion named  in the  module which, as his name states, receives a  function and returns a  one... or that's what I thought until I read the source code (or at least an equivalent version) of this high level function included in the docsDespite the fact that  works as expected, I get surprised by the fact that this funtion doesn't return a function but a  class instead. Why? How does it work? My guess it that the  function internally checks whether cmp is a function or a K class or something similar, but I'm not sure.P.S.: Despite his wierdness, I found that K class is very useful. Check this code:This way, any list of instances of MyClass can be, by default, sorted by the criteria defined in 
No,  function (or ) internally does not need to check if the object it received is a function or a class . All it cares about is that the object it received in  argument should be callable and should return a value that can be compared to other values when called.Classes are also callable , when you call a class , you receive the instance of that class back.To answer your question, first we need to understand (atleast at a basic level) how  argument works -The  callable is called for each element and it receives back the object with which it should sort.After receiving the new object, it compares this to other objects (again received by calling the  callable with the othe element).Now the important thing to note here is that the new  received is compared against other same objects.Now onto your equivalent code, when you create an instance of that class, it can be compared to other instances of the same class using your  function. And sort when sorting the values compares these objects (in-effect) calling your  function to determine whether the value is less than or greater than the other object.Example with print statements -
I just realized that, despite not being a function, the K class is a callable, because it's a class! and classes are callables that, when called, creates a new instance, initializes it by calling the corresponding  and then returns that instance.This way it behaves as a  function because K receives the object when called, and wraps this object in a K instance, which is able to be compared against other K instances.Correct me if I'm wrong. I feel I'm getting into the, unfamiliar to me, meta-classes territory.
I didn't look into the source, but i believe the result of the key function can also be anything, and therefore also a comparable object. And cmp_to_key just masks creation of those K objects, which are than compared to each other while sort does its work.If i try to create a sort on departments and reverse room numbers like this:That's not what i want, and i think sort is only stable on each call, the documentation is misleading imo:The sort() method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal â€” this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade).The old style approach works because each result calling the K class returns a K instance and compares to results of mycmp:It's an important difference, that one can't do multiple passes just out of the box. The values/results of the key function have to be sortable relative in order, not the elements to be sorted. Therefore is the cmp_to_key mask: create those comparable objects one needs to order them.Hope that helps. and thanks for the insight in the cmp_to_key code, helped me alot also :)


Answer URL
https://docs.python.org/3/library/stdtypes.html#list.sort
