Natural Text
This should be very simple and I'm very surprised that I haven't been able to find this questions answered already on stackoverflow.I have a daemon like program that needs to respond to the SIGTERM and SIGINT signals in order to work well with upstart. I read that the best way to do this is to run the main loop of the program in a separate thread from the main thread and let the main thread handle the signals. Then when a signal is received the signal handler should tell the main loop to exit by setting a sentinel flag that is routinely being checked in the main loop.I've tried doing this but it is not working the way I expected. See the code below:I tested this in the following two ways:1)2)In both cases I expect this written to the output:In the first case the program exits but all I see is:In the second case the SIGTERM signal is seemingly ignored when ctrl+c is pressed and the program doesn't exit.What am I missing here?
The problem is that, as explained in Execution of Python signal handlers:A Python signal handler does not get executed inside the low-level (C) signal handler. Instead, the low-level signal handler sets a flag which tells the virtual machine to execute the corresponding Python signal handler at a later point(for example at the next bytecode instruction)… A long-running calculation implemented purely in C (such as regular expression matching on a large body of text) may run uninterrupted for an arbitrary amount of time, regardless of any signals received. The Python signal handlers will be called when the calculation finishes.Your main thread is blocked on , which ultimately means it's blocked in C on a  call. Of course that's not a "long-running calculation", it's a block on a syscall… but nevertheless, until that call finishes, your signal handler can't run.And, while on some platforms  will fail with  on a signal, on others it won't. On linux, I believe it depends on whether you select BSD-style or default  behavior, but the default is no.So, what can you do about it?Well, I'm pretty sure the changes to signal handling in Python 3.3 actually changed the default behavior on Linux so you won't need to do anything if you upgrade; just run under 3.3+ and your code will work as you're expecting. At least it does for me with CPython 3.4 on OS X and 3.3 on Linux. (If I'm wrong about this, I'm not sure whether it's a bug in CPython or not, so you may want to raise it on python-list rather than opening an issue…)On the other hand, pre-3.3, the  module definitely doesn't expose the tools you'd need to fix this problem yourself. So, if you can't upgrade to 3.3, the solution is to wait on something interruptible, like a  or an . The child thread notifies the event right before it quits, and the main thread waits on the event before it joins the child thread. This is definitely hacky. And I can't find anything that guarantees it will make a difference; it just happens to work for me in various builds of CPython 2.7 and 3.2 on OS X and 2.6 and 2.7 on Linux…
abarnert's answer was spot on. I'm still using Python 2.7 however. In order to solve this problem for myself I wrote an InterruptableThread class. Right now it doesn't allow passing additional arguments to the thread target. Join doesn't accept a timeout parameter either. This is just because I don't need to do that. You can add it if you want. You will probably want to remove the output statements if you use this yourself. They are just there as a way of commenting and testing.The class can be used two different ways. You can sub-class InterruptableThread:Or you can use it more like the way threading.thread works. The run method has to take the InterruptableThread object as a parameter though.Do with it what you will.
I faced the same problem here signal not handled when multiple threads join. After reading abarnert's answer, I changed to Python 3 and solved the problem. But I do like to change all my program to python 3. So, I solved my program by avoiding calling thread join() before signal sent. Below is my code.It is not very good, but solved my program in python 2.7. My question was marked as duplicated, so I put my solution here.


Answer URL
https://docs.python.org/3/whatsnew/3.3.html#signal
