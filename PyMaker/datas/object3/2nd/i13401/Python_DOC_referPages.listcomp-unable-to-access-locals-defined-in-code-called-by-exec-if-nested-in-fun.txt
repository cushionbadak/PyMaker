Natural Text
Are there any python gurus out there able to explain why this code doesn't work : Error: while this one works fine: I know it has something to do with locals and globals, as if I pass the exec function the locals and globals from my main scope it works fine, but I don't exactly understand what is going on. Could it be a bug with Cython?EDIT: Tried this with python 3.4.0 and python 3.4.3
The problem is because the list comprehension is closureless in the .When you make a function (in this case a list comprehension) outside of an , the parser builds a tuple with the free variables (the variables used by a code block but not defined by it, ie.  in your case). This tuple is called the function's closure. It is kept in the  member of the function.When in the , the parser won't build a closure on the list comprehension and instead tries by default to look into the  dictionary. This is why adding  at the beginning of the code will work (as well as ).Using the  in its two parameter version will also solve the problem: Python will merge the globals() and locals() dictionary in a single one (as per the documentation). When an assignation is performed, it is done in the globals and locals at the same time. Since Python will check in the globals, this approach will work.Here's another view on the problem:This code produces this bytecode:Notice how it performs a  to load  at the end.Now, if you have this code instead:This will provide exactly the same bytecode, which is problematic: since we're in a function,  won't be declared in the global variable, but in the locals of the function. But Python tries to search it in the global variables (with )!This is what the interpreter does outside of :This code gives us this bytecode:As you can see,  is loaded using , available in the tuple generated in the , that loaded the variable  using . The  statement creates a function, just like  seen earlier, but with a closure.Here's my guess on the reason it is this this way: The closures are created when needed when the module is read the first time. When  is executed, it is not able to realize the functions defined within its executed code needs closure. For him, the code in its string that doesn't begin with an indentation is in the global scope. The only way to know if he was invoked in a way that requires a closure would require  to inspect the current scope (which seems pretty hackish to me).This is indeed an obscure behavior which may be explained but certainly raises some eyebrows when it happens. It is a side-effect well explained in the Python guide, though it is hard to understand why it applies to this particular case.All my analysis was made on Python 3, I have not tried anything on Python 2.
EDIT 2As other commenters have noticed, you appear to have found a bug in Python 3 (doesn't happen for me in 2.7).As discussed in the comments below this answer, the original code:is functionally equivalent to:On my machine, running 3.4 it is functionally equivalent to the extent that it will blow up just the same.  The bug here has to do with running the list comprehension while having two mapping objects.  For example:will also fail with the same exception.To avoid provoking this bug, you have to pass exactly one mapping object (because not passing any is equivalent to passing two), and to insure that it works under all cases, you should never pass a function's  as that mapping object.The rest of this answer was written before I realized behavior was different under 3.  I'm leaving it, because it's still good advice and gives some insights into exec behavior.You should never directly alter a function's  dictionary.  That messes with optimized lookups.  See, e.g. this question and its answersIn particular, as the Python doc explains:The contents of this dictionary should not be modified; changes may not affect the values of local and free variables used by the interpreter.Because you called  from within a function and didn't explicitly pass in , you modified the function's locals, and as the doc explains, that doesn't always work.So the Pythonic way, as others have pointed out, is to explicitly pass mapping objects to exec().Python 2.7When is it OK to modify ?  One answer is when you are building a class -- at that point it is merely another dictionary:[5, 5, 5, 5, 5] 5EDIT -- Python 3 As others point out, there appears to be a bug with the  here, independent of whether you are inside a function.  You can work around this by only passing a single parameter for the globals.  The Python documentation explains that if you only pass a single dict, that will be used for both global and local accesses (it's really the same thing as if your code is not executing in a function or class definition -- there is no ).  So the bug related to  does not appear in this case.The class example above would be:
Ok! Did some looking about, and it looks like your line  is trying to create a new and uninitialized value  rather than using the one you defined earlier. The pythonic fix is to pass in your scope to your  like so:That was a very good question. I learned a lot from answering it.Reference this for more info on : https://docs.python.org/3/library/functions.html#execA shortened version was suggested by @Pynchia and defines the  when calling  within the function.


Answer URL
https://docs.python.org/3/library/functions.html#exec
https://docs.python.org/3/library/functions.html#exec
