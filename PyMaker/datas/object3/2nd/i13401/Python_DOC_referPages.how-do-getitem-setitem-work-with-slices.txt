Natural Text
I'm running Python 2.7.10.I need to intercept changes in a list. By "change" I mean anything that modifies the list in the shallow sense (the list is not changed if it consists of the same objects in the same order, regardless of the state of those objects; otherwise, it is). I don't need to find out how the list has changed, only that it has. So I just make sure I can detect that, and let the base method do its work. This is my test program:Cases #1, #2, #3, and #5 work as I expected; #4, #6, and #7 don't. The program prints:I'm not terribly surprised by #7:  is probably implemented in an ad-hoc way. But for #4 and #6 I am confused. The  documentation says: "Called to implement evaluation of self[key]. For sequence types, the accepted keys should be integers and slice objects." (my emphasys). And for : " Same note as for ()", which I take to mean that  can also be a slice.What's wrong with my reasoning? I'm prepared, if necessary, to override every list-modifying method (append, extend, insert, pop, etc.), but what should override to catch something like #6?I am aware of the existence of , etc. But those methods are deprecated since 2.0 ...Hmmm. I read again the docs for , , etc., and I find this bone-chilling statement:"(However, built-in types in CPython currently still implement . Therefore, you have to override it in derived classes when implementing slicing.)"Is this the explanation? Is this saying "Well, the methods are deprecated, but in order to achieve the same functionality in 2.7.10 as you had in 2.0 you still have to override them"? Alas, then why did you deprecate them? How will things work in the future? Is there a "list" class - that I am not aware of - that I could extend and would not present this inconvenience?  What do I really need to override to make sure I catch every list-modifying operation?
Your problem is that you are subclassing a builtin, and so have to deal with a few wrinkles.  Before I delve into the issue, I'll go straight to the "better" answer:How will things work in the future? Is there a "list" class - that I am not aware of - that I could extend and would not present this inconvenience? Yes, the modern way to do this is to use python's Abstract Base Classes.  You can avoid these ugly complications you are seeing when subclassing builtin , by using the ABCs instead.  For something list-like, try subclassing :Now you should only need to deal with  and friends for slicing behaviour.  If you want to push ahead with subclassing the builtin , read on...Your guess is correct, you will need to override  and .  The language reference explains why and you already saw that:However, built-in types in CPython currently still implement . Therefore, you have to override it in derived classes when implementing slicing.Note that  will hook into , whereas the otherwise equivalent  will hook into .  So you have to handle slices in both... groan!


Answer URL
https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableSequence
