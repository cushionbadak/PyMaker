Natural Text
I'm trying to write a Python  which, in addition to printing out the stack trace for the code as you wrote it, also prints out the  for each evaluated value.For example, if I ran the following code:Instead of just printing out:It would also print out  so I can immediately see which value was invalid and know the right area of the code to look in (obviously this is a very simple example).I know that the CPU needs to store these intermediate values in some temporary registers... I suspect that internally Python has to do something similar and I'm hoping that there's some way I can access those temporary values, possibly through the  module or something similar.
By the time that  is called, you can't get those intermediary values any more, as they are already gone. Yes, the intermediary results of component expressions are stored somewhere by Python. You can't access that 'somewhere' directly at the time, nor are those kept around at all when an exception occurs.In CPython, the standard Python implementation, that 'somewhere' is the stack attached to the current frame of execution (each active function has one). Python code is compiled to bytecode, and an evaluation loop then executes that bytecode, and individual bytecode instructions in bytecode operate on that stack.You can use the  function to see what bytecode is used for your example expression:then look up what those bytecode instructions do: finds the object named  and puts that on the top of the stack (TOS). removes 0 elements from the stack to be the arguments for a call, then takes the next object from the stack to be the callable object, calls that object with the arguments, and puts the result as the new TOS. takes the top two elements from the stack, adds them up, and puts the result back on TOS.So together,  and  execute a call to a named object, and the top of the stack ends up referencing both results, the  result on top of the  result. The  instruction then replaces those two results on the stack with the result of adding them together.You don't have access to that stack from within Python, because it is the very act of executing Python bytecode that makes Python work in the first place. Any code that could access the stack would have to deal with the fact that stack is currently being used to execute that Python code!But you have a bigger problem. If you look at the CPython source code, you can search for instruction names in the evaluation loop in . When you look at the  instruction implementation, you can see that the two input values are removed from the stack before adding them together:If  fails with an exception,  is true and  is executed to wind down the call stack and propagate the exception along to the first  block or, failing that, eventually calling the  function. At that point, the intermediary results are gone from the stack. The local  and  pointers in the above block are also long, long gone (C uses block scope, and when  is executed the scope is exited so the variables are lost).
Use a pythonic  block:For @LukasGraf, a reading list on "proper Python coding practices":Python Exception Handling TechniquesRobust exception handlingWrite Cleaner Python: Use ExceptionsGoogle Python Style GuidePEP 0008 -- Style Guide for Python Code: Programming RecommendationsCode Like a Pythonista: Idiomatic Python -- EAFP vs. LBYL


Answer URL
https://docs.python.org/3/library/dis.html#python-bytecode-instructions
https://docs.python.org/3/library/dis.html#dis.dis
https://docs.python.org/3/library/dis.html#opcode-LOAD_NAME
https://docs.python.org/3/library/dis.html#opcode-CALL_FUNCTION
https://docs.python.org/3/library/dis.html#opcode-BINARY_ADD
