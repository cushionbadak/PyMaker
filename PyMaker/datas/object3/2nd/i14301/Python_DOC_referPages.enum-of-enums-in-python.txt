Natural Text
Is it possible to have an enum of enums in Python? For example, I'd like to have And for me to be able to refer to  as , or to refer to  as .Is this possible? If so, how?EDIT: When implemented in the naive way:It gives:
You can't do this with the  stdlib module. If you try it:… you'll just get an exception like:This is because the enumeration values of  act like instances of , not like instances of their value type. Just like a normal enum holding  values doesn't have  methods on the values, the  won't have  methods. Compare:You can, of course, access the underlying value (the , or the  class) explicitly:… but I doubt that's what you want here.So, could you use the same trick that  uses, of subclassing both  and  so that its enumeration values are  values, as described in the Others section of the docs?No, because what type would you subclass? Not ; that's already your type. You can't use  (the type of arbitrary classes). There's nothing that works.So, you'd have to use a different Enum implementation with a different design to make this work. Fortunately, there are about 69105 different ones on PyPI and ActiveState to choose from.For example, when I was looking at building something similar to Swift enumerations (which are closer to ML ADTs than Python/Java/etc. enumerations), someone recommended I look at . I forgot to do so, but now I just did, and:This gives you:It might be nice if it looked at its  instead of its  for creating the str/repr values, but otherwise it looks like it does everything you want. And it has some other cool features (not exactly what I was looking for, but interesting…).
Note  The below is interesting, and may be useful, but as @abarnert noted the resulting  Enum doesn't have  members -- i.e.  returns an empty list.Without commenting on whether an Enum of Enums is a good idea (I haven't yet decided ;) , this can be done... and with only a small amount of magic.You can either use the  class from this answer:Or you can use the new aenum library and its built-in  desriptor decorator (which is what I will show).At any rate, by wrapping the subEnum classes in a descriptor they are sheltered from becoming members themselves.Your example then looks like:and you can then access them as:which gives you:The difference between using  and  is esoteric:  in 's   will return a  object (if  was used) or  if  was used; normal access will always return .In Python 3.5+ you can even (un)pickle the nested Enums:Do note that the subEnum doesn't include the parent Enum in it's display; if that's important I would suggest enhancing  to recognize the  descriptor and modify its contained class'  -- but I'll leave that as an exercise for the reader.  ;)
You can use namedtuples to do something like this:This is not a enum but, maybe solves your problem
I made an enum of enum implementing  de __ getattr __ in the base enum like thisIn my case I have an enum of enum of enumAnd works
Solution based on attrs. This also allows to implement attributes validators and other goodies of attrs:


Answer URL
https://docs.python.org/3/library/enum.html#others
