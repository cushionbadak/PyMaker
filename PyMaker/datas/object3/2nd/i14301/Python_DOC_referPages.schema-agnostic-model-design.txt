Natural Text
It is time for a question on good design and performance.Say I have three django models:I want to make sure that a view has a nice way to access all the students that a teacher has.  To do this, it might make sense to have a method defined on the Teacher modelNow, there are a few ways to do this.  One of my priorities is to keep each model relatively agnostic to overall database schema.  As a result, I don't really like the following solution:This solution relies on students being related to teachers via a classroom; if I change this structure (maybe students will need to be related to teachers directly, rather than through a classroom), I have to now change the get_students method.  If I have a bunch of models and they relate to each other through these nested relationships, changing the schema means hunting down all such filter queries.  In my particular case, I have a number of models that exist in different applications and my project is getting quite big, so taking this approach means all inviting all sorts of opportunities for me to miss something and create a bug.  Even if my tests are good, I will have to spend a lot of time looking for queries.  A solution that seems more elegant to me is to have a Student manager that defines a for_teacher method:Now, my get_students method can look like this:With this approach, I've abstracted things so that a Teacher doesn't know how it is related to Student (namely, through Classroom).  All it knows is it is related to students somehow.  Of course, if I change the schema, I will have to change the StudentManager.  However, if I again imagine a project with many models related to other models through  different models, this method offers a way to concentrate all the schema-dependent calls in one place (the managers).  This saves me from having to hunt down queries in all sorts of models (and views, perhaps).  The question is, is this a sane approach?  If not, what is a preferred way to handle this?A corollary:As mentioned above, my project has a bunch of models in a bunch of apps and they need to know about each other somehow.  So now we have an added issue: if Teacher contains a get_students method and Student has a get_teacher method, I now run into cyclic module dependencies. A potential solution to this new problem is this version of get_students (get_teacher):I come from a world where imports are put at the top of a program, so this seems a little strange to me.  Is this a reasonable approach?  Are there performance considerations when doing dynamic imports like this?  Will Python cache the Student import in the get_students method so it only happens once?Thanks in advance!
Certainly it seems like a fine idea to centralize your schema-dependent operations in one place. However, I don't see any advantage to doing that in  instead of  as you propose.this method offers a way to concentrate all the schema-dependent calls in one place (the managers)But the managers aren't in one place, there will be one for each relevant model, and they are usually put in the exact same place - . In your example there's certainly no advantage, since in both cases you would have to change one method if the schema changed.  Don't get me wrong,  are great, and  might make more sense than  based on your needs and access patterns. But I don't see an advantage from an encapsulation point of view.As for imports, it's common and accepted to import a module inside a function if that's necessary to avoid a circular import, even though it's less Pythonic. PEP 8 advises against it, but doesn't say why. The most often cited reason (in my experience) is that it makes it harder to track the module's dependencies when the imports are spread around the file. Performance is not an important consideration here since Python will indeed cache the imported module.It's probably also true that circular imports are often a sign that something more serious is going wrong. However, in Django it's not uncommon and not troublesome in and of itself.


Answer URL
https://docs.python.org/3/reference/import.html#the-module-cache
