Natural Text
This question already has an answer here:Why does id({}) == id({}) and id([]) == id([]) in CPython?                    4 answers                Here is the simple Python code: What's the difference between Case 1 and Case 2 -- why am I getting result as False in first case and True in other? Why are the s equal in the Case 2? Also does  call  internally? If so the return object/results of two calls should it be the same.Output
It's just a coincidence that you're ever getting . (Well, not a coincidence, since the implementation of CPython makes it very likely… but it's not something the language requires.)In case 1, you have two different s in  and . They're both alive at the same time, so they can't have the same .In case 2, you again have two different s—but this time, you aren't storing them anywhere; as soon as you call  on one, you release it, which means it can get garbage collected* before you get the other one,** which means it can end up reusing the same .***Notice that the docs for  say:This is an integer which is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same  value.If you actually want to test whether two expressions refer to the same object, use , don't compare their s.Your edited question also asks:Also does dir(object) calls object._dir__() internally? According to :If the object has a method named , this method will be called and must return the list of attributes.And the data model section on  says:Called when  is called on the object. A sequence must be returned.  converts the returned sequence to a list and sorts it.Then you say:If so the return object of two calls should be the same.Well, it depends on what you mean by "the same". It should return an equal value (since nothing has changed), but it's not going to be the identical value, which is what you're trying to test for. (If it isn't obvious why  gives you a new list each time, it should still be clear that it must do so from the fact that " converts the returned sequence to a list and sorts it"…)* Because CPython uses reference counting as its primary garbage collection mechanism, "can be collected" generally means "will be collected immediately". This isn't true for most other Python implementations.** If the order in which parts of your expression get evaluated isn't clear to you from reading the docs, you can try  to see the actual bytecodes in order.*** In CPython, the  is just the address of the  struct that represents the object; if one  gets freed and another one of the same type gets allocated immediately after, it will usually get the same address.


Answer URL
https://docs.python.org/3/library/functions.html#id
https://docs.python.org/3/library/functions.html#dir
https://docs.python.org/3/reference/datamodel.html#object.__dir__
