Natural Text
I have a variable, , and I want to know whether it is pointing to a function or not.I had hoped I could do something like:But that gives me:The reason I picked that is because
If this is for Python 2.x or for Python 3.2+, you can also use . It used to be deprecated, but is now undeprecated, so you can use it again. You can read the discussion here: http://bugs.python.org/issue10518. You can do this with:If this is for Python 3.x but before 3.2, check if the object has a  attribute. You can do this with:The oft-suggested  approach is not correct because it fails to cover many cases that you would presumably want it to pass, like with builtins:The proper way to check properties of duck-typed objects is to ask them if they quack, not to see if they fit in a duck-sized container. Don't use  unless you have a very specific idea of what a function is.
Builtin types that don't have constructors in the built-in namespace (e.g. functions, generators, methods) are in the  module. You can use  in an isinstance call.
Since Python 2.1 you can import  from the  module.
The accepted answer was at the time it was offered thought to be correct. As itturns out, there is no substitute for , which is back in Python3.2: Specifically,  checks the  field of the object beingtested. There is no plain Python equivalent.  Most of the suggested tests arecorrect most of the time:We can throw a monkey-wrench into this by removing the  from theclass. And just to keep things extra exciting, add a fake  to the instance!Notice this really isn't callable: returns the correct result:But  is wrong: does have that attribute after all; it's just not used when callingthe instance.Even more subtle,  also gets this wrong:Because we used this check earlier and later deleted the method, caches the result. Arguably this is a bug in . That said,there's really no possible way it could produce a more accurate result thanthe result than by using  itself, since the slot method is not accessible in any other way.Just use 
The following should return a boolean:
Python's 2to3 tool (http://docs.python.org/dev/library/2to3.html) suggests:It seems this was chosen instead of the  method because of http://bugs.python.org/issue7006.
 will return true if the object passed can be called in Python, but the function does not exist in Python 3.0, and properly speaking will not distinguish between:You'll get  and  as output. works perfectly well to determine if something is a function (try ); if you're really interested in knowing if something can be called, you can either use  or just try it.This, of course, won't tell you whether it's callable but throws a  when it executes, or isn't callable in the first place.  That may not matter to you.
If you want to detect everything that syntactically looks like a function: a function, method, built-in fun/meth, lambda ... but exclude callable objects (objects with  method defined), then try this one:I compared this with the code of  checks in  module and the expression above is much more complete, especially if your goal is filtering out any functions or detecting regular properties of an object.
Try using .
A function is just a class with a  method, so you can doFor example:That is the "best" way of doing it, but depending on why you need to know if it's callable or note, you could just put it in a try/execpt block:It's arguable if try/except is more Python'y than doing .. I would say  is more accurate, since you wont accidently catch the wrong TypeError, for example:
Here's a couple of other ways:Here's how I came up with the second:
Note that Python classes are also callable.To get functions (and by functions we mean standard functions and lambdas) use:
If you have learned , you must be familiar with  or , means any object that can .In C++,   is a function object, and so is a function pointer; more generally, so is an object of a class that defines . In C++11 and greater,  is the  too.Similarity, in Python, those  are all .  can be callable,  can be callable, a  can be callable, the instances of  can be callable. Ok, go back to question : If you want to judge weather the object acts like a function, then the  method suggested by  is ok.If you want to ( not a callable class instance, or a lambda expression), then the  suggested by  is a better choice.Then I do an experiment using those code:Define a class and an ordinary function.Define the functors:Define the functors' list and the types' list:Judge wether the functor is callable. As you can see, they all are callable.Judge the functor's type( types.XXX). Then the types of functors are not all the same.I draw a table of callable functor's types using the data.Then you can choose the functors' types that suitable.such as:
Since classes also have  method, I recommend another solution:
As the accepted answer, John Feminella stated that:The proper way to check properties of duck-typed objects is to ask them if they quack, not to see if they fit in a duck-sized container. The "compare it directly" approach will give the wrong answer for many functions, like builtins.Even though,  there're two libs to distinguish functions strictly, I draw an exhaustive comparable table:8.9. types — Dynamic type creation and names for built-in types — Python 3.7.0 documentation30.13. inspect — Inspect live objects — Python 3.7.0 documentationThe "duck typing" is a preferred solution for general purpose:As for the builtins functionWhen go one more step to check if builtin function or user-defined funtionDetermine if SummaryEmploy  to duck type checking a function,Use  if you have further specified demand.
Instead of checking for  (which is not exclusive to functions), you can check whether a user-defined function has attributes , , etc. This does not work for methods. Another way of checking is using the  method from the  module.To check if an object is a method, use 
Whatever function is a class so you can take the name of the class of instance x and compare:
The solutions using  and  mentioned in some of the answers have a main drawback: both also return  for classes and instances of classes with a  method. Eg.One proper way of checking if an object is a user-defined function (and nothing but a that) is to use :If you need to check for other types, have a look at inspect — Inspect live objects.
In Python3 I came up with  which yields  if  is a function and  if it is not. But I think I prefer , which feels less ad hoc. I wanted to do , but that doesn't work. 
Following previous replies, I came up with this:
If the code will go on to perform the call if the value is callable, just perform the call and catch .
The following is a "repr way" to check it. Also it works with lambda.


Answer URL
https://docs.python.org/3/library/inspect.html
