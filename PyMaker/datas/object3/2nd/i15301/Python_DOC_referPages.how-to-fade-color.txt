Natural Text
I would like to fade the color of a pixel out toward white, but obviously maintain the same color. If I have a pixel , will adding 10 to each value to make  make it the same color, just lighter, or will it change the color entirely? For example, I know that  going to  is a greyscale fade. I would like the same with RGB values and I would like to do it numerically, as indicated. Is there an equation to do so?
There are a bunch of ways to do this. How you choose to do it will depend on whether you value speed and simplicity or perceptual uniformity. If you need it to be truly uniform you will need to define you RGB colors with a color profile and you'll need the primaries of the profile so you can convert to XYZ and then to LAB where you can manipulate the L channel.Most of the time you don't need to do that and you can instead use a simple HSB model like Photoshop does in the info palette. To do this you simply imagine a line between your RGB point and the white point in 3D space and move your color along that line. In practical terms you can just create a parametric equation for that line and move the parameter.A percentage of 0.0 will return the same color and 1.0 will return white. Everything between will be a lighter shade of the same hue. This should give you results that agree with Photoshop's HSB implementation, but will be device dependent and may not be perfectly uniform. If you have  and put in a percentage of .50 it should return  Photoshop reports both as a hue of 20ยบ.It is not hard to do this without numpy, but the element wise operations are convenient. Edit based on comment:I'm not suggesting you do this unless you know you really need to do it the hard way. But if you want to convert to LAB you can without too much trouble. The most important thing is that you need to know what color space your RGB numbers are in to begin with or you need to make some assumptions about their meaning. Since sRGB is pretty standard on the web, I'll assume that here.The conversions aren't that difficult, but it's easy to make mistakes. Happily, there's a pretty nice colormath module with good documentation: https://github.com/gtaylor/python-colormathUsing that you can convert between sRGB and LAB  like this:lab now is a color with a Luminance channel  which you can move up or down between black(0) and white(100). This should be more perceptually uniform than HSB (but, depending on your application, maybe not enough to warrant the work).You can simply change  and then convert back: is now . colormath took care of the illuminant and gamma issues for you. 
Simply linearly interpolate between your color and white:Or without numpy:
I prefer to use HSV color mode.To grayer your color you have to decrease Saturation factor.Standard colorsys module can help in RGB <-> HSV conversions, but please keep in mind:  operates with channel values in range [0, 1), not [0, 256).There is full code example:
It's not that simple because in your monitor each color channel is weighted differently.  I'd say the best bet is to do this in scikit image by converting to gray, dimming or brightening, and then back-converting to color.  Scikit-image will take care of keeping the colors straight.If you want to work directly with hue, saturation and value, check out this example:http://scikit-image.org/docs/dev/auto_examples/plot_tinting_grayscale_images.html
As MarkM suggested, HSB (or HSL) is a simple method for doing this, but will not give perfect hue constance. If this is good enough (I assume you want your own method instead of a module) then this page has code for doing it.In python it would look like this:Then to brighten:The benefit of this method is that the increment is a percentage of the total brightness. Modifying this to take the percentage as an input would be trivial.You can reverse engineer the mathematical equations form this code, or see HSL to RGB.
The question, "to fade the color of a pixel out toward white" (not some shade of gray), is really about mixing the original pixel color with white, going from 100% original color and 0% white to 0% original color and 100% white. There's not more to it. Doing this in, for example, 101 steps would look like this:
You might want to check out this answer by denis:RGB -> ^gamma -> Y -> L*In color science, the common RGB values, as in html rgb( 10%, 20%, 30%  ), are called "nonlinear" or Gamma  corrected. "Linear"  values are defined aswhere gamma is 2.2 for many PCs. The usual R G B are sometimes written  as R' G' B' (R' = Rlin ^ (1/gamma)) (purists tongue-click) but here  I'll drop the '.Brightness on a CRT display is proportional to RGBlin = RGB ^ gamma,  so 50% gray on a CRT is quite dark: .5 ^ 2.2 = 22% of maximum  brightness. (LCD displays are more complex; furthermore, some graphics  cards compensate for gamma.)To get the measure of lightness called  from RGB, first divide R G  B by 255, and computeThis is  in XYZ color space; it is a measure of color "luminance".  (The real formulas are not exactly x^gamma, but close; stick with  x^gamma for a first pass.)Finally,      L* = 116 * Y ^ 1/3 - 16 "... aspires to perceptual uniformity ... closely matches human perception of lightness." -- Wikipedia Lab  color space


Answer URL
https://docs.python.org/3/library/colorsys.html
