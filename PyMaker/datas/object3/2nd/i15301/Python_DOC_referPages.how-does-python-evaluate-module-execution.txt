Natural Text
I have two files in the same directory one that contains the contents of my program  and the other that has test cases .In  I execute the following commands to run the test cases:Then at the end of  while I'm developing i have the following commnands:Everything works just fine(for now) and this setup is great for iterative development. My question is how does python evaluate  when I run it, given that  depends on  and vice versa?I have a rough idea, but was wondering what the "official" answer is.Thanks,-M
In terms of whether you should do it, as Alex says, avoid it at all costs.  Cyclical imports are a state of sin.With that aside, it's interesting to look at what's happening (roughly - it looks like the module import mechanism is an area that gets tweaked from version to version in Python.  My main source for this was the Python 3.4.2 docs on the importing system)When the line within :gets executed, the system first checks if the module is already loaded.  Loaded modules live in a dictionary called .If the module being imported is in  already, any reference to  in  just points to that namespace.  (Note that in the case of cyclical imports, the module might already be added to , but the populating of the namespace may not be fully over.  Execution of that module might be paused for the moment at the line that says )If the module is not there, then the system creates a new namespace, adds it to , looks for the code that is associated with the  module (in this case, living in ) and begins to execute it, putting all the variables in the newly created namespace.So you'd think  gets run once, and  gets run once and already notices that  is a loaded module, so the importing ends there.  Except...When a module is run as the original script, it gets registered as  in , instead of its actual name.  So  is going to be called the  module, and as a result, when  tries running , it can't find  under .   will be loaded twice, once as  and again as .  Cyclical imports are frowned upon, but cyclical imports of the  module is downright condemned because of this issue of creating two identical(ish) namespaces and the potential weird errors that can result.There are two more complications in your code.1) Because you're doing an , instead of putting all the variables created from  in its own namespace, it gets thrown into the  namespace.2) Because you're only importing from  if the module is the main script being executed, the Python interpreter will not touch that line when  gets imported from .  So your code isn't really looping conceptually.   as  imports  which imports  and stops there.  Simple!...so let's not do circular imports.Some reference material:Official Python 3.4.2 docs on the import system2008 comp.lang.python discussion on cyclical imports
It's always soundest to avoid circular dependencies like the one you've created here.  However you luck out because the  comes at the very end of , i.e, after the latter has defined all it does define, so it can be imported in a good state by the circularly-dependent .However, while this happens to work in current Python version,s it's not guaranteed by the language spec.  For solidity, break the circular dependency, e.g as follows:move all the "substantial" contents of  before the  check to e.g in , just do in , instead of , use This way, your dependency graph becomes acyclical, and as a consequence your code will work as intended in any correct version of Python, including hypothetical future ones:-).


Answer URL
https://docs.python.org/3/reference/import.html#references
https://docs.python.org/3/reference/import.html
