Natural Text
Suppose I have a class with Now I am going to change  of .  was created after  of  had changed, so Python, in principle, could allocate memory for . Why it didn't?How to properly modify  of a class, so that new instances have the modified attributes?
You cannot dynamically alter the  attribute after creating the class, no. That's because the value is used to create special descriptors for each slot. From the  documentation: are implemented at the class level by creating descriptors (Implementing Descriptors) for each variable name. As a result, class attributes cannot be used to set default values for instance variables defined by ; otherwise, the class attribute would overwrite the descriptor assignment.You can see the descriptors in the class :You cannot yourself create these additional descriptors. Even if you could, you cannot allocate more memory space for the extra slot references on the instances produced for this class, as that's information stored in the C struct for the class, and not in a manner accessible to Python code.That's all because  is only an extension of the low-level handling of the elements that make up Python instances to Python code; the  and  attributes on regular Python instances were always implemented as slots:All the Python developers did here was extend the system to add a few more of such slots using arbitrary names, with those names taken from the  attribute on the class being created, so that you can save memory; dictionaries take more memory than simple references to values in slots do. By specifying  you disable the  and  slots, unless you explicitly include those in the  sequence.The only way to extend slots then is to subclass; you can dynamically create a subclass with the  function or by using a factory function:
It appears to me a type turns  into a tuple as one of it's first orders of action.  It then stores the tuple on the extended type object.  Since beneath it all, the python is looking at a , there is no way to mutate it.  Indeed, I'm not even sure you can access it unless you pass a tuple in to the instance in the first place.The fact that the original object that you set still remains as an attribute on the type is (perhaps) just a convenience for introspection.You can't modify  and expect to have that show up somewhere (and really -- from a readability perspective, You probably don't really want to do that anyway, right?)...Of course, you can always subclass to extend the slots:
You cannot modify the  attribute after class creation. This is because it would leade to strange behaviour.Imagine the following.What should happen in this scenario? No space was originally allocated for a second slot, but according to the slots attribute,  should be able have space for . is not about protecting what names can and cannot be accessed. Rather  is about reducing the memory footprint of an object. By attempting to modify  you would defeat the optimisations that  is meant to achieve.How __slots__ reduces memory footprintNormally, an object's attributes are stored in a , which requires a fair bit of memory itself. If you are creating millions of objects then the space required by these dicts becomes prohibitive.  informs the python machinery that makes the class object that there will only be so many attributes refered to by instances of this class and what the names of the attributes will be. Therefore, the class can make an optimisation by storing the attributes directly on the instance rather than in a . It places the memory for the (pointers to the) attributes directly on the object, rather than creating a new  for the object.


Answer URL
https://docs.python.org/3/reference/datamodel.html#descriptors
https://docs.python.org/3/reference/datamodel.html#notes-on-using-slots
