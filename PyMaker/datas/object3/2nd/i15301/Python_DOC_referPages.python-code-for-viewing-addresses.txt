Natural Text
When you call the  method in Python you get something like this back: Is there any way to get a hold of the memory address if you overload , other then calling  and regexing it out? 
The Python manual has this to say about :Return the "identity'' of an object.  This is an integer (or long integer)  which is guaranteed to be unique and  constant for this object during its  lifetime. Two objects with  non-overlapping lifetimes may have the  same id() value. (Implementation note:  this is the address of the object.)So in CPython, this will be the address of the object. No such guarantee for any other Python interpreter, though.Note that if you're writing a C extension, you have full access to the internals of the Python interpreter, including access to the addresses of objects directly.
You could reimplement the default repr this way:
Just use 
There are a few issues here that aren't covered by any of the other answers.First,  only returns:the “identity” of an object. This is an integer (or long integer) which is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same  value.In CPython, this happens to be the pointer to the  that represents the object in the interpreter, which is the same thing that  displays. But this is just an implementation detail of CPython, not something that's true of Python in general. Jython doesn't deal in pointers, it deals in Java references (which the JVM of course probably represents as pointers, but you can't see those—and wouldn't want to, because the GC is allowed to move them around). PyPy lets different types have different kinds of , but the most general is just an index into a table of objects you've called  on, which is obviously not going to be a pointer. I'm not sure about IronPython, but I'd suspect it's more like Jython than like CPython in this regard. So, in most Python implementations, there's no way to get whatever showed up in that , and no use if you did.But what if you only care about CPython? That's a pretty common case, after all.Well, first, you may notice that  is an integer;* if you want that  string instead of the number , you're going to have to format it yourself. Under the covers, I believe  is ultimately using 's  format, which you don't have from Python… but you can always do this:* In 3.x, it's an . In 2.x, it's an  if that's big enough to hold a pointer—which is may not be because of signed number issues on some platforms—and a  otherwise.Is there anything you can do with these pointers besides print them out? Sure (again, assuming you only care about CPython).All of the C API functions take a pointer to a  or a related type. For those related types, you can just call  to make sure it really is a  object, then cast with . So, if you're writing a C extension, the  is exactly what you need.What if you're writing pure Python code? You can call the exact same functions with  from .Finally, a few of the other answers have brought up . That isn't relevant here. This only works for  objects like  (and maybe a few memory-buffer-like objects, like those provided by ). And, even there, it isn't giving you the address of the  value, it's giving you the address of the C-level  that the  wraps up.That being said, more often than not, if you really think you need the address of something, you didn't want a native Python object in the first place, you wanted a  object.
Just in response to Torsten, I wasn't able to call  on a regular python object. Furthermore, . This is in CPython, don't know about anything else.
With ctypes, you can achieve the same thing withDocumentation:  Return the address of the C instance internal bufferNote that in CPython, currently , but  should return the real address for each Python implementation, ifctypes is supportedmemory pointers are a valid notion.Edit: added information about interpreter-independence of ctypes
You can get something suitable for that purpose with:
While it's true that  gets the object's address in the default CPython implementation, this is generally useless... you can't do anything with the address from pure Python code.The only time you would actually be able to use the address is from a C extension library... in which case it is trivial to get the object's address since Python objects are always passed around as C pointers.


Answer URL
https://docs.python.org/3/library/functions.html#id
https://docs.python.org/3/c-api/object.html
https://docs.python.org/3/c-api/index.html
https://docs.python.org/3/library/ctypes.html#accessing-values-exported-from-dlls
https://docs.python.org/3/library/ctypes.html#ctypes.addressof
