Natural Text
I have a bunch of strings that are of the form:In all likelihood they have three or more multi-letter substrings separated by 's. There might be ill formed strings with less than two 's, and I want the original string in that case.The first thing that comes to mind is the str.partition method, which I would use if I were after everything after the first :returns This could be repeated:But is this efficient? It doesn't seem efficient to call a method twice and use a subscript twice. It is certainly inelegant. Is there a better way? The main question is:How do you drop everything from the beginning up to the second instance of the  character, so that  becomes ? What would be the best/most efficient way to do that?
Using  with  argument:UPDATETo handle string with less than two s:
Summary: This is the most performant approach (generalized to n characters):but I show other approaches for comparison.There are various ways of doing this with string methods and regular expressions. I'll ensure you can follow along with an interpreter by being able to cut and paste everything in order.First imports:Different approaches: string methodsThe way mentioned in the question is to partition twice, but I discounted it because it seems rather inelegant and unnecessarily repetitive:The second way that came to mind to do this is to split on the 's, slice from the second on, and join with 's. This struck me as fairly elegant and I assumed it would be rather efficient.But slices create an unnecessary extra list. However,  from the itertools module provides an iterable that doesn't! So I expected this to do even better:Different approaches: regular expressionsNow regular expressions. First way that came to mind with regular expressions was to find and substitute with an empty string up to the second .But it occurred to me that it might be better to use a non-capturing group, and return a match on the end:Finally, I could use a regular expression search to find the end of the second  and then use that index to slice the string, which would use a lot more code, but might still be fast and memory efficient.update Falsetru suggests 's maxsplit argument, which had completely slipped my mind. My thoughts are that it may be the most straightforward approach, but the assignment and extra checking might hurt it.And JonClements suggests using an except referencing https://stackoverflow.com/a/27989577/541136 which would look like this:which would be totally appropriate since not having enough s would be exceptional.TestingNow let's test our functions. First, let's assert that they actually work (not a best practice in production code, which should use unittests, but useful for fast validation on StackOverflow):The asserts don't raise s, so now let's time them to see how they perform:PerformanceResultsUpdate Best performer is falsetru's , which slightly edges out the secondpartition function. Congratulations to falsetru. It makes sense since it is a very direct approach. And JonClements's modification is even better...Older run and analysis without falsetru's maxsplittwo and JonClements' maxsplittwoexcept:It turns out that the most performant approach is to partition twice, even though my intuition didn't like it.Also, it turns out my intuition on using islice was wrong in this case, it is much less performant, and so the extra list from the regular slice is probably worth the tradeoff if faced with a similar bit of code.Of the regular expressions, the match approach for my desired string is the best performer here, nearly tied with .


Answer URL
https://docs.python.org/3/library/stdtypes.html#str.split
