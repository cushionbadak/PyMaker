Natural Text
In Python, long integers have unlimited precision. I would like to write a 16 byte (128 bit) integer to a file.  from the standard library supports only up to 8 byte integers.  has the same limitation. Is there a way to do this without masking and shifting each integer?Some clarification here: I'm writing to a file that's going to be read in from non-Python programs, so pickle is out. All 128 bits are used.
Two possible solutions:Just pickle your long integer.  This will write the integer in a special format which allows it to be read again, if this is all you want.Use the second code snippet in this answer to convert the long int to a big endian string (which can be easily changed to little endian if you prefer), and write this string to your file.The problem is that the internal representation of bigints does not directly include the binary data you ask for.
I think for unsigned integers (and ignoring endianness) something likemight technically satisfy the requirements of having non-Python-specific output, not using an explicit mask, and (I assume) not using any non-standard modules.  Not particularly elegant, though.
The PyPi bitarray module in combination with the builtin  function seems like a good combination for a solution that is simple and flexible.The endianness can be controlled with a few more lines of code. You'll have to evaluate the efficiency.
Why not use struct with the unsigned long long type twice?That's documented here (scroll down to get the table with Q): http://docs.python.org/library/struct.html
This may not avoid the "mask and shift each integer" requirement.  I'm not sure that avoiding mask and shift means in the context of Python long values. The bytes are these:You can then pack this list of bytes using 
With Python 3.2 and later, you can use  and : https://docs.python.org/3/library/stdtypes.html#int.to_bytes
You could pickle the object to binary, use protocol buffers (I don't know if they allow you to serialize unlimited precision integers though) or BSON if you do not want to write code.But writing a function that dumps 16 byte integers by shifting it should not be so hard to do if it's not time critical.
This may be a little late, but I don't see why you can't use struct:The bigint by itself is rejected, but if you mask it with &0xFFFFFFFFFFFFFFFF you can reduce it to an 8 byte int instead of 16.  Then the upper part is shifted and masked as well.  You may have to play with byte ordering a bit.  I used the ! mark to tell it to produce a network endian byte order.  Also, the msb and lsb (upper and lower bytes) may need to be reversed.  I will leave that as an exercise for the user to determine.  I would say saving things as network endian would be safer so you always know what the endianess of your data is.No, don't ask me if network endian is big or little endian...


Answer URL
https://docs.python.org/3/library/stdtypes.html#int.to_bytes
