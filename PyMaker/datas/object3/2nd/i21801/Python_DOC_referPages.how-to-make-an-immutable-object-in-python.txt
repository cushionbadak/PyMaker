Natural Text
Although I have never needed this, it just struck me that making an immutable object in Python could be slightly tricky. You can't just override , because then you can't even set attributes in the . Subclassing a tuple is a trick that works:But then you have access to the  and  variables through  and , which is annoying.Is this possible in Pure Python? If not, how would I do it with a C extension?(Answers that work only in Python 3 are acceptable).Update: So subclassing tuple is the way to do it in Pure Python, which works well except for the additional possibility of accessing the data by ,  etc. So, to complete this question all that is missing is howto do it "properly" in C, which I suspect would be quite simple, by just not implementing any  or , etc. But instead of doing it myself, I offer a bounty for that, because I'm lazy. :)
Yet another solution I just thought of:  The simplest way to get the same behaviour as your original code isIt does not solve the problem that attributes can be accessed via  etc., but at least it's considerably shorter and provides the additional advantage of being compatible with  and . creates a type similar to what I described in this answer, i.e. derived from  and using .  It is available in Python 2.6 or above.
The easiest way to do this is using :Instances of  are immutable now, since you can't set any attributes on them.If you want the class instances to contain data, you can combine this with deriving from :Edit: If you want to get rid of indexing either, you can override :Note that you can't use  for the properties in thise case, since this would rely on  instead of .  Fuerthermore this won't prevent the use of , but I can hardly imagine how this should constitute a problem.I don't think the "right" way of creating an immutable object is writing a C extension.  Python usually relies on library implementers and library users being consenting adults, and instead of really enforcing an interface, the interface should be clearly stated in the documentation.  This is why I don't consider the possibility of circumventing an overridden  by calling  a problem.  If someone does this, it's on her own risk.
..howto do it "properly" in C..You could use Cython to create an extension type for Python:It works both Python 2.x and 3.TestsIf you don't mind indexing support then  suggested by @Sven Marnach is preferrable:
Another idea would be to completely disallow  and use  in the constructor:Of course you could use  to modify a  instance , but your original implementation suffers from the same problem (try  on an  instance).You can apply the same trick in your original implementation: get rid of , and use  in your property functions.
You could create a  decorator that either overrides the  and change the  to an empty list, then decorate the  method with it.Edit: As the OP noted, changing the  attribute only prevents the creation of new attributes, not the modification.Edit2: Here's an implementation:Edit3: Using  breaks this code, because if stops the creation of the object's . I'm looking for an alternative.Edit4: Well, that's it. It's a but hackish, but works as an exercise :-)
I don't think it is entirely possible except by using either a tuple or a namedtuple. No matter what, if you override  the user can always bypass it by calling  directly. Any solution that depends on  is guaranteed not to work.The following is about the nearest you can get without using some sort of tuple:but it breaks if you try hard enough:but Sven's use of  is genuinely immutable.UpdateSince the question has been updated to ask how to do it properly in C, here's my answer on how to do it properly in Cython:First :and a  to compile it (using the command :Then to try it out:
In addition to the excellent other answers I like to add a method for python 3.4 (or maybe 3.3). This answer builds upon several previouse answers to this question.In python 3.4, you can use properties without setters to create class members that cannot be modified. (In earlier versions assigning to properties without a setter was possible.)You can use it like this:which will print But calling  will cause:Explaination: properties without setters are a very recent feature of python 3.4 (and I think 3.3). If you try to assign to such a property, an Error will be raised.Using slots I restrict the membervariables to  (which is ).Problem: Assigning to  is still possible (). But if you assign to a private variable, it is your own fault...This answer among others, however, discourages the use of . Using other ways to prevent attribute creation might be preferrable.
Here's an elegant solution:Inherit from this class, initialize your fields in the constructor, and you'e all set.
I've made immutable classes by overriding , and allowing the set if the caller is :This isn't quite enough yet, since it allows anyone's  to change the object, but you get the idea.
If you are interested in objects with behavior, then namedtuple is almost your solution.  As described at the bottom of the namedtuple documentation, you can derive your own class from namedtuple; and then, you can add the behavior you want.For example (code taken directly from the documentation):This will result in:This approach works for both Python 3 and Python 2.7 (tested on IronPython as well).The only downside is that the inheritance tree is a bit weird; but this is not something you usually play with.
I needed this a little while ago and decided to make a Python package for it. The initial version is on PyPI now:To use:Full docs here: https://github.com/theengineear/immutableHope it helps, it wraps a namedtuple as has been discussed, but makes instantiation much simpler.
This way doesn't stop  from working, but I've still found it useful:you may need to override more stuff (like ) depending on the use case.
As of Python 3.7, you can use the  decorator in your class and it will be immutable like a struct! Though, it may or may not add a  method to your class. Quote:hash() is used by built-in hash(), and when objects are added to hashed collections such as dictionaries and sets. Having a hash() implies that instances of the class are immutable. Mutability is a complicated property that depends on the programmerâ€™s intent, the existence and behavior of eq(), and the values of the eq and frozen flags in the dataclass() decorator.By default, dataclass() will not implicitly add a hash() method unless it is safe to do so. Neither will it add or change an existing explicitly defined hash() method. Setting the class attribute hash = None has a specific meaning to Python, as described in the hash() documentation.If hash() is not explicit defined, or if it is set to None, then dataclass() may add an implicit hash() method. Although not recommended, you can force dataclass() to create a hash() method with unsafe_hash=True. This might be the case if your class is logically immutable but can nonetheless be mutated. This is a specialized use case and should be considered carefully.Here the example from the docs linked above:      
Classes which inherit from the following  class are immutable, as are their instances, after their  method finishes executing.  Since it's pure python, as others have pointed out, there's nothing stopping someone from using the mutating special methods from the base  and , but this is enough to stop anyone from mutating a class/instance by accident.It works by hijacking the class-creation process with a metaclass.
The third party  module provides this functionality.Edit: python 3.7 has adopted this idea into the stdlib with . implements frozen classes by overriding  and has a minor performance impact at each instantiation time, according to the documentation.If you're in the habit of using classes as datatypes,  may be especially useful as it takes care of the boilerplate for you (but doesn't do any magic). In particular, it writes nine dunder (__X__) methods for you (unless you turn any of them off), including repr, init, hash and all the comparison functions. also provides a helper for .
You can override setattr and still use init to set the variable. You would use super class setattr. here is the code.
An alternative approach is to create a wrapper which makes an instance immutable.This is useful in situations where only some instances have to be immutable (like default arguments of function calls).Can also be used in immutable factories like:Also protects from , but fallable to other tricks due to Python's dynamic nature.
I used the same idea as Alex: a meta-class and an "init marker", but in combination with over-writing __setattr__:Note: I'm calling the meta-class directly to make it work both for Python 2.x and 3.x.It does work also with slots ...:... and multiple inheritance:Note, however, that mutable attributes stay to be mutable:
One thing that's not really included here is total immutability... not just the parent object, but all the children as well. tuples/frozensets may be immutable for instance, but the objects that it's part of may not be. Here's a small (incomplete) version that does a decent job of enforcing immutability all the way down:
You can just override setAttr in the final statement of init. THen you can construct but not change. Obviously you can still override by usint object.setAttr but in practice most languages have some form of reflection so immutablility is always a leaky abstraction. Immutability is more about preventing clients from accidentally violating the contract of an object. I use:=============================The original solution offered was incorrect, this was updated based on the comments using the solution from hereThe original solution is wrong in an interesting way, so it is included at the bottom.===============================Output :======================================Original Implementation:It was pointed out in the comments, correctly, that this does not in fact work, as it prevents the creation of more than one object as you are overriding the class setattr method, which means a second cannot be created as self.a = will fail on the second initialisation.
The basic solution below addresses the following scenario: can be written accessing the attributes as usual. AFTER that the OBJECT is frozen for attributes changes only:The idea is to override  method and replace its implementation each time the object frozen status is changed.So we need some method () which stores those two implementations and switches between them when requested.This mechanism may be implemented inside the user class or inherited from a special  class as shown below:


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__setattr__
https://docs.python.org/3/reference/datamodel.html#object.__init__
https://docs.python.org/3/library/dataclasses.html
https://docs.python.org/3/reference/datamodel.html#object.__hash__
https://docs.python.org/3/library/dataclasses.html
