Natural Text
As far as I know, Python has 3 ways of finding out what operating system is running on:Knowing this information is often useful in conditional imports, or using functionality that differs between platforms (e.g.  on Windows v.s.  on UNIX).My question is, why 3 different ways of doing this? When should one way be used and not another? Which way is the 'best' (most future-proof or least likely to accidentally exclude a particular system which your program can actually run on)?It seems like  is more specific than , allowing you to distinguish  from  (as opposed to just ), and  from  (as opposed to just ). But if that's so, that what about the difference between  and ?For example, which is better, this:or this? :For now I'll be sticking to , so this question isn't particularly urgent, but I would be very grateful for some clarification regarding this.
Dived a bit into the source code.The output of  and  are determined at compile time.  determines the system type at run time. is specified as a compiler define during the build configuration. checks whether certain os specific modules are available (e.g. , , ...) actually runs  and potentially several other functions to determine the system type at run time.My suggestion, use  to check whether it's a posix-compliant system, use  to check whether it's a linux, cygwin, darwin, atheos, whatever, and use , well, if you don't believe the other sources.
There is a thin line difference between  and  and interestingly for most cases   degenerates to Here is what the Source  saysAlso per the documentationos.uname()Return a 5-tuple containing information identifying the current operating system. The tuple contains 5 strings: (sysname, nodename,  release, version, machine). Some systems truncate the nodename to 8  characters or to the leading component; a better way to get the  hostname is socket.gethostname() or even  socket.gethostbyaddr(socket.gethostname()).
From  docs: has a coarser granularity gives system-dependent version informationThe  module provides detailed checks for the systemâ€™s identityOften the "best" future-proof way to test whether some functionality is available is just to try to use it and use a fallback if it fails.what about the difference between sys.platform and platform.system()? returns a normalized value that it might get from several sources: , ,  command (on Windows).
It depends on whether you prefer raising exception or trying anything on an untested system and whether your code is so high level or so low level that it can or can't work on a similar untested system (e.g. untested Mac - 'posix' or on embedded ARM systems). More pythonic is to not enumerate all known systems but to test possible relevant properties. (e.g. it is considered important the endianess of the system but unimportant multiprocessing properties.)os.name is a sufficient resolution for the correct usage of  module. Possible values are 'posix', 'nt', 'os2', 'ce', 'java' or 'riscos' in Python 2.7, while only the 'posix', 'nt' and 'java' are used since Python 3.4.sys.platform is a finer resolution. It is recommended to use  idiom because "linux2" means a Linux kernel version 2.xx or 3. Older kernels are currently never used. In Python 3.3 are all Linux systems simple 'linux'. I do not know the specifics of "Mac" and "Java" systems and so I can not use the results of very good method platform.system() for branching, but I would use advantages of the  module for messages and error logging.
I believe the platform module is probably preferred for new code. The others existed before it. It is an evolution, and the others remain for backwards compatibility.


Answer URL
https://docs.python.org/3/library/os.html#os.name
https://docs.python.org/3/library/platform.html
https://docs.python.org/3/library/sys.html#platform
