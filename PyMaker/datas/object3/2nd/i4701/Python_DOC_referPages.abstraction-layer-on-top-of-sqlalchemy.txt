Natural Text
I am on a Python 3.6 project that uses Sqlalchemy where we want another layer of abstraction over Sqlalchemy. This will allow us to more easily replace Sqlalchemy with another library if desired.In this example it is the  class:dbhelper.pymain.pyQuestion: Is there a better method than creating the  class for use as a container and having only  in it? I have read that this is not pythonic.Converting all the  functions in  to regular methods will populate the namespace when we do 
Yes, there is a better solution than creating a class full of s: Just don't create the class, and make them all module-level functions:The only real point of a class full of s is to provide a namespace for all those functions to live in. A module already is a namespace for all those functions to live in. And, because it's more directly supported by the language syntax, it means you can more easily go around the namespacing when you want to do so explicitly (e.g., ).You say:Converting all the staticmethod functions in dbhelper.py to regular methods will populate the namespace when we do But the answer to that is obvious: Don't , just . Then, all the code that you would have written with  becomes .If you really want two levels of namespace, you can just use a package with a submodule, rather than a module with a class. But I can't see any good reason you'd need two levels of namespace here.Another alternative (as suggested by juanpa.arrivillaga in the comments) is to turn this into a real class, where each instance (even if there will probably only be one in your real code) has its own  instead of using a module global. That  can either be passed into the , or constructed directly inside the . For example:Notice that we're using normal methods, and accessing a normal instance variable. This is what a class is forâ€”to wrap up some state together with the methods that transform that state.How do you decide between the two? Well, if there's only ever going to be one  per process, they're functionally equivalent, but conceptually they have different connotations. If you think of a DbHelper as a database, both the connection and the database behavior, it should be a class, and you should instantiate an instance of that class and use it that way. If you think of it as just a bunch of helper functions that operate on a dbconn that has its own independent existence, it should be a flat module.In some languages (like Java), there is another point to using a class full of -equivalents: the language either doesn't support "free functions", or makes them a completely different kind of thing from methods. But that isn't true in Python.While we're at it, do you want your module to export  and  as a "public" part of the interface? If not, you should add an  spec to the top of your module, like this:Or, alternatively, name all your "private" module members with underscores:Either way, users of your module can still access the "private" data, but it won't show up in  , , the default autocomplete in many IDEs, etc.


Answer URL
https://docs.python.org/3/tutorial/modules.html
