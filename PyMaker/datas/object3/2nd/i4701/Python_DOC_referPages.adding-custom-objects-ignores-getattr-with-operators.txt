Natural Text
This question already has an answer here:How can I intercept calls to python's “magic” methods in new style classes?                    4 answers                Why does Python's bool builtin only look at the class-level __bool__ method [duplicate]                    1 answer                I am trying to create a custom object that passes all non-existent method calls down to a member attribute. This works under normal custom method invocations, but fails when attempting to call arithmetic operators.Below is a console snippet of an example class, a test function, and a cleaned up disassembly of the test function.I thought that the Python interpreter would look for the  method using the standard procedure of invoking  when the method was not found in the object's method list, before looking for  in the int. This is apparently not what is happening.Can someone help me out by explaining what is going on or helping me find out where in the Python source code I can find what  is doing? I'm not sure if I can fix this, but a workaround would be appreciated.
The methods  and  are only used for recovering attributes when you call then explicitly, by example when you do . They are not used for implicit invocation.This behaviour is specified in the documentationNote: This method may still be bypassed when looking up special methods  as the result of implicit invocation via language syntax or built-in  functions.The reason for such an implementation is explained here.Bypassing the  machinery in this fashion provides  significant scope for speed optimisations within the interpreter, at  the cost of some flexibility in the handling of special methodsIn conclusion what you are trying to do, i.e. using  to redirect implicit special method calls, has been voluntarily sacrificed in favor of speed.InheritanceThe behaviour you are describing can be achieved by class inheritance. Although, passing in arguments to your class constructor will require the following fidling with the  method.MetaclassNow, suppose you really need to catch implicit call to special methods. I see very little case where this could be useful, but it is a fun exercise. In this case we can rely on metaclass to fill in missing methods with the ones from .
After some more intense research (and following some initially unlikely trails) I found my answer. My thought process didn't come up with the same search keywords, which is why I didn't find these before. My question could probably be considered a duplicate of one of the ones linked below.I found the simplest/best explanation for why this happens here. I found some good references for resolving this here and here. The links in Oliver's answer are also helpful.In summary, Python does not use the standard method lookup process for the magic methods such as  and . It looks like the workaround is to make a  class from here.
I don't understand you.Why you can't do something like:


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__getattribute__
https://docs.python.org/3/reference/datamodel.html#special-method-lookup
