Natural Text
Here's the Python code to run an arbitrary command returning its  data, or raise an exception on non-zero exit codes: is used to wait for the process to exit:The  module does not support timeout--ability to kill a process running for more than X number of seconds--therefore,  may take forever to run.What is the simplest way to implement timeouts in a Python program meant to run on Windows and Linux?
In Python 3.3+: is a byte string that contains command's merged stdout, stderr data. This code raises  on non-zero exit status as specified in the question's text unlike  method.I've removed  because it is often used unnecessarily. You can  always add it back if  indeed requires it. If you add  i.e., if the child process spawns its own descendants;  can return much later than the timeout indicates, see Subprocess timeout failure.The timeout feature is available on Python 2.x via the  backport of the 3.2+ subprocess module.
I don't know much about the low level details; but, given that inpython 2.6 the API offers the ability to wait for threads andterminate processes, what about running the process in a separatethread?The output of this snippet in my machine is:where it can be seen that, in the first execution, the processfinished correctly (return code 0), while the in the second one theprocess was terminated (return code -15).I haven't tested in windows; but, aside from updating the examplecommand, I think it should work since I haven't found in thedocumentation anything that says that thread.join or process.terminateis not supported.
jcollado's answer can be simplified using the threading.Timer class:
If you're on Unix,
Here is Alex Martelli's solution as a module with proper process killing. The other approaches do not work because they do not use proc.communicate(). So if you have a process that produces lots of output, it will fill its output buffer and then block until you read something from it.
I've modified sussudio answer. Now function returns: (, , , ) -  and  is decoded to utf-8 string
surprised nobody mentioned using This won't for work for every use case obviously, but if your dealing with a simple script, this is hard to beat.Also available as gtimeout in coreutils via  for mac users.
Another option is to write to a temporary file to prevent the stdout blocking instead of needing to poll with communicate(). This worked for me where the other answers did not; for example on windows.
 is now supported by  and  in the subprocess module (as of Python3.3):This will call the command and raise the exceptionif the command doesn't finish after 20 seconds.You can then handle the exception to continue your code, something like:Hope this helps.
Here is my solution, I was using Thread and Event:In action:
The solution I use is to prefix the shell command with timelimit. If the comand takes too long, timelimit will stop it and Popen will have a returncode set by timelimit. If it is > 128, it means timelimit killed the process.See also python subprocess with timeout and large output (>64K)
I added the solution with threading from  to my Python module easyprocess.Install:Example:
I don't know why it isn't mentionned but since Python 3.5, there's a new  universal command (that is meant to replace ,  ...) and which has the  parameter as well.subprocess.run(args, *, stdin=None, input=None, stdout=None, stderr=None, shell=False, cwd=None, timeout=None, check=False, encoding=None, errors=None)It raises a  exception when the timeout is expired.
if you are using python 2, give it a try
I've implemented what I could gather from a few of these. This works in Windows, and since this is a community wiki, I figure I would share my code as well:Then from another class or file:
Once you understand full process running machinery in *unix, you will easily find simplier solution:Consider this simple example how to make timeoutable communicate() meth using select.select() (available alsmost everythere on *nix nowadays). This also can be written with epoll/poll/kqueue, but select.select() variant could be a good example for you. And major limitations of select.select() (speed and 1024 max fds) are not applicapable for your task.This works under *nix, does not create threads, does not uses signals, can be lauched from any thread (not only main), and fast enought to read 250mb/s of data from stdout on my machine (i5 2.3ghz).There is a problem in join'ing stdout/stderr at the end of communicate. If you have huge program output this could lead to big memory usage. But you can call communicate() several times with smaller timeouts.
You can do this using 
Prepending the Linux command  isn't a bad workaround and it worked for me.
I've used killableprocess successfully on Windows, Linux and Mac. If you are using Cygwin Python, you'll need OSAF's version of killableprocess because otherwise native Windows processes won't get killed.
Although I haven't looked at it extensively, this decorator I found at ActiveState seems to be quite useful for this sort of thing. Along with , at least I'm ready for shell-scripting in Python.
There's an idea to subclass the Popen class and extend it with some simple method decorators. Let's call it ExpirablePopen.
I had the problem that I wanted to terminate a multithreading subprocess if it took longer than a given timeout length. I wanted to set a timeout in , but it did not work. Then, I realized that  is equal to  and so I had the idea to set a timeout within the  method, which finally worked. Thus, I solved it this way:
Unfortunately, I'm bound by very strict policies on the disclosure of source code by my employer, so I can't provide actual code.  But for my taste the best solution is to create a subclass overriding  to poll instead of wait indefinitely, and  to accept a timeout parameter.  Once you do that, all the other  methods (which call ) will work as expected, including .
https://pypi.python.org/pypi/python-subprocess2 provides extensions to the subprocess module which allow you to wait up to a certain period of time, otherwise terminate. So, to wait up to 10 seconds for the process  to terminate, otherwise kill:This is compatible with both windows and unix.  "results" is a dictionary, it contains "returnCode" which is the return of the app (or None if it had to  be killed), as well as "actionTaken". which will be "SUBPROCESS2_PROCESS_COMPLETED" if the process completed normally, or a mask of "SUBPROCESS2_PROCESS_TERMINATED" and SUBPROCESS2_PROCESS_KILLED depending on action taken (see documentation for full details)
This solution kills the process tree in case of shell=True, passes parameters to the process (or not), has a timeout and gets the stdout, stderr and process output of the call back (it uses psutil for the kill_proc_tree).  This was based on several solutions posted in SO including jcollado's. Posting in response to comments by Anson and jradice in jcollado's answer. Tested in Windows Srvr 2012 and Ubuntu 14.04.  Please note that for Ubuntu you need to change the parent.children(...) call to parent.get_children(...).
for python 2.6+, use gevent
python 2.7

Was just trying to write something simpler.


Answer URL
https://docs.python.org/3/library/subprocess.html#subprocess.call
https://docs.python.org/3/library/subprocess.html#subprocess.run
