Natural Text
Hi friends I want to perform an operation I believe I can solve this with map.The following operation is actually working correctly. But I want to do something a bit different.18 will be 19 when it increases. But when the next value comes, it will now be collected with 19.in this example, the output I want is:This is what I can do:
How about using the  function which is present in 2.7?   is often used in conjunction with  to aggregate lists after some number of map transformations.Here's my 3.5 version of it, which should be close, if not identical to 2.7:I'm taking advantage of addition of lists (which concatenates) to append subsequent values to the empty list defined in the initializer.  There's a little conditional since you can't get the last entry of an empty list.
Trying to do what you want with  will require adding some kind of "memory" to the function—it has to know what it's done so far, so it knows what to do next.You can do this, either by using a closure, or by using a class with a  method. But there's an easier way.What you're looking for is almost exactly the  function. The only difference is that you want to supply a starting value. (And, of course, that  isn't actually in the stdlib in 2.7; you need to get it off a backport on PyPI.)You could handle that in three obvious ways:, then add your starting value to each element. a starting value before the input, then , then  (or ) to skip over the extra value in the output.Take the "roughly equivalent" sample code in the  docs and modify it to take a start value.Let's do the last one—it's probably the heaviest-weight option, but the one you can learn the most from, plus it'll work even in 2.7 without any backports:Compare to the original code in the docs—all I did was add a new parameter, set , and change the special handling for the first element or for empty iterables. You can obviously simplify things (if we have a start value, we don't even need special handling for empty input), or make things fancier (default to no start value instead of 0, so  works for types that aren't interoperable with int just like the one in  does), etc., but this is a simple starting point.And now:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.accumulate
https://docs.python.org/3/library/itertools.html#itertools.accumulate
