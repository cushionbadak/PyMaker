Natural Text
How can I make python mmap assignment atomic? Nothing about atomic is said here: https://docs.python.org/3.0/library/mmap.htmlImmediately, I execute the following code in another processThen I am seeing {888, 9999}Which means mmap is not atomic. Anyway to make it atomic?
In general, you can't. File writes aren't atomic to begin with, whether done via mmap or write. Some filesystems, such as Tahoe-LAFS, do have a file put operation, but even there it's a matter of known completion, not atomic operation (chunks are stored individually). Atomicity of file content updates are frequently done with three methods:Using the rename call, where you can be sure a name points to either the old or new file (Python's Path.replace might be more clear). This is the method used in e.g. maildir.Using file locks. These are in general cooperative, meaning all programs that access the file must use the same locking method consistently. Sometimes this is not possible, for instance across some network filesystems. Due to this inconsistency, other lock methods such as lock files are also used - thus the "same method" requirement. Using smaller accesses that are atomic due to underlying architecture, such as disk sectors. This is done e.g. in SQLite's journal headers. Notably the threshold is different with mmap because the memory page itself may be shared, allowing far finer granularity for atomic accesses (perhaps CPU word size or single byte). The topic is fairly complex. The key to combining any of these synchronization methods with mmap is mmap.flush. 
I don't think it's a  problem - I'd bet that it happens because  guarantess just that Python has sent the data to the underlying OS's buffer but that doesn't mean it has been actually written. Then when you open it again, and give the handle to , you're still operating on the buffer.You can try syncing the buffer before you close the file to ensure everything has been written:Or better, just to let Python handle closing cleanly in case of an error:Although even  is not a 100% guarantee, from the underlying  man page:Calling fsync() does not necessarily ensure that the entry in the directory containing the file has also reached disk. For that an explicit fsync() on a file descriptor for the directory is also needed. But I'd bet that it wouldn't do what you need in very rare edge cases.


Answer URL
https://docs.python.org/3/library/pathlib.html#pathlib.Path.replace
https://docs.python.org/3/library/os.html#os.lockf
https://docs.python.org/3/library/mmap.html#mmap.mmap.flush
https://docs.python.org/3/library/array.html
