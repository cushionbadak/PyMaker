Natural Text
I am trying to figure out if an input list is a strictly increasing list. Moreover, If removing only one element from the list results in a strictly increasing list, we still consider the list true. Here is my code. It seems to have an index error, but I do not understand why. 

Alright, so it turns out this problem is not that easy. If you want an efficient solution, I think your best bet may be an algorithm similar to the longest increasing subsequence problem. But here, we don't care about the actual longest increasing subsequence - we just need it's length. Also, we can short-circuit when maintaining our ordered list if we have had to perform  insertions already (where  is our restriction on the number of "out of order" elements).This also generalizes very well to the  element "almost increasing" case, and in the worst case performs  binary searches on lists of size  to , where  is the size of the list. The idea behind this algorithm is as follows:We move through the list, and maintain an ordered subsequence of our list all the while. When we reach a new elementif that element cannot be appended onto our ordered subsequence, it is a "violator" of the increasing property. We subsequently insert it into the ordered subsequence in the correct position, using  for binary search. otherwise, we just append it to our ordered subsequence and continue on.At the end of each iteration, if we have too many violators already we can short-circuit out. Otherwise, after the loop is done we are guaranteed to have an increasing subsequence that has length within  of the length of our original list. Demo
If you've written  in Python, you've probably done the wrong thing. This is indeed why this is failing.  is the length of the sequence as it stands before any processing, but that length can change as you  items from the list.Better instead is to compare each mark which indices need to be removed and do them all at once, or better yet -- don't remove them at all!! It's a side-effect that's not well-explained.You can build this by building a list of all sequences that might be strictly increasing using , comparing each pair with 's  recipe, then short-circuiting as long as at least one is.
The only thing you need to do is walk the list, counting the number of times . If it happens at most once, your list is almost monotonically increasing.You can also avoid counting, since the number of exceptions is small. Just return  as soon as you find the second exception, as tracked by the value of a Boolean variable initialized to .


Answer URL
https://docs.python.org/3/library/bisect.html
