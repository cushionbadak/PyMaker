Natural Text
In this example, I show two different methods for creating a list of strings using Cython. One uses an array of char pointers (and the  C function) and the other by simply appending elements to a list.I then pass each of these lists into the  function and see that performance is drastically different.Question - What can I do to create the list using character pointers to have equal performance?A simple function to create lists in CythonHere,  is just an array of 3-length characters. Cython will return this object as a Python list.  is just a normal Python list. We are filling both lists with just a single sequence of bytes, 'AB'.Create the listsPrint out some of the contentsShow both lists are equalTime operations - this is insane to me! 3x differenceUnicode and pure pythonInterestingly, the performance difference vanishes if I decode each value to unicode, though it is slower than the original . If I create a unicode list in pure Python then I am back to the original performance.Even simpler exampleTimingseditPossible solutionI found the function  in the unicode Python C API and am getting performance on par with regular python lists. This 'interns' the string - not sure what that means
Your  is a list of 100000 distinct bytestrings with the same contents. Cython has to convert each  to a bytestring separately, and it doesn't bother to do any object deduplication.Your  is a list of the same bytestring object 100000 times. Every  appends the same object to ; without the trip through a C array, Cython never needs to copy the bytestring. is slower than  because  has to actually perform string comparison, while  gets to skip that with an object identity check.


Answer URL
https://docs.python.org/3/c-api/unicode.html#c.PyUnicode_InternFromString
