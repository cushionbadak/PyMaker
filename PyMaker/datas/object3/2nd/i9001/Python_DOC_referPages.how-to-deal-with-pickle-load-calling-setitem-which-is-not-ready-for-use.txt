Natural Text
I was trying to implement a (prototype, not production) version of a persistent dictionary that uses pickle on disk as persistent storage. However,  calls  for its own purposes, and that's the method that is (of course) overridden to ensure changes to the dictionary are propagated back to the persistent storage -- and so it calls . Of course, it's not ok to call  as every item is being set during unpickling.Is there any way to solve this, other than by brute force (as below)? I tried reading Pickling Class Instances in search of a solution using of special methods, but didn't find any.The code below monitors whether unpickling is in progress, and skips  in that case; while it works fine, it feels hacky.
Inheriting directly from  is not advised when trying to get to fancy dictionary implementations. For one thing, Python's ABI takes some shortcuts on dict class that might eventually skip some calls tos certain dunder methods - and also, as you can perceive when pikcling and unpickling - dictionaries and direct subclasses of it will be treated in a different way than ordinary objects (which have their  attribute pickled, not their keys set with .So, for one thing, start with inheriting from  - this is a different implementation of  which ensures all data access is done through a proper Python side call to the dunder special methods. You might even want to implement it as an implementation of  - that ensures you have to implement a minimal number of methods in your code to have your class working like if it were a real dictionary. Second thing: the Pickle protocol will do "its thing" by default - which in mapping classes is (I haven't checked, but apparently is), pickling the (key, value) pairs and calling  for each of those on unpicling.  But the pickling behavior is fully customizable-  as you can see on the documentation - you can simply implement explict  and  methods on your class to have full control over the pickling/unpickling code.Example using MutableMapping, and storing the dictionary contents in an associated internal dictionary:BTW, a big advantage of using the MutableMapping super class is that it is guarranteed that if you implement properly the methods described in the documentation, your code is ready for production (so, no need to worry about missing exquisite corner cases).   
The strategy employed in this recipe by Raymond Hettinger is to:and inside  (you therefore don't need to implement )


Answer URL
https://docs.python.org/3/library/pickle.html#pickling-class-instances
https://docs.python.org/3/library/pickle.html#object.__setstate__
https://docs.python.org/3/library/collections.abc.html
