Natural Text
I'm having trouble understanding the use of asynchronous comprehensions introduced in Python 3.6. As a disclaimer, I don't have a lot of experience dealing with asynchronous code in general in Python.The example given in the what's new for Python 3.6 document is:In the PEP, this is expanded to:I think I understand that the  function gets called asynchronously, so that each iteration of  can proceed without the previous one necessarily returning yet (or is this understanding wrong?).What I'm not sure about is how that then translates to the list comprehension here. Do results get placed into the list in the order that they are returned? Or are there effective 'placeholders' in the final list so that each result is placed in the list in the right order? Or am I thinking about this the wrong way?Additionally, is someone able to provide a real-world example that would illustrate both an applicable use case and the basic mechanics of  in comprehensions like this?
You are basically asking how an  loop works over a regular loop. That you can now use such a loop in a list comprehension doesn't make any difference here; that's just an optimisation that avoids repeated  calls, exactly like a normal list comprehension does.An  loop then, simply awaits each next step of the iteration protocol, where a regular  loop would block.To illustrate, imagine a normal  loop:For this loop, Python essentially does this:The  call is not asynchronous; it blocks.Now replace  with , and what Python does changes to:In the above example  and  are fictional functions; these are functionally exact equivalents of their  and  brethren but instead of  and  these use  and . That is to say, asynchronous hooks exist for the same functionality but are distinguished from their non-async variants by the prefix .The  keyword there is the crucial difference, so for each iteration an  loop yields control so other coroutines can run instead.Again, to re-iterate, all this already was added in Python 3.5 (see PEP 492), all that is new in Python 3.6 is that you can use such a loop in a list comprehension too. And in generator expressions and set and dict comprehensions, for that matter.Last but not least, the same set of changes also made it possible to use  in the expression section of a comprehension, so:is now possible.
I think I understand that the  function gets called asynchronously, so that each iteration of  can proceed without the previous one necessarily returning yet (or is this understanding wrong?).That understanding is wrong. Iterations of an  loop cannot be performed in parallel.  is just as sequential as a regular  loop.The asynchronous part of  is that it lets the iterator  on behalf of the coroutine iterating over it. It's only for use within asynchronous coroutines, and only for use on special asynchronous iterables. Other than that, it's mostly just like a regular  loop.


Answer URL
https://docs.python.org/3/whatsnew/3.6.html
