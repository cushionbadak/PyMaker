Natural Text
I came across the following interesting construct:assuming you have a list of lists as follows:and you want to create a dict out of them with the -index elements being the keys. A handy way to do it would be this:As it seems, the  precedes the assignment of list  as the value and that is why  does not appear in the values (it is already popped)Now let's take this a step further and try to get a structure like:For this task I wrote the following:but this returns:so the  in this case happens after the inner dictionary is constructed (or at least after the ).How can that be? How does this work?The question is not about how to do it but rather why this behavior is seen.I am using Python version 3.5.1.
tl;dr: Even though Python does evaluate values first (the right-side of the expression) this does appear to be a bug in (C)Python according to the reference manual and the grammar and the PEP on dict comprehensions. Though this was previously fixed for dictionary displays where values were again evaluated before the keys, the patch wasn't amended to include dict-comprehensions. This requirement was also mentioned by one of the core-devs in a mailing list thread discussing this same subject.According to the reference manual, Python evaluates expressions from left to right and assignments from right to left; a dict-comprehension is really an expression containing expressions, not an assignment*: where, according to the corresponding rule of the  one would expect  to be evaluated similarly to what it does in displays. So, both expressions should follow the defined order,  should be evaluated before  (and, if  contains expressions of its own, they too should be evaluated from left to right.) The PEP on dict-comps additionally states that the following should be semantically equivalent:The semantics of dict comprehensions can actually be demonstrated in  stock Python 2.2, by passing a list comprehension to the built-in  dictionary constructor: is semantically equivalent to:were the tuple  is evaluated left to right as expected.Changing this to behave according to the rules for expressions would create an inconsistency in the creation of s, of course. Dictionary comprehensions and a for loop with assignments result in a  different evaluation order but, that's fine since it is just following the rules.Though this isn't a major issue it should be fixed (either the rule of evaluation, or the docs) to disambiguate the situation.*Internally, this does result in an assignment to a dictionary object but, this shouldn't break the behavior expressions should have. Users have expectations about how expressions should behave as stated in the reference manual. As the other answerers pointed out, since you perform a mutating action in one of the expressions, you toss out any information on what gets evaluated first; using  calls, as Duncan did, sheds light on what is done. A function to help in showing the discrepancy:(Fixed) dictionary display:(Odd) dictionary comprehension:and yes, this applies specifically for Python. I am not aware of how other implementations evaluate this specific case (though they should all conform to the Python Reference Manual.)Digging through the source is always nice (and you also find hidden comments describing the behavior too), so let's peek in  of the file :this might seem like a good enough reason and, if it is judged as such, should be classified as a documentation bug, instead. On a quick test I did, switching these statements around ( getting visited first) while also switching the corresponding order in  (which is used for dict-comps):results in the evaluation one would expect based on the docs, with the key evaluated before the value. (Not for their asynchronous versions, that's another switch required.) I'll drop a comment on the issue and update when and if someone gets back to me.Created Issue 29652 -- Fix evaluation order of keys/values in dict comprehensions on the tracker. Will update the question when progress is made on it.
As it seems, the pop precedes the assignment of list x as the value      and that is why 'captain' does not appear in the values (it is already     popped)No, the order in which it happens is irrelevant. You are mutating the list so you will see the modified list after the pop wherever you use it. Note that in general you probably don't want to do this as you will destroy the original list. Even if that doesn't matter this time its a trap for the unwary in the future.In both cases the value side is calculated first and then the corresponding key. It's just that in your first case it doesn't matter whereas it does in the second.You can see this quite easily:Note that you should not write code that depends on the values being evaluated first: the behaviour may change in future versions (it was said in some places to have changed in Python 3.5 and later although in fact that appears not to be the case).A simpler way to do this, which avoids mutating the original data structure:Or your second example:To answer the comments: the zip uses the original  because it is evaluated before the , but it uses the content of the list to construct a new list so any later changes to the list aren't seen in the result. The first comprehension also uses the original  as the value, but it then mutates the list so the value still sees the original list and hence the mutation.
As I said in comment that's because in a dictionary comprehension python evaluates the value first. And as a more pythonic approach you can use unpacking variables for this task, instead of popping from list in each iteration:Regarding the strange behavior of python in evaluating the keys and values in a dictionary comprehension, after some experiments I realized that this behavior is somehow reasonable rather than being a bug.I'll brake down my impression in following parts:In an assignment expression, python evaluates the right side first.from doc:Python evaluates expressions from left to right. Notice that while evaluating an assignment, the right-hand side is evaluated before the left-hand side.Dictionary comprehension is an expression and will be evaluated left to right but since there is an assignment under the hood, after translating it by python.the value which is the right had side will be evaluated first.for example the following comprehension:is equivalent with following snippet:Here are some examples:Regarding the disparity between the the fact (Or it's better to say abstraction) that dictionary comprehensions are expression and should be evaluated left to right (based on python documentation)with the observed behaviors I think it's actually a problem and immaturity of the python documentation and not a bug in python code. Because it's not reasonable at all to change the functionality because of the having a consistent documentation without any exception.
Actually your observation doesn't require special ordering of the operation. The reason is that  modifies the object . So whether you evaluate the value () before or after the key () doesn't matter in this case.Anyway I don't think the python language specification prescribes a certain order of operations, which means that you should not rely on the order being any particular.Actually the standard implementation happens to evaluate the value before it evaluates the key, but there's nowhere in the standard where this is stated. The only guarantee is that the key-value pairs are evaluating in iteration order and they are inserted in that order.


Answer URL
https://docs.python.org/3/reference/expressions.html#evaluation-order
