Natural Text
Is there a way to have Python static analyzers (e.g. in PyCharm, other IDEs) pick up on Typehints on  objects?  Example:If I remove the type declaration in the inline comment, PyCharm doesn't complain, but it also doesn't pick up on invalid attributes.  For example:Any ideas?UpdateInspired by Austin's answer below, the simplest solution I could find is one using :While this is satisfactory, I still don't like having to repeat the argument names.  If the argument list grows considerably, it will be tedious updating both locations.  What would be ideal is somehow extracting the arguments from the  object like the following:I haven't been able to find anything in the  module that could make this possible, and I'm still unsure if any static analysis tool could be clever enough to get those values and not bring the IDE to a grinding halt.Still searching...Update 2Per hpaulj's comment, the closest thing I could find to the method described above that would "magically" extract the attributes of the parsed object is something that would extract the  attribute from each of the parser's s.:But this still does not cause attribute errors to get flagged in static analysis.  This is true also true if I pass  in the  call.
Consider defining an extension class to  that provides the type hints you want:Then use  to pass that to :
I don't know anything about how PyCharm handles these typehints, but understand the  code. is a simple class; essentially an object with a few methods that make it easier to view the attributes. And for ease of unittesting it has a  method.  You can read the definition in the  file.The  interacts with the namespace in the most general way possible - with , , .  So you can use almost any  string, even ones you can't access with the  syntax.  Make sure you don't confuse the   parameter; that's a function.Using your own  class (from scratch or subclassed) as suggested in the other answer may be the best option.  This is described briefly in the documentation.  Namespace Object.  I haven't seen this done much, though I've suggested it a few times to handle special storage needs.  So you'll have to experiment.If using subparsers, using a custom Namespace class may break, http://bugs.python.org/issue27859Pay attention to handling of defaults.  The default default for most  actions is .  It is handy to use this after parsing to do something special if the user did not provide this option.That could get in the way type hints.  Whatever solution you try, pay attention to the defaults.A  won't work as a .First, the proper use of a custom Namespace class is:That is, you initial an instance of that class, and pass it as the parameter.  The returned  will be the same instance, with new attributes set by parsing.Second, a namedtuple can only created, it can't be changed.A namespace has to work with  and .Another problem with  is that it doesn't set any kind of  information.  It just defines field/attribute names.  So there's nothing for the static typing to check.While it is easy to get expected attribute names from the , you can't get any expected types.For a simple parser:The Actions  is the normal attribute name.  But  is not the expected static type of that attribute.  It is a function that may or may not convert the input string.  Here  means the input string is saved as is.  Because static typing and  require different information, there isn't an easy way to generate one from the other.I think the best you can do is create your own database of parameters, probably in a dictionary, and create both the Namespace class and the parsesr from that, with your own utility function(s).Let's say  is dictionary with the necessary keys.  Then we can create an argument with:You or someone else will have to come up with a Namespace class definition that sets the  (easy), and static type (hard?) from such a dictionary.


Answer URL
https://docs.python.org/3/library/argparse.html#the-namespace-object
