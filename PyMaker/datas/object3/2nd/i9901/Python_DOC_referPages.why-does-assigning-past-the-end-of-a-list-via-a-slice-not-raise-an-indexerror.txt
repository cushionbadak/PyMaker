Natural Text
This question already has an answer here:Why substring slicing index out of range works in Python?                    3 answers                I'm working on a sparse list implementation and recently implemented assignment via a slice. This led me to discover some behaviour in Python's built-in  implementation that I find suprising.Given an empty  and an assignment via a slice:I would have expected an  from  here because the way this is implemented means that an item can't be retrieved from the specified index:: cannot even be retrieved from the specified slice: appends to the  (that is,  after this assignment) and appears to have behaved this way since the BDFL's initial version. I can't find this functionality documented anywhere (*) but both CPython and PyPy behave this way.Assigning by index raises an error:So why does assigning past the end of a  via a slice not raise an  (or some other error, I guess)?To clarify following the first two comments, this question is specifically about assignment, not retrieval (cf. Why substring slicing index out of range works in Python?).Giving into the temptation to guess and assigning  to  at index 0 when I had explicitly specified index 100 doesn't follow the usual Zen of Python.Consider the case where the assignment happens far away from the initialisation and the index is a variable. The caller can no longer retrieve their data from the specified location.Assigning to a slice before the end of a  behaves somewhat differently to the example above:(*) This behaviour is defined in Note 4 of 5.6. Sequence Types in the official documentation (thanks elethan) but it's not explained why it would be considered desirable on assignment.Note: I understand how retrieval works and can see how it may be desirable to be consistent with this for assignment but am looking for a cited reason as to why assigning to a slice would behave in this way.  returning  immediately after  but  returning  after  is astonishing if you have no knowledge of , particularly if you're following Python's EAFP idiom.
Let's see what is actually happening:So the assignment was actually successful, and the item got placed into the list, as the first item.Why this happens is because  in indexing position is converted to a  object: :Now, the  class has a method  (I am not able to find its Python documentation online, though) that, when given a length of a sequence, will give  that is adjusted for the length of that sequence.Thus when this slice is applied to a sequence of length 0, it behaves exactly like a slice  for slice retrievals, e.g. instead of  throwing an error when  is an empty sequence, it behaves as if  was requested - this will result on empty slice on retrieval.Now the setter code should work correctly when  was used when l is a sequence that has more than 100 elements. To make it work there, the easiest is to not reinvent the wheel, and to just use the  mechanism above. As a downside, it will now look a bit peculiar in edge cases, but slice assignments to slices that are "out of bounds" will be placed at the end of the current sequence instead. (However, it turns out that there is little code reuse in the CPython code;  essentially duplicates all this index handling, even though it would also be available via slice object C-API).Thus: if start index of a slice is greater than or equal to the length of a sequence, the resulting slice behaves as if it is a zero-width slice starting from the end of the the sequence. I.e.: if ,  behaves like  on built-in types. This is true for each of assignment, retrieval and deletion.The desirability of this is in that it doesn't need any exceptions. The  method doesn't need to handle any exceptions - for a sequence of length ,  will always result in  of indices that can be used for any of assignment, retrieval and deletion, and it is guaranteed that both  and  are .
For indexing, an error must be raised if the given index is out-of-bounds, because there is no acceptable default value that could be returned. (It is not acceptable to return , because  could be a valid element of the sequence).By contrast, for slicing, raising an error is not necessary if any of the indexes are out-of-bounds, because it is acceptable to return an empty sequence as a default value. And it also desirable to do this, because it provides a consistent way refer to subsequences both between elements and beyond the ends of the sequence (thus allowing for insertions).As stated in the Sequence Types Notes, if the start or end value of a slice is greater than , then  is used instead.So given , the expressions  and  both point to the empty subsequence following the last element in the list. However, after a slice assignment using these expressions, they may no longer refer to the same thing, since the length of the list may have been changed.Thus, after the asignment , the slice  will return . But after the asignment , the slice  will still return , because  is still less than . And given everything else stated above, this is exactly what one should expect if consistency between slice assignment and slice retrieval is to be maintained.


Answer URL
https://docs.python.org/3/library/functions.html#slice
https://docs.python.org/3/c-api/slice.html
