Natural Text
In the following I will give two examples that have different dimension values.Lock-1So what I would expect for all of my posibilities isMy second lock has the following values:So what I would expect as my posibilities would look like thisI know this can be done with  and so on, but I want to generate the rows by building them and not by overloading my RAM. I figured out that the last 2 rows are always building up the same way.So I wrote a funtion which builds it for me:Now I want some kind of way to fit the other values dynamically around my function, so e.g. Lock - 2 would now look like this:I know I should use a  loops and so on, but I can't get the solution for dynamic values.
You could do this recursively, but it's generally best to avoid recursion in Python unless you really need it, eg, when processing recursive data structures (like trees). Recursion in standard Python (aka CPython) is not very efficient because it cannot do tail call elimination. Also, it applies a recursion limit (which is by default 1000 levels, but that can be modified by the user).The sequences that you want to generate are known as weak compositions, and the Wikipedia article gives a simple algorithm which is easy to implement with the help of the standard  function.outputFWIW, the above code can generate the 170544 sequences of  in around 1.6 seconds on my old 2GHz 32bit machine, running on Python 3.6 or Python 2.6. (The timing information was obtained by using the Bash  command).FWIW, here's a recursive version taken from this answer by user3736966. I've modified it to use the same argument names as my code, to use lists instead of tuples, and to be compatible with Python 3.Somewhat surprisingly, this one is a little faster than the original version, clocking in at around 1.5 seconds for .  If your version of Python doesn't understand , you can do this:To generate the compositions in descending order, simply reverse the  call, i.e. .Finally, here's an unreadable one-line version. :)Being an inveterate tinkerer, I couldn't stop myself from making yet another version. :) This is simply the original version combined with the code for  listed in the itertools docs. Of course, the real  is written in C so it runs faster than the roughly equivalent Python code shown in the docs.This version is about 50% slower than the original at doing : it takes around 2.3 seconds on my machine.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.combinations
