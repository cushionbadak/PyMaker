Natural Text
So just to establish, I feel like I understand the difference between  vs.  in the copy module and I've used  and  before successfully, but this is the first time I've actually gone about overloading the  and  methods.  I've already Googled around and looked through the built-in Python modules to look for instances of the  and  functions (e.g. , , and ), but I'm still not 100% sure I've got it right.Here's my scenario: I have a configuration object that mostly just consists of simple properties (though it will potentially have lists of other non-primitive objects in it).  Initially I'm going to instantiate one configuration object with a default set of values.  This configuration will be handed off to multiple other objects (to ensure all objects start with the same configuration).  Once user interaction starts, however, each object will need to be able to tweak the configurations independently without affecting each other's configurations (which says to me I'll need to make deepcopys of my initial configuration to hand around).Here's a sample object:What is the right way to implement the  and  methods on this object to ensure  and  give me the proper behavior?  I'm currently using Python 2.6.2.  Thanks in advance!
The recommendations for customizing are at the very end of the docs page:Classes can use the same interfaces to  control copying that they use to  control pickling. See the description  of module pickle for information on  these methods. The copy module does  not use the copy_reg registration  module.In order for a class to define its own  copy implementation, it can define  special methods  and  . The former is called to implement the shallow copy  operation; no additional arguments are  passed. The latter is called to  implement the deep copy operation; it  is passed one argument, the memo  dictionary. If the   implementation needs to make a deep  copy of a component, it should call  the  function with the  component as first argument and the  memo dictionary as second argument.Since you appear not to care about pickling customization, defining  and  definitely seems like the right way to go for you.Specifically,  (the shallow copy) is pretty easy in your case...: would be similar (accepting a  arg too) but before the return it would have to call  for any attribute  that needs deep copying (essentially attributes that are containers -- lists, dicts, non-primitive objects which hold other stuff through their s).
Putting together Alex Martelli's answer and Rob Young's comment you get the following code:printshere  fills in the  dict to avoid excess copying in case the object itself is referenced from its member.
Following Peter's excellent answer, to implement a custom deepcopy, with minimal alteration to the default implementation (e.g. just modifying a field like I needed) :
I might be a bit off on the specifics, but here goes;From the  docs;A shallow copy constructs a new compound object and then (to the extent possible) inserts references into it to the objects found in the original.A deep copy constructs a new compound object and then, recursively, inserts copies into it of the objects found in the original.In other words:  will copy only the top element and leave the rest as pointers into the original structure.  will recursively copy over everything.That is,  is what you need.If you need to do something really specific, you can override  or , as described in the manual. Personally, I'd probably implement a plain function (e.g.  or such) to make it plain that it isn't Python standard behaviour.
Its not clear from your problem why you need to override these methods, since you don't want to do any customization to the copying methods.Anyhow, if you do want to customize the deep copy (e.g. by sharing some attributes and copying others), here is a solution:
The  module uses evantually the / pickling protocol, so these are also valid targets to override.  The default implementation just returns and sets the  of the class, so you don't have to call  and worry about Eino Gourdin's clever trick, above.
Building on Antony Hatchkins' clean answer, here's my version where the class in question derives from another custom class (s.t. we need to call ):


Answer URL
https://docs.python.org/3/library/pickle.html#object.__getstate__
https://docs.python.org/3/library/pickle.html#object.__setstate__
