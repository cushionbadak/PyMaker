Natural Text
Python VersionPython 3.5.2IssueI notice this issue when I tried to call the C DLL using ctypes, the C function is something like:So I need to pass an IP address string (for example, 192.168.100.100) from Python to ctypes, according to ctypes doc of Python 3.5, I tried both c_wchar_p and c_char_p, but none of them working, I got error code retrun from c dll side. I had some other function call to this dll passing c_int, c_void_p, c_bool and other data types which are all ok. Traced back and found that the c_wchar_p and c_char_p return results behaves different from what it should be based on ctypes doc. From the ctypes doc of Python 3.5:It return the ctypes string.But my results of execute the same cmd in Python console:So seems like the orignial string part becomes memory address maybe. Digged in more, and found out if it is Python 2.x(default encoding is ASCII), then the return shows the string like the Python 3.5 ctypes doc shows. But in Python 3.x(default encoding is UTF-8), it always return numbers, behave differnt from the doc. Checked on multiple PCs. And understood the part that, we can use .value to return the original string. But it could not pass to the C function which has to be a ctype.QuestionCan anyone provide a explaination about this about behavior ctypes?and how to resolve this, so that I could get the same behave like ctype doc in Python3.5 and then make the call c dll work?Thanks a lot in advance~
I am more than certain now that you should be using  instead of  for passing the string to your  function; the non- signature indicates a mutation and that requires a character buffer as stated in the docs:You should be careful, however, not to pass them to functions expecting pointers to mutable memory. If you need mutable memory blocks, ctypes has a  function which creates these in various ways. The current memory block contents can be accessed (or changed) with the raw property; if you want to access it as  terminated string, use the value property.(emphasis mine)So in essence, . Aside from that, it just seems that the documentation might indeed be off on this. The implementation of  for  and  returns their name and, after a pointer to their memory buffer has been created, the  that  pointer.


Answer URL
https://docs.python.org/3/library/ctypes.html
https://docs.python.org/3/library/ctypes.html#ctypes.c_wchar_p
https://docs.python.org/3/library/ctypes.html#ctypes.create_string_buffer
https://docs.python.org/3/library/ctypes.html#ctypes.create_string_buffer
