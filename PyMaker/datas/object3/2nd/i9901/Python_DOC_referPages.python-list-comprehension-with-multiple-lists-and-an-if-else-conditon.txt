Natural Text
I would like to loop over two equally long sets and determine whether elements in each set are also in an array.This is a Hackerrank question of which I have already solved. However, I am using Hackerrank to further understanding of Python. I have been learning about list comprehension and whilst I do believe how I am attempting to use it to be considered bad production code I still would like to explore the possibilities of the language syntax for my own knowledge.This is the code that sets it up:The task is to output an integer with a value of +1 for every element both in A and arr and -1 for every element both in B and arr.Sample Input:Sample Output:This achieves the required results:However, this is closer to what I would like to achieve:EDIT (this is closer actually):As you can see both are one-liners so it's not about attempting to reduce the code but rather to just understand the possibilities of list comprehension and pythonic code. If this is not possible or even bad practice I am very interested also.This is the Hackerrank link:https://www.hackerrank.com/challenges/no-idea
First of all, forgo the list comprehension; feed the values directly into  with a generator expression:If  is a set, use the  method to extract the common values, then take the length of the result:This is faster than trying to test  for each value. This does produce a new  object first however, but you were creating a list before so that's not much difference.At that point it is far simpler just to subtract the second length:You can avoid creating sets altogether by looping over  and testing each value in  against either  or ; this too is faster because set membership tests are O(1) constant time:Your method, of testing  for every value in the set , requires a full list scan of  if the value  is not present; this makes membership testing against a list a O(N) linear time problem, and you do so for every value in  and for every value in , so you end up with O((A+B) * N) == O(KN) time. Testing each value in  against the set is only O(N * 1) == O(N) time.Moreover, if values in  are not unique, your approach would actually lead to to the wrong answer; you'd only count happy or unhappy numbers once, while the problem requires them to be counted each time they appear.
How about coverting array to set and taking intersectionEdit:     This solution will not work for duplicate values in 
Your solution is great but here's a catch. You're using a  data structure for the two sets of numbers and a  for your array. When applying the  operator on top of list you're doing a O(n) search  whereas in a set the same operation is O(logn) (In python average case is O(1)!). So your total time complexity is O(2 * m * n) = O(m*n). You could search in a reverse manner such as:The total complexity of this would be O(n * 2 * logm) = O(n*logm)More about python time complexities here
This is the answer I submitted as it worked using list comprehension as I first thought. This was only necessary as the array may have multiples of the same element as such the count would need to reflect that.
The most efficient way of solving the problem is probably to put the items of  and  into a dictionary (as keys), with the values being  or  depending on which set they came from. This will let you scan through the list  and easily get the value to add to the sum:The calculation of the result has the same computational complexity as using couple of conditional operators in a generator expression (), but should be faster by some constant factor since for each item there's only one dict lookup instead of two set membership tests.


Answer URL
https://docs.python.org/3/library/stdtypes.html#set.intersection
