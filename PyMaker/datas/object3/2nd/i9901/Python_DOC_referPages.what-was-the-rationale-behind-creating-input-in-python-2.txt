Natural Text
In Python 2, there were two ways of getting input.  and , which was a wrapper around . In Python 3 however,  replaced  and the old meaing of  was deprecated. This is documented in What's new in Python 3:PEP 3111:  was renamed to . That is, the new  function reads a line from  and returns it with the trailing newline stripped. It raises  if the input is terminated prematurely. To get the old behavior of , use .But why exactly was  around in Python 2 in the first place? What was the rationale for having user input that was evaluated as literal Python 2 code? This is what the Python 2 documentation had to say:[ is] Equivalent to .This function does not catch user errors. If the input is not syntactically valid, a  will be raised. Other exceptions may be raised if there is an error during evaluation.If the  module was loaded, then  will use it to provide elaborate line editing and history features.Consider using the  function for general input from users.Notice the part in bold (which I emphasized). What exactly does this mean? I looked over the documentation for the  module and found a few things. The only real relevant bit I found, however, was this:Settings made using this module affect the behavior of both the interpreter’s interactive prompt and the prompts offered by the  and built-in functions.Which doesn't really help explain why  was created or needed in the first place, though.Needless to say, using  is very dangerous security wise, can cause debugging difficulties, and, from what I've read, is slow. So why did they create  in Python 2 in the first place? Were the developers unaware at the time of the downfalls of ?References:Is using eval in Python a bad practice?eval(input()) in python 2to3What’s New In Python 3.0Python 2.7.12 documentation
First of all, probably the only person who can answer this question decisively is the BDFL. can be useful in programs that are meant to be used by a  programmer, so that they can enter complex structures, like , or even expressions, but less so in programs intended to be used by an unskilled user.From the SCM history we can see that both  and  were present in 1990; or pre-0.9, when Python was in its infancy - back then  was a function, and  would have thrown an exception. Most notably,  was already present as well, so one could have used  even back then to get much of the same effect.Back then there was no Zen of Python yet, and the "only one obvious way" wasn't as much a guiding principle, so this could have been an oversight.And both  and  remained. During the history of Python, the backwards-compatibility was a guiding principle, so  was unchanged until backwards-incompatible Python 3 was released.As for the bolded part about  module: if you import , then you can use arrow keys to move cursor keys around on the  line, and configurable bindings; if  is not imported in the program, then no such behaviour exists. Again, this wouldn't have been the reason for  existing in the first place; back in 1990 Python didn't support such editing at all, regardless of whether  or  was used.
For what it worths,  builtin was there in a first available Python version (0.9.1), it is from 1991. I can imagine Python 2.x had it for backwards compatibility with Python 1.x, and Python 1.x had it for backwards compatibility with 0.x. Say no to 0.x -> 1.x and 1.x -> 2.x porting issues!


Answer URL
https://docs.python.org/3/whatsnew/3.0.html
