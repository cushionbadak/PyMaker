Natural Text
I defined a dictionary like this (list is a list of integers):Now, I want to create a new list by iterating over this dictionary. In the end, I want it to look like this:And so on.So my question is: How can I realize this?I triedBut instead of the desired output I receive a Type Error (unhashable type: 'list') in line 4 of this example.
You're trying to get a dictionary item by it's value whereas you already have your value.Do it in one line using a list comprehension:result:Note that since the order in your dictionary is not guaranteed, the order of the list isn't either. You could fix the order by sorting the items according to keys:
Try this:Hope this helps.
Your immediate problem is that  is a generator yielding the values from the dictionary, not the keys, so when you attempt to do a lookup on line 4, it fails (in this case) as the values in the dictionary can't be used as keys.  In another case, say , it would fail with a , and  would not raise an error, but likely give confusing behaviour.As for your actual question, lists do not attribute any names to data, like dictionaries do; they simply store the index.Calling  will return , with any concept of , , and  being lost entirely.If you want to simply concatenate the lists in your dictionary, making a copy of the first, then calling  on it will suffice:If you're looking to keep the order of the lists' items, while still referring to them by name, look into the OrderedDict class in collections.
You've written an outer loop over keys, then an inner loop over values, and tried to use each value as a key, which is where the program failed. Simply use the dictionary's  method to iterate over key,value pairs instead:Oops, failed to parse the format desired; we were to produce each item in the inner list. Not to worry...This is a little more complex. We again take key,value pairs from the dictionary, then make an inner loop over the list that was the value and format those into strings. This produces inner sequences, so we flatten it using chain and *, and finally save the result as one list. Edit: Turns out Python 3.4.3 gets quite confused when doing this nested as generator expressions; I had to turn the inner one into a list, or it would replace some combination of k and l before doing the formatting. Edit again: As someone posted in a since deleted answer (which confuses me), I'm overcomplicating things. You can do the flattened nesting in a chained comprehension:That method was also posted by Jean-François Fabre. 
Use list comprehensions like thisOutput：
Let's initialize our dataNote that in my example, different from yours, the lists' content is not strings... aren't lists heterogeneous containers?That said, you cannot simply join the keys and the list's items, you'd better cast these value to strings using the  builtin.Now it comes the solution to your problem... I use a list comprehensionwith two loops, the outer loop comes first and it is on the items (i.e., key-value couples) in the dictionary, the inner loop comes second and it is on the items in the corresponding list.In your case, using  would be fine as well, but the current idiom for joining strings with a fixed  is the  method.  Note that  takes a SINGLE argument, an iterable, and hence in the list comprehension I used to collect the joinands in a single argument.


Answer URL
https://docs.python.org/3/library/collections.html#collections.OrderedDict
