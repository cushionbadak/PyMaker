Natural Text
Using python3.4. Here I want use singledispatch to dispatch different type in  method . The code like this :As you can see the code , I want support Vector*Vertor , This has Name errorThe question may be How Can I use class Name a Type in the class's method ? I know c++ have  font class statement . How python solve my problem ? And it is strange to see  where the  can be used in method body .update . After have A look at http://lukasz.langa.pl/8/single-dispatch-generic-functions/I can choose this way to implement :The ans is strange :  can work but  can't work. This is strange From my option  is just the same as  .Update after @Martijn Pieters's comment, I still want implement v*3 in class. So I try thisThis time . I implemet like I implement . But the error is For me static methond should act like the instance methond.
You cannot use  on methods at all, not as a decorator at least.It doesn't matter that  isn't defined here yet; the first argument to any method is always going to be , while you'd use single dispatch for the second argument here.Because decorators apply to the function objects before the class object is created, you could just as well register your 'methods' as functions instead, outside of the class body, so you have access to the  name:For non-supported types, you need to return the  singleton, not raise an exception. This way Python will try the inverse operation too.However, since the dispatch is going to key on the wrong argument () here anyway, you'll have to come up with your own single dispatch mechanism.If you really want to use  you'd have to delegate to a regular function, with the arguments inversed:As for your updates using :  is not translated to . It is instead translated to , see Special method lookup in the Python datamodel reference. This always bypasses any methods set directly on the instance.Here  is ; Python looks up the function, it won't use a bound method here. Again, because  dispatches on the first argument, always, you cannot use single dispatch directly on the methods of , because that first argument is always going to be a  instance.In other words, Python will not use the methods you set on  in ; special methods are never looked up on the instance, see Special method lookup in the datamodel documentation.
This is a little ugly, as you need to defer binding the implementation of / multiplication until after  is actually defined. But the idea is that the single-dispatch function needs the first argument to be of arbitrary type, so  will call that function with  as the second argument.


Answer URL
https://docs.python.org/3/reference/datamodel.html#special-method-lookup
https://docs.python.org/3/reference/datamodel.html#special-lookup
https://docs.python.org/3/reference/datamodel.html#special-method-lookup
https://docs.python.org/3/howto/descriptor.html
