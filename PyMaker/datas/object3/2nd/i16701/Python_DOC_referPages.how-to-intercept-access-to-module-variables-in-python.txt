Natural Text
How can implement the equivalent of a  on a class, on a module?ExampleWhen calling a function that does not exist in a module's statically defined attributes, I wish to create an instance of a class in that module, and invoke the method on it with the same name as failed in the attribute lookup on the module.Which gives:
A while ago, Guido declared that all special method lookups onnew-style classes bypass  and . Dunder methods had previously worked on modules - you could, for example, use a module as a context manager simply by defining  and , before those tricks broke.Recently some historical features have made  a comeback, the module  among them, and so the existing hack (a module replacing itself with a class in  at import time) should be no longer necessary.In Python 3.7+, you just use the one obvious way.  To customize attribute access on a module, define a  function at the module level which should accept one argument (name of attribute), and return the computed value or raise an :This will also allow hooks into "from" imports, i.e. you can return dynamically generated objects for statements such as .On a related note, along with the module getattr you may also define a  function at module level to respond to . See PEP 562 for details.
There are two basic problems you are running into here: methods are only looked up on the class(1) means any solution would have to also keep track of which module was being examined, otherwise every module would then have the instance-substitution behavior; and (2) means that (1) isn't even possible... at least not directly.Fortunately, sys.modules is not picky about what goes there so a wrapper will work, but only for module access (i.e. ; for same-module access you pretty much have to yank the methods from the substitution class and add them to  eiher with a custom method on the class (I like using ) or with a generic function (such as those already listed as answers).  One thing to keep in mind: if the wrapper is creating a new instance each time, and the globals solution is not, you end up with subtly different behavior.  Oh, and you don't get to use both at the same time -- it's one or the other.UpdateFrom Guido van Rossum:There is actually a hack that is occasionally used and recommended: a  module can define a class with the desired functionality, and then at  the end, replace itself in sys.modules with an instance of that class  (or with the class, if you insist, but that's generally less useful).  E.g.:This works because the import machinery is actively enabling this  hack, and as its final step pulls the actual module out of  sys.modules, after loading it. (This is no accident. The hack was  proposed long ago and we decided we liked enough to support it in the  import machinery.)So the established way to accomplish what you want is to create a single class in your module, and as the last act of the module replace  with an instance of your class -- and now you can play with // as needed.Note that if you use this functionality anything else in the module, such as globals, other functions, etc., will be lost when the  assignment is made -- so make sure everything needed is inside the replacement class.
This is a hack, but you can wrap the module with a class:
We don't usually do it that way.  What we do is this.Why?  So that the implicit global instance is visible.For examples, look at the  module, which creates an implicit global instance to slightly simplify the use cases where you want a "simple" random number generator.
Similar to what @Håvard S proposed, in a case where I needed to implement some magic on a module (like ), I would define a new class that inherits from  and put that in  (probably replacing the module where my custom  was defined).See the main  file of Werkzeug for a fairly robust implementation of this.
This is hackish, but...This works by iterating over the all the objects in the global namespace. If the item is a class, it iterates over the class attributes. If the attribute is callable it adds it to the global namespace as a function. It ignore all attributes which contain "__".I wouldn't use this in production code, but it should get you started.
Here's my own humble contribution -- a slight embellishment of @Håvard S's highly rated answer, but a bit more explicit (so it might be acceptable to @S.Lott, even though probably not good enough for the OP):
Create your module file that has your classes. Import the module. Run  on the module you just imported. You can do a dynamic import using  and pull the module from sys.modules.Here's your module :And in another module:Doing this dynamically:
In some circumstances the  dictionary can suffice, for example you can instantiate a class by name from the global scope:


Answer URL
https://docs.python.org/3/library/functions.html#dir
