Natural Text
Say I have a list . I want to find the 3 closest numbers to, say, 6.5. Then the returned value would be .Finding one closest number is not that tricky in python, which can be done usingBut I am trying not to put a loop around this to find k closest numbers. Is there a pythonic way to achieve the above task?
The short answerThe heapq.nsmallest() function will do this neatly and efficiently:Essentially this says, "Give me the three input values that have the lowest absolute difference from the number 6.5".The algorithm and its running timeThe algorithm for nsmallest makes a single pass over the data, keeping no more than the n best values in memory at any time (that means that it works with any input iterator, is cache-efficient, and space-efficient).   The algorithm only adds new values to the heap when a new "best" value is found.  Accordingly, it minimizes the number of comparisons made.   For example, if you are looking for the 100 best values out of 1,000,000 random inputs, it typically makes fewer than 1,008,000 comparisons (about 0.8% more compares than using min() to find the single best value).The key functions for min(), nsmallest(), and sorted() all guarantee that the key function is called exactly once per value in the input iterable.  That means that this technique will be efficient for even more complex and interesting examples of the n-closest value problem (i.e. words that sound the most alike, closest colors, smallest diffs, fewest genetic mutations, Euclidean distance, etc).Both nsmallest() and sorted() will return a list rank ordered by nearness (ties are settled by which value was seen first).For those who are interested, there is a somewhat involved analysis of expected number of comparisons here and here.  Quick summary:Average case for random inputs:  Best case for ascending inputs:  Worst case for descending inputs:   Optimizing for repeated lookupsIn the comments, @Phylliida, asked how to optimize for repeated lookups with differing start points.  The key is to pre-sort the data and then use bisect to locate the center of a small search segment:For example:Both bisect() and nsmallest() take advantage of the sorted data.  The former runs O(log2 k) time and the latter runs in O(n) time.
You could compute distances, and sort:This does the following:Create a sequence of tuples  where  is the distance to your targetSelect the first  elements of that listExtract just the number values from the result, discarding the distance
Both answers were good, and Greg was right, Raymond's answer is more high level and easier to implement, but I built upon Greg's answer because it was easier to manipulate to fit my need. In case anyone is searching for a way to find the n closest values from a list of dicts.My dict looks like this, where npi is just an identifier that I need along with the value:To get an  list (not just a list of values) , I use this:Which produces this:EDITI actually found it pretty easy to manipulate Raymond's answer too, if you're dealing with a dict (or list of lists).This will produce the same as the above output.And this will produce a dict instead.


Answer URL
https://docs.python.org/3/library/bisect.html#bisect.bisect
