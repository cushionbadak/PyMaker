Natural Text
I want to parse strings into python enums. Normally one would implement a parse method to do so. A few days ago I spotted the __new__ method which is capable of returning different instances based on a given parameter.Here my code, which will not work:When I execute my Python script, I get this message:How can I return a proper instance of a enum value?Edit 1:This Enum is used in URI parsing, in particular for parsing the schema. So my URI would look like thisSo after a simple string.split operation I would pass the first part of the URI to the enum creation.type should now contain a value of the enum Types with 3 possible values (Unknown, Source, NetList)If I would allow aliases in the enum's member list, it won't be possible to iterate the enum's values alias free.
Yes, you can override the  method of an  subclass to implement a parse method if you're careful, but in order to avoid specifying the integer encoding in two places, you'll need to define the method separately, after the class, so you can reference the symbolic names defined by the enumeration.Here's what I mean:UpdateHere's a more table-driven version that helps eliminates some of the repetitious coding that would otherwise be involved:
The  method on the your  type is used for creating new instances of the enum values, so the , , etc. singleton instances. The enum call (e.g.  is handled by , which you could subclass.Using name aliases fits your usecasesOverriding  is perhaps overkill for this situation. Instead, you can easily use name aliases:Here  is an alias and will return the same object as . You then access members by names (using  index access); so  works and returns .Your assertion that it won't be possible to iterate the enum's values alias free is incorrect. Iteration explicitly doesn't include aliases:Iterating over the members of an enum does not provide the aliasesAliases are part of the  ordered dictionary, if you still need access to these.A demo:The only thing missing here is translating unknown schemas to ; I'd use exception handling for that:Overriding If you want to treat your strings as values, and use calling instead of item access, this is how you override the  method of the metaclass:Demo:Note that we translate the string value to integers here and leave the rest to the original Enum logic.Fully supporting value aliasesSo,  supports name aliases, you appear to want value aliases. Overriding  can offer a facsimile, but we can do better than than still by putting the definition of the value aliases into the enum class itself. What if specifying duplicate names gave you value aliases, for example?You'll have to provide a subclass of the  too as it is that class that prevents names from being re-used. We'll assume that the first enum value is a default:This then lets you define aliases and a default in the enum class:Demo:
I think the by far easiest solution to your problem is to use the functional API of the  class which gives more freedom when it comes to choosing names since we specify them as strings:This creates an enum with name aliases. Mind the order of the entries in the  list. The first one will be chosen as default value (and also returned for ), further ones are considered as aliases but both can be used:To use the  property as a return value for  we replace the default version from :Note that we also replace the  method which is called by .
I don't have enough rep to comment on the accepted answer, but in Python 2.7 with the enum34 package the following error occurs at run-time:"unbound method <lambda>() must be called with instance MyEnum as first argument (got EnumMeta instance instead)"I was able to correct this by changing:to the following, wrapping the lambda in with staticmethod():This code tested correctly in both Python 2.7 and 3.6.
Is it possible to override  in a python enum to parse strings to an instance?In a word, yes.  As martineau illustrates you can replace the  method after the class has been instanciated (his original code):and also as his demo code illustrates, if you are not extremely careful you will break other things such as pickling, and even basic member-by-value lookup:Martijn showed is a clever way of enhancing  to get what we want:but this puts us having duplicate code, and working against the Enum type.The only thing lacking in basic Enum support for your use-case is the ability to have one member be the default, but even that can be handled gracefully in a normal  subclass by creating a new class method.The class that you want is:and in action:If you really need value aliases, even that can be handled without resorting to metaclass hacking:which gives us:


Answer URL
https://docs.python.org/3/library/enum.html#duplicating-enum-members-and-values
https://docs.python.org/3/library/enum.html#programmatic-access-to-enumeration-members-and-their-attributes
https://docs.python.org/3/library/enum.html#iteration
