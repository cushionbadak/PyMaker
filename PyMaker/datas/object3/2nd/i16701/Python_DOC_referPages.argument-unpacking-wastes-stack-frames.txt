Natural Text
When a function is called by unpacking arguments, it seems to increase the recursion depth twice. I would like to know why this happens.Normally:With an unpacking call:In theory both should reach about 1000:This happens on CPython 2.7 and CPython 3.3.On PyPy 2.7 and PyPy 3.3 there is a difference, but it is much smaller (1480 vs 1395 and 1526 vs 1395).As you can see from the disassembly, there is little difference between the two, other than the type of call ( vs ):
The exception message actually offers you a hint. Compare the non-unpacking option:with:Note the addition of the . This exception is specific to the  function. You won't see this exception when you set an odd recursion limit:because that is the specific exception raised in the  frame evaluation code inside :Note the empty message there. This is a crucial difference.For your 'regular' function (no variable arguments), what happens is that an optimized path is picked; a Python function that doesn't need tuple or keyword argument unpacking support is handled directly in the  function of the evaluation loop. A new frameobject with the Python bytecode object for the function is created, and run. This is one recursion check.But for a function call with variable arguments (tuple or dictionary or both), the  call cannot be used. Instead,  (extended call) is used, which handles the argument unpacking, then uses  to invoke the function.  does a recursion limit check, and 'calls' the function object. The function object is invoked via the  function, which calls , which calls , which makes the second recursion limit check.TL;DR versionPython functions calling Python functions are optimised and bypass the  C-API function, unless argument unpacking takes place. Both Python frame execution and  make recursion limit tests, so bypassing  avoids incrementing the recursion limit check per call.More places with 'extra' recursion depth checksYou can grep the Python source code for  for other locations where recursion depth checks are made; various libraries, such as  and  use it to avoid parsing structures that are too deeply nested or recursive, for example. Other checks are placed in the  and   implementations, rich comparisons (, , , etc.), handling the  callable object hook and handling  calls.As such, you can hit the recursion limit much faster still:


Answer URL
https://docs.python.org/3/c-api/object.html#c.PyObject_CallObject
