Natural Text
I need to call a task every second (say) to poll some sensor data on a piece of hardware. In the unit test, all I want to do, is to check that the right methods are called and that errors (such as sensor has blown up or vanished) do get caught.Here is a toy example that mimics the real code:As expected, running this will block forever.How can I cancel the  task so that the unit test does not block?A work around would be to split the loop into another function and define it as no testable. I want to avoid doing that.  Note also that messing with  (to call  or some such) does not work either as it is there just so the toy example test can assert something.
As it stands, the way you've designed the  method is the cause of your issue.Due to the  method, it will always be a blocking operation. I assume, since you're using  you want  to be non-blocking on the main thread?If thats the case,  actually comes with an event loop built in, see this comment for an example., which will run an task on another thread and gives you ways to control that task.Documentation/samples for the event loop are here
Based off duFF's answer, here is the fixed toy code:When run:


Answer URL
https://docs.python.org/3/library/asyncio-eventloop.html#event-loop-examples
