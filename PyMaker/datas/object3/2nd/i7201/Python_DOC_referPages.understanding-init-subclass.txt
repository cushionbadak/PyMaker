Natural Text
I finally upgraded my python version and I was discovering the new features added. Among other things, I was scratching my head around the new  method. From the docs:This method is called whenever the containing class is subclassed. cls  is then the new subclass. If defined as a normal instance method, this  method is implicitly converted to a class method.So I started to playing around with it a little bit, following the example in the docs:Produces this output:I understand that this method is called after the subclass definition, but my questions are particularly about the usage of this feature. I read the PEP 487 article as well, but didn't help me much. Where would this method be helpful? Is it for:the superclass to register the subclasses upon creation?forcing the subclass to set a field at definition time?Also, do I need to understand the  to fully comprehend its usage?
 and  are orthogonal mechanisms - they're not tied to each other, just described in the same PEP. Both are features that needed a full-featured metaclass before. The PEP 487 addresses 2 of the most common uses of metaclasses:how to let the parent know when it is being subclassed ()how to let a descriptor class know the name of the property it is used for ()As the PEP says:While there are many possible ways to use a metaclass, the vast majority of use cases falls into just three categories: some initialization code running after class creation, the initialization of descriptors and keeping the order in which class attributes were defined.The first two categories can easily be achieved by having simple hooks into the class creation:An  hook that initializes all subclasses of a given class.upon class creation, a  hook is called on all the attribute (descriptors) defined in the class, andThe third category is the topic of another PEP, PEP 520.Notice also, that while  is a replacement for using a metaclass in this class's inheritance tree,  in a descriptor class is a replacement for using a metaclass for the class that has an instance of the descriptor as an attribute.
PEP 487 sets out to take two common metaclass usecases and make them more accessible without having to understand all the ins and outs of metaclasses. The two new features,  and  are otherwise independent, they don't rely on one another. is just a hook method. You can use it for anything you want. It is useful for both registering subclasses in some way, and for setting default attribute values on those subclasses.We recently used this to provide 'adapters' for different version control systems, for example:This trivially let us define handler classes for specific repositories without having to resort to using a metaclass or decorators.
The main point of  was, as the title of the PEP suggest, to offer a simpler form of customization for classes. It's a hook that allows you to tinker with classes w/o the need to know about metaclasses, keep track of all aspects of class construction or worry about metaclass conflicts down the line. As a message by Nick Coghlan on the early phase of this PEP states:The main intended readability/maintainability benefit is from the  perspective of more clearly distinguishing the "customises subclass  initialisation" case from the "customises runtime behaviour of  subclasses" case.A full custom metaclass doesn't provide any indication of the scope of  impact, while  more clearly indicates that there's no  persistent effects on behaviour post-subclass creation.Metaclasses are considered magic for a reason, you don't know what their effects will be after the class will be created. , on the other hand, is just another class method, it runs once and then it's done. (see its documentation for exact functionality.) The whole point of PEP 487 is about simplifying (i.e removing the need to use) metaclasses for some common uses. takes care of post-class initialization while   (which makes sense only for descriptor classes) was added to simplify initializing descriptors. Beyond that, they aren't related.The third common case for metaclasses (keeping definition order) which is mentioned, was also simplified. This was addressed w/o a hook, by using an ordered mapping for the namespace (which in Python 3.6 is a , but that's an implementation detail :-)
I would like to add some references related to metaclasses and  that may be helpful.Background was introduced as an alternative to creating metaclasses.Here is a 2-minute summary of PEP 487 in a talk by one of the core developers, Brett Cannon.Recommended ReferencesGuido van Rossum's blog post on the early history of metaclasses in PythonJake Vanderplas's blog post looking more deeply on implementing metaclasses


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__init_subclass__
https://docs.python.org/3/reference/datamodel.html#object.__set_name__
https://docs.python.org/3/reference/datamodel.html#object.__init_subclass__
