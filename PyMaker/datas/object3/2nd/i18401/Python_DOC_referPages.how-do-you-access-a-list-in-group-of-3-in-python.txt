Natural Text
This question already has an answer here:How do you split a list into evenly sized chunks?                    57 answers                The code above takes two lists and splits them into groups of three, but when I go to check each individual element, it makes a new list of three, moving along one element each time.i.e. this is one list made:But these are the elements it checks:How do I make it so that each group of three is checked and then it moves on to the next?My list is split into groups of three (becoming items in the list), I want to check each of those items for their corresponding amino acid (in a dictionary), but the  program keeps making new lists, e.g. the user enters AAATTT, then the program checks:rather than just AAA and TTT
With a nod to Óscar, who figured out the bulk of the problem, I think the OP is asking about something like this:The list  was an unintended result of the OP's code, because each triplet contains the last two characters of the previous one.Edit:  Also, this chunk of code:should probably be this instead:The reason is that checking for membership with  is much faster than looping over the members.This will only work if  is a dict.  If  is a list, the same syntax will work to check whether  is in , but  is probably a mistake.
There are two ways to do this: slices, or a shared iterator.The other answers show the slice method—which I think you could have gotten correct, if you just knew/remembered the step=3 to :The only major downside of this method is that it only works on a list or other sequence, not a general iterable. In your current code, this doesn't matter, because the thing you want to call it on is a list.But it's worth knowing the alternative too: just asks a sequence or other iterable for a single-pass iterator over its contents.Then  just advances them in lockstep, as usual.Because all three of 's arguments are references to the exact same iterator, when it tries to advance one, it advances all of them. (This is why we can't just do —then you'd have three separate iterators.)But what if you want to group by 2, or 5? Writing separate functions for  and  and so on wouldn't be very nice.If we had a sequence of  references of the iterator, we could use  syntax, as described in the tutorial under Unpacking Argument Lists, to just call .And we can easily get such a sequence by using the  repetition operator: . (If you don't understand why that ends up with  references to one iterator, instead of  separate iterators, read the Python FAQ's entry on How do I create a multidimensional list?.)And you can put that all together into a one-liner:If there's a partial group left over, this will drop it, because that's what  does. So if you'd rather do something different in that case, you can just replace  with a different function—e.g., to pad the partial group with spaces, just:The  recipes in the docs have a function caller  which does this for you.
You mean, like this?The above will iterate over the original list and create sublists of at most three elements - notice that the last sublist can have 1, 2 or 3 elements.


Answer URL
