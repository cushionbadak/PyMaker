Natural Text
Does argparse provide built-in facilities for having it parse groups or parsers into their own namespaces? I feel like I must be missing an option somewhere.Edit: This example is probably not exactly what I should be doing to structure the parser to meet my goal, but it was what I worked out so far. My specific goal is to be able to give subparsers groups of options that are parsed into namespace fields. The idea I had with parent was simply to use common options for this same purpose.Example:This is what I get, obviously:But this is what I am really after:And then even more groups of options already parsed into namespaces:I've found a related question here but it involves some custom parsing and seems to only covers a really specific circumstance.Is there an option somewhere to tell argparse to parse certain groups into namespaced fields?
If the focus is on just putting selected arguments in their own , and the use of subparsers (and parents) is incidental to the issue, this custom action might do the trick.There are various ways of specifying the  name.  It could be passed as an argument when defining the Action.  It could be added as parameter.  Here I chose to parse it from the  (so  can get the value of .I had to add  so a  entry does not appear in the main namespace.   Result:If you need default entries in the nested namespaces, you could define the namespace before hand:result as before, except for:
I'm not entirely sure what you're asking, but I think what you want is for an argument group or sub-command to put its arguments into a sub-namespace.As far as I know,  does not do this out of the box. But it really isn't hard to do by postprocessing the result, as long as you're willing to dig under the covers a bit. (I'm guessing it's even easier to do it by subclassing , but you explicitly said you don't want to do that, so I didn't try that.)Now, the list of all destinations for  options is:And the key-value pairs in  is:So, all we have to to is move the ones that match. It'll be a little easier if we construct dictionaries to create the namespaces from:And that's it;  looks like:Of course in this case, we've got one static group. What if you wanted a more general solution? Easy.  is a list of all groups, but the first two are the global positional and keyword groups. So, just iterate over , and do the same thing for each that you did for  above.What about sub-commands instead of groups? Similar, but the details are different. If you've kept around each  object, it's just whole other . If not, but you did keep the  object, it's a special type of , whose  is a dict whose keys are the subparser names and whose values are the subparsers themselves. If you kept neither… start at  and figure it out from there.At any rate, once you know how to find the names you want to move and where you want to move them, it's the same as with groups.If you've got, in addition to global args and/or groups and subparser-specific args and/or groups, some groups that are shared by multiple subparsers… then conceptually it gets tricky, because each subparser ends up with references to the same group, and you can't move it to al of them. But fortunately, you're only dealing with exactly one subparser (or none), so you can just ignore the other subparsers and move any shared group under the selected subparser (and any group that doesn't exist in the selected subparser, either leave at the top, or throw away, or pick one subparser arbitrarily).
Nesting with  subclasses is fine for one type of Action, but is a nuisance if you need to subclass  several types (store,  store true, append, etc).  Here's another idea - subclass Namespace.  Do the same sort of name split and setattr, but do it in the Namespace rather than the Action.  Then just create an instance of the new class, and pass it to .  producing:The  for this namespace (needed for actions like count and append) could be:I've proposed several other options, but like this the best.  It puts the storage details where they belong, in the Namespace, not the parser.
Starting from abarnert's answer, I put together the following MWE++ ;-) that handles multiple configuration groups with similar option names.Then you can call it like this (mnemonic:  are options for "mod1", etc.):
In this script I have modified the  method of the argparse._SubParsersAction.  Instead of passing the  on to the subparser, it passes a new one.  It then adds that to the main .  I only change 3 lines of .This produces:I used  to test how extra strings are passed back to the main parser.I dropped the  stuff because it does not add anything to this namespace change.  it is just a convenient way of defining a set of arguments that several subparsers use.   does not keep a record of which arguments were added via , and which were added directly.  It is not a grouping tool don't help much either.  They are used by the Help formatter, but not by .I could subclass  (instead of reassigning ), but then I'd have change the .
Please check out the argpext module on PyPi, it may help you!


Answer URL
