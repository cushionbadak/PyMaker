Natural Text
This question already has an answer here:Merge two or more lists with given order of merging                    2 answers                I have one list with boolean values likeand two different lists for example like:I just want to replace True with the values from  and False with the values from .or make a new list with the sequence from  and values from  and .The result should be my code so far:but this creates a list match longer than 5.How can i do this?
Ok, I couldn't help myself:This makes use of some boolean expression features:a boolean  expression will NOT evaluate the second operand if the first operand is Falsea boolean  expression will return the second operand (the actual object) if both operands evaluate to Truea boolean  expression will return the first object that evaluates to TrueA potential problem would be if any items in  or  evaluate to False.  Also this isn't as readable as the ternary in the first solution.But it was fun.I guess I'll add that after looking at this again, I probably shouldn't have reassigned the original list names - I should have chosen something different for the iterator names.  Once exhausted, the iterators cannot be reset and since the list names were reassigned, the original list information is lost.
Assuming that there are the correct number of  and  entries in , you can do this efficiently by creating iterators of the other two lists. This is more efficient than ing from the front of the lists.outputThe  construction works because  has a numeric value of 0, and  has a numeric value of 1, so we can use the boolean values of  to index into the  list.TimingsI decided to write a  script to compare the speeds of the various algorithms posted here, as well as vaultah's code from the dupe target question.To test these algorithms I've put them all into functions. To get accurate timing data  runs the function multiple times. The algorithms that use  consume the lists they pop from, so I had to add code to those functions to create copies of those lists. Obviously, that copying process slows those functions down, and in some applications it may not matter that the input data lists get destroyed, but I feel that the copying time needs to be included to fairly compare the speeds of these functions for more general use. measures wall clock time not CPU time, so the timings will be affected by the other processes running on the system. So when running  code it's a good idea to reduce the system load as much as possible. Ideally, you should shut down Net access, or at least avoid using your browser while the tests are running. And definitely don't listen to music or watch videos. :)The code below runs on Python 2.6+ as well as Python 3. I tested it on Python 2.6.6 and Python 3.6.0.Python 3 outputPython 2 outputThese results are from my rather ancient 32 bit single-core 2GHZ machine with 2GB of RAM running a Debian derivative of Linux.

My first idea is to use a  to choose between the  values (car) and the  values (a).Since, the values are in order, you can make an iteration.Here is a solution which use  and  functions which are efficient:You can generalize this solution if you have more complex choices than True/False.
Code by @Alex is a great one, but complexity is a little bad due to that pop(0) operation. To avoid that-`As for other answers, I am a bit surprised to see the use of all those complex syntax and data structures for such a simple task.
Just another option much like the one from @AlexL but with the  statements replaced by a dictionary look-up.


Answer URL
https://docs.python.org/3/library/timeit.html
