Natural Text
I'm taking my first computing science course, and we just learned about class implementation and inheritance.  In particular, we just covered method overriding and how classes we define inherit from the  superclass by default.  As one of my examples trying out this particular case of inheritance, I used the following code:I expected the result from , because as I understand it the default for  is to check if they're the same objects or not, not worrying about the contents.  Which is ,  and  have the same contents but are different objects.  The second one surprised me though.So my questions: I thought  and  were synonymous and made exactly the same call.  Why do these produce differing output?  And why does the second conditional return ?
The  value you're seeing returned from your inherited  method is a special builtin value used as a sentinel in Python. It can be returned by  methods that implement mathematical or comparison operators to indicate that the class does not support the operator that was attempted (with the provided arguments).This can be more useful than raising an exception, as it allows Python to fall back to other options to resolve the operator use. For instance, if you do , Python will first try to run . If that returns , it will next try the "reverse" version, , which may work if  is a more sophisticated type than  is.In the case you're asking about, , Python first tries , then , and finally  (which will always evaluate to a Boolean value). Since  returns  in all cases, your class falls back to the identity comparison when you use the real operator, but shows you the  sentinel when you call  directly.
The  operator is equivalent to the  function, which will internally call the  method of the left operand if it exists to try to determine equality. This is not the only thing it will do, and if  does not exist, as is the case here, it will do other checks, such as checking whether the two are the same object, or  pre-Python 3.So in a nutshell, your confusion arises from this assumption, which is incorrect:I thought (x==y) and x.__eq__(y) were synonymous and made exactly the same callIn fact,  and  are synonymous, and  is one of the things  will try to check.
If you have implemented the  function for a class, it gets called when you use . Otherwise  relies on a default comparison logic.  does not get implemented automatically when you define a class.


Answer URL
https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy
