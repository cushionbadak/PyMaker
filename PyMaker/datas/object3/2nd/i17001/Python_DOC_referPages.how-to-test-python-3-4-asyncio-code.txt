Natural Text
What's the best way to write unit tests for code using the Python 3.4  library? Assume I want to test a TCP client ():When running this test case with the default test runner, the test will always succeed as the method executes only up until the first  instruction, after which it returns before executing any assertions. This causes tests to always succeed.Is there a prebuilt test runner that is able to handle asynchronous code like this?
I temporarily solved the problem using a decorator inspired by Tornado's gen_test:Like J.F. Sebastian suggested, this decorator will block until the test method coroutine has finished. This allows me to write test cases like this:This solution probably misses some edge cases.I think a facility like this should added to Python's standard library to make  and  interaction more convenient out of the box.
, suggested by Marvin Killing, definitely can help -- as well as direct calling But I also strongly recommend to recreate new event loop for every test and directly pass loop to API calls (at least  itself accepts  keyword-only parameter for every call that need it).Likethat isolates tests in test case and prevents strange errors like longstanding coroutine that has been created in  but finished only on  execution time.
pytest-asyncio looks promising:
Really like the  wrapper mentioned in https://stackoverflow.com/a/23036785/350195, here is an updated version for Python 3.5+
Use this class instead of  base class:
You can also use  that takes similar approach as @Andrew Svetlov, @Marvin Killing answers and wrap it in easy to use  class:As you can see the async case is handled by . It supports also synchronous test. There is a possibility to provide custom event loop, just override .If you prefer (for some reason) the other TestCase class (eg ), you might use  decorator:
I usually define my async tests as coroutines and use a decorator for "syncing" them:


Answer URL
https://docs.python.org/3/tutorial/controlflow.html#function-annotations
