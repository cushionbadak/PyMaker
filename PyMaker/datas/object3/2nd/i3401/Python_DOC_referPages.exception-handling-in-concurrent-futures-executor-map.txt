Natural Text
From https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor.mapIf a func call raises an exception, then that exception will be raised  when its value is retrieved from the iterator.The following snippet only outptus the first exeption (Exeption: 1), and stops. Does this contradict the above statement? I expect the following to print out all exceptions in the loop.
The  method returns a generator which allows to iterate through the results once ready.Unfortunately, it is not possible to resume a generator after an exception occurs. From PEP 255.If an unhandled exception-- including, but not limited to, StopIteration --is raised by, or passes through, a generator function, then the exception is passed on to the caller in the usual way, and subsequent attempts to resume the generator function raise StopIteration. In other words, an unhandled exception terminates a generator's useful life.There are other libraries such as  which allow to continue the iteration after an error occurs. Check the examples in the documentation.
As mentioned above, unfortunately executor.map's API is limited and only lets you get the first exception. Also, when iterating through the results, you will only get values up to the first exception.To answer your question, if you don't wan to use a different library, you can unroll your map and manually apply each function:This allows you to handle each future individually.
Ehsan's solution is good, but it may be slightly more efficient to take the results as the are completed instead of waiting for sequential items in the list to finish. Here is an example from the library docs.


Answer URL
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor.map
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor.map
https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor-example
