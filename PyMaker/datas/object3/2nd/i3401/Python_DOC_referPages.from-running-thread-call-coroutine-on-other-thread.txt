Natural Text
I'm replacing part of an existing program. That original program uses threads. There's this particular class which inherits from  which functionality I need to replace but I need to keep the interface the same.The functionality I'm integrating is packaged in a library which uses  a lot.The original calls to the class I'm replacing go something like this:I've gotten to a point where my replacing class inherits from  too and I can connect, from within the  method to my backends via the client library:Running this code throws an exception:I sort of get what's going on here. In the  method things worked out because the same thread running the event loop was the caller. In the other case an other thread was the caller hence the problem. As you might have noticed I was hoping the problem would have been solved by using the same event loop. Alas, that didn't work out.I really want to keep the interface exactly as it is otherwise I'm refactoring for the remainder of the year. I could relatively easily pass arguments to the constructor of the  class. I've tried passing in an event loop created on the main thread but the result was the same.(Note that this is the opposite problem this author has: Call coroutine within Thread)
When scheduling a coroutine from a different thread, you must use . For example: schedules the coroutine with the event loop in a thread-safe way and returns a . You can use the returned future to simply wait for the result as shown above, but you can also pass it to other functions, poll whether the result has arrived, or implement timeouts.When combining threads and asyncio, remember to make sure that all interfacing with the event loop from other threads (even to call something as simple as  to implement ) is done using  and .


Answer URL
https://docs.python.org/3/library/asyncio-task.html#asyncio.run_coroutine_threadsafe
https://docs.python.org/3/library/concurrent.futures.html#future-objects
