Natural Text
I'm writing an application which reads text data and acts on it. The text data could come from a TCP port, or from a text file (which contains data earlier read from the TCP port and archived). I'm writing it in Python 3, and using asyncio seems like the obvious tool to use. It's straightforward to use the Streams API  to open the TCP port and read from it. The asyncio architecture has the concept a Transport and a Protocol for the lower and upper layers of input-output. So, it seems I should implement a Transport for reading text from a file, and pass it to the Protocol. That will let me keep the rest of my application decoupled from whether the text data came from the TCP port or the file.But I'm having a hard time figuring out how to tell asyncio to use my preferred Transport. the Streams API  has a parameter list which is all about the TCP port Transport, with no way to specify a different Transport, much less parameters like file path.   turns around and calls . This is just as specialised for the TCP Port Transport. Still now way to provide a different Transport.The implementation of  gets its Transport object from either  or . These have alternative implementations in  and , so we are clearly past the point where a File Transport ought to have been selected.Am I missing some place where asyncio lets me tell it what Transport to use?  Or is asyncio really coded down to its roots to use its own TCP port and UDP datagram Transports, and nothing else? If I want to allow the possibility of using my own Transport with asyncio, it looks like I have to extend the event loop, or write more a flexible alternative  that is coded to a particular event loop implementation.  That seems like a lot of work, and vulnerable to changes in the implementation.Or, is it a foolish errand to handle file input with a Transport?  Should I instead structure my code to say:
According to the documentation of API , it takes a protocol and creates a streaming transport, which is a TCP connection. So it is not supposed to be an API for custom transports.However, the idea to reuse the same protocol for either TCP transports or custom file transports is valid. It won't be a "completely different implementation", but at least not using . Let's assume it is :Then you would have something like this:


Answer URL
https://docs.python.org/3/library/asyncio.html
https://docs.python.org/3/library/asyncio-stream.html#stream-functions
https://docs.python.org/3/library/asyncio-protocol.html#transports
https://docs.python.org/3/library/asyncio-protocol.html#protocols
https://docs.python.org/3/library/asyncio-stream.html#stream-functions
https://docs.python.org/3/library/asyncio-eventloop.html#creating-connections
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.create_connection
