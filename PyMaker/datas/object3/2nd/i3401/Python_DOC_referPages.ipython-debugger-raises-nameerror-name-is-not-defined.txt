Natural Text
I can't understand the following exception that is raised in this Python debugger session:Why is it sometimes telling me  is not defined and other times not?Incidentally, this is the code immediately prior to the debugger starting:I am using Python 3.6 running in PyCharm.AMENDED UPDATE:After more testing it appears that local variables are not visible within list comprehensions within a  session when I do the following from an iPython REPL or in PyCharm:But in a regular Python REPL it works:I tested above with versions 3.4, 3.5, 3.6 so it does not appear to be version dependent.UPDATE 2Please note, the above test ('AMENDED UPDATE') is problematic because it uses  in the interactive REPL.  Also, the original problem is not limited to iPython.See answer by user2357112 below for a comprehensive explanation of what is going on here.Sorry if I caused any confusion!
You've got two core problems here. The first is that (when calling  interactively in IPython) you're debugging IPython's guts instead of the scope you wanted. The second is that list comprehension scoping rules interact badly with cases where the variables present in enclosing scopes can't be determined statically, such as in debuggers or class bodies.The first problem pretty much only happens when typing  into an IPython interactive prompt, which isn't a very useful thing to do, so the simplest way to avoid the problem is to just not do that. If you want to do it anyway, you can enter the  command a few times until pdb says you're out of IPython's guts. (Don't overshoot, or you'll end up in a different part of IPython's guts.)The second problem is an essentially unavoidable interaction of heavily entrenched language design decisions. Unfortunately, it's unlikely to go away. List comprehensions in a debugger only work in a global scope, not while debugging a function. If you want to build a list while debugging a function, the easiest way is probably to use the  command and write a  loop.Here's the full combination of effects going into this. triggers pdb on the next trace event, not at the point where  is called.The trace function mechanism used by pdb and other Python debuggers only triggers on certain specific events, and "when a trace function is set" is unfortunately not one of those events. Normally, the next event is either a  event for the next line or a  event for the end of the current code object's execution, but that's not what happens here.IPython sets a displayhook to customize expression statement handling.The mechanism Python uses to display the result of expression statements is . When you do  at the interactive prompt: is what prints the  instead of discarding it. It also sets . When the result of an expression statement is , such as with the expression ,  does nothing, but it's still called.IPython replaces  with its own custom handler, responsible for printing the  thingy, for setting entries in the  record, for calling IPython custom pretty-printing, and for all sorts of other IPython conveniences. For our purposes, the important thing is that IPython's displayhook is written in Python, so the next trace event is a  event for the displayhook.pdb starts debugging inside IPython's displayhook.List comprehensions create a new scope.People didn't like how list comprehensions leaked the loop variable into the containing scope in Python 2, so list comprehensions get their own scope in Python 3.pdb uses , which interacts really poorly with closure variables.Python's closure variable mechanism relies on static scope analysis that's completely incompatible with how  works. Thus, new scopes created inside  have no access to closure variables; they can only access globals.Putting it all together, in IPython, you end up debugging the IPython displayhook instead of the scope you're running interactive code in. Since you're inside IPython's displayhook, your  assignment goes into the displayhook's locals. The subsequent list comprehension would need access to the displayhook's locals to access , but that would be a closure variable to the list comprehension, which doesn't work with .Outside of IPython,  is written in C, so pdb can't enter it, and there's no  event for it. You end up debugging the scope you intended to debug. Since you're in a global scope,  goes in globals, and the list comprehension can access it.You would have seen the same effect if you tried to run  while debugging any ordinary function.


Answer URL
https://docs.python.org/3/library/sys.html#sys.settrace
https://docs.python.org/3/library/sys.html#sys.displayhook
