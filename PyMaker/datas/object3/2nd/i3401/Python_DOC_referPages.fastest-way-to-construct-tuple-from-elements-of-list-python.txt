Natural Text
I have 3 NumPy arrays, and I want to create tuples of the i-th element of each list. These tuples represent keys for a dictionary I had previously defined.Ex:These tuples represent keys of a dictionary I have previously defined (essentially, as input variables to a previously calculated function). I had read that this is the best way to store function values for lookup.My current method of doing this is as follows:This works, but is obviously slow. Is there a way to vectorize this operation, or make it faster in any way? I'm open to changing the way I've stored the function values as well, if that is necessary. EDIT: My apologies for the question being unclear. I do in fact, have NumPy arrays. My mistake for referring to them as lists and displaying them as such. They are of the same length. 
Your question is a bit confusing, since you're calling these NumPy arrays, and asking for a way to vectorize things, but then showing lists, and labeling them as lists in your example, and using list in the title. I'm going to assume you do have arrays.If so, you can stack these up in a 2D array:And then you can just transpose that:This is better than vectorized; it's constant-time. NumPy is just creating another view of the same data, with different striding so it reads in column order instead of row order.As miradulo points out, you can do both of these in one step with :But I suspect you're actually going to want  as a value in its own right. (Although I admit I'm just guessing here at what you're trying to do…)And of course if you want to loop over these rows as 1D arrays instead of doing further vectorized work, you can:Of course, you can convert them from 1D arrays to tuples just by calling  on each row. Or… whatever that  is supposed to be (it doesn't look like a dictionary—there's no key-value pairs, just values), you can do that.If you're worried about the time to look up a tuple of keys in a dict,  in the  module has a C-accelerated version. If  is a , or a , or whatever, you can do this:Meanwhile, I decided to slap together a C extension that should be as fast as possible (with no error handling, because I'm lazy it should be a tiny bit faster that way—this code will probably segfault if you give it anything but a dict and a tuple or list):Times for looking up 100 random keys out of a 10000-key dictionary on my laptop with python.org CPython 3.7 on macOS:: 1.6µs: 1.8µscomprehension:  3.4µspure-Python : 6.7µsSo, I'm pretty sure anything you do is going to be fast enough—that's only 34ns/key that we're trying to optimize. But if that really is too slow,  does a good enough job moving the loop to C and cuts it roughly in half, which is pretty close to the best possibly result you could expect. (It's hard to imagine looping up a bunch of boxed-value keys in a hash table in much less than 16ns/key, after all.)
Define your 3 lists. You mention 3 arrays, but show lists (and call them that as well):Now create a dictionary with tuple keys:Accessing elements from that dictionary with your code:Now for an array equivalent - turn the lists into a 2d array:Access the same dictionary elements.  If I used  I could have omitted the , but that's slower.  (array transpose is fast)Notice that this is substantially slower.  Iteration over an array is slower than iteration over a list.   You can't access elements of a dictionary in any sort of numpy 'vectorized' fashion - you have to use a Python iteration.I can improve on the array iteration by first turning it into a list:Array construction times:With the pure Python  (from v3.6.3) there's no savings:and if I move the getter definition out of the time loop:


Answer URL
https://docs.python.org/3/library/operator.html#operator.itemgetter
