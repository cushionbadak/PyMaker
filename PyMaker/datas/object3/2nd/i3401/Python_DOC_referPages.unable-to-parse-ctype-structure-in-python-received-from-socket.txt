Natural Text
I have a python client connected to an embedded server, which we communicate using c structure, am able to send the structure to the server and he is able to receive and parse my structure, the socket response is again a structure which I am unable to parse, there is no change in the structure format.while trying to parse the struct data getting an errorBuffer size too small (24 instead of at least 93 bytes)Please do help....
Starting with the ctypes doc page: [Python]: ctypes - A foreign function library for Python.There's a design problem here. Imagine the following scenario: the other part sends the header + data (2 times) like:15 bytes ( = 15), and 15 extra bytes after the ones corresponding to the struct25 bytes ( = 25), and 25 extra bytes after the ones corresponding to the structYou can't model that scenario with a  defined statically. What you need to do, is split it in 2 (header and data) sections, and every time you want to get a message:Read the headerLook in the header for Read exactly  bytes as dataThis is the general solution, which works for all such cases. If there are particularities in your situation, other approaches - which are either simpler (from code PoV) either faster - could be used, but those will only work for those particularities. But since the question doesn't mention any such particularities (it's not even a mcve -  as the code doesn't compile OOTB), I'm going to stick with the general solution. Note that it's the same as [SO]: multiple send from server to client python (@CristiFati's answer).code.py:Notes:The largest function () is just used for printing an objectI modified a bit your original buffer to actually have something to work with is the function that attempts to convert the existing buffer into an  (which is different than the one in the question which is now ) instance:It expects a buffer (meaning that it's already read). That is because I didn't want to create a whole server / client app and exchange messages. Actually I got rid of all the socket related code (as the protocol that I'm trying to illustrate doesn't really depend on it). Probably the final implementation should rely on a socket instead of a buffer, and only read the required amount of data from itThe  class is created on the fly for each message (it's not global like  for example) since  can only be set onceIf the buffer is too small  is raisedThe 2nd value returned is the number of bytes that were "consumed" for this instance; if for example the input buffer is longer, the remaining ones might belong to the next messageOutput:


Answer URL
https://docs.python.org/3/library/ctypes.html#module-ctypes
