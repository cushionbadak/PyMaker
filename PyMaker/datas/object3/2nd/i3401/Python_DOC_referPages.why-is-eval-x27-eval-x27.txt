Natural Text
I'm very confused with python's eval():I tried  and it evaluates to . Can somebody explain why this is the case? Both expressions evaluate to . I understand why  does (the string evaluated has a single character, which is an escaped hexadecimal representing an apostrophe), but shouldn't  be equal to ?Secondly, adding to the confusion, if I set the following variables,then  is again , but  is . Why is that?
According to the docs,  "parses and evaluates the argument as a python expression". In other words, it's applying the same processing that is applied if you write  inside a program or the IDLE. In this example,  gets turned into a newline-character (which, note, is not identical to the literal ).If you typed  into the IDLE, you'd get . The  is escaped because of the backslash and thus changed during evaluation. If you escape the backslash, then  is not changed during evaluation. Instead, you simply get a string with a backslash followed by .Now if you evaluated that string again, you only have one backslash left - seemingly escaping . Thus, it is changed to . Another way to look at this:  evaluates the argument twice, but it is only changed the first time, to .  also evaluates the argument twice, first to , then to . Here's an easier example to demonstrate how this works: Look at it like this: The right hand side of  contains two components: the information that  should be of type string, expressed using the two , and the value of that string, expressed by the character . The separation of these two aspects is done during evaluation of the code you write. The string object itself never sees the  during initialization.So in the above example, after the first line, we have  of type  with value . If you evaluate that again, the  are interpreted this time not as part of the value of  but as the type of . So  basically transforms the string  to , which, if you want to use that using the language Python, you have to write as  and .
For  the backslash escape is expanded during parsing, so this is literally.  only strips the backslash, i.e. it is equal to .A direct  on the string literals adds another iteration of special character expansion: In the first case,  is a valid escape sequence yielding . The second case is the same as above. When you use variable names, only one round of unescaping is performed when you assign the values.  simply expands to the value of  without further unescaping. If you want an emulation of the first case, you need to , i.e. evaluate the value of the string referenced by .


Answer URL
https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals
