Natural Text
I want to find the index of the n'th occurrence of an item in a list.  e.g., What is the index of the n'th true?  If I wanted the fifth occurrence (4th if zero-indexed), the answer is 10.I've come up with:Note that  returns the first occurrence or the first occurrence after some point, and therefore as far as I can tell is not a solution.There is also a solution in numpy for cases similar to the above, e.g. using  and , but I'd like to know if there's a numpy-free way to solve the problem.I'm concerned about performance since I first encountered this while implemented a Sieve of Eratosthenes for a Project Euler problem, but this is a more general question that I have encountered in other situations.EDIT:  I've gotten a lot of great answers, so I decided to do some performance tests.  Below are  execution times in seconds for lists with  nelements searching for the 4000'th/1000'th True.  The lists are random True/False.  Source code linked below; it's a touch messy.  I used short / modified versions of the posters' names to describe the functions except , which is the simple list comprehension above.Hettinger's itertools solution is almost always the best.  taymon's and graddy's solutions are next best for most situations, though the list comprehension approach can be better for short arrays when you want the n'th instance such that n is high or lists in which there are fewer than n occurrences.  If there's a chance that there are fewer than n occurrences, the initial  check saves time.  Also, graddy's is more efficient when searching for numbers instead of True/False... not clear why that is.  eyquem's solutions are essentially equivalent to others with slightly more or less overhead; eyquem_occur is approximately the same as taymon's solution, while eyquem_occurrence is similar to listcomp.
The answer from @Taymon using list.index was great.FWIW, here's a functional approach using the itertools module.  It works with any iterable input, not just lists:The example is nice because it shows off how to effectively combine Python's functional toolset.  Note, that once the pipeline is set-up, there are no trips around Python's eval loop -- everything gets done at C speed, with a tiny memory footprint, with lazy evaluation, with no variable assignments, and with separately testable components.  IOW, it is everything functional programmers dream about :-)Sample run:
I can't say for certain that this is the fastest way, but I imagine it'd be pretty good:The answer is .
Note: Here Z is the n'th occurance,
If you're concerned with performance, you are best off seeing if there are algorithmic optimizations you can make. For example, if you are calling this function many times on the same values, you may wish to cache previous computations (e.g. once you find the 50th occurrence of an element, you can find any previous occurrence in  time).Otherwise, you want to make sure your technique works on (lazy) iterators.The most *in*elegant and performance-happy way I can think of implementing it is as:(if you really care about the performance difference between enumerate and other techniques, you will need to resort to profiling, especially with the numpy functions, which may resort to C)To preprocess the entire stream and support  queries:
A solution that first creates a list object and returns the nth-1 element of this list : function occurence()And a solution that fulfill functional programmers'dreams too, I think, using generators, because I love them : function occur() resultThe second solution seems complex but it isn't really. It doesn't need to run completely through the iterable: the process stops as soon as the wanted occurence is found.
Here is another way to find the  occurrence of  in a list :
if efficiency is a concern i think its better to iterate the normally ( O(N) ) instead of list comprehension which takes O(L) where L is length of listExample : Consider a very huge list and you want to find the first occurence N=1 it is obviously better to stop as soon as you find the first occurence
here is a way :for the example above :  we can define a function find_indexand if we apply the function :  the result is:  
I think this should work.
You could use count:OutputThe idea is that due to the short-circuit nature of , the expression  only gets evaluated when  so you are only counting the elements equals to .
You can use  with  and a generator expression.  allows you to slice an iterable as required.If the iterator is exhausted, i.e. the nth occurrence of the specified value doesn't exist,  can return a default value, in this instance :


Answer URL
https://docs.python.org/3/library/itertools.html
https://docs.python.org/3/library/itertools.html#itertools.islice
