Natural Text
I'm implementing a program that needs to serialize and deserialize large objects, so I was making some tests with ,  and  modules to choose the best module. Along the way I found something very interesting:I'm using  and then  (for each module) on a list of dicts, tuples, ints, float and strings.This is the output of my benchmark:So, from these results we can see that  was extremely fast in the dumping part of the benchmark:14.8x times faster than  and 2.6x times faster than .But, for my big surprise,  was by far slower than  in the loading part:2.2x times faster than , but 3.1x times slower than .And as for RAM,  performance while loading was also very inefficient:I'm guessing the reason why loading with  is so slow is somehow related with the length of the its serialized string (much longer than  and ).Why  dumps faster and loads slower?Why  serialized string is so long?Why 's loading is so inefficient in RAM?Is there a way to improve 's loading performance?Is there a way to merge  fast dumping with  fast loading?
 has a smarter algorithm than  and is able to do tricks to reduce the space used  by large objects. That means it'll be slower to decode but faster to encode as the resulting output is smaller. is simplistic and serializes the object straight as-is without doing any further analyze it. That also answers why the  loading is so inefficient, it simply has to do more work - as in reading more data from disk - to be able to do the same thing as . and  are really different things in the end, you can't really get both fast saving and fast loading since fast saving implies analyzing the data structures less which implies saving a lot of data to disk.  Regarding the fact that  might be incompatible to other versions of Python, you should generally use :"This is not a general “persistence” module. For general persistence and transfer of Python objects through RPC calls, see the modules pickle and shelve. The marshal module exists mainly to support reading and writing the “pseudo-compiled” code for Python modules of .pyc files. Therefore, the Python maintainers reserve the right to modify the marshal format in backward incompatible ways should the need arise. If you’re serializing and de-serializing Python objects, use the pickle module instead – the performance is comparable, version independence is guaranteed, and pickle supports a substantially wider range of objects than marshal." (the python docs about marshal)
Some people might think this too much of a hack, but I've had great success by simply wrapping the pickle dump calls with gc.disable() and gc.enable().  For example, the the snips below writing a ~50MB list of dictionaries goes from 78 seconds to 4.
The difference between these benchmarks gives one idea for speeding up cPickle:In the first case, the list repeats the same string. The second list is equivalent, but each string is a separate object, because it is the result of an expression. Now, if you are originally reading your data in from an external source, you could consider some kind of string deduplication.
You can make cPickle cca. 50x (!) faster by creating instance of cPickle.Pickler and then setting undocumented option 'fast' to 1:But if your myHugeObject has cyclic references, the dump method will never end.
As you can see, the output produced by  has about 1/4 of the length of the output produced by . This means that  must use a more complicated algorithm to dump the data as unneeded things are removed. When loading the dumped list,  has to work through much more data while  can process its data quickly as there is less data that has to be analysed.Regarding the fact that  might be incompatible to other versions of Python, you should generally use :"This is not a general “persistence” module. For general persistence and transfer of Python objects through RPC calls, see the modules pickle and shelve. The marshal module exists mainly to support reading and writing the “pseudo-compiled” code for Python modules of .pyc files. Therefore, the Python maintainers reserve the right to modify the marshal format in backward incompatible ways should the need arise. If you’re serializing and de-serializing Python objects, use the pickle module instead – the performance is comparable, version independence is guaranteed, and pickle supports a substantially wider range of objects than marshal." (the python docs about marshal)
You could improve the storage efficiency by compressing the serialize result.My hunch are that compressing data and feeding it into the unserialize would be faster than reading raw from disk via HDD.Test below was made to prove that compression would speed up the unserialize process.The result wasn't as expect since the machine were equip with SSD.On HHD equip machine compressing the data using lz4 would be faster since reading from disk average between 60-70mb/s.LZ4: At a speed reduction of 18%, the compression yield 77.6% of additional storage.


Answer URL
