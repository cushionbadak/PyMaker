Natural Text
I'm trying to implement RC4 and DH key exchange in python. Problem is that I have no idea about how to convert the python long/int from the key exchange to the byte array I need for the RC4 implementation. Is there a simple way to convert a long to the required length byte array?Update: forgot to mention that the numbers I'm dealing with are 768 bit unsigned integers.
I haven't done any benchmarks, but this recipe "works for me".The short version: use , then  the result. The devil is in the details, though, as  requires an even number of hex digits, which  doesn't guarantee. See the docstring, and the liberal inline comments for details....and my nosetest unit tests ;-)
With Python 3.2 and later, you can use  and : https://docs.python.org/3/library/stdtypes.html#int.to_bytes
Everyone has overcomplicated this answer:You just need to know the number of bytes that you are trying to convert. In my use cases, normally I only use this large of numbers for crypto, and at that point I have to worry about modulus and what-not, so I don't think this is a big problem to be required to know the max number of bytes to return.Since you are doing it as 768-bit math, then instead of 32 as the argument it would be 96.
One-liner:The 192 is 768 / 4, because OP wanted 768-bit numbers and there are 4 bits in a hex digit. If you need a bigger  use a format string with a higher number. Example:[My answer had used  before. I corrected it with  in order to handle ints with odd-sized byte expressions. This fixes previous complaints about .]
long/int to the byte array looks like exact purpose of .  For long integers that exceed 4(8) bytes, you can come up with something like the next:
You can try using struct:
Little-endian, reverse the result or the range if you want Big-endian:Big-endian:
Basically what you need to do is convert the int/long into its base 256 representation -- i.e. a number whose "digits" range from 0-255. Here's a fairly efficient way to do something like that:You many not need thecall depending on the endian-ness desired (doing so would require the padding to be done differently as well). Also note that as written it doesn't handle negative numbers.You might also want to take a look at the similar but highly optimized  function in themodule which is part of the open source Python Cryptography Toolkit. It actually converts the number into a string, not a byte array, but that's a minor issue.
Python 2.7 does not implement the int.to- very slow_bytes() method.I tried 3 methods:hex unpack/pack : very slowbyte shifting 8 bits at a time: significantly faster.using a "C" module and packing into the lower (7 ia64 or 3 i32) bytes.This was about twice as fast as 2/ . It is the fastest option, but still too slow.All these methods are very inefficient for two reasons: Python 2.7 does not support this useful operation.c does not support extended precision arithmetic using the carry/borrow/overflow flags available on most platforms.



Answer URL
https://docs.python.org/3/library/stdtypes.html#int.to_bytes
