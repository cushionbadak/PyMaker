Natural Text
I am finding that I am using plenty of context managers in Python. However, I have been testing a number of things using them, and I am often needing the following:When this gets to many tests, this is clearly going to get boring, so in the spirit of SPOT/DRY (single point of truth/dont repeat yourself), I'd want to refactor those bits into the test  and  methods.However, trying to do that has lead to this ugliness:There must be a better way to do this. Ideally, in the / without repetitive bits for each test method (I can see how repeating a decorator on each method could do it).Edit: Consider the undertest object to be internal, and the  object to be a third party thing (which we aren't changing).I've renamed  to  here—this is more general than specific case—where context managers are the way which the object is intended to go into a locked state and out.
How about overriding  as illustrated below?  This approach doesn't require calling any private methods or doing something to every method, which is what the questioner wanted.This approach also allows passing the  instance to the context manager, if you want to modify the  instance there.
Manipulating context managers in situations where you don't want a  statement to clean things up if all your resource acquisitions succeed is one of the use cases that  is designed to handle.For example (using  rather than a custom  implementation):That's the most robust approach, since it correctly handles acquisition of multiple resources:Here, if  fails, the first resource will be cleaned up immediately by the with statement, while if it succeeds, the  call will postpone the cleanup until the registered cleanup function runs.If you know you're only ever going to have one resource to manage, you can skip the with statement:However, that's a bit more error prone, since if you add more resources to the stack without first switching to the with statement based version, successfully allocated resources may not get cleaned up promptly if later resource acquisitions fail.You can also write something comparable using a custom  implementation by saving a reference to the resource stack on the test case:
The problem with calling  and  as you did, is not that you have done so: they can be called outside of a  statement. The problem is that your code has no provision to call the object's  method properly if an exception occurs. So, the way to do it is to have a decorator that will wrap the call to your original method in a statement. A short metaclass can apply the decorator transparently to all methods named test* in the class -(I also included mock implementations of "GetSlot" and the methods and functions in your example so that I myself could test the decorator and metaclass I am suggesting on this answer)
 fixtures are very close to your idea/style, and allow for exactly what you want:
I'd argue you should separate your test of the context manager from your test of the Slot class. You could even use a mock object simulating the initialize/finalize interface of slot to test the context manager object, and then test your slot object separately.This makes code simpler, prevents concern mixing and allows you to reuse the context manager without having to code it in many places.


Answer URL
https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack
https://docs.python.org/3/library/unittest.html#unittest.TestCase.addCleanup
