Natural Text
While reading Python 101 by Michael Driscoll I got to his explanation on checking if a key exists in a dictionary. I checked it on my machine with a dictionary containing keys  to  where the value is their order, and a function that measures time on retrieving the key  (picked it at random)Here's my function:And here are the results:BUT, I still don't get it. I thought that  would result in iteration on much smaller collection, which will be faster. Is there something special in the implementation of  or  that causes this?
Using  is slower because it does more work:It adds an attribute lookup; It adds a method call (), requiring the current call frame to be pushed onto the stack, and popped afterwards.Another object has to be created for the return value (a dictionary view). It's a light-weight object, but you still need to allocate memory for it on the heap.None of this is needed, because a containment test against the dictionary and the dictionary view on the keys test the exact same thing. Containment testing directly on a dictionary does not include the values, you are testing for keys only, in both cases.From the  object documentation:  Return  if d has a key key, else .Note that using walk-clock time is not a great way of testing for performance differences. Use the  module instead, which picks the best performing timer, disables the GC to eliminate a source of skew, and repeats the test many times to minimise system skew.You can reproduce the time difference by testing for the additional steps above separately (combining the call and object creation into one). By default  repeats the test 1 million times and returns the total time taken:So merely looking up the  attribute 1 million times already takes 44 milliseconds, while calling the method (without attribute lookup) adds another 63ms. Both methods have some overhead for looking up the global name however:So one would expect there to be a 107 - 28 == 79ms (roughly) difference between the two methods.And indeed, the time difference between using  and  is about that much:116 - 37 is 79 milliseconds, as predicted.


Answer URL
https://docs.python.org/3/library/stdtypes.html#dict
https://docs.python.org/3/library/timeit.html
