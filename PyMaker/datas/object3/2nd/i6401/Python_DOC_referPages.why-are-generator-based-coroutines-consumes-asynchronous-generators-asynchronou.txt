Natural Text
From a comment by Jim Fasarakis Hilliard:Generators:  functions that contain one or more  expressions.Generators are used as data producers (they  values). I can understand that.Generator-based coroutine: A generator ( + ) that is wrapped by . You need to wrap it in   if you need it to be considered a coroutine object.Generator-based coroutines are used as consumers (you  values to  them or to a sub-generator they ). What does "consumers (you  values to them or to a sub-generator they )" mean? Asynchronous Generator:  functions that contain a one or more  expressions. These can also contain  expressions.Asynchronous generators are asynchronous data producers.What does  "asynchronous data producers" mean?Coroutine:  without zero or more s and no s. coroutines are asynchronous data consumers.What does "asynchronous data consumers" mean?Thanks.
In python, generators are NOW used in a number of various ways. The original purpose of generators was to suspend execution and then  a value back to the caller. The caller can then call next later to resume the generator. Hence generators were data producers.Now the above version of generators only allowed returning data through the  statement. Now for a function to be a coroutine, it should also accept values from the caller. Hence PEP 342 was introduced in python 2.5 to enhance generators so that they can act as full fledged coroutines. This allowed callers to send values to the generators.Now the new issue was that when generators were refactored and you wanted to delegate parts of its operation to subgenerators, you need to explicitly invoke the subgenerator as an iterator, propagate the data send by caller and handle exception. To simplify the operation of subgenerators, a new operation  was defined in PEP 380 as part of python 3.3. The  is syntactically is much more than the plain yield syntax. In a perfect world, a new keyword probably would have used.Now the issue was that generators were used in two different contexts. As an iterator and as a coroutine. It would have been better if a generator can be explicitly defined as a coroutine. Hence PEP 492 introduced  and  keywords in Python 3.5. Hence any generator which was used as a coroutine was indicated by the  keyword. The coroutine in Python 3.5 can use  keyword instead of the . Note that from python 3.5 onwards coroutines are a different type!!Now assume you have a generator function with  and . You can convert an existing generator type to a coroutine type using the  decorator. These are consumers who can accept values through  and delegate the same to subgenerators using .In python 3.5, you can use  to indicate that the function is a coroutine type. Such a function can contain plain  and . They cannot contain  (since  replaces the feature). When a coroutine contains plain , they are the lowest in a chain of generator calls and hence called an asynchronous data producer. Any coroutine without plain  will be a data consumer since it must call another coroutine through  to get asynchronous data.


Answer URL
https://docs.python.org/3/library/types.html#types.coroutine
