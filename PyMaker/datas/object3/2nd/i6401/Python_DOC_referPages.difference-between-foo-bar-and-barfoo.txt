Natural Text
Consider:The above is from the Udacity Python course. I discovered I'm able to call  for instance  using either of the following:I'm curious as to why. Is there a difference between the two methods? If so when would one be used vs. the other? I'm using Python 3.6 if that matters.
In terms of just calling the method, there is no difference most of the time. In terms of how the underlying machinery, works, there is a bit of a difference.Since  is a method, it is a descriptor in the class. That means that when you access it through an instance in which it is not shadowed by another attribute, the  operator calls  on the descriptor to create a bound method for that instance. A bound method is basically a closure that passes in the  parameter for you before any of the other arguments you supply. You can see the binding happen like this:A different closure is created every time you use the  operator on a class method.If you access the method through the class object, on the other hand, it does not get bound. The method is a descriptor, which is just a regular attribute of the class:You can simulate the exact behavior of binding a method before calling it by calling its  yourself:Again, this will not make any difference to you in 99.99% of cases, since functionally  and  end up calling the same underlying function object with the same parameters.Where it mattersThere are a couple of places where it matters how you call a class method. One common use case is when you override a method, but want to use the definition provided in the parent class. For example, say I have a class that I made "immutable" by overriding . I can still set attributes on the instance, as in the  method shown below:If I tried to do a normal call to  in  by doing , a  would be raised every time. But by using , I can bypass this limitation. Alternatively, I could do  for the same effect, or  for a very similar one.@Silvio Mayolo's answer has another good example, where you would deliberately want to use the class method as a function that could be applied to many objects.Another place it matters (although not in terms of calling methods), is when you use other common descriptors like . Unlike methods, properties are data-descriptors. This means that they define a  method (and optionally ) in addition to . A property creates a virtual attribute whose getter and setter are arbitrarily complex functions instead of just simple assignments. To properly use a property, you have to do it through the instance. For example:Now you can do something likeIf you try to access the property through the class, you can get the underlying descriptor object since it will be an unbound attribute:On a side note, hiding attributes with the same name as a property in  is a neat trick that works because data descriptors in a class  trump entries in the instance , even though instance  entries trump non-data-descriptors in a class.Where it can Get WeirdYou can override a class method with an instance method in Python. That would mean that  and  don't call the same underlying function at all. This is irrelevant for magic methods because they always use the former invocation, but it can make a big difference for normal method calls.There are a few ways to override a method on an instance. The one I find most intuitive is to set the instance attribute to a bound method. Here is an example of a modified , assuming the definition of  in the original question:In this case, calling the method on the instance vs the class would have completely different results. This only works because methods are non-data descriptors by the way. If they were data descriptors (with a  method), the assignment  would not override anything but would instead just redirect to , and manually setting it in b's  would just get it ignored, as happens with a property.Additional ResourcesHere are a couple of resources on descriptors:Python Reference - Descriptor Protocol: http://python-reference.readthedocs.io/en/latest/docs/dunderdsc/(Official?) Descriptor HowTo Guide: https://docs.python.org/3/howto/descriptor.html
There is no semantic difference between the two. It's entirely a matter of style. You would generally use  in normal use, but the fact that the second approach is allowed permits you to use  to get the method as a first-class object itself. If that was not allowed, then it would not be possible (or at least, it would be fairly difficult) to do something like this.


Answer URL
https://docs.python.org/3/reference/datamodel.html#implementing-descriptors
https://docs.python.org/3/reference/datamodel.html#object.__get__
https://docs.python.org/3/reference/datamodel.html#object.__setattr__
https://docs.python.org/3/reference/datamodel.html#special-method-names
https://docs.python.org/3/howto/descriptor.html
