Natural Text
I am trying to add multiprocessing to some code which features functions that I can not modify. I want to submit these functions as jobs to a multiprocessing pool asynchronously. I am doing something much like the code shown here. However, I am not sure how to keep track of results. How can I know to which applied function a returned result corresponds?The important points to emphasise are that I can not modify the existing functions (other things rely on them remaining as they are) and that results can be returned in an order different to the order in which the function jobs are applied to the pool.Thanks for any thoughts on this!EDIT: Some attempt code is below:EDIT: This question has been placed [on hold] for the following stated reason:"Questions asking for code must demonstrate a minimal understanding of the problem being solved. Include attempted solutions, why they didn't work, and the expected results. See also: Stack Overflow question checklist"This question is not requesting code; it is requesting thoughts, general guidance. A minimal understanding of the problem under consideration is demonstrated (note the correct use of the terms "multiprocessing", "pool" and "asynchronously" and note the reference to prior code). Regarding attempted solutions, I acknowledge that attempted efforts at solutions would have been beneficial. I have added such code now. I hope that I have addressed the concerns raised that lead to the [on hold] status.
Without seeing actual code, I can only answer in generalities. But there are two general solutions.First, instead of using a  and ignoring the s, store them in some kind of collection. Then you can just use that collection. For example, if you want to be able to look up the results for a function using that function as a key, just create a  keyed with the functions:Alternatively, you can change the callback function to store the results in your collection by key. For example:I'm using the function itself as a key. But you want to use the index instead, that's just as easy. Any value you have, you can use as a key.Meanwhile, the example you linked is really just calling the same function on a bunch of arguments, waiting for all of them to finish, and leaving the results in some iterable in arbitrary order. That's exactly what  does, but a lot more simply. You could replace the whole complicated thing from the linked code with this:And then, if you want the results in their original order instead of in arbitrary order, you can just switch to  or  instead. So:If you need something similar but too complicated to fit into the  paradigm,  will probably make your life easier than . If you're on Python 2.x, you will have to install the backport. But then you can do things that are much harder to do with s or s (or ), like composing a whole bunch of futures into one big future. See the examples in the linked docs.One last note:The important points to emphasise are that I can not modify the existing functionsâ€¦If you can't modify a function, you can always wrap it. For example, let's say I have a function that returns the square of a number, but I'm trying to build a dict mapping numbers to their squares asynchronously, so I need to have the original number as part of the result as well. That's easy:And now, I can just  instead of just , and get the results I want.I didn't do that in the examples above because in the first case I stored the key into the collection from the calling side, and in the second place I bound it into the callback function. But binding it into a wrapper around the function is just as easy as either of these, and can be appropriate when neither of these is.


Answer URL
