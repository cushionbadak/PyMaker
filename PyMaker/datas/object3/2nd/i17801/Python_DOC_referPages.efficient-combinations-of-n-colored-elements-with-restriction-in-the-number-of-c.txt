Natural Text
Given a set of N elements colored with C colors, how can I find every possible combination of length L that contains no more than a maximum of M colors?I tried this algorithm that uses itertools.combinations to generate all the possible combinations, and then filter out those that do not hold the maximum colors condiction.the output is like:The problem is that generating all possible combinations can be computationally very expensive. In my case, for instance, L is often 6 and  the number of elements N is around 50, so it gives us Bin(50,6) = 15890700 possible combinations. If maximum number of colors allowed in a comination is small, most of combinations are "useless" and so they are discarded in the filter step. My intuition is that I should put the filtering step inside/before the combinatory step, to avoid the explotion of combinations, but I don't see how.
Combinatorial problems are notorious for being easy to state but possibly difficult to solve.  For this one, I wouldn't use  at all, but instead write a custom generator.  For example,Then:produces the same 188 combinations as your post-processing code, but internally abandons a partial combination as soon as it would span more than  colors.  There's no way to change what  functions do internally, so when you want control over that, you need to roll your own.Using itertoolsHere's another approach, generating first all solutions with exactly 1 color, then exactly 2 colors, and so on.   can be used directly for much of this, but at the lowest level still needs a custom generator.  I find this harder to understand than a fully custom generator, but it may be clearer to you:I haven't timed these, because I don't care ;-)  The fully custom generator's single  list is reused for building each output, which slashes the rate of dynamic memory turnover.  The second way creates a lot of memory churn by pasting together multiple levels of  and  tuples - and that's mostly unavoidable because it uses  to generate the  tuples at each level.Internally,  functions almost always work in a way more similar to the first code sample, and for the same reasons, reusing an internal buffer as much as possible.AND ONE MOREThis is more to illustrate some subtleties.  I thought about what I'd do if I were to implement this functionality in C as an  function.  All the  functions were first prototyped in Python, but in a semi-low-level way, reduced to working with vectors of little integers (no "inner loop" usage of sets, dicts, sequence slicing, or pasting together partial result sequences - sticking as far as possible to  worst-case time operations on dirt simple native C types after initialization).At a higher level, an  function for this would accept any iterable as its primary argument, and almost certainly guarantee to return combinations from that in lexicographic index order.  So here's code that does all that.  In addition to the  argument, it also requires an  mapping, which maps each element from the iterable to its equivalence class (for you, those are strings naming colors, but any objects usable as dict keys could be used as equivalence classes):(Note that this is Python 3 code.)  As advertised, nothing in  is fancier than indexing a vector with a little integer.  The only thing remaining to make it directly translatable to C is removing the recursive generation.  That's tedious, and since it wouldn't illustrate anything particularly interesting here I'm going to ignore that.Anyway, the interesting thing is timing it.  As noted in a comment, timing results are strongly influenced by the test cases you use.   here is sometimes fastest, but not often!  It's almost always faster than my original , but usually slower than my  or @GarethRees's lovely .So how can that be when  has been optimized "almost all the way down to mindless ;-) C-level operations"?  Easy!  It's still written in Python.   and  use the C-coded  to do much of their work, and that makes a world of difference.   would run circles around them if it were coded in C.Of course any of these can run unboundedly faster than the  in the original post - but that one can be fastest too (for example, pick just about any inputs where  is so large that no combinations are excluded - then  wastes little effort, while all these others add extra substantial extra overheads to "optimize" pruning that never occurs).
Here's an implementation that's a bit simpler than the other answers posted so far. The basic approach is to:Pick a value ("colour" in your terminology) that has not been picked so far;Loop over , the number of keys ("elements") associated with that value that will be included in the output;  Loop over , the combinations of those keys of length ;    Recurse to pick the next value.NotesIn Python 3.3 or later, you could use the  statement to simplify the recursive call:If you're wondering why the doctests use , it's so that the combinations can be returned in a predictable order, which is necessary for the tests to work.The code reverses the list , and iterates downwards over  so that if the caller passes in an , the combinations are returned in a sensible order (with values that appear early in the input also appearing early in the output).Given the slight awkwardness in getting predictable output from this function, it would, I think, be worth considering changing the interface so that instead of taking a dictionary mapping keys to values, it would take an iterable of (key, value) pairs.PerformanceThis is broadly similar in speed to Tim Peter's :
Rough outline.You have in total C different colors. For each , choose  colorsin  ways. (I'm using your notation here assuming Bin mean binomial coefficient).For each of the above choices, collect all the elements with the chosen colors. Let's say it gives  distinct elements. Then choose  from these  elements in  different ways.All of the above subject to obvious checks, , , etc.The advantage of this approach is that it will generate only valid combinations and every valid combination will be generated exactly once. (edit: and as pointed out in a comment, this is not true duplicate, combination can be generated).PS. And here's an implementation of the above algorithm, with the fix for duplicated combinations:PS. I also timed Tim's , my own  and Gareth's  with the program here with these results:


Answer URL
