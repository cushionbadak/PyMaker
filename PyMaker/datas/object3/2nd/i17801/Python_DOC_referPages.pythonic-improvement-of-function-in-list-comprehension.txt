Natural Text
Is there a more pythonic way to do the following code?  I would like to do it in one lineparsed_rows is a function that can return a tuple of size 3, or None.
Doing this in one line won't make it more Pythonic; it will make it less readable. If you really want to, you can always translate it directly by substitution like this:… which can obviously be flattened as Doorknob of Snow shows, but it's still hard to understand. However, he didn't get it quite right: clauses nest from left to right, and you want  to be each  result, not each element of each  result (as Volatility points out), so the flattened version would be:I think the fact that a good developer got it backward and 6 people upvoted it before anyone realized the problem, and then I missed a second problem and 7 more people upvoted that before anyone caught it, is pretty solid proof that this is not more pythonic or more readable, just as Doorknob said. :)In general, when faced with either a nested comp or a comp with multiple  clauses, if it's not immediately obvious what it does, you should translate it into nested  and  statements with an innermost  expression statement, as shown in the tutorial. But if you need to do that with a comprehension you're trying to write, it's a pretty good sign you shouldn't be trying to write it…However, there is a way to make this more Pythonic, and also more efficient: change the first list comprehension to a generator expression, like this:All I did is change the square brackets to parentheses, and that's enough to compute the first one lazily, calling  on each  as needed, instead of calling it on all of the rows, and building up a list in memory that you don't actually need, before you even get started on the real work.In fact, if the only reason you need  is to iterate over it once (or to convert it into some other form, like a CSV file or a NumPy array), you can make that a generator expression as well.Or, even better, replace the list comprehension with a  call. When your expression is just "call this function on each element",  is generally more readable (whereas when you have to write a new function, especially with , just to wrap up some more complex expression, it's usually not). So:And now it actually is readable to sub in:You could similarly turn the second comprehension into a  call. However, just as with , if the predicate isn't just "call this function and see if it returns something truthy", it usually ends up being less readable. In this case:But notice that you really don't need to check  in the first place. The only non- values you have are 3-tuples, which are always truthy. So, you can replace the  with , which can simplifies your comprehension:… and which can be written in two different ways with :Asking which of those two is better will start a religious war on any of the Python lists, so I'll just present them both and let you decide.Note that if you're using Python 2.x,  is not lazy; it will generate the whole intermediate list. So, if you want to get the best of both worlds, and can't use Python 3, use  instead of . An in the same way, in 3.x,  is lazy, so if you want a list, use .
You can nest one in the other:(Also, @Volatility points out that this will give an error if  is , which can be solved like this:)However, in my opinion this is much less readable. Shorter is not always better.


Answer URL
