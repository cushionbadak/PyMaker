Natural Text
I have two Code that is same in My pc Time needed for  is 1s But for  is 480s !!Why ? Waht is Different?
(In what follows I'm assuming you're using Python 3; in Python 2 the story would be similar but we'd have to discuss the cost of memory allocation due to .)Your second program spends its time running in Python bytecode. Let's disassemble it using the  module:The loop runs from bytes 22 to 41, and each time round the loop, Python has to decode and execute seven byte code instructions, and call a function too (the function being ). That's 420 million byte code instructions and 60 million function calls.Whereas your first program spends its time running in native code:You can see that not only is there no loop, there are no function calls. All the work happens "under the hood" inside the  instruction, which dispatches to  in , and since the list  contains just one element, the result is constructed in this tight loop at lines 529–536:
 in Python 2.7 creates a list itself, and not an iterator. Therefore, you do double the work in . That means, you first create a list of 6000000 items, and then iterate over it.  does not need that intermediate step.This [range] is a versatile function to create lists containing arithmetic  progressionsSoure: Range Python 2.xCompare that to Python 3.x: Rather than being a function, range is actually an immutable sequence  type, as documented in Ranges and Sequence Types — list, tuple, range.Source: Range Python 3.xTry to use  instead of , and test it again.
Ignoring the fact that you used  instead of , there are two things that are going on:1) The functions don't do the same thing, though they arrive at the same output.  Your  means "60 million copies of  concatenated together".  That is not what  is doing, obviously- it has to call the  method of lists 60 million times.2) Explicit loops in python are slow.  There is a loop in , somewhere, but it occurs "at C speed" as opposed to, well, python speed.In a tight loop like this, the majority of the overhead is in the loop itself rather than the operations contained therein.  So a popular method to optimize tight loops is to drop them into a comprehension:Note that again the two functions are not doing the same thing, which is why there is discrepancy between  and .


Answer URL
