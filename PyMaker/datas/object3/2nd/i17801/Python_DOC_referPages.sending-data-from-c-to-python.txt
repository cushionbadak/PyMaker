Natural Text
I have some C code running on an embedded processor, which outputs integers (16 bits) over a serial port (stdout) using . I have some python code running on a PC that reads the serial stream using pyserial and writes it to a file, which I can just achieve using . This works quite happily, although it isn't very efficient.As the embedded C is sending quite a lot of numbers and I want to cut down on the transfer time, I would like to send the data formatted as binary rather than ascii (i.e. two bytes/chars rather than several bytes/chars.) I tried to do this with:And then in my python code:But value seems to be gibberish. Could anyone point out the thing(s) I'm doing wrong?
Try with this:I've assumed that your integer is signed short and please note the presence of '>' for endianness (bytes order).However the error with you code was because of operator precedence: this should work. But it is better to use struct anyway.
The  idea is great, but your protocol is faulty.If you write binary data, it is not useful to have line endings in-between: one of the "value bytes" could have that value - 10 - as well.So better refrain from using these line ends and .But there could arise the problem that you could get out of sync. So you either should define a kind of package boundaries, or you could encode your data in more than 2 bytes.Example: Each 16bit value is encoded in 3 bytes, in the following way: is ,  is ,  is .The value 57723 - 0xE17B, 0b1110000101111011, is encoded asorby means ofUpon reception of these bytes, you immediately can detecta) which byte it is (the 1st, the 2nd or the 3rd) andb) its contents.So even if one byte gets missing, you can detect that and can resume reception of the stream immediately.Plus, this implementation is endianness-agnostic - it will work on every machine regardless of its endianness, a way every protocol should be designed.How to implement that I'll leave to you.
As the embedded C is sending quite a lot of numbers and I want to cut down on the transfer time,To improve time performance you could send and/or receive more than one number at a time. In my tests,  is 10 - 100 times faster than . It comes at the cost of calling  sometimes to take into account endianness explicitly. If the C program and Python script were running on the same machine (same size, same endianess); then you could use  to write short ints as platform values on C side and  on Python side to read them back in a native format.For example, print short ints as binary:Read it in Python: should be efficient both time and memory-wise. If you don't know the size then call  until  is raised.If C program and Python script are on different machines then you could send integers in the network byte order:And swap byte order if necessary on the Python side:To avoid converting to network order, you could send a magic number instead. It allows to send numbers in a native byte order on C side (as in the 1st code example) and check it in Python to swap bytes if necessary:


Answer URL
