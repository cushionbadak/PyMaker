Natural Text
Not sure how to title this question. I've run into a few situations where I have a list of data, maybe annotated with some property, and I want to collect them into groups. For example, maybe I have a file like this:and I want to group each set of readings, splitting them on a condition (in this case, an event happening) so that I end up with a structure like In it's generic form, it is:  Look for a condition, collect the data until that condition is true again, repeatRight now, I'd do something like which produces what I want, but it's ugly and hard to understand. I'm fairly certain there has to be a better wayMy guess is that it involves some itertools wizardry, but I'm new to itertools and can't quite wrap my head around all of it. Thanks!UpdateI've actually gone with Steve Jessop's answer with a Grouper class. Here's what I'm doing:and then using it like and then to turn it into a dictionary I dowhich gives
You can use the fact that functions in Python have state. This grouper function serves the same purpose as DSM's :Then if you need it:To allow for concurrent use you need a new grouper function object each time you use it (so that it has its own count). You might find it simpler to make it a class:
I doubt itertools (or collections) can make it clearer than this, unless the exact pattern is implemented in there somewhere.Two things I notice:You always have a current event (since the first line is an event)You always append the line to the current event (so the event itself is always So you can skip the checking for if you have a current event, and you don't have to special-case creating it either.  Additionally, since the "current" event is always the last one, we can just use a negative index to jump straight to it:
With , you can easily group things based on a key, like . So, as a first step:Of course this doesn't put the events together with their values. I suspect you really don't want the events together with their values, but would actually prefer to have a dict of  or a list of . In which case you're nearly done. For example, to get that dict, just use the grouper recipe (or ) to group into pairs, then use a dict comprehension to map either  in those pairs to .On the other hand, if you really do want them together, it's the same steps, but with a list of  at the end.However, if you don't actually understand  well enough to turn that description into code, you should probably write something you do understand. And that's not too hard:Yes, it's 7 lines (condensable to 4 with some tricks) instead of 3 (condensable to 1 by nesting comprehensions in an ugly way), but 7 lines you understand and can debug are more useful than 3 lines of magic.When you iterate the generator created by this function, it gives you lists of lines, like this:This will print:If you want a list instead of an generator (so you can index it, or iterate over it twice), you can do the same thing you do to turn any other iterable into a list:
I wish  had a function which did what you wanted.  For entertainment value, in modern Python you could do something likewhich givesbut to be honest I'd probably do what @abarnert did.
You can make your code more concise using list comprehensions:Output:I'm not sure how much you gain in raw readability, but it's pretty straightforward to understand with the comments.


Answer URL
