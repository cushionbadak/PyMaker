Natural Text
There are essentially three ways to use the with statement:Use an existing context manager:Create a context manager and bind its result to a variable:Create an context manager and discard its return value:If we have place a function  inside the three with blocks above, is there any implementation that can return the enclosing context manager, or at least their  function? It's obviously easy in the first case, but I can't think of a way to make it work in the other two. I doubt it's possible to get the entire context manager, since the value stack is popped immediately after the  opcode. However, since the  function is stored on the block stack by , is there some way to access it?
Unfortunately, as discussed in the comments, this is not possible in all cases. When a context manager is created, the following code is run (in cPython 2.7, at least. I can't comment on other implementations):The  method is pushed onto a stack with the  macro, which is defined as: The stack pointer, in turn, is set to the top of the frame's value stack at the start of frame eval:Where f is a frame object defined in frameobject.h. Unfortunately for us, this is where the trail stops. The python accessible frame object is defined with the following methods only:Which, unfortunaltey, does not include the  that we would need. This makes sense, since  is of the type , which would need to be wrapped in an object to be accessible from python any way.TL;DR: The  method we're looking for is only located in one place, the value stack of a frame object, and cPython doesn't make the value stack accessible to python code.
If the context manager is a class and only ever has a single instance, then you could find it on the heap:(Disclaimer: Don't do this)
The difference between this case and similar-appearing cases like  is that here there is no enclosing frame to look at. A  statement is not a new scope.  (or, if you're putting the code into a function, ) will work just fine, but it'll return you the exact same frame you have before and after the  statement.The only way you could do it would be by inspecting the bytecode. But even that won't help. For example, try this:Obviously, as  explains, the method does get looked up and pushed onto the stack for  to use later. So, even after  removes the return value of , its  is still on the stack.But there's no way to get at that from Python. Unless you want to start munging the bytecode, or digging apart the stack with  or something, it might as well not exist.


Answer URL
