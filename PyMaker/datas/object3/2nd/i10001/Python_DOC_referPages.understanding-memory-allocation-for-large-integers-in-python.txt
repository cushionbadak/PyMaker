Natural Text
How does Python allocate memory for large integers?An  type has a size of  and as I keep increasing the value of the , the size increases in increments of .Why  initially for any value as low as ?Why increments of ? PS: I am running Python 3.5.2 on a x86_64 (64 bit machine). Any pointers/resources/PEPs on how the (3.0+) interpreters work on such huge numbers is what I am looking for.Code illustrating the sizes:
Why  bytes initially for any value as low as ?I believe @bgusach answered that completely; Python uses  structs to represent objects in the Python world, any objects including s: is a macro that when expanded adds another field in the struct (field  which is specifically used for objects that have some notion of length) and,  is an array holding the value for the number. Boiler-plate in size comes from that struct, for small and large Python numbers.Why increments of  bytes?Because, when a larger number is created, the size (in bytes) is a multiple of the ; you can see that in  where the allocation of memory for a new  is performed with : is the 'boiler-plate' (in bytes) for the long object that isn't related with holding its value. is defined in the header file holding the  as a  for :and  is  bytes. That's the amount by which you'll see the size in bytes increase when the  argument to  increases.Of course, this is just how Python has chosen to implement it. It is an implementation detail and as such you wont find much information in PEPs. The python-dev mailing list would hold implementation discussions if you can find the corresponding thread :-). Either way, you might find differing behavior in other popular implementations, so don't take this one for granted. 
It's actually easy. Python's  is not the kind of primitive you may be used to from other languages, but a full fledged object, with its methods and all the stuff. That is where the overhead comes from.Then, you have the payload itself, the integer that is being represented. And there is no limit for that, except your memory. The size of a Python's  is what it needs to represent the number plus a little overhead.If you want to read further, take a look at the relevant part of the documentation:Integers have unlimited precision


Answer URL
https://docs.python.org/3/c-api/structures.html#c.PyObject_VAR_HEAD
https://docs.python.org/3/c-api/structures.html#c.PyVarObject
https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex
https://docs.python.org/3/library/sys.html#sys.int_info
