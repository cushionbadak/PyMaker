Natural Text
As I read Python answers on Stack Overflow, I continue to see some people telling users to use the data model's special methods or attributes directly.I then see contradicting advice (sometimes from myself) saying not to do that, and instead to use builtin functions and the operators directly.Why is that? What is the relationship between the special "dunder" methods and attributes of the Python data model and builtin functions? When am I supposed to use the special names?
What is the relationship between the Python datamodel and builtin functions?The builtins and operators use the underlying datamodel methods or attributes.The builtins and operators have more elegant behavior and are in general more forward compatible.The special methods of the datamodel are semantically non-public interfaces.The builtins and language operators are specifically intended to be the user interface for behavior implemented by special methods.Thus, you should prefer to use the builtin functions and operators where possible over the special methods and attributes of the datamodel.The semantically internal APIs are more likely to change than the public interfaces. While Python doesn't actually consider anything "private" and exposes the internals, that doesn't mean it's a good idea to abuse that access.  Doing so has the following risks:You may find you have more breaking changes when upgrading your Python executable or switching to other implementations of Python (like PyPy, IronPython, or Jython, or some other unforeseen implementation.)Your colleagues will likely think poorly of your language skills and conscientiousness, and consider it a code-smell, bringing you and the rest of your code to greater scrutiny.The builtin functions are easy to intercept behavior for. Using special methods directly limits the power of your Python for introspection and debugging.In depthThe builtin functions and operators invoke the special methods and use the special attributes in the Python datamodel. They are the readable and maintainable veneer that hides the internals of objects. In general, users should use the builtins and operators given in the language as opposed to calling the special methods or using the special attributes directly. The builtin functions and operators also can have fallback or more elegant behavior than the more primitive datamodel special methods. For example: allows you to provide a default instead of raising  when an iterator runs out, while  does not.  fallsback to  when  isn't available - whereas calling  directly would raise an attribute error. fallsback to  in Python 3 when no  - calling  would not take advantage of this.(Builtin functions can also be easily overshadowed, if necessary or desirable, on a module's global scope or the  module, to further customize behavior.)Mapping the builtins and operators to the datamodelHere is a mapping, with notes, of the builtin functions and operators to the respective special methods and attributes that they use or return - note that the usual rule is that the builtin function usually maps to a special method of the same name, but this is not consistent enough to warrant giving this map below:The  module has  which has a fallback implemented by a respective special method if  is not implemented:Dotted LookupsDotted lookups are contextual. Without special method implementation, first look in class hierarchy for data descriptors (like properties and slots), then in the instance  (for instance variables), then in the class hierarchy for non-data descriptors (like methods). Special methods implement the following behaviors:DescriptorsDescriptors are a bit advanced - feel free to skip these entries and come back later - recall the descriptor instance is in the class hierarchy (like methods, slots, and properties). A data descriptor implements either  or :When the class is instantiated (defined) the following descriptor method  is called if any descriptor has it to inform the descriptor of its attribute name. (This is new in Python 3.6.)  is same as  above, and  stands in for the attribute name:Items (subscript notation)The subscript notation is also contextual:A special case for subclasses of ,  is called if  doesn't find the key:OperatorsThere are also special methods for  operators, for example:and in-place operators for augmented assignment, , for example:and unary operations:Context ManagersA context manager defines , which is called on entering the code block (its return value, usually self, is aliased with ), and , which is guaranteed to be called on leaving the code block, with exception information.If  gets an exception and then returns a false value, it will reraise it on leaving the method. If no exception,  gets  for those three arguments instead, and the return value is meaningless:Some Metaclass Special MethodsSimilarly, classes can have special methods (from their metaclasses) that support abstract base classes:An important takeaway is that while the builtins like  and  do not change between Python 2 and 3, underlying implementation names are changing. Thus using the builtins also offers more forward compatibility.When am I supposed to use the special names?In Python, names that begin with underscores are semantically non-public names for users. The underscore is the creator's way of saying, "hands-off, don't touch."This is not just cultural, but it is also in Python's treatment of API's. When a package's  uses  to provide an API from a subpackage, if the subpackage does not provide an , it excludes names that start with underscores. The subpackage's  would also be excluded. IDE autocompletion tools are mixed in their consideration of names that start with underscores to be non-public. However, I greatly appreciate not seeing , , , , , etc. (nor any of the user created non-public interfaces) when I type the name of an object and a period.Thus I assert:The special "dunder" methods are not a part of the public interface. Avoid using them directly. So when to use them? The main use-case is when implementing your own custom object or subclass of a builtin object. Try to only use them when absolutely necessary. Here are some examples:Use the  special attribute on functions or classesWhen we decorate a function, we typically get a wrapper function in return that hides helpful information about the function. We would use the  decorator to make sure we don't lose that information, but if we need the name of the function, we need to use the  attribute directly:Similarly, I do the following when I need the name of the object's class in a method (used in, for example, a ):Using special attributes to write custom classes or subclassed builtinsWhen we want to define custom behavior, we must use the data-model names. This makes sense, since we are the implementors, these attributes aren't private to us.However, even in this case, we don't use  or  (see my answer here for proof that the latter can lead to unexpected behavior.) Instead, we should use the higher level of abstraction.Another point at which we'd need to use the special method names is when we are in a child's implementation, and want to delegate to the parent. For example:  ConclusionThe special methods allow users to implement the interface for object internals. Use the builtin functions and operators wherever you can. Only use the special methods where there is no documented public API.
I'll show some usage that you apparently didn't think of, comment on the examples you showed, and argue against the privacy claim from your own answer.I agree with your own answer that for example  should be used, not . I'd put it like this:  exists so we can use it, and  exists so  can use it. Or however that really works internally, since  can actually be much faster, at least for example for lists and strings:But besides defining these methods in my own classes for usage by builtin functions and operators, I occasionally also use them as follows:Let's say I need to give a filter function to some function and I want to use a set  as the filter. I'm not going to create an extra function  or . No. I already have a perfectly fine function that I can use: the set's  method. It's simpler and more direct. And even faster, as shown here (ignore that I save it as  here, that's just for this timing demo):So while I don't directly call magic methods like , I do occasionally pass them somewhere like . And I think that's perfectly fine, and better than the lambda/def alternative.My thoughts on the examples you showed:Example 1: Asked how to get the size of a list, he answered . Even without any reasoning. My verdict: That's just wrong. Should be .Example 2: Does mention  first! And then adds  with the reasoning "if your keyboard is missing the square bracket keys", which rarely applies and which I doubt was serious. I think it was just the foot in the door for the last point, mentioning that that's how we can support the square bracket syntax in our own classes. Which turns it back to a suggestion to use square brackets.Example 3: Suggests . Bad, like the  example. But I suspect he just didn't know , and I can understand it, as  is less common/known and the name does differ from the "dict" in .Example 4: Suggests . Should be . I suspect it's similar to the  story, although I think  is more well-known.About privacy: In your own answer you say these methods are "semantically private". I strongly disagree. Single and double leading underscores are for that, but not the data model's special "dunder/magic" methods with double leading+trailing underscores.The two things you use as arguments are importing behaviour and IDE's autocompletion. But importing and these special methods are different areas, and the one IDE I tried (the popular PyCharm) disagrees with you. I created a class/object with methods  and  and then autocompletion didn't offer  but did offer . And when I used both methods anyway, PyCharm only warned me about  (calling it a "protected member"), not about .PEP 8 says 'weak "internal use" indicator' explicitly for single leading underscore, and explicitly for double leading underscores it mentions the name mangling and later explains that it's for "attributes that you do not want subclasses to use". But the comment about double leading+trailing underscores doesn't say anything like that.The data model page you yourself link to says that these special method names are "Python’s approach to operator overloading". Nothing about privacy there. The words private/privacy/protected don't even appear anywhere on that page.I also recommend reading this article by Andrew Montalenti about these methods, emphasizing that "The dunder convention is a namespace reserved for the core Python team" and "Never, ever, invent your own dunders" because "The core Python team reserved a somewhat ugly namespace for themselves". Which all matches PEP 8's instruction "Never invent [dunder/magic] names; only use them as documented". I think Andrew is spot on - it's just an ugly namespace of the core team. And it's for the purpose of operator overloading, not about privacy (not Andrew's point but mine and the data model page's).Besides Andrew's article I also checked several more about these "magic"/"dunder" methods, and I found none of them talking about privacy at all. That's just not what this is about.Again, we should use , not . But not because of privacy.


Answer URL
https://docs.python.org/3/reference/datamodel.html
https://docs.python.org/3/library/functions.html
https://docs.python.org/3/reference/datamodel.html
https://docs.python.org/3/reference/datamodel.html#special-method-names
