Natural Text
How to best write a Python function () to efficiently test if an element () occurs at least  times in a list ()?My first thought was:But this doesn't short-circuit once  has been found  times and is always O(n).A simple approach that does short-circuit would be:I also have a more compact short-circuiting solution with a generator:Are there other good solutions? What is the best efficient approach?Thank you
Instead of incurring extra overhead with the setup of a  object and using  which has to test the truthiness of each item, you could use  to advance the generator  steps ahead, and then return the next item in the slice if the slice exists or a default  if not:Note that like ,  also runs at C speed. And this has the extra advantage of handling iterables that are not lists.Some timing:
You could use the second argument of  to find the subsequent indices of occurrences:About  argumentsThe official documentation does not mention in its Python Tutuorial, section 5 the method's second or third argument, but you can find it in the more comprehensive Python Standard Library, section 4.6:    index of the first occurrence of x in s (at or after index i and before index j) (8)(8)  raises  when x is not found in s. When supported, the additional arguments to the index method allow efficient searching of subsections of the sequence. Passing the extra arguments is roughly equivalent to using , only without copying any data and with the returned index being relative to the start of the sequence rather than the start of the slice.Performance ComparisonIn comparing this  method with the  method, the most important factor is the distance between the occurrences to be found. Once that distance is on average 13 or more, the  has a better performance. For lower distances, the fastest method also depends on the number of occurrences to find. The more occurrences to find, the sooner the  method outperforms  in terms of average distance: this gain fades out when the number of occurrences becomes really large. The following graph draws the (approximate) border line, at which both methods perform equally well (the X-axis is logarithmic):
Ultimately short circuiting is the way to go if you expect a significant number of cases will lead to early termination. Let's explore the possibilities:Take the case of the  method versus the  method (these were the two fastest according to my testing, although ymmv)For  if the list contains n or more of x and the method is called n times. Whilst within the list.index method, execution is very fast, allowing for much faster iteration than the custom generator. If the occurances of x are far enough apart, a large speedup will be seen from the lower level execution of . If instances of x are close together (shorter list / more common x's), much more of the time will be spent executing the slower python code that mediates the rest of the function (looping over  and incrementing )The benefit of  is that it does all of the heavy lifting outside of slow python execution. It is a much easier function to analyse, as it is simply a case of O(n) time complexity. By spending almost none of the time in the python interpreter however it is almost gaurenteed to be faster for short lists. Summary of selection criteria:shorter lists favor lists of any length that don't have a high probability to short circuit favor lists that are long and likely to short circuit favor 
I would recommend using  from the  module. 
This shows another way of doing it.Sort the list.Find the index of the first occurrence of the item.Increase the index by one less than the number of times the item must occur. (n - 1)Find if the element at that index is the same as the item you want to find.
Another possibility might be:


Answer URL
https://docs.python.org/3/tutorial/datastructures.html
https://docs.python.org/3/library/stdtypes.html#common-sequence-operations
