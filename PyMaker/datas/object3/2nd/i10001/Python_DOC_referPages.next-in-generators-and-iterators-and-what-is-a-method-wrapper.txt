Natural Text
I was reading about generator and iterators and the role of  . . is true,  is falseAs I looked deeper into it,  is truewhy is only available to list but only to  and  but not . How does  call  when we are stepping thru the list using list-comprehensionTrying to manually step (+1) up the generator, I called . It doesn't exist. It only exist as which is called method-wrapper.what is a method-wrapper and what does it do? How is it applied here: in if  is what both generator and iterator provide (and their sole properties) then what is the difference between generator and iterator?*Answer to 3: Solved, as noted by mod/editor:Difference between Python's Generators and IteratorsUPDATE: both generator and iterator have . My mistake. Looking at the logs, somehow  test was giving me stopiteration exception error. But I wasn't able to duplicate that error again.Thanks everyone for answering!
The special methods  and  are part of the iterator protocol to create iterator types. For this purpose, you have to differentiate between two separate things: Iterables and iterators.Iterables are things that can be iterated, usually, these are some kind of container elements that contain items. Common examples are lists, tuples, or dictionaries.In order to iterate an iterable, you use an iterator. An iterator is the object that helps you iterate through the container. For example, when iterating a list, the iterator essentially keeps track of which index you are currently at.To get an iterator, the  method is called on the iterable. This is like a factory method that returns a new iterator for this specific iterable. A type having a  method defined, turns it into an iterable.The iterator generally needs a single method, , which returns the next item for the iteration. In addition, to make the protocol easier to use, every iterator should also be an iterable, returning itself in the  method.As a quick example, this would be a possible iterator implementation for a list:The list implementation could then simply return  from the  method. Of course, the actual implementation for lists is done in C, so this looks a bit different. But the idea is the same.Iterators are used invisibly in various places in Python. For example a  loop:This is kind of the same to the following:So the for loop requests an iterator from the iterable object, and then calls  on that iterable until it hits the  exception. That this happens under the surface is also the reason why you would want iterators to implement the  as well: Otherwise you could never loop over an iterator.As for generators, what people usually refer to is actually a generator function, i.e. some function definition that has  statements. Once you call that generator function, you get back a generator. A generator is esentially just an iterator, albeit a fancy one (since it does more than move through a container). As an iterator, it has a  method to “generate” the next element, and a  method to return itself.An example generator function would be the following:The function body containing a  statement turns this into a generator function. That means that when you call  you get back a generator object. Generator objects implement the iterator protocol, so we can call  on it (or use the the  function as above):Note that the first  call did not print anything yet. This is the special thing about generators: They are lazy and only evaluate as much as necessary to get the next item from the iterable. Only with the second  call, we get the first printed line from the function body. And we need another  call to exhaust the iterable (since there’s not another value yielded).But apart from that laziness, generators just act like iterables. You even get a  exception at the end, which allows generators (and generator functions) to be used as  loop sources and wherever “normal” iterables can be used.The big benefit of generators and their laziness is the ability to generate stuff on demand. A nice analogy for this is endless scrolling on websites: You can scroll down item after after (calling  on the generator), and every once in a while, the website will have to query a backend to retrieve more items for you to scroll through. Ideally, this happens without you noticing. And that’s exactly what a generator does. It even allows for things like this:Non-lazy, this would be impossible to compute since this is an infinite loop. But lazily, as a generator, it’s possible to consume this iterative one item after an item. I originally wanted to spare you from implementing this generator as a fully custom iterator type, but in this case, this actually isn’t too difficult, so here it goes:
Why is  only available to list but only to  and  but not . How does  call  when we are stepping through the list using list-comprehension.Because lists have a separate object that is returned from  to handle iteration, this objects  is consecutively called. So, for lists:While, for generators:In looping constructs,  is first going to get called on the target object to be looped over.  calls  and an iterator is expected to be returned; its  is called until no more elements are available.What is a method-wrapper and what does it do? How is it applied here: in  and ?A method wrapper is, if I'm not mistaken, a method implemented in . Which is what both these  ( is an object implemented in ) and  (not sure here but generators are probably too) are.If  is what both generator and iterator provide (and their sole properties) then what is the difference between generator and iterator?A generator is an iterator, as is the iterator provided from . It is an iterator since it provides a  method (which, usually, when used in a for loop it is capable of providing values until exhausted).
 and  are method wrappers for when you do  or .  is the same as So if I do  then  is  implemented as a generator object and has a  method descriptor. Lists themselves do not have this method because they are not generators.Generators are iterators. Check out difference between generators and iterators


Answer URL
https://docs.python.org/3/library/stdtypes.html#typeiter
