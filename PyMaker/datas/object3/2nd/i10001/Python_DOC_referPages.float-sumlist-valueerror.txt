Natural Text
I've been building this program to make a decision based off a sum of numbers in a given list.  When I sum the numbers in a given function that also tests ceratin required logic it gives the correct answer, but the if statement that tests the value doesn't work properly, or will execute the wrong if statement:From start if you go south 3 times you will get an error, 2 times you will end up east in the pantry, and 1 time wont do anything??? I'm very very lostThe program at this point will be followed by three more similar elif statements, however the first time you give input will be ignored, and the second time it will perform the wrong action except for the one including the prime fraction of 1/11;  side note all other elifs use increasing prime fractions{1/11, 1/13, 1/17, 1/19}.  I have very little experience programing(3-ish months) and am just learning python as my first language.  Any help would be greatly appretiated
There are a bunch of errors in your code. Lets see the ones the cause the issue you describe when you enter  as your input three times.The  function has one test that's seriously broken: That's always going to be true, so if you reach that condition (by not going north or east, which are tested for earlier), you always end up going to the pantry.The  function has a similar issue, where you're not converting some of your fractions to  before subtracting from the value you get from the parsing code. This causes the exception you see.The reason you have the  twice is that your  function always calls the current room's function twice (on two consecutive lines). The choice made the first time is ignored.There are probably more errors in other parts of the code that I looked at yet.You're making your task much more difficult than it needs to be by using fractions for the values you parse your input text into. A much better approach would be to use integer powers of two, and use bitwise-or () to combine them. For instance, if the word  parsed to  () and  parsed to  (), your test for  or  could be  (with no type conversions or epsilon needed). If you don't care about extra words, you could use bitwise-and () to just test for one term: .You might also consider using an  if you're using a version of Python that includes the  module (it was added in Python 3.4).
This are the issues with your program:You use  for equally testing when you should use , for example in herethe  operator tell you if the to object have the same place in memory not if they have the same value, usually they may be the same for immutable object like strings but you can't count on that, for examplewhile using  give the correct answerchange all the  for You don't need to compare Boolean values or any other value against  or . In python, when a object is used in and Boolean context that object behave as True or Falsevalues are interpreted as false: , , numeric zero of all types, and empty strings and containers (including strings, tuples, lists, dictionaries, sets and frozensets). All other values are interpreted as true. User-defined objects can customize their truth value by providing a  method.so this for instancechange it to In your  function you call your other functions twice which cause that the first time the result to be ignored as you do nothing with itlike in herethe same with  and . Remove the first call of each one to solve that issue.In the pantry function, hereperhaps you mean?the same with the  in the third in the  in the second  what is this suppose to mean? by point 2, that is always true as none of those number is zero, so if fail the other check, this always will passIn  in the for-loopyou never use the , so there is no reason to use enumerate, so change it toalso you repeat the  too many times, you should try to avoid repeat instructions that always give the same result because is a waste of time, instead make a new variable or reuse the one you have con the result of that method for instanceyou can also call the  as soon as you get the input like or as you split it then Finally as you may have notice Decimal and floats don't like each other very much as I said in my previous comment, choose one or the other and stick with it all the way. Or as Blckknght suggest, change instead to use Bit Mask, or enumeration 


Answer URL
https://docs.python.org/3/reference/expressions.html#is
https://docs.python.org/3/library/stdtypes.html?#comparisons
https://docs.python.org/3/reference/expressions.html#boolean-operations
https://docs.python.org/3/library/enum.html?
