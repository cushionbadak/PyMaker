Natural Text
I have the following data:and want to create a list of the names which index is in . The list must have the size specified in the variable .I could not achieve it by doing this (wrong length):and I don't like this solution because declaring the empty list at the beginning is not elegant.I can do this:but that's a bit unreadable and the list length is still wrong. Is there a correct and more beautiful way to create that list? maybe something like this?
 wouldn't even solve this since it would cause you to stop when you'd pulled  elements, not when you'd kept  elements. The only reason it seems to work is that you use a test for  (which actually keeps  elements), and your  happens to be one element larger than . If  was larger, or  smaller, your test wouldn't work as intended.If the goal is to keep  elements, without processing more elements than needed, then the simplest approach (assuming you don't mind slicing to create a small intermediate , which is usually okay) is just:If  and  are huge, you can use  with a generator expression to avoid the intermediate slice, using less memory, but somewhat more CPU:The fastest option I can find, avoiding any explicit looping at all, is using the  module, though it involves temporaries for argument passing, which is probably a bad idea if  is ever going to be huge (10s of thousands and up):This creates an  callable that will look up the first  elements from , then immediately calls it on , returning a  of all the values (wrap the  call in  if you need a mutable  result instead of a ). It also avoids all Python level loops in CPython; a loop still occurs at the C layer in CPython, but a loop at the C layer runs a lot faster than any loop at the Python layer. For simple   tests, the  approach won, taking ~24% less time than slice +  comprehension (which in turn was about 9% faster than  +  comprehension). For larger inputs (I just multiplied  and  by 100),  wins by a factor of 3x (slice still beats , but by a meaningless margin; the overhead in  is mostly in setup, and doesn't increase meaningfully as the number of items sliced goes up).All are equivalent to:except they don't populate the complete  first, then cut it down to ; they get enough entries and stop immediately.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.islice
https://docs.python.org/3/library/operator.html
