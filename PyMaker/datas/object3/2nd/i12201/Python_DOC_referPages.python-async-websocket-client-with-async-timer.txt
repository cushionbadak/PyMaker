Natural Text
I need to have a long running websocket client that receives push messages from a websocket server and I need to monitor the client's connection state: if the connection goes down, I need to find out. My approach is to periodically log a constant string, and trigger an alarm if ever the log message is not detected.My idea: 1) have a websocket client that responds to irregularly incoming messages. And 2) at the same time have loop that stops logging a message when the websocket client throws a ConnectionClosed exeption.I am intrigued by the new 3.5 async syntax. This websocket implementation is specifically based on the asyncio. The client in the docs look exactly like what I need. However, I have no idea how to add a second coroutine that does my logging statements and somehow stops when the websocket connection throws the ConnectionClosed.Here is something to start the conversation but that doesn't work because the alive method blocks the event loop. What I am looking for is an elegant solution to run both methods concurrently.
Actually the  is blocking here, since it waits until  finish.You can solve it with 2 steps:schedule coroutines with  (immediately runs without waiting for results), each returning task. wait for tasks to get finished with  The code like:As @Vincent mentioned  accepts tasks, so  is needless:


Answer URL
https://docs.python.org/3/library/asyncio-task.html#asyncio.ensure_future
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.wait
