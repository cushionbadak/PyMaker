Natural Text
My Django project has hundreds of test in various modules across a number of apps. Recently we added a feature where an email gets sent (via sendgrid) on creation of a User object (using Django Signals).The problem we ran into is that when running tests, many users are created either explicitly or as fixtures. This results in many hundreds of emails being sent on each test cycle, and because most of them are invalid we get hundreds of bounces. In addition to the costs involved, Sendgrid actually suspended our account briefly due to the odd behaviour.Obviously I can mock the call on each test individually, however this would have to take place in hundreds of places, and we would have to remember to do it on all future tests we create.Is there an easier way to globally mock a particular chunk of code for all tests (leaving it intact for when actually running of course)
I don't use Django and maybe there is some idiomatic way to do it well in Django. My approach to this kind of problem is to create my own  class that extend from  and override /// to set up the mock/patch that I need globally in my tests (or at least in a part of them).Now every time I need it instead of importing  module I'm importing Example: And in your tests:
Below are two methods to implement mocking.Method 1: With modifications to production code:You can create a pseudo-package and import it for testing instead of importing the original package. This check-based-import could be done at the beginning of every file. For example:Method 2: No modifications to production code:In your test program, you could import the utility package ( the package containing the email function described in the question) and overwrite the utility function. For example:Consider the following code:The test code could do the following:The output for above test was:Thus the test code can import the utility file, overwrite the function it provides and then run the tests on production code. This method is superior as it does not change production code.
Two ways that I have used in a big django project Assuming a: 1) You can add a mock inside a custom test runner class:2) You can add a mock on a custom base test class:


Answer URL
https://docs.python.org/3/library/unittest.mock.html#patch
