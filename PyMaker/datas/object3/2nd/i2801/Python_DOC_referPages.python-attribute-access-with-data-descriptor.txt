Natural Text
I've read some blogs and docs that when access an instance attribute :try accessing data descriptor (named ) in current class  and base class __dict__find  in find non-data descriptor (named ) in current class  and base class find attribute (named ) in current class  and base class call  if anyraise But I found that this searching rule does not match the behavior of below codes:I think the last  will invoke the  in , because according to the 1st rule,  of base class  contains the attribute  that we're accessing, so that data descriptor should be called. So is the above access rule wrong or any other magic involved here ?
You misunderstood how descriptors are found in classes. Python will use the first such name in the class hierarchy. Once found, the search stops.  exists, so  is not considered.The documentation tells you about base classes for the case where  does not define ; in that case  is searched, then . But when  has an attribute , any further search is stopped.Note that the search order is set by the class MRO (method resolution order). Rather than distinguish between a search in the class , and separately, the  attributes of the base classes, you should see the search as:The MRO (as embodied by the  attribute) includes the current class object:The relevant documentation is found in the datamodel reference; where Custom Classes states:Class attribute references are translated to lookups in this dictionary, e.g.,  is translated to  (although there are a number of hooks which allow for other means of locating attributes). When the attribute name is not found there, the attribute search continues in the base classes.The actual implementation for instance attributes works like this:The class is located ()The class  method is called () scans the MRO to see if the name exists on the class and its base classes ()if there is such an object, and it is a data descriptor (has a  or  method), this object is used, and the search stops.if there is such an object but it is not a data descriptor, a reference is kept for later. looks for the name in if there is such an object, the search stops. The instance attribute is used.There was no data descriptor found, and no attribute in the instance dict. But the search through the MRO may have located a non-data-descriptor objectif there is a reference to an object found in the MRO, it is used and the search stops.If there is a  method defined on the class (or a base class), it is called, and the result is used. Search stops.an  is raised.
There aren't three separate searches through the class and the base class. (Also, it's not just the class and its base; it's the entire MRO.) There's one search through the MRO, and it stops as soon as it finds something, regardless of what parts of the descriptor protocol the found object may or may not support.When the search for  finds , it stops the MRO search. It doesn't keep looking just because  isn't a descriptor.Here's the correct version of the standard attribute resolution logic, implemented in . (This is only ; it doesn't cover classes with their own  or .)Search the object's MRO for a dict entry matching the attribute name.If the MRO search finds a data descriptor with a  method, stop searching and use the descriptor.Otherwise, we check the instance dict. If there's an entry matching the attribute name, stop and use that. If there is no matching entry (or if there is no instance dict), continue.If the step 2 search found a non-data-descriptor or a non-descriptor, use that.Otherwise, lookup fails. Raise an AttributeError.


Answer URL
https://docs.python.org/3/reference/datamodel.html
https://docs.python.org/3/reference/datamodel.html
