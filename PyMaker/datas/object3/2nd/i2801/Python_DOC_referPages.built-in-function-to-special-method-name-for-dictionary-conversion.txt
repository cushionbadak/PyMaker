Natural Text
I've been delving into operator overloading and special methods within Python classes, and I noticed that many built-in functions have their equivalent special method names: calls  calls  or  in Python 2However, a couple functions, namely  and , do not have any equivalent. I am aware that the need has not arised yet for such special methods, but in some cases, a method for  conversion called on a class may be useful. How might I implement this? Or, what would you remark on someone attempting to use this kind of logic?
Option 1: Casting to  or , or any type that takes an iterable, relies on the  method.The same will work for tuples.Option 2:  and Alternatively, to cast to a , you can implement both  and .Option 3: Both for supporting multiple typesFinally, if you want your class to have different behaviour for casting to a  and a , the following example demonstrates that  will prioritize the  and  solution.
In it's simplest form, I could try and retrieve . I've also created a method, called  that returns a , but can customise what values are returned and how. I implemented a small function that tries to call  and other successive attempts at other methods:For demonstration, a little class which encapsulates a :Now consider calling my custom  function on a few objects to test it out:As you can see, it seems to work in a decent way. I know that for my simple  class demonstration, I could have simply returned , but I added an extra  attribute which only exists in  form to show that this enables extra customisation. In addition, if I defined the  class with , then the  call would fail withObviously, I could extend the  blocks to attempt to access  as well, but this is not the point I am trying to get across: If I defined the following in the custom  method, the code wouldwork as expected:


Answer URL
https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers
