Natural Text
I'm trying to resolve this error:  in my asyncio process. I believe it's happening because there's a failure while tasks are still pending, and then I try to close the event loop. I'm thinking I need to await the remaining responses prior to closing the event loop, but I'm not sure how to accomplish that correctly in my specific situation.How can I handle the error and properly close the event loop so I can start a new one and essentially re-boot the whole program and continue on.EDIT:This is what I'm trying now, based on this SO answer. Unfortunately, this error only happens rarely, so unless I can force it, i will have to wait and see if it works. In my  method I changed it to this:UPDATE:I got rid of the  method and added this to my  method instead and it seems to be working without issue:  
To answer the question as originally stated, there is no need to  a running loop, you can reuse the same loop for the whole program.Given the code in the update, your  could look like this:Cancelling  is not necessary and as far as I can tell has no effect. This is different from the referenced answer which specifically reacts to , special because it is raised by asyncio itself.  can be propagated by  without the future having actually completed. Handling Ctrl-C correctly in asyncio is very hard or even impossible (see here for details), but fortunately the question is not about Ctrl-C at all, it is about exceptions raised by the coroutine. (Note that  doesn't inherit from , so in case of Ctrl-C the except body won't even execute.)I was canceling the future because in this instance there are remaining tasks pending and i want to essentially remove those tasks and start a fresh event loop.This is a correct thing to want to do, but the code in the (updated) question is only canceling a single future, the one already passed to . Recall that a future is a placeholder for a result value that will be provided at a later point. Once the value is provided, it can be retrieved by calling . If the "value" of the future is an exception,  will raise that exception.  has the contract that it will run the event loop for as long as it takes for the given future to produce a value, and then it returns that value. If the "value" is in fact an exception to raise, then  will re-raise it. For example:When the future in question is in fact a , an asyncio-specific object that wraps a coroutine into a , the result of such future is the object returned by the coroutine. If the coroutine raises an exception, then retrieving the result will re-raise it, and so will :When dealing with a task,  finishing means that the coroutine has finished as well, having either returned a value or raised an exception, as determined by  returning or raising.On the other hand, cancelling a task works by arranging for the task to be resumed and the  expression that suspended it to raise . Unless the task specifically catches and suppresses this exception (which well-behaved asyncio code is not supposed to do), the task will stop executing and the  will become its result. However, if the coroutine is already finished when  is called, then  cannot do anything because there is no pending  to inject  into.


Answer URL
https://docs.python.org/3/library/asyncio-task.html#asyncio.Task
