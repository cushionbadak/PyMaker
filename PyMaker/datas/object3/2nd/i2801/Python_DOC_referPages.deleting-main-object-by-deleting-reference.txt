Natural Text
I am working with large nested dictionaries, and am trying to delete nested subdictionaries.  I am wondering why the following behavior occurs. When I set a reference to dictionary d (called ref), then I change ref and print d, it shows an updated version of d with the third element added. Given this behavior, I was expecting to be able to delete the dictionary by deleteI am wondering if there is a way to delete the original object when I delete the reference (meaning that the output of the second program would be an error because d was deleted.
The  statement behaves differently depending on what is being deleted. Paraphrasing slightly:Deletion of a name removes the binding of that name from the local or global namespaceThat is the second case presented. You've got two references to the same object. The name  has been deleted, but the name  still exists and points to the same object is always did.However, attributes, subscriptions, and slicings have different behaviour:Deletion of attribute references, subscriptions and slicings is passed to the primary object involvedThat is more like the first case - deleting an element from either name will be reflected in the other:So, wrapping the references inside a dictionary (or other container), will allow deletion by any reference.
 doesn't actually handle any de-allocation of memory, it merely unbinds a value from a name, and then decrements the reference count of that object by one. There is no way to systematically unbind all names from an object given a single reference.An object is not garbage collected until some point after the reference count drops to 0. You can see an object's reference count by using the  method (which is typically one higher than it actually is because of the temporary reference within the method itself).We can demonstrate  in practice using this method and the  method (which is called only when the reference count for the object is decremented to 0):If you're curious to read more about how all of this works internally, check out the  API documentation on the internal calls for reference counting, and check out the  module, which is the high level python interface for introspecting the garbage collection sub-system.Given your specific problem, since you are working with dictionaries which are mutable types, you could just  the dictionary:Alternatively you can use the equivalent  syntax to clear the dictionary .


Answer URL
https://docs.python.org/3/tutorial/datastructures.html#the-del-statement
https://docs.python.org/3/library/sys.html#sys.getrefcount
https://docs.python.org/3/reference/datamodel.html#object.__del__
https://docs.python.org/3/library/stdtypes.html#typesmapping
