Natural Text
How to increment  if  is  of  without code dublication?Here we can see that we duplicated (in the code) a chain of keys 3 times.Question: Is it possible to write a function  that will take  and do the same job as above? So:Update (20 Aug 2018):There is still no answer to the question. It's clear that there are options "how to do what I want", but the question is straightforward: there is "value", we pass it to a function, function modifies it. It looks that it's not possible.Just a value, without any "additional keys", etc.If it is so, can we make an answer more generic?Notes:What is defaultdict of defaultdicts - SO.This question is not about "storing of integers in a defaultdict", so I'm not looking for a hierarchy of defaultdicts with an int type at the leaves.Assume that type ( in the examples) is known in advance / can be even parametrized (including the ability to perform  operator) - the question is how to dereference the object, pass it for modification and store back in the context of defaultdict of defaultdicts.Is the answer to this question related to the mutability? See example below:Example:Where  is:
It's not exactly abut mutability, more about how assignment performs name binding.When you do  in your  function you bind a new object to the name , and any connection between that name and the previous object bound to that name is lost. That doesn't depend on whether or not  is mutable.But since  is an item in a mutable object we can achieve what you want by passing the parent mutable object to  along with the key needed to access the desired item.outputNow we aren't binding a new object, we're merely mutating an existing one, so the original  object gets updated correctly.BTW, that deeply nested dict is a bit painful to work with. Maybe there's a better way to organize your data... But anyway, one thing that can be handy when working with deep nesting is to use lists or tuples of keys. Eg, now refers to 
You can't have multiple default types with . You have the following options:Nested  of  objects indefinitely; of  objects, which likely won't suit your needs; of  down to a specific level with  defined for the last level, e.g.  for a single nesting;Similar to (3), but for counting you can use  instead, i.e. .I recommend the 3rd or 4th options if you are always going to go down to a set level. In other words, a scalar value will only be supplied at the nth level, where n is constant.Otherwise, one manual option is to have a function perform the type-testing. In this case,  /  may be a good alternative. Here we also define a recursive algorithm to allow you to feed a list of keys rather than defining manual  calls.


Answer URL
https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference
