Natural Text
This is a follow up question to this question:Why do most asyncio examples use loop.run_until_complete()?I'm trying to figure out how asynchronous programming work in python. There's something very basic which I'm still not sure about..when having this line code:  , will this line ALONE actually enqueue the  returned in the default event loop and start the task? Or do I ALSO need to call  (or some other kind of run) before that in order to get the event loop up and running? 
  will this line ALONE actually enqueue the Future returned in the default event loop and start the task?It will schedule the coroutine, but it won’t run it. You still need to run the loop to do that. You can do that with If you want the loop to run until  is done rather than forever, useDon’t call both  and  or you’ll end up with a  since  will have already been scheduled. 
when having this line code: , will this line ALONE actually enqueue the Future returned in the default event loop and start the task?That depends on when the line is executed. If it executes from some coroutine while the event loop is running, then you truly don't need to do anything else - the task will appear to magically run "in the background".If the event loop isn't running yet, then you need to spin up the event loop for any task to run, not just the freshly added one.  is just one option, other is , meaning "run the event loop until someone calls ".Note that  is a no-op because if you already have a , it will just be returned unchanged.  will wrap the coroutine into a , schedule it in the event loop, and return it, effectively calling  for you. When the argument is known to be a coroutine, it is recommended to call  directly.


Answer URL
https://docs.python.org/3/library/asyncio-task.html#asyncio.Task
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.create_task
