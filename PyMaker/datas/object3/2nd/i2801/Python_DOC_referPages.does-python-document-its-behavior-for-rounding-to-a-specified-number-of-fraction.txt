Natural Text
Is the algorithm used for rounding a  in Python to a specified number of digits specified in any Python documentation? The semantics of  with zero fractional digits (i.e. rounding to an integer) are simple to understand, but it's not clear to me how the case where the number of digits is nonzero is implemented.The most straightforward implementation of the function that I can think of (given the existence of  to zero fractional digits) would be:I'm trying to write some C++ code that mimics the behavior of Python's  function for all values of , and the above agrees with Python for the most part, when translated to equivalent C++ calls. However, there are some cases where it differs, e.g.:There is clearly a difference that occurs when the value to be rounded is at or very near the exact midpoint between two potential output values. Therefore, it seems important that I try to use the same technique if I want similar results.Is the specific means for performing the rounding specified by Python? I'm using CPython 2.7.15 in my tests, but I'm specifically targeting v2.7+.
Also refer to What Every Programmer Should Know About Floating-Point Arithmetic, which has more detailed explanations for why this is happening as it is.This is a mess. First of all, as far as  is concerned, there is no such number as 0.493125, when you write 0.493125 what you actually get is:0.493124999999999980015985556747182272374629974365234375So this number is not exactly between two decimals, it's actually closer to 0.49312 than it is to 0.49313, so it should definitely round to 0.49312, that much is clear.The problem is that when you multiply by 105, you get the exact number 49312.5. So what happened here is the multiplication gave you an inexact result which by coincidence canceled out the rounding error in the original number. Two rounding errors canceled each other out, yay! But the problem is that when you do this, the rounding is actually incorrect... at least if you want to round up at midpoints, but Python 3 and Python 2 behave differently. Python 2 rounds away from 0, and Python 3 rounds towards even least-significant digits.Python 2if two multiples are equally close, rounding is done away from 0Python 3...if two multiples are equally close, rounding is done toward the even choice...SummaryIn Python 2,In Python 3,And in both cases, 0.493125 is really just a short way of writing 0.493124999999999980015985556747182272374629974365234375.So, how does it work?I see two plausible ways for  to actually behave.Choose the closest decimal number with the specified number of digits, and then round that decimal number to  precision. This is hard to implement, because it requires doing calculations with more precision than you can get from a .Take the two closest decimal numbers with the specified number of digits, round them both to  precision, and return whichever is closer. This will give incorrect results, because it rounds numbers twice.And Python chooses... option #1! The exactly correct, but much harder to implement version. Refer to Objects/floatobject.c:927 double_round(). It uses the following process:Write the floating-point number to a string in decimal format, using the requested precision.Parse the string back in as a .This uses code based on David Gay's dtoa library. If you want C++ code that gets the actual correct result like Python does, this is a good start. Fortunately you can just include  in your program and call it, since its licensing is very permissive.
The Python documentation for  and 2.7 specifies the behaviour:Values are rounded to the closest multiple of 10 to the power minus  ndigits; if two multiples are equally close, rounding is done away  from 0.For 3.7:For the built-in types supporting round(), values are rounded to the  closest multiple of 10 to the power minus ndigits; if two multiples  are equally close, rounding is done toward the even choiceUpdate: The (cpython) implementation can be found floatobjcet.c in the function , which calls  if  is not given, but  if it is. has two implementations.One converts the double to a string (aka decimal) and back to a double.The other one does some floating point calculations, calls to  and at its core calls . It seems to have more potential problems with overflows, since it actually multiplies the input by .For the precise algorithm, look at the linked source file.


Answer URL
https://docs.python.org/3/library/functions.html#round
https://docs.python.org/3/library/functions.html#round
