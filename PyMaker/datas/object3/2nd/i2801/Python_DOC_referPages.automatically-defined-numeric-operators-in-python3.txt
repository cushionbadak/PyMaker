Natural Text
I'm trying to create a custom class that behaves like an integral numeric type. The straightforward way to do that is to consult Python3 documentation on the matter, and then implement all the magic functions: both arithmetic  and comparison  operators.However, implementing them all by hand is tedious. I believe that in many cases, a good enough solution would be to implement them automatically based on the  magic function: we simply do the arithmetic with the object converted to int. Is this part of any commonly used library? What I'm looking for is something similar to @functools.total_ordering, which automatically derives all comparison operators from only one of the operators.If there is no such thing, then why? Would it be a bad idea to have such automatic conversion, or is it simply an issue one does not encounter too often?Edit: In case that the details of the custom class are relevant, I provide some of them here.What I'm constructing is a counter whose value can change not only through arithmetic operations, but also other means. These can be very general: for example, we can tell the counter the following: "If anybody asks you what value you represent, return twice the normal value."To illustrate, suppose you're playing a board game, for example, similar to Civilization. The game makes use of many parts, one of them is the counter that counts the military strength your civilization has. However, there may be an in-game effect which causes each point of strength to count twice.Since the class is required to be mutable, I believe subclassing int is not an option (as int is immutable).
You can write your own mixin class or decorator that does this, similarly to the way  implements a bunch of  methods on top of a handful that you write manually, or  implements a bunch of comparison methods for you. (If you're wondering how to decide which one to use: if the code has to examine your class before modifying it, as with , your mixin would need a custom metaclass, so a decorator is easier. Otherwise, a mixin is usually simpler.)There are dozens of implementations of this idea floating around PyPI and the ActiveState recipes and random blog posts and GitHub repos. But the problem isn't quite generalizable to turn a solution into a widely-used library.As for the specific case you want—an object that acts like a mutable , and implements it on the basis of its  method—I think that specific case just doesn't come up often enough that anyone has sat down and written it.Anyway, getting all of this right—including things like  and —is a bit of a pain.Implementing the arithmetic operations in the  documentation explains exactly what you want to do to get it right. It also contains an explanation of the source code used by the  library to reduce the boilerplate and repetition of defining all of these methods on , which is very handy.The only problem with all of that is that it's written for immutable numeric types, not mutable ones. So, if you want to use it, you'll need to modify it, with an  function that builds and returns  instead of just .However, your case is simpler than , so you can simplify the operator-function-creating methods, like this:You might want to consider . You might also want to make your class a subtype of . If you do both, be careful about how you construct them, so you don't end up with an  instead of an .If you wanted to generalize this into a mixin that can be used for mutable , , , , , etc. types, you could just add a  method that all of your types have to implement, instead of relying on . Although you'd have to think through the conversion issues ( is easy, being on the base of the numeric tower).


Answer URL
https://docs.python.org/3/library/numbers.html#implementing-the-arithmetic-operations
https://docs.python.org/3/library/fractions.html
