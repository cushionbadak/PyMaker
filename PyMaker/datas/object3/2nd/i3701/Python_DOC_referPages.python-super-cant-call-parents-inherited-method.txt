Natural Text
I have a question in Python that seems very complex to me, that combines inheritance, recursion, and the super() function.First of all, I am using Python 3, and I have a structure of deep inheritance.In the very first parent class I declare a method, and I want that method to be called from each child class in the hierarchy, but with different inputs for each of them. The use of that structure seems very pythonic to me and it really saves me from a lot of code repetition.A simplified sample of my code is shown below:I expect that code to print Instead it raises an attribute error:I know that it is a complex problem, but I have tried to divide it. I tried to remove the recursion part, but I do not get any better.Based on the various attempts I have done, I believe that I am very close to the cause of the problem, and it seems to me like a syntax problem or something that simple.Thanks!!
I'm afraid you have built up the wrong mental model on how Python instances and classes relate. Classes only provide a series of attributes for instances to 'inherit', not separate namespaces for instance attributes to live in. When you look up an attribute on an instance and the attribute doesn't exist on the instance itself, a search is done of the classes that back the instance, with the 'nearest' class with that attribute winning over others.  just lets you reach attributes with the same name but defined on a next class in that same layered search space.In order for  to work correctly, Python records what class the  function was defined on. Here that's , and  will only find attributes on the parent classes of . In your example,  and  had already been searched and they didn't have a  attribute, so  is being used, but there is no further  attribute in the rest of the layers that are searched (only  remains, and there is no ).You don't need to use  when subclasses are not overriding a method, nor can you do what you want with  anyway. Note that the  and  subclasses do not get a copy of the method at all, there is no  direct attribute that needs to account for  to exist, etc. Again, what happens when looking up attributes on an instance is that all class objects in the inheritance hierarchy of the instance are inspected for that attribute, in a specific order.Take a look at your subclasses:The  attribute gives you the method resolution order of your  class object; it is this order that attributes are searched for, and that  uses to further search for attributes. To find , Python will step through each of the objects in  and will return the first hit, so .In your example, you used  in the  definition. Python has attached some information to that function object to help further searches of attributes:When you call  the closure I show above is used to start a search along the  sequence, starting at the next object past the one named in the closure. It doesn't matter that there are subclasses here, so even for your  object everything is skipped an only  is inspected:At no point are  or  involved here anymore. The MRO depends on the class hierarchy of the current instance, and you can make radical changes when you start using multiple inheritance. Adding in extra classes into a hierarchy can alter the MRO enough to insert something between  and : inherits from  and from .  inherits from  too. Python follows some complicated rules to put all classes in the hierarchy into a logical linear order, and  ends up between  and  because it inherits from the latter, and not the former.Because  is injected into the MRO after , calling  changes how  behaves, and suddenly calling that method will do something different:Remember, it helps to see classes as a layered search space for attributes on instances!  is searched for along the classes if the attribute doesn't exist on the instance itself.  just let you search for the same attribute along the remainder of that search space.This lets you reuse method implementations when implementing a method with the same name in a subclass. That's the whole point of !There are other problems with your code.When looking up methods, they are bound to the object they were looked up on.  binds the method to , so that when you call , Python knows what to pass into the method as .  For  objects,  is replaced with , unless you did , at which point  is used.So your  method will always be producing  for , as the  object that is passed in is that of the current instance.  doesn't change what class s are bound to when accessed on an instance! It'll always be .You also forgot to call  in the  and   methods, so for , only  is ever actually used. The  and  implementations are never called. You'd have to add a call to  in both for that to happen, at which point there are three  assignments on the same instance, and only the one that executes last will remain. There is no separate  for each of the classes that make up the code for the instance, so there are no separate  attributes with different values.Again, that's because  is called,  is bound to  for the  argument, and even if you used  the  that is passed on remains .What you want to achieve is something entirely different from an attribute search across all of the classes. Printing all class names can be done with a loop over  instead:This then produces:If you have to print , ,  you can add extra attributes to each class:and you'll getprinted.
Thats because you're trying to access Method1() on Object_classYou've written an if-else which satisfies when you're instantialize with Class C and access method1().To print a,b,c, you will need override the method in every class.. and calling super from them. However, this will still have a problem. Because the self attribute carries the instance of Class C, not Class B or A. So, they can't access the attribute that you're initializing in the init func. Final code looks like this


Answer URL
https://docs.python.org/3/howto/descriptor.html
