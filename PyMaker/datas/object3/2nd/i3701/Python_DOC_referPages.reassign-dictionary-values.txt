Natural Text
I have a dictionary likeHow can I remove elements from this dictionary without creating gaps in values, in case the dictionary is not ordered? An example:I have a big matrix, where rows represent words, and columns represent documents where these words are encountered. I store the words and their corresponding indices as a dictionary. E.g. for this matrixthe dictionary would look like:If I remove the words  and , the matrix would contain only two rows. So the value of  in the dictionary should now equal  and not , and the value of  should be  instead of . In Python 3.6+ dictionaries are ordered, so I can just write something like this to reassign the values:or, alternativelyI think, this is far from being the most efficient way to change the values, and it wouldn't work with unordered dictionaries. How to do it efficiently? Is there any way to easily reassign the values in case the dictionary is not ordered?
Turn the dict into a sorted list and then build a new dict without the words you want to remove:This has a runtime of O(n) because manually ordering the list  with indexing operations is a linear operation, as opposed to  which would be O(n log n).See also the documentation for  and .
You can use your existing logic, using a representation of the dictionary that is sorted:
Initially we haveTo reorder based on from minimum to maximum, you may use  and dictionary comprehension.Does this okay..? 
You could always keep an inverted dictionary that maps indices to words, and use that as a reference for keeping the order of the original dictionary. Then you could remove the words, and rebuild the dictionary again:Which Outputs:Note: Like the accepted answer, this is also . 
You are using the wrong tool () for the job, you should use a A note on complexityI had several comments mentioning that a  is more efficient because it's lookup time is  and the lookup time of a  is .This is simply not true in this case.The  guarantee of a hash table ( in python), is a result of an amortised complexity, meaning, that you average a common usage of lookup table that is generated once, assuming that your hash function is balanced.This amortised calculation does not take into account deleting the entire dictionary and regenerating it every time you remove an item, as some of the other answers suggest.The  implementation and the  implementation have the same worst-case complexity of .Yet, the  implementation could be optimised with two lines of python () to have a worst-case complexity of 


Answer URL
https://docs.python.org/3/library/functions.html#sorted
https://docs.python.org/3/library/itertools.html#itertools.count
https://docs.python.org/3/library/functions.html#next
