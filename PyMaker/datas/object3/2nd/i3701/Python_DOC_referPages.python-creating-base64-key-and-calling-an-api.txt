Natural Text
There appears to be two different ways to convert a string to bytes, as seen in the answers to TypeError: 'str' does not support the buffer interfaceWhich of these methods would be better or more Pythonic? Or is it just a matter of personal preference?
If you look at the docs for , it points you to :bytearray([source[, encoding[, errors]]])Return a new array of bytes. The bytearray type is a mutable sequence of integers in the range 0 <= x < 256. It has most of the usual methods of mutable sequences, described in Mutable Sequence Types, as well as most methods that the bytes type has, see Bytes and Byte Array Methods.The optional source parameter can be used to initialize the array in a few different ways:If it is a string, you must also give the encoding (and optionally, errors) parameters; bytearray() then converts the string to bytes using str.encode().If it is an integer, the array will have that size and will be initialized with null bytes.If it is an object conforming to the buffer interface, a read-only buffer of the object will be used to initialize the bytes array.If it is an iterable, it must be an iterable of integers in the range 0 <= x < 256, which are used as the initial contents of the array.Without an argument, an array of size 0 is created.So  can do much more than just encode a string. It's Pythonic that it would allow you to call the constructor with any type of source parameter that makes sense. For  encoding a string, I think that  is more Pythonic than using the constructor, because it is the most self documenting -- "take this string and encode it with this encoding" is clearer than  -- there is no explicit verb when you use the constructor.Edit: I checked the Python source. If you pass a unicode string to  using CPython, it calls PyUnicode_AsEncodedString, which is the implementation of ; so you're just skipping a level of indirection if you call  yourself.Also, see Serdalis' comment --  is also more Pythonic because its inverse is  and symmetry is nice.
Its easier than it is thought:
The absolutely best way is neither of the 2, but the 3rd. The first parameter to  defaults to  ever since Python 3.0. Thus the best way is This will also be faster, because the default argument results not in the string  in the C code, but , which is much faster to check!Here be some timings:Despite the warning the times were very stable after repeated runs - the deviation was just ~2 per cent.Using  without an argument is not Python 2 compatible, as in Python 2 the default character encoding is ASCII.
You can simply convert string to bytes using:and you can simply convert bytes to string using: and  have  as default value.The following functions (taken from Effective Python) might be useful to convert  to  and  to :



Answer URL
https://docs.python.org/3/library/functions.html#func-bytearray
https://docs.python.org/3/library/stdtypes.html#str.encode
