Natural Text
It is well known, that small -objects are automatically "interned" by CPython (similar to the intern-function for strings). Correction: As explained by @abarnert it is more like the integer-pool than the interned strings.Is  it  possible to restore the interned bytes-objects after they have been corrupted by let's say an "experimental" third party library or is the only way to restart the kernel?The proof of concept can be done with Cython-functionality (Cython>=0.28):or as suggested by @jfs through :Obviously, by misusing C-functionality,  changes immutable (or so the CPython thinks) object  to  and because this -object is interned, we can see bad things happen afterwards:It is possible to restore/clear the byte-object-pool, so that  means  once again?A little side note: It seems as if not every -creation process is using this pool. For example:
Python 3 doesn't intern  objects the way it does . Instead, it keeps a static array of them the way it does with .This is very different under the covers. On the down side, it means there's no table (with an API) to be manipulated. On the up side, it means that if you can find the static array, you can fix it, the same way you would for ints, because the array index and the character value of the string are supposed to be identical.If you look in , the array is declared at the top:… and then, for example, within :Notice that the array is , so it's not accessible from outside this file, and that it's still refcounting the objects, so callers (even internal stuff in the interpreter, much less your C API extension) can't tell that there's anything special going on.So, there's no "correct" way to clean this up.But if you want to get hacky…If you have a reference to any of the single-char bytes, and you know which character it was supposed to be, you can get to the start of the array and then clean up the whole thing.Unless you've screwed up even more than you think, you can just construct a one-char  and subtract the character it was supposed to be.  is going to return the object that's supposed to be , even if it happens to actually hold . How do we know that? Because that's exactly the problem that you're trying to fix.Actually, there are probably ways you could break things even worse… which all seem very unlikely, but to be safe, let's use a character you're less likely to have broken than , like :The only other caveat is that if you try to do this from Python with  instead of from C code, it would require some extra care,1 but since you're not using , let's not worry about that.So, now we have a pointer to , we can walk it. We can't just delete the objects to "unintern" them, because that will hose anyone who has a reference to any of them, and probably lead to a segfault. But we don't have to. Any object that's in the table, we know what it's supposed to be— is supposed to be a one-char  whose one character is . So just set it back to that, with a loop something like this:That's all there is to it.Well, except for compilation.2Fortunately, at the interactive interpreter, each complete top-level statement is its own compilation unit, so… you should be OK with any new line you type after running the fix.But a module you've imported, that had to be compiled, while you had the broken strings? You've probably screwed up its constants. And I can't think of a good way to clean this up except to forcibly recompile and reimport every module.1. The compiler might turn your  argument into the wrong thing before it even gets to the C call. And you'd be surprised at all the places you think you're passing around a  and it's actually getting magically converted to and from . Probably better to use a .2. If you compiled some code with  in it, the consts array should have a reference to , which will get fixed. But, since  are known immutable to the compiler, if it knows that , it may actually store the pointer to the  singleton instead, for the same reason that  is true, in which case fixing  may not actually solve the problem.
I followed the great explanation of @abarnert and here is my implementation of his idea in Cython. Things to consider:There is a bytes-pool (like it is the case for integers) and not a dynamically structure (like it is the case for string-interning). So we can just brute-force all bytes-objects in this pool and ensure that they have the right value.Only bytes-objects constructed via  and  are using the internal pool, so make sure to use them.This leads to the following implementation:Slightly differences (and in my opinion advantages to the original proposal):this version doesn't need the knowledge, how the byte-object-pool is built and that it is a continuous array. no potentially corrupted bytes-objects are used.And now:For testing purposes, there is function corrupting (almost) all objects in the pool:


Answer URL
https://docs.python.org/3/library/sys.html#sys.intern
