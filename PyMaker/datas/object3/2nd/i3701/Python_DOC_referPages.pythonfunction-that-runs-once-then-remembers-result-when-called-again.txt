Natural Text
I just started Python and I've got no idea what memoization is and how to use it. Also, may I have a simplified example?
Memoization effectively refers to remembering ("memoization" → "memorandum" → to be remembered) results of method calls based on the method inputs and then returning the remembered result rather than computing the result again. You can think of it as a cache for method results. For further details, see page 387 for the definition in Introduction To Algorithms (3e), Cormen et al.A simple example for computing factorials using memoization in Python would be something like this:You can get more complicated and encapsulate the memoization process into a class:Then:A feature known as "decorators" was added in Python 2.4 which allow you to now simply write the following to accomplish the same thing:The Python Decorator Library has a similar decorator called  that is slightly more robust than the  class shown here.
New to Python 3.2 is . By default, it only caches the 128 most recently used calls, but you can set the  to  to indicate that the cache should never expire:This function by itself is very slow, try  and you will have to wait about ten seconds. Adding  annotation ensures that if the function has been called recently for a particular value, it will not recompute that value, but use a cached previous result. In this case, it leads to a tremendous speed improvement, while the code is not cluttered with the details of caching.
The other answers cover what it is quite well. I'm not repeating that. Just some points that might be useful to you. Usually, memoisation is an operation you can apply on any function that computes something (expensive) and returns a value. Because of this, it's often implemented as a decorator. The implementation is straightforward and it would be something like thisor expressed as a decorator
Memoization is keeping the results of expensive calculations and returning the cached result rather than continuously recalculating it. Here's an example:A more complete description can be found in the wikipedia entry on memoization.
Let's not forget the built-in  function, for those who want to hand-craft. That way you can keep the mem cache inside the function definition (as opposed to a global).
I've found this extremely useful
Memoization is basically saving the results of past operations done with recursive algorithms in order to reduce the need to traverse the recursion tree if the same calculation is required at a later stage.see http://scriptbucket.wordpress.com/2012/12/11/introduction-to-memoization/Fibonacci Memoization example in Python:
Memoization is the conversion of functions into data structures. Usually one wants the conversion to occur incrementally and lazily (on demand of a given domain element--or "key"). In lazy functional languages, this lazy conversion can happen automatically, and thus memoization can be implemented without (explicit) side-effects.
Well I should answer the first part first: what's memoization?It's just a method to trade memory for time. Think of Multiplication Table.Using mutable object as default value in Python is usually considered bad. But if use it wisely, it can actually be useful to implement a .Here's an example adapted from http://docs.python.org/2/faq/design.html#why-are-default-values-shared-between-objectsUsing a mutable  in the function definition, the intermediate computed results can be cached (e.g. when calculating  after calculate , we can reuse all the intermediate results)
Here is a solution that will work with list or dict type arguments without whining:Note that this approach can be naturally extended to any object by implementing your own hash function as a special case in handle_item. For example, to make this approach work for a function that takes a set as an input argument, you could add to handle_item:
Solution that works with both positional and keyword arguments independently of order in which keyword args were passed (using inspect.getargspec):Similar question: Identifying equivalent varargs function calls for memoization in Python

Just wanted to add to the answers already provided, the Python decorator library has some simple yet useful implementations that can also memoize "unhashable types", unlike .


Answer URL
https://docs.python.org/3/library/functools.html#functools.lru_cache
https://docs.python.org/3/library/functools.html#functools.wraps
