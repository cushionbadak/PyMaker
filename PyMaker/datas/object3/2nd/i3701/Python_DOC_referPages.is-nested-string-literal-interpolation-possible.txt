Natural Text
When using formatted string literal, it is possible to have nested f-strings to some extent.Although, the same does not work if the inner expression is a variable containing a string.Is there a way to make this work and to have the second output to be  as well? If not, what is the difference between the first and second string that prevents it?
I think it can be helpful to see what is actually happening under the hood when each of these expressions is called.  The outer f-string encounters an expression which it evaluates, and the inner f-string also finds an expression which it evaluates, which results in the call to Here, the first f-string encounters an expression and evaluates it, and the inner f-string, encounters a string, resulting in the call to  instead of evaluating the contents of the string as Python code.Also it is important to note in this second example the missing  calls to both  and , which are present in the first example.
There are a few libraries that have developed functions for evaluating numerical and logical expressions safely ("safe" being the key).First, the setup -  is smart enough to optimise your expressions, and is even faster than numpy in some instances. Install using .A safe eval from the Pandas API similar to .
It's called "string literal interpolation". The string must be a literal, i.e. at the time the compilation takes place compiler will turn the string into a proper executable code. If you already have a string as a value (not as a literal), it's too late for that.I don't have access to Python that has PEP 498 enabled, so my examples will be in Ruby, which has had this mechanism for a long time. The Ruby syntax for Python's  is .In Ruby,  is syntactic sugar for  (as in, they produce exactly the same bytecode). If you have the string  already as a value, the compiler can't do anything about it; the only way to turn a string value into a result is to evaluate it.In the first example, you have a string literal inside a string literal; both are processed by the compiler at compile time: when the compiler sees the outer literal, it compiles it, finds another string literal there, compiles that as well, produces code. As a matter of fact,  produces exactly the same byte code, again.The fact that this is done at compile time is also the reason why string literal interpolation will raise a syntax error if the expression inside is malformed, even if the line in question is never executed:  will produce a .The fact that this is done at compile time means strings already in variables are not eligible for this mechanism. In your code, by the time  is evaluated,  could have been anything; the only way out is  (or another, safer, evaluator).


Answer URL
https://docs.python.org/3/reference/lexical_analysis.html#formatted-string-literals
