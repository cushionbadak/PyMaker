Natural Text
Given a list of integers e.g.and an integer e.g.count the number of integer combinations that have sum=m e.g.For small values of m, I can use this recursion (Fibonacci-like linear recurrence relation):But for larger l and m, it gets to slow and it´s proposed to use dynamic programming to memorize already solved combinations to reduce the recursive calls. Unfortunately, I'm not able to implement this. I tried reading this, but it didn´t help https://bio.informatik.uni-jena.de/wp/wp-content/uploads/2014/09/book_handout_3.pdfEdit: The learning outcome would be the greatest, if I would be able to implement it using dynamic programming
A straightforward search time for this is , where  is the sum and  is the number of integers in the list. The search space can be confined to  but for convenience we can just use .Python code:Output:
You can easily add memoization by adding the  decorator to your recursive function.This will automatically cache the results for certain parameters and check that cache first before calling the function again, dramatically reducing the number of calls, and hence runtime. However, this requires all the parameters to be hashable, i.e. you'd have to pass  as a .Example for : Result: 518,145; function call without memoization: 4,672,513; with memoization: 29.(If this is for an exercise in DP, this is probably not an option, but otherwise this works well in practice.)
This solution doesn't use dynamic programming but is significantly faster:A small performance test:


Answer URL
https://docs.python.org/3/library/functools.html#functools.lru_cache
