Natural Text
I have been transforming some of my original  () code to  (). Luckily there are a lot of similarities between the two. However, I did stumble upon some strange behaviour that I cannot find written down in any documentation. It considers the internal representation of descendant nodes.In ET,  is used to iterate over all descendants of an Element, optionally filtered by tag name. Because I could not find any details about this in the documentation, I expected similar behaviour for lxmlET. The thing is that from testing I conclude that in lxmlET, there is a different internal representation of a tree.In the example below, I iterate over nodes in a tree and print each node's children, but in addition I also create all different combinations of those children and print those. This means, if an element has children  I create alterations, namely trees .The expected output here is the id's of the children of each node joined together with a hyphen, and also all possible combinations of the children (cf. supra) in a top-down breadth-first fashion.However, when you use the  module instead of  (uncomment the import for lxmlET and comment the import for ET), and run the code you'll see that the output is So the deeper descendant nodes are never visited. This can be circumvented by either:using  (comment/uncomment relevant part in ), orusing  in  instead of .So I know that there is a way around this, but I am mainly wondering what is happening?! It took me ages to debug this, and I can't find any documentation on it. What is going on, what is the actual underlying difference here between the two modules? And what is the most efficient work-around when working with very large trees?
While Louis's answer is correct and I completely agree that modifying a data structure as you traverse it generally a Bad Idea(tm), you also asked why the code works with  and not  and there is a very reasonable explanation for that.Implementation of  in This library is implemented directly in Python and could vary depending on which Python runtime you're using. Assuming you're using CPython, the implementation you're looking for is implemented in vanilla Python:The last line is the only part we're concerned with. As it turns out,  is initialized towards the top of that file as:So adding a child to a tree is just appending an element to a list. Intuitively, that's exactly what you're looking for (in this case) and the implementation behaves in a completely unsurprising way.Implementation  in  is implemented as a mix of Python, non-trivial Cython, and C code so spelunking through it was significantly harder than the pure-Python implementation. First off,  is implemented as: is implemented over in :There's definitely a bit more going on here. In particular,  explicitly removes the node from the tree and then adds it elsewhere. This prevents you from accidentally creating a cyclic XML graph while manipulating nodes (which is something you could probably do with the  version).Workarounds for Now that we know that  copies nodes when appending but  moves them, why do those workarounds work? Based on the  method (which is actually defined in C inside of ), unlinking just messes with a bunch of pointers. So, anything that copies node metadata will do the trick. Because all of the metadata we care about are direct fields on the  struct, anything that shallow copies nodes will do the trick definitely works returns nodes wrapped in proxy elements which happens to shallow copy the tree metadata also does the trickIf you don't need your combinations to actually be in an official tree, setting  also gives you list appending just like .If you're really concerned about performance and large trees, I'd probably start with shallow copying with  although you should absolutely profile a few different options and see which one works best for you.
Copying ProblemIn general, the safe thing to do when you are manipulating an XML tree and want to copy information in multiple places in the tree (by opposition to moving information from one place to another) is to perform a deep copy operation on those elements rather than just add them to their new location. The vast majority of XML parsing libraries that produce trees require you to perform a deep copy if you want to copy structures around. They just won't give you the results you want if you do not deep copy.  is one such library that requires you to deep copy the structures you want to copy.The fact that  works in a way such that  effectively allows you to have the same element in two places in the tree is definitely unusual in my experience.Walking-while-Modifying ProblemYou mentioned that  also solves you problem. Note that if you use , you'll get the same result. What is going on here is that using  or  or using  to copy the nodes instead of moving them protect you against another problem with your code: you are walking a structure while modifying it. creates an iterator that goes over the XML structure as you iterate it. If you wrap it in , then the structure is walked immediately and the result put in a list. So you've effectively taken a snapshot of the structure before you walk it. That prevents your walking operation from being affected by changes to the tree. If you do  you are also obtaining a snapshot of the tree before you walk it because that method returns a list of nodes. And if you do a  of the nodes and append the copy of the node instead of appending the original node, then you are not modifying the tree you are walking while you are walking it.Whether you can get away with using XPath or using  instead of using  depends on what you plan to do with your combinations. The code you show in your question prints the combinations to the screen as soon you create them. They look fine when you print them, but if you do not use a  for creating them, then as soon as you create a new combination, the old one will get messed up because any node that appeared in the old combination and needs to appear in the new one will be moved instead of copied.And what is the most efficient work-around when working with very large trees?It depends on the specifics of your application and the data you need to parse. You gave one example which is a small document but you ask about "large trees". What applies to small documents does not necessarily transfer to large documents. You can optimize for case X but if case X happens only extremely rarely in real data, then your optimization may not pan out. In some cases, it may actually be harmful.In one application of mine, I had to replace references to some structures with the structures themselves. A simplified illustration would be a document that contains elements like  and references like . Every instance of  would have to be replaced with the  it points to. In general, this may mean copying a single  multiple times but sometimes a  may be referred by only one  so one optimization was to detect this and skip the deep copy in those cases where there was only one reference. I got this optimization "for free" because the application already required recording each instance of  and  for other purposes. If I've had to add bookkeeping just for this optimization, it is not clear it would have been worth it.
At the beginning I didn't think there was such a difference (neither did I check), but both @supersam654 and @Louis answers pinpointed it very clearly.But code that is dependent on internal representation (rather than interface) of stuff that it uses, doesn't seem right (from design PoV) to me. Also, as I was asking in my comment: combo_children seems totally useless:Get child nodes combo (as a list)Append each node from the list as a child to combo_childrenReturn combo_childrenGet combo_children children (as a list)Use the list (combo)when things could be easily done:Get child nodes combo (as a list)Return the listUse the list (combo)Apparently, the combo_children approach was also exposing the behavioral difference between the modules.code_orig_lxml.py:Notes:This is your code with the changes aboveI didn't removed anything, instead just commented stuff (which would generate the smallest diff between the old and new versions)Output:While I was investigating, I modified your code further, to:Fix the issueImprove printingMake it modularUse both parsing methods, to make differences between them clearerxml_data.py:code.py:Output:


Answer URL
https://docs.python.org/3/library/copy.html#copy.copy
