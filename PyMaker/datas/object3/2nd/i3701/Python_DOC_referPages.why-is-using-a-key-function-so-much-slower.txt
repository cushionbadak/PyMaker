Natural Text
There is a drastic performance hit when using a keyfunc in :I expected a small extra cost, perhaps something like 30% - not 400%. This degradation seems to be reproducible over a few different data sizes. You can see in the source code there is a special-case handling for , but otherwise the implementation looks more or less the same.Why is performance so degraded by using a key function? Is it only due to the extra function call overhead, or is the algorithm fundamentally changed somehow by using a keyfunc?For comparison,  takes about a 30% hit with the same data and lambda.
Say your iterable has  elements.  Whether sorting or doing , the key function will be called  times.  When sorting, that overhead is largely buried under roughly  other operations.  But when doing  of  items, there are only roughly  other operations, which is much smaller when  is much smaller than .In your example,  and , and so the ratio of other operations, sorting over , is roughly:That this is close to 6 is purely coincidence ;-)  It's the qualitative point that matters:  the overhead of using a key function is much more significant for  than for sorting randomly ordered data, provided  is much smaller than .In fact, that greatly understates the relative burden for , because the   is called in the latter only when the next element is larger than the 'th largest seen so far.  Most of the time it isn't, and so the loop on such an iteration is nearly pure overhead, calling a Python-level key function just to discover that the result isn't interesting.Quantifying that is beyond me, though; for example, on my Win10 box under Python 3.6.5, I only see a timing difference in your code a bit less than a factor of 3.  That doesn't surprise me - calling a Python-level function is much more expensive than poking a list iterator and doing an integer compare (both "at C speed").
The extra overhead of calling  so many times is really just that expensive.As you can see, the cost of calling  on all the elements accounts for almost the entirety of the overhead.Key evaluations are equally expensive for , but because the total work of sorting is more expensive, the overhead of key calls is a smaller percentage of the total. You should have compared the absolute overhead of using a key with  or , rather than the overhead as a percentage of the base.As you can see, the cost of  calls accounts for about half the overhead of using this key with  on this input, the rest of the overhead probably coming from the work of shuffling more data around in the sort itself.You might wonder how  manages to do so little work per element. For the no-key case, most iteration happens in the following loop:or for the case with a key:The crucial realization is that the  and  branches are almost never taken. Once the algorithm has found 10 fairly large elements, most of the remaining elements are going to be smaller than the 10 current candidates. On the rare occasions where a heap element needs to be replaced, that just makes it even harder for further elements to pass the bar needed to call .On a random input, the number of heapreplace calls  makes is expected logarithmic in the size of the input. Specifically, for , aside from the first 10 elements of , element  has a  probability of being in the top 10 elements of , which is the condition necessary for a heapreplace call. By linearity of expectation, the expected number of heapreplace calls is the sum of these probabilities, and that sum is O(log(len(x))). (This analysis holds with 10 replaced by any constant, but a slightly more sophisticated analysis is needed for a variable  in .)The performance story would be very different for a sorted input, where every element would pass the  check:Over 10 times as expensive as the unsorted case!


Answer URL
https://docs.python.org/3/library/heapq.html#heapq.nlargest
