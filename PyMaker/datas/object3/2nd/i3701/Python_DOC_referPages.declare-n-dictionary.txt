Natural Text
Can someone please explain this to me? This doesn't make any sense to me.I copy a dictionary into another and edit the second and both are changed. Why is this happening?
Python never implicitly copies objects. When you set , you are making them refer to the same exact dict object, so when you mutate it, all references to it keep referring to the object in its current state.If you want to copy the dict (which is rare), you have to do so explicitly withor
When you assign , you are not making a copy of , it results in  being just another name for .To copy the mutable types like dictionaries, use  /  of the  module.

On python 3.5+ there is an easier way to achieve a shallow copy by using the ** unpackaging operator. Defined by Pep 448.** unpackages the dictionary into a new dictionary that is then assigned to dict2. We can also confirm that each dictionary has a distinct id. If a deep copy is needed then copy.deepcopy() is still the way to go. 
You can also just make a new dictionary with a dictionary comprehension.  This avoids importing copy.Of course in python >= 2.7 you can do:But for backwards compat., the top method is better.
The best and the easiest ways to create a copy of a dict in both Python 2.7 and 3 are... To create a copy of simple(single-level) dictionary:1. Using dict() method, instead of generating a reference that points to the existing dict.2. Using the built-in update() method of python dictionary. To create a copy of nested or complex dictionary:Use the built-in copy module, which provides a generic shallow and deep copy operations. This module is present in both Python 2.7 and 3.*
Assignment statements in Python do not copy objects, they create bindings between a target and an object. so, , it results another binding between and the object that  refer to.if you want to copy a dict, you can use the .The copy module has two interface:The difference between shallow and deep copying is only relevant for compound objects (objects that contain other objects, like lists or class instances):A shallow copy constructs a new compound object and then (to the extent possible) inserts references into it to the objects found in the original.A deep copy constructs a new compound object and then, recursively, inserts copies into it of the objects found in the original.For example, in python 2.7.9:and the result is:
In addition to the other provided solutions, you can use  to integrate the dictionary into an empty dictionary, e.g.,. Now you will have a "shallow" copy of . Applied to your example:Pointer: Difference between shallow and deep copys
You can copy and edit the newly constructed copy in one go by calling the  constructor with additional keyword arguments:
This confused me too, initially, because I was coming from a C background.In C, a variable is a location in memory with a defined type. Assigning to a variable copies the data into the variable's memory location.But in Python, variables act more like pointers to objects. So assigning one variable to another doesn't make a copy, it just makes that variable name point to the same object.
Every variable in python (stuff like  or  or  is a pointer to some hidden platonic "object" inside the machine.If you set ,you just point  to the same object (or memory location, or whatever analogy you like) as . Now, the object referenced by  is the same object referenced by .You can check:  should be . Also,  should be the same as .You want , or .The difference between  and ?  will make sure that the elements of  (did you point it at a list?) are also copies.I don't use  much - it's usually poor practice to write code that needs it (in my opinion).
 does not copy the dictionary. It simply gives you the programmer a second way () to refer to the same dictionary.
 is a symbol that references an underlying dictionary object. Assigning  to  merely assigns the same reference. Changing a key's value via the  symbol changes the underlying object, which also affects . This is confusing.It is far easier to reason about immutable values than references, so make copies whenever possible:This is syntactically the same as:
Because python works with reference, so when you did dict2 = dict1 you pass a reference to dict2, that was the same as dict1. So, when you make a change in dict1 or dict2 you change a reference, and both dicts chages. Sorry if I mistake something on English. 
As others have explained, the built-in  does not do what you want. But in Python2 (and probably 3 too) you can easily create a  class that copies with  so you can be sure that the original will not change.Please refer to the lvalue modification pattern discussed here: Python 2.7 - clean syntax for lvalue modification. The key observation is that  and  behave as values in Python (even though they're actually immutable objects under the hood). While you're observing that, please also observe that nothing is magically special about  or .  can be used in much the same ways, and I can think of many cases where  makes sense.
There are many ways to copy Dict object, I simply use
because, dict2 = dict1, dict2 holds the reference to dict1. Both dict1 and dict2 points to the same location in the memory. This is just a normal case while working with mutable objects in python. When you are working with mutable objects in python you must be careful as it is hard to debug. Such as the following example.This example intention is to get all the user ids including blocked ids.That we got from ids variable but we also updated the value of my_users unintentionally. when you extended the ids with blocked_ids my_users got updated because ids refer to my_users.
Nice explanations, I want to add the simplest rule you can refer to when thinking of Python variables which you assign equal with . If the data type is immutable, you don't have to worry about the unexpected behavior you encountered. If the data type is mutable, you want to make sure you make a copy of it to prevent the unexpected behavior your encountered.Immutable data types: string (a tuple of characters), tupleMutable data types: list, array, dictionary
You can use directly:where object dict2 is an independent copy of dict1, so you can modify dict2 without affecting dict1.This works for any kind of object.


Answer URL
https://docs.python.org/3/library/copy.html
