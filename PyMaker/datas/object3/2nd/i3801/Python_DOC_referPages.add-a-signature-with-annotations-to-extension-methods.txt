Natural Text
When embedding Python in my application, and writing an extension type, I can add a  to the method by using a properly crafted  string.When  is executed, the following is returned (abbreviated):This is good, but I'm using Python3.6, which has support for annotations.  I'd like to annotate question to be a string, and the function to return an int.  I've tried:but this reverts to the  notation, and the documentation becomes:and asking for  results in an exception.I've tried to add the annotations after the fact with Python code:But the builtin method descriptors can't have annotations added this way.Is there a way to add annotations to extension methods, using the C-API?Argument Clinic looked promising and may still be very useful, but as of 3.6.5, it doesn't support annotations.  The annotation value for this parameter. Not currently supported, because PEP 8 mandates that the Python library may not use annotations.
TL;DR There is currently no way to do this.How do signatures and C extensions work together?In theory it works like this (for Python C extension objects):If the C function has the "correct docstring" the signature is stored in the  attribute.If you call  or  on such an object it parses the  and tries to construct a signature from that.If you use the argument clinic you don't need to write the "correct docstring" yourself. The signature line is generated based on comments in the code. However the 2 steps mentioned before still happen. They just happen to the automatically generated signature line.That's why built-in Python functions like  have a s:The signature in this case is generated through the argument clinic based on the comments around the  implementation.What are the problems with annotations?There are several problems with annotations:Return annotations break the contract of a "correct docstring". So the  will be empty when you add a return annotation. That's a major problem because a workaround would necessarily involve re-writing the part of the CPython C code that is responsible for the docstring ->  translation! That's not only complicated but you would also have to provide the changed CPython version so that it works for the people using your functions.Just as example, if you use this "signature":You get:But if you remove the return annotation:It gives you a :If you don't have the return annotation it still won't work because annotations are explicitly not supported (currently).Assuming you have this signature:It doesn't work with  (the exception message actually says it all):The function that is responsible for the parsing of  is . In theory it could be possible that you maybe could make it work by monkey-patching it (return annotations still wouldn't work!). But maybe not, there are several places that make assumptions about the  that may not work with annotations.Would  work?In the comments this C API function was mentioned. However that deliberately doesn't work with C extension functions. If you try to call it on a C extension function it will raise a . I tested this with a small Cython Jupyter "script":So that also doesn't work with C extension functions.SummarySo return annotations are completely out of the question currently (at least without distributing your own CPython with the program). Parameter annotations could work if you monkey-patch a private function in the  module. It's a Python module so it could be feasible, but I haven't made a proof-of-concept so treat this as a maybe possible, but probably very complicated and almost certainly not worth the trouble.However you can always just wrap the C extension function with a Python function (just a very thing wrapper). This Python wrapper can have function annotations. It's more maintenance and a tiny bit slower but saves you all the hassle with signatures and C extensions. I'm not exactly sure but if you use Cython to wrap your C or C++ code it might even have some automated tooling (writing the Python wrappers automatically).


Answer URL
https://docs.python.org/3/howto/clinic.html#using-real-argument-clinic-converters-instead-of-legacy-converters
https://docs.python.org/3/howto/clinic.html
