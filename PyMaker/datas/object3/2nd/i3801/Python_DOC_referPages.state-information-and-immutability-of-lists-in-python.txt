Natural Text
I am a beginner in Python and using Mark Lutz's book to learn the fundamentals of Python. Here's an example that the author uses to demonstrate storing state information using lists:Here's the code to test state information:You would see that the counter increases from 3 and then continues. In essence, above code stores initial state  (passed during initialization of the object) in  and increments it every time  is called. However, I am unsure why Python doesn't throw an error in  block. Specifically,  is local to  and not  To demonstrate what I mean, I am going to replace  by Technically, above code should also work fine because all I have done is that replaced the list with the variable. However, PyCharm wouldn't even run this code. I get an error Can someone please explain why the version with  works fine? The author has stated that "this leverages the mutability of lists, and relies on the fact that in-place object do not classify a name as local."I am not really sure what that means. Can someone please help me? Thanks for any help extended to me.
You should read this section of the documentation. Basically, in both versions the scope of the nested block allows it to interact with the namespace of the encompassing block.  The difference is that you are not reassigning  in the first example, you're mutating it. In the second example, Python knows that you are going to assign a value to that reference later in the function, so it is treated as a name from the local  namespace, rather than the outer  namespace.You can use the  keyword to circumvent this and use the other reference from the other namespace 
From what I understand, because  is nested under , it would have access to any objects and variables that belong to  because  is the parent function and  is the child function in this case. Python will not produce an error because of inheritance.And about replacing  with , Python automatically assumes that  is an  because you are trying to add to it. While  is a list, and you can't add to is unless you append an element to it- which this isn't your case. The reason why  works and not  is because  is an element in the  list and it adds 0 to it.
It's a function of 1) how Python variable assignment actually just creates aliases (pointers) to underlying values in memory, and the difference between how mutable and immutable types are treated; and 2) some Python "magic" related to closures. The crux of your question is really the first point. To address that, take for example the following:Both a and b point to the same underlying object:is True. However, then setting  will cause b to point to a different object in memory (showing that the int is immutable).However, a list is mutable (modifiable "in place"). For example:  will have the same memory location before and after an operation like .There are a lot of implications of this very basic explanation that take some time to interpret. For example, variables can’t “point to” other variables, but rather still point to underlying objects.As a result, lists can exhibit "weird" behavior (another common, related confusion revolves around setting a default parameter value as a list that's then modified in the function), but can also be taken advantage of in the way your example shows.


Answer URL
https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces
