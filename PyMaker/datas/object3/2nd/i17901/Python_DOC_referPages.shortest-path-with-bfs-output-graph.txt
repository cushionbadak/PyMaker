Natural Text
I am trying to create a backtrace function the will return a list of the order of the shortest path from the root to the My path_holder:In my  input, it is the output of a BFS so the first node is the root and the last node is the goal. Because the  input is the output of a BFS, it stops when the  is found so all the nodes that are branches of the previous nodes required to search for  are added to  as well. Currently I am getting stuck in the while loop where an infinite loop occurs. My general strategy to is to start from the  node and use the key of this node to find where this key is located in another key's(node) list. Once I found that node (where it's list contains the key), I set the node's key to be the new goal. (Confusing sentence sorry) This graph may contain cycles which might be why I am also getting infinite loops.my backtrace function:ex: output
1. BugsWhen I run your code I get the following error:That's because when you iterate over a dictionary like this:what you get are the keys of the dictionary. So  takes values ,  and so on, and you can't pass these to the  method.But what are you trying to do here anyway? If you're trying to copy  into , you could just write:but why bother making a copy? Why not just use ?With bug #1 fixed, the program runs but get stuck in an infinite loop. That's because of these lines:These lines mean that you only add a node to the path if it has a neighbour  which is not yet in the path, but is equal to the goal. But hang on a second,  is already in the path at this point. So both conditions cannot be satisfied at the same time. Hence nothing ever gets added to the path!Clearly the line: should be:since  is the node we are considering adding to the path.With bugs #1 and #2 fixed, the program makes some progress but still gets stuck in an infinite loop. If we add the line  after  then we get the following output up to the point where it gets stuck:You can see that the search has made a mistake: from  it has gone to , but there is no route from  to  except for the one that goes through . And the search will never consider adding  to the path, because it's already there.2. What to do insteadWhen you find a path to a node like , you can't know whether or not that node will be on the shortest path from  to . All you can know at this point is that if  is on the shortest path from  to , then you'll get there via . So that's all that you must record.Here's how I'd implement this, using the dictionary  to record for each node the previous node on the shortest path from  to that node, and a  to maintain a queue of nodes whose neighbours we may not have visited yet.Notes:Your variable  contains a data structure that is known as a graph in adjacency list representation. So I have called this variable .I've written a docstring explaining what the function does and how to call it. The docstring also contains embedded code examples that can be run using the  module.Your function searches backwards from the goal to the start. But this is just the same as searching forwards from the start to the goal with all the edges reversed. So I've kept things simple by searching forwards.


Answer URL
