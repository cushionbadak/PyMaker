Natural Text
Suppose that there is a function  such that: it is very costly in terms of execution time;it returns the same output whenever the same  is fed to it; and it does not perform "additional tasks" besides returning an output.In these conditions, instead of calling the function twice in a row with the same , we can store the result in a temporary variable, then use that variable to do these computations.Now suppose that there are some functions (,  and  in the example below) that call , and that some of these functions may call each others (in the example below, and  both call ). In this case, using the simple method mentioned above still results in repeated calls to  with the same  (see  below). I did found a way to minimize the number of calls, but it is "ugly" (see  below). Any ideas of a better way to do this?The output of this code is:Note that I do not want to "store" the results for all values of  used in the past (because this would require too much memory). Moreover, I do not want to have a function returning a tuple of the form  because there are cases where I only want  (so there is no need to evaluate ).
What you are looking for is a LRU cache; only most-recently used items are cached, limiting memory usage to balance invocation cost with memory requirements.As your costly function is invoked with different values for , up to a number of return values (per unique  value) is cached, with the least-recently used cache results discarded when the cache is full.As of Python 3.2, the standard library comes with a decorator implementation: :A backport is available for earlier versions, or pick one of the other available libraries that can handle LRU caches avaible on PyPI.If you only ever need to cache one most recent item, create your own decorator:This simpler decorator has less overhead than the more featureful .
I am accepting @MartijnPieters' solution because it is probably the right way to do it for 99% of the people that will get a problem similar to mine. However, in my very particular case, I only need a "cache of 1", so the fancy  decorator is slightly overkill. I ended up writing my own decorator (thanks to this awesome stackoverflow answer), which I provide below. Be warned that I am new to Python, so this code may not be perfect.


Answer URL
