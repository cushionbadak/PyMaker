Natural Text
In this PyCon talk, Jack Diederich shows this "simple" implementation of Conway's Game of Life. I am not intimately familiar with either GoL or semi-advanced Python, but the code seems quite easy to grasp, if not for two things:The use of . I have seen the use of yield to create generators before, but eight of them in a row is new... Does it return a list of eight generators, or how does this thing work?. The star unpacks the resulting list (?) from applying neighbours to board, and ... my mind just blew.Could someone try to explain these two parts for a programmer that is used to hacking together some python code using map, filter and reduce, but that is not using Python on a daily basis? :-)
Generators operate on two principles: they produce a value each time a  statement is encountered, and unless it is iterated over, their code is paused.It doesn't matter how many  statements are used in a generator, the code is still run in normal python ordering. In this case, there is no loop, just a series of  statements, so each time the generator is advanced, python executes the next line, which is another  statement.What happens with the  generator is this:Generators always start paused, so calling  returns a generator that hasn't done anything yet.When it is advanced ( is called on it), the code is run until the first  statement. First  is executed, then  is calculated and yielded. The code pauses again.When advanced again, the code runs until the next  statement is encountered. It yields .etc. until the function completes.The  line does: produces an iterator for each and every position in the  sequence. It simply loops over board, calls  on each value, and returns a new sequence of the results. Each  function returns a generator.The  syntax expands the  sequence into a list of parameters, as if the function was called with each element in  as a separate positional parameter instead.  would translate to . takes each and every generator produced by the map, and applies that as a series of positional parameters to . Looping over the output of chain means that each and every generator for each and every board position is iterated over once, in order.All the generated positions are added to a set, essentially removing duplicatesYou could expand the code to:In python 3, that line could be expressed a little more efficiently still by using  instead, because  in Python 3 is a generator too;  doesn't force the  to be expanded and will instead loop over the  results one by one as needed.
Wow, that's a neat implementation, thanks for posting it !For the , there is nothing to add to Martijn's answer.As for the star : the  returns a generator or a list (depending on python 2 or 3), and each item of this list is a generator (from ), so we have a list of generators. takes many arguments that are iterables and chains them, meaning it returns a single iterable while iterate over all of them in turn.Because we have a list of generators, and  takes many arguments, we use a star to convert the list of generator to arguments. We could have done the same with .
it just returns a tuple of all cell's neighbours. If you do understand what generators do, it is pretty clear that using generators is a good practice when working with big amount of data. you do not need to store all this in memory, you calculate it only when you need it.


Answer URL
