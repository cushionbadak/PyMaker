Natural Text
I'm in the process of trying to engineer a data structure for a game engine, and allow a scripting language to grab data from it. Due to some limitations of design, the data would need to be stored on the C++ side of the program in a database like structure. Main reason being that I'm not sure if Python's serialization base can compensate for modders suddenly adding and removing data fields.I am wondering if is possible to call a python script, and have it act as it's own object with it's own data? If not, can you instantiate a python class from C++ without knowing the class's name until runtime?
What you are describing is called embedding the Python interpreter.  CPython is suitable for this kind of embedding, and provides a nice tutorial on some of the higher-level points (though it is primarily focused on extending rather than embedding, most of the concepts are relevant to both areas).There are a number of drawbacks to this approach, however.  In particular, CPython is quite slow compared to C++.  You should assume that executing arbitrary Python bytecode will block for an unreasonable amount of time unless you have profiled it and know you can get away with it.  Worse, each Python interpreter (you can have more than one in a process, with some caveats) has a global interpreter lock (GIL), and you generally cannot interact with a Python interpreter unless you hold its GIL.  In other words, only one thread is allowed to call into a given Python interpreter at a time, which makes it harder to manage the execution speed of Python with threads.  It also means you will gain no speed bonus by giving Python extra threads, even if the Python code is embarrassingly parallel.  The only major exception is I/O-bound operation, which Python can usually do without holding the GIL.Another difficulty is that Python objects are all of type .  These are (pointers to) reference counted objects with a number of interesting properties, but the point is that you can't just give raw memory directly to a Python script and expect it to work.  You will at a minimum have to wrap it in an  or some other suitable Python object.  If you want the underlying memory to still "belong" to your application, you may want to use the buffer protocol to expose this memory in a standard fashion that  and friends can work with (so that you don't end up copying memory unnecessarily).At a high level, I would recommend having one or several dedicated Python worker threads (one per interpreter, and try not to spin up too many interpreters since they are heavy objects), and asynchronously passing work objects between these threads and the rest of your application.  The worker threads are responsible for converting between C++ objects and Python objects, holding the GIL(s), and running slow Python code.  You should also bear in mind that Python will consume the same computational resources (CPU, memory, perhaps disk I/O) the rest of your application is using.  Threading may help you make use of multiple cores, but it won't buy you more CPU than you actually have to play with.  You may simply find that Python is too slow for your application, depending on how responsive you need your scripting system to be and how much the rest of your game engine can tolerate the performance pressure of an extra CPU-bound thread.  You should start by building a small prototype and verifying that it has acceptable performance characteristics before you try to build the real thing, or if you already have a complete game engine, try bolting a minimal Python interpreter onto it and run some benchmarks.
I never worked with python. But I think this is one of the main features of any programming/script languages: Call a function multiple times with it's own instances as many times as you need.


Answer URL
https://docs.python.org/3/extending/index.html
https://docs.python.org/3/c-api/init.html#sub-interpreter-support
https://docs.python.org/3/library/array.html
https://docs.python.org/3/c-api/buffer.html#bufferobjects
https://docs.python.org/3/extending/index.html#embedding-the-cpython-runtime-in-a-larger-application
