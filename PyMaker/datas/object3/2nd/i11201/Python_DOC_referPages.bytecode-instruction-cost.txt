Natural Text
Is it possible to know a "cost" in some measure(seconds, CPU ticks, logarithm scale, anything) for each instruction? Or at least for some instructions, skipping something like SLICE. There is a description at https://docs.python.org/3/library/dis.html. There is source code: https://hg.python.org/cpython/file/tip/Python/ceval.c#l1199. I guess it is possible to estimate how much resources will eat each instruction by analyzing the source code, but I doubt that this can be done by noob like me. May be somebody already done this? Of course there are numerous high level advices about optimization, about over optimization, but may be such measure will help beginners with better bytecode understanding without digging into the C sources?Edit: the actual question is not about profiling or debugging code - I know about various profiling methods - the question is particularly about bytecode. I am keeping in mind CPU instructions which has a cost measure - cycles per instruction.
The typical way to measure the performance of "small" pieces of code is .  For larger things, we usually use  instead.These techniques will measure the code by actually running it and seeing how long it takes to execute, so they will not produce totally deterministic answers.  If you're looking for something more theoretical, you may need to look at the disassembly and the CPython source code, and reason about how fast it is.  You may find the source easier to read if you consult the Python/C API docs, since a lot of CPython source is ultimately calling those same functions.
As mentioned by @kevin you can use cProfile. You can see http://lanyrd.com/2013/pycon/scdywg/For line by line profiling you can use, https://github.com/rkern/line_profilerwhich I found out from here.


Answer URL
https://docs.python.org/3/library/dis.html
https://docs.python.org/3/library/timeit.html
https://docs.python.org/3/library/profile.html
https://docs.python.org/3/c-api/index.html
