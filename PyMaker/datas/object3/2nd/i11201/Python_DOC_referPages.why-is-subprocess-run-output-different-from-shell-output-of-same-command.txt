Natural Text
I am using  for some automated testing. Mostly to automate doing:If you execute the above redirection in a shell, the two files are always identical. But whenever  is too long, the below Python code does not return the correct result.This is the Python code:Here is the C++ code in : can be anything like this:The second integer on the first line is the number of lines following, hence here  will be 100,001 lines long. Question: Am I misusing subprocess.run() ?  EditMy exact Python code after comment (newlines,rb) is taken into account:Here is the first diff:Here is the input file: https://drive.google.com/open?id=0B--mU_EsNUGTR3VKaktvQVNtLTQ
To reproduce, the shell command:without the shell in Python:It works with arbitrary large files.You could use  in this case (available since Python 2), instead of  that is available only in Python 3.5+.Works very well thanks. But then why was the original failing ? Pipe buffer size as in Kevin Answer ?It has nothing to do with OS pipe buffers. The warning from the subprocess docs that @Kevin J. Chase cites is unrelated to . You should care about OS pipe buffers only if you use  and manually read()/write() via multiple pipe streams ().It turns out that the observed behavior is due to Windows bug in the Universal CRT. Here's the same issue that is reproduced without Python: Why would redirection work where piping fails?As said in the bug description, to workaround it: "use a binary pipe and do text mode CRLF => LF translation manually on the reader side" or use   directly instead of or wait for Windows 10 update this summer (where the bug should be fixed)or use a different C++ compiler e.g., there is no issue if you use  on WindowsThe bug affects only text pipes i.e., the code that uses  should be fine ( should still work or it is some other bug).
I'll start with a disclaimer:  I don't have Python 3.5 (so I can't use the  function), and I wasn't able to reproduce your problem on Windows (Python 3.4.4) or Linux (3.1.6).  That said...Problems with  and FamilyThe  docs say that it's just a front-end for the old -and- technique.  The  docs warn that:The data read is buffered in memory, so do not use this method if the data size is large or unlimited.This sure sounds like your problem.  Unfortunately, the docs don't say how much data is "large", nor what will happen after "too much" data is read.  Just "don't do that, then".The docs for  go into a little more detail (emphasis mine)...Do not use  or  with this function. The child process will block if it generates enough output to a pipe to fill up the OS pipe buffer as the pipes are not being read from....as do the docs for :This will deadlock when using  or  and the child process generates enough output to a pipe such that it blocks waiting for the OS pipe buffer to accept more data. Use  when using pipes to avoid that.That sure sounds like  is the solution to this problem, but 's own docs say "do not use this method if the data size is large" --- exactly the situation where the  docs tell you to use .  (Maybe it "avoid(s) that" by silently dropping data on the floor?)Frustratingly, I don't see any way to use a  safely, unless you're sure you can read from it faster than your child process writes to it.On that note...Alternative:  You're holding all your data in memory... twice, in fact.  That can't be efficient, especially if it's already in a file.If you're allowed to use a temporary file, you can compare the two files very easily, one line at a time.  This avoids all the  mess, and it's much faster, because it only uses a little bit of RAM at a time.  (The IO from your subprocess might be faster, too, depending on how your operating system handles output redirection.)Again, I can't test , so here's a slightly older -and- solution (minus  and the rest of your setup):Unfortunately, since I can't reproduce your problem, even with a million-line input, I can't tell if this works.  If nothing else, it ought to give you wrong answers faster.Variant: Regular FileIf you want to keep the output of your test run in  (from your command-line example), then you would direct your subprocess' output to a normal file instead of a .  This is the solution recommended in J.F. Sebastian's answer.I can't tell from your question if you wanted , or if it was just a side-effect of the two step test-then- --- your command-line example saves test output to a file, while your Python script doesn't.  Saving the output would be handy if you ever want to investigate a test failure, but it requires coming up with a unique filename for each test you run, so they don't overwrite each other's output.


Answer URL
https://docs.python.org/3/library/subprocess.html#subprocess.run
https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate
https://docs.python.org/3/library/subprocess.html#subprocess.call
https://docs.python.org/3/library/subprocess.html#subprocess.Popen.wait
https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate
https://docs.python.org/3/library/subprocess.html#subprocess.PIPE
https://docs.python.org/3/library/tempfile.html#tempfile.TemporaryFile
https://docs.python.org/3/library/subprocess.html#subprocess.run
