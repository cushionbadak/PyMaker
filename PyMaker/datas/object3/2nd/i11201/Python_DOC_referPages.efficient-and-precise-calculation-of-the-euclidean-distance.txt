Natural Text
Following some online research (1, 2, numpy, scipy, scikit, math), I have found several ways for calculating the Euclidean Distance in Python: I was wondering if someone could provide an insight on which of the above (or any other that I have not found) is considered the best in terms of efficiency and precision. If someone is aware of any resource(s) which discusses the subject that would also be great.The context I am interesting in is in calculating the Euclidean Distance between pairs of number-tuples, e.g. the distance between  and .
Conclusion first:From the test result by using  for efficiency test, we can conclude that regarding the efficiency: >  >  > While I didn't really test your  as it is not suitable for general cases and it is generally equivalent to . For the rest, quite surprisingly,  is the fastest one. While for  which uses , as what we expected, which is heavily optimized in C, is the second fastest. For , if you go directly to the function definition, you will see that it is actually using , except it will perform the validation on the two input vectors before the actual . That's why it is slightly slower thant .Finally for , according to the documentation:This formulation has two advantages over other ways of computing distances. First, it is computationally efficient when dealing with sparse data. Second, if one argument varies but the other remains unchanged, then dot(x, x) and/or dot(y, y) can be pre-computed.  However, this is not the most precise way of doing this computation, and the distance matrix returned by this function may not be exactly symmetric as requiredSince in your question you would like to use a fixed set of data, the advantage of this implementation is not reflected. And due to the trade off between the performance and precision, it also gives the worst precision among all of the methods.Regarding the precision, ==>Efficiency Test Script:Efficiency Test Output:Precision Test Script & Result:
I don't know how the precision and speed compares to the other libraries you mentioned, but you can do it for 2D vectors using the built-in  function:
As a general rule of thumb, stick to the  and  implementations where possible, as they're vectorized and much faster than native Python code. (Main reasons are: implementations in C, vectorization eliminates type checking overhead that looping does.)(Aside: My answer doesn't cover precision here, but I think the same principle applies for precision as for efficiency.)As a bit of a bonus, I'll chip in with a bit of information on how you can profile your code, to measure efficiency. If you're using the IPython interpreter, the secret is to use the  line magic.What  does is tell you how long a function call takes to run, including a bit of trace to figure out where the bottleneck might be. In this case, both the  and  implementations are pretty fast. Assuming you defined a function , you can profile using the same IPython magic call. As another added bonus,  also works inside the Jupyter notebook, and you can do  to profile an entire cell of code, rather than just one function, simply by making  the first line of that cell.


Answer URL
https://docs.python.org/3/library/math.html#math.hypot
https://docs.python.org/3/library/math.html#math.hypot
https://docs.python.org/3/library/timeit.html#module-timeit
https://docs.python.org/3/library/math.html#math.hypot
https://docs.python.org/3/library/itertools.html#itertools-recipes
