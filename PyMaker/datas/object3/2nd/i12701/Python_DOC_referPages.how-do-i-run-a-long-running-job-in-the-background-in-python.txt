Natural Text
I have a web-service that runs long-running jobs (in the order of several hours). I am developing this using Flask, Gunicorn, and nginx.What I am thinking of doing is to have the route which takes a long time to complete, call a function that creates a thread. The function will then return a guid back to the route, and the route will return a url (using the guid) that the user can use to check progress. I am making the thread a daemon (thread.daemon = True) so that the thread exits if my calling code exits (unexpectedly).Is this the correct approach to use? It works, but that doesn't mean that it is correct.
The more regular approch to handle such issue is extract the action from the base application and call it outside, using a task manager system like Celery. Using this tutorial you can create your task and trigger it from your web application.Then you can run:Just remember you need to run worker separately:
Celery and RQ is overengineering for simple task.Take a look at this docs - https://docs.python.org/3/library/concurrent.futures.htmlAlso check example, how to run long-running jobs in background for Flask app - https://stackoverflow.com/a/39008301/5569578
Well, Although your approach is not incorrect, basicly it may lead your program run out of available threads. As Ali mentioned, a general approach is to use Job Queues like  or .  However you don't need to extract functions to use those libraries.  For Flask, I recommend you to use Flask-RQ.  It's simple to start:RQJust remember to install Redis before using it in your Flask app.And simply use @Job Decorator in your Flask functions:And finally you need  to start the worker:rqworkerYou can see RQ docs for more info.  RQ designed for simple long running processes.CeleryCelery is more complicated, has huge list of features and is not recommended if you are new to job queues and distributed processing methods.GreenletsGreenlets have switches.  Let you to switch between long running processes.You can use greenlets for running processes.  The benefit is you don't need Redis and other worker, instead you have to re-design your functions to be compatible:
Your approach is fine and will totally work, but why reinvent the background worker for python web applications when a widely accepted solution exists, namely celery.I'd need to see a lot tests before I trusted any home rolled code for such an important task.Plus celery gives you features like task persistence and the ability to distribute workers across multiple machines.


Answer URL
https://docs.python.org/3/library/concurrent.futures.html
