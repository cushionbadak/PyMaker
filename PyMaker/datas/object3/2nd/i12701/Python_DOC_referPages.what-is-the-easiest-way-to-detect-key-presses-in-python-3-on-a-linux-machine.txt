Natural Text
Right now I'm trying to make a small code with a raspberry pi and and a makey makey. The makey makey is a small board that acts as a usb keyboard when certain contacts are powered. My question is what is the easiest way to detect those keypresses inside a python script. I understand using the GPIO pins would be easier, but right now I'm looking for this. I have seen examples such as using using getch() from msvcrt (which from what I understand is windows only,) using pygame.key, and using getKey. Which of theses is easiest to use? Are there any that can detect a key being pressed and a key being released?Pseudocode Code (... is that what it's called?)and so on. Thanks.
This is a simple loop that will put stdin in raw mode (disabling buffering so you don't have to press enter) to get single characters. You should do something smarter (like a  statement to disable it) but you get the idea here:I think you'd have to loop to detect key releases in Python.ETA some more explanation:On Linux, input to your program will be line buffered. This means that the operating system will buffer up input until it has a whole line, so your program won't even see anything the user typed until the user also hits 'enter'. In other words, if your program is expecting the user to type 'w' and the user does this, 'w' will be sitting in the OS's buffer until the user hits 'enter'. At this point the entire line is delivered to your program so you will get the string "w\n" as the user's input.You can disable this by putting the tty in raw mode. You do this with the Python function  which will make a call down the tty driver in linux to tell it to stop buffering. I passed it the  argument to tell it which stream I wanted to turn buffering off for1. So after the  call, the loop above will give you output for every key the user presses.A complication, though, is that once your program exits, the tty is still in raw mode. You'll generally find this unsatisfying since you don't get any of the power that modern terminal settings offer (like when you use control or escape sequences). For example, notice that you might have trouble exiting the program with . Consequently you should put the terminal back into cooked mode once you are done reading input characters. The  call simply says "put the terminal back the way I found it". It knows how to do this by first calling  at the beginning of the program which is saying "tell me all the current settings for the terminal".Once you understand all that, you should easily be able to encapsulate the functionality in a function that suits your program.1  is the stream that input comes to you from the user. Wikipedia can tell you more about standard streams.
Using a good lightweight module curtsies you could do something like this (taken from their examples/ directory):So pressing keys on your keyboard gives you something like this:curtsies is used by bpython as a low level abstraction of terminal-related stuff.The basic problem of decoding the input is that in different terminals and terminal emulator programs like  or  physically same keys produce different keycode sequences. That's why one needs to know which terminal settings should be used to decode input. Such a module helps to abstract from those gory details.


Answer URL
https://docs.python.org/3/library/tk.html
