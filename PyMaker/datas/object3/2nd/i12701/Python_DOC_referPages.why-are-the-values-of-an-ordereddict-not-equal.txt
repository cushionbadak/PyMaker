Natural Text
With Python 3:I wanted to check for equality:But:Do you know why values are not equal?I've tested this with Python 3.4 and 3.5.Following this question, I posted on the Python-Ideas mailing list to have additional details:https://mail.python.org/pipermail/python-ideas/2015-December/037472.html
In Python 3,  and  return special iterable classes - respectively a  and a . The first one inherit it's  method from , the second uses the default  which tests on object identity. 
In python3,  and  are  objects:Don't compare them as an  object, convert them to lists and then compare them:Investigating why it works for comparing keys, in  of CPython,  is inheriting from  while  does not:Tracing for  in  and its parents: . is implemented only in  and not overridden. In the other hand,  inherits  directly from .
Unfortunately, both current answers don't address why this is but focus on how this is done. That mailing list discussion was amazing, so I'll sum things up:For / and /:  (subclass of ) supports comparison due to its conformance to  (it's a set-like object). This is possible due to the fact that  inside a dictionary (ordered or not) are guaranteed to be unique and hashable. (subclass of ) also supports comparison for the same reason as  does.  is allowed to do this since it raises the appropriate error if one of the s (specifically, the second element representing the value) is not hashable, uniqueness is guaranteed, though (due to  being unique):For both these views , , the comparison uses a simple function called  (pretty readable) that uses the objects  method to check for membership of the elements in the views involved.Now, about /:As noticed,  (subclass of  [shocker]) doesn't compare like a set-like object. This is because the  of a  cannot be represented as a set, the reasons are two-fold:Most importantly, the view might contain duplicates which cannot be dropped.The view might contain non-hashable objects (which, on it's own, isn't sufficient to not treat the view as set-like).As stated in a comment by @user2357112 and by @abarnett in the mailing list, / is a multiset, a generalization of sets that allows multiple instances of it's elements. Trying to compare these is not as trivial as comparing  or  due to the inherent duplication, the ordering and the fact that you probably need to take into consideration the keys that correspond to those values. Should  that look like this: actually be equal even though the values that correspond to the keys isn't the same? Maybe? Maybe not? It isn't straight-forward either way and will lead to inevitable confusion.The point to be made though is that it isn't trivial to compare these as is with  and , to sum up, with another comment from @abarnett on the mailing list:If you're thinking we could define what multisets should do, despite not having a standard multiset type or an ABC for them, and apply that to values views, the next question is how to do that in better than quadratic time for non-hashable values. (And you can't assume ordering here, either.) Would having a values view hang for 30 seconds and then come back with the answer you intuitively wanted instead of giving the wrong answer in 20 millis be an improvement? (Either way, you're going to learn the same lesson: don't compare values views. I'd rather learn that in 20 millis.) 


Answer URL
https://docs.python.org/3/glossary.html#term-dictionary-view
https://docs.python.org/3/library/stdtypes.html#dict-views
