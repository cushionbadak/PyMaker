Natural Text
Let's say I have the following:This is just a dot image (from https://en.wikipedia.org/wiki/Data_URI_scheme). But I do not know if it is image or text etc. Is it possible to understand what it is only having this encoded string? I try it in Python, but it is also general question. So any insight in both is highly welcome.
You can't, at least not without decoding, because the bytes that help identify the filetype are spread across the base64 characters, which don't directly align with whole bytes. Each character encodes 6 bits, which means that for every 4 characters, there are 3 bytes encoded.Identifying a filetype requires access to those bytes in different block sizes. A JPEG image for example, can be identified from the bytes FF D8 or FF D9, but that's two bytes; the third byte that follows must also be encoded as part of the 4-character block. What you can do is decode just enough of the base64 string to do your filetype fingerprinting. So you can decode the first 4 characters to get the 3 bytes, and then use the first two to see if the object is a JPEG image. A large number of file formats can be identified from just the first or last series of bytes (a PNG image can be identified by the first 8 bytes, a GIF by the first 6, etc.). Decoding just those bytes from the base64 string is trivial.Your sample is a PNG image; you can test for image types using the  module:I only used the first 33 bytes from the base64 data, to echo what the  function will read from the file you pass it (it reads 32 bytes, but that number doesn't divide by 3).There is an equivalent  module, and there is also the  project that lets you pass in a number of bytes to determine a file type.
Of course, you can. There are few extremely easy approaches to the problem I can think of:Partial decodeEach base64 character encodes 6 bits of input, so you can relate them as follows:If you would like to extract 4 bytes of data, starting with offset 1, like this:Then, to decode only parts that you want, you need to know bit distances. They are easy to calculate, just multiply your byte distances by 8. Now, after you know you want 32 bits, starting with bit 8, you can find what base64 character contains your starting bits. To do that, divmod your  and  by 6:Well, this maps to the scheme above — your span starts after 1 full base64 char and 2 bits, and ends after 6 full base64 chars and 4 bits.Now, after you know exact base64 chars you want, you need to decode them. To do that, it makes sense to leverage existing base64 decoders, so we won't need to deal with base64 encoding yourself. And to do that, you should know that each 4 chars of base64 code correspond to 3 bytes of data. So, here goes the trick — you can prepend and append gibberish to your extracted base64 code, until base64 and byte boundaries align — and knowing how much invalid input will base64 decoder produce, throw out excess.So, how much to prepend depends on value of bit remainder. If start bit remainder is 0, it means that  and  are aligned, so no changes required:If bit remainder is 2, you need to prepend one base64 char, and throw out one leading byte after decoding:If bit remainder is 4, you need to prepend two base64 chars, and throw out two leading bytes after decoding:Same goes for trailing. If end bit remainder is zero, no changes:If end bit remainder is 2, you need to append two base64 chars, and throw out two trailing bytes:If end bit remainder is 4, you need to append one base64 char, and throw out one trailing byte:So, for synthetic example above, one character needs to be prepended (instead of ), and one character appended (in place of ):Now, after decoding, throw out extra bytes from head and tail and you're done.Practical exampleImagine you have a magic like . Then, to check if base64-coded string matches your magic, you can identify bytes in magic that are known, and their bit offsets and lengths:So, using our ideas from above:To decode  part, you need to take 7 full base64 chars, starting with char 1, then prepend 1 char, decode, throw out 1 leading byte and compare.To decode  part, you need to take 6 base64 chars, starting with char 16, then append 2 chars, decode, throw out 2 trailing bytes and compare.Translate magicsAlternative approach to what I had described above is instead of translating data, translate magics themselves.So, if you have magic  (I had replaced  and  for presentation purposes), like in an example above, when encoded to base64, it looks like this:In  part,  sign is only partially random. Let's look at that construct bitwise:So, only two lower bits of  are truly unknown, and that means that you can use that information while testing magic against the data, to narrow the scope of magic.For this particular case, here is exhaustive list of all encodings:Same applies to trailing  group, but because there are 4 undefined bits instead of 2, permutation list is longer:So, in regexp, your base64-magic for  would look like this:
Its a PNG imageOutput:


Answer URL
https://docs.python.org/3/library/imghdr.html
https://docs.python.org/3/library/sndhdr.html
