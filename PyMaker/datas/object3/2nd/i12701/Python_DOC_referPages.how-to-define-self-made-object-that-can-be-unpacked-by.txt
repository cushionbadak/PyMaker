Natural Text
Today I'm learning using  and  to unpack arguments.I find that both , , ,  can be unpacked by .I guess because they are all iterables. So I made my own class.It works! But how to make a  object like  in python so that  unpacking works on it? Is it possible to do that? And is there already another kind of  object in python except ?PS:I know I can make an object inherit from  class to make it a mapping object. But is there some key  like  to make a mapping object without class inheritance?PS2:With the help of @mgilson's answer, I've made an object which can be unpacked by  without inherit from current mapping object:Be aware, when unpacking using , the key in your mapping object should be type , or TypeError will be raised.
Any mapping can be used.  I'd advise that you inherit from  or 1.  They're abstract base classes -- you supply a couple methods and the base class fills in the rest.Here's an example of a "frozendict" that you could use:And usage is just:To answer your question about which "magic" methods are necessary to allow unpacking -- just based on experimentation alone -- in Cpython a class with  and  is enough to allow it to be unpacked with .  With that said, there is no guarantee that works on other implementations (or future versions of CPython).  To get the guarantee, you need to implement the full mapping interface (usually with the help of a base class as I've used above).In python2.x, there's also  which can be accessed in python3.x as  -- However if you're going to use this one, you can frequently just subclass from .1Note that as of Python3.3, those classes were moved to the module.
First, let's define unpacking:Now, the structure: two built-in options available are collections.abc.Mapping and collections.UserDict. As there's another answer exploring highly-customizable  type,  I will focus on :  can be easier to start with if all you need is a basic dict structure with some twist. After definition, underlying  dictionary of is also accessible as  attribute. 1.It can be used inline, like so: Breaking  into key=value pairs:2.If subclassing, all you have to do is to define self.data within . Note that i expanded the class with additional functionality with (self+other) 'magic' methods:Usage is:Adding other dict (or any  type) to it will call , returning new object:In-place modification with  will return the same object (same id in memory)Btw, i agree with other contributors that you should also be familiar with  and brethren types. For basic dictionary exploration  UserDict has all the same features and does not require from you to override abstract methods before becoming usable.


Answer URL
https://docs.python.org/3/library/collections.abc.html#collections.abc.Mapping
