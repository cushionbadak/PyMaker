Natural Text
How can I wrap an open binary stream – a Python 2 , a Python 3 , an  – in an ?I'm trying to write code that will work unchanged:Running on Python 2.Running on Python 3.With binary streams generated from the standard library (i.e. I can't control what type they are)With binary streams made to be test doubles (i.e. no file handle, can't re-open).Producing an  that wraps the specified stream.The  is needed because its API is expected by other parts of the standard library. Other file-like types exist, but don't provide the right API.ExampleWrapping the binary stream presented as the  attribute:In unit tests, the stream is replaced with an  instance to control its content without touching any subprocesses or filesystems.That works fine on the streams created by Python 3's standard library. The same code, though, fails on streams generated by Python 2:Not a solution: Special treatment for An obvious response is to have a branch in the code which tests whether the stream actually is a Python 2  object, and handle that differently from  objects.That's not an option for well-tested code, because it makes a branch that unit tests – which, in order to run as fast as possible, must not create any real filesystem objects – can't exercise.The unit tests will be providing test doubles, not real  objects. So creating a branch which won't be exercised by those test doubles is defeating the test suite.Not a solution: Some respondents suggest re-opening (e.g. with ) the underlying file handle:That works on both Python 3 and Python 2:But of course it relies on re-opening a real file from its file handle. So it fails in unit tests when the test double is an  instance:Not a solution: The standard library also has the  module, which provides wrapper features:That's good because it doesn't attempt to re-open the stream. But it fails to provide the  API. Specifically, it doesn't inherit  and doesn't have the  attribute:So  doesn't provide objects which substitute for .What to do?So how can I write code that works for both Python 2 and Python 3, with both the test doubles and the real objects, which wraps an  around the already-open byte stream?
Use codecs.getreader to produce a wrapper object:Works on Python 2 and Python 3.
It turns out you just need to wrap your  in  which exists on both Python 2 and Python 3.This answer originally suggested using os.pipe, but the read-side of the pipe would have to be wrapped in io.BufferedReader on Python 2 anyway to work, so this solution is simpler and avoids allocating a pipe.
Based on multiple suggestions in various forums, and experimenting with the standard library to meet the criteria, my current conclusion is this can't be done with the library and types as we currently have them.
Okay, this seems to be a complete solution, for all cases mentioned in the question, tested with Python 2.7 and Python 3.5. The general solution ended up being re-opening the file descriptor, but instead of io.BytesIO you need to use a pipe for your test double so that you have a file descriptor.
I needed this as well, but based on the thread here, I determined that it was not possible using just Python 2's  module.  While this breaks your "Special treatment for " rule, the technique I went with was to create an extremely thin wrapper for  (code below) that could then be wrapped in an , which can in turn be passed to the  constructor.  It will be a pain to unit test, as obviously the new code path can't be tested on Python 3.Incidentally, the reason the results of an  can be passed directly to  in Python 3 is because a binary-mode  actually returns an  instance to begin with (at least on Python 3.4, which is where I was testing at the time).At least this is small, so hopefully it minimizes the exposure for parts that cannot easily be unit tested.
Here's some code that I've tested in both python 2.7 and python 3.6.The key here is that you need to use detach() on your previous stream first. This does not close the underlying file, it just rips out the raw stream object so that it can be reused. detach() will return an object that is wrappable with TextIOWrapper.As an example here, I open a file in binary read mode, do a read on it like that, then I switch to a UTF-8 decoded text stream via io.TextIOWrapper.I saved this example as this-file.pyHere's what I get when I run it with both python2 and python3.Obviously the print syntax is different and as expected the variable types differ between python versions but works like it should in both cases.


Answer URL
https://docs.python.org/3/library/codecs.html#codecs.getreader
