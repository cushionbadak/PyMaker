Natural Text
The "traditional" way for a library to take file input is to do something like this:The client code is responsible for opening the file, seeking to the appropriate point (if necessary), and closing it.  If the client wants to hand us a pipe or socket (or a , for that matter), they can do that and it Just Works.But this isn't compatible with asyncio, which requires a syntax more like this:Naturally, this syntax only works with asyncio objects; trying to use it with traditional file objects makes a mess.  The reverse is also true.Worse, it seems to me there's no way to wrap this  inside a traditional  method, because we need to yield all the way up to the event loop, not just at the site where the reading happens.  The gevent library does do something like this, but I don't see how to adapt their greenlet code into generators.If I'm writing a library that handles file input, how should I deal with this situation?  Do I need two versions of the  function?  I have many such functions; duplicating all of them is not scalable.I could tell my client developers to use  or some equivalent, but that feels like working against asyncio instead of with it.
This is one of the downsides of explicit asynchronous frameworks. Unlike , which can monkeypatch synchronous code to make it asynchronous without any code changes, you can't make synchronous code -compatible without rewriting it to use  and  (or at least  and callbacks) all the way down.There's no way that I know of to have the same function work properly in both an  and normal, synchronous context; any code that's  compatible is going to rely on the event loop to be running to drive the asynchronous portions, so it won't work in a normal context, and  synchronous code is always going to end up blocking the event loop if its run in an  context. This is why you generally see -specific (or at least asynchronous framework-specific) versions of libraries alongside synchronous versions. There's just no good way to present a unified API that works with both.
Having considered this some more, I've come to the conclusion that it is possible to do this, but it's not exactly beautiful.Start with the traditional version of :We need to pass a file object which will behave "correctly" here.  When the file object needs to do I/O, it should follow this process:It creates a new event.It creates a closure which, when invoked, performs the necessary I/O and then sets the event.It hands the closure off to the event loop using .It blocks on the event.Here's some example code:We then arrange for  to be run in an executor (e.g. using  as suggested in the OP).The nice thing about this technique is that it works even if the author of  has no knowledge of .  It also ensures I/O is served on the event loop, which could be desirable in certain circumstances.


Answer URL
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.BaseEventLoop.run_in_executor
https://docs.python.org/3/library/threading.html#threading.Event
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.BaseEventLoop.call_soon_threadsafe
