Natural Text
I have spent the day trying to find an answer to this question but have come up with nothing.Suppose I have several classes, each containing a methods that are identical to those in the others.In this example, the identical methods are reduced to just one identical method, set_color, to illustrate what I am trying to do.Is there a way to eliminate repeating code, perhaps with an abstract class  as follows?I want to be able change from blue to red in a way like thisso that I don't have to define the same methods within each class  and but this doesn't work as I expected it to, it doesn't change the value of 
You can't. The whole point of -style attributes is that they're private. Base classes, subclasses, outsiders, nobody else can see the or modify them. If a base class or subclass tries, they will end up creating their own private attribute on the instance, completely independent of yours.If you don't want that, just don't use -style attributes.So, what should you do?Well, the most Pythonic thing is to just use public attributes, and scrap your getters and setters entirely: . If you have a really good reason you need to hide the attributes, maybe you wanted to make them  instead of , which means they're private only by convention, so your code will just work as-is. But again, I doubt you really need to hide them.If you really, really need  members, but still really need to defeat the entire purpose of  members… well, in that case, I lied; you actually can access them, by manually mangling the names. For example, the attribute that's named  from inside class  is named  from outside of class .If you're wondering why Python lets you violate the  protection... well, unlike the similar feature in Java, this isn't meant to protect you against someone else's malicious code. What it protects you from is a scenario like this: You write a class  with a an attribute . I write a class  with an attribute . Someone else composes our classes by inheriting from both, without telling either you or me. My code still works, so does yours.For further information, see the tutorial section on private variables, and the reference documentation on identifiers.
The only reason this wouldn't work exactly as you have it is because you're using attributes prefixed with , which makes them "private" and so not accessible to the parent class. Don't do that: just use normal attribute names.


Answer URL
https://docs.python.org/3/tutorial/classes.html#private-variables
