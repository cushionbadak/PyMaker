Natural Text
I've a vague idea of  referential and compact arrays.In Python, lists are referential arrays,so they use more memory for storing the memory locations of the referred elements.I could only infer from above examples that an integar in a list occupies an extra 4 bytes(32+4).Strings are array of characters.A unicode character should occupy 2 bits.Why is an empty string occupying 25 bytes?why is an empty list occupying 32 bytes?
I could only infer from above examples that an integar in a list occupies an extra 4 bytes(32+4).No, you're thinking about this wrong. is not recursive. In particular, the size of a list is just the size of the list "header" plus the array of references to its members. (In the usual CPython implementation, those references are  pointers) It makes no difference what kind of objects you have in the list, just how many there are.(Also, remember that lists usually have slack at the end. So, a list of 3 elements might actually have an array of 4 references, with the last one being a null pointer.)Meanwhile, the number  itself probably doesn't take any storage. Most Python implementations intern small integers, so there's a  object that's built into Python, and no matter how many references you create to the number , they're all just references to the same object; you never create another 4 bytes.Why is an empty string occupying 25 bytes?An string is, similarly to a list, a string "header", plus an array—just an array of characters, not of references to objects. Because they're immutable, there's no need for slack, which makes it easier to predict the size. If an empty string is 25 bytes on your system, that means a string header is 25 bytes, so  will be 28 bytes, and  will be 30, and so on. (I'm assuming either Python 2.x or Python 3.3+ here; if you're on 3.0-3.2, each character is actually 2 or 4 bytes. Although things are actually a bit more complicated for strings in Python 3.3+; read the source if you really want to know.)why is an empty list occupying 32 bytes?Because that's how big a list header is.If you want to see what's actually in these headers, you need to look at the source for your implementation. Assuming you're using CPython, you can find it here. (That points to the latest trunk version, 3.5alpha at this point; you can replace the  in the URL with  or  or whatever version you care about.)For example, lists are of type  in the C API. You can either search the source, or guess that  is probably the file that defines . And there, you will see the C struct that defines the type. Summarizing the members, there's a general header with information needed for all types (like a refcount), a pointer to the actual array, and an allocated count.
Read the docs: calls the object’s  method and adds an additional garbage collector overhead if the object is managed by the garbage collector.(emphasis is mine)
A unicode character should occupy 2 bits. Why is an empty string  occupying 25 bits?Because a Python string (bytes or unicode) is an object, not a unicode character. 


Answer URL
https://docs.python.org/3/c-api/list.html
https://docs.python.org/3/library/sys.html#sys.getsizeof
