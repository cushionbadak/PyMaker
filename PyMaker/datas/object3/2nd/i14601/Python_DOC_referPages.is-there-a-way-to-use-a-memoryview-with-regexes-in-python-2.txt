Natural Text
In Python 3, the  module can be used with a :However, in Python 2, this does not seem to be the case:I can cast the string to a , but looking at the buffer documentation, it doesn't mention exactly how a  works compared to a .Doing an empirical comparison shows that using a  object in Python 2 does not offer the performance benefits of using a  in Python 3:If the  argument is changed from  to , Python 2's performance is roughly the same as Python 3's, but in the code I'm writing, there's lots of repeated string slicing.Is there a way to circumvent this issue in Python 2 while still having the zero-copy performance benefits of a ?
The way that I understand the buffer object in Python 2, you’re supposed to use it without slicing:So instead of slicing the resulting buffer, you use the buffer function directly to perform your slicing which results in a fast access to the substring you are interested in:I got very similar results in Python 2 and 3 which suggests that using  like that with the  module has a similar effect as the newer  (which then seems to be a lazily evaluated buffer):And as a comparison with standard string slicing:If you want to support the slice access (so that you can use the same syntax everywhere), you could easily create a type that dynamically creates a new buffer when you slice on it:If you only use it with the  module, it could probably work as a direct drop-in replacement for . However, my tests show that this already gives you a large overhead. So you might want to do the opposite instead and wrap Python 3’s memoryview object in a wrapper that gives you the same interface as :


Answer URL
https://docs.python.org/3/library/re.html
https://docs.python.org/3/library/stdtypes.html#memoryview
