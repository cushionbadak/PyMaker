Natural Text
What is the difference between iterators and generators? Some examples for when you would use each case would be helpful.
 is a more general concept: any object whose class has a  method ( in Python 3) and an  method that does .Every generator is an iterator, but not vice versa.  A generator is built by calling a function that has one or more  expressions ( statements, in Python 2.5 and earlier), and is an object that meets the previous paragraph's definition of an .You may want to use a custom iterator, rather than a generator, when you need a class with somewhat complex state-maintaining behavior, or want to expose other methods besides  (and  and ).  Most often, a generator (sometimes, for sufficiently simple needs, a generator expression) is sufficient, and it's simpler to code because state maintenance (within reasonable limits) is basically "done for you" by the frame getting suspended and resumed.For example, a generator such as:or the equivalent generator expression (genexp)would take more code to build as a custom iterator:But, of course, with class  you could easily offer extra methods, i.e.if you have any actual need for such extra functionality in your application.
What is the difference between iterators and generators? Some examples for when you would use each case would be helpful.In summary: Iterators are objects that have an  and a  ( in Python 2) method. Generators provide an easy, built-in way to create instances of Iterators.A function with yield in it is still a function, that, when called, returns an instance of a generator object:A generator expression also returns a generator:For a more in-depth exposition and examples, keep reading.A Generator is an IteratorSpecifically, generator is a subtype of iterator.We can create a generator several ways. A very common and simple way to do so is with a function.Specifically, a function with yield in it is a function, that, when called, returns a generator:And a generator, again, is an Iterator:An Iterator is an IterableAn Iterator is an Iterable, which requires an  method that returns an Iterator:Some examples of iterables are the built-in tuples, lists, dictionaries, sets, frozen sets, strings, byte strings, byte arrays, ranges and memoryviews:Iterators require a  or  methodIn Python 2: And in Python 3:We can get the iterators from the built-in objects (or custom objects) with the  function:The  method is called when you attempt to use an object with a for-loop. Then the  method is called on the iterator object to get each item out for the loop. The iterator raises  when you have exhausted it, and it cannot be reused at that point.From the documentationFrom the Generator Types section of the Iterator Types section of the Built-in Types documentation:Python’s generators provide a convenient way to implement the iterator protocol. If a container object’s  method is implemented as a generator, it will automatically return an iterator object (technically, a generator object) supplying the  and  [ in Python 3] methods. More information about generators can be found in the documentation for the yield expression.(Emphasis added.)So from this we learn that Generators are a (convenient) type of Iterator. Example Iterator ObjectsYou might create object that implements the Iterator protocol by creating or extending your own object.But it's easier to simply use a Generator to do this:Or perhaps simpler, a Generator Expression (works similarly to list comprehensions):They can all be used in the same way:ConclusionYou can use the Iterator protocol directly when you need to extend a Python object as an object that can be iterated over. However, in the vast majority of cases, you are best suited to use  to define a function that returns a Generator Iterator or consider Generator Expressions.Finally, note that generators provide even more functionality as coroutines. I explain Generators, along with the  statement, in depth on my answer to "What does the “yield” keyword do?".
Iterators:Iterator are objects which uses  method to get next value of sequence.Generators:A generator is a function that produces or yields a sequence of values using  method. Every  method call on generator object(for ex:  as in below example) returned by generator function(for ex:  function in below example), generates next value in sequence.When a generator function is called, it returns an generator object without even beginning execution of the function. When  method is called for the first time, the function starts executing until it reaches yield statement which returns the yielded value. The yield keeps track of i.e. remembers last execution. And second  call continues from previous value.The following example demonstrates the interplay between yield and call to next method on generator object.
Adding an answer because none of the existing answers specifically address the confusion in the official literature.Generator functions are ordinary functions defined using  instead of . When called, a generator function returns a generator object, which is a kind of iterator - it has a  method. When you call , the next value yielded by the generator function is returned.Either the function or the object may be called the "generator" depending on which Python source document you read. The Python glossary says generator functions, while the Python wiki implies generator objects. The Python tutorial remarkably manages to imply both usages in the space of three sentences:Generators are a simple and powerful tool for creating iterators. They are written like regular functions but use the yield statement whenever they want to return data. Each time next() is called on it, the generator resumes where it left off (it remembers all the data values and which statement was last executed). The first two sentences identify generators with generator functions, while the third sentence identifies them with generator objects.Despite all this confusion, one can seek out the Python language reference for the clear and final word:The yield expression is only used when defining a generator function, and can only be used in the body of a function definition. Using a yield expression in a function definition is sufficient to cause that definition to create a generator function instead of a normal function.When a generator function is called, it returns an iterator known as a generator. That generator then controls the execution of a generator function. So, in formal and precise usage, "generator" unqualified means generator object, not generator function. The above references are for Python 2 but Python 3 language reference says the same thing. However, the Python 3 glossary states thatgenerator ... Usually refers to a generator function, but may refer to a generator iterator in some contexts. In cases where the intended meaning isn’t clear, using the full terms avoids ambiguity.
Generator Function, Generator Object, Generator:A Generator function is just like a regular function in Python but it contains one or more  statements. Generator functions is a great tool to create  Iterator objects as easy as possible.  The Iterator object returend by generator function is also called Generator object or Generator. In this example I have created a Generator function which returns a Generator object . Just like other iterators, Generator objects can be used in a   loop  or with   the built-in function  which returns the next value from generator. So a generator function is the easiest way to create an Iterator object.Iterator:Every generator object is an iterator but not vice versa.  A custom  iterator object  can  be created if its class implements   and  method (also called iterator protocol). However, it is  much easier to use generators function to create iterators because they simplify their creation,  but a custom Iterator gives you more freedom and you can also implement other methods according to your requirements as shown in the  below example. 
Everybody has a really nice and verbose answer with examples and I really appreciate it. I just wanted to give a short few lines answer for people who are still not quite clear conceptually:If you create your own iterator, it is a little bit involved - you have to create a class and at least implement the iter and the next methods. But what if you don't want to go through this hassle and want to quickly create an iterator. Fortunately, Python provides a short-cut way to defining an iterator. All you need to do is define a function with at least 1 call to yield and now when you call that function it will return "something" which will act like an iterator (you can call next method and use it in a for loop). This something has a name in Python called GeneratorHope that clarifies a bit.
Previous answers missed this addition: a generator has a  method, while typical iterators don’t. The  method triggers a  exception in the generator, which may be caught in a  clause in that iterator, to get a chance to run some clean‑up. This abstraction makes it most usable in the large than simple iterators. One can close a generator as one could close a file, without having to bother about what’s underneath.That said, my personal answer to the first question would be: iteratable has an  method only, typical iterators have a  method only, generators has both an  and a  and an additional .For the second question, my personal answer would be: in a public interface, I tend to favor generators a lot, since it’s more resilient: the  method an a greater composability with . Locally, I may use iterators, but only if it’s a flat and simple structure (iterators does not compose easily) and if there are reasons to believe the sequence is rather short especially if it may be stopped before it reach the end. I tend to look at iterators as a low level primitive, except as literals.For control flow matters, generators are an as much important concept as promises: both are abstract and composable.
You can compare both approaches for the same data:Besides, if you check the memory footprint, the generator takes much less memory as it doesn't need to store all the values in memory at the same time.


Answer URL
https://docs.python.org/3/reference/expressions.html#yield-expressions
https://docs.python.org/3/glossary.html
