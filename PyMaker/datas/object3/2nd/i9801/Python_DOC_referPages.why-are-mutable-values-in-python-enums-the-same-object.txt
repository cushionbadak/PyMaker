Natural Text
While experimenting with different value types for  members, I discovered some odd behavior when the values are mutable.If I define the values of an  as different lists, the members still behave similarly to when the  values are typical immutable types like  or , even though I can change the values of the members in place so that the values of the two  members are the same:However, if I define the values to be identical lists, each member's value seems to be the same object, and thus any mutation of one member's value affects all members:Why does  behave this way?  Is it the intended behavior or is it a bug?NOTE: I'm not planning on actually using Enums this way, I was simply experimenting with using non-standard values for Enum members
From the docs:Given two members A and B with the same value (and A defined first), B is an alias to A. By-value lookup of the value of A and B will return A. By-name lookup of B will also return A:This operates by equality, even when the values are mutable. Since you defined equal values for  and , with  first,  is an alias for .
To complement @user2357112's answer, take a look in , the metaclass for all  classes; it gets a peek at every class definition that has its type and gets a change to alter it. Specifically, it takes care to  re-assign members with the same value in its  method  via simple assignment:I didn't opt to check the docs and instead looked in the source. Lesson to take: Always check the docs, and if  is raised;  check the source :-)
Python 3 Enum class doesn't enforce uniqueness unless you specifically tell it to via the unique decoratorSee also duplicate values. since  is identical to , it just becomes an alias for .
From the Python documentation for Enums:By default, enumerations allow multiple names as aliases for the same value. When this behavior isnâ€™t desired, the following decorator can be used to ensure each value is used only once in the enumeration....This means that  is an alias for . When either one changes, the other must as well. You can however, force Python to make each enum value unique, by using the  decorator. Also from the docs:


Answer URL
https://docs.python.org/3/library/enum.html#duplicating-enum-members-and-values
https://docs.python.org/3/library/enum.html#ensuring-unique-enumeration-values
https://docs.python.org/3/library/enum.html#duplicating-enum-members-and-values
https://docs.python.org/3/library/enum.html#how-are-enums-different
