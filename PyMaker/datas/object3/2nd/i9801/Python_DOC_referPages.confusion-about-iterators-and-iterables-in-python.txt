Natural Text
I am currently reading in the official documentation of Python 3.5.It states that  is iterable, and that  and  are iterators. [section 4.3]However, here it states that  makes an iterator.My question is that when we use this instruction:are we using an iterator () to iterate through another iterator?
The documentation is creating some confusion here, by re-using the term 'iterator'.There are three components to the iterator protocol:Iterables; things you can potentially iterate over and get their elements, one by one.Iterators; things that do the iteration. Every time you want to step through all items of an iterable, you need one of these to keep track of where you are in the process. These are not re-usable; once you reach the end, that's it. For most iterables, you can create multiple indepedent iterators, each tracking position independently.Consumers of iterators; those things that want to do something with the items.A  loop is an example of the latter, so #3. A  loop uses the  function to produce an iterator (#2 above) for whatever you want to loop over, so that "whatever" must be an iterable (#1 above). is an example of #1; it is iterable object. You can iterate over it multiple times, independently:Here  and  are two separate iterators, and each time you ask for a next item they do so based on their own internal bookkeeping. is an example of both an iterable (#1) and a iteration consumer (#3). If you pass another iterable (#1) to the  call, a list object is produced containing all elements from that iterable. But list objects themselves are also iterables., in Python 3, takes in multiple iterables (#1), and is itself an iterator (#2).  stores a new iterator (#2) for each of the iterables you gave it. Each time you ask  for the next element,  builds a new tuple with the next elements from each of the contained iterables:So in the end,  uses both  and  as iterables (#1),  consumes those (#3) when it itself is being consumed by the outer  call. 
The documentation is badly worded. Here's the section you're referring to:We say such an object is iterable, that is, suitable as a target for functions and constructs that expect something from which they can obtain successive items until the supply is exhausted. We have seen that the  statement is such an iterator. The function  is another; it creates lists from iterables:In this paragraph, iterator does not refer to a Python iterator object, but the general idea of "something which iterates over something". In particular, the  statement cannot be an iterator object because it isn't an object at all; it's a language construct.To answer your specific question:... when we use this instruction:are we using an iterator () to iterate through another iterator?No,  is not an iterator. It's the constructor for the  type. It can accept any iterable (including an iterator) as an argument, and uses that iterable to construct a list. is an iterator function, that is, a function which returns an iterator. In your example, the iterator it returns is passed to , which constructs a  object from it.A simple way to tell whether an object is an iterator is to call  with it, and see what happens:In this case, the next element of  is returned.Notice that only the last two elements of the iterator are found in , because we already consumed the first one with .This doesn't work, because lists are not iterators.This time, although  is an iterator, calling  with it raises  because it's already been exhausted to construct .


Answer URL
https://docs.python.org/3/tutorial/controlflow.html
https://docs.python.org/3/library/functions.html#zip
https://docs.python.org/3/library/stdtypes.html#iterator-types
https://docs.python.org/3/library/functions.html#iter
https://docs.python.org/3/reference/compound_stmts.html#for
https://docs.python.org/3/library/stdtypes.html#list
https://docs.python.org/3/library/stdtypes.html#list
https://docs.python.org/3/library/functions.html#zip
https://docs.python.org/3/library/functions.html#next
