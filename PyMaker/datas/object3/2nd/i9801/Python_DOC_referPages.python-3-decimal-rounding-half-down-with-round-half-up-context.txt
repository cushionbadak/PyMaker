Natural Text
Can anybody explain or propose a fix for why when I round a decimal in Python 3 with the context set to round half up, it rounds 2.5 to 2, whereas in Python 2 it rounds correctly to 3:Python 3.4.3 and 3.5.2:Python 2.7.6:
Notice that when you call  you are getting a float value as a result, not a .  is coercing the value to a float and then rounding that according to the rules for rounding a float.If you use the optional  parameter when you call  you will get back a Decimal result and in this case it will round the way you expected.I haven't found where it is documented that  returns an int but  returns a decimal, but that seems to be what happens in Python 3.3 and later. In Python 2.7 you always get a float back when you call  but Python 3.3 improved the integration of  with the Python builtins.As noted in a comment,  delegates to  and that indeed shows the same behaviour:I note that the documentation for  says:Thus the behaviour is consistent in that with no argument it changes the type of the result and rounds half to even, however it seems that  fails to document the behaviour of its  method.Edit to note as Barry Hurley says in the comments,  is documented as returning a  if called without the optional arguments and a "floating point value" if given the optional argument. https://docs.python.org/3/library/functions.html#round
Expanding on @Duncan's answer, the  builtin function changed between python 2 and python 3 to round to the nearest even number (which is the norm in statistics).  Python2 docs:...if two multiples are equally close, rounding is done away  from 0 (so, for example, round(0.5) is 1.0 and round(-0.5) is -1.0).Python3 docs:...if two multiples are equally close, rounding is done toward the even  choice (so, for example, both round(0.5) and round(-0.5) are 0, and  round(1.5) is 2)Since  converts to  if no argument is given for  (credit to @Duncan's answer),  behaves the same way as it would for s.Examples (in python3):
This is a combination of changes between the rounding mode of  in Python 2 vs 3 and the re-implementation of  from Python to  (See "Other final large-scale changes" in the Features for 3.3 section PEP 398).For , the rounding strategy changed as can be seen in What's New In Python 3.0 [Also see Python 3.x rounding behavior ]. Additionally,  in Python  first tries to find an appropriate  method defined for the object passed:While in Python  it first tries to coerce it specifically to a  and then round it: For , in Python , the implementation even lacked a  method to be called: So, calling  on a  object coerced it to a  which  got rounded using ; this resulted in a  always getting returned irregardless of if a value for  was supplied.  is implemented in pure Python for  and (was?) for Python  until .In Python  it got shinny new  method as it was re-implemented in :and now, it gets picked up by  when  is invoked.This, mapped to  in , now returns a PyLong (an integer) using the default context () if the argument  is not supplied and, if it is, calls  on it and returns a new rounded  object.


Answer URL
https://docs.python.org/3/library/functions.html#round
https://docs.python.org/3/library/functions.html#round
