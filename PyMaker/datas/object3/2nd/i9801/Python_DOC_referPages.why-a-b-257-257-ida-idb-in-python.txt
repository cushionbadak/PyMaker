Natural Text
This question already has an answer here:'is' operator behaves unexpectedly with non-cached integers                    2 answers                After reading this and this, which are pretty similar to my question, I still cannot understand the following behaviour:When printing  and  I can see that the variables, to which the values were assigned in separate lines, have different ids, whereas with multiple assignment both values have the same id:But it's impossible to explain this behaviour by saying that multiple assignment of same values always creates pointers to the same id since:Is there a clear rule, which explains when the variables get the same  and when not?editrelevant info: The code in this question was run in interactive mode(ipython3)
This is due to a constant folding optimization in the bytecode compiler. When the bytecode compiler compiles a batch of statements, it uses a dict to keep track of the constants it's seen. This dict automatically merges any equivalent constants.Here's the routine responsible for recording and numbering constants (as well as a few related responsibilities):You can see that it only adds a new entry and assigns a new number if it doesn't find an equivalent constant already present. (The  bit makes sure things like , , and  are considered inequivalent.)In interactive mode, a batch ends every time the interpreter has to actually run your command, so constant folding mostly doesn't happen across commands:In a script, all top-level statements are one batch, so more constant folding happens:In a script, this prints .A function's code gets its constants tracked separately from code outside the function, which limits constant folding:Even in a script, this prints .
That's because of pythons interpreter optimization at  time, during loading the constant values. When python encounters an iterable during the unpacking, it doesn't load the duplicate objects multiple times, instead it just keeps the first object and assigns all your duplicate variable names to one pointer (In CPython implementation). Therefore, all your variables will become same references to one object. At python level you can think of this behavior as using a dictionary as the namespace which doesn't keep duplicate keys.In other words, your unpacking would be equivalent to following command:And about the negative numbers, in python 2.X it doesn't make any difference but in python 3.X it seems that for numbers smaller than -5 python will create new object during unpacking:
Any such rule is implementation-specific. CPython, for example, pre-allocates  objects for small integers (-5 through 256) as a performance optimization.The only general rule is to assume any use of a literal will generate a new object.


Answer URL
https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy
