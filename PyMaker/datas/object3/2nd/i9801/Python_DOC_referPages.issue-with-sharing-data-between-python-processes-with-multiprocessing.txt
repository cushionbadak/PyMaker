Natural Text
I've seen several posts about this, so I know it is fairly straightforward to do, but I seem to be coming up short.  I'm not sure if I need to create a worker pool, or use the Queue class.  Basically, I want to be able to create several processes that each act autonomously (which is why they inherit from the Agent superclass).  At random ticks of my main loop I want to update each Agent.  I'm using  with different values in the main loop and the Agent's run loop to simulate different processor speeds.Here is my Agent superclass:A specific agent's subclass (simulating an HVAC system):And my main loop:So the issue is that, whenever I run  within the main loop, I can see the value being passed into the  subclass in its  loop (so it prints the received value correctly).  However, the value never is successfully stored.So typical output looks like this:When in reality, as soon as Measured [68] appears, the internal stored value should be updated to output 68 (not heating 1, heating 2, etc.).  So effectively, the HVAC's self.__meas_temperature is not being properly updated.  Edit: After a bit of research, I realized that I didn't necessarily understand what is happening behind the scenes.  Each subprocess operates with its own virtual chunk of memory and is completely abstracted away from any data being shared this way, so passing the value in isn't going to work.  My new issue is that I'm not necessarily sure how to share a global value with multiple processes.   I was looking at the Queue or JoinableQueue packages, but I'm not necessarily sure how to pass a Queue into the type of superclass setup that I have (especially with the  call).A side concern would be if I can have multiple agents reading values out of the queue without pulling it out of the queue?  For instance, if I wanted to share a  value with multiple agents, would a Queue work for this?  Pipe v Queue
Here's a suggested solution assuming that you want the following:a centralized manager / main process which controls lifetimes of the workersworker processes to do something self-contained and then report results to the manager and other processesBefore I show it though, for the record I want to say that in general unless you are CPU bound  is not really the right fit, mainly because of the added complexity, and you'd probably be better of using a different high-level asynchronous framework. Also, you should use python 3, it's so much better!That said, , makes this pretty easy to do using . I've done this in python 3 but I don't think anything shouldn't "just work" in python 2, but I haven't checked.


Answer URL
https://docs.python.org/3/library/multiprocessing.html
