Natural Text
I'm writing some code for an esp8266 micro controller using micro-python and it has some different class as well as some additional methods in the standard built in classes.  To allow me to debug on my desktop I've built some helper classes so that the code will run.  However I've run into a snag with micro-pythons time function which has a time.sleep_ms method since the standard time.sleep method on micropython does not accept floats.  I tried using the following code to extend the built in time class but it fails to import properly.  Any thoughts?This code exists in a file time.py.  Secondly I know I'll have issues with having to import time.time that I would like to fix.  I also realize I could call this something else and put traps for it in my micro controller code however I would like to avoid any special functions in what's loaded into the controller to save space and cycles.
You're not trying to override a class, you're trying to monkey-patch a module.First off, if your module is named , it will never be loaded in preference to the built-in  module. Truly built-in (as in compiled into the interpreter core, not just C extension modules that ship with CPython) modules are special, they are always loaded without checking , so you can't even attempt to shadow the  module, even if you wanted to (you generally don't, and doing so is incredibly ugly). In this case, the built-in  module shadows you; you can't import your module under the plain name  at all, because the built-in will be found without even looking at .Secondly, assuming you use a different name and import it for the sole purpose of monkey-patching time (or do something terrible like adding the monkey patch to a custom  module, it's not trivial to make the function truly native to the monkey-patched module (defining it in any normal way gives it a scope of the module where it was defined, not the same scope as other functions from the  module). If you don't need it to be "truly" defined as part of , the simplest approach is just:Of course, as mentioned,  is still part of your module, and carries your module's scope around with it (that's why you do , not just ; you could do  to avoid qualifying it, but it's still a local alias that might not match  if someone else monkey-patches  later).If you want to make it behave like it's part of the  module, so you can reference arbitrary things in 's namespace without qualification and always see the current function in , you need to use  to compile your code in 's scope:


Answer URL
https://docs.python.org/3/tutorial/modules.html#the-module-search-path
https://docs.python.org/3/library/site.html
https://docs.python.org/3/tutorial/modules.html#the-module-search-path
