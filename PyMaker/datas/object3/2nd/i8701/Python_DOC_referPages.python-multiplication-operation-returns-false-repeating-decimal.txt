Natural Text
This question already has an answer here:Is floating point math broken?                    28 answers                I was doing my program for a school project when I encountered a problem which I'm unable to understand after trying many different methods to resolve it. I have a function that does a simple mathematical operation like this:Now, when giving the function numbers 4.9 and 140 (in this same order), it returns me a number which isn't true, because 4.9 * 1.2 + 0.5 = 6.38 and 140 * 6.38 = 893.2, but all I get is 893.1999999999999, but it's not even true, try doing 140 * 6.38 yourself - it's exactly 893.2 PS! It has to be a float number, it's in my project instructions that it can't be rounded to an integer, so answers like "just put a round() infront and you are good" don't help me at all.
This has to do with the internal representation of floating point numbers in python. From the docs:Itâ€™s easy to forget that the stored value is an approximation to the original decimal fraction, because of the way that floats are displayed at the interpreter prompt. Python only prints a decimal approximation to the true decimal value of the binary approximation stored by the machine. If Python were to print the true decimal value of the binary approximation stored for 0.1, it would have to display0.1      0.1000000000000000055511151231257827021181583404541015625so you are better of specifying the precision you want, From here
This is a floating point precision problem. If you read the docs it says that this problem is due to it trying to produce numbers that are as accurate as possible, there are ways around this issue such as rounding with the built-in function  which in your case you could round anywhere after the tenths place and it would fix your problem.


Answer URL
https://docs.python.org/3/tutorial/floatingpoint.html
https://docs.python.org/3/library/decimal.html
