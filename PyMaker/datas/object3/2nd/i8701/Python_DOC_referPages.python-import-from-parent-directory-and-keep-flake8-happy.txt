Natural Text
This import works fine, but feels dirty in a few ways. Mainly that it uses a specific number in the slice* to get the parent path, and that it annoys the flake8 linter.It's in a file system that looks a bit like this:( is actually called , hence the 5 in the slice)This question is extremely similar to Python import from parent directory, but in that case the discussion focused on whether or not it was good to run tests from the end point. In my case, I have a series of directories that have code that uses helpers that live in the parent.Context: each directory is a set of weekly exercises, so I'd like to keep them as simple as possible.Is there a cleaner, more pythonic way to do this import?@cco solved the number problem, but it's still upsetting the linter.
First since you haven't been specific about which lint error you are getting, I am going to assume it's because you have an import after your .The cleanest way to do it is with relative or absolute imports.Using absolute imports:Using relative imports:For the simple example listed in the original question this should be all that's required.  It's simple, it's pythonic, it's reliable, and it fixes the lint issue.You may find yourself in a situation where the above does not work for you and  manipulation is still required. A drawback is that your IDE will likely not be able to resolve imports to modules from the new path causing issues such as automatic code completion not working and flagging the imports as errors, even though the code will run properly.If you find you still need to use  and want to avoid lint errors for this type of situation create a new module and do the  manipulation in it instead.  Then make sure that you import your new module before any modules that require the modified .For example:local_imports.pyThen in the target file:The drawback to this is it requires you to include  in each  and if the folder structure changes, you would have to modify each one  file.Where this pattern is really useful is when you need to include external libraries in your package (for example in a  folder) without requiring the user to install the libs themselves.If you are using this pattern for a  folder, you may want to make sure your included libraries are preferred over the installed libraries.To do so, changetoThis will make your custom path the second place the python interpreter will check (the first will still be  which is the local directory).
You can import from a module a level up in a package by using . In this_file.py:Had you wanted to go more levels up just keep adding dots...While I'm here, just be aware that  is a relative import, and you should always use them when importing something in the same package.  is an absolute import, which are ambiguous in Python 2 (should it import from in the package or from the unfortunately named  module you have installed on your system?), and in Python 3 actually forbidden as a way to import from within the same module (i.e. they are always absolute). You can read the ancient PEP 328 for an explanation of the difficulties.
It might be easier to use absolute import paths, like the following:But this would require you to make sure that the PYTHONPATH environment variable is set such that it can see the highest root directory ( in this case, I think).  For instance,Make sure to add an  to the child_directory as well.
You can remove the assumption about the length of the final directory name by applying  twice.e.g. instead of , use 
Either way you have to hack around. If you main goal avoid flakes warningsadd a  commentyou can pass a filename with interpreter option -c (should not bother flakes8)


Answer URL
https://docs.python.org/3/library/__main__.html
