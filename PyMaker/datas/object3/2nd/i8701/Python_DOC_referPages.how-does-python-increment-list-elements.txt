Natural Text
Can someone explain to me why the first code block doesn't change the list, but the second does.This leaves  as . That said if I runthen . My guess is that in the first, when looping over the elements  is a temporary variable, and not actually the thing that references that element in the list. Not sure why incrementing it doesn't effect the list though.
Python integers are not mutable, but lists are.In the first case  references immutable integers, so  creates a new integer that only  refers to.In the second case the list  is mutated directly, modifying its elements directly.   still references an immutable integer, so  creates a new integer, but its reference is assigned directly to an element of the mutable list.ExamplesHere are examples showing the reference ids of list elements.  In the first case, new integers are created, but the original list references are unchanged.OutputIn the second case, the list references are updated:Output
 (when the left-hand side is just an identifier) is purely a syntactic construct, which binds the name on the left to the object on the right.All other assignments are short-hand for various method calls. is short for  is  short for  is short for The end result of each method call depends on how  implements the method being called. The method might mutate its caller, or it might return a new object.
I first wrote this as a comment but I'd like to expand it a bit, especially to add the tuple example.Mark Tolonen's answer is correct (and upvoted) in that ordinary integers are immutable (cannot be changed) and lists are mutable (can have elements replaced), but does not mention another couple of key concepts, which show up in slightly scary examples:Objects get bound to variables.Ordinary variable assignment like  simply binds the object on the right—which may be constructed on the spot if needed—to the name on the left."In-place" operators like  attempt to invoke modifier functions, which allows mutable objects to capture them.  For instance, if  is bound to a class instance, writing  will actually execute , if  has an .1  If not, it runs  instead, which invokes the  operator: .  See the operator documentation for all the gory details.  In this case, the objects involved—ordinary integers—don't have modifier functions:so this particular twist is irrelevant for , but it's worth remembering.Indexed assignment, , invokes the  method.  This is how mutable (modifiable) objects mutate themselves.  A list object implements :For completeness, I will note that it also implements  to retrieve .Hence, when you write , you wind up calling:which is how Python manages to add 5 to the i'th element of the list bound to .Here's the slightly scary example.  A tuple object is not modifiable, but a list object is.  If we embed a list into a tuple:we can then use  to invoke  and .  Meanwhile  is bound to the same list object as .  This part is obvious enough:We modified  in place, so , which names the same list as , has been modified.  But now:What?!  How did  change when we got an error telling us that  can't change?The answer is,  didn't change, but the list (which we can also access via ) did change.  Lists implement , so the assignment:"means":The  accessed the list and the  augmented the list:and then the  raised the , but the list was already augmented by then.Note, by the way, the fact that tweaking the list object bound to  affects the tuple object bound to , because  is that list object.  This—the fact that variables are bound to objects, and elements within data structures like tuples, lists, and dictionaries, can refer to other objects—is critical in reading and writing Python code.  Understanding both the binding rules, and when objects get created, is the key to knowing why this is usually a bad idea:Specifically, the list object here is created at  time, i.e., just once.  Any time someone adds to the list inside , with  for instance, it keeps adding to that original list!See also python: how binding works for (way too) much more about additional binding rules. :-)1As Duncan points out in a comment on chepner's answer, after invoking , the returned result is re-bound to the object.  (All functions return a result; returning without an expression, or "falling off the end" of a function, is defined as returning .)Mutable objects should generally return themselves, and immutable objects don't need to implement  in the first place since implementing a mutation on a supposedly-immutable object just seems odd.  Nonetheless, we can abuse, and thereby expose, this behavior by writing a class that pretends to be immutable, but is not.  Here's an example.  This is not meant to be useful, just to illustrate one of the darker corners of Python.Once we create the two objects and freeze the class, we invoke  three times on , so in the end,  and  are actually both bound to the second object.  The first object—findable only through the class's  field—has two items in its list-of-items.As an exercise, try to predict what this will print out, before running it.(Extra-advanced exercise: turn  into a metaclass that can be applied to classes to turn them into freeze-able multi-singletons.  [Is there a term for "thing that is like a singleton but allows N of them"?]  See also Why Singletons Are Controversial.)[Edit: this had been bugging me: it turns out there is a name for fixed-set-of-singletons.  When the set has just two elements, it's a "doubleton".  In Python,  and  are the doubletons comprising the  type.  The generalization to n objects is a multiton, often instantiated / used as a fixed—at least, after "freeze" time—hash table.  Note that Python's doubleton boolean instances are immutable, as is Python's singleton .]
In the first code block,  is a reference to one of the elements in  (depending on which iteration of the loop we're in).When you do  (or more clearly in this case, ), what you are doing is reassigning  to the value of . After this operation,  no longer points to the first element of the list, but the new variable we created (). The list remains unchanged.In the second code block, you are assigning something directly to an element of a list, as opposed to temporary reference .
In the first example,  is a local variable, and it's completely unaware that it's part of a list.In the second example, you are explicitly manipulating elements of the list.The lesson here will be slightly more clear if we expand the  shorthand, and if we use a list of mutable objects instead of immutable integers:Iterator pattern:After this loop,  is unchanged:Counting loop pattern:After this loop,  is changed:On the other hand, if you mutate  itself instead of reassigning it:Note that here we are not reassigning , we are mutating it without reassignment.The change will be visible through the list too:In case of your original example with a list of integers,this kind of mutation is not possible,because integers are immutable.So if you want to modify the values inside the list,you must use the counting loop approach.


Answer URL
https://docs.python.org/3/library/operator.html
