Natural Text
This results in .This results in . What order of evaluation gives these two results?
RHS first and then LHS. And at any side, the evaluation order is left to right. is same as, See how the behavior changes when we change the order of the operations at RHS,
The key insight is that  is syntactic sugar for . This holds true because  is being applied to an immutable object (an  here) rather than a mutable object (relevant question here).The right hand side (RHS) is evaluated first. On the RHS: equivalent syntax is . First,  gets the last value . Second,  s . +  is .On the Left hand side (LHS),  is now  due to the in-place mutation already applied by  and so the value of  is changed from  to .
Let's have a look at the output of  for 1):The meaning of the different instructions is listed here.First,  and  load  and  onto the stack, and  duplicates the two, before  gets the subscript value, resulting in  on the stack. It then loads  again, and  loads the  function, which is called with no arguments by . The stack is now , and  adds the top two values. Finally,  rotates the stack to  to match the order expected by  and the value is stored.So, in short, the current value of  is evaluated before calling  and the result of the addition is then stored back to the new , irrespective of its current value.1)  This is the disassembly for Python 3, slightly compressed to better fit on the page, with an added column showing the stack after ; for Python 2 it looks a bit different, but similar.
Using a thin wrapper around a list with debugging print-statements can be used to show the order of evaluation in your cases:When I now run your example:So it starts by getting the last item, which is 3, then pops the last item which is also 3, adds them and overwrites the last item of your list with . So the final list will be .And in your second case:This now takes the first item () adds it to the popped value () and overwrites the first item with the sum: .The general order of evaluation is already explained by  and . This answer just supplements the general principle mentioned there.
For you specific exampleOrder:evaluate  after , decreasing the length of additionassignmentThe thing is, that  becomes the value of  (was ) after the , but this happens before the assignment. Works as expectedevaluate  after additionassignmentThis example shows, why you shouldn't manipulate a list while working on it (commonly said for loops). Always work on copys in this case.


Answer URL
https://docs.python.org/3/library/dis.html#dis.dis
https://docs.python.org/3/library/dis.html#python-bytecode-instructions
