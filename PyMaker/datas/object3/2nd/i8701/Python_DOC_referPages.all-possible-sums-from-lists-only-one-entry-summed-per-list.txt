Natural Text
I'm making a practice program in Python to calculate all the different weights I can put on the rack, with a given set of plates.This leaves me with 6 lists.  To get all the combos, I need to add up one element of a list with one element of each other list.  At this point, it's clearly a linear algebra problem, I just don't know how to express this in Python, especially because I don't want to use plugins (No NumPy)
To get all the combos, I need to add up one element of a list with one element of each other list.It sounds like you want . To simplify the example, let's just take three of your seven terms (but it's trivial to pass more, or fewer, arguments into ):prints the following:...which sounds like what you want when you refer to "all the combos".To get the sum of each, it can all be done in one line:Here's a possible flexible way of parameterizing the function:When you call, say,  the call itself makes it explicit (and readable) that there is one compulsory 45-pound weight, two possible 10-pound weights, and three possible 5-pound weights. You have complete flexibility as to how many such arguments you pass and what their values are.You could then use a  to associate each total weight with the combo used to achieve it (incidentally removing duplicate totals, where more than one combo adds up to the same total):...and then pretty-print the result:Output:BTW: if you want to achieve each total using the minimum number of plates, make sure you're passing heavier plates before lighter plates in your call to , as in the example above.Balancing both sides of the bar is left as an exercise for the reader 
I think your approach is wrong and also you signature is bad design: what if you have other than 7 different kinds of weights? I think input as list of tuples (weight, max_number) is more appropriate. And when you start thinking in such terms you understand that "cross-joining" 7 lists is also wrong approach. What you want is to have one list of all simple weights and than get the power set i.e. all subsets. Rosetta Code has a few nice implementations of power set in Python. I particularly like this one because it doesn't force generation of whole power-set in memory which might be an issue:Or you can build one using itertools powerset recipe which is in practice faster (thanks to umutto)So the algorithm is:Build single list of all simple weights (join of your , , ...)Use  to generate powersetSum all items in each sub-setPush results to set to filter for uniqueness Note that uniqueness condition forces materialization of whole collection into memory so might be a limiting factor of the size of the problem this code can solve.UpdateActually jez is right: doing product of lists by coins will be significantly faster then iterating through  of joined lists 


Answer URL
https://docs.python.org/3/library/itertools.html
https://docs.python.org/3/library/itertools.html
