Natural Text
I have to work with big arrays, says for example I know python hold a variable in memory as long as it has at least one reference to it.But lets say i have to import a big array, do some math on it, and save a smaller array computed from the big one. Would the big array still be on memory ?For example : (in real life, i'm not creating array in the function but loading a file which contains large arrays, but this is for example purpose)will be  still in memory even if we aren't anymore in the 'process' function ?Edit : i know x will not be reachable as if I type  outside the function, there will be an error because he was defined in the scope of the function. I'm asking about memory and reference instead of variable name.If yes, should i use  to create another array so the reference would be deleted when leaving the function ?If no, where does it copy it ?Thanks for the explanation
Fancy indexing, unlike slicing, does not return a view, so you will not end up holding a reference to the your big array. See official explanation on views vs copies in Numpy.To directly answer your question, the part where you write  is where the copying is done. You do not need to explicitly call  unless you are doing slicing.To delve deeper, one way you can check that a variable is a view of the numpy array is to use Numpy's shares_memory functionYou can also use  to check the number of references  pointing to a variable  at one time.Note that the reason  prints 2 is that 1 reference is held by the variable  and the other is held by the function  and not .So in conclusion, you do not need to do an explicit copy if you are doing fancy indexing like in your example. If you are doing slicing, then that is a different story.
The variables specified in the scope of your process() will be removed from memory once you are no longer executing that function. You can see this in action by running the following:You get a  as the variable  is only defined in the scope of the  method. NOTE: If you had  in the  method, then after the  line you'd be able to access the  variable using  because that allocates the variable to the  object which you have reference to globally.EDIT for further clarification:Once a variable is out of scope, it is removed from memory automatically in Python. see Garbage Collection in Python for more info. 
To delete a Python object  from memory, call  and wait for the garbage collection to kick in. Garbage collection can also be interfered with manually with module gc, at your risk.It it important to clarify that  or similar deletion methods do not remove the object from memory, they only remove  the name  from the namespace. You still have to wait for garbage collection.UPDATETo answer the comment here below, we can check whether a slice of an array is a reference to the original array or not with the following code:Therefore, calling .copy() on the original array will create a new object, allowing you to delete the old one from the namespace and wait for its automatic deletion from memory. If you do not call .copy() you are still working with a reference to the old object and, as a consequence, whatever happens to the original object affetcts the reference.What should you do if you want to remove from memory part of an array:1) Copy the slice of the original array that you want to keep into a new array with a new name.2) Call  or any other deletion instruction on the original array3) Wait for its automatic deletion from memory4) Continue working with the new object.Since you are working with big arrays though, remember that you have both arrays loaded in memory for a certain amount of time if you use this process.UPDATE 2OP, as mentioned by @lightalchemist in the comment down below, the code you provided does not produce a reference to x, but rather a copy to it. The code you provided as an example does not fit the description of the problem you are facing.


Answer URL
https://docs.python.org/3/library/gc.html
