Natural Text
I was facing import error (ImportError: cannot import name 'ClassB') in following code:dir structure:::::in past i fixed it by quick 'experiment' by adding full name in import in a.py:I have read about import machinery and according to :This name will be used in various phases of the import search, and it may be the dotted path to a submodule, e.g. foo.bar.baz. In this case, Python first tries to import foo, then foo.bar, and finally foo.bar.baz. link2docI was expecting it will fail again, because it will try to import test_pkg during test_pkg import, but it is working. My question is why?Also 2 additional questions:is it proper approach to have cross modules dependencies?is it ok to have modules imported in package init.py?My analysis:Based on readings i recognized that high probably issue is that, because offClassA and ClassB import is executed as part of test_pkg import, but then hits import statement in a.py:and it fail because circular dependency occured.But is working when is imported using:and according to my understanding it shouldnt, because: This name will be used in various phases of the import search, and it  may be the dotted path to a submodule, e.g. foo.bar.baz. In this case,  Python first tries to import foo, then foo.bar, and finally  foo.bar.baz. If any of the intermediate imports fail, a  ModuleNotFoundError is raised.so i was expecting same behavior for both imports.Looks like import with full path is not launching problematic test_pkg import process
Your file is named , but you're trying to , not .Depending on your platform (see PEP 235 for details), this may work, or it may not. If it doesn't work, the symptoms will be exactly what you're seeing: .The fix is to . Or, if you want the module to be named , rename the file to .This actually has nothing to do with packages (except that the error message you get says  instead of , because in a failed  statement, Python can't tell whether you were failing to import a module from a package, or some global name from a module).So, why does this work?I was expecting it will fail again, because it will try to import test_pkg during test_pkg import, but it is working. My question is why?Because importing  isn't the problem in the first place; importing  is. And you solved that problem by importing  instead. is successfully found in .And then,  is found within that module, and imported into your module, because of course there's a  statement in .For your followup questions:is it proper approach to have cross modules dependencies?There's nothing wrong with cross-module dependencies as long as they aren't circular, and yours aren't.It's perfectly fine for  to import  with an absolute import, like . However, it's usually better to use a relative import, like  (unless you need dual-version code that works the same on Python 2.x and 3.x). PEP 328 explains the reasons why relative imports are usually better for intra-package dependencies (and why it's only "usually" rather than "always").is it ok to have modules imported in package ?Yes. In fact, this is a pretty common idiom, used for multiple purposes.For example, see , which imports all of the public exports from each of its submodules and re-exports them. There are a handful of rarely-used names in the submodules, which don't start with  but aren't included in , and if you want to use those you need to import the submodule explicitly. But everything you're likely to need in a typical program is included in  and re-exported by the package, so you can just write, e.g.,  instead of .
The code I would prefer to write is probably::::::The proper approach is to have cross module dependencies but not circular. You should figure out the hierarchy of your project and arrange your dependency graph in a DAG (directed acyclic graph).what you put in package  will be what you can access thru the package. Also you can refer to this question for the use of  in .


Answer URL
https://docs.python.org/3/reference/import.html#searching
