Natural Text
I have a python script with the following contents:Curiously, executing this script with the  flag prevents only the REPL from accessing builtins:How come the script can access builtins, but the REPL can't?
CPython doesn't look up  every time it needs to do a built-in variable lookup. Each frame object has an  member holding its built-in variable dict, and built-in variable lookup goes through there. is set on frame object creation. If a new frame has no parent frame (), or a different global variable dict from its parent frame, then frame object initialization looks up  to set . (If the new frame shares a global dict with its parent frame, then it inherits its parent's .) This is the only way  is involved in built-in variable lookup. You can see the code that handles this in .When you delete  inside a script, that doesn't affect . The rest of the code executing in the script's stack frame still sees builtins. Once the script completes and  drops you into interactive mode, every interactive command gets a new stack frame (with no parent), and the  lookup is repeated. This is when the deleted  finally matter.
The execution context is different. Within the REPL we are working line-by-line (Read, Eval, Print, Loop), which allows an opportunity for global execution scope to change in between each step. But the runtime executing a module is to load the modules code, and then exec it within a scope.In CPython, the builtins namespace associated with the execution of a code block is found by looking up the name  in the global namespace; this should be bound to a dictionary or a module (in the latter case the module's dictionary is used). When in the  module,  is the built-in module , otherwise  is bound to the dictionary of the  module itself. In both contexts of your question, we are in the  module.What's important is that CPython only looks up the builtins once, right before it begins executing your code. In the REPL, this happens every time a new statement is executed. But when executing a python script, the entire content of the script is one single unit. That is why deleting the builtins in the middle of the script has no effect.To more closely replicate that context inside a REPL, you would not enter the code of the module line by line, but instead use a compound statement:Naturally, you're probably now wondering how to remove builtins from within a script. The answer should be obvious: you can't do it by rebinding a name, but you can do it by mutation:As a final note, the fact that  name is bound at all is implementation detail of CPython and that is explicitly documented:Users should not touch ; it is strictly an implementation detail.  Don't rely on  for anything serious, if you need access to that scope the correct way is to  and go from there.


Answer URL
https://docs.python.org/3/reference/executionmodel.html#builtins-and-restricted-execution
