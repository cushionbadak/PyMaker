Natural Text
Is there any way to hook the CPython interpreter so that every function creation (, ) results in a call to a procedure that I've defined?  and  unfortunately don't seem to cover both  and .Update:It seems Python 3.7 has ... is there any option for earlier versions?
There is no equivalent to  tracing in versions before 3.7. If there were, the feature wouldn't have been added to 3.7 in the first place.If you can upgrade to 3.7, then what you want is easy:But if you can't… there are a number of more complicated things you could do, depending on what your reasons are for wanting this, but none of them are remotely easy:Use  tracing, and inspect the code until the next line. This is trivial for , but for  (and comprehensions1) it's going to be a big pain, because a  (or even five of them) can appear in the middle of a statement. You could  the source, or examine the bytecode, to figure out that there are functions being defined within, but there's still no way to call your hook right at the time of definition.Instead of using tracing, write an import hook that modifies the code as it's being imported. The easy way to do this is probably at the AST level: after you parse the source, use a  to inject calls to some function2 before or after each  and  node, then compile the transformed tree. But you could also do it at the bytecode level with  or , before or after each .3Script  instead of writing your own debugger. I'm not sure if this will even help, because  has no way to step through part of an expression in the first place.Debug CPython itself, and add a breakpoint in the  handler in the  loop that calls your code. Of course your code is in the debugger's interpreter—which can be Python for  and , but it's still not the same Python interpreter you're debugging. And, while it's possible to recursively evaluate code into the debugged interpreter (or trigger its ), it's not easy, and you segfault all over the place while working it out.1. Comprehensions (except list comprehensions, in 2.x) are implemented by defining and then calling a function. So, any of the methods that rely on the  opcode or similar are going to also fire on comprehensions, while those that rely on source or AST parsing will not (unless you do so explicitly, of course).2. Obviously you also need to inject an  at the top of every module to make that function available, or inject the function into the builtins module.3. And , for earlier versions of Python.


Answer URL
https://docs.python.org/3/library/ast.html#ast.NodeTransformer
