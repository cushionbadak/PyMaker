Natural Text
Since this question is about inheritance and , let's begin by writing a class. Here's a simple everyday class that represents a person:Like every good class should, it calls its parent constructor before initializing itself. And this class does its job perfectly well; it can be used with no problems:But when I try to make a class that inherits from both  and another class, things suddenly go wrong:Because of diamond inheritance (with the  class at the top), it's not possible to initialize  instances correctly. The  in  ends up calling , which throws an exception because the  argument is missing.But this problem wouldn't exist if  and  didn't call .This raises the question: Should classes that inherit directly from  call ? If yes, how would you correctly initialize ?Disclaimer: I know what  does, how the MRO works, and how  interacts with multiple inheritance. I understand what's causing this error. I just don't know what the correct way to avoid the error is.Why am I asking specifically about  even though diamond inheritance can occur with other classes as well? That's because  has a special place in python's type hierarchy - it sits at the top of your MRO whether you like it or not. Usually diamond inheritance happens only when you deliberately inherit from a certain base class for the goal of achieving a certain goal related to that class. In that case, diamond inheritance is to be expected. But if the class at the top of the diamond is , chances are that your two parent classes are completely unrelated and have two completely different interfaces, so there's a higher chance of things going wrong.
Should classes that inherit directly from  call ?You seem to search a simple "yes or no" answer for this question, but unfortunately the answer is "it depends". Furthermore, when deciding if you should call , it is somewhat irrelevant whether or not a class inherits directly from . What is invariant is that, if  is called, it should be called without arguments - since  does not accept arguments. Practically, in cooperative inheritance situations, this means you must ensure that all arguments are consumed before  gets invoked. It does not mean you should try to avoid  being invoked. Here is an example of consuming args before invoking , the  and  context has been popped out of the mutable mapping .I mentioned earlier that whether or not a class inherits directly from  is a red herring1. But I didn't mention yet what should motivate this design decision: You should call super init [read: super ] if you want the MRO to continue to be searched for other initializers [read: other s]. You should not invoke super if you want to indicate the MRO search should be stopped here.Why does  exist at all, if it doesn't do anything? Because it does do something: ensures it was called without arguments. The presence of arguments likely indicates a bug2.  also serves the purpose of stopping the chain of super calls - somebody has to not call super, otherwise we recurse infinitely. You can stop it explicitly yourself, earlier, by not invoking super. If you don't,  will serve as the final link and stop the chain for you.Class MRO is determined at compile time, which is generally when a class is defined / when the module is imported. However, note that the use of  involves many chances for runtime branching. You have to consider:Which arguments a method of the  is called with (i.e. which arguments you want to forward along the MRO)Whether or not super is called at all (sometimes you want to intentionally break the chain)Which arguments, if any, the  itself is created with (there is an advanced use case described below)Whether to call a proxied method before or after the code in your own method (put super first if need to access some state the proxied methods set up, put super last if you're setting up some state that the proxied methods rely on being there already - in some cases you even want to put super in the middle somewhere!)The question asks mostly about , but don't forget that super can be used with any other method, tooIn rare circumstances, you might conditionally invoke a  call. You might check whether your  instance has this or that attribute, and base some logic around the result. Or, you might invoke  to explicitly "step over" a link and manually traverse the MRO for this section. Yes, if the default behaviour is not what you wanted, you can hijack the MRO! What all these diabolical ideas have in common is an understanding of the C3 linearization algorithm, how Python makes an MRO, and how super itself uses the MRO. Python's implementation was more or less lifted from another programming language, where super was named . Honestly  is a super-bad name in Python because it causes a common misconception amongst beginners that you're always invoking "up" to one of the parent classes, I wish they had chosen a better name.When defining an inheritance hierarchy, the interpreter can not know whether you wanted to reuse some other classes existing functionality or to replace it with an alternate implementation, or something else. Either decision could be a valid and practical design. If there was a hard and fast rule about when and how  should be invoked, it would not be left to the programmer to choose - the language would take the decision out of your hands and just do the right thing automatically. I hope that sufficiently explains that invoking super in  is not a simple yes/no question.If yes, how would you correctly initialize ?(Source for ,  etc in this revision of the question)For the purposes of answering this part, I will assume the  methods shown in the MCVE actually need to do some initialization (perhaps you could add placeholder comments in the question's MCVE code to that effect). Don't define an  at all if the only you do is call super with same arguments, there's no point. Don't define an  that's just , unless you intentionally mean to halt the MRO traversal there (in which case a comment is certainly warranted!).Firstly, before we discuss the , let me say that  looks like an incomplete or bad design. How do you pass the  argument to 's init? The  init value of  was hardcoded. It might be OK to hardcode (or otherwise automatically determine) foo's init value, but then you should probably be doing composition not inheritance.As for , it inherits  and .  looks intended for inheritance,  does not. That means you may have some work to do, as pointed out in super harmful. One way forward, as discussed in Raymond's blog, is writing adapters.Note that  has a , not  is a . This is not the only possible design choice. However, if you are inheriting like , then you're implying a  is a , and can be used in any place where a  would otherwise be - it's often easier to avoid violations of LSP by using composition.   should also cooperate by allowing :Maybe  is also out of your control and you have to adapt it too, so be it. The point is, this is a way to re-use code, by adjusting the interfaces so that the signatures are matching. Assuming everyone is cooperating well and consuming what they need, eventually  will proxy to .Since 99% of classes I've seen don't use  in their constructor, does that mean 99% of python classes are implemented incorrectly?No, because YAGNI. Do 99% of classes need to immediately support 100% general dependency-injection with all the bells and whistles, before they are useful? Are they broken if they don't? As an example, consider the  recipe given in the collections docs.  accepts  and , but doesn't proxy them in the super init call. If you wanted to use one of those arguments, well tough luck, you've got to override  and intercept them.  isn't defined cooperatively at all, really, some parent calls are hardcoded to  - and the  of anything next in line isn't invoked, so any MRO traversal would be stopped in its tracks there. If you accidentally defined it as  instead of  the metaclass bases would still be able to create a consistent MRO, but the class just wouldn't work at all as an ordered counter.In spite of all these shortcomings, the  recipe works as advertised, because the MRO is traversed as designed for the intended use-case. So, you don't even need to do cooperative inheritance 100% correctly in order to implement a dependency-injection. The moral of the story is that perfection is the enemy of progress (or, practicality beats purity). If you want to cram  into any crazy inheritance tree you can dream up, go ahead, but it is up to you to write the necessary scaffolding to allow that. As usual, Python will not prevent you to implement it in whatever hacky way is good enough to work.1You're always inheriting from object, whether you wrote it in the class declaration or not. Many open source codebases will inherit from object explicitly anyway in order to be cross-compatible with 2.7 runtimes.2This point is explained in greater detail, along with the subtle relationship between  and , in CPython sources here.
If  and  were never designed to be used as base classes of the same class, then  probably shouldn't exist. Correctly designing for multiple inheritance is very hard, much more than just calling . Even single inheritance is pretty tricky.If  and  are supposed to support creation of classes like , then  and  (and likely the classes around them) need some redesigning. Here's a start:You'll notice some changes. Let's go down the list.First, the  signatures now have a  in the middle. The  marks the beginning of keyword-only arguments:  and  are now keyword-only. It's nearly impossible to get positional arguments to work safely when different classes in a multiple inheritance graph take different arguments, so for safety, we require arguments by keyword. (Things would be different if multiple classes needed to use the same constructor arguments.)Second, the  signatures all take  now. This lets  accept keyword arguments it doesn't understand, like , and pass them on to down the line until they reach whatever class does understand them. By the time the parameters reach ,  should receive empty .Third,  doesn't have its own  any more. With  and  redesigned, it doesn't need an . The inherited  from  will do the right thing with 's MRO, passing  to .
When using  to call a superclass method, you would normally need the current class and the current instance as parameters:Now, the problem comes with the way Python handles walking the superclasses. If the  methods don't have matching signatures, then the calls will probably cause problems. From the linked example:The output is:This shows the order the constructors are called. Also note that the subclass constructors all have compatible signatures because they were written with each other in mind.


Answer URL
https://docs.python.org/3/glossary.html#term-method-resolution-order
https://docs.python.org/3/library/collections.html#ordereddict-examples-and-recipes
