Natural Text
I need to create a software that receives concurrently from web socket and pipe and it sends the messages on the other channel (it receives from the socket, creates a new thread and sends to the pipe. In the same way it receives from the pipe, creates a new thread and sends to the socket).I have a problem with multithreading, at the boot of the program I have to start the methods  and  but I can only start the . I tried removing all the code and keep only  and  but it only enters in the  of the .This program is called by a subprocess, the parent process communicates with it through pipes connected to stdout and stdin.UPDATE: I receive this exception with @Martijn Pieters code
You are not using the  correctly, and you really don't want to use that here. Instead, you need to set up consumers and producers to handle your socket and pipe with queues to send messages between them.for each connection type, create a coroutine that creates the connection, then passes that single connection to both a consumer and producer tasks (created with ) for that connection. Use  to run both tasks with , so you can cancel any that are still running when one of the two completes 'early' (e.g. has failed).Use a queue to pass messages from the consumer of one, to the producer of the other connection. and  are blocking streams, don't just read and write to them!  See https://gist.github.com/nathan-hoad/8966377 for a gist attempting to set up non-blocking STDIO streams, and this asyncio issue that asks for a non-blocking streams feature.Don't use a global socket connection, certainly not with two separate  statements. Your  method would actually close the socket because the  context manager exits when the first message is sent, and this then causes issues for the  code which assumes the socket remains open indefinitely. Don't use threading here! Your connections are entirely managed by asyncio, threading would stomp majorly on this.  instances should only be used with regular callables, not with coroutines.  states it takes a callable, passing in a coroutine with  or  will cause an exception to be raised as coroutines are not callables. You are probably not seeing an exception message as that exception is raised in the other thread.This is the reason your  coroutine fails; it certainly starts but attempts to send messages fail. When I run your code against a local mocked-up websocket server a warning is printed:When a coroutine is not awaited, the code in that coroutine is never executed. Wrapping the coroutine in one that prints out the exception to stderr () you get:Executors should only be used to integrate code that can't be converted to using coroutines; the executor manages that code to run parallel to the  tasks without interference. Care should be taken if that code wanted to interact with  tasks, always use  or  to call across the boundary. See the Concurrency and multithreading section.Here is an example of how I'd rewrite your code to use the consumer/producer pattern, with  based on the Nathan Hoad gist on the subject, plus a fallback for Windows where support for treating stdio as pipes is limited:This then starts with two tasks, one to manage the socket, the other to manage the STDIO pipe. Both each start 2 more tasks, for their consumer and producer. There are two queues to send the messages from the consumer of one and to the producer of the other.


Answer URL
https://docs.python.org/3/library/asyncio-task.html#asyncio.ensure_future
https://docs.python.org/3/library/asyncio-task.html#asyncio.wait
https://docs.python.org/3/library/asyncio-queue.html#asyncio.Queue
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor.submit
https://docs.python.org/3/library/asyncio-task.html#asyncio.run_coroutine_threadsafe
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.call_soon_threadsafe
https://docs.python.org/3/library/asyncio-dev.html#asyncio-multithreading
