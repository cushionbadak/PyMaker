Natural Text
I was trying to reverse a list in python. There are many methods out there and  seems to be a great one!But I'm curious how  is done? What's the time complexity of it?I searched through CPython repo in github, but I couldn't find any clue.My strategy of searching was that I searched the key word:  in CPython repo. Since there is  in the python syntax, i.e. , there may be  in the CPython source code so that  can refer to it and does the reversing. Does this make sense?
 is using indexing, or more accurate subscription syntax, and  is a slicing. Python 3 passes a  object to the subscription call for such cases, there is no  in the CPython source code as that's not how the language parser would threat that part. Slicing notation allows for defaults, an empty slot between in the  parts means that a default is picked, and  leaves  and  at defaults (represented by , and the step value is set to .All this just means you need to remember to separate syntax from operations. You could analyse the syntax by parsing it into an abstract syntax tree, or by disassembling the bytecode generated for it. When you generate an abstract syntax tree for  you'll see that the parser separates out the slice part:So the  syntax node operates on the name , passing in a slice. Producing a disassembly for this operation shows the bytecode used:Here the  bytecode operation takes the top-three elements from the stack (put there by  operations at indices 2, 4 and 6) to build a  object, which is then passed to the  object (next on the stack) with . That last bytecode is the  operation in the AST, and the bytecodes 2-8 are the  object in the AST.With the bytecode in hand, you can then head over to the Python bytecode evaluation loop to see what those bytecodes actually do. I'll skip , that's just creating a simple  object to hold the ,  and  values.Focusing on the  opcode, we find:So Python takes the top of the stack and puts that in  (that's the  object here), and puts the  reference into , and then calls . That's it. Next step then is to find . That's defined in , and the first thing it does is see if the object is a mapping type: is the object class ( does the same), and  is set when the mapping protocol is supported. If the mapping protocol is supported then  is called with  being the list object, and  being the list mapping support definition.Lists support this protocol, because only this protocol supports slice objects (it implements the sequence protocol as well, but that only accepts integers and a much older, more limited form of slicing with just two indices). We can see that  implements the protocol by looking for a  entry in the  type definition:which points to  which is defined asSo now we know where to find the actual implementation for the indexing operation; that implementation is handled by the  function, which uses  to check for  objects, and then just creates a new list object and copies the indices over:For a non-empty slice, with a step size of , the  branch is taken, where  creates a new, pre-allocated list to accommodate all slice indices, then a  loop that uses  is used to generate the index to copy into the new list. For your  slice, the  object is passed in a  object, and  uses the  and  functions to turn that into concrete , ,  and  values; for a negative  and  and  both set to  the end result is that  is set to ,  is set to , and  to .Thus, the effect on the above  loop is that all elements, starting at index  and iterating through to index , are copied in to the new list object.So reversing with  is a O(N) operation, for length N of the list (this includes pre-allocation, which takes up to O(N) time to allocate memory for the list references of the new list).


Answer URL
https://docs.python.org/3/reference/expressions.html#subscriptions
https://docs.python.org/3/reference/expressions.html#slicings
https://docs.python.org/3/library/ast.html#ast.parse
https://docs.python.org/3/library/dis.html#dis.dis
https://docs.python.org/3/library/dis.html#opcode-BUILD_SLICE
https://docs.python.org/3/c-api/typeobj.html#c.tp_as_mapping
https://docs.python.org/3/c-api/typeobj.html#mapping-structs
https://docs.python.org/3/c-api/typeobj.html#sequence-object-structures
