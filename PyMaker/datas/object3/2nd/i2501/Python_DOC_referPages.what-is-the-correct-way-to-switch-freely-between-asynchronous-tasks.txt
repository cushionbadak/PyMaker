Natural Text
Suppose I have some tasks running asynchronously. They may be totally independent, but I still want to set points where the taks will pause so they can run concurrently.What is the correct way to run the tasks concurrently? I am currently using , but I feel this is adding a lot of overhead. OutputIf we were using simple generators, an empty  would pause the flow of a task without any overhead, but empty  are not valid.What is the correct way to set such breakpoints without overhead?
As mentioned in the comments, normally asyncio coroutines suspend automatically on calls that would block or sleep in equivalent synchronous coffee. In your case the coroutine is CPU-bound, so awaiting blocking calls is not enough, it needs to occasionally relinquish control to the event loop to allow the rest of the system to run.Explicit yields are not uncommon in cooperative multitasking, and using  for that purpose will work as intended, it does carry a risk: sleep too often, and you're slowing down the computation by unnecessary switches; sleep too seldom, and you're hogging the event loop by spending too much time in a single coroutine.The solution provided by asyncio is to offload CPU-bound code to a thread pool using . Awaiting it will automatically suspend the coroutine until the CPU-intensive task is done, without any intermediate polling. For example:


Answer URL
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.run_in_executor
