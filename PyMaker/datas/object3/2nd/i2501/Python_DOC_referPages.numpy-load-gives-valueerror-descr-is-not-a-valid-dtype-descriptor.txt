Natural Text
I have written a  file in my C++ program using :following the example here.But when I try to load the file using  I get an errorBelow I paste the result of  for a  file containing a  of length 2 (should contain 46.950, 43.94):This issue has been posted to  github site as well. Just wondering if there is something I can do on the  side? Thanks.
If you want to fix this from the numpy side… Well, you probably don't want to modify numpy to understand non-standard descr strings, and I suspect that even if you treat that descr string as what it seems to be claiming you'd get garbage anyway.  But you can do a hacky workaround.If you open the binary file, it should start with something like this:… followed by some whitespace ending in a newline before the raw bytes.You can edit this carefully in a hex editor or text editor, or with Python code that opens the file in binary mode, reads it, does some normal string operations on the bytes, and writes it back out.In particular, the bit that looks like a Python dict repr really is exactly that, and the values mean exactly what you think they mean. Loading the file ends up trying to create an , and that's where the error comes from.If you just edit the  and  values, and make sure to keep the dict repr the same length (by padding with whitespace), that will give you something you can .So, what does  mean? Well, it's not a valid format as specified by  PEP 3118 and , but it does fit the pattern of numpy's extensions to that format. For example, in numpy, you can specify , meaning "same as  but 8 bytes". So, presumably, this means a 24-byte little-endian version of , which means  if compiled with C99,  if not, and is meant to be interpreted as  in Python.So, if numpy allowed this descr to specify a dtype, what it would mean is that every cell is 24 bytes, interpreted as a little-endian integer interpreted as a bool. Of course numpy doesn't know how to handle integers of any length but 1, 2, 4, or 8 bytes, and it expects bools to be 1 byte, so it isn't allowed. But you could read the same thing as 24 separate bools.How do you do that? Just change the  string to , and the  to , and now you've got a 30x20x24 boolean array, and if you slice , you get a 30x20 boolean array. Or, possibly,  would do that without needing to change the .The problem is, your C++ values are doubles, not bools.Hopefully, it's just written the doubles in little-endian format with 16 extra 0 bytes after each one. If so, just change the  to , change the  to , and see what you get. If the first  is your desired array, and the other two are all zeros, you're done; just slice it. (And maybe  it if you want to cut the memory use.)
You have a bug as per the format of  arguments on the example you provided.Instead of,You want,


Answer URL
https://docs.python.org/3/library/struct.html#format-characters
