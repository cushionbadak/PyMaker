Natural Text
So I'm trying to solve a challenge and have come across a dead end. My solution works when the list is small or medium but when it is over 50000. It just "time out" Wherea = 10 and b = [ 2, 4 ,6 ,8, 5 ]Solution sum any two element in b which matches a**Edit: ** Updated full code
 is a list, of potentially the same order of magnitude as . So, when you do  that's a linear search: it has to check every value in  to see if that value is . So, that's 50000 comparisons. And you're doing that once per loop in a linear walk over . So, your total time is quadratic: . (And  is also linear time.)If you replace  with a set, you can test it for membership (and remove from it) in constant time. So your total time drops from quadratic to linear, or  steps, which is a lot faster than 2 billion:If  needs to retain duplicate values, then it's a multiset, not a set, which means you can implement with :In your edited code, you’ve got another list that’s potentially of the same size, , and you’re sorting that list every time through the loop.Sorting takes log-linear time. Since you do it up to 50,000 times, that’s around , or around 30 billion steps.If you needed to keep  in order throughout the operation, you’d want to use a logarithmic data structure, like a binary search tree or a skiplist, so you could insert a new element in the right place in logarithmic time, which would mean just 800.000 steps.But you don’t need it in order until the end. So, much more simply, just move the  out of the loop and do it at the end.


Answer URL
https://docs.python.org/3/library/collections.html#collections.Counter
