Natural Text
I'm trying to learn how to create a bitcoin address by following this guide. If you scroll down, the first step, step 0, is to have a 256 bit (64 hex) long ECDSA key. I looked into Python Cryptography and am using the code below to test generating keys, but the saved key is always a long (180 characters) base 64 string. I've tried to read the docs and look at the functions I'm calling on Github but I don't see where I can specify how long the key should be. On line 216 of this file, it says that the key size for secp256k1 is 256 bits by default. Does that mean I'm exporting it wrong?Alternatively, I've considered generating a random hex string 64 characters long within the range of secp256k1,(  to  ), but I don't see where I can create a private key instance from a string or hex valuegentest.pyprivkey.pem
If you do not have an opaque private key (I think that'd involve specialist hardware, so not likely), you can get access to the private numbers information via the  method of the private key object, at which point you can access the value itself as an integer number; the  method produces a  object with a  attribute, a Python . Format that value as a 64-character zero-padded hex with :or encode it to bytes with  in big or little endian order (the integer hex output is in big-endian order):All this is a little convoluted because that's not normally needed to operate the  module, which works with OpenSSL or other cryptography backends via data structures that keep this information in library-friendly, not Python-friendly formats.And yes, the key you produce is 256 bits long, you can verify this by looking at the  attribute of the private key:The DER format could be another path, because that's machine-readable information. The traditional OpenSSL format makes it relatively easy to fish the info out of the X.690 ASN.1 structure manually, without installing a ASN.1 parser, but this is not exactly fool-proof. You'd look for the  byte sequence (4 is an octet string, 20 hex means it's 32 bytes long), and the value would be the second element in a sequence with the first an integer; this means the private key will always start at the 8th byte:I'm not 100% certain if those assertions hold however, and just accessing the private numbers is much simpler.


Answer URL
https://docs.python.org/3/library/functions.html#format
https://docs.python.org/3/library/functions.html#format
