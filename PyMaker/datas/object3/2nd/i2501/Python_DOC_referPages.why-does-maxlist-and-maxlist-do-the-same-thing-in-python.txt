Natural Text
See below example:The unpack operator did not have an effect here, I am trying to unpack a list and get a maximal value of matrix(two dim list). 
Given:Either  or  will give the same result because the individual sublist are being compared:In the first case, , you have a iterable list of lists returning each sublist one at a time. In the second case, , the elements (sublists) within that list of lists are unpacked into multiple individual arguments to .If you want the sublist that has the max value in it, use  as a key function:If you want the individual max value in a two dimensional matrix, you can flatten it:Or have three 's:
The documentation for  mentions:builtin maxmax(iterable, *[, key, default])max(arg1, arg2, *args[, key])...If one positional argument is provided, it should be an iterable. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned.In the first case you have one positional argument, in the second case you have multiple.To get what you want, which is the maximal entry in a matrix you could tryThis will pass one argument to the max function which is a generator that iterates over all the entries in the matrix - triggering the first case which  finds the maximum of an iterable.
You need to chain the lists into a single iterable to get this to work.  will let you do this:To unpack the list without  or other imports, use a nested comprehension: has two modes. If you pass in a single positional argument, e.g. , it will be interpreted as an iterable, and the maximum element of the iterable will be returned. If you pass in multiple positionnant arguments, e.g. , it will find the maximum of those elements. Since lists are comparable in Python, both versions are indeed equivalent.
You can put the max of each sublist into a list, and then call the max on that.
 should be your first port of call. means  with a single argument, , and the largest element of this is returned. means  with three arguments, , and the largest of these is returned.Clearly these are equivalent in your example.But in general you should use the former to find the max of an iterable. It's the correct use case. The latter will break for e.g. .For your specific problem, you need to flatten the list of lists into a single iterable and pass it to . Here is a quick way:
Its because  will have three lists then get's maximum list, so you can do , for integer lists:Also since from:As it says "With two or more arguments, return the largest argument.", so we have three arguments, so 3>2 is , then  is largest argument Or can use, :even tho kind of similar to Mad Physicist's answer, but i use  instead of unpacking:


Answer URL
https://docs.python.org/3/glossary.html#term-iterable
https://docs.python.org/3/library/itertools.html#itertools.chain
https://docs.python.org/3/library/functions.html#max
