Natural Text
I'm using Python 2.7 and have the following:I'd like create a 1-d list where the elements are ordered by position in sublist and then order of sublist.  So the correct output for the above list is:Here's my (incorrect) attempt:This flattens my 2-d list and gives me: The first half of this list is correct but the second isn't.I'd also like my function to be able to handle only 2 sublists.  For instance, if given:the correct output is:Any thoughts?Thanks!
You're attempting to flatten, and then reorder, which makes things a lot harder than reordering and then flattening.First, for your initial problem, that's just "unzip", as explained in the docs for :(In Python 2.7, you could just write  here instead of , but this way, the same demonstration works identically in both 2.x and 3.x.)And then, you already know how to flatten that:But things get a bit more complicated for your second case, where some of the lists may be empty (or maybe just shorter?).There's no function that's like  but skips over missing values. You can write one pretty easily. But instead… there is a function that's like  but fills in missing values with  (or anything else you prefer), . So, we can just use that, then filter out the  values as we flatten:(In Python 3, the function  is renamed .)It's worth noting that the  recipe, as covered by ShadowRanger's answer, is an even nicer solution to this problem, and even easier to use (just copy and paste it from the docs, or  and use it from there). It is a bit harder to understand—but it's worth taking the time to understand it (and asking for help if you get stuck).
i.e.
The  module's recipes section provides a  recipe that would do exactly what you want. It produces a generator, but your expected behavior would be seen with:Your original code's main issue is that it looped over , extending with . Problem is, this ends up duplicating elements from index 3 onwards (index 3 was already selected as the second element of the index 0 slice). There are lots of other small logic errors here, so it's much easier to reuse a recipe.This will be fairly performant, and generalize better than most hand-rolled solutions (it will round robin correctly even if the sublists are of uneven length, and it doesn't require second pass filtering or special handling of any kind to allow  as a value like  does).
If you are happy to use a 3rd party library, you can use NumPy and :For the case where you have one or more empty lists, you can use  to remove empty lists:Both solutions require non-empty sublists to contain the same number of items. If list conversion is necessary you can use, for example, .While these "black box" methods won't teach you much, they will be faster for large arrays than -based operations. See also What are the advantages of NumPy over regular Python lists?


Answer URL
https://docs.python.org/3/library/functions.html#zip
