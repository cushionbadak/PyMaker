Natural Text
This question already has an answer here:Why does the `is` operator behave differently in a script vs the REPL?                    2 answers                I want to preface this by saying that I know the difference between  and  one is for references and the other is for objects. I also know that python caches the integers in the range  at startup so they should work when comparing them with . However I have seen a strange behaviour.This is to be expected,  is  and  is , one is in the interval  and the other is not. However...Why does this return ? It is obviously a value WAY above any kind of caching interval and  clearly showed that  does actually not work on integers above . So... why does this happen?
CPython detects constant values in your code and re-uses them to save memory. These constants are stored on code objects, and can even be accessed from within python:Both operands of your  refer to this very same 999 integer. We can confirm this by dissecting the code with the  module:As you can see, the first two  instructions both load the constant with index , which is the 999 number.However, this only happens if the two numbers are compiled at the same time. If you create each number in a separate code object, they will no longer be identical:
Remember that Python is compiled.  The expression was compiled all at once and its literals are shared when possible.  Any operation, like your exponentiation, or adding and subtracting 1 from one side, will break the identity. (Python could in theory do constant folding and thereby extend the set of -identical expressions, but it doesnâ€™t bother.)Performing multiple compilations will also break this:


Answer URL
https://docs.python.org/3/library/dis.html
