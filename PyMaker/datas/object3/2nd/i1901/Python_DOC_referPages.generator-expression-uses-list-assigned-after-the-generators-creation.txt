Natural Text
I found this example and I can't understand why it works unpredictably?I supposed it must output  or .
The reason is that, at creation time, the generator  only evaluates  (which sometimes makes  predictable as well). But , ,  are evaluated at consumption time (at each iteration). Here, it uses the current binding of  from the enclosing scope when evaluating  ().You can for instance do:Without having declared  in advance. But, you have to make sure  exists when the generator is consumed.But you cannot do similarly:Upon request:You can observe similar (however not identical) patterns with a common generator function:The generator function does not execute any of its body ahead of consumption. Hence, even the  in the for-loop header is bound late. An even more disturbing example occurs where we "switch out"  during iteration:
From the docs on Generator expressions:Variables used in the generator expression are evaluated lazily when  the  method is called for the generator object (in the same  fashion as normal generators). However, the iterable expression in the  leftmost  clause is immediately evaluated, so that an error  produced by it will be emitted at the point where the generator  expression is defined, rather than at the point where the first value  is retrieved.So when you runonly the first  in the generator expression is evaluated.  and  will only be evaluated when you call . Since you make  point to another list  before consuming the generator you get the 'unexpected' result.
when you first create the array and assign the elements in it, elements of the array points to some memory location and generator keeps that location (not the array's) for its execution.but when you modify its elements of the array it gets changed but as '8' is common for both of them python does not reassign it and points to the same element after modification.Look the below example for better understandingOutput
Actually, it is not really crazy if you look more carefully.look at it will create a generator that looks through the array and will search if the count of already existing values is more than zero. so your generator only looks for ,  and , and when you change the values to another, the generator just looks for the previous values again not new ones. because it(generator) creates when array had them.so if you put thousands of values in the array it only looks for those three only.
The confusion, and so is the answer, lies in the line:If we simplify this line then it will become: Now, when generator is created then it keeps the reference of  object. So even if I will change the value of  to any other value (i.e. set it to a new array object), it will not affect the generator's copy of . Because only  is changing it's object reference. But  is checked dynamically. So if we change its value it will be reflected.You can see outputy from following code to understand it batter. See it working online here: Output: 


Answer URL
https://docs.python.org/3/reference/expressions.html#generator-expressions
https://docs.python.org/3/reference/expressions.html#generator.__next__
https://docs.python.org/3/reference/compound_stmts.html#for
