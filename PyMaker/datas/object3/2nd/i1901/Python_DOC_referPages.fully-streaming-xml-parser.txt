Natural Text
I'm trying to consume the Exchange GetAttachment webservice using requests, lxml and base64io. This service returns a base64-encoded file in a SOAP XML HTTP response. The file content is contained in a single line in a single XML element.  is just an example, but the problem is more general.I would like to stream the decoded file contents directly to disk without storing the entire contents of the attachment in-memory at any point, since an attachment could be several 100 MB.I have tried something like this:but  still stores a copy of the attachment as . Is there any way I can create a fully streaming XML parser that also streams the content of an element directly from the input stream?
Don't use  in this case. The  method can only issue element start and end events, so any text in an element is given to you when the closing XML tag has been found.Instead, use a SAX parser interface. This is a general standard for XML parsing libraries, to pass on parsed data to a content handler. The  callback is passed character data in chunks (assuming that the implementing XML library actually makes use of this possibility). This is a lower level API from the ElementTree API, and and the Python standard library already bundles the Expat parser to drive it.So the flow then becomes:wrap the incoming request stream in a  for easy decompression. Or, better still, set  and leave decompression to the requests library based on the content-encoding the server has set.Pass the  instance or raw stream to the  method of a parser created with . The parser then proceeds to read from the stream in chunks. By using  you first can enable features such as namespace handling (which ensures your code doesn't break if Exchange decides to alter the short prefixes used for each namespace).The content handler  method is called with chunks of XML data; check for the correct element start event, so you know when to expect base64 data. You can decode that base64 data in chunks of (a multiple of) 4 characters at a time, and write it to a file. I'd not use  here, just do your own chunking.A simple content handler could be:and you'd use it like this:This will parse the input XML in chunks of up to 64KB (the default  buffer size), so attachment data is decoded in at most 48KB blocks of raw data.I'd probably extend the content handler to take a target directory and then look for  elements to extract the filename, then use that to extract the data to the correct filename for each attachment found. You'd also want to verify that you are actually dealing with a  document, and handle error responses.


Answer URL
https://docs.python.org/3/library/xml.sax.html#module-xml.sax
https://docs.python.org/3/library/xml.sax.handler.html#xml.sax.handler.ContentHandler.characters
https://docs.python.org/3/library/xml.sax.reader.html#xml.sax.xmlreader.XMLReader.parse
https://docs.python.org/3/library/xml.sax.html#xml.sax.make_parser
