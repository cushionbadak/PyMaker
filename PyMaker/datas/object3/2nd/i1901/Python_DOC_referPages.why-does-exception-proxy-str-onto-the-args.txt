Natural Text
Why does printing an exception instance print the value of  instead of representing  directly? The docs call it a convenience but it's actually an inconvenience in practice.Can't tell the difference between *args and a tuple:Can't reliably discern type:And the lovely "invisible" exception:Which you'll inherit unless you specifically ask not to:This can be a real problem if you forget to log error instances specifically with  - a default string representation in a log file has irreversibly lost information.What's the rationale for such strange implementation of ?  Presumably if a user wanted to print  then they should just print ?
 could have been fixed in a backwards-incompatible manner with Python 3 to include at least the type of the exception, but perhaps no one noticed that it is a thing that should be fixed. The current implementation dates back to PEP 0352 which provides rationale:No restriction is placed upon what may be passed in for  for backwards-compatibility reasons. In practice, though, only a single string argument should be used. This keeps the string representation of the exception to be a useful message about the exception that is human-readable; this is why the  method special-cases on length-1  value. Including programmatic information (e.g., an error code number) should be stored as a separate attribute in a subclass.Of course Python itself breaks this principle of useful human-readable messages in many cases - for example stringification of a  is the key that was not found, which leads to debug messages likeThe reason why  is essentially  or  was originally backwards-compatibility with Python 1.0. In Python 1.0, the syntax for raising an exception, such as  would have been:Python retained backwards-compatibility with 1.0 up to 2.7, so that you can run most Python 1.0 programs unchanged in Python 2.7 (like you never would):Likewise, in Python 1.0 you would catch the  with which worked unchanged in Python 2.7.But the mechanism of how this worked internally had changed: In Python 1.0.1,  was a string with value... There were no exception classes at all, and you could only  a single argument, or a tuple, with a string as a discriminator:It would also be possible to give a tuple as an argument:And if you catch this "exception" in Python 1.0, what you get in  is:A tuple!Let's try the code in Python 2.7:The output looks identical, except for the type of the value; which was a  before and now an exception... Not only does the  delegate  to the  member, but it also supports indexing like a tuple does - and unpacking, iteration and so on:Python 2.7All these hacks for the purpose of keeping backwards-compatibility.The Python 2.7 behaviour comes from the  class that was introduced in PEP 0352; PEP 0352 was originally implemented in Python 2.5.In Python 3, the old syntax was removed - you could not raise exceptions with ; and the  could only use the  syntax. PEP 0352 discussed about dropping support for multiple arguments to :It was decided that it would be better to deprecate the  attribute in Python 2.6 (and remove it in Python 2.7 and Python 3.0) and consider a more long-term transition strategy in Python 3.0 to remove multiple-argument support in  in preference of accepting only a single argument. Thus the introduction of message and the original deprecation of  has been retracted.Seemingly this deprecation of  was forgotten, as it still does exist in Python 3.7 and is the only way to access the arguments given to many built-in exceptions. Likewise  no longer needs to delegate to the args, and could actually alias the  which gives nicer, unambiguous representation:but no one considered it.P.S. The  of an exception is useful - next time try printing your exception with  format:which results inbeing output.


Answer URL
https://docs.python.org/3/tutorial/errors.html#handling-exceptions
