Natural Text
I'm looking for a way to define properties conditionally in python.The idea was to define the property inside a try/except blockI don't know which properties are defined inside the parent object, hence I need something that builds properties conditionally. Any other solution is also welcome.[EDIT] Another attempt...however not only the attribute gets created anyway, but trying to accessing it throws an infinite recursion error[EDIT2] I have a method inside the parent that allows me to know which are the properties. For the sake of the example let's suppose I have a method  in the  C++ class which returns a list of the attributes names (strings) dynamically created by the Parent class.
You can think of python classes as namespace for code, with special binding. It's you can write pretty much anything in class body (think a loop, for extra craziness), and it will be executed on class import (in module import, really). The only problem you have is that you don't have easy access to parent classes in child class closure (without using metaclasses).So, if you need to make quick and dirty patch, you can actually make  like:First issue with this — parent class is hard-coded, if you change inheritance, you need to change implementation. This is actually bad design, but if you're hardly constraint, may it's ok for you.Bigger issue, tho, is that such interface is hell to use. In most cases, if you provide property/method, your users will expect class to have this. It's no fun to constantly use  or  just because some parent class somewhere missing method. And this part can't be fixed the way you have it now.So, main thing to consider — what's the situation, when parent class behaviour is unknown? If it's known for users on install time, consider providing two different child classes, no surprises inside.If it's known in runtime only, why even bother checking for this? Users will still useto catch your flappy interface, but the fun thing is missing parent getter will produce same exception, so simple will be used pretty much the same
First point: the  syntax is nothing magical, it's just syntactic sugar, so is actually just a convenient shortcut for:Second point: the  type is a generic (and rather simple - here again, no magic involved) implementation of the  protocol. Descriptors only "work" when resolved as class attributes, so setting properties as instance attributes will not work, period (looking them up will return the descriptor object itself, it will not invoke the descriptor's  and  methods).Third point: your code is not even setting the created properties as instance attributes (which wouldn't work anyway), they are just plain local names that only exist during the  method execution. None of this will solve your problem - you'd have to provide more context for someone to post a solution garanteed to work for your concrete use case (based on how this C++ parent class is actually implemented etc) - but at least you now know why your attempts fail.EDIT:I have a method inside the parent that allows me to know which are the properties. For the sake of the example let's suppose I have a method ListAttributes in the SomeOtherObj C++ class which returns a list of the attributes names (strings) dynamically created by the Parent class.If that's a classmethod or staticmethod, you can use a class decorator to create the properties (or, to reduce boilerplate, a custom descriptor):If  is an instance method then you can still use the  and   special methods:Beware:  is only invoked as a last resort if all other lookups failed so it's mostly harmless, but  is the default attribute setter, so you have to make sure you use it wisely.
How about that:You can simply patch class by setting a property in a runtime


Answer URL
https://docs.python.org/3/reference/datamodel.html#implementing-descriptors
