Natural Text
The Python docs mentions the following about names being aliases to objects:Objects have individuality, and multiple names (in multiple scopes) can be bound to the same object. This is known as aliasing in other languages. This is usually not appreciated on a first glance at Python, and can be safely ignored when dealing with immutable basic types (numbers, strings, tuples). However, aliasing has a possibly surprising effect on the semantics of Python code involving mutable objects such as lists, dictionaries, and most other types. This is usually used to the benefit of the program, since aliases behave like pointers in some respects. For example, passing an object is cheap since only a pointer is passed by the implementation; and if a function modifies an object passed as an argument, the caller will see the change â€” this eliminates the need for two different argument passing mechanisms as in Pascal.In some other high-level languages it is often the case that primitive types are special-cased, and are copied instead of referenced, for performance reasons. For example, in Java:The code above will copy the value , instead of the pointer to the value . In this case,  and  will likely occupy different locations in memory. Due to special-casing on  to test for equality instead of identity for primitive types only, I don't believe this behaviour can be introspected in normal code, however.On the other hand, limited testing with types such as  and  in Python 3 shows that indeed, the pointers are copied rather than the values, as specified in the documentation:This is a very nice property that makes the language very consistent, as there is no special-casing for primitive types. All assignments reassign a name to another object. However, for performance reasons, might it be possible for a Python interpreter to special-case types like ?Hence, my question is: Is this property for primitive types guaranteed? In other words, is it always true that after , the comparison  will be , no matter the Python interpreter used?
Yes, it is specified in the documentation:If the target is an identifier (name):If the name does not occur in a global statement in the current code block: the name is bound to the object in the current local namespace.Otherwise: the name is bound to the object in the current global namespace.(In Python 3 there is an additional case related to , but the rule is the same; the only difference is what namespace the binding takes place in.)Note, crucially, that this only applies when assigning to a bare name.  If the assignment is something like  or , all bets are off and just about anything can happen.
 make the names  and  reference the exact same object. So yes, in Python,  will then always be True.
Python doesn't use primitive types in the same way as Java. As you see here,  is a class. Instances of this class are objects with all that means. It just so happens that this is a builtin class rather than one defined in a  file somewhere.Think about the Java behavior of  vs .When you do  you are setting  to a reference to the same object that  refers to, so it doesn't copy the value.As far as special casing, CPython does make "small" integers (from -5 to 255) into singletons so they do not have to be recreated, but this is an implementation detail.
All variables and expressions in Python are references (semantically equivalent to pointers to objects). If you are familiar with a C++, it is like the following:Assigning one variable to another will copy the value, a pointer. After the assignment the two pointers will always point to the same object.


Answer URL
https://docs.python.org/3/tutorial/classes.html#a-word-about-names-and-objects
