Natural Text
That prints out:So this link returns streaming data in JSON format, How do I record the response in Python?
You shouldn't be doing this. I'll explain why later; first I'll show how to make it work. You have three problems, and you have to fix them all.As the  manpage says:(HTTP/FTP/FILE) Fetch the HTTP-header only! HTTP-servers feature the command HEAD which this uses to get nothing but the header of a document. When used on an FTP or FILE file, curl displays the file size and last modification time only.So you're explicitly telling curl to ask the server not to send you the response body. To fix this, don't send .As the  docs say:On Unix, the return value is the exit status of the process encoded in the format specified for …On Windows, the return value is that returned by the system shell after running command.In other words, all you get back is an exit code—a small integer. The output just gets printed out; there's no way for you to record it. To actually record the text, look at the next paragraph:The  module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using this function. See the Replacing Older Functions with the  Module section in the  documentation for some helpful recipes.Follow that link, and it shows you exactly how to do get the output in the first example: use the  function. Note that you will have to convert that command line into a list of arguments. (You could use  instead, but there's no good reason to; all the shell will do for you here is get in the way.)Finally, by default,  outputs the body to stdout—which is great, that's what you're capturing—but it also outputs stuff to stderr, which may include a progress meter, the headers, etc., depending on various circumstances. Unless you want to capture this information, or just dump it out for your users to see, you want to tell curl not to do this. See the manpage linked above for details:So, that works. Why do you not want to do things this way?Because there's a much better way to do what you want: the  module (or, if you're on Python 2.x, ):How is this better?Portable: works on any system that can run Python, not just systems with  installed.Simpler: no need to work out the right arguments to an external program, then figure out how to pass them from Python.Better error handling: you can check the HTTP status code, instead of trying to parse whatever  gives you.More flexible: if you want to, e.g., get both the headers and data separately, you can get them separately, without having to figure out how to get curl to dump the headers to a separate pipe and  it from Python and read from the two pipes without deadlocking.Easier to debug.


Answer URL
https://docs.python.org/3/library/os.html#os.system
https://docs.python.org/3/library/subprocess.html#module-subprocess
https://docs.python.org/3/library/subprocess.html#subprocess-replacements
https://docs.python.org/3/library/urllib.request.html#module-urllib.request
