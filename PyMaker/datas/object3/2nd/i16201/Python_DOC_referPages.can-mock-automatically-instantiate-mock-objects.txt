Natural Text
I'm writing tests for the class  which instantiates a class of type , which in turn instantiates a class of type . The method I'm testing in this example is  which tests connectivity with the remote service, by issuing a  request to a  resource in the remote API.I'm currently patching these objects to be mocks using the following code, but it still looks a bit verbose to me.Do I really have to assign a  mock instance to the property of another mock instance manually? Perhaps there is some feature in the  package that can do this for me?UPDATEI've split up the test in two and also attached the relevant code from the  that is under test. Here is the  class:And here is the test code:Currently the test passes if I run it. Commenting out the line we're discussing gives me the following failure in :
The line:assigns a new empty  instance to . However, accessing  without that assignment already does this because  is itself a  object; the line is entirely redundant:As such, the following would suffice:Of course, if the code-under-test is not using  to obtain the resource, then the above code would not achieve its goal; but then you won't need to alter  either.The thing to remember here is that you replaced ; what that class original does is no longer of concern to you. All you need to do is manage the expectation of the code using ; if it uses  and uses attributes or methods on that object, mock those out. If  is not directly used by the code-under-test, leave it out of your tests too.Your added code shows that you are mocking the wrong object however. You mocked  correctly, but theh  object in the CUT is not a mock. See the Where to patch section of the  documentation. Your CUT uses a global name ; it does not reference . Mock that global:or you could just have mocked out just the  resource; evidently that is what your unmocked  class uses, after all:


Answer URL
https://docs.python.org/3/library/unittest.mock.html#where-to-patch
