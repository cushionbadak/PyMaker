Natural Text
I defined the function  asBut  returns a generator no matter what  is:And if I iterate over the returned object:It looks like  returns a generator which has been iterated over. What's the reason? Thank you.
A function containing a  statement always returns a generator object.Only when you iterate over that generator object will the code in the function be executed. Until that time, no code in the function is executed and Python cannot know that you'll just return.Note that using  in a generator function has different semantics than in a regular function;  in this case simply is seen as 'exit the generator here'; the return value is discarded as a generator can only produce values via  expressions.It looks like you want to use  instead: requires Python 3.3 or up.See the  expression documentation:Using a  expression in a function’s body causes that function to be a generator.When a generator function is called, it returns an iterator known as a generator. That generator then controls the execution of a generator function. The execution starts when one of the generator’s methods is called. At that time, the execution proceeds to the first  expression, where it is suspended again, returning the value of expression_list to the generator’s caller.Iteration over a generator calls the  method, triggering execution.If you wanted to return a generator some of the time, then don't use  in this function. You'd produce the generator by other means; using a separate function for example, or by using a generator expression perhaps:Now no  is used in  and it will no longer produce a generator object directly. Instead, the generator expression  produces it, but only conditionally.
You can work around this by using a nested function that actually uses :As Martijn points out, any function containing a  will always return a generator object, so if in some cases you want the body of  to actually be executed when  is called, rather than only be executed when iterated over, you have to use this approach.The standard library instance method  from / uses this to ensure futures are submitted as soon as  is called, rather than only when you try to actually retrieve results from it, for example:


Answer URL
https://docs.python.org/3/reference/expressions.html#yield-expressions
https://docs.python.org/3/reference/expressions.html#generator.__next__
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor.map
