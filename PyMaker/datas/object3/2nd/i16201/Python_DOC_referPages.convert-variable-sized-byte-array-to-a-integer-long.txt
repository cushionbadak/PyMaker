Natural Text
How can I convert a (big endian) variable-sized binary byte array to an (unsigned) integer/long? As an example, , which represents 4404Right now, I'm using Which is small and somewhat readable, but probably not very efficient. Is there a better (more obvious) way?
Python doesn't traditionally have much use for "numbers in big-endian C layout" that are too big for C. (If you're dealing with 2-byte, 4-byte, or 8-byte numbers, then  is the answer.)But enough people got sick of there not being one obvious way to do this that Python 3.2 added a method  that does exactly what you want:Unfortunately, if you're using an older version of Python, you don't have this. So, what options do you have? (Besides the obvious one: update to 3.2, or, better, 3.4…)First, there's your code. I think  is a better way to spell it than , because "encode" has always seemed a little weird for a method on byte strings (as opposed to Unicode strings), and it's in fact been banished in Python 3. But otherwise, it seems pretty readable and obvious to me. And it should be pretty fast—yes, it has to create an intermediate string, but it's doing all the looping and arithmetic in C (at least in CPython), which is generally an order of magnitude or two faster than in Python. Unless your  is so big that allocating the string will itself be costly, I wouldn't worry about performance here.Alternatively, you could do it in a loop. But that's going to be more verbose and, at least in CPython, a lot slower.You could try to eliminate the explicit loop for an implicit one, but the obvious function to do that is , which is considered un-Pythonic by part of the community—and of course it's going to require calling a function for each byte.You could unroll the loop or  by breaking it into chunks of 8 bytes and looping over , or by just doing a big  and looping over that, but that makes it a lot less readable and probably not that much faster.You could use NumPy… but if you're going bigger than either 64 or maybe 128 bits, it's going to end up converting everything to Python objects anyway.So, I think your answer is the best option.Here are some timings comparing it to the most obvious manual conversion:For comparison in Python 3.4:So, your method is still pretty fast…
Function struct.unpack(...) does what you need.


Answer URL
https://docs.python.org/3/library/stdtypes.html#int.from_bytes
