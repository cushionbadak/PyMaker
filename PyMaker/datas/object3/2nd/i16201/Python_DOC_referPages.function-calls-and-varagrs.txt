Natural Text
Why does the former call work but the latter not? I mean shouldn't the first return an error too? Doesn't * simply unpack an iterable?
As the docs say:If the syntax  appears in the function call,  must evaluate to an iterable. Elements from this iterable are treated as if they were additional positional arguments; if there are positional arguments x1, ..., xN, and expression evaluates to a sequence y1, ..., yM, this is equivalent to a call with M+N positional arguments x1, ..., xN, y1, ..., yM.A consequence of this is that although the  syntax may appear after some keyword arguments, it is processed before the keyword argumentsâ€¦At lot of people are confused by the fact that function definitions have a similar, sometimes misleadingly-similar, syntax.In a function definition, a variable-argument parameter (like ) comes before any the keyword-only parameters. Of course being keyword-only and having a default value are completely independent, but it's pretty common that the keyword-only parameters all have default values. So, the syntax often looks like . Which can lead you to expect  to be the matching call syntax, even though it isn't. Just remember that  is perfectly legal, and it still makes  a positional-or-keyword parameter and  a keyword-only parameter.If you're interested how this works specifically in CPython (although other implementations are probably all pretty similar):The function call itself gets compiled to pass the value of the  on the stack, still separate from the normal arguments. It's inside the interpreter, in the function-call evaluator, where the stack frame for the function body's execution gets built, where that value is exploded into extra arguments.It may help to see how CPython parses and compiles this code:Even if you don't understand ASTs, you should be able to see that the  is still separate at parse time, stored in a field named .This gets compiled to this bytecode:You probably don't understand all that gibberish, but you can see that the tuple  is being loaded onto the stack at offset 12, and it's still on the stack when the opcode  gets executed. And you can look that opcode up in the docs, where it says:Calls a function.  is interpreted as in . The top element on the stack contains the keyword arguments dictionary, followed by the variable-arguments tuple, followed by explicit keyword and positional arguments.So, the "variable-arguments tuple" is still separate.
Positional parameters must always appear before named and unpacked parameters.In the expression:The  is a positional parameter while  is a named parameter.  It is invalid written this way.  You have to move the named parameter after all positional parameters.On the other hand, the expression:is valid.   is the only positional parameter here.   is a named parameter and  and  are unpacked.  It's all valid as long as the positional parameter comes first.


Answer URL
https://docs.python.org/3/reference/expressions.html#calls
https://docs.python.org/3/library/dis.html#opcode-CALL_FUNCTION_VAR_KW
