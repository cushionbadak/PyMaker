Natural Text
Is there a method to wait for a result from an SSL socket before continuing?for example this is my current code :but is there a way to pause the program until something is sent back from that stream or do I just simply carry on using the code above which should do this as connected willn't be assigned a value until somthing is received? create stream is a section of code i have written which creates a stream to send data through the tor network,and recvCell is below, this gets a reply and decodes it so it can be read :
The code you provided is not complete so we can't figure out the entire design, but the  module uses , whose  method can:(socket in blocking mode): Blocks the execution until some data is ready.(socket in non-blocking mode): Throws an error if no data is availableThe sockets are created in blocking mode as default (the blocking setting can be changed using setblocking). So a call to  should block until some data is ready on the SSL socket.
To answer your literal question:is there a way to pause the program until something is sent back from that streamYes, the  module (or, in 3.4+, the higher-level  module) provides ways to pause until something has been sent back, after which you know you can receive it without blocking.But there's a much simpler way to do this, and as far as I can tell you're already doing it:do I just simply carry on using the code above which should do this as connected willn't be assigned a value until somthing is received?If  isn't assigned a value until something is received, then you're already pausing the program until something is sent back from the stream. Unless you switch a socket to non-blocking mode,  automatically does that. So… I don't know what your problem is, but if you're looking for validation that your code is correct, then yes, it is—at least in this aspect.There is at least one other problem, however. There is absolutely no guarantee that  will block until 509 bytes come in. It will block until any packet comes in. Which could be less than 509 bytes. Which means your code will read the first, say, 300 bytes of a message and treat it as a whole message, and then the next time you try to  you'll get the remaining 209 bytes of that message (or maybe those 209 bytes plus the first 140 of the next message, or whatever) and confuse your code badly. You should always loop and accumulate until you get the full data. The easiest way to do that is to write a function like this:


Answer URL
https://docs.python.org/3/library/select.html
https://docs.python.org/3/library/selectors.html
