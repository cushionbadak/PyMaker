Natural Text
I want to define constraint specification language based on Python. For example:Here  is a class describing a variable that can assume any integer value, and  is a class to represent constraints. To implement this I can just overload operator  by defining method  for class .Suppose now that I want to state that . I would like to write something like:Unfortunately, I cannot do this because  cannot be overloaded in Python. Using  instead of  is not an option because of its precedence and because a bit-wise  has its proper meaning in the constraint language, e.g., .What solution could you suggest?As a workaround I am using quoted expressions for constraints:But this requires implementing constraint language parsing that I would prefer to avoid, and, more importantly, the syntactical correctness may be checked only when the parsing is actually done. Thus the user may spend several hours to discover that there is a syntax error in a constraint definition.Another option I considered is using kind of a lambda expression for constraint definition:but I cannot get access to the parse tree of the lambda-object.
Using ,  and  is actually a pretty good option. You simply need to document that parentheses are required because of the different operator precedence.SQLAlchemy does it like this for example. For people who do not like this kind of abuse of the bitwise operators, it also provides , , and  functions doing the same thing as their operator counterparts. However, you are forced to prefix notation () which is not as readable as infix notation ().The  approach is a good idea, too (besides the ugliness introduced by the  itself). Unfortunately the AST is indeed not available without source code - but wait, you do have the source code, just not attached to the function object!Imagine this code:That will give you this AST:The disadvantage is that you get the whole source line - but you can easily walk the AST until you reach your lambda expression (the first one inside the call to your evaluation function) and then you can work on just the relevant part.To avoid having to evaluate it on your own, you can now simply rewrite the AST to use the bitwise operators instead and then compile the new AST to a function which will then make use of the overloadable operators.Let's have a look at the AST of :As you can see, the difference is pretty minor. You just need to rewrite your AST's BoolOp to use a BinOp!The AST of  would look like this:Also not too hard to rewrite to.
Are you familiar with the Infix pattern (hack)?Here is how you can apply it:Unfortunately you cannot specify operator precedence when using  and, as you can already notice, this leads to excessive bracketing.All things considered, I doubt that you will find a solutions that exactly mimics the behavior of  and  and has no drawbacks.
For what it worth, ,  and  cannot be overloaded in Python as they are not really operators. They are merely control flow operators for "short-circuit" expression evaluation.That being said, as a Python developer, I find the use of  to implements a "logical and" quite confusing and probably error prone.Is your "constraint language" necessary embedded in Python? If so, maybe you should consider pre-processing you files Python+constraint files.Considering "parsing" the constraint language, some option that come to my mind:take a look at PLY. That might allow you to define a complete language with its own grammar. Maybe not the best option for embedded languages.An other option would be to use ast. To quote the doc: "The  module helps Python applications to process trees of the Python abstract syntax grammar." That would allow you to parse a Python-like syntax. But providing your own semantic (take a look at ast.NodeTransformer)


Answer URL
https://docs.python.org/3/reference/import.html#import-hooks
