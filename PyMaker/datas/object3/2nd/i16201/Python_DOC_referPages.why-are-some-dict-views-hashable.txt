Natural Text
In python 3, the , , and  methods provide dynamic views of their respective elements.  These were backported to python 2.7 and are available there as , , and .  I'm referring to them interchangeably here.Is there any reasonable explanation for this:I found this rather surprising.The python docs glossary on "hashable" says:An object is hashable if it has a hash value which never changes  during its lifetime (it needs a  method), and can be  compared to other objects (it needs an  method). Hashable  objects which compare equal must have the same hash value.Okay, the first part actually checks out; it doesn't appear that the hash of a  object will change over its lifetime - even though its underlying values certainly can.But the part about ... well, it doesn't have one of those, actually.So... yeah.  Can someone make any sense of this?  Is there a reason for this asymmetry that of the three  methods, only  objects are hashable?
I believe this occurs because  and  provide custom rich comparison functions, but  does not. Here are the definitions of each view type:Notice that  is defined as  for  and , but not . Now, the documentation for  says this:A class that overrides  and does not define  will have its  implicitly set to None....If a class that overrides  needs to retain the implementation  of  from a parent class, the interpreter must be told this  explicitly by setting .If a class that does not override  wishes to suppress hash  support, it should include  in the class definition.`So, because / are overriding  (by providing a  function), they would need to explicitly define  as being equal to the parent's to retain an implementation for it. Because  doesn't override , it inherits the  from , because  and  get inherited from the parent if they're both NULL:This field is inherited by subtypes together with tp_richcompare: a  subtype inherits both of tp_richcompare and tp_hash, when the  subtypeâ€™s tp_richcompare and tp_hash are both NULL.The fact that the impelmentation for  isn't preventing this automatic inheritence would probably be considered a bug.


Answer URL
https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects
https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_hash
