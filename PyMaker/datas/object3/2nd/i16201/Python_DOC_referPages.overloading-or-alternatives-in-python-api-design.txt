Natural Text
I have a large existing program library that currently has a .NET binding, and I'm thinking about writing a Python binding. The existing API makes extensive use of signature-based overloading. So, I have a large collection of static functions like:There are a few cases where the same inputs must be used in different ways, so signature-based overloading doesn't work, and I have to use different function names, instead. For exampleI suppose this second technique (using different function names) could be used everywhere in the Python API. So, I would haveBut the names look unpleasantly verbose (I don't like abbreviations), and inventing all of them will be quite a challenge, because the library has thousands of functions.Low Priorities:Effort (on my part) -- I don't care if I have to write a lot of code.PerformanceHigh Priorities:Ease of use/understanding for callers (many will be programming newbies).Easy for me to write good documentation.Simplicity -- avoid the need for advanced concepts in caller's code.  I'm sure I'm not the first person who ever wished for signature-based overloading in Python. What work-arounds do people typically use?
One option is to exclusively keyword arguments in the constructor, and include logic to figure out what should be used:You can also use classmethods to make things easier for the users of the API:Usage:
There are a couple of options.You can have one constructor that accepts and arbitrary number of arguments (with  and/or  syntaxes) and does different things depending on the number and type the arguments have.Or, you can write secondary constructors as class methods. These are known as "factory" methods. If you have multiple constructors that take the same number of objects of the same classes (as in your  example), this is probably your only option.If you don't mind overriding  rather than , you can even have both, with the  method handling one form of arguments by itself and referring other kinds to the factory methods for regularizing. Here's an example of what that might look like, including doc strings for the multiple signatures to :
You could use a dictionary, like soAnd the initializer would say
One way would be to just write code parse the args yourself. Then you wouldn't have to change the API at all. You could even write a decorator so it'd be reusable:How it appears to API users:This is the best part. To an API user, they just see this:They can just call  like you showed in your question.How it works:The whole idea is to hide the signature-matching from the API. This is accomplished by using a decorator to create a signature, basically a tuple containing the types of each of the arguments, and passing that as the first argument to the functions.overload:When you decorate a function with ,  is called with that function as an argument. Whatever is returned (in this case ) replaces the decorated function.  ensures that the new function has the same name, docstring, etc.Overload is a fairly simple decorator. All it does is make a tuple of the types of each argument and pass that tuple as the first argument to the decorated function.Circle take 1:This is the simplest approach. At the beginning of the function, just test the signature against all valid ones. Circle take 2:This is a little more fancy. The benefit is that you can define all of your valid signatures together in one place. The return statement uses a generator to filter the matching valid signature from the dictionary, and  just gets the first one. Since that entire statement returns a function, you can just stick a  afterwards to call it. If none of the valid signatures match,  raises a .All in all, this function just returns the result of the function with the matching signature.final notes:One thing you see a lot in this bit of code is the  construct. When used in a function definition, it just stores all the arguments in a list named "args". Elsewhere, it expands a list named  so that each item becomes an argument to a function (e.g. ).I don't think it's terribly uncommon to do odd things like this to present clean APIs in Python.
There are a number of modules in PyPI that can help you with signature based overloading and dispatch: multipledispatch, multimethods, Dispatching - none of which I have real experience with, but  looks like what you want and it's well documented. Using your circle example:It's also possible to decorate instance methods, so you can provide multiple implementations of , which is quite nice. If you were implementing any actual behaviour within the class, e.g. , you would need some logic to work out what values are available with to draw the circle (centre and radius, 3 points, etc). But as this is just to provide a set of bindings, you probably only need to call the correct native code function and pass on the parameters  :


Answer URL
https://docs.python.org/3/library/functools.html#functools.singledispatch
