Natural Text
I have to implement a search function which will be fault tolerant.Currently, I have the following situation:Models:Query:Example data:Illustrations:Illustration has Tags:Tags:When I run the query with , the similarity for  should be higher than for , as it is a perfect match.Unfortunately, both tags are considered together somehow.Currently, it looks like it's concatenating the tags in a single string and then checks for similarity:But I would like to adjust it in a way that I will get the highest similarity between an  instance name and its tags:Edit1: I'm trying to query all Illustration, where either the title or one of the tags has a similarity bigger than X.Edit2: Additional example:fulltext = 'Animal'TrigramSimilarity('Animal Brown', fulltext) => x  TrigramSimilarity('Animals', fulltext) => yWhere x < yBut what I want is actuallyTrigramSimilarity(Max(['Animal', 'Brown]), fulltext) => x (Similarity  to Animal) TrigramSimilarity('Animals', fulltext) => yWhere x > y
You cannot break up the  (at least I don't know a way). From your examples, I can assume 2 possible solutions (1st solution is not strictly using Django):Not everything needs to pass strictly through DjangoWe have Python powers, so let's use them:Let us compose the query first:Then to create your queryset:Decode the above:We are checking every  and  name against our  and we are composing a query with every name that it's similarity passes the . method compares sequences and returns a ratio  where 0 indicates No-Match and 1 indicates Perfect-Match. Check this answer for another usage example: Find the similarity percent between two strings (Note: There are other strings comparing modules as well, find one that suits you) Django objects, allow the creation of complex queries (more on the linked docs).With the  and  we transform a list of  objects to an OR separated query argument: Note:You need to define an acceptable .As you can imagine this will be a bit slow but it is to be expected when you need to do a "fuzzy" search. (The Django Way:) Use a query with a high similarity threshold and order the queryset by this similarity rate:  Decode the above: accepts an aggregation (not to be confused with the Django method ) of expressions or of model fields and returns the max item. returns a rate between 0 and 1. The closer the rate is to 1, the more similar the  is to ., will filter similarities lower than the .. You can set the threshold to  which is pretty high (consider that the default is ). You can play around with that to tune your performance.Finally, order the queryset by the  rate in a descending order.
I solved it using only TrigramSimilarity, Max and Greatest.I populated some data as in your question:I imported all necessary functions and initialized :Then I executed the query:With this results:This is the SQL query exceuted from PostgreSQL:You can use the  annotation to filter or order your results.


Answer URL
https://docs.python.org/3/library/difflib.html#difflib.SequenceMatcher
https://docs.python.org/3/library/operator.html#module-operator
