Natural Text
This question already has an answer here:How is returning the output of a function different from printing it?                    6 answers                So I'm working my way through Wentworth et al How to Think Like a Computer Scientist a Python 3 guidebook to try and teach myself more about programming. While it's a fantastic resource, it has very little to say about style and "best practice" for writing in Python 3. I'm working through one of practice questions in the chapter on conditionals that asks me to write a function that returns a string 'grade' when an int or float 'mark' is inputted. My direct question here is about the repetition in the conditionals in the function and the value the function returns. Is it possible to use a loop instead somehow to make it more concise instead of just writing  statements over and over? Also, the main  function is returning a null  value; How I can make this function "fruitful" and not print  when it's called? Here's what I've written:
Rather than using  in the  function, return your result and have the caller print the resulting mark. The  function should only be used to return a grade:Note that  is responsible for printing now; that's the best place for it, as that same function also is responsible for printing the question on the screen and taking user input. Like your version,  returns  (because that's the default), and I removed the  from around the  call to avoid printing that return value. There's no point in printing it,  will never return anything other than .You can also remove half of your tests; only the first matching  or  branch is picked, the rest are skipped. So you can remove tests for what a previous branch already covered:If the first  test did not match, then there is no need to test for  anymore, because we have tested for the inverse. Testing for  is enough for the next grade. If that fails to match, we know the mark is definitely smaller than 70, so the next test only needs to test if it is larger than , etc.Now a pattern emerges that you could build a loop on. You test for a lower bound, and if it matches, you know which index to return. Build a separate list to store the lower bounds:I used the  function here to pair up the grade names and the bounds, pairwise. You could also have used the  function to generate an index along with each grade name, or a  loop, but I find  to work cleaner here.Next, we can start being clever with the algorithm. The above still tests each grade, from high to low, one by one. That can take up to N steps, for N grades. That's a linear algorithm, it takes as many steps as there are inputs.But the grades are sorted, so we could use bisection here; jump to the middle and see if the mark is lower or higher than the current bound. Then pick either half, and test again, until you find a best match. Bisection takes at most Log(N) steps. Python has a very fast implementation included; it assumes values in increasing order, so reverse the grades and boundaries: bisects into  to find the 'insertion point' for , which will be to the right of the same value in the list. So  would be inserted at ,  at  (as it is equal or higher),  at  and anything at  or higher at . And those happen to be the exact indices for the matching grades.
Two very simple things:You never return anything.  By default, Python is going to return .  You can fix this by adding a return statement in addition to or in lieu of your print statement.You can simplify your expression.  Python accepts ranges of expressions analogous to mathematical ranges (e.g. 0 <= x <= 100 is valid Python).  You can see an example of that above; I leave cleaning it up and making it more readable as an exercise for the reader.
Below are two pythonic solutions. As a learning problem, there are a few interesting bits to understand: dictionaries with tuple keys, iterating dictionary items, generator expressions, class inheritance.This isn't the only way to structure your code. Another way is to set a sequence of boundary scores, as in @MartijnPeter's answer. However, these are readable and reasonably performant solutions.In both instances note the importance of the  statement, which is missing in your code. By default, Python returns .FunctionalObject-orientedThe beauty of python is it marries, to some degree, object-oriented and functional programming. Consider the below solution. Efficiency will be similar to the above, but it introduces a construct, subclass  inheriting from , which can be reused easily in other scenarios.
First : why does your function return None ?Because you actually use print, which echoes the text to the user. What you want to use instead is return, which will leave the function and basically say "that's what I have calculated".As there is no value returned, python automatically returns None. If you were in a stricter language, you would probably have an error.Therefore, you should do this :Second : how to improve your code ?The first thing to see is that if the first condition is valid () then, in all the elifs, mark can't be more (or equal) to 75, which mean that you can, in this case, get rid of every lower than condition in every elif.Third : how to improve your code (2) ?Now, as I have told you, return leaves the function. So you can use this to remove the elifs as such : The issue now is that you have the same code repeated a lot of times. This mean that you can break it into a loop. I would recommend using an array of bounds as such :I hope I have explained this clearly, if you have any questions, just ask them below.
Slightly different approach to Makoto. Again, just for a snippet.


Answer URL
https://docs.python.org/3/library/functions.html#zip
https://docs.python.org/3/library/functions.html#enumerate
https://docs.python.org/3/library/bisect.html
https://docs.python.org/3/library/bisect.html#other-examples
