Natural Text
I have designed a piece of python code which essentially works as a microservice in the larger scheme of things. There are two tasks that I have scheduled on the loop and two tasks that I set up to be run in executor.The strange part is the code runs well. Does everything I expect. But when I end it with KeyboardInterrupt (Ctrl+C) I get to see error and exception. Which makes me feel I am definitely misusing the asyncio patterns here. I will try to provide a brief overview of the code without going into the lengthy details right away:Also, I tried experimenting with another approach in the Protoype.run() method: Regardless, when I try to end the running script with Ctrl+C,it doesn't exit at the first attempt. I have to press it twice. And this is what comes up:Where am I going wrong?
You scheduled two infinite tasks in the executor. Thes tasks are blocking exiting.The default task executor puts those in a thread managed by a queue, and when exiting, the queue is signalled to stop executing tasks. However, if your task never returns, the queue manager never can check for this state.You can avoid this state by not running an infinite loop. Instead, reschedule your task each time you reach the end, and do not block on getting messages:You still run this function in the executor to kick it off:Do the same for  and make sure you avoid using blocking calls to the , so use .You could even use a decorator for this:and use this decorator on your inner function, where you have access to your instance attribute referencing the loop:A quick demo of the latter:


Answer URL
https://docs.python.org/3/library/asyncio-dev.html
