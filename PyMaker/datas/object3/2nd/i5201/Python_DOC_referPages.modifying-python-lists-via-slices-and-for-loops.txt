Natural Text
I was trying to modify the values in lists via slices and for-loops, and ran into some pretty interesting behavior. I would appreciate if someone could explain what's happening internally here.
Let's break down your comments 1 by 1:1.)  slices can be modified:See these answers here.  It's calling the  method from the  object and assigning the  to it.  Each time you  reference  a new slice object is created (you can simple do  and it's apparent, not once will it be the same id).2.) indices of slices cannot be modified:That's not true.  It couldn't be modified because you're performing the assignment on the  instance, not the , so it doesn't trigger the  to be performed on the .  Also,  are immutable so it cannot be changed either way.3.) slices of slices cannot be modified:See above.  Same reason - you are assigning to an instance of the slice and not modifying the  directly.4.) this version of a for-loop cannot modify lists: being referenced here is the actual objects in the elements of .  If you ran the for loop with id(z) you'll note that they're identical to .  Even though  contains all 5 identical references, when you do  you are only assigning the new value to the object , not the object that is stored in .  If you want to modify the , you'll need to assign it by index, for the same reason you can't expect  will turn  into .5.) this version of a for-loop can modify lists:See my answer above. Now you are directly performing item assignment on the  instead of its representation.6.) if I assign a slice to a var, it can be modified:If you've been following so far, you'll realize now you are assigning the instance of  to the object , which is now a .  The story follows - you perform an item assignment by index on , of course it will be updated.7.) ...but it has no impact on the original list:Of course.   and  are two different objects.  , therefore any operation performed on  will not affect  whatsoever.  if you however assigned  and then made a change to , then yes,  will be affected as well.To expand a bit on , say you have a  and assigned two instances of such to the list :Note that the reference in question is the actual  instance, not the object  and .  So even if I did the following: still remains unchanged since the foo instances remains the same even though object  now is assigned to a different value.  For the same reason, whenever you make changes to  in , you are only affecting the object , but nothing in the list is changed until you update  by index.If however the object have attribute or is mutable, you can directly update the referenced object in the loop:That is because you are directly updating the object in reference instead of assigning to object .  If you however assigned  or  to a new object,  will not be affected.
There is nothing odd happening here. Any slice that you obtain from a list is a new object containing copies of your original list. The same is true for tuples.When you iterate through your list, you get the object which the iteration yields. Since s are immutable in Python you can't change the state of  objects. Each time you add two s a new  object is created. So your "version of a for-loop [which] cannot modify lists" is not really trying to modify anything because it will not assign the result of the addition back to the list.Maybe you can guess now why your second approach is different. It uses a special slicing syntax which is not really creating a slice of your list and allows you to assign to the list (documentation). The newly created object created by the addition operation is stored in the list through this method.For understanding your last (and your first) examples, it is important to know that slicing creates (at least for lists and tuples, technically you could override this in your own classes) a partial copy of your list. Any change to this new object will, as you already found out, not change anything in your original list.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__setitem__
https://docs.python.org/3/reference/simple_stmts.html#assignment-statements
https://docs.python.org/3/reference/datamodel.html#object.__setitem__
https://docs.python.org/3/reference/simple_stmts.html#assignment-statements
