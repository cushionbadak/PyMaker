Natural Text
I am trying to call a function  from another file named "File1" as module to the "Main File". I expect the value of  in "Main File" to be 4 instead of 1 and the value of  to be 3 instead of 2 after calling the function. Question: How do I ensure the value from the module's function from "File1" is passed onto the "Main File"? For this case,  and .My thoughts: I tried using global value but it does not seem to work, return in this case is only going to return either  or  value back to the function itself which probably defeat the purpose. Felt like I am missing out something simple but can't seem to get it. File1:Main:
There are multiple reasons it doesn't work:First, objects assigned in a function are created locally. When you do  and ,  and  are local objects that you created within the function that assigned to the parameter values.  Once the function exits,  and  no longer hold any relevance to code outside of the immediate function's scope.Second, while objects are passed in reference in Python, what remains immutable are immutable.  Since  and  are integers, they are immutable to change, i.e. each time you perform any operation on them, a new value is being assigned to the object instead of it changed.To understand this, consider the following function:Now consider I have three s I want to pass:And I call the function as follows:Now you might expect ,  and , but that is wrong.  If you ran it, you'll notice  will actually be an empty  (unchanged).So what makes  and  changes? Let's take a look at the object IDs printed out and compare:Before any changes were made in the function, you can see the object IDs are exactly the same respectively, that means  is an exact reference of , etc.  Now after the changes were done is where you notice the changes.  You can see that  and  now have a different object ID.  Why is that? That's because in the lines  and  you are effectively reassigning both objects to a new reference, which is .  You might also wonder why they both have a different ID because the value should be the same.  While  is the same reference, each  is a new instance of the  object containing the word  as an item, so they are different objects even though they have the same values.Why doesn't 's object reference get affected though? That's because when you call the  function on , it doesn't reassign but is changing the object in reference, appending the value  into the same object.Now after the function call, when you print the s, you will see: is changed, as expected, because the same object in reference was modified.   is unchanged, because even though  was reassigned a new list, it was a local object created within the function, and lost after function exits.Why did  get updated? You might think it's updated, but it's actually a NEW object with the same name.  Note the last part of the function returns the locally created  which has the value of .  So the function call evaluates as follows:If that's still confusing, run a , and you'll see , which is exactly the object ID of the locally created  (again, you'll probably see a different number, but the  will always equal ).Applying this logic, now you can understand why it is impossible to pass immutable integers in reference and hoping to modify them in the function.  The only way you can change the outside object is reassign them to the newly created local objects being returned by the function.This answer is obviously much more long winded than Stephen Rauch's, but it gives a little bit more background to why it doesn't work.
You need to  the values like:This returns a .  The  can the unpacked like:


Answer URL
https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences
https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences
