Natural Text
The question that I posted initially was lacking so here is an explanation that I hope will satisfy everyone and cancel some down votes that I received on it.I would like to have an intelligence inside a class, that with the creation of an instance, it is decided that the instance would be of a different class, which is one of the subclasses of this class, according to some logic.More specifically, I am making a Magic Square solver as a learning exercise and:I want to have a  class that will contain the logic of a MagicSquare.I want to have  and  subclasses of that class that will contain the logics of solving these two types of Magic Squares.I want to be able to call the creation of a , providing it's size, , and have the intelligence within  determine which subclass to create an instance of, instead of the generic, top, class .I understand that the intelligence to determine which subclass (/) to create an instance of can be (and perhaps would be easier to implement if it would be) outside of . The reason that I want it to be inside  is perhaps a gut feeling. I have a hunch that it would be more clean and tidy this way because the logic of determining which kind of Magic Square a certain Magic Square is, seems to me, to belong in the  class.
Not every thing have to be a class.Execution in the Kingdom of Nounswhy not use a factory function ? 
First, since you didn't give an example, here's the familiar toy minimal class hierarchy:Now, presumably you want to decide whether to be a  or not in the middle of, or right after, .The best way to do that is to not do it; just move the choice earlier. Then you don't need to do any re-classing; you just construct the class you actually want, and know it's going to be initialized as appropriate for that class.You can either use a factory function:… or an "alternate constructor" method:Or a custom  method:The advantage of all of these mechanisms is that  works the way it's supposed to. If someone writes a normal, Pythonic  method that correctly calls its superclass, it won't get trapped in an endless loop.The only reason to re- something in the base  would be if you wanted to explicitly prevent the child's  getting called. That's a very rare case, but if it's what you actually want, it's easy:
Initially I've supplied an answer which is based on changing  during . It was explained to me in the comments that this should be avoided.Now I am providing an answer that that is based on redefining the base class' :The code responsible for the creation of an instance is in the built in(1)  method. It is called when a class is called (e.g. ) and passed the arguments that were given in that call.When the instanciation of a  or a  (due to the inheritance of ) is called, the redefined  checks whether the instance to be created is of   and also has a  greater than 100.If so, it creates an instance of , instead of , using  and returns that.Otherwise, it calls upon the normal, default, built in,  for the creation of this instance, using  and returns that. This catches the expected case where  and also the case where this redefined  is called by the subclass  (like in ).For the record, here's my former answer:When you want an instance's class to be changed to one of it's  subclasses, depending on some condition, upon creation of that  instance, you can use some logic in , like so:The  is for re-initialisation of the instance as it's  new class.Footnotes:Is this really a built-in? I can't see it in the "Built-in functions" topic of Python Documentation.
I think you're misusing subclasses here.A subclass is supposed to represent a subtype—something whose interface is visibly specialized. That isn't true in the case of odd vs. even magic squares. They both have the same methods, and do the same (caller-visible) things in response to those methods, and so on.If the difference between an odd magic square and an even one is not what they do, but how they do it, then they aren't subclasses, there's just a single class with multiple policies.There may be a reasonable  type, whose user is the  type, which has to interact differently with odd and even subtypes. In that case, you want to make the separate policies into separate classes. You could base them on an abstract base class (which is rarely necessary in Python, but I'll show it anyway just for the hell of it):However, I think even this is likely overkill. What is the interface to solving a magic square, even from the square's point of view, beyond a single  method? There might be an answer to that question if, e.g., you're planning to visualize the solution process or turn it into a helper for a GUI game (although even in that case, a  method, or a  generator method, might still be all you need; look at some of the open source Sudoku games for examples). But likely there's nothing.And this is what yossi's answer (and the rant he linked to) are getting at: if the interface of a class is just a single method named  (or a more useful name that has exactly the same information as the class name itself), and there's no state that needs to live outside of an invocation of that method, you don't have a class at all, you have a function, clumsily hidden away. Some languages (notably Java and C#) force you to be clumsy like that, but Python does not; you can just write this:


Answer URL
