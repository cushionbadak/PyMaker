Natural Text
Is there a standard way (without installing third party libraries) to do cross platform filesystem mocking in Python? If I have to go with a third party library, which library is the standard?
The standard mocking framework in Python 3.3+ is unittest.mock; you can use this for the filesystem or anything else.You could also simply hand roll it by mocking via monkey patching:A trivial example:A bit more full (untested):In this example, the actual mocks are trivial, but you could back them with something that has state so that can represent filesystem actions, such as save and delete. Yes, this is all a bit ugly since it entails replicating/simulating basic filesystem in code.Note that you can't monkey patch python builtins. That being said...For earlier versions, if at all possible use a third party library, I'd go with Michael Foord's awesome Mock, which is now  in the standard library since 3.3+ thanks to PEP 0417, and you can get it on PyPI for Python 2.5+. And, it can mock builtins!
pyfakefs (homepage) does what you want – a fake filesystem; it’s third-party, though that party is Google. See How to replace file-access references for a module under test for discussion of use.For mocking, unittest.mock is the standard library for Python 3.3+ (PEP 0417); for earlier version see PyPI: mock (for Python 2.5+) (homepage).Terminology in testing and mocking is inconsistent; using the Test Double terminology of Gerard Meszaros, you’re asking for a “fake”: something that behaves like a filesystem (you can create, open, and delete files), but isn’t the actual file system (in this case it’s in-memory), so you don’t need to have test files or a temporary directory.In classic mocking, you would instead mock out the system calls (in Python, mock out functions in the  module, like   and ), but that’s much more fiddly.
pytest is gaining a lot of traction, and it can do all of this using tmpdir and monkeypatching (mocking).You can use the  function argument which will provide a temporary directory unique to the test invocation, created in the base temporary directory (which are by default created as sub-directories of the system temporary directory).The  function argument helps you to safely set/delete an attribute, dictionary item or environment variable or to modify  for importing. You can also pass it a function instead of using lambda.If your application has a lot of interaction with the file system, then it might be easier to use something like pyfakefs, as mocking would become tedious and repetitive.
Faking or Mocking?Personally, I find that there are a lot of edge cases in filesystem things (like opening the file with the right permissions, string-vs-binary, read/write mode, etc), and using an accurate fake filesystem can find a lot of bugs that you might not find by mocking. In this case, I would check out the  module of  (it has various concrete implementations of the same interface, so you can swap them out in your code).Mocking (and without Monkey Patching!):That said, if you really want to mock, you can do that easily with Python's  library:The above example only demonstrates creating and writing to files via mocking the  method, but you could just as easily mock any method.


Answer URL
https://docs.python.org/3/library/unittest.mock.html
https://docs.python.org/3/library/unittest.mock.html
https://docs.python.org/3/library/unittest.mock.html
