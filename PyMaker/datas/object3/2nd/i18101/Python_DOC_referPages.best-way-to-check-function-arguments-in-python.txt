Natural Text
I'm looking for an efficient way to check variables of a python function. For example, I'd like to check arguments type and value. Is there a module for this? Or should I use something like decorators, or any specific idiom?
The most Pythonic idiom is to clearly document what the function expects and then just try to use whatever gets passed to your function and either let exceptions propagate or just catch attribute errors and raise a  instead. Type-checking should be avoided as much as possible as it goes against duck-typing. Value testing can be OK – depending on the context.The only place where validation really makes sense is at system or subsystem entry point, such as web forms, command line arguments, etc. Everywhere else, as long as your functions are properly documented, it's the caller's responsibility to pass appropriate arguments.
In this elongated answer, we implement a Python 3.x-specific type checking decorator based on PEP 484-style type hints in less than 275 lines of pure-Python (most of which is explanatory docstrings and comments) – heavily optimized for industrial-strength real-world use complete with a -driven test suite exercising all possible edge cases.Feast on the unexpected awesome of bear typing:As this example suggests, bear typing explicitly supports type checking of parameters and return values annotated as either simple types or tuples of such types. Golly!O.K., that's actually unimpressive.  resembles every other Python 3.x-specific type checking decorator based on PEP 484-style type hints in less than 275 lines of pure-Python. So what's the rub, bub?Pure Bruteforce Hardcore EfficiencyBear typing is dramatically more efficient in both space and time than all existing implementations of type checking in Python to the best of my limited domain knowledge. (More on that later.)Efficiency usually doesn't matter in Python, however. If it did, you wouldn't be using Python. Does type checking actually deviate from the well-established norm of avoiding premature optimization in Python? Yes. Yes, it does.Consider profiling, which adds unavoidable overhead to each profiled metric of interest (e.g., function calls, lines). To ensure accurate results, this overhead is mitigated by leveraging optimized C extensions (e.g., the  C extension leveraged by the  module) rather than unoptimized pure-Python (e.g., the  module). Efficiency really does matter when profiling.Type checking is no different. Type checking adds overhead to each function call type checked by your application – ideally, all of them. To prevent well-meaning (but sadly small-minded) coworkers from removing the type checking you silently added after last Friday's caffeine-addled allnighter to your geriatric legacy Django web app, type checking must be fast. So fast that no one notices it's there when you add it without telling anyone. I do this all the time! Stop reading this if you are a coworker.If even ludicrous speed isn't enough for your gluttenous application, however, bear typing may be globally disabled by enabling Python optimizations (e.g., by passing the  option to the Python interpreter):Just because. Welcome to bear typing.What The...? Why "bear"? You're a Neckbeard, Right?Bear typing is bare-metal type checking – that is, type checking as close to the manual approach of type checking in Python as feasible. Bear typing is intended to impose no performance penalties, compatibility constraints, or third-party dependencies (over and above that imposed by the manual approach, anyway). Bear typing may be seamlessly integrated into existing codebases and test suites without modification.Everyone's probably familiar with the manual approach. You manually  each parameter passed to and/or return value returned from every function in your codebase. What boilerplate could be simpler or more banal? We've all seen it a hundred times a googleplex times, and vomited a little in our mouths everytime we did. Repetition gets old fast. DRY, yo.Get your vomit bags ready. For brevity, let's assume a simplified  function accepting only a single  parameter. Here's what the manual approach looks like:Python 101, right? Many of us passed that class.Bear typing extracts the type checking manually performed by the above approach into a dynamically defined wrapper function automatically performing the same checks – with the added benefit of raising granular  rather than ambiguous  exceptions. Here's what the automated approach looks like:It's long-winded. But it's also basically* as fast as the manual approach. * Squinting suggested.Note the complete lack of function inspection or iteration in the wrapper function, which contains a similar number of tests as the original function – albeit with the additional (maybe negligible) costs of testing whether and how the parameters to be type checked are passed to the current function call. You can't win every battle.Can such wrapper functions actually be reliably generated to type check arbitrary functions in less than 275 lines of pure Python? Snake Plisskin says, "True story. Got a smoke?"And, yes. I may have a neckbeard.No, Srsly. Why "bear"?Bear beats duck. Duck may fly, but bear may throw salmon at duck. In Canada, nature can surprise you.Next question.What's So Hot about Bears, Anyway?Existing solutions do not perform bare-metal type checking – at least, none I've grepped across. They all iteratively reinspect the signature of the type-checked function on each function call. While negligible for a single call, reinspection overhead is usually non-negligible when aggregated over all calls. Really, really non-negligible.It's not simply efficiency concerns, however. Existing solutions also often fail to account for common edge cases. This includes most if not all toy decorators provided as stackoverflow answers here and elsewhere. Classic failures include:Failing to type check keyword arguments and/or return values (e.g., sweeneyrod's  decorator).Failing to support tuples (i.e., unions) of types accepted by the  builtin.Failing to propagate the name, docstring, and other identifying metadata from the original function onto the wrapper function.Failing to supply at least a semblance of unit tests. (Kind of critical.)Raising generic  exceptions rather than specific  exceptions on failed type checks. For granularity and sanity, type checking should never raise generic exceptions.Bear typing succeeds where non-bears fail. All one, all bear!Bear Typing UnbaredBear typing shifts the space and time costs of inspecting function signatures from function call time to function definition time – that is, from the wrapper function returned by the  decorator into the decorator itself. Since the decorator is only called once per function definition, this optimization yields glee for all.Bear typing is an attempt to have your type checking cake and eat it, too. To do so, :Inspects the signature and annotations of the original function.Dynamically constructs the body of the wrapper function type checking the original function. Thaaat's right. Python code generating Python code.Dynamically declares this wrapper function via the  builtin.Returns this wrapper function.Shall we? Let's dive into the deep end.And leycec said, Let the   bring forth type checking fastly: and it was so.Caveats, Curses, and Empty PromisesNothing is perfect. Even bear typing.Caveat I: Default Values UncheckedBear typing does not type check unpassed parameters assigned default values. In theory, it could. But not in 275 lines or less and certainly not as a stackoverflow answer.The safe (...probably totally unsafe) assumption is that function implementers claim they knew what they were doing when they defined default values. Since default values are typically constants (...they'd better be!), rechecking the types of constants that never change on each function call assigned one or more default values would contravene the fundamental tenet of bear typing: "Don't repeat yourself over and oooover and oooo-oooover again."Show me wrong and I will shower you with upvotes.Caveat II: No PEP 484PEP 484 ("Type Hints") formalized the use of function annotations first introduced by PEP 3107 ("Function Annotations"). Python 3.5 superficially supports this formalization with a new top-level  module, a standard API for composing arbitrarily complex types from simpler types (e.g., , a type describing a function accepting two arguments of type  and  and returning a value of type ).Bear typing supports none of them. In theory, it could. But not in 275 lines or less and certainly not as a stackoverflow answer.Bear typing does, however, support unions of types in the same way that the  builtin supports unions of types: as tuples. This superficially corresponds to the  type – with the obvious caveat that  supports arbitrarily complex types, while tuples accepted by  support only simple classes. In my defense, 275 lines.Tests or It Didn't HappenHere's the gist of it. Get it, gist? I'll stop now.As with the  decorator itself, these  tests may be seamlessly integrated into existing test suites without modification. Precious, isn't it?Now the mandatory neckbeard rant nobody asked for.A History of API ViolencePython 3.5 provides no actual support for using PEP 484 types. wat?It's true: no type checking, no type inference, no type nuthin'. Instead, developers are expected to routinely run their entire codebases through heavyweight third-party CPython interpreter wrappers implementing a facsimile of such support (e.g., mypy). Of course, these wrappers impose:A compatibility penalty. As the official mypy FAQ admits in response to the frequently asked question "Can I use mypy to type check my existing Python code?": "It depends. Compatibility is pretty good, but some Python features are not yet implemented or fully supported." A subsequent FAQ response clarifies this incompatibility by stating that:"...your code must make attributes explicit and use a explicit protocol representation." Grammar police see your "a explicit" and raise you an implicit frown."Mypy will support modular, efficient type checking, and this seems to rule out type checking some language features, such as arbitrary runtime addition of methods. However, it is likely that many of these features will be supported in a restricted form (for example, runtime modification is only supported for classes or methods registered as dynamic or ‘patchable’)."For a full list of syntactic incompatibilities, see "Dealing with common issues".  It's not pretty. You just wanted type checking and now you refactored your entire codebase and broke everyone's build two days from the candidate release and the comely HR midget in casual business attire slips a pink slip through the crack in your cubicle-cum-mancave. Thanks alot, mypy.A performance penalty, despite interpreting statically typed code. Fourty years of hard-boiled computer science tells us that (...all else being equal) interpreting statically typed code should be faster, not slower, than interpreting dynamically typed code. In Python, up is the new down.Additional non-trivial dependencies, increasing:The bug-laden fragility of project deployment, especially cross-platform.The maintenance burden of project development.Possible attack surface.I ask Guido: "Why? Why bother inventing an abstract API if you weren't willing to pony up a concrete API actually doing something with that abstraction?" Why leave the fate of a million Pythonistas to the arthritic hand of the free open-source marketplace? Why create yet another techno-problem that could have been trivially solved with a 275-line decorator in the official Python stdlib?I have no Python and I must scream.
Type checking is generally not Pythonic. In Python, it is more usual to use duck typing. Example:In you code, assume that the argument (in your example ) walks like an  and quacks like an . For instance:This means that not only does your function work with integers, it also works with floats and any user defined class with the  method defined, so less (sometimes nothing) has to be done if you, or someone else, want to extend your function to work with something else. However, in some cases you might need an , so then you could do something like this:and the function still works for any  that defines the  method.In answer to your other questions, I think it is best (as other answers have said to either do this:orSome type checking decorators I made:
One way is to use :
You can use Type Enforcement accept/returns decorators fromPythonDecoratorLibraryIt's very easy and readable:
There are different ways to check what a variable is in Python. So, to list a few: function takes your variable,  and gives you  is it is the same type of the  you listed. function that takes in a variable , and gives you  if  is a subclass of . So for example  would give you a  value is another example, demonstrated by this function, : leans more towards duck-typing, and something that is usually more pythonic but that term is up opinionated.Just as a note,  statements are usually used in testing, otherwise, just use  statements.
Normally, you do something like this:
I did quite a bit of investigation on that topic recently since I was not satisfied with the many libraries I found out there.I ended up developing a library to address this, it is named valid8. As explained in the documentation, it is for value validation mostly (although it comes bundled with simple type validation functions too), and you might wish to associate it with a PEP484-based type checker such as enforce or pytypes.This is how you would perform validation with  alone (and  actually, to define the validation logic - but it is not mandatory) in your case:And this is the same example leveraging PEP484 type hints and delegating type checking to :
This checks the type of input arguments upon calling the function:Also check with  (it must give assertion error)
If you want to check ,  as well as normal arguments in one go, you can use the  function as the first statement in your function definition to get a dictionary of the arguments.Then use  to examine the arguments, for example whilst iterating over the dict.
Demo:more about locals()
If you want to do the validation for several functions you can add the logic inside a decorator like this:and use it:Hope this helps!
This is not the solution to you, but if you want to restrict the function calls to some specific parameter types then you must use the PROATOR { The Python Function prototype validator }. you can refer the following link. https://github.com/mohit-thakur-721/proator 



Answer URL
https://docs.python.org/3/library/typing.html
