Natural Text
When I'm using Python 3 to launch a program via , why do I need 4 backslashes in paths?This is my code:When I examine the command line of the launched  instance with Task Manager, it shows the path correctly with only one backslash separating each path.Because of this, I need this on Windows to make the paths work:is there a more elegant solution?
Part of the problem is that you're using , which implements escaping rules used by Unix-ish shells.  But you're running on Windows, whose command shells use different rules.  That accounts for one level of needing to double backslashes (i.e., to worm around something  does that you didn't need to begin with).That you're using a regular string instead of a raw string () accounts for the other level of needing to double backslashes, and 2*2 = 4.  QED ;-)This works fine on Windows:By the way, read the docs for  carefully:  the Windows  API call requires a string for an argument.  When you pass a sequence instead, Python tries to turn that sequence into a string, via rules explained in the docs.   When feasible, it's better - on Windows - to pass the string you want directly.
When you are creating the string, you need to double each backslash for escaping, and then when the string is passed to your shell, you need to double each backslash again. You can cute the backslashes in half by using a raw string:
 has special meaning - you're using it as part of an escape sequence.  Double up the backslashes, and you have a literal backslash .The caveat is that, with only one pair of escaped backslashes, you still have only one literal backslash.  You need to escape that backslash, too.Alternatively, why not just use  instead?  You'll be able to ensure your code is more portable (since it'll use the system-specific separator), and you won't have to deal [directly] with escaping backslashes.
As John points out 4 slashes isn't necessary when accessing files locally.One place where 4 slashes is necessary is when connecting to (generally windows) servers over SMB or CIFS.Normally you would just use \servername\share\But each one of those slashes needs to be escaped.  So thus the 4 slashes before servernames.you could also use subprocess.call()


Answer URL
