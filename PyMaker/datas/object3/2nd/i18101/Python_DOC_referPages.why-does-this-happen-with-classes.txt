Natural Text
I have written following class which does the following:When I run this code I see that the variable  gets appended with the values and so does the But when I initialize the  with empty list, I still see  holds to the values. What could be the reason 
Why would you think otherwise? At first, you assign  to point to the same list as , so mutations to one will be seen in the other. But when you do  you simply rebind  to a new list, you don't affect  at all.
After the  method has run, we have two objects in memory:They contain:Now we call add_code and it runs:At this point, both lastval and self.Values are references to object #2, the array. So we have:Continuing...The  method modifies object #2. So now we have:This continues similarly...So now we have:At this point, we do something different:This is an assignment to a local variable. It doesn't do anything to object #2. It creates a new array. So finally we have:As you can see, lastval and self.Values now refer to different objects.The important thing to understand is the difference updating a variable to reference different objects, and mutating an existing object. For an in-depth discussion, see http://docs.python.org/3/reference/datamodel.html (That document is for Python 3, but there is no major difference in these concepts between Python 2 and Python 3.)
Classes have nothing (or not much) to do with this.  The underlying effect is that several variables can hold the same list (this happens via assignment).  And if you then change the list, all variables seem to change.You might want to create copies of the lists to avoid that.


Answer URL
