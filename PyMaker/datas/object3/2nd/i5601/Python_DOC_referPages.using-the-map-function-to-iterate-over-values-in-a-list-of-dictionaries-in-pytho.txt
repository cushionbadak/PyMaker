Natural Text
I've been trying to process data stored in a list of dictionaries, and store it in another list of tuples. For example say i have the following data:And I want to run all the data through the following function which i cannot change:Ideally, after computing all the data, I want to sort the triangles based on their hypotenuse length and I want to return a list of tuples in the following format:I know I have to use the map() function in conjunction with sorted() but I have no idea how to pass only the values corresponding to "base" and "height" keys. If someone could point me in the right direction, it would be greatly appreciated.Thanks
You need do modify you hypotenuse function, for some like this:map will returns a generator of tuples, when, each tuple is (name, hyp), so, just sort using the second element of tuple:UPDATE:Cause you can't change hypotenuse function, you can just use list comprehension:
Around 1993, Python got lambda, reduce(), filter() and map(), courtesy of a Lisp hacker who missed them and submitted working patches. These Lisp-flavored constructs are considered a little alien in Python specially after the introduction of list comprehensions in 2000. So no, you don't need map, you can use list comprehensions or generator expressions.You can let your  function take extra arguments and ignore them:Then you can use a list comprehension:This should perform well enough even for large . The generator expression version is:Profiling both solutions and posting here would be a great exercise.thanks. is there a way to this without modifying the hypotenuse function? â€“ canecseSure! Just call it with both arguments:Note that the accepted solution is allocating an actual list and trowing it away so you may want to use a generator expression instead of a list comprehension if you are concerned about memory footprint (specially useful if  is big but always a good habit):
Since your  function works fine here, you can construct a comprehension to create your list of tuples:Which gives:or if you really wanted to use , you could try this:Note: You can use  instead of . It's just a matter of preference here. If your interested, you can read this to see the performance between the two, and their respective pros and cons. UPDATE:@Paulo Scardine pointed out in the comments that if  gets bigger in the future, using a generator expression within  is more efficient. This is because the list comprehension creates a list on the spot, but  removes this list anyways in the process, so its a waste to pass in a list when its not needed. This isn't a problem for the second example, since  already returns a generator. I updated the above code to account for these recommendations. 


Answer URL
https://docs.python.org/3/library/operator.html#operator.itemgetter
