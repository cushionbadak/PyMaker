Natural Text
Tl;dr is bold-faced text.I'm working with an image dataset that comes with boolean "one-hot" image annotations (Celeba to be specific). The annotations encode facial features like bald, male, young. Now I want to make a custom one-hot list (to test my GAN model). I want to provide a literate interface. I.e., rather than specifying  knowing that  - counting from zero - corresponds to the male feature, I want something like  or .Suppose the header of my  file isand I want to codify Young, Bald, and Chubby. The expected output issince Bald is the fourth entry of the header, Chubby is the sixth, and so on. What is the clearest way to do this without expecting a user to know Bald is the fourth entry, etc.? I'm looking for a Pythonic way, not necessarily the fastest way.Ideal FeaturesIn rough order of importance:A way to accomplish my stated goal that is already standard in the Python community will take precedence.A user/programmer should not need to count to an attribute in the  header. This is the point of what I'm trying to design.A user should not be expected to have non-standard libraries like .A user/programmer should not need to reference the  header for attribute names/available attributes. One example: if a user wants to specify the gender attribute but does not know whether to use  or , it should be easy to find out.A user/programmer should be able to find out the available attributes via documentation (ideally generated by Sphinx api-doc). That is, the point 4 should be possible reading as little code as possible. Attribute exposure with  sufficiently satisfies this point.The programmer should find the indexing tool natural. Specifically, zero-indexing should be preferred over subtracting from one-indexing.Between two otherwise completely identical solutions, one with better performance would win.Examples:I'm going to compare and contrast the ways that immediately came to my mind. All examples use:1: Dict ComprehensionObviously we could use a dictionary to accomplish this:For what it's worth, this has the fewest lines of code and is the only one that doesn't rely on a standard library over builtins. As for negatives, it isn't exactly self-documenting. To see the available options, you must  - it's not exposed with . This borders on not satisfying feature 5 because it requires a user to know  is a dict to exposure features AFAIK.2: Enum:Since I'm learning C++ right now,  is the first thing that came to mind:This gives dot notation and the image options are exposed with . However,  uses one-indexing by default (the reason is documented). The work-around makes me feel like  is not the Pythonic way to do this, and entirely fails to satisfy feature 6.3: Named TupleHere's another one out of the standard Python library:Using , we again get dot notation and self-documentation with . But, the  class is heavier than . By this I mean,  has functionality I do not need. This solution appears to be a leader among my examples, but I do not know if it satisfies feature 1 or if an alternative could "win" via feature 7.4: Custom EnumI could really break my back:This has all the advantages of Ex. 2. But, it comes with obvious the obvious drawbacks. I have to write out all the features (there's 40 in the real dataset) just to zero-index! Sure, this is how to make an enum in C++ (AFAIK), but it shouldn't be necessary in Python. This is a slight failure on feature 6.SummaryThere are many ways to accomplish literate zero-indexing in Python. Would you provide a code snippet of how you would accomplish what I'm after and tell me why your way is right? (edit:) Or explain why one of my examples is the right tool for the job?Status Update:I'm not ready to accept an answer yet in case anyone wants to address the following feedback/update, or any new solution appears. Maybe another 24 hours? All the responses have been helpful, so I upvoted everyone's so far. You may want to look over this repo I'm using to test solutions. Feel free to tell me if my following remarks are (in)accurate or unfair:zero-enum:Oddly, Sphinx documents this incorrectly (one-indexed in docs), but it does document it! I suppose that "issue" doesn't fail any ideal feature.dotdict:I feel that  is overkill, but  is acceptable. Thanks to both answerers that got this solution working with . However, it doesn't appear that it "works seamlessly" with Sphinx.Numpy record:As written, this solution takes significantly longer than the other solutions. It comes in at 10x slower than a  (fastest behind pure dict) and 7x slower than standard  (slowest behind numpy record). That's not drastic at current scale, nor a priority, but a quick Google search indicates  is in fact slow. Let's stick withunless I've implemented something wrong in the linked repo. This brings the execution speed into a range that compares with the other solutions. Again, no Sphinx.namedtuple (and rassar's critiques)I'm not convinced of your  critique. It seems to me that you believe I'm approaching the problem wrong. It's fine to call me out on that, but I don't see how using the  is fundamentally different from "Enum [which] will provide separate values for each constant." Have I misunderstood you?Regardless,  appears in Sphinx (correctly numbered, for what it's worth). On the Ideal Features list, this chalks up identically to zero-enum and profiles ahead of zero-enum.Accepted RationaleI accepted the zero-enum answer because the answer gave me the best challenger for . By my standards,  is marginally the best solution. But salparadise wrote the answer that helped me feel confident in that assessment. Thanks to all who answered.
How about a factory function to create a zero indexed  since that is the object that suits your needs, and  provides flexibility in construction:Then:
You can use a custom class which I like to call as  or as mentioned here is this SO discussion as : https://stackoverflow.com/a/32107024/2598661 (, longer complete version)https://stackoverflow.com/a/23689767/2598661 (, shorter lighter version)About :It has the features of a dictionary since the input to a Map/DotMap is a dict. You can access attributes using .Additionally you can access the attributes using dot i.e.  and the attributes will be exposed when you do .It is only as heavy as it needs to be in order to enable the dot functionality.Unlike  you don't need to pre-define it and you can add and remove keys willy nilly.The  function described in the SO question is not Python3 compatible because it uses . Just replace it with  instead.About : provides the same advantages of  with the exception that it does not override the  method therefore you will not be able to obtain the attributes for documentation. @SigmaPiEpsilon has provided a fix for this here.It uses the  method instead of  therefore it will return  instead of throwing  when you are access attributes that don't exist.It does not recursively apply  to nested dicts therefore you won't be able to use .Here's the updated version of  which solves the first two issues:Update and  don't have the same behavior as pointed out by @SigmaPiEpsilon so I added separate descriptions for both.
Of your examples, 3 is the most pythonic answer to your question.1, as you said, does not even answer your question, since the names are not explicit. 2 uses enums, which though being in the standard library are not pythonic and generally not used in these scenarios in Python.(Edit): In this case you only really need two different constants - the target values and the other ones. An Enum will provide separate values for each constant, which is not what the goal of your program is and seems to be a roundabout way of approaching the problem.4 is just not maintainable if a client wants to add options, and even as it is it's painstaking work.3 uses well-known classes from the standard library in a readable and succinct way. Also, it does not have any drawbacks, as it is perfectly explicit. Being too "heavy" doesn't matter if you don't care about performance, and anyway the lag will be unnoticeable with your input size.
Your requirements if I understand correctly can be divided into two parts:Access the position of header elements in the  by name in the most pythonic way possible and with minimum external dependenciesEnable dot access to the data structure containing the names of the headers to be able to call  and setup easy interface with SphinxPure Python Way (no external dependencies)The most pythonic way to solve the problem is of course the method using dictionaries (dictionaries are at the heart of python). Searching a dictionary through key is also much faster than other methods. The only problem is this prevents dot access. Another answer mentions the Map and dotdict as alternatives.  is simpler but it only enable dot access, it will not help in the documentation aspect with  since  calls the  method which is not overridden in these cases. Hence it will only return the attributes of Python  and not the header names. See below:There are two options to get around this problem.Option 1: Override the  method like below. But this will only work when you call  on the instances of the class. To make the changes apply for the class itself you have to create a metaclass for the class. See hereOption 2: A second option which makes it much closer to user-defined object with attributes is to update the  attribute of the created object. This is what Map also uses. A normal python  does not have this attribute. If you add this then you can call  to get attributes/keys and also all the additional methods/attributes of python . If you just want the stored attribute and values you can use  which is also useful for documentation.Numpy wayAnother option will be to use a numpy  array which allows dot access. I noticed in your code you are already using numpy. In this case too  has to be overrridden to get the attributes. This may result in faster operations (not tested) for data with lots of other numeric values. In Python 3, you will need to use  since  became its own object.


Answer URL
https://docs.python.org/3/library/enum.html#functional-api
