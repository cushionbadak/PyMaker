Natural Text
I am writing a webapp with a Tornado backend and, of course, javascript and jquery on the frontend, so I am using the builtin json module in the standard library to serialize objects for the frontend. I had started writing a custom JSONEncoder for my classes, but then it occurred to me that I could simply write a very simple, generic object encoder:It seems to be working nicely, so I wondered why this is not included in the module, and if this technique has drawbacks. I didn't experiment if it works nicely with check_circular, but I have no reason to believe it doesn't.Any comments on my doubts? Otherwise, I suppose this technique may be useful to somebody, since I didn't find it with a search (admittedly, a quick one).EDIT: here's an example, as simple as it gets, to show the behaviour of the json module:
 is syntactic sugar for , so it doesn't work on any object without . This includes stuff like:User-defined objects where every level in the class hierarchy defined  (without a  slot) to reduce memory usageObjects of built-in types that don't opt-in to a  slotWorse, there are in-between cases, where some attributes are set on the , while others aren't (e.g. a class hierarchy where  was used for some levels, but other levels didn't use  and relied on the implicit ). In cases like that, you wouldn't get an error to let you know something had gone wrong, you'd just serialize the  part of the object state and silently ignore the rest.You'd have similar problems if the interface uses s; they're used like attributes, but they're not on the instance , so you'd either lose the information completely (if there is no hidden underlying attribute), or serialize the "wrong" value (the internal name, rather than the API name exposed as an ).In short, lots of things can go subtly wrong by trying to guess at the correct behavior like this, which is why The Zen of Python (type  in an interactive terminal to see it) includes stuff like:Errors should never pass silently.andIn the face of ambiguity, refuse the temptation to guess.Beyond these errors, there's also the general problem of reversability. A general encoder of this form is definitionally incapable of being handled by a general decoder (because you lose all the type information). Offering an easy way to lose important information is... suboptimal.


Answer URL
https://docs.python.org/3/library/json.html#py-to-json-table
