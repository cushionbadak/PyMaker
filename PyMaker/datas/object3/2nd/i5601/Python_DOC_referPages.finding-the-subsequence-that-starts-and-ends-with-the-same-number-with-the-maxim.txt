Natural Text
I have to make a program that takes as input a list of numbers and returns the sum of the subsequence that starts and ends with the same number which has the maximum sum (including the equal numbers in the beginning and end of the subsequence in the sum). It also has to return the placement of the start and end of the subsequence, that is, their index+1. The problem is that my current code runs smoothly only while the length of list is not that long. When the list length extends to 5000 the program does not give an answer. The input is the following:The first line is for the length of the list. The second line is the list itself, with list items separated by space. The output will be , because as you can see there is 1 equal pair of numbers (3): the first and fourth element, so the sum of elements between them is 3 + 2 + 4 + 3 = 12, and their placement is first and fourth.Here is my code.
This should be faster than your current approach. Rather than searching through  looking for pairs of matching numbers we pair each number in  with its index and sort those pairs. We can then use  to find groups of equal numbers. If there are more than 2 of the same number we use the first and last, since they will have the greatest sum between them.outputNote that this code will not necessarily give the maximum sum between equal elements in the list if the list contains negative numbers. It will still work correctly with negative numbers if no group of equal numbers has more than two members. If that's not the case, we need to use a slower algorithm that tests every pair within a group of equal numbers. Here's a more efficient version. Instead of using the  function we build a list of the cumulative sums of the whole list. This doesn't make much of a difference for small lists, but it's much faster when the list size is large. Eg, for a list of 10,000 elements this approach is about 10 times faster. To test it, I create an array of random positive integers.outputIf you're using a recent version of Python you can use  to build the list of cumulative sums. This is around 10% faster.Here's a faster version, derived from code by Stefan Pochmann, which uses a dict, instead of sorting & . Thanks, Stefan!If the list contains no duplicate items (and hence no subsequences bound by duplicate items) it returns the maximum item in the list.Here are two more variations. These can handle negative items correctly, and if there are no duplicate items they return . In Python 3 that could be handled elegantly by passing  to , but that option isn't available in Python 2, so instead I catch the  exception that's raised when you attempt to find the  of an empty iterable.The first version, , uses  to generate all combinations of a group of equal numbers and thence finds the combination that gives the maximum sum. The second version,  uses a variation of Kadane's algorithm to find the maximum subsequence within a group.If there aren't many duplicates in the original sequence, so the average group size is small,  is generally faster. But if the groups are large, then  is much faster than . The code below tests these functions on random sequences of 15000 items, firstly on sequences with few duplicates (and hence small mean group size) and then on sequences with lots of duplicates. It verifies that both versions give the same results, and then it performs  tests.outputThis code runs on both Python 2 and Python 3. The above results were generated on an old 32 bit 2GHz machine running Python 2.6.6 on a Debian derivative of Linux. The speeds for Python 3.6.0 are similar.If you want to include groups that consist of a single non-repeated number, and also want to include the numbers that are in groups as a "subsequence" of length 1, you can use this version:I haven't tested it extensively, but it should work. ;)


Answer URL
https://docs.python.org/3/library/timeit.html
