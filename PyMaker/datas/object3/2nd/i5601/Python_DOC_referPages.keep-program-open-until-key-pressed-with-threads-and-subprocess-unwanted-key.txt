Natural Text
tl;dr: I have several threads, one being a thread listening to input() to keep the program running/exit on keypress. But at one time in the program I need to stop this listener or it will intercept the input for a subprocessed program.    Long version:- Program should download some data, then hand this over to some other console program to be processed.- Program should either run until download is finished or until ENTER-keypress has been sent.- In both cases the download thread will be ended gracefully and the external processing should be done.- Problem: The input() function is still listening and intercepting the first input to the subprocess'ed console program.   Will result in:Press ENTER to stop downloading.Press Enter                                 << stopped here until I   pressed ENTERkeypress intercepted                        << stopped here until I   pressed ENTER All done  
If you can keep the main thread on top of the console, maybe you could take advantage of the fact that  is going to block the main thread until  is pressed. Once the execution continues (because  was pressed), communicate to the running threads that they have to stop using an Event (another example here). If you do want to listen for S.O. signals, I suggest you take a look to the signal module (watch out, some features may be O.S dependent).EDIT (as per the OP's comment):One of the complications that the original question has is how to communicate the termination request to a subprocess. Because processes don't share memory with the parent process (the process who spawned it) this can, indeed, only (or almost only) be done through actual SO signals. Because of this memory isolation, any flags set on the parent process will have no effect in the spawned subprocesses: the only way of inter process communication is either through OS signals, or through files (or file-like structures) that both parent and child process "known about" and use to share information. Also, calling an  in the parent binds the standard input () to that process which means by default, the subprocesses are unaware about the keys pressed in the parent (you could always bind the  of the child process to the  of the parent, but that would complicate a bit more the code)Fortunately, the instances of  do offer a nice way to send signals to the child process: the TERM signal, which the subprocess could catch and is supposed to interpret as "Hey, you're gonna be stopped real soon, so do your clean-up things, close files and so on and exit" and the KILL signal that doesn't really tell anything to the subprocess (can't be caught): it just kills it (In Linux, for instance a KILL signal removes all access to memory from the killed process so any action that uses memory, such as a seek for next operation will cause an error. More info here)To demonstrate that, let's say we have a simple  file in the same directory where our main program is located that looks like this:script.py >A script that would take a random time to process and that can, potentially, be quite long (at least long enough to demonstrate)Now, we could create one (or many) subprocesses in a tread that run that  file, regularly check their status (using poll()) and if the user has requested the forced output send a  signal and a bit later a  if necessary.


Answer URL
https://docs.python.org/3/library/threading.html#event-objects
