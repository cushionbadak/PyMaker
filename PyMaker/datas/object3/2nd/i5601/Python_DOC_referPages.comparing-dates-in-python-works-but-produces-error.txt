Natural Text
I'm trying to compare two dates. This code works:It produces:Those code does not work and I don't know why:It produces this error:Note that all I changed was  to , why does equality comparison results in  or , while greater than comparaison results in an error?I would appreciate any help!
TL;DRIt's because of how the comparison methods are defined.Reason why `==` is comparable while `>=` isn't between `time` objects and type `int`:Here's a copy of the source code for the  object: returns  when it's not another  instance, while  calls , which is defined as followed:Very Important EditAlthough this answer already got some positive scores, but I have miss read your question, you used  objects, not  objects.Reason why `==` is comparable while `>=` isn't between `date` objects and type `int`:First of all,  objects, unlike  objects, they are implemented the same for  and . Both of them actually returns , therefore there's nothing special about the  object's methods:What is different, however, is 's  comparison's to the other methods.  returns  when an object has a none-comparable type for  and  for .The  returned by  will result in a fallback on 's methods. Since  is always equality comparable,  does not result in an error.Here is an example:You can run this example here.If you do not know what  is, here's a short explanation and a quote from the doc:When a binary [ ( ,  ...) ] (or in-place) method returns  the  interpreter will try the reflected operation on the other type (or  some other fallback, depending on the operator). If all attempts  return , the interpreter will raise an appropriate  exception. Incorrectly returning NotImplemented will result in a  misleading error message or the  value being returned to  Python code.When  is returned from a binary method, it refers that the binary method isn't able to compare itself with the targets' type. The result of the binary method will depend on the other objects' binary method. If both object returns  an error is raised.
As others have already pointed out, you cannot use  because both do not have the same type. works because you are checking if two objects are equal to each other. If their types are different, the answer is automatically no and thus you get  back.However, when using , , , , you check whether or not something is greater or smaller than something else. If you use two objects with different types that cannot be trivially converted to one another, then it is not defined what 'greater than' or 'smaller than' means. So, in your case,  is of type , while  is of type .
You are trying to compare  with 0.That would not work since  is a  (See how you define it initially). So basically you are comparing a  with an .You can compare only similar types.


Answer URL
https://docs.python.org/3/library/constants.html?highlight=notim#NotImplemented
