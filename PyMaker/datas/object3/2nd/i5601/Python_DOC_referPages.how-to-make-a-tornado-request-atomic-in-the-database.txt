Natural Text
I have a python app written in the Tornado Asynchronous framework. When an HTTP request comes in, this method gets called:The three database operations are interrelated. And this is a concurrent application so multiple such HTTP calls can be happening concurrently and hitting the same DB.For data-integrity purposes, its important that the three database operations in this method are all called without another processes reading or writing to those database rows in between.How can I make sure this method has database atomicity? Does Tornado have a decorator for this?
Synchronous database accessYou haven't stated how you access your database. If, which is likely, you have synchronous DB access in  and friends (e.g. with pymysql) and  is blocking (doesn't return control to IO loop) then you block your server (which has implications on performance and responsiveness of your server) but effectively serialise your clients and only one can execute  at a time. So in terms of data consistency you don't need to do anything, but generally it's a bad design. You can solve both with @xyres's solution in short term (at cost of keeping in mind thread-safely concerns because most of Tornado's functionality isn't thread-safe).Asynchronous database accessIf you have asynchronous DB access in  and friends (e.g. with tornado-mysql) then you can use . Here's an example:Note that the above is said about normal single-process Tornado application. If you use , then you can only go with .
Since you want to run those three db operations one right after the other,  the function  must be non-asynchronous.But this would also mean that  will block the server. You definitely don't want that. One way that I can think of is to run this function in another thread. This won't block the server and will keep accepting new requests while the operations are running. And since, it's going to be non-async, db atomicity is guaranteed.Here's the relevant code to get you started:


Answer URL
https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Lock
