Natural Text
I have the following list of paired values :This list can contain one or more remarkable pairs that are made of the same item:I'd like to move those pairs to the end of the list to obtain :I can't figure it out, but I believe I'm not too far:
Straight-forward sorting:This simple key function works because  is sorted before  while mapping all pairs to only two keys maintains stability. The downside to this approach is that sorting is . For a linear solution without unecessary list concatenations, you could use  with appropriate generators:
Use list comprehensions:Note that a more efficient solution would beIt is more efficient, as here you iterate  only once, whereas in the list comprehensions solution, you iterate  twice. Still, both solutions take  time complexity and  space complexity, which are better (and more natural for this problem), than a sorting solution.
If you want your original solution to work, you can do something simple like this instead:This however is , because of  in the for loop, which is  itself.  is only  if you pop from the end of a list.You could also group using a dictionary by the length of lists sets, which is  if you avoid sorting at the end and just use  and , both of which are  operations. Here is an example:Of course, as shown by @schwobaseggl, you can also accept the  approach of sorting:
Just collect all the duplicates in a list and at last extend the list :output:


Answer URL
https://docs.python.org/3/howto/sorting.html#sorting-basics
https://docs.python.org/3/howto/sorting.html#key-functions
https://docs.python.org/3/howto/sorting.html#sort-stability-and-complex-sorts
https://docs.python.org/3/library/itertools.html#itertools.chain
