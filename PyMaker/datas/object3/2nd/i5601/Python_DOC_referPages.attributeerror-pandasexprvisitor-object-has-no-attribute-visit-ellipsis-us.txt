Natural Text
I have a series of the form: Note that its elements are strings: I'm trying to use  to parse this string into a column of lists. This works for this sample data. However, on much larger data (order of 10K), this fails miserably!What am I missing here? Is there something wrong with the function or my data?
TL;DRAs of , this is a bug, and an open issue on GitHub. See GH16289.Why am I getting this error?This (in all probability) is 's fault, which cannot parse series with more than 100 rows. Here's an example. Whereas, This issue persists, regardless of the parser or the engine.What does this error mean?When a series with more than 100 rows is passed,  operates on the  of the Series, rather than the objects contained within it (which is the cause of this bug). The  truncated rows, replacing them with a  (ellipsis). This ellipsis is misinterpreted by the engine as an  object - Which is exactly the cause for this error.What can I do to make this to work?Right now, there isn't a solution (the issue is still open as of 12/28/2017), however, there are a couple of workarounds. Option 1This option should work out of the box if you can guarantee that you do not have any malformed strings.If there is a possibility of malformed data, you'll need to write a little error handling code. You can do that with a function - Pass this function to  -  works for any number of rows, and is slow, but reliable. You can also use  for JSON data, applying the same ideas as with .Option 2Another great option for parsing simple data, I picked this up from @ayhan a while ago.I haven't tested this on more complex structures, but this should work for almost any basic string representation of data. You can find the documentation for PyYAML here. Scroll down a bit and you'll find more details on the  function.Note If you're working with JSON data, it might be suitable to read your file using  or  to begin with.You can also perform parsing as you read in your data, using  - Where the  argument will apply that function passed on the column as it is read, so you don't have to deal with parsing later.Continuing the point above, if you're working with a dataframe, pass a  - Where  is the column that needs to be parsedYou can also pass  (for json data), or  (if you have 100 rows or less).Credits to MaxU and Moondra for uncovering this issue. 
Your data is fine, and  is buggy, but not in the way you think. There is a hint in the relevant github issue page that urged me to take a closer look at the documentation. As you can see, the documented behaviour is to pass strings to , in line with the general (and expected) behaviour of the / class of functions. You pass a string, and end up with an arbitrary object.As I see it,  is buggy because it doesn't reject the  input  up front, leading it to guess in the face of ambiguity. The fact that the default shortening of the '  designed for pretty printing can drastically affect your result is the best proof of this situation.The solution is then to step back from the XY problem, and use the right tool to convert your data, and preferably stop using  for this purpose entirely. Even in the working cases where the  is small, you can't really be sure that future pandas versions don't break this "feature" completely.


Answer URL
https://docs.python.org/3/library/ast.html#ast.literal_eval
