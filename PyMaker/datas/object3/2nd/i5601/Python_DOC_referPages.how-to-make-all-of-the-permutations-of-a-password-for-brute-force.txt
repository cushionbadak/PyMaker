Natural Text
So I was trying to make a program that brute forces passwords. Firstly, I made a program for a password of length 1:Then I edited it for a password of length 2:Finally I did the same for a password of length 3:How could I generalize this for a variable called length which contains the integer value of the lenght of the password?
You can use the following recursive function:which you can call with syntax like:Why does this work?We always call each function with the three variables: ,  and . The variable  holds the current guess up to this point, so in the first example,  will be everything up to  such as ,  etc.The next variable  holds how many characters there are to go till the  is the right length.The next variable  is the correct password which we just pass through and is compare against.In the main body of the function, we need to first check the case where  is  (done by checking  as  evaluates to ). This is the case when we already have a string that is the length of the goal and we just want to check whether it is correct.If it matches, then we return the string, otherwise we return . We return either the solution or  to indicate to the function which called us (the call above in the stack) that we found the right password (or not).We have now finished the case where  and now need to handle the other cases.In these cases, the aim is to take the string that we have been called with and loop through all of the characters in , each time calling the  function (recursive) with the result of the concatenation of the string we were called with and that character (). This will create a tree like affect where every string up to the original  is checked.We also need to know what to do with the  and  variables when calling the next function.Well, to handle these, we just need to think what the next function needs to know. It already has the  (as this was the result of concatenating the next character in the  string) and the  is just going to be one less as we just added one to the  through the concatenation and the  is clearly going to be the same - we are still searching for the same password.Now that we have called this function, it will run through subtracting one from the length at each of the subsequent calls it makes until it eventually reaches the case where . And we are at the easy case again and already know what to do!So, after calling it, the function will return one of two things, either  indicating that the last node did not find the password (so this would occur in the case where something like  reached the end in our search for  so returned  after no solution was found), or, the call could return the actual solution.Handling these cases is simple, if we got the actual solution, we just want to return that up the chain and if we got a fail (), we just want to return  And that will indicate to the node above us that we did not succeed and tell it to continue its search.So now, we just need to know how to call the function. We just need to send in an empty  and a target  and  value and let the recursion take place.Note one last thing is that if you wanted this to be even neater, you could modify the function definition to:and change the recursive call within. This way, you could call the function with something just like:  and wouldn't need to specify what  should start at. This is just something that you can add in if you want, but isn't necessary for the function to work.
In addition to the answer that shows you how this works, I'd like to draw attention to the fact that the standard library has a function for just this, in the shape of â€”not  because that does not allow repetitions and therefore would only generate guesses with all unique characters:
Here's one solution: is the maximum guess length the function will go up to.  should take a guess and return a truthy value if it worked. The function returns the first successful guess, or  if it couldn't find anything.I will admit I forgot about the guess length and was reminded by @Joe Iddon's answer.Now, that function checks for a correct answer even if the guess isn't the right length yet, which is wasteful in some circumstances. Here's a function that doesn't do that:
Try this:Instead of using nested loops it guesses each character in turn.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.product
