Natural Text
Here is the tracebackQ1. Why is this error thrown? They are Q2. How do I pause the mocking so that the first line will pass if the error is fixed?From the docNormally the class attribute of an object will return its type.  For a mock object with a spec class returns the spec class  instead. This allows mock objects to pass isinstance tests for the  object they are replacing / masquerading as: Thanks
Don't use , instead check for the existence of the  method. If the method exists, call it:This is a better design anyway: relying on type information is much more brittle.
IMHO this is a good question and saying "don't use , use duck typing instead" is a bad answer. Duck typing is great, but not a silver bullet. Sometimes  is necessary, even if it is not pythonic. For instance, if you work with some library or legacy code that isn't pythonic you must play with . It is just the real world and mock was designed to fit this kind of work.In the code the big mistake is when you write:From  documentation we read (emphasize is mine):Inside the body of the function or with statement, the target is patched with a new object.That means when you patch the  class object the reference to  will be replaced by a  object for the context of the  function. Then, when  is executed in   is a  object and not a class (as the error suggests).That behavior is because as a side effect of patching a class reference the 2nd argument of  becomes an object (a  instance). This is neither a  or a . A simple experiment to understand this behavior is to modify  as follows:The error will disappear because the original reference to  class is saved in  when you load the module. When the patch is applied it will change just  and not .Unfortunately, the previous experiment doesn't give us any way to play with cases like yours because you cannot change the library or legacy code to introduce a trick like this. Moreover, these are that kind of tricks that we would like to never see in our code.The good news is that you can do something ,but you cannot just  the  reference in the module where you have   code to test. The best way depends on the real case that you must solve. In your example you can just create a  to use as  object, use  argument to dress it as  instance and pass the  test. This is exactly one of the aims for which  is designed. Your test would be written like this:And the output of just unittest part is
Michele d'Amico provides the correct answer in my view and I strongly recommend reading it. But it took me a while a grok and, as I'm sure I'll be coming back to this question in the future, I thought a minimal code example would help clarify the solution and provide a quick reference:
You can do it by being inherited from the  class and overriding the  method:And then you can use this class with the  decorator:That's it!Remarks:You MUST mock all classes which are compared using .Example: will cause an error  because  contains a default  method. And then we should handle the test like this:
I've been wrestling with this myself lately while writing some unit tests. One potential solution is to not actually try to mock out the entire HelloWorld class, but instead mock out the methods of the class that are called by the code you are testing. For example, something like this should work:


Answer URL
https://docs.python.org/3/library/unittest.mock.html#patch
