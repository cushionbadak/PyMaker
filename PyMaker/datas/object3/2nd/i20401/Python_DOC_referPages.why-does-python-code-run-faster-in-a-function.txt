Natural Text
This piece of code in Python runs in  (Note: The timing is done with the time function in BASH in Linux.)However, if the for loop isn't placed within a function, then it runs for a much longer time:Why is this?
You might ask why it is faster to store local variables than globals. This is a CPython implementation detail.Remember that CPython is compiled to bytecode, which the interpreter runs. When a function is compiled, the local variables are stored in a fixed-size array (not a ) and variable names are assigned to indexes. This is possible because you can't dynamically add local variables to a function. Then retrieving a local variable is literally a pointer lookup into the list and a refcount increase on the  which is trivial.Contrast this to a global lookup (), which is a true  search involving a hash and so on. Incidentally, this is why you need to specify  if you want it to be global: if you ever assign to a variable inside a scope, the compiler will issue s for its access unless you tell it not to.By the way, global lookups are still pretty optimised. Attribute lookups  are the really slow ones!Here is small illustration on local variable efficiency.
Inside a function, the bytecode isAt top level, the bytecode isThe difference is that  is faster (!) than .  This is because in a function,  is a local but at toplevel it is a global.To examine bytecode, use the  module.  I was able to disassemble the function directly, but to disassemble the toplevel code I had to use the  builtin.
Aside from local/global variable store times, opcode prediction makes the function faster.As the other answers explain, the function uses the  opcode in the loop. Here's the bytecode for the function's loop:Normally when a program is run, Python executes each opcode one after the other, keeping track of the a stack and preforming other checks on the stack frame after each opcode is executed. Opcode prediction means that in certain cases Python is able to jump directly to the next opcode, thus avoiding some of this overhead.In this case, every time Python sees  (the top of the loop), it will "predict" that  is the next opcode it has to execute. Python then peeks at the next opcode and, if the prediction was correct, it jumps straight to . This has the effect of squeezing the two opcodes into a single opcode.On the other hand, the  opcode is used in the loop at the global level. Python does *not* make similar predictions when it sees this opcode. Instead, it must go back to the top of the evaluation-loop which has obvious implications for the speed at which the loop is executed.To give some more technical detail about this optimization, here's a quote from the  file (the "engine" of Python's virtual machine):Some opcodes tend to come in pairs thus making it possible to   predict the second code when the first is run.  For example,    is often followed by . And  is often   followed by  or .Verifying the prediction costs a single high-speed test of a register      variable against a constant.  If the pairing was good, then the      processor's own internal branch predication has a high likelihood of      success, resulting in a nearly zero-overhead transition to the      next opcode.  A successful prediction saves a trip through the eval-loop      including its two unpredictable branches, the  test and the      switch-case.  Combined with the processor's internal branch prediction,      a successful  has the effect of making the two opcodes run as if      they were a single new opcode with the bodies combined.We can see in the source code for the  opcode exactly where the prediction for  is made:The  function expands to  i.e. we just jump to the start of the predicted opcode. In this case, we jump here:The local variable is now set and the next opcode is up for execution. Python continues through the iterable until it reaches the end, making the successful prediction each time.The Python wiki page has more information about how CPython's virtual machine works.


Answer URL
https://docs.python.org/3/whatsnew/3.6.html#optimizations
https://docs.python.org/3/whatsnew/3.1.html#optimizations
https://docs.python.org/3/whatsnew/3.2.html#build-and-c-api-changes
