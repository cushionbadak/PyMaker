Natural Text
I'm trying to convert a longish hollow "data" class into a named tuple. My class currently looks like this:After conversion to  it looks like:But there is a problem here. My original class allowed me to pass in just a value and took care of the default by using default values for the named/keyword arguments. Something like:But this doesn't work in the case of my refactored named tuple since it expects me to pass all the fields. I can of course replace the occurrences of  to  but it isn't to my liking.So does there exist a good trick which can make my re-write successful without adding a lot of code complexity (metaprogramming) or should I just swallow the pill and go ahead with the "search and replace"? :)
Python 3.7Use the defaults parameter.Before Python 3.7Set  to the default values.Before Python 2.6Set  to the default values.OrderIn all versions of Python, if you set fewer default values than exist in the namedtuple, the defaults are applied to the rightmost parameters. This allows you to keep some arguments as required arguments.Wrapper for Python 2.6 to 3.6Here's a wrapper for you, which even lets you (optionally) set the default values to something other than . This does not support required arguments.Example:
I subclassed namedtuple and overrode the  method:This preserves an intuitive type hierarchy, which the creation of a factory function disguised as a class does not.
Wrap it in a function.
With  in Python 3.6.1+ you can provide both a default value and a type annotation to a NamedTuple field. Use  if you only need the former:Usage:Also, in case you need both default values and optional mutability, Python 3.7 is going to have data classes (PEP 557) that can in some (many?) cases replace namedtuples.Sidenote: one quirk of the current specification of annotations (expressions after  for parameters and variables and after  for functions) in Python is that they are evaluated at definition time*. So, since "class names become defined once the entire body of the class has been executed", the annotations for  in the class fields above must be strings to avoid NameError.This kind of type hints is called "forward reference" ([1], [2]), and with PEP 563 Python 3.7+ is going to have a  import (to be enabled by default in 4.0) that will allow to use forward references without quotes, postponing their evaluation.* AFAICT only local variable annotations are not evaluated at runtime. (source: PEP 526)
I'm not sure if there's an easy way with just the built-in namedtuple. There's a nice module called recordtype that has this functionality:
This is an example straight from the docs:Default values can be implemented by using _replace() to customize a  prototype instance:So, the OP's example would be:However, I like some of the other answers given here better.  I just wanted to add this for completeness. 
Here is a more compact version inspired by justinfay's answer:
In python3.7+ there's a brand new defaults= keyword argument.defaults can be  or an iterable of default values. Since fields with a default value must come after any fields without a default, the defaults are applied to the rightmost parameters. For example, if the fieldnames are  and the defaults are , then  will be a required argument,  will default to , and  will default to .Example usage:
Short, simple, and doesn't lead people to use  improperly:
A slightly extended example to initialize all missing arguments with :
You can also use this:This basically gives you the possibility to construct any named tuple with a default value and override just the parameters you need, for example:
Combining approaches of @Denis and @Mark:That should support creating the tuple with positional arguments and also with mixed cases.Test cases:but also support TypeError:
Python 3.7: introduction of  param in namedtuple definition.Example as shown in the documentation:Read more here.
I find this version easier to read:This is not as efficient as it requires creation of the object twice but you could change that by defining the default duple inside the module and just having the function do the replace line. 
Since you are using  as a data class, you should be aware that python 3.7 will introduce a  decorator for this very purpose -- and of course it has default values. An example from the docs:Much cleaner, readable and usable than hacking . It is not hard to predict that usage of s will drop with the adoption of 3.7.
Inspired by this answer to a different question, here is my proposed solution based on a metaclass and using  (to handle future subcalssing correctly).  It is quite similar to justinfay's answer.Then:
Using the  class from my  library, and using the  syntax, this is quite simple:The one potential drawback is the requirement for a  string for any attribute with a default value (it's optional for simple attributes).  In use it looks like:The advantages this has over :is simplicity, as well as  being  based instead of  based.
Another solution:Usage:
Here's a short, simple generic answer with a nice syntax for a named tuple with default arguments:Usage:Minified:
The answer by jterrace to use recordtype is great, but the author of the library recommends to use his namedlist project, which provides both mutable () and immutable () implementations.
Here's a less flexible, but more concise version of Mark Lodato's wrapper: It takes the fields and defaults as a dictionary.Example:


Answer URL
https://docs.python.org/3/library/collections.html#collections.namedtuple
https://docs.python.org/3/reference/datamodel.html?highlight=__metaclass__#metaclasses
https://docs.python.org/3/library/functions.html#super
