Natural Text
In python, in order to permutate the lettters of a string one can writeI wonder what does seed do with the key string and how it produces from it the permutation (or says shuffle how to do that). For example if I take the key to be 'hGd' how I get that specific output while if I write another key like 'AGd' I get another output?EDIT: The decryption algorithm I tried to use on that code is:
What  does with its argument is to pass it to the built-in  function, which converts it to a 32 bit signed integer, in other words a number in the range -2,147,483,648 to 2,147,483,647. That number is then used as the starting number by the pseudo-random integer generator (by default, the Mersenne Twister algorithm) that is the heart of the standard random functions. Each time a pseudo-random number generator (PRNG) is called it does a particular arithmetic operation on its current number to produce a new number. It may return that number as is, or it may return a modified version of that number. See Wikipedia for a simple type of PRNG.With a good PRNG it is very hard to predict what the next number in the sequence is going to be, and Mersenne Twister is very good. So it's not easy to predict the effect that different seeds will have on the output.BTW, you can pass  any kind of hashable object. So it can be passed an int, string, tuple, etc, but not a list. But as I said above, whatever you pass it, it gets converted to a number.Update In recent versions of Python,  takes an optional version arg version 1 works as I described above, but version 2 (the default in Python 3.2+) a , , or  object gets converted to an  and all of its bits are used.And I guess I should mention that if you call  without a seed value it uses the system entropy pool to generate a seed value, and if the system doesn't provide an entropy pool the current time as its seed value.The Mersenne Twister algorithm has a period of , which is a number of about 6000 decimal digits. So it takes a very long time before the cycle of integers it produces repeats exactly. Of course, individual integers and sub-sequences of integers will repeat much sooner. Python's version of Mersenne Twister doesn't actually return the integers it calculates, it converts them to 53 bit floating-point numbers; I assume it uses 64 bits internally. See the Wikipedia article on the Mersenne Twister if you're curious to know how it works.FWIW, here's a slightly improved version of your program.Now, onto your decryption problem. :) Is the message you have to decrypt merely scrambled, as by the program above, or does it use some other form of encryption? If it's merely scrambled, it will be relatively easy to unscramble. So unless you tell me otherwise, I shall assume that to be the case.You said that the key length is 3. Is the key purely alphabetic, or can the 3 characters in the key be anything in the range chr(0) to chr(255)? Either way, that's not really a lot of keys to check, and a Python program will be able to unscramble the message using a brute-force search of all keys in less than one second minute.To iterate over all possible keys, you can do this:I used  in that code because we want to generate all possible strings of 3 ascii letters, so we want the Cartesian product of 3 copies of .  is equivalent to  and putting  in front unpacks that list so that  gets 3 separate args. If we use  then we don't get any strings with repeated characters. To illustrate:Update  takes a repeat keyword arg, so we can simplify that to .......I thought you said that the string to be decoded has 42 chars, but there are only 40 chars in . Also, the appearance of the digits  &  in that string is a bit of a worry, although I guess the original unscrambled version could have digits in it...Anyway, I just tried unscrambling that string using the shuffle algorithm with all possible 140608 3 letter keys and printing the permutations produced that begin with . There are only 5 of them, and only one of those had a space after . But in every case the rest of the unscrambled string is garbage. My guess is that you've misunderstood the encryption algorithm that your lecturer used. Just in case you were wondering how random.shuffle() works, you can see Python code equivalent to the actual C source code here. It's like a randomized version of one pass through a selection sort.Another cute method is to sort the list using a random comparison function, or a random key function. EgHowever, the technique used by  is more efficient, and much faster since it's totally implemented in C.Reversing the shuffling procedure for a given keyLet's look at what happens when we shuffle a simple range.After the shuffle,  will be So to unshuffle  we need to build this list:Can you see how to do that? If you can't figure it out, I'm happy to post my code, but I think you should spend a little bit of time trying to figure it out first. Hint: Don't try to do it in a list comprehension, just use a  loop.Ok. You've struggled with this long enough. Here's my decoder.
I'm going to start by noting the code you posted is a little confusing! message is never named, but I assume you mean the original string by that. So we good. Your question is also confusing. Are you asking what random number generator seeds are? Because that's easy enough. But if you're asking how to get the output of an 'AGd' seeded generator using an 'hGd' seeded generator, that should probably be impossible because 'hGd' is not a permutation of 'AGd' and vice versa. They're simply not in the same set of permutations! But supposing they were, if you're asking how many iterations you would need to get the same output (or a collision, in other words) that would depend on the implementation and the algorithm and whatnot. Maybe it'd be worth looking into the details of python's random module; I'll admit I don't personally know that.But as for seeding, we could for example write a pseudorandom number generator but iteratively applying the equation  (where of course this one would be pretty garbage as far as random number generators go). The output on each call will be the equation applied to the input. But obviously this specifies a whole class of generators depending on what the initial value of x is! That's all a random seed is, usually, it's the value of x that starts off the whole process. Now checking the documentation here: https://docs.python.org/2/library/random.html I see that random seeds can actually be any hashable object. Consequently, if you feed in a string, the first thing it does is apply some hash function to the string in order to get a suitable seed to the pseudorandom number generator, where, of course, suitable is relative to the implementation of the specific pseudorandom number generator.If I've misunderstood your question, please accept my humble apologies.EDIT: PM 2Ring beat me to it, and his answer is better. See his.


Answer URL
https://docs.python.org/3/library/random.html#random.seed
https://docs.python.org/3/library/itertools.html#itertools.product
