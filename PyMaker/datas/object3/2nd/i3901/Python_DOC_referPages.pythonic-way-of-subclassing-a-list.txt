Natural Text
Here's my general problem space:I have a byte/bit protocol with a device over I2C.I've got a "database" of the commands to fully describe all the bitfields types and values and enumerations.I have a class to consume the database and a i2c driver/transactor so that I can then call commands and get responses.creates the proper byte stream for the GET_STATUS command, sends it over the i2c and returns the response as a byte array currently.  I can get it to pretty print the response inside of the GET_STATUS() implementation, but I want to move that behavior to return object, rather than in the command.I want my return object to be 'smart':   needs to have the list/array of bytes plus a reference to its field definitions.I want  to act like an list/bytearray, so I can directly inspect the bytes.  I don't care if slices are anything other than lists of bytes or bytearray.   Once they've been sliced out they're just bytes.I want 'theStatus' to be able to be printed  and have it pretty print all the fields in the status.  I'm comfortable on how to make this happen once I settle on a workable data structure that allows me to access the bytes and the data base.I want to inspect  by field name with something like  or maybe .   Same thing:  once I have a workable data structure that has the byte array and database as members, I can make this happen.The problem is I don't know the "right" data structure to cause the least amount of problems.   Any suggestions on the most pythonic way to accomplish this?  My initial thought was to subclass  and add the field definitions as a member, but it seems like python doesn't like that idea at all.Composition seems like the next bet, but getting it to act like a proper  seems like that might be a bunch of work to get it 'right'.
What you really want is to implement a new sequence type, one that is perhaps mutable. You can either create one from scratch by implementing the special methods needed to emulate container types, or you can use a suitable  collection ABC as a base.The latter is probably the easiest path to take, as the ABCs provide implementations for many of the methods as base versions that rely on a few abstract methods you must implement.For example, the (immutable)  ABC only requires you to provide implementations for  and ; the base ABC implementation provides the rest:If you really need a full list implementation, including support for rich comparisons (), sorting (), copying [] and multiplication (), then there is also the  class. This class inherits from , and adds the extra functionality that  offers over the base sequence ABCs. If you don't need that extra functionality, stick to base ABCs.
Make a subclass which inherits from , that's exactly what its for  https://docs.python.org/3/library/collections.html#collections.UserList
It sounds like you're looking for collections.UserList.


Answer URL
https://docs.python.org/3/glossary.html#term-sequence
https://docs.python.org/3/reference/datamodel.html#emulating-container-types
https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes
https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence
https://docs.python.org/3/library/collections.html#collections.UserList
https://docs.python.org/3/library/collections.html#collections.UserList
https://docs.python.org/3/library/collections.html#collections.UserList
