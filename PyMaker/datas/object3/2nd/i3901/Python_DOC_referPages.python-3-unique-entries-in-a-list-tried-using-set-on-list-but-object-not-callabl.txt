Natural Text
I am novice to Python and following a tutorial. There is an example of  in the tutorial :Now, In tutorial, . But in my case I am getting following error:Please tell me where I am wrong. I searched SO this but it is different.
Seems like you've shadowed the builtin name  pointing at a class by the same name pointing at its instance. Here is an example:I believe this is fairly obvious. Python stores object names (functions and classes are objects, too) in dictionaries (namespaces are implemented as dictionaries), hence you can rewrite pretty much any name in any scope. It won't show up as an error of some sort. As you might know Python emphasizes that "special cases aren't special enough to break the rules". And there are two major rules behind the problem you've faced.Namespaces. Python supports nested namespaces. Theoretically you can endlessly nest namespaces. As I've already mentioned, namespaces are basically dictionaries of names and references to corresponding objects. Any module you create gets its own "global" namespace. In fact it's just a local namespace with respect to that particular module. Scoping. When you reference a name, the Python runtime looks it up in the local namespace (with respect to the reference) and, if such name does not exist, it repeats the attempt in a higher-level namespace. This process continues until there are no higher namespaces left. In that case you get a . Builtin functions and classes reside in a special high-order namespace . If you declare a variable named  in your module's global namespace, the interpreter will never search for that name in a higher-level namespace (that is ). Similarly, suppose you create a variable  inside a function in your module, and another variable  in the module. Then, if you reference  inside the function, you will never get the global , because there is a  in the local namespace - the interpreter has no need to search it elsewhere. Here is a simple illustration.So, as you see there is nothing special about Python builtins. And your case is a mere example of universal rules. You'd better use an IDE (e.g. a free version of PyCharm or Atom with Python plugins) that highlights name shadowing to avoid such errors.You might as well be wondering what is a "callable", in which case you can read the following post: https://stackoverflow.com/a/111255/3846213. , being a class, is callable. Calling a class triggers instance construction and initialisation. An instance might as well be callable, but  instances are not. If you are even more puzzled by the distinction between classes and instances, then you might want to read the documentation (quite conveniently, the same page covers namespaces and scoping).If you want to know more about builtins, please read the answer by Christian Dean. P.S.When you start an interactive Python session you create a temporary module. 
Before you can fully understand what the error means and how to solve, it is important to understand what a built-in name is in Python.What is a built-in name?In Python, a built-in name is a name that the Python interpreter already has assigned a predefined value. The value can be either a function or class object. These names are always made available by default, no matter the scope. Some of the values assigned to these names represent fundamental types of the Python language, while others are simple useful. As of the latest version of Python - 3.6.2 - there are currently 61 built-in names. A full list of the names and how they should be used, can be found in the documentation section Built-in Functions.An important point to note however, is that Python will not stop you from re-assigning builtin names. Built-in names are not reserved, and Python allows them to be used as variable names as well.Here is an example using the  built-in:As you can see, Python allowed us to assign the  name, to reference a dictionary object.What does "TypeError: 'list' object is not callable" mean?To put it simply, the reason the error is occurring is because you re-assigned the builtin name  in the script:When you did this, you overwrote the predefined value of the built-in name. This means you can no longer use the predefined value of , which is a class object representing Python list.Thus, when you tried to use the  class to create a new list from a  object:Python raised an error. The reason the error says "'list' object is not callable", is because as said above, the name  was referring to a list object. So the above would be the equivalent of doing:Which of course makes no sense. You cannot call a list object.How can I fix the error?Suppose you have code such as the following:Running the above code produces the following error:If you are getting a similar error such as the one above saying an "object is not callable", chances are you used a builtin name as a variable in your code. In this case and other cases the fix is as simple as renaming the offending variable. For example, to fix the above code, we could rename our  variable to :PEP8 - the official Python style guide - includes many recommendations on naming variables.This is a very common error new and old Python users make. This is why it's important to always avoid using built-in names as variables such as , , , , etc.Many linters and IDEs will warn you when you attempt to use a built-in name as a variable. If your frequently make this mistake, it may be worth your time to invest in one of these programs.I didn't rename a built-in name, but I'm still getting "TypeError: 'list' object is not callable". What gives?Another common cause for the above error is attempting to index a list using parenthesis () rather than square brackets (). For example:For an explanation of the full problem and what can be done to fix it, see TypeError: 'list' object is not callable while trying to access a list.
You may have used built-in name 'list' for a variable in your code.If you are using Jupyter notebook, sometimes even if you change the name of that variable from 'list' to something different and rerun that cell, you may still get the error. In this case you need to restart the Kernal. In order to make sure that the name has change, click on the word 'list' when you are creating a list object and press Shit+Tab, and check if Docstring shows it as an empty list.
If you are in a interactive session and don't want to restart you can remove the shadowing with 
Why does  appear?Explanation:It is because you defined  as a variable before (i am pretty sure), so it would be a list, not the function anymore, that's why everyone shouldn't name variables functions, the below is the same as what you're doing now:So you need it to be the default function of , how to detect if it is? just use:How do i detect whether a variable name is a function? well, just simple see if it has a different color, or use a code like:After this, you should know why does  appear.Okay, so now...How to fix this  error?Code:You have to either do :Or use :Or remove  variable from memory:Or just rename the variable:P.S. Last one is the most preferable i guess :-)There are a whole bunch of solutions that work.References:'id' is a bad variable name in PythonHow do I use a keyword as a variable name?How to use reserved keyword as the name of variable in python?
For me it was a flask server returning some  array (which I expected to be in json format..)adding  fixed this issue


Answer URL
https://docs.python.org/3/
https://docs.python.org/3/library/functions.html#built-in-functions
https://docs.python.org/3/library/functions.html?highlight=dict#func-dict
