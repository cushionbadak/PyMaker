Natural Text
Base scenarioFor a recommendation service I am training a matrix factorization model (LightFM) on a set of user-item interactions. For the matrix factorization model to yield the best results, I need to map my user and item IDs to a continuous range of integer IDs starting at 0.I'm using a pandas DataFrame in the process, and I have found a MultiIndex to be extremely convenient to create this mapping, like so:And then allows me to get the continuous maps like soAfterwards, I can map them back using  method. Great!ExtensionBut, now I'm trying to streamline my model training process, ideally by training it incrementally on new data, preserving the old ID mappings. Something like:Then, simply appending the new ratings to the old DataFrameLooks good, butI added user_id=2 and item_id=2 in the later DataFrame on purpose, to illustrate where it goes wrong for me. In , labels 3 (for both user and item), have moved from integer position 1 to 2. So the mapping is no longer the same. What I'm looking for is  and  for user and item mappings respectively.This is probably because of ordering in pandas Index objects, and I'm unsure if what I want is at all possible using a MultiIndex strategy. Looking for help on how most to effectively tackle this problem :)Some notes:I find using DataFrames convenient for several reasons, but I use the MultiIndex purely for the ID mappings. Alternatives without MultiIndex are completely acceptable.I cannot guarantee that new user_id and item_id entries in new ratings are larger than any values in the old dataset, hence my example of adding id 2 when [1, 3] were present.For my incremental training approach, I will need to store my ID maps somewhere. If I only load new ratings partially, I will have to store the old DataFrame and ID maps somewhere. Would be great if it could all be in one place, like it would be with an index, but columns work too.EDIT: An additional requirement is to allow for row re-ordering of the original DataFrame, as might happen when duplicate ratings exist, and I want to keep the most recent one.Solution (credits to @jpp for original)I've made a modification to @jpp's answer to satisfy the additional requirement I've added later (tagged with EDIT). This also truly satisfies the original question as posed in the title, since it preserves the old index integer positions, regardless of rows being reordered for whatever reason. I've also wrapped things into functions:The result:
Forcing alignment of index labels after concatenation does not appear straightforward and, if there is a solution, it is poorly documented.One option which may appeal to you is Categorical Data. With some careful manipulation, this can achieve the same purpose: each unique index value within a level has a one-to-one mapping to an integer, and this mapping persists even after concatenation with other dataframes.I use  to return an ordered unique list, but if you don't have access to this library, you can use the identical  recipe from the  docs.Now let's have a look at the category codes underlying the 0th index level:Then perform our concatenation:Finally, check that categorical codes are aligned:For each index level, note we must take the union of all index values across dataframes to form , otherwise the concatenation will fail.
I think the use of MultiIndex overcomplicates this objective:I need to map my user and item IDs to a continuous range of integer IDs starting at 0.This solution falls in to the below category:Alternatives without MultiIndex are completely acceptable.ExplainationThis is how to maintain a mapping for the  values. Same holds for the  values as well.These are the initial  values (unique): maintains a mapping for  values, as per your requirement:These are the new  values you got from  - ones that you didn't see in :Now we update  for the total user base with the new users:Then, just map the values from  to :


Answer URL
https://docs.python.org/3/library/itertools.html#itertools-recipes
