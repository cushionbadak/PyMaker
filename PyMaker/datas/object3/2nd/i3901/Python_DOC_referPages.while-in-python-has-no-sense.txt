Natural Text
I have no idea what's happening there.It's something so simple, but I've been experimenting for long and it's have no sense.Here is the code:If I answer the input with 1, it works, as is suposed to do. But when i answer 2, it enter in the loop.And the strangest part is that when i Write 0 it don't enter in the loop!Someone has and idea of what can be happening. Maybe is an  interpreter problem...It's only a reduction of my problem, but I can't use the while loop by this way!!
 and  are not the same operator in Python. means logical (aka boolean) and, the one you want—it's truthy if both of its arguments are truthy. means bitwise and—it returns a new number with  for every bit that was  in both arguments (e.g., , aka , is , aka , and  is —which is false, even though both arguments are true, because they don't share any bits in common). That's not what you want.On top of that, they have different operator precedence (notice that  comes above  in the table, but  comes below it), so what you're actually doing is . Since , this is true no matter what  happens to be.There are two more differences that aren't relevant here, but worth learning:  short-circuits: if  is false, Python doesn't evaluate . This means you can do things like , and know it won't call  and raise an exception if  is . But  is just a normal operator, like , that always evaluates both arguments. always compares the values as boolean truthy-or-falsey; it can't be overriden by custom classes to do custom things, but  can—e.g., it means set intersection if the values are sets, or elementwise bitwise and if they're numpy arrays, etc.


Answer URL
https://docs.python.org/3/reference/expressions.html#boolean-operations
https://docs.python.org/3/reference/expressions.html#binary-bitwise-operations
https://docs.python.org/3/reference/expressions.html#operator-precedence
