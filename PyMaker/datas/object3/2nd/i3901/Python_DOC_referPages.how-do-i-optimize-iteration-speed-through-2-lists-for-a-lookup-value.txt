Natural Text
I have two lists built from a "cursor.fetchall()" statement from two different data sources.List 1's structure (when doing call to print()):List 2's structure, seemingly truncated (when doing a print() statement):I'm needing to look up each value in list_1 to see if it exists in list_2. And then, vice versa, in a separate task to see if each of the list_2[0] values are in list_1.Example of what I'm currently using:Each list contains roughly 30,000 records, and is currently very slow when using this method.Is there a faster way to perform these lookups? I'm performing a SQL INSERT or DELETE for each iteration (if that matters).
First: you've already got these values in a SQL database. Presumably with an appropriate index. So let the database do the work. Instead of reading all of A and all of B into memory, use a join or a subselect to read only those elements of A that have a match in B.But let's assume that's not appropriate somehow.To look up many values quickly, you usually want to use a set or dict instead of a list.In your case, you're trying to look up values on  rather than all of , so that would be a dict, with your current  as the keys. Instead of this:… you want this:Ideally, you want to build the dict instead of the list in the first place. If you can't do that, you can convert in linear time:Since you appear to be getting these from a database cursor: Most database libraries for Python have cursors that act as lazy iterators of rows (fetching a buffered chunk at a time in whatever way is most efficient), so you can just use the cursor itself:However you build your dict or set, lookups take constant time instead of linear—and they're simpler to write, to boot:… or:No need for a loop and a  flag.For many cases—although I don't think it will work here—you can make things even simpler. If you have two sets, or a set and a dict, and you just want the intersection of the first set with the second set, or with the dict's keys, that's just:When a hash-based structure like a set or dict isn't appropriate (e.g., if the keys can't be hashed), you can still get logarithmic time—not quite as good as constant, but a lot better than linear. If you can just  the list after building it, you can use  to search it. If you have to keep modifying the list between searches, you'll want to use a data structure that stays sorted—a balanced binary search tree, something wider like a b-tree, a hybrid b-tree/deque structure like , a skiplist, etc. There are many options on PyPI to choose from, and you can even more to implement yourself in a good book on data structures.


Answer URL
https://docs.python.org/3/tutorial/datastructures.html#sets
