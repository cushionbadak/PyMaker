Natural Text
This question already has an answer here:Two methods inherited from one method in class are different in instances, aren't they?                    1 answer                If I have a this evaluates to :but this evaluates to :as doesWhy?I found that  and  both are represented by So no hint there....
At least in CPython, bound methods are implemented as an instance of a class . Every time you ask for the value of a bound function, you get a new instance of this class.All this class does is store a reference to the instance and the unbound function, and when you call the class it calls the unbound function with the stored instance (along with your other arguments).Unbound functions, like , are just regular old functions - no new instances of proxy classes are being constructed, so identity works as you expect.The reason for this difference is that the semantic meaning of  depends on two things, the value of  and the value of . In order to be able to get this meaning at any point in time later, both of these values need to be stored. This is what the  class does.Conversely, the meaning of  depends only on a single value: . So no additional work is required to store anything, and the value itself is used.You might consider the idea of pre-allocating bound method instances, so that  always returns the same immutable object - but given the dynamic nature of Python, it is simpler and cheaper to just construct a new one each time, even if they could be the same.
To add to @GManNickG answer:will return .
Some objects stored in classes are descriptors, which don't follow normal rules for object lookups. The  method you're dealing with in your example is one (function objects are descriptors).A descriptor is an instance of a class that defines a  (and optionally  and ) method(s). Those methods control what happens when you look up the desciptor on an instance of the class it's stored in.I think an example will make this more clear:A  method doesn't need to return the same thing every time it's called. In fact, it usually won't. In the specific case of functions being used as descriptors (i.e. methods), a new "bound method" object will be created each time you look the function up. Thus the  operator will not see multiple bound methods as the same object, even though they may be binding the same function to the same instance.


Answer URL
https://docs.python.org/3/howto/descriptor.html
https://docs.python.org/3/howto/descriptor.html#functions-and-methods
