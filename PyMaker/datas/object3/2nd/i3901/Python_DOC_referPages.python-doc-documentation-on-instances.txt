Natural Text
I'd like to provide documentation (within my program) on certain dynamically created objects, but still fall back to using their class documentation. Setting  seems a suitable way to do so. However, I can't find many details in the Python help in this regard, are there any technical problems with providing documentation on an instance? For example:
 is documented as a writable attribute for functions, but not for instances of user defined classes.  , for example, will only consider the  defined on the type.Other protocols (including future use-cases) may reasonably bypass the special attributes defined in the instance dict, too. See Special method lookup section of the datamodel documentation, specifically:For custom classes, implicit invocations of special methods are only guaranteed to work correctly if defined on an object’s type, not in the object’s instance dictionary. So, depending on the consumer of the attribute, what you intend to do may not be reliable. Avoid.A safe and simple alternative is just to use a different attribute name of your own choosing for your own use-case, preferably not using the  syntax convention which usually indicates a special name reserved for some specific use by the implementation and/or the stdlib.
There are some pretty obvious technical problems; the question is whether or not they matter for your use case.Here are some major uses for docstrings that your idiom will not help with:: Type  in an interactive terminal, and you get the docstring for , not the docstring for .Auto-generated documentation: Unless you write your own documentation generator, it's not going to understand that you've done anything special with your  value. Many doc generators do have some way to specify help for module and class constants, but I'm not aware of any that will recognize your idiom.IDE help: Many IDEs will not only auto-complete an expression, but show the relevant docstring in a tooltip. They all do this statically, and without some special-case code designed around your idiom (which they're unlikely to have, given that it's an unusual idiom), they're almost certain to fetch the docstring for the class, not the object.Here are some where it might help:Source readability: As a human reading your source, I can tell the intent from the  right near the construction of . Then again, I could tell the same intent just as easily from a Sphinx comment on the constant.Debugging:  doesn't really do much with docstrings, but some GUI debuggers wrapped around it do, and most of them are probably going to show .Custom dynamic use of docstrings: Obviously any code that you write that does something with  is going to get the instance docstring if you want it to, and therefore can do whatever it wants with it. However, keep in mind that if you want to define your own "protocol", you should use your own name, not one reserved for the implementation.Notice that most of the same is true for using a descriptor for the docstring:If you type , you'll get , but  will treat it as an object with no docstring.It's worth noting that making  work is one of the reasons some dynamic proxy libraries generate new classes on the fly—that is, a proxy to underlying type  has some new type like , instead of the same  type used for proxies to s and eses. The former allows  to show dynamically-generated information about . But I don't know how important a reason it is; often you already need dynamic classes to, e.g., make special method lookup work, at which point adding dynamic docstrings comes for free.
I think it's preferred to keep it under the class via your doc string as it will also aid any developer that works on the code. However if you are doing something dynamic that requires this setup then I don't see any reason why not. Just understand that it adds a level of indirection that makes things less clear to others.Remember to K.I.S.S. where applicable :)


Answer URL
https://docs.python.org/3/library/pydoc.html
https://docs.python.org/3/reference/datamodel.html#special-method-lookup
