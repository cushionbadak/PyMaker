Natural Text
My understanding is that the typical GIL manipulations involve, e.g., blocking I/O operations. Hence one would want to release the lock before the I/O operation and reacquire it once it has completed.I'm currently facing a different scenario with a C extension: I am creating X windows that are exposed to Python via the  class. When the method  is called on an instance, a new UI thread is started using  (with a call to ). This new thread is responsible for drawing on the X window, using the Python code specified in the  method of a subclass of . A pure C event loop is started in the main thread that simply checks for events on the X window and, for the time being, only captures the .So I have potentially many threads (one for each X window) that want to execute Python code and the main thread that does not execute any Python code at all.How do I release/acquire the GIL in order to allow the UI threads to get into the interpreter orderly?
The rule is easy: you need to hold the GIL to access Python machinery (any API starting with  and any ).So, you can release it whenever you don't need any of that.Anything further than this is the fundamental problem of locking granularity: potential benefits vs locking overhead. There was an experiment for Py 1.4 to replace the GIL with more granular locks that failed exactly because the overhead proved prohibitive.That's why it's typically released for code chunks involving call(s) to extental facilities that can take arbitrary time (especially if they involve waiting for external events) -- if you don't release the lock, Python will be just idling during this time.Heeding this rule, you will get to your goal automatically: whenever a thread can't proceed further (whether it's I/O, signal from another thread, or even so much as a  to avoid a busy loop), it will release the lock and allow other threads to proceed in its stead. The GIL assigning mechanism strives to be fair (see issue8299 for exploration on how fair it is), releasing the programmer from bothering about any bias stemming solely from the engine.
I think the problem stems from the fact that, in my opinion, the official documentation is a bit ambiguous on the meaning of Non-Python created threads. Quoting from it:When threads are created using the dedicated Python APIs (such as the  module), a thread state is automatically associated to them and the code showed above is therefore correct. However, when threads are created from C (for example by a third-party library with its own thread management), they donâ€™t hold the GIL, nor is there a thread state structure for them.I have highlighted in bold the parts that I find off-putting. As I have stated in the OP, I am calling . Whilst this creates a new thread from C, this function is not part of a third-party library, but of the dedicated Python (C) APIs. Based on this assumption, I ruled out that I actually needed to use the  paradigm.As far as I can tell from what I've seen with my experiments, a thread created from C with (just)  should be considered as a non-Python created thread.


Answer URL
https://docs.python.org/3/c-api/init.html#non-python-created-threads
