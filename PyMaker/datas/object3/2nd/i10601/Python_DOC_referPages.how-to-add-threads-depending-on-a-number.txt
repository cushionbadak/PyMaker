Natural Text
In a part of my software code written with python, I have a list of items where it size can vary greatly from 12 to only one item . For each item in this list I'm doing some processing (sending an HTTP request related to the given item, parse results and many other operations . I'd like to speed up my code using threading, I'd like to create 2 threads where each one take a number of items and do the processing async. Example 1 : Let's say that in my list I have 12 items, each thread would take in this case 6 items and call the processing functions on each item .Example 2 : Now let's say that my list have 9 items, one thread would take 5 items and the other thread would take the other 4 left items .Currently I'm not applying any threading and my code base is very large, so here some code that do almost the same thing as my case :Below is a basic lite code that explain what I'm doing, I can't figure out how can I make my threads flexible, so each one take a number of items and the other take the rest (as explained in example 1 & 2) .Thank's for your time
You might rather implement it using shared queueshttps://docs.python.org/3/library/queue.html#queue-objectsQuoting fromhttps://docs.python.org/3/library/queue.html#module-queue:The queue module implements multi-producer, multi-consumer queues. It  is especially useful in threaded programming when information must be  exchanged safely between multiple threads.The idea is that you have a shared storage and each thread attempts reading items from it one-by-one. This is much more flexible than distributing the load in advance as you don't know how threads execution will be scheduled by your OS, how much time each iteration would take etc. Furthermore, you might add items for further processing to this queue dynamically — for example, having a producer thread running in parallel.Some helpful links:A brief introduction into concurrent programming in python:http://www.slideshare.net/dabeaz/an-introduction-to-python-concurrencyMore details on producer-consumer pattern with line-by-line explanation:http://www.informit.com/articles/article.aspx?p=1850445&seqNum=8
You can use the  class from the  module in Python 3. The module is not present in Python 2, but there are some workarounds (which I will not discuss).A thread pool executor does basically what @ffeast proposed, but with fewer lines of code for you to write. It manages a pool of threads which will execute all the tasks that you submit to it, presumably in the most efficient manner possible. The results will be returned through  objects, which represent a "pending" result.Since you seem to know the list of tasks up front, this is especially convenient for you. While you can not guarantee how the tasks will be split between the threads, the result will probably be at least as good as anything you coded by hand.If you need more information with the output, like some way of identifying the futures that have completed or getting results out of them, see the example in the Python documentation (on which the code above is heavily based).


Answer URL
https://docs.python.org/3/library/queue.html#queue-objects
https://docs.python.org/3/library/queue.html#module-queue
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor
https://docs.python.org/3/library/concurrent.futures.html#module-concurrent.futures
https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor-example
