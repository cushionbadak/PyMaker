Natural Text
On codewars.com I encountered the following task:Create a function  that adds numbers together when called in succession. So  should return ,  should return , ...While I'm familiar with the basics of Python, I've never encountered a function that is able to be called in such succession, i.e. a function  that can be called as . Thus far, I'm not even sure how to interpret this notation. As a mathematician, I'd suspect that  is a function that assigns to every  a function  and then returns  and likewise for . Should this interpretation be correct, Python would allow me to dynamically create functions which seems very interesting to me. I've searched the web for the past hour, but wasn't able to find a lead in the right direction. Since I don't know how this programming concept is called, however, this may not be too surprising.How do you call this concept and where can I read more about it?
I don't know whether this is function chaining as much as it's callable chaining, but, since functions are callables I guess there's no harm done. Either way, there's two ways I can think of doing this:Sub-classing  and defining :The first way would be with a custom  subclass that defines  which returns a new instance of itself with the updated value:Function  can now be defined to return a  instance, which, as a callable that returns an updated value of itself, can be called in succession:In addition, as an  subclass, the returned value retains the  and  behavior of s. For more complex operations though, you should define other dunders appropriately. As @Caridorc noted in a comment,  could also be simply written as:Renaming the class to  instead of  also works similarly.Define a closure, requires extra call to yield value:The only other way I can think of involves a nested function that requires an extra empty argument call in order to return the result. I'm not using  and opt for attaching attributes to the function objects to make it portable between Pythons:This continuously returns itself () which, if a  is supplied, increments it () and if not, returns the value as it is. Like I mentioned, it requires an extra  call in order to return the incremented value:
You can hate me, but here is a one-liner :)Edit: Ok, how this works? The code is identical to answer of @Jim, but everything happens on a single line. can be used to construct new types: . For  we provide empty string, as name is not really needed in this case. For  (tuple) we provide an , which is identical to inheriting .  are the class attributes, where we attach the  lambda. is identical to The new type is constructed and returned within the outer lambda.
If you want to define a function to be called multiple times, first you need to return a callable object each time (for example a function) otherwise you have to create your own object by defining a  attribute, in order for it to be callable.The next point is that you need to preserve all the arguments, which in this case means you might want to use Coroutines or a recursive function. But note that Coroutines are much more optimized/flexible than recursive functions, specially for such tasks.Here is a sample function using Coroutines, that preserves the latest state of itself. Note that it can't be called multiple times since the return value is an  which is not callable, but you might think about turning this into your expected object ;-).
The pythonic way to do this would be to use dynamic arguments:This is not the answer you're looking for, and you may know this, but I thought I would give it anyway because if someone was wondering about doing this not out of curiosity but for work. They should probably have the "right thing to do" answer.
Simply:


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__call__
https://docs.python.org/3/library/asyncio-task.html
