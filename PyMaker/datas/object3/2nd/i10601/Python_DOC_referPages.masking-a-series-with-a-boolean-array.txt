Natural Text
This has given me a lot of trouble, and I am perplexed by the incompatibility of numpy arrays with pandas series. When I create a boolean array using a series, for instancedelta mask creates a boolean pandas series.However, if you doYou find that the array ignores completely the mask. No error is raised, but you end up with two objects of different length. This means that an operation likeresults in an error:Even more perplexing, I noticed that the operator < is treated differently. For instancewill give you a pd.series and np.array respectively. Also,results in a series, so it seems that the series takes precedence, whereas the boolean elements of a series mask are promoted to integers when passed to a numpy array and result in a sliced array.What is the reason for this?
Fancy IndexingAs numpy currently stands, fancy indexing in numpy works as follows:If the thing between brackets is a  (whether with explicit parens or not), the elements of the tuple are indices for different dimensions of . For example, both  and  will raise  in this case because  is 1D. However, before the exception happens, a telling warning will be raised too: .If the thing between brackets is exactly an , not a subclass or other array-like, and has a boolean type, it will be applied as a mask. This is why  gives the expected result (empty array since  is all .If the thing between brackets is any array-like, whether a subclass like  or just a , or something else, it is converted to an  array (if possible) and used as an integer index. So  yeilds something equivalent to  or just . In this case,  and  so the result is .This behavior is counterintuitive, and the  it generates indicates that a fix is in the works. I will update this answer as I find out about/make any changes to numpy.This information can be found in Sebastian Berg's response to my initial query on Numpy discussion here.Relational OperatorsNow let's address the second part of your question about how the comparison works. Relational operators (, , , ) work by calling the corresponding method on one of the objects being compared. For  this is . However, instead of just calling  for the expression , Python actually checks the types of the objects being compared. If  is a subtype of  that implements the comparison, then Python prefers to call  instead, regardless of how you wrote the original comparison. The only way that  will get called if  is a subclass of  is if  returns  to indicate that the comparison is not supported in that direction.A similar thing happens when you do . While  is not a subclass of , the comparison  returns , so Python actually ends up calling , which is of course defined and works just fine.A much more succinct explanation of all this can be found in the Python docs.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__lt__
