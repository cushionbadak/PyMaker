Natural Text
If  evaluates to , why does  evaluates to ?For example, the "voids" of the other types (e.g. 0, 0.0) will return  when compared to :Thanks
In the context of Boolean operations, and also when expressions are used by control flow statements, the following values are interpreted as false: , , numeric zero of all types, and empty strings and containers (including strings, tuples, lists, dictionaries, sets and frozensets). All other values are interpreted as true. User-defined objects can customize their truth value by providing a  method.The operator  yields  if its argument is false,  otherwise.https://docs.python.org/3/reference/expressions.html#comparisonsBut:The operators , , , , , and  compare the values of two objects. The objects do not need to have the same type....Because all types are (direct or indirect) subtypes of , they inherit the default comparison behavior from . Types can customize their comparison behavior by implementing rich comparison methods like  ...https://docs.python.org/3/reference/expressions.html#boolean-operationsSo, the technical implementation answer is that it behaves the way it does because  and  use different comparisons.  uses , the "truth value" of an object, while  uses , the direct comparison of one object to another. So it's possible to ask an object whether it considers itself to be truthy or falsey, and separately from that ask it whether it considers itself to be equal to another object or not. The default implementations for that are arranged in a way that two objects can both consider themselves falsey yet not consider themselves equal to one another.
It doesn't make sense for  and  to actually equal , because they are clearly different values: a string and a list. If they both equalled  they would have to be equal to each other*. They are just "falsey", which means they come out as false when they are converted to a boolean.(* in any sensibly constructed language) is an operation that returns a boolean. Which boolean it returns depends on whether the operand is falsey or not. So  is not equivalent to ; it is equivalent to .
If you want to check the official explanation, just cast your values like this:
Because  and . This is what Python is doing when it tries to evaluate . On the other hand, . The same goes for  and .The fact that  evaluates to  doesn't necessarily mean that .
Such a comparison isn't "Pythonic" (i.e. it isn't what an experienced Python programmer would naturally do). The Pythonic way to proceed is to use a value in a Boolean context such as an  statement, and leave the interpreter to apply the  built-in invisibly to determine a  or  value. That's why people commonly write code such asrather than using the commonly-seen but less Pythonic  or the even clumsier but still functionally correct .In some respects unfortunately, Python's designer decided that  and  would be instances of the  type, and that  would be a subclass of . As a result of this  compares equal to  and  compares equal to . Numerical conversion accounts for the floating-point (and, for that matter, complex) result.But just because a  doesn't mean , any more than  implies . There are many other values that evaluate false, the best-known beingNumeric zeroesThe empty stringEmpty containers (list, tuple, dict)There's no way they can all be equal to each other!


Answer URL
https://docs.python.org/3/reference/expressions.html#comparisons
https://docs.python.org/3/reference/expressions.html#boolean-operations
https://docs.python.org/3/library/stdtypes.html#truth-value-testing
