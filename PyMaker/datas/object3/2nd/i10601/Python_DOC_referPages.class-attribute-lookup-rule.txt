Natural Text
Why does  return the name of the class, while  returns the defined attribute in class D? And from where do builtin attributes such as  and  come from? I suspected  or  to be simple descriptors that live either in  class or somewhere, but this can't be seen.In my understanding, the attribute lookup rule as follows in Python, omitting the conditions for descriptors etc..: Given the fact that a class is an instance of a metaclass,  in this case, why  doesn't look for  in ?
The names  and  are special. Both are data descriptors.  is defined on the  object,  is defined on  (a base-class of all new-style classes):Because they are data descriptors, the  method (used for attribute access on a class) will ignore any attributes set in the class  and only use the descriptors themselves:Fun fact:  derives from  (everything in Python is an object) which is why  is found on  when checking for data descriptors:( is used directly as an unbound method, not , because all special method access goes to the type).See the Descriptor Howto an what constitutes a data descriptor and why that matters:If an object defines both  and , it is considered a data descriptor. Descriptors that only define  are called non-data descriptors (they are typically used for methods but other uses are possible).Data and non-data descriptors differ in how overrides are calculated with respect to entries in an instance’s dictionary. If an instance’s dictionary has an entry with the same name as a data descriptor, the data descriptor takes precedence. If an instance’s dictionary has an entry with the same name as a non-data descriptor, the dictionary entry takes precedence.For data descriptors on , a class is just another instance.So when looking up the  or  attributes, it doesn't matter what is defined in the  namespace, because for either a data descriptor is found in the namespace formed by  and it's MRO.These descriptors are defined in the  C code:On instances,  is used, and it'll find the  and  entries in the  mapping before it'll find the data descriptors on  or .If you omit either, however, then looking up the names on  will only  as a data descriptor in the MRO of  (so, on ).  is not found as the metatypes are not considered when resolving instance attributes.As such you can set  on an instance, but not :


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__getattribute__
https://docs.python.org/3/reference/datamodel.html#special-lookup
https://docs.python.org/3/howto/descriptor.html
