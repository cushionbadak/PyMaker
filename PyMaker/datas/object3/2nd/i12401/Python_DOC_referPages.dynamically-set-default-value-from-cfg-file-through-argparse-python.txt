Natural Text
I am trying to use  module. I am dealing with 2 configuration files:1.default cfg file 2. File provided by user.   If no file provided at run time, read from default file. And if user provides a file, use the content of provided file.My question is : I want to provide  field for each , so if it's not provided by user,it will always have some default value. These values can be read from either of the file (i.e. default or user given file). I need to check which file is provided and then My code:get_args.pycode to read cfg file: read_file.pysomething like:  It works perfect when i don't provide --config.Is this possible to read dynamically?
Populating a parser dynamicallyAnother question today got an answer that shows how to populate a parser from values in a dictionary:  https://stackoverflow.com/a/35132772/901925Ipython does something similar.  It reads config files (default as well as user profile one(s)), and uses the config values to popular a parser.  That gives the user several levels of control - default config, profile config, and finally, commandline.  But the Ipython code is rather complex.Editing argument valuesAnother useful point, is that each argument, or Action object, is available after creation, and may (within limits) be modified.So it is possible dynamically set the default values before parsing.Prefix char fileAnother useful tool is https://docs.python.org/3/library/argparse.html#fromfile-prefix-charsallows me to specify the name of a file prefaced with the character.  It will read the files contents and splice the strings into the  list, just as though I had typed them it.  Filling in defaults after parsingHowever if you want to specify the config file in the commandline, and then use its contents to set defaults for the parser, things get more complicated.After parsing  will be a namespace object that contains the config file name along with all other arguments that it parsed.You can see the exact contents of  with , or in dictionary form as .  There's no hidden information about which values were set with the parser defaults and which were set by the commandline.The cleanest, post parsing test for defaults isIf the value is  it can only come from the default, not the commandline (there's no string that translates to ).So I can imagine writing a function that iterates through the keys of , testing for , and replacing it with the corresponding value from .  (Do you need help with that?).If both  and  are cast as compatible dictionaries, then you could use the dictionary  method to transfer values from one to the other.   can be used to keep an argument out of the namespace if the argument does not appear in the commandline.  https://docs.python.org/3/library/argparse.html#default.  This could be used along with the dictionary update, e.g.would only change  for arguments given in the commandline.Two stage parserAnother idea is to use two stage parsing.  Define one parser that has the  argument, and no (or few) others.  Run it with  to the get the  value.  Read the config file and use it to populate the 2nd stage parser (or at least to modify its defaults).  Now run the 2nd stage parser to get the full namespace (I'd just ignore any  values in this args).ChainMaphttps://docs.python.org/3/library/collections.html#chainmap-examples-and-recipesA newish  class,  has an example of chained value lookup from a namespace, env, defaults, etc.Other good ideas at Setting options from environment variables when using argparse


Answer URL
https://docs.python.org/3/library/argparse.html#fromfile-prefix-chars
https://docs.python.org/3/library/argparse.html#default
https://docs.python.org/3/library/collections.html#chainmap-examples-and-recipes
