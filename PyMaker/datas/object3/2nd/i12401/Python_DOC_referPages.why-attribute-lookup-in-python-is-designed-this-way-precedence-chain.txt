Natural Text
I've just ran into the descriptors in Python, and I got the ideas about the descriptor protocol on "__get__, __set__, __delete__", and it really did a great job on wrapping methods.However, in the protocol, there're other rules:Data and non-data descriptors differ in how overrides are calculated with respect to entries in an instance’s dictionary. If an instance’s dictionary has an entry with the same name as a data descriptor, the data descriptor takes precedence. If an instance’s dictionary has an entry with the same name as a non-data descriptor, the dictionary entry takes precedence.I don't get the point, isn't it ok just to look up in the classic way(instance dictionary -> class dictionary -> base class dictionary)?And if implement this way, data descriptors can be hold by instances, and the descriptor itself do not have to hold a  to hold values for different instances of the owner.Why put descriptors into the lookup chain? And why the data descriptor is placed in the very beginning?
Let's see on an example:The output:Try it yourself to get a taste on descriptors. But bottomline, what we see here is...First, definition from official docs to refresh the memory:If an object defines both  and , it is considered a  data descriptor. Descriptors that only define  are called  non-data descriptors (they are typically used for methods but other  uses are possible).From the output and failed snippets...It's clear that before the name referencing the descriptor(any type) is reassigned, the descriptor is looked up as usual following MRO from the class level to superclasses to the place where it was defined. (See Test 2, where it's defined in the instance and doesn't get called, but gets redefined with simple value.)Now when the name is reassigned, things start to be interesting:If it's a data descriptor (has ), then really no magic happens and the value assigned to the variable referencing the descriptor is passes to descriptors's  and is used inside this method (regarding the code above it's assigned to ). The descriptor is first looked up in hierarchy ofc. Btw, the descriptor without  is returned itself, not the value used with its  method.If it's a non-data descriptor (has only ), then it's looked up, but having no  method it's "droped", and the variable referencing this descriptor gets reassigned at lowest possible level (instance or subclass, depending on where we define it).So descriptors are used to control, modify, the data assigned to variables, which are made descriptors. So this makes sence, if a descriptor is a data descriptor, which defines , it probably wants to parse the data you pass and hence gets called prior to instance dictionary key assignment. That's why it's put in hierarchy at first place. On the other hand, if it's a non-data descriptor with only , it probably doesn't care for setting the data, and even more - it can't do anything to the data beign set, so it falls off from the chain on assignment and the data gets assigned to instance dictionary key.Also, new style classes are all about MRO (Method Resolution Order), so it affects every feature - descriptor, properties (which are in fact descriptors too), special methods, etc. Descriptors are basicly methods, that get called on assignment or attribute read, so it makes sence, that they are looked up at class level as any other method is expected to.If you need to control assignment, but refuse any change to variable use a data descriptor, but raise and exception in its  method.
First of all the classic way (actually it hasn't changed that much) is not what you describe. There is in reality not a base class in that sense, base classes are only something that is used during class creation. The classic lookup is first looking in the instance, and then in the class.The reason one introduces descriptors is to allow a cleaner way to customize attribute access. The classic way relied on there being lookupable functions to set and get attributes. The new way also allows for defining properties using the  decorator.Now for the reason one distinguish data and non-data (or RW and RO) descriptors. First one should note that it's reasonable to do the same lookup regardless of what type of access you're attempting (whether its read, write or delete):The reason the descriptor should take precedence with RO-descriptors is that if you have a RO descriptor your intention is normally that the attribute should be read only. This means that using the descriptor is proper in this case.On the other side if you have a RW-descriptor it would be useful to use the  entry to store the actual data.One should also note that a descriptor is properly placed in the class and not in the instance (and having the attribute lookup automatically call  if it finds an object with that method). Why it's not the other way is because if you place a descriptor in an instance you might want that attribute to actually refer to a descriptor and not what the descriptor would make you think it is (by calling  on it). For example:Now the last statement could be that we actually stored  in  for the purpose that  to return  instead of calling  which would return .
The issue is one of overloading. Let's imagine you have a  class, and you set one attribute of your object to an instance of that class:In this case, you have a non-data descriptor. Any code that accesses  will get a result of 1, due to the getter.But suppose you try to store to that attribute? What happens?Answer: a simple entry will be added to the instance dictionary, and  will point to whatever value was stored.In this case, if you subsequently read from , which value do you get back? The '1' returned by the get function, or the recently-stored "live" value that is listed in the dictionary?Right! In cases where a conflict appears, the descriptor silently fades away, and you are left with retrieving whatever it was that you stored.


Answer URL
https://docs.python.org/3/howto/descriptor.html#descriptor-protocol
