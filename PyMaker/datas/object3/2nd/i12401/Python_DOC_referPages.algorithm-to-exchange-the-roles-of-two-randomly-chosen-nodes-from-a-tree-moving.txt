Natural Text
I have created an algorithm whose purpose should be of, given two nodes A and B in a BST, it switches the roles (or positions in the tree) of the two by simply moving pointers. In my representation of a BST, I am using a double linked connection (i.e. A.parent == B and (B.left == A) or (B.right == A)). I am not sure if it's completely correct or not. I have divided the algorithm in two situations. A and B are directly connected (either A is the parent of B or B the parent of A)All the other casesFor each of the previous cases I have created a nested function. I would like to have your opinion on the first the correctness of the algorithms and if I can somehow then improve it. Here's the code:I really need that  works in all cases no matter which nodes  or  we choose. I have already done some tests, and it seems to work, but I am still not sure.EDITEventually, if it's helpful somehow, here you have the complete implementation of my BST (with the tests I am doing):https://github.com/dossan/ands/blob/master/ands/ds/BST.pyEDIT 2 (just a curiosity)@Rishav commented:I do not understand the intention behind this function.. if it is to swap two nodes in the BST, is it not sufficient to swap their data instead of manipulating pointers?I answered:Ok, maybe I should have added a little bit more about the reason behind all this "monster" function. I can insert  objects or any comparable objects in my BST. When the user decides to insert any comparable object, the responsibility of creating the  is mine, therefore the user has no access to a initial  reference, unless they search for the key. But a  would only be returned after the insertion of the key, or there's already another  object in the tree with the same key (or value), but this latter case is irrelevant.The user can also insert a  object in the tree which has an initial (and should remain constant) key (or value). Nevertheless, if I just exchanged the values or keys of the nodes, the user would have a reference to a node with a different key then the key of the node he inserted. Of course, I want to avoid this.
you need proper unit testing. I recommend python-nose - very easy to use.As for the test vectors I'd recommend using every potential combination of two nodes a and b:In the case of BSP trees you have 3 types of nodes:leaf node,1-child node,2-children node.in combination with the following additional cases:a is root, ora is the parent of b,a is not the parent of b.and their combinations as well (also in the symmetric situation).then after swapping you'll need to check all the nodes involved i.e.:a,b, children of a and b, parents of a and b if everything went as planned.I'd do that using a small tree that contains all the types of nodes.Then go through all possible combinations of the nodes and swap the nodes and check against the expected outcome, and then swap again to bring the tree back to its original state.[ EDIT ]If your question was how to avoid all the tedious work. You may consider looking for some well established BSP implementation and compare results with your function. Vectors can be created automatically by using a prepared tree and generating all possible pairs of nodes of this tree.[/EDIT]As for the unwanted input to the function. You'll need to use your imagination although in my opinion you have most of the cases covered. Except the one that Austin Hastings mentions where at least on of the input nodes does not belong to the tree.I found an old version of the same function written for one of my private projects, maybe you can find it useful:and performance optimised version:I haven't done proper unit tests for this code - it worked as I expected it to. I was more interested in performance differences between the implementations.  handles neighbouring nodes a bit faster giving it around 5% of speed increase over the compact implementation of . [EDIT2] But that depends on the tree used for testing and hardware [/EDIT2]
Your  defines . Members of that class have an element,  that can point to a node. Your code, as shown, does not account for this.I believe you need to handle these cases:Swap the root node with one of its children.Swap the root node with a non-child.Swap a non-root node with one of its children.Swap a non-root node with a non-child non-root node.Edit: After re-examining switch_1, I think you do handle all the cases.Also, there is the possibility that a caller could request you swap a node that is not a member of the tree for a node that is a member. Or swap two nodes that are both not members of the current tree. It would cost some code to detect these cases, but you could probably get by with a  or  to trace tree membership. I don't know if you want to consider "swap-ins" as a valid operation or not.In several places you compare nodes using  That is an operation that can be overridden. You should use  and  for identity comparisons and comparisons against Finally, please consider Pythonifying your  class. It is a mutable iterable container, so it should support the standard operations as much as possible.


Answer URL
https://docs.python.org/3/library/stdtypes.html?highlight=container#sequence-types-list-tuple-range
