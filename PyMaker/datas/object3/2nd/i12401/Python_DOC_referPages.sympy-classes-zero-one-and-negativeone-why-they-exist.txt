Natural Text
Today I found thisI looked the documentation from sympy about those types, but it doesn't say anything about why they exist. Is there a reason to have 3 special singleton classes for -1, 0 and 1? Edit: I saw this at the SymPy online shell
Every number in SymPy is represented by an instance of the class.s, s and s are subclasses of .  is asubclass of .You can inspect the full class lineage of an object by calling its class's  (method resolution order) method:These subclasses "teach" SymPy how to manipulate and simplify expressions symbolically. As aexample, instances of the Rational class are negated thisway:That is to say, if  is an instance of , then  causes  to be called. Meanwhile, instances of the  class, are negated byAnd if the object is, in particular, an instance of , then its negation isdefined by:,  and  also implement a  method which"teaches" these objects how to evaluate  raised to a power (where  is,  or ). For example,  raised to a positiveexpression equals itself: raised to anything equals itself: If you peruse the source code for the  module, you'll findloads of definitions which are in effect teaching SymPy how to do symbolicarithmetic. It's not too different from what children are taught in math class, except that it is expressed in computer-ese.You might be wondering why there isn't a special class for every integer. besides ,  and  are treated as instances of thegeneral  class. Their rules of addition and multiplication and so on are laid out there. Unlike ,  and  which are instantated when the module is loaded, other Integers are cached only as needed:
First, note that  gave you  because SymPy Live wraps integer literals in  automatically (this is to avoid a gotcha where  evaluates to  instead of ). But note that in a regular Python session  is . There are several objects in SymPy which are implemented as singletons, meaning only one instance will ever exist. You can see these all on the  object(ignore the ones that start with ; those are Python internal methods)The reason this is done is that these objects are used a lot. 0, 1, and -1 are very common objects. Every time you write  it is represented internally as .  is represented as . For 0, it appears quite often in all sorts of symbolic calculations. 1 is also common. By having a single instance, SymPy enables two optimizations. First, it saves memory. Second, you can compare against these objects using  comparison, like . Because only one instance can ever exist  is always the same as . (also, I should note that some of the objects in  aren't actually that common, like  and . I guess they were added more for convenience than anything)


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__neg__
