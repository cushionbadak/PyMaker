Natural Text
I have a list of lists that I am searching through to find the indices of duplicates. The intended outcome is:But instead I am getting:If I include the enumerate within the in-line for loop (see example below), I receive the correct answer but see a significant reduction in speed. How can I perform this task without losing the enumerate information stored in enum_listA?
 returns an iterator which can only be iterated once. So once it is exhausted, which is the case after you iterate it in the list comprehension of the first for loop iteration, it will not yield any more items.If you want to keep the information, you will have to actually store that data in memory, for example as a list:Note that this effectively duplicates the information in the list and adds the indexes, so this is wasting a lot of extra memory and might not end up being more efficient than recreating the enumerate object over and over.The performance difference you are seeing however comes from the fact that after the first loop iteration, the enumerator is empty, so the list comprehension no longer runs for subsequent iterations.
use a  and a  and your code will run a lot more efficiently:Output:If you want to maintain the order first seen:output:Whatever way you use enumerate, your complexity is still quadratic, this will be considerably faster than your own approach.Some timings on a random data set:  times faster.
The reason you are seeing a significant reduction in speed (by your terminology) is that your second, correct version is actually computing the values you are looking for.Because enumerate produces a generator, once you consume its values, you cannot produce them again. The second version you have presented is the correct way of using enumerate.Side not, I'm not sure how your code is working at all. You are calling a list, a non-callable objectMaybe, you meant to do


Answer URL
https://docs.python.org/3/library/functions.html#enumerate
