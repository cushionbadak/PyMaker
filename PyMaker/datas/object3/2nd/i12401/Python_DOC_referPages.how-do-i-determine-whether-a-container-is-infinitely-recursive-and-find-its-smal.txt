Natural Text
I was reading Flatten (an irregular) list of lists and decided to adopt it as a Python exercise - a small function I'll occasionally rewrite without referring to the original, just for practice. The first time I tried this, I had something like the following:This works fine for basic structures like nested s containing numbers, but strings crash it because the first element of a string is a single-character string, the first element of which is itself, the first element of which is itself again, and so on. Checking the question linked above, I realized that that explains the check for strings. That gave me the following:Now it works for strings as well. However, I then recalled that a  can contain references to itself.So, a string isn't the only type that could cause this sort of problem. At this point, I started looking for a way to guard against this issue without explicit type-checking.The following  ensued.  is a version that just checks for strings.  checks whether an object's first item's first item is equal to itself to determine recursion.  does this and then checks whether either the object or its first item's first item is an instance of the other's type. The  class basically just defines a wrapper for sequences. The comments on the lines that test each function describe the results, in the form . As you can see, each fails in various ways on  wrapped around a string,  wrapped around a  of integers, single-character strings, and multiple-character strings.I've also tried the following with the recursive  defined above and :As you can see, it fails similarly to  as well as in its own special way.I read how can python function access its own attributes? thinking that maybe the function could keep track of every object it had seen, but that wouldn't work either because our  contains an object with matching identity and equality, strings contain objects that may only have matching equality, and equality isn't enough due to the possibility of something like .Is there any reliable way (i.e. doesn't simply check known types, doesn't require that a recursive container and its containers all be of the same type, etc.) to check whether a container holds iterable objects with potential infinite recursion, and reliably determine the smallest unique container? If there is, please explain how it can be done, why it is reliable, and how it handles various recursive circumstances. If not, please explain why this is logically impossible.
I don't think there's a reliable way to find out if an arbitrary iterable is infinite. The best we can is to yield primitives infinitely from such an iterable without exhausting the stack, for example:The above definition of "primitive" is, well, primitive, but that surely can be improved.
There's an issue with your test code that's unrelated to the recursive container issue you're trying to solve. The issue is that your  class is an iterator and can only be used once. After you iterate over all its values, it will always raise  when you try to iterate on it again.So if you do multiple operations on the same  instance, you shouldn't expect to get anything be empty output after the first operation has consumed the iterator. If you recreate the iterator before each operation, you won't have that problem (and you can actually try addressing the recursion issue).So on to that issue. One way to avoid infinite recursion is to maintain a stack with the objects that you're currently nested in. If the next value you see is already on the stack somewhere, you know it's recursive and can skip it. Here's an implementation of this using a list as the stack:Note that this can still yield values from the same container more than once, as long as it's not nested within itself (e.g. for  will print ).It also does recurse into strings, but it will only do so for only one level, so  will yield the letters ,  and  in turn. If you want to avoid that, you probably do need the function to be type aware, since from the iteration protocol's perspective, a string is not any different than an iterable container of its letters. It's only single character strings that recursively contain themselves.
The scenario you ask about is very loosely defined.  As defined in your question, it is logically impossible "to check whether a container holds iterable objects with potential infinite recursion[.]"  The only limit on the scope of your question is "iterable" object.  The official Python documentation defines "iterable" as follows:An object capable of returning its members one at a time. Examples of iterables include all sequence types (such as list, str, and tuple) and some non-sequence types like dict, file objects, and objects of any classes you define with an  or  method. [...]The key phrase here is "any classes [defined] with an  or  method."  This allows for "iterable" objects with members that are generated on demand.  For example, suppose that someone seeks to use a bunch of string objects that automatically sort and compare in chronological order based on the time at which the particular string was created.  They either subclass str or reimplement its functionality, adding a timestamp associated with each pointer to a  object, and adjust the comparison methods accordingly.Accessing a substring by index location is a way of creating a new string, so a  of  could legitimately return a  of  with the same character but a new timestamp when you access .  Because the timestamp is part of the specific object instance, there is no kind of identity test that would say that the two objects are the same unless any two strings consisting of the same character are considered to be the same.  You state in your question that this should not be the case.To detect infinite recursion, you first need to add a constraint to the scope of your question that the container only contain static, i.e. pre-generated, objects.  With this constraint, any legal object in the container can be converted to some byte-string representation of the object.  A simple way to do this would be to pickle each object in the container as you reach it, and maintain a stack of the byte-string representations that result from pickling.  If you allow any arbitrary static object, nothing less than a raw-byte interpretation of the objects is going to work.However, algorithmically enforcing the constraint that the container only contain static objects presents another problem: it requires type-checking against some pre-approved list of types such as some notion of primitives.  Two categories of objects can then be accommodated: single objects of a known-static type (e.g. primitives) and containers for which the number of contained items can be determined in advance.  The latter category can then be shown to be finite when that many contained objects have been iterated through and all have been shown to be finite.  Containers within the container can be handled recursively.  The known-static type single objects are the recursive base-case.If the container produces more objects, then it violates the definition of this category of object.  The problem with allowing arbitrary objects in Python is that these objects can be defined in Python code that can use components written in C code and any other language that C can be linked to.  There is no way to evaluate this code to determine if it actually complies with the static requirement.
What about something like this:After a finite number of (recursion) steps a list will contain at most itself as iterable element (Since we have to generate it in finite many steps). That's what we test for with  where  in an element of .The list  keeps track of all elements since we want each element only once. We could remove it but we'd get an ugly (and more importantly not well-defined) behaviour on which elements get yield how often.Drawback is that we store the entire list at the end in the list ...Testing this with some lists seems to work: Note: It actually makes sense that the infinite lists  and  are considered as elements since these actually contain themselves but if that's not desired one can comment out the first  in the code above.
Just avoid flattening recurring containers. In the example below  keeps track of them and  ignores containers of a certain type. I believe this works down to python 2.3.It can flatten circular lists like  and keep some containers like strings and dicts un-flattened.It also works with the following case:You may want to keep some default classes in  to make calling  the function more terse.


Answer URL
https://docs.python.org/3/glossary.html#term-iterable
