Natural Text
I have a text file with 32 articles. Each article starts with the expression: , for example: , , etc. In order to find each article I have used the following code:So now, articles are represented by the expression The next thing I want to do, is to subgroup the articles in 2 groups. Those articles containing the words: economy OR economic AND uncertainty OR uncertain AND tax OR policy, identify them with the number 1. Whereas those articles containing the following words: economy OR economic AND uncertain OR uncertainty AND regulation OR spending, identify them with the number 2. This is what I have tried so far:Nevertheless, it does not seem to work. Any ideas why?
It's a bit wordy, but you can get away without using regular expressions here, for example:
It is possible to write this as a single regular expression, but it is a bit tricky. For each  you'd use a zero-width lookahead assertion , and for each  you'd use a branch. Also, we'd have to use the  for a word boundary. We'd use  instead of .Thus not very readable.A more fruitful approach would be to find all words and put them into a set
You can use re.search to find those words. Then you can use if statements and python's  and  statements for the logic, and then store group one and two as two lists with the section index number as a value.One thing you might want to note is that your logic may need brackets. Byeconomy OR economic AND uncertainty OR uncertain AND tax OR policyI assume you mean(economy OR economic) AND (uncertainty OR uncertain) AND (tax OR policy)which is different to (for example)economy OR (economic AND uncertainty) OR (uncertain AND tax) OR policyEDIT1: Python will evaluate your statement without brackets from left to right, i.e.:( ( ( ( (economy OR economic) AND uncertainty) OR uncertain) AND tax) OR policy)Which I imagine is not what you want (e.g. the above evaluates true if it includes the word policy but none of the others)EDIT2:As pointed out in comments, EDIT1 is incorrect, although you would still need brackets to achieve case 1, if you don't have them you will get case 2 instead (and case 3 is a load of rubbish)


Answer URL
https://docs.python.org/3/howto/regex.html
