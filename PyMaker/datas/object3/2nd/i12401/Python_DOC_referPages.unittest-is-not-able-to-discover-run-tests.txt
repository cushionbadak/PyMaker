Natural Text
There are some related questions, but none apply.This is my directory tree: is not able to find anything:Not even from within :What I have already verified:my test methods are properly named ()my testcases extend the  and the  directories have an (empty) all test modules are importable (see below) finds the tests, but has problems with relative imports (see below) is able to discover and run the tests, no problemsI would like to understand:why do I need to pass  to  to force it to discover the tests? What does  do without the  sub-command? (I thought unittest does test discovery by default). According to the documentation: python -m unittest is the equivalent of python -m unittest discoveronce the tests are discovered (by forcing the  sub-command), why do I have import issues?Test modules are importableunittest discover has problems with relative importsIf I run it from the top dir:If I run it from within :
I reproduced all the problems with CPython 3.5, so my answer shouldbe relevant to both 3.4 and 3.5.Relative import issuesThe reason why there are issues with relative imports is that due tospecifics of invocations you really do not import  package.First, let’s take a look at When you run tests from top that way,  is just not imported.That is because  is added to sys.path insteadof . To solve this problem, doNow, about the in-abc_backend invocation. When you do is not importable, as dir does not contain  package. This too can be solved withthat will correctly put  dir (pun intended) into .The  (or ) option sets top level directoryof project and defaults to start directory (which is  by default).So, what is in  is important, as that affects imports, whichaffect test loading, as discovery loads tests using import machinery.Difference between  and When you doin reality you are running  file. There is invoked, and eventually you get to that doesAs  does not contain any test cases, returns for all module members (so  is empty).To make this particular way of invocation work, you’ll have to dowhat people usually did in pre- times (aside from non-stdlibframeworks): manually import cases from test modules (ormaybe construct test suite according to  protocol).So, how differs?Basically, differences may be expressed as following conditional:When  is ,actual discovery mechanism is used. When  is , is used, which calls  at some point, and no tests are found.That’s the way things are in .
I encountered similar problem today, actually the solution was written in the Python API document:If a package (a directory containing a file named init.py) is found, the package will be checked for a load_tests function. If this exists then it will be called package.load_tests(loader, tests, pattern). Test discovery takes care to ensure that a package is only checked for tests once during an invocation, even if the load_tests function itself calls loader.discover.Hence, all you need to do is write a load_tests function and register your TestCase classes in __init__.py


Answer URL
https://docs.python.org/3/library/unittest.html#unittest.TestLoader.discover
