Natural Text
I know I'm not supposed to modify the list inside a loop, but just out of curiosity, I would like to know why the number of iterations is different between the following two examples.Example 1:Example 2:Example 1 runs only 3 times because when , . Example 2 runs 5 times even though .So my question is, does  generate a full list of  pairs at the beginning of the loop and iterate through it? Or are they generated on each iteration of the loop?
enumerate() returns an iterator, or some other object which supports iteration. The __next__() method of the iterator returned by enumerate() returns a tuple containing a count (from start which defaults to 0) and the values obtained from iterating over iterable.__next__() returns the next item from the container. If there are no further items, raise the  exception.Does enumerate() generate a full list of (index, value) pairs at the beginning of the loop and iterates through it? Or are they generated on each iteration of the loop? So,  returns an iterator and at every iteration,  checks if there are further items.  doesn't create a full list at the beginning of the loop. As, @Wisperwind mentioned, in your second case, you're assigning a new object to the name . The object, the loop iterates over does not change during the iteration.
In the first example, you're actually modifying the list you're iterating over.On the other hand, in the second case, you're only assigning a new object to the name . The object the loop iterates over does not change, though.Have a look at http://foobarnbaz.com/2012/07/08/understanding-python-variables/ for a more detailed explanation about names and variables in Python.
Just a clarification to what Wasi Ahmad and Wisperwind have said.  Both state that "you're only assigning a new object to the name x".  This might be slightly confusing as it might be interpreted as saying "you're creating a new object () and storing it to the name , to which you'd say "Well yah, so why isn't it changing?!"  To see what's happening, print out the id of the object You'll notice that the  of  is changing each time through the loop and when you're finished with the loop,  will point to the last modification made in the loop.  When you're going through your loop, it is iterating over the original instance of x, regardless of whether you can still reference it.  As you can see,  points to the original .  As you make your iterations through the loop, even though  is changing,  is still pointing to the original  which is still being looped over.
Indeed: Your first snippet modifies the iterated-over list in place; the second points the variable  to a new list, leaving unmodified the list transversed by . You can see this in action by going to the following links on www.pythontutor.com, which allow you to single-step over your code and visualize the contents of your variables:First version ( is modified in place).Second version ( is redirected to ).To better see what's going on, go here instead to step over the following expanded code:
Others have already pointed out that your second example only changes the value to which  points, but not the list over which you're iterating. This is a perfect example for the difference between ordinary assignment () and slice assignment (). The latter modifies the list  points to in-place:will print
The list  is 'tagged' with enumerate() attaches another tag, so  is now tagged  and . enumerate() will continue using the  tag, not the  tag. The list stored in memory is modified, so  and  now both refer to Alternatively, when you useA new list  is created in memory, and the  tag now points to that. The  tag is still pointing to the original list.How Python variable work:http://foobarnbaz.com/2012/07/08/understanding-python-variables/


Answer URL
https://docs.python.org/3/library/functions.html#enumerate
https://docs.python.org/3/library/stdtypes.html#iterator.__next__
https://docs.python.org/3/library/functions.html#enumerate
https://docs.python.org/3/library/stdtypes.html#iterator.__next__
