Natural Text
I was looking for a solution to finding the symmetric difference between two dictionaries in Python.For example, if I have two dictionaries A and B, and I want to create a third dictionary C which contains all the items from A and B that are not found in the other, or in other words, unique. I could not find a canonical answer, so I decided to open this question and give it my own answer. If you think you have a better method, I would love to see it.Some data:Desired output:
Here is some code that does timeit speed tests on the various algorithms.The tests use pairs of dicts of equal sizes. The keys are short random letter strings, with varying proportions of shared keys between the dicts. The dicts are constructed from shuffled lists, so even if they contain lots of shared keys the underlying hash table structure of the two dicts should be rather different.The exact amount of shared keys is random, the proportion of shared keys is controlled by the  arg of . The main body of this code will run on Python 2.6+ and Python 3. I have Python 2.6.6 and Python 3.6.0 installed on this machine (which is a single core 32 bit machine with 2GB of RAM running on an old Debian derivative of Linux). Some of the dictionary symmetric difference functions use dictionary comprehensions, which aren't available in Python 2.6, so I couldn't test those functions on Python 2. Also,  won't run on Python 3, so I've commented it out. I was originally going to post Python 2.6 results too, but I had to reduce the output to fit within the message size limits.output
To get the symmetric difference between two dictionaries use the following robust function:Just the logic:Here is a simpler version of the function for explanation:Explanation of the  expression:It is a ternary operator which allows me to use it like so: With this trick, I get the value for the key, no matter which dictionary it is in.Using either Function:
A symmetric difference is equal to the union minus the intersection:
The  View object is set-like, and it supports the  symmetric_difference operator. From the docs:Keys views are set-like since their entries are unique and hashable.  [...] For set-like views, all of the operations defined for the  abstract base class collections.abc.Set are available (for example,  ==, <, or ^).To handle the problem with false-ish values that arises by using the  expression in Inbar Rose's original solution we can just use an  test; if the key isn't in  it must be in , so we only need 1  test.outputPython 2 doesn't have dictionary view objects, so in Python 2 you need to wrap the  calls with . Versions of Python prior to 2.7 don't support the dictionary comprehension, but you can pass a generator expression to the  constructor, unless you're running a really ancient version of Python.Here's a version that will run correctly on Python 2.4+:We can avoid making two calls to set by using the  method instead of the  operator, since the non-operator versions of the various set operations will accept any iterable as an argument. So we can doinstead ofAs Martijn Pieters has pointed out in the comments, dictionary view objects have been backported to Python 2.7. The syntax is slightly different than in Python 3 to avoid breaking code which uses the , , and  methods. To get the keys view object use the  method.  is much more efficient than . Dictionary view objects also have the benefit that they're dynamic, i.e., they reflect any changes made to the dictionary, whereas  has to be called again if any changes are made to . That's not an issue for this code, but it's a great feature when you do need it.
This is how I would do it:
Very shortIn case you feel uncomfortable about speed and suspect Python to do  at each iteration you can just use this code:


Answer URL
https://docs.python.org/3/library/timeit.html
https://docs.python.org/3/library/stdtypes.html#dict-views
