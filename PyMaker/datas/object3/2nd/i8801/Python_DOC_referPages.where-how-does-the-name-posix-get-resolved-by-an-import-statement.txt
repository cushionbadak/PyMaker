Natural Text
What happens behind the scenes (in CPython 3.6.0) when code uses ?  This module doesn't have a  attribute.  When starting the interpreter in verbose mode, I see this line:It's already present in  in a newly openened interpreter, and importing it just binds a name to the existing module.  I'm trying to look at implementation detail of  on my platform to determine if and when it uses .  
Here, have more detail than you're likely to need. is a built-in module. When you hear "built-in module", you might think of ordinary standard library modules, or you might think of modules written in C, but  is more built-in than most.The  module is written in C, in . However, while most C modules, even standard library C modules, are compiled to  or  files and placed on the import path like regular Python modules,  actually gets compiled right into the Python executable itself.One of the internal details of CPython's import system is the  array:This is an array of s, which consist of a name and a C module initialization function for the module with that name. Modules listed here are built-in.This array is initially set to , which comes from  (or  depending on your OS, but that's not the case here). Unfortunately,  is generated from  during the Python build process, so I can't show you a source code link, but here's part of what it looks like when I generate the file:As you can see, there's an entry for the  module, along with the module initialization function, .As part of the import system, when trying to load a module, Python goes through , a list of module finders. One of these finders is responsible for performing the  search you're likely more familiar with, but one of the others is , responsible for finding built-in modules like . When Python tries that finder, it runs the finder's  method:which uses  to search  for the  name. The search finds the name, so  returns a module spec representing the fact that the loader for built-in modules should handle creating this module. (The loader is the second argument to . It's  here, because  is both the finder and loader.)Python then runs the loader's  method to generate the module object:which delegates to , which searches  for the module name and runs the corresponding initialization function.( just calls , but part of the import system treats it as a magic indicator to strip  frames from stack traces, which is why you never see those frames in the stack trace when your imports go wrong.)If you want to see more of the code path involved, you can look through , where most of the import implementation lives, , where most of the C part of the implementation lives, and , which is where the bytecode interpreter loop lives, and thus is where execution of an  statement starts, before it reaches the more core parts of the import machinery.Relevant documentation includes the section of the language reference on the import system, as well as PEPs 451 and 302. There isn't much documentation on built-in modules, although I did find a bit of documentation targeted toward people embedding Python in other programs, since they might want to modify , and there is the  list.


Answer URL
https://docs.python.org/3/reference/import.html#finders-and-loaders
https://docs.python.org/3/reference/import.html
https://docs.python.org/3/c-api/import.html#c._inittab
https://docs.python.org/3/library/sys.html#sys.builtin_module_names
