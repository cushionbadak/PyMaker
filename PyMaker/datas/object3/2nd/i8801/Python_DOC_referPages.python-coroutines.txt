Natural Text
I have a little bit of experience with promises in Javascript. I am quite experienced with Python, but new to its coroutines, and there is a bit that I just fail to understand: where does the asynchronicity kick in?Let's consider the following minimal example:As I understand it,  puts execution of our function aside and lets the main program run other bits. At some point  has a new result and  will have a result soon after.If  and  are coroutines, then by all internet wisdom they are generators. And the only way to know when a generator has a new item available, afaik, is by polling it: . But this is blocking! How does the scheduler "know" when  has a result? The answer can't be "when  has a result" because  must be a generator, too (for it is a coroutine). And this argument applies recursively.I can't get past this idea that at some point the process will just have to sit and wait synchronously.
The secret sauce here is the  module. Your  object has to be an awaitable object itself, and either depend on more awaitable objects, or must yield from a  object. For example, the  coroutine yields a :(The syntax here uses the older generator syntax, to remain backwards compatible with older Python 3 releases).Note that a future doesn't use  or ; they simply use  until some condition is met. In the above  coroutine, that condition is met when a result has been produced (in the  code above, via the  function called after a delay).An event loop then keeps pulling in the next 'result' from each pending future it manages (polling them efficiently) until the future signals it is done (by raising a  exception holding the results;  from a co-routine would do that, for example). At that point the coroutine that yielded the future can be signalled to continue (either by sending the future result, or by throwing an exception if the future raised anything other than ).So for your example, the loop will kick off your  coroutine, and  then (directly or indirectly) yields a future. That future is polled until it raises  (signalling it is done) or raises some other exception. If the future is done,  is executed, allowing it to then advance to the  line, triggering a new  exception with that value, allowing a calling coroutine awaiting on  to continue, etc.


Answer URL
https://docs.python.org/3/library/asyncio.html
https://docs.python.org/3/library/asyncio-eventloop.html#futures
