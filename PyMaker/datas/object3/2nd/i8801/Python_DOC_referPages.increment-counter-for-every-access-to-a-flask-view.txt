Natural Text
I want to increment a counter when users access a page in my Flask app. If two users access the page, the count should increase by 2. I tried the following but the count is always 1. How do I increment the value for each access?
Counting concurrently is hard. Assume the count is 0. If two users both hit the endpoint at close enough intervals, they may each get the value 0, increment it to 1, and put it back. Two users hit the endpoint, but the resulting count is 1, not 2. To get around this, you need to use a data store that supports incrementing atomically (as in, an operation that only one process can do at a time).You can't use a simple Python  because WSGI servers will spawn multiple processes, so they will each have their own independent copy of the global. Repeated requests could be handled by different processes, resulting in different, unsynchronized values.The simplest solution is a Python . This synchronizes access to a shared value across processes, as long as the processes are spawned after the value is created.There are still some caveats:The data only persists as long as the manager is alive. If you restart the server, the counter resets too.If the application processes are distributed across multiple machines, shared memory suffers the same issues as globals: they are only synchronized on the local machine, not across the network.For real world scenarios, Redis is a much more robust solution. The server is independent of the web application, has options for persistence, and can do atomic increments. It can also be used for other parts of the application, such as caching.
There is a small gotcha in the accepted answer from @davidism. The  is accessed outside of the lock, so there is still a chance for duplicate values if you are unlucky.Here is an example showing that collision. It also shows how this collision is possible if you are using asyncronous code (asyncio has it's own locking mechanisms).Here is the output of the above:Luckily, you are using Flask which is synchronous, so the async problem isn't a concern for your use case.So, I would suggest changing the accepted answer to store the lock inside the context and then release the lock ASAP. If you were to call jsonify or anything else you would keep the lock while doing operations which don't require it.


Answer URL
https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Value
