Natural Text
Edit:The reason I as getting strange results was that the dictionary I was using(https://github.com/dwyl/english-words/blob/master/words_alpha.txt) contained many values that were not really words. The code I have below all works as it should. I thought it was because of the  line but I was wrongThis is my code:Shell
As roganjosh observes, the behavior you describe does not happen.You offered a two-letter input word, . My dictionary lists 160 "valid" two-letter combinations, nearly a quarter of the 676 possible combinations. I don't know exactly what input dictionary you used, but this effect may account for producing lots of  scores. For example I notice "mw" may correspond to megawatt, plus I see some ISO-3166 two-letter country codes in your output. The dictionary I use is the  supplied with OS/X.To debug, simply use a print statement after incrementing the score:That will highlight the "surprising"  values.Python's  operator is behaving exactly as documented.EDIT:People mostly compile word lists to support spell-checking applications, which will tend to favor erring on the side of including everything. A moment's googling yields lots of word lists, but the first one I grabbed, from infochimps, turned out to have 427 two-letter words, an impressive 63%. Perhaps SCOWL would prove relevant.You might want to use the enclosed (platform-neutral) code to access a fairly reasonable corpus of English words.What you really want here is unigram frequency. That is, rather than scoring a win for a two-letter word based on some boolean  function, you would prefer to give a higher score to a common word like  and some smaller positive score for a less common word like  or .I rather like the suggestion from Dunes about paying more attention to longer words. Suppose we lack unigram frequency numbers, and so are forced to assume a uniform prior on n-letter words, e.g.  and  are equally likely to appear in the plaintext. Count up the number of n-letter words in your dictionary, divide by , and use that fraction in your scoring.Levenshtein distance combined with  would improve resiliency to typos in the plaintext.
You code works fine for me.Are you sure the problem is not in the counter?The following code below for me is returning 'two', like is supposed to:


Answer URL
https://docs.python.org/3/reference/expressions.html#in
