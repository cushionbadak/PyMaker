Natural Text
Searching for this topic I came across the following: How to represent integer infinity?I agree with Martijn Peeters that adding a separate special infinity value for  may not be the best of ideas.However, this makes type hinting difficult. Assume the following code:However, the code behaves everywhere just the way as it should. And my type hinting is correct everywhere else.If I write the following instead:I can assign  without a hitch. But now any other float is accepted as well.Is there a way to properly constrain the type-hint? Or am I forced to use  each time I assign infinity?
The super lazy (and probably incorrect) solution:Rather than adding a specific value, the  class can be extended via subclassing.  This approach is not without a number of pitfalls and challenges, such as the requirement to handle the infinity value for the various  methods (i.e. , ,  and the like, and all of these should be tested).  This would be an unacceptable amount of overhead in the use cases where a specific value is required.  In such a case, wrapping the desired value with  would be able to better indicate to the type hinting system the specific value (i.e. ) be acceptable for assignment.The reason why this approach is incorrect is simply this: since the value assigned looks/feels exactly like some number, some other users of your API may end up inadvertently use this as an  and then the program may explode on them badly when  (or variations of such) be provided.An analogy is this: given that lists have items that are indexed by positive integers, we would expect that any function that return an index to some item be some positive integer so we may use it directly (I know this is not the case in Python given there are semantics that allow negative index values be used, but pretend we are working with say C for the moment).  Say this function return the first occurrence of the matched item, but if there are any errors it return some negative number, which clearly exceed the range of valid values for an index to some item.  This lack of guarding against naive usage of the returned value will inevitably result in problems that a type system is supposed to solve.In essence, creating surrogate values and marking that as an  will offer zero value, and inevitably allow unexpected and broken API/behavior to be exhibited by the program due to incorrect usage be automatically allowed.Not to mention the fact that infinity is not a number, thus no  value can properly represent that (given that  represent some finite number by its very nature).As an aside, check out  vs .  One of these have a return value that definitely violate user expectations (i.e. exceed the boundaries of the type positive integer; won't be told that the return value may be invalid for the context which it may be used at during compile time, results in potential failure randomly at runtime).Framing the question/answer in more correct terms:Given the problem is really about the assignment of some integer when a rate exist, and if none exist some other token that represent unboundedness for the particular use case should be done (it could be some built-in value such as  or ).  However as those tokens would also not be  values, it means  would actually need a type that encompasses those, and with a way to apply operation that would do the right thing.This unfortunately isn't directly available in Python in a very nice way, however in strongly static typed languages like Haskell, the more accepted solution is to use a  type to define a number type that can accept infinity.  Note that while floating point infinity is also available there, it inherits all the problems of floating point numbers that makes that an untenable solution (again, don't use  for this).Back to Python: depending on the property of the assignment you actually want, it could be as simple as creating a class with a constructor that can either accept an  or  (or ), and then provide a method which the users of the class may make use of the actual value.  Python unfortunately do not provide the advanced constructs to make this elegant so you will inevitably end up with code managing this be splattered all over the place, or have to write a number of methods that handle whatever input as expected and produce the required output in the specific ways your program actual needs.Unfortunately, type-hinting is really only scratching the surface and simply grazing over of what more advanced languages have provided and solved at a more fundamental level.  I supposed if one must program in Python, it is better than not having it.


Answer URL
https://docs.python.org/3/library/typing.html#typing.cast
