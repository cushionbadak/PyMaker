Natural Text
I have a numPy array e.g.  and I want to sum over the elements after each element resulting in .In a loop, that can be done as:
You can use numpy's cumulative sum function for this. You need to reverse the original array first, and then reverse the result to get it in the order you want:Alternatively use  to reverse:The answers to this question include a full discussion of different options for calculating a cumulative sum in python. itertools.accumulate seems a good option in Python 3.2 or newer.
You can use numpy's ufuncs and their accumulate function to get the desired output. 
Here's a concise (albeit costly) way to do it:Although it is a non-procedural (conceptual) approach using only matrix operators, it is by far the slowest solution.I played around with the various solutions proposed here, and a few of my own to see which approach would be fastest.  Here are the results:All the numpy functions come dead last on a small list.The same test performed on a much larger array: [1,2,3,4]*100 (repeated 10000 times instead of 100000) gives different results reflecting the scalability of these solutions:numpy starts to show its power on large arrays but still not the best for this type of problem. The itertools  module (accumulate) seems to be the most scalable approach.Here are the functions ...
Sum once, append the current total  to the result array  and deduct the current value .It's not a Numpy array though, is that bit important?Some other answers appear to sum the remainder of the on each iteration. Which seems inefficient to me.As pointed out by @User2699 reversing the array and simply adding the numbers together is the most efficient way to accomplish this.The fastest way I could find to do that is with a generator:UpdateI found it interesting how much faster Numpy Arrays appeared to be with the Numpy based scripts. So I ran some further tests to see why that was. What I realised is that I hadn't taken in to account the way the lists were being generated. Each method for creating the lists has a different amount of overhead which for the most part accounts for the difference in speeds. The standout exception being  which is much faster with Numpy based scripts.Benchmarks: https://repl.it/repls/SumEachItemAfterBenchmark Gist: https://gist.github.com/sarcoma/8fc4b87c3cf649d6ef9af92bffe5a771
May be you can try simply with :
I think that you mean after instead of before. To sum the elements after each element do the following:Or you can also use the list comprehension notation to make it shorter and much more elegant:However, this may lead to bad performance when list is big enough. The best solution in terms of efficiency would be to iterate over the list backwards computing only the sum of the last element seen and the current one, as the last is the sum of all its previous ones:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.accumulate
