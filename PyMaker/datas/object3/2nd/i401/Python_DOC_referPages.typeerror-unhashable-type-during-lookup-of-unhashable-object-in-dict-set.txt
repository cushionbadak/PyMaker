Natural Text
PrefaceI understand that s/s should be created/updated with hashable objects only due to their implementation, so when this kind of code failsit's ok and I've seen tons of this kind of messages.But if I want to check if some unhashable object is in /I get error as wellProblemWhat is the rationale behind this behavior? I understand that lookup and updating may be logically connected (like in  method), but shouldn't it fail on modification step instead of lookup? Maybe I have some hashable "special" values that I handle in some way, but others (possibly unhashable) -- in another:so with given lookup behavior I'm forced to use one of the optionsLBYL way: check if  is hashable and only after that check if it is one of  (which is not great since it is based on  structure and lookup mechanism restrictions, but can be encapsulated in separate predicate),EAFP way: use some sort of utility for "safe lookup" likeuse / for  (which is not  on lookups).Or am I missing something trivial?
As you have no doubt realized, sets and dicts are very similar in their inner workings. Basically the concept is that you have key - value pairs (or just keys with a set), and the key must never change (immutable). If an object were mutable, the hash would loose it's meaning as a unique identifier of the underlying data. If you can't tell if an object is unique or not, the meaning of a set of unique keys looses it's key property of uniqueness. This is why mutable types are disallowed in sets and as the keys of a dict. With your example:  I think you have a slight misunderstanding, as  only checks the keys of the dict, not the values. Since you can never have a dict as a key (because it's mutable) this is invalid.
I've found this issue on Python bug tracker. Long story short:if returned  it will be in some way counter-intuitive since values are equalSo I think I'll write & use proper utilities where situation like this can possibly occur.About the roots of the error: in CPython repo  function (which is a  method implementation) calls  function (which corresponds to  function) -> for unhashable objects (like  in our first case) calls  function -> generates this error.


Answer URL
https://docs.python.org/3/library/stdtypes.html#dict.setdefault
https://docs.python.org/3/glossary.html#term-lbyl
https://docs.python.org/3/glossary.html#term-eafp
https://docs.python.org/3/library/functions.html#hash
