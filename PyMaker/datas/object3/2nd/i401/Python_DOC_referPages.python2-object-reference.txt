Natural Text
Why does the following behave unexpectedly in Python?I am using Python 2.5.2. Trying some different versions of Python, it appears that Python 2.3.3 shows the above behaviour between 99 and 100.Based on the above, I can hypothesize that Python is internally implemented such that "small" integers are stored in a different way than larger integers and the  operator can tell the difference. Why the leaky abstraction? What is a better way of comparing two arbitrary objects to see whether they are the same when I don't know in advance whether they are numbers or not?
Take a look at this:EDIT: Here's what I found in the Python 2 documentation, "Plain Integer Objects" (It's the same for Python 3):The current implementation keeps an  array of integer objects for all  integers between -5 and 256, when you  create an int in that range you  actually just get back a reference to  the existing object. So it should be  possible to change the value of 1. I  suspect the behaviour of Python in  this case is undefined. :-)
Python's “is” operator behaves unexpectedly with integers?In summary - let me emphasize: Do not use  to compare integers.This isn't behavior you should have any expectations about.Instead, use  and  to compare for equality and inequality, respectively. For example:ExplanationTo know this, you need to know the following.First, what does  do? It is a comparison operator. From the documentation:The operators  and  test for object identity:  is true  if and only if x and y are the same object.  yields the  inverse truth value.And so the following are equivalent. From the documentation:  Return the “identity” of an object. This is an integer (or long  integer) which is guaranteed to be unique and constant for this object  during its lifetime. Two objects with non-overlapping lifetimes may  have the same  value.Note that the fact that the id of an object in CPython (the reference implementation of Python) is the location in memory is an implementation detail. Other implementations of Python (such as Jython or IronPython) could easily have a different implementation for .So what is the use-case for ?  PEP8 describes:Comparisons to singletons like  should always be done with  or  , never the equality operators.The QuestionYou ask, and state, the following question (with code):Why does the following behave unexpectedly in Python?It is not an expected result. Why is it expected? It only means that the integers valued at  referenced by both  and  are the same instance of integer. Integers are immutable in Python, thus they cannot change. This should have no impact on any code. It should not be expected. It is merely an implementation detail. But perhaps we should be glad that there is not a new separate instance in memory every time we state a value equals 256. Looks like we now have two separate instances of integers with the value of  in memory. Since integers are immutable, this wastes memory. Let's hope we're not wasting a lot of it. We're probably not. But this behavior is not guaranteed.Well, this looks like your particular implementation of Python is trying to be smart and not creating redundantly valued integers in memory unless it has to. You seem to indicate you are using the referent implementation of Python, which is CPython. Good for CPython. It might be even better if CPython could do this globally, if it could do so cheaply (as there would a cost in the lookup), perhaps another implementation might. But as for impact on code, you should not care if an integer is a particular instance of an integer. You should only care what the value of that instance is, and you would use the normal comparison operators for that, i.e. .What  does checks that the  of two objects are the same. In CPython, the  is the location in memory, but it could be some other uniquely identifying number in another implementation. To restate this with code:is the same asWhy would we want to use  then?This can be a very fast check relative to say, checking if two very long strings are equal in value. But since it applies to the uniqueness of the object, we thus have limited use-cases for it. In fact, we mostly want to use it to check for , which is a singleton (a sole instance existing in one place in memory). We might create other singletons if there is potential to conflate them, which we might check with , but these are relatively rare. Here's an example (will work in Python 2 and 3) e.g.Which prints:And so we see, with  and a sentinel, we are able to differentiate between when  is called with no arguments and when it is called with . These are the primary use-cases for  - do not use it to test for equality of integers, strings, tuples, or other things like these.
It depends on whether you're looking to see if 2 things are equal, or the same object.  checks to see if they are the same object, not just equal. The small ints are probably pointing to the same memory location for space efficiency You should use  to compare equality of arbitrary objects. You can specify the behavior with the , and  attributes.
I'm late but, you want some source with your answer?*Good thing about CPython is that you can actually see the source for this. I'm going to use links for the  release for now; finding the corresponding  ones is trivial.In CPython, the  function that handles creating a new  object is . The description for this function is:The current implementation keeps an array of integer objects for all integers between -5 and 256, when you create an int in that range you actually just get back a reference to the existing object. So it should be possible to change the value of 1. I suspect the behaviour of Python in this case is undefined. :-)Don't know about you but I see this and think: Let's find that array!If you haven't fiddled with the  code implementing CPython you should, everything is pretty organized and readable. For our case, we need to look in the  subdirectory of the main source code directory tree. deals with  objects so it shouldn't be hard to deduce that we need to peek inside . After looking inside you might think things are chaotic; they are, but fear not, the function we're looking for is chilling at  waiting for us to check it out. It's a smallish function so the main body (excluding declarations) is easily pasted here:Now, we're no  master-code-haxxorz but we're also not dumb, we can see that  peeking at us all seductively; we can understand it has something to do with this. Let's check it out:So it's a macro that calls function  if the value  satisfies the condition:So what are  and ? If you guessed macros you get nothing because that wasn't such a hard question.. Anyway, here they are:So our condition is  call . No other place to go but continue our journey by looking at  in all its glory (well, we'll just look at it's body because that's were the interesting things are):Okay, declare a , assert that the previous condition holds and execute the assignment: looks a lot like that array we've been searching for.. and, it is! We could've just read the damn documentation and we would've know all along!:So yup, this is our guy. When you want to create a new  in the range  you'll just get back a reference to an already existing object that has been preallocated. Since the reference refers to the same object, issuing  directly or checking for identity with  on it will return exactly the same thing. But, when are they allocated??During initialization in  Python will gladly enter in a for loop do do this for you: I hope my explanation has made you  (pun obviously intented) things clearly now.But, 257 is 257? What's up?This is actually easier to explain, and I have attempted to do so already; it's due to the fact that Python will execute this interactive statement:as a single block. During complilation of this statement, CPython will see that you have two matching literals and will use the same  representing . You can see this if you do the compilation yourself and examine its contents:When CPython does the operation; it's now just going to load the exact same object:So  will return .* -- I'll try and word this in a more introductory manner in order for most to be able to follow along.
As you can check in source file intobject.c, Python caches small integers for efficiency. Every time you create a reference to a small integer, you are referring the cached small integer, not a new object. 257 is not an small integer, so it is calculated as a different object.It is better to use  for that purpose.
I think your hypotheses is correct. Experiment with  (identity of object):It appears that numbers  are treated as literals and anything above is treated differently!
For immutable value objects, like ints, strings or datetimes, object identity is not especially useful. It's better to think about equality. Identity is essentially an implementation detail for value objects - since they're immutable, there's no effective difference between having multiple refs to the same object or multiple objects.
 is the identity equality operator (functioning like ); it's just that two equal numbers aren't necessarily the same object. For performance reasons some small integers happen to be memoized so they will tend to be the same (this can be done since they are immutable).PHP's  operator, on the other hand, is described as checking equality and type:  as per Paulo Freitas' comment. This will suffice for common numbers, but differ from  for classes that define  in an absurd manner:PHP apparently allows the same thing for "built-in" classes (which I take to mean implemented at C level, not in PHP). A slightly less absurd use might be a timer object, which has a different value every time it's used as a number. Quite why you'd want to emulate Visual Basic's  instead of showing that it is an evaluation with  I don't know.Greg Hewgill (OP) made one clarifying comment "My goal is to compare object identity, rather than equality of value. Except for numbers, where I want to treat object identity the same as equality of value."This would have yet another answer, as we have to categorize things as numbers or not, to select whether we compare with  or . CPython defines the number protocol, including PyNumber_Check, but this is not accessible from Python itself.We could try to use  with all the number types we know of, but this would inevitably be incomplete. The types module contains a StringTypes list but no NumberTypes. Since Python 2.6, the built in number classes have a base class , but it has the same problem:By the way, NumPy will produce separate instances of low numbers.I don't actually know an answer to this variant of the question. I suppose one could theoretically use ctypes to call , but even that function has been debated, and it's certainly not portable. We'll just have to be less particular about what we test for now.In the end, this issue stems from Python not originally having a type tree with predicates like Scheme's , or Haskell's type class Num.  checks object identity, not value equality. PHP has a colorful history as well, where  apparently behaves as  only on objects in PHP5, but not PHP4. Such are the growing pains of moving across languages (including versions of one).
It also happens with strings:Now everything seems fine.That's expected too.Now that's unexpected.
Take a look hereThe current implementation keeps an array of integer objects for all  integers between -5 and 256, when you create an int in that range you  actually just get back a reference to the existing object.
There's another issue that isn't pointed out in any of the existing answers. Python is allowed to merge any two immutable values, and pre-created small int values are not the only way this can happen. A Python implementation is never guaranteed to do this, but they all do it for more than just small ints.For one thing, there are some other pre-created values, such as the empty , , and , and some short strings (in CPython 3.6, it's the 256 single-character Latin-1 strings). For example:But also, even non-pre-created values can be identical. Consider these examples:And this isn't limited to  values:Obviously, CPython doesn't come with a pre-created  value for . So, what's going on here?The CPython compiler will merge constant values of some known-immutable types like , , , ,  in the same compilation unit. For a module, the whole module is a compilation unit, but at the interactive interpreter, each statement is a separate compilation unit. Since  and  are defined in separate statements, their values aren't merged. Since  and  are defined in the same statement, their values are merged.You can see what's going on by disassembling the bytecode. Try defining a function that does  and then calling  on it, and you'll see that there's a single constant value You may notice that the compiler has stored  as a constant even though it's not actually used by the bytecode, which gives you an idea of how little optimization CPython's compiler does. Which means that (non-empty) tuples actually don't end up merged:Put that in a function,  it, and look at the —there's a  and a , two  tuples that share the same  and  but are not identical, and a  tuple that has the two distinct equal tuples.There's one more optimization that CPython does: string interning. Unlike compiler constant folding, this isn't restricted to source code literals:On the other hand, it is limited to the  type, and to strings of internal storage kind "ascii compact", "compact", or "legacy ready", and in many cases only "ascii compact" will get interned.At any rate, the rules for what values must be, might be, or cannot be distinct vary from implementation to implementation, and between versions of the same implementation, and maybe even between runs of the same code on the same copy of the same implementation.It can be worth learning the rules for one specific Python for the fun of it. But it's not worth relying on them in your code. The only safe rule is:Do not write code that assumes two equal but separately-created immutable values are identical.Do not write code that assumes two equal but separately-created immutable values are distinct.Or, in other words, only use  to test for the documented singletons (like ) or that are only created in one place in the code (like the  idiom).


Answer URL
https://docs.python.org/3/c-api/long.html
https://docs.python.org/3/c-api/long.html#c.PyLong_FromLong
