Natural Text
I'm writing a program that creates a bunch of workers to call an API asynchronously using . However this question is about shared-objects. I assume I would run into the same or a similar issue if I was multithreading.  I have a set of default URL params which all the workers share, however two of these params' values are changed from worker to worker:Here's how I'm initializing my  class:I'm looking for an alternative to calling  for every new worker I create.Figuring out how to pose this question has been a challenge. I suspect my answer may lie somewhere in class via instance attributes. Here's an extremely barebones example of my program:
Copying dictionaries, even for 100 workers, is not that expensive. You can create a copy of a 1000-key dictionary and update it, in 7 microseconds:So I'd say that there isn't really a problem here.However, you are essentially layering dictionary contents; adjustments per worker to just one or two keys. Instead of creating a copy, you could use a  object to handle the layering. A  object takes more than one dictionary and will look up keys in these until a value is found. No copy is created, and the top-most dictionary is used to set values when you mutate the map:Creating  objects is cheaper still:so only half a microsecond. That comes at a price of slower iteration and per-key access, of course. It'll depend on how  processes these, I recommend you do your own micro-benchmarks with the  module to measure performance of actual operations that your code is executing.But note that there is always a price to pay when trying to handle shared state like this, with any concurrency model, and sharing a dictionary between instances is always going to be problematic, even without concurrency.
If q is owned by the worker why not just make it an instance variable in the Worker itself. And wherever you want  do  


Answer URL
https://docs.python.org/3/library/collections.html#collections.ChainMap
