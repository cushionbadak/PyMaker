Natural Text
I'm writing data from sql server into a csv file using Python's csv module and then uploading the csv file to a postgres database using the copy command. The issue is that Python's csv writer automatically converts Nulls into an empty string "" and it fails my job when the column is an int or float datatype and it tries to insert this "" when it should be a None or null value.To make it as easy as possible to interface with modules which  implement the DB API, the value None is written as the empty string.https://docs.python.org/3.4/library/csv.html?highlight=csv#csv.writerWhat is the best way to keep the null value? Is there a better way to write csvs in Python? I'm open to all suggestions.Example:I have lat and long values:When writing to csv it converts nulls to "":.NULLSpecifies the string that represents a null value. The default is \N  (backslash-N) in text format, and an unquoted empty string in CSV  format. You might prefer an empty string even in text format for cases  where you don't want to distinguish nulls from empty strings. This  option is not allowed when using binary format.https://www.postgresql.org/docs/9.2/sql-copy.htmlANSWER:What solved the problem for me was changing the quoting to csv.QUOTE_MINIMAL.csv.QUOTE_MINIMAL Instructs writer objects to only quote those fields  which contain special characters such as delimiter, quotechar or any  of the characters in lineterminator.Related questions:- Postgresql COPY empty string as NULL not work
You have two options here: change the  quoting option in Python, or tell PostgreSQL to accept quoted strings as possible NULLs (requires PostgreSQL 9.4 or newer)Python  and quotingOn the Python side, you are telling the  object to add quotes, because you configured it to use :Instructs  objects to quote all non-numeric fields. values are non-numeric, so result in  being written.Switch to using  or :  Instructs  objects to only quote those fields which contain special characters such as delimiter, quotechar or any of the characters in lineterminator.  Instructs  objects to never quote fields. When the current delimiter occurs in output data it is preceded by the current escapechar character.Since all you are writing is longitude and latitude values, you don't need any quoting here, there are no delimiters or quotecharacters present in your data.With either option, the CSV output for  values is simple an empty string:PostgreSQL 9.4 ,  values and As of PostgreSQL 9.4, you can also force PostgreSQL to accept quoted empty strings as s, when you use the  option. From the  documentation:Match the specified columns' values against the null string, even if it has been quoted, and if a match is found set the value to . In the default case where the null string is empty, this converts a quoted empty string into . This option is allowed only in , and only when using CSV format.Naming the columns in a  option lets PostgreSQL accept both the empty column and  as  values for those columns, e.g.:at which point it doesn't matter anymore what quoting options you used on the Python side.Other options to considerFor simple data transformation tasks from other databases, don't use PythonIf you already querying databases to collate data to go into PostgreSQL, consider directly inserting into Postgres. If the data comes from other sources, using the foreign data wrapper (fdw) module lets you cut out the middle-man and directly pull data into PostgreSQL from other sources.Numpy data? Consider using COPY FROM as binary, directly from PythonNumpy data can more efficiently be inserted via binary ; the linked answer augments a numpy structured array with the required extra metadata and byte ordering, then efficiently creates a binary copy of the data and inserts it into PostgreSQL using  and the  method. This neatly avoids number -> text -> number conversions.Persisting data to handle large datasets in a pipeline?Don't re-invent the data pipeline wheels. Consider using existing projects such as Apache Spark, which have already solved the efficiency problems. Spark lets you treat data as a structured stream, and includes the infrastructure to run data analysis steps in parallel, and you can treat distributed, structured data as Pandas dataframes.Another option might be to look at Dask to help share datasets between distributed tasks to process large amounts of data.Even if converting an already running project to Spark might be a step too far, at least consider using Apache Arrow, the data exchange platform Spark builds on top of. The  project would let you exchange data via Parquet files, or exchange data over IPC.The Pandas and Numpy teams are quite heavily invested in supporting the needs of Arrow and Dask (there is considerable overlap in core members between these projects) and are actively working to make Python data exchange as efficient as possible, including extending Python's  module to allow for out-of-band data streams to avoid unnecessary memory copying when sharing data. 
your codeuses writer as-is, but you don't have to do that. You can filter the values to change some particular values with a generator comprehension and a ternary expression
You are asking for .  This will turn everything that is not a number into a string.  You should consider using  as it might be more what you are after:Test Code:Results:test1.csv:test2.csv:
I'm writing data from sql server into a csv file using Python's csv module and then uploading the csv file to a postgres database using the copy command.I believe your true requirement is you need to hop data rows through the filesystem, and as both the sentence above and the question title make clear, you are currently doing that with a csv file.Trouble is that csv format offers poor support for the RDBMS notion of NULL.Let me solve your problem for you by changing the question slightly.I'd like to introduce you to parquet format.Given a set of table rows in memory, it allows you to very quickly persist them to a compressed binary file, and recover them, with metadata and NULLs intact, no text quoting hassles.Here is an example, using the pyarrow 0.12.1 parquet engine:Output:Once you've recovered the rows in a dataframe you're free to call  or use some other favorite technique to put numbers and NULLs into a DB table.EDIT:If you're able to run  on the PG server, or on same LAN, then do that.Otherwise your favorite technique will likely involve .Why?The summary is that with psycopg2, "bulk INSERT is slow".Middle layers like sqlalchemy and pandas, and well-written apps that care about insert performance, will use .The idea is to send lots of rows all at once, without waiting for individual result status, because we're not worried about unique index violations.So TCP gets a giant buffer of SQL text and sends it all at once, saturating the end-to-end channel's bandwidth,much as copy_expert sends a big buffer to TCP to achieve high bandwidth.In contrast the psycopg2 driver lacks support for high performance executemany.As of 2.7.4 it just executes items one at a time, sending a SQL command across the WAN and waiting a round trip time for the result before sending next command.Ping your server;if ping times suggest you could get a dozen round trips per second,then plan on only inserting about a dozen rows per second.Most of the time is spent waiting for a reply packet, rather than spent processing DB rows.It would be lovely if at some future date psycopg2 would offer better support for this.
I would use pandas,psycopg2,and sqlalchemy. Make sure  are installed. Coming from your current workflow and avoiding writing to csv


Answer URL
https://docs.python.org/3/library/csv.html#csv.QUOTE_NONNUMERIC
https://docs.python.org/3/library/csv.html#csv.QUOTE_MINIMAL
https://docs.python.org/3/library/csv.html#csv.QUOTE_NONE
