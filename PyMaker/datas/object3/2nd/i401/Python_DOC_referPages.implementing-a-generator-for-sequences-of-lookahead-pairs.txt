Natural Text
I am trying to determine how to efficiently implement a generator over an iterable that yields all look-ahead or look-behind pairs within a defined window. For exampleShould produce something similar toWhen an element does not exist during look-ahead or look-behind it should be filled with a defined empty value. This is what I have so far for a lookahead generatorExecuting the above implementation gives:I am not sure how I should proceed from here. The above implementation generates look-ahead and look-behind sequences but I am not sure how to approach modifying it to produce the sequences of pairs. I also have concerns that my implementation may not be efficient. I am rather inexperience with the implementation of iterators in Python. Any assistance would be much appreciated.
ExplanationsI feel like the best solution is to use as much available tools as possible. In particular, something that is very interesting in this case is to use  (and its alterego ):Which produces:Also note that  can be used to "unzip": Outputs: The first step is to understand this piece of code which builds the case : This prints: That's very close from being modulable, the only thing we presume here is that we only have two  objects to merge, where in the real case we will have an unknown number, therefore we need to be able to translate  into a case where the list has an unknown size. To do so we will simply add all the "x_steps_ahead" in a list, lets call it , then we will merge all these pairs using the spread operation . In the end it will look like this: Which produces the same result as before: That's basically the whole idea of the code I'm proposing. The case of looking backward is a bit more unusual but I'll let you understand how it works as an exercise. A slight difference in the final code is also that I try to avoid instantiating lists as much as I can. Iterators/generators are prefered, which makes the code a bit harder to read, but way more efficient in terms of memory usage. Basically, things like the pair construction will turn to: That does the exact same thing as the previous code, it just avoid having a list of size  in memory to remember all the  we create. For the same reason, in the following code I also use  instead of classical slicing because its a lighter version (unlike  it doesn't instantiate a copy of the input list).Solution implementationYou can call it as you suggested:This outputs:
You could try something like the following code I wrote:Explanation:If / is 0 we set variable / to 1 in order for the following loops to atleast loop once.Outer loop loops over the range of , the two inner loops over range of (counted down) and (counted up),respectively. Inside the most inner loop we set the respective lookahead/-behind indices and then check with help of the three  statements whether indices are out of bound in order to set the respective values to the out of bound value () if necessary. The fourth  statement is chosen if the indices are not out of bound. Inside each  statement there are  statements which change the appended tuple depending on the lookahead/-behind values stored in  and . If both are 0 only append , if  is 0 only append a tuple consisting of  and current lookahead value, and so on.After the work is done we print the value of  in order to visualize the result.Source Code:Output:First Major Update:According to a new comment you want a different ouput when both lookbehind/-forward are specified, so I altered my program to now hopefully fulfill your needs:Additional explanation for updated program:In each iteration of the outer loop first the lookbehind pairs are added in a loop, then  the lookforward pairs are added, also in a loop. As before we check for out of bounds and set the value of the lookbehind/forward value accordingly. Updated source code:New output: [when lookforward and lookbehind are specified]Second Major Update:In case you want a list containing tuples of tuples as a result you could do something like this [I slightly modified the code of my first major update]:Additional explanation:In the beginning of each outer loop iteration we append an empty list to . To this list we append the according values of first the lookbehind pairs, then the lookforward pairs. In the end of each outer loop iteration we then convert this newly created list to a tuple.Output: [list containing tuples of tuples]
A useful intermediate step in solving your problem is to produce sequences of adjacent values. So if the input was , you'd iterate and get  then  and so on.There's a nifty way to do this using :Now we can fairly easily do lookahead and lookbehinds (I'm ignoring the  values for now):The easiest way to adapt this to support the empty values would just be to pad the iterable. You need  extra empty values at the start, and  extra values at the end.Now, this behaves a little odd when it looks back or ahead into several empty values in a row (since it repeats the same output for each missing value), but I'm not sure what you expect in those situations. There's probably a simple way to filter the output to avoid the duplicates, if you want that.
As a first step write a function that from a  index returns the list of look-ahead and look-behind pairs centered in the .Using list comprehensions:If now all pairs are desired it a a matter of applying again list comprehensions, varying the :Or if you prefer a one line solution, but please consider code readability/maintenability:If you want optimize memory usage a generator comprehensions may be used instead:


Answer URL
https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions
