Natural Text
I'm learning how to use  classes in Python, and have found that whenever I need to access the actual value of the enum, I need to append the  property:As an exercise, I'm trying configure my  class so that I do not need to continually access that  property. My desired behavior is that when I call , I get  as my value.I'm tried to implement this with :However, I receive a , and  is a string value of . I'm not quite understanding why this behavior is happening - is this built in Python behavior, or because I am using a special class ?I did take a look at a similar SO post, but the solutions there were to use another module (), or access the  or  and parse it yourself with a combination of conditionals or regex. Is there a better way to access the underlying 's value?
Don't use the enum class if you want to map attributes to strings. The whole point of the  module is to produce a set of singleton objects that represent an enumeration, not strings. From the module documentation:An enumeration is a set of symbolic names (members) bound to unique, constant values. Within an enumeration, the members can be compared by identity, and the enumeration itself can be iterated over.)Bold emphasis mine. Strings are not unique, constant values (I can create more  strings at will) and are not designed to be compared by identity (even though sometimes, for a subset of strings, you can).Just define your own class with attributes that are strings, directly:Your infinite recursion error is caused by a misunderstanding on your part as to what that method is used for. Like all special methods,  looks up  on the object type, meaning here that your method applies to instances of your  subclass, the  and  attributes here, not to the class itself, and interferes with the  metaclass trying to test for the  attibute, which is handled by your  method with  being the newly-minted  instance, and  set to , which then calls , which calls , etc.For your approach to work, you'd have to subclass  and implement  on that subclass ( is only ever called for missing attributes). However, take into account that  is used for all attribute access, so you have to take care to check for instances of the current class first:at which point  produces .


Answer URL
https://docs.python.org/3/reference/datamodel.html#special-method-lookup
https://docs.python.org/3/reference/datamodel.html#object.__getattribute__
