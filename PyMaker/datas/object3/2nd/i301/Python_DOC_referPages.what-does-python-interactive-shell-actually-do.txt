Natural Text
I've been looking at dynamic evaluation of Python code, and come across the  and  functions, and the  statement.Can someone please explain the difference between  and , and how the different modes of  fit in?
The short answer, or TL;DRBasically,  is used to evaluate a single dynamically generated Python expression, and  is used to execute dynamically generated Python code only for its side effects. and  have these two differences: accepts only a single expression,  can take a code block that has Python statements: loops, ,  and function/method initions and so on. An expression in Python is whatever you can have as the value in a variable assignment: returns the value of the given expression, whereas  ignores the return value from its code, and always returns  (in Python 2 it is a statement and cannot be used as an expression, so it really does not return anything).In versions 1.0 - 2.7,  was a statement, because CPython needed to produce a different kind of code object for functions that used  for its side effects inside the function. In Python 3,  is a function; its use has no effect on the compiled bytecode of the function where it is used.Thus basically:The  in  mode compiles any number of statements into a bytecode that implicitly always returns , whereas in  mode it compiles a single expression into bytecode that returns the value of that expression. In the  mode (and thus with the  function if a string is passed in), the  raises an exception if the source code contains statements or anything else beyond a single expression:Actually the statement "eval accepts only a single expression" applies only when a string (which contains Python source code) is passed to . Then it is internally compiled to bytecode using  This is where the difference really comes from.If a  object (which contains Python bytecode) is passed to  or , they behave identically, excepting for the fact that  ignores the return value, still returning  always. So it is possible use  to execute something that has statements, if you just d it into bytecode before instead of passing it as a string:works without problems, even though the compiled code contains statements. It still returns , because that is the return value of the code object returned from .In the  mode (and thus with the  function if a string is passed in), the  raises an exception if the source code contains statements or anything else beyond a single expression:The longer answer, a.k.a the gory details and The  function (which was a statement in Python 2) is used for executing a dynamically created statement or program:The  function does the same for a single expression, and returns the value of the expression: and  both accept the program/expression to be run either as a ,  or  object containing source code, or as a  object which contains Python bytecode. If a // containing source code was passed to , it behaves equivalently to:and  similarly behaves equivalent to:Since all expressions can be used as statements in Python (these are called the  nodes in the Python abstract grammar; the opposite is not true), you can always use  if you do not need the return value. That is to say, you can use either  or , the difference being that  returns the value returned by , and  discards it:Of the 2, only  accepts source code that contains statements, like , , , , or , the assignment statement (a.k.a ), or entire programs:Both  and  accept 2 additional positional arguments -  and  - which are the global and local variable scopes that the code sees. These default to the  and  within the scope that called  or , but any dictionary can be used for  and any  for  (including  of course). These can be used not only to restrict/modify the variables that the code sees, but are often also used for capturing the variables that the uted code creates:(If you display the value of the entire , it would be much longer, because  and  add the built-ins module as  to the globals automatically if it is missing).In Python 2, the official syntax for the  statement is actually , as inHowever the alternate syntax  has always been accepted too (see below).The  built-in can be used to speed up repeated invocations of the same code with  or  by compiling the source into a  object beforehand. The  parameter controls the kind of code fragment the  function accepts and the kind of bytecode it produces. The choices are ,  and : mode expects a single expression, and will produce bytecode that when run will return the value of that expression: accepts any kinds of python constructs from single expressions to whole modules of code, and executes them as if they were module top-level statements. The code object returns : is a limited form of  which accepts a source code containing a single statement (or multiple statements separated by ) if the last statement is an expression statement, the resulting bytecode also prints the  of the value of that expression to the standard output(!).An -- chain, a loop with , and  with its ,  and  blocks is considered a single statement.A source fragment containing 2 top-level statements is an error for the , except in Python 2 there is a bug that sometimes allows multiple toplevel statements in the code; only the first is compiled; the rest are ignored:In Python 2.7.8:And in Python 3.4.2:This is very useful for making interactive Python shells. However, the value of the expression is not returned, even if you  the resulting code.Thus greatest distinction of  and  actually comes from the  function and its modes.In addition to compiling source code to bytecode,  supports compiling abstract syntax trees (parse trees of Python code) into  objects; and source code into abstract syntax trees (the  is written in Python and just calls ); these are used for example for modifying source code on the fly, and also for dynamic code creation, as it is often easier to handle the code as a tree of nodes instead of lines of text in complex cases.While  only allows you to evaluate a string that contains a single expression, you can  a whole statement, or even a whole module that has been d into bytecode; that is, with Python 2,  is a statement, and cannot be led directly: it with  mode into a  object and you can   it; the  function will return .If one looks into  and  source code in CPython 3, this is very evident; they both call  with same arguments, the only difference being that  explicitly returns .Syntax differences of  between Python 2 and Python 3One of the major differences in Python 2 is that  is a statement and  is a built-in function (both are built-in functions in Python 3).It is a well-known fact that the official syntax of  in Python 2 is .Unlike majority of the Python 2-to-3 porting guides seem to suggest, the  statement in CPython 2 can be also used with syntax that looks exactly like the  function invocation in Python 3. The reason is that Python 0.9.9 had the  built-in function! And that built-in function was replaced with  statement somewhere before Python 1.0 release.Since it was desirable to not break backwards compatibility with Python 0.9.9, Guido van Rossum added a compatibility hack in 1993: if the  was a tuple of length 2 or 3, and  and  were not passed into the  statement otherwise, the  would be interpreted as if the 2nd and 3rd element of the tuple were the  and  respectively. The compatibility hack was not mentioned even in Python 1.4 documentation (the earliest available version online); and thus was not known to many writers of the porting guides and tools, until it was documented again in November 2012:The first expression may also be a tuple of length 2 or 3. In this case, the optional parts must be omitted. The form  is equivalent to , while the form  is equivalent to . The tuple form of  provides compatibility with Python 3, where  is a function rather than a statement.Yes, in CPython 2.7 that it is handily referred to as being a forward-compatibility option (why confuse people over that there is a backward compatibility option at all), when it actually had been there for backward-compatibility for two decades.Thus while  is a statement in Python 1 and Python 2, and a built-in function in Python 3 and Python 0.9.9,has had identical behaviour in possibly every widely released Python version ever; and works in Jython 2.5.2, PyPy 2.3.1 (Python 2.7.6) and IronPython 2.6.1 too (kudos to them following the undocumented behaviour of CPython closely).What you cannot do in Pythons 1.0 - 2.7 with its compatibility hack, is to store the return value of  into a variable:(which wouldn't be useful in Python 3 either, as  always returns ), or pass a reference to :Which a pattern that someone might actually have used, though unlikely; Or use it in a list comprehension:which is abuse of list comprehensions (use a  loop instead!).
 is not an expression: a statement in Python 2.x, and a function in Python 3.x. It compiles and immediately evaluates a statement or set of statement contained in a string. Example: is a built-in function (not a statement), which evaluates an expression and returns the value that expression produces. Example: is a lower level version of  and . It does not execute or evaluate your statements or expressions, but returns a code object that can do it. The modes are as follows: returns the code object that would have been executed had you done . Note that you cannot use statements in this mode; only a (single) expression is valid. returns the code object that would have been executed had you done . You can use any number of statements here. is like the  mode, but it will ignore everything except for the first statement. Note that an / statement with its results is considered a single statement.
exec is for statement and does not return anything.eval is for expression and returns value of expression.expression means "something" while statement means "do something".


Answer URL
https://docs.python.org/3/library/functions.html#eval
https://docs.python.org/3/library/functions.html#exec
https://docs.python.org/3/library/functions.html#compile
https://docs.python.org/3/library/functions.html#exec
https://docs.python.org/3/library/functions.html#eval
https://docs.python.org/3/reference/expressions.html
https://docs.python.org/3/library/ast.html#abstract-grammar
https://docs.python.org/3/library/functions.html#compile
https://docs.python.org/3/library/ast.html#abstract-grammar
https://docs.python.org/3/reference/compound_stmts.html#grammar-token-dotted_name
