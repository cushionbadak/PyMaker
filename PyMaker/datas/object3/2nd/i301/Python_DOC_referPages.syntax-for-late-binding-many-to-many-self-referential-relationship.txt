Natural Text
I have found many explanations for how to create a self-referential many-to-many relationship (for user followers or friends) using a separate table or class:Below are three examples, one from Mike Bayer himself:Many-to-many self-referential relationship in sqlalchemyHow can I achieve a self-referencing many-to-many relationship on the SQLAlchemy ORM back referencing to the same attribute?Miguel Grinberg's Flask Megatutorial on followersBut in every example I've found, the syntax for defining the  and  in the relationship is an early-binding one:This works great, except for one circumstance: when one uses a  class to define the  column for all of your objects as shown in Mixins: Augmenting the base from the docsMy  class and  table are defined thusly:But now I have trouble with the followers relationship that has served me loyally for a while before I moved the 's to the mixin:Presumably because the  is not present in the local scope, though it seems to throw a strange error for that:ArgumentError: Could not locate any simple equality expressions involving locally mapped foreign key columns for primary join condition  on relationship .  Ensure that referencing columns are associated with a  or , or are annotated in the join condition with the  annotation. To allow comparison operators other than , the relationship can be marked as .And it throws the same error if I change the parentheses to quotes to take advantage of late-binding. I have no idea how to annotate this thing with  and  because I simply don't know what sqlalchemy would like me to describe as foreign and remote on a self-referential relationship that crosses a secondary table! I've tried many combinations of this, but it hasn't worked thus far.I had a very similar (though not identical) problem with a self-referential relationship that did not span a separate table and the key was simply to convert the  argument to a late-binding one. This makes sense to me, as the  column isn't present during an early-binding process.If it is not late-binding that I am having trouble with, please advise. In the current scope, though, my understanding is that  is mapped to the Python builtin  and thus will not work as an early-binding relationship.Converting  to  in the joins results in the following error:ArgumentError: Could not locate any simple equality expressions involving locally mapped foreign key columns for primary join condition  on relationship .  Ensure that referencing columns are associated with a  or , or are annotated in the join condition with the  annotation. To allow comparison operators other than , the relationship can be marked as .
You can't use  in your join filters, no, because that's the built-in  function, not the  column.You have three options:Define the relationship after creating your  model, assigning it to a new  attribute; you can then reference  as it has been pulled in from the base:Use strings for the join expressions. Any argument to  that is a string is evaluated as a Python expression when configuring the mapper, not just the first argument:Define the relationships as callables; these are called at mapper configuration time to produce the final object:For the latter two options, see the  documentation:Some arguments accepted by  optionally accept a callable function, which when called produces the desired value. The callable is invoked by the parent Mapper at “mapper initialization” time, which happens only when mappers are first used, and is assumed to be after all mappings have been constructed. This can be used to resolve order-of-declaration and other dependency issues, such as if  is declared below  in the same file*[.]*[...]When using the Declarative extension, the Declarative initializer allows string arguments to be passed to . These string arguments are converted into callables that evaluate the string as Python code, using the Declarative class-registry as a namespace. This allows the lookup of related classes to be automatic via their string name, and removes the need to import related classes at all into the local module space*[.]*[...]primaryjoin –  [...] may also be passed as a callable function which is evaluated at mapper initialization time, and may be passed as a Python-evaluable string when using Declarative.[...]secondaryjoin –[...] may also be passed as a callable function which is evaluated at mapper initialization time, and may be passed as a Python-evaluable string when using Declarative.Both the string and the lambda define the same  /  expressions as used in the first option, but because they are given as a string and callable function, respectively, you postpone evaluation until SQLAlchemy needs to have those declarations finalised.


Answer URL
https://docs.python.org/3/library/functions.html#id
