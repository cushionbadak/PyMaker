Natural Text
EDIT: I'm using Python 3.5.0, and so  will return an iterator instead of a , unlike Python 2.xI have a list of units and I am calling a REST api on all of them to return more data about them. I'm using  to do this, but when I try to convert that map to a list, the program hangs there and doesn't proceed (both when I run it and debug it)At first I thought maybe it was an issue with calling the api so quickly, but when I iterate through the map (without converting it to a list) manually and print it goes just fine:Anyone know why I'm getting this behavior? 
When you -ify the , that means every single request is dispatched serially, waits for completion, then stores to the resulting . If you're dispatching 1000 requests, that means each request must complete in order, one by one, before the  is constructed and you see the first result; it's entirely synchronous.You get results (almost) immediately in the direct  iteration case because it only makes one request at a time; instead of waiting for 1000 requests, it waits for 1, you process that result, then it waits for another, etc.If the goal is to minimize latency, take a look at  (or the thread based version of the pool implemented in ; threads can be ideal for parallel network I/O requests and won't require pickling data for IPC). With the 's , , or  methods (choose one based on your needs), the requests will be dispatched asynchronously, several at a time (depending on the number of workers you select). If you absolutely must have a ,  will usually construct it faster; if you can iterate directly and don't care about the ordering of results,  will get you results as fast as the workers can get them, in whatever order they are satisfied in. Plain  without a  isn't getting you any magical performance benefits (a list comprehension would usually run faster actually), so use a .Simple example code for fastest results:If you really need to, you can use  and store to a real , and assuming you have the bandwidth to run eight parallel requests (or however many workers you configure the pool for), that should (roughly) divide the time to complete the  by eight.
Better answer than I previously had.  Check out this link. Near the bottom of the answer it gives a great analysis on why you should really use a list comprehension.data = [ client.request(units_url + "/" + product) for product in units ]


Answer URL
https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.imap_unordered
