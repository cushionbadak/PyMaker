Natural Text
How can I generate all permutations of cyclic shifts of length k in a list of length n. Here shift is cyclic and right. Notice that:if K==1 , there's no shift. Hence, no permutation of those 0 shifts.if K==2 , this is equivalent to swapping the elements. Hence all n! permutations can be generated.  eg. if list is [1 4 2],K=2  (thus from 0 to N-K, loop)   if K==3, things get interesting as some permutations are left out.eg. if list=[1,3,4,2],K=3 ( thus from index 0 to 4-3,loop)Notice,that these permutations are half (12) of what should've been (24).  To, implement this, algorithm, I am currently using backtracking. Here's what I have tried so far (in Python)This produces the outputThis is exactly what I want, but a lot lot slower,since here the recursion depth exceeds for N>7. I hope, I have explained myself clearly. Anyone, with any optimizations?
The checkgets slower and slower as  grows, because it requires comparing  with the elements of  one at a time, until either a copy is found or the end of the list is encountered. Since every permutation will be added to  once, the number of comparisons with  is at least quadratic in the number of permutations found, which will generally be either all the possible permutations or half of them, depending on whether k is even or odd (assuming 1 < k < N).It's a lot more efficient to use a set. Python's set is based on a hash-table, so the membership check is usually O(1) rather than O(N). However, there are a couple of limitations:The elements added to the set need to be hashable, and Python lists are not hashable. Fortunately, tuples are hashable, so a small change fixes the issue.Iterating over a set is unpredictable. In particular, you cannot reliably modify the set while you are iterating over it.In addition to changing P to a tuple and stored_perms to a set, it's worthwhile considering search based on a workqueue instead of a recursive search. I don't know if it will be any faster, but it avoids any issues with recursion depth.Putting all that together, I threw the following together:


Answer URL
https://docs.python.org/3/library/stdtypes.html#types-set
https://docs.python.org/3/glossary.html#term-hashable
