Natural Text
In the Python data model reference section on slots there is a list of notes on using .  I am thoroughly confused by the 1st and 6th items, because they seem to be contradicting each other. First item:When inheriting from a class without, the  attributeof that class will always beaccessible, so a definition in the subclass ismeaningless.Sixth item:The action of a declaration is limited to the classwhere it is defined. As a result,subclasses will have a unless they also define (which must only contain names of anyadditional slots).It seems to me these items could be better worded or shown through code, but I have been trying to wrap my head around this and am still coming up confused. I do understand how  are supposed to be used, and I am trying to get a better grasp on how they work.The Question:Can someone please explain to me in plain language what the conditions are for inheritance of slots when subclassing? (Simple code examples would be helpful but not necessary.)
As others have mentioned, the sole reason for defining  is to save some memory, when you have simple objects with a predefined set of attributes and don't want each to carry around a dictionary.  This is meaningful only for classes of which you plan to have many instances, of course.The savings may not be immediately obvious -- consider...:From this, it would seem the with-slots size is larger than the no-slots size!  But that's a mistake, because  doesn't consider "object contents" such as the dictionary:Since the dict alone takes 140 bytes, clearly the "32 bytes" object  is alleged to take are not considering all that's involved in each instance.  You can do a better job with third-party extensions such as pympler:This shows much more clearly the memory footprint that's saved by : for a simple object such as this case, it's a bit less than 200 bytes, almost 2/3 of the object's overall footprint.  Now, since these days a megabyte more or less doesn't really matter all that much to most applications, this also tells you that  is not worth the bother if you're going to have just a few thousand instances around at a time -- however, for millions of instances, it sure does make a very important difference. You can also get a microscopic speedup (partly due to better cache use for small objects with ):but this is somewhat dependent on Python version (these are the numbers I measure repeatably with 2.5; with 2.6, I see a larger relative advantage to  for setting an attribute, but none at all, indeed a tiny disadvantage, for getting it).Now, regarding inheritance: for an instance to be dict-less, all classes up its inheritance chain must also have dict-less instances.  Classes with dict-less instances are those which define , plus most built-in types (built-in types whose instances have dicts are those on whose instances you can set arbitrary attributes, such as functions). Overlaps in slot names are not forbidden, but they're useless and waste some memory, since slots are inherited:as you see, you can set attribute  on an  instance --  itself only defines slot , but it inherits slot  from .  Repeating the inherited slot isn't forbidden:but does waste a little memory:so there's really no reason to do it.
First ItemSixth ItemYou probably won't need to use  in the near future. It's only intended to save memory at the cost of some flexibility. Unless you have tens of thousands of objects it won't matter.
Python: How does inheritance of  in subclasses actually work?I am thoroughly confused by the 1st and 6th items, because they seem to be contradicting each other. Those items don't actually contradict each other. The first regards subclasses of classes that don't implement , the second regards subclasses of classes that do implement .Subclasses of classes that don't implement I am increasingly aware that as great as the Python docs are (rightly) reputed to be, they are not perfect, especially regarding the less used features of the language. I would alter the docs as follows:When inheriting from a class without , the  attribute  of that class will always be accessible, so a  definition in  the subclass is meaningless . is still meaningful for such a class. It documents the expected names of attributes of the class. It also creates slots for those attributes - they will get the faster lookups and use less space. It just allows for other attributes, which will be assigned to the .This change has been accepted and is now in the latest documentation.Here's an example: not only has the slots it declares, it also has Foo's slots - which include :Subclasses of classes that do implement The action of a  declaration is limited to the class where it  is defined. As a result, subclasses will have a  unless they  also define  (which must only contain names of any additional  slots).Well that's not quite right either. The action of a  declaration is not entirely limited to the class where it is defined. They can have implications for multiple inheritance, for example.I would change that to:For classes in an inheritance tree that defines , subclasses will have a  unless they  also define  (which must only contain names of any additional  slots).I have actually updated it to read:The action of a  declaration is not limited to the class  where it is defined.  declared in parents are available in  child classes. However, child subclasses will get a  and   unless they also define  (which should only contain names of any additional slots).Here's an example:And we see that a subclass of a slotted class gets to use the slots:(For more on , see my answer here.)
From the answer you linked:The proper use of  is to save space in objects. Instead of having a dynamic dict..."When inheriting from a class without , the  attribute of that class will always be accessible", so adding your own  cannot prevent objects from having a , and cannot save space.The bit about  not being inherited is a little obtuse.  Remember that it's a magic attribute and doesn't behave like other attributes, then re-read that as saying this magic slots behavior isn't inherited.  (That's really all there is to it.)
My understanding is as follows:class  has no   class  and its superclasses all have  specifiedin this case, the actual slots of the class are comprised from the union of  declarations  for  and its superclasses; the behavior is undefined (and will become an error) if this union is not disjoint


Answer URL
https://docs.python.org/3/reference/datamodel.html#notes-on-using-slots
