Natural Text
I am creating a simple TCP server as a stub so I can test a script that operates a piece of test equipment, without having to have the equipment there. The server should sit there waiting for a connection and then maintain and update a state variable (just a list of 6 integers) in response to commands that it receives. The parent process (a unit test class for example) should then be able to interrogate the state at any time.The interface of the server should be as simple as:I have subclassed Multiprocessing.Process to do this and I can start the server off no problem. When I first tested this, in the getState() method I just returned the instance variable _state but I found this was always just the initial state. After some digging I couldn't find any similar examples out there. Lots about subclassing Process, but not this specific problem. Eventually I put together the below which uses an internal Queue() to store the state on but this looks messy and clunky to me. Is there a better way to do this?
As its name implies,  uses different processes. At some point,  is called and the child processes copy the memory of the parent process, and the child is left with its own memory, not being shared with the parent process.Unfortunately, you have to use tools available to share memory between processes, leading to the code overhead you mention.You can look up for other ways to do parallel processing with shared memory, but do mind that sharing memory between threads/processes/nodes/etc is never easy.
You can dump state of your stub server to file and read it from unittests in any moment. It's pretty simple solution for test needs. All that you need to do:Pass  as parameter to constructorCall  with init valuesRewrite  to write state to . It's better to create a new file near  and replace it. If you are worrying about atomicity.
Thanks Felipe, my question was mainly 'is there a better way than using queues' as I did in the question. After a bit more research (prompted by your mention of shared memory) I have found a shared array is much better for this case:This works a treat and is a bit more elegant. Thanks for your help


Answer URL
https://docs.python.org/3/library/multiprocessing.html#exchanging-objects-between-processes
