Natural Text
I've got a script that runs on a infinite loop and adds things to a database and does things that I can't just stop halfway through so I can't just press ctrl+C and stop it.I want to be able to somehow stop a while loop but let it finish it's last iteration before it stops.Let me clarify:my code looks something like this:I want to be able to interrupt the while loop at the end, or the beginning, but not between doing things because that would be bad.and I don't want it to ask me after every iteration if i want to continue.thanks for the great answers, i'm super grateful but my implementation doesn't seem to be working:when I press ctr+c the program just keeps going ignoring me
What you need to do is catch the interrupt, set a flag saying you were interrupted but then continue working until it's time to check the flag (at the end of each loop). Because python's try-except construct will abandon the current run of the loop, you need to set up a proper signal handler; it'll handle the interrupt but then let python continue where it left off. Here's how:Notes: Use this from the command line. In the IDLE console, it'll trample on IDLE's own interrupt handling.A better solution would be to "block" KeyboardInterrupt for the duration of the loop, and unblock it when it's time to poll for interrupts. This is a feature of some Unix flavors but not all, hence python does not support it (see the third "General rule")The OP wants to do this inside a class. But the interrupt function is invoked by the signal handling system, with two arguments: The signal number and a pointer to the stack frame-- no place for a  argument giving access to the class object. Hence the simplest way to set a flag is to use a global variable. You can rig a pointer to the local context by using closures (i.e., define the signal handler dynamically in , but frankly I wouldn't bother unless a global is out of the question due to multi-threading or whatever.Caveat: If your process is in the middle of a system call, handling an signal may interrupt the system call. So this may not be safe for all applications. Safer alternatives would be (a) Instead of relying on signals, use a non-blocking read at the end of each loop iteration (and type input instead of hitting ^C); (b) use threads or interprocess communication to isolate the worker from the signal handling; or (c) do the work of implementing real signal blocking, if you are on an OS that has it. All of them are OS-dependent to some extent, so I'll leave it at that.
the below logic will help you do this,while running this, try pressing CTRL+C
I hope below code would help you:
To clarify @praba230890's solution: The  variable was not defined in the correct scope. It was defined in the  function and the handler could not reach it as a global variable, according to the definition of the handler at the root of the program.


Answer URL
https://docs.python.org/3/library/signal.html#general-rules
https://docs.python.org/3/library/signal.html
