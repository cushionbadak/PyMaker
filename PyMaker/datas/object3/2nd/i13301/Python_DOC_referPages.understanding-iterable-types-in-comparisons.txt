Natural Text
Recently I ran into cosmologicon's pywats and now try to understand part about fun with iterators:Ok,  returns a  and  becomes just a two lists comparision. But  returns . So why these reversed objects are different? And id's comparision makes me even more confused:
The basic reason why  returns  , whereas  returns  , can be seen from the below example using custom classes -As you can see when you did  , the object that was created on the fly was not destroyed until after the comparison occurred, this is because that object was required for the comparison.But in case of  , the custom object created was passed to  function, and then only the result of  function is required for comparison , so the object that was created has no reference left, and hence the object was garbage collected, and then when the Python interpreter recreated a new object for the right side of  operation, it reused the space that was freed previously. Hence, the  for both came as same.This above behavior is an implementation detail of CPython (it may/may not differ in other implementations of Python) . And you should never rely on the equality of  . For example in the below case it gives the wrong result -The reason for this is again as explained above (garbage collection of the  object created for  before creation of reversed object for ).If the lists are large, I think the most memory efficient and most probably the fastest method to compare equality for two iterators would be to use  built-in function along with  function for Python 3.x (or  for Python 2.x).Example for Python 3.x - Example for Python 2.x -This is because  short circuits at the first False value is encounters, and `zip() in Python 3.x returns an iterator which yields out the corresponding elements from both the different iterators. This does not need to create a separate list in memory.Demo -
 returns a list, whereas  returns a  object and is a different object. If you were to cast the result of  to a list before comparison, they will be equal.
 returns an iterable that doesn't implement a specific  operator and therefore is compared using identity.The confusion about  is because after evaluating the first  call the iterable can be disposed (nothing references it) and the second iterable may be reallocated at the very same memory address when the second  call is done. This is however just a coincidence.Tryand compare  with  and you will see they are different numbers (because in this case the iterable objects cannot be deallocated as they're referenced by / variables).
You may try   will return once try again 


Answer URL
https://docs.python.org/3/library/functions.html#zip
