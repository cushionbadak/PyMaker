Natural Text
How do I see if a file exists or not, without using the  statement?
If the reason you're checking is so you can do something like , it's safer to use a  around the attempt to open it. Checking and then opening risks the file being deleted or moved or something between when you check and when you try to open it.If you're not planning to open the file immediately, you can use Return  if path is an existing regular file. This follows symbolic links, so both islink() and isfile() can be true for the same path.if you need to be sure it's a file.Starting with Python 3.4, the  module offers an object-oriented approach (backported to  in Python 2.7):To check a directory, do:To check whether a  object exists independently of whether is it a file or directory, use :You can also use  in a  block:
You have the  function:This returns  for both files and directories but you can instead useto test if it's a file specifically. It follows symlinks.
Unlike ,  will return  for directories.So depending on if you want only plain files or also directories, you'll use  or . Here is a simple REPL output.

Use  with :

Although almost every possible way has been listed in (at least one of) the existing answers (e.g. Python 3.4 specific stuff was added), I'll try to group everything together.Note: every piece of Python standard library code that I'm going to post, belongs to version 3.5.3.Problem statement:Check file (arguable: also folder ("special" file) ?) existenceDon't use try / except / else / finally blocksPossible solutions:[Python 3]: os.path.exists(path) (also check other function family members like , ,  for slightly different behaviors)Return  if path refers to an existing path or an open file descriptor. Returns  for broken symbolic links. On some platforms, this function may return  if permission is not granted to execute os.stat() on the requested file, even if the path physically exists.All good, but if following the import tree: - posixpath.py (ntpath.py)genericpath.py, line ~#20+it's just a try / except block around [Python 3]: os.stat(path, *, dir_fd=None, follow_symlinks=True). So, your code is try / except free, but lower in the framestack there's (at least) one such block. This also applies to other funcs (including ).1.1. [Python 3]: Path.is_file()It's a fancier (and more pythonic) way of handling paths, butUnder the hood, it does exactly the same thing (pathlib.py, line ~#1330):[Python 3]: With Statement Context Managers. Either:Create one:And its usage - I'll replicate the  behavior (note that this is just for demonstrating purposes, do not attempt to write such code for production):Use [Python 3]: contextlib.suppress(*exceptions) - which was specifically designed for selectively suppressing exceptionsBut, they seem to be wrappers over try / except / else / finally blocks, as [Python 3]: The with statement states:This allows common try...except...finally usage patterns to be encapsulated for convenient reuse.Filesystem traversal functions (and search the results for matching item(s))[Python 3]: os.listdir(path='.') (or [Python 3]: os.scandir(path='.') on Python v3.5
This is the simplest way to check if a file exists. Just because the file existed when you checked doesn't guarantee that it will be there when you need to open it.
Python 3.4+ has an object-oriented path module: pathlib.  Using this new module, you can check whether a file exists like this:You can (and usually should) still use a  block when opening files:The pathlib module has lots of cool stuff in it: convenient globbing, checking file's owner, easier path joining, etc.  It's worth checking out.  If you're on an older Python (version 2.6 or later), you can still install pathlib with pip:Then import it as follows:
Prefer the try statement. It's considered better style and avoids race conditions.Don't take my word for it. There's plenty of support for this theory. Here's a couple:Style: Section "Handling unusual conditions" of http://allendowney.com/sd/notes/notes11.txtAvoiding Race Conditions
How do I check whether a file exists, using Python, without using a try statement?Now available since Python 3.4, import and instantiate a  object with the file name, and check the  method (note that this returns True for symlinks pointing to regular files as well):If you're on Python 2, you can backport the pathlib module from pypi, , or otherwise check  from the  module:Now the above is probably the best pragmatic direct answer here, but there's the possibility of a race condition (depending on what you're trying to accomplish), and the fact that the underlying implementation uses a , but Python uses  everywhere in its implementation. Because Python uses  everywhere, there's really no reason to avoid an implementation that uses it.But the rest of this answer attempts to consider these caveats.Longer, much more pedantic answerAvailable since Python 3.4, use the new  object in . Note that  is not quite right, because directories are not files (except in the unix sense that everything is a file).So we need to use :Here's the help on :So let's get a file that we know is a file:By default,  deletes the file when closed (and will automatically close when no more references exist to it).If you dig into the implementation, though, you'll see that  uses :Race Conditions: Why we like tryWe like  because it avoids race conditions. With , you simply attempt to read your file, expecting it to be there, and if not, you catch the exception and perform whatever fallback behavior makes sense.If you want to check that a file exists before you attempt to read it, and you might be deleting it and then you might be using multiple threads or processes, or another program knows about that file and could delete it - you risk the chance of a race condition if you check it exists, because you are then racing to open it before its condition (its existence) changes. Race conditions are very hard to debug because there's a very small window in which they can cause your program to fail.But if this is your motivation, you can get the value of a  statement by using the  context manager.Avoiding race conditions without a try statement: Python 3.4 gives us the  context manager (previously the  context manager), which does semantically exactly the same thing in fewer lines, while also (at least superficially) meeting the original ask to avoid a  statement:Usage:For earlier Pythons, you could roll your own , but without a  will be more verbose than with. I do believe this actually is the only answer that doesn't use  at any level in the Python that can be applied to prior to Python 3.4 because it uses a context manager instead:Perhaps easier with a try:Other options that don't meet the ask for "without try":isfilefrom the docs:Return True if path is an existing regular file. This follows symbolic  links, so both  and  can be true for the same path.But if you examine the source of this function, you'll see it actually does use a try statement:All it's doing is using the given path to see if it can get stats on it,  catching  and then checking if it's a file if it didn't raise the exception.If you intend to do something with the file, I would suggest directly attempting it with a try-except to avoid a race condition:os.accessAvailable for Unix and Windows is , but to use you must pass flags, and it does not differentiate between files and directories. This is more used to test if the real invoking user has access in an elevated privilege environment:It also suffers from the same race condition problems as . From the docs:Note:  Using access() to check if a user is authorized to e.g. open a file  before actually doing so using open() creates a security hole, because  the user might exploit the short time interval between checking and  opening the file to manipulate it. Itâ€™s preferable to use EAFP  techniques. For example:is better written as:Avoid using . It is a low level function that has more opportunities for user error than the higher level objects and functions discussed above.Criticism of another answer:Another answer says this about :Personally, I prefer this one because under the hood, it calls native APIs (via "${PYTHON_SRC_DIR}/Modules/posixmodule.c"), but it also opens a gate for possible user errors, and it's not as Pythonic as other variants:This answer says it prefers a non-Pythonic, error-prone method, with no justification. It seems to encourage users to use low-level APIs without understanding them. It also creates a context manager which, by unconditionally returning , allows all Exceptions (including  and !) to pass silently, which is a good way to hide bugs.This seems to encourage users to adopt poor practices.
Importing  makes it easier to navigate and perform standard actions with your operating system. For reference also see How to check whether a file exists using Python?If you need high-level operations, use .
Testing for files and folders with ,  and Assuming that the "path" is a valid path, this table shows what is returned by each function for files and folders:You can also test if a file is a certain type of file using  to get the extension (if you don't already know it)
In 2016 the best way is still using :Or in Python 3 you can use :
It doesn't seem like there's a meaningful functional difference between try/except and , so you should use which one makes sense.If you want to read a file, if it exists, doBut if you just wanted to rename a file if it exists, and therefore don't need to open it, doIf you want to write to a file, if it doesn't exist, doIf you need file locking, that's a different matter.
You could try this (safer):The ouput would be:([Errno 2] No such file or directory:  'whatever.txt')Then, depending on the result, your program can just keep running from there or you can code to stop it if you want.
Although I always recommend using  and  statements, here are a few possibilities for you (my personal favourite is using ):Try opening the file:Opening the file will always verify the existence of the file. You can make a function just like so:If it's False, it will stop execution with an unhanded IOErroror OSError in later versions of Python. To catch the exception,you have to use a try except clause. Of course, you can alwaysuse a  except` statement like so (thanks to hsandtfor making me think):Use :This will check the existence of what you specify. However, it checks for files and directories so beware about how you use it.Use :This will check whether you have access to the file. It will check for permissions. Based on the os.py documentation, typing in , it will check the existence of the path. However, using this will create a security hole, as someone can attack your file using the time between checking the permissions and opening the file. You should instead go directly to opening the file instead of checking its permissions. (EAFP vs LBYP). If you're not going to open the file afterwards, and only checking its existence, then you can use this.Anyway, here:I should also mention that there are two ways that you will not be able to verify the existence of a file. Either the issue will be  or . If you catch an , set the  (like my first option), and then type in  so that you can hopefully determine your issue. I hope it helps! :)
Date:2017-12-04Every possible solution has been listed in other answers.An intuitive and arguable way to check if a file exists is the following:I made an exhaustive cheatsheet for your reference:
In Python 3.4 the language provides a new module to manage files:
Additionally, :Being , , and  the flags to test for permissions (doc).
If the file is for opening you could use one of the following techniques:UPDATEJust to avoid confusion and based on the answers I got, current answer finds either a file or a directory with the given name.
Raising exceptions is considered to be an acceptable, and Pythonic,  approach for flow control in your program. Consider handling missing  files with IOErrors. In this situation, an IOError exception will be  raised if the file exists but the user does not have read permissions.SRC: http://www.pfinn.net/python-check-if-file-exists.html
You can write Brian's suggestion without the . is part of Python 3.4. In older releases you can quickly write your own suppress:
If you imported NumPy already for other purposes then there is no need to import other libraries like , , , etc.This will return true or false based on its existence.
Check file or directory existsYou can follow these three ways:Note1: The  used only for filesNote2: The  used for both files and directoriesThe  method (included in Python 3+, installable with pip for Python 2)
Adding one more slight variation which isn't exactly reflected in the other answers.This will handle the case of the  being  or empty string.Adding a variant based on suggestion from ShahbazAdding a variant based on suggestion from Peter Wood
I'm the author of a package that's been around for about 10 years, and it has a function that addresses this question directly. Basically, if you are on a non-Windows system, it uses  to access .  However, if you are on Windows, it replicates  with an efficient filesystem walker.The code itself does not use a  blockâ€¦ except in determining the operating system and thus steering you to the "Unix"-style  or the hand-buillt . Timing tests showed that the  was faster in determining the OS, so I did use one there (but nowhere else).And the docâ€¦The implementation, if you care to look, is here:https://github.com/uqfoundation/pox/blob/89f90fb308f285ca7a62eabe2c38acb87e89dad9/pox/shutils.py#L190
Here's a 1 line Python command for the Linux command line environment. I find this VERY HANDY since I'm not such a hot Bash guy.I hope this is helpful.
You can use the "OS" library of Python:
How do I check whether a file exists, without using the try statement?In 2016, this is still arguably the easiest way to check if both a file exists and if it is a file: is actually just a helper method that internally uses  and  underneath. This  is a lower-level method that will provide you with detailed information about files, directories, sockets, buffers, and more. More about os.stat hereNote: However, this approach will not lock the file in any way and therefore your code can become vulnerable to "time of check to time of use" (TOCTTOU) bugs.So raising exceptions is considered to be an acceptable, and Pythonic, approach for flow control in your program. And one should consider handling missing files with IOErrors, rather than  statements (just an advice).


Answer URL
https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file
https://docs.python.org/3/library/os.path.html#os.path.exists
https://docs.python.org/3/library/os.html#os.stat
https://docs.python.org/3/library/os.html#os.stat
https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file
https://docs.python.org/3/reference/datamodel.html#context-managers
https://docs.python.org/3/library/contextlib.html#contextlib.suppress
https://docs.python.org/3/reference/compound_stmts.html#with
https://docs.python.org/3/reference/compound_stmts.html#try
https://docs.python.org/3/reference/compound_stmts.html#except
https://docs.python.org/3/reference/compound_stmts.html#finally
https://docs.python.org/3/library/os.html#os.listdir
https://docs.python.org/3/library/os.html#os.scandir
https://docs.python.org/3/library/contextlib.html#contextlib.suppress
https://docs.python.org/3/library/os.html#os.access
https://docs.python.org/3/whatsnew/3.6.html#optimizations
https://docs.python.org/3/library/os.html#os.replace
https://docs.python.org/3/library/os.path.html#os.path.exists
