Natural Text
When using  to run "" (just as an example), on Windows we get this:So it's nicely printing out the version as I expect. But on Linux we get this:Because gcc hasn't received the  option.The docs don't specify exactly what should happen to the args under Windows, but it does say, on Unix, "If args is a sequence, the first item specifies the command string, and any additional items will be treated as additional shell arguments." IMHO the Windows way is better, because it allows you to treat  calls the same as  ones.Why the difference between Windows and Linux here?
Actually on Windows, it does use  when  - it prepends  (it actually looks up the  environment variable but defaults to  if not present) to the shell arguments. (On Windows 95/98 it uses the intermediate  program to actually launch the command).So the strange implementation is actually the  one, which does the following (where each space separates a different argument):It looks like the correct implementation (at least on Linux) would be:Since this would set the command string from the quoted parameters, and pass the other parameters successfully.From the  man page section for :This patch seems to fairly simply do the trick:
From the subprocess.py source:On UNIX, with shell=True: If args is a string, it specifies the  command string to execute through the shell.  If args is a sequence,  the first item specifies the command string, and any additional items  will be treated as additional shell arguments.On Windows: the Popen class uses CreateProcess() to execute the child  program, which operates on strings.  If args is a sequence, it will be  converted to a string using the list2cmdline method.  Please note that  not all MS Windows applications interpret the command line the same  way: The list2cmdline is designed for applications using the same  rules as the MS C runtime.That doesn't answer why, just clarifies that you are seeing the expected behavior.The "why" is probably that on UNIX-like systems, command arguments are actually passed through to applications (using the  family of calls) as an array of strings. In other words, the calling process decides what goes into EACH command line argument. Whereas when you tell it to use a shell, the calling process actually only gets the chance to pass a single command line argument to the shell to execute: The entire command line that you want executed, executable name and arguments, as a single string.But on Windows, the entire command line (according to the above documentation) is passed as a single string to the child process. If you look at the CreateProcess API documentation, you will notice that it expects all of the command line arguments to be concatenated together into a big string (hence the call to ).Plus there is the fact that on UNIX-like systems there actually is a shell that can do useful things, so I suspect that the other reason for the difference is that on Windows,  does nothing, which is why it is working the way you are seeing. The only way to make the two systems act identically would be for it to simply drop all of the command line arguments when  on Windows.
The reason for the UNIX behaviour of  is to do with quoting. When we write a shell command, it will be split at spaces, so we have to quote some arguments:This leads to problems when our arguments contain quotes, which requires escaping:Sometimes we can get awful situations where  must be escaped too!Of course, the real problem is that we're trying to use one string to specify multiple strings. When calling system commands, most programming languages avoid this by allowing us to send multiple strings in the first place, hence:Sometimes it can be nice to run "raw" shell commands; for example, if we're copy-pasting something from a shell script or a Web site, and we don't want to convert all of the horrible escaping manually. That's why the  option exists:I'm not familiar with Windows so I don't know how or why it behaves differently.


Answer URL
https://docs.python.org/3/library/subprocess.html#popen-constructor
