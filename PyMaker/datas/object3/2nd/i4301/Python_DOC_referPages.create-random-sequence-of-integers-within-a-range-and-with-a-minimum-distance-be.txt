Natural Text
What is the fastest way to generate a specific nr of integers of random value uniformly distributed within a specific range and with a minimum distance between each element?For example, given a sequence range between 0 and 20, we want to create 5 elements with at least 3 points distance between each element, the result could be something like this  or  I created a loop that achieves this but it is very slow when i want to create ranges in the order of millions. 
How about the following recipe: If you want a gap of 3 between your 5 adjacent elements, but want a total range of 20, then you effectively have  steps of "slack" that you can randomly distribute in the gaps between your elements. Suppose we generate a number in that range, and scatter it between the elements, then we end up with code something like the following:If you then invoke this  function ten times, you get a collection of vectors something like the following:
This:will give you 5 random numbers spaced by at least 3 points.You have to tweak  to get the correct maximum value of the random numbers. Perhaps you may want to have a slightly bigger  and the reject samples whose elements exceed your maximum value (20).Note: you didn't say what final distribution you are looking for, e.g. if you want the resulting samples uniformly distributed over the space of the valid samples, or anything else, if that matters.
This answer is a followup to the comments on my previous answer.You said you want uniformly distributed numbers, but that of course is not possible to have while respecting the condition that the numbers must be spaced by at least 3 points.So, I provide you a different definition of uniformly randomness: suppose you can enumerate all the valid vectors respecting your condition. I wrote a function to do so:Let's consider a smaller instance of the problem. Suppose you want vectors of 3 random numbers from 0 to 10 (excluded), spaced by at least 4 points:that list is the complete enumeration of all valid results according to that rule.Now you can uniformly sample from this list (see for example random.choice).Now it's possible that your problem size (i.e. the range, or the vector size) make the problem instance too big to be exhaustively enumerated.But you can still use this "brute force" enumeration to check if a method generates truly uniformly distributed samples.For the problem instance of your question (0-20 range, 5 length, 3 min. dist) it's still doable:For example, we can check if rwp's recipe generates uniformly distributed samples (according to this definition):and we observe this distribution of counts:Clearly there are some vectors occurring way more often than other vectors.We can also check the first solution I proposed:even with =15 and using rejection sampling, it's still a bit skew and not perfectly uniform. Using the same benchmark/plot code as before:


Answer URL
https://docs.python.org/3/library/random.html#random.choice
