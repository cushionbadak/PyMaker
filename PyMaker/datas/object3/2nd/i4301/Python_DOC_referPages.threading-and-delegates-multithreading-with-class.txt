Natural Text
I can make the below example to run on a different thread (for every function I'm calling) but I'm having a problem when I'm trying to combine it with Classes and delegation.In the below example calling  into the classes, I always get the same thread.Any ideas why this is happening?
Okay, few points before going to the solution which I got after trying quite a while: (The working code is below, if you want to skip the explanation)(i) If you look at what Thread.start() does, you will see that it is mentioned that itarranges for  method to be invoked in a separate thread of control.So, what that means is, currently, without  functions in your code for the thread classes, it is not going to invoke the other functions in a separate thread of control.Hence the main thread is executing all of it. To understand this, place two of the run function definitions in each of your thread class: and try running it. You will see that now, the separate threads are invoked.(ii) So how would you go about calling your custom functions from ?When you look at Thread.run()'s definition, it saysThe standard run() method invokes the callable object passed to the objectâ€™s constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively.So one way to do this is to you pass your arguments in the call  and receive and initialize it in  as:Your  function would then call your  or function like(iii) But now, how are you going to call the other thread each time in the loop? You can only start a thread once and if you try giving a  for the  thread in the loop each time, it is not going to go back to the thread's execution. It will continue that function in the same thread .(iv) And also, how are you going to pass the current list value to , execute the cube root, and then jump back to  and proceed with square of the next number?For solving (iii) and (iv), you would need both a  (where the shared list can reside) and a synchronization mechanism that can safely execute one thread, then give control to the next, take it back again, etc.Remember, threads share the same address space, so we should be careful to avoid race conditions, and only one thread can use the scheduler at a time. This is why a synchronization mechanism is needed.Okay, so there are better ways to solve your problem (like just have two functions for square and cube and create two threads that call those functions directly without involving a class for each thread) but I have worked out a solution you can use to achieve your desired result.Here is the code (with comments as explanations):Read more about the lock used here: threading.RLockSo, here what the lock class does is that, initially thread t1 can only start a job when owner is set to A, and thread t2 can only start a job when owner is set to B. Once thread calls , it acquires the lock to scheduler, executes, and when thread calls , it assigns the owner to the passed argument (the other thread) and releases the lock.Your output on running the above code would be:Is this explanation clear to you? If you have any doubt, let me know. Hope this helps! :)


Answer URL
https://docs.python.org/3/library/threading.html#threading.Thread.start
https://docs.python.org/3/library/threading.html#threading.Thread.run
