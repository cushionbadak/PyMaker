Natural Text
Say for a list comprehension like this:what are the exact steps that Python is taking to evaluate the right hand expression and assign it to ? Between 2.x and 3.x ... is the internal logic to handle something like this varying between the two?I would imagine that from a procedural perspective, Python is first performing  then starting to iterate over the resulting list stripping the elements and then splitting them then appending the result a new list and finally pointing to that last list as .Is it internally allocating a new list for each operation? (One list for the resulting , then another list for the result of , etc.?Thank you for any insight.
In Python 3.x, your list comprehension is compiled into something much like this:There are a few minor differences—the compiler can use something a bit faster than  because  isn't accessible;  is actually named something that isn't a valid identifier so you can't accidentally call it; etc. But that's basically it.1For full details, see Displays for lists, sets, and dictionaries in the reference documentation.That  just calls . If  is a , that's handled by creating a new list with the elements from 10 through the end of . But if  were, say, a numpy array, it might be a view into the same memory of , and if it were an instance of some crazy class you created just to see how you could screw with things, it could be anything you wanted, like the string .Similarly, if the elements of  are strings (or ), the  method returns a new string with all of the characters but the stripped-off whitespace copied, and the  method returns a new list of copied strings.In Python 2.x, it's more like this:Although again, it's not exactly this— and  have names that aren't valid identifiers, and the optimized special version of  is used, and so on.The 2.x documentation is in List Displays.The main reason for the change was that the 2.x design means the  leaks out into the enclosing scope,2 although the fact that it allowed comprehensions and generator expressions to share most of the same code was another benefit.The other list and string operations are the same between 2.x and 3.x. While many functions did change to return iterators instead of copied lists in 3.x, slicing and splitting are not among them.The tutorial has a nice section on comprehensions, but it explains the 2.x behavior even in 3.x (because it's a bit easier to understand, and the difference isn't likely to matter to novices' code—it is a tutorial, after all).1. Also, notice the way the outermost iterable is passed in as an argument. This means you don't accidentally end up capturing a nested variable in a closure. Which doesn't make much difference for list comprehensions, but it's important for generator expressions, where the iteration may not start until after the value of that captured variable has changed.2. In 2.3-2.6, this leaking was officially documented behavior you could rely on. In 2.7, it was deprecated, and you aren't supposed to rely on it either leaking or not leaking. But in all current major implementations of 2.7 (and there won't be any new ones), list comprehensions always leak, although set and dict comprehensions do not.
Yeah, a new list is created for  (assuming  is a list), and a new list is created for each  call (assuming  is a ).It is equivalent to:Except that  isn't assigned to until the endNote, by convention, you shouldn't use  as a variable name unless you intend for it to not be used.Finally, one major difference between list comprehensions between Python 2 and Python 3 is that Python 3 creates an enclosing scope (essentially, a function scope) for the expression inside the list comprehension. Python 2 comprehensions do not, and variable will "leak" out of the construct.So, in Python 3:However, in Python 2:And if you really want, you can dig into the CPython internals a bit using :Note, the first three operations essentially create a function where the list comprehension magic happens. We can further introspect:And this is the bytecode that is actually executed for the comprehension. Note that the list is given the name , which you can see here:  `


Answer URL
https://docs.python.org/3/reference/expressions.html#displays-for-lists-sets-and-dictionaries
https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions
