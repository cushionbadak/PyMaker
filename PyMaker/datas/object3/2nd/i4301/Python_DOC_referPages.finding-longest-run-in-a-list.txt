Natural Text
Given a list of data, I'm trying to create a new list in which the value at position  is the length of the longest run starting from position  in the original list. For instance, givenShould return:My solution: Firstly I create a list  of tuples, where every tuple's first element is the element from , and where the second element is the number of the total run.  In this case:Having this, I create a new list and append appropriate values.However, I was wondering if there is a shorter way/another way to do this? 
Here's a simple solution that iterates over the list backwards and increments a counter each time a number is repeated:Result:
This is possible using :ResultExplanationFirst use  to group identical items in your list.For each item in your , create a  object which counts backwards from the length of the number of consecutive items to 1.Turn this all into a generator to avoid building a list of lists.Use  to chain the ranges from the generator.Performance notePerformance will be inferior to @Aran-Fey's solution. Although  is O(n), it makes heavy use of expensive  calls. These do not scale as well as iteration in simple  loops. See itertools docs for  pseudo-code.If performance is your main concern, stick with the  loop.
You are performing a reverse cumulative count on contiguous groups.  We can create a Numpy cumulative count function withand then generate our result with
I would use a generator for this kind of task because it avoids building the resulting list incrementally and can be used lazily if one wanted:This will also work if the input cannot be  (certain generators/iterators cannot be reversed):And it works for your input:This can actually be made simpler by using :I also did some benchmarks and according to these Aran-Feys solution is the fastest except for long lists where piRSquareds solution wins:This was my benchmarking setup if you want to confirm the results:Python 3.6.5, NumPy 1.14
Here's a simple iterative approach to achieve it using :which will return you  as:As an alternative, here's one-liner to achieve this using list comprehension with  but it is not performance efficient due to iterative usage of :
You can count the consecutive equal items and then add a countdown from count-of-items to 1 to the result:(A couple of minutes later) Oh, that's the same as MSeifert's code but without the iterable aspect. This version seems to be almost as fast as the method shown by Aran-Fey.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.groupby
https://docs.python.org/3/library/collections.html#collections.Counter
https://docs.python.org/3/library/functions.html#enumerate
