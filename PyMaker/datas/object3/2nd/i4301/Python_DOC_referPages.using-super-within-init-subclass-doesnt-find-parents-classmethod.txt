Natural Text
This question already has an answer here:Why does a classmethod's super need a second argument?                    1 answer                I try to access the classmethod of a parent from within  however that doesn't seem to work.Suppose the following example code:which produces the following exception:The  however shows that  is a part of it: .So I don't understand why  doesn't dispatch to . Can someone explain this?
A normal  object (what you normally get from calling  or  or ) keeps track of both the type and the object it was created with. Whenever you look up an attribute on the , it skips over  in the method resolution order, but if it finds a method it binds it to that  object.An unbound  has no  object. So,  skips over  in the MRO to find the method , and then binds it to… oops, it has nothing to call it on.So, what things can you call a  on? The class itself, or a subclass of it, or an instance of that class or subclass. So, any of those will work as the second argument to  here, the most obvious one being:This is somewhat similar to the difference between staticmethods (bound  are actually bound to nothing) and  (bound  are bound to the class instead of an instance), but it's not quite that simple.If you want to know why an unbound  doesn't work, you have to understand what an unbound  really is. Unfortunately, the only explanation in the docs is:If the second argument is omitted, the super object returned is unbound.What does this mean? Well, you can try to work it out from first principles as a parallel to what it means for a method to be unbound (except, of course, that unbound methods aren't a thing in modern Python), or you can read the C source, or the original introduction to 2.2's class-type unification (including a pure-Python  clone).A  object has a  attribute, just like a method object. And  is missing its , just like  is.1You can't use an unbound  explicitly the way you can with an unbound method (e.g.,  does the same as , but  doesn't work the same as ). But you can use them implicitly, the same way you do with unbound methods all the time without normally thinking about it.If you don't know how methods work, the tl'dr is: when you evaluate , Python looks up , doesn't find it on  itself, but does find it on the type, so it checks whether it's a non-data descriptor, and, if so, calls its  method to bind it to .So, unbound methods2 are non-data descriptors whose  method returns a bound method. Unbound s are similar, but their  ignores the object and returns a bound method bound to the class. And so on. And unbound s are non-data descriptors whose  method returns a bound .Example (credit to wim for coming up with the closest thing to a use for unbound  that I've seen):We created an unbound super , stuck it on the type , and then  is a normal bound super, so  is , just like  would have been inside a  method.Why would you want to do that? I'm not sure. I've written all kinds of ridiculously dynamic and reflective code in Python (e.g., for transparent proxies to other interpreters), and I can't remember ever needing an unbound . But if you ever need it, it's there.1. I'm cheating a bit here. First, unbound methods aren't a thing anymore in Python 3—but functions work the same way, so Python uses them where it used to use unbound methods. Second, , being a C builtin, wasn't properly an unbound method even in 2.x—but it acts like one anyway, at least as far as we're concerned here.2. Actually plain-old functions.


Answer URL
https://docs.python.org/3/library/functions.html#super
https://docs.python.org/3/howto/descriptor.html
https://docs.python.org/3/library/functions.html#super
