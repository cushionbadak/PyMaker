Natural Text
So I tried to simplify the problem as much as possible. I know this looks like a wall of text but I try to give you a bit of context.  I created a simple sqlite database with over 6 millions row. the test table look like this:I am trying to see if its possible to multi-thread calls at the same time so I get a faster I/O.After reading the docs and checking SO, I decided to use . the fetching code look like this:this get a runtime of about 88 seconds. but when I simply call them one after the other, I get a runtime of about 27 seconds:I did the same test on a MS SQL Server and was getting similar result. I am very confuse on what I am doing wrong and why is it so much slower with the multi-thread approach, any tips or tricks would be appreciated
Some backgroundPython has a Global Interpreter Lock so only one operation will actually be occurring at any one given time. The Python threading module provides concurrency, but not parallelism. As a very simplistic analogy, you could think of having two decks of cards in front of you, and you want to look at every card in both decks. The threading module presents itself as though it picks a card from each deck and reads both simultaneously, but behind the scenes it just shuffles the decks together and looks at the cards one at a time.Without knowing many intimate details, I would guess that the performance is not as expected, because the "threaded" calls are actually happening serially, the extra overhead of the threading, in this case, only acts as a performance detriment.  SolutionPython provides a different method for parallelism in the multiprocessingmodule. It spawns (or is capable or spawning depending on use) a new interpreter process which runs the desired function in parallel. Sharing memory between processes is somewhat more complicated than with threads though, so it's NOT likely to be as simple as changing  to .


Answer URL
https://docs.python.org/3/library/threading.html
