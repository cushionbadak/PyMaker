Natural Text
I'm looking to get the path of a module after  has been called.In this example:..the  variable will be , as will  -- yet, there's no way to know where  is located now, right?What could I use, outside (or inside, without storing it as a variable at import time) of , which would allow me to discover the location of ?I'm attempting to build a definitive method to determine which file a module is executing from.  Since I use IPython as a shell, this is something I could actually run into.  Example usage:I have two versions of a project I'm working on, and I'm comparing their behavior during the process of debugging them.  ..let's say they're in the directories  and .  ..which  do I have loaded in the IPython interpreter again?The ideal:** As abarnert noted, that is not possible, as python does not record the base directory location of relative imports.  This will, however, work with normal (non-relative) imports.** Also, regular python (as opposed to IPython) does not allow imports from the current directory, but rather only from the module directory.
The information isn't available anymore, period. Tracebacks, the debugger, ipython magic, etc. can't get at it. For example:So:the  variable will be , as will  -- yet, there's no way to know where  is located now, right?Right. As you can see, Python treats it as a relative path, and (incorrectly) resolves it according to the current working directory whenever it needs an absolute path.What could I use, outside (or inside, without storing it as a variable at import time) of 'foo', which would allow me to discover the location of foo?Nothing. You have to store it somewhere.The obvious thing to do is to store  from outside, or  from inside, at import time. Not what you were hoping for, but I can't think of anything better.If you want to get tricky, you can build an import hook that modifies modules as they're imported, adding a new  attribute or, more simply, changing  to always been an abspath. This is easier with the  module Python 3.1+.As a quick proof of concept, I slapped together . After doing an , every further  you do that finds a normal .py file or package will absify its .I don't know whether it works for .so/.pyd modules, or .pyc modules without source. It definitely doesn't work for modules inside zipfiles, frozen modules, or anything else that doesn't use the stock . It won't retroactively affect the paths of anything imported before it. It requires 3.3+, and is horribly fragile (most seriously, the  class or its hook function has to be the last thing in â€”which it is by default in CPython 3.3.0-3.3.1 on four Mac and linux boxes I tested, but certainly isn't guaranteed).But it shows what you can do if you want to. And honestly, for playing around in iPython for the past 20 minutes or so, it's kind of handy.
 now has original directory stored in it...


Answer URL
