Natural Text
I'm trying to solve this problem from Timus Online Judge. To solve this problem you need  generate a sequence of 1 000 000 lowercase Latin letters and write it to stdin in 1 second.It is easy to solve this problem with C++ or Java. I have python solution here:It takes 1.7s:And I got "Time limit exceeded" in result. So the question is "How to do it faster?"UPD1:Using  reduces time at 16ms. Now it is 1.740sUPD2:Solution by @Martijn Pieters takes 0.979s, but it doesn't pass test either.UPD3Martijn Pieters suggested a very good solutions, but it's still slow:Takes 0.924sTakes 1.173sTakes 1.155sTakes 0.901sUPD4Some guy just solved problem on Timus. I hope he will share his solution :)UPD5Thanks to Ashwini Chaudhary for sharing his Python 2.x solution with us:It takes 0.527s on my computer and it passes tests on Timus. But problem with Python3.x still remains.UPD6Thanks to Markku K. this code:Takes 0.445s, but still didn't pass the test
Here's Python 3 code that generates 1000000 "random" lowercase letters in  seconds (see also -seconds solution at the end; @Ashwini Chaudhary's code from the question takes  seconds on my machine,  @Markku K.'s code -- ): skews the distribution (see at the end on how to fix it) though It still satisfies the conditions (ascii, lowercase, frequencies of 1, 2, 3 letter sequences):where :Note: on acm.timus.ru  gives "Output limit exceeded".To improve performance, you could use  method ( seconds):How to fix  skew (number of bytes) is not evenly divisible by  (number of lower Latin letters) therefore the formula  makes some values appear less often than others e.g.:Here, the input  is uniformly distributed (each byte occurs exactly once) but  letters in the output are less often then the rest  vs.  occurrences. To fix it, unaligned bytes could be dropped:Here, the input is uniformly distributed bytes in the range  the output is uniformly distributed ascii lowercase letters. accepts the second argument to specify bytes to delete:If the random generator ( here) produces long sequences of the bytes that are outside of the aligned range () then the  loop may execute many times.The time performance can be improved by another order of magnitude if  is used instead of . The former uses Mersenne Twister as the core generator that may be faster than  that uses sources provided by the operating system. The latter is more secure if you use the random string for secrets.
Use  instead of  to generate lowercase charaters:Also writing to  directly appears to be faster, encoding yourself in python is not faster than having it all handled in the C code.I also use a list comprehension;  needs to scan through the input sequence twice, once to determine the length of the output, once to actually copy the input elements to output  string. A list comprehension then beats out the slower generator-to-list code.Just using  over your method of generating each character from an integer is over twice as fast:You could try and avoid the  overhead by writing individual characters directly to :Next to try is to write raw bytes:but these are no improvements over  in my tests.Next we move to encoding the ASCII characters to bytes once, then using : is a list of lowercase ASCII characters encoded to bytes, from which we random pick 1 million items, join them to into a large byte string then write that in one go to the binary stdout buffer.The bytes join is just as 'slow' as the string version:but we encode 26 characters, not 1 million so the write stage is faster.
I get a huge speed improvement by changing from randint(0,25) to int(random()*25) in your original solution. On my machine, the time went from about 2 seconds, to about 0.6 seconds. If you take a look at the random.py code, you will see that randint is full of checks that you don't want or need.update: Oops, off by one. You need int(random()*26). Thanks Ashwini
My solution which just got accepted (python 2.7, Execution time: 0.984):Accessing elements of a list is faster is than for strings.And you don't need  or  here as most online judges us something like this to test your script:So you can use  instead of  and  instead of , though for huge inputs  is faster than .Update 1:Using @Markku's  tip execution time was reduced to .64 in py2.7:
Try turning some part of it into C++ or another compiled language. That will almost guaranteed make it faster. Python, unfortunately, isn't too fast, especially when it comes to things like this. Try C++, C, or Pascal.EDIT: Also see the Python Performance Tips
Generate and write in chunks that are a larger power of 2 in size.Maybe use a string or array of the 26 lower-case letters and randomly pick then instead of generating chars.
Use random.choices?On Python 3.6:


Answer URL
https://docs.python.org/3/library/random.html#random.choices
