Natural Text
normaly I can use eval like that:in this case it would return true and therefore I would know that the color in new_dict is actually green. Now I found some code where somebody wanted to use eval but with a more general object instead of a dict.In the following code is basicly what this person did:I wonder now - how did the developer of the above code know that eval is using the method  on new_dict for color? I found the documentation and the python help function, but I couln't find a step-by-step documentation for a method (or the actual code), so that I would never ever came up on the idea to do just that what the above code does. Or is it bad to use the above method, because no one really knows how the eval method has been implemented and the code could therefore come up with some strange errors in future?EDIT: Here is why eval is used in the program: Imagine you got like 20 objects of myStuff in a list mylist and you want to filter them by color yellow, then one can simply call [ n for n in mylist if eval(query, Dummy(n) ] with `query="color=='yellow'". I am not an expert but I just want to know if this method can lead to problems.
The  function is a way to simulate a dictionary or list (or, more accurately, any mapping or sequence).The reference documentation for sequences and mappings is in Data model, but the best place to start is probably with the  module, and the links from there.To summarize the basic idea, when you write code like this:Python translates it into*:There is nothing wrong with defining  to simulate a . And doing it to create an object that treats its attributes as dict items is such a common pattern that it has a name ("attrdict").However, using  is almost always the wrong thing to do. So, doing the right thing to make  work is, generally, right in that you're doing the right thing, but wrong in that you're using  in the first place.In your particular case, there's no good reason to use  in the first place. Instead of this:Just do this:One reason Python novices (especially those who grew up on old versions of PHP, Tcl, or JavaScript) often want to use  is to get an expression they can pass around easily. But in Python (and, for that matter, modern PHP and JS), functions are first-class values, just as easy to pass around as strings—and, unlike strings, of course, they're callable. You can create named or lambda functions, or use , close over whatever local variables you want, etc. There is almost nothing you can do with a string you can't do with a function—except, of course, for opening a gaping security hole, slowing down performance, and hindering debugging.So, instead of something like this:… just do this:In you edited question:Here is why eval is used in the program: Imagine you got like 20 objects of myStuff in a list mylist and you want to filter them by color yellow, then one can simply call [ n for n in mylist if eval(query, Dummy(n) ] with `query="color=='yellow'".So, you're presumably doing something like this:But you could just as easily do this:Even when you need something more dynamic, you can build functions dynamically, even more easily than strings:In fact, if you really want to, you can even make this completely functional:But the great thing about Python is that you don't have to go completely functional or completely imperative, you can write something half-way between—or 25% or 75%, whatever happens to be easiest to read and write.Meanwhile:Or is it bad to use the above method, because no one really knows how the eval method has been implemented and the code could therefore come up with some strange errors in future?No, that's almost never a problem. First, the documentation for  is generally sufficient to predict exactly what it will do, and all Python implementations must follow that documentation.In the rare occasions where you do need to know more, all of the major implementations are open source, so you can just read the code. For example, you can browse the CPython 3.3 code online here.*** This isn't completely accurate; the real code actually looks up  in the class rather than the object (slightly differently for old-style vs. new classes in 2.x), and handles extension types from C modules/Java packages/whatever's appropriate to your Python implementation, deals with slices (differently in 2.x vs. 3.x), etc. But that's the basic idea.** The  code has been gradually refactored over the years, so at this point you could pretty much reimplement  in a few lines of pure Python by using the  module and friends, or a few lines of C using the  functions, so it's hard to point you to the exact line of code to start in without knowing which implementation and version you care about.
 is what s use to retrieve items by their key. By overriding  and making it return the attributes of , you essentially turn  into a dictionary.A simpler way would be to just use the  attribute, which does the same thing:But really, don't use this. Please.  is rarely the right tool for the job and this is a perfect instance of where you don't need to use .


Answer URL
