Natural Text
I'd like to automate handbrake a little bit and wrote a little program in python.Now I have a problem with the subprocess and threading module. I want to dynamically change the number of handbrake processes which I run. And I implement the queue module, for getting and putting the movies. calls the encode method in the handbrake class, and encode calls . Now I want to store the progress, which I read in the handbrake class, in the compressor class centralized. So I can publish the progress to a  and a . No I write to a  db, but this should be removed(because of threading issues), and only on exit of the program saved.The only way I can think of save the data centralized is to create another thread, and poll data in the  class. My problem with this is that there are 4 threads for my program. Is there a better solution? Maybe the db is not wrong, and I shouldn't remove it?Compressor class:A piece of the handbrake class:
Just do exactly what you were planning to do.If this means you have 5 threads instead of 4, so what?None of your threads are CPU-bound. That is, they're not crunching numbers or parsing strings or doing other computational work, they're just waiting on I/O, or an external process, or another thread. So there's no harm in creating more non-CPU-bound threads, unless you go hog-wild to the point where your OS can't handle them smoothly anymore. Which is in the hundreds.If any of your threads were CPU-bound, then even 2 would be too many. In CPython,* threads have to acquire the Global Interpreter Lock to do any work,** so they end up not running in parallel, and spending more time fighting over the GIL than working. But even then, adding another non-CPU-bound thread that spends all its time waiting on a queue that the CPU-bound threads were filling wouldn't make things significantly worse than they already are.***As for the dbâ€¦SQLite3 itself, as long as you have a new enough version, is fine with multithreading. But the Python  module is not, for backward compatibility with very old versions of the SQLite3 engine. See Multithreading in the docs for details. If I remember correctly (the site seems to be temporarily down, so I can't check), you can build the third-party module  (which the stdlib module is based on) with threading support if you need to. However, if you're not using the database very heavily, running a single thread to talk to the database, with a queue to listen to other threads, is a perfectly reasonable design.* And PyPy, but not necessarily in other implementations.** Extension modules can release the GIL to do work in C, as long as they don't touch any values visible from Python. Some well-known modules like NumPy take advantage of this.*** The waiting thread itself might be hampered by the CPU-bound threads, especially in Python 3.1 and earlier, but it won't interfere with them.


Answer URL
