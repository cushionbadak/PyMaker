Natural Text
I wrote the following insertion sort algorithmEdit: All you need to do is change the final > to < to get it to work in reverse.However, what do most people do in these situations? Write the algorithm twice in two if-statements, one where it's > and the other where it's < instead? What is the "correct" way to typically handle these kinds of scenarios where the change is minor but it simply changes the nature of the loop/code entirely? I know this question is a little subjective.
You could use a variable for the less-than operator:
Option 1:Option 2:
You'll probably notice that  and  and all other functions that do any kind of potentially-decorated processing have a  parameter, and those that specifically do ordering also have a  parameter. (The Sorting Mini-HOWTO covers this.)So, you can look at how they're implemented. Unfortunately, in CPython, all of this stuff is implemented in C. Plus, it uses a custom algorithm called "timsort" (described in ). But I think can explain the key parts here, since it's blindingly simple. The  code is separate from the  code, and they're both spread out over a slew of functions. But if you just look at the top-level function , you can see how it handles the  flag:Why reverse the list at the start as well as the end? Well, in the case where the list is nearly-sorted in the first place, many sort algorithms—including both timsort and your insertion sort—will do a lot better starting in the right order than in backward order. Yes, it wastes an O(N)  call, but you're already doing one of those—and, since any sort algorithm is at least O(N log N), and yours is specifically O(N^2), this doesn't make it algorithmically worse. Of course for smallish N, and a better sort, and a list in random order, this wasted 2N is pretty close to N log N, so it can make a difference in practice. It'll be a difference that vanishes as N gets huge, but if you're sorting millions of smallish s, rather than a few huge ones, it might be worth worrying about.Second, notice that it does the reversing by creating a reverse slice. This, at least potentially, could be optimized by referencing the original  object with  in reverse order, meaning the two reversals are actually O(1). The simplest way to do this is to literally create a reverse slice: . Unfortunately, this actually creates a new reversed , so timsort includes its own custom reverse-slice object. But you can do the same thing in Python by creating a  class.This probably won't actually be faster in CPython, because the cost of the extra function calls is probably high enough to swamp the differences. But you're complaining about the algorithmic cost of the two  calls, and this solves the problem, in effectively the same way that the built-in sort functions do.You can also look at how PyPy does it. Its  is implemented in . It delegates to one of a few different Strategy classes depending on what the list contains, but if you look over all of the strategies (except the ones that have nothing to do), they basically do the same thing:  the list, then  it.So, it's good enough for CPython, and for PyPy… it's probably good enough for you.


Answer URL
