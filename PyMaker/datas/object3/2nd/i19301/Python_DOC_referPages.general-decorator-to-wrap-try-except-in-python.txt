Natural Text
I'd interacting with a lot of deeply nested json I didn't write, and would like to make my python script more 'forgiving' to invalid input. I find myself writing involved try-except blocks, and would rather just wrap the dubious function up.I understand it's a bad policy to swallow exceptions, but I'd rather prefer they to be printed and analysed later, than to actually stop execution. It's more valuable, in my use-case to continue executing over the loop than to get all keys.Here's what I'm doing now:Here's what I'd like, (1):or (2):...where I can wrap either the single data item (1), or a master function (2), in some function that turns execution-halting exceptions into empty fields, printed to stdout.  The former would be sort of an item-wise skip - where that key isn't available, it logs blank and moves on - the latter is a row-skip, where if any of the fields don't work, the entire record is skipped.My understanding is that some kind of wrapper should be able to fix this.  Here's what I tried, with a wrapper:Here's why it doesn't work.  Call a function that doesn't exist, it doesn't try-catch it away:Before I even add a blank return value, I'd like to get it to try-catch correctly.  If the function had worked, this would have printed "Error", right?  Is a wrapper function the correct approach here?UPDATEI've had a lot of really useful, helpful answers below, and thank you for them---but I've edited the examples I used above to illustrate that I'm trying to catch more than nested key errors, that I'm looking specifically for a function that wraps a try-catch for...When a method doesn't exist. When an object doesn't exist, and is getting a method called on it. When an object that does not exist is being called as an argument to a function. Any combination of any of these things. Bonus, when a function doesn't exist.
You could use a defaultdict and the context manager approach as outlined in Raymond Hettinger's PyCon 2013 presentation
There are lots of good answers here, but I didn't see any that address the question of whether you can accomplish this via decorators.The short answer is "no," at least not without structural changes to your code.  Decorators operate at the function level, not on individual statements.  Therefore, in order to use decorators, you would need to move each of the statements to be decorated into its own function.But note that you can't just put the assignment itself inside the decorated function.  You need to return the rhs expression (the value to be assigned) from the decorated function, then do the assignment outside.To put this in terms of your example code, one might write code with the following pattern: could be something like:
It's very easy to achieve using configurable decorator.Just pass to get_decorator tuples with error types which you want to silence and default value to return.Output will beEdit: Thanks to martineau i changed default value of errors to tuples with basic Exception to prevents errors.
It depends on what exceptions you expect.If your only use case is , you could doFor the other cases, your decorator approach might be useful, but not in the way you do it.I'll try to show you:Nevertheless, won't work, becausea)  isn't yet active at the executon time andb) it is used wrong. The right way would be to wrap the function and then call it: .A "layer of lambda" would help here:wraps a lambda function which in turn calls a non-existing function. Calling  leads to calling the wrapper which calls the lambda which tries to call . If this doesn't exist, the lambda raises an exception which is caught by the wrapper.This works because the name  is not executed at the time the lambda is defined, but when it is executed. And this execution is protected and wrapped by the function  then.  So the exception occurs inside the lambda and is propagated to the wrapping function provided by the decorator, which handles it gracefully.This move towards inside the lambda function doesn't work if you try to replace the lambda function with a wrapper likefollowed by abecause here the name resolution is "back at the surface":  cannot be resolved and this happens before  or even  are called. So it doesn't work.And if you try to do something likeit cannot work as well if you have no , because  protects , not .If you want to protect  here, you'll have to dobecause the wrapper provided by  calls that lambda function which raises an exception which is then silenced.
in your case you first evaluate the value of the meow call (which doesn't exist) and then wrap it in the decorator. this doesn't work that way.first the exception is raised before it was wrapped, then the wrapper is wrongly indented ( should not return itself). You might want to do something like:output:anyway in your case I don't understand why you don't use a simple method such asand in the code:Edited:In case you want something that will work at any depth. You can do something like:That you'd call:And using your codeBy the way, on a personal point of view I also like @cravoori solution using contextmanager. But this would mean having three lines of code each time:
Since you're dealing with lots of broken code, it may be excusable to use  in this case.Then wrap all your potentially broken statements:
Why not just use cycle?Or if you wish write a little helper:Also you can combine both solutions if you have a few places where you need to get value and helper function would be more reasonable.Not sure that you actually need a decorator for your problem.
Extending @iruvar answer - starting with Python 3.4 there is an existing context manager for this in Python standard lib: https://docs.python.org/3/library/contextlib.html#contextlib.suppress


Answer URL
https://docs.python.org/3/library/contextlib.html#contextlib.suppress
