Natural Text
Edits and Updates3/24/2013:My output hash from Python is now matching the hash from c++ after converting to utf-16 and stoping before hitting any 'e' or 'm' bytes.  However the decrypted results do not match.  I know that my SHA1 hash is 20 bytes = 160 bits and RC4 keys can vary in length from 40 to 2048 bits so perhaps there is some default salting going on in WinCrypt that I will need to mimic.  CryptGetKeyParam KP_LENGTH or KP_SALT3/24/2013:CryptGetKeyParam KP_LENGTH is telling me that my key ength is 128bits. I'm feeding it a 160 bit hash. So perhaps it's just discarding the last 32 bits...or 4 bytes. Testing now.3/24/2013:Yep, that was it.  If I discard the last 4 bytes of my SHA1 hash in python...I get the same decryption results.Quick Info:I have a c++ program to decrypt a datablock. It uses the Windows Crytographic Service Provider so it only works on Windows.  I would like it to work with other platforms.  Method Overview:In Windows Crypto API An ASCII encode password of bytes is converted to a wide character representation and then hashed with SHA1 to make a key for an RC4 stream cipher. In Python PyCrypto  An ASCII encoded byte string is decoded to a python string.  It is truncated based on empircally obsesrved bytes which cause mbctowcs to stop converting in c++.  This truncated string is then enocoded in utf-16, effectively padding it with 0x00 bytes between the characters.  This new truncated, padded  byte string is passed to a SHA1 hash and the first 128 bits of the digest are passed to a PyCrypto RC4 object.Problem [SOLVED]I can't seem to get the same results with Python 3.x w/ PyCryptoC++ Code Skeleton: Python Code Skeleton:Suspected [EDIT: Confirmed] Causes1.  mbstowcs conversion of the password resulted in the "original data" being fed to the SHA1 hash was not the same in python and c++. mbstowcs was stopping conversion at 0x65 and 0x6D bytes. Original data ended with a wide_char encoding of only part of the original 33 byte password.RC4 can have variable length keys. In the Enhanced Win Crypt Sevice provider, the default length is 128 bits.  Leaving the key length unspecified was taking the first 128 bits of the 160 bit SHA1 digest of the "original data"How I investigatededit: based on my own experimenting and the suggestions of @RolandSmith, I now know that one of my problems was mbctowcs behaving in a way I wasn't expecting.  It seems to stop writing to sBuf on "e" (0x65) and "m"(0x6d) (probably others).  So the passoword "Monkey" in my description (Ascii encoded bytes), would look like "M o n k" in sBuf because mbstowcs stopped at the e, and placed 0x00 between the bytes based on the 2 byte wchar typedef on my system.  I found this by writing the results of the conversion to a text file.References:wide characters cause problems depending on environment definitionDifference in Windows Cryptography Service between VC++ 6.0 and VS 2008convert a utf-8 to utf-16 stringPython - converting wide-char strings from a binary file to Python unicode stringsPyCrypto RC4 examplehttps://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.ARC4-module.htmlHashing a string with Sha256http://msdn.microsoft.com/en-us/library/windows/desktop/aa379916(v=vs.85).aspxhttp://msdn.microsoft.com/en-us/library/windows/desktop/aa375599(v=vs.85).aspx
You can test the size of  with a small test program (in C):You could also use  calls in your C++ code to write e.g.  and the result of the hash in  to the screen if you can run the C++ program from a terminal. Otherwise use  to dump them to a file.To better mimic the behavior of the C++ program, you could even use  to call  in your Python code.Edit: You wrote:One problem is definitely with mbctowcs. It seems that it's transferring an unpredictable (to me) number of bytes into my buffer to be hashed.Keep in mind that  returns the number of wide characters converted. In other words, a 33 byte buffer in a multi-byte encodingcan contain anything from 5 (UTF-8 6-byte sequences) up to 33 characters depending on the encoding used. Edit2: You are using 0 as the  parameter for . According to its documentation, the upper 16 bits should contain the key length. You should check 's return value to see if the call succeeded.Edit3: You could test  in Python (I'm using IPython here.):Note that in Windows you should probably use  instead of .


Answer URL
