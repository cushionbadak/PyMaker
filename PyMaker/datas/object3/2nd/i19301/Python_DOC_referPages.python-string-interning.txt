Natural Text
While this question doesn't have any real use in practice, I am curious as to how Python does string interning. I have noticed the following.This is as I expected.You can also do this.And that's pretty clever!But you can't do this.Why wouldn't Python evaluate , and realize it is the same as  and point it to the same address? What is actually going on in that last block to have it return ?
This is implementation-specific, but your interpreter is probably interning compile-time constants but not the results of run-time expressions.In what follows I use CPython 2.7.3.In the second example, the expression  is evaluated at compile time, and is replaced with . This makes the first two examples behave the same.If we examine the bytecodes, we'll see that they are exactly the same:The third example involves a run-time concatenation, the result of which is not automatically interned:If you were to manually  the result of the third expression, you'd get the same object as before:
Case 1Case 2Now, your question is why the id is same in case 1 and not in case 2.In case 1, you have assigned a string literal  to  and . Since string are immutable, it makes sense for the interpreter to store the string literal only once and point all the variables to the same object.Hence you see the id as identical.In case 2, you are modifying  using concatenation. Both  and  has same values, but not same identity.Both points to different objects in memory. Hence they have different  and  operator returned 


Answer URL
https://docs.python.org/3/library/sys.html?highlight=sys#sys.intern
