Natural Text
The is operator is used test for identity.I was wondering if the  operator and  function call any  method, the way  calls .I had some fun checking out :Think about dict  and the value of  Every subsequent lookup of  is either a  or a random integer.But as the docs on the special methods state[the default implementation of] x.() returns id(x).So there is relation between the two, but just the other way around. I've seen many questions on  and  here, and the answers have helped many confused minds, but I couldn't find an answer to this one.
No,  is a straight pointer comparison, and  just returns the address of the object cast to a .From : and  here are simply .From :
The short answer is: No, they do not. As the docs that you link to say:The operators  and  test for object identity:  is true if and only if  and  are the same object.Being "the same object" is not something you're allowed to override. If your object is not the same object as another, it cannot pretend to be.So… Why? What would be the harm of letting you override  and/or ? Obviously it would almost always be a stupid thing to do, but Python lets you do a lot of stupid things if you try hard enough.The design FAQ and similar documents don't say. But I suspect it's primarily because it makes it easier to debug Python and some of the deeper standard library modules, knowing there is some way, from within the interpreter, to verify that two names really do refer to the same object, or to print out the  to make sure a name hasn't changed over time, etc. Imagine debugging , or even , without that.So, what exactly does "same object" mean? Well, that's up to the interpreter. Obviously it has to be impossible to distinguish two instances of the same object at the language level, and probably at the interpreter level as well (especially since there's a well-defined API for plugging into most interpreter implementations).All of the major implementations handle this by deferring to the notion of identity at the lower level. CPython compares the values of the  pointers, Jython identity-compares the Java references, PyPy does an  on the objectspace objects…It's worth looking at the PyPy source, which requires the " iff  and  are the same object" to be true in both directions. The top-level expression  is true iff, whatever objects  and  in the appropriate objectspace are,  is true, and  is implemented as . So,  at level N iff  at level N-1.Notice that this means you could pretty easily use PyPy to build a dialect of Python where  can be overridden, just by attaching  to a dunder method  at the higher level. But there's a simpler way to do the same thing:Now play with  instead of , and see if you can find any fun trouble before doing the hard work of modifying the interpreter (even if it isn't that hard, in this case).So, what does  have to do with ? Could  be implemented on top of —e.g.,  just checks ? Well, :Return the “identity” of an object. This is an integer which is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same  value.So, the  of an object is unique and constant during its lifetime, and  is true iff they're the same object, therefore  is true iff , right?Well,  can be rebound to whatever you want, and that isn't allowed to affect . If you crafted the definition very carefully (keep in mind that if you discard the  reference to , whatever implementation used to be there isn't even guaranteed to exist anymore, or to work correctly if it does exist…), you could define  on top of the default implementation of .But it would be an odd thing to do. In CPython, where  just "returns the address of the object in memory", which is the same thing as the value of the pointer to the object in memory. But that's just an artifact of CPython; there's nothing saying other implementations have to make  return the underlying value used for identity comparison as an integer. In fact, it's not clear how you'd even do that in an implementation written in a language without pointers (that can be cast to integers). In PyPy, the  of an object may even be a value computed the first time it's accessed and stashed in a dictionary in the objectspace, keyed by the object itself. As for , you're misreading an important part of the docs.[...]  returns .The part you ellipsized makes it clear that this is only true for instances of user-defined classes (that don't redefine ). It's obviously not true for, e.g., . In short, identity has nothing to do with hashing, except that for some objects the identity makes a convenient hash value.


Answer URL
