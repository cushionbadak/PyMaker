Natural Text
If you checked Python C- API documentation about running python code via the C calls, you will always find mention to , but nothing really describes what is it except the last portion of documentation and says nothing about its possible values and their effect on execution.
 is the C API equivalent to the flags argument passed to  and related functions in Python. This probably isn't at all obvious if you don't already know the Python docs forward and backward before looking at the CPython C-API docs. From :The optional arguments flags and dont_inherit control which future statements affect the compilation of source. If neither is present (or both are zero) the code is compiled with those future statements that are in effect in the code that is calling . If the flags argument is given and dont_inherit is not (or is zero) then the future statements specified by the flags argument are used in addition to those that would be used anyway. If dont_inherit is a non-zero integer then the flags argument is it – the future statements in effect around the call to compile are ignored.Future statements are specified by bits which can be bitwise ORed together to specify multiple statements. The bitfield required to specify a given feature can be found as the  attribute on the  instance in the  module.Following the link to future statements gives more details on how they work, and the link to the  has a chart showing the list of future statements available.Another thing that may not be obvious: each future feature flag corresponds to a flag that ends up in the  attribute of a  object. So:In C, if you pass  to get the same effect.If you want to see the actual numeric values for those flags, you have to look up the corresponding  constants in the C source or in the  source. Things are slightly different in the C API, in a few ways.Rather than passing both flags and dont_inherit, you only pass flags, which is a complete set of all of the future statements you want to be in effect during the  or  call.Most of the functions take a  struct holding an int, instead of a raw int. This is just for the purpose of type checking; in memory, a struct holding an int is stored the same way as an int.Many functions take their flags by pointer, so you can retrieve the possibly-updated set of flags after running the code.Let's look at a complete example. I'll use Python 2.7 even though I've been linking to 3.7 docs, just because an example using  is simpler than one using forward annotations.This code prints an empty tuple:But if you run the first one with , passing  (0x10000) as the flags`, it will print a blank line, a la Python 3.If you run this code:… then whether you passed in  or , it will print a blank line. And after the call, if you look at the flags you passed in by reference, it will have that  or'd onto it. So, if you're compiling and running a chunk at a time, you can pass that same value along to the next string, and it'll inherit that future flag. (Much like when you write a future statement in the interactive interpreter, it affects all the statements you interpret after that.)


Answer URL
https://docs.python.org/3/library/functions.html#compile
https://docs.python.org/3/reference/simple_stmts.html#future
https://docs.python.org/3/library/__future__.html#module-__future__
https://docs.python.org/3/reference/simple_stmts.html#future
https://docs.python.org/3/library/__future__.html#module-__future__
