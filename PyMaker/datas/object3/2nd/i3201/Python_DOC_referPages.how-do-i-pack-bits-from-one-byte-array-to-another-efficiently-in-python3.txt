Natural Text
I have a fairly large byte array in python. In the simplest situation the byte array only contains 0 or 1 values (0x00, 0x01), also the array is always a multiple of 8 in length. How can I pack these "bits" into another byte array (it doesn't need to be mutable) so the source index zero goes to the MSB of the first output byte etc.For example if Desired output would be .I could do it with a for loop and bit shifting and or-ing and concatenation, but there surely is a faster/better built-in way to do this.In a follow up question, I also might want to have the source byte array contain values from the set 0-3 and pack these 4 at a time into the output array. Is there a way of doing that?In general is there a way of interpreting elements of a list as true or false and packing them 8 at a time into a byte array?
As ridiculous as it may sound, the fastest solution using builtins may be to build a string and pass it to , much as the fastest way to count 1-bits in an  is . And it's dead simple, too:Equivalent (but marginally more complex) code using  instead of native Python  is a bit faster.And you can extend it to 2-bit values pretty easily:If you want something more flexible, but possibly slower, here's a simple solution using .If you know C, you can probably see a struct of 8 single-bit bit-fields would come in handy here. And you can write the equivalent struct type in Python like this:And you can construct one of them from 8 ints that are all 0 or 1:And you can convert that to a single int by using an ugly cast or a simple union:So now it's just a matter of chunking  into groups of 8 in big-endian order:And it should be pretty obvious how to extend this to four 2-bit fields, or two 4-bit fields, or even two 3-bit fields and a 2-bit field, per byte.However, despite looking like low-level C code, it's probably slower. Still, it might be worth testing to see if it's fast enough for your uses.A custom C extension can probably do better. And there are a number of bit-array-type modules on PyPI to try out. But if you want to go down that road,  is the obvious answer. You can't get any simpler than this:(A  works just fine as an "array-like".)It's also hard to beat for speed.For comparison, here's some measurements:60ns/byte + 0.3µs:  on an  instead of a 60ns/byte + 1.9µs: 440ns/byte + 3.2µs:  and bit-twiddling in PyPy instead of CPython570µs/byte + 3.8µs:  in PyPy instead of CPython610ns/byte + 9.1µs: 800ns/byte + 2.9µs: 1.0µs/byte + 2.8µs: 2.9µs/byte + 0.2µs: 16.µs/byte + 0.9µs:  and bit-twiddling
Using numpy, with test code and comments:Similar code exists for other deinterleaving, bit since the number of bits between inputs is less than the number of bytes in a word, we can avoid the masking here (note that the  does not overlap the ).


Answer URL
https://docs.python.org/3/library/ctypes.html
