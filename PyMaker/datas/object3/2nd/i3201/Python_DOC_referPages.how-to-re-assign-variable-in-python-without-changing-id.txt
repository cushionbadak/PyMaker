Natural Text
when assign a variable to another they point to a same object, So, how to value change for one of them but variables still point same object! how to re-assign variable in python without changing id?
I'm not sure whether you're confused about variables in Python, or about immutable values. So I'm going to explain both, and half the answer will probably seem like "no duh, I already knew that", but the other half should be useful.In Python—unlike, say, C—a variable is not a location where values live. It's just a name. The values live wherever they want to.1 So, when you do this:You're not making  into a reference to . That idea doesn't even make sense in Python. You're making  into a name for , and then making  into another name for . And if you later do this:… you've made  into a name for , but this has no effect on —it's still just a name for .This also means that  is not giving you the ID of the variable , because there is no such thing.  is just a name that gets looked up in some namespace (e.g., a module's globals dict). It's the value,  (or, if you ran it earlier, the different value ) that has an ID. (While we're at it: it's also values, not variables, that are typed. Not relevant here, but worth knowing.)Things get a bit tricky when it comes to mutability. For example:This still makes  and  both names for a list.This doesn't assign to , so  and  are still names for the same list. It does assign to , which is part of that list. So, the list that  and  both name now holds .This obviously does the same thing:  and  now name the list .Here's where things get confusing:Is it an assignment that rebinds , or is it just mutating the value that  is a name for? In fact, it's both. What this means, under the covers, is:… or, roughly:So, we are assigning to , but we're assigning the same value back to it that it already named. And meanwhile, we're also mutating that value, which is still the value that  names.So now:You probably can guess that the last line does something like this:That's not quite true, because  doesn't define an  method, so it falls back to this:But that's not the important bit.2 The important bit is that, because integers, unlike lists, are immutable. You can't turn the number 10 into the number 11 the way you could in INTERCAL or (sort of) Fortran or that weird dream you had where you were the weirdest X-Man. And there's no "variable holding the number 10" that you can set to 11, because this isn't C++. So, this has to return a new value, the value .So,  becomes a name for that new . Meanwhile,  is still a name for . It's just like the first example.But, after all this telling you how impossible it is to do what you want, I'm going tell you how easy it is to do what you want.Remember earlier, when I mentioned that you can mutate a list, and all the names for that list will see the new value? So, what if you did this:Now  is going to be .Or you can create a class:Now,  is .Or you can even create a class that implements  and  and all the other numeric methods, so it can hold numbers (almost) transparently, but do so mutably.And now:And  is a name for the same  as .If you really want to do this, though, you should consider making something specific like  rather than a generic  that holds anything that acts like a number, and using the appropriate ABC in the  module to verify that you covered all the key methods, to get free implementations for lots of optional methods, and to be able to pass  type checks. (And probably call  in its constructor the way  does, or at least special-case  so you don't end up with a reference to a reference to a reference… unless that's what you want.)1. Well, they live wherever the interpreter wants them to live, like Romanians under Ceaușescu. But if you're a builtin/extension type written in C and a paid-up member of the Party, you could override  with a constructor that doesn't rely on  to allocate, but otherwise you have no choice.2. But it's not completely unimportant. By convention (and of course in all builtin and stdlib types follow the convention),  doesn't mutate,  does. So, mutable types like  define both, meaning they get in-place behavior for  but copying behavior for , while immutable types like  and  define only , so they get copying behavior for both. Python doesn't force you to do things this way, but your type would be very strange if it didn't pick one of those two. If you're familiar with C++, it's the same—you usually implement  by mutating in-place and returning a reference to , and  by copying and then returning  on the copy, but the language doesn't force you to, it's just confusing if you don't.
Variables don't have id, an id belongs to an object.Integers e.g.: 10,9 are separate and immutable objects, 'a','b' variables are references only. id(a) really gives the id of the referenced object. The object '10' can not be mutated in place.However, lists are mutable objects and can be changed in place with the [:] operator (and of course, with their methods,e.g.: append,extend):


Answer URL
https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types
https://docs.python.org/3/library/numbers.html
