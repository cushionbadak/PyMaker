Natural Text
This question already has an answer here:Python and “arbitrary precision integers”                    1 answer                This is my code in python but the answer it gives is not correct according to projecteuler.net.It gives an output 1189. Am I making some mistake?
Your logic is fine. The problem is that  is too big for all the digits to fit into a float, so the number gets rounded when you do . A Python  only has 53 bits of precision, you can read about it in the official tutorial article: Floating Point Arithmetic: Issues and Limitations, and on Wikipedia: Double-precision floating-point format. Also see Is floating point math broken?.This is 10715086071862673209484250490600018105614048117055336074437503883703510511249361224931983788156958581275946729175531468251871452856923140435984577574698574803934567774824230985421074605062371141877954182153046474983581941267398767559165543946077062914571196477686542167660429831652624386837205668069376But  gives us this:1071508607186267380429101388171324322483904737701556012694158454746129413355810495130824665231870799934327252763807170417136096893411236061781867579266085792026680021578208129860941078404632071895251811587214122307926025420797364998626502669722909817741077261714977537247847201331018951634334519394304.000000You can see that the digits start going wrong after .So you need to use integer arithmetic, which in Python has arbitrary precision (only limited by how much memory Python can access). To do that, use the  floor division operator.outputWe can condense that code a little by using augmented assignment operators.Here's a faster way. Convert  to a string then convert each digit back to  and sum them. I use bit shifting to compute  because it's faster than exponentiation.


Answer URL
https://docs.python.org/3/tutorial/floatingpoint.html
https://docs.python.org/3/glossary.html#term-floor-division
https://docs.python.org/3/reference/simple_stmts.html#augmented-assignment-statements
