Natural Text
I was trying to initiate a new list which every index's value is previous accumulation, according to args nums(type list), using list comprehension.the final result would look likeIs there ways to translate the function to lambda expression? or any other ones to make it one-line?
I would propose the following as a replacement for that:That is a generator, so a  operation is not being performed for elements not yet needed.Then to get the elements, use :And if you do want them all at once, just use  on the generator:The performance of this function on non trivial lists is HORRIBLE because it has  complexity. Only use it as a curiosity. See timings below. And (thanks to AChampion) another reduce:But the right answer is  or your your original function. Any one line solution will have far greater computational complexity.Here is a set of timings to show that other than , the single line replacements have  type complexity (ie, 10x more items, 100x more time roughly). That is because for each element in the list, because lambdas or reduce or comprehensions do not have any form of accumulator, the entire list up to that point must be looped over again. Your original function and  are both  type complexity (ie, 10x more items, a linear 10x more time).Here is a graph and cheatsheet of O Complexity.Here is the timing and results:Results:
This is one way to do it:Output:Another way is to use itertools.accumulate as suggested by @Blckknght.Output:
If the list is continuously.A simple but not efficient way:Output:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.accumulate
https://docs.python.org/3/library/itertools.html#itertools.accumulate
