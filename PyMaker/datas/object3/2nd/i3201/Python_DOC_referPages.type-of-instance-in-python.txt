Natural Text
I came across this piece of code, and I am surprised that it adds an element to the list.Here's the code: I am surprised because if I run , I get , which makes sense because  is an object of class . Hence, I am unsure why  adds to the list in the attribute  directly. After all, the type of  isn't  but Shouldn't the call have been ? This works as well. I am a beginner, and this might be a basic question. I'd appreciate any thoughts, and thanks for any help.This code was adopted from Mark Lutz's book. I am using Anaconda 3.6 distribution
This class is just adding a print statement before the original attribute of the object is accessed.To understand how this works, you have to understand a bit about what  does. The documentation for these methods is under the data model section of the Python manual:Called when the default attribute access fails with an   (either  raises an  because name is  not an instance attribute or an attribute in the class tree for self;  or  of a name property raises ). This method  should either return the (computed) attribute value or raise an   exception.The  (dot) operator is really a search or lookup operator, when you write a statement like this:You and I understand this to mean "call the append method of the foo object, with the argument x" - Python is trying to search for an attribute "append" on the foo object, then trying to call it with an argument of x.In the custom object, we don't have an  attribute, which triggers the  call. We then intercept this call to , print out a debug statement, and then pass on this call to the actual object (a reference to it is in ).In short, we are saying - hey - we understand that our wrapper object doesn't have this property, but try and see if the wrapped object does, by calling its  instead.This concept of passing along the call up the chain allows flexibility in that we mimic what the original (wrapped) object would do - making our wrapper very generic. It would work even if you passed in a string or any other Python object.
The  is an operator overload magic method for the attribute reference  operator. There are several other ways to do this, like descriptors for single attributes or  that overrides even existing attributes.


Answer URL
https://docs.python.org/3/reference/datamodel.html
