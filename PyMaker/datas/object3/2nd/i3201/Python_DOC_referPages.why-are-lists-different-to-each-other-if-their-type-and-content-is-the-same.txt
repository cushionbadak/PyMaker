Natural Text
The  operator does not match the values of the variables, but the  instances themselves.What does it really mean?I declared two variables named  and  assigning the same values in both variables, but it returns false when I use the  operator.I need a clarification. Here is my code.
You misunderstood what the  operator tests. It tests if two variables point the same object, not if two variables have the same value.From the documentation for the  operator:The operators  and  test for object identity:  is true if and only if  and  are the same object.Use the  operator instead:This prints .  and  are two separate lists:If you use the  function you'll see that  and  have different identifiers:but if you were to assign  to  then both point to the same object:and  shows both are the same object, it returns .Remember that in Python, names are just labels referencing values; you can have multiple names point to the same object.  tells you if two names point to one and the same object.  tells you if two names refer to objects that have the same value.
Another duplicate was asking why two equal strings are generally not identical, which isn't really answered here:So, why aren't they the same string? Especially given this:Let's put off the second part for a bit. How could the first one be true?The interpreter would have to have an "interning table", a table mapping string values to string objects, so every time you try to create a new string with the contents , you get back the same object. Wikipedia has a more detailed discussion on how interning works.And Python has a string interning table; you can manually intern strings with the  method.In fact, Python is allowed to automatically intern any immutable types, but not required to do so. Different implementations will intern different values.CPython (the implementation you're using if you don't know which implementation you're using) auto-interns small integers and some special singletons like , but not strings (or large integers, or small tuples, or anything else). You can see this pretty easily:OK, but why were  and  identical?That's not the interpreter automatically interning, that's the compiler folding values.If the same compile-time string appears twice in the same module (what exactly this means is hard to define—it's not the same thing as a string literal, because , , and  are all different literals but the same string—but easy to understand intuitively), the compiler will only create one instance of the string, with two references.In fact, the compiler can go even farther:  can be converted to  by the optimizer, in which case it can be folded together with an  constant in the same module.Again, this is something Python is allowed but not required to do. But in this case, CPython always folds small strings (and also, e.g., small tuples). (Although the interactive interpreter's statement-by-statement compiler doesn't run the same optimization as the module-at-a-time compiler, so you won't see exactly the same results interactively.)So, what should you do about this as a programmer?Well… nothing. You almost never have any reason to care if two immutable values are identical. If you want to know when you can use  instead of , you're asking the wrong question. Just always use  except in two cases:For more readable comparisons to the singleton values like .For mutable values, when you need to know whether mutating  will affect the .
 only returns true if they're actually the same object. If they were the same, a change to one would also show up in the other. Here's an example of the difference.
Prompted by a duplicate question, this analogy might work:
 and  are the two identity operators in Python.  operator does not compare the values of the variables, but compares the identities of the variables. Consider this:The above example shows you that the identity (can also be the memory address in Cpython) is different for both  and  (even though their values are the same). That is why when you say  it returns false due to the mismatch in the identities of both the operands. However when you say , it returns true because the  operation only verifies if both the operands have the same value assigned to them.Interesting example (for the extra grade):In the above example, even though  and  are two different variables,  returned . This is because the type of  is  which is an immutable object. So python (I guess to save memory) allocated the same object to  when it was created with the same value. So in this case, the identities of the variables matched and  turned out to be .This will apply for all immutable objects:Hope that helps.
As you can check here to a small integers. Numbers above 257 are not an small ints, so it is calculated as a different object.It is better to use  instead in this case.Further information is here: http://docs.python.org/2/c-api/int.html
 is same as , comparing identity of objects.  As @tomasz-kurgan pointed out in the comment below  operator behaves unusually with certain objects.  E.g.Ref;https://docs.python.org/2/reference/expressions.html#is-nothttps://docs.python.org/2/reference/expressions.html#id24
X points to an array, Y points to a different array. Those arrays are identical, but the  operator will look at those pointers, which are not identical.
It compares object identity, that is, whether the variables refer to the same object in memory. It's like the  in Java or C (when comparing pointers).
A simple example with fruits   Output:If you try The output is different:That's because the == operator compares just the content of the variable. To compare the identities of 2 variable use the is operator To print the identification number: 


Answer URL
https://docs.python.org/3/library/sys.html#sys.intern
