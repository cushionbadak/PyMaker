Natural Text
I have a dataframe with 30,000 records in the following format:I would like to select one record to be the start location and one record to be the destination and return a path (list) for the shortest path. I am using Geopy to find the distance between points in kmI have read how to do A* in python from the following tutorial:https://www.redblobgames.com/pathfinding/a-star/implementation.htmlHowever they create a grid system to navigate through.This is a visual representation of the records in the dataframe:This is the code I have so far however it fails to find a path:^Calculates the distance between points^Returns the 4 closest locations (ignoring itself)Finds the path from the closed list:Currently this implementation of A* isn't finding a complete path . Any suggestions?Edit:I have tried increasing the number of considered neighbors from 4 to 10 and I got a path but not a optimum path:We are trying to get from Hessle to Leeds. ^ available nodesRaw Data:Link
I'm still not sure what's the problem with your appraoch, although there certainly are a few, as already mentioned in comments.regarding only the closest four (or for that matter, any fixed number of) neighbors might lead to dead-ends or to certain portions of the graph being entirely cut off, e.g. isolated cities that are not within the "closest X" for any of their neighborsyour checks in the form  will check whether  is any of the values in the numpy-array returned by , not necessarily the ID fieldusing dataframes instead of a proper heap for the open-list and a hash-set for the closed-list makes the search unneccessarily slow, as you have to search and sort the entire lists all the time (not sure whether Pandas can speed up the lookup with indexing, but the sorting definitely takes time)Anyhow, I found this to be an interesting problem and gave it a try. Turns out, though, that using dataframes as some kind of pseudo-heap was indeed very slow, and also I found the dataframe-indexing to be extremely confusing (and possibly error-prone?), so I changed the code to use  for data and a proper  heap for the  and a  mapping nodes to their parents for the . Also, there are fewer checks than in your code (e.g. whether a node is already in the openlist) and those do not matter really.This gives me this path from Hessle to Leeds, which seems more reasonable:Even if you can't use this because you have to use Pandas (?), maybe this helps you finally spot your actual error.


Answer URL
https://docs.python.org/3/library/collections.html#collections.namedtuple
https://docs.python.org/3/library/heapq.html
