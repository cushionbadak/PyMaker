Natural Text
I'm new to python socket programming. I want to transfer 5 files (photos) from one host in mininet to another. The name of these files are numbered respectively (I mean 1.jpg, 2.jpg and ...). The problem is that when I run these codes, the first photo is transferred correctly but others become corrupted. What's the problem:sender.pyreceiver.py:
The simple solution to your problem is to create a new connection for each file. The code below does that.SenderReceiverYou need to hit CtrlC or Break (depending on your OS) to exit the receiver. But using those numeric file names at the receiver isn't very satisfactory , so I decided to make it a little more complicated. :) In the following version we send the file name before the file data. That's slightly tricky because the receiver needs to separate the file name from the actual file data. If each  call corresponded to a  call that would be easy, but that's not guaranteed to happen: the received bytes may be split differently from how they were sent. The receiver needs to buffer the bytes so it can break them up correctly. See the Socket Programming HOWTO for details.So that the receiver knows where the file name ends we first send a single byte that encodes the length of the file name. A byte can hold a number from 0 to 255, so this code can't handle file names longer than that. After the length byte, we send the file name itself, encoded using UTF-8. And then we send the actual file contents.The receiver uses a class named Receiver to handle the buffering. This class has a  method which we can use to get a specified number of bytes. We use that method to get the file name length and the file name. And then we use Receiver's  method to save the received file contents to a new file.This code is a little bit messy because it's designed to run on Python 2 and Python 3, in any combination. It'd be somewhat neater if it was for Python 3 only. I hard-coded 'localhost' as the host name, since I only have one computer, so I couldn't test it over a network, but I'm confident that it will work correctly on a network.Here's the sender:And here's the receiver:
You should use it like:this way f gets closed automatically when you leave the with  block when you exit the while.I guess you need to extend the protocol so that the receiver knows what it gets and that you can let it act on that. Something like a 'begin-of-transfer' ... sending the filename, sending the data, sending 'end-of-transfer' that makes the receiver close the file


Answer URL
https://docs.python.org/3/howto/sockets.html
