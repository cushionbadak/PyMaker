Natural Text
I'm hoping to run an initial (synchronous) function (initial_number_adder), pass it's return to a second function that's async (repeated_number_adder), and then run that function in a loop, passing it's previous return value back into itself, forever.If I can make both functions async, and manage the single initial run of the first, from the task list, that would be great also. This was just the best way I could imagine doing it to begin with (initial synchronous pass into async loop)I'll be using a setup like this with aiohttp to make GET requests. One function returns a large DataFrame initially, the second function will async append one new row and make calculations every 15 minutes, then pass the DataFrame and calcs back into itself. (just wanted to give a gist for anyone curious)I appreciate your time. Let me know if there's anything that needs clarification.
There are several issues with the pseudo-code in the question. doesn't accept a coroutine; it accepts no arguments and runs the event loop forever (or until  is invoked). To run a coroutine forever, simply use a  loop in its body, and add it to the loop before calling . won't work because  is an integer. Valid arguments to  are awaitable objects, such as coroutines and futures. If the result is ready, it is perfectly fine to return it from the coroutine using the regular  statement.You don't need  or  to await a single coroutine, as in the first invocation of , you can  it directly. You need  to await the results of multiple coroutines running in parallel.With those in mind, you could write the program as follows:


Answer URL
https://docs.python.org/3/glossary.html#term-awaitable
