Natural Text
I would like to have my print output length limited to X characters. I've been looking for some info and I found the command  which makes just what I was looking for by using something like: However, I was wondering if there is a way to apply this length limitation to every print without having to write it (I do have plenty of them) by creating or setting a class or something at the very beginning of the script.
Monkeypatching  is doable, but it's not a good idea. For one thing, what do you want to happen if someone does a ? Or ? Or ?A better solution is probably replacing  with a wrapper. The normal  is a plain old text file object, a  just like the ones you get from , except that when you write to it, it goes to the console instead of to a file on disk.And you're allowed to replace it with anything else that meets the  protocol.And writing a  is really simple. All you really need to implement is  and/or  and  (depending on whether you're wrapping output, input, or both), and all our wrapper needs to do in  is to buffer up lines,  them, and pass them to the real file object underneath.Like this:Technically, I think I may be cheating in a few ways here:The docs say the ABC  wants , , and , even if they don't make sense here. But the ABC doesn't seem to enforce them as abstract methods, so I didn't bother.I think it's legal (and it works) to leave  and  set to , since we're just passing through to another  and expecting it to do the encoding, but I can't find anything that says it's legal. And if some code were to test  to see if it's UTF-8 or something, that might be trouble.Similarly for . And, since I haven't tested on Windows, I can't be as sure that it works.Also, forwarding other methods to  might be a good idea, like  and . But I'd worry that any app that wants to access  as a TTY probably need to know about the  that we stuck in front of it, not just transparently go through it.This is of course all Python 3-specific. In Python 2: is a , not a . The API you need to wrap is a bit different, and not nearly as well defined. Unless you  up the 3.x-style  function,  is a statement, so you can't monkeypatch it. (I mean, you could write an import hook that bytecode-hacks out every  bytecode, or maybe even inject a .so that replaces â€¦ but who cares anyway? It's Python 2.)


Answer URL
https://docs.python.org/3/library/functions.html#print
https://docs.python.org/3/library/sys.html#sys.stdout
https://docs.python.org/3/library/io.html#io.TextIOWrapper
https://docs.python.org/3/library/io.html#io.TextIOBase
