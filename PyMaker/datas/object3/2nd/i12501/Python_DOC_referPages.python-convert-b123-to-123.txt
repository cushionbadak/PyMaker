Natural Text
I'm using this code to get standard output from an external program:The communicate() method returns an array of bytes:However, I'd like to work with the output as a normal Python string. So that I could print it like this:I thought that's what the binascii.b2a_qp() method is for, but when I tried it, I got the same byte array again:Does anybody know how to convert the bytes value back to string? I mean, using the "batteries" instead of doing it manually. And I'd like it to be ok with Python 3.
You need to decode the bytes object to produce a string:
I think this way is easy:
You need to decode the byte string and turn it in to a character (unicode) string. or on Python 3
If you don't know the encoding, then to read binary input into string in Python 3 and Python 2 compatible way, use ancient MS-DOS cp437 encoding:Because encoding is unknown, expect non-English symbols to translate to characters of  (English chars are not translated, because they match in most single byte encodings and UTF-8).Decoding arbitrary binary input to UTF-8 is unsafe, because you may get this:The same applies to , which was popular (default?) for Python 2. See the missing points in Codepage Layout - it is where Python chokes with infamous .UPDATE 20150604: There are rumors that Python 3 has  error strategy for encoding stuff into binary data without data loss and crashes, but it needs conversion tests  to validate both performance and reliability.UPDATE 20170116: Thanks to comment by Nearoo - there is also a possibility to slash escape all unknown bytes with  error handler. That works only for Python 3, so even with this workaround you will still get inconsistent output from different Python versions:See https://docs.python.org/3/howto/unicode.html#python-s-unicode-support for details.UPDATE 20170119: I decided to implement slash escaping decode that works for both Python 2 and Python 3. It should be slower that  solution, but it should produce identical results on every Python version.
In Python 3, the default encoding is , so you can use directly:which is equivalent toOn the other hand, in Python 2, encoding defaults to the default string encoding. Thus, you should use:where  is the encoding you want.Note: support for keyword arguments was added in Python 2.7.
I think what you actually want is this:Aaron's answer was correct, except that you need to know WHICH encoding to use. And I believe that Windows uses 'windows-1252'. It will only matter if you have some unusual (non-ascii) characters in your content, but then it will make a difference.By the way, the fact that it DOES matter is the reason that Python moved to using two different types for binary and text data: it can't convert magically between them because it doesn't know the encoding unless you tell it! The only way YOU would know is to read the Windows documentation (or read it here).
Set universal_newlines to True, i.e.
While @Aaron Maenpaa's answer just works, a user recently askedIs there any more simply way? 'fhand.read().decode("ASCII")' [...] It's so long!You can use has a standard argument
To interpret a byte sequence as a text, you have to know thecorresponding character encoding:Example: command may produce output that can't be interpreted as text. File nameson Unix may be any sequence of bytes except slash  and zero:Trying to decode such byte soup using utf-8 encoding raises .It can be worse. The decoding may fail silently and produce mojibakeif you use a wrong incompatible encoding:The data is corrupted but your program remains unaware that a failurehas occurred.In general, what character encoding to use is not embedded in the byte sequence itself. You have to communicate this info out-of-band. Some outcomes are more likely than others and therefore  module exists that can guess the character encoding. A single Python script may use multiple character encodings in different places. output can be converted to a Python string using function that succeeds even for undecodablefilenames (it uses and  error handler onUnix):To get the original bytes, you could use .If you pass  parameter then  uses to decode bytes e.g., it can be on Windows.To decode the byte stream on-the-fly,could be used: example.Different commands may use different character encodings for theiroutput e.g.,  internal command () may use cp437. To decode itsoutput, you could pass the encoding explicitly (Python 3.6+):The filenames may differ from  (which uses WindowsUnicode API) e.g.,  can be substituted with —Python'scp437 codec maps  to control character U+0014 instead ofU+00B6 (¶). To support filenames with arbitrary Unicode characters, see  Decode poweshell output possibly containing non-ascii unicode characters into a python string
Since this question is actually asking about  output, you have a more direct approach available since  accepts an encoding keyword (in Python 3.6+):The general answer for other users is to decode bytes to text:With no argument,  will be used.  If your data is not , then you must specify the encoding explicitly in the  call:
If you should get the following by trying :You can also specify the encoding type straight in a cast:
I made a function to clean a list
When working with data from Windows systems (with  line endings), my answer isWhy? Try this with a multiline Input.txt:All your line endings will be doubled (to ), leading to extra empty lines. Python's text-read functions usually normalize line endings so that strings use only . If you receive binary data from a Windows system, Python does not have a chance to do that. Thus,will replicate your original file.
For Python 3,this is a much safer and Pythonic approach to convert from  to :Output:

From http://docs.python.org/3/library/sys.html,To write or read binary data from/to the standard streams, use the underlying binary buffer. For example, to write bytes to stdout, use sys.stdout.buffer.write(b'abc').


Answer URL
https://docs.python.org/3/howto/unicode.html#python-s-unicode-support
https://docs.python.org/3/library/stdtypes.html#bytes.decode
https://docs.python.org/3/library/stdtypes.html#bytes-and-bytearray-operations
https://docs.python.org/3/library/io.html#io.TextIOWrapper
https://docs.python.org/3/library/subprocess.html#frequently-used-arguments
https://docs.python.org/3/library/sys.html#sys.getdefaultencoding
https://docs.python.org/3/library/stdtypes.html#bytes.decode
https://docs.python.org/3/howto/unicode.html#python-s-unicode-support
https://docs.python.org/3/whatsnew/3.7.html#subprocess
https://docs.python.org/3/library/subprocess.html#subprocess.Popen
