Natural Text
The python3 socket programming howto presents this code snippetwhere the send loop is interrupted if the socket  method returns 0. The logic behind this snippet is that when the  method returns '0 bytes sent', the sending side of a socket connection should give up its efforts to send data. This is for sure true for the  method, where zero bytes read for a socket in blocking mode should be interpreted as , and therefore the reading side should give up.However I cannot understand under which situations the  method could return zero. My understanding of python sockets is that  returns immediately due to buffering at the OS level. If the buffer is full  will block, or if the connections is closed at the remote side, an exception is raised. Finally suppose  returns zero without raising an exception: does this really indicate that all future  calls will return zero?I've done some testing (although using only socket connected to  on OS X) and was not able to find a situation in which  returns 0.EditThe HOWTO states:But if you plan to reuse your socket for further transfers, you need  to realize that there is no EOT on a socket. I repeat: if a socket  send or recv returns after handling 0 bytes, the connection has been  broken. If the connection has not been broken, you may wait on a recv  forever, because the socket will not tell you that thereâ€™s nothing  more to read (for now).It is pretty easy to find a situation in which  returns 0: when the remote (sending) side calls , further  on the receiving side will return  and not raise any exception. I'm looking for a concrete example where you can show that receiving 0 zero from  indicates a broken connection (which will continue to return 0 on send.)
Upon seeing the question I was somehow stunned, because a  C call can return 0 bytes and the connection is of course still alive (the socket cannot simply send more bytes at that given moment in time)https://github.com/python/cpython/blob/master/Modules/socketmodule.cI decided to "use the source" and unless I am very wrong (which can always be and often is) this is a bug in the HOWTO.Chain: is an alias for  calls in turn  calls in turn  calls in turn  (which has been passed down the chain starting with )Unwinding: returns  or  (1 or 0) with  returns if  returns  if  returns  returns this value transparently.returns  for a  (because an error has been set and an exception will be raised)returns  for from And  is the number of bytes written by the C call  in .The chain shows that if  bytes have been sent, there is no error and this actually is a potential real life socket situation.If my logic is wrong, someone please let me know.
I might be wrong, but I think you are looking for an impossible situation...As @mementum has shown in his answer, it is theoretically possible for a socket to return zero when there is no error, but also no data sent.  However, as shown elsewhere on SO this can only happen in very specific scenarios.  In my experience (and also covered in the comments to the accepted answer) you would only ever get a zero result on a non-blocking socket when the network is congested.  Now Python sockets are blocking by default, which means that the kernel should wait until there is room to take some more data then return how many bytes were queued.  By definition, this can never be zero.So, putting it all together, since your snippet doesn't reset the socket type - e.g. using the  function - it is using blocking sockets and so cannot return zero and thus cannot hit the path mementum identified.This is backed up by the fact that you have been unable to trigger the specific line of code no matter what you do.


Answer URL
https://docs.python.org/3/howto/sockets.html#using-a-socket
https://docs.python.org/3/library/socket.html#socket.socket.send
https://docs.python.org/3/library/socket.html#socket.socket.recv
https://docs.python.org/3/library/socket.html#socket.socket.shutdown
