Natural Text
I am mocking (using python Mock) a function where I want to return a list of values, but in some of the items in the list I want a side effect to also occur (at the point where the mocked function is called).  How is this most easily done?  I'm trying something like this:The except clause (and it's internal if) I copied from the internals of socket and want to verify that I "test" that path through my copy of the code.  (I don't understand how socket can get to that code (setting the target while still raising an exception, but that isn't my concern, only the I verify that I can replicate that code path.)  That's why I want the side effect to happen when the mock is called and not when I build the list.
According to the  documentation for :If you pass in an iterable, it is used to retrieve an iterator which must  yield a value on every call. This value can either be an exception   instance to be raised, or a value to be returned from the call to the  mock ( handling is identical to the function case).Therefore, your  mock will return the function  for the first two calls, then return the  object for the last call. From what I understand, you want to mock  object to actually call those functions as side effects rather than returning them.I find this behavior rather odd, since you'd expect , to mean  in every case, not . I suppose the reason this is so lies in the fact that the value of the  property must be interpreted as-is. For instance, if your Mock had , would your Mock return  for every call, or would it return  for the first call?SolutionFortunately, there is a solution to this problem. According to the docs, if you pass a single function to , then that function will be called (not returned) every time the mock is called.If you pass in a function it will be called with same arguments as the  mock and unless the function returns the  singleton the call to  the mock will then return whatever the function returns. If the function  returns  then the mock will return its normal value (from the  ).Therefore, in order to achieve the desired effect, your  function must do something different every time it is called. You can easily achieve this with a counter and some conditional logic in your function. Note that in order for this to work, your counter must exist outside the scope of the function, so the counter isn't reset when the function exits.


Answer URL
https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.side_effect
https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch
