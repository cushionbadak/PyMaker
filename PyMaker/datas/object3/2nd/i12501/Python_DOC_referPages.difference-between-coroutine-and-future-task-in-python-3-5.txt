Natural Text
Let's say we have a dummy function:What's the difference between:And:Note: The example returns a result, but this isn't the focus of the question. When return value matters, use  instead of .Regardless of return value, I'm looking for clarity on .  and  both run the coroutines, so when and why should a coroutine be wrapped in ?Basically, what's the Right Way (tm) to run a bunch of non-blocking operations using Python 3.5's ?For extra credit, what if I want to batch the calls? For example, I need to call  1000 times, but I don't want to crush the web server/database/etc with 1000 simultaneous connections. This is doable with a thread or process pool, but is there a way to do this with ?
A coroutine is a generator function that can both yield values and accept values from the outside. The benefit of using a coroutine is that we can pause the execution of a function and resume it later. In case of a network operation, it makes sense to pause the execution of a function while we're waiting for the response. We can use the time to run some other functions. A future is like the  objects from Javascript. It is like a placeholder for a value that will be materialized in the future. In the above-mentioned case, while waiting on network I/O, a function can give us a container, a promise that it will fill the container with the value when the operation completes. We hold on to the future object and when it's fulfilled, we can call a method on it to retrieve the actual result. Direct Answer: You don't need  if you don't need the results. They are good if you need the results or retrieve exceptions occurred. Extra Credits: I would choose  and pass an  instance to control the number of max workers. Explanations and Sample codesIn the first example, you are using coroutines. The  function takes a bunch of coroutines and combines them together. So  finishes when all the coroutines are exhausted (completed/finished returning all the values). The  method would make sure that the loop is alive until the execution is finished. Please notice how you are not getting the results of the async execution in this case. In the second example, you are using the  function to wrap a coroutine and return a  object which is a kind of . The coroutine is scheduled to be executed in the main event loop when you call . The returned future/task object doesn't yet have a value but over time, when the network operations finish, the future object will hold the result of the operation. So in this example, we're doing the same thing except we're using futures instead of just using coroutines. Let's look at an example of how to use asyncio/coroutines/futures:Here, we have used the  method on the  object.  would schedule the task in the main event loop. This method enables us to schedule a coroutine on a loop we choose. We also see the concept of adding a callback using the  method on the task object. A  is  when the coroutine returns a value, raises an exception or gets canceled. There are methods to check these incidents. I have written some blog posts on these topics which might help:http://masnun.com/2015/11/13/python-generators-coroutines-native-coroutines-and-async-await.htmlhttp://masnun.com/2015/11/20/python-asyncio-future-task-and-the-event-loop.htmlhttp://masnun.com/2015/12/07/python-3-using-blocking-functions-or-codes-with-asyncio.htmlOf course, you can find more details on the official manual: https://docs.python.org/3/library/asyncio.html
A comment by Vincent linked to https://github.com/python/asyncio/blob/master/asyncio/tasks.py#L346, which shows that  wraps the coroutines in  for you!In other words, we do need a future, and coroutines will be silently transformed into them.I'll update this answer when I find a definitive explanation of how to batch coroutines/futures.
Simple answer isCall a croutine function() does NOT run it. it returns just coroutine objects, like generator function returns generator objects. retrieves values from coroutines, i.e. calls the coroutine schedule the coroutine to run on the event loop on next iteration(although not waiting them to finish, like a daemon thread).Some code examplesLet's first clear some terms:coroutine function, the one you scoroutine, what you got when you call a corotine functionseem comments below.Case 1,  on a coroutineWe create two coroutines,  one, and use create_task run the other one.you will get result:Explain:task1 was executed directly, and task2 was executed in the following iteration.Case 2, yielding control to event loopIf we replace the main function, we can see a different result:you will get result:Explain:When calling , the control was yielded back to the event loop, and the loop checks for tasks to run, then it runs the task created by .Note that, we first invoke the corotine function, but not  it, so we just created a single corotine, and not make it running. Then, we call the corotine function again, and wrap it in a  call, creat_task will actully schedule the coroutine to run on next iteration. So, in the result,  is executed before .Actually, the point here is to give back control to the loop, you could use  to see the same result.Under the hood actually calls , which will call . And  will put the task in . During each iteration of the loop, it checks for every callbacks in loop._ready and runs it.,  and  actully call  directly or indirectly.Also note in the docs:Callbacks are called in the order in which they are registered. Each callback will be called exactly once.
From the BDFL [2013]TasksIt's a coroutine wrapped in a Futureclass Task is a subclass of class FutureSo it works with await too!How does it differ from a bare coroutine?It can make progress without waiting for itAs long as you wait for something else, i.e. await [something_else]With this in mind,  makes sense as a name for creating a Task since the Future's result will be computed whether or not you await it (as long as you await something). This allows the event loop to complete your Task while you're waiting on other things. Note that in Python 3.7  is the preferred way ensure a future.Note: I changed "yield from" in Guido's slides to "await" here for modernity.


Answer URL
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.BaseEventLoop.run_in_executor
https://docs.python.org/3/library/asyncio.html
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.call_soon
https://docs.python.org/3/library/asyncio-task.html#creating-tasks
https://docs.python.org/3/library/asyncio-task.html#asyncio.ensure_future
