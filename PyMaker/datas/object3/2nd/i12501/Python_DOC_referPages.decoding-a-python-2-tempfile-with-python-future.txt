Natural Text
I'm attempting to write a Python 2/3 compatible routine to fetch a CSV file, decode it from  into Unicode and feed it to a  in a robust, scalable manner.For Python 2/3 support, I'm using  including imporing  from , and importing  for consistent behaviourI'm hoping to handle exceptionally large files by spilling to disk, using I'm using  to handle decoding from the  encoding before feeding to This all works fine under Python 3.The problem is that  expects to wrap a stream which conforms to . Unfortunately under Python 2, although I have imported the Python 3-style , the vanilla Python 2  still of course returns a Python 2 , instead of a Python 3  as required by .I can think of these possible approaches:Wrap the Python 2  as a Python 3-style . I'm not sure how to approach this - would I need to write such a wrapper or does one already exist?Find a Python 2 alternative to wrap a  stream for decoding. I haven't found one yet.Do away with , decode entirely in memory. How big would the CSV file need to be for operating entirely in memory to become a concern?Do away with , and implement my own spill-to-disk. This would allow me to call  from python-future, but I'd rather not as it would be very tedious and probably less secure.What's the best way forward? Have I missed anything?Imports:Init:Routine:Error:
Not sure whether this will be useful. The situation is only vaguely analogous to yours.I wanted to use NamedTemporaryFile to create a CSV to be encoded in UTF-8 and have OS native line endings, possibly not-quite-standard, but easily accommodated by using the Python 3 style io.open.The difficulty is that NamedTemporaryFile in Python 2 opens a byte stream, causing problems with line endings. The solution I settled on, which I think is a bit nicer than separate cases for Python 2 and 3, is to create the temp file then close it and reopen with io.open. The final piece is the excellent backports.csv library which provides the Python 3 style CSV handling in Python 2.
@cbare's approach should probably be avoided. It indeed works but here is what happens with it:We use  to create temporary file. We then remember its name.We leave  statement and that file is closed.Now that the file is closed (but not removed) we open it again and open it with .At first glance it looks okay, and at second glance too. But I am not sure if on some platforms (like ) it might be possible to remove the other user's file when it is not opened - and then create it again but have access to its contents. Please somebody correct me if this is not possible.Here is what I would suggest instead:Or we could directly use  which will create file and return its name and fd as a tuple - although using  is probably more secure & portable between platforms.And to answer the original question regarding SpooledTemporaryFileI would try subclassing  under python2 and overriding its  method.Warning: this is not tested.


Answer URL
https://docs.python.org/3/library/tempfile.html#tempfile.NamedTemporaryFile
