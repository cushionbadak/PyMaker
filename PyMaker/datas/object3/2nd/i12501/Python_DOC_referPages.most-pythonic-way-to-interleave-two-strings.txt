Natural Text
What's the most pythonic way to mesh two strings together?For example:Input:Output:
For me, the most pythonic* way is the following which pretty much does the same thing but uses the  operator for concatenating the individual characters in each string:It is also faster than using two  calls:Faster approaches exist, but they often obfuscate the code.Note: If the two input strings are not the same length then the longer one will be truncated as  stops iterating at the end of the shorter string. In this case instead of  one should use  ( in Python 2) from the  module to ensure that both strings are fully exhausted.*To take a quote from the Zen of Python: Readability counts. Pythonic = readability for me;  is just visually parsed more easily, at least for my eyes.
Faster AlternativeAnother way:Output:SpeedLooks like it is faster:than the fastest solution so far:Also for the larger strings:Python 3.5.1.Variation for strings with different lengthsShorter one determines length ( equivalent)Output:Longer one determines length ( equivalent)Output:
With  and .
On Python 2, by far the faster way to do things, at ~3x the speed of list slicing for small strings and ~30x for long ones, isThis wouldn't work on Python 3, though. You could implement something likebut by then you've already lost the gains over list slicing for small strings (it's still 20x the speed for long strings) and this doesn't even work for non-ASCII characters yet.FWIW, if you are doing this on massive strings and need every cycle, and for some reason have to use Python strings... here's how to do it:Special-casing the common case of smaller types will help too. FWIW, this is only 3x the speed of list slicing for long strings and a factor of 4 to 5 slower for small strings.Either way I prefer the  solutions, but since timings were mentioned elsewhere I thought I might as well join in.
If you want the fastest way, you can combine itertools with :But combining  and  is faster againThere is also a substantial difference between  and .There is no such thing as a generator with join, passing one is always going to be slower as python  will first build a list using the content because it does two passes over the data, one to figure out the size needed and one to actually do the join which would not be possible using a generator:join.h:Also if you  have different length strings and you don't want to lose data you can use izip_longest :For python 3 it is called But  for python2, veedrac's suggestion is  by far the fastest:
You could also do this using  and :Output:What map does is it takes every element from the first iterable  and the first elements from the second iterable  and applies the function supplied as the first argument . Then join just joins them.
Jim's answer is great, but here's my favorite option, if you don't mind a couple of imports:
A lot of these suggestions assume the strings are of equal length. Maybe that covers all reasonable use cases, but at least to me it seems that you might want to accomodate strings of differing lengths too. Or am I the only one thinking the mesh should work a bit like this:One way to do this would be the following:
I like using two s, the variable names can give a hint/reminder to what is going on:
Just to add another, more basic approach:
Potentially faster and shorter than the current leading solution:Strategy speed-wise is to do as much at the C-level as possible.  Same zip_longest() fix for uneven strings and it would be coming out of the same module as chain() so can't ding me too many points there!Other solutions I came up with along the way:
Feels a bit un-pythonic not to consider the double-list-comprehension answer here, to handle n string with O(1) effort:where  is a list of the strings you want to interleave. In your case, . A full use example would look like this:Like many answers, fastest? Probably not, but simple and flexible. Also, without too much added complexity, this is slightly faster than the accepted answer (in general, string addition is a bit slow in python):
You could use 1or the  class from the same package:1 This is from a third-party library I have written: .
I would use zip() to get a readable and easy way:


Answer URL
https://docs.python.org/3/library/functions.html#zip
https://docs.python.org/3/library/itertools.html#itertools.zip_longest
https://docs.python.org/3/library/itertools.html
https://docs.python.org/3/library/functions.html#map
https://docs.python.org/3/library/operator.html#operator.add
