Natural Text
I'm teaching myself algorithms. I needed to swap two items in a list. Python makes all things easy:This works a treat:Note the function is resilient to the degenerate case . As you'd expect, it simply leaves the list unchanged:Later I wanted to permute three items in a list. I wrote a function to permute them in a 3-cycle:This worked well:However I (eventually) discovered it goes wrong in degenerate cases. I assumed a degenerate 3-cycle would be a swap. So it is when , :But when  something else happens:What's going on?  should be invariant under any permutation! Why does this case  degenerate differently?How can I achieve what I want? That is a 3-cycle function that degenerates to a swap if only 2 indices are distinct 
 is doing exactly what you ask it to: assigning to the left hand values the right hand values.is functionally equivalent to So when you do  what you are saying is that you wantIf you want cycle to work sequentially then you must write it sequentially, otherwise python evaluates the right hand and then expands that to the arguments on the left hand.
Well it seems you are re-assigning to the same target , to get a visualization of the call:Remember, from the documentation on assignment statements:An assignment statement evaluates the expression list (remember that this can be a single expression or a comma-separated list, the latter yielding a tuple) and assigns the single resulting object to each of the target lists, from left to right.So your evaluation goes something like dis: Create tuple with values  translating to Assign these to the target list  from left to right.Assignment from left to right takes place:  So the first assignment made is  with the first element of the tuple , then the second assignment  with the second element   and, finally, at the end,  is overriden with the third element in the tuple . You can get a more convoluted view of this with ; notice how all elements in the right hand of the assignment statement are loaded first and then they are assigned to their values:
Because  becomes , resulting in both  and  ending up with the old value of .  works because it becomes , which is equivalent to .


Answer URL
https://docs.python.org/3/library/dis.html#dis.dis
https://docs.python.org/3/library/itertools.html#itertools.permutations
