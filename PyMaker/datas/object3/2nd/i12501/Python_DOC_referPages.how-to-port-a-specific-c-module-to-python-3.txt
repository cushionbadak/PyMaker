Natural Text
There is a thinning pip package that is currently getting compiled only with Python2.When I install it with  and then attempt to , I get an error:I assume this is because of  is not used by Python3 anymore.Here is complete c source file:I've started reading Porting Extension Modules to Python 3 but I must admit there is little I can understand.I tried to change  to Python 3 analogue  with some other code adjustments but it didn't work. Unfortunately this thinning module is a hard dependency for our application. So, I am pretty stuck right now without time and knowledge how to port this module to Python3. 
What has changed:Note: I can't really get into the details of what the function  does per se. What I know is that it uses a small subset of the  for getting and returning the data as an ; I couldn't find any documentation on them being altered so it should be good to go. Now, what has definitely changed is the way modules are initialized; with this I can help you and get it imported in a Python 3 distribution. I'm using  for this too, even though, I believe differences between older versions of the  family shouldn't exist or are backwards compatible.As you noted, general information is provided in the Porting to Python 3 document with specifics about the initialization phase in Module Initialization and state. The new change is described in PEP 3121 which, by itself, is a nice but challenging read. Now, the gist of it can be listed in two points:A) Modules are now defined in a dedicated  struct:This new struct contains some additional members holding the name and documentation for the module. The members , ,  and  provide additional control during initialization/finalization but, we can opt to leave them as . These along with a module  set to  are for simplicity, setting these values is generally done to support multiple interpreters/ mutliple initializations and should be more tricky.So, in short, the fancy new module struct for the  module could look like this:aaand that's it for the first issue!B) New initialization function i.e you'll need to give  a major face-lift.The new module initialization function returns a  and is now named . In it (heh, get it?) new modules are created with  which takes the struct we defined and returns the initialized module. It's prettier now and looks like this:Installing the module:All this is for the initialization of the module. You can download the module (as you have done, I believe) find the  file and replace everything prior to:with the following:After that, navigate to the top level directory containing  and run:as usual. Some compilation warnings will probably pop-up but those are safe to ignore. If all goes well you'll get a successful install and the following will not result in a nasty seg-fault:It seems to run :) :I further edited the source in  to print out the number of elements changed during every iteration. It seems to be changing things but I don't understand what underlying criteria it uses because I haven't read the corresponding paper.In short,  apparently does the 'thinning' in place. This means that after it is executed, the original array that was supplied as a parameter is going to be altered. So, a check of the form:is always going to be  (Hint: check for equality between numpy arrays with ).Here's a test I ran in which you can visually see the altering taking place, I believe this test can be reproduced on your machine too:So I'm guessing it does work :-).


Answer URL
https://docs.python.org/3/howto/cporting.html
https://docs.python.org/3/howto/cporting.html
https://docs.python.org/3/howto/cporting.html#module-initialization-and-state
https://docs.python.org/3/c-api/module.html#c.PyModuleDef
https://docs.python.org/3/c-api/module.html#c.PyModuleDef
https://docs.python.org/3/c-api/module.html#c.PyModule_Create
https://docs.python.org/3/extending/extending.html
