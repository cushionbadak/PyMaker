Natural Text
So I think I basically understand how floating-point works and why we can't have "precise" results for some operations.I got confused by this SO-question, where @MikeMÃ¼ller suggests rounding.My understanding is the following. If we write decimal places it would look like this:It would look like this in binary:So we store 0.5 or 0.25 or 0.125 precisely in memory but not e.g. 0.3So why does python output the following:I think it should output Where am I wrong?My Question is NOT a duplicate of Is floating point math broken?because OP does not understand why 0.1+0.2 != 0.3. This is not topic of my question!
Because they're not the same, as  and  isn't correctly represented already. So:So it's all up to the Python rules for printing stuff, especially considering that pure  representation is much closer to actual  than .Here's the related excerpt from Python docs:Interestingly, there are many different decimal numbers that share the  same nearest approximate binary fraction. For example, the numbers   and  and   are all approximated by . Since all of these decimal  values share the same approximation, any one of them could be  displayed while still preserving the invariant .Historically, the Python prompt and built-in  function would  choose the one with 17 significant digits, .  Starting with Python 3.1, Python (on most systems) is now able to  choose the shortest of these and simply display .
From the docs on floating point in Python 3,Interestingly, there are many different decimal numbers that share the same nearest approximate binary fraction. For example, the numbers 0.1 and 0.10000000000000001 and 0.1000000000000000055511151231257827021181583404541015625 are all approximated by 3602879701896397 / 2 ** 55. Since all of these decimal values share the same approximation, any one of them could be displayed while still preserving the invariant eval(repr(x)) == x.Historically, the Python prompt and built-in repr() function would choose the one with 17 significant digits, 0.10000000000000001. Starting with Python 3.1, Python (on most systems) is now able to choose the shortest of these and simply display 0.1.So that is why it shows  when it can -- because that is the shortest string that is stored as that binary representation. The slightly higher result of  cannot be shown as a shorter string than .
To make the rounding problems no so visible, normally floating point numbers are printed without their last digit, which is rounded. This is exactly to hide the problems you wish to see.So, 0.30000000000000004 will be rounded to 0.3.But you can easily reproduce the problem if you make intentionally such a calculation which avoids this rounding. For example, multiple the result with 1e+6. And you will see, what you see.


Answer URL
https://docs.python.org/3/tutorial/floatingpoint.html
https://docs.python.org/3/tutorial/floatingpoint.html
