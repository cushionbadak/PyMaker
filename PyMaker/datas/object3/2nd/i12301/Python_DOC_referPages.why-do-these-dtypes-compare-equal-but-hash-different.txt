Natural Text
Why do these dtypes compare equal but hash different?Note that Python does promise that:The only required property is that objects which compare equal have  the same hash value…My workaround for this problem is to call  on everything, after which hash values and comparisons are consistent.
They shouldn't behave this way, but  and  for  objects are broken on an essentially unfixable design level. I'll be pulling heavily from njsmith's comments on a dtype-related bug report for this answer. isn't actually a dtype. It's a type, in the ordinary sense of the Python type system. Specifically, if you retrieve a scalar from an array of float64 dtype,  is the type of the resulting scalar. is a dtype, an instance of . dtypes are how NumPy records the structure of the contents of a NumPy array. They are particularly important for structured arrays, which can have very complex dtypes. While ordinary Python types could have filled much of the role of dtypes, creating new types on the fly for new structured arrays would be highly awkward, and it would probably have been impossible in the days before type-class unification. implements  basically like this:which is pretty broken. Among other problems, it's not transitive, it raises  when it should return , and its output is really bizarre at times because of how dtype coercion works: isn't any better. It makes no attempt to be consistent with the  methods of all the other types  accepts (and with so many incompatible types to deal with, how could it?). Heck, it shouldn't even exist, because dtype objects are mutable! Not just mutable like modules or file objects, where it's okay because  and  work by identity. dtype objects are mutable in ways that will actually change their hash value:When you try to compare ,  builds a dtype out of  and finds that  is True. When you take their hashes, though,  uses the regular (identity-based) hash for type objects and  uses the hash for dtype objects. Normally, equal objects of different types should have equal hashes, but the dtype implementation doesn't care about that.Unfortunately, it's impossible to fix the problems with dtype  and  without breaking APIs people are relying on. People are counting on things like  or , and fixing dtypes would break that.
As  notes, the  (class) for  and  are different.  They are different kinds of things:Type  means (usually) that it is a function, so it can be used as:creating a numeric object.  Actually that looks more like a class definition.  But since  uses a lot of compiled code, and its  uses its own , I wouldn't be surprised if it straddles the line.I was thinking this would the , but it might actually be the hash for an object of that type, e.g. .  In that case  just uses the default  method.Moving on to the : is not a function or class:Looks like  does not define any special  method, it just inherits from .Further illustrating the difference between  and , look at the class inheritance stackSo  doesn't define a hash either, it just inherits from .   doesn't have an  because it's an object, not a class. has enough compiled code, and a long history of its own, that you can't count on Python documentation always applying. and  evidently have  methods that allow them to be compared with each other, but  developers did not put any effort into making sure that the  methods comply.  Most likely because they don't need to use either as a dictionary key.I've never seen code like:
They are not the same thing, while  is a ,  is an instance of , hence they hash to different values, but all instances of  created the same way will hash to the same value because they are identical (which of course does not necessarily mean they point to the same memory location).Edit:Given your code above you can try the following:which shows you that the two are of different type and hence will hash to different values. Showing that different instances of  can be shown by the following example:Its nice to see that  (the instance created the same way as ), and  itself share the same object in memory, but  (the copied object) uses a different address.The equality checks evaluate as you would expect, given the hashes above:
It's because you're hashing a  against a  object.Although the values compare equal (as evidences by , their types are different:Produces<type 'numpy.dtype'><type 'type'>According to the Python docs:(object)Return the hash value of the object (if it has one). Hash values are integers. They are used to quickly compare dictionary keys during a dictionary lookup. Numeric values that compare equal have the same hash value (even if they are of different types, as is the case for 1 and 1.0).And since a  is not a numeric type, there is no guarantee that such and object will result in the same hash as a  that compares equal.EDIT:From the Python 3.5 docs:Called by built-in function hash() and for operations on members of hashed collections including set, frozenset, and dict. hash() should return an integer. The only required property is that objects which compare equal have the same hash value; it is advised to somehow mix together (e.g. using exclusive or) the hash values for the components of the object that also play a part in comparison of objects.Which appears to imply that  should return  in your case.I did notice that there is a note right after that states: truncates the value returned from an object’s custom hash() method to the size of a Py_ssize_t. This is typically 8 bytes on 64-bit builds and 4 bytes on 32-bit builds.However, I wasn't able to determine that the size of the objects returned from the hash functions were in fact different; they appear the same (I used )


Answer URL
