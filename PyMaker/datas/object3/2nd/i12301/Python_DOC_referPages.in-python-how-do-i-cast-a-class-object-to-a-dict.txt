Natural Text
Let's say I've got a simple class in pythonI can cast it to an integer very easilyWhich is great! But, now I want to cast it to a dict in a similar fashionWhat do I need to define for this to work? I tried substituting both  and  for , but  resulted in a  in both cases. I don't think simply making the class iterable will solve the problem. I also attempted many googles with as many different wordings of "python cast object to dict" as I could think of but couldn't find anything relevant :{Also! Notice how calling  won't do what I want because it's going to contain  and . I want to customize the cast to  in the same way that I can customize the cast to  by using .I know that I could just do something like thisBut I am assuming there is a pythonic way to make  work since it is the same type of thing as  or . If there isn't a more pythonic way, that's fine too, just figured I'd ask. Oh! I guess since it matters, this is for python 2.7, but super bonus points for a 2.4 old and busted solution as well.There is another question Overloading __dict__() on python class that is similar to this one but may be different enough to warrant this not being a duplicate. I believe that OP is asking how to cast all the data in his class objects as dictionaries. I'm looking for a more customized approach in that I don't want everything in  included in the dictionary returned by . Something like public vs private variables may suffice to explain what I'm looking for. The objects will be storing some values used in calculations and such that I don't need/want to show up in the resulting dictionaries.UPDATE:I've chosen to go with the  route suggested but it was a tough choice selecting what I wanted to be the answer to the question. Both @RickTeachey and @jpmc26 provided the answer I'm going to roll with but the former had more info and options and landed on the same result as well and was upvoted more so I went with it. Upvotes all around though and thanks for the help. I've lurked long and hard on stackoverflow and I'm trying to get my toes in the water more.
There are at least five ways. The preferred way depends on what your use case is.Option 1: Simply add an  method.Based on the problem description I would very much consider the  way of doing things suggested by other answers. This is because it does not appear that your object is really much of a collection:Using the other options below could be confusing for others unless it is very obvious exactly which object members would and would not be iterated or specified as key-value pairs.Option 2: Override .Like this, for example:Now you can just do: This works because the  constructor accepts an iterable of  pairs to construct a dictionary. Before doing this, ask yourself the question whether iterating the object as a series of key,value pairs in this manner- while convenient for creating a - might actually be surprising behavior in other contexts. E.g., ask yourself the question "what should the behavior of  be...?"Additionally, note that accessing values directly using the get item  syntax will not work, and keyword argument unpacking won't work. For those, you'd need to implement the mapping protocol.Option 3: Implement the mapping protocol. This allows access-by-key behavior, casting to a  without using , and also provides keyword unpacking behavior.The mapping protocol requires that you provide (at minimum) two methods together:  and .Now you can do things like:Note that the mapping protocol takes precedence over the  method when casting an object to a  directly (without using kwarg unpacking, i.e. ). So it is possible- and sometimes convenient- to cause the object to have different behavior when used as an iterable (e.g., ) vs. when cast to a  ().EMPHASIZED: Just because you CAN use the mapping protocol, does NOT mean that you SHOULD do so. Does it actually make sense for your object to be passed around as a set of keyword arguments? Does accessing it by key- just like a dictionary- really make sense?If the answer to these questions is yes, it's probably a good idea to consider the next option.Option 4: Look into using the ' module.Inheriting your class from  or  signals to other users that, for all intents and purposes, your class is a mapping * and can be expected to behave that way.You can still cast your object to a  just as you require, but there would probably be little reason to do so. Because of duck typing, bothering to cast your mapping object to a  would just be an additional unnecessary step the majority of the time.This answer might also be helpful.As noted in the comments below: it's worth mentioning that doing this the abc way essentially turns your object class into a -like class (assuming you use  and not the read-only  base class). Everything you would be able to do with , you could do with your own class object. This may be, or may not be, desirable.Also consider looking at the numerical abcs in the  module:https://docs.python.org/3/library/numbers.htmlSince you're also casting your object to an , it might make more sense to essentially turn your class into a full fledged  so that casting isn't necessary. Option 5: Look into using the  module (Python 3.7 only).Now you can do this:* "Mapping" has become the standard "name" of the -like duck type
There is no magic method that will do what you want. The answer is simply name it appropriately.  is a reasonable choice for a plain conversion to , inspired primarily by . However, your method will obviously contain special logic that might not be immediately obvious from that name; you are returning only a subset of the class' state. If you can come up with with a slightly more verbose name that communicates the concepts clearly, all the better.Other answers suggest using , but unless your object is truly iterable (represents a series of elements), this really makes little sense and constitutes an awkward abuse of the method. The fact that you want to filter out some of the class' state makes this approach even more dubious.
something like this would probably work
I think this will work for you.  Output{'a': 1, 'c': 3, 'b': 2, 'sum': 6, 'version': 5}
It's hard to say without knowing the whole context of the problem, but I would not override .I would implement  on the class.
Like many others, I would suggest implementing a to_dict() function rather than (or in addition to) allowing casting to a dictionary. I think it makes it more obvious that the class supports that kind of functionality. You could easily implement such a method like this:


Answer URL
https://docs.python.org/3/c-api/mapping.html
https://docs.python.org/3/library/collections.abc.html
https://docs.python.org/3/library/numbers.html
https://docs.python.org/3/library/dataclasses.html
https://docs.python.org/3/reference/datamodel.html?emulating-container-types#emulating-container-types
https://docs.python.org/3/library/collections.abc.html#collections.abc.Mapping
