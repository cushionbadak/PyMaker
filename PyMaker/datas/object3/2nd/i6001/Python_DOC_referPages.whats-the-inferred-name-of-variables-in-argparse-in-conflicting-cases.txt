Natural Text
I have noticed that  uses a rather "mystic" way of creating the variables in the parser. I know that the names of the variables are usually easy to infer:it's the stripped version of long or short option (without the  or  respectively).Also all hyphens () becomes underscores () to become legal variable names.But that leaves me with a question about conflicting cases (I know it's an extreme case but the inferring part it's a bit mysterious to me). For example the program:uses apparently two very similar options ( and ) which lead to the same inferred variable . If either of the options was missing the variable would be  without ambiguity.But when both are present, apparently  gets the trophy variable  and the second one () gets what? I haven't been able to find what's the second variable. So, to access it I must define a variable explicitly with  option? How do I get list of the names of variables available? The funny thing is that if I use  for the  option then  gets the expected variable  while  gets the non inferred one (in my case )!I know also that metavar has nothing to do with the actual variable name but only affects the display in help.Edit:Adding some information from the @Martijn Pieters answer:If I am getting it write if no  is applied the parser follows the general rule which states that an implicit  is applied. The same in my case .So, is exactly the same as:internally.But, then the following code snippets should produce different results which it does not:max-value 3max-value 3Both just print the value of  as  independently of the order they are declared.So,  option have higher precedence than binary (i.e. flags)? Are option types important in these cases?P.S. I am using python 3.6.3 and since it might be a version issue I wanted to mention it.
There is no conflict here; for both  and , the library simply generates the exact same destination name. Multiple options writing to the same  destination name is perfectly valid; the last option used on the command line wins in that case:Here  wins because  was used last on the command line.Note that any defaults are applied before command-line parsing; the first registered option default value wins. Then the command-line is parsed and if only one of the options is used, then naturally the action associated with that option wins.It is up to you to pick non-conflicting destination names. Not picking option strings that are easy to confuse is also a good idea.If you were looking for a formal set of rules on what  name is generated for a given optional argument, see the  option documenation:For optional argument actions, the value of  is normally inferred from the option strings.  generates the value of dest by taking the first long option string and stripping away the initial  string. If no long option strings were supplied,  will be derived from the first short option string by stripping the initial  character. Any internal  characters will be converted to  characters to make sure the string is a valid attribute name.Multiple options all writing to the same  destination name is useful for supporting old, deprecated names for a given option:So using  or  on the command line has the exact same effect as using  or ; the same destination name is set on the namespace.


Answer URL
https://docs.python.org/3/library/argparse.html#dest
https://docs.python.org/3/library/argparse.html#metavar
https://docs.python.org/3/library/argparse.html#dest
