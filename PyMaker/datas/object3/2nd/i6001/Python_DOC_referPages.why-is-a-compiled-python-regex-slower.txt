Natural Text
In another SO question, the performance of regexes and Python's  operator were compared. However, the accepted answer uses , which only matches the beginning of a string, and thus behaves completely different to . Also, I wanted to see the performance gain of not recompiling the RE each time.Surprisingly, I see that the pre-compiled version seems to be slower.Any ideas why?I am aware that there are quite a few other questions here that wonder about a similar issue. Most of them perform the way they do simply because they do not correctly reuse the compiled regex. If that is also my issue, please explain.Output:
Short answerIf you call  directly, it won't call  at all, it will be faster than  and much faster than .This performance difference is due to s in cache and slow hash calculations for compiled patterns. functions and  methodsAny time a  function with a  as 1st argument (e.g.  or ) is called, Python tries to compile the  first with  and then calls the corresponding method on the compiled pattern. For example:Note that  could be either a string or an already compiled pattern (an  instance)._compileHere's a compact version of . I simply removed debug and flags check: with String patternWhen  is called with a string pattern, the compiled pattern is saved in  dict. Next time the same function is called (e.g. during the many  runs),  simply checks in  if this string has already been seen and returns the corresponding compiled pattern.Using  debugger in Spyder, it's easy to dive into  during execution.With a breakpoint at the second , it can be seen that the pair:is saved in . The compiled pattern is returned directly. with compiled patternslow hashWhat happens if  is called with an already compiled pattern?First,  checks if the pattern is in . To do so, it needs to calculate its hash. This calculation is much slower for a compiled pattern than for a string: is 60 times slower than  here.When a  is unknown,  fails with a .The  gets handled and ignored. Only then does  check if the pattern is already compiled. If it is, it gets returned, without being written in cache.It means that the next time  is called with the same compiled pattern, it will calculate the useless, slow hash again, but will still fail with a .Error handling is expensive, and I suppose that's the main reason why  is slower than .This weird behaviour might be a choice to speed up calls with string patterns, but it might have been a good idea to write a warning if  is called with an already compiled pattern.


Answer URL
https://docs.python.org/3/library/re.html#re.regex.search
https://docs.python.org/3/library/re.html#re.search
