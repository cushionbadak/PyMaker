Natural Text
I'm converting some serial processed python jobs to multiprocessing with dask or joblib. Sadly I need to work on windows.When running from within IPython or from command line invoking the py-file with python everything is running fine.When compiling an executable with cython, it is no longer running fine: Step by step more and more processes (unlimited and bigger than the number of requested processes) get startet and block my system.It somehow feels like Multiprocessing Bomb - but of course I used  for having the control block - approved by fine running from python call at the command line.My cython call is  and I'm compiling with  resulting in a windows executable .With other (single processing) code that is running fine.The problem seems to be the same for dask and joblib (what might mean, that dask works like or is based on joblib).Any suggestions?For those interested in a mcve: Just taking the first code from Multiprocessing Bomb and compiling it with my cython commands above will result in an executable blowing your system. (I just tried :-) )I just found something interesting by adding one line to the code sample for showing the :When running that piece of code with  it shows(other output supressed). Explaining that the if decision works.When running the executable after cython and compilation is showsand more and more. Thus the workers call to the module are no longer  like an import and thus each workers tries to start five new ones in a recursive manner.
At first I was surprised to see, that your cython version worked somehow, but it is only an appearance of working. However, with some hacking it seems to be possible to make it work. I'm on linux, so I use  to simulate the behavior of windows. What happens in the -mode? Let's add some s, so we can investigate the processes:By using  we can see that at first there is only one-python process, then 7(!) different s. We can see the command-line arguments via . 5 of the new processes have command lineand one:That means, the parent process starts 6 new python interpreter instances and every newly started interpreter executes a code sent from the parent via the command line options, the information is shared via pipes. One of these 6 python-instances is a tracker, which observes the whole thing.Ok, what happens if cythonized+embeded? The same as with the normal python, the only difference is that the -executable is started instead of python. But differently as the python-interpreter, it doesn't execute/isn't aware of the command line arguments, so the  function runs over and over and over again.There is an easy fix: let the -exe to start the python interpreterNow the  is no longer a multiprocessing bomb! However, the goal is probably not to have a python-interpreter around, so we need to make our program aware of possible command lines:Now, our bomb doesn't need a stand-alone python-interpreter and stops after the workers are done. Please note the following:The way it is decide, in which mode  should be started is not very error-safe, but I hope you get the gist is just a canary, it doesn't do anything it only must be there, see here.I would like to end with a disclaimer: I don't have much experience with multiprocessing-module and none on windows, so I'm not sure this solution should be recommended. But at least it is a funny one:)NB: The changed code can be also used with python, because after executing  python changes the  so the code no longer sees the original command line and  is .
Inspired by the answer (or the given ideas there) from ead, I found a very simple solution - or lets better call it workaround.For me just changing the if clause todid it.The reason why that works is (in my case):When calling the original .py-file the worker's  is set to  (but all processes are just the plain .py-file).When running the (cython) compiled version the worker's  is not usable, but the workers get called different and thus we can identify them by more that one argument in argv. In my case worker's argv readsThus in  the code for activation of the workers is found and gets executed with the upper commands.Of course if you need arguments for your compiled file, you need a bigger effort, maybe parsing for the parent_pid in the call. But in my case, that would simply be overdone.
I think based on the detail from the submitted bug report, I can offer the maybe most elegant solution over hereThe -call is needed on windows - see python multiprocessing documentation.If running within python only with that line it is already fine.But somehow cython is obviously not aware of some of those things (the docs tell it is tested with ,  and ). It could be alleviated by the -call, which only may be used when compiling, thus the decision by file extension.


Answer URL
https://docs.python.org/3/library/multiprocessing.html#multiprocessing.freeze_support
