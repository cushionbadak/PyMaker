Natural Text
I have a class with two class methods (using the classmethod() function) for getting and setting what is essentially a static variable.  I tried to use the property() function with these, but it results in an error.  I was able to reproduce the error with the following in the interpreter:I can demonstrate the class methods, but they don't work as properties:Is it possible to use the property() function with classmethod decorated functions?
A property is created on a class but affects an instance.  So if you want a classmethod property, create the property on the metaclass.But since you're using a metaclass anyway, it will read better if you just move the classmethods in there.or, using Python 3's  syntax, and the metaclass defined outside of the  class body, and the metaclass responsible for setting the initial value of :
Reading the Python 2.2 release notes, I find the following.The get method [of a property] won't be called when  the property is accessed as a class  attribute (C.x) instead of as an  instance attribute (C().x). If you  want to override the __get__ operation  for properties when used as a class  attribute, you can subclass property -  it is a new-style type itself - to  extend its __get__ method, or you can  define a descriptor type from scratch  by creating a new-style class that  defines __get__, __set__ and  __delete__ methods.NOTE: The below method doesn't actually work for setters, only getters.Therefore, I believe the prescribed solution is to create a ClassProperty as a subclass of property.However, the setters don't actually work: is unchanged, you've simply overwritten the property with a new value.You can also use  as a decorator:
I hope this dead-simple read-only  decorator would help somebody looking for classproperties.
Is it possible to use the property() function with classmethod decorated functions?No. However, a classmethod is simply a bound method (a partial function) on a class accessible from instances of that class.Since the instance is a function of the class and you can derive the class from the instance, you can can get whatever desired behavior you might want from a class-property with :This code can be used to test - it should pass without raising any errors:And note that we didn't need metaclasses at all - and you don't directly access a metaclass through its classes' instances anyways.writing a  decoratorYou can actually create a  decorator in just a few lines of code by subclassing  (it's implemented in C, but you can see equivalent Python here):Then treat the decorator as if it were a classmethod combined with property:And this code should work without errors:But I'm not sure how well-advised this would be. An old mailing list article suggests it shouldn't work.Getting the property to work on the class:The downside of the above is that the "class property" isn't accessible from the class, because it would simply overwrite the data descriptor from the class .However, we can override this with a property defined in the metaclass . For example:And then a class instance of the metaclass could have a property that accesses the class's property using the principle already demonstrated in the prior sections:And now we see both the instanceand the class have access to the class property.
Python 3!Old question, lots of views, sorely in need of a one-true Python 3 way. Luckily, it's easy with the  kwarg:Then, 'FOO!'
There is no reasonable way to make this "class property" system to work in Python.Here is one unreasonable way to make it work. You can certainly make it more seamless with increasing amounts of metaclass magic.The knot of the issue is that properties are what Python calls "descriptors". There is no short and easy way to explain how this sort of metaprogramming works, so I must point you to the descriptor howto.You only ever need to understand this sort of things if you are implementing a fairly advanced framework. Like a transparent object persistence or RPC system, or a kind of domain-specific language.However, in a comment to a previous answer, you say that you need to modify an attribute that in such a way that is seen by all instances of a class, and in the scope from which these class methods are called does not have references to all instances of the class.It seems to me, what you really want is an Observer design pattern.
Setting it only on the meta class doesn't help if you want to access the class property via an instantiated object, in this case you need to install a normal property on the object as well (which dispatches to the class property). I think the following is a bit more clear:
Because I need to modify an attribute that in such a way that is seen by all instances of a class, and in the scope from which these class methods are called does not have references to all instances of the class.Do you have access to at least one instance of the class? I can think of a way to do it then:
Half a solution, __set__ on the class does not work, still. The solution is a custom property class implementing both a property and a staticmethod
Give this a try, it gets the job done without having to change/add a lot of existing code.The  function needs two  arguments. give them lambda wrappers (which it passes the instance as its first argument) and all is well.
Here's a solution which should work for both access via the class and access via an instance which uses a metaclass.This also works with a setter defined in the metaclass.
After searching different places, I found a method to define a classpropertyvalid with Python 2 and 3.Hope this can help somebody :)
Here's my suggestion.  Don't use class methods.  Seriously.  What's the reason for using class methods in this case?  Why not have an ordinary object of an ordinary class?If you simply want to change the value, a property isn't really very helpful is it?  Just set the attribute value and be done with it.A property should only be used if there's something to conceal -- something that might change in a future implementation.  Maybe your example is way stripped down, and there is some hellish calculation you've left off.  But it doesn't look like the property adds significant value.The Java-influenced "privacy" techniques (in Python, attribute names that begin with _) aren't really very helpful.  Private from whom?  The point of private is a little nebulous when you have the source (as you do in Python.)The Java-influenced EJB-style getters and setters (often done as properties in Python) are there to facilitate Java's primitive introspection as well as to pass muster with the static language compiler.  All those getters and setters aren't as helpful in Python.


Answer URL
https://docs.python.org/3/howto/descriptor.html#properties
