Natural Text
I need to build a python encoder so that I can reformat strings like this:The reason this is even something I'm asking stack overflow is, the encoded strings need to pass this validation function. This is a hard constraint, there is no flexibility on this, its due to how the strings have to be stored.Making an encoder seemed easy enough, but I'm not sure if this encoder is making it harder to build a decoder. Heres the encoder I've written.This is the encoder I've written. I've only included it for example purposes, theres probably a better way to do this.Edit 1 - Someone has wisely pointed out just using base32 on the entire string, which I can definitely use. However, it would be preferable to have something that is 'somewhat readable', so an escaping system like https://en.wikipedia.org/wiki/Quoted-printable or https://en.wikipedia.org/wiki/Percent-encoding would be preferred.Edit 2 - Proposed solutions must work on Python 3.4 or newer, working in Python 2.7 as well is nice, but not required. I've added the python-3.x tag to help clarify this a little.
This seems to do the trick. Basically, alphanumeric letters are left alone. Any non-alphanumeric character in the ASCII set is encoded as a  escape code. All other unicode characters are encoded using the  escape code. However, you've said you can't use , but you can use , thus all escape sequences are translated to start with a . This makes decoding extremely simple. Just replace the  with  and then use the  codec. Encoding is slightly more difficult as the  codec leaves ASCII characters alone. So first you have to escape the relevant ASCII characters, then run the string through the  codec, before finally translating all  to .Code:Which outputs:This works on both python 3.4 and python 2.7, which is why the  is a bit messy  on python 2.7 is an alias for , which works differently to  on python 3.4. This is why the table is constructed using a . For python 2.7, the  method expects a  object not .
Use base32! It uses only the 26 letters of the alphabet and 0-9. You can’t use base64 because it uses the = character, which won’t pass your validator.
You could abuse the url quoting, to get both readable and easy to decode in other languages format that passes your validation function:OutputHere's an implementation using a  (to move it to C later if necessary):
If you want a transliteration of Unicode to ASCII (e.g. ç --> c), then check out the Unidecode package. Here are their examples:Here's my example:Gives as an output**may be nonsense, but at least it's ASCIITo remove punctuation, see this answer.
Despite several good answers. I ended up with a solution that seems cleaner and more understandable. So I'm posting the code of my eventual solution to answer my own question.


Answer URL
https://docs.python.org/3/library/urllib.parse.html#url-quoting
