Natural Text
Is there a more compact or pythonic way to write the boolean expressionI came up with but that is a little strange.
If we look at the Zen of Python, emphasis mine:The Zen of Python, by Tim PetersBeautiful is better than ugly.  Explicit is better than implicit.Simple is better than complex.  Complex is better than complicated.  Flat is better than nested.  Sparse is better than dense.Readability counts.  Special cases aren't special enough to break the rules.  Although practicality beats purity.  Errors should never pass silently.  Unless explicitly silenced.  In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.  Although that way may not be obvious at first unless you're Dutch.  Now is better than never.  Although never is often better than right now.If the implementation is hard to explain, it's a bad idea.If the implementation is easy to explain, it may be a good idea.  Namespaces are one honking great idea -- let's do more of those!The most Pythonic solution is the one that is clearest, simplest, and easiest to explain:Even better, you don't even need to know Python to understand this code! It's that easy. This is, without reservation, the best solution. Anything else is intellectual masturbation.Furthermore, this is likely the best performing solution as well, as it is the only one out of all the proposals that short circuits. If , only a single addition and comparison is done. 
Solving the three equalities for a:
Python has an  function that does an  on all the elements of a sequence. Here I've converted your statement into a 3-element tuple.Note that  is short circuiting, so if calculating the individual conditions is expensive it might be better to keep your original construct.
If you know you're only dealing with positive numbers, this will work, and is pretty clean:As I said, this only works for positive numbers; but if you know they're going to be positive, this is a very readable solution IMO, even directly in the code as opposed to in a function.You could do this, which might do a bit of repeated computation; but you didn't specify performance as your goal:Or without  and the possibility of repeated computations:I would probably put this, or any other solution, into a function. Then you can just cleanly call the function in your code.Personally, unless I needed more flexibility from the code, I would just use the first method in your question. It's simple and efficient. I still might put it into a function:That's pretty Pythonic, and it's quite possibly the most efficient way to do it (the extra function call aside); although you shouldn't worry too much about performance anyway, unless it's actually causing an issue.
If you will only be using three variables then your initial method:Is already very pythonic.If you plan on using more variables then your method of reasoning with:Is very smart but lets think about why. Why does this work?  Well through some simple arithmetic we see that:And this will have to hold true for either a,b, or c, meaning that yes it will equal , , or . This will be true for any number of variables.So a good way to write this quickly would be to simply have a list of your variables and check their sum against a list of the doubled values.This way, to add more variables into the equation all you have to do is edit your values list by 'n' new variables, not write 'n' equations
The following code can be used to iteratively compare each element with the sum of the others, which is computed from sum of the whole list, excluding that element.
Don't try and simplify it. Instead, name what you're doing with a function:Replace the condition with something "clever" might make it shorter, but it won't make it more readable. Leaving it how it is isn't very readable either however, because it's tricky to know why you're checking those three conditions at a glance. This makes it absolutely crystal clear what you're checking for.Regarding performance, this approach does add the overhead of a function call, but never sacrifice readability for performance unless you've found a bottleneck you absolutely must fix. And always measure, as some clever implementations are capable of optimizing away and inlining some function calls in some circumstances.
Python 3:It scales to any number of variables:However, in general I agree that unless you have more than three variables, the original version is more readable.
If the sum of any two terms is equal to the third term, then one of the factors will be zero, making the entire product zero.
How about just:Note that this won't work if variables are unsigned.From the viewpoint of code optimization (at least on x86 platform) this seems to be the most efficient solution.Modern compilers will inline both abs() function calls and avoid sign testing and subsequent conditional branch by using a clever sequence of CDQ, XOR, and SUB instructions. The above high-level code will thus be represented with only low-latency, high-throughput ALU instructions and just two conditionals.
The solution provided by Alex Varga "a in (b+c, b-c, c-b)" is compact and mathematically beautiful, but I wouldn't actually write code that way because the next developer coming along would not immediately understand the purpose of the code.Mark Ransom's solution of is more clear but not much more succinct than When writing code that someone else will have to look at, or that I will have to look at a long time later when I have forgotten what I was thinking when I wrote it, being too short or clever tends to do more harm than good.  Code should be readable.  So succinct is good, but not so succinct that the next programmer can't understand it.
Request is for more compact OR more pythonic - I tried my hand at more compact.givenThis is 2 characters less than the originaltest with:additionally, given:This is equivalent
I want to present what I see as the most pythonic answer:The general case, non-optimized:   In terms of the Zen of Python I think the emphasized statements are more followed than from other answer:The Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.  Complex is better than complicated.  Flat is better than nested.  Sparse is better than dense.Readability counts.  Special cases aren't special enough to break the rules.  Although practicality beats purity.  Errors should never pass silently.  Unless explicitly silenced.  In the face of ambiguity, refuse the temptation to guess.  There should be one-- and preferably only one --obvious way to do it.  Although that way may not be obvious at first unless you're Dutch.  Now is better than never.  Although never is often better than right now.  If the implementation is hard to explain, it's a bad idea.  If the implementation is easy to explain, it may be a good idea.  Namespaces are one honking great idea -- let's do more of those!
As an old habit of my programming, I think placing complex expression at right in a clause can make it more readable like this:Plus :And also I think using multi-lines can also make more senses like this:
In a generic way,if, manipulating an input variable is OK for you,if you want to exploit using bit hacks, you can use "!", ">> 1" and "<< 1"I avoided division though it enables use to avoid two multiplications to avoid round off errors. However, check for overflows



Answer URL
https://docs.python.org/3/library/decimal.html
