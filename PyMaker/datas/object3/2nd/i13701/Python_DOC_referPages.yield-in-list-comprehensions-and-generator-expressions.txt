Natural Text
The following behaviour seems rather counterintuitive to me (Python 3.4):The intermediate values of the last line are actually not always , they are whatever we  into the generator, equivalent (I guess) to the following generator:It strikes me as funny that those three lines work at all. The Reference says that  is only allowed in a function definition (though I may be reading it wrong and/or it may simply have been copied from the older version). The first two lines produce a  in Python 2.7, but the third line doesn't.Also, it seems oddthat a list comprehension returns a generator and not a listand that the generator expression converted to a list and the corresponding list comprehension contain different values.Could someone provide more information?
Note: this was a bug in the CPython's handling of  in comprehensions and generator expressions, fixed in Python 3.8, with a deprecation warning in Python 3.7. See the Python bug report and the What's New entries for Python 3.7 and Python 3.8.Generator expressions, and set and dict comprehensions are compiled to (generator) function objects. In Python 3, list comprehensions get the same treatment; they are all, in essence, a new nested scope.You can see this if you try to disassemble a generator expression:The above shows that a generator expression is compiled to a code object, loaded as a function ( creates the function object from the code object). The  reference lets us see the code object generated for the expression, and it uses  just like a generator function would.As such, the  expression works in that context, as the compiler sees these as functions-in-disguise.This is a bug;  has no place in these expressions. The Python grammar before Python 3.7 allows it (which is why the code is compilable), but the  expression specification shows that using  here should not actually work:The yield expression is only used when defining a generator function and thus can only be used in the body of a function definition.This has been confirmed to be a bug in issue 10544. The resolution of the bug is that using  and  will raise a  in Python 3.8; in Python 3.7 it raises a  to ensure code stops using this construct. You'll see the same warning in Python 2.7.15 and up if you use the  command line switch enabling Python 3 compatibility warnings.The 3.7.0b1 warning looks like this; turning warnings into errors gives you a  exception, like you would in 3.8:The differences between how  in a list comprehension and  in a generator expression operate stem from the differences in how these two expressions are implemented. In Python 3 a list comprehension uses  calls to add the top of the stack to the list being built, while a generator expression instead yields that value. Adding in  just adds another  opcode to either:The  opcode at bytecode indexes 15 and 12 respectively is extra, a cuckoo in the nest. So for the list-comprehension-turned-generator you have 1 yield producing the top of the stack each time (replacing the top of the stack with the  return value), and for the generator expression variant you yield the top of the stack (the integer) and then yield again, but now the stack contains the return value of the  and you get  that second time.For the list comprehension then, the intended  object output is still returned, but Python 3 sees this as a generator so the return value is instead attached to the  exception as the  attribute:Those  objects are the return values from the  expressions.And to reiterate this again; this same issue applies to dictionary and set comprehension in Python 2 and Python 3 as well; in Python 2 the  return values are still added to the intended dictionary or set object, and the return value is 'yielded' last instead of attached to the  exception:


Answer URL
https://docs.python.org/3/reference/expressions.html#yield-expressions
https://docs.python.org/3/reference/expressions.html#yield-expressions
https://docs.python.org/3/library/exceptions.html#StopIteration
