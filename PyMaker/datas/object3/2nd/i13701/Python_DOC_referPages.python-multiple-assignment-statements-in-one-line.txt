Natural Text
(Don't worry, this isn't another question about unpacking tuples.)In python, a statement like  assigns the variables foo, bar, and baz to 5.  It assigns these variables from left to right, as can be proved by nastier examples likeBut the python language reference states that assignment statements have the form and on assignment the  is evaluated first and then the assigning happens.So how can the line  be valid, given that  isn't an ?  How are these multiple assignments on one line getting parsed and evaluated?  Am I reading the language reference wrong?
All credit goes to @MarkDickinson, who answered this in a comment:Notice the  in , which means one or more copies. In , there are two  productions, and the  part is just All  productions (i.e. things that look like ) in an assignment statement get assigned, from left to right, to the  on the right end of the statement, after the  gets evaluated.And of course the usual 'tuple-unpacking' assignment syntax works within this syntax, letting you do things like
Mark Dickinson explained the syntax of what is happening, but the weird examples involving  show that the semantics can be counter-intuitive.In C,  is a right-associative operator which returns as a value the RHS of the assignment so when you write ,  is first evaluated (assigning 5 to  in the process) and this value (5) is then assigned to .Before I read this question, I naively assumed that roughly the same thing happens in Python. But, in Python  isn't an expression (for example,  is a syntax error). So Python must achieve multiple assignments in another way.We can disassemble rather than guess:See this for a description of the byte code instructions.The first instruction pushes 5 onto the stack.The second instruction duplicates it -- so now the top of the stack has two 5s "Implements name = TOS" according to the byte code documentation Thus  implements  (the 5 on top of the stack), popping that 5 off the stack as it goes, after which  implements  with the other 5 on the stack.The rest of the bytecode isn't directly relevant here.In the case of  the byte-code is more complicated because of the lists but has a fundamentally similar structure. The key observation is that once the list  is created and placed on the stack then the instruction  doesn't place another copy of  on the stack, instead it places another reference to the list. In other words, at that stage the top two elements of the stack are aliases for the same list. This can be seen most clearly in the somewhat simpler case: When  is executed, the list  is first assigned to  and then an alias of the same list is assigned to . This is why it results in  being a circular reference.
 is not an expression.  The multiple assignment is a separate statement from the assignment statement; the expression is everything to the right of the right-most .A good way to think about it is that the right-most  is the major separator; everything to the right of it happens from left to right, and everything to the left of it happens from left to right as well.
https://docs.python.org/3/reference/simple_stmts.html#grammar-token-assignment_stmtAn assignment statement evaluates the expression list (remember that this can be a single expression or a comma-separated list, the latter yielding a tuple) and assigns the single resulting object to each of the target lists, from left to right.


Answer URL
https://docs.python.org/3/reference/simple_stmts.html#grammar-token-assignment_stmt
