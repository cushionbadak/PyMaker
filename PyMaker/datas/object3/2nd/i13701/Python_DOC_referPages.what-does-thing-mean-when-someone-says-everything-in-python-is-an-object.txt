Natural Text
I constantly see people state that "Everything in Python is an object.", but I haven't seen "thing" actually defined.  This saying would lead me to believe that all tokens of any kind are also considered to be objects, including operators, punctuators, whitespace, etc.  Is that actually the case?  Is there a more concise way of stating what a Python object actually is?Thanks
Anything that can be assigned to a variable is an object.That includes functions, classes, and modules, and of course 's, 's, 's, 's, and everything else. It does not include whitespace, punctuation, or operators.Just to mention it, there is the  module in the standard library which includes functions that implement operators; those functions are objects. That doesn't mean  or  are objects.I could go on and on, but this is simple and pretty complete.
Some values are obviously objects; they are instances of a class, have attributes, etc.Other values are less obviously objects. Types are objects:Even  is an object (of type , oddly enough):Modules are objects:Built-in functions are objects:In short, if you can reference it by name, it's an object.
What is generally meant is that most things, for example functions and methods are objects. Modules too. Classes (not just their instances) themselves are objects. and int/float/strings are objects. So, yes, things generally tend to be objects in Python. Cyphase is correct, I just wanted to give some examples of things that might not be immediately obvious as objects. Being objects then a number of properties are observable on things that you would consider special case, baked-in stuff in other languages.  Though __dict__, which allows arbitrary attribute assignment in Python, is often missing on things intended for large volume instantiations like int.Therefore, at least on pure-Python objects, a lot of magic can happen, from introspection to things like creating a new class on the fly.Kinda like turtles all the way down.
You're not going to find a rigorous definition like C++11's, because Python does not have a formal specification like C++11, it has a reference manual like pre-ISO C++. The Data model chapter is as rigorous as it gets:Objects are Python’s abstraction for data. All data in a Python program is represented by objects or by relations between objects. (In a sense, and in conformance to Von Neumann’s model of a “stored program computer,” code is also represented by objects.)Every object has an identity, a type and a value. An object’s identity never changes once it has been created; you may think of it as the object’s address in memory. …The glossary also has a shorter definition:Any data with state (attributes or value) and defined behavior (methods).And it's true that everything in Python has methods and (other) attributes. Even if there are no public methods, there's a set of special methods and values inherited from the  base class, like the  method.This wasn't true in versions of Python before 2.2, which is part of the reason we have multiple words for nearly the same thing—object, data, value; type, class… But from then on, the following kinds of things are identical:Objects.Things that can be returned or yielded by a function.Things that can be stored in a variable (including a parameter).Things that are instances of type  (usually indirectly, through a subclass or two).Things that can be the value resulting from an expression.Things represented by pointers to  structs in CPython.… and so on.That's what "everything is an object" means.It also means that Python doesn't have "native types" and "class types" like Java, or "value types" and "reference types" like C#; there's only one kind of thing, objects.This saying would lead me to believe that all tokens of any kind are also considered to be objects, including operators, punctuators, whitespace, etc. Is that actually the case?No. Those things don't have values, so they're not objects.1Also, variables are not objects. Unlike C-style variables, Python variables are not memory locations with a type containing a value, they're just names bound to a value in some namespace.2 And that's why you can't pass around references to variables; there is no "thing" to reference.3Assignment targets are also not objects. They sometimes look a lot like values, and even the core devs sometimes refer to things like the  in  loosely as a tuple object—but there is no tuple there.4There's also a bit of apparent vagueness with things like elements of a  (or an  or ). When you write , the  object doesn't get stored in the  the way it would with a . Instead, numpy stores some bytes that Python doesn't even understand, but that it can use to do "the same thing a 3 would do" in array-wide operations, or to make a new copy of the  object if you later ask for .But if you go back to the definition, it's pretty clear that this "virtual " is not an object—while it has a type and value, it does not have an identity.1. At the meta level, you can write an import hook that can act on imported code as a byte string, a decoded Unicode string, a list of token tuples, an AST node, a code object, or a module, and all of those are objects… But at the "normal" level, from within the code being imported, tokens, etc. are not objects.2. Under the covers, there's almost always a string object to represent that name, stored in a dict or tuple that represents the namespace, as you can see by calling  or . But that's not what the variable is.3. A closure cell is sort of a way of representing a reference to a variable, but really, it's the cell itself that's an object, and the variables at different scopes are just a slightly special kind of name for that cell.4. However, in , although  isn't a value,  and  are, because that assignment is equivalent to the expression , except that it's not an expression.


Answer URL
https://docs.python.org/3/reference/index.html
https://docs.python.org/3/reference/datamodel.html#objects-values-and-types
https://docs.python.org/3/glossary.html#term-object
