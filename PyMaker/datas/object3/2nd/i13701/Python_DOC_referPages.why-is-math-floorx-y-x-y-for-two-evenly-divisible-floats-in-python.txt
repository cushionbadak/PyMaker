Natural Text
I have been reading about division and integer division in Python and the differences between division in Python2 vs Python3. For the most part it all makes sense. Python 2 uses integer division only when both values are integers. Python 3 always performs true division. Python 2.2+ introduced the  operator for integer division.Examples other programmers have offered work out nice and neat, such as:How is  implemented? Why does the following happen:Shouldn't ? These results were produced on python2.7, but since x and y are both floats the results should be the same on python3+. If there is some floating point error where  is actually  and  wouldn't that be reflected in ?The following similar cases, however, aren't affected:
I didn't find the other answers satisfying. Sure,  has no finite binary expansion, so our hunch is that representation error is the culprit. But that hunch alone doesn't really explain why  yields  while  yields .The punchline is that  is actually doing , as opposed to simply ..5 / .1 is exactly 5.0First of all, note that the result of  is exactly  in Python. This is the case even though  cannot be exactly represented. Take this code, for instance:And the corresponding output:This shows that  can be represented with a finite binary expansion, but  cannot. But it also shows that despite this, the result of  is exactly . This is because floating point division results in the loss of precision, and the amount by which  differs from  is lost in the process.That's why  works as you might expect: since  is , writing  is just the same as writing .So why doesn't  result in 5?One might assume that  is shorthand for , but this is not the case. As it turns out, the semantics differ. This is even though the PEP says:Floor division will be implemented in all the Python numeric      types, and will have the semantics ofAs it turns out, the semantics of  are actually equivalent to:where  is the floating point remainder of  rounded towards zero. This is made clear by reading the Python source code.This is where the fact that  can't be exactly represented by binary expansion causes the problem. The floating point remainder of  is not zero:and it makes sense that it isn't. Since the binary expansion of  is ever-so-slightly greater than the actual decimal , the largest integer  such that  (in our finite precision math) is . So  is nonzero, and is roughly . Hence  becomes  becomes  which equals .And that's why .Why does  do that?The behavior of  may seem strange, but there's a reason for it's divergence from . In his blog on the history of Python, Guido writes:The integer division operation (//) and its sibling, the modulo  operation (%), go together and satisfy a nice mathematical  relationship (all variables are integers):such that(assuming a and b are >= 0).Now, Guido assumes that all variables are integers, but that relationship will still hold if  and  are floats, if . If  the relationship won't hold in general. And so  might be preferred because it satisfies this nice mathematical relationship.
That's because  cannot be precisely represented in binaryYou can also see that 
The issue is that Python will round the output as described here. Since  cannot be represented exactly in binary, the result is something like . Naturally this becomes  when not using format. 
This isn't correct, I'm afraid. .5 / .1 is 5.0 exactly. See: (.5/.1).as_integer_ratio(), which yields (5,1).Yes,  can be represented as , that is true. But in order to see the fraction of the actual result Python gives due to the inexact representation, follow along.First, import:Variables for easy usage:Yields the following values:Naturally,  and .So what happens when we divide?But when we want the integer ratio...As stated earlier,  is  of course. That's where  comes in:And wolfram alpha confirms that this is indeed . Why don't you just do  or ?The latter will give us the same  result. The former will give us  instead. This results in , similar but not the same result.


Answer URL
https://docs.python.org/3/tutorial/floatingpoint.html
