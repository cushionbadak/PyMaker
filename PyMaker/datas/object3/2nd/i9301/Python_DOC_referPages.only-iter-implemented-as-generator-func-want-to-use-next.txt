Natural Text
I have a class with  defined like below:I want to do  but I have to implement  to do so. But it would change this simple implementation to a fairly complicated one - or actually I don't know how to implement this instead of defining  as a generator function.Generally spealing, if  is implemented as a generator fuction which might be difficult to be done without generator, how should I do if I want to use ?Note: Apparently,  works, but I don't want to do it.
If your class is supposed to be an iterator, it should not have its  method implemented as a generator function. That makes the class iterable, but not an iterator. An iterator's  method is supposed to return itself.If you really want your class to be an iterator, try something like this:The  call may raise , which I deliberately do not catch. That exception is the signal we're finished iterating, so if we caught it we'd only have to raise it again.This code uses a "Easier to Ask Forgiveness than Permission" (EAFP) approach to detecting iterable items within the iterator it's been given. It simply tries calling  on each one and catches the  that will be raised if they're not iterable. If you prefer to stick with the "Look Before You Leap" (LBYL) style and explicitly test with  (which is badly named, since it checks for any kind of iterable, not only iterators), you could replace the inner  with:I usually prefer EAFP style to LBYL style in my Python code, but there are situations where either one can be better. Other times it's just a matter of style.
As @BrenBarm commented, the apparent answer was to return , or  by keeping . I couldn't just come up with it.
an iterator is an object with a  method that returns values until finally raising .an iterable is an object with an  method that returns an iterator.a generator is a special iterable created by python when a function or method include the yield statement.In your example,  has a yield so it is a generator. And that means it returns another iterable, not an iterator. That's why you have to do that strange  thing, and that doesn't work because it restarts the enumation each time.How best to solve this problem depends on how you are using this class. You could create a generator function instead and then use  to make iterators as needed:Or you can implement  instead of . But you can't use  and have to return a value on each call until the outer iterator completes and raises .


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable
