Natural Text
I'm running memcached with the following bash command pattern:to try and track down unmatched gets to sets for keys platform wide.The memtracer script is below and works as desired, with one minor issue.  Watching the intermediate log file size, memtracer.py doesn't start getting input until memkeywatchYMD.logis about 15-18K in size.  Is there a better way to read in stdin or perhaps a way to cut the buffer size down to under 1k for faster response times?
You can completely remove buffering from stdin/stdout by using python's  flag:and the man page clarifies:Beyond this, altering the buffering for an existing file is not supported, but you can make a new file object with the same underlying file descriptor as an existing one, and possibly different buffering, using os.fdopen.  I.e.,should bind  to the name of a file object that reads the same FD as standard input, but buffered by only about 100 bytes at a time (and you could continue with  to use the new file object as standard input from there onwards).  I say "should" because this area used to have a number of bugs and issues on some platforms (it's pretty hard functionality to provide cross-platform with full generality) -- I'm not sure what its state is now, but I'd definitely recommend thorough testing on all platforms of interest to ensure that everything goes smoothly.  (, removing buffering entirely, should work with fewer problems across all platforms, if that might meet your requirements).
You can simply use  instead of :This gives me line-buffered reads using Python 2.7.4 and Python 3.3.1 on Ubuntu 13.04.
The  still being line-buffered, one can have an iterator that behaves mostly identically (stops at EOF, whereas  won't) by using the 2-argument form of  to make an iterator of :Or provide  as the sentinel (but note that then you need to handle the EOF condition yourself).
This worked for me in Python 3.4.3:The documentation for  says it is just an alias for . has an optional  parameter:buffering is an optional integer used to set the buffering policy. Pass 0 to switch buffering off (only allowed in binary mode), 1 to select line buffering (only usable in text mode), and an integer > 1 to indicate the size in bytes of a fixed-size chunk buffer. In other words:Fully unbuffered stdin requires binary mode and passing zero as the buffer size.Line-buffering requires text mode.Any other buffer size seems to work in both binary and text modes (according to the documentation).
The only way I could do it with python 2.7 was:from Python nonblocking console input . This completly disable the buffering and also suppress the echo.EDIT: Regarding Alex's answer, the first proposition (invoking python with ) is not possible in my case (see shebang limitation).The second proposition (duplicating fd with smaller buffer: ) is not working when I use a buffer of 0 or 1, as it is for an interactive input and I need every character pressed to be processed immediatly.


Answer URL
https://docs.python.org/3/library/os.html#os.fdopen
https://docs.python.org/3/library/functions.html#open
