Natural Text
Since we're on the topic of peculiarities surrounding numpy's , I've discovered something that I don't understand either. I'm posting this question mainly as an extension of MSeifert's since it seems there might be a common reason for both of our observations.Earlier on, I posted a solution that involves using  on a sequence containing  values:However, I saw this answer on MSeifert's question linked above which shows an alternative way I might have formulated this algorithm:ExperimentI've tested both of these variations with both lists and numpy arrays. The code and results are included below:AnalysisOf all four combinations, only checks against lists using the original function works as expected.The modified function (using ) seems to work the same way for both lists and arrays.The original function does not appear to find any  values when checking arrays.Can anyone explain these results? Again, as this question is related to MSeifert's, it's possible that an explanation of his results would explain mine too (or vice versa).Further InvestigationTo get a better picture of what's happening, I tried printing out the groups generated by :One fundamental difference (which in retrospect makes sense) is that the original function (using ) will filter out everything except  values, so all generated groups will consist only of  values, like this:On the other hand, the modified function will group all non- values into their own groups, like this:This explains why the modified function returns  in both cases - it's considering values as either "" or "not " and returning the longest contiguous series of either.This also means that I was wrong about my assumptions of how  works, and that the modified function is not a viable alternative to the original.I'm still not sure about the difference in results when running the original function on lists and arrays, though.
Item access in numpy arrays behaves different than in lists:While the list contains references to the same object, numpy arrays 'contain' only a region of memory and create new Python objects on the fly each time an element is accessed. (Thank you user2357112, for pointing out the inaccuracy in phrasing.)Makes sense, right? Same object returned by the list, different objects returned by the array - obviously  internally uses  for comparison... But wait, it's not that easy! Why does  work correctly? The answer is buried in the the itertools C source, line 90 shows that the function  is used for comparing two keys.Although this is basically equivalent to using  in Python, the docs note one speciality:Note If o1 and o2 are the same object,  will always return  for  and  for .This means that actually this comparison is performed (equivalent code):So for lists, we have the same  objects, which is identified as equal. In contrast, arrays give us different objects with value , which are compared with  - but  always evaluates as .
Alright, I think I've painted a clear enough picture for myself of what's going on.There two factors at play here:My own misunderstanding of what the  argument did for .The (much more interesting) story of how Python represents  values within arrays and lists, which is best explained in this answer.Explaining the  factorFrom the documentation on :It generates a break or new group every time the value of the key function changesFrom the documentation on :For scalar input, the result is a new boolean with value True if the input is NaN; otherwise the value is False.Based on these two things, we deduce that when we set  as , each element in the sequence passed to  will be mapped to either  or , depending on whether it is a  or not. This means that the key function will only change at the boundary between  elements and non- elements, and therefore that  will only split the sequence into contiguous blocks of  and non- elements.In contrast, the original function (which used ) will use the identity function for  (its default value). This naturally leads into the nuances of  identity which is explained below (and in the linked answer above), but the important point here is that the  will filter out all groups keyed on non- elements.Explaining nuances in  identity As better explained in the answer I linked above, all instances of  that occur within Python's built-in lists seem to be one and the same instance. In other words, all occurrences of  in lists point to the same place in memory. In contrast to this,  elements are generated on the fly when using numpy arrays and so are all separate objects.This is demonstrated using the code below:When I run this using the list defined in the original question, I obtain this output (identical elements are highlighted):On the other hand, array elements seem to be handled in memory very differently:The function seems to alternate between two separate locations in memory for storing these values. Notice that none of the elements are identical to the  used in the filter condition.Case StudiesWe can now apply all this information we've gathered to the four separate cases used in the experiment to explain our observations.Original function with listsDuring this case, we use the default  function as , and we've seen that each occurrence of  in lists are in fact all the same instance. The  used in the filter conditional  is also identical to the  elements in the list, causing  to break the list at appropriate places and only retain the groups containing . This is why this variant works and we obtain the correct result of .Original function with arraysAgain, we use the default  function as , but this time all  occurrences - including the one in the filter conditional - point to different objects. This means that the conditional filter  will fail for all groups. Since we can't find the maximum of an empty collection, we fall back on the default value of .Modified function with lists and arraysIn both of these cases, we use  as . This will cause  to split the sequence into contiguous sequences of  and non- elements.For the list/array we used for our experiment, the longest sequence of  elements is , which has three elements, and the longest sequence of non- elements is , which has 7 elements. will select the longer of these two sequences and return  in both cases.


Answer URL
https://docs.python.org/3/c-api/object.html#c.PyObject_RichCompareBool
