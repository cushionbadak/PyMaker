Natural Text
I'm having a difficult time to debug a problem in which the float  in a  and  in a  are handled differently when these are used in :Given the following list and array:When I iterate over the list the contiguous s are grouped:However if I use the array it puts successive s in different groups:Even if I convert the array back to a list:I'm using:I know that generally  so why do these operations give different results? And how is it possible that  can group s at all?
Python lists are just arrays of pointers to objects in memory. In particular  holds pointers to the object :( is at 139832272211880 on my computer.)On the other hand, NumPy arrays are just contiguous regions of memory; they are regions of bits and bytes that are interpreted as a sequence of values (floats, ints, etc.) by NumPy.The trouble is that when you ask Python to iterate over a NumPy array holding floating values (at a -loop or  level), Python needs to box these bytes into a proper Python object. It creates a brand new Python object in memory for each single value in the array as it iterates.For example, you can see that that distinct objects for each  value are created when  is called: is able to group on  for the Python list because it checks for identity first when it compares Python objects. Because these pointers to  all point at the same  object, grouping is possible.However, iteration over the NumPy array does not allow this initial identity check to succeed, so Python falls back to checking for equality and  as you say.
The answers of tobias_k and ajcr are correct, it's because the s in the list have the same  while they have different ids when they are "iterated over" in the numpy-array.This answer is meant as a supplement for these answers.The problem is that Python uses the -operation when comparing values, which only tests for object identity if  fails because it's not implemented.  on the other hand uses  (see Source: 1, 2) which tests for object identity first and before  is tested.This can be verified with a small cython snippet:The source code for  reads like this:The object identity test () is indeed done before the normal python comparison  is used and mentioned in its documentation:Note :If o1 and o2 are the same object,  will always return 1 for Py_EQ and 0 for Py_NE. 
I am not sure whether this is the reason, but I just noticed this about the  in  and :I.e., while all  are inequal, the regular  (of type ) are all the same instance, while the  in the  are different instances of type ). So my guess would be that if no  function is given,  will test for identity before doing the more expensive equality check.This is also consistent with the observation that is does not group in  either, because even though those  are now  again, they are no longer the same instance.


Answer URL
https://docs.python.org/3/c-api/object.html#c.PyObject_RichCompareBool
https://docs.python.org/3/c-api/object.html#c.PyObject_RichCompareBool
