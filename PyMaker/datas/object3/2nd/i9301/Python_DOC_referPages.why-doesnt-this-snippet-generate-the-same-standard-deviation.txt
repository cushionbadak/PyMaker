Natural Text
I am trying to calculate the std in a non-vectorized and semi-vectorized way. the code for non-vectorized version works well, the semi-vectorized version works as well but the results they generate are not the same.this is the version 1 :   semi-vectorized :and this is the method for calculating mean if its needed :the output generated using pythons numpy.std() and the two method is as follows:generates : As you can see, all three generate the same result up to 8 digits. but the 3rd method has different remaining digits. What am I doing wrong here? 
There are lots of good ressources on floating point arithmetic error propagation. But one immediate problem is that  display floats to a different precision that python s. So to compare your results you should convert to an identical data structure (for example s):In your explicit case:The difference between  and  is because one uses naive summation  while the other uses . The  could be naive summation but as far as I know it uses pairwise summation. If you want even higher accuracy you could implement Kahan summation or use the python-builtin .The difference between  and your variants is harder to explain because I don't know what algorithm is used by . There is a whole article about "Algorithms for calculating variance" on wikipedia. Note that any naive implementation may suffer from under-/overflow issues especially because of the  subtraction.A general advice: If you want it fast then use , if you want it with highest precision then use . NumPy mostly focusses on the performance aspect so they might not implement the most accurate algorithm. Avoid any naive implementations without doing research on the algorithm, because they probably are neither accurate nor fast.


Answer URL
https://docs.python.org/3/library/statistics.html
