Natural Text
I created a Stack class as an exercise in Python, using all list functions. For example, Stack.push() is just list.append(), Stack.pop() is list.pop() and Stack.isEmpty() is just list == [ ].I was using my Stack class to implement a decimal to binary converter, and what I noticed is that even though the two functions are completely equivalent beyond the wrapping of my Stack class for push(), pop() and isEmpty(), the implementation using the Stack class is twice as slow as the implementation using Python's list.Is that because there's always an inherent overhead to using classes in Python? And if so, where does the overhead come from technically speaking ("under the hood")? Finally, if the overhead is so significant, isn't it better not to use classes unless you absolutely have to?
First off, a warning: Function calls are rarely what limits you in speed. This is often an unnecessary micro-optimisation. Only do that, if it is what actually limits your performance. Do some good profiling before and have a look if there might be a better way to optimise.Make sure you don't sacrifice legibility for this tiny performance tweak!Classes in Python are a little bit of a hack.The way it works is that each object has a  field (a dict) which contains all attributes the object contains. Also each object has a  object which again contains a  field (again a dict) which contains all class attributes.So for example have a look at this:If you define a function dynamically (so not in the class declaration but after the object creation) the function does not go to the  but instead to .Also there are two dicts that hold all variables accessible from the current function. There is  and  which include all global and local variables.So now let's say, you have an object  of class  with functions  and  that was declared in the class declaration and a second function , which was defined dynamically. Let's say object  is defined in global space.Also, for comparison, there are two functions , which was defined in local space and , which was defined in global space.Now I will show what happens if you call each of these functions:So as you see, class space methods take a lot more time to lookup, object space methods are slow as well. The fastest option is a local function.But you can get around that without sacrificing classes. Lets say, x.y() is called quite a lot and needs to be optimised.Similar things happen with member variables of objects. They are also slower than local variables. The effect also adds up, if you call a function or use a member variable that is in an object that is a member variable of a different object. So for examplewould be a fair bit slower as each dot needs another dictionary lookup.An official Python performance guide reccomends to avoid dots in performance critical parts of the code:https://wiki.python.org/moin/PythonSpeed/PerformanceTips
There is an inherent overhead using functions (where methods on an instance are just wrappers around functions to pass in ).A function call requires the current function information (a frame) to be stored on a stack (the Python call stack), and a new frame to be created for the function being called. That all takes time and memory:There is also a (smaller) cost of looking up the attribute (methods are attributes too), and creating the method object (each attribute lookup for a method name causes a new method object to be created):So the sum cost of attribute lookup, method object creation and call stack operations add up to the extra time requirements you observed.


Answer URL
https://docs.python.org/3/howto/descriptor.html
https://docs.python.org/3/library/dis.html
