Natural Text
I know that most of You stays for that exec shouldn't be used, but I have some problem.Here is minimal example, which works:But, when I do:Does anybody know why is that difference?
 names are class private; such names are prefixed, at compile time, with another underscore and the class name. The purpose is to protect the names from accidental clashes with names used in subclasses. These names are not meant to be private to outside callers.Quoting the Reserved classes of identifiers section:  Class-private names. Names in this category, when used within the context of a class definition, are re-written to use a mangled form to help avoid name clashes between “private” attributes of base and derived classes.and the Identifiers (Names) section:Private name mangling: When an identifier that textually occurs in a class definition begins with two or more underscore characters and does not end in two or more underscores, it is considered a private name of that class. Private names are transformed to a longer form before code is generated for them. The transformation inserts the class name, with leading underscores removed and a single underscore inserted, in front of the name. For example, the identifier  occurring in a class named  will be transformed to . This transformation is independent of the syntactical context in which the identifier is used.What happens in your case is that  postpones compilation, effectively compiling that call in isolation. The class context is gone, so no mangling takes place.As such, you need to apply the automatic prefixing manually:If you are using Python 3, you could use the  closure normally available for the  function to access the class name the current method is defined for:Now, unless you actually plan for your class to be widely subclassed in third-party code that should not have to worry about accidentally clashing with internal implementation details, you should not be using double-underscore names at all. Stick with single-underscore names instead.
Python private methods are "disguised" under a different identifier than the one specified in the code, you can access them like _classname__privateAttribute.Posting this to be specific:I put the print answer there to detect if it worked, and it did!


Answer URL
https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers
https://docs.python.org/3/reference/expressions.html#atom-identifiers
