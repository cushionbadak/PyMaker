Natural Text
I'd like to go through all n-digit numbers such that second digit of the number is always lower or equal to the first, third is lower or equal to the second etc. I can get this by writing a horrible code such as:etc., but with 10-digit numbers my code starts looking horrible, and also that's a lot of writing, and indentation get horrible if I want to commend few of those. Is there a nice, concise way of getting this?Edit: just so that people know why I'm bothering with this, https://projecteuler.net/problem=74 has me check numbers from 1 to one milion. Unfortunately, It's not as straightforward as I thought -- numbers with leading zeros are treated differently than the ones with zeros inside, so some additional magic had to be performed. Anyway, thanks to all for insightful suggestions.
Could use :Or recursively, appending more and more digits until enough, which can more directly produce  objects instead of digit tuples (not sure whether that's what you actually need):Demo (note it leaves out "", not sure whether you'd want that anyway):
this an approach using :note that the order is not the same as in your original approach.i recently had a simliar question...
A simple recursive approach:Then called via:works as expected.The mathematician's approachThe itertools package already has logic which essentially already implements this recursion. Presumably better than we can, with significant testing. So we can use it as follows:Given an ordered subset  of , we pick the number with the ith digit from the right equal to . We have to exclude the case  because that consists of he number with all zeros.
I implemented @iFlo's suggestion as commented originally. It's not hyper efficient but it certainly doesn't take ages.
I would probably implement this recursively:The output:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.combinations_with_replacement
