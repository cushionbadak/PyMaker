Natural Text
Using python3's super in a comprehension seems to always result in  (but using python 2's super does work as expected)So, why does new  fail in generator comprehensions?Addendum:
Simple explanationLook at the documentation for :The zero argument form only works inside a class definition, as the compiler fills in the necessary details to correctly retrieve the class being defined, as well as accessing the current instance for ordinary methods.By inside a class definition they meant inside class method scope. Inside class method scope interpreter is able to complete zero form with same parameters as you would explicitly provide it in Python 2. List comprehension however creates it's own scope. That's the reason why it fails: you call to  not from the class method scope and interpreter is not able to complete it with all parameters.Advanced explanationAccording to Python data model: is an implicit closure reference created by the compiler if any methods in a class body refer to either  or . This allows the zero argument form of  to correctly identify the class being defined based on lexical scoping, while the class or instance that was used to make the current call is identified based on the first argument passed to the method.Python is able to collect first parameter for  from  variable even inside list comprehension (since it is available in all child scopes as any usual closure). You can test it using:Will output:But interpreter incorrectly collects second parameter for : . It assumes that call to  happens inside method scope and tries to get first parameter for the method using following C code (many lines are omitted for clarity):It's not possible to access  from Python, but it contains "locals+stack" according to comment in code. So we can utilize  for a test (unfortunately order is missing). Let's test, what is available in locals inside class method and list comprehension:Will print:There is a reference to our object in the first case and it will be correctly found by interpreter. Inside list comprehension there is no object inside dictionary so it will get either  or  (remember, order is missing?). Neither of those is instance of our object. It will fail  and give you an error  (e.g. ).Take a look here for more information on how  is implemented and here for more details why it's done like this.


Answer URL
https://docs.python.org/3/library/functions.html#super
