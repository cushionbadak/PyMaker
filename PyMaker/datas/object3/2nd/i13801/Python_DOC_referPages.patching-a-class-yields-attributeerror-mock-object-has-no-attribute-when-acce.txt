Natural Text
The ProblemUsing  with  to patch a class is not preserving attributes of instances of that class.The DetailsI am trying to test a class  that instantiates an instance of class  as a  object attribute called . The  method under test is called ; it calls method  of the  instance belonging to . In testing this, I am mocking , as I only want to test that  is accessing the correct  member:The classes and methods work just fine ( passes), but when I try to Foo in a test case (tested using both nosetests and pytest) using , I encounter "AttributeError: Mock object has no attribute 'foo'"Indeed, when I print out , I can see that  is not in the list of children or methods:My understanding of autospec is that, if True, the patch specs should apply recursively. Since foo is indeed an attribute of Foo instances, should it not be patched? If not, how do I get the Foo mock to preserve the attributes of Foo instances?NOTE:This is a trivial example that shows the basic problem. In reality, I am mocking a third party module.Class --  -- whose client I instantiate in a Consul wrapper class that I have. As I don't maintain the consul module, I can't modify the source to suit my tests (I wouldn't really want to do that anyway). For what it's worth,  returns a consul client, which has an attribute  -- an instance of .  has a method , which I am wrapping in an instance method  in my Consul class. After patching , the call to get fails because of AttributeError: Mock object has no attribute kv.Resources Already Checked: http://mock.readthedocs.org/en/latest/helpers.html#autospeccinghttp://mock.readthedocs.org/en/latest/patch.html
No, autospeccing cannot mock out attributes set in the  method of the original class (or in any other method). It can only mock out static attributes, everything that can be found on the class.Otherwise, the mock would have to create an instance of the class you tried to replace with a mock in the first place, which is not a good idea (think classes that create a lot of real resources when instantiated).The recursive nature of an auto-specced mock is then limited to those static attributes; if  is a class attribute, accessing  will return an auto-specced mock for that attribute. If you have a class  whose  attribute is an object of type , then the mock of  will be an auto-specced mock of the  class.The documentation you read explicitly covers this:A more serious problem is that it is common for instance attributes to be created in the  method and not to exist on the class at all.  canâ€™t know about any dynamically created attributes and restricts the api to visible attributes.You should just set the missing attributes yourself:or create a subclass of your  class for testing purposes that adds the attribute as a class attribute:


Answer URL
https://docs.python.org/3/library/unittest.mock.html#autospeccing
