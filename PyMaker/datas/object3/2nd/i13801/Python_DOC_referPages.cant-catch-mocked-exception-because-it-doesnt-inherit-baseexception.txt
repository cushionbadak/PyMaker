Natural Text
I'm working on a project that involves connecting to a remote server, waiting for a response, and then performing actions based on that response.  We catch a couple of different exceptions, and behave differently depending on which exception is caught.  For example:To test this, we've written a test like the followingIf I run the function directly, everything happens as expected.  I even tested by adding  to the  clause of the function.  But when I run my unit tests, I get I tried to change the exception I was patching in to  and I got a more or less identical error.I've read https://stackoverflow.com/a/18163759/3076272 already, so I think it must be a bad  hook somewhere, but I'm not sure where to look for it or what I can even do in the mean time.  I'm also relatively new to  so it's very possible that I'm doing something wrong there as well.This is a Fusion360 add-in so it is using Fusion 360's packaged version of Python 3.3 - as far as I know it's a vanilla version (i.e. they don't roll their own) but I'm not positive of that.
I could reproduce the error with a minimal example:foo.py:Test without mocking :Ok, all is fine, both test passThe problem comes with the mocks. As soon as the class MyError is mocked, the  clause cannot catch anything and I get same error as the example from the question :Immediately gives :Here I get a first that you did not have, because I am raising a mock while you forced a true exception with  in config. But the problem remains that the  clause tries to catch a mock.TL/DR: as you mock the full  package, the  clause tries to catch a mock. As the mock is not really a , it causes the error.The only solution I can imagine is not to mock the full  but only the parts that are not exceptions. I must admit I could not find how to say to mock mock everything except this but in your example, you only need to patch . So I think that this should work :That is : only patch the  method with the exception as side effect.
I just ran into the same issue while trying to mock  (and found this post while looking for solutions).What Serge said is correct:  TL/DR: as you mock the full requests package, the except requests.exceptions.ConnectionError clause tries to catch a mock. As the mock is not really a BaseException, it causes the error. The only solution I can imagine is not to mock the full requests but only the parts that are not exceptions. I must admit I could not find how to say to mock mock everything except this My solution was to mock the entire module, then set the mock attribute for the exception to be equal to the exception in the real class, effectively "un-mocking" the exception.  For example, in my case:For , you could assign exceptions individually like this:or do it for all of the  exceptions like this:I don't know if this is the "right" way to do it, but so far it seems to work for me without any issue.
For those of us who need to mock an exception and can't do that by simply patching , here is an easy solution that replaces the target exception with an empty one:Say we have a generic unit to test with an exception we have to have mocked:We want to mock  but because it is an exception we run into trouble if we try to patch it like everything else. Normally, a call to  replaces the target with a  but that won't work here. Mocks are nifty, but they do not behave like exceptions do. Rather than patching with a mock, let's give it a stub exception instead. We'll do that in our test file.So what's with the ? The  param calls whatever we give it and replaces the target with the return of that call. If we pass our  class straight, it will call the class's constructor and patch our target object with an exception instance rather than a class which isn't what we want. By wrapping it with , it returns our class as we intend.Once our patching is done, the  object (which is literally our  class) can be raised and caught as if it were the . Neat!
I faced a similar issue while trying to mock the sh package. While sh is very useful, the fact that all methods and exceptions are defined dynamically make it more difficult to mock them. So following the recommendation of the documentation:
I just ran into the same problem when mocking .I get the error:TypeError: catching classes that do not inherit from BaseException is not allowedWhen trying to catch a  raised from .I found that the simplest way to get around this in my tests was to simply set the value of the error attribute in my mock to be . For exampleThe method I want to test has this basic pattern:The test has this basic pattern.This is similar to the approach taken by @BillB, but it is certainly simpler as I don't need to add imports to my tests and still get the same behavior. To me it would seem this is the logical conclusion to the general thread of reasoning in the answers here.


Answer URL
https://docs.python.org/3/library/unittest.mock.html#autospeccing
https://docs.python.org/3/library/struct.html
