Natural Text
I've been trying to round long float numbers like:With no success so far. I tried ,  (although that would round up or down, which is not what I'm looking for) and  which didn't work either (still float numbers).What could I do?EDIT: CODE:
Will round it and change it to integerEDIT:You are not assigning int(round(h)) to any variable. When you call int(round(h)), it returns the integer number but does nothing else; you have to change that line for:To assign the new value to h
Use . It will round up your number up to your desired decimal place.For example:
 is the ordinary solution, however this does not operate as one would expect from a math perspective when round values ending in .  If the  is in the digit just after the one you're rounded to, these values are only sometimes rounded up as expected (i.e.  rounding to two decimal digits gives ).  For certain values due to the quirks of floating point math, they are rounded down instead!i.e.Weird.Assuming your intent is to do the traditional rounding for statistics in the sciences, this is a handy wrapper to get the  function working as expected needing to  extra stuff like .Aha! So based on this we can make a function...Basically this adds a value guaranteed to be smaller than the least given digit of the string you're trying to use  on. By adding that small quantity it preserve's 's behavior in most cases, while now ensuring if the digit inferior to the one being rounded to is  it rounds up, and if it is  it rounds down.The approach of using  was deliberate, as it the largest small number you can add to force the shift, while also ensuring that the value you add never changes the rounding even if the decimal  is missing.  I could use just  with a condiditional  to subtract  more... but it's simpler to just always subtract the  as that won't change much the applicable range of decimal numbers this workaround can properly handle.  This approach will fail if your values reaches the limits of the type, this will fail, but for nearly the entire range of valid decimal values it should work.You can also use the decimal library to accomplish this, but the wrapper I propose is simpler and may be preferred in some cases.Edit: Thanks Blckknght for pointing out that the  fringe case occurs only for certain values.  Also an earlier version of this answer wasn't explicit enough that the odd rounding behavior occurs only when the digit immediately inferior to the digit you're rounding to has a .
For positives, tryTo make it work for negatives too, try works like a floor function and hence you can exploit this property. This is definitely the fastest way.
Isn't just Python doing round half to even, as prescribed by IEEE 754?Be careful redefining, or using "non-standard" roundingâ€¦(See also https://stackoverflow.com/a/33019948/109839)
You can also use numpy assuming if you are using python3.x here is an example
If you need (for example) a two digit approximation for A, then  will do what you are looking for.If you need three digit approximation multiply and divide by 1000 and so on.
For this purpose I would suggest just do the following thing - This will give you nearest integer.Hope this helps!!


Answer URL
https://docs.python.org/3/library/decimal.html
