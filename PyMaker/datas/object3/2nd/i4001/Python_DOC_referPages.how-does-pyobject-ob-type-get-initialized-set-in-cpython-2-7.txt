Natural Text
I am investigating how isinstance() func works for CPython 2.7Now I have an example with two Python files: lib1.py lib2.pyThe results print: TrueThen I dig into CPython source code tohttps://github.com/python/cpython/blob/ad65d09fd02512b2ccf500f6c11063f705c9cd28/Objects/abstract.c#L2945where CPython did this check:where Py_TYPE() is macroDoes anyone know the clues how CPython inits or sets the ob_type during the program starting?
Normally, this happens in  (or , which I won't mention again, but there are equivalent variations across the board), or the  macro (which does the same thing in a faster way, but one that isn't guaranteed to be binary-compatible with other interpreter builds on the same platform). The docs for  say:Initialize a newly-allocated object op with its type and initial reference. Returns the initialized object. If type indicates that the object participates in the cyclic garbage detector, it is added to the detector’s set of observed objects. Other fields of the object are not affected.You can see the source in :For more details, see the comments in .When an object is constructed from Python (or via the high-level C API):The type's  method or  slot gets called.This usually inherits from or s to , which calls .… or it delegates to some other constructor (which ultimately gets you back here)… or returns some already existing object… but if not, it must call  manually. calls the type's  slot (there's no Python special method for this).This usually inherits from or s to , which calls the  macro.… but if not,  must call one of the -family functions or macros, or do the same thing itself.Code in C extension modules, and internal interpreter code may:Use the same high-level API… or call , which allocates the object and calls  on it, and casts the result pointer… or just call  directly (when it knows the type it's constructing doesn't customize , , or )… or construct objects manually, but at some point it must call one of the  family directly or indirectly, or do the same thing itself, just as with custom … or allocate constant objects statically rather than on the heap, like  and many builtin and extension type objects, in which case the type (which also has to be a static constant, of course) is just specified in the struct initializer.


Answer URL
https://docs.python.org/3/c-api/allocation.html#c.PyObject_Init
https://docs.python.org/3/reference/datamodel.html#object.__new__
https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_new
https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_alloc
