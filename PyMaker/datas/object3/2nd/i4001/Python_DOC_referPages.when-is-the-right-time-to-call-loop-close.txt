Natural Text
I have been experimenting with  for a little while and read the PEPs; a few tutorials; and even the O'Reilly book.I think I got the hang of it, but I'm still puzzled by the behavior of  which I can't quite figure out when it is "safe" to invoke.Distilled to its simplest, my use case is a bunch of blocking "old school" calls, which I wrap in the  and an outer coroutine; if any of those calls goes wrong, I want to stop progress, cancel the ones still outstanding, print a sensible log and then (hopefully, cleanly) get out of the way.Say, something like this:I tried several variants of the  and  calls, the "run_forever first, then stop" seems to be the one to use according to the pydoc and, without the call to  yields a satisfying:However, when the call to  is added (as shown above) I get two exceptions:which is at best annoying, but to me, totally puzzling: and, to make matter worse, I've been unable to figure out what would The Right Way of handling such a situation.Thus, two questions:what am I missing? how should I modify the code above in a way that with the call to  included does not raise?what actually happens if I don't call  - in this trivial case, I presume it's largely redundant; but what might the consequences be in a "real" production code?For my own personal satisfaction, also:why does it raise at all? what more does the loop want from the coros/tasks: they either exited; raised; or were canceled: isn't this enough to keep it happy?Many thanks in advance for any suggestions you may have!
Distilled to its simplest, my use case is a bunch of blocking "old school" calls, which I wrap in the  and an outer coroutine; if any of those calls goes wrong, I want to stop progress, cancel the ones still outstandingThis can't work as envisioned because  submits the function to a thread pool, and OS threads can't be cancelled in Python (or in other languages that expose them). Canceling the future returned by  will attempt to cancel the underlying , but that will only have effect if the blocking function is not yet running, e.g. because the thread pool is busy. Once it starts to execute, it cannot be safely cancelled. Support for safe and reliable cancellation is one of the benefits of using  compared to threads.If you are dealing with synchronous code, be it a legacy blocking call or longer-running CPU-bound code, you should run it with  and incorporate a way to interrupt it. For example, the code could occasionally check a  flag and exit if that is true, perhaps by raising an exception. Then you can "cancel" those tasks by setting the appropriate flag or flags.how should I modify the code above in a way that with the call to close() included does not raise?As far as I can tell, there is currently no way to do so without modifications to  and the top-level code.  will insist on informing the event loop of the result, and this fails when the event loop is closed. It doesn't help that the asyncio future is cancelled, because the cancellation check is performed in the event loop thread, and the error occurs before that, when  is called by the worker thread. (It might be possible to move the check to the worker thread, but it should be carefully analyzed whether it leads a race condition between the call to  and the actual check.)why does it raise at all? what more does the loop want from the coros/tasks: they either exited; raised; or were canceled: isn't this enough to keep it happy?It wants the blocking functions passed to  (literally called  in the question) that have already been started to finish running before the event loop is closed. You cancelled the asyncio future, but the underlying concurrent future still wants to "phone home", finding the loop closed.It is not obvious whether this is a bug in asyncio, or if you are simply not supposed to close an event loop until you somehow ensure that all work submitted to  is done. Doing so requires the following changes:Don't attempt to cancel the pending futures. Canceling them looks correct superficially, but it prevents you from being able to  for those futures, as asyncio will consider them complete.Instead, send an application-specific event to your background tasks informing them that they need to abort.Call  before .With these modifications (except for the application-specific event - I simply let the s finish their course), the exception did not appear.what actually happens if I don't call  - in this trivial case, I presume it's largely redundant; but what might the consequences be in a "real" production code?Since a typical event loop runs as long as the application, there should be no issue in not call  at the very end of the program. The operating system will clean up the resources on program exit anyway.Calling  is important for event loops that have a clear lifetime. For example, a library might create a fresh event loop for a specific task, run it in a dedicated thread, and dispose of it. Failing to close such a loop could leak its internal resources (such as the pipe it uses for inter-thread wakeup) and cause the program to fail. Another example are test suites, which often start a new event loop for each unit test to ensure separation of test environments.EDIT: I filed a bug for this issue.EDIT 2: The bug was fixed by devs.
Until the upstream issue is fixed, another way to work around the problem is by replacing the use of  with a custom version without the flaw. While rolling one's own  sounds like a bad idea at first, it is in fact only a small glue between a  and an  future.A simple version of  can be cleanly implemented using the public API of those two classes:When  is replaced with ,  being a  created in , the code works without other modifications.Of course, in this variant the synchronous functions will continue running in the other thread to completion despite being canceled -- but that is unavoidable without modifying them to support explicit interruption.


Answer URL
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.run_forever
https://docs.python.org/3/library/concurrent.futures.html#future-objects
https://docs.python.org/3/library/concurrent.futures.html#future-objects
https://docs.python.org/3/library/asyncio-task.html#future
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor
