Natural Text
I'm trying to understand metaclass black magic in Python. AFAIK, metaclasses can be used, for example, to ensure that some method is implemented in derived class, but I have a problem grandchildrens. It seems that I need to explicitly implement all required derived methods even if there is no reason(?) to do that.Look at this:As far I understand this should not happen, because  should be derived from  class like here:This is expected? If yes, could you give me some hint how to fix this behaviour, so I wouldn't need to reimplement methods?
You seem to be trying to reinvent the wheel that is the  module and its  decorator. I'm not sure why you want to do that, but if you do, you should look at its source (which is linked from the docs).Your solution checks that the required name is implemented in the body of the class. That won't be true for inherited methods, but you seem to know that, so I won't explain. What you want to know is: what can you do instead? You need to check for inherited methods explicitly.The way  does it is pretty simple: before checking whether all abstract methods are implemented, it calls  on each . (The best way to simulate what  will do on the class is to call , after all.) Anything that's found there doesn't need to appear in the body.Your use case—with a static single required method instead of a dynamic set of methods that have to be harvested from the output of a decorator—is even simpler:
 contains what is defined in the class you're defining. In your case,  isn't defined in , it doesn't exist in it.When you use  (or even ), it will perform a lookup. It will not find it in Derived, but then it will try the parent classes, aka the bases, using the MRO (Method Resolution Order).See the params in , the bases are separate from  which is what you defined in your class, before MRO kicks in.
Inheritance isn't something that injects a definition into a class. Rather, it allows the lookup for an attribute to proceed beyond the immediate class if it is not defined locally.In the absence of your metaclass, a call to  proceeds roughly as follows:An instance of  is created.An attribute named  is looked for that instance's  attribute, and is not found. is looked for in  and not found. is searched for in the  attributes of the classes in 's based classes, starting with . is found, and its value is called  with the instance of  as its implicit first argument.With your metaclass,  is created with the same metaclass used by its base class, meaning  (not ) is used to create  . Since  is not in the body of the class statement, it does not appear in the  object passed to , resulting in the  being raised. (Note that you should be raising , not , as you aren't attempting to access any particular attribute yet.)


Answer URL
https://docs.python.org/3/library/abc.html
https://docs.python.org/3/library/abc.html
