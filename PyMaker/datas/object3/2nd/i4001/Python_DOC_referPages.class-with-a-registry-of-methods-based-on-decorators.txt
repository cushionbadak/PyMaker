Natural Text
I have a class that has several methods which each have certain properties (in the sense of quality). I'd like these methods to be available in a list inside the class so they can be executed at once. Note that the properties can be interchangeable so this can't be solved by using further classes that would inherit from the original one. In an ideal world it would look something like this:When the class is instantiated, it should be easy to simply execute all red and soft rules by combining the sets and executing the methods. The decorators for this are tricky though since a regular registering decorator can fill out a global object but not the class attribute:How do I go about implementing something like this?
You can subclass  and give it a decorator method:Or if you find using the  method ugly, you can always define the  method to use the set itself as a decorator:This looks better, but it's less explicit, so for other collaborators (or future yourself) it might be harder to grasp what's happening here.To call the stored functions, you can just loop over the set you want and pass in the instance as the  argument:You can also create an utility function to do this for you, for example you can create a  method:And now just call:Or you could have  handle this instead:And then call this on an instance of :
Decorators are applied when the function is defined; in a class that's when the class is defined. At this point in time there are no instances yet!You have three options:Register your decorators at the class level. This is not as clean as it may sound; you either have to explicitly pass additional objects to your decorators (, then  so the decorator factory can then add the function to the right location), or you have to use some kind of class initialiser to pick up specially marked functions; you could do this with a base class that defines the  class method, at which point you can iterate over the namespace and find those markers (attributes set by the decorators).Have your  method (or a  method) loop over all the methods on the class and look for special attributes the decorators have put there. The decorator would only need to add a  or similar attribute to decorated methods, and  would pick up any method that has the right rule name defined in .Make your decorators produce new descriptor objects; descriptors have their  method called when the class object is created. This gives you access to the class, and thus you can add attributes to that class.Note that  and  require Python 3.6 or newer; you'd have to resort to a metaclass to achieve similar functionality in earlier versions.Also note that when you register functions at the class level, that you need to then explicitly bind them with  to turn them into methods, or you can explicitly pass in  when calling them. You could automate this by making a dedicated class to hold the rule sets, and make this class a descriptor too:Then just use:and you can access , etc. as a set with bound methods:The same rules are accessible on the class; normal functions remain unbound:Containment testing works as expected:You can use these rules to register  and  objects too:


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__init_subclass__
https://docs.python.org/3/reference/datamodel.html#descriptors
https://docs.python.org/3/reference/datamodel.html#object.__set_name__
https://docs.python.org/3/reference/datamodel.html#metaclasses
