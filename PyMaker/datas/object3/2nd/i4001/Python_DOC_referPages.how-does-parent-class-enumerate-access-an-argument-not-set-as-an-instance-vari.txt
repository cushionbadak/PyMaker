Natural Text
I stumbled upon a question yesterday that involved enumerating over an iterable type and yeilding descending indices accompanied by ascending items in the iterable.  In:Out:Instead of writing a quick and reliable answer applying built-in  twice, or simply , I decided to try create a child class of  that redefines  and  methods.The code for my original working solution was as follows:However, I now realize this code has redundancy as  appears to yield the result of , makes sense.  After deleting the redefined  I realized that  was not being used anywhere, so I removed the last four lines from  leaving me with the following code, which still provides the desired behavior.Now it appears that the iterable argument passed into  is not for anything except determining the integer .My question is - where is  stored and how does  access it? A quick look at  with the PyCharm debugger does not provide a lot of help in figuring this out (or so it seems to me at this stage), and I am not well traversed with the Python source code repository.  My guess is something to do with the  or  method of parent class , or it's parent .  
 is a lie. PyCharm made it up. If you want to look at the real source code for the  module, that's  in the Python Git repository.  itself is implemented in . iterators store an iterator over their underlying object in a C-level  struct slot:set in :The fact that it's set in  is why it still worked even though you forgot to call .Subclassing  for this doesn't make a lot of sense.  is only documented as a callable; the fact that it's a class and supports subclassing is an implementation detail. Also, you're not getting a lot of use out of , and the relationship between your iterators and  iterators doesn't really sound like "is-a". Implementing your functionality as a generator, like zvone did, is cleaner and clearer.
What  does is more-or-less* this:One thing you can notice is that it does not know how long the iterable is. It can even be infinitely long, but enumerate will still work.The problem with  is that you first have to count how many items there are before being able to yield the first one, so you actually have to create a list of all enumerated items and then yield them backwards (at least if you want your  to work with any iterable, like ).Once you accept that limitation as inavoidable, the rest is simple:(*)  is actually a class, but this is its behaviour. See my other answer about how that works and what  does.
Others have answered your specific question about how your code works so here's another way to implement a reverse enumerator using : returns a  object that is very similar to the  object returned by .By default the items will be enumerated starting at the length of the iterable less one, which requires that the length be finite. You can supply a start value from which to count down which would be useful if you just wanted to start counting from an arbitrary value, or to sort of handle infinite iterables.If you tried to work on an infinite iterable without specifying the start value:Which prevents the interpreter entering an infinite loop. You could handle the exception and raise one of your own if that suited your application.
In my previous answer I wrote how I would do it, but here are some answers to what was actually asked about  and ...IterableIn order for an object to be iterable, it has to implement method , which has to return an iterator.Here are some simple examples:These can be iterated:IteratorThe object returned from  is an iterator. An iterator must implement the  method.For example:Custom iteratorEDIT: As others mentioned in the comments, an iterator should always implement  which returns  (as I did in the examples below). This requirement can be read in PEP-0234 and in Python docs:A class that wants to be an iterator should implement two methods: a   method that behaves as described above, and an   method that returns .Iterable iteratorAn iterable iterator? Well if a class implements both  and , then it is both: actually does something like this:So, to answer your question, in your , you are calling this  here, which uses the iterator which it stored in the constructor.


Answer URL
https://docs.python.org/3/library/stdtypes.html#iterator-types
https://docs.python.org/3/library/stdtypes.html#iterator.__iter__
