Natural Text
Suppose I have a list:And its suffix list:I'd like the desired output to be:The result is the interleaved version of the two lists above.I can write regular  loop to get this done, but I'm wondering if there's a more Pythonic way (e.g., using list comprehension or lambda) to get it done.I've tried something like this:Furthermore, what changes would need to be made for the general case i.e., for 2 or more lists where  is not necessarily a derivative of ?
You can use a generator for an elegant solution. At each iteration, yield twice—once with the original element, and once with the element with the added suffix.The generator will need to be exhausted; that can be done by tacking on a  call at the end.You can also re-write this using the  syntax for generator delegation:If you're on versions older than python-3.6, replace  with .GeneralisingConsider a general scenario where you have N lists of the form:Which you would like to interleave. These lists are not necessarily derived from each other.To handle interleaving operations with these N lists, you'll need to iterate over pairs:Sliced I'd recommend this from the perspective of performance. First allocate space for an empty list, and then assign list items to their appropriate positions using sliced list assignment.  goes into even indexes, and  ( modified) goes into odd indexes. This is consistently the fastest from my timings (below).GeneralisingTo handle N lists, iteratively assign to slices.  + A functional approach, similar to @chrisz' solution. Construct pairs using  and then flatten it using . is widely regarded as the pythonic list flattening approach.GeneralisingThis is the simplest solution to generalise, and I suspect the most efficient for multiple lists when N is large.PerformanceLet's take a look at some perf-tests for the simple case of two lists (one list with its suffix). General cases will not be tested since the results widely vary with by data.FunctionsSoftwareSystem—Mac OS X High Sierra—2.4 GHz Intel Core i7Python—3.6.0IPython—6.2.1    
You can use a list comprehension like so:Output:Optional, shorter method:
You could use :Output:
Here's my simple implementation
If you wanted to return  you could write This isn't what you want, instead you want . This can be made from the result of the operation above using ; since you're summing lists you need to add the empty list as an argument to avoid an error. So that givesI don't know how this compares speed-wise (probably not well), but I find it easier to understand what's going on than the other list-comprehension based answers.
A very simple solution:


Answer URL
https://docs.python.org/3/reference/expressions.html#yield-expressions
https://docs.python.org/3/library/functions.html#zip
https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable
https://docs.python.org/3/library/functions.html#zip
https://docs.python.org/3/reference/lexical_analysis.html#formatted-string-literals
