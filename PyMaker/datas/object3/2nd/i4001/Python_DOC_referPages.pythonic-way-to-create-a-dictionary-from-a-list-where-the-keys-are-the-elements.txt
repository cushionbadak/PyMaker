Natural Text
Considering that I have two lists like:and I need to create a dictionary where the keys are those element from second list that are found in the first and values are lists of elements found between "keys" like:What's a more pythonic way to do this?Currently I'm doing this :But I'm quite positive that this is not the best way to do it and it also doesn't looks nice :) Edit:I also have to mention that no list is necessary ordered and neither the second list must start with an element from the first one.
I don't think you'll do much better if this is the most specific statement of the problem. I mean I'd do it this way, but it's not much better.
For fun, you can also do this with  and 3rd party :
Here is a version using . It may or may not be more efficient than the plain version from your post, depending on how  is implemented, because the  loop has fewer iterations.This doesn't distinguish between keys that don't occur in  at all (like  and ), and keys for which there are no corresponding values (like ). If this information is needed, one of the other solutions might be better suited.
Updated ... AgainI misinterpreted the question. If you are using large lists then list comprehensions are the way to go and they are fairly simple once you learn how to use them.I am going to use two list comprehensions.Results:Speed Testing for large lists:Results:old stuff belowThis is rather simple with list comprehensions.Results:The code below shows what is happening above.The list comprehension / dictionary comprehension (First piece of code) is actually way faster. List comprehensions are creating the list in place which is much faster than walking through and appending to the list. Appending makes the program walk the list, allocate more memory, and add the data to the list which can be very slow for large lists.References:http://www.pythonforbeginners.com/basics/list-comprehensions-in-pythonhttps://docs.python.org/3.6/tutorial/datastructures.html#list-comprehensions
You can use :Output:
Your code is readable, does the job and is reasonably efficient. There's no need to change much!You could use more descriptive variable names and replace  with a set for faster lookup:
Comparison of methods, using justengel's test:justengel     run_comp:     .455     run_other:    .244mkrieger1    group_by_keys: .160me    find_index:    .068Note that my method ignores keys that don't appear , and doesn't handle cases where keys appear more than once in . Adding in empty lists for keys that don't appear in  can be done by , which raises the time to .105.
Even cleaner than turning  into a , use the keys of the dictionary you're building. Like thisThis is because (in the worst case) your code would be iterating over all the values in  for every value in  on the  line, because checking if a value is  a list takes linear time. Checking if a value is  a dictionary's keys is constant time in the average case (same with s, as already suggested by Eric Duminil).I set  to  and check for it because your code would've returned  with , which is presumably not what you want. This assumes  can't contain .My solution also assumes it's okay for the resulting dictionary to contain keys with empty lists if there are items in  that never appear in . If that's not okay, you can remove them at the end with


Answer URL
https://docs.python.org/3/tutorial/datastructures.html#sets
