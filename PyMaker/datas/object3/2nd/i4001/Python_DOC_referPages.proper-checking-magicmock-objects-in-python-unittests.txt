Natural Text
I have this code under test:In my unittest I want to assert that exactly this is done with the passed  and the result returned, so I pass a  object as :Then I check the result for being what I expect:After importing  I need to patch the internal structure of the  module in order to be able to properly magic-mock the  function (see https://stackoverflow.com/a/50329607/1281485 for details on that):So, now, as I said, this works.  But I find it extremely unreadable.  Furthermore I needed to play around a lot to find the things like  etc.  The underscore also indicates that this is a "private" attribute and shouldn't be used.  The documentation doesn't mention it.  It also does not mention another way of achieving what I try to.Is there a nicer way to test returned  objects for being created the way they should have been?
You are going overboard. You are testing the implementation, not the result. Moreover, you are reaching into internals of the mock implementation that you do not need to touch.Test that you get the right result, and test that the result is based on the inputs you want to be used. You can set up the mock such that  is passed an actual numeric value to round: results in a call to , passing in . is called, so we can test that it was called if that's needed.Just set the result of  to a number for  to round off. Getting the correct  result from the function means  was called.Passing in a number to  is sufficient here, because you are not testing the  function. You can rely on the Python maintainers to test that function, focus on testing your own code.This is what I'd test:If you must assert that  took place, then you can addbut the  call assert passing is already proof that at least a  expression took place and that  was accessed on the result.If you must validate that  was used on an actual mock instance, you'll have to stick to patching the  class to include  as a special method and remove the  assignment, after which you can assert that the return value is the correct object withSome further notes:There is no point in trying to make everything a mock object. If the code under test is supposed to work on standard Python types, just have your mocks produce those types. E.g. if some call is expected to produce a string, have your mock return a test string, especially when you are then passing stuff to other standard-library APIs.Mocks are singletons. You do not need to work back from a given mock to test that they have the right parent, because you can reach the same object by traversing the parent attributes and then use . E.g. if a function returns the a mock object somewhere, you can assert that the right mock object was returned by testing .When a mock is called, that fact is recorded. You can assert this with the  methods, the  and  attributes, and traverse the result of calls with the  attributesWhen in doubt, inspect the  attribute to see what the code-under-test has accessed. Or do so in an interactive session. For example, it's easier to see what  does in a quick test with:


Answer URL
https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types
