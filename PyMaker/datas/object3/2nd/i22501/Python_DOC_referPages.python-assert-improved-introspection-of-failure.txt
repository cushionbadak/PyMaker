Natural Text
This is a rather useless assertion error; it does not tell the values of the expression involved (assume constants used are actually variable names): Is there a better  implementation in Python that is more fancy? It must not introduce additional overhead over execution (except when assert fails) .. and must turn off if  flag is used.Edit: I know about assert's second argument as a string. I don't want to write one .. as that is encoded in the expression that is being asserted. DRY (Don't Repeat Yourself).
Install your of function as  -- see the docs. Your function, if the second argument is , can introspect to your heart's contents; in particular, through the third argument, the traceback, it can get the frame and exact spot in which the assert failed, getting the failing exception through the source or bytecode, the value of all relevant variables, etc. Module inspect helps.Doing it in full generality is quite a piece of work, but depending on what constraints you're willing to accept in how you write your s it can be lightened substantially (e.g. restricting them to only local or global variables makes introspection easier than if nonlocal variables of a closure could be involved, and so forth).
As @Mark Rushakoff said  can evaluate failed asserts. It works on the standard  too.' help:Example:
You can attach a message to an :The message can also be built dynamically:See The  statement in the Python documentation for more information.
The nose testing suite applies introspection to asserts. However, AFAICT, you have to call their asserts to get the introspection:results inNotice the AssertionError there. When my line was just , I would get:Also, I'm not sure offhand if their asserts are skipped with , but that would be a very quick check.
Add a message to your assertion, which will be displayed if the assertion fails:The only way I can think of to provide this automatically would be to contain the assertion in a procedure call, and then inspect the stack to get the source code for that line. The additional call would, unfortunately, introduce overhead into the test and would not be disabled with .
It sounds like what you really want to do is to set up a debugger breakpoint just before the  and inspect from your favorite debugger as much as you like.
I coded a replacement for  (which is called for any unhandled exception) which is a bit more fancy than the standard one. It will analyze the line where the exception occured and print all variables which are referred to in this line (it does not print all local variables because that might be too much noise - also, maybe the important var is global or so).I called it py_better_exchook (perfect name) and it's here.Example file:Output:There are a few other alternatives:(Presented here) https://github.com/albertz/py_better_exchook/https://github.com/patrys/great-justiceNose does something similar for assertion failures, see here.IPython has something similar (this). Do this: .Ka-Ping Yee's "cgitb.py", which is part of Python, see here, code here.


Answer URL
https://docs.python.org/3/library/cgitb.html
