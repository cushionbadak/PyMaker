Natural Text
I have a class , which contains two member variables  and :I have two instances of this class, each of which has identical values for  and :However, when I compare them for equality, Python returns :How can I make python consider these two objects equal?
You should implement the method :Now it outputs:Note that implementing  will automatically make instances of your class unhashable, which means they can't be stored in sets and dicts. If you're not modelling an immutable type (i.e. if the attributes  and  may change value within the lifetime of your object), then it's recommend to just leave your instances as unhashable.If you are modelling an immutable type, you should also implement the datamodel hook :A general solution, like the idea of looping through  and comparing values, is not advisable - it can never be truly general because the  may have uncomparable or unhashable types contained within.N.B.: be aware that before Python 3, you may need to use  instead of .  Python 2 users may also want to implement , since a sensible default behaviour for inequality (i.e. inverting the equality result) will not be automatically created in Python 2.
You override the rich comparison operators in your object.Like this:
Implement the  method in your class; something like this:Edit: if you want your objects to compare equal if and only if they have equal instance dictionaries:
As a summary : It's advised to implement  rather than , except if you run python <= 2.0 ( has been added in 2.1)Don't forget to also implement  (should be something like  or  except very special case)Don`t forget that the operator must be implemented in each custom class you want to compare (see example below).If you want to compare with object that can be None, you must implement it. The interpreter cannot guess it ... (see example below)
When comparing instances of objects, the  function is called.If the == operator is not working for you by default, you can always redefine the  function for the object.Edit:As has been pointed out, the  function is deprecated since 3.0.Instead you should use the “rich comparison” methods.
If you want to get an attribute-by-attribute comparison, and see if and where it fails, you can use the following list comprehension:The extra advantage here is that you can squeeze it one line and enter in the "Evaluate Expression" window when debugging in PyCharm.
I tried the initial example (see 7 above) and it did not work in ipython. Note that cmp(obj1,obj2) returns a "1" when implemented using two identical object instances. Oddly enough when I modify one of the attribute values and recompare, using  cmp(obj1,obj2) the object continues to return a "1".  (sigh...)Ok, so what you need to do is iterate two objects and compare each attribute using the == sign.
Instance of a class when compared with == comes to non-equal. The best way is to ass the cmp function to your class which will do the stuff. If you want to do comparison by the content you can simply use cmp(obj1,obj2)In your case cmp(doc1,doc2) It will return -1 if the content wise they are same.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__eq__
https://docs.python.org/3/reference/datamodel.html#object.__hash__
https://docs.python.org/3/library/functools.html#functools.total_ordering
