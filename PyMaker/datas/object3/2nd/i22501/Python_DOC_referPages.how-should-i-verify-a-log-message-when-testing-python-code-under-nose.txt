Natural Text
I'm trying to write a simple unit test that will verify that, under a certain condition, a class in my application will log an error via the standard logging API.  I can't work out what the cleanest way to test this situation is.I know that nose already captures logging output through it's logging plugin, but this seems to be intended as a reporting and debugging aid for failed tests.  The two ways to do this I can see are:Mock out the logging module, either in a piecemeal way (mymodule.logging = mockloggingmodule) or with a proper mocking library.Write or use an existing nose plugin to capture the output and verify it.If I go for the former approach, I'd like to know what the cleanest way to reset the global state to what it was before I mocked out the logging module.Looking forward to your hints and tips on this one...
I used to mock loggers, but in this situation I found best to use logging handlers, so I wrote this one based on the document suggested by jkp:
From python 3.4 on, the standard unittest library offers a new test assertion context manager, . From the docs:
Fortunately this is not something that you have to write yourself; the  package provides a context manager that captures all logging output that occurs in the body of the  statement. You can find the package here:http://pypi.python.org/pypi/testfixturesAnd here are its docs about how to test logging:http://testfixtures.readthedocs.org/en/latest/logging.html
UPDATE: No longer any need for the answer below. Use the built-in Python way instead!This answer extends the work done in https://stackoverflow.com/a/1049375/1286628. The handler is largely the same (the constructor is more idiomatic, using ). Further, I add a demonstration of how to use the handler with the standard library's .Then you can use the handler in a standard-library  like so:
Brandon's answer:snippet:Note: the above does not conflict with calling nosetests and getting the output of logCapture plugin of the tool
As a follow up to Reef's answer, I took a liberty of coding up an example using pymox.It introduces some extra helper functions that make it easier to stub functions and methods.
You should use mocking, as someday You might want to change Your logger to a, say, database one. You won't be happy if it'll try to connect to the database during nosetests.Mocking will continue to work even if standard output will be suppressed.I have used pyMox's stubs. Remember to unset the stubs after the test.
Found one answer since I posted this.  Not bad.
The  class implemented in tornado is a great utility:http://tornado.readthedocs.org/en/latest/_modules/tornado/testing.html#ExpectLog
Keying off @Reef's answer, I did tried the code below. It works well for me both for Python 2.7 (if you install mock) and for Python 3.4.


Answer URL
https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertLogs
https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertLogs
https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertLogs
