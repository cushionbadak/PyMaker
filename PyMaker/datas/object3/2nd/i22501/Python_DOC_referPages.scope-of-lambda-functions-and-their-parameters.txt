Natural Text
I need a callback function that is almost exactly the same for a series of gui events. The function will behave slightly differently depending on which event has called it. Seems like a simple case to me, but I cannot figure out this weird behavior of lambda functions.So I have the following simplified code below:The output of this code is:I expected:Why has using an iterator messed things up?I've tried using a deepcopy:But this has the same problem.
The problem here is the  variable (a reference) being taken from the surrounding scope.Only parameters are held in the lambda scope.To solve this you have to create another scope for lambda:In the example above, lambda also uses the surounding scope to find , but thistime it's  scope which is created once per every call.Or with functools.partial:
When a lambda is created, it doesn't make a copy of the variables in the enclosing scope that it uses. It maintains a reference to the environment so that it can look up the value of the variable later. There is just one . It gets assigned to every time through the loop. After the loop, the variable  has value . So when you actually run the function you created later, it will look up the value of  in the environment that created it, which will by then have value .One common and idiomatic solution to this problem is to capture the value of  at the time that the lambda is created by using it as the default argument of an optional parameter. You usually use a parameter of the same name so you don't have to change the body of the code:
Python does uses references of course, but it does not matter in this context.When you define a lambda (or a function, since this is the exact same behavior), it does not evaluate the lambda expression before runtime:Even more surprising than your lambda example:In short, think dynamic: nothing is evaluated before interpretation, that's why your code uses the latest value of m.When it looks for m in the lambda execution, m is taken from the topmost scope, which means that, as others pointed out; you can circumvent that problem by adding another scope:Here, when the lambda is called, it looks in the lambda' definition scope for a x. This x is a local variable defined in factory's body. Because of this, the value used on lambda execution will be the value that was passed as a parameter during the call to factory. And doremi!As a note, I could have defined factory as factory(m) [replace x by m], the behavior is the same. I used a different name for clarity :)You might find that Andrej Bauer got similar lambda problems. What's interesting on that blog is the comments, where you'll learn more about python closure :)
Not directly related to the issue at hand, but an invaluable piece of wisdom nevertheless: Python Objects by Fredrik Lundh. 
First, what you are seeing is not a problem, and not related to call-by-reference or by-value.The lambda syntax you defined has no parameters, and as such, the scope you are seeing with parameter  is external to the lambda function. This is why you are seeing these results.Lambda syntax, in your example is not necessary, and you would rather be using a simple function call:Again, you should be very precise about what lambda parameters you are using and where exactly their scope begins and ends.As a side note, regarding parameter passing. Parameters in python are always references to objects. To quote Alex Martelli:The terminology problem may be due to  the fact that, in python, the value of  a name is a reference to an object.  So, you always pass the value (no  implicit copying), and that value is  always a reference. [...] Now if you  want to coin a name for that, such as  "by object reference", "by uncopied  value", or whatever, be my guest.  Trying to reuse terminology that is  more generally applied to languages  where "variables are boxes" to a  language where "variables are post-it  tags" is, IMHO, more likely to confuse  than to help.
The variable  is being captured, so your lambda expression always sees its "current" value.If you need to effectively capture the value at a moment in time, write a function takes the value you want as a parameter, and returns a lambda expression. At that point, the lambda will capture the parameter's value, which won't change when you call the function multiple times:Output:
there are actually no variables in the classic sense in Python, just names that have been bound by references to the applicable object. Even functions are some sort of object in Python, and lambdas do not make an exception to the rule :)
As a side note, , although despised by some well known Python figure, forces a construction which prevents this pitfall.NB : the first  acts like the factory in other answers.
Yes, that's a problem of scope, it binds to the outer m, whether you are using a lambda or a local function. Instead, use a functor:
the soluiton to lambda is more lambdathe outer  is used to bind the current value of  to  at theeach time the outer  is called it makes an instance of the inner  with  bound to the current value of  as 's value 


Answer URL
https://docs.python.org/3/faq/programming.html#why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result
https://docs.python.org/3/faq/programming.html#why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result
