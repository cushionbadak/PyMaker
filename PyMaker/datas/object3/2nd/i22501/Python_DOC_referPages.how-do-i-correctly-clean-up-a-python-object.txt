Natural Text
 above fails with an AttributeError exception.  I understand Python doesn't guarantee the existence of "global variables" (member data in this context?) when  is invoked.  If that is the case and this is the reason for the exception, how do I make sure the object destructs properly?
I'd recommend using Python's  statement for managing resources that need to be cleaned up.  The problem with using an explicit  statement is that you have to worry about people forgetting to call it at all or forgetting to place it in a  block to prevent a resource leak when an exception occurs.To use the  statement, create a class with the following methods:In your example above, you'd use Then, when someone wanted to use your class, they'd do the following:The variable package_obj will be an instance of type Package (it's the value returned by the  method).  Its  method will automatically be called, regardless of whether or not an exception occurs.You could even take this approach a step further.  In the example above, someone could still instantiate Package using its constructor without using the  clause.  You don't want that to happen.  You can fix this by creating a PackageResource class that defines the  and  methods.  Then, the Package class would be defined strictly inside the  method and returned.  That way, the caller never could instantiate the Package class without using a  statement:You'd use this as follows:
The standard way is to use :But you should keep in mind that this will persist all created instances of  until Python is terminated.Demo using the code above saved as package.py:
As an appendix to Clint's answer, you can simplify  using :Alternatively, though probably not as Pythonic, you can override :and simply use .To get things shorter, name your cleanup function  and use , in which case you can either use the unmodified  class via  or override its  to the simplerAnd this constructor is inherited, so you can simply inherit, e.g.
I don't think that it's possible for instance members to be removed before  is called. My guess would be that the reason for your particular AttributeError is somewhere else (maybe you mistakenly remove self.file elsewhere).However, as the others pointed out, you should avoid using . The main reason for this is that instances with  will not be garbage collected (they will only be freed when their refcount reaches 0). Therefore, if your instances are involved in circular references, they will live in memory for as long as the application run. (I may be mistaken about all this though, I'd have to read the gc docs again, but I'm rather sure it works like this).
I think the problem could be in  if there is more code than shown? will be called even when  has not been executed properly or threw an exception.Source
A better alternative is to use weakref.finalize. See the examples at Finalizer Objects and Comparing finalizers with __del__() methods.
Just wrap your destructor with a try/except statement and it will not throw an exception if your globals are already disposed of.EditTry this:It will stuff the file list in the del function that is guaranteed to exist at the time of call. The weakref proxy is to prevent Python, or yourself from deleting the self.files variable somehow (if it is deleted, then it will not affect the original file list). If it is not the case that this is being deleted even though there are more references to the variable, then you can remove the proxy encapsulation.
It seems that the idiomatic way to do this is to provide a  method (or similar), and call it explicitely.
Here is a minimal working skeleton:Important: return selfIf you're like me, and overlook the  part (of Clint Miller's correct answer), you will be staring at this nonsense:I spent half a day on this. Hope it helps the next person.


Answer URL
https://docs.python.org/3/library/atexit.html#atexit.register
https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager
https://docs.python.org/3/library/contextlib.html#contextlib.closing
