Natural Text
I have a string that holds a very long sentence without whitespaces/spaces. I would like to find all of the repeated substrings that contains minimum 4 chars. So I would like to achieve something like this:As both , and  can be found two times in the  they were recognized as propely matched substrings with more than 4 char length. It's important that I am seeking repeated substrings, finding only existing english words is not a requirement. The answers I found are helpful for finding duplicates in texts with whitespaces, but I couldn't find a proper resource that covers the situation when there are no spaces and whitespaces in the string. I would really appreciate if somebody could show me how this should be done the most efficient way. 
This is in Python 2 because I'm not doing Python 3 at this time. So you'll have to adapt it to Python 3 yourself.
Let's go through this step by step. There are several sub-tasks you should take care of:Identify all substrings of length 4 or more.Count the occurrence of these substrings.Filter all substrings with 2 occurrences or more.You can actually put all of them into a few statements. For understanding, it is easier to go through them one at a time.The following examples all use1. Substrings of a given lengthYou can easily get substrings by slicing - for example,  gives you the substring from position 4 of length 6: . More generically, you want substrings of the form .So what values do you need for  and ? must...cover all substrings, so it must include the first character: .not map to short substrings, so it can stop  characters before the end: . must...cover the shortest substring of length 4: .not exceed the remaining string after : The  terms come from converting lengths (>=1) to indices (>=0).You can put this all together into a single comprehension:2. Count substringsTrivially, you want to keep a count for each substring. Keeping anything for each specific object is what s are made for. So you should use substrings as keys and counts as values in a . In essence, this corresponds to this:You can simply feed your  to , and it produces something like the above.Notice how the duplicate  maps to the count of 2.3. Filtering duplicate substringsSo now you have your substrings and the count for each. You need to remove the non-duplicate substrings - those with a count of 1.Python offers several constructs for filtering, depending on the output you want. These work also if  is a regular :Using Python primitivesPython ships with primitives that allow you to do this more efficiently.Use a generator to build substrings. A generator builds its member on the fly, so you never actually have them all in-memory. For your use case, you can use a generator expression:Use a pre-existing Counter implementation. Python comes with a -like container that counts its members:  can directly digest your substring generator. Especially in newer version, this is much more efficient.You can exploit Python's lazy filters to only ever inspect one substring. The  builtin or another generator generator expression can produce one result at a time without storing them all in memory.
Script (explanation where needed, in comments):Output:
Nobody is using ! Time for an answer [ab]using the regular expression built-in module ;)Finding all the maximal substrings that are repeatedThis matches the longest substrings which have at least a single repetition after (without consuming). So it finds all disjointed substrings that are repeated while only yielding the longest strings.Finding all substrings that are repeated, including overlapsThis ensures that all --not only disjoint-- substrings which have repetition are returned. It should be much slower, but gets the work done.If you want in addition to the longest strings that are repeated, all the substrings, then:That will ensure that for long substrings that have repetition, you have also the smaller substring --e.g. "sample" and "ample" found by the  code; but also "samp", "sampl", "ampl" added by the above snippet.Counting matchesBecause (by design) the substrings that we count are non-overlapping, the  method is the way to go:ResultsFinding maximal substrings:With the question's original :with the  sample:Finding all substrings:With the question's original :... and if we add the code to get all substrings then, of course, we get absolutely all the substrings:with the  sample:Future workIt's possible to filter the results of the finding all substrings with the following steps:take a match "A"check if this match is a substring of another match, call it "B"if there is a "B" match, check the counter on that match "B_n"if "A_n = B_n", then remove Ago to first stepIt cannot happen that "A_n < B_n" because A is smaller than B (is a substring) so there must be at least the same number of repetitions.If "A_n > B_n" it means that there is some extra match of the smaller substring, so it is a distinct substring because it is repeated in a place where B is not repeated.

Here's a Python3 friendly solution:Bonus: largest string Everything as a function:Example:Output:
CODE: OUTPUT:Hope this helps as my code length was short and it is easy to understand. Cheers!
This is my approach to this problem:
This is how I would do it, but I don't know any other way:Output:Efficient, no, but easy to understand, yes.
Here is simple solution using the  library.GivenCodeOutputDetailsThe procedures are:build sliding windows of varying sizes count all occurrences and filter replicates is a third-party package installed by .


Answer URL
https://docs.python.org/3/library/collections.html#collections.Counter
