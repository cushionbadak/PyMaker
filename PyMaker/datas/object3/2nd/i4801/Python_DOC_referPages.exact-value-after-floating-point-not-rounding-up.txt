Natural Text
I want to remove digits from a float to have a fixed number of digits after the dot, like:I need to output as a string to another function, not print.Also I want to ignore the lost digits, not round them.
First, the function, for those who just want some copy-and-paste code:This is valid in Python 2.7 and 3.1+. For older versions, it's not possible to get the same "intelligent rounding" effect (at least, not without a lot of complicated code), but rounding to 12 decimal places before truncation will work much of the time:ExplanationThe core of the underlying method is to convert the value to a string at full precision and then just chop off everything beyond the desired number of characters. The latter step is easy; it can be done either with string manipulationor the  moduleThe first step, converting to a string, is quite difficult because there are some pairs of floating point literals (i.e. what you write in the source code) which both produce the same binary representation and yet should be truncated differently. For example, consider 0.3 and 0.29999999999999998. If you write  in a Python program, the compiler encodes it using the IEEE floating-point format into the sequence of bits (assuming a 64-bit float)This is the closest value to 0.3 that can accurately be represented as an IEEE float. But if you write  in a Python program, the compiler translates it into exactly the same value. In one case, you meant it to be truncated (to one digit) as , whereas in the other case you meant it to be truncated as , but Python can only give one answer. This is a fundamental limitation of Python, or indeed any programming language without lazy evaluation. The truncation function only has access to the binary value stored in the computer's memory, not the string you actually typed into the source code.1If you decode the sequence of bits back into a decimal number, again using the IEEE 64-bit floating-point format, you getso a naive implementation would come up with  even though that's probably not what you want. For more on floating-point representation error, see the Python tutorial.It's very rare to be working with a floating-point value that is so close to a round number and yet is intentionally not equal to that round number. So when truncating, it probably makes sense to choose the "nicest" decimal representation out of all that could correspond to the value in memory. Python 2.7 and up (but not 3.0) includes a sophisticated algorithm to do just that, which we can access through the default string formatting operation.The only caveat is that this acts like a  format specification, in the sense that it uses exponential notation () if the number is large or small enough. So the method has to catch this case and handle it differently. There are a few cases where using an  format specification instead causes a problem, such as trying to truncate  to 28 digits of precision (it produces ), and I'm not yet sure how best to handle those.If you actually are working with s that are very close to round numbers but intentionally not equal to them (like 0.29999999999999998 or 99.959999999999994), this will produce some false positives, i.e. it'll round numbers that you didn't want rounded. In that case the solution is to specify a fixed precision.The number of digits of precision to use here doesn't really matter, it only needs to be large enough to ensure that any rounding performed in the string conversion doesn't "bump up" the value to its nice decimal representation. I think  may be enough in all cases, but if not that  might have to be increased, and it doesn't hurt to do so.In earlier versions of Python (up to 2.6, or 3.0), the floating point number formatting was a lot more crude, and would regularly produce things likeIf this is your situation, if you do want to use "nice" decimal representations for truncation, all you can do (as far as I know) is pick some number of digits, less than the full precision representable by a , and round the number to that many digits before truncating it. A typical choice is 12,but you can adjust this to suit the numbers you're using.1Well... I lied. Technically, you can instruct Python to re-parse its own source code and extract the part corresponding to the first argument you pass to the truncation function. If that argument is a floating-point literal, you can just cut it off a certain number of places after the decimal point and return that. However this strategy doesn't work if the argument is a variable, which makes it fairly useless. The following is presented for entertainment value only:Generalizing this to handle the case where you pass in a variable seems like a lost cause, since you'd have to trace backwards through the program's execution until you find the floating-point literal which gave the variable its value. If there even is one. Most variables will be initialized from user input or mathematical expressions, in which case the binary representation is all there is.
See Python's documentation on the standard types. You'll need to scroll down a bit to get to the round function. Essentially the second number says how many decimal places to round it to.
The result of  is a float, so watch out (example is from Python 2.6):You will be better off when using a formatted string:

At my Python 2.7 prompt:
This should work.  It should give you the truncation you are looking for.
Simple python script -
The truely pythonic way of doing it isor shorter:UpdateUsually the problem is not in truncating floats itself, but in the improper usage of float numbers before rounding. For example: . If you are forced to use floats (say, you're accelerating your code with ), it's better to use cents as "internal representation" of prices: () and multiply/divide the inputs/outputs.
So many of the answers given for this question are just completely wrong. They either round up floats (rather than truncate) or do not work for all cases.This is the top Google result when I search for 'Python truncate float', a concept which is really straightforward, and which deserves better answers. I agree with Hatchkins that using the  module is the pythonic way of doing this, so I give here a function which I think answers the question correctly, and which works as expected for all cases.As a side-note, fractional values, in general, cannot be represented exactly by binary floating point variables (see here for a discussion of this), which is why my function returns a string. 
I did something like this:
You can do:testing:
If you fancy some mathemagic, this works for +ve numbers:
Just wanted to mention that the old "make round() with floor()" trick ofcan be turned around to make floor() from round()Although both these rules break around negative numbers, so using it is less than ideal:
int(16.5);this will give an integer value of 16, i.e. trunc, won't be able to specify decimals, but guess you can do that by 
Here is an easy way:for num = 1.923328437452, this outputs 1.923
use numpy.round

A general and simple function to use:
1.923
>>>floor((1.23658945) * 10**4) / 10**41.2365# divide and multiply by 10**number of desired digits
There is an easy workaround in python 3. Where to cut I defined with an help variable decPlace to make it easy to adapt.Output:Hope it helps.
Something simple enough to fit in a list-comprehension, with no libraries or other external dependencies. For Python >=3.6, it's very simple to write with f-strings.The idea is to let the string-conversion do the rounding to one more place than you need and then chop off the last digit.Of course, there is rounding happening here (namely for the fourth digit), but rounding at some point is unvoidable. In case the transition between truncation and rounding is relevant, here's a slightly better example:Bonus: removing zeros on the right
The core idea given here seems to me to be the best approach for this problem. Unfortunately, it has received less votes while the later answer that has more votes is not complete (as observed in the comments). Hopefully, the implementation below provides a short and complete solution for truncation.which should take care of all corner cases found here and here.
Short and easy variant
Am also a python newbie and after making use of some bits and pieces here, I offer my two centsstr(int(time.time())) will take the time epoch as int and convert it to string and join with...str(datetime.now().microsecond)[:3] which returns the microseconds only, convert to string and truncate to first 3 chars

If you mean when printing, then the following should work:


Answer URL
https://docs.python.org/3/tutorial/floatingpoint.html
