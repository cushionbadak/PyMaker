Natural Text
For any possible try-finally block in Python, is it guaranteed that the  block will always be executed?For example, letâ€™s say I return while in an  block:Or maybe I re-raise an :Testing shows that  does get executed for the above examples, but I imagine there are other scenarios I haven't thought of.Are there any scenarios in which a  block can fail to execute in Python?
"Guaranteed" is a much stronger word than any implementation of  deserves. What is guaranteed is that if execution flows out of the whole - construct, it will pass through the  to do so. What is not guaranteed is that execution will flow out of the -.A  in a generator or async coroutine might never run, if the object never executes to conclusion. There are a lot of ways that could happen; here's one:Note that this example is a bit tricky: when the generator is garbage collected, Python attempts to run the  block by throwing in a  exception, but here we catch that exception and then  again, at which point Python prints a warning ("generator ignored GeneratorExit") and gives up. See PEP 342 (Coroutines via Enhanced Generators) for details.Other ways a generator or coroutine might not execute to conclusion include if the object is just never GC'ed (yes, that's possible, even in CPython), or if an  s in , or if the object s or s in a  block. This list is not intended to be exhaustive.A  in a daemon thread might never execute if all non-daemon threads exit first. will halt the process immediately without executing  blocks. may cause  blocks to execute twice. As well as just the normal problems you'd expect from things happening twice, this could cause concurrent access conflicts (crashes, stalls, ...) if access to shared resources is not correctly synchronized.Since  uses fork-without-exec to create worker processes when using the fork start method (the default on Unix), and then calls  in the worker once the worker's job is done,  and  interaction can be problematic (example).A C-level segmentation fault will prevent  blocks from running. will prevent  blocks from running.  and  will also prevent  blocks from running unless you install a handler to control the shutdown yourself; by default, Python does not handle  or .An exception in  can prevent cleanup from completing. One particularly noteworthy case is if the user hits control-C just as we're starting to execute the  block. Python will raise a  and skip every line of the  block's contents. (-safe code is very hard to write).If the computer loses power, or if it hibernates and doesn't wake up,  blocks won't run.The  block is not a transaction system; it doesn't provide atomicity guarantees or anything of the sort. Some of these examples might seem obvious, but it's easy to forget such things can happen and rely on  for too much.
Yes.  Finally always wins. The only way to defeat it is to halt execution before  gets a chance to execute (e.g. crash the interpreter, turn off your computer, suspend a generator forever).  I imagine there are other scenarios I haven't thought of.Here are a couple more you may not have thought about:Depending on how you quit the interpreter, sometimes you can "cancel" finally, but not like this:Using the precarious  (this falls under "crash the interpreter" in my opinion):I'm currently running this code, to test if finally will still execute after the heat death of the universe:However, I'm still waiting on the result, so check back here later.
According to the Python documentation:No matter what happened previously, the final-block is executed once the code block is complete and any raised exceptions handled. Even if there's an error in an exception handler or the else-block and a new exception is raised, the code in the final-block is still run.It should also be noted that if there are multiple return statements, including one in the finally block, then the finally block return is the only one that will execute.
Well, yes and no.What is guaranteed is that Python will always try to execute the finally block. In the case where you return from the block or raise an uncaught exception, the finally block is executed just before actually returning or raising the exception.(what you could have controlled yourself by simply running the code in your question)The only case I can imagine where the finally block will not be executed is when the Python interpretor itself crashes for example inside C code or because of power outage.
To really understand how it works, just run these two examples:will output finallywill output except  finally
I found this one without using a generator function:The sleep can be any code that might run for inconsistent amounts of time.What appears to be happening here is that the first parallel process to finish leaves the try block successfully, but then attempts to return from the function a value (foo) that hasn't been defined anywhere, which causes an exception. That exception kills the map without allowing the other processes to reach their finally blocks.Also, if you add the line  just after the sleep() call in the try block. Then the first process to reach that line throws an exception (because bazz isn't defined), which causes its own finally block to be run, but then kills the map, causing the other try blocks to disappear without reaching their finally blocks, and the first process not to reach its return statement, either.What this means for Python multiprocessing is that you can't trust the exception-handling mechanism to clean up resources in all processes if even one of the processes can have an exception. Additional signal handling or managing the resources outside the multiprocessing map call would be necessary.


Answer URL
https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods
https://docs.python.org/3/library/os.html#os._exit
https://docs.python.org/3/tutorial/errors.html#defining-clean-up-actions
