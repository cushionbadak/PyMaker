Natural Text
The code i'm writing calculates the sum of divisors of all numbers up to a specified limit. I tried writing it in three ways, two using numpy and one using the array module.the timing results (using timeit) are:And the results really go against my intuition, I would expect that the version with only one for loop would be faster then the version with two for loops and wouldn't expect there to be such a big difference between numpy and the array module. So, what am I missing?
The first problem is that you're using  for benchmarking. As the big box at the top of the docs says:The profiler modules are designed to provide an execution profile for a given program, not for benchmarking purposes (for that, there is timeit for reasonably accurate results). This particularly applies to benchmarking Python code against C code…The second problem is that you seem to have read your results out of order:Yes, the second output is much slower than the first and third—but the second output is , not . So numpy slicing () is actually much faster than looping over numpy (), not slower.The third problem is that you're creating the arrays inside the loop that you're timing, and this is actually a non-trivial cost. Numpy is slower at creating large arrays than , but that's rarely an issue in real life for the simple reason that you're usually doing a whole lot more work per array than just creating it. I'm not sure if that's relevant in this case or not, but it could be, and it's a lot easier to just not do that than to try to measure and prove that doing that didn't really hurt anything.When I change the arrays to be parameters, use  in iPython, and interpret the results in the right order, I see  as a little faster than  and much faster than . Since that agrees with the results that kazemakase posted in a comment, it's pretty likely that at least one of three problems above is responsible for your different numbers.In other words, numpy slicing seems to be slower because you measured it wrong, not because of anything to do with numpy or array or loops.
The reason two for loops are faster than slicing is that when slicing returns only a small subset of the array iterating is faster.and the timing*:So for most of the way (inside the outer for loop) the (inner) for loop is a bit faster than slicing using numpy.the "-n1 -r1" options are set because the python interpeter optimizes the slicing operation when it is preformed more than once so the timeit function throws this warning when it is not set - 


Answer URL
https://docs.python.org/3/library/profile.html
https://docs.python.org/3/library/profile.html
