Natural Text
I have trouble understanding why this simple program raises an  at the end.I am using a  to communicate with a  that I want to automatically and cleanly terminate  of my program.This raises:Moreover, this snippet behaves strangely: if I remove the  line, no error is raised and the thread exits successfully. Similarly, this seems to work if the  is call before .Does anyone know from where could come the error please?Edit: I noticed that using a  seems to make the error disappear. 
The issue comes from a conflict between multiple  calls.The documentation states that: runs these functions in the reverse order in which they were registered; if you register , , and , at interpreter termination time they will be run in the order , , .[...]The assumption is that lower level modules will normally be imported before higher level modules and thus must be cleaned up later.By first importing  and then calling , you would expect your stop function to be executed before any internal termination procedure... But this is not the case, because  may be called dynamically.In the present case, the  library makes use of a  function which is meant to cleanly close internal threads and queues. This function is registered in  at the module level, however the module is only loaded once the  object is initialized.Consequently, the  stop function is registered before the 's one and thus  is called after .During its termination,  closes internal pipes connections, so if the thread later try to call  with a closed read-connection, an  is raised. This happens only if Python did not have time to automatically kill the  thread at the end, that is if a "slow" exit function (like  or in this case ) is register and run after the usual closure procedure. For some reason, the write-connection shutdown is delayed hence  does not raise error immediately.As to why small modifications to the snippet makes it work:  does not have  so internal pipe is closed later. The internal thread of  is not started until the first  is called so removing it means there is no pipe to close. It is also posible to force registeration by importing .
To achieve it you can define  and  inside your class and create your instance using  statement:Above code gives as an output:
The surface answer to your question is fairly simple, The queued_writer process is still waiting for entries to be written to the queue when the main process ends, sending an EOF to the open blocking connection that  opened.That raises the question of why the  didn't seem to do it's job, but of that I do not know the reason for.


Answer URL
https://docs.python.org/3/library/exceptions.html#EOFError
https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue
https://docs.python.org/3/library/threading.html#threading.Thread
https://docs.python.org/3/library/atexit.html#atexit.register
https://docs.python.org/3/library/multiprocessing.html#multiprocessing.SimpleQueue
