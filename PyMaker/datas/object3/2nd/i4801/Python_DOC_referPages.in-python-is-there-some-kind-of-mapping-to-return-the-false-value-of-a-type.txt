Natural Text
I am looking for some kind of a mapping function  that does something similar to this:Meaning that it returns an object of type that evaluates to  when cast to .Does such a function exist?
No, there is no such mapping. Not every type of object has a falsy value, and others have more than one. Since the truth value of a class can be customized with the  method, a class could theoretically have an infinite number of (different) falsy instances.That said, most builtin types return their falsy value when their constructor is called without arguments:
Nope, and in general, there may be no such value. The Python data model is pretty loose about how the truth-value of a type may be implemented:Called to implement truth value testing and the built-in operation  bool(); should return False or True. When this method is not defined,   is called, if it is defined, and the object is considered true if its result is nonzero. If a class defines neither   nor , all its instances are considered true.So consider:What should  return?
Not all types have such a value to begin with. Others may have many such values. The most correct way of doing this would be to create a type-to-value dict, because then you could check if a given type was in the dict at all, and you could chose which value is the correct one if there are multiple options. The drawback is of course that you would have to somehow register every type you were interested in.Alternatively, you could write a function using some heuristics. If you were very careful about what you passed into the function, it would probably be of some limited use. For example, all the cases you show except  are containers that generalize with . actually works like that too, but I mention it separately because  and  do not. So if your attempt with the empty constructor fails by returning a truthy object or raising a , you can try . And so on and so forth...Update@juanpa.arrivillaga's answer actually suggests a clever workaround that will work for most classes. You can extend the class and forcibly create an instance that will be falsy but otherwise identical to the original class. You have to do this by extending because dunder methods like  are only ever looked up on the class, never on an instance. There are also many types where such methods can not be replaced on the instance to begin with. As @Aran-Fey's now-deleted comment points out, you can selectively call  or , depending on whether you are dealing with a very special case (like ) or not:This will only work for 99.9% of classes you ever encounter. It is possible to create a contrived case that raises a  when passed to  as  does, and does not allow for a no-arg version of , but I doubt you will ever find such a thing in nature. See the gist @Aran-Fey made to demonstrate this.
This is actually called an identity element, and in programming is most often seen as part of the definition of a monoid.  In python, you can get it for a type using the  function in the PyMonad package.  Haskell calls it mempty.  
No such function exists because it's not possible in general. A class may have no falsy value or it may require reversing an arbitrarily complex implementation of .What you could do by breaking everything else is to construct a new object of that class and forcibly assign its  function to one that returns . Though I suspect that you are looking for an object that would otherwise be a valid member of the class.In any case, this is a Very Bad Idea in classic style.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__bool__
https://docs.python.org/3/reference/datamodel.html#object.__bool__
https://docs.python.org/3/library/stdtypes.html
