Natural Text
There is a simple class where I want to store some functions statically in a dictionary using different ways:Some example methods:And a little test:All this works provided all these elements are in the same file. As soon as the functionality is split up in 2 files and a main file:Only the first two keep working (setting the function directly), the others - using a function to do the same thing - give a  on all the  calls. For instance: .What is the logic here for the loss of scope when using the methods versus directly setting the functions? And can I get it to work using imports from other packages so I can place any function in the class with a method rather than directly?
There's a live version of fix #1 from this answer online that you can try out for yourselfThe problemYou're right that the reason this doesn't work is due to scoping issues. You can figure out what's going on by scrutinizing the docs for :eval(expression, globals=None, locals=None)...If both dictionaries [ie globals and locals] are omitted, the expression is executed in the environment where eval() is called.Thus, it is reasonable to assume that the issue you're having is down to the contents of  and  in the context (ie within the definition (and possibly separate module) of ) in which  is getting called. Since the context in which  is getting called is not, in general, the context in which you have defined and/or imported , these functions are undefined as far as  is concerned. This line of thinking is backed up by the docs for :globals()...This is always the dictionary of the current module (inside a function or method, this is the module where it is defined, not the module from which it is called).The fixYou have a few different options for how you can go about fixing this code. All of them are going to involve passing  from the context in which you call, eg,  to the context in which that method is defined. Additionally, you should take the opportunity to factor out the use of  from your code (its use is considered bad practice, it's a massive security hole, yadda yadda yadda). Given that  is the dict of a scope in which  is defined, you can always just do:instead of: fix #1Link to live version of this fixThis'll be the easiest fix to implement, since it only requires a few tweaks to the definitions of the methods of  (and no changes to any method signatures). It relies on the fact that it is possible to use the  package within a function to directly grab the  of the calling context:If you use the above given definition of , the import test you cooked up will now function as expected.ProsProvides exactly the originally intended functionality.Involves no changes to function signatures.ConsCalling  can cause a dip in performance, so you may not be able to use this fix if you're planning on calling the methods of  a million times a second. is only guaranteed to work on CPython. Mileage may vary when running this code with other implementations of Python.fix #2Fix #2 is basically the same as fix #1, except that in this version you explicitly pass  into the methods of  at the point of call. For example, under this fix the definition of  would be:and you would call it in your code like this:ProsDoesn't rely on , and so is probably more performant/portable than fix #1.ConsYou have to modify method signatures, so you'll also have to change any existing code that uses those methods.You'll have to add the  boilerplate to every invocation of every  method from here on.


Answer URL
https://docs.python.org/3/library/functions.html#eval
https://docs.python.org/3/library/functions.html#globals
