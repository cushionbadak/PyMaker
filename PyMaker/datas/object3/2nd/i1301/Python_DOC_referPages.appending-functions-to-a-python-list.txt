Natural Text
Recently I started playing around with Python and I came around something peculiar in the way closures work. Consider the following code:It builds a simple array of functions that take a single input and return that input added by a number. The functions are constructed in  loop where the iterator  runs from  to . For each of these numbers a  function is created which captures  and adds it to the function's input. The last line calls the second  function with  as a parameter. To my surprise the output was .I expected a . My reasoning was: in Python everything is an object and thus every variable is essential a pointer to it. When creating the  closures for , I expected it to store a pointer to the integer object currently pointed to by . That means that when  assigned a new integer object it shouldn't effect the previously created closures. Sadly, inspecting the  array within a debugger shows that it does. All  functions refer to the last value of , , which results in  returning .Which make me wonder about the following:What do the closures capture exactly?What is the most elegant way to convince the  functions to capture the current value of  in a way that will not be affected when  changes its value?
Your second question has been answered, but as for your first:what does the closure capture exactly?Scoping in Python is dynamic and lexical. A closure will always remember the name and scope of the variable, not the object it's pointing to. Since all the functions in your example are created in the same scope and use the same variable name, they always refer to the same variable.EDIT: Regarding your other question of how to overcome this, there are two ways that come to mind:The most concise, but not strictly equivalent way is the one recommended by Adrien Plisson. Create a lambda with an extra argument, and set the extra argument's default value to the object you want preserved.A little more verbose but less hacky would be to create a new scope each time you create the lambda:The scope here is created using a new function (a lambda, for brevity), which binds its argument, and passing the value you want to bind as the argument. In real code, though, you most likely will have an ordinary function instead of the lambda to create the new scope:
you may force the capture of a variable using an argument with a default value:the idea is to declare a parameter (cleverly named ) and give it a default value of the variable you want to capture (the value of  )
For completeness another answer to your second question: You could use partial in the functools module.With importing add from operator as Chris Lutz proposed the example becomes: 
Consider the following code:I think most people won't find this confusing at all. It is the expected behaviour.So, why do people think it would be different when it is done in a loop? I know I did that mistake myself, but I don't know why. It is the loop? Or perhaps the lambda?After all, the loop is just a shorter version of:
In answer to your second question, the most elegant way to do this would be to use a function that takes two parameters instead of an array:However, using lambda here is a bit silly. Python gives us the  module, which provides a functional interface to the basic operators. The lambda above has unnecessary overhead just to call the addition operator:I understand that you're playing around, trying to explore the language, but I can't imagine a situation I would use an array of functions where Python's scoping weirdness would get in the way.If you wanted, you could write a small class that uses your array-indexing syntax:
Here's a new example that highlights the data structure and contents of a closure, to help clarify when the enclosing context is "saved."What is in a closure?Notably, my_str is not in f1's closure.What's in f2's closure?Notice (from the memory addresses) that both closures contain the same objects. So, you can start to think of the lambda function as having a reference to the scope. However, my_str is not in the closure for f_1 or f_2, and i is not in the closure for f_3 (not shown), which suggests the closure objects themselves are distinct objects.Are the closure objects themselves the same object?


Answer URL
https://docs.python.org/3/faq/programming.html#why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result
https://docs.python.org/3/faq/programming.html#why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result
