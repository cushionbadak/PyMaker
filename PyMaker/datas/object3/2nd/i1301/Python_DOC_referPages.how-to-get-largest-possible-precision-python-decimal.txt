Natural Text
I'm using the Decimal class for operations that requires precision.I would like to use 'largest possible' precision. With this, I mean as precise as the system on which the program runs can handle.To set a certain precision it's simple:I tried to figure out the maximum precision the 'Decimal' class can compute:So I tried to set the precision to the maximum precision (knowing it probably won't work..):But, of course, this throws a Memory Error (on division)So my question is: How do I figure out the maximum precision the current system can handle?Extra info:
Trying to do this is a mistake. Throwing more precision at a problem is a tempting trap for newcomers to floating-point, but it's not that useful, especially to this extreme.Your operations wouldn't actually require the "largest possible" precision even if that was a well-defined notion. Either they require exact arithmetic, in which case  is the wrong tool entirely and you should look into something like  or symbolic computation, or they don't require that much precision, and you should determine how much precision you actually need and use that.If you still want to throw all the precision you can at your problem, then how much precision that actually is will depend on what kind of math you're doing, and how many absurdly precise numbers you're attempting to store in memory at once. This can be determined by analyzing your program and the memory requirements of  objects, or you can instead take the precision as a parameter and binary search for the largest precision that doesn't cause a crash.
I'd like to suggest a function that allows you to estimate your maximum precision for a given operation in a brute force way:This is just halving intervals one step at a time and looks if an error occurs. Calling with  and  gives:This may give a rough idea of what you are dealing with. This took approx half an hour on i5-3470 and 16GB RAM so you really only would use it for testing purposes. I don't think, that there is an actual exact way of getting the maximum precision for your operation, as you'd have to have exact knowledge of the dependency of your memory usage on memory consumption. I hope this helps you at least a bit and I would really like to know, what you need that kind of precision for.EDIT I feel like this really needs to be added, since I read your comments under the top rated post here. Using arbitrarily high precision in this manner is not the way, that people calculate constants. You would program something, that utilizes disk space in a smart way (for example calcutating a bunch of digits in RAM and writing this bunch to a text file), but never only use RAM/swap only, because this will always limit your results. With modern algorithms to calculate pi, you don't need infinite RAM, you just put another 4TB hard drive in the machine and let it write the next digits. So far for mathematical constants.Now for physical constants: They are not precise. They rely on measurement. I'm not quite sure atm (will edit) but I think the most exact physical constant has an error of 10**(-8). Throwing more precision at it, doesn't make it more exact, you just calculate more wrong numbers.As an experiment though, this was a fun idea, which is why I even posted the answer in the first place.
The maximum precision of the Decimal class is a function of the memory on the device, so there's no good way to set it for the general case. Basically, you're allocating all of the memory on the machine to one variable to get the maximum precision.If the mathematical operation supports it, long integers will give you unlimited precision. However, you are limited to whole numbers.Addition, subtraction, multiplication, and simple exponents can be performed exactly with long integers.Prior to Python 3, the built-in  data type would perform arbitrary precision calculations.https://docs.python.org/2/library/functions.html#longIn Python >=3, the  data type now represents long integers.https://docs.python.org/3/library/functions.html#intOne example of a 64-bit integer math is implementation is bitcoind, where transactions calculations require exact values. However,  the precision of Bitcoin transactions is limited to 1 "Satoshi"; each Bitcoin is defined as 10^8 (integer) Satoshi.The Decimal class works similarly under the hood. A Decimal precision of 10^-8 is similar to the Bitcoin-Satoshi paradigm.
From your reply above:What if I just wanted to find more digits in pi than already found? what if I wanted to test the irrationality of e or mill's constant.I get it. I really do. My one SO question, several years old, is about arbitrary-precision floating point libraries for Python. If those are the types of numerical representations you want to generate, be prepared for the deep dive. Decimal/FP arithmetic is notoriously tricky in Computer Science. Some programmers, when confronted with a problem, think “I know, I’ll use floating point arithmetic.” Now they have 1.999999999997 problems. – @tomscottI think when others have said it's a "mistake" or "it depends" to wonder what the max precision is for a Python Decimal type on a given platform, they're taking your question more literally than I'm guessing it was intended. You asked about the Python Decimal type, but if you're interested in FP arithmetic for educational purposes -- "to find more digits in pi" -- you're going to need more powerful, more flexible tools than Decimal or float. These built-in Python types don't even come close. Those are good enough for NASA maybe, but they have limits... in fact, the very limits you are asking about.That's what multiple-precision (or arbitrary-precision) floating point libraries are for: arbitrarily-precise representations. Want to compute pi for the next 20 years? Python's Decimal type won't even get you through the day.The fact is, multi-precision binary FP arithmetic is still kinda fringe science. For Python, you'll need to install the GNU MPFR library on your Linux box, then you can use the Python library gmpy2 to dive as deep as you like. Then, the question isn't, "What's the max precision my program can use?"It's, "How do I write my program so that it'll run until the electricity goes out?"And that's a whole other problem, but at least it's restricted by your algorithm, not the hardware it runs on.


Answer URL
https://docs.python.org/3/library/functions.html#int
