Natural Text
A frozen set is a frozenset.  A frozen list could be a tuple.  What would a frozen dict be? An immutable, hashable dict.  I guess it could be something like , but that is more like a frozen-keys dict (a half-frozen dict). Isn't it?A "frozendict" should be a frozen dictionary, it should have , , , etc., and support , , etc.
Python doesn't have a builtin frozendict type. It turns out this wouldn't be useful too often (though it would still probably be useful more often than  is).The most common reason to want such a type is when memoizing function calls for functions with unknown arguments. The most common solution to store a hashable equivalent of a dict (where the values are hashable) is something like . This depends on the sorting not being a bit insane. Python cannot positively promise sorting will result in something reasonable here. (But it can't promise much else, so don't sweat it too much.)You could easily enough make some sort of wrapper that works much like a dict. It might look something likeIt should work great:
Curiously, although we have the seldom useful  in python, there's still no frozen mapping.  The idea was rejected in PEP 416.  So the python 2 solution to this:Still seems to be the somewhat lame:In python3 you have the option of this:Now the default config can be updated dynamically, but remain immutable where you want it to be immutable by passing around the proxy instead.  So changes in the  will update  as expected, but you can't write to the mapping proxy object itself.  Admittedly it's not quite the same thing as an "immutable, hashable dict" - but it's a decent substitute given the same kind of use cases for which we might want a frozendict.    
Assuming the keys and values of the dictionary are themselves immutable (e.g. strings) then:
Here is the code I've been using.  I subclassed frozenset.  The advantages of this are the following.This is a truly immutable object.  No relying on the good behavior of future users and developers.It's easy to convert back and forth between a regular dictionary and a frozen dictionary.  FrozenDict(orig_dict) --> frozen dictionary.  dict(frozen_dict) --> regular dict.Update Jan 21 2015:  The original piece of code I posted in 2014 used a for-loop to find a key that matched.  That was incredibly slow.  Now I've put together an implementation which takes advantage of frozenset's hashing features.  Key-value pairs are stored in special containers where the  and  functions are based on the key only.  This code has also been formally unit-tested, unlike what I posted here in August 2014.MIT-style license.
I think of frozendict everytime I write a function like this:
You may use  from  package as:As per the document:frozendict(dict_obj): Accepts obj of dict type and returns a hashable and immutable dict
There is no  but you can use :
Yes, this is my second answer, but it is a completely different approach.  The first implementation was in pure python.  This one is in Cython.  If you know how to use and compile Cython modules, this is just as fast as a regular dictionary.  Roughly .04 to .06 micro-sec to retrieve a single value.This is the file "frozen_dict.pyx"Here's the file "setup.py"If you have Cython installed, save the two files above into the same directory.  Move to that directory in the command line.And you should be done.
The main disadvantage of  is that it needs to be specified before it is used, so it's less convenient for single-use cases.However, there is a practical workaround that can be used to handle many such cases. Let's say that you want to have an immutable equivalent of the following dict:This can be emulated like this:It's even possible to write an auxiliary function to automate this:Of course this works only for flat dicts, but it shouldn't be too difficult to implement a recursive version.
Install frozendictUse it!
Another option is the  class from the  package.
Subclassing i see this pattern in the wild (github) and wanted to mention it:example usage:Prossupport for , ,  ( on py2) and all the goodies from  out of the box without explicitly implementing themuses internally  which means performance ( is written in c in CPython)elegant simple and no black magic returns True - although python encourages duck-typing many packages uses , this can save many tweaks and customizationsConsany subclass can override this or access it internally (you cant really 100% protect something in python, you should trust your users and provide good documentation).if you care for speed, you might want to make  a bit faster.
In the absence of native language support, you can either do it yourself or use an existing solution. Fortunately Python makes it dead simple to extend off of their base implementations.
I needed to access fixed keys for something at one point for something that was a sort of globally-constanty kind of thing and I settled on something like this:Use it likeWARNING: I don't recommend this for most use cases as it makes some pretty severe tradeoffs.


Answer URL
https://docs.python.org/3/library/types.html#types.MappingProxyType
https://docs.python.org/3/library/types.html#types.MappingProxyType
