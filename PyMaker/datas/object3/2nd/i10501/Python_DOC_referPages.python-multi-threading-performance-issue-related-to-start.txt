Natural Text
I had some performance issues with a multi-threading code to parallelize multiple telnet probes.SlowMy first implementation was is really slow, same a if the tasks were run sequencially:Blastlingly FastQuestionI don't get why moving the  method change the performance so much.
In your first implementation you are actually running the code sequentially because by calling  immediately after  the main thread is blocked until the started thread is finished.
thread.join() is blocking every thread as soon as they are created in your first implementation.
According to threading.Thread.join() documentation:Wait until the thread terminates.  This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs".In your slow example you start the thread and wait till it is complete, then you iterate to the next thread. ExampleProduces
In your slow solution you are basically not using multithreading at all. Id's running a thread, waiting to finish it and then running another - there is no difference in running everything in one thread and this solution - you are running them in series.The second one on the other hand starts all threads and then joins them. This solution limits the execution time to the longest execution time of one single thread - you are running them in parallel.


Answer URL
https://docs.python.org/3/library/threading.html#threading.Thread.join
https://docs.python.org/3/library/threading.html#threading.Thread.start
https://docs.python.org/3/library/threading.html#threading.Thread.join
