Natural Text
I'm using python's  to simulate a 29-dimensional linear system of differential equations. Since I need to solve several problem instances, I thought I could speed it up by doing computations in parallel using . Since there is no shared data or synchronization necessary between threads (the problem is embarrassingly parallel), I thought this should obviously work. After I wrote the code to do this, however, I got very strange performance measurements:Single-threaded, without jacobian: 20-30 ms per callSingle-threaded, with jacobian: 10-20 ms per callMulti-threaded, without jacobian: 20-30 ms per callMulti-threaded, with jacobian: 10-5000 ms per callWhat's shocking is that what I thought should be the fastest setup, was actually the slowest, and the variability was two orders of magnitude. It's a deterministic computation; computers aren't supposed to work this way. What could possibly be causing this?Effect seems system-dependentI tried the same code on another computer and I didn't see this effect. Both machines were using Ubuntu 64 bit, Python 2.7.6, scipy version 0.18.0, and numpy version 1.8.2. I didn't see the variability with an Intel(R) Core(TM) i5-5300U CPU @ 2.30GHz processor. I did see the issue with an Intel(R) Core(TM) i7-2670QM CPU @ 2.20GHz.TheoriesOne thought was that there might be a shared cache among processors, and by running it in parallel I can't fit two instances of the jacobian matrix in the cache, so they constantly battle each other for the cache slowing each other down compared with if they are run serially or without the jacobian. But it's not a million variable system. The jacobian is a 29x29 matrix, which takes up 6728 bytes. The level 1 cache on the processor is 4 x 32 KB, much larger. Are there any other shared resources between processors that might be to blame? How can we test this?Another thing I noticed is that each python process seems to take several hundred percent of the CPU as it's running. This seems to mean that the code is already parallelized at some point (perhaps in the low-level library). This could mean that further parallelization wouldn't help, but I wouldn't expect such a dramatic slowdown.CodeIt would be good to try out the on more machines to see if (1) other people can experience the slowdown at all and (2) what are the common features of systems where the slowdown occurs. The code does 10 trials of two parallel computations using a multiprocessing pool of size two, printing out the time per scipy.ode.integrate call for each of the 10 trials. Example OutputHere's an example of the output that demonstrates the problem (each run is slightly different). Notice the large variability in execution times (over two orders of magnitude!). Again, this all goes away if I either use a pool of size 1 (or run the code without a pool), or if I don't use an explicit jacobian in the call to .times: 5847ms, 5760mstimes: 4177ms, 3991mstimes: 229ms, 36mstimes: 1317ms, 1544mstimes: 87ms, 100mstimes: 113ms, 102mstimes: 4747ms, 5077mstimes: 597ms, 48mstimes: 9ms, 49mstimes: 135ms, 109ms
Based on the variability of the execution times you posted for the machine showing the problem, I wonder what else that computer is doing at the time you are running your test.  Here are times I saw when I ran your code on an AWS r3.large server (2 cores, 15 GB of RAM) that normally runs interactive R sessions but is currently mostly idle:times: 11ms, 11mstimes: 9ms, 9mstimes: 9ms, 9mstimes: 9ms, 9mstimes: 10ms, 10mstimes: 10ms, 10mstimes: 10ms, 10mstimes: 11ms, 10mstimes: 11ms, 10mstimes: 9ms, 9msIs it possible your machine is swapping and you do not know it?   will give you a lot of information about swap in and outs, but not about cache evictions.Intel makes some very nice tools for monitoring--two at a time--thousands of different types of operations and errors going on in a processor--including L2 cache evictions--but they are a bit of a firehose: there is information generated every microsecond--or more frequently--and you have to decide what you are going to monitor and how often you want an interrupt to deliver the numbers into your software.  Likely it will take many runs just to narrow down the stats you want to track and you still have to filter out the noise generated by the operating system and everything else running at the time.  It is a time consuming process, but if you follow it to the end and run many different tests you will come to understand what is going on.  But is this--shared cache resources in a processor--really your question?  It seems more like you just want to figure out why you have variable run times on one machine and, second, why multi-threaded is slower on both machines than single threaded.  Do I have it right?  If not I will edit my answer and we can talk about processor cache, cache snooping and cache coherency.So, as to the variability on the i7-2670QM CPU machine, I would start with ,  and  to see if the machine is doing something you didn't realize.  That much variability says the executable is getting stalled because the processor is busy doing something else: going off to the network and not finding a share it expects, unable to connect to a DNS server, getting kerbios failures: it could be a lot of things including hardware failures from a hard disk that is being continually reset.  Oh, and move your program to /dev/shm and cd there before you start it.  That won't help you if there are Python libraries in a bad place on a disk, but at least you won't have issues with your local directory.  Report back what you find and we can make further suggestions.Your second question as I see it, which is perhaps where you started, is why is your program slower when run multi-threaded than single-threaded.  This is a big subject that will come a lot more in focus if we can see how you multi-threaded it.  But even before we do you have to realize that there are several things that can cause a multi-threaded program to run slower than a single-threaded program, and it can have as much to do with the support infrastructure around your program--libraries and operating system calls you make--as your program.  Just because you do not need mutexes does not mean the libraries and operating system do not need them when they are being called from a multi-threaded application.  Locking a mutex is an expensive operation, especially as different threads are rotated between different cores.  On top of that, since the vode is not re-entrant, if you called it from multiple threads it is possible that it is having trouble finding convergence and having to recalculate the same values many times before it "gets lucky" and has enough processor time to complete an iteration before it is swapped out and intermediate results are overwritten.  Give us the code you are using for your multi-threaded runs and I will add to this answer.
This is intended as a formatted comment regarding the mathematical background raised in a comment by @Dietrich. As it doesn't address the programming question, I intend to delete this answer in a little while until the bounty blows over.As @Dietrich noted, you can solve your ODE exactly, since ifthen the exact solution isAlready I'd say that an exact solution is always superior than a numerical approximation, but this can indeed be faster than a numerical integration. As you noted in a comment, you're worried about efficiency. So don't compute the matrix exponential for each : compute the eigensystem of  only once:thenand the coefficients  can be determined from the linear equationsNow, having an inhomogeneous term doesn't change much, as long as your matrix is not singular:so we can solve the homogeneous equation for  and in a final step recover .This all works nicely while the matrix is regular, but in your specific case it's singular. But it turns out that this is due to your final dimension:And also note that the final row of  is all zeros (this is the reason for the singularity of ). So the last dimension of  is constant (or changes linearly due to ).I suggest eliminating this variable, rewriting your equation for the rest of the variables, and solving the non-singular inhomogeneous linear system of ODEs using the above procedure, exactly. It should be faster and precise.The following will be a bit speculative, see also the caveat at the end.In case of user-input  and , things might get trickier. Finding a zero row/column in your matrix would be easy, but  can be singular even though none of its rows/columns are fully zero. I'm not an expert in the subject, but I think your best bet is using something akin to principal component analysis: transforming your system of equations according to the eigensystem of . My following thoughts will still assume that  is diagonalizable, but mostly because I'm unfamiliar with singular value decomposition. In realistic cases I'd expect your matrices to be diagonalizable, even if singular.So I'll assume that the matrix  can be decomposed aswhere  is a diagonal matrix containing the eigenvalues of , and columns of  are the eigenvectors of  corresponding to each respective eigenvalue. The very same decomposition can be obtained in numpy usingI usually prefer using s instead of matrices, but this way  would really correspond to the matrix product of the three matrices, rather than calling  twice.Now, rewrite your equation again:By defining the auxiliary variableswe obtaini.e. the usual inhomogeneous form, but now  is a diagonal matrix containing the eigenvalues of  in the diagonal.Since  is singular, some of the eigenvalues are zero. Look for zero elements in  (well, you can do that already with  from ), and you'll know that they behave trivially during time-evolution. The remaining variables behave well, although at this point we see that the equations for  are decoupled due to  being diagonal, so you could integrate each independently and analytically. For this you need to first go from your initial condition  to , then after solving the equations, back to .Caveat: as I said, I'm not an expert in this subject. I can easily imagine that the inversions involved in the diagonalization can be a numerical issue in practical applications. So I'd first test if the matrix is singular, and only carry on with this procedure if it is (or nearly is). It's possible that the above carries a lot of error, in which case numerical integration might be better (I really can't tell).
on my compiled linux kernel :times: 8ms, 7mstimes: 5ms, 4mstimes: 4ms, 4mstimes: 8ms, 8mstimes: 4ms, 4mstimes: 5ms, 4mstimes: 4ms, 8mstimes: 8ms, 8mstimes: 8ms, 8mstimes: 4ms, 5msIntel(R) Core(TM) i5-4300U CPU @ 1.90GHzbe sure your processor runs at fixed speed, noswap./tmp is mounted in RAM.


Answer URL
https://docs.python.org/3/library/multiprocessing.html#all-start-methods
