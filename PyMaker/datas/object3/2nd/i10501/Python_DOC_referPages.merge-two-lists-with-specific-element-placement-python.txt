Natural Text
I have two lists of objects. Each list is already sorted by a property of the object that is of the datetime type. I would like to combine the two lists into one sorted list. Is the best way just to do a sort or is there a smarter way to do this in Python?
People seem to be over complicating this.. Just combine the two lists, then sort them:..or shorter (and without modifying ):..easy! Plus, it's using only two built-in functions, so assuming the lists are of a reasonable size, it should be quicker than implementing the sorting/merging in a loop. More importantly, the above is much less code, and very readable.If your lists are large (over a few hundred thousand, I would guess), it may be quicker to use an alternative/custom sorting method, but there are likely other optimisations to be made first (e.g not storing millions of  objects)Using the  (which repeats the functions 1000000 times), I loosely benchmarked it against ghoseb's solution, and  is substantially quicker: took.. took..
is there a smarter way to do this in PythonThis hasn't been mentioned, so I'll go ahead - there is a merge stdlib function in the heapq module of python 2.6+. If all you're looking to do is getting things done, this might be a better idea. Of course, if you want to implement your own, the merge of merge-sort is the way to go.Here's the documentation.
Long story short, unless  use:Description of the figure and source code can be found here. The figure was generated by the following command:
This is simply merging. Treat each list as if it were a stack, and continuously pop the smaller of the two stack heads, adding the item to the result list, until one of the stacks is empty. Then add all remaining items to the resulting list.
There is a slight flaw in ghoseb's solution, making it O(n**2), rather than O(n).The problem is that this is performing:With linked lists or deques this would be an O(1) operation, so wouldn't affect complexity, but since python lists are implemented as vectors, this copies the rest of the elements of l1 one space left, an O(n) operation.  Since this is done each pass through the list, it turns an O(n) algorithm into an O(n**2) one.  This can be corrected by using a method that doesn't alter the source lists, but just keeps track of the current position.I've tried out benchmarking a corrected algorithm vs a simple sorted(l1+l2) as suggested by dbrI've tested these with lists generated withFor various sizes of list, I get the following timings (repeating 100 times):So in fact, it looks like dbr is right, just using sorted() is preferable unless you're expecting very large lists, though it does have worse algorithmic complexity.  The break even point being at around a million items in each source list (2 million total).One advantage of the merge approach though is that it is trivial to rewrite as a generator, which will use substantially less memory (no need for an intermediate list).[Edit]I've retried this with a situation closer to the question - using a list of objects containing a field "" which is a datetime object.The above algorithm was changed to compare against  instead, and the sort method was changed to:This does change things a bit.  The comparison being more expensive means that the number we perform becomes more important, relative to the constant-time speed of the implementation.  This means merge makes up lost ground, surpassing the sort() method at 100,000 items instead.  Comparing based on an even more complex object (large strings or lists for instance) would likely shift this balance even more.[1]: Note: I actually only did 10 repeats for 1,000,000 items and scaled up accordingly as it was pretty slow.
This is simple merging of two sorted lists. Take a look at the sample code below which merges two sorted lists of integers.This should work fine with datetime objects. Hope this helps.
The output:I bet this is faster than any of the fancy pure-Python merge algorithms, even for large data. Python 2.6's  is a whole another story.
Python's sort implementation "timsort" is specifically optimized for lists that contain ordered sections.  Plus, it's written in C.  http://bugs.python.org/file4451/timsort.txthttp://en.wikipedia.org/wiki/TimsortAs people have mentioned, it may call the comparison function more times by some constant factor (but maybe call it more times in a shorter period in many cases!).I would never rely on this, however. – Daniel NadasiI believe the Python developers are committed to keeping timsort, or at least keeping a sort that's O(n) in this case.Generalized sorting (i.e. leaving apart radix sorts from limited value domains)  cannot be done in less than O(n log n) on a serial machine. – Barry KellyRight, sorting in the general case can't be faster than that.  But since O() is an upper bound, timsort being O(n log n) on arbitrary input doesn't contradict its being O(n) given sorted(L1) + sorted(L2).
Recursive implementation is below. Average performance is O(n).or generator with improved space complexity:

An implementation of the merging step in Merge Sort that iterates through both lists:I'm still learning about algorithms, please let me know if the code could be improved in any aspect, your feedback is appreciated, thanks!
Well, the naive approach (combine 2 lists into large one and sort) will be O(N*log(N)) complexity. On the other hand, if you implement the merge manually (i do not know about any ready code in python libs for this, but i'm no expert) the complexity will be O(N), which is clearly faster.The idea is described wery well in post by Barry Kelly.
Use the 'merge' step of merge sort, it runs in O(n) time.From wikipedia (pseudo-code):
If you want to do it in a manner more consistent with learning what goes on in the iteration try this

Have used merge step of the merge sort. But I have used generators.  Time complexity O(n)
Will sort the list in place. Define your own function for comparing two objects, and pass that function into the built in sort function.Do NOT use bubble sort, it has horrible performance.
This is my solution in linear time without editing l1 and l2:
This code has time complexity O(n) and can merge lists of any data type, given a quantifying function as the parameter . It produces a new merged list and does not modify either of the lists passed as arguments.
Hope this helps. Pretty Simple and straight forward:l1 = [1, 3, 4, 7]l2 = [0, 2, 5, 6, 8, 9]l3 = l1 + l2l3.sort()print (l3)[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]


Answer URL
https://docs.python.org/3/library/heapq.html#heapq.merge
