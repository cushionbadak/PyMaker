Natural Text
I have discovered that I can't use the  argument in the new print function if I use Python 2.7.11. I have used:but it complains with the error:After looking at the documentation for  I discovered that it doesn't work even though it is an argument. My inference is that it doesn't work because  was only added in version 3.3, thus the special  statement is probably importing an older version of the function. The comments suggest it's using 2.7.11 but I don't understand why it's doing this.I did see Need Python 3.4 version of print() from __future__, whose answer just wraps  and manually adds the  parameter. Even though that works, it seems more of a hack than addressing the real problem, that we don't have the most recent version of print. Is there a way to import specific versions of Python functions (I want to use the Python 3.5  function, specifically) to my current Python script? If this is not possible, why not?It seems (surprisingly) its not clear to people how my question is different even though I wrote it. I will say it differently.It seems that my issue is that its importing the python function that I am not expecting (since it doesn't find the flush argument). Therefore, the most natural and the first thing I'd like to do and know is, which print function is it importing. The comments suggest its using 2.7.11 but I don't understand why its doing this.I understand that the from future statement changes how my compiler works. It seems I assumed that since it was a future statement it also brought in the print function from a future release. It seems it only changes the behaviour of my interpreter. If I were able to see what print function its using I would know that its not importing a function from a future release but only acting like a future python interpreter. Thats what it seems but I don't know for sure and I'd like to know for sure whats going on.Last but not least, is there not a natural way to import future python functions to my current python script? I want to use python 3.5 print statement, is it not possible to use that function apart from just making the compiler behave like a future python interpreter but also behave like a future python version? It was (at least to me) counter intuitive to have the parser act like future python but still act like a 2.7.11. The solution I want is not a wrapper but a import of the recent python. If this is not possible, then a answer to my question should explain why its not possible.
its importing the python function that I am not expectingI don't see why, this is the version of  that's documented in 2.7.x.which print function is it importing. The version bundled with 2.7.11, which is the version that was introduced in 3.0 (see PEP-3105).The comments suggest its using 2.7.11 but I don't understand why its doing this...because that's the version of Python you're using?  doesn't search your computer for alternative implementations, it uses the one that's bundled with the version of Python you're using. If you think about it this is inevitable, as otherwise future imports would fail on machines that don't have 3.x installed.The majority of this made little sense to me, but:I assumed that since it was a future statement it also brought in the print function from a future release.That's exactly what it's doing. You don't get to choose which future release, though. You get the version that was planned for release at the time it was added into .is there not a natural way to import future python functions to my current python script?Yes, and it's the way you're using, as long as that functionality is supported in .is it not possible to use that functionnot the 3.3-onwards version of it in the version of Python that you're using, no*. If you want the functionality offered by more recent versions of Python, use a more recent version of Python. 2.x is running out of road.It was (at least to me) counter intuitive to have the parser act like future python but still act like a 2.7.11It's not "[acting] like a 2.7.11". It's using the print function from 3.x rather than the print statement from 2.x. If you try to  after the import of , you'll get a  as you would in 3.x.* assuming you're not planning to get into hacking your installation


Answer URL
https://docs.python.org/3/library/functions.html#print
