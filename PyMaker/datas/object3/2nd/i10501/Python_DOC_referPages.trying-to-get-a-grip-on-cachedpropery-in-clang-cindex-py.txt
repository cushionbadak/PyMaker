Natural Text
This is related to other question I had, which left with no answer...I trying to understand what's going on under the hood of the Python binding to libclang, and having really hard-time doing so.I've read TONs of articles about both  and  in Python, in order to understand how the CachedProperty class in clang/cindex.py works, but still can't get all the pieces together.The most related texts I've seen is one SO answer,  and this code recipe in ActiveState. This helps me a bit, but - as I mentioned - I'm still not there.So, let's cut to the chase:I want to understand why am I getting  on creating CIndex. I will post here only the relevant code (cindex.py is 3646 lines long..), and I hope I don't miss anything that is relevant to me.My code has only one relevant line, which is:This reffers to line 2291 in cindex.py, which yields:From now on, there's a series of function calls, which I can't explain why and WTH did they come from. I'll list the code and  output along the questions that relevant to each part:(Important thing to notice ahead: conf.lib defined like this:)CachedProperty code: output:Why the next call after is to method? What about the ?If the  method isn't get called, how comes that self.wrapped hasvalue? output:Where  should return value to? Where the call for  method come from?MOST CRITICAL PART, for meThis is the creation of , which class Index inherits from.But - where there's any call to  with one parameter? Is this is the one that  returning?Where is this number (40998256) coming from? I'm getting the same number over and over again. As far as I understand, it should be just a number, but a  and that's why the assertion failed.To sum it up, the best for me will be step-by-step guidance of the functions invocation over here, cause I'm felling a little lost in all this...
The  object is a descriptor object; the  method is called automatically whenever Python tries to access an attribute on an instance that is only available on the class and has a  method.Using  as a decorator means it is called and an instance of  is created that replaces the original function object on the  class. It is the  line that causes  to be called, and the instance ends up on the  class as . Remember, the syntaxis essentially executed asso this creates an instance of  with  passed in as the  argument, and then  is set to that object.You can see this in the debugger; one step up you could inspect :In the rest of the codebase  is an instance of the  class. At first, that instance has no  name in the  object, so the instance has no such attribute:So trying to get  has to fall back to the class, where Python finds the  attribute, and this is a descriptor object. Instead of using  directly, Python returns the result of calling  in that case.The  method then executes the original function (referenced by ) and stores that in . So future access to  will find that result, and the descriptor on the class is not going to be used after that.The  method is called to satisfy the next attribute in the  expression;  returns a dynamically loaded library from  (via ), and that specific object type is handled by the Python ctypes libary. It translates attributes to specific C calls for you; here that's the  method; see Accessing functions from loaded dlls.Once the call to  completes, that resulting object is indeed passed to ; the  class itself has no  method, but the base class  does.Whatever that return value is, it has a representation that looks like an integer number. However, it almost certainly is not an .  You can see what type of object that is by using , see what attributes it has with , etc. I'm pretty certain it is a  data type representing a  value (it is a Python object that proxies for the real C value in memory); it'll represent as an integer:Represents the C  type. The value is represented as integer. The constructor accepts an optional integer initializer.The rest of the  Python code will just pass this value back to more C calls proxied by .


Answer URL
https://docs.python.org/3/howto/descriptor.html
https://docs.python.org/3/library/ctypes.html#ctypes.CDLL
https://docs.python.org/3/library/ctypes.html
https://docs.python.org/3/library/ctypes.html#accessing-functions-from-loaded-dlls
https://docs.python.org/3/library/ctypes.html#ctypes.c_void_p
