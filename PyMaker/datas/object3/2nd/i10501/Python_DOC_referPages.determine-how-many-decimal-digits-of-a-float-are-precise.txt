Natural Text
In my real-life problem, I multiply the size of a widget, with a  which can be anything from  to . Assuming the minimum size of a widget is  and the max size is , on which digit should I expect the error to occur, when I multiply ? For example* on  the error occurs on the.. .. 18th decimal digit.On the other hand, the error below occurs on the 14th decimal Questions:   Is there a way to determine on which exactly decimal digit the error will occur? Is there a difference between Python 2 and Python 3?Using decimals instead of floats is not a option, and that both  and  are provided by the user.*  I used  since  is displayed as..  in the console, but I think this is related to how it's printed, not how it's stored. 
If we assume that the size of the widget is stored exactly, then there are 2 sources of error: the conversion of  from decimal -> binary, and the multiplication. In Python, these should both be correctly rounded to nearest, so each should have relative error of half an ulp (unit in the last place). Since the second operation is a multiplication we can just add the bounds to get a total relative error which will be bounded 1 ulp, or 2-53.Converting to decimal:this means you should be accurate to 15 significant figures.There shouldn't be any difference between Python 2 and 3: Python has long been fairly strict about floating point behaviour, the only change I'm aware of is the behaviour of the  function, which isn't used here.
To answer the decimal to double-precision floating-point conversion part of your question...The conversion of decimal fractions between 0.0 and 0.1 will be good to 15-16 decimal digits (Note: you start counting at the first non-zero digit after the point.)0.1 = 0.1000000000000000055511151231257827021181583404541015625 is good to 16 digits (rounded to 17 it is 0.10000000000000001; rounded to 16 it is 0.1).0.2 = 0.200000000000000011102230246251565404236316680908203125 is also good to 16 digits.(An example only good to 15 digits:0.81 = 0.810000000000000053290705182007513940334320068359375)
I'd recommend you take a read to pep485Using  operator to compare floating-point values is not the right way to go, instead consider using math.isclose or cmath.isclose, here's a little example using your values:As you can see, I'm explicitly casting to float in python 2.x and using the function provided in the documentation, with python 3.x I just use directly your values and the provided function from math module.


Answer URL
https://docs.python.org/3/whatsnew/3.5.html#pep-485-a-function-for-testing-approximate-equality
https://docs.python.org/3/library/math.html#math.isclose
https://docs.python.org/3/library/cmath.html#cmath.isclose
https://docs.python.org/3/tutorial/floatingpoint.html
