Natural Text
Is there a method like ? The only solution I have found so far is to callBut I am not sure how fool-proof this is.
Checking for  works on sequence types, but it would fail on e.g. strings in Python 2. I would like to know the right answer too, until then, here is one possibility (which would work on strings, too):The  built-in checks for the  method or in the case of strings the  method.Another general pythonic approach is to assume an iterable, then fail gracefully if it does not work on the given object. The Python glossary:Pythonic programming style that determines an object's type by inspection of its method or attribute signature rather than by explicit relationship to some type object ("If it looks like a duck and quacks like a duck, it must be a duck.") By emphasizing interfaces rather than specific types, well-designed code improves its flexibility by allowing polymorphic substitution. Duck-typing avoids tests using type() or isinstance(). Instead, it typically employs the EAFP (Easier to Ask Forgiveness than Permission) style of programming....The  module provides some abstract base classes, which allow to ask classes or instances if they provide particular functionality, for example:However, this does not check for classes that are iterable through .
Duck typingType checkingUse the Abstract Base Classes. They need at least Python 2.6 and work only for new-style classes.However,  is a bit more reliable as described by the documentation:Checking  detects classes that are  registered as Iterable or that have an  method, but  it does not detect classes that iterate with the   method. The only reliable way to determine whether an object  is iterable is to call .
I'd like to shed a little bit more light on the interplay of ,  and  and what happens behind the curtains. Armed with that knowledge, you will be able to understand why the best you can do isI will list the facts first and then follow up with a quick reminder of what happens when you employ a  loop in python, followed by a discussion to illustrate the facts.FactsYou can get an iterator from any object  by calling  if at least one of the following conditions holds true: a)  has an  method which returns an iterator object. An iterator is any object with an  and a  (Python 2: ) method. b)  has a  method.Checking for an instance of  or , or checking for theattribute  is not enough.If an object  implements only , but not ,  will constructan iterator that tries to fetch items from  by integer index, starting at index 0. The iterator will catch any  (but no other errors) that is raised and then raises  itself.In the most general sense, there's no way to check whether the iterator returned by  is sane other than to try it out.If an object  implements , the  function will make surethat the object returned by  is an iterator. There is no sanity checkif an object only implements . wins. If an object  implements both  and ,  will call .If you want to make your own objects iterable, always implement the  method. loopsIn order to follow along, you need an understanding of what happens when you employ a  loop in Python. Feel free to skip right to the next section if you already know.When you use  for some iterable object , Python calls  and expects an iterator object as the return value. An iterator is any object which implements a  (or  in Python 2) method and an  method. By convention, the  method of an iterator should return the object itself (i.e. ). Python then calls  on the iterator until  is raised. All of this happens implicitly, but the following demonstration makes it visible:Iteration over a :Discussion and illustrationsOn point 1 and 2: getting an iterator and unreliable checksConsider the following class:Calling  with an instance of  will return an iterator without any problems because  implements .However, it is important to note that  does not have the  attribute and is not considered an instance of  or :This is why Fluent Python by Luciano Ramalho recommends calling  and handling the potential  as the most accurate way to check whether an object is iterable. Quoting directly from the book:As of Python 3.4, the most accurate way to check whether an object  is iterable is to call  and handle a  exception if it isn’t. This is more accurate than using  , because  also considers the legacy  method, while the  ABC does not.On point 3: Iterating over objects which only provide , but not Iterating over an instance of  works as expected: Pythonconstructs an iterator that tries to fetch items by index, starting at zero, until an  is raised. The demo object's  method simply returns the  which was supplied as the argument to  by the iterator returned by .Note that the iterator raises  when it cannot return the next item and that the  which is raised for  is handled internally. This is why looping over a  with a  loop works as expected:Here's another example in order to drive home the concept of how the iterator returned by  tries to access items by index.  does not inherit from , which means instances won't have an  method.Note that calls to  are delegated to  for which the square bracket notation is simply a shorthand.On point 4 and 5:  checks for an iterator when it calls :When  is called for an object ,  will make sure that the return value of , if the method is present, is an iterator. This means that the returned objectmust implement  (or  in Python 2) and .  cannot perform any sanity checks for objects which onlyprovide , because it has no way to check whether the items of the object are accessible by integer index.Note that constructing an iterator from  instances fails immediately, while constructing an iterator from  succeeds, but will throw an Exception on the first call to .On point 6:  winsThis one is straightforward. If an object implements  and ,  will call . Consider the following classand the output when looping over an instance:On point 7: your iterable classes should implement You might ask yourself why most builtin sequences like  implement an  method when  would be sufficient.After all, iteration over instances of the class above, which delegates calls to  to  (using the square bracket notation), will work fine:The reasons your custom iterables should implement  are as follows:If you implement , instances will be considered iterables, and  will return .If the the object returned by  is not an iterator,  will fail immediately and raise a .The special handling of  exists for backwards compatibility reasons. Quoting again from Fluent Python:That is why any Python sequence is iterable: they all implement  . In fact,  the standard sequences also implement , and yours should too, because the  special handling of  exists for backward compatibility reasons and may be  gone in the future (although it is not deprecated as I write this).
This isn't sufficient: the object returned by  must implement the iteration protocol (i.e.  method). See the relevant section in the documentation.In Python, a good practice is to "try and see" instead of "checking".
Don't run checks to see if your duck really is a duck to see if it is iterable or not, treat it as if it was and complain if it wasn't.
In Python <= 2.5, you can't and shouldn't - iterable was an "informal" interface.But since Python 2.6 and 3.0 you can leverage the new ABC (abstract base class) infrastructure along with some builtin ABCs which are available in the collections module:Now, whether this is desirable or actually works, is just a matter of conventions. As you can see, you can register a non-iterable object as Iterable - and it will raise an exception at runtime. Hence, isinstance acquires a "new" meaning - it just checks for "declared" type compatibility, which is a good way to go in Python.On the other hand, if your object does not satisfy the interface you need, what are you going to do? Take the following example:If the object doesn't satisfy what you expect, you just throw a TypeError, but if the proper ABC has been registered, your check is unuseful. On the contrary, if the  method is available Python will automatically recognize object of that class as being Iterable.So, if you just expect an iterable, iterate over it and forget it. On the other hand, if you need to do different things depending on input type, you might find the ABC infrastructure pretty useful.
The best solution I've found so far:which basically checks if the object implements the  operator.Advantages (none of the other solutions has all three):it is an expression (works as a lambda, as opposed to the try...except variant)it is (should be) implemented by all iterables, including strings (as opposed to )works on any Python >= 2.5Notes: the Python philosophy of "ask for forgiveness, not permission" doesn't work well when e.g. in a list you have both iterables and non-iterables and you need to treat each element differently according to it's type (treating iterables on try and non-iterables on except would work, but it would look butt-ugly and misleading)solutions to this problem which attempt to actually iterate over the object (e.g. [x for x in obj]) to check if it's iterable may induce significant performance penalties for large iterables (especially if you just need the first few elements of the iterable, for example) and should be avoided
I found a nice solution here:
You could try this:If we can make a generator that iterates over it (but never use the generator so it doesn't take up space), it's iterable. Seems like a "duh" kind of thing. Why do you need to determine if a variable is iterable in the first place?
According to the Python 2 Glossary, iterables areall sequence types (such as , , and ) and some non-sequence types like  and  and objects of any classes you define with an  or  method. Iterables can be used in a for loop and in many other places where a sequence is needed (zip(), map(), ...). When an iterable object is passed as an argument to the built-in function iter(), it returns an iterator for the object.Of course, given the general coding style for Python based on the fact that it's “Easier to ask for forgiveness than permission.”, the general expectation is to useBut if you need to check it explicitly, you can test for an iterable by . You need to check for both, because s don't have an  method (at least not in Python 2, in Python 3 they do) and because  objects don't have a  method.
I often find convenient, inside my scripts, to define an  function.(Now incorporates Alfe's suggested simplification):so you can test if any object is iterable in the very readable formas you would do with the functionEDIT: if you have numpy installed, you can simply do: from , which is simply something likeIf you do not have numpy, you can simply implement this code, or the one above.
pandas has a built-in function like that:
Since Python 3.5 you can use the typing module from the standard library for type related things:
This will say yes to all manner of iterable objects, but it will say no to strings in Python 2. (That's what I want for example when a recursive function could take a string or a container of strings.  In that situation, asking forgiveness may lead to obfuscode, and it's better to ask permission first.)Many other strategies here will say yes to strings. Use them if that's what you want.Note: is_iterable() will say yes to strings of type  and . objects in Python 3 are iterable  There is no such type in Python 2. objects in Python 2 and 3 are iterable The O.P.  approach will say yes to strings in Python 3 and no in Python 2 (no matter whether  or  or ). Thanks to @LuisMasuelli for noticing it will also let you down on a buggy .
The easiest way, respecting the Python's duck typing, is to catch the error (Python knows perfectly what does it expect from an object to become an iterator):Notes:It is irrelevant the distinction whether the object is not iterable, or a buggy  has been implemented, if the exception type is the same: anyway you will not be able to iterate the object.I think I understand your concern: How does  exists as a check if I could also rely on duck typing to raise an  if  is not defined for my object, but that's not the case for iterable checking?I don't know the answer, but you can either implement the function I (and other users) gave, or just catch the exception in your code (your implementation in that part will be like the function I wrote - just ensure you isolate the iterator creation from the rest of the code so you can capture the exception and distinguish it from another .
The  func at the following code returns  if object is iterable. if it's not iterable returns example
Instead of checking for the  attribute, you could check for the  attribute, which is implemented by every python builtin iterable, including strings. None-iterable objects would not implement this for obvious reasons. However, it does not catch user-defined iterables that do not implement it, nor do generator expressions, which  can deal with. However, this can be done in a line, and adding a simple  expression checking for generators would fix this problem. (Note that writing  would throw a . Refer to this answer instead.)You can use GeneratorType from types:--- accepted answer by utdemir(This makes it useful for checking if you can call  on the object though.)
It's always eluded me as to why python has  but not ...surely it's easier to do  even if it is slower.Since just about every other answer recommends using /, where testing for exceptions is generally considered bad practice among any language, here's an implementation of  I've grown more fond of and use often:For python 2's sake, I'll use a lambda just for that extra performance boost...(in python 3 it doesn't matter what you use for defining the function,  has roughly the same speed as )Note that this function executes faster for objects with  since it doesn't test for .Most iterable objects should rely on  where special-case objects fall back to , though either is required for an object to be iterable.(and since this is standard, it affects C objects as well)
Not really "correct" but can serve as quick check of most common types like strings, tuples, floats, etc...
Apart from regular try and except, you could run help.help would give all the methods that could be run on that object(it could be any object and may not be a list as per example), which is temp in this case. Note: This would be something you would manually do.


Answer URL
https://docs.python.org/3/library/typing.html
