Natural Text
I'm trying to use 's  function to divide out work simultaneously. When I use the following code, it works fine:However, when I use it in a more object-oriented approach, it doesn't work. The error message it gives is:This occurs when the following is my main program:and the following is my  class:Anyone know what the problem could be, or an easy way around it?
The problem is that multiprocessing must pickle things to sling them among processes, and bound methods are not picklable.  The workaround (whether you consider it "easy" or not;-) is to add the infrastructure to your program to allow such methods to be pickled, registering it with the copy_reg standard library method.For example, Steven Bethard's contribution to this thread (towards the end of the thread) shows one perfectly workable approach to allow method pickling/unpickling via .
All of these solutions are ugly because multiprocessing and pickling is broken and limited unless you jump outside the standard library.If you use a fork of  called , you can directly use classes and class methods in multiprocessing's  functions.  This is because  is used instead of  or , and  can serialize almost anything in python. also provides an asynchronous map function… and it can  functions with multiple arguments (e.g. )See:What can multiprocessing and dill do together?and:http://matthewrocklin.com/blog/work/2013/12/05/Parallelism-and-Serialization/And just to be explicit, you can do exactly want you wanted to do in the first place, and you can do it from the interpreter, if you wanted to.Get the code here: https://github.com/uqfoundation/pathos
You could also define a  method inside your , which calls  and then pass an instance of  to the pool. This object is pickleable and it works fine (for me)...
Some limitations though to Steven Bethard's solution :When you register your class method as a function, the destructor of your class is surprisingly called every time your method processing is finished. So if you have 1 instance of your class that calls n times its method, members may disappear between 2 runs and you may get a message  (e.g. open member file) or  (which means than the lifetime of a member object I used was shorter than what I thought). I got this when dealing with n greater than the pool size. Here is a short example :Output:The  method is not so equivalent, because [None,...] are read from the results :So none of both methods is satisfying...
There's another short-cut you can use, although it can be inefficient depending on what's in your class instances.As everyone has said the problem is that the  code has to pickle the things that it sends to the sub-processes it has started, and the pickler doesn't do instance-methods.However, instead of sending the instance-method, you can send the actual class instance, plus the name of the function to call, to an ordinary function that then uses  to call the instance-method, thus creating the bound method in the  subprocess.  This is similar to defining a  method except that you can call more than one member function.Stealing @EricH.'s code from his answer and annotating it a bit (I retyped it hence all the name changes and such, for some reason this seemed easier than cut-and-paste :-) ) for illustration of all the magic:The output shows that, indeed, the constructor is called once (in the original pid) and the destructor is called 9 times (once for each copy made = 2 or 3 times per pool-worker-process as needed, plus once in the original process).  This is often OK, as in this case, since the default pickler makes a copy of the entire instance and (semi-) secretly re-populates it—in this case, doing:—that's why even though the destructor is called eight times in the three worker processes, it counts down from 1 to 0 each time—but of course you can still get into trouble this way.  If necessary, you can provide your own :in this case for instance.
You could also define a  method inside your , which calls  and then pass an instance of  to the pool. This object is pickleable and it works fine (for me)...
The solution from parisjohn above works fine with me. Plus the code looks clean and easy to understand. In my case there are a few functions to call using Pool, so I modified parisjohn's code a bit below. I made call to be able to call several functions, and the function names are passed in the argument dict from :
A potentially trivial solution to this is to switch to using . This is a thread based implementation of the multiprocessing interface that doesn't seem to have this problem in Python 2.7. I don't have a lot of experience here, but this quick import change allowed me to call apply_async on a class method.A few good resources on :https://docs.python.org/2/library/multiprocessing.html#module-multiprocessing.dummyhttp://chriskiehl.com/article/parallelism-in-one-line/
In this simple case, where  is not inheriting any data from the class and not attaching anything to the class, a possible solution would be to separate out , so it can be pickled:
Why not to use separate func?
Update: as of the day of this writing, namedTuples are pickable (starting with python 2.7) The issue here is the child processes aren't able to import the class of the object -in this case, the class P-, in the case of a multi-model project the Class P should be importable anywhere the child process get useda quick workaround is to make it importable by affecting it to globals()


Answer URL
https://docs.python.org/3/library/copyreg.html?highlight=copyreg
