Natural Text
I need to measure the time certain parts of my program take (not for debugging but as a feature in the output). Accuracy is important because the total time will be a fraction of a second.I was going to use the time module when I came across timeit, which claims to avoid a number of common traps for measuring execution times. Unfortunately it has an awful interface, taking a string as input which it then eval's. So, do I need to use this module to measure time accurately, or will time suffice? And what are the pitfalls it refers to?Thanks
According to the Python documentation it has to do with the accuracy of the time function in different operating systems:The default timer function is platform  dependent. On Windows, time.clock()  has microsecond granularity but  time.time()â€˜s granularity is 1/60th of  a second; on Unix, time.clock() has  1/100th of a second granularity and  time.time() is much more precise. On  either platform, the default timer  functions measure wall clock time, not  the CPU time. This means that other  processes running on the same computer  may interfere with the timing ... On Unix, you can  use time.clock() to measure CPU time.To pull directly from 's code:In addition, it deals directly with setting up the runtime code for you.  If you use time you have to do it yourself.  This, of course saves you timeTimeit's setup:Edit, Python 3 only:Since Python 3.3 you can use  (system-wide timing) or  (process-wide timing), just the way you used to use :The new function  will not include time elapsed during sleep.
You could build a timing context (see PEP 343) to measure blocks of code pretty easily.
The timeit module looks like it's designed for doing performance testing of algorithms, rather than as simple monitoring of an application.  Your best option is probably to use the time module, call  at the beginning and end of the segment you're interested in, and subtract the two numbers.  Be aware that the number you get may have many more decimal places than the actual resolution of the system timer.
Have you reviewed the functionality provided profile or cProfile?http://docs.python.org/library/profile.htmlThis provides much more detailed information than just printing the time before and after a function call.  Maybe worth a look...
I was annoyed too by the awful interface of timeit so i made a library for this, check it out its trivial to use https://github.com/Karlheinzniebuhr/pythonbenchmark 
The documentation also mentions that time.clock() and time.time() have different resolution depending on platform.  On Unix, time.clock() measures CPU time as opposed to wall clock time.timeit also disables garbage collection when running the tests, which is probably not what you want for production code.I find that time.time() suffices for most purposes.
From Python 2.6 on timeit is not limited to input string anymore. Citing the documentation:Changed in version 2.6: The stmt and setup parameters can now also take objects that are callable without arguments. This will embed calls to them in a timer function that will then be executed by timeit(). Note that the timing overhead is a little larger in this case because of the extra function calls.


Answer URL
