Natural Text
I'm experimenting with  vs  in Python 2.6. I don't understand the reason for some differences.A  iterator returns strings:Gives:But a  iterator returns s:Gives:Why the difference?I'd like to write code that will translate well into Python 3. So, is the situation the same in Python 3?
In Python 2.6 bytes is merely an alias for str.This "pseudo type" was introduced to [partially] prepare programs [and programmers!] to be converted/compatible with Python 3.0 where there is a strict distinction of semantics and use for str (which are systematically unicode) and bytes (which are arrays of octets, for storing data, but not text)Similarly the b prefix for string literals is ineffective in 2.6, but it is a useful marker in the program, which flags explicitly the intent of the programmer to have the string as a data string rather than a text string. This info can then be used by the 2to3 converter or similar utilities when the program is ported to Py3k.You may want to check this SO Question for additional info.
For (at least) Python 3.7According to the docs: objects are immutable sequences of single bytes objects are a mutable counterpart to bytes objects.And that's pretty much it as far as  vs . In fact, they're fairly interchangeable and designed to flexible enough to be mixed in operations without throwing errors. In fact, there is a whole section in the official documentation dedicated to showing the similarities between the  and  apis.Some clues as to why from the docs:Since many major binary protocols are based on the ASCII text encoding, bytes objects offer several methods that are only valid when working with ASCII compatible data and are closely related to string objects in a variety of other ways.
I am not sure since which version, but  is actually a , which you can see if you do  -> . is a mutable array of bytes, one constructor of which takes a string.
I tried it on Python 3.0.In Python 3.0, a  iterator returns s, not strings as Python 2.6 did:Gives:A  iterator also returns s.
TL;DRpython2.6+  = python2.6+  = python3.x  != python3.x python2.6+  = python3.x python2.x  = python3.x Long Answer and  have changed meaning in python since python 3.x. First to answer your question shortly, in python 2.6  is an immutable array of bytes (8-bits or octets). So the type of each  is simply , which is the same as  in python 2.6+ (However, this is not the case in python 3.x) is again a mutable array of bytes. But when you ask its type, it's an , because python represents each element of  as an integer in range 0-255 (all possible values for an 8-bit integer). However, an element of  array is represented as an ASCII value of that byte.For example, consider in Python 2.6+Now python 3.x is an entirely different story. As you might have suspected, it is weird why an  literal would mean a  in python2.6+. Well this answer explains thatIn Python 3.x, an  is a Unicode text (which was previously just an array of bytes, note that Unicode and bytes are two completely different things).  is a mutable array of bytes while  is an immutable array of bytes. They both have almost the same functions. Now if I run the above same code again in python 3.x, here is the result. In Python 3.x and  are the same things in python 3.x, except for there mutability. What happened to  you might ask?  in python 3 got converted to what  was in python 2, and  type was subsequently removed from python 3 as it was redundant.I'd like to write code that will translate well into Python 3. So, is the situation the same in Python 3?It depends on what you are trying to do. Are you dealing with bytes or are you dealing with ASCII representation of bytes?If you are dealing with bytes, then my advice is to use  in Python 2, which is the same in python 3. But you loose immutability, if that matter to you.If you are dealing with ASCII or text, then represent your string as  in Python 2, which has the same meaning in python 3.  has special meaning in Python 2, which instructs python 2 to treat a string literal as  type. 'u' in python 3 as no meaning, because all string literal in Python 3 are Unicode by default (which is confusingly called  type in python 3, and  type in python 2). 


Answer URL
https://docs.python.org/3/library/stdtypes.html
https://docs.python.org/3/library/stdtypes.html#bytes-and-bytearray-operations
https://docs.python.org/3/library/stdtypes.html#bytes-and-bytearray-operations
https://docs.python.org/3/library/stdtypes.html#bytearray-objects
