Natural Text
Despite reading up on it, I still dont quite understand how  works.  What would be a simple explaination?  I've seen . I don't see how this works or the steps on how this works.  
An iterator needs to define two methods:  and  ( in python2). Usually, the object itself defines the  or  method, so it just returns itself as the iterator. This creates an iterable that is also itself an iterator. These methods are used by  and  statements.Python 3 docs: docs.python.org/3/library/stdtypes.html#iterator-typesPython 2 docs: docs.python.org/2/library/stdtypes.html#iterator-types
As simply as I can put it: defines a method on a class which will return an iterator (an object that successively yields the next item contained by your object).The iterator object that  returns can be pretty much any object, as long as it defines a  method.The  method will be called by statements like  to yield the next item, and  should raise the  exception when there are no more items.What's great about this is it lets you define how your object is iterated, and  provides a common interface that every other python function knows how to work with.
The specs for  are: it returns an iterator.  So, if  is an iterator,  is clearly appropriate."Being an iterator" means "having a  method" (in Python 3; in Python 2, the name of the method in question is unfortunately plain  instead, clearly a name design glitch for a special method).In Python 2.6 and higher, the best way to implement an iterator is generally to use the appropriate abstract base class from the  standard library module -- in Python 2.6, the code might be (remember to call the method  instead in Python 3):an instance of this class will return infinitely many copies of  when iterated on (like ) so the loop must be terminated otherwise. The point is that subclassing  adds the right  method on your behalf -- not a big deal here, but a good general principle (avoid repetitive, boilerplate code like iterators' standard one-line  -- in repetition, there's no added value and a lot of subtracted value!-).
A class supporting the __iter__ method will return an iterator object instance: an object supporting the next() method.  This object will be usuable in the statements "for" and "in".
In Python, an iterator is any object that supports the iterator protocol. Part of that protocol is that the object must have an  method that returns the iterator object. I suppose this gives you some flexibility so that an object can pass on the iterator responsibilities to an internal class, or create some special object. In any case, the  method usually has only one line and that line is often simply The other part of the protocol is the  method, and this is where the real work is done. This method has to figure out or create or get the next thing, and return it. It may need to keep track of where it is so that the next time it is called, it really does return the next thing.Once you have an object that returns the next thing in a sequence, you can collapse a for loop that looks like this:into this:Notice that there is nowhere where we have code that gets the next value of i because range(10) is an object that FOLLOWS the iterator protocol, and the list comprehension is a construct that USES the iterator protocol.You can also USE the iterator protocol directly. For instance, when writing scripts to process CSV files, I often write this:I am using the iterator directly by calling  to skip the header row, then using it indirectly via the builtin  operator in the  statement.


Answer URL
https://docs.python.org/3/library/stdtypes.html#iterator-types
