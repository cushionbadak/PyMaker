Natural Text
Python imports drive me crazy (my experience with python imports sometime doesn't correspond at all to idiom 'Explicit is better than implicit' :( ):I get: works, but i want to use  because i want to make  portable for my other applications, that's why i want to use relative paths.I am using python 3.I need circular imports. A function in module1 asserts that one of its parameter is instance of a class defined in module2 and viceversa.In other words: contains . I want to get a reference to it in form , but it tries to get a name, not a package like in case  (which works fine). I tried  - but that's a syntax error.Also,  in  works fine, but  in  doesn't work...UPDATE:This hack works (but i am looking for the 'official' way):
A better solution for your problem is to put package1 in it's own separate package. Of course then it can't import package2, but then again if it is reusable, why would it?
Circular imports should be generally avoided, see also this answer to a related question, or this article on effbot.org.In this case the problem is that you import  where  is the current package. So all your  imports go through the package’s .You can make your problem a bit more visible, if you explicitely import your modules in the  and give them another name (and adjust the other imports to use those names of course):Now when you are importing  in , the package first initializes  and comes to the  line. At that point, there is no  known in  so you get an import error. If you switch the import statements in  around (so you load  first), then in  it finds the  line, which fails for the same reason as before.If you don’t explicitely import the modules in  something similar still happens in the background. The difference is that you get a less flat structure (as the imports are no longer started from the package only). As such both  and  get “started” and you get the respective initialization prints.To make it work, you could do an absolute import in . That way you could avoid that the package needs to resolve everything first, and make it reuse the import from  (as it has the same import path).Or even better, you get rid of the circular import at all. It’s generally a sign that your application structure is not so good, if you have circular references.(I hope my explanation makes any sense, I already had difficulties writing it, but the general idea should be clear, I hope…)editIn response to your update; what you are doing there is that you use the full package name to get the reference to the module. This is equivalent (but much more complicated) to the first possible option to make it work; you use an absolute import using the same import path as in .
Your update emulates what the absolute import does:  if you do it while  being imported. If you'd like to use a dynamic parent package name then to import  in the :I need circular imports. A function in module1 asserts that one of its  parameter is instance of a class defined in module2 and viceversa.You could move one the classes to a separate module to resolve the circular dependency or make the import at a function level if you don't want to use absolute imports.OutputAnother option that might be simpler than refactoring out  is to merge  into a single .  make the imports from  in this case.
Works too.
The accepted answer to Circular import dependency in Python makes a good point:If a depends on c and c depends on a, aren't they actually the same unit then?You should really examine why you have split a and c into two packages, because either you have some code you should split off into another package (to make them both depend on that new package, but not each other), or you should merge them into one package.  — Lasse V. Karlsen♦Maybe you should consider placing them in the same module. :)
I ran into this same issue today, and it seems this is indeed broken in python3.4, but works in python3.5.The changelog has an entry:Circular imports involving relative imports are now supported. (Contributed by Brett Cannon and Antoine Pitrou in bpo-17636).Looking through the bugreport, it seems that this not so much a buf fixed, as well as a new feature in the way imports work. Referring to poke's answer above, he shows that  means to load  and get  from it (possibly from the implicitly loaded list of submodules). Since python3.5,  will do the same, but if  is not available as an attribute, it will fall back to looking through the lists of loaded modules () to see if it is already present there, which fixes this particular case. I'm not 100% sure I properly presented how this works, though.
Make sure your  is a folder. Create a class in  -- say . Include your logic in a method under  -- say . Now, write the following code - This was my way of resolving it. To summarize, your root directory is  so write your  statement using  notations, e.g.  or .


Answer URL
https://docs.python.org/3/whatsnew/3.5.html
