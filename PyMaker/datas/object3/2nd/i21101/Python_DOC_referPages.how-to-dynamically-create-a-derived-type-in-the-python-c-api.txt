Natural Text
Assume we have the type  as defined in the tutorial on writing C extension modules for Python.  Now we want to create a derived type, overwriting only the  method of .Currently I use the following approach (error checking stripped for readability):This works, but I'm not sure if it is The Right Way To Do It.  I would have expected that I have to set the  flag, too, because I dynamically allocate the type object on the heap, but doing so leads to a segfault in the interpreter.I also thought about explicitly calling  using  or similar, but I discarded the idea.  I would need to wrap the function  in a Python function object and create a dictionary mapping  to this function object, which seems silly.What is the best way to go about this?  Is my approach correct? Is there an interface function I missed?UpdateThere are two threads on a related topic on the python-dev mailing list (1) (2).  From these threads and a few experiments I deduce that I shouldn't set  unless the type is allocated by a call to .  There are different recommendations in these threads whether it is better to allocate the type manually or to call .  I'd be happy with the latter if only I knew what the recommended way to wrap the C function that is supposed to go in the  slot is.  For regular methods this step would be easy -- I could just use  to get a suitable wrapper object. I don't know how to create such a wrapper object for my  method, though -- maybe I need the undocumented function  to create such a wrapper object.
I encountered the same problem when I was modifying an extension to be compatible with Python 3, and found this page when I was trying to solve it.I did eventually solve it by reading the source code for the Python interpreter, PEP 0384 and the documentation for the C-API.Setting the  flag tells the interpreter to recast your  as , which contains additional members that must also be allocated. At some point the interpreter attempts to refer to these extra members and, if you leave them unallocated, it will cause a segfault.Python 3.2 introduced the C structures  and  and the C function  that simplify the creation of dynamic types. In a nutshell, you use  and  to specify the  members of the  and then call  to do the dirty work of allocating and initialising the memory.From PEP 0384, we have:(The above isn't a literal copy from PEP 0384, which also includes  as a member of . But that member doesn't appear in the source code.)To use these in the original example, assume we have a C structure, , that extends the C structure for the base class . Then we would have:This should do everything in the original code, including calling , plus what is necessary for creating a dynamic type, including setting , and allocating and initialising the extra memory for a .I hope that's helpful.
I apologize up front if this answer is terrible, but you can find an implementation of this idea in PythonQt, in particular I think the following files might be useful references:PythonQtClassInfo.cppPythonQtClassInfo.hPythonQtClassWrapper.cppPythonQtClassWrapper.hThis fragment from PythonQtClassWrapper_init jumps out at me as being somewhat interesting:It's worth noting that PythonQt does use a wrapper generator, so it's not exactly in line with what you're asking for, but personally I think trying to outsmart the vtable isn't the most optimal design. Basically, there are many different C++ wrapper generators for Python and people use them for a good reason - they're documented, there are examples floating around in search results and on stack overflow. If you hand roll a solution for this that nobody's seen before, it'll be that much harder for them to debug if they run into problems. Even if it's closed-source, the next guy who has to maintain it will be scratching his head and you'll have to explain it to every new person who comes along.Once you get a code generator working, all you need to do is maintain the underlying C++ code, you don't have to update or modify your extension code by hand. (Which is probably not too far away from the tempting solution you went with)The proposed solution is an example of breaking the type-safety that the newly introduced PyCapsule provides a bit more protection against (when used as directed).So, while its possible it might not be the best long term choice to implement derived/subclasses this way, but rather wrap the code and let the vtable do what it does best and when the new guy has questions you can just point him at the documentation for whatever solution fits best.This is just my opinion though. :D
One way to try and understand how to do this is to create a version of it using SWIG.  See what it produces and see if it matches or is done a different way.  From what I can tell the people who have been writing SWIG have an in depth understanding of extending Python.  Can't hurt to see how they do things at any rate. It may help you understand this problem.


Answer URL
https://docs.python.org/3/c-api/type.html?highlight=pytype_fromspec
