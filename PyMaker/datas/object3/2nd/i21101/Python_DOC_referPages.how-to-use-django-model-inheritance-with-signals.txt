Natural Text
I have a few model inheritance levels in Django:There are many different models inherited from  and . I want to create a signal, which would update an  field for parent work, when attachment is created. It would be logical, to think that signal made for parent sender () would run for all inherited models too, but it does not. Here is my code:Is there a way to make this signal work for all models inherited from ?Python 2.7, Django 1.4 pre-alphaP.S. I've tried one of the solutions I found on the net, but it did not work for me.
You could try something like:(Disclaimer: I have not tested the above)
You could register the connection handler without  specified. And filter the needed models inside it.Ref: https://groups.google.com/d/msg/django-users/E_u9pHIkiI0/YgzA1p8XaSMJ
The simplest solution is to not restrict on the , but to check in the signal handler whether the respective instance is a subclass:However, this may incur a significant performance overhead as every time any model is saved, the above function is called.I think I've found the most Django-way of doing this: Recent versions of Django suggest to connect signal handlers in a file called . Here's the necessary wiring code:your_app/__init__.py:your_app/apps.py:your_app/signals.py:I think this works for all subclasses, because they will all be loaded by the time  is called (and thus  is imported).
have a nice day!
Michael Herrmann's solution is definitively the most Django-way of doing this.And yes it works for all subclasses as they are loaded at the ready() call.I would like to contribute with the documentation references : In practice, signal handlers are usually defined in a signals submodule of the application they relate to. Signal receivers are connected in the ready() method of your application configuration class. If you’re using the receiver() decorator, simply import the signals submodule inside ready().https://docs.djangoproject.com/en/dev/topics/signals/#connecting-receiver-functionsAnd add a warning :The ready() method may be executed more than once during testing, so you may want to guard your signals from duplication, especially if you’re planning to send them within tests.https://docs.djangoproject.com/en/dev/topics/signals/#connecting-receiver-functionsSo you might want to prevent duplicate signals with a dispatch_uid parameter on the connect function.In this context I'll do : https://docs.djangoproject.com/en/dev/topics/signals/#preventing-duplicate-signals
This solution resolves the problem when not all modules imported into memory.  
It's also possible to use content types to discover subclasses - assuming you have the base class and subclasses packaged in the same app. Something like this would work:
I just did this using python's (relatively) new  method:This requires django 2.1 and python 3.6 or better. Note that the  line seems to be required when working with the django model and associated metaclass even though it's not required according to the official python docs.


Answer URL
https://docs.python.org/3/reference/datamodel.html#customizing-class-creation
