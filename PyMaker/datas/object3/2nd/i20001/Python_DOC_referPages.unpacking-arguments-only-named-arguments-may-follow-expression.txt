Natural Text
The following works beautifully in Python:The elements of  get unpacked as if you had called it like  and it returns . Wonderful!But I can't unpack the elements of  into the first two arguments:Instead of calling that like , I get "SyntaxError: only named arguments may follow *expression".I'm just wondering why it has to be that way and if there's any clever trick I might not be aware of for unpacking arrays into arbitrary parts of argument lists without resorting to temporary variables.
As Raymond Hettinger's answer points out, this may change has changed in Python 3 and here is a related proposal, which has been accepted.Especially related to the current question, here's one of the possible changes to that proposal that was discussed:Only allow a starred expression as the last item in the exprlist. This would simplify the   unpacking code a bit and allow for the starred expression to be assigned an iterator. This   behavior was rejected because it would be too surprising.So there are implementation reasons for the restriction with unpacking function arguments but it is indeed a little surprising!In the meantime, here's the workaround I was looking for, kind of obvious in retrospect:
It doesn't have to be that way.  It was just rule that Guido found to be sensible.In Python 3, the rules for unpacking have been liberalized somewhat:Depending on whether Guido feels it would improve the language, that liberalization could also be extended to function arguments. See the discussion on extended iterable unpacking for some thoughts on why Python 3 changed the rules.
Thanks to the PEP 448 - Additional Unpacking Generalizations,is now accepted syntax starting from Python 3.5. Likewise you can use the double-star  for keyword argument unpacking anywhere and either one can be used multiple times.
 is expecting 3 arguments (, , , in that order).Suppose . When you call , what python does behind the scenes, is to call , without really knowing the length of .So what happens if  was instead ?Then, when  you call , you'll end up calling , which will be an error because  is expecting exactly 3 arguments and you gave it 4.Now, suppose f`:Now, you implicitly know when you call  that 3 will be assigned to , but python doesn't know that. It only knows that the last  many elements of the input to  will be defined by the contents of . But since it doesn't know the value of , it can't make assumptions about whether  would have the correct number of arguments.This however, is not the case with . In this case, python knows that all the arguments EXCEPT the first one will be defined by the contents of .But if you have named arguments , then the arguments being assigned to by name will be bound first. Only then are the positional arguments bound. So you do . In that case,  is bound to  first, and then, the other values get bound. Now interestingly, if you did , that would give you an error for trying to assign to  twice (once with the keyword, once again with the positional)Hope this helps
Nice. This also works for tuples. Don't forget the comma:
You can use  if you use , it do not know how to unpack the parameter for you provided 2 parameters and 2 is the second.


Answer URL
https://docs.python.org/3/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations
