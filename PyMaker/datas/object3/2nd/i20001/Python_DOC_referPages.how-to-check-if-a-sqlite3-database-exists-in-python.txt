Natural Text
I am trying to create a function in Python 2.7.3 to open a SQLite database. This is my code at the moment:I have tried the code above and I have observed that the  library opens the database declared if exists, or creates a new database if this one doesn't exist. Is there a way to check if the database exists with  methods or I have to use file operation like ?
In Python 2, you'll have to explicitly test for the existence using :There is no way to force the  function to not create the file for you.For those that are using Python 3.4 or newer, you can use the newer URI path feature to set a different mode when opening a database. The  function by default will open databases in , that is Read, Write & Create mode, so connecting to a non-existing database will cause it to be created.Using a URI, you can specify a different mode instead; if you set it to , so Read & Write mode, an exception is raised when trying to connect to a non-existing database. You can set different modes when you set the  flag when connecting and pass in a  URI, and add a  query parameter to the path:See the SQLite URI Recognized Query Parameters documentation for more details on what parameters are accepted.
 is just telling you if a file exists, not if it exists AND is a SQLite3 database! Knowing http://www.sqlite.org/fileformat.html, you could do this :and subsequently use it like :
Yes, there is a way to do what you want with Python 3.4+.Use the  function to connect, but pass it a URI instead of a file path, and add  to its query string.Here is a complete working code example:This will open an existing database from a file named  in the current folder, but will raise an error in case that file can not be opened or does not exist:Python sqlite.connect() docs state that:If uri is true, database is interpreted as a URI. This allows you to specify options. For example, to open a database in read-only mode you can use:db = sqlite3.connect('file:path/to/database?mode=ro', uri=True)More information about this feature, including a list of recognized options, can be found in the SQLite URI documentation.Here's an excerpt of all the relevant URI option information collected from http://www.sqlite.org/c3ref/open.html:mode: The mode parameter may be set to either "ro", "rw", "rwc", or "memory". Attempting to set it to any other value is an error. If "ro" is specified, then the database is opened for read-only access, just as if the SQLITE_OPEN_READONLY flag had been set in the third argument to sqlite3_open_v2(). If the mode option is set to "rw", then the database is opened for read-write (but not create) access, as if SQLITE_OPEN_READWRITE (but not SQLITE_OPEN_CREATE) had been set. Value "rwc" is equivalent to setting both SQLITE_OPEN_READWRITE and SQLITE_OPEN_CREATE. If the mode option is set to "memory" then a pure in-memory database that never reads or writes from disk is used. It is an error to specify a value for the mode parameter that is less restrictive than that specified by the flags passed in the third parameter to sqlite3_open_v2().The sqlite3_open_v2() interface works like sqlite3_open() except that it accepts two additional parameters for additional control over the new database connection. The flags parameter to sqlite3_open_v2() can take one of the following three values, optionally combined with the SQLITE_OPEN_NOMUTEX, SQLITE_OPEN_FULLMUTEX, SQLITE_OPEN_SHAREDCACHE, SQLITE_OPEN_PRIVATECACHE, and/or SQLITE_OPEN_URI flags:SQLITE_OPEN_READONLY     The database is opened in read-only mode. If the database does not already exist, an error is returned.SQLITE_OPEN_READWRITE     The database is opened for reading and writing if possible, or reading only if the file is write protected by the operating system. In either case the database must already exist, otherwise an error is returned.SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE     The database is opened for reading and writing, and is created if it does not already exist. This is the behavior that is always used for sqlite3_open() and sqlite3_open16().For convenience, here's also a Python 3.4+ function for converting a regular path to an URI usable by sqlite.connect():
This is a fork (using Python 3) based on Tom Horen's answer, which presents a solution more complete and reliable that the elected answer. The elected answer, does not evaluate any content, header, etc., in order to determine whether the file actually contains any data related to a SQLite3 database or not.I tried to present something more pragmatic here:
I am using a function like the following at the beginning of my script so that I can try and figure out why a sqlite3 db script might not be working. Like the comments say, it uses 3 phases, checks if a path exist, checks if the path is a file, checks if that file's header is a sqlite3 header. 


Answer URL
https://docs.python.org/3/library/sqlite3.html#sqlite3.connect
