Natural Text
I have a string variable which represents a dos path e.g:I want to split this string into:I have tried using  and  but they either only process the first backslash or they insert hex numbers into the string.I need to convert this string variable into a raw string somehow so that I can parse it.What's the best way to do this?I should also add that the contents of  i.e. the path that I'm trying to parse, is actually the return value of a command line query. It's not path data that I generate myself. Its stored in a file, and the command line tool is not going to escape the backslashes.
I've been bitten loads of times by people writing their own path fiddling functions and getting it wrong. Spaces, slashes, backslashes, colons -- the possibilities for confusion are not endless, but mistakes are easily made anyway. So I'm a stickler for the use of , and recommend it on that basis.(However, the path to virtue is not the one most easily taken, and many people when finding this are tempted to take a slippery path straight to damnation. They won't realise until one day everything falls to pieces, and they -- or, more likely, somebody else -- has to work out why everything has gone wrong, and it turns out somebody made a filename that mixes slashes and backslashes -- and some person suggests that the answer is "not to do that". Don't be any of these people. Except for the one who mixed up slashes and backslashes -- you could be them if you like.)You can get the drive and path+file like this:Get the path and the file:Getting the individual folder names is not especially convenient, but it is the sort of honest middling discomfort that heightens the pleasure of later finding something that actually works well:(This pops a  at the start of  if the path was originally absolute. You could lose a bit of code if you didn't want that.)
I would doFirst normalize the path string into a proper string for the OS. Then  must be safe to use as a delimiter in string function split.
You can simply use the most Pythonic approach (IMHO):Which will give you:The clue here is to use  instead of  or , as this makes it system independent.To remove colon from the drive letter (although I don't see any reason why you would want to do that), you can write:
In Python >=3.4 this has become much simpler. You can now use  to get all the parts of a path.Example:On a Windows install of Python 3 this will assume that you are working with Windows paths, and on *nix it will assume that you are working with posix paths. This is usually what you want, but if it isn't you can use the classes  or  as needed:Edit:There is also a backport to python 2 available: pathlib2
The problem here starts with how you're creating the string in the first place.Done this way, Python is trying to special case these: , , , and .  In your case,  is being treated as a formfeed (0x0C) while the other backslashes are handled correctly.  What you need to do is one of these:Then once you split either of these, you'll get the result you want.
For a somewhat more concise solution, consider the following:
I can't actually contribute a real answer to this one (as I came here hoping to find one myself), but to me the number of differing approaches and all the caveats mentioned is the surest indicator that Python's os.path module desperately needs this as a built-in function.
It works for me:Sure you might need to also strip out the colon from the first component, but keeping it makes it possible to re-assemble the path.The  modifier marks the string literal as "raw"; notice how embedded backslashes are not doubled.
Let assume you have have a file  with content:You can read and split the file paths:
The stuff about about  would be better expressed as .  is the path separator for your particular platform (e.g.,  for Windows,  for Unix, etc.), and the Python build knows which one to use. If you use , then your code will be platform agnostic.
re.split() can help a little more then string.split()If you also want to support Linux and Mac paths, just add filter(None,result), so it will remove the unwanted '' from the split() since their paths starts with '/' or '//'. for example '//mount/...' or '/var/tmp/'
The functional way, with a generator.In action:
You can recursively  the stringTesting this against some path strings, and reassembling the path with The first element of the list may need to be treated differently depending on how you want to deal with drive letters, UNC paths and absolute and relative paths. Changing the last  to  forces the issue by splitting the drive letter and directory root out into a tuple.Edit: I have realised that this answer is very similar to that given above by user1556435. I'm leaving my answer up as the handling of the drive component of the path is different.
Just like others explained - your problem stemmed from using , which is escape character in string literal/constant. OTOH, if you had that file path string from another source (read from file, console or returned by os function) - there wouldn't have been problem splitting on '\\' or r'\'.And just like others suggested, if you want to use  in program literal, you have to either duplicate it  or the whole literal has to be prefixed by , like so  or  to avoid the parser converting that  and  to CR (carriage return) character.There is one more way though - just don't use backslash  pathnames in your code! Since last century Windows recognizes and works fine with pathnames which use forward slash as directory separator ! Somehow not many people know that.. but it works:This by the way will make your code work on Unix, Windows and Mac... because all of them do use  as directory separator... even if you don't want to use the predefined constants of module .
I use the following as since it uses the os.path.basename function it doesn't add any slashes to the returned list. It also works with any platform's slashes: i.e window's \\ or unix's /. And furthermore, it doesn't add the \\\\ that windows uses for server paths :)So for '\\\\server\\folder1\\folder2\\folder3\\folder4'you get['server','folder1','folder2','folder3','folder4']
I'm not actually sure if this fully answers the question, but I had a fun time writing this little function that keeps a stack, sticks to os.path-based manipulations, and returns the list/stack of items.
use 


Answer URL
https://docs.python.org/3/library/pathlib.html#accessing-individual-parts
