Natural Text
I have been doing some functional programming and had a question. Perhaps I might be missing something but is there any way to stop a "reduce()" function midway? Lets say when I reach a certain condition? The idea somehow seems anti functional. I haven't seen any such option in python or F#, As an example, lets say I have a list such as [1,2,3,4,5]. I want to sum the elements in this list until the sum is not greater than some number (lets say 8), and return/mark/store/identify somehow, the number of elements I have actually added.If we looked at python for example for I might try something likeThis gives me the right answer 6, but how do I find that I had added 3 elements to get here. There is no counter as such. I can't do assignments inside lambdas. I think F# has the same situation.I know I can use a for loop or use a function that can store state etc. But what would be the functional way of doing/thinking about this. Reduce() wants to run until the end, but somewhere along this line of processing, we either want to stop it (because we don't care about processing the rest of the elements) or at least make a note of the place where we stopped caring.
Reduce is often used in combination with map. Google for example has developed a map-reduce framework for querying their databases and this map-reduce pattern is now used in several other projects (e.g. CouchDB, Hadoop, etc).First, you need to map the  variables  to something like:In that case,  will represent the number of the elements to get the sum . Of course, the number of elements is  at the beginning for each single element.The next thing then, is to operate on those tuples:This will return , meaning the partial sum is  using  elements.I hope you got the idea behind map-reduce-algorithms.Regards,Christoph
I agree with JaredPar that writing your own recursive function that behaves similarly to , but allows you to stop the computation earlier is the best approach. The way I would write it is a bit more general (so that you can use the function for any situation where you need folding that can stop earlier):This is a very general function and you can use it for all similar scenarios. The nice thing about writing it is that you will never need to write similar explicit recursion again (because you can just use  once you have it).Note that you can use  to implement  by always wrapping the result of the accumulation function in 'Some' (so it is more general):
Let's imagine Python had two functions, ireduce (similar to reduce but it would yield intermediate values; it's called scanl in some languages) and ilast (get last item of an iterable):In Haskell:
I think that the 'most functional' way to do this is probably via lazy evaluation.  If you're in a lazy language like Haskell, or in an eager language but using a lazy list data structure (like  in the F# PowerPack), you can create e.g. a 'scan' of the running sums, and then leave it in the hands of the consumer of the list to decide how much she wants/needs to evaluate.Or, you know, write a simple recursive function, like @JaredPar's answer.  For some reason I often get a mental block on that, preventing me from noticing that "not everything has to be a , you can in fact write your own recursive functions" :)
Try the followingF# interactive result
This is a function that implements that functional program:or recursively:There's probably a way to clean it up a bit, but you would use it like this:
I think this does what you are after, using functions built-in to the F# Seq module:The "scan" function is similar to "fold", but returns a sequence containing intermediate (and final) states, rather than just the final state.  In this case, the state is a tuple containing a count and sum of items thus far processed, starting with (0,0).  This gets computed and fed, one at a time, into the "find" function, which returns the first element which matches the supplied condition (v>8), in this case (4,10).The only issue you'd need to handle with the above is the case where the "find" condition is never satisfied, in which case a KeyNotFoundException is thrown.  You could use "tryFind" which returns an option value.  However, I can't see a graceful way to return the last element computed if no earlier state matches the condition, short of pre-computing the length of the sequence:
Another functional approch could be using a "continution"-based version of reduce/fold:Call with 'id' (fun x -> x) as 'initial continuation':And you will get your '6'. Note that this version of  is not tail recursive - or otherwise recommended - thought...  
The only way to get out of the builtin  part way through is to throw an exception. Fortunately it's not hard to get the desired result this way:
I know you're specifically interested in python, but I thought I would chime in with respect to how Clojure accomplishes this, since it solves the problem quite elegantly and directly.Clojure has a  function that returns a version of whatever it is passed, such that this version will immediately terminate within a call to reduce. This makes it trivially simple to do something like this:This returns the first sum which is greater than or equal to a hundred, or the greatest sum reached if none exceeds. And it's worth noting that it does this without consuming/iterating through the entirety of the collection being reduced over, which could be very large or even infinite lazy sequence. Moreover, this has a definite advantage over applying some filter operation first, as you can have your termination condition dependent on the value being constructed, not just by individual values in the collection being reduced.You mention this idea seems somehow "anit-functional". This might seem to be the case in python, where it's unclear how you would accomplish it without resorting to some messy outside state (or at best an alternate version of ). However, this works cleanly and functionally (even purely so) in Clojure because it's been baked into the language. The key is that  knows to look for  values, and objects can carry that information around with them (either as a wrapped value of as metadata; not sure which actually...).It's certainly a handy feature I've been glad to have when I've needed it.
Here is a slight variation of Stephen's code, using  instead of  (I hope) and not requiring a sequence:
If you want to avoid carrying out unnecessary computations (which you still will with a map-reduce algorithm), write your own reduce and catch :Then, write a step function that wraps the return value in a call to  when you reach a certain condition.  Using your original lambda:Similar to Duncan's answer, but allows you to use lambdas (no manually raising exceptions).
First, in F#. What's the first triangle number greater than 100?Note that Seq.scan is lazy, so triangle numbers beyond the solution are never calculated.To find the ordinal of the solution, we exchange  for In Python, the analogue of F#'s List.scan is itertools.accumulate, introduced Python 3.2 (2011).


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.accumulate
