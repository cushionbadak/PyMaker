Natural Text
I have a multi-line string defined like this:This string we used as test-input for a parser I am writing. The parser-function receives a -object as input and iterates over it. It does also call the  method directly to skip lines, so I really need an iterator as input, not an iterable.I need an iterator that iterates over the individual lines of that string like a -object would over the lines of a text-file. I could of course do it like this:Is there a more direct way of doing this? In this scenario the string has to traversed once for the splitting, and then again by the parser. It doesn't matter in my test-case, since the string is very short there, I am just asking out of curiosity. Python has so many useful and efficient built-ins for such stuff, but I could find nothing that suits this need.
Here are three possibilities:Running this as the main script confirms the three functions are equivalent. With  (and a  for  to get substantial strings for more precise measurement):Note we need the  call to ensure the iterators are traversed, not just built.IOW, the naive implementation is so much faster it isn't even funny: 6 times faster than my attempt with  calls, which in turn is 4 times faster than a lower-level approach.Lessons to retain: measurement is always a good thing (but must be accurate); string methods like  are implemented in very fast ways; putting strings together by programming at a very low level (esp. by loops of  of very small pieces) can be quite slow.Edit: added @Jacob's proposal, slightly modified to give the same results as the others (trailing blanks on a line are kept), i.e.:Measuring gives:not quite as good as the  based approach -- still, worth keeping in mind because it might be less prone to small off-by-one bugs (any loop where you see occurrences of +1 and -1, like my  above, should automatically trigger off-by-one suspicions -- and so should many loops which lack such tweaks and should have them -- though I believe my code is also right since I was able to check its output with other functions').But the split-based approach still rules.An aside: possibly better style for  would be:at least, it's a bit less verbose.  The need to strip trailing s unfortunately prohibits the clearer and faster replacement of the  loop with  (the  part whereof is redundant in modern versions of Python, I believe since 2.3 or 2.4, but it's also innocuous).  Maybe worth trying, also:or variations thereof -- but I'm stopping here since it's pretty much a theoretical exercise wrt the  based, simplest and fastest, one.
I'm not sure what you mean by "then again by the parser".  After the splitting has been done, there's no further traversal of the string, only a traversal of the list of split strings.  This will probably actually be the fastest way to accomplish this, so long as the size of your string isn't absolutely huge.  The fact that python uses immutable strings means that you must always create a new string, so this has to be done at some point anyway.If your string is very large, the disadvantage is in memory usage: you'll have the original string and a list of split strings in memory at the same time, doubling the memory required.  An iterator approach can save you this, building a string as needed, though it still pays the "splitting" penalty.  However, if your string is that large, you generally want to avoid even the unsplit string being in memory.  It would be better just to read the string from a file, which already allows you to iterate through it as lines.However if you do have a huge string in memory already, one approach would be to use StringIO, which presents a file-like interface to a string, including allowing iterating by line (internally using .find to find the next newline).  You then get:
If I read  correctly, this should be quite efficient (although somewhat verbose):
Regex-based searching is sometimes faster than generator approach:
I suppose you could roll your own:I'm not sure how efficient this implementation is, but that will only iterate over your string once.Mmm, generators.Edit:Of course you'll also want to add in whatever type of parsing actions you want to take, but that's pretty simple.


Answer URL
https://docs.python.org/3/library/io.html
