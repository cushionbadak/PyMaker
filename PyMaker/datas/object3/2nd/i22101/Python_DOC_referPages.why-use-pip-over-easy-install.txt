Natural Text
A tweet reads: Don't use easy_install, unless you  like stabbing yourself in the face.  Use pip.Why use pip over easy_install? Doesn't the fault lie with PyPI and package authors mostly? If an author uploads crap source tarball (eg: missing files, no setup.py) to PyPI, then both pip and easy_install will fail. Other than cosmetic differences, why do Python people (like in the above tweet) seem to strongly favor pip over easy_install?(Let's assume that we're talking about easy_install from the Distribute package, that is maintained by the community)
Many of the answers here are out of date for 2015 (although the initially accepted one from Daniel Roseman is not). Here's the current state of things:Binary packages are now distributed as wheels ( files)—not just on PyPI, but in third-party repositories like Christoph Gohlke's Extension Packages for Windows.  can handle wheels;  cannot.Virtual environments (which come built-in with 3.4, or can be added to 2.6+/3.1+ with ) have become a very important and prominent tool (and recommended in the official docs); they include  out of the box, but don't even work properly with .The  package that included  is no longer maintained. Its improvements over  got merged back into . Trying to install  will just install  instead. itself is only quasi-maintained.All of the cases where  used to be inferior to —installing from an unpacked source tree, from a DVCS repo, etc.—are long-gone; you can , . comes with the official Python 2.7 and 3.4+ packages from python.org, and a  bootstrap is included by default if you build from source.The various incomplete bits of documentation on installing, using, and building packages have been replaced by the Python Packaging User Guide. Python's own documentation on Installing Python Modules now defers to this user guide, and explicitly calls out  as "the preferred installer program".Other new features have been added to  over the years that will never be in . For example,  makes it easy to clone your site-packages by building a requirements file and then installing it with a single command on each side. Or to convert your requirements file to a local repo to use for in-house development. And so on.The only good reason that I know of to use  in 2015 is the special case of using Apple's pre-installed Python versions with OS X 10.5-10.8. Since 10.5, Apple has included , but as of 10.10 they still don't include . With 10.9+, you should still just use , but for 10.5-10.8, this has some problems, so it's easier to . (In general,  is a bad idea; it's only for OS X 10.5-10.8 that you want to do this.) Also, 10.5-10.8 include  in a way that  knows how to kludge around but  doesn't, so you also want to  if you want to upgrade that.
From Ian Bicking's own introduction to pip:pip was originally written to improve on easy_install in the following waysAll packages are downloaded before installation. Partially-completed installation doesn’t occur as a result.Care is taken to present useful output on the console.The reasons for actions are kept track of. For instance, if a package is being installed, pip keeps track of why that package was required.Error messages should be useful.The code is relatively concise and cohesive, making it easier to use programmatically.Packages don’t have to be installed as egg archives, they can be installed flat (while keeping the egg metadata).Native support for other version control systems (Git, Mercurial and Bazaar)Uninstallation of packages.Simple to define fixed sets of requirements and reliably reproduce a set of packages.
Another—as of yet unmentioned—reason for favoring pip is because it is the new hotness and will continue to be used in the future. The infographic below—from the Current State of Packaging section in the The Hitchhiker's Guide to Packaging v1.0—shows that setuptools/easy_install will go away in the future.Here's another infographic from distribute's documentation showing that Setuptools and easy_install will be replaced by the new hotness—distribute and pip. While pip is still the new hotness, Distribute merged with Setuptools in 2013 with the release of Setuptools v0.7.
Two reasons, there may be more:pip provides an  commandif an installation fails in the middle, pip will leave you in a clean state.
REQUIREMENTS files.Seriously, I use this in conjunction with virtualenv every day.QUICK DEPENDENCY MANAGEMENT TUTORIAL, FOLKSRequirements files allow you to create a snapshot of all packages that have been installed through pip.  By encapsulating those packages in a virtualenvironment, you can have your codebase work off a very specific set of packages and share that codebase with others.From Heroku's documentation https://devcenter.heroku.com/articles/pythonYou create a virtual environment, and set your shell to use it. (bash/*nix instructions)Now all python scripts run with this shell will use this environment's packages and configuration.  Now you can install a package locally to this environment without needing to install it globally on your machine.Now you can dump the info about which packages are installed withIf you checked that file into version control, when someone else gets your code, they can setup their own virtual environment and install all the dependencies with:Any time you can automate tedium like this is awesome.
pip won't install binary packages and isn't well tested on Windows.As Windows doesn't come with a compiler by default pip often can't be used there. easy_install can install binary packages for Windows.
UPDATE:  has absorbed  as opposed to the other way around, as some thought.  is up-to-date with the latest  changes and the wheel format. Hence,  and  are more or less on  equal footing now.Source: http://pythonhosted.org/setuptools/merge-faq.html#why-setuptools-and-not-distribute-or-another-name
As an addition to fuzzyman's reply:pip won't install binary packages and isn't well tested on Windows.As Windows doesn't come with a compiler by default pip often can't be  used there. easy_install can install binary packages for Windows.Here is a trick on Windows:you can use  to install binary packages to avoid building a binaryyou can use   even if you used easy_install.This is just a work-around that works for me on windows.Actually I always use pip if no binaries are involved.See the current pip doku: http://www.pip-installer.org/en/latest/other-tools.html#pip-compared-to-easy-installI will ask on the mailing list what is planned for that.Here is the latest update:The new supported way to install binaries is going to be !It is not yet in the standard, but almost. Current version is still an alpha: 1.0.0a1https://pypi.python.org/pypi/wheelhttp://wheel.readthedocs.org/en/latest/I will test  by creating an OS X installer for  using  instead of eggs. Will get back and report about this.cheers - ChrisA quick update:The transition to  is almost over. Most packages are supporting .I promised to build wheels for , and I did that last summer. Works great!HINT:A few developers failed so far to support the wheel format, simply because they forget toreplace  by .Often, it is easy to convert such packages by replacing this single word in .
Just met one special case that I had to use  instead of , or I have to pull the source codes directly.For the package , the version in  is too old, which is , while the one from  is the latest which is .I'm using . I'm not sure about the underlay mechanism of  and , but at least the versions of some packages may be different from each other, and sometimes  is the one with newer version.


Answer URL
https://docs.python.org/3/installing/index.html
https://docs.python.org/3/installing/index.html
