Natural Text
"Learning Python, 4th Ed." mentions that:the enclosing scope variable is looked up when the nested functions  are later called..However, I thought that when a function exits, all of its local references disappear. is the same for every  because the variable  is somehow looked up at call time. How does Python look up this variable? Shouldn't it not exist at all because makeActions has already exited? Why doesn't Python do what the code intuitively suggests, and define each function by replacing i with its current value within the for loop as the loop is running?
I think it's pretty obvious what happens when you think of  as a name not some sort of value. Your lambda function does something like "take x: look up the value of i, calculate i**x" ... so when you actually run the function, it looks up  just then so  is .You can also use the current number, but you have to make Python bind it to another name:It might seem confusing, because you often get taught that a variable and it's value are the same thing -- which is true, but only in languages that actually use variables. Python has no variables, but names instead.About your comment, actually i can illustrate the point a bit better:You said you changed i to 6, that is not what actually happend:  means "i have a value,  and i want to name it ". The fact that you already used  as a name matters nothing to Python, it will just reassign the name, not change it's value (that only works with variables).You could say that in , whatever value  currently points to (the number 5) gets three new names: . That's the same thing that happens when you call a function: The arguments are given new names. But that is probably going against any intuition about lists ...This can explain the behavior in the example: You assign , ,  - no wonder they don't change when you reassign the . If  was something muteable, for example a list, then changing  would reflect on all entries in  too, because you just have different names for the same value!The simple fact that you can use  on the left hand of a  proves that it is indeed a name. I like to call  the assign name operator: It takes a name on the left, and a expression on the right, then evaluates the expression (call function, look up the values behind names) until it has a value and finally gives the name to the value. It does not change anything.For Marks comment about compiling functions:Well, references (and pointers) only make sense when we have some sort of addressable memory. The values are stored somewhere in memory and references lead you that place. Using a reference means going to that place in memory and doing something with it. The problem is that none of these concepts are used by Python!The Python VM has no concept of memory - values float somewhere in space and names are little tags connected to them (by a little red string). Names and values exist in separate worlds!This makes a big difference when you compile a function. If you have references, you know the memory location of the object you refer to. Then you can simply replace then reference with this location.Names on the other hand have no location, so what you have to do (during runtime) is follow that little red string and use whatever is on the other end. That is the way Python compiles functions: Whereever there is a name in the code, it adds a instruction that will figure out what that name stands for.So basically Python does fully compile functions, but names are compiled as lookups in the nesting namespaces, not as some sort of reference to memory.When you use a name, the Python compiler will try to figure out where to which namespace it belongs to. This results in a instruction to load that name from the namespace it found. Which brings you back to your original problem: In , the  is compiled as a lookup in the  namespace (because  was used there). Python has no idea, nor does it care about the value behind it (it does not even have to be a valid name). One that code runs the  gets looked up in it's original namespace and gives the more or less expected value.
What happens when you create a closure:The closure is constructed with a pointer to the frame (or roughly, block) that it was created in: in this case, the  block.The closure actually assumes shared ownership of that frame, by incrementing the frame's ref count and stashing the pointer to that frame in the closure. That frame, in turn, keeps around references to the frames it was enclosed in, for variables that were captured further up the stack.The value of  in that frame keeps changing as long as the for loop is running â€“ each assignment to  updates the binding of  in that frame.Once the for loop exits, the frame is popped off the stack, but it isn't thrown away as it might usually be! Instead, it's kept around because the closure's reference to the frame is still active. At this point, though, the value of  is no longer updated.When the closure is invoked, it picks up whatever value of  is in the parent frame at the time of invocation. Since in the for loop you create closures, but don't actually invoke them, the value of  upon invocation will be the last value it had after all the looping was done.Future calls to  will create different frames. You won't reuse the for loop's previous frame, or update that previous frame's  value, in that case.In short: frames are garbage-collected just like other Python objects, and in this case, an extra reference is kept around to the frame corresponding to the  block so it doesn't get destroyed when the for loop goes out of scope.To get the effect you want, you need to have a new frame created for each value of  you want to capture, and each lambda needs to be created with a reference to that new frame. You won't get that from the  block itself, but you could get that from a call to a helper function which will establish the new frame. See THC4k's answer for one possible solution along these lines.
The local references persist because they're contained in the local scope, which the closure keeps a reference to.
I thought that when a function exits, all of its local references disappear.Except for those locals which are closed over in a closure. Those do not disappear, even when the function to which they are local has returned.
Intuitively one might think  would be captured in its current state but that is not the case. Think of each layer as a dictionary of name value pairs.Every time you create a closure for the inner lambda you are capturing a reference to level one. I can only assume that the run-time will perform a look-up of the variable , starting in level 2 and making its way to level 1. Since you are not executing these functions immediately they will all use the final value of .Experts?


Answer URL
https://docs.python.org/3/c-api/cell.html
