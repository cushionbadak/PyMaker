Natural Text
I need to replace some characters as follows:  -> ,  -> , ...I coded as follows, but I guess there should be some better way. Any hints?
Replacing two charactersI timed all the methods in the current answers along with one extra.With an input string of  and replacing & -> \& and # -> #, the fastest was to chain together the replacements like: .Timings for each function:a) 1000000 loops, best of 3: 1.47 μs per loopb) 1000000 loops, best of 3: 1.51 μs per loopc) 100000 loops, best of 3: 12.3 μs per loopd) 100000 loops, best of 3: 12 μs per loope) 100000 loops, best of 3: 3.27 μs per loopf) 1000000 loops, best of 3: 0.817 μs per loopg) 100000 loops, best of 3: 3.64 μs per looph) 1000000 loops, best of 3: 0.927 μs per loopi) 1000000 loops, best of 3: 0.814 μs per loopHere are the functions:Timed like this:Replacing 17 charactersHere's similar code to do the same but with more characters to escape (\`*_{}>#+-.!$):Here's the results for the same input string :a) 100000 loops, best of 3: 6.72 μs per loopb) 100000 loops, best of 3: 2.64 μs per loopc) 100000 loops, best of 3: 11.9 μs per loopd) 100000 loops, best of 3: 4.92 μs per loope) 100000 loops, best of 3: 2.96 μs per loopf) 100000 loops, best of 3: 4.29 μs per loopg) 100000 loops, best of 3: 4.68 μs per looph) 100000 loops, best of 3: 4.73 μs per loopi) 100000 loops, best of 3: 4.24 μs per loopAnd with a longer input string ():a) 100000 loops, best of 3: 7.59 μs per loopb) 100000 loops, best of 3: 6.54 μs per loopc) 100000 loops, best of 3: 16.9 μs per loopd) 100000 loops, best of 3: 7.29 μs per loope) 100000 loops, best of 3: 12.2 μs per loopf) 100000 loops, best of 3: 5.38 μs per loopg) 10000 loops, best of 3: 21.7 μs per looph) 100000 loops, best of 3: 5.7 μs per loopi) 100000 loops, best of 3: 5.13 μs per loopAdding a couple of variants:With the shorter input:ab) 100000 loops, best of 3: 7.05 μs per loopba) 100000 loops, best of 3: 2.4 μs per loopWith the longer input:ab) 100000 loops, best of 3: 7.71 μs per loopba) 100000 loops, best of 3: 6.08 μs per loopSo I'm going to use  for readability and speed.AddendumPrompted by haccks in the comments, one difference between  and  is the  check. Let's test them against two more variants:Times in μs per loop on Python 2.7.14 and 3.6.3, and on a different machine from the earlier set, so cannot be compared directly.We can conclude that:Those with the check are up to 4x faster than those without the check is slightly in the lead on Python 3, but  (with check) has a greater lead on Python 2However, the biggest lesson here is Python 3 is up to 3x faster than Python 2! There's not a huge difference between the slowest on Python 3 and fastest on Python 2!

Simply chain the  functions like thisIf the replacements are going to be more in number, you can do this in this generic way
Are you always going to prepend a backslash? If so, tryIt may not be the most efficient method but I think it is the easiest.
Here is a python3 method using  and :The printed string is .
You may consider writing a generic escape function:This way you can make your function configurable with a list of character that should be escaped.
FYI, this is of little or no use to the OP but it may be of use to other readers (please do not downvote, I'm aware of this).As a somewhat ridiculous but interesting exercise, wanted to see if I could use python functional programming to replace multiple chars. I'm pretty sure this does NOT beat just calling replace() twice. And if performance was an issue, you could easily beat this in rust, C, julia, perl, java, javascript and maybe even awk. It uses an external 'helpers' package called pytoolz, accelerated via cython (cytoolz, it's a pypi package).I'm not even going to explain this because no one would bother using this to accomplish multiple replace. Nevertheless, I felt somewhat accomplished in doing this and thought it might inspire other readers or win a code obfuscation contest.
Using reduce which is available in python2.7 and python3.* you can easily replace mutiple substrings in a clean and pythonic way.In python2.7 you don't have to import reduce but in python3.* you have to import it from the functools module.
You want to use a 'raw' string (denoted by the 'r' prefixing the replacement string), since raw strings to not treat the backslash specially. 
Late to the party, but I lost a lot of time with this issue until I found my answer.Short and sweet,  is superior to . If you're more interested in funcionality over time optimization, do not use . Also use  if you don't know if the set of characters to be replaced overlaps the set of characters used to replace. Case in point:Using  you would naively expect the snippet  to return , but it will return in fact . Translation seems to perform what OP originally desired. 


Answer URL
https://docs.python.org/3/library/stdtypes.html#str.translate
https://docs.python.org/3/library/stdtypes.html#str.maketrans
