Natural Text
What is the best way to escape a string for safe usage as a command-line argument? I know that using  takes care of this using , but that doesn't seem to work correctly for paramiko. Example:This creates a file named literally , which is what I want. Compare:This creates a file called  and prints the uptime of the remote host. It has executed  as a second command instead of using it as part of the argument to the first command, . This is not what I want.I tried escaping the semicolon with a backslash before and after sending it to , but then I ended up with a file called .Also, it works correctly if  instead of , you use a command with a space:This creates a file literally called  because  surrounded it with quotes.Also, I tried  and it had the same effect as .EDIT: To clarify, I need to make sure that only a single command gets executed on the remote host, regardless of the whatever input data I receive, which means escaping characters like , ,  and the backtick.
Assuming the remote user has a POSIX shell, this should work:Why does this work?POSIX shell single quotes are defined as:Enclosing characters in single-quotes ( '' ) shall preserve the literal value of each character within the single-quotes. A single-quote cannot occur within single-quotes.The idea here is that you enclose the string in single quotes. This, alone, is almost good enough --- every character except a single quote will be interpreted literally. For single quotes, you drop out of the single-quoted string (the first ), add a single quote (the ), and then resume the single quoted string (the last ).What does this work with?This should work for any POSIX shell. I've tested it with dash and bash. Solaris 5.10's  (which I believe is not POSIX-compatible, and I couldn't find a spec for) also seems to work.For arbitrary remote hosts, I believe this is impossible. I think  will execute your command with whatever the remote user's shell (as configured in  or equivalent). If the remote user might be running, say,  or  or something, not only is any quoting scheme probably going to run into cross-shell inconsistencies, but you command execution is probably going to fail too.csh / tcshSlightly more problematic is the possibility that the remote user might be running , since some people actually do run that in the wild and might expect paramiko's  to work. (Users of  as a shell probably have no such expectations...)tcsh seems to mostly work. However, I can't figure out a way to quote a newline such that it will be happy. Including a newline in single-quoted string seems to make tcsh unhappy:Other than newlines, everything I've tried seems to work with tcsh (including single quotes, double quotes, backslashes, embedded tabs, asterisks, ...).Testing shell escapingIf you have an escaping scheme, here are some things you might want to test with:Escape sequences (, , ...)Quotes (, , )Globbing characters (, , , etc.)Job control and pipelines (, , , , ...)NewlinesNewlines are worth a special note. The  solution doesn't handle this right --- it escapes any non-alphanumeric character, and POSIX shell considers an escaped newline (ie, in Python, the two-letter string ) to be zero characters, not a single newline character. I think  handles all other cases correctly, though it scares me to use something designed for regular expressions to do escaping for shell. It might turn out to work, but I'd worry about a subtle case in  or shell escaping rules (like newlines), or possible future changes in the API.You should also be aware that escape sequences can get processed at various stages, which complicates testing things --- you only care about what the shell passes to a program, not what the program does. Using  is probably the best bet.  works surprisingly poorly: In dash, the  built-in processes backslash escapes like . Using  is usually safe, but on a Solaris 5.10 machine I tested on, it also handles sequences like .
You are not having success with  because it targets the Microsoft command line, which has different rules than the POSIX command line with which you are communicating using SSH.Instead, use the native Python routine , and be careful to apply it separately to each argument in the command. This will give you a working command line for SSH:The output carefully quotes the second argument to protect the  character:
 is what I am looking for. re.*escape(**string*)Return **string* with all non-alphanumerics backslashed...Example:This creates a file on the server called , which is what I want.I have tried all of the shell meta-characters I can think of and it works :


Answer URL
https://docs.python.org/3/library/shlex.html#shlex.quote
