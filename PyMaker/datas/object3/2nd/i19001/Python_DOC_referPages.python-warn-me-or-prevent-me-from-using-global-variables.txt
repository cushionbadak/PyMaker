Natural Text
I've gotten myself in trouble a few times now with accidentially (unintentionally) referencing global variables in a function or method definition.My question is: is there any way to disallow python from letting me reference a global variable?  Or at least warn me that I am referencing a global variable?Let me add that the typical situation where this arrises for my is using IPython as an interactive shell.  I use 'execfile' to execute a script that defines a class.  In the interpreter, I access the class variable directly to do something useful, then decide I want to add that as a method in my class.  When I was in the interpreter, I was referencing the class variable.  However, when it becomes a method, it needs to reference 'self'.  Here's an example.Now in my interpreter I run the script 'execfile('script.py')', I'm inspecting my class and type: 'm.a * m.b' and decide, that would be a useful method to have.  So I modify my code to be, with the non-intentional copy/paste error:This of course still executes in IPython, but it can really confuse me since it is now referencing the previously defined global variable!Maybe someone has a suggestion given my typical IPython workflow.  
First, you probably don't want to do this. As Martijn Pieters points out, many things, like top-level functions and classes, are globals.You could filter this for only non-callable globals. Functions, classes, builtin-function-or-methods that you import from a C extension module, etc. are callable. You might also want to filter out modules (anything you  is a global). That still won't catch cases where you, say, assign a function to another name after the . You could add some kind of whitelisting for that (which would also allow you to create global "constants" that you can use without warnings). Really, anything you come up with will be a very rough guide at best, not something you want to treat as an absolute warning.Also, no matter how you do it, trying to detect implicit global access, but not explicit access (with a  statement) is going to be very hard, so hopefully that isn't important.There is no obvious way to detect all implicit uses of global variables at the source level.However, it's pretty easy to do with reflection from inside the interpreter.The documentation for the  module has a nice chart that shows you the standard members of various types. Note that some of them have different names in Python 2.x and Python 3.x.This function will get you a list of all the global names accessed by a bound method, unbound method, function, or code object in both versions:If you want to only handle non-callables, you can filter it:This isn't perfect (e.g., if a function's globals have a custom builtins replacement, we won't look it up properly), but it's probably good enough.A simple example of using it:And you can pretty easily  a module and recursively walk its callables and call  on each one, which will work for the major cases (top-level functions, and methods of top-level and nested classes), although it won't work for anything defined dynamically (e.g., functions or classes defined inside functions).If you only care about CPython, another option is to use the  module to scan all the bytecode in a module, or .pyc file (or class, or whatever), and log each  op.One major advantage of this over the  method is that it will find functions that have been compiled, even if they haven't been created yet.The disadvantage is that there is no way to look up the names (how could there be, if some of them haven't even been created yet?), so you can't easily filter out callables. You can try to do something fancy, like connecting up  ops to corresponding  (and related) ops, but… that's starting to get pretty complicated.Finally, if you want to hook things dynamically, you can always replace  with a wrapper that warns every time you access it. For example:Again, you can filter on non-callables pretty easily:Obviously for Python 3 you'd need to change the  statement to a  function call.You can also raise an exception instead of warning pretty easily. Or you might want to consider using the  module.You can hook this into your code in various different ways. The most obvious one is an import hook that gives each new module a  around its normally-built . Although I'm not sure how that will interact with C extension modules, but my guess is that it will either work, or be harmlessly ignored, either of which is probably fine. The only problem is that this won't affect your top-level script. If that's important, you can write a wrapper script that s the main script with a , or something like that.


Answer URL
https://docs.python.org/3/library/inspect.html
https://docs.python.org/3/library/dis.html
https://docs.python.org/3/library/warnings.html
