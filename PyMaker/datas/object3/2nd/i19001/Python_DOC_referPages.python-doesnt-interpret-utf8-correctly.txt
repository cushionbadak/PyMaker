Natural Text
I know similar questions have been asked a million times, but despite reading through many of them I can't find a solution that applies to my situation.I have a django application, in which I've created a management script. This script reads some text files, and outputs them to the terminal (it will do more useful stuff with the contents later, but I'm still testing it out) and the characters come out with escape sequences like  instead of the intended . Since that escape sequence means , which is a common misinterpretation of  because of encoding problems, I suspect there are at least two places where this is going wrong. However, I can't figure out where - I've checked all the possible culprits I can think of:The terminal encoding is UTF-8;  gives The text files are encoded in UTF-8;  in the directory where they reside results in all entries being listed as "UTF-8 Unicode text" except one, which does not contain any non-ASCII characters and is listed as "ASCII text". Running  on that file yields another file with ASCII text encoding.The Python scripts are all UTF-8 (or, in several cases, ASCII with no non-ASCII characters). I tried inserting a comment in my management script with some special characters to force it to save as UTF-8, but it did not change the behavior. The above observations on the text files apply on all Python script files as well.The Python script that handles the text files has  at the top; the only line preceding that is , but I've tried both changing to  for Python 2.7 or removing it entirely to leave it up to Django, without results.According to the documentation, "Django natively supports Unicode data", so I "can safely pass around Unicode strings" anywhere in the application.I really can't think of anywhere else to look for a non-UTF-8 link in the chain. Where could I possibly have missed a setting to change to UTF-8?For completeness: I'm reading from the files with  and printing with the standard  function. No manual encoding or decoding happens at either end.UPDATE:In response to quiestions in comments: yields  for all files.I started compiling an SSCCE, and quickly found that the problem is only there if I try to print the value in a tuple. In other words,  works fine, but  does not. Adding  yields a tuple where both strings are marked with a prepending  and  (the correct escape sequence for ) instead of the odd characters before - but I can't figure out how to print them as regular strings, with no escape characters. I've tested another call to  as well as wrapping in  but both fail with  complaining that  can't be encoded in ascii. Since a single string works correctly, I don't know what else to test.SSCCE:
The big problem here is that you're mixing up Python 2 and Python 3. In particular, you've written Python 3 code, and you're trying to run it in Python 2.7. But there are a few other problems along the way. So, let me try to explain everything that's going wrong.I started compiling an SSCCE, and quickly found that the problem is only there if I try to print the value in a tuple. In other words,  works fine, but  does not.The first problem here is that the  of a tuple (or any other collection) includes the , not the , of its elements. The simple way to solve this problem is to not print collections. In this case, there is really no reason to print a tuple at all; the only reason you have one is that you've built it for printing. Just do something like this:In cases where you already have a collection in a variable, and you want to print out the str of each element, you have to do that explicitly. You can print the repr of the str of each with this:… or print the str of each directly with this:Notice that I'm using Python 2 syntax above. That's because if you actually used Python 3, there would be no tuple in the first place, and there would also be no need to call .You've got a Unicode string. In Python 3,  and  are the same type. But in Python 2, it's  and  that are the same type, and  is a different one. So, in 2.x, you don't have a  yet, which is why you need to call .And Python 2 is also why  prints a tuple. In Python 3, that's a call to the  function with two strings as arguments, so it will print out two strings separated by a space. In Python 2, it's a  statement with one argument, which is a tuple.If you want to write code that works the same in both 2.x and 3.x, you either need to avoid ever printing more than one argument, or use a wrapper like , or do a , or be very careful to do ugly things like adding in extra parentheses to make sure your tuples are tuples in both versions.So, in 3.x, you've got  objects and you just print them out. In 2.x, you've got  objects, and you're printing out their . You can change that to print out their , or to avoid printing a tuple in the first place… but that still won't help anything. Why? Well, printing anything, in either version, just calls  on it and then passes it to . But in 3.x,  means , and  is a ; in 2.x,  means , and  is a binary .So, the pseudocode for what ultimately happens is:And, as you saw, those will do different things, because: yields You can simulate Python 3 here by using a  or  and then using  or  instead of , or you can explicitly encode all your  objects like this:But really, the best way to deal with all of these problems is to run your existing Python 3 code in a Python 3 interpreter instead of a Python 2 interpreter.If you want or need to use Python 2.7, that's fine, but you have to write Python 2 code. If you want to write Python 3 code, that's great, but you have to run Python 3.3. If you really want to write code that works properly in both, you can, but it's extra work, and takes a lot more knowledge.For further details, see What's New In Python 3.0 (the "Print Is A Function" and "Text Vs. Data Instead Of Unicode Vs. 8-bit" sections), although that's written from the point of view of explaining 3.x to 2.x users, which is backward from what you need. The 3.x and 2.x versions of the Unicode HOWTO may also help.
For completeness: I'm reading from the files with lines = file.readlines() and printing with the standard print() function. No manual encoding or decoding happens at either end.In Python 3.x, the standard  function just writes Unicode to . Since that's a , its  method is equivalent to this:So one likely problem is that  does not match your terminal's actual encoding.And of course another is that your shell's encoding does not match your terminal window's encoding.For example, on OS X, I create a myscript.py like this:Then I fire up Terminal.app, create a session profile with encoding "Western (ISO Latin 1)", create a tab with that session profile, and do this:… and I get exactly the behavior you're seeing.
It seems from your comment that you are using python-2 and not python-3.If you are using  python-3, it's worth reading the unicode howto guide on reading/writing to understand what python is doing.The basic flow if encoding is:DECODE from encoding to unicode -> Processing -> Encode from unicode to encodingIn python3 the bytes are decoded to strings and strings are encoded to bytes.The bytes to string decoding is handled for you with .[..] the built-in open() function can return a file-like object that  assumes the file’s contents are in a specified encoding and accepts  Unicode parameters for methods such as read() and write(). This works  through open()‘s encoding and errors parameters [..]So to read in unicode from a utf-8 encoded file you should be doing this:If you want similar functionality using python-2, you can use :


Answer URL
