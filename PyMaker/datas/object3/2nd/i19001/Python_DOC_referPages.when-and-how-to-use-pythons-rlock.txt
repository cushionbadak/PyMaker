Natural Text
Reading through the Python docs I came across .Can someone explain to me (with example) a scenario in which  would be preferred to ?With particular reference to:'s “recursion level”. How is this useful?A threads "ownership" of an  objectPerformance?
This is one example where I see the use:Useful whenyou want to have threadsave access from outside the class and use the same methods from inside the class:for recursion more obvious:other threads have to wait until the first call of  finishes = thread ownership.PerformanceUsually I start programming with the Lock and when case 1 or 2 occur, I switch to an RLock. Until Python 3.2 the RLock should be a bit slower because of the additional code. It uses Lock:Thread Ownershipwithin the given thread you can acquire a  as often as you like. Other threads need to wait until this threads releases the resource again. This is different to the  which implies 'function-call ownership'(I would call it this way): Another function call has to wait until the resource is released by the last blocking function even if it is in the same thread = even if it is called by the other function. When to use Lock instead of RLockWhen you make a call to the outside of the resource which you can not control.The code below has two variables: a and b and the RLock shall be used to make sure a == b * 2In  the Lock would be the right choice although it does block. Or one can enhance it with errors using . Functions like  may occur when you have implemented a Observer pattern or a Publisher-Subscriber and add locking afterwards.
recursion levelownershipA primitive lock (Lock) is a synchronization primitive that is not owned by a particular thread when locked.For the repeatable Lock (RLock) In the locked state, some thread owns the lock; in the unlocked state, no thread owns it.When invoked if this thread already owns the lock, increment the recursion level by one, and return immediately. if thread doesn't own the lock It waits until owner release lock.Release a lock, decrementing the recursion level. If after the decrement it is zero, reset the lock to unlocked.PerformanceI don't think there is some performance difference rather conceptual one. 
Here is another use case for RLock.  Suppose you have a web-facing user interface that supports concurrent access, but you need to manage certain kinds of access to an external resource.  For instance, you have to maintain consistency between objects in memory and objects in a database, and you have a manager class that controls access to the database, with methods that you must ensure get called in a specific order, and never concurrently.What you can do is create an RLock and a guardian thread that controls access to the RLock by constantly acquiring it, and releasing only when signaled to.  Then, you ensure all methods you need to control access to are made to obtain the lock before they run.  Something like this:This way, you're ensured of the following things:Once a thread acquires the resource lock, it can call the resource manager's protected methods freely, because RLock is recursiveOnce the thread acquires the resource lock through the master method in the web facing interface, all access to protected methods in the manager will be blocked to other threadsProtected methods in the manager can only be accessed by first appealing to the guardian.


Answer URL
https://docs.python.org/3/whatsnew/3.2.html#optimizations
