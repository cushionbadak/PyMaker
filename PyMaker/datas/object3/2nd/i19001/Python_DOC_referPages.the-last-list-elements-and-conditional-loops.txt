Natural Text
Error:I'm assuming that when it gets to the last (nth) element it can't find an n+1 to compare it to, so it gives me an error. Interestingly, i think that I've done this before and not had this problem on a larger list: Here is an example (with credit to Raymond Hettinger for fixing it up) For crawling through a list in the way I've attempted, is there any fix so that I don't go "out of range?" I plan to implement this on a very large list, where I'll have to check if "list[i]==list[i+16]", for example. In the future, I would like to add on conditions like "if int(mylist[i+3])-int(mylist[i+7])>10: newerlist.append[mylist[i]". So it's important that I solve this problem. I thought about inserting a break statement, but was unsuccessful. I know this is not the most efficient, but I'm at the point where it's what i understand best. 
Edit:Right, with the new information in the OP, this becomes much simpler. Use the   recipe to group the data for each person into tuples:Now your data looks like:Which should be easy to work with, by comparison.Old Answer:If you need to make more arbitrary links, rather than just checking continuous values:    Naturally, you would want to use semantically valid names. The advantage to this method is it works with arbitrary iterables, not just lists, and is efficient and readable, without any ugly, inefficient iteration by index. If you need to continue checking once the offset values have run out (for other conditions, say) then use  ( in 2.x). Using the  recipe from .I would, however, greatly question if you need to re-examine your data structure in this case.Original Answer:I'm not sure what your aim is, but from what I gather you probably want :You can use this to work out when there are (arbitrarily large) runs of repeated items. It's worth noting you can provide  with a  argument that will group them based on any factor you want, not just equality.
So it sounds like you are trying to compare elements in your list at various fixed offsets. perhaps something like this could help you:Explanation: returns a copy of lst, starting from the nth (mind the 0-indexing) element creates a new list of tuples, with one element from each listNote that it stops as soon as either list runs out. in this case, the offset list runs out first.for a list of tuples, you can "upack directly" in the loop variable, sogives loops through the elements you want (pairs of successive elements in your list)
As a general idea, if you are trying to look ahead a certain number of places, you can do a few things: In the loop check (I.e. count < length), you'll need to check on the max field. So in your example, you wanted to go 16 spaces. This would mean that you would need to check count < (length - 16). The downside is that your last elements (the last 16) won't be iterated over. Check inside the loop to make sure the index is applicable. That is, on each if statement start with: if(I+16 < length && logic_you_want_to_check). This will allow you to continue through the loop, but when the logic will fail because its out of bounds, you won't error out. Note- this probably isn't what you want, but ill add it for completeness. Wrap around your logic. This will only work if wrap arounds can be considered. If you literally want to check the 16th index ahead of your current index (I.e like a place in a line perhaps), then wrapping around doesn't really suit well. But if don't need that logic, and want to model your values in a circular pattern, you can modulus your index. That is: if array[i] == array [(i + 16)%length(array)] would check either 16 ahead or wrap around to the front of the array. 
If you adhere to "Practicality beats purity":If you don't care about memory efficiency go for second's answer. If you want the purest answer then go for Lattyware's one.


Answer URL
