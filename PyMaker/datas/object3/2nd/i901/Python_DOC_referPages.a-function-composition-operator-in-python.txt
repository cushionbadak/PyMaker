Natural Text
In this question I asked about a function composition operator in Python. @Philip Tzou offered the following code, which does the job.I added the following functions.With these additions, one can use , , and  as operators to compose functions. For, example, one can write  and get . (PyCharm complains that a boolean isn't callable for . But it still ran.)All along, though, I wanted to use  as a function composition operator. So I added (Note that this fouls up , which can be removed for the sake of this question.)When I run  I get this error at runtime: . It turns out (apparently) that arguments to  are converted to strings before being passed to . Is there a way around that conversion? Or am I misdiagnosing the problem, and some other approach will work?
I am actually unwilling to provide this answer. But you should know in certain circumstance you can use a dot "" notation even it is a primary. This solution only works for functions that can be access from :To test:
You can't have what you want. The  notation is not a binary operator, it is a primary, with only the value operand (the left-hand side of the ), and an identifier. Identifiers are strings of characters, not full-blown expressions that produce references to a value.From the Attribute references section:An attribute reference is a primary followed by a period and a name:The primary must evaluate to an object of a type that supports attribute references, which most objects do. This object is then asked to produce the attribute whose name is the identifier.So when compiling, Python parses  as a string value, not as an expression (which is what you get for operands to operators). The  hook (and any of the other attribute access hooks) only has to deal with strings. There is no way around this; the dynamic attribute access function  strictly enforces that  must be a string:If you want to use syntax to compose two objects, you are limited to binary operators, so expressions that take two operands, and only those that have hooks (the boolean  and  operators do not have hooks because they evaluate lazily,  and  do not have hooks because they operate on object identity, not object values).


Answer URL
https://docs.python.org/3/reference/expressions.html#primaries
https://docs.python.org/3/reference/expressions.html#atom-identifiers
https://docs.python.org/3/reference/expressions.html#attribute-references
https://docs.python.org/3/reference/datamodel.html#customizing-attribute-access
https://docs.python.org/3/library/functions.html#getattr
