Natural Text
I wrote a class in python which inherits from  . I thought that this was the only requirement for a class so as to be called as a metaclass but had not defined a  method for it. But on instantiating with this new class as the metaclass I got an error stating the below : The following is my code  :Now when the class statement is being processed , that the  method of  is being called is my assumption. This is because the default metaclass of all classes in python is  . Now when I am instantiating the class  , which I have assumed to be a metaclass under the assumption that any class inheriting from () is a metaclass , isn't it the same as creating a class ? Why should this not result in  being called with correct arguments ? 
This does not work:...for the same reason for which this does not work:In the end, both do the same.To use it as a metaclass, do this:You could also instantiate the class directly, as you tried, but you have to provide the correct arguments:
This error is due to you not respecting 's signature.Inheriting from  is indeed enough for a class to be used as a metaclass, but the thing is you actually have to use it as a metaclass. itself has "two working modes:  if called with 3 positional arguments, it creates a new class. And then type is the metaclass of that class. If called with 1 positional argument, it creates no new class or object at all - instead, it just returns that object's class. But it makes no sense calling  with no arguments at all. And the arguments in the modes above are not optional. So, you will get a  if your try to call type with no arguments at all - and that is not  a "TypeError because something went wrong with the type class" - it is a "TypeError because your call did not match the callable signature".When you inherit from  and change nothing, you class will behave exactly the same as the original : you can call it with either one or three positional arguments, and the code responsible for working in either mode lies in .Now, if you want to use your class as a metaclass, you can indeed call it, but in the three argument form: you ass it the new class name, its bases and its attributes - which can actually be all empty, but you have to pass a string, a tuple and a dictionary as these three arguments:And now,  is working as the metaclass for :However, whenever one defines a metaclass it is more usual to use it with the  named argument when declaring a class body:Python's runtime will then compile this class body, and when the bytecod for it is executed, it will make the call to your metaclass'  (and then , and before that its ) method, so that it works as a metaclass.So, just in case it is not clear: when you derive a class from  intending to use it as a metaclass, there is no need to further instantiate it to say that "it is now a metaclass". A subclass of type already can be a metaclass, and its instances will be classes, that will have it as a metaclass.  


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__new__
