Natural Text
I am using following code snippet to encrypt a text in :Output: cUXDhOEGz19QEo9XDvMzXkGFmg/YQUnXEqKVpfYtUGo=Now, when I try to decrypt this in  it gives error:Traceback (most recent call last):  File "<stdin>", line 1, in <module>    File  "/anaconda3/lib/python3.6/site-packages/Crypto/Cipher/blockalgo.py",  line 295, in decrypt      return self._cipher.decrypt(ciphertext) ValueError: Input strings must be a multiple of 16 in lengthI get that AES is a block cipher algorithm. However, how should I fix my PHP code so that it generates "padded" cipher, any clues?
The main issue here is that you're using different key-size. PHP's  determines the key size from the encryption algorithm string  ( in this case) so it expects a 256 bit key. If the key is shorter it is padded with zero bytes, so the actual key used by  is:  Pycryptodome determines the key size from the actual size of the key, so your Python code uses AES-128-CBC. Also, as mentioned in the coments by kelalaka, the ciphertext is base64 encoded ( base64-encodes the ciphertext by default - we can get raw bytes if we use  in ). Pycryptodome doesn't decode the ciphertext, so we must use .  The extra  characters at the end is the padding - CBC requires padding. Pycryptodome doesn't remove padding automatically but it provides padding functions in .  Although PHP's openssl accepts arbitrary sized keys, it's best to use key size specified in the algorithm string, to prevent confusion at the very least. Also the key bytes should be as random as possible.  As noted by Maarten Bodewes in the comments this key uses a limited range of bytes and so it's very weak. Furthermore it is created by repeating a word and that makes it vulnerable to dictionary attacks (which are much faster than bruteforce attacks).  In PHP we can get cryptographically secure random bytes with , and in Python with (You can use the same functions to create the IV; you shouldn't use a static IV, the IV must be unpredictable)  You could also derive a key from your password with a KDF. In this case it is important to use a random salt and a high enough number of iterations. PHP provies a PBKDF2 algorithm with the  function, and Python with .


Answer URL
https://docs.python.org/3/library/os.html#os.urandom
https://docs.python.org/3/library/hashlib.html#hashlib.pbkdf2_hmac
