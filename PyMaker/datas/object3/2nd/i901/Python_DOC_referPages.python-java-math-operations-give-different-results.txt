Natural Text
I am doing some large number maths in both Java and Python. The sums are the same however the results are different.Python Answers = Java Answers = Java is getting the correct result but python is not. I am not using Floating point numbers as far as I know. Whats the issue here.
When you doyou get a big number elevated to a power but using a floating point method, even if arguments are integers. Converting to integer loses precision (the original result is a float: )When you doyou get a big number elevated to a power using a binary power method using only integer multiplication.So the second result is accurate, whereas the first isn'tLet's try a disassembly of both  and  functions:outputas you see, the functions aren't equivalent.  is called in the first case. This function has a chance to perform integer multiply accurately when parameters are integer:BINARY_POWER()Implements TOS = TOS1 ** TOSBinary power yields the same value as  when parameters aren't all integer:Note: what probably adds to the confusion is the built-in  method, which is different from  (and overridden by the latter when using ), but is equivalent to  operator when used without modulo argument:pow(x, y[, z])Return x to the power y; if z is present, return x to the power y, modulo z (computed more efficiently than pow(x, y) % z). The two-argument form pow(x, y) is equivalent to using the power operator: x**y.


Answer URL
https://docs.python.org/3/library/dis.html#opcode-BINARY_POWER
https://docs.python.org/3/library/functions.html#pow
https://docs.python.org/3/library/math.html#math.pow
