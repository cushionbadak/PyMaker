Natural Text
I have two (sorted) arrays, A and B, of different lengths each containing unique labels that are repeated a number of times.The count for each label in A is less than or equal to that in B.All labels in A will be in B, but some labels in B do not appear in A.I need an object the same length as B where, for each label  in A (which occurs  times), the first  occurrences of label  in B need to be set to .The remaining elements should be .The following code gives me what I need, but if A and B are large, this can take a long time:Is there a faster or more efficient way to do this? I feel like I may be missing some obvious broadcasting or vectorized solution.
Here's one with  -We can optimize further to compute  using its sorted nature instead of using , like so -
Example without numpy
This solution is inspired by the one by @Divakar, using itertools.groupby:OutputThe idea is to use np.searchsorted to find the insertion position of each element of , as equal elements will have the same insertion position you have to shift by one each of them, hence the groupby. Then create an array of  and set the values of the  to .If you can use , compute the  like this:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.groupby
