Natural Text
When I use the Functional API to create an enum, I get back an enum object that allows arbitrary assignment (i.e. it has a __dict__):The item does not appear in the list:But it can still be referenced:Now while it seems unlikely to ever occur, one of the reasons I want to use an enum is to prevent spelling mistakes and string literals, and for those things to be caught when a module is imported or as early as possible.Is there a way to dynamically build an enum that behaves more like a __slots__ object that does not allow arbitrary attributes to be assigned?
To make an enum class fully 'read-only', all that is required is a meta class that uses the  hook that prevents all attribute assignments. Because the metaclass is attached to the class after it is created, there is no issue with assigning the proper enumerated values.Like Ethan's answer, I'm using the  class as a base for the custom metaclass:The above distinguishes between attributes that are already available and new attributes, for ease of diagnosing. It also blocks attribute deletion, which is probably just as important! It also provides both the metaclass and a  base class for enumerations; use this instead of .To freeze a sample  enumeration:Note that all attribute changes are disallowed, no new attributes permitted, and deletions are blocked too. When names are enum members, we delegate to the original  handling to keep the error messages stable.If your enum uses properties that alter attributes on the enum class, you'd either have to whitelist those, or allow for names starting with a single underscore to be set; in  determine what names would be permissible to set and use  for those exceptions, just like the code now distinguishes between class construction and later alterations by using a flag attribute.The above class can be used just like  to programmatically create an enumeration:Demo:
Not necessarily easy, but possible.  We need to create a new  type1, create the  normally, then reassign the type after the  is created:and in use:Trying to reassign a member still gives the friendlier error:In order to make the class reassignment a little easier, we can write a decorator to encapsulate the process:and in use:Note that it is still possible to overwrite ordinary attributes, such as functions:and in use:Even that can be blocked, but I'll leave that (for now) as an exercise for someone else.1  This is only the second case I have seen where subclassing  is required.  For the other, see .Disclosure:  I am the author of the Python stdlib , the  backport, and the Advanced Enumeration ()  library.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__setattr__
https://docs.python.org/3/library/enum.html
