Natural Text
I am trying to build a parser with RPLY and am failing at making if - else if -else statements work.It seems to me as if the parser desperately tries to follow one path and when it fails, instead of looking for another, it just stops.Here is my current productions/rules:And here is the grammar in EBNF:So as of now, the parser parses:but not:orIs there something wrong with my rules? How would you implement such a (common) grammar?
The problem lies in your handling of  tokens. This creates shift/reduce conflict, which are resolved in favour of the shift action. The consequence is that the conflict reduce action can never be taken, which makes certain grammatical constructions impossible to parse.Here's one example:That's taken from bison's state machine dump for the same grammar. A parser state is a collection of "items"; each item is a production with a marked position. (The mark is the  in the two productions.) The mark basically shows how far the parser has gotten when it reaches that state; if the  is at the end of a production (as in the first line), then a reduction action is possible because the parser has reached the end of the production. If the  has some following symbol, then the parser could shift the next token if the next token could possibly be (or be the first token in some expansion of) the following symbol. In the case of the second production above, a  could be shifted if it happened to be the next token.Productions in the state are also annotated with a lookahead set, although bison only shows the lookahead set for productions which could be reduced. The annotation  at the end of the first production is that production's lookahead set. In other words, it is the set of possible next tokens in a context in which the production could be reduced.This state is a shift/reduce conflict because  could either trigger a reduction of , or it could be shifted on the assumption that  will be parsed. Since the default resolution of a shift/reduce conflict is to prefer the shift (in bison, ply, rply and most other LR parser generators), the reduction will never take place, forcing the parser to always chose to try to extend . In effect, that means that an  not at the end of a block must always be followed by another , making it impossible to parse  in which the  is followed by an  clause.A parser which could look ahead two tokens wouldn't have any problems with this grammar. The second next token, the one which comes after the , must be either  or ; in the first case, a reduction is needed, while in the second case the shift is the correct action. In fact, the  really serves no purpose there, since both  and  must always be preceded by  tokens. Also, since  can only end with  and  can only end with , we can conclude that the  must be preceded by a . It appears that you choose to send  after the , since your grammar seems to indicate that you send a  before an . That's probably workable in theory but it definitely leads to the shift/reduce conflicts you're experiencing.The more common implementation of whitespace-aware lexical scanning uses the algorithm outlined in the Python manual: a  token is generated when the newline is encountered, unless the surrounding lines are explicitly or implicitly joined, and then the decision is made to issue either one , one or more s, or nothing. Careful examination of the Python grammar shows how this fits together. Here's a simplified extract, in EBNF: more or less corresponds to your  but allows unindented single statements on the same line, but note that it starts with a . Simple (non-compound) statements end with a ; compound statements are treated as being self-delimiting.An alternative approach is to only issue  tokens in the case where two consecutive lines have exactly the same indentation. As noted above,  tokens in lines which are indented or dedented are strictly redundant, since there presence can be deduced; leaving them out entirely reduces the number of tokens which need to be handled by the parser. But if you do that, you can no longer use the simple principle that simple statements are always terminated with a  since the last simple statement in a  is directly followed by a . That makes it necessary to use a slightly more complicated (and right-recursive) definition of :


Answer URL
https://docs.python.org/3/reference/lexical_analysis.html#indentation
https://docs.python.org/3/reference/grammar.html
