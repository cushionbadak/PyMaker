Natural Text
I am attempting to make a painting based on the mass of the universe with pi and the gravitational constant of earth at sea level converted to binary.  i've done the math and i have the right dimentions and it should only be less than a megabyte of ram but im running into maximum allowed dimention exceeded value error.Here is the code:I keep running into the error at , and maybe my reshape is too big but its only a little bigger than 4k.  seems like this should be no problem for gpu enhanced colab.  Doesn't run on my home machine either with the same error.  Would this be fixed with more ram?
Making it WorkThe problem is that  creates a string. The string consists of  digits, all of them zeros and ones. If you convert the string to a python integer, , you will (A) wait a very long time, and (B) get a non-iterable object. The array you create with  will have a single element.The good news is that you can bypass the time-consuming step entirely using the fact that the string  is already an iterable:The step  will take a couple of seconds since it has to split up the string, but everything else should be quite fast.Plotting is easy from there with :ColormapsYou can easily change the color map to  or whatever you want when you save the image. Keep in mind that your image is binary, so only two of the values will actually matter:ExplorationYou have an opportunity here to add plenty of color to your image. Normally, a PNG is 8-bit. For example, instead of converting  to bits, you can take the bytes from it to construct an image. You can also take nibbles (half-bytes) to construct an indexed image with 16 colors. With a little padding, you can even make sure that you have a multiple of three data points, and create a full color RGB image in any number of ways. I will not go into the more complex options, but I would like to explore making a simple image from the bytes. bits is  bytes (with four leading zero bits). This is a very nasty factorization leading to an image size of 55x12613, so let's remove that upper nibble: while 's factorization is just as bad as 's,  factors very nicely into .You can convert your integer to an array of bytes using its own  method:The reason that I use the built-in  rather than  is that it return an integer rather than a float.Converting the huge integer is very fast because the  object has direct access to the data of the integer: even if it makes a copy, it does virtually no processing. It may even share the buffer since both  and  are nominally immutable. Similarly, you can create a numpy array from the  as just a view to the same memory location using :The  is necessary to chop off the leading nibble, since  must be large enough to hold the entirety of . You could also chop off on the  side:The results are identical. Here is what the picture looks like:The result is too large to upload (because it's not a binary image), but here is a randomly selected sample:I am not sure if this is aesthetically what you are looking for, but hopefully this provides you with a place to start looking at how to convert very large numbers into data buffers.More Options, Because this is InterestingI wanted to look at using nibbles rather than bytes here, since that would allow you to have 16 colors per pixel, and twice as many pixels. You can get an 1162x1194 image starting fromHere is one way to unpack the nibbles:With a colormap like , you get:Another option, going in the opposite direction in a manner of speaking) is not to use colormaps at all. Instead, you can divide your space by a factor of three and generate your own colors in RGB space. Luckily, one of the prime factors of  is . You can therefore have a 398x581 image (). How you interpret the data is even more than usual up to you. Side Note Before I ContinueWith the black-and-white binary image, you could control the color, size and orientation of the image. With 8-bit data, you could control how the bits were sampled (8 or fewer, as in the 4-bit example), the endianness of your interpretation, the color map, and the image size. With full color, you can treat each triple as a separate color, treat the entire dataset as three consecutive color planes, or even do something like apply a Bayer filter to the array. All in addition to the other options like size, ordering, number of bits per sample, etc.The following will show the color triples and three color planes options for now.Full Color ImagesTo treat each set of 3 consecutive bytes as an RGB triple, you can do something like this:Notice that there is no colormap in this case.Interpreting the data as three color planes requires an extra step because  expects the last dimension to have size 3.  is a good tool for this:
I could not reproduce your problem, because the line  took like forever. I replaced it with a , loop to cast each digit on its own. The code worked then and produced the desired image.


Answer URL
https://docs.python.org/3/library/stdtypes.html#int.to_bytes
https://docs.python.org/3/library/math.html#math.ceil
