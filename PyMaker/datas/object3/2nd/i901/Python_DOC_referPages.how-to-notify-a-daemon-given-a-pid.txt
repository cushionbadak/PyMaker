Natural Text
So I have been getting my feet wet with python, attempting to build a reminder system that ties into the gnome notification ui. The basic idea is you type a command into your shell like  and then in 20 min you get a desktop notification saying "check on dinner". The way I am doing this is by having a script parse the message and write the time the notification should be sent and the message that should be sent to a log file. The notifications are getting triggered by a python daemon. I am using this daemon design I found online. The issue I am seeing is when this daemon is running it is taking 100% of my cpu! I stripped down all the code the daemon was doing and it I still have this problem when all the daemon is doing is I presume that this is a bad approach and I should instead be notifying the daemon when there is a new reminder and then most of the time the reminder daemon should be sleeping. Now this is just an idea but I am having a hard time finding resources on 'how to notify a process' when all I know is the daemons pid. So if I have suspend the daemon with something like  would there be a way for me to send a signal to to the daemon letting it know that there was a new reminder? 
Though I believe you're better off using a server - client type solution that listens on a port, what you are asking is 100% possible using the  and  libraries. This approach will not work well with multi threaded programs however as signals are only handled by the parent thread in python. Additionally windows doesn't implement signals in the same way so the options are more limited.SignalsThe "client" process can send arbitrary signals using . You will have to go through the available signals and determine which one you want to use ( may be a good option because it shouldn't stomp on any other default behavior).The "daemon" process on startup must register a handler for what to do when it receives your chosen signal. The handler is a function you must define that receives the signal itself that was received as well as the current stack frame of execuiton (). If you're only doing one thing with this handler, and it doesn't need to know what was happening when it was called, you can probably ignore both these parameters. Then you must register the handler with  ex: .From there you will want to find some appropriate way to wait until the next signal without consuming too many resources. This could be as simple as looping on a command, or you could try to get fancy. I'm not sure 100% how execution resumes on returning from a signal handler, so you may need to concern yourself with recursion depth (ie, make sure you don't recurse every time a signal is handled or you'll only ever be able to handle a limited number of signals before needing to re-start).ServerHaving a process listen on a port (generally referred to as a server, but functionally the same as your 'daemon' description) instead of listen for operating system signals has several main advantages.Ports are able to send data where signals are only able to trigger eventsPorts are more similar cross-platformPorts play nice[r] with multi-threadingPorts make it easy to send messages across a network (ie: create reminder from phone and execute on PC)Waiting for multiple things at onceIn order to address the need to wait for multiple processes at once (listening for input as well as waiting to deliver next notification) you have quite a few options:Signals actually may be a good use case as  can be used as a conveniently re-settable alarm clock (if you're using UNIX). You would set up the handler in the same way as before, and simply set an alarm for the next notification. After setting the alarm, you could simply resume listening on the port for new tasks. If a new task comes in, setting the alarm again will override the existing one, so the handler would need to retrieve the next queued notification and re-set the alarm once done with the first task.Threads could either be used to poll a queue of notification tasks, or an individual thread could be created to wait for each task. This is not a particularly elegant solution, however it would be effective and easy to implement.The most elegant solution would likely be to use  co-routines, however I am not as well versed in asyncio, and will admit they're a bit more confusing than threads.


Answer URL
https://docs.python.org/3/library/signal.html
https://docs.python.org/3/library/os.html
https://docs.python.org/3/library/os.html#os.kill
