Natural Text
In Python2:super(Q,cls).M1(cls)#Getting error from here,But we can use same statement in python 3 and it works . I just wondering whether python 2.7 can have any similar way to call parent class implementation by using super() or not .`
Modifying the print statements to functions, this seems to run happily inside of Python 3.7But fails in Python2 with the errorTypeError: unbound method M1() must be called with Q instance as first argument (got type instance instead)Exactly as the error says, because  is an instance method its argument must be an instance, not a class. You can get around this by making  static and take no arguments. I suspect this works in Python3 because of tricks inside the implementation of  to support usage inside of methods. Reading through the standard library docs and this recommended post were helpful.This works in Python3 because it doesn't assert the type of the first argument -- it assumes the value is suitable and doesn't hit an error. An example of duck typing.Edit, more general to Python 3 behaviorThe error OP is seeing is not actually due to  but due to how Python 3 handles instance methods differently than Python 2. An example class could beIn both cases for, Python2 has an embedded assertion that the first argument of an instance method must be an instance type of the matching class. Python3 does not have this assertion for -- it's happy receiving  or a  type, at least until whatever argument it received fails to work. This is a great example of ducktyping.So  works in Python3 because it doesn't actually care what the value of the argument is -- it doesn't use it. In , however, it fails with an  when trying to increment the  instance property (because that instance property doesn't exist in the argument it was given).


Answer URL
https://docs.python.org/3/library/functions.html#super
