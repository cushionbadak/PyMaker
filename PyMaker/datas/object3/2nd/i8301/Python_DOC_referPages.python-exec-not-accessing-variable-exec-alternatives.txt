Natural Text
I am writing a command line calculator. I have all the math down but I want to add my own functions, like solve("x^3 = 8", x). My math works fine but the way I'm using exec() is preventing it from writing the result to the local variable finalAnswer.I included foo() to show what I wantOn execution my output is:The first three lines of the output tell me that every part of the script executes, but finalAnswer isn't getting initialized. Have I missed some nuance of using exec().Also, bonus points if you help me remove exec without changing the format of the string input calling a parameterized function and storing the returned value locally.
You may not need  or  here. If your expressions are all simple, like in your example code, then we can get away with using  which (as the name suggests) can evaluate strings that contain valid Python literals. This makes it far safer than plain  or . Of course, your code only attempts to execute approved functions, so it should be safe, but still...Anyway, here's a solution. We store the approved functions in a dict, keyed by the function name. And we pretend that the string containing the function argument list is a tuple, and get  to build that tuple for us, so we can pass the args to the function using  sequence unpacking.outputThis is safe because  is very strict about what it'll accept in a string. From the docs:Safely evaluate an expression node or a string containing a Python  literal or container display. The string or node provided may only  consist of the following Python literal structures: strings, bytes,  numbers, tuples, lists, dicts, sets, booleans, and .A container display is a list, tuple, set, or dict literal, eg  or . If you try to pass  something containing a function call or even an arithmetic expression, egorit will raise There's a minor exception to this.  will accept arithmetic expressions that only use  or . That's because it needs to be able to evaluate complex number literals, and those literals contain  or . The implementers decided that the easy way to handle that is to simply allow  to evaluate arithmetic expressions containing  or ; doing so doesn't create a security risk. That only applies to arithmetic expressions though, you cannot do string concatenation with , sowill raise ; OTOH, it does accept the usual automatic concatenation of adjacent string literals, so this is ok:



Answer URL
https://docs.python.org/3/library/ast.html#ast.literal_eval
