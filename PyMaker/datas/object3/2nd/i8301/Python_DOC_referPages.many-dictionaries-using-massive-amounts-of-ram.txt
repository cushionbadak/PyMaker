Natural Text
I have a very simple Python script to create (for test purposes), 35 million dictionary objects within a list. Each dictionary object contains two key/value pairs. eg.The script very simply take a query on name and age, searches through the list of dictionaries and returns a new list containing the index of all matching dictionary entries.However as you can see below, an insane amount of memory is consumed. I presume I am making a very naive mistake somewhere.My code is as follows: (can also be viewed in the image if more readable).What is causing the massive consumption of RAM?
The overhead for a  object is quite large. It depends on your Python version and your system architechture, but on Python 3.5 64bitSo guesstimating:So that is a lower limit on my ram usage in gigabytes if I created that many dictionaries, not factoring in the ! Rather than use a dict as a record type, which isn't really the use case, use a .And to get a view of how this compares, let's set up an equivalent list of tuples:Consider:So 5 gigs is an upper limit that is quite conservative. For example, it assumes that there is no small-int caching going on, which for a record-type of ages will totally matter. On my own system, the python process is registering 2.7 gigs of memory usage (via ).So, what is actually going on in my machine is better modeled by being conservative for strings assuming -- unique strings that have an average size of 10, so no string interning -- but liberal for ints, assuming int-caching is taking care of our  objects for us, so we just have to worry about the 8-byte pointers!Which is a good model for what I'm observing from .If you really want efficient storageNow, if you really want to cram data into ram, you are going to have to lose the flexibility of Python. You could use the  module in combination with , to get C-like memory efficiency. An easier world to wade into might be  instead, which allows for similar things. For example:Note, we are now allowed to be quite compact. I can use 8-bit unsigned integers (i.e. a single byte) to represent age. However, immediately I am faced with some inflexibility: if I want efficient storage of strings I must define a maximum size. I've used , which is 20 characters. These are ASCII bytes, but a field of 20 ascii characters might very well suffice for names. Now,  gives you a lot of fast methods wrapping C-compiled code. So, just to play around with it, let's fill our records with some toy data. Names will simply be string of digits from a simple count, and age will be selected from a normal distribution with a mean of 50 and a standard deviation of 10. Now, we can use numpy to query our . For example, if you want the indices of your records given some condition, use :So  records that have an age . Now, let's try :Of course, one major inflexibility is that  arrays are sized. Resizing operations are expensive. Now, you could maybe wrap a  in some class and it will act as an efficient backbone, but at that point, you might as well use a real data-base. Lucky for you, Python comes with .
Let's look at thisSo ~10 GB. Python is doing exactly what you are asking it to do.You need to split this up into chucks and check them sequentially.Try this as a starting point
... 35 million dictionary objects within a list. Each dictionary object  contains two key/value pairs. eg.  {'Name': 'Jordan', 'Age': 35}You're right that this manner of storage has considerable overhead. The Flyweight Design Pattern suggests that the solution involves factoring-out the commonalities.  Here are two ideas for alternative storage of the same data with better space utilization.You can use __slots__ to save space on instances of classes (this suppresses the creation of per-instance dictionaries):It is even more space-efficient to use dense data structures like a pair of parallel lists:If there duplicates in the data, you save even more space by interning the values:Or in Python 3:


Answer URL
https://docs.python.org/3/reference/datamodel.html#slots
