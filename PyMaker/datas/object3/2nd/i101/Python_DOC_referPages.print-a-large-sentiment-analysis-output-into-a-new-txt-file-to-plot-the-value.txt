Natural Text
I'm used to doing However, it seems that  is getting deprecated. What is the recommended way to do the line above?Update:Regarding all those answers with ...is this universal or Unix-specific? IE, should I be doing  on Windows?
This should be as simple as:From The Documentation:Do not use  as a line terminator when writing files opened in text mode (the default); use a single '\n' instead, on all platforms.Some useful reading:The  statement'a' is for append, or use'w' to write with truncation (particularly )
You should use the  function which is available since Python 2.6+For Python 3 you don't need the , since the   function is the default.The alternative would be to use:Quoting from Python documentation regarding newlines:On output, if newline is None, any  characters written are translated to the system default line separator, . If newline is , no translation takes place. If newline is any of the other legal values, any  characters written are translated to the given string.
The python docs recommend this way:So this is the way I usually do it :)Statement from docs.python.org:It is good practice to use the 'with' keyword when dealing with file  objects. This has the advantage that the file is properly closed after  its suite finishes, even if an exception is raised on the way. It is  also much shorter than writing equivalent try-finally blocks.
Regarding os.linesep:Here is an exact unedited Python 2.7.1 interpreter session on Windows:On Windows:As expected, os.linesep does NOT produce the same outcome as . There is no way that it could produce the same outcome.  is equivalent to , which is NOT equivalent to .It's this simple: use  which will be translated automatically to os.linesep. And it's been that simple ever since the first port of Python to Windows.There is no point in using os.linesep on non-Windows systems, and it produces wrong results on Windows.DO NOT USE os.linesep!
I do not think there is a "correct" way.I would use:In memoriam Tim Toady.
In Python 3 it is a function, but in Python 2 you can add this to the top of the source file:Then you do 
If you are writing a lot of data and speed is a concern you should probably go with . I did a quick speed comparison and it was considerably faster than  when performing a large number of writes.On average  finished in 2.45s on my machine, whereas  took about 4 times as long (9.76s). That being said, in most real-world scenarios this will not be an issue.If you choose to go with  you will probably find that you'll want to suppress the newline from time to time, or replace it with something else. This can be done by setting the optional  parameter, e.g.;Whichever way you choose I'd suggest using  since it makes the code much easier to read.Update: This difference in performance is explained by the fact that  is highly buffered and returns before any writes to disk actually take place (see this answer), whereas  (probably) uses line buffering. A simple test for this would be to check performance for long writes as well, where the disadvantages (in terms of speed) for line buffering would be less pronounced.The performance difference now becomes much less pronounced, with an average time of 2.20s for  and 3.10s for . If you need to concatenate a bunch of strings to get this loooong line performance will suffer, so use-cases where  would be more efficient are a bit rare.
Since 3.5 you can also use the pathlib for that purpose:Path.write_text(data, encoding=None, errors=None)Open the file pointed to in text mode, write data to it, and close the file:
When you said Line it means some serialized characters which are ended to '\n' characters. Line should be last at some point so we should consider '\n' at the end of each line. Here is solution:in append mode after each write the cursor move to new line, if you want to use 'w' mode you should add '\n' characters at the end of write() function:
One can also use the  module as in:


Answer URL
https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_text
