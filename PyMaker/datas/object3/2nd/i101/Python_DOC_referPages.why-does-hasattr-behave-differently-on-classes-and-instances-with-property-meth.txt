Natural Text
I implemented a write-only property in my class with . The weird thing is that  behaves differently on the class and corresponding instance with this property.From the result of ,  tries to execute the method and raises an error, while  doesn't execute the  method. Why do they behave differently?
Adding to what @timgeb mentioned, there is lot happening in the background than what it appears.Properties are implemented as Descriptors and the way attribute lookup happens is different when you access an attribute with  and . When you access the attribute with object like  basically the rules for attribute lookup are as followsLooks inside  and see if this attribute is a data descriptor, if yes then the call the , this translates to .Look in the  of the object and return If the attribute is a non-data descriptor, call its , this again translates to .Fetch the attribute from  of the class.Call the default implementation of .Now when you try to access the same attribute with  the same rules apply with a slight difference that this time  of the class is also involved, so here it looksDoes the metaclass has data descriptor defined for this attribute, if yes then call return  on it.Look inside  of the class and see if this attribute is a descriptor of any type, if yes then fetch the attribute calling the , if it is not a descriptor fetch the value from  of the class.If the attribute is a non-data descriptor in the metalcass, call its .Fetch the attribute from  of the metaclass.Call the default implementation of . Further the default implementation of  for properties has a check that when you access the attribute with the class, it returns the descriptor instance itself, however when you access the attribute with object it actually fires the code inside the . This also explains why  returns  because since you are calling the attribute with class the  is not getting executed and hence  is not being raised and  returns  as it encounters exception.
Properties are descriptors.Regarding :When you access an attribute via  or the dot-notation on an object () and the class of that object () happens to have a descriptor going by the name you are trying to access, that descriptor's  method is called1, as happens when you issue . In your specific case, the logic you defined in your getter (raising the ) will be executed.With  the instance passed to the  method is , in which case  just returns the descriptor itself instead of executing the getter logic you implemented.1There are some special rules depending on whether you have a data or a non-data descriptor, as explained in the Descriptor HowTo.Regarding : returns  because  raises an error. See this question.


Answer URL
https://docs.python.org/3/howto/descriptor.html
