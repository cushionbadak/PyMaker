Natural Text
I am currently implementing a graphical calculator in Python, in a manner where you can type a natural expression and evaluate it. This is not a problem with most functions or operators, but as the factorial function is denoted by a  after the operand, this is more difficult.What I have is a string which contains a function, for example:  which needs to be replaced with: However, the string may also include other terms such as: and the factorial term may not necessarily contain brackets: I've been trying to find a solution to this problem, but to no avail, I don't think the  method can do this directly. Is what I seek too ambitious, or is there some method by which I could achieve a result as desired?
There's two levels of answer to your question: (1) solve your current problem; (2) solve your general problem.(1) is pretty easy - the most common, versatile tool in general for doing string pattern matching and replacement is Regular Expressions (RE). You simply define the pattern you're looking for, the pattern you want out, and pass the RE engine your string. Python has a RE module built-in called . Most languages have something similar. Some languages (eg. Perl) even have it as a core part of the language syntax.A pattern is a series of either specific characters, or non-specific ("wildcard") characters. So in your case you want the non-specific characters before a specific '!' character. You seem to suggest that "before" in your case means either all the non-whitespace characters, or if the proceeding character is a ')', then all the characters between that and the proceeding '('. So let's build that pattern, starting with the version without the parentheses:And then the version with the parentheses:Then we just need to put it all together. We use  to match the first pattern OR the second pattern. And we use  and  to denote the part of the pattern we want to "capture" - it's the bit before the '!' and inside the parentheses that we want to use later. So your pattern becomes:Don't worry, RE expressions always come out looking like someone has just mashed the keyboard. There are some great tools out there like RegExr which help break down complex RE expressions.Finally, you just need to take your captures and stick them in "math.factorial".  means the th match. If the first pattern matches,  will be blank and vice-versa, so we can just use both of them at once.That's it! Here how you run your RE in Python (note the  before the strings prevents Python from trying to process the  as an escape sequence): takes three parameters (plus some optional ones not used here): the RE pattern, the replacement string, and the input string. This produces:which is I believe what you're after.Now, (2) is harder. If your intention really is to implement a calculator that takes strings as input, you're quickly going to drown in regular expressions. There will be so many exceptions and variations between what can be entered and what Python can interpret, that you'll end up with something quite fragile, that will fail on its first contact with a user. If you're not intending on having users you're pretty safe - you can just stick to using the patterns that work. If not, then you'll find the pattern matching method a bit limiting.In general, the problem you're tackling is known as lexical analysis (or more fully, as the three step process of lexical analysis, syntactic analysis and semantic analysis). The standard way to tackle this is with a technique called recursive descent parsing.Intriguingly, the Python interpreter performs exactly this process in interpreting the  statement above - compilers and interpreters all undertake the same process to turn a string into tokens that can be processed by a computer.You'll find lots of tutorials on the web. It's a bit more complex than using RE, but allows significantly more generalisation. You might want to start with the very brief intro here.
You could remove the brackets and calculate everything in a linear form, such that when parsing the brackets it would evaluate the operand, and then apply the factorial function - in the order written.Or, you could get the index of the factorial  in the string, then if the character at the index before is a close bracket   you know there is a bracketed operand that needs to be calculated prior to applying math.factorial().


Answer URL
https://docs.python.org/3/library/re.html
