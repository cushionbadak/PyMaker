Natural Text
I'm trying to do some of the code golf challenges, but they all require the input to be taken from . How do I get that in Python?
You could use the  module: will loop through all the lines in the input specified as file names given in command-line arguments, or the standard input if no arguments are provided.Note:  will contain a trailing newline; to remove it use 
There's a few ways to do it. is a file-like object on which you can call functions  or  if you want to read everything or you want to read everything and split it by newline automatically. (You need to  for this to work.)If you want to prompt the user for input, you can use  in Python 2.X, and just  in Python 3.  If you actually just want to read command-line options, you can access them via the sys.argv list.You will probably find this Wikibook article on I/O in Python to be a useful reference as well.

Python also has built-in functions  and . See the Python documentation under Built-in Functions.For example,or
Here's from Learning Python:On Unix, you could test it by doing something like:On Windows or DOS, you'd do:
The answer proposed by others:is very simple and pythonic, but it must be noted that the script will wait until EOF before starting to iterate on the lines of input.This means that  will not process lines as expected.The correct script for such a use case would be:UPDATEFrom the comments it has been cleared that on python 2 only there might be buffering involved, so that you end up waiting for the buffer to fill or EOF before the print call is issued.
How do you read from stdin in Python?I'm trying to do some of the code golf challenges, but they all require the input to be taken from stdin. How do I get that in Python?You can use: - A file-like object - call  to read everything. - pass it an optional prompt to output, it reads from stdin up to the first newline, which it strips. You'd have to do this repeatedly to get more lines, at the end of the input it raises EOFError. (Probably not great for golfing.) In Python 2, this is . - In Python 3  accepts file descriptors (integers representing operating system IO resources), and 0 is the descriptor of . It returns a file-like object like  - probably your best bet for golfing. - similar to , works on Python 2 and 3, but not on Windows (or even Cygwin). - returns an iterator over lines in all files listed in , or stdin if not given. Use like .Both  and  must be imported, respectively, of course.Quick  examples compatible with Python 2 and 3, Windows, UnixYou just need to  from , for example, if you pipe data to stdin:file exampleSay you have a file, , we can accept that file and write it back out: Longer answerHere's a complete, easily replicable demo, using two methods, the builtin function,  (use  in Python 2), and . The data is unmodified, so the processing is a non-operation.To begin with, let's create a file for inputs:And using the code we've already seen, we can check that we've created the file:Here's the help on  from Python 3:Builtin function,  ( in Python 2)The builtin function  reads from standard input up to a newline, which is stripped (complementing , which adds a newline by default.) This occurs until it gets EOF (End Of File), at which point it raises .Thus, here's how you can use  in Python 3 (or  in Python 2) to read from stdin - so we create a Python module we call stdindemo.py:And let's print it back out to ensure it's as we expect:Again,  reads up until the newline and essentially strips it from the line.  adds a newline. So while they both modify the input, their modifications cancel. (So they are essentially each other's complement.)And when  gets the end-of-file character, it raises EOFError, which we ignore and then exit from the program.And on Linux/Unix, we can pipe from cat:Or we can just redirect the file from stdin:We can also execute the module as a script:Here's the help on the builtin  from Python 3:Here we make a demo script using . The efficient way to iterate over a file-like object is to use the file-like object as an iterator. The complementary method to write to stdout from this input is to simply use :Print it back out to make sure it looks right:And redirecting the inputs into the file:Golfed into a command:File Descriptors for GolfingSince the file descriptors for  and  are 0 and 1 respectively, we can also pass those to  in Python 3 (not 2, and note that we still need the 'w' for writing to stdout).If this works on your system, it will shave off more characters. Python 2's  does this as well, but the import takes a lot more space:Addressing other comments and answersOne comment suggests  but that's actually longer than sys.stdin.read() - plus Python must create an extra list in memory (that's how  works when not given a list) - for contrast:The top answer suggests:But, since  implements the file API, including the iterator protocol, that's just the same as this:Another answer does suggest this. Just remember that if you do it in an interpreter, you'll need to do Ctrl-d if you're on Linux or Mac, or Ctrl-z on Windows (after Enter) to send the end-of-file character to the process. Also, that answer suggests  - which adds a  to the end - use  instead (if in Python 2, you'll need ). The real use-case for  is for reading in a series of files.
This will echo standard input to standard output:
Building on all the anwers using , you can also do something like the following to read from an argument file if at least one argument exists, and fall back to stdin otherwise:and use it as eitheroror evenThat would make your Python script behave like many GNU/Unix programs such as ,  and .
The following chip of code will help you (it will read all of stdin blocking unto , into one string):
 is an easy solutionExample compatible with both Python versions 2 and 3:You can run this script in many ways:1. Using â€ƒ or shorter by replacing  by here string:2. Using a filename argument3. Using  through the special filename 
Try this:and check it with:
You can read from stdin and then store inputs into "data" as follows:
I am pretty amazed no one had mentioned this hack so far:compatible with both python2 and python3
Read from , but to read binary data on Windows, you need to be extra careful, because  there is opened in text mode and it will corrupt  replacing them with .The solution is to set mode to binary if Windows + Python 2 is detected, and on Python 3 use .
The problem I have with solutionis that if you don't pass any data to stdin, it will block forever. That's why I love this answer: check if there is some data on stdin first, and then read it. This is what I ended up doing:
I had some issues when getting this to work for reading over sockets piped to it. When the socket got closed it started returning empty string in an active loop. So this is my solution to it (which I only tested in linux, but hope it works in all other systems)So if you start listening on a socket it will work properly (e.g. in bash):And you can call it with telnet or just point a browser to localhost:12345
Regarding this:I just tried it on python 2.7 (following someone else's suggestion) for a very large file, and I don't recommend it, precisely for the reasons mentioned above (nothing happens for a long time). I ended up with a slightly more pythonic solution (and it works on bigger files):Then I can run the script locally as:



Answer URL
https://docs.python.org/3/library/functions.html#input
https://docs.python.org/3/library/sys.html#sys.stdin
https://docs.python.org/3/library/functions.html#input
https://docs.python.org/3/library/functions.html#open
https://docs.python.org/3/library/argparse.html?highlight=stdin#filetype-objects
https://docs.python.org/3/library/argparse.html?highlight=stdin#filetype-objects
