Natural Text
While working on a buffer overflow exploit I found something really strange. I have successfully found that I need to provide 32 characters before the proper address I want to jump to and that the proper address is . When I executedthe exploit resulted in a success. But, when I tried:it didn't. The executable simply resulted in a Segmentation Fault without jumping to the desired address. In fact, executingandresults in two different output on the console. The characters are, of course, not readable but they're visually different.I wonder why is this happening? 
The Python 2 code writes bytes, the Python 3 code writes text that is then encoded to bytes. The latter will thus not write the same output; it depends on the codec configured for your pipe.In Python 3, write bytes to the  object instead:You may want to manually add the  newline that  would add. is a  object, encoding data written to it to a given codec (usually based on your locale, but when using a pipe, often defaulting to ASCII), before passing it on to the underlying buffer object. The  attribute gives you direct access to the underlying  object.


Answer URL
https://docs.python.org/3/library/io.html#io.TextIOBase
https://docs.python.org/3/library/io.html#io.TextIOBase.buffer
https://docs.python.org/3/library/io.html#io.BufferedIOBase
