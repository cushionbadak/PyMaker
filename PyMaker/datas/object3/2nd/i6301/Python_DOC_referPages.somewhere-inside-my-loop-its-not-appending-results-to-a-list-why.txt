Natural Text
So I have two files/dictionaries I want to compare, using a binary search implementation (yes, this is very obviously homework).One file isamerican-englishAnd the other file is british-englishThe code below should be pretty straight forward. Import files, compare them, return differences. However, somewhere near the bottom, where it says  I feel as if the debugger skips right over, even though I can see the two variables in memory being different, and I only get the final element returned in the end. Where am I going wrong?
You don't have an  suite for your  statement. Your  statement does nothing (it uses  when the test is true, skipped otherwise).You do have an  suite for the  loop:A  loop can have an  suite as well; it is executed when a loop completes without a  statement. So when your  loop completes, the current value for  is appended; so whatever was assigned last to that name.Fix your indentation if the  suite was meant to be part of the  test:However, you shouldn't use a  statement there, just invert the test:Note that the variable name  feels off here; you are appending words that are missing in the other list, not words that match. Perhaps  is a better variable name here.Note that your  function always returns , the word you searched on. That'll always be equal to the element you passed in, so you can't use that to detect if a word differed! You need to unindent that last  line and return  instead:Now you can use a list comprehension in your  loop:Last but not least, you don't have to re-invent the binary seach wheel, just use the  module:
With setsBinary search is used to improve efficiency of an algorithm, and decrease complexity from  to .Since the naive approach would be to check every word in  for every word in , the complexity would be .Using binary search would help to get , which is already much better.Using sets, you could get :You could get the american words not present in the british dictionary:You could get the british words not present in the american dictionary:You could get the union of the two last sets. I.e. words that are present in exactly one dictionary:This approach is faster and more concise than any binary search implementation. But if you really want to use it, as usual, you cannot go wrong with @MartijnPieters' answer.With two iteratorsSince you know the two lists are sorted, you could simply iterate in parallel over the two sorted lists and look for any difference:It outputs:It's  as well.


Answer URL
https://docs.python.org/3/library/bisect.html
