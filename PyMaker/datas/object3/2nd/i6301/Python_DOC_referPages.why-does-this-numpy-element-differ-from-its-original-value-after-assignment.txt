Natural Text
I've made a structured array in numpy and set a value like this:but the value actually is not 100.12, but 100.12000275. Even when I check if they are same, it says it's false:How can I assign exact 100.12 to an element?
There are a couple of things going on here, and not everything is what it appears, so let's separate everything out.Float ApproximationAs both @COLDSPEED and @Eric alluded to, when you have a floating point number, it's only an approximation of the "real" value that you intended to store. The reason for this fact is because computers store numbers in binary - base 2 representation - and 100.12 is thus 100 and 12/100. The integer portion is easy to represent using positive powers of 2, but the fractional portion has no exact representation in base 2 (you can see this by using Wolfram Alpha and running the query "12/100 base 2"). So, to store 100.12, the computer has to approximate 100 using powers of 2 (easy) and 12/100 using powers of 2 (impossible to do exactly), and it uses either 32 or 64 bits (32 or 64 slots corresponding to powers of 2) to do that. Everything beyond that is truncated, so the approximate value of 12/100 that is stored is not exact. The more bits in the representation, the closer the approximation is, and you could get arbitrarily close using arbitrarily more bits, but you'll never get it exactly.Float32 vs Float64 ApproximationDepending on how many bits are used to store each floating point number, 32 or 64, you'll get a better or worse approximation. You can see this by asking Python to print out 50 digits of each number (50 is too many, but just to illustrate - we'll get to printing next):Intermediate CalculationsDoing intermediate calculations can also change the final binary representation. Here's an example of that, comparing 100.12 to 100.02 + 0.10:In the first case, Python is creating an approximation for 12/100 using powers of 2. In the second case, Python is creating an approximation for 2/100 using powers of two, then another approximation of 1/10 using powers of two, then combining those two representations, leading to a different approximation.Print RepresentationAnother layer of approximation that's going on here is, when Numpy/Python prints 100.12000275, it's only printing that as part of the string representation of a Numpy array, which in turn uses a string representation of each element of the array. So, don't assume that printing an array gives you the "absolute" version of what the computer sees in that array. If you pull out that particular value and print it out using a print formatting string, you'll see there are more decimal points:However, I should point out that, because of the base-2 representation, printing 50 decimal places corresponds to printing more bits of accuracy than are actually stored by Python, so at some point even the number above is just an approximation of the approximation.Compare this to the case where you use : again, you see the layers of representation. Printing the array makes it look like you now have "exactly" 100.12, but using print formatting reveals that you only have a closer approximation:And again, this is just an approximation of an approximation - Python is turning the base 10 number "100.12" into a base 2 representation to store its value, and when you print it out it turns that base 2 representation back into a base 10 representation.Equality CheckYour equality check doesn't account for these multiple layers of representation because of the nature of the == operator. You are interpreting it as a mathematical equals operator, as in, 2 + 2 = 4. However, because of the binary representation of the floating point numbers, this doesn't work the way you would expect. (What I mean is, even if it did work, it would not work because it is actually checking if "100.12" equals the value of 100.12 in the array, it is checking if the computer representation of the thing on the left equals the computer representation of the thing on the right.) To check if two numbers are equal, don't use ==, use  or compare the absolute difference of the two numbers:Your question certainly is a rabbit hole into the guts of Python... Hope you enjoyed this little excursion.
 is a python , which is a  under the hood, but your array contains .When you do the assignment, the  is downcast to a , and you lose precision.When you do the comparison, the  is upcast to a , but the precision is not recovered, and so the values are not equal.@cᴏʟᴅsᴘᴇᴇᴅ is alluding to the fact that  is only an approximation of , and they are not exactly equal


Answer URL
https://docs.python.org/3/library/math.html#math.isclose
