Natural Text
I am new to Python and I am slowly learning via Codewars. I know this is potentially against the rules but I have an efficiency question. You are given a list of integersls = [100, 76, 56, 44, 89, 73, 68, 56, 64, 123, 2333, 144, 50, 132, 123, 34, 89]You must write a function choose_best_sum(t, k, ls)such that you find a combination of k integers from ls such that the sum of those k intergers is as close to or equal to t. My final solution passes the tests but on the more detailed testing fails perhaps because of efficiency. I am trying to understand efficiency more. Here is my codeCould someone highlight where the bottleneck is here (I assume on the permutations call) and how this function could be made faster?EDIT:The above solution profiled gave1806730 function calls in 0.458 secondsusing the assistance I got my final solution was:Ordered by: standard name7090 function calls in 0.002 seconds
You have a couple of obvious flaws in the expressionYou are running  twice for no good reason;You are packing the result into a list () and then unpacking it ()You are converting  to a set for no reasonTry replacing it withEdit: ok, a few ideas on a better algorithm:D'oh! First, use  instead of . You are just taking the sum; the order of items makes no difference. If you are running on ie k = 4,  will return 4! == 24 times fewer entries than  on the same input data.Second, we want to discard as many items as possible from  at the very start. Obviously we can throw out any value > t; but we can get a tighter bound than that. If we add the (k - 1) smallest values, the largest allowable value must be <= t - (k-1)_sum.(If we were looking for an exact sum, we could run this trick in reverse - adding the (k - 1) largest values would give us a minimum allowable value - and we could repeatedly apply those two rules to discard more possibilities. That does not apply here though.)Third, we could look at all combinations of (k - 1) values, then use  to jump directly to the best possible k'th value. There's a bit of a complication, because you have to double-check that the k'th value has not already been selected as one of the (k - 1) values - you can't do that directly using the built-in  function, but you could use a modified copy of the itertools.combinations code (ie test that  returns an index higher than the last one currently in use).Together these should speed up your code by a factor of ... Good luck!Edit 2:Let this be a lesson in the dangers of over-optimization :-)


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.combinations
