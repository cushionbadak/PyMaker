Natural Text
Python's  function returns the unique identifier for an object. So when in my terminal I do something like:Now, I know that python keeps track of all the objects created and number of references to that object and when the value reaches 0, the object is garbage collected.What I want to know is that what happens when I do something like this:I never created an object with value 27 i.e i never wrote  still somehow I get a unique identifier for this. Does this mean that an object was created in memory? If yes, even then there should be 0 references to this object and it should have been garbage collected.So, when is an Object actually created in Memory ?Please let me know if i am wrong somewhere.Another interesting thing that I just found out is:28487496In this case Python remembers the reference to number 23 itself, how does Python do this?
Objects are created as needed, in different places.To start, when you writetwo things happen. The  expression is evaluated, resulting in an integer object being pushed onto the stack, and then, as a separate step, the object is assigned to . Assignment doesn't create objects.If you did just this:The  expression is still evaluated. The object would be created*, then destroyed again as the reference count drops back to 0 again.That's needed because you could pass that object to another function:needs something to be passed to the  function. So  is added to the stack so you can call the function.I'll use a mutable object instead of an integer, to illustrate that a new object is created; so instead of  I'll use  and ask the  module to show me the bytecode that Python would execute:The  opcode is used to create the empty list object and push it onto the stack, and  then calls  to passing in one value from the stack, which is that list.I didn't use  because immutable objects like integers and tuples and such are actually cached with the bytecode that is compiled; these are created when Python compiles the code (or when you load the  bytecode cache from disk):Note the , it loads the data from the  structure:So objects can be created when compiling, or when execuning special opcodes for specific Python syntax.There are more places:There are more opcodes, for creating lists, tuples, dictionaries, sets and strings, for example.When you create an instance of a class,  will create an instance object on the heap. So  creates an object with the right type.The same applies to all built-in types;  creates an integer object on the heap.Plenty of built-in functions will create new objects as needed, returning those from calls,  statements and the  expression create objects (class objects, functions, and more functions, these are all objects too).* Small integers are actually interned; for performance reasons, CPython keeps a single copy each of the integers between -5 and and 256, so these objects are actually created only once, and referenced everywhere you need one. See "is" operator behaves unexpectedly with integers. For the purposes of this answer I'm ignoring this.And because they are interned, the result of  returns that single copy and the  will still be the same as if you asked for  directly.There are more implementation details; there are many more. Some string objects are interned (see my answer here). Code evaluated in the interactive interpreter is compiled one top-level block at a time, but in a script compilation is done per scope instead. Because constants are attached to compiled code objects, that means that there are differences as to when constants are shared. Etc. etc.The only objects you can rely on not being recreated all the time are explicitly documented in the datamodel documentation as being singletons;  being the most prominent of these.


Answer URL
https://docs.python.org/3/library/dis.html
https://docs.python.org/3/library/dis.html#opcode-BUILD_LIST
https://docs.python.org/3/library/dis.html#opcode-CALL_FUNCTION
https://docs.python.org/3/library/dis.html#opcode-LOAD_CONST
https://docs.python.org/3/reference/datamodel.html
