Natural Text
When using Python's built in  function on strings, I was just playing with it when I noticed something odd. Typically, a normal hash function is supposed to be uncorrelated, in the sense that from ,  should be completely unrecognizable (for sufficient definitions of uncorrelated/unrecognizable).However, this quick little script shows otherwiseI understand Python's  function isn't supposed to be cryptographically secure by any stretch, and for that you would use the  library, but why are the values of  so regularly distributed? This seems to me like it could have poor collision behavior.
The hash is calculated one character after the other. That's why the hashes are so similar.During the computation,  and  have the exact same hash up to . There's only one bit difference, in the last character. In secure hashes, changing one bit anywhere should completely change the whole hash (e.g. thanks to multiple passes).You can check this behaviour by calculating the hash of "0test" and "1test":This is the kind of widespread distribution you were expecting, right? By the way, Python 3 seems to have a different hash computation for strings.For more information about Python2 string hash, take a look at "Python Hash Algorithms":By the way, this problem isn't related to Python. In Java,  and  share the same hash. 
the python  function is not a cryptographic hash (i.e. must not protect against collisions or show an avalanche effect etc.); its just a identifier (e.g. to be used as dictionary keys) for objects.read more about  and hash in the documentation.as stated there: should return an integer. The only required property is that objects which compare equal have the same hash valueand - as Jean-Fran√ßois Fabre pointed out in a comment - python hashes must be fast (i.e. to build dictionaries). cryptographic hashes are slow and therefore unusable for that.by the way: in python 3 the distribution looks way more random.
The explanation can be found in the comments for the source code of Python2.7's Objects/dictobject.c:Major subtleties ahead:  Most hash schemes depend on having a "good"  hash function, in the sense of simulating randomness.  Python doesn't:  its most important hash functions (for strings and ints) are very  regular in common cases:This isn't necessarily bad!  To the contrary, in a table of size 2**i,  taking the low-order i bits as the initial table index is extremely  fast, and there are no collisions at all for dicts indexed by a  contiguous range of ints. The same is approximately true when keys are  "consecutive" strings.  So this gives better-than-random behavior in  common cases, and that's very desirable.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__hash__
https://docs.python.org/3/library/functions.html#hash
https://docs.python.org/3/reference/datamodel.html#object.__hash__
