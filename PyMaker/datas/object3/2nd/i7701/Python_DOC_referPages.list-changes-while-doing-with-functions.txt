Natural Text
I get the following results -If I perform deepcopy -results are the same -If I work on assignment operations -then results are -Can somebody explain what exactly makes a difference between the copies? Is it something related to mutable & immutable objects? If so, can you please explain it to me?
Normal assignment operations will simply point the new variable towards the existing object. The docs explain the difference between shallow and deep copies:The difference between shallow and deep copying is only relevant for  compound objects (objects that contain other objects, like lists or  class instances):A shallow copy constructs a new compound object and then (to the    extent possible) inserts references into it to the objects found in the original.A deep copy constructs a new compound object and then, recursively,    inserts copies into it of the objects found in the  original.Here's a little demonstration:Using normal assignment operatings to copy:Using a shallow copy:Using a deep copy:
For immutable objects, there is no need for copying because the data will never change, so Python uses the same data; ids are always the same. For mutable objects, since they can potentially change, [shallow] copy creates a new object.Deep copy is related to nested structures. If you have list of lists, then deepcopy  the nested lists also, so it is a recursive copy. With just copy, you have a new outer list, but inner lists are references.Assignment does not copy. It simply sets the reference to the old data. So you need copy to create a new list with the same contents.
For immutable objects, creating a copy don't make much sense since they are not going to change. For mutable objects , and  behaves differently. Lets talk about each of them with examples.An assignment operation simply assigns the reference of source to destination e.g:Now  and  technically refers to same list. Both  and  have same memory address. Any updation to eitherof them will be reflected to the other. e.g: On the other hand  and  creates a new copy of variable. So now changes to original variable will not be reflectedto the copy variable and vice versa. However , don't creates a copy of nested objects, instead it just copies the reference of nested objects. Deepcopy copies all the nested objects recursively.Some examples to demonstrate behaviour of  and : Flat list example using :Nested list example using :Flat list example using : Nested list example using :
Let's see in a graphical example how the following code is executed:
a, b, c, d, a1, b1, c1 and d1 are references to objects in memory, which are uniquely identified by their ids.An assignment operation takes a reference to the object in memory and assigns that reference to a new name.   is an assignment that creates a new list object containing those four integers, and assigns the reference to that object to .   is an assignment that takes the same reference to the same object and assigns that to .  Since the list is mutable, anything that happens to that list will be visible regardless of whether you access it through  or , because they both reference the same object. is a "shallow copy" that creates a new list and assigns the reference to the new list to .   still points to the original list.  So, if you modify the list at , the list that  refers to will not change.The concept of copying is irrelevant to immutable objects like integers and strings.  Since you can't modify those objects, there is never a need to have two copies of the same value in memory at different locations.  So integers and strings, and some other objects to which the concept of copying does not apply, are simply reassigned.  This is why your examples with  and  result in identical ids. is a "deep copy", but it functions the same as a shallow copy in this example.  Deep copies differ from shallow copies in that shallow copies will make a new copy of the object itself, but any references inside that object will not themselves be copied.  In your example, your list has only integers inside it (which are immutable), and as previously discussed there is no need to copy those.  So the "deep" part of the deep copy does not apply.  However, consider this more complex list:This is a list that contains other lists (you could also describe it as a two-dimensional array).If you run a "shallow copy" on , copying it to , you will find that the id of the list changes, but each copy of the list contains references to the same three lists -- the lists with integers inside.  That means that if you were to do , then  would be .  But  would also be .  On the other hand, if you subsequently did ,  would be .  But  would still be .  That's because the outer lists are separate objects that initially each contain three references to three inner lists.  If you modify the inner lists, you can see those changes no matter if you are viewing them through one copy or the other.  But if you modify one of the outer lists as above, then  contains three references to the original three lists plus one more reference to a new list.  And  still only contains the original three references.A 'deep copy' would not only duplicate the outer list, but it would also go inside the lists and duplicate the inner lists, so that the two resulting objects do not contain any of the same references (as far as mutable objects are concerned).  If the inner lists had further lists (or other objects such as dictionaries) inside of them, they too would be duplicated.  That's the 'deep' part of the 'deep copy'.
In python, when we assign objects like list, tuples, dict, etc to another object usually with a ' = ' sign, python creates copy’s by reference. That is, let’s say we have a list of list like this :and we assign another list to this list like :then if we print list2 in python terminal we’ll get this :Both list1 & list2 are pointing to same memory location, any change to any one them will result in changes visible in both objects, i.e both objects are pointing to same memory location.If we change list1 like this :then both list1 and list2 will be :Now coming to Shallow copy, when two objects are copied via shallow copy, the child object of both parent object refers to same memory location but any further new changes in any of the copied object will be independent to each other.Let’s understand this with a small example. Suppose we have this small code snippet :notice, list2 remains unaffected, but if we make changes to child objects like :then both list1 and list2 will get change :Now, Deep copy helps in creating completely isolated objects out of each other. If two objects are copied via Deep Copy then both parent & it’s child will be pointing to different memory location.Example :notice, list2 remains unaffected, but if we make changes to child objects like :then also list2 will be unaffected as all the child objects and parent object points to different memory location :Hope it helps.
Below code demonstrates the difference between assignment, shallow copy using the copy method, shallow copy using the (slice) [:] and the deepcopy. Below example uses nested lists there by making the differences more evident.
The GIST to take is this:Dealing with shallow lists (no sub_lists, just single elements) using "normal assignment" rises a "side effect" when you create a shallow list and then you create a copy of this list using "normal assignment". This "side effect" is when you change any element of the copy list created, because it will automatically change the same elements of the original list. That is when  comes in handy, as it won't change the original list elements when changing the copy elements.On the other hand,  does have a "side effect" as well, when you have a list that has lists in it (sub_lists), and  solves it. For instance if you create a big list that has nested lists in it (sub_lists), and you create a copy of this big list (the original list). The "side effect" would arise when you modify the sub_lists of the copy list which would automatically modify the sub_lists of the big list. Sometimes (in some projects) you want to keep the big list (your original list) as it is without modification, and all you want is to make a copy of its elements (sub_lists). For that, your solution is to use  which will take care of this "side effect" and makes a copy without modifying the original content.The different behaviors of  and  operations concerns only compound objects (ie: objects that contain other objects such as lists).Here are the differences illustrated in this simple code example:First let's check how  (shallow) behaves, by creating an original list and a copy of this list:Now, let's run some  tests and see how the original list behave compared to its copy list:original_list and copy_list have different addresseselements of original_list and copy_list have the same addressessub_elements of original_list and copy_list have the same addressesmodifying original_list elements does NOT modify copy_list elementsmodifying copy_list elements does NOT modify original_list elementsmodifying original_list sub_elements automatically modify copy_list sub_elementsmodifying copy_list sub_elements automatically modify original_list sub_elementsSecond let's check how  behaves, by doing the same thing as we did with  (creating an original list and a copy of this list):Now, let's run some  tests and see how the original list behave compared to its copy list:original_list and copy_list have different addresseselements of original_list and copy_list have the same addressessub_elements of original_list and copy_list have different addressesmodifying original_list elements does NOT modify copy_list elementsmodifying copy_list elements does NOT modify original_list elementsmodifying original_list sub_elements does NOT modify copy_list sub_elementsmodifying copy_list sub_elements does NOT modify original_list sub_elements
a=lstb=lst[:]b      [1, 2, 3, 4, 5]a      [1, 2, 3, 4, 5]lst is b      Falselst is a      Trueid(lst)      46263192id(a)      46263192 ------>  See here id of a and id of lst is same so its called deep copy and even boolean answer is trueid(b)      46263512 ------>  See here id of b and id of lst is not same so its called shallow copy and even boolean answer is false although output looks same.


Answer URL
https://docs.python.org/3/reference/simple_stmts.html#assignment-statements
https://docs.python.org/3/library/copy.html#copy.copy
https://docs.python.org/3/library/copy.html#copy.deepcopy
