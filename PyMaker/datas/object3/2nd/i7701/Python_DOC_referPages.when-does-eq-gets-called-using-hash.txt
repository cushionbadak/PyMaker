Natural Text
As mentioned here,Below code,Output:Question:Why  gets called on accessing but not on ?
Short answer: a dictionary lookup first does a (cheap) reference equality check () when searching a bucket, and only if that fails, a (more expensive) equality check () is done.ScenarioThe  function does not call  internally. Given you construct  and , no such methods are called.Next you associate  with . In order to know in which bucket of the dictionary, you have to store , you calculate the hash. Now once you have done that we store  (and the value in the correct bucket).Next we want to obtain . In order to know in which bucket  resides, we calculate the hash. Next we start searching in the bucket. The bucket will contain . We first perform a reference check () but that fails, so then we fallback on the equality check. That check succeeds, so we return the value corresponding with : .The same scenario happens when we want to look for : we calculate the hash, fetch the bucket. Perform a reference check on , and that one succeeds. So we do not need a (probably more expensive equality check). We simply return the value .Reference checksThe fact that a reference check is done first can be proven with the following (unhealthy) code:Here we return always  for equality. So even: is not equal to itself (this is actually not good design, since for a dictionary, it is a contract that an object is equal to itself: a good equality relation is reflexive, symmetrical and transitive). Nevertheless, if we associate  with , we are still able to fetch the value associated with :
To answer the title:When does  gets called using hash()?Never. The other question:Why  gets called on accessing jim but not on bob?That's more complicated. To understand that you need to know how a dictionary is implemented. Assuming CPython it will be a table containing a  column, a  column and a  column:It will have a certain size but it won't be big enough to contain every possible  value, so it will calculate the position based on the . For example if you add  it could have (string hashes are randomized in certain CPython versions so the actual result will differ) a  of . Assuming the dictionary has an actual size of 2 (in reality it will be bigger, but that would unnecessarily waste space in the answer) it just takes the modulo, so it will place it in :When you want to look up a key italways calculate the  of the lookupthen it will calculate the position. Then it compares the  of the lookup to the  saved in that positionif the es are equal then it will compare the lookup and the saved  with . That will:first check for identity: if that is  it will check So in case you lookup :hash: position:  -> found an entry, so compare the es: that was equal so check for identity:  -> So it returns  without an equality check. In the second case it checks for :hash: position:  -> found an entry, so compare the es: that was equal so check for identity:  -> check for equality  -> So it returns .This is just an approximation of the actual implementation (it's missing some details). It gets more complicated if the es are not equal or the  but these are not really important to understand the observed behavior you questioned.However, I really need to say this: What you're doing is really dangerous because your class isn't immutable. You could accidentally make the saved dictionary entry unavailable to you:(It could still work in case the new  is equal to the "old" hash, but that would be rather accidental).That's because while you alter the  of your instance - the dictionary won't update the saved  because it assumes all keys are immutable! So the dictionary would either assume it would be saved in another position or if the position would (miraculously) be the same then it would fail in the step where it contains the actual hashes.


Answer URL
https://docs.python.org/3/c-api/object.html#c.PyObject_RichCompareBool
https://docs.python.org/3/c-api/object.html#c.PyObject_RichCompareBool
