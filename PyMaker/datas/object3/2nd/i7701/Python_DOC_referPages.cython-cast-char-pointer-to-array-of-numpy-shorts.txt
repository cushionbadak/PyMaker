Natural Text
I'm trying to improve on the time taken in adding two fixed length arrays. I must convert 2 strings of bytes into 2 short arrays of fixed length and then add the two arrays together, finally outputting the resultant array as a string of bytes. Currently I have:however, the simpler numpy only method yields a very similar (better) performance:Is it possible to improve on numpy speed for this simple example ? My gut says yes but I don't have enough of a handle on Cython to improve anymore. Using Ipython  magic I've clocked the functions at:e.g:edit: changes  to show  orig and new are both byte arrays of length 2048. Converting them to shorts () results in an output array of size 1024.edit2: I'm an idiot.edit3: example in action
One solution is to skip the numpy arrays and just use C pointers:Essentially, I create an empty string for the result using the C API function  and modify that. The advantages of that are that unlike your version the both the inputs and outputs are used as is and not copied. Note that the only situation where you're allowed to modify Python strings like this is when you've just created an new one using  - this is in the C API documentation.I then get a  to it (doesn't copy the data, just points to existing data).I then cast the  for both inputs and the output to be  - this just changes how the memory is interpreted.I then loop over the array doing the addition and using pointer indexing.In terms of speed, this is about 8 times faster than the Python implementation for short strings (). This is largely due to the fixed Python overhead of function calls are creating numpy arrays I believe. For longer strings () my version actually slower slightly. I suspect numpy has a better vectorized/parallelized loop for the addition.Extra notesCode shown is form Python 3 - for Python 2 you want  instead of You can get a slight improvement (~10-20%) on your pure Python version by using  instead of . This avoids copying the inputs.


Answer URL
https://docs.python.org/3/c-api/bytes.html
