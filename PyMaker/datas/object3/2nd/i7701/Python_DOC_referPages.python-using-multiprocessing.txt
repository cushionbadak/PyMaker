Natural Text
I am trying to use multiprocessing in python 3.6. I have a that runs a  with different arguments. Currently, it is running one at a time which is taking quite a bit of time so I am trying to use multiprocessing. Here is what I have:I think what my code is using 3 processes to run one  but I would like to run 1 method per process but I don't know how this is done. I am using 4 cores btw.
You're making a pool at every iteration of the for loop. Make a pool beforehand, apply the processes you'd like to run in multiprocessing, and then join them:
You're not populating your  with data - you're re-initializing the pool on each loop. In your case you can use  to do all the heavy work for you:Also, given all those  arguments I reckon you're snatching this off of a class instance and if so - don't, unless you know what you're doing. Since multiprocessing in Python essentially works as, well, multi-processing (unlike multi-threading) you don't get to share your memory, which means your data is pickled when exchanging between processes, which means anything that cannot be pickled (like instance methods) doesn't get called. You can read more on that problem on this answer.
I think what my code is using 3 processes to run one method but I would like to run 1 method per process but I don't know how this is done. I am using 4 cores btw.No, you are in fact using the correct syntax here to utilize 3 cores to run an arbitrary function independently on each. You cannot magically utilize 3 cores to work together on one task with out explicitly making that a part of the algorithm itself/ coding that your self often using threads (which do not work the same in python as they do outside of the language). You are however re-initializing the pool every loop you'll need to do something like this instead to actually perform this properly:Take a look at the  docs for more specific information if you'd like to get a better understanding of how it works.  Under python, you cannot utilize threading to do multiprocessing with the default CPython interpreter.  This is because of something called the global interpreter lock, which stops concurrent resource access from within python itself.   The GIL doesn't exist in other implementations of the language, and is not something other languages like C and C++ have to deal with (and thus you can actually use threads in parallel to work together on a task, unlike CPython) Python gets around this issue by simply making multiple interpreter instances when using the multiprocessing module, and any message passing between instances is done via copying data between processes (ie the same memory is typically not touched by both interpreter instances).  This does not however happen in the misleadingly named threading module, which often actually slow processes down because of a process called context switching.  Threading today has limited usefullness, but provides an easier way around non GIL locked processes like socket and file reads/writes than async python. Beyond all this though there is a bigger problem with your multiprocessing.  Your writing to standard output.  You aren't going to get the gains you want.  Think about it.  Each of your processes "print" data, but its all being displayed in one terminal/output screen.  So even if your processes are "printing" they aren't really doing that independently, and the information has to be coalesced back into another processes where the text interface lies (ie your console). So these processes write whatever they were going to to some sort of buffer, which then has to be copied (as we learned from how multiprocessing works) to another process which will then take that buffered data and output it.  Typically dummy programs use printing as a means of showing how there is no order between execution of these processes, that they can finish at different times, they aren't meant to demonstrate the performance benefits of multi core processing. 


Answer URL
https://docs.python.org/3/library/multiprocessing.html
