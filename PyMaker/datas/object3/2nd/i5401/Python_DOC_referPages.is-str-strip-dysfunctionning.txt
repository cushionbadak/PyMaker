Natural Text
I have a list built from a string split operation, and I wanted to input it to map() function, then strip these substrings from their trailing parenthesis and spaces.And rebuild a list from them.  But in the end, I only strip oddly the substrings, while "all combinations are tested", as stated by docs.  I  know another method is available with list comprehension:which works.. But I wonder why map doesn't work correctly.  I am on python 3.6.4, with Anaconda 4.4 on windows64.  Subsidiary question; the following topic gives some pointers to find source code of functions. But I could not find the code for map (and generally, for builtin functions), so I could not see if there were bugs into it...
 with 3 arguments is not behaving the way you think it does. The 3rd argument for  is not the arguments for the function provided as the 1st argument. It is used as a 2nd iterable.From the docs:map(function, iterable, ...) Return an iterator that applies function  to every item of iterable, yielding the results. If additional  iterable arguments are passed, function must take that many arguments  and is applied to the items from all iterables in parallel. With  multiple iterables, the iterator stops when the shortest iterable is  exhausted. For cases where the function inputs are already arranged  into argument tuples, see itertools.starmap()In other words: is not equivalent to. It is remotely equivalent to See the difference?
 works differently from how you are using it. When you do , it yields , while you are using it like it will yield .To fix this, you can use a list comprehension, like in the question, or a lambda like .
You could use :
The problem is that you seem to be under the impression that the last argument to  gets passed as an argument to the function being mapped, that isn't what happens, instead, from the docs:map(func, *iterables) --> map objectMake an iterator that computes the function using arguments from each  of the iterables.  Stops when the shortest iterable is exhausted.In other words,  is the equivalent of:Which is not what you want. You want to partially apply  using  as the second argument, but instead,  is being take as another iterable of arguments. So, straightforward solution, use a helper function:You could make a factor function if you will be needing to be flexible:
Using  function it can be achieved as follows:


Answer URL
https://docs.python.org/3/library/functions.html#map
