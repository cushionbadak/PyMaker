Natural Text
My task is that I want to specify a seed for shuffling a list of of items such that I can re-create the shuffled result using the same seed as input next time. However, I tried a few "close but different numbers" (a fairly meaningless statement in retrospect) as seeds and they all produced the same results.Here is a piece of code I wrote as an attempt to examine the behavior of seed numbers in Python's random.shuffle()And the output looks something like this:According to the printout and some finer-grained seeds I tried between intervals, the seed interval which triggers "moving the first element to the last" is at least 0.05-0.0=0.05 (same as "doing nothing" for [0.9, 0.95]).There are two aspects about the behavior which I find troublesome:1) One-twentieth of the total interval is a large proportion. How are the rest of the shuffle behaviors fairly distributed in the rest of the intervals? (Doesn't "randomness" or "shuffle" conveys "Any order is possible?" How to cram the rest of the randomness in when a large interval is occupied by some behaviors.)2) "Shift head to tail" & "doing nothing" seem to be very bad/useless behaviors for a shuffling function. Is there something wrong with my implementation?Edit: I purposely picked seeds so I may reproduce results in my task. More info: I got the impression that I was using seeds from this post. Since  produces some float in [0.,1.), I assumed I can pick one myself and further test the behaviors of different seeds by picking them in different same-distance interval.Please tell me if I made false assumption, logic error, or bad coding. Thank you.
You are passing in a function that returns a fixed number:Here  is one of your floating point values. That's very different from the default  function; you are returning the same number repeatedly, forever. From the documentation:The optional argument random is a 0-argument function returning a random float in ; by default, this is the function .You produced the Dilbert accounting department random number generator here:When you pass in an alternative  function as the second argument, the value it returns is used to pick what preceding index to swap the 'current' index with (starting from the end); the source code that is run essentially does this:So your fixed number would always pick the same relative index to swap with. For small enough differences in that fixed value the rounding down to the nearest integer would result in the exact same indices being used to swap with.This is what happens for  to , for example; in both cases the indices picked are , not much of a 'random' shuffle. Ditto for  and , when you swap everything with index , and for  and , when you swap each index with itself.If you wanted to test how seeding works, create an instance of the  class with your seed and call  on that object:which outputsOr you could just call  each test, passing in the  value, but this changes the global  instance affecting other modules using it too.That second argument to  should really just be forgotten about, you never need it. It was only there in the first revision of the function as a performance improvement, to ensure that in a tight loop a local name was used instead of a global. But because it was added to the function signature without a leading underscore, it became part of the public API in perpetuity, by accident. There is no real use-case that requires it to be used.
You can check what it does:The  branch applies here and the  line in particular. This is the classic Fisher-Yates shuffleSo the 'used granularity' of the random value depends on the length of the list in general, and on index of the current element in particular.Oh, and by the way: you are not supplying a seed, you are supplying the random values - which end up being a single value for each iteration.What you could do instead is using your random values for a single shuffle:Or, you could use seed-s, but they are not really expected to be floating-point numbers between 0 and 1, seeand the parent class (where  ends up, with or without these mangling passes) is native code:and it may even happen that the passing a floating-point value results in running the final branch here, which uses the uninitialized  value here, resulting in consistent behaviour solely because the function calls preceding the invocation of this  leave the stack in the same state.
A seed is supposed to initialize a random number generator. You're instead using it to be the random number generator.You're doing:A correct way is:A better way is:


Answer URL
https://docs.python.org/3/library/random.html#random.seed
