Natural Text
I defined a class that holds a list collection of objects, and defined the  and  methods to make it for loopable. The collection here, is a  class that holds a list of  objects.Code:On running, I get the following error:It seems the thing doesn't for the second run of the for loop when I push the card object back into the list. How do I solve this while keeping the pop,push functionality.Edit: The  is at 50 after the first call to . When the card is added back to list, index remains at 50, whereas the deck length is now 51 cards. So in the second (and third) call to print the last card is printed instead of the entire deck. Then subsequently error is raised.I think I have read the documentation wrong here. My question is should I reset the index at the  bit. Is that the correct way to do this, or is the index supposed to reset on its own?
Note: If you are trying to learn how iterators work by implementing your own, then the above advice holds. If you just want to make your  iterable, you can just do this in :Even better, if you want your deck to behave like a list (iterating, indexing, slicing, removal), you can just extend .Learning how iterators work:The problem you have here is you are conflating a collection with an iterator. A collection should hold a group of items. Your  is a collection. A collection is iterable, which means I can do  on it. When we do , Python actually does , which turns the collection into an iterator.You want your iterator and collection to be separate. If you collection was its own iterator, then you can only have one iterator over it at a time (itself). Also note that iterators should only be used once. By doing  in your , you are making your iterator () reusable.Consider the following:We expect this to return:Note that each time the inner loop iterates over the whole collection. If  was its own iterator, then we'd have some issues:Unexpected output:The solution is  should return a new object called , which keeps track of its own .  should return self (as required by the docs), but that is just a detail. By doing this you enable multiple iterations over the deck at once that work as expected.So a minimal example of this would be:Also, if you don't believe me about this list as its own iterator, here's a list that exhibits this bad behavior:Output from it:
Not sure how you got there, but you are beyond the length of your list.  Suggest you compare for  length of the list like:
Make the following changes,So that each time  is called,  is reset.The reason your'e getting this error is, once you iterate through the , at the end of the iteration, .The next time you iterate, the  should be reset to .I made the above change and it worked for me.
Your specific issue at the moment is caused by the check in your  method not being general enough to detect all situations where you've iterated past the last value in . Since  can change, you need to use a greater-than-or-equal test:This will fix the current issue, but you'll still have other problems, since your  can only be iterated once. That's because you've implemented the iterator protocol, rather than the iterable protocol.  These are easy to confuse, so don't feel bad if you don't understand the difference immediately.An iterable is any object with an  method that returns an iterator. Some iterables return different iterators each time they're called, so you can iterate on them multiple times.An iterator implements a  method, which yields the next value or raises . An iterator must also have an  method, which returns itself, which allows an iterator to be used wherever an iterable is expected, though it can only be iterated on once.For your , it probably makes sense to implement the iterable protocol, and return a separate iterator each time  is called. It's only rarely useful to implement your own iterator type, but if you want to test your knowledge of how the different protocols fit together, it can be interesting:A more practical approach is to have  borrow some convenient iterator type. For instance, you could do  and you'd get an iterator that works exactly like the custom version above. Another option is to make  a generator function, since generator objects are iterators. This can be convenient if you need to do just a little bit of processing on each item as you iterate over it.


Answer URL
https://docs.python.org/3/tutorial/classes.html#iterators
