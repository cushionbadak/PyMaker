Natural Text
I'm looking for solution of this problem:I have two functions:I would like to run them alternately, like:run foo1()stop foo1() run foo2()stop foo2() run foo1()Functions can't work simultaneously, at the moment only one of them can work.
Edit: Leave it to @StefanPochmann to shoot down my beautiful answer: It doesn't matter for the question as it is posed, but it is certainly worth mentioning that zip works pair-by-pair. So while you can formally pause  defined below after an odd number of iterations, at this point 'y' will have been printed already.If you care about this the solution also due to Stefan iswhich is actually pretty clever.Edit endsYou could convert the functions into generators, then zip them.or:
I personally favour the  approach by Paul Panzer. However, if it is an option, I'd strongly suggest moving the "infinite loop" out of these functions and instead putting it in another "driver" function that calls these two in an alternating fashion.I get that this won't be possible to implement in every situation, but it does lead to better design in the end if you can.
There's no way to do what you want with the functions you've shown. However, there are some approaches that might come close, to differing degrees, depending on what details you're willing to change in your current code.One option to get sort-of parallel execution is to use threads. Python doesn't actually allow more than one thread to be running Python code at once, so this isn't really useful in most situations, but it might be good enough for your specific use case. Unfortunately it does very badly with your current code, since one thread will tend to block the other for a long time, so you'll get lots of s, followed by lots of s, as they functions only swap the GIL irregularly.Another option is to use , which does allow parallel execution. It would do a better job of interleaving your two functions, but the exact timing of the swaps between the two processes will still not be exactly consistent, so you won't always get "xyxyxyxy", you might get something more like "xyxxyyxy" (the exact details may depend on your OS, CPU and how busy your machine is at the time you run the code).Now we get into solutions that require modifications to the functions. An obvious solution is to simply rewrite them into a single function that does both steps:Another option is to make the functions into generators, which you can combine yourself using :You could consume the generators like this:Or, if you want a single iterable:
From what you say you don't want/need for them really both be running at the same time, but rather to be able to switch execution back and forth among them. What you've describe is what's called co-operative multitasking. This can be accomplished by simply making each function a coroutine. In Python that can be accomplished by making them generator functions which is done by simply by adding a  statement to them at the right spot. That way they will each pause execution until  is called on them again.The only slightly tricky part is remembering that each generator function will need to be "primed" once it's called the first time (which actually doesn't execute the code in the function). The first call to  of the value returned by the first call to the function itself will advances its execution to the location of the first  in it.Here's what I mean:Output:If you're going to do a lot of this, you can create a decorator that will make generator functions used as coroutines prime themselves automatically (taken from a tutorial David Beazley gave at Pycon 2009 titled Curious Course on Coroutines and Concurrency).
So this is my personal way of doing this but there's probably a better one.So the way this works is  is working as an iterator. Then it checks it increments the iterator every time by 1 with . Next we check if  is odd or even and because it will alternate. So with every even number you will get  and every odd you you will get . Hope this helps!


Answer URL
https://docs.python.org/3/glossary.html#term-generator
