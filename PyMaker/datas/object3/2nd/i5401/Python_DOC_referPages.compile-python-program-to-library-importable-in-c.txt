Natural Text
I started off today wondering whether it is possible to save a python object for use in a C program, a proposition which, after many hours of reading looks naive. Here is a possible workaround:1. Create a complex object dependent on many python libraries with data inside I need preserved. 2. Pickle the complex object and place it where it will be accessible. 3. Define compileme.py:4.  to generate a .c version of the script.5. Define main.c:6. Compile main.c properly, with all the right linkages.It is not clear to me this basic solution strategy is sound, and I have a number of concerns:The  is of a class from a library not even mentioned here, so its  method depends on that external python. How can I ensure the relevant parts are also being compiled and linked?How should I include  in my  so the  will be accessible there? (location (A) in the code)How can I appropriately define an input to 's method here? Do I need to use one of the many types defined in ? (location (B) in the code)How do I compile  with the proper linkages?In doing all this, it appears I have to include references to the python header files from the  package. Just to be clear, I am not actually including the interpreter by doing this, correct?Here are some resources I've found during my search that prove it is possible to compile a simple python script to an executable compiled C program: Compile main Python program using Cythonhttp://masnun.rocks/2016/10/01/creating-an-executable-file-using-cython/Here is some relevant cython documentation:http://cython.readthedocs.io/en/latest/src/reference/compilation.html
I'm afraid this answer just explains why I don't think what you want is realistic, rather than offering solutions. It's worth looking at the code that Cython generates for a slightly modified This creates a function that you can happily call from C (the signature is generated in  and is ). The generated '.c' file containing the implementation is quite long, but the relevant section looks like:I've cut this down quite a bit for clarity (mostly removing reference counting and some checks) but you can see it uses the Python import mechanism to load the  module from the Python standard library, it does  to get the function . It calls the Python builtin  and then it calls . All of these operations need libpython.Then we consider what  does - it basically gets the .py file your class came from, imports that, and creates a new instance of your class, then populates the instance dictionary with data from the file (possibly calling some special methods if present). Again, this is entirely dependent on the using Python.Finally let's consider what you can do with the result of . You have a , a fairly opaque C structure. Most of its information is probably stored in its internal Python dictionary, which you can access through the Python C API  and related functions. However this data is still stored as other s which you will need to access using the Python C API. (If it's a Cython class the data may be stored in more accessible C struct fields which require less use of libpython, but probably not none).In summary, Cython is largely implemented using the Python C API, which requires access to the  library for anything but the absolute most trivial programs. Using Python standard library functions such as  requires the Python standard library is installed too. Therefore you can't really achieve this without needing to bundle Python with your C program. The examples that you linked fall in this category - they are C programs but they depend on Python being present.A better solution might be to look at common serialization formats that both Python and C support, such as JSON, XML, or HDF5 to allow you to save the data in one language and retrieve it in the other with as little effort as possible.


Answer URL
https://docs.python.org/3/library/pickle.html#pickling-class-instances
