Natural Text
In python, it is possible to chain operators in this manner:Which is evaluated to With the only difference being that  is evaluated only once (so, something more like ).This is advantageous from the view point that it is very readable and more concise than the equivalent version with explicit conjunction (using ). However... I've noticed that there is a minor performance difference between chained expressions and the equivalent, be it for 3 operands or 20. This becomes apparent when you time these operations.And,Note: All tests were done with Python-3.4.Examining the byte code for both expressions, I noticed that one performs significantly more (actually, 4 more) operations than the other.Contrast this with,I am not experienced with reading byte code, but the first code snippet definitely performs more operations at the byte code level than the second.Here's how I've interpreted this. In the first case, variables are pushed onto some sort of stack, and popped successively for comparison. All variables are popped only once. In the second case, there is no stack, but at least (N - 2) of the operands have to be loaded into memory twice for comparison. It appears the stack popping operation is more expensive than loading (N - 2) variables twice for comparison, accounting for the speed difference.In a nutshell, I'm trying to understand why one operation is always slower than the other by a constant factor. Is my hypothesis correct? Or is there something more to the python internals I'm missing? More benchmarks:
In CPython's stack-based bytecode execution engine, saving an extra reference to  for the chained comparison isn't free. It's at the "seriously, don't worry about it" level of cheap, but it's not literally free, and you're comparing it to the slightly cheaper operation of loading a local variable.The  opcode removes the objects it's comparing from the stack, so for the chained comparison, Python has to create another reference to  () and shove it two places down in the stack () to get it out of the way.In , instead of the above reference shuffling, Python just copies another reference to  out of the stack frame's  array. This involves less pointer shuffling and one less trip around the bytecode evaluation loop, so it's slightly cheaper.


Answer URL
https://docs.python.org/3/reference/expressions.html#comparisons
