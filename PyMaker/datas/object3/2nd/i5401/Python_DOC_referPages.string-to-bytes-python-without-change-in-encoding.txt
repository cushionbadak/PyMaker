Natural Text
I have this issue and I can't figure out how to solve it. I have this string:When I tried to encode it:I get this result:I only want:Anyone knows the reason and how to fix this. The string is already stored in a variable, so I can't add the literal b in front of it.
You cannot convert a string into bytes or bytes into string without taking an encoding into account. The whole point about the  type is an encoding-independent sequence of bytes, while  is a sequence of Unicode code points which by design have no unique byte representation.So when you want to convert one into the other, you must tell explicitly what encoding you want to use to perform this conversion. When converting into bytes, you have to say how to represent each character as a byte sequence; and when you convert from bytes, you have to say what method to use to map those bytes into characters.If you don’t specify the encoding, then UTF-8 is the default, which is a sane default since UTF-8 is ubiquitous, but it's also just one of many valid encodings.If you take your original string, , take a look at what Unicode code points these characters represent.  for example is the , i.e. . That character happens to be encoded in UTF-8 as  which explains why that’s what you get when you encode it into bytes. But it also has an encoding of  in UTF-16 for example.As for how to solve this properly so you get the desired output, there is no clear correct answer. The solution that Kasramvd mentioned is also somewhat imperfect. If you read about the  codec in the documentation:Latin-1 encoding with  and  for other code points. Existing backslashes are not escaped in any way. It is used in the Python pickle protocol.So this is just a Latin-1 encoding which has a built-in fallback for characters outside of it. I would consider this fallback somewhat harmful for your purpose. For Unicode characters that cannot be represented as a  sequence, this might be problematic:So the code point 256 is explicitly outside of Latin-1 which causes the  encoding to instead return the encoded bytes for the string , turning that one character into 6 bytes which have little to do with the original character (since it’s an escape sequence).So if you wanted to use Latin-1 here, I would suggest you to use that one explictly, without having that escape sequence fallback from . This will simply cause an exception when trying to convert code points outside of the Latin-1 area:Of course, whether or not code points outside of the Latin-1 area can cause problems for you depends on where that string actually comes from. But if you can make guarantees that the input will only contain valid Latin-1 characters, then chances are that you don't really need to be working with a string there in the first place. Since you are actually dealing with some kind of bytes, you should look whether you cannot simply retrieve those values as bytes in the first place. That way you won’t introduce two levels of encoding there where you can corrupt data by misinterpreting the input.
You can use  as your encoding:As mentioned in comments you can also pass the encoding directly to the  method of your string.


Answer URL
https://docs.python.org/3/library/codecs.html#text-encodings
