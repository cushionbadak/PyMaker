Natural Text
I have 2 instances of classes that I would like to resolve to the same key in a dictionary:Here, a and b are not equal as being keys:What exactly is happening with hash; it seemed like a second instance of the CustomClass should match the hashing? What is going on that these hashes do not match? I just now discovered the actual class is what is being hashed. So how to add a custom dictionary key for a class (i.e. when I try to use a class as a key for a dictionary, how should it be stored so that a and b match)?Note that in this case I do not care about keeping a link to the original object in the dictionary, I can work with some unusable key object; just it matters they resolve to the same.EDIT:Perhaps some advice on the actual case I'd like to solve is required.I have classes containing boolean  of shape . I want to hash these such that whenever this object is put into a dictionary, the comparison takes place on these values. I made a bitarray out of them according to this answer. I noticed it has a  there (thanks  for showing I have to look there). However, my class can be updated, so I'd only like to hash the np.array when I'm actually trying to put it into a dictionary, and not on initiation (and thus storing the hashable bitarray whenever I init, since the np.array might be updated, such that the hash is not a real representation anymore). I know that whenever I would update the np.array, I could also update the hashed value, but I'd prefer to only hash once!  
You broke the contract between ,  and . Quoting the  documentation,If a class does not define a  or  method it should not define a  operation either; if it defines  or  but not , its instances will not be usable in hashed collections. If a class defines mutable objects and implements a  or  method, it should not implement , since hashable collection implementations require that a object’s hash value is immutable (if the object’s hash value changes, it will be in the wrong hash bucket).User-defined classes have  and  methods by default; with them, all objects compare unequal (except with themselves) and  returns an appropriate value such that  implies both that  and .In your case, the hash value is the same for two objects and hash Collision is common in any hash implementation. So, Python compares the object being looked up with the help  method and finds out that the actual object being searched is not the same as the object already stored in. That is why  returns .So, to fix your problem, define custom  function also, like thisNote:  value should always be the same for a given object. So, please make sure that the  is never changed after assigned initially. Otherwise you ll never be able to get the object from the dictionary, since  value of  will be different, if it changes in the later point of time.
The problem is that the hash function can cause collisions -- different objects can produce the same hash value. As a result the final check to see if an object is present in a dict is still done using an equality comparison (ie. ). The hash value is first used to find the relevant objects quickly.If you want the behaviour you describe then you must also override  as well.eg.
 just determines which bucket the value will be placed into. Within the bucket python always calls to  to make sure it doesn't return an element that just happened to have the same hash, but which is in fact different, so you need to implement your own  as well.
You should implement  method to make your object .The definition of  from doc:An object is hashable if it has a hash value which never changes during   its lifetime (it needs a __hash__() method), and can be  compared to other objects (it needs an __eq__() method). Hashable  objects which compare equal must have the same hash value.Hashability makes an object usable as a dictionary key and a set member, because these data structures use the hash value internally.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__hash__
