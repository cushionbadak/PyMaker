Natural Text
I'm a beginner in Python programming and I'm having some trouble with some list stuff. So I want to write a function that returns a boolean value. The function will inform the user whether there is a duplicate consecutive pair of elements in the list he or she entered. By the way, I want to do this using only , , , , variables and arithmetic (no built in functions).For example:My code:My logic to this was as follows: Each time the for loop would run,  would refer to some element in the list. If that element was such that the element before it or after it was equal to it, then the for loop would return true. If not, keep searching. If there are none, it would return false.Now, I actually understand where the error is (I think). The problem is that I don't know how to solve it. I think the for loop is running into a problem at the beginning (when  is reffering to the 0th element). There is no element before the 0th element, hence the error:P.S: Is that how you return a boolean value?Is there a better way to do this?I would appreciate any help given! Thanks in advance!
This should do the trick:It iterates through all values bar the first and last (created by the range function), returning (which ends the loop) if it finds a duplicate.If it reaches the end and hasn't found a duplicate one must not exist, so it returns .
@roeland pointed out the problem with assuming iterating the  directly would get you indices (if you want index and value, use ). But in this case you don't actually need the index.For the simple case (where it's known to be a container you can slice), you can just iterate with  over offset slices:More general solutions can be made with  to handle the case where you can't slice, but this is simple and involves no imports.Use of  in this case is just a short hand to slurp the generator expression and return  if any values are truthy. The long equivalent form is:Since your teacher apparently thinks built-ins are bad, but  and  aren't built-ins (they are), you can do this the dumb way:Which does the same work as ing, just less efficiently (generating index integers and explicitly indexing is surprisingly expensive in Python relative to native iteration).
This should do:
By using only ,  and  statements, this can be done with:You access lists with their  and not by their value (which you are by using ). Additionally, if you perform the check  this will not yield the result you want since  will check the end of the list so  will return True.As a small demonstration:
Try this:What you are doing is trying to do is evaluate , but that does not exist.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.groupby
