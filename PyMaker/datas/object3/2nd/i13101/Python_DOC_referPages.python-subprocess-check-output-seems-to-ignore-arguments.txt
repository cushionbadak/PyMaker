Natural Text
First of all, I read as many related questions to subprocess.check_output() as I could find, but still struggle to identify the problem.If I execute  in the shell, I get the corresponding signal name for 1, which is . I need the same behaviour in my python script, so I use:The subprocess seems to ignore the '1' in the argument list and instead executes .I tried different versions, the argument as a list or string, with shell optione True and False, but none seem to work.Any ideas what could be the reason? Using python3.4 on a Ubuntu14.04.Thanks!
Possible cause: The  command in your shell is executing a shell built-in (most shells have one, because you need to be able to kill without a process launch when you have runaway fork bombs and the like), whereas  (not executing within a shell by default) is running the  executable found in your  (often , but not always, running  in  will tell you where that executable is).Odds are, the built-in supports the switches you're looking for, the executable does not. In , try running , then explicitly running the  to see if the   is finding actually supports that invocation. Often there are subtle differences between different implementations of .The best solution to this is probably to avoid expensive and pointless  launches and check the Python definitions for the signals. For example, in Python 3.5, it's trivial to construct a mapping from the signals known by Python to their Python names:In older Python where the names aren't s, you can use similar code using  of the module, filtering for names whose  is  and whose values are integers to construct the mapping.


Answer URL
https://docs.python.org/3/library/shlex.html#shlex.quote
