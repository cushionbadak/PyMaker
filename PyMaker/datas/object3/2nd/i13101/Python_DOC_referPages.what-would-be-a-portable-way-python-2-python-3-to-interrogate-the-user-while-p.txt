Natural Text
I want to ask the user a question that has a default answer, for example:How could this be coded in a neat, robust way that would be usable in Python 2 and 3? How could the way the default value is displayed be made to look something like that shown above?I have the beginnings of an attempt below:
If the focus of the question is compatibility with python 2 and python 3, the answer is: Don't do it in an ad hoc way! There are many things to pay attention to. If you can't avoid having to support multiple platforms, choose a library designed for the purpose and use it consistently. I believe  is the current state of the art:Then use  to read user input. It is bound to  on python 2, and to regular  on python 3. So basically you'll write a python 3 program, with compatibility plumbing at the top of the module.Alternative: You could write , which on python 2 makes  behave like . This allows for more "native" python 3 code, but is confusing if you're reading it with python 2 specs. I suppose it's safe if the code is consistently in python 3 style.For the default-setting part, keep it explicit so you can understand and debug it easily. I like to set the default values in advance. Then I would simply read an answer, and use it if it's non-empty (and valid)Compared to the  trick that was suggested, this set-up has the advantage that you can validate further and ignore negative values, fractional values, keyboard mash, and in general anything that doesn't fit the particular question you are asking (there's more in life than non-negative integers).In this case, you could use a try-except block to easily discard non-integer values:
You can use  to supply a default for cases where the user inputs nothing (as the result is an empty string, which evaluates false-y):To integrate that into a function you can actually use ( is used to invoke , so that e.g. quotes are included for strings):Note compliance with the style guide and an "easier to ask forgiveness than permission" approach to working across Pythons 2.x and 3.x. Although this does shadow a built-in function in 2.x (which some people evidently feel is bad practice), it's one you shouldn't really be using anyway ( calls it a bad built-in, in fact!) and makes it easier to write 3.x-style code that will continue to run in 2.x. An alternative would be to use an alias in both cases, e.g.:then use  everywhere; this might be more appropriate if you're treating 2.x and 3.x as equally important.
Is this okay?


Answer URL
https://docs.python.org/3/library/stdtypes.html#truth-value-testing
https://docs.python.org/3/glossary.html#term-eafp
