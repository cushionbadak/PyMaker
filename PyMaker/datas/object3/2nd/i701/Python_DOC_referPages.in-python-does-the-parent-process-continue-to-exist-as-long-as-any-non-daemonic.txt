Natural Text
I am using the multiprocessing module of Python. I am testing the following code :I have the following observations :The first child process  runs for 2 secsAfter 1 sec, the second child process  becomes zombieThe parent (main) process runs (is active) till child#1 (non-daemon process) is running, that is for 2secsNow I have the following queries :Why should the parent (main) process be active after it finishes execution? Note that the parent does not perform a  on .Why should the daemon child  become a zombie after 1 sec? Note that the parent (main) process actually stays alive till the time  is running.I have executed the above program on ubuntu.My observations are based on the output os the  command on ubuntu
To sum up and persist the discussion in the comments of the other answer:Why should the parent (main) process be active after it finishes  execution? Note that the parent does not perform a  on . tries to make sure that your programs using it behave well. That is, it attempts to clean up after itself. In order to do so, it utilizes the  module which lets you register exit handlers that are to be executed when the interpreter process prepares to terminate normally. defines and registers the function  that first calls  on all still running daemonic childs and then calls  on all remaining non-daemonic childs. Since  blocks, the parent waits until the non-daemonic childs have terminated.  on the other hand does not block, it simply sends a  signal (on Unix) to childs and returns.That brings us to:Why should the daemon child  become a zombie after 1 sec? Note that  the parent (main) process actually stays alive till the time  is  running.That is because the parent has reached the end of its instructions and the interpreter prepares to terminate, i.e. it executes the registered exit handlers. The daemonic child  receives a  signal. Since  is allowed to be caught and handled inside processes, the child is not ordered to shut down immediately, but instead is given the chance to do some cleanup of its own. That's what makes  show up as . The Kernel knows that the process has been instructed to terminate, but the process has not done so yet.In the given case,  has not yet had the chance to honor the  signal, presumably because it still executes . At least as of Python 3.5:The function now sleeps at least secs even if the sleep is interrupted  by a signal, except if the signal handler raises an exception (see PEP  475 for the rationale).
The parent stays alive because it is the root of the app. It stays in memory while the children are processing. Note, join waits for the child to exit and then gives control back to the parent. If you don't join the parent will exit but remain in memory.p1 will zombie because the parent exits after the sleep 1. It stays alive with p because you don't deamon p. if you don't deamon a process and you call start on it, the control is passed to the child and when the child is complete it will pass control back to the parent. if you do daemon it, it will keep control with the parent and run the child in the back.


Answer URL
https://docs.python.org/3/library/atexit.html
https://docs.python.org/3/library/time.html#time.sleep
