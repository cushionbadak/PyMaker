Natural Text
Unfortunately this code runs slower than "os.walk", but why?Can it be "for" cycle that causes it to run slowly?"Code that works like 'os.walk': (The "os.walk" function does what it does)Note: I wrote to improve myself!:for example:It ends in 2 seconds:It is in 0.5 seconds:
 doesn't use . It uses the much faster  function, which provides an iterator with more information per directory entry:Using  instead of  can significantly increase the performance of code that also needs file type or file attribute information, because  objects expose this information if the operating system provides it when scanning a directory. All  methods may perform a system call, but  and  usually only require a system call for symbolic links;  always requires a system call on Unix but only requires one for symbolic links on Windows.The  code makes heavy use of the  call, which with  is much cheaper than using  (which must make separate  calls).Next, your code is calling  too often. You are effectively calling it twice for every file entry in your path. You already collected all the subdirectories in , you don't need to test the paths again when re-creating . These extra  calls cost you a lot of time. You also recurse when  is empty (no further subdirectories), causing you to first wrap the empty list in another list, after which  throws a  exception which your blanket Pokemon-catch-em-all except handler silences.Next, you should get rid of the global variables, and use proper variable names.  and  would be far clearer names than  and . Because you made  and  globals you are retaining all file and directory names for a given level, and for every first subdirectory on down, you then re-report those same file and directory names as if they are members of those subdirectories. Only when the first leaf of such a directory tree (with no further subdirectories) is reached do the  calls on  and  get executed, leading to very confusing results with repeated filenames.You can study the  source code, but if we simplify it down to only use top-down traversal and no error handling, then it comes down to:Note that there are no global variables used; there simply is no need for any in this algorithm. There is only a single  call per directory, and the  variable is re-used to recurse into subdirectories.
This code it works almost as fast as !


Answer URL
https://docs.python.org/3/library/os.html#os.scandir
