Natural Text
In Python 2.7, I could get dictionary keys, values, or items as a list:Now, in Python >= 3.3, I get something like this:So, I have to do this to get a list:I'm wondering, is there a better way to return a list in Python 3? 
Try .This will convert the  object to a list.On the other hand, you should ask yourself whether or not it matters. The Pythonic way to code is to assume duck typing (if it looks like a duck and it quacks like a duck, it's a duck). The  object will act like a list for most purposes. For instance:Obviously, insertion operators may not work, but that doesn't make much sense for a list of dictionary keys anyway.
Python >= 3.5 alternative: unpack into a list literal New unpacking generalizations (PEP 448) were introduced with Python 3.5 allowing you to now easily do:Unpacking with  works with any object that is iterable and, since dictionaries return their keys when iterated through, you can easily create a list by using it within a list literal. Adding  i.e  might help in making your intent a bit more explicit though it will cost you a function look-up and invocation. (which, in all honesty, isn't something you should really be worried about).The  syntax is similar to doing  and its behaviour was initially documented in the Calls section of the Python Reference manual. With PEP 448 the restriction on where  could appear was loosened allowing it to also be placed in list, set and tuple literals, the reference manual on Expression lists was also updated to state this.Though equivalent to  with the difference that it's faster (at least for small dictionaries) because no function call is actually performed:with larger dictionaries the speed is pretty much the same (the overhead of iterating through a large collection trumps the small cost of a function call).In a similar fashion, you can create tuples and sets of dictionary keys:beware of the trailing comma in the tuple case!
 works in both Python 2 and Python 3, providing a simple list of the keys in .  isn't necessary. (:
A bit off on the "duck typing" definition --  returns an iterable object, not a list-like object. It will work anywhere an iterable will work -- not any place a list will. a list is also an iterable, but an iterable is NOT a list (or sequence...)In real use-cases, the most common thing to do with the keys in a dict is to iterate through them, so this makes sense. And if you do need them as a list you can call . Very similarly for  -- in the vast majority of cases, it is iterated through -- why create an entire new list of tuples just to iterate through it and then throw it away again?This is part of a large trend in python to use more iterators (and generators), rather than copies of lists all over the place. should work with comprehensions, though -- check carefully for typos or something... it works fine for  me:
You can also use a list comprehension:Or, shorter,Note: Order is not guaranteed on versions under 3.7 (ordering is still only an implementation detail with CPython 3.6). 
Converting to a list without using the  method makes it more readable:and, when looping through dictionaries, there's no need for :unless you are modifying it within the loop which would require a list of keys created beforehand:On Python 2 there is a marginal performance gain using .
If you need to store the keys separately, here's a solution that requires less typing than every other solution presented thus far, using Extended Iterable Unpacking (python3.x+). 
Other than the ways mentioned on this page, you could use  from the operator module:
You can also do a  or :


Answer URL
https://docs.python.org/3/reference/expressions.html#calls
https://docs.python.org/3/reference/expressions.html#expression-lists
https://docs.python.org/3/reference/expressions.html#calls
