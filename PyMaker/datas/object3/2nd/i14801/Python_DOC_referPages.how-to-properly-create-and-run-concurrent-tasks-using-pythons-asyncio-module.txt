Natural Text
I am trying to properly understand and implement two concurrently running  objects using Python 3's relatively new  module.In a nutshell, asyncio seems designed to handle asynchronous processes and concurrent  execution over an event loop. It promotes the use of  (applied in async functions) as a callback-free way to wait for and use a result, without blocking the event loop. (Futures and callbacks are still a viable alternative.)It also provides the  class, a specialized subclass of   designed to wrap coroutines. Preferably invoked by using the  method. The intended use of asyncio tasks is to allow independently running tasks to run 'concurrently' with other tasks within the same event loop. My understanding is that  are connected to the event loop which then automatically keeps driving the coroutine between  statements.I like the idea of being able to use concurrent Tasks without needing to use one of the  classes, but I haven't found much elaboration on implementation. This is how I'm currently doing it:In the case of trying to concurrently run two looping Tasks, I've noticed that unless the Task has an internal  expression, it will get stuck in the  loop, effectively blocking other tasks from running (much like a normal  loop). However, as soon the Tasks have to (a)wait, they seem to run concurrently without an issue. Thus, the  statements seem to provide the event loop with a foothold for switching back and forth between the tasks, giving the effect of concurrency.Example output with internal :Example output without internal :QuestionsDoes this implementation pass for a 'proper' example of concurrent looping Tasks in ? Is it correct that the only way this works is for a  to provide a blocking point ( expression) in order for the event loop to juggle multiple tasks?
Yes, any coroutine that's running inside your event loop will block other coroutines and tasks from running, unless it Calls another coroutine using  or  (if using Python 3.5+).Returns.This is because  is single-threaded; the only way for the event loop to run is for no other coroutine to be actively executing. Using / suspends the coroutine temporarily, giving the event loop a chance to work.Your example code is fine, but in many cases, you probably wouldn't want long-running code that isn't doing asynchronous I/O running inside the event loop to begin with. In those cases, it often makes more sense to use  to run the code in a background thread or process.  would be the better choice if your task is CPU-bound,  would be used if you need to do some I/O that isn't -friendly.Your two loops, for example, are completely CPU-bound and don't share any state, so the best performance would come from using  to run each loop in parallel across CPUs:
You don't necessarily need a  to give control over to the event loop.In your example, I think the proper way would be to do a  or equivalently a simple , rather than a :Coroutines are just plain old Python generators.Internally, the  event loop keeps a record of these generators and calls  on each of them one by one in a never ending loop. Whenever you , the call to  completes and the loop can move on. (I'm simplifying it; take a look around https://hg.python.org/cpython/file/3.4/Lib/asyncio/tasks.py#l265 for the actual code)  That said, I would still go the  route if you need to do CPU intensive computation without sharing data.


Answer URL
https://docs.python.org/3/library/asyncio-task.html#task
https://docs.python.org/3/library/asyncio.html
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.BaseEventLoop.run_in_executor
https://docs.python.org/3/library/asyncio-task.html#asyncio.async
https://docs.python.org/3/library/asyncio-task.html#asyncio.ensure_future
