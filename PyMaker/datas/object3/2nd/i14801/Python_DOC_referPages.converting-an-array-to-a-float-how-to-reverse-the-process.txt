Natural Text
Suppose we start with an integer numpy array with integers between 0 and 99, i.e.Now we want to represent rows in this array with a single unique value. One simple way to do this is representing it as a floating number. An intuitive way to do this is where we exploit that the integers have at most 2 digits. (I'm casting  as a float to avoid exceeding the maximum value of int in case the entries of  have more elements; this is not very elegant) This returnsHow can this process be reversed to obtain  again? I'm thinking of converting  to a string, then split the string every 2nd entry. I'm not too familiar with these string operations, especially when they have to be executed on all entries of an array simultaneously. A problem is also that the first number has a varying number of digits, so trailing zeros have to be added in some way. Maybe something simpler is possible using some divisions or rounding, or perhaps represting the rows of the array in a different manner. Important is that at least the initial conversion is fast and vectorized.Suggestions are welcome.
First, you need to find the correct number of columns:Note that is your first column is always 0, then there is no way with your code to know it even existed: . It might be something to consider. Anyways, here is a mockup for the string way:But you can also compute the numbers directly:Example:Here is a numpy solution:Finally, you say you use  in case of overflow of . First, the mantissa of floating point numbers is also limited, so you don't eliminate the risk of overflow. Second, in Python3, integer actually have unlimited precision.
You could exploit that Numpy stores its arrays as continuous blocks in memory. So storing the memory-block as binary string and remembering the shape of the array should be sufficient:The reason for flattening the array first is that you don't need to pay attention to the storage order of 2D arrays (C or FORTRAN order). Of course you also could generate a string for each row separately too:
Since your numbers are between 0 and 99, you should  rather pad up to 2 digits: 0 becomes "00" , 5 becomes "05" and 50 becomes "50". That way, all you need to do is repeatedly divide your number by 100 and you'll get the values. Your encoding will also be smaller, since every number is encoded in 2 digits instead of 2-3 as you currently do.If you want to be able to detect [0,0,0] (which is currently undistinguishable from [0] or [O.....O]) as well, add a 1 in front of your number: 1000000 is [0,0,0] and 100 is [0]. When your division returns 1, you know you've finished.You can easily construct a string with that information and cast it to a number afterwards.


Answer URL
https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex
