Natural Text
I have a python multi-threaded application. I want to run an asyncio loop in a thread and post calbacks and coroutines to it from another thread. Should be easy but I cannot get my head around the asyncio stuff.I came up to the following solution which does half of what I want, feel free to comment on anything:So starting and stoping the loop works fine. I thought about creating task using create_task, but that method is not threadsafe so I wrapped it in call_soon_threadsafe. But I would like to be able to get the task object in order to be able to cancel the task. I could do a complicated stuff using Future and Condition, but there must be a simplier way, isnt'it?
I think you may need to make your  method aware of whether or not its being called from a thread other than the event loop's. That way, if it's being called from the same thread, you can just call  directly, otherwise, it can do some extra work to pass the task from the loop's thread to the calling thread. Here's an example:First, we save the thread id of the event loop in the  method, so we can figure out if calls to  are coming from other threads later. If  is called from a non-event loop thread, we use  to call a function that will both schedule the coroutine, and then use a  to pass the task back to the calling thread, which waits on the result of the .A note on cancelling a task: You when you call  on a , a  will be raised in the coroutine the next time the event loop runs. This means that the coroutine that the Task is wrapping will aborted due to the exception the next time it hit a yield point - unless the coroutine catches the  and prevents itself from aborting. Also note that this only works if the function being wrapped is actually an interruptible coroutine; an  returned by , for example, can't really be cancelled, because it's actually wrapped around a , and those can't be cancelled once their underlying function actually starts executing. In those cases, the  will say its cancelled, but the function actually running in the executor will continue to run.Edit: Updated the first example to use , instead of a , per Andrew Svetlov's suggestion.Note:  is deprecated since version 3.4.4 use  instead.
You do everything right.For task stopping make methodBTW you have to setup an event loop for the created thread explicitly by because  creates implicit event loop only for main thread.
just for reference here it the code I finally implemented based on the the help I got on this site, it is simpler since I did not need all features. thanks again!
Since version 3.4.4  provides a function called run_coroutine_threadsafe to submit a coroutine object from a thread to an event loop. It returns a concurrent.futures.Future to access the result or cancel the task.Using your example:


Answer URL
https://docs.python.org/3/library/asyncio-task.html#asyncio.async
https://docs.python.org/3/library/asyncio-task.html#asyncio.ensure_future
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future
https://docs.python.org/3/library/asyncio-task.html#asyncio.Future
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future.result
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future.set_result
