Natural Text
EDIT: Looks like this is a very old "bug" or, actually, feature. See, e.g., this mail I am trying to understand the Python scoping rules. More precisely, I thought that I understand them but then I found this code here: In Python 3.4 the output is:If I replace the inner class by a function then it reasonably gives . Could you explain me why it behaves this strange way with classes and what is the reason for such choice of scoping rules?
TL;DR: This behaviour has existed since Python 2.1 PEP 227: Nested Scopes, and was known back then. If a name is assigned to within a class body (like ), then it is assumed to be a local/global variable; if it is not assigned to (), then it also can potentially point to a closure cell. The lexical variables do not show up as local/global names to the class body.On Python 3.4,  shows the following:The  loads the  on the stack; this is called with arguments ; where  is the class body, and  is . The class body is the constant #3 for the function :Within the class body,  is accessed with  (15) while  is load with  (25). The  is a Python 3.4+ opcode for loading values from closure cells specifically within class bodies (in previous versions, the generic  was used); the  is for loading values from locals and then globals. However closure cells show up neither as locals nor globals. Now, because the name  is stored to within the class body (35), it is consistently being used as not a closure cell but a local/global name.The closure cells do not show up as local variables to the class body. This behaviour has been true ever since implementing PEP 227 - nested scopes. And back then BDFL stated that this should not be fixed - and thus it has been for these 13+ years.The only change since PEP 227 is the addition of  in Python 3; if one uses it within the class body, the class body can set the values of the cells within the containing scope:The output now isThat is,  read the value of the cell  of the containing scope, and  set the value in that cell; in this case, no attribute was created for the class .
First focus on the case of a closure -- a function within a function:Note the commented out  in  If you run this, it replicates the  you got. Why? Run dis.dis on it:Note the different access mode of  vs  inside of . The use of  inside of  has created the  Now uncomment  inside of . Now you have unambiguously create  to be the top global version until resigned as With  uncommented, prints:You can get a more sensible result with:Prints:The analysis of the closure class is complicated by instance vs class variables and what / when a naked class (with no instance) is being executed. The bottom line is the same: If you reference a name outside the local namespace and then assign to the same name locally you get a surprising result. The 'fix' is the same: use the global keyword:Prints:You can read more about Python 3 scope rules in PEP 3104


Answer URL
https://docs.python.org/3/whatsnew/2.1.html#pep-227-nested-scopes
https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces
https://docs.python.org/3/reference/executionmodel.html#naming-and-binding
