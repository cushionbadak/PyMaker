Natural Text
Many make that comment, but no one offers a reason why it is bad.How else to catch user input errors? Wait for some code somewhere else to "throw an exception?" Why is it not better to catch an error immediately?For instance, an (ab)user types in 17.6 for an expected integer response. It is clearly an error, getting a type of  for an expected type of  (just to be clear?).Or, say, that (ab)user even enters 17/6 for the intended . 17/6 is a , so it would be hard to catch this error, if one waited for the data to get where it is actually used.I do not understand the premise.===========================The following is an edit based on the many (very good) replies - and THANKS for all of them!First, I believe that ALL coding styles are based upon opinions of people that have learned to have those opinions based on some error they have encountered. So, yes, by definition, as this is a coding style question, all answers are likely based upon opinions, or experience which led there.Second, testing type after input, at a function, is now something I understand from the comments. Many thanks for the examples and explanations.Third, perhaps the "testing for type is bad" ideology should be somewhat expounded upon to mean AFTER testing inputs, as many comments pointed towards. It was a blanket statement stated in many responses to searches I have done, trying to test the human inputs obtained in my code.Once again, many thanks for all of the knowledge y'all have shared.
As a couple examples,Let's say you need to pass a file to a function.  What you really want is a file-like object, which means that you implement the  method on any object you like and pass it to the function.  Checking the type of the object is bad, what you need is to verify that the object has the correct interface.Let's say you take some numbers out of a numpy array and serialize them to disk in JSON.  Whoops!When you run it,What? Obviously, 1 is JSON serializable, but that's a 1 with a different type.  Just imagine tracking that kind of error down.  Who knows how long it's been since that number was in a numpy array!So you want to do input validation, yes, because this will catch errors earlier before they become problems.  However, you don't want to simply rely on an object's type, because the type system in Python does not express the kind of constraints that you actually want on your inputs.In other languages, the convention is to express constraints on inputs using the type system.  For example, file-like object could be implemented as a type class or an interface in languages with such concepts.That said, I think type checking is fine if you really just need an .
To expand on Simeon Visser's and my comments, input validation should always be done. However, using type checking to validate input is not a good idea, since that implies you're probably using  on arbitrary data, and that's a massive security flaw, as explained by SO member Ned Batchelder's article Eval really is dangerousInput validation should be performed as soon as possible so that you can guarantee that the internal functions of your program only receive sane data which does not require further validation. Having every function validate its arguments is inefficient and bloats the code, making it harder to read and maintain. An analogy: input validation routines are like security guards at the entrance of your program. Once the data has passed the security check, all the functions inside your program can assume that the data is safe.Duck typing allows you to write functions that are lenient on the type of data they expect. This makes them more flexible and re-usable. So (for example) functions that perform arithmetic shouldn't care about the type of data they receive, only that the data supports the arithmetic operations that the functions perform. This lets you use the same functions not only on ints or floats, but also on more exotic numeric types like fractions, or even polynomials.
I disagree with the question that type checking is a bad idea, and I'm not sure why somebody would make such statements. I find type checking rather important, and Python provides many built-in functions to address type related issues. The use of types improves the safety and performance of the code execution by eliminating runtime checks to determine a value's type.Python is a dynamically typed language (and interpreted), in contrast to statically typed languages (which are often compiled). As per Python 3.5 and PEP 484 the language supports type hints in its source code which are yet to be supported by the bytecode interpreter or a compiler.You may want to read up on the term Duck Typing, but also check out the  function and other type related functions.To illustrate with your examples:


Answer URL
https://docs.python.org/3/library/typing.html
