Natural Text
I read some question and answers about differences between iterators and generators. But I don't understand when you should choose one over other? Do you know any examples (simple, real life ones) when one is better than the other? Thank you.
Iterators provide efficient ways of iterating over an existing data structure.Generators provide efficient ways of generating elements of a sequence on the fly.Iterator ExamplePython's file readers can be used as iterators.  So what you might use to process one line of a file:You can implement more efficiently using iteratorsThe advantage is in the fact that in the second example, you're not reading the entire file into memory, then iterating over a list of lines.  Instead, the reader ( in Python3) is reading a line at a time, every time you ask for one.Generator ExampleGenerators generate elements of a sequence on the fly.  Consider the following:This is an example of a generator.  In this case, every time it's "called" it produces the next number in the Fibonacci sequence.I put "called" in scare quotes because the method of getting successive values from generators is different than a traditional function.We have two main ways to get values from generators:Iterating over itHere we use the  syntax to iterate over the generator, and print the values that are returned, until we get a value that's greater than 100.Output:Calling next()We could also call  on the generator (since generators are iterators) and (generate and) access the values that way:There are more persuasive examples of generators however.  And these often come in the form of "generator expressions", a related concept (PEP-289).Consider something like the following:Here, we're creating a generator expression:And passing it to the  built-in function.   will return  as soon as an element of the iterable is determined to be .  So when you pass a generator function to , it will only call  as many times as necessary to find a -ish value.Compare this with using a list comprehension passed to :In this case,  will be called for all values of , first, then the 100-element list of / values will be given to  which will return  if it finds a -ish value.But if  returned , clearly the better approach would only be to evaluate that, test it, and stop there.  Generators allow you to do this, whereas something like a list comprehension do not.Consider the following example, illustrating the advantage of using a generator expression over list comprehension:The function  introduces an artificial delay to illustrate the difference between the two approaches.  The second (list comprehension) approach takes significantly longer, because  is evaluated at all 100 indices, whereas the first only calls  until it finds a  values ().


Answer URL
https://docs.python.org/3/library/functions.html#next
https://docs.python.org/3/glossary.html#term-generator-expression
https://docs.python.org/3/glossary.html#term-generator
