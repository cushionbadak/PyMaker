Natural Text
I am using the new  module (which also has a Python 2 backport) to do some simple multithreaded I/O. I am having trouble understanding how to cleanly kill tasks started using this module.Check out the following Python 2/3 script, which reproduces the behavior I'm seeing:While this script is running it appears impossible to kill cleanly using the regular Control-C keyboard interrupt. I am running on OS X.On Python 2.7 I have to resort to  from the command line to kill the script. Control-C is just ignored.On Python 3.4, Control-C works if you hit it twice, but then a lot of strange stack traces are dumped.Most documentation I've found online talks about how to cleanly kill threads with the old  module. None of it seems to apply here.And all the methods provided within the  module to stop stuff (like  and ) only work when the Futures haven't started yet or are complete, which is pointless in this case. I want to interrupt the Future immediately.My use case is simple: When the user hits Control-C, the script should exit immediately like any well-behaved script does. That's all I want.So what's the proper way to get this behavior when using ?
It's kind of painful. Essentially, your worker threads have to be finished before your main thread can exit. You cannot exit unless they do. The typical workaround is to have some global state, that each thread can check to determine if they should do more work or not.Here's the quote explaining why. In essence, if threads exited when the interpreter does, bad things could happen.Here's a working example. Note that C-c takes at most 1 sec to propagate because the sleep duration of the child thread.


Answer URL
https://docs.python.org/3/library/concurrent.futures.html
