Natural Text
In my work, my Python scripts get a lot of input from non-Python-professional users.So, for example, if my function needs to handle both single values and a series of values (Polymorphism/Duck Typing, Yo!) I would like to do something like this pseudo-code:If the user passes me a list:a tuple:or even a singleton tuple (terminology help here, please)everything works as expected.  But as soon as the user passes in a single integer everything goes to $%^&:1The Difference between Smart and CleverNow, I immediately think, "No problem, I just need to get clever!"  and I do something like this: Well, now it works for the single integer case:(1,)but when the user passes in an iterable, the $%^&*s come out again.  My trick gives me a nested iterable:((1,2),)ARGH!The Usual SuspectsThere are of course the usual workarounds.  Try/except clauses:These work, but I run into this issue A LOT.  This is really a 1-line problem and try/except is a 4-line solution.  I would really love it if I could just call:have it return (1,) and call it a day.Other People Use this Language Too, You KnowNow I'm aware that my needs in my little corner of the Python programming universe don't apply to the rest of the Python world.  Being dynamically typed makes Python such a wonderful language to work in -- especially after years of work in neurotic languages such as C.  (Sorry, sorry.  I'm not bashing C.  It's quite good at what its good at, but you know: xkcd)I'm quite sure the creators of the Python language have a very good reason to not allow .Question 1Will someone please explain why the creators chose to not allow  and/or  to work?  I'm sure its completely sane reason and bloody obvious to many.  I may have just missed it during my tenure at the School of Hard Knocks.  (It's on the other side of the hill from Hogwarts.)Question 2Is there a more practical -- hopefully 1-line -- way to make the following conversion?X(1)  -> (1,)X((1,2)) -> (1,2)If not, I guess I could just break down and roll my own.
Try this:
Duck typing explains and validates why  fails.The method was expecting a Duck but was given a Hamster, and Hamsters can't swim1.In duck typing, a programmer is only concerned with ensuring that objects behave as demanded of them in a given context, rather than ensuring that they are of a specific type.But not all objects/types behave the same, or "as demanded". In this case, an integer does not behave like an iterable and causes an exception. However,  works precisely because a string does act like an iterable and goes Quack - ['q','u','a','c','k']! To make  take a non-iterable would actually mean special casing, not duck typing.Expecting an integer to "be iterable" sounds like a design issue because this requires an implicit change in multiplicity. That is, the concepts of a value and a sequence of [zero or more] values should be kept separate. Polymorphism doesn't apply in this case as polymorphism (of any type) only works over unification - and there is no unification to "iterate a non-iterable".Furthermore, having  only accept an iterable fits in the strongly-typed Python model and avoids edge-cases. Consider that if  was written in such a way that it allowed a non-iterable as well, one could not determine if the result would be [x] or [x0..xn] without knowing the value supplied. Python simply forbids this operation and puts the burden of changing multiplicity - or, passing a Duck - on the calling code.See In Python, how do I determine if an object is iterable? which presents several solutions to wrap (or otherwise deal with) a non-iterable value.While I do not recommend this approach, as it changes the multiplicity, I would likely write such a coercion function as follows. Unlike  checks it will handle all non-iterable values. However, you will have to work out the rules for what should happen on .And then "one line" usage:1 Hamsters can swim .. or at least stay afloat for a little bit. However I find the analogy is apt (and more memorable) precisely because a wet/drowning hamster is a sad thought. Keep those little critters safe and dry!


Answer URL
https://docs.python.org/3/library/stdtypes.html#list
