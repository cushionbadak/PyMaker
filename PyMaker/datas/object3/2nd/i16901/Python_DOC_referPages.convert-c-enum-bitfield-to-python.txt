Natural Text
Looking at kismet's source code in packet_ieee80211.h is the section I understand this as shifting bits but that's about it. Suppose I have the int 706, how do I break this number up into the cryptset as defined above i.e. how can I extract which crypts are used give 706 especially ported to pythonThanks
Aruisdante's answer is very good, I just wanted to expand on the answer if you have to use a Python previous to 3.4, as there does exist a backport on PyPI:
So, what you have to understand here is that this enum is defining a series of bitmasks. In this case, each one of these enum values, in binary, contains one and only one . For example,And so on. Using the bitshift operator is just an easy way of representing 'I want the nth+1 binary digit to be the flag' This lets us bitwise  a bunch of these values together and get a magic number that describes a combination of these crypt values uniquely as bit flags. To test if a magic number contains a value, we can simply bitwise  it with the value we wish to test and  will be  if and only if  contained those bit flags.So lets look at the number , which in binary is . We can look at this and immediately see that it must have been built with , ,  and , because the correct bits are set for those values.So how to port to python? Well, python has enums just like C/C++ does if you're in python 3.4 or later. So you can simply create the same enum table in python, and apply the same bitwise tests to determine what your magic number represents. If you're on a version of python that doesn't have enums, you can simply define a class with some static constants in it to get the same effect (and build in a method to test for the set of crypts a magic number contains). Such a class could look like this:


Answer URL
https://docs.python.org/3/library/enum.html
