Natural Text
I have nested dictionaries that may contain other dictionaries or lists. I need to be able to compare a list (or set, really) of these dictionaries to show that they are equal. The order of the list is not uniform. Typically, I would turn the list into a set, but it is not possible since there are values that are also dictionaries. Is there a good way to approach this to show that  has the same contents as ?
You can use a simple loop to check if each of one list is in the other:
I suggest writing a function that turns any Python object into something orderable, with its contents, if it has any, in sorted order. If we call it , we can compare nested objects with:Here's my attempt at writing a  function:This should work for most Python objects. It won't work for lists of heterogeneous items, containers that contain themselves (which will cause the function to hit the recursion limit), nor  (which has bizarre comparison behavior, and so may mess up the sorting of any container it's in).It's possible that this code will do the wrong thing for non-iterable, unorderable objects, if they don't have a  function that describes all the data that makes up their value (e.g. what is tested by ). I picked  as it will work on any kind of object and might get it right (it works for , for example). It should also work as desired for classes that have a  that looks like a constructor call. For classes that have inherited  and so have  output like  it at least won't crash, though the objects will be compared by identity rather than value. I don't think there's any truly universal solution, and you can add some special cases for classes you expect to find in your data if they don't work with .
If the elements in both lists are shallow, the idea of sorting them, and then comparing with equality can work. The problem with @Alex's solution is that he is only using "id" - but if instead of id, one uses a function that will sort dictionaries properly, things shuld just work:(I use an  to wrap the key because it will cast all elements to string before comparison, which will avoid typerror if different elements are of unorderable types - which would almost certainly happen if you are using Python 3.x)Just to be clear, if your dictionaries and lists have nested dictionaries themselves, you should use the answer by @m_callens. If your inner lists are also unorderd, you can fix this to work, jsut sorting them inside the key function as well.
In this case they are the same dicts so you can compare ids (docs). Note that if you introduced a new  whose values were identical it would still be treated differently. I.e.  would be treated as not equal to . As @jsbueno points out, you can do this with the kwarg .
An elegant and relatively fast solution:This runs in  flat. While slow for dictionaries of low depth, this is faster for dictionaries of high depth. Here's a considerably longer snippet which is faster for dictionaries where depth is low and length is high.Test all three (, , and ) and see which one is faster in your situation. I'll betcha it's faster than the other solutions.


Answer URL
https://docs.python.org/3/library/functions.html#id
