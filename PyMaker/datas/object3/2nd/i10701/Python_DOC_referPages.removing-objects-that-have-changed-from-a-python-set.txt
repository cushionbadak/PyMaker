Natural Text
Given this program:If I run this a few times with Python 3.4.2, sometimes it will succeed, other times it throws a KeyError after removing 2 or 3 objects:Is this a bug in Python? Or something about the implementation of sets I don't know about?Interestingly, it seems to always fail at the second  call in Python 2.7.9.
This is not a bug in Python, your code is violating a principle of sets: that the hash value must not change. By mutating your object attributes, the hash changes and the set can no longer reliably locate the object in the set.From the  method documentation:If a class defines mutable objects and implements an  method, it should not implement , since the implementation of hashable collections requires that a key’s hash value is immutable (if the object’s hash value changes, it will be in the wrong hash bucket).Custom Python classes define a default  method that returns True when both operands reference the same object ( is true).That it sometimes works in Python 3 is a property of hash randomisation for strings. Because the hash value for a string changes between Python interpreter runs, and because the modulus of a hash against the size of the hash table is used, you can end up with the right hash slot anyway, purely by accident, and then the  equality test will still be true because you didn't implement a custom  method.Python 2 has hash randomisation too but it is disabled by default, but you could make your test 'pass' anyway by carefully picking the 'right' values for the  and  attributes.Instead, you could make your code work by basing your hash on the  of your instance; that makes the hash value not change and would match the default  implementation:You could also just remove your  implementation for the same effect, as the default implementation does basically the above (with the  value rotated by 4 bits to evade memory alignment patterns). Again, from the  documentation:User-defined classes have  and  methods by default; with them, all objects compare unequal (except with themselves) and  returns an appropriate value such that  implies both that  and .Alternatively, implement an  method that bases equality on equality of the attributes of the instance, and don't mutate the attributes.
You are changing the objects (ie changing the objects' hash) after they were added to the set. When  is called, it can't find that hash in the set because it was changed after it was calculated (when the objects were originally added to the set). 


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__hash__
https://docs.python.org/3/using/cmdline.html#cmdoption-R
