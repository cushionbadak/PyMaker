Natural Text
Is there any reason  is not evaluated quickly? I was hoping  would check if its two arguments are identical, and if so return True instantly. But it doesn't do it:For built-ins,  always returns True I think? For user-defined classes, I guess someone could define  that doesn't satisfy this property, but is there any reasonable use case for that?The reason I want  to be evaluated quickly is because it's a huge performance hit when memoizing functions with very large arguments:Note that the reason @lru_cache is repeatedly slow for large objects is not because it needs to calculate  (this is only done once and is then hard-cached as pointed out by @jsbueno), but because the dictionary's hash table needs to execute  every time to make sure it found the right object in the bucket (equality of hashes is obviously insufficient).UPDATE:It seems it's worth considering this question separately for three situations.1) User-defined types (i.e., not built-in / standard library).As @donkopotamus pointed out, there are cases where  should not evaluate to True. For example, for  and  types, the result is intentionally not convertible to boolean because it's unclear what the natural semantics should be (does False mean the container is empty, or does it mean all items in it are False?).But here, there's no need for python to do anything, since the users can always short-circuit  comparison themselves if it's appropriate:2) Python built-in / standard library types.a) Non-containers.For all I know the short-circuit may already be implemented for this case - I can't tell since either way it's super fast.b) Containers (including ).As @Karl Knechtel commented, adding short-circuit may hurt total performance if the savings from short-circuit are outweighed by the extra overhead in cases where . While theoretically possible, even in that case the overhead is a small in relative terms (container comparison is never super-fast). And of course, in cases where short-circuit helps, the savings can be dramatic.BTW, it turns out that  does short-circuit: comparing huge identical strings is instant.
As you say, someone could quite easily define an  that you personally don't happen to approve of ... for example, the Institute of Electrical and Electronics Engineers might be so foolish as to do that:Another "unreasonable use case":Or even:which has the audacity to not even be convertible to !So there is certainly practical scope for  to not automagically be short-circuited to be true.  Going Off CourseHowever the following is perhaps a good question:Why doesn't  check for instance identity?Well, one might think ... because a set  might contain  and since  cannot equal itself then surely such a set  cannot equal itself?  Investigating:Hmm, that's interesting, especially since:This behaviour is due to Python's desire for sequences to be reflexive.


Answer URL
https://docs.python.org/3/reference/expressions.html#value-comparisons
