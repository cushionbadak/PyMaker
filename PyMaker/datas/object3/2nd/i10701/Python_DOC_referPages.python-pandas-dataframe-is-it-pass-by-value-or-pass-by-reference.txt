Natural Text
If I pass a dataframe to a function and modify it inside the function, is it pass-by-value or pass-by-reference?I run the following codethe value of  does not change after the function call. Does it mean it is pass-by-value?I also tried the followingIt turns out  does change  and  does not. Why is it like this?
The short answer is, Python always does pass-by-value, but every Python variable is actually a pointer to some object, so sometimes it looks like pass-by-reference.In Python every object is either mutable or non-mutable. e.g., lists, dicts, modules and Pandas data frames are mutable, and ints, strings and tuples are non-mutable. Mutable objects can be changed internally (e.g., add an element to a list), but non-mutable objects cannot. As I said at the start, you can think of every Python variable as a pointer to an object. When you pass a variable to a function, the variable (pointer) within the function is always a copy of the variable (pointer) that was passed in. So if you assign something new to the internal variable, all you are doing is changing the local variable to point to a different object. This doesn't alter (mutate) the original object that the variable pointed to, nor does it make the external variable point to the new object. At this point, the external variable still points to the original object, but the internal variable points to a new object. If you want to alter the original object (only possible with mutable data types), you have to do something that alters the object without assigning a completely new value to the local variable. This is why  and  leave the external item unaltered, but  alters it. As @ursan pointed out, if  used something like this instead, then it would alter (mutate) the original object that  points to, which would change the value seen via the global  variable:In some cases, you can completely hollow out the original variable and refill it with new data, without actually doing a direct assignment, e.g. this will alter the original object that  points to, which will change the data seen when you use  later:Notice that I'm not assigning something directly to ; I'm assigning something to the entire internal range of .If you absolutely must create a completely new object and make it visible externally (which is sometimes the case with pandas), you have two options. The 'clean' option would be just to return the new object, e.g., Another option would be to reach outside your function and directly alter a global variable. This changes  to point to a new object, and any function that refers to  afterward will see that new object:Directly altering global variables is usually a bad idea, because anyone who reads your code will have a hard time figuring out how  got changed. (I generally use global variables for shared parameters used by many functions in a script, but I don't let them alter those global variables.)
The question isn't PBV vs. PBR. These names only cause confusion in a language like Python; they were invented for languages that work like C or like Fortran (as the quintessential PBV and PBR languages). It is true, but not enlightening, that Python always passes by value. The question here is whether the value itself is mutated or whether you get a new value. Pandas usually errs on the side of the latter.http://nedbatchelder.com/text/names.html explains very well what Python's system of names is.
To add to @Mike Graham's answer, who pointed to a very good read:In your case, what is important to remember is the difference between names and values. , , , , are all names, but they refer to the same or different values at different points of your examples:In the first example,  rebinds  to another value, because  returns a new  unless you set the argument  (see doc). That means that the name  (local to the  function), which was referring to the value of , is now referring to a new value, here the  return value. The value  is referring to still exists and hasn't changed.In the second example,  mutates , without rebinding it, which is why  is modified by . Unlike the previous example, here the local name  always refers to the value the name  is referring to, and changes that value in place, which is why the value  is referring to has changed.In the third example,  rebinds  to a new . That causes the name , local to  and previously referring to the value of , to now refer to another value, the new . The value  is referring to hasn't changed.
Python is neither pass by value nor pass by reference.  It is pass by assignment.Supporting reference, the Python FAQ:https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-referenceIOW:If you pass an immutable value, changes to it do not change itsvalue    in the caller - because you are rebinding the name to a newobject.If you pass a mutable value, changes made in the called function,also change the value in the caller, so long as you do not rebindthat name to a new object.  If you reassign the variable,creating a new object, that change and subsequent changes to thename are not seen in the caller.So if you pass a list, and change its 0th value, that change is seen in both the called and the caller.  But if you reassign the list with a new list, this change is lost.  But if you slice the list and replace that with a new list, that change is seen in both the called and the caller.EG:If you're a C fan, you can think of this as passing a pointer by value - not a pointer to a pointer to a value, just a pointer to a value.HTH.
Here is the doc for drop:Return new object with labels in requested axis removed.So a new dataframe is created. The original has not changed.But as for all objects in python, the data frame is passed to the function by reference.
you need to make 'a' global at the start of the function otherwise it is a local variable and does not change the 'a' in the main code.


Answer URL
https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference
https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference
