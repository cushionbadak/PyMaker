Natural Text
A little background: You'll notice my comments describe what I'll go through later. Let's say I have the following object...Now, when generating the objects I can have a dict that looks something like this:  that, once created, can be called like this: In the scenario there's the  which tells the application what data type the object really is. This is referencing off of Django models but any python could apply.All containers will have an  (or ) key to them as part of their instantiation. This is mandatory.The RubIdeally, we fill our the top level attributes and only when the user requests for the attributes that lie underneath it do we construct them based off the  value and the  type.So finally, let's say the  attribute has a foreign key field type. If we call  the app should understand that the 'newkey' attribute does not exist, query against our django instance, store the  attribute as the now more filled out Container, and return the  value that's been put to memory.The Python PitfallI'd hoped it would be a simple  but Python seems to just use  with a default  (The recursion is real!). I've also had loads of trouble getting a  to work.As I write this I'm realizing how much more complicated it may be due to the recursive attribute setting relying on  and  Any suggestions would be greatly appreciated. - Cheers
So to answer the first part of the question: how to have  call   only when the attribute is not defined already.  There are two attribute access methods in python classes:  and .  The first is called every time an attribute lookup is attempted, the second is called only when the normal attribute lookup system fails (including lookups in superclasses).  Since you're defining , which is only called when the attribute doesn't already exist, you can simply proxy it to a call to .  Where you run into recursion issues is if you try to look up another attribute of , that also doesn't yet exist, inside of .  The way to avoid this is to have a list of keys that require special handling and check if the current attribute requested is one of them.  This typically is only needed when implementing .Note that your  method has a problem:   and  are undefined.  I'd give a slightly more concrete answer for what to put in  if I knew what values for 's  and  want.
You could consider using the @property decorator with private internal fields. The idea would be something like:
Check this out:Here, instead of returning , you create a new attribute and return it.


Answer URL
https://docs.python.org/3/reference/datamodel.html#customizing-attribute-access
