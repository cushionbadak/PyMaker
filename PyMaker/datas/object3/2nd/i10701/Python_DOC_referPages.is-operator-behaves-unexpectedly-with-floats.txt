Natural Text
I came across a confusing problem when unit testing a module. The module is actually casting values and I want to compare this values.There is a difference in comparison with  and  (partly, I'm beware of the difference)As expected till now, but here is my "problem":Why? At least the last one is really confusing to me. The internal representation of  and  should be equal. Comparison with  is working as expected.
This has to do with how  works. It checks for references instead of value. It returns  if either argument is assigned to the same object.In this case, they are different instances;  and  have the same value , but are distinct entities as far as Python is concerned. CPython implementation also caches integers as singleton objects in this range -> [x | x ∈ ℤ ∧ -5 ≤ x ≤ 256 ]:In this example we can demonstrate the integer caching principle:Now, if floats are passed to , the float literal is simply returned (short-circuited), as in the same reference is used, as there's no need to instantiate a new float from an existing float:This can be demonstrated further by using  also:However, the results of  are also dependant on the scope it is being executed in (beyond the span of this question/explanation), please refer to user: @Jim's fantastic explanation on code objects. Even python's doc includes a section on this behavior:5.9 Comparisons[7]   Due to automatic garbage-collection, free lists, and the dynamic nature of descriptors, you may notice seemingly unusual behaviour in certain uses of the  operator, like those involving comparisons between instance methods, or constants. Check their documentation for more info.
If a  object is supplied to , CPython* just returns it without making a new object. This can be seen in  (which is eventually called from ) where the object  passed in is checked with ; if , it just increases its reference count and returns it:As a result, the  of the object stays the same. So the expression reduces to:But why does that equal ? Well,  has some small optimizations. In this case, it uses the same object for the two occurrences of  in your command because they are part of the same  object (short disclaimer: they're on the same logical line); so the  test will succeed.This can be further corroborated if you execute  in separate lines (or, delimited by ) and then check for identity:On the other hand, if an  (or a ) is supplied, CPython will create a new  object from it and return that. For this, it uses  and  respectively. The effect is that the returned objects differ in s (which used to check identities with ):*Note: All previous mentioned behavior applies for the implementation of python in  i.e . Other implementations might exhibit different behavior. In short, don't depend on it.


Answer URL
https://docs.python.org/3/c-api/float.html#c.PyFloat_CheckExact
https://docs.python.org/3/c-api/float.html#c.PyFloat_FromDouble
https://docs.python.org/3/c-api/float.html#c.PyFloat_FromString
