Natural Text
For legibility purposes, I would like to have a custom class that behaves exactly like a dict (but carries a meaningful type instead of the more general dict type):Now, is there a way of building new objects of this class in a way that does not involve copies? The naive usagein fact creates a copy of the dictionary passed as an argument, which I would like to avoid, for efficiency reasons.I tried to bypass the copy but then the class of the dict cannot be changed, in CPython:I would like to have both the ability to give an explicit class name to the dictionaries that the program manipulates and an efficient way of building such dictionaries (instead of being forced to copy a Python dict). Is this doable efficiently in Python?PS: The use case is maybe 100,000 creations of single-key , where the key is a variable (not a string, so no keyword initialization). This is actually not slow, so "efficiency reasons" here means more something like "elegance": there is ideally no need to waste time doing a copy when the copy is not needed. So, in this particular case the question is more about the elegance/clarity that Python can bring here than about running speed.
TL;DR: There's not general-purpose way to do it unless you do it in C.Long answer:The  class is implemented in C. Thus, there is no way to access it's internal properties - and most importantly, it's internal hash table, unless you use C.In C, you could simply copy the pointer representing the hash table into your object without having to iterate over the  (key, value) pairs and insert them into your object. (Of course, it's a bit more complicated than this. Note that I omit memory management details).Longer answer:I'm not sure why you are concerned about efficiency.Python passes arguments as references. It rarely every copies unless you  explicitly tell it to.I read in the comments that you can't use named parameters, as the keys are actual Python objects. That leaves me to understand that you're worried about copying the  keys (and maybe values). However, even the dictionary keys are not copied, and passed by reference! Consider this code:Thus, the only remaining area of concern is iterating through the  and inserting the values in your  class.  This is unavoidable, unless you can somehow set the internal hash table of your class to the 's internal hash table. There is no way to do this in pure python, as the dict class is implemented in C (as mentioned above).Note that others have suggested using generators. This seems like a good idea too - say if you were reading the derivatives from a file or if you were generating them with a simple formula. It would avoid creating the  object in the first place. However, there will be no noticable improvements in efficiency if the generators are just wrappers around s (or any other data structure that can contain an arbritary set of values).Your best bet is do stick with your original method. Generators are great, but they can't efficiently represent an arbritary set of values (which might be the case in your scenario). It's also not worth it to do it in C.EDIT: It might be worth it to do it in C, after all!I'm not too big on the details of the Python C API, but consider defining a class in C, for example, (deriving from ). All you do is define an  function in C for  that takes a  as a parameter and copies the hash table pointer from the  into your  object. Then, in python, your  class derives from  and implements the bulk of the functionality.
By inheriting from  you are given three possibilities for constructor arguments: (baring the  literal)This means that, in order to instantiate your instance you must do one of the following:Pass the variables as keywords  which are then packed into an intermediate dictionary anyway.Create a plain dictionary and pass it as a .Pass an iterable of (key,value) pairs.So in all three of these cases you will need to create intermediate objects to satisfy the  constructor.The third option for a single pair it would look like  which I highly recommend against for readability sake.So if you want your class to inherit from a dictionary, using  is your most efficient and most readable option.  As a personal note if you will have thousands of single pair dictionaries I'm not sure how the  setup is the best in the first place, you may just reconsider the basis of your class.


Answer URL
https://docs.python.org/3/library/functions.html#func-dict
