Natural Text
I am using Python with the Rasbian OS (based on Linux) on the Raspberry Pi board. My Python script uses GPIOs (hardware inputs). I have noticed when a GPIO activates, its callback will interrupt the current thread.This has forced me to use locks to prevent issues when the threads access common resources. However it is getting a bit complicated. It struck me that if the GPIO was 'queued up' until the main thread went to sleep (e.g. hits a ) it would simplify things considerably (i.e. like the way that javascript deals with things).Is there a way to implement this in Python? 
Are you using ? Or you call your Python code from C when a callback fires?In case of , it runs a valid Python thread, and you do not need extra synchronization if you organize the threads interaction properly.The most common pattern is to put your event in a queue (in case of Python 3 this library will do the job, Python 2 has this one). Then, when your main thread is ready to process the event, process all the events in your queue. The only problem is how you find a moment for processing them. The simplest solution is to implement a function that does that and call it from time to time. If you use a long  call, you may have to split it into many smaller sleeps to make sure the external events are processed often enough. You may even implement your own wrapper for  that splits one large delay into several smaller ones and processes the queue between them. The other solution is to use  with  parameter instead of  (it returns immediately after an event arrives into the queue), however, if you need to sleep exactly for a period you specified, you may have to do some extra magic such as measuring the time yourself and calling  again if you need to wait more after processing the events.
Use a Queue from the multithreading module to store the tasks you want to execute. The main loop periodically checks for entries in the queue and executes them one by one when it finds something.You GPIO monitoring threads put their tasks into the queue (only one is required to collect from many threads).You can model your tasks as callable objects or function objects.


Answer URL
