Natural Text
I am learning about sockets in Python and I wrote a short server socket program on one machine which can be polled using . The communication works fine but for some reason when I am evaluating the  which is sent from the client, it does not seem to evaluate as it should.The offending code is below:From the client I do the following:So what is happening is I poll the server using , which responds with  indicating a successful connection. Then I type in , the server responds with the data it received (i.e.  hence the same line twice) but then tells me the command is not recognized, implying the  statements on the server program did not evaluate  correctly.Am I missing something, like the data is actually null-terminated like  leading to incorrect evaluation in the  block?
You're presumably typing something and hitting Enter, just as the instructions say.So, you're sending . Or maybe .And either way,  and .A good way to test for this is to print out what you get. Printing the  of a string will quote it and escape all control characters, so you'll see exactly  instead of just  followed by a blank line, which is a lot easier to interpret. (This would also let you rule out spurious  terminators, etc.)You could fix this by checking, e.g.,  instead of .However, once you do that, your program will not actually work, it'll just work most of the time, or in certain situations (like testing on localhost). This is a recipe for hard-to-catch bugs that will require you to rewrite your whole app when you finally find them.A  might get the data from a single , or half the data from that , or the data from three separate s. And if you receive  or , no amount of manipulation is going to make that match .To deal with this, you need to design a protocol that delimits messages in some way, and loop over , adding to a buffer, and splitting off messages. Or, if your protocol is just "terminate every command with a newline" (and there are no embedded newlines within commands), you can just use , which gives you a file-like object that automatically does that for youâ€”so you can just iterate over it line by line (or call  on it, etc.), just like you can with a regular file. You can even open it with universal newline support, so you don't have to worry about pesky inconsistent  vs. .See Sockets are byte streams, not message streams for more detail.
The problem here is likely that a newline is being sent from telnet. Try stripping trailing whitespace before the  block:


Answer URL
