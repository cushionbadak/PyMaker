Natural Text
I was browsing some of the code from the serge pygame engine and I cam across something in  that I couldn't wrap my head around:This method was retrieved from the  object. What I'm confused about is why the  parameter in  has a default value of . Why wouldn't a state be sent to  upon unpickling an object, and in what situation would this be useful?
This isn't useful if your class relies entirely on / for pickling.As the docs on  explain:Upon unpickling, if the class defines , it is called with the unpicked state… If  returns a false value, the  method will not be called upon unpicking.So, if your  returns , it will not be passed back to you at  time; you just won't get called.However, note that in the 2.x version, this is not true for classic classes. With a classic class, "If a class defines both  and , the state object needn’t be a dictionary and these methods can do what they want." (In fact, I believe there are cases where any falsey value turns into , which isn't very well documented, but the same  statement handles that…)Still, that doesn't explain why you'd need a default value… If you can get , sure, you need to write code that deals with … but you don't need to write code that doesn't get a parameter at all, right?But, there are reasons you might do this.First, note that this particular class's  does more than the usual: it initializes "first from the defaults and then from the live state". So, it could very easily be useful to unit test that initializing from the defaults is working.On top of that, if you define a custom  method and unreducer, there's no reason that it has to follow exactly the same rules as the default unreducer. Or course there's no reason it has to call  at all—but if you're, say, building a base class that you expect your users to subclass, making your unreducer work as much like the default as possible, so your users can just override  instead of adding their own whole  implementation.Similarly, if you're building your own serializer on top of /, rather than just using it as-is, your code doesn't have to use the exact same rules as . Again, there's no reason it has to use even similar rules, but doing so might make it much easier for your users to extend your classes.Whether any of these applies to , I have no idea, but they're both things that could easily apply to a wide range of types you might want to build.


Answer URL
