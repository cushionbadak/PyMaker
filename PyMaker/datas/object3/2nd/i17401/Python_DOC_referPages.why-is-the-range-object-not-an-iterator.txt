Natural Text
This question already has an answer here:If range() is a generator in Python 3.3, why can I not call next() on a range?                    1 answer                I wrote this and expected :Instead I got:TypeError: 'range' object is not an iteratorBut I thought it was a generator?The initial answer yielded the same thing I initially said to myself: it's an iterable, not an interator. But then, that wouldn't explain why this works, if both are simply generators:
 returns an iterable, not an iterator. It can make iterators when iteration is necessary. It is not a generator.A generator expression evaluates to an iterator (and hence an iterable as well).
The range object is iterable. However, it's not an iterator.To get an iterator, you need to call  first:Edit: But be careful not to call  with every call to . It creates a new iterator at index 0.
The  builtin calls the  hook method.  So,  objects have a well defined , but not a well-defined .iterable objects have  defined, iterator objects have well defined  (typically with an  method which simply returns ).
It's because the  function calls the  method of the object that passed in. s and s both have the  method.But a  doesn't have it. And that is the reason why it raises that exception. doesn't care much about whether the object it's passed is an iterator or not.But adding the  method doesn't necessarily make it a collection/sequence/iterable.But adding the  method to it makes it one.The  seems to have some builtin intelligence when it comes to . 


Answer URL
