Natural Text
I am trying to pass different functions which have pointers as arguments to a python function. One example of the input function as input parameter is the given  function: Sample.pyxtest.pyRunning the  code I am getting this error:I am trying to write a wrapper for different  functions which have three pointer arrays as their argument. My conclusion so far was that it can be done with a class, since the class can be accessible in python. I am wondering how I can pass the  functions with pointer arrays as argument to  class? Update: Normal function
The first thing to deal with is that a function of signature  does not pass the array length. You can't know how long these arrays are, and thus you can't safely access their elements. The sensible thing is to change the function signature to pass a length too:What is extra confusing is that you seem to be iterating over the same axis of a 1D array in both  and . I suspect that isn't what you want to do, but I'm not going attempt to fix that.Essentially your problem is that you want to pass an arbitrary Python callable as a C function pointer. The bad news is that Cython can't do it - a Python callable has a significant amount of information associated with it, while a C function pointer is simply the address of some executable memory. Therefore a C function pointer does not have the space available to hold the information in a Python callable. In order to make this work you need to generate code at runtime, which Python can't do.I've recommended the ctypes standard library module as a solution to similar problems previously, since it can create a function pointer from a Python callable. There is a simpler but more limited solution if you only want to call  Cython functions.ctypesHere's a minimal example which demonstrates how to implement the idea:I realise that there's some slightly messy conversion between ctypes and Cython - this is unavoidable.A bit of explanation: I'm assuming you want to keep the Python interface simple, hence  just takes a numpy array-like object. The function passed by ctypes needs to accept a number of elements and a pointer to match your C interface.The ctypes pointer type () can do do indexing (i.e. ) so it works fine for simple uses, but it doesn't store its length internally. It's helpful (but not essential) to change it to a numpy array so you can use it more generally and thus we create a wrapper function to do this. We do:to convert it to a known length ctypes array and thento convert it to a numpy array. This shares the data rather than makes a copy, so if you change it then your original data will be changed. Because the conversion to a numpy array follows a standard pattern it's easy to generate a wrapper function in .(In the comments you ask how to do the conversion if you're just passing a , not a . In this case you don't have to do anything since a ctypes  behaves exactly like a Python type)Only  functionsIf you're certain the functions you want to pass will always be  functions then you can avoid ctypes and come up with something a bit simpler. You first need to make the function signature match the pointer exactly:You should then be able to use your definition of  almost as is to create module level objects: is the way you wrote it (no  code):This code will run quicker, but you want be able to call  from Python.Python interfaceYou mention in the comments that you'd also like the be able to access  from Python. You're likely to need a different interface for the Python function and the one you pass to C, so I'd define a separate function for both uses, but share the implementation:


Answer URL
https://docs.python.org/3/library/ctypes.html#callback-functions
