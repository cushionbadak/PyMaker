Natural Text
Basically, in the example below, why do the lambdas in  capture a reference to the list comprehension loop variable, but those in  "capture" (really, they just accept an argument) "the way we expect" lambda capture to work?The three lines outputted are:
Python closures always capture variables, not objects.In ,all lambdas in the list capture the  variable, not the object the variable refers to at the time the lambda is defined. At the end of the comprehension,  refers to the last function in , so all lambdas in  find that function when they look up .In each call to  creates a new local  variable, and each  captures a different  variable. Unlike , the  variables are never reassigned, so the  functions each see a different value of .
 is the same variable throughout the list comprehension. A simpler example:One common hack to work around this without the extra lambda wrapper is to use a default (as defaults are evaluated when the function is), but that can be confusing to those new to the idiom and you should generally split it out into a new function instead.
In the second example,  is a free variable in the lambdas in  which is bound into their enclosing scope (the list comprehension). The functions take 's value at the time they are called.    The functions in  are called in the following print statement, at which point  is already the third lambda from .Note that  is never in the scope in which ,  and  are defined (presumably global or some broader function scope), but the lambdas always reference their enclosing scope which contains .In contrast,  is a parameter in the outer lambdas , but it is bound in the call to those outer lambdas, which happens in the list comprehension that defines .


Answer URL
https://docs.python.org/3/reference/executionmodel.html
