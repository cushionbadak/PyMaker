Natural Text
I'm trying to understand how Python 3 handles the index variable value at the completion of a for loop. I'm a python newbie, with prior programming experience in C, so at this point, I "think" in C, and try to construct the equivalent code in Python.Here's a toy example . . .After the first loop completes, the value of the variable  is , as expected.But after the second loop completes, I expected (from my C experience) that the value of  would be  (i.e., the final value of  would fall one past the end of the range, unless there was a break), but the actual value is . I want it to be .As an alternative, I could code the second loop this way:which works the way I want.Is that the way to do it?Update:Thanks to all for explaining how Python interprets range expressions.Using juanpa.arrivillaga's suggestion, I've settled for the following . . .
You misunderstood how  works; the  value is not included:If you want the range to go down to 0, use  as the end value:From the  object documentation:For a positive step, the contents of a range  are determined by the formula  where  and .For a negative step, the contents of the range are still determined by the formula , but the constraints are  and . means it'll never be equal to .Your  loop decrements  after you tested it, so  is still true for , but then you substracted , making it , at which point the  test is false and the loop ends.Note that you can't really compare Python's  construct with C . The Python concept is a For each loop, while the  construct is really a setup, test, alter construct, which executes setup once, then repeats until the test fails, running the alter instructions after every repetition. This is what your  loop did too; the setup is , the test is  and the alter instruction is your  at the end, at the end of the loop body.If you wanted think about Python  loops in C terms, the closest I can think of is a  loop over a pointer:You'd have to add a  in the  definition if you wanted it to continue on to . Python  loops handle any iterable however, including infinite generators; see the iterator protocol.
That≈õ because the stop value it's not included. This it's the sintax of range:
Here's the way to think about it. In Python, the  loop always iterates over a collection of objects. When the loop finishes, the index variable will always hold the last object from the collection. The thing that's tripping you up is that the Python  function is non-inclusive at the end. See the documentation at https://docs.python.org/3/library/stdtypes.html#typesseq-range.So in your case, the second loop is iterating correctly over , which is equivalent to , not . So  ends up with the last value in that collection, which is 1. If you want to include 0 in the range, you have to use . I find this behavior of  confusing, but it's a very standard Python element. It works well if you want a loop to repeat  times -- just use  to get [0, 1, ..., n-1]. String and collection indexing work similarly:  gives you everything before element 4 of . That behavior can be nice if you are splitting strings:  gives you the first 4 characters, and then  gives you everything after that. This saves you from having to add 1 to your indexes in various places or remember to use  (not ) as you would in C. On the other hand, if you want a list of numbers from 1 to 5 (inclusive), you have to remember to use something like . (I sometimes to use +1 as a reminder that this is forcing the range a little further, and so that the  call shows the actual stopping point somewhere.)
the problem you have is with  this returns change it to 


Answer URL
https://docs.python.org/3/library/stdtypes.html#ranges
https://docs.python.org/3/library/stdtypes.html#iterator-types
https://docs.python.org/3/library/stdtypes.html#typesseq-range
