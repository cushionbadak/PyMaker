Natural Text
Following code gives different output in  and in : prints: prints:Why does  bind the variable  inside the  function to the values in the string of the  function, while  doesn't do this? How can I achieve the behavior of  in ? I already tried to pass dictionaries for globals and locals to  function in , but nothing worked so far.--- EDIT ---After reading Martijns answer I further analyzed this with . In following example I give the  dictionay as  to , but  prints something else than just printing .The comparison of the ids of  and  shows that they are the same object. But under these conditions  should be the same as . What is wrong in my example?
There is a big difference between  in Python 2 and  in Python 3. You are treating  as a function, but it really is a statement in Python 2.Because of this difference, you cannot change local variables in function scope in Python 3 using , even though it was possible in Python 2. Not even previously declared variables.  only reflects local variables in one direction. The following never worked in either 2 or 3:In Python 2, using the  statement meant the compiler knew to switch off the local scope optimizations (switching from  to  for example, to look up variables in both the local and global scopes). With  being a function, that option is no longer available and function scopes are now always optimized.Moreover, in Python 2, the  statement explicitly copies all variables found in  back to the function locals using , but only if no globals and locals parameters were supplied.The proper work-around is to use a new namespace (a dictionary) for your  call:The  documentation is very explicit about this limitation:Note: The default locals act as described for function  below: modifications to the default locals dictionary should not be attempted. Pass an explicit locals dictionary if you need to see effects of the code on locals after function  returns. 
I'd say it's a bug of python3.prints "2".prints "2".Butfails with--- EDIT ---Another interesting behaviour:outputsAnd alsooutputsApparently, the action of  on locals is the following:If a variable is set within  and this variable was a local variable, then  modifies the internal dictionary (the one returned by ) and does not return it to its original state. A call to  updates the dictionary (as documented in section 2 of python documentation), and the value set within  is forgotten.The need of calling  to update the dictionary is not a bug of python3, because it is documented, but it is not intuitive. Moreover, the fact that modifications of locals within  don't change the locals of the function is a documented difference with python2 (the documentation says "Pass an explicit locals dictionary if you need to see effects of the code on locals after function exec() returns"), and I prefer the behaviour of python2.If a variable is set within  and this variable did not exist before, then  modifies the internal dictionary unless the variable is set afterwards. It seems that there is a bug in the way  updates the dictionary ; this bug gives access to the value set within  by calling  after .
To sum it up:There is no bug in Python 2 nor in Python 3The different behavior of  stems from  being a statement in Python 2, while it became a function in Python 3.Please note:I do not tell anything new here.  This is just an assembly of the truth  out there found in all the other answers and comments.  All I try here is to bring light to some of the more obscure details.The only difference between Python 2 and Python 3 is, that, indeed,  is able to change the local scope of the enclosing function in Python 2 (because it is a statement and can access the current local scope) and cannot do this anymore in Python 3 (because it now is a function, so runs in it's own local scope).The irritation, however, has nothing to do with the  statement, it only stems from one special behavior detail: returns something, which I want to call "a scope-wise mutable singleton which, after the call to , always only references all variables in the local scope".Please note that the behavior of  did not change between Python 2 and 3.  So, this behavior together with change of how  works looks like being erratic, but isn't, as it just exposes some detail, which always was there.What does "a scope-wise mutable singleton which references variables in local scope" mean?It is a , as regardless how often you call  in the same scope, the object returned is always the same.Hence the observation, that , because  and  refer to the same object, the same singleton, as there can only be one (in a different scope you get a different object, but in the same scope you only see this single one).It is , as it is a normal object, so you can alter it. forces all entries in the object to reference the variables in the local scope again.If you change something in the object (via ), this alters the object, as it is a normal mutable object.These changes of the singleton do not propagate back into the local scope, because all entries in the object are .  So if you alter entries, these changes the singleton object, and not the contents of where "the references pointed to before you change the reference" (hence you do not alter the local variable).In Python, Strings and Numbers are not mutable.  This means, if you assign something to an entry, you do not change the object where the entry points to, you introduce a new object and assign a reference to that to the entry.  Example:Besides optimization this does:Create new object Number(1) - which is some other singleton, BTW.store pointer to this Number(1) into (where  shall be the internal local scope)If not already exist, create  objectupdate , so it references all entries in store pointer of the  into Create Number(300), which is not a singleton, BTW.store pointer to these Number(300) into hence the  is updated, too.but  is not updated,so the local variable  or  still is Number(1)Now,  is called again, the  is updated.As  refers to , not ,  changes, too!For more on this surprising detail, why  is a singleton while  is not, see https://stackoverflow.com/a/306353But please do not forget: Numbers are immutable, so if you try to change a number to another value, you effectively create another object.Conclusion:You cannot bring back the  behavior of Python 2 to Python 3 (except by changing your code), as there is no way to alter the local variables outside of the program flow anymore.However, you can bring the behavior of Python 3 to Python 2, such that you, today, can write programs, which run the same, regardless if they run with Python 3 or Python 2.  This is because in (newer) Python 2 you can use  with function like arguments as well (in fact, those is a 2- or 3-tuple), with allows to use the same syntax with the same semantics known from Python 3:(which only works in Python 2) becomes (which works for Python 2 and 3):But beware, that  can no more alter the local enclosing scope this way.  See also https://docs.python.org/2/reference/simple_stmts.html#execSome very last words:The change of  in Python 3 is good.  Because of optimization.In Python 2 you were not able to optimize across , because the state of all local variables which contained immutable contents could change unpredictably.  This cannot happen anymore.  Now the usual rules of function invocations apply to  like to all other functions, too.
I'm afraid I can't explain it exactly, but it basically comes from the fact that b inside the function is local, and  appears to assign to the global b. You'll have to declare b to be global inside the function, and inside the exec statement. Try this:Which gives meYou can see that outside the function, the global b is automatically picked up. Inside the function, you're printing the local b. Note that I would have thought that  always uses the global b first, so that in , you don't need to declare it inside the  function. But I find that doesn't work (which is the part I can't explain exactly).


Answer URL
https://docs.python.org/3/library/functions.html#exec
