Natural Text
I want to know how to automate this part:In this code:Meaning perform specified amount of  checks automatically, instead of manually hard-coding those 3 comparing statements in there. And not loose any performance?I tried to replace this hard-coded if statement with this code down below, but it's a few times slower than the hardcoded way:So is there a way to:make it not hard-coded (use a variable's value to generate specified amount of check)retain performanceUpdate:The first list is always the same, the second list always has random values, so I want it to go through the specified range of numbers  (100, 101, 102, ...) and find the first  that would satisfy ALL the checks (find the 2nd list that has the same values as the first list) I want it to work with all the operations, like +,-,*,/,% etc
I think you are missing a key point here. You do not need to guess the size of your delta. You can rearrange  to read . This way, there is only one or no values of  which make all the elements you want to compare equal to each other. You can do something like:This is a very simplified approach. One improvement that might help with performance would be to use itertools.islice instead of the index  since that would avoid allocating a new pair of lists.Your original code only allows  within a certain range. If this is something you want and not just an artifact, you can add that test as well:Update in response to your updateYou should be able to write all the operations besides modulo in the same way:For , use For , use For , use For , use etc.The problem with modulo is that it does not have a unique inverse operation. I do not remember enough number theory at this point to say if there will be a faster solution than just using @Steven's answer using a direct application of ,  and , but I suspect not.
Use the builtin  function
This code is slow because the slices  and  iterate  times to create sublists that get thrown away.  It's particularly unfortunate when  evaluates to  on an early iteration because  is happy to shorcut evaluation in these situations, but you've already paid the performance penalty in the sublist creation.Use  to avoid the performance penalty of creating the sublists:This can be streamlined by switching the order or  and Put it all together and you get
Just change  and  according to your rangeHowever, of course this isn't quite as fast as writing out all the conditions by hand. If we measure execution time using  with some sample values, it becomes obvious:so keep that in mind (since I don't know how high your performance needs are)


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.islice
https://docs.python.org/3/library/itertools.html#itertools.islice
https://docs.python.org/3/library/itertools.html#itertools.islice
