Natural Text
I've been playing around with Python's . I think I have a reasonable understanding by now. But the following behavior puzzles me.test.py:This code is wrong. I know that. The event loop can't be run while it's running, and it's generally not thread safe.My question: why can  sometimes still finish its job?Here's the output from two consecutive runs:The first run's behavior is what I expected - the main thread fails, but the event loop still runs  to finish in the thread .The second run is puzzling, how can  do its job when the  is already thrown? I guess it has to do with thread synchronization and the non-thread-safe nature of the event loop. But I don't know exactly how this works.
Ohhh... never mind. I read the code of  and figured it out. It's actually quite simple. calls  before it checks  (which is done in ). Since the loop is already running, it can pick up the task before the  is thrown. Of course it doesn't always happen because of the race condition.
Exceptions are thrown per thread. The runtime error is raised in a different thread from the event loop. The event loop continues to execute, regardless.And  can sometimes finish it's job because you can get lucky. The  loop internal data structures are not guarded against race conditions caused by using threads (which is why there are specific thread-support methods you should use instead). But the nature of race conditions is such that it depends on the exact order of events and that order can change each time you run your program, depending on what else your OS is doing at the time.The  method first calls  to add the coroutine to the task queue with a 'done' callback attached that will stop the event loop again, then calls . When the coroutine returns, the callback stops the loop. The  call throws the  here.When you do this from a thread, the task gets added to a deque object attached to the loop, and if that happens at the right moment (e.g. when the running loop is not busy emptying the queue), the running loop in the main thread will find it, and execute it, even if the  call raised an exception. All this relies on implementation details. Different versions of Python will probably exhibit different behaviour here, and if you install an alternative loop (e.g. ), there will almost certainly be different behaviour again.If you want to schedule coroutines from a different thread, use ; it would :The above doesn't actually complete the  coroutine because the  coroutine is being run with  so its callback stops the loop again before the 2 second wait is over. But the coroutine is actually started:but if you made the main-thread coroutine take longer (with, say, ) then the one scheduled from the thread would also complete. You'd have to do additional work to ensure that there are no more pending tasks scheduled to run with the loop before you shut it down.


Answer URL
https://docs.python.org/3/library/asyncio-dev.html#asyncio-multithreading
https://docs.python.org/3/library/asyncio-future.html#asyncio.ensure_future
https://docs.python.org/3/library/asyncio-task.html#asyncio.run_coroutine_threadsafe
