Natural Text
Consider this small example:which prints Why is the  parameter (which should be the Test obj instance) not passed as first argument to the decorated function ?If I do it manually, like :it works as expected. But if I must know in advance if a function is decorated or not, it defeats the whole purpose of decorators. What is the pattern to go here, or do I misunderstood something?
tl;drYou can fix this problem by making the  class a descriptor and returning a partially applied function from  which applies the  object as one of the arguments, like thisThe actual problemQuoting Python documentation for decorator,The decorator syntax is merely syntactic sugar, the following two function definitions are semantically equivalent:So, when you say,it is actually only the function object is passed to the , the object to which it is actually bound is not passed on along with it. So, when you invoke it like this will refer to the unbound function object and it is invoked with  as the first argument. That is why  prints as .How can I fix this?Since you have no reference to the  instance in the , the only way to do this would be to convert  as a descriptor class. Quoting the documentation, Invoking descriptors section,In general, a descriptor is an object attribute with “binding behavior”, one whose attribute access has been overridden by methods in the descriptor protocol: , , and . If any of those methods are defined for an object, it is said to be a descriptor.The default behavior for attribute access is to get, set, or delete the attribute from an object’s dictionary. For instance,  has a lookup chain starting with , then , and continuing through the base classes of  excluding metaclasses.However, if the looked-up value is an object defining one of the descriptor methods, then Python may override the default behavior and invoke the descriptor method instead.We can make  a descriptor, by simply defining a method like thisHere,  refers to the  object itself,  refers to the actual object on which the attribute lookup is happening and  refers to the class corresponding to the .Now, when  is invoked on , the  method will be invoked. Now, somehow, we need to pass the first argument as the instance of  class (even before ). So, we create another partially applied function, whose first parameter will be the  instance, like thisNow,  is a bound method (bound to  instance) and the second parameter to  is the first argument to the  call.So, all these effectively translate like thisNow  is actually  (this will be referred as  from now on) object. Whenever we access it, the  method defined in it will be invoked and it returns a  function. You can confirm that like thiswould printSo,gets translated toSince we return a  function,which is actuallySo,  also becomes a part of , and when  is invoked, the first argument will be the .
You first have to understand how function become methods and how  is "automagically" injected.Once you know that, the "problem" is obvious: you are decorating the  function with a  instance - IOW,  is a  instance, not a  instance - and your  class does not mimick the  type's implementation of the  protocol. What you want looks like this:
I use decorators in the following way:


Answer URL
https://docs.python.org/3/glossary.html#term-descriptor
https://docs.python.org/3/glossary.html#term-decorator
