Natural Text
I am in confusion when trying to understand the order that  creates a class instance. According to this diagram (source), I type the following codes to verify it.However, the result seems not like this follow.Any help will be appreciated.
Despite @torek's lenghty answer, with a lot of other details on class creation, what you brought together to this question is mostly correct.The only thing that is wrong in your code, which propably puzzled you is that te class you call  have to be itself the  metaclass from  and not its parent.Simply change  declaration to:(No need for it to inherit from "Meta" as well - it can derive only from . It is otherwise though to think of a customization to  that would be usefull at the same time for creating instances of your classes (that is when  is called), and your classes themselves ( called))Here is another, shorter example I just typed at the terminal. Sorry for the naming inconsistencies, and for being less complete - but it shows the main point:Upon processing the  body, Python output was:MoreoverAs you can see from this, with a meta-meta class it is possible to customize the call order and parameters to the metaclass  and , but there are still steps that can't be customized from pure-Python code, and would require native calls to API's (and possibly raw object structure manipulation) - that are:One can't control the call to One can't control the call to  on the created classes One can control when descriptors'  are calledThe last two items take place after meta-meta's  return, and before resuming the flow to the module where the class module is.
The trick, identifiedUpdate 2: Based on behavior, the fact that  is called below must be a side effect of this line in  in the CPython source ().In order to define a class that has a metaclass, we call the metaclass's , , and  as usual.  This creates a class—in the example below, —that is callable, but its internal  slot points not to its own  but rather to its metaclass's .  Hence if we call  (the metaclass object), we invoke :produces:In other words, we see that  acts like , but it (rather magically and not very well documented) invokes .  This is no doubt due to looking up  in the class's type, rather than in an instance of the class (and indeed there is no instance except for the one we're creating).  This is in fact the general case: it falls out of the fact that we call  on the type of , and the type of  is :prints:which explains where this comes from.  (I still think this should be emphasized in the documentation, which also should describe the constraints on metaclass typing—these are enforced in  in  and, as C code, in  in Objects/typeobject.c.)Updated original answerI don't know where your diagram came from, but it's wrong. UPDATE: You can in fact have a metaclass for your metaclass; see jsbueno's answer, and I've updated the example below.  New sentences / text are in bold, except for the final section describing my puzzlement at the apparent lack of documentation.Your existing metaclass code has at least one error.  Most significantly, its  needs to be a class-method.  See also Using the __call__ method of a metaclass instead of __new__? and PEP 3115.  And, to use a meta-meta-class, your metaclass needs to have a metaclass of its own, not a base class.Chris's answer contains correct definitions.  But there are some unfortunate asymmetries between metaclass method arguments and class method arguments, which I'll illustrate below.One other thing that may help: note that the metaclass  method is called before creating any instances of class : it is called when  itself is being defined.  To show this, here is a corrected metaclass-and-class.  I have also added a few more illustrators.  I've added a meta-metaclass as well, based on jsbueno's answer.  I cannot find formal Python documentation on this, but I've updated the output below.Now, let's observe what happens when I run this, and take each piece apart:To create class  itself, Python first calls the metaclass's , delivering it the name of the class (), the list of base classes (an empty tuple—it's called a list but is actually a tuple), and any keyword arguments (none).  As PEP 3115 notes, the metaclass needs to return a dictionary or -like object; this one does by just returning an empty dictionary, so we are good here.(I don't print  itself here, but if you do, you will see it is just .)Next, having gotten a dictionary from , Python first calls the meta-meta , i.e., , passing the entire set of arguments as the  tuple.  It then populates the -supplied dictionary with all the attributes for the class, passing this as the  to the metaclass  and .  If you print the  of the dictionary returned from  and passed to  and  you will see they all match.Since class  has no methods or data members, we see only the magic  and  attributes here.  We also see no keyword arguments, so now let's move on to creating class :This one is rather more interesting.  Now we have one base class, namely .  Class  also defines several methods ( and ) and we see them in the  dictionaries passed to the metaclass  and  methods (which, remember, are just the now-populated dictionary returned by the metaclass's ).  As before, the passing-on happens through the meta-meta-class .  We also see one keyword argument throughout, .  In the attribute dictionary, we can also observe the magic  entry: see Provide __classcell__ example for Python 3.6 metaclass for a short description as to what this is about, but to be, er, super-short, it's for making  work.The keyword argument is passed to all three metaclass methods, plus that of the meta-meta-class.  (I'm not quite sure why.  Note that modifying the dictionary in any metaclass method does not affect it in any other, as it's a copy each time of the original keyword arguments.  However, we can modify it in the meta-meta-class: add  to  to observe this.)Now that we have our classes  and , we can get on to the process of creating an actual instance of class .  Now we see the metaclass's  invoked (not the meta-meta-class's):It's possible to change the  or  passed on, but I don't; the sample code above winds up calling  (through the magic of ).  This in turn calls  and :which finishes the realization of the new instance of class , which we then bind to the name .Note that  says:so we invoke  to create the instance—this is more or less a requirement of all versions of Python; you can only "cheat" when you return a singleton instance (ideally, one that's non-modifiable).  It's  that calls  on this object, passing the arguments and keyword-arguments we passed it.  If we replace 's  with:we will see that  and  are never called:This would, in effect, create a useless/uninitialized instance .  It's therefore critical that the metaclass  method call the underlying class's , usually by invoking  via .  If the underlying class has a , the metaclass should call that first, again usually by invoking .Side note: what the documentation saysTo quote section 3.3.3.6:Once the class namespace has been populated by executing the class body, the class object is created by calling  (the additional keywords passed here are the same as those passed to ).This explains the call to  when creating  as an instance of class , but not the fact that Python first calls  before calling  and  when creating classes  and  themselves.The next paragraph mentions the  entry; the one after that goes on to describe the use of  and  hooks.  Nothing here tells us how or why Python calls  at this point.Earlier, in sections 3.3.3.3 through 3.3.3.5, the documentation describes the process of determining the metaclass, preparing the class namespace, and executing the class body.  This is where the meta-metaclass action should be described, but isn't.Several additional sections describe a few additional constraints.  One important one is 3.3.10, which talks about how special methods are found via the object type, bypassing both regular member attribute lookups and even (sometimes) a metaclass getattribute, saying:Bypassing the  machinery in this fashion provides significant scope for speed optimisations within the interpreter, at the cost of some flexibility in the handling of special methods (the special method must be set on the class object itself in order to be consistently invoked by the interpreter).Update 2: This is really the secret of the trick: the special  method is found via the type's type.  If the metaclass has a metaclass, the meta-meta-class provides the  slot; otherwise the type of the metaclass is , so that the  slot is .


Answer URL
https://docs.python.org/3/reference/datamodel.html
https://docs.python.org/3/reference/datamodel.html
