Natural Text
I would like to take a list like this: ['5', '0 1', '1 2', '1 8', '2 3'] and return a new list made of tuples like this: [(0,[1]),(1,[0,2,8]),(2[1,3]),(3,[2]),(8,[1])]. The first element of each tuple is an integer and the second element is a list of integers it appears next to in the original list. I cannot use dictionaries, sets, deque, bisect module. This is what I have so far. I want it to return:[(0, [1, 2, 3]), (1, [0, 4, 6, 7, 9]), (2, [0, 3, 6, 8, 9]), (3, [0, 2, 8, 9]), (4, [1, 6, 7, 8]), (5, [9]), (6, [1, 2, 4, 8]), (7, [1, 4, 8]), (8, [2, 3, 4, 6, 7]), (9, [1, 2, 3, 5])] but it is returning [(0, [1, 2, 3]), (1, [4, 6, 7, 9]), (2, [3, 6, 8, 9]), (3, [8, 9]), (4, [6, 7, 8]), (5, [9]), (6, [8]), (7, [8])]. I don't know why it isn't working.
You could do something like this:OutputThe general idea is to create a dictionary where the keys are the integers and the values are a set of integers it appears nextto. The statement  creates an iterable of integers, then using combinations pick every possible pair from the iterable, add each pair to the dictionary and finally return the tuples where the values are sorted.UPDATE (not using any built-in module)OutputThe above code does not use set, dictionary nor any external module. Be warned it can be slow.
You can use a list comprehension:Output:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.combinations
