Natural Text
First off, apologies for the confusing title. What I am trying to achieve is the following: Suppose I have some function  which takes a function and an integer as input. e.g. Now, I'd like to wrap this function in a python extension module. So I start writing my interface:Now, when it comes time to parse the input tuple, I get confused, as I'm not really sure how to parse it. The idea is rather simple: I need to be able to call  in python. But I could use some help on how to realize this.
First off, when you have a Python "extension method", implemented in C, and that function receives a Python callable as an argument, here is how you receive the argument, and how you call the callable:The problem with using logic like this to wrap  is that the pointer to the Python callable is a data pointer.  If you passed that pointer directly to ,  would attempt to invoke data as machine code and it would crash.  If  passed through a data pointer to the function that it calls, you could work around this with a "glue" procedure:Unfortunately,  does not have this signature, so you cannot do this.  But the alternative interface  takes a , which is an object-oriented wrapper around the pattern above, so you can do this instead:The magic here is all in the  notation, which is syntactic sugar for defining and creating an instance of a local class that "captures" the variables  and  so that the code inside the curly braces, which will be compiled as a separate function, can communicate with  proper.  This is a C++11 feature called "lambdas", which is a jargon term going all the way back to the earliest days of theoretical CS and immortalized by Lisp.  Here is a tutorial, but I am not sure how good it is because I already know the concept inside and out.It is not possible to do this in plain C, but it isn't possible to call  from plain C either (because you can't define a  object at all in plain C ... well, not without reverse engineering the C++ standard library and ABI, anyway) so that's okay.
The Python callable passed in will be a Python object which matches the Callable protocol.  Therefore, in order to pass it to your C function, you'll have to create another C function as a proxy which matches the required signature of your function pointer.As an example:Note that I used a global callback object pointer in the example, since your original function pointer didn't have a place for custom user data.  If you add a generic user parameter to the  callback, the  could be passed to it that way instead of making a global variable.  For example:


Answer URL
https://docs.python.org/3/c-api/init.html#non-python-created-threads
