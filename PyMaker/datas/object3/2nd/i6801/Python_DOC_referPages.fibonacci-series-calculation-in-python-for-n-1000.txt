Natural Text
I have this tail recursive function here:It works up to n=997, then it just breaks and spits a "maximum recursion depth exceeded in comparison" . Is this just a stack overflow? Is there a way to get around it?
It is a guard against a stack overflow, yes. Python (or rather, the CPython implementation) doesn't optimize tail recursion, and unbridled recursion causes stack overflows. You can change the recursion limit with , but doing so is dangerous -- the standard limit is a little conservative, but Python stackframes can be quite big.Python isn't a functional language and tail recursion is not a particularly efficient technique. Rewriting the algorithm iteratively, if possible, is generally a better idea.
Looks like you just need to set a higher recursion depth
It's to avoid a stack overflow. The Python interpreter limits the depths of recursion to help you avoid infinite recursions, resulting in stack overflows.Try increasing the recursion limit (sys.setrecursionlimit) or re-writing your code without recursion.from python website:Return the current value of the recursion limit, the maximum depth of the Python interpreter stack. This limit prevents infinite recursion from causing an overflow of the C stack and crashing Python. It can be set by setrecursionlimit().
Use a language that guarantees tail-call optimisation. Or use iteration. Alternatively, get cute with decorators.
I realize this is an old question but for those reading, I would recommend against using recursion for problems such as this - lists are much faster and avoid recursion entirely.  I would implement this as:(Use n+1 in xrange if you start counting your fibonacci sequence from 0 instead of 1.)
Of course Fibonacci numbers can be computed in O(n) by applying the Binet formula:As the commenters note it's not O(1) but O(n) because of . Also a difference is that you only get one value, while with recursion you get all values of  up to that value. 
I had a similar issue with the error "Max recursion depth exceeded". I discovered the error was being triggered by a corrupt file in the directory I was looping over with os.walk. If you have trouble solving this issue and you are working with file paths, be sure to narrow it down, as it might be a corrupt file. 
If you often need to change the recursion limit (e.g. while solving programming puzzles) you can define a simple context manager like this:Then to call a function with a custom limit you can do:On exit from the body of the  statement the recursion limit will be restored to the default value.
 must also be used to increase the stack size and prevent segfaultThe Linux kernel limits the stack of processes.Python stores local variables on the stack of the interpreter, and so recursion takes up stack space of the interpreter.If the Python interpreter tries to go over the stack limit, the Linux kernel segfaults it.The stack limit size is controlled with the  and  system calls.Python offers access to those system calls through the  module.Of course, if you keep increasing ulimit, your RAM will run out, which will either slow your computer to a halt due to swap madness, or kill Python via the OOM Killer.From bash, you can see and set the stack limit (in kb) with:Default value for me is 8Mb.See also:Setting stacksize in a python scriptPython: What is the hard recursion limit for Linux, Mac and Windows?Tested on Ubuntu 16.10, Python 2.7.12.
Use generators?above fib() function adapted from: http://intermediatepythonista.com/python-generators
If you want to get only few Fibonacci numbers, you can use matrix method.It's fast as numpy uses fast exponentiation algorithm. You get answer in O(log n). And it's better than Binet's formula because it uses only integers. But if you want all Fibonacci numbers up to n, then it's better to do it by memorisation.
Many recommend that increasing recursion limit is a good solution however it is not because there will be always limit. Instead use an iterative solution. 
As @alex suggested, you could use a generator function to do this. Here's the equivalent of the code in your question:
I wanted to give you an example for using memoization to compute Fibonacci as this will allow you to compute significantly larger numbers using recursion:This is still recursive, but uses a simple hashtable that allows the reuse of previously calculated Fibonacci numbers instead of doing them again.


Answer URL
https://docs.python.org/3/reference/datamodel.html#context-managers
