Natural Text
My question refers specifically to why it was designed that way, due to the unnecessary performance implication.When thread T1 has this code:and thread T2 has this code:what happens is that T1 waits and releases the lock, then T2 acquires it, notifies  which wakes up T1. Now, there is a race-condition between T2's release and T1's reacquiring after returning from . If T1 tries to reacquire first, it will be unnecessarily resuspended until T2's  is completed.Note: I'm intentionally not using the  statement, to better illustrate the race with explicit calls.This seems like a design flaw. Is there any rationale known for this, or am I missing something?
This is not a definitive answer, but it's supposed to cover the relevant details I've managed to gather about this problem.First, Python's threading implementation is based on Java's.  Java's  documentation reads:An implementation may (and typically does) require that the current thread hold the lock associated with this Condition when this method is called.Now, the question was why enforce this behavior in Python in particular. But first I want to cover the pros and cons of each approach.As to why some think it's often a better idea to hold the lock, I found two main arguments:From the minute a waiter s the lock—that is, before releasing it on —it is guaranteed to be notified of signals. If the corresponding  happened prior to signalling, this would allow the sequence(where P=Producer and C=Consumer)  in which case the  corresponding to the  of the same flow would miss the signal. There are cases where this doesn't matter (and could even be considered to be more accurate), but there are cases where that's undesirable. This is one argument.When you  outside a lock, this may cause a scheduling priority inversion; that is, a low-priority thread might end up taking priority over a high-priority thread. Consider a work queue with one producer and two consumers (LC=Low-priority consumer and HC=High-priority consumer), where LC is currently executing a work item and HC is blocked in .The following sequence may occur:Whereas if the  happened before , LC wouldn't have been able to  before HC had been woken-up. This is where the priority inversion occurred. This is the second argument.The argument in favor of notifying outside of the lock is for high-performance threading, where a thread need not go back to sleep just to wake-up again the very next time-slice it gets—which was already explained how it might happen in my question.Python's  ModuleIn Python, as I said, you must hold the lock while notifying. The irony is that the internal implementation does not allow the underlying OS to avoid priority inversion, because it enforces a FIFO order on the waiters. Of course, the fact that the order of waiters is deterministic could come in handy, but the question remains why enforce such a thing when it could be argued that it would be more precise to differentiate between the lock and the condition variable, for that in some flows that require optimized concurrency and minimal blocking,  should not by itself register a preceding waiting state, but only the  call itself.Arguably, Python programmers would not care about performance to this extent anyway—although that still doesn't answer the question of why, when implementing a standard library, one should not allow several standard behaviors to be possible.One thing which remains to be said is that the developers of the  module might have specifically wanted a FIFO order for some reason, and found that this was somehow the best way of achieving it, and wanted to establish that as a  at the expense of the other (probably more prevalent) approaches. For this, they deserve the benefit of the doubt until they might account for it themselves.
There are several reasons which are compelling (when taken together).1. The notifier needs to take a lockPretend that  exists.The standard producer/consumer arrangement requires taking locks on both sides:This fails because both the  and the  can intervene between the  and the .Writing either ofworks (which is an interesting exercise to demonstrate).  The second form has the advantage of removing the requirement that  be thread-safe, but it costs no more locks to take it around the call to  as well.It remains to explain the preference for doing so, especially given that (as you observed) CPython does wake up the notified thread to have it switch to waiting on the mutex (rather than simply moving it to that wait queue).2. The condition variable itself needs a lockThe  has internal data that must be protected in case of concurrent waits/notifications.  (Glancing at the CPython implementation, I see the possibility that two unsynchronized s could erroneously target the same waiting thread, which could cause reduced throughput or even deadlock.)  It could protect that data with a dedicated lock, of course; since we need a user-visible lock already, using that one avoids additional synchronization costs.3. Multiple wake conditions can need the lock(Adapted from a comment on the blog post linked below.)Suppose  is  and thread #1 is waiting in .  Thread #2 calls ; when it releases , #1 is still blocked on the condition.  Thread #3 then calls , finds that  is , and waits.  Then #2 calls , waking #3, which is still unsatisfied and blocks again.  Now #1 and #3 are both waiting, despite the fact that one of them must have its condition satisfied.Now that situation cannot arise: either #3 arrives before the update and never waits, or it arrives during or after the update and has not yet waited, guaranteeing that the notification goes to #1, which returns from .4. The hardware might need a lockWith wait morphing and no GIL (in some alternate or future implementation of Python), the memory ordering (cf. Java's rules) imposed by the lock-release after  and the lock-acquire on return from  might be the only guarantee of the notifying thread's updates being visible to the waiting thread.5. Real-time systems might need itImmediately after the POSIX text you quoted we find:however, if predictable scheduling behavior is required, then that mutex  shall be locked by the thread calling pthread_cond_broadcast() or  pthread_cond_signal().One blog post contains further discussion of the rationale and history of this recommendation (as well as of some of the other issues here).
What happens is that T1 waits and releases the lock, then T2 acquires it, notifies cv which wakes up T1.Not quite.  The  call does not wake the T1 thread:  It only moves it to a different queue.  Before the , T1 was waiting for the condition to be true.  After the , T1 is waiting to acquire the lock.  T2 does not release the lock, and T1 does not "wake up" until T2 explicitly calls .
A couple of months ago exactly the same question occurred to me. But since I had  opened, looking at  result (the source for the method) didn't take long to answer it myself.In short, the  method creates another lock called waiter, acquires it, appends it to a list and then, surprise, releases the lock on itself. After that it acquires the waiter once again, that is it starts to wait until someone releases the waiter. Then it acquires the lock on itself again and returns.The  method pops a waiter from the waiter list (waiter is a lock, as we remember) and releases it allowing the corresponding  method to continue.That is the trick is that the  method is not holding the lock on the condition itself while waiting for the  method to release the waiter.UPD1: I seem to have misunderstood the question. Is it correct that you are bothered that T1 might try to reacquire the lock on itself before the T2 release it?But is it possible in the context of python's GIL? Or you think that one can insert an IO call before releasing the condition, which would allow T1 to wake up and wait forever?
There is no race condition, this is how condition variables work.When wait() is called, then the underlying lock is released until a notification occurs. It is guaranteed that the caller of wait will reacquire the lock before the function returns (eg, after the wait completes).You're right that there could be some inefficiency if T1 was directly woken up when notify() is called. However, condition variables are typically implemented via OS primitives, and the OS will often be smart enough to realize that T2 still has the lock, so it won't immediately wake up T1 but instead queue it to be woken.Additionally, in python, this doesn't really matter anyways, as there's only a single thread due to the GIL, so the threads wouldn't be able to run concurrently anyways.Additionally, it's preferred to use the following forms instead of calling acquire/release directly:And:This ensures that the underlying lock is released even if an exception occurs.


Answer URL
https://docs.python.org/3/library/threading.html
