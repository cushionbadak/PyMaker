Natural Text
I have a class that uses  and makes them nearly immutable by overriding  to always raise an error:Here, the "private" attribute  is a place-holder for a complex operation to interact with some custom hardware.Since  is a property, I expect to be able to do something likeInstead, I see my  with the message .There are a number of obvious workarounds here, such as to remove the custom  (which I do not want to do) or to rewrite it asThis seems like an awkward method that has the potential to balloon out of proportion if I start adding more properties like that.The real issue is that I do not understand why there is no conflict between  and the property, but there is one between  and the property. What is happening with the lookup order, and is there another, more elegant workaround to this problem?
The real issue is that I do not understand why there is no conflict between  and the property, but there is one between  and the property.Both  and  implement attribute lookup by providing a descriptor for the corresponding attribute(s). The presence of  prevents arbitrary instance attribute creation not by doing anything to , but by preventing creation of a .  and other descriptors don't rely on an instance , so they're unaffected.However,  handles all attribute assignment, meaning that descriptor invocation is 's responsibility. If your  doesn't handle descriptors, descriptors won't be handled, and  setters won't be invoked.is there another, more elegant workaround to this problem?You could explicitly allow only properties:or you could explicitly reject assignment to slots, and delegate other attribute assignment to :


Answer URL
https://docs.python.org/3/reference/datamodel.html#descriptors
