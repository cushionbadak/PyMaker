Natural Text
From the Google Style Guide on lexical scoping:A nested Python function can refer to variables defined in enclosing  functions, but can not assign to them.This specification can be seen here:Reversing the order of the two statements in  gets rid of this issue:My question is, what is it about Python's implementation that tells the first function that  will be declared locally (after the print statement)?  My understanding is that Python is effectively interpreted line by line.  So, shouldn't it default to looking for a nonlocal  at that point in the code?To elaborate, if I was to use just reference (no assignment),somehow the print statement knows to reference the nonlocal  defined in the enclosing function.  But if I assign to a local  after that line, the function is almost too smart for its own good.
My understanding is that Python is effectively interpreted line by line.That's not the right mental model.The body of the entire function is analysed to determine which names refer to local variables and which don't.To simplify your example, the following also gives :Here,  compiles to the following bytecodes:Compare this withwhich compiles toObserve how the absence of assignment to  turns the reference from a local to a global one.
My understanding is that Python is effectively interpreted line by lineThat's where you're wrong. The whole file is compiled to bytecode before any interpretation begins.Also, even if the bytecode compilation pass didn't exist,  wouldn't actually be executed before  is seen, because it's in a function definition. Python would still know about the  by the time it actually tries to execute .
As per documentA special quirk of Python is that – if no  statement is in effect – assignments to names always go into the innermost scope. Assignments do not copy data — they just bind names to objects.


Answer URL
https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces
