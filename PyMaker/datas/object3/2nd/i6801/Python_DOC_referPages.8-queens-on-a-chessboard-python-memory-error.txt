Natural Text
I came across this question where 8 queens should be placed on a chessboard such that none can kill each other.This is how I tried to solve it:Traceback (most recent call last):qPositions=[''.join(p) for p in itertools.combinations(chessPositions,8)]MemoryErrorI'm still a newbie.How can I overcome this error?Or is there any better way to solve this problem?
What you are trying to do is impossible ;)!means that you will get a list with length , since , which you cannot store in memory. Why not? Combining what I stated in the comments and @augray in his answer, the result of above operation would be a list which would takeof RAM, since it will have  elements, each element will have 8 substrings like  and each substring like this consists of 2 character. One character takes 1 byte.You have to find another way. I am not answering to that because that is your job. The n-queens problem falls into dynamic programming. I suggest you to google 'n queens problem python' and search for an answer. Then try to understand the code and dynamic programming.I did searching for you, take a look at this video. As suggested by @Jean Fran√ßois-Fabre, backtracking. Your job is now to watch the video once, twice,... as long as you don't understand the solution to problem. Then open up your favourite editor (mine is Vi :D) and code it down!
This is one case where it's important to understand the "science" (or more accurately, math) part of computer science as much as it is important to understand the nuts and bolts of programming.From the documentation for , we see that the number of items returned is  where  is the length of the input collection (in your case the number of chess positions, 64) and  is the length of the subsequences you want returned (in your case 8). As @campovski has pointed out, this results in 4,426,165,368. Each returned subsequence will consist of 8*2 characters, each of which is a byte (not to mention the overhead of the other data structures to hold these and calculate the answer). Each character is 1 byte, so in total, just counting the memory consumption of the resulting subsequences gives . dividing this by 1024^3 gives the number of Gigs of memory held by these subsequences, about 66GB.I'm assuming you don't have that much memory :-) . Calculating the answer to this question will require a well thought out algorithm, not just "brute force". I recommend doing some research on the problem- Wikipedia looks like a good place to start.
As the other answers stated you cant get every combination to fit in memory, and you shouldn't use brute force because the speed will be slow. However, if you want to use brute force, you could constrain the problem, and eliminate common rows and columns and check the diagonalAlso as a note, this line of code attempts to first find all of the combinations, then feed your function, which is a waste of memory.If you decided you do want to use a brute force method, it is possible. Just modify the code for itertools combinations. Remove the  and  and just feed your check function one at a time.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.combinations
