Natural Text
I want to write a library that manages child processes with asyncio. I don't want to force my callers to be asynchronous themselves, so I'd prefer to get a , do a , and then  it. Ideally I'd like to do this without conflicting with any other asyncio stuff the caller might be doing.My problem is that waiting on subprocesses doesn't work unless you call , which attaches the internal watcher. But of course if I do that, I might conflict with other event loops in the caller. A workaround is to cache the caller's current loop (if any), and then call  one more time when I'm done to restore the caller's state. That almost works. But if the caller is not an asyncio user, a side effect of calling  is that I've now created a global loop that didn't exist before, and Python will print a scary warning if the program exits without calling  on that loop.The only meta-workaround I can think of is to do an  callback that closes the global loop. That won't conflict with the caller because close is safe to call more than once, unless the caller has done something crazy like trying to start the global loop during exit. So it's still not perfect.Is there a perfect solution to this?
What you're trying to achieve looks very much like ProcessPoolExecutor (in concurrent.futures).Asyncronous caller:Synchronous caller:


Answer URL
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor
https://docs.python.org/3/library/concurrent.futures.html#module-concurrent.futures
