Natural Text
As a simple example, consider the network equivalent of /dev/zero, below. (Or more realistically, just a web server sending a large file.)If a client disconnects early, you get a barrage of log messages:But I'm not finding any way to catch said exception. The hypothetical server continues reading gigabytes from disk and sending them to a dead socket, with no effort on the client's part, and you've got yourself a DoS attack.The only thing I've found from the docs is to yield from a read, with an empty string indicating closure. But that's no good here because a normal client isn't going to send anything, blocking the write loop.What's the right way to detect failed writes, or be notified that the TCP connection has been closed, with the streams API or otherwise?Code:
This is a little bit strange, but you can actually allow an exception to reach the  coroutine by forcing it to yield control to the event loop for one iteration:If I do that, I get this output when I kill the client connection:I'm really not quite sure why you need to explicitly let the event loop get control for the exception to get through - don't have time at the moment to dig into it. I assume some bit needs to get flipped to indicate the connection dropped, and calling  (which can short-circuit going through the event loop) in a loop is preventing that from happening, but I'm really not sure. If I get a chance to investigate, I'll update the answer with that info.
I did some digging into the  source to expand on dano's answer on why the exceptions aren't being raised without explicitly passing control to the event loop. Here's what I've found.Calling  gives the control over to the  coroutine. This coroutine checks for and raises any exceptions that that the  set on the . But since we passed control over to , the protocol hasn't had the chance to set the exception yet.  then gives control over to the  coroutine. This coroutine the returns immediately because some more flags haven't been set yet, and the control ends up back with the coroutine that called .And so we have gone full circle without giving control to the event loop to allow it handle other coroutines and bubble up the exceptions to .ing before a  gives the transport/protocol a chance to set the appropriate flags and exceptions.Here's a mock up of what's going on, with all the nested calls collapsed:This should probably fixed upstream in the Streams API by the  developers.
The stream based API doesn't have a callback you can specify for when the connection is closed. But the Protocol API does, so use it instead: https://docs.python.org/3/library/asyncio-protocol.html#connection-callbacks


Answer URL
https://docs.python.org/3/library/asyncio-protocol.html#connection-callbacks
