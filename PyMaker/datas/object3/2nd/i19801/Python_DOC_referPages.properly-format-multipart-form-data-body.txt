Natural Text
IntroductionBackgroundI'm writing a script to upload stuff including files using the  content type defined in RFC 2388. In the long run, I'm trying to provide a simple Python script to do uploads of binary packages for github, which involves sending form-like data to Amazon S3.RelatedThis question has already asked about how to do this, but it is without an accepted answer so far, and the more useful of the two answers it currently has points to these recipes which in turn build the whole message manually. I am somewhat concerned about this approach, particularly with regard to charsets and binary content.There is also this question, with its currently highest-scoring answer suggesting the  module. But that is not much different from the recipes I mentioned, and therefore my concerns apply tho that as well.ConcernsBinary contentRFC 2388 Section 4.3 explicitely states that content is expected to be 7 bit unless declared otherwise, and therefore a  header might be required. Does that mean I'd have to Base64-encode binary file content? Or would  be sufficient for arbitrary files? Or should that read ?Charset for header fieldsHeader fields in general, and the  header field in particular, are ASCII only by default. I'd like my method to be able to pass non-ASCII file names as well. I know that for my current application of uploading stuff for github, I probably won't need that as the file name is given in a separate field. But I'd like my code to be reusable, so I'd rather encode the file name parameter in a conforming way. RFC 2388 Section 4.4 advises the format introduced in RFC 2231, e.g. .My approachUsing python librariesAs  is essentially a MIME type, I thought that it should be possible to use the  package from the standard python libraries to compose my post. The rather complicated handling of non-ASCII header fields in particular is something I'd like to delegate.Work so farSo I wrote the following code:The result looks like this:It does seem to handle headers reasonably well. Binary file content will get base64-encoded, which might be avoidable but which should work well enough. What worries me are the text fields in between. They are base64-encoded as well. I think that according to the standard, this should work well enough, but I'd rather have plain text in there, just in case some dumb framework has to deal with the data at an intermediate level and does not know about Base64 encoded data.QuestionsCan I use 8 bit data for my text fields and still conform to the specification?Can I get the email package to serialize my text fields as 8 bit data without extra encoding?If I have to stick to some 7 bit encoding, can I get the implementation to use quoted printable for those text parts where that encoding is shorter than base64?Can I avoid base64 encoding for binary file content as well?If I can avoid it, should I write the  as  or as ?If I had to serialize the body myself, how could I use the  package on its own to just format header values? ( does this.)Is there some implementation that already did all I'm trying to do?These questions are very closely related, and could be summarized as “how would you implement this”. In many cases, answering one question either answers or obsoletes another one. So I hope you agree that a single post for all of them is appropriate.
This is a placeholder answer, describing what I did while waiting for some authoritative input to some of my questions. I'll be happy to accept a different answer if it demonstrates that this approach is wrong or unsuitable in at least one of the design decisions.Here is the code I used to make this work according to my taste for now.I made the following decisions:Can I use 8 bit data for my text fields and still conform to the specification?I decided to do so. At least for this application, it does work.Can I get the email package to serialize my text fields as 8 bit data without extra encoding?I found no way, so I'm doing my own serialization, just as all the other recipes I saw on this.Can I avoid base64 encoding for binary file content as well?Simply sending the file content in binary seems to work well enough, at least in my single application.If I can avoid it, should I write the Content-Transfer-Encoding as 8bit or as binary?As RFC 2045 Section 2.8 states, that  data is subject to a line length limitation of 998 octets between CRLF pairs, I decided that  is the more general and thus the more appropriate description here.If I had to serialize the body myself, how could I use the email.header package on its own to just format header values?As already edited into my question,  is very useful for this. I try to encode using ascii first, but use that method in case of either non-ascii data or ascii characters which are forbidden inside a double-quoted string.Is there some implementation that already did all I'm trying to do?Not that I'm aware of. Other implementations are invited to adopt ideas from my code, though.Edit:Thanks to this comment I'm now aware that the use of RFC 2231 for headers is not universally accepted: the current draft of HTML 5 forbids its use. It has also been seen to cause problems in the wild. But since POST headers not always correspond to a specific HTML document (think web APIs for example), I'm not sure I'd trust that draft in that regard either. Perhaps the right way to go is giving both encoded and unencoded name, the way RFC 5987 Section 4.2 suggests. But that RFC is for HTTP headers, while a multipart/form-data header is technically HTTP body. That RFC therefore doesn't apply, and I do not know of any RFC which would explicitely allow (or even encourage) the use of both forms simultaneously for multipart/form-data.
You might want to look at Send file using POST from a Python script question which points to the Requests library which is becoming the mostly used Python library for http.In case you won't find all needed functionality there and decide to implement it yourself I encourage you to contribute it to this project.


Answer URL
