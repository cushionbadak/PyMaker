Natural Text
I need to make a league table for a project. There has to be 3 files,2 files consist of 1 class and the last file is for running a program. I have done all of the parts but when I call a method to add a team, the program adds the name but it does not insert it into the list of teams(which should do). When I try to display the items in the list, the program displays an error message instead of showing the actual team.How can I fix it?Any help would be appreciated. :)
A few things here:When I try to display the items in the list, the program displays: team.Team object at 0x000000000332A978 insted of showing the actual team.The default display for a user class is something like . If you want it to display something different, you have to tell Python what you want to display. There are two separate functions for this:  and . The idea is that the first is a representation for the programmer, the second for the user. If you don't need two different representations, just define  and it'll use that whenever it needs .So, a really simple way to fix this is to add this to the  class:Now, if you call , then , you'll get  instead of .Meanwhile, these two methods are probably not what you want:These will remove or find a team given the  object—not the name, or even a new  created from the name, but a reference to the exact same object stored in the . This is not all that useful, and you seem to want to call them with just names.There are two ways to fix this: You could change  so that it compares by name instead of by object identity, by adding this method to the class:What this means is that if you say , it will now be true instead of False. Even if the first team is in a different league, and has a different W-L record, and so on (e.g., like the baseball "Giants" from San Francisco vs. the football "Giants" from New York), as far as Python is concerned, they're now the same team. Of course if that's not what you want, you can write any other  function that seems more appropriate. Anyway, if you do this, the  and  functions will now be able to find any  with the same name, instead of just the exact same team, so:If you go this way, you might want to consider defining all of the comparison methods, so you can, e.g., sort a list of teams, and they sort by name.Or you could change these methods so they don't work based on equality, e.g., by redefining them like this:To understand how these work, if you're not used to reading list comprehensions, turn each one back into the equivalent loop:If you step through this,  ends up with a list of every team in the table, except the one you wanted to remove, and then you replace the old  with the new filtered one. (Another way to write the same idea is with , if you know that function.)It's usually better to create a new filtered list than to modify a list in-place. Sometimes there are performance reasons not do this, and sometimes it ends up being very complex and hard to understand, but it's usually both faster and simpler to reason about. Also, modifying lists in place leads to problems like this:Play with this for a while, and you'll see that it doesn't actually work. Understanding why is a bit complicated, and you probably don't want to learn that until later. The usual trick to solve the problem is to iterate over a copy of the list… but once you're doing that, you've now got the worst of filtering and the worst of deleting-in-place at the same time.The second function may be a little too clever, but let's look at it:First, I'm creating a list like the original one, but it's a list of just the names instead of the team objects. Again, let's decompose the list comprehension:Or try to translate it into English: This is a list of the team name of every team in the table.Now, because this is a list of team names, I can use  and it will find it. And, because the two lists have the same shape, I know that this is the right index to use in the original  list as well.A much simpler solution would be to change  from a  of s into a  mapping names to s. This is probably the most Pythonic solution—it looks a lot simpler than writing list comprehensions to do simple operations. (It's also probably the most efficient, but that's hardly relevant unless you have some truly gigantic leagues.) And then you don't even need  for anything. To do that:Note that I've defined  to just return the team name itself as the position. If you think about it,  keys are used exactly the same way as  indices, so this means any code someone wrote for the "old" API that required  will still work with the "new" API. (I probably wouldn't try to sell this to a teacher who assigned a problem that required us to use , but for a real-life library where I wanted to make it easier for my 1.3 users to migrate to 2.0, I probably would.)This only requires a few other changes. In  and , you iterate over  rather than ; in , you change  to . Speaking of : You might want to consider renaming those local variables from , , , and  to , , , and .A few other comments:As kreativitea says in the comments, you should not create "private" variables and then add do-nothing accessor methods in Python. It's just more boilerplate that hides the real code, and one more thing you can get wrong with a silly typo that you'll spend hours debugging one day. Just have members named , , , etc., and access them directly. (If someone told you that this is bad style because it doesn't let you replace the implementation in the future without changing the interface, that's only true in Java and C++, not in Python. If you ever need to replace the implementation, just read up on .)You don't need —and it's very easy to accidentally miscount the number of  characters. (Especially since some IDEs will actually be confused by this and think the multi-line string never ends.) Just do .You've got the same ending condition both in the  loop () and in an internal . You don't need it in both places. Either change it to , or get rid of the  (just make  do , so you don't need to special-case it at all inside the loop).Whenever you have a long chain of  statements, think about whether you can turn it into a  of short functions. I'm not sure it's a good idea in this case, but it's always worth thinking about and making the explicit decision. The last idea would look something like this:As I said, I'm not sure it's actually clearer in this case, but it's worth considering.


Answer URL
