Natural Text
For simplification purposes lets assume the shell script is the  command. In the shell it would be normally called like this:Now the file will be created dynamically and writing it to disk would be a major performance hit, present security issues and increase the file management overhead in a multiuser environment. The script cannot be modified nor can read from stdin ( was just a working sample).I tried this:Even if I close   still returns nothing showing that the command is still waiting more input from the pipe. How can I tell the command there's no more data coming from the pipe?Is there any other approach to solve this?EditIn bash, if the file content is generated by a program named  this would be solved in this manner:Edit 2If you don't need the shell then the other option mentioned by Alfe is better, though the problem still exists (i.e. the process is not finishing after reading the file contents)
This is what I did at the end but is not nice. Because I'm working on CentOS and the problem I'm having (I've asked about it here: Python Popen can't open bash shell in CentOS/Red Hat) I can't use  that's why the solution looks a little different than the question.What I'm passing in some configuration to the process using bash process substitution and here-documents:I'm now considering using tmpfs for creating named pipes on it. I think that starting the script on it first and then writing to the pipe should work... If I'm successfull I'll write it here too.
Fiddled around a little bit, seems that closing the pipe on the one side does not generate an eof on the associated pseudo file /proc/self/fd/<#> of the child process.  Did you try it with /dev/stdin and simple piping your input to the subprocess's stdin?
Try using a named pipe for this.  On it, EOFs are properly propagated:You can create named pipes on the fly from Python as well, of course, just use .


Answer URL
