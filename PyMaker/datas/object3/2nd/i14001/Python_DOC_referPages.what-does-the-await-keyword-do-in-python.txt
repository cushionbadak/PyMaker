Natural Text
PEP 0492 adds the  keyword to Python 3.5. How does Python benefit from the use of this operator? The example that is given for a coroutine is According to the docs this achieves suspend[ing] execution of read_data coroutine until db.fetch awaitable completes and returns the result data.Does this  keyword actually involve creation of new threads or perhaps the use of an existing reserved async thread? In the event that  does use a reserved thread, is it a single shared thread each in their own?
No, co-routines do not involve any kind of threads. Co-routines allow for cooperative multi-tasking in that each co-routine yields control voluntarily. Threads on the other hand switch between units at arbitrary points.Up to Python 3.4, it was possible to write co-routines using generators; by using  or  expressions in a function body you create a generator object instead, where code is only executed when you iterate over the generator. Together with additional event loop libraries (such as ) you could write co-routines that would signal to an event loop that they were going to be busy (waiting for I/O perhaps) and that another co-routine could be run in the meantime:Every time the above code advances to the  line, the event loop is free to run a different co-routine, because this routine is not going to do anything for the next second anyway.Because generators can be used for all sorts of tasks, not just co-routines, and because writing a co-routine using generator syntax can be confusing to new-comers, the PEP introduces new syntax that makes it clearer that you are writing a co-routine.With the PEP implemented, the above sample could be written instead as:The resulting  object still needs an event loop to drive the co-routines; an event loop would  on each co-routine in turn, which would execute those co-routines that are not currently ing for something to complete.The advantages are that with native support, you can also introduce additional syntax to support asynchronous context managers and iterators. Entering and exiting a context manager, or looping over an iterator then can become more points in your co-routine that signal that other code can run instead because something is waiting again.


Answer URL
https://docs.python.org/3/library/asyncio.html
