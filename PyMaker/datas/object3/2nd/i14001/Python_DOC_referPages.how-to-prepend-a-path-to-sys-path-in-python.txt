Natural Text
Problem description:Using pip, I upgraded to the latest version of requests (version 2.7.0, with  giving the location ). When I  and print  in the interactive command line, though, I am seeing version 2.2.1. It turns out that Python is using the pre-installed Ubuntu version of requests ( is  -- not ).From my investigation, this fact is caused by Ubuntu's changes to the Python search path (I run Ubuntu 14.04) by prepending the path to Ubuntu's Python package (for my machine, this happens in ). In my case, this causes the  version of requests, which is pre-packaged with Ubuntu, to be used, rather than the pip version I want to use.What I'm looking for:I want to globally prepend pip's installation directory path to Python's search path (), before the path to Ubuntu's Python installation directory. Since requests (and many other packages) are used in many Python scripts of mine, I don't want to manually change the search path for every single file on my machine.Unsatisfactory Solution 1: Using virtualenvUsing virtualenv would cause an unnecessary amount of change to my machine, since I would have to reinstall every package that exists globally. I only want to upgrade from Ubuntu's packages to pip's packages.Unsatisfactory Solution 2: Changing easy-install.pthSince  is overwritten every time  is used, my changes to  would be removed if a new package is installed. This problem makes it difficult to maintain the packages on my machine.Unsatisfactory (but best one I have so far) Solution 3: Adding a separate .pth fileIn the same directory as easy-install.pth I added a  with contents:This file is read by  when Python is starting. Since its file name comes after  alphanumerically, it is consumed by  afterwards. Taken together, the first and last lines of the file prepend the path to  (these lines were taken from ).I don't like how this solution depends on the alphanumeric ordering of the file name to correctly place the new path.PYTHONPATHs come after Ubuntu's pathsAnother answer on Stack Overflow didn't work for me. My  paths come after the paths in , which uses the same code I mention in "Unsatisfactory solution 3" to prepend its paths.Thank you in advance!
This is not recommended*, but from your python scriptyou can do After this your imports will look into the prepended path before looking anywhere else.-- For the hardcoding of path and inability of script to run anywhere else.
You shouldn't need to mess with pip's path, python actually handles it's pathing automatically in my experience. It appears you have two pythons installed.  If you type:what paths do you see?  If they're not in the same /bin folder, then that's your problem.  I'm guessing that the python you're running (probably the original system one), doesn't have it's own pip installed.  You probably just need make sure the path for the python you want to run should come before /usr/bin in your .bashrc or .zshrcIf this is correct, then you should see that:shares the same path as the python installation you're using, maybe under /usr/local/bin.  Then just run:And start installing the right packages for the python that you're using.
Using virtualenv would cause an unnecessary amount of change to my machine, since I would have to reinstall every package that exists globally. I only want to upgrade from Ubuntu's packages to pip's packages.Nope, you can use .EditAs you see, the path of this virtualenv include the system path.To check if it was working, i installed a package system-wide after making the virtualenv.Obviously, what is installed inside the virtualenv takes precedence over the system-wide libraries.I belive that answer your needs.
Answer to direct questionYou could create a directory called  in your  directory.  We'll turn this into a  module as described here (Python 2 here).  Specifically:an attempt is made to import a module named sitecustomize, which can perform arbitrary site-specific customizations. It is typically created by a system administrator in your site-packages directory. In the  directory create a file called  and add the manipulations you want to perform there.  A very simple example is:In your case, I think  would be .  You might want to do something more sophisticated, but this crudely prepends to  and is run whenever python is started (e.g. starting the interpreter in the command line, or running a python script from a file).CaveatI'm not a huge advocate of doing this - it's a bit of a blunt way to do what you want.  But you specifically say that using a  is undesirable for you and you want to make the change "globally" and I think this will do what you want.Thoughts on underlying issueI think @fivetentaylor's answer is on the right track here - it appears you are using  from one install with  executable for another.  Masking this by messing with the path could get very confusing very quickly.  I'd definitely ensure you have a separate  for each install of  and you use that.  That should keep the directory structures for the separate installs separate.  Otherwise, you are forcing one install to use packages from a different installation's directories.  No problem technically, but confusing logistically.
Well, the alternatives presented by the others are very acceptable and might even be better. However, if you are intent on using the  way, then just treat it like a list and use the insert method. 
I would do this with  as described in the  docs. This file is imported after the initial  is configured and you can use it to alter  in arbitrary ways as needed.I've used it as a sysadmin to include custom release locations and it does the job quite nicely.https://docs.python.org/2/library/site.html
While bufh's answer will solve your problem now, you'll likely find that there'll be some other package where you don't want to use the Ubuntu-provided version. So here's why you want to use virtualenvs to manage the versions of packages (and not try to override the system versions).As you've noticed, the order of sys.path sets the order that python packages are found. This means that changing sys.path affects how python scripts find their imports, both scripts you've written, and those provided by Ubuntu. Given that python scripts are used in Ubuntu programs, it's possible to "break" Ubuntu in interesting ways by changing which version of python packages Ubuntu programs use (which is the reason dist-packages exists).To avoid this, virtualenv was created, which effectively allows there to be different sets of packages to be used. There's now a bunch of utilities which make using and managing virtualenvs easier. The one that's probably of most interest for you is pipsi, which creates a virtualenv per script, and avoids the need to activate it.
From the sounds of things, Ubuntu is using a package path configuration  file as documented here to set up any packages it installs.Looking at site.py I see that there is a specific order of path resolution that invokes the configuration files as it resolves the site packages directories.I think that gives you three options that I can see:Use virtualenv --system-site-packages as per @bufh's answer.Use pip user installs to set up the packages you need in the path before the standard site packages.Use sitecustomize to re-write your sys.path (e.g. to put your local directories first).


Answer URL
https://docs.python.org/3/library/site.html
