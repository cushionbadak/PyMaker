Natural Text
When using the argparse module in Python I am looking for a way to trap invalid options and report them better.The documentation at https://docs.python.org/3/library/argparse.html#invalid-arguments provides an example:However it is quite easy to trip this up as bad options are not reported first. For example:will report:When I would prefer it to report the more useful:Is it possible to achieve this?It seems to me a quite basic use case.When writing argument parsers directly I typically use a patternsuch that anything starting with a -- option prefix that is not a known option is rejected immediately. For example in bashI believe argparse uses regular expressions internally but I don't think they are accessible via add_argument()Is there any way to do the equivalent easily with argparse?
The short answer is that  uses .  This method lets you handle unknown arguments like .  As a result, argument type errors get raised before  errors.I've added a solution that involves subclassing  and modifying a method deep in its calling stack.I'll try to outline  as applied to your example.The first thing it does is categorize the strings as either  or .  Put simply, ones that begin with  are , others .  It also tries to match the  ones with a defined argument.In your example, it finds .  Regex is used to match this string against patterns defined by the argument .  (if needed I can explain this step in more detail) does not match; at some point (whether in this initial loop or later) it gets put into a  list.  (I'll check the code for details).For the 2nd loop through the strings it alternately tries to handle postionals and optionals.It's when trying to match the  with  that your Action class raises the type error, which propagates up to printing the usage and exiting.  Because  is not defined,  is not consumed as an optional's argument.  Thus it gets parsed as the first positional string.  (Some kinds of optionals take 0 arguments, so it does not assume anything following an  is an optionals argument).I think, that without the , the last string would match.   would return with  in the  term.   uses  but raises an error when  is not empty.So in a sense the parser does detect both errors, but it's the  one that triggers the error message.  It waits till the end to complain about unrecognized .As a general philosophy,  does not try to detect and present all errors.  It does not collect a list of errors to present in one final comprehensive message.I'll review the code to check the details.  I don't think you can easily change basic parsing pattern.  If I think of a way to force an earlier  error, I'll edit this answer. tries to classify an  string.  If the string looks like a  it returns .  If it matches an Action option_string, it returns a tuple '(action, option_string, None)` with the matching action.  Finally if not match, it returns:I think that is what happens with your .  Note the reason why it might still be a valid option.This function is called by collecting that  pattern, as well a list of these tuples.During a 2nd loop it alternates between consuming positionals and optionals.  The function that consumes an optional is:As I wrote earlier, your  gets put on the  list, while  remains on the list of arguments that can be parsed as positionals.The  and  are passed on through  to you, the user, or to .Conceivably you could subclass  and define a modified  method.  It could raise an error instead of returning that  tuple.producesSubclassing to provide custom action is good  (and Python) practice.If you want more consideration of this case by Python developers, consider writing a   (at PEP is for more developed formal ideas).  But there is quite a backlog of  bugs/patches, and a lot of caution about backwards compatibility.http://bugs.python.org/issue?%40columns=id%2Cactivity%2Ctitle%2Ccreator%2Cassignee%2Cstatus%2Ctype&%40sort=-activity&%40filter=status&%40action=searchid&ignore=file%3Acontent&%40search_text=_parse_optional&submit=search&status=-1%2C1%2C2%2C3is a list of bug/issues that reference .  Possible changes include how ambiguous optionals are handled.  (I'll scan them to see if I'm forgetting anything.  A some of the patches are mine.)  But by using , my suggested change is not affected by changes within the function.  It's affected only by changes in how the function is called and what it returns, which is much less likely to occur.  By filing your own issue, you at least put the developers on notice that someone depends on this interface.


Answer URL
https://docs.python.org/3/library/argparse.html#invalid-arguments
