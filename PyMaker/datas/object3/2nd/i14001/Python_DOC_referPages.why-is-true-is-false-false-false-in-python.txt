Natural Text
This question already has an answer here:Why does (1 in [1,0] == True) evaluate to False? [duplicate]                    1 answer                Why is it that these statements work as expected when brackets are used:But it returns  when there are no brackets?
Based on python documentation about operator precedence :Note that comparisons, membership tests, and identity tests, all have the same precedence and have a left-to-right chaining feature as described in the Comparisons section.So actually you have a chained statement like following :You can assume that the central object will be shared between 2 operations and other objects (False in this case).And note that its also true for all Comparisons, including membership tests and identity tests operations which are following operands :Example :
Python has a unique transitive property when it comes to the comparison operators. It will be easier to see in a simpler case.This does what it looks like. It checks if 1 < x and if x < 2. The same thing is happening in your non-parenthesized code.It is checking whether True is False and False == False, only one of which is true.
This is a double inequality which gets expanded as . See for instance What is the operator precedence when writing a double inequality in Python (explicitly in the code, and how can this be overridden for arrays?)
Python interprets multiple (in)equalities the way you would expect in Math:In Math  mean all ,  and .So  means  and  and , which is .For boolean constants,  is equivalent to .
Python performs chaining if it encounters operators of same precedence when evaluating an expression.comparisons, including tests, which all have the same precedence  chain from left to rightThe below mentioned operators have the same precedence.So, when Python tries to evaluate the expression , it encounters the operators  and   which have the same precedence, so it performs chaining from left to right.So, the expression  is actually evaluated as:giving  as the output.


Answer URL
https://docs.python.org/3/reference/expressions.html#operator-precedence
