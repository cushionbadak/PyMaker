Natural Text
I've defined a  class and an associated convenience function like so:I then define a simple convenience function:Most of this works perfectly, but I have two issues:It's not flexible enough; I'd like to be able to instantiate a  using  instead of  (so the fields are ), and vice versa, so the   is . I'm not clear on how to do this, though.I'd like to free the memory which is now owned by Python, by sending a  back to my dylib (see  â€“ I've already defined a function in my dylib), but I'm not sure at what point I should call it.Is there a way of encapsulating all this in a neater, more Pythonic way, which is also safer? I'm concerned that without the memory cleanup being defined in a robust way (on ? ?) That anything that goes wrong will lead to unfreed memory 
Since you have some control over the rust side, the cleanest thing to do would be to pre-allocate the result array from Python before the call, and pass everything in a single structure.The code below assumes this modification, but also designates the place where you would do the deallocation if you cannot do this.Note that if you do this sort of encapsulation, you do NOT need to specify things like the parameters and result processing for the library function, because you're only calling the actual function from a single place, and always with exactly the same kinds of parameters.I don't know rust (and even my C is a bit rusty), but the code below assumes you redefine your rust to match the equivalent of something like this:Here is the Python.  One final note -- this is not thread-safe, due to the reuse of the parameter structure.  That's easy enough to fix if needed.
Here is a modified version of the code that allocates the return array in the called DLL.  Since that would be harder to test with pure Python, and since I don't know rust, I built a cheesy C library for the actual test:Here is the Python code that calls it:And here is the result when I executed it:This happens to be a 32 bit Ubuntu 14.04 system. I used Python 2.7, and I built the library with 


Answer URL
https://docs.python.org/3/library/collections.html#collections.namedtuple
