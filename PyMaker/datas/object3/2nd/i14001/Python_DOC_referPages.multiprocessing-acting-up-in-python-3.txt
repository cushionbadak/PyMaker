Natural Text
I was messing around with a zip file cracker and decided to use the multiprocessing module to speed the process up. It was a complete pain since it was my first time using the module and I don't even fully understand it yet.  However, I got it to work.The problem is that it doesn't complete the word list; it just stops at random puts during the word list, and if the password is found it continues to go through the word list instead of just stopping the process.Does anyone know why it's exhibiting this behaviour?Source Code For ZipFile Cracker
Here's an implementation of the advice from @phihag's and @Equality 7-2521's answers:Note:each worker process has its own  object and the zip file is opened once per process: it should make it more portable (Windows support)  and improve time performancethe content is not extracted:  tries to open and immediately closes an archive member on success: it is safer and it should improve time performance (no need to create directories, etc)all errors except  while decrypting the archive member are assumed to happen after the password is accepted: the rational is to avoid silencing unexpected errors -- each exception should be considered individually expects nonempty passwords parameter may drastically improve performancea rare / syntax is used, to report cases when the password is not  foundthe -statement calls  for you
You are terminating your program too early. To test this out, add a harmless  in the  method and observe your program still terminating within a second.Call  to wait for the pool to finish:Additionally, once you find the right password, calling  just indicates that no more future tasks are coming - all tasks already submitted will still be done. Instead, call  to kill the pool without processing any more tasks.Furthermore, depending on the implementation details of , the global variable  may not be available when you need it (and its value isn't serializable anyways). To solve this problem, you can use a callback, as inOf course, since you now look at the result all the time,  is not the right way to go. Instead, you can write your code using :Instead of using globals, you may also want to open the zip file (and create a  object) in each process, by using an  for the pool. Even better (and way faster), forgo all of the I/O in the first place and read just the bytes you need once and then pass them on to the children.
phihag's answer is the correct solution.I just wanted to provide an additional detail regarding calling  when you've found the correct password.  The  variable in  was not defined when I ran the code.  So trying to invoke it from there simply threw an exception:(My  experience is weak, so I don't completely understand why the global  is copied to the child processes successfully while  is not. Even if it were copied, it would not be the same  in the parent process, right?  So any methods invoked on it would have no effect on the real pool in the parent process.  Regardless, I prefer this advice listed within the  module's Programming guidelines section: Explicitly pass resources to child processes.)My suggestion is to make  return the password if it is correct, otherwise return .  Then pass a callback to  that records the correct password, as well as terminating the pool.  Here's my take at modifying your code to do this:


Answer URL
https://docs.python.org/3/library/multiprocessing.html#all-start-methods
