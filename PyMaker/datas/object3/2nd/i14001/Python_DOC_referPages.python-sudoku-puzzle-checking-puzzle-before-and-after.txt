Natural Text
I have written a Sudoku solver for very easy Sudoku problems in Python. How it works is by checking each empty square, and if there is only one possible number that is legal, then replace the empty square with that number. Once it has gone through the whole puzzle, if there are still more than 1 empty squares, it calls itself again with the new puzzle. The part where I am having problems is I want the solver to check at the end of each call if the puzzle is the same as it was at the beginning of the call, and if it has not changed that means that all remaining empty squares have more than 1 possible value, and therefore the solver should return False to indicate that the solver isn't capable of solving that particular puzzle. However, when I tried to implement this, the Solver only goes through the puzzle once and returns False. Here is my code:The getPossible() function returns a list of possible values and the length of the list.Here is the main() function:
Your problem is that the line:Makes a reference to  called  not a copy so they are always the same - you need to either copy the  to  with  or more simply set a flag:and in the:Then check changed if it is False return it.
You are setting the reference of  to  , hence if you do any changes to  , it will reflect in  as well. and  would always be equal to .I do not think you need to set the puzzle to old puzzle (or you need to save the complete puzzle at the start).According to the logic, the number of  cells would never increase and a cell that is marked non-zero previously would never become marked  .Hence you can just store the count of s at the start, and then at the end check if the count of s has changed or not, if it has then good, otherwise return False.Example code -
The problem is that  will always be true because when  is created it doesn't become a copy of the puzzle list but rather a duplicate. This means that if you change  then  will also change.One way to make  a copy of  is to use the copy library. In this case it is required to make a deep copy of  because it is a list with list in it. One way to do this is to use the deep copy function from the copy library. So the function would look something like this:


Answer URL
https://docs.python.org/3/library/copy.html?highlight=copy#copy.deepcopy
