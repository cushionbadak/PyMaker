Natural Text
If I tell Python v. 3.4.3,  , then it outputs . If I tell it  then it outputs 2 as well, though. Similarly,  gives , while  gives  as well. I need Python to round with consistency, though. Specifically, it needs to round anytime I input a number halfway between two integers. So  and , while  and such, as usual.How can I resolve this?EDIT: I've already read the documentation for the  function and understand that this is its intended behavior. My question is, how can I alter this behavior, because for my purposes I need 1.5 round down.
The round docs do address the peculiaries of rounding floating point numbers.You can use the decimal library to achieve what you want.
Your want "round down", and you are getting "round to even". Just do it manually by doing
Python 3 uses a different rounding behaviour compared to Python 2: it now uses so-called "banker's rounding" (Wikipedia): when the integer part is odd, the number is rounded away from zero; when the integer part is even, is it rounded towards zero.The reason for this is to avoid a bias, when all values at .5 are rounded away from zero (and then e.g. summed).This is the behaviour you are seeing, and it is in fact consistent. It's perhaps just different than what you are used to.
This is documented pretty well. According to the Python docs for :Note The behavior of round() for floats can be surprising: for example, round(2.675, 2) gives 2.67 instead of the expected 2.68. This is not a bug: it’s a result of the fact that most decimal fractions can’t be represented exactly as a float. See Floating Point Arithmetic: Issues and Limitations for more informationIn specific, this is a side-effect of how computers handle floating-point numbers in general.If you need more precision, including different rounding, I suggest you check out the Python Decimal module. Specifically of interest, they have the ability to control rounding modes. Looks like you might want .
I believe I have the answer to all the rounding errors people have been encountering.  I have wrote my own method, which functions same as the "round" but actually looks at the last digit and rounds from there case by case.  There is no converting a decimal to binary.  It can handle any amount of numbers behind the decimal and it also takes scientific notation (as outputted by floats).  It also doesn't require any imports!  Let me know if you catch any cases that don't work!
Python 3 provides rounding methods defined in the IEEE Standard for Floating-Point Arithmetic (IEEE 754), the default rounding[1] is directed to the nearest number and minimizing cumulative errors.In IEEE 754, there are 5 methods defined, two for rounding to nearest (Python provides the first one by ) and three methods that are explicitly directed (Python has , , and  in its  module).You obviously need a directed rounding and there is a way to tell this Python, you have just to choose.[1] Since the representation of floating point numbers in computers is limited, rounding is not as trivial as you might think, you'll be surprised! I recommend a careful read of 15. Floating Point Arithmetic: Issues and Limitations in the python 3 documentation.


Answer URL
https://docs.python.org/3/library/functions.html#round
https://docs.python.org/3/tutorial/floatingpoint.html#tut-fp-issues
https://docs.python.org/3/library/decimal.html
https://docs.python.org/3/library/decimal.html#rounding-modes
https://docs.python.org/3/library/functions.html#round
https://docs.python.org/3/tutorial/floatingpoint.html#tut-fp-issues
https://docs.python.org/3/library/decimal.html
