Natural Text
If I do this:That returns . Simply because  is in the list.But if I do:That returns . Whereas  is equal to :Why?
Operator precedence 2.x, 3.x. The precedence of  is lower than that of . So it is equivalent to:This is what you want:As @Ben points out: It's recommended to never write , prefer . The former makes it look like a function call, while  is an operator, not a function.
 is evaluated as You can see exactly what's happening by disassembling the code.  The first case works as you expect:The second case, evaluates to , which is  clearly:What you wanted to express instead was , which as expected is , and you can see why:
Operator precedence.  binds more tightly than , so your expression is equivalent to .
It's all about operator precedence ( is stronger than ). But it can be easily corrected by adding parentheses at the right place:writing:is the same like:which looks if  is in the list and returns the "not" of the result.
It is evaluating as , which returns  because  is in  If you try You get the expected result.
Alongside the other answers that mentioned the precedence of  is lower than , actually your statement is equivalent to :But note that if you don't separate your condition from the other ones, python will use 2 roles ( or ) in order to separate that, and in this case python used precedence. Also, note that if you want to separate a condition you need to put all the condition in parenthesis not just the object or value :But as mentioned, there is another modification by python on operators that is chaining:Based on python documentation :Note that comparisons, membership tests, and identity tests, all have the same precedence and have a left-to-right chaining feature as described in the Comparisons section.For example the result of following statement is :Because python will chain the statements like following :Which exactly is  that is . You can assume that the central object will be shared between 2 operations and other objects (False in this case).And note that its also true for all Comparisons, including membership tests and identity tests operations which are following operands :Example :Another famous example is number range :which is equal to :
Let's see it as a collection containment checking operation:  is a list containing some elements.The expression  returns , as  is an element contained in the list.Therefore,  gives the "boolean opposite",  result of the above expression (without any parentheses to preserve precedence, as  has greater precedence than  operator).Therefore,  will result .On the other hand, , is equal to , which is  ( is contained in the list).
To clarify on some of the other answers, adding parentheses after a unary operator does not change its precedence.  does not make  bind more tightly to . It's just a redundant set of parentheses around . It's much the same as . The parentheses don't do anything.  If you want the binding to be more tight, you have to put the parentheses around the whole expression, meaning both the operator and the operand, i.e., .To see this another way, consider  binds more tightly than , which is why you get the negative of two squared, not the square of negative two (which would be positive four). What if you did want the square of negative two? Obviously, you'd add parentheses:However, it's not reasonable to expect the following to give because  is the same as . The parentheses do absolutely nothing.  is exactly the same. 


Answer URL
https://docs.python.org/3/reference/expressions.html#operator-precedence
https://docs.python.org/3/reference/expressions.html#operator-precedence
