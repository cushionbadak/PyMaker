Natural Text
I am in need of a Python (2.7) object that functions like a set (fast insertion, deletion, and membership checking) but has the ability to return a random value. Previous questions asked on stackoverflow have answers that are things like:But this is quite slow for large sets (it runs in O(n) time). Other solutions aren't random enough (they depend on the internal representation of python sets, which produces some results which are very non-random):I coded my own rudimentary class which has constant time lookup, deletion, and random values.Are there any better implementations for this, or any big improvements to be made to this code?
I think the best way to do this would be to use the  abstract base class in . Inherit from , and then define , ,  , and ; also rewrite  to optionally accept a sequence, just like the  constructor does.  provides built-in definitions of all other  methods based on those methods. That way you get the full  interface cheaply. (And if you do this,  is defined for you, under the name .)  in the standard  interface appears to be what you have called  here. So rename  to . Also, instead of having a separate  method, you could just define  like so:That way you don't have to maintain two separate item removal methods. Finally, in your item removal method ( now,  according to the standard set interface), you don't need an if statement. Instead of testing whether , simply swap the final item in the list with the item at the index of the list to be popped, and make the necessary change to the reverse-indexing dictionary. Then pop the last item from the list and remove it from the dictionary. This works whether  or not:
One approach you could take is to derive a new class from  which salts itself with random objects of a type derived from . You can then use  to select a random element, and if it is not of the salt type, reinsert and return it, but if it is of the salt type, insert a new, randomly-generated salt object (and pop to select a new object). This will tend to alter the order in which objects are selected. On average, the number of attempts will depend on the proportion of salting elements, i.e. amortised O(k) performance.
Can't we implement a new class inheriting from  with some (hackish) modifications that enable us to retrieve a random element from the list with O(1) lookup time? Btw, on Python 2.x you should inherit from , i.e. use . Also PEP8 is something to consider for you :-)Edit:For getting some ideas of what hackish solutions might be capable of, this thread is worth reading:http://python.6.n6.nabble.com/Get-item-from-set-td1530758.html
Yes, I'd implement an "ordered set" in much the same way you did - and use a list as an internal data structure.However, I'd inherit straight from "set" and just keep track of the added items in an internal list (as you did) - and leave the methods I don't use alone.Maybe add a "sync" method to update the internal list whenever the set is updatedby set-specific operations, like the *_update methods.That if using an "ordered dict" does not cover your use cases. (I just found that trying to cast ordered_dict keys to a regular set is not optmized, so if you need set operations on your data that is not an option)
If you don't mind only supporting comparable elements, then you could use .
Here's a solution from scratch, which adds and pops in constant time. I also included some extra set functions for demonstrative purposes.


Answer URL
https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes
