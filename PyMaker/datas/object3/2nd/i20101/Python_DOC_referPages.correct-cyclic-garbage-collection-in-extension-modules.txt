Natural Text
Two sections of Python 2.7's doc mentioned adding cyclic garbage collection (CGC) support for container objects defined in extension modules.The Python/C API Reference Manual gives two rules, i.e.,The memory for the object must be allocated using  or .Once all the fields which may contain references to other containers are initialized, it must call .Whereas in Extending and Embedding the Python Interpreter, for the  example, it seems that adding the  flag and filling  and  slots would be sufficient to enable CGC support. And the two rules above are NOT practiced at all.When I modified the  example to actually follow the rules of / and /, it surprisingly raised assertion error saying,Modules/gcmodule.c:348: visit_decref: Assertion "gc->gc.gc_refs != 0" failed. refcount was too smallThis leads to my confusion about the correct / safe way to implement CGC. Could anyone give advices or, preferably, a neat example of a container object with CGC support?
Under most normal circumstances you shouldn't need to do do the tracking/untracking yourself. This is described in the documentation, however it isn't made specifically clear. In the case of the  example you definitely don't.The short version is that a TypeObject contains two function pointers:  and . By default  calls all the right functions on creation of a class (if  is set) and  untracks the class on destruction.The Noddy documentation says (at the end of the section):That’s pretty much it. If we had written custom  or  slots, we’d need to modify them for cyclic-garbage collection. Most extensions will use the versions automatically provided.Unfortunately, the one place that doesn't make it clear that you don't need to do this yourself is the Supporting Cyclic Garbage Collection documentation.Detail:Noddy's are allocated using a function called  put in the  slots of the . According to the documentation, the main thing the "new" function should do is call the  slot. You typically don't write  yourself, and it just defaults to .Looking at  in the Python source shows a number of sections where it changes based on . First it calls  instead of , and second it calls . [Note that all that  really does is call  and then .]Similarly, on deallocation you call the  slot, which is automatically set to  for classes with .  includes code that does the same as  so a call to untrack is unnecessary.
I am not experienced enough in the C API myself to give you any advice, but there are plenty of examples in the Python container implementations themselves.Personally, I'd start with the tuple implementation first, since it's immutable: Objects/tupleobject.c. Then move on to the ,  and  implementations for further notes on mutable containers:Objects/dictobject.cObjects/listobject.cObjects/setobject.cI can't help but notice that there are calls to ,  and  throughout, as well as having  set.


Answer URL
https://docs.python.org/3/extending/newtypes.html
https://docs.python.org/3/extending/newtypes.html#supporting-cyclic-garbage-collection
https://docs.python.org/3/c-api/gcsupport.html
https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_new
https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_alloc
https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_free
