Natural Text
I'm experimenting with GPIO access from Python on an embedded system (ARM core), which is running linux built with Buildroot (kernel 4.1.15).  I want my code to BLOCK waiting for a pin change on GPIO2 (i.e. I don't want to poll the pin by calling "read" repeatedly). I'm trying to do this using "epoll" in edge-triggered mode: See Python docs for epoll. select.EPOLLET flag is used to get edge triggering for epoll. See also Linux docs for epoll.For simplicity, I've already set up my GPIO pin from the console, using sysfs:Here's my Python code:For testing, I am feeding the input pin with a square wave from a signal generator at about 2 seconds per cycle, so I can see when the pin changes.  When I run this on my embedded system, I get this: The code sleeps on the 1 seconds sleep, then on the next iteration, the poll() immediately returns and doesn't block. It should block since my input is only operating at one rising edge per 2 seconds. Why isn't "poll()" blocking?==== EDIT: ====Originally, the code caused a weird error when I tried to use "select.EPOLLET":However, I discovered that I had accidentally used myPoll = select.poll() instead of epoll(). Code now fixed. 
I decided to check the interrupt information by looking at /proc/interrupts.Here it is, only a couple of seconds after setting edge to "rising" for the GPIO pin:Hmm, 421 interrupts have occurred already!Two seconds later: That could explain it. Interrupts are piling up at ~400 per second, definitely faster than I am processing them in Python. Further investigation with a scope showed that the signal generator was only putting out about 1.6 V, and it looks like noise was triggering the input circuit on the device. When I switched to the correct signal generator output and got a clean signal on the GPIO pin, I started getting the expected number of interrupts, and the python code worked correctly (i.e. poll() blocked correctly between rising edges on the input).


Answer URL
https://docs.python.org/3/library/select.html#epoll-objects
