Natural Text
I have a little helper class:This lets me do sweet magic like:without having to use a list comprehension (as in ).(I maintain a UI that lets (trusted) users type in arbitrary code, and  is a lot more palatable than a list comprehension to the non-technically savvy user.)However!This only works one way! For example, if I were to do  then my  class's  method never gets called: instead, the NumPy array's  method gets called, which internally (I would presume) calls the  method of all its elements.This lead me to wonder: why does Python not allow a right-sided equivalent to ? (Roughly equivalent to methods like , , et cetera.)
An  is not a good idea in the language, because if class  defines  and class  defines , then Python is obliged to make a consistent decision about who gets called first in .  They can't both win.However, the Python datamodel does allow a way for you to do what you want here.  From both sides you can control this comparison, but you'll need to define  correctly.  If you want  to control the __eq__ from the right hand side, you must define it to be a subclass of . if I were to do  then my  class's  method never gets calledNo, you have a fundamental misunderstanding here.  The left hand side always gets first try at the equality comparison, unless the right hand side is a subclass of the type of the left hand side.  In the case above, your custom  is being called, because the numpy array calls it!  So  wins, and it decides to check once per element.  It literally could do anything else, including not calling your  at all.  In the case above, your class does get the first try at the comparison, and it fails because of the way you used  (checking if an array is in a tuple).  
The documentation about the  methods like  states:These functions are only called if the left operand does not support the  corresponding operation and the operands are of different types.While classes don't have  or  methods per default, they do have :This means  would never be called unless you explicitly remove  from the other class. You can solve your specific problem with :
This is the documentation on the data model:There are no swapped-argument versions of these methods (to be used when the left argument does not support the operation but the  right argument does); rather,  and  are each other’s  reflection,  and  are each other’s reflection, and   and  are their own reflection. If the operands are of different types, and right operand’s type is a direct or indirect  subclass of the left operand’s type, the reflected method of the right  operand has priority, otherwise the left operand’s method has  priority. Virtual subclassing is not considered.As stated in the comments above, what you want works, and  is essentially the sames as a potential : it is called on the right hand side of  if the object on the left hand side returns :As it comes, it even work with other, ordinary, objects: However, some objects may yield a TypeError on  instead of returning  or , and that makes this not reliable for all kinds of objects.What happens in your case, is an incorrect use of the operator   with arrays and tuples inside your own  method. (Thanks @wim to have spotted this in another answer here).


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__eq__
