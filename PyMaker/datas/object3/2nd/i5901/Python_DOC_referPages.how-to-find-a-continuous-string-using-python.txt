Natural Text
Given a string (e.g.,  jaghiuuabc
There's a nice example in the Python 2.6  docs that shows how to find consecutive sequences. To quote:Find runs of consecutive numbers using .  The key to the  solution is differencing with a range so that consecutive numbers all  appear in same group.For some strange reason, that example is not in the later versions of the docs. That code works for sequences of numbers, the code below shows how to adapt it to work on letters.outputHow it worksThe heart of this code is  generates tuples containing the index number and character for each character in . For example:output takes items from a sequence or iterator and gathers adjacent equal items together into groups. By default, it simply compares the values of the items to see if they're equal. But you can also give it a key function. When you do that, it passes each item to the key function and uses the result returned by that key function for its equality test.Here's a simple example. First, we define a function  that divides a number by 10, using integer division. This basically gets rid of the last digit in the number.outputSo if we use  as the key function to  it will ignore the last digit in each number and thus it will group adjacent numbers together if they only differ in the last digit.outputMy  receives a (index_number, character) tuple and subtracts that index_number from the character's code number and returns the result. Let's see what that does with my earlier example of :outputThe code number for 'A' is 65, the code number for 'B' is 66, the code number for 'C' is 67, etc. So when we subtract the index from the code number for each of 'A', 'B', and 'C' we get 65. But we skipped over 'D' so when we do the subtractions for 'E' and 'F' we get 66. And that's how  can put 'A', 'B', & 'C' in one group and 'E' & 'F' in the next group.This can be tricky stuff. Don't expect to understand it all completely straight away. But if you do some experiments yourself I'm sure it will gradually sink in. ;)Just for fun, here's the unreadable multiply-nested list comprehension version of that code. ;)Here's another version which was inspired by Amit Tripathi's answer. This one doesn't use any imports because it does the grouping manually.  contains the codepoint number of the previous character. We initialize  to -2 so that the first time the  test is performed it's guaranteed to be true because the smallest possible value of  is zero, so a new empty list will be added to .output
This can be done easily with pure PythonPython 3(should work with Python 2 also) implementation. A simple 8 liner converts char to equivalent ASCII number converts a number to equivalent ASCII char set default value as list if a key doesn't exists
What about some recursion without any external module ?output:


Answer URL
https://docs.python.org/3/library/functions.html#enumerate
https://docs.python.org/3/library/itertools.html#itertools.groupby
https://docs.python.org/3/library/itertools.html#itertools.groupby
https://docs.python.org/3/library/functions.html#enumerate
