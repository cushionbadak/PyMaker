Natural Text
In the mathematical sense, a set (or type) is closed under an operation if the operation always returns a member of the set itself.This question is about making a class that is closed under all operations inherited from its superclasses.Consider the following class.Since  has not been overridden, it is not closed under addition.One very tedious way to make the type closed would be to manually cast back the result of every operation that returns an  to .Here, I automated that process using a metaclass, but this seems like an overly complex solution.This fails on some cornercases such as  and methods recovered through . It also fails when the base is not composed only of base types.For example, this fails:I attempted to fix this, but it just seems to go deeper and deeper in the rabbit hole.This seems like a problem that might have some simple pythonic solution. What would be a other, neater ways to achieve such a closed type?
I think that the idea of using a metaclass is the way to go. The trick is to cast the values dynamically when you get them instead of up front. That's basically what python is all about: not knowing quite what you'll get or what's there until you actually get it.To do that, you have to redefine  and  on your class with some caveats:Operators don't go through the normal attribute access methods. Even defining the right  and  on your metaclass won't help. Dunders have to be overridden explicitly for each class.Methods returned by  and  need to have their return values cast to the target type. Same applies to dunders called as operators.Some methods should be excepted from #2 to ensure proper operation of the machinery.The same basic casting wrapper can be used for all the attribute and method return values. It just needs to recurse exactly oncewhen it's called on the result of  or .The solution shown below does exactly that. It explicitly wraps all dunders that aren't listed as exceptions. All other attributes are either cast immediately or wrapped if they are functions. It allows any method to be customized by checking everything in the , including the class itself. The solution will work correctly with class and static methods because it stores the casting routine and doesn't rely on  (as some of my previous attempts did). It will correctly exclude any attributes listed in , not just dunder methods.The result isThe last example is a tribute to @wim's answer. It shows that you have to want to do this for it to work.IDEOne link because I don't have access to a computer right now: https://ideone.com/iTBFW3Appendix 1: Improved default exceptionsI think that a better default set of exceptions than all dunder methods can be complied by looking carefully through the special method names section of the documentation. Methods can be categorized into two broad classes: methods with very specific return types that make the python machinery work, and methods whose output should be checked and wrapped when they return an instance of your type of interest. There is a third category, which is methods that should always be excepted, even when you forget to mention them explicitly.Here is a list of the methods that are always excepted:Here is a list of everything that should be excepted by default: (not a method, but still)If we stash this list into a variable called , the class  can be removed entirely, and the conditional that extracts  can be replaced by:Appendix 2: Improved targettingIt should be possible to target multiple types pretty easily. This is especially useful when extending other instances of , which may not override all the methods we want.The first step in doing this is making  into a container of classes instead of a single class reference. Instead ofdoNow replace every occurrence of  (or  in the wrappers) with  (or ).
I think using a class decorator with a black list of methods that should not return objects of the same type would be somewhat more Pythonic:so that:would output:and that as a bonus the decorator can be selectively used on individual methods as well:This outputs:
This cannot be done, the data model forbids it. And I can prove it to you:Addition is handled by the left hand object first, and if the left type handles it (i.e. does not return  singleton) then nothing about  is considered in this operation.  If the right hand type is a subclass of the left-hand type, you could control the result with the reflected method  - but of course that is impossible in the general case.
Everyone is writing short codes and meta classes while I barely write a decorator. (damn, lol) But I'm gonna share it anyways.Now after you have this long setup, you just decorate the class as you would normally do;  I am too sleepy to make it work with inherited classes so for now you have to decorate the class that inherits from a closed class.Feel free to downvote as I'm still not sure if I understood the question correctly. 
I still feel there might be a more natural way to accomplish this, but I was able to fix the attempt provided in the question.Here are the main points that needed ot be fixed.We must check methods of all classes in the mro, not only the bases; and  must be treated as special cases;Attributes with  must be treated separately;We have to write a list of exceptions as methods such as  or   obviously should return their expected types.CodeExampleOutputThis still has some issues. By example we still have the tedious task to go through all dunder methods an mark down exceptions to the implemented rules, but unless there is a list of those somewhere, this seems unavoidable.


Answer URL
https://docs.python.org/3/reference/datamodel.html#special-method-names
