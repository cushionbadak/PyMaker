Natural Text
I made a function which will look up ages in a  and show the matching name:I know how to compare and find the age I just don't know how to show the name of the person. Additionally, I am getting a  because of line 5. I know it's not correct but I can't figure out how to make it search backwards.
There is none.  is not intended to be used this way.
Or in Python 3.x:Basically, it separates the dictionary's values in a list, finds the position of the value you have, and gets the key at that position.More about  and  in Python 3: Python: simplest way to get list of values from dict?
If you want both the name and the age, you should be using  which gives you key  tuples:You can unpack the tuple into two separate variables right in the  loop, then match the age.You should also consider reversing the dictionary if you're generally going to be looking up by age, and no two people have the same age:so you can look up the name for an age by just doingI've been calling it  instead of  because  is the name of a built-in type, and you shouldn't use that name for anything else.You can even get a list of all people with a given age in one line:or if there is only one person with each age:which will just give you  if there isn't anyone with that age.Finally, if the  is long and you're on Python 2, you should consider using  instead of  as Cat Plus Plus did in his answer, since it doesn't need to make a copy of the list.
I thought it would be interesting to point out which methods are the quickest, and in what scenario:Here's some tests I ran (on a 2012 MacBook Pro)Results from  on each method 100000 times:Method 1:Method 2:Method 3:So this shows that for a small dict, method 1 is the quickest. This is most likely because it returns the first match, as opposed to all of the matches like method 2 (see note below).Interestingly, performing the same tests on a dict I have with 2700 entries, I get quite different results (this time run 10000 times):Method 1:Method 2:Method 3:So here, method 3 is much faster. Just goes to show the size of your dict will affect which method you choose.Notes:Method 2 returns a list of all names, whereas methods 1 and 3 return only the first match.I have not considered memory usage. I'm not sure if method 3 creates 2 extra lists (keys() and values()) and stores them in memory.
one line version: (i is an old dictionary, p is a reversed dictionary)explanation : i.keys() and i.values() returns two lists with keys and values of the dictionary respectively. The zip function has the ability to tie together lists to produce a dictionary.warning : This would work only if the values are hashable and unique.
or better

Here is my take on this problem. :)I have just started learning Python, so I call this:"The Understandable for beginners" solution...
You can get key by using ,  and  methods, see code samples below:
If you want to find the key by the value, you can use a dictionary comprehension to create a lookup dictionary and then use that to find the key from the value.
Consider using Pandas. As stated in William McKinney's "Python for Data Analysis'Another way to think about a Series is as a fixed-length, ordered  dict, as it is a mapping of index values to data values. It can be  used in many contexts where you might use a dict.To query your series do the following:Which yields:If you need to do anything else with the output transforming the answer into a list might be useful:
Here, recover_key takes dictionary and value to find in dictionary. We then loop over the keys in dictionary and make a comparison with that of value and return that particular key.
I found this answer very effective but still no very easy to read for me.To make it more clear you can invert the key and the value of a dictionary. This is make the keys values and the values keys, as seen here.orwhich is essentially the same that this other answer.
Try this one-liner to reverse a dictionary:

it's answered, but it could be done with a fancy 'map/reduce' use, e.g.:


here is my take on it. This is good for displaying multiple results just in case you need one. So I added the list as well And that's it... 
There is no easy way to find a key in a list by 'looking up' the value. However, if you know the value, iterating through the keys, you can look up values in the dictionary by the element. If D[element] where D is a dictionary object, is equal to the key you're trying to look up, you can execute some code.
I know this is old but you could quite easily find all the people in the list with your search age using list comprehension.
I hope this might help...
Cat Plus Plus mentioned that this isn't how a dictionary is intended to be used. Here's why:The definition of a dictionary is analogous to that of a mapping in mathematics. In this case, a dict is a mapping of K (the set of keys) to V (the values) - but not vice versa. If you dereference a dict, you expect to get exactly one value returned. But, it is perfectly legal for different keys to map onto the same value, e.g.:When you look up a key by it's corresponding value, you're essentially inverting the dictionary. But a mapping isn't necessarily invertible! In this example, asking for the key corresponding to v1 could yield k1 or k3. Should you return both? Just the first one found? That's why indexof() is undefined for dictionaries.If you know your data, you could do this. But an API can't assume that an arbitrary dictionary is invertible, hence the lack of such an operation.
Sometimes int() may be needed:
You need to use a dictionary and reverse of that dictionary. It means you need another data structure. If you are in python 3, use  module but if you are using python 2.7 use  which is back ported for python 2.Example:
already been answered, but since several people mentioned reversing the dictionary, here's how you do it in one line (assuming 1:1 mapping) and some various perf data:python 2.6:2.7+:if you think it's not 1:1, you can still create a reasonable reverse mapping with a couple lines:how slow is this: slower than a simple search, but not nearly as slow as you'd think - on a 'straight' 100000 entry dictionary, a 'fast' search (i.e. looking for a value that should be early in the keys) was about 10x faster than reversing the entire dictionary, and a 'slow' search (towards the end) about 4-5x faster. So after at most about 10 lookups, it's paid for itself. the second version (with lists per item) takes about 2.5x as long as the simple version.Also had some interesting results with ifilter. Theoretically, ifilter should be faster, in that we can use itervalues() and possibly not have to create/go through the entire values list. In practice, the results were... odd...So, for small offsets, it was dramatically faster than any previous version (2.36 *u*S vs. a minimum of 1.48 *m*S for previous cases). However, for large offsets near the end of the list, it was dramatically slower (15.1ms vs. the same 1.48mS). The small savings at the low end is not worth the cost at the high end, imho. 
The output is as follows:
This is how you access the dictionary to do what you want:of course, your names are so off it looks like it would be printing an age, but it DOES print the name. Since you are accessing by name, it becomes more understandable if you write:Better yet: 
For multiple occurrences use:
Here is a solution which works both in Python 2 and Python 3:The part until  constructs the reverse dictionary (where values are keys and vice-versa).You could create a helper method which will cache this reversed dictionary like so:or even more generally a factory which would create a by-age name lookup method for one or more of you listsso you would be able to do:Note that I renamed  to  since the former is a predefined type.


Answer URL
https://docs.python.org/3/library/stdtypes.html#dict-views
