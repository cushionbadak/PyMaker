Natural Text
So I'm writing an interface framework that allow people to write a collection of commands. What I am trying to do here is that, for each subclass of , find all of its methods that has a description, then collect all those functions and generate a collective description out of them (plus something else, but its not relevant to this question)Here is MCVENow the problem with my current method is that it doesn't detect method overrides. Suppose I add this snippet into the definition of class Now the generated descriptions will be completely wrong. What I want is that when a method got overridden, it's collected description also got overridden. So the description should always point to the method that Python would normally resolve to if people do it with usual ways (e.g. )So the expected output would then change to I suppose I can make a special case out of word  and fix the first  method. But is there a more elegant and Pythonic way to achieve that? To be honest,  looks pretty horrible. 
When you iterate over , you are iterating over the resolution order, which would be  in your example.As a result, you are looking at the  properties of each of these classes subsequently. When you declare  inside class , you are not actually overriding it in the parent class , you are just overriding it in the child class .So, instead, you could do something like this:That way, you are only inspecting the actual child and not its parents. However,  cannot be a property in this case, because properties get evaluated upon declaration, which would make  keep inspecting itself infinitely long.
I think you can fix your first implementation of , which may be easier than messing with the MRO. The reason you are getting a  is that  will show up in the list of attribute names. When you do  on it, it recursively calls itself, since it's a property. You can easily avoid that by only looking up the name if it is not . You also have an issue that when you lookup a method by name on an instance, you'll get a bound method object, rather than a function. Perhaps you should be calling  on  instead of on ? That would look something like this:Another way to avoid the issue would be to get rid of the  decorator, and leave  as a normal method. That way looking it up won't cause any recursion, it will just get a bound method.
We're not quite sure exactly what behavior you would like to have happen, but the  module almost certainly has what you need. E.g.


Answer URL
https://docs.python.org/3/library/stdtypes.html#class.__mro__
https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers
