Natural Text
I'm trying to do the following expression with dict comprehension and a ternary operation in python:I tried this:and several permutations thereof, but I keep getting syntax errors. Is it possible to do what I want?UPDATEThis is the correct syntax, but not my dict only comes back with 1's:Can someone explain why this doesn't function the same way as the for loop? Thank you.
Don't. It seems like using dict comprehensions for this should be a good idea, but it's actually a horrible trap. Use :or if you don't want to do that, then stick with the loop.The problem with trying to use a dict comprehension is that a dict comprehension has no good way to maintain state or interleave the computation of the values of each key. Each value must be computed in a single expression. In contrast, the best way to solve your counting problem is to make a single pass over  and update each element's count as you go.The restrictions of a comprehension lead to horribly inefficient attempts likewhich makes a number of passes over  equal to the length of , or the slightly more efficient but still horribly suboptimalwhich only needs to make  passes, or for people a bit more familiar with the standard library,which at least isn't quadratic time, but is still O(nlogn) for a length-n .If we run a timing of these four snippets with input :We get the following output: finishes in half a millisecond, while the  snippets both take over a second. (The  version seems to have a lower runtime due to some sort of first-run effect slowing down the other version; swapping the order of the  and non- version usually reverses the relative timing of those versions. The deduplication of  doesn't help in this test, since the input has no duplicates.)For a longer input, relying on  would be even more prohibitively expensive. Relying on  could easily take days for an input that  would still finish in under a second.
Here, it was actually way simpler than I thought. Basically what you want is the amount of times something occurs in the list, which you can do by saying . You can easily do this without ternary operators like so: 
It seems like you're trying to get the appearances of all values in a list. (If it's not, please let me know.) Here's how I would approach that:An explanation:: the  method returns the number of appearances of  in : creates a  object, which when converted back to a list removes all duplicates, or in other words, gets all distinct values of a list: the distinct values in The dictionary return would have key-value pairs of -.


Answer URL
https://docs.python.org/3/library/collections.html#collections.Counter
https://docs.python.org/3/library/itertools.html#itertools.groupby
