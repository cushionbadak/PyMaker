Natural Text
I run codes in Jupyter console(Python's version is ),I've guessed  is a equivalent of  but it seems no. So I wonder:What have been done by the python interpreter when I call  or ?When the  will be invoked?Thanks.
Short version: There are two reasonable things  could resolve to: a bound method representing the method used for calling  itself, or an unbound method representing the method used for calling instances of . You're expecting the first result, but what you actually get is the second.Long version: is normally equivalent to . For example,  is equivalent to  (as long as you have  turned on): is a callable, and  would be equivalent to , except that attribute lookup runs into a complication.During the  attribute lookup, Python searches  and its superclasses (just ) for a  entry with key . Python also searches 's type and 's type's superclasses for such a  entry. (You can see the code responsible for invoking these searches in , the C function that handles attribute lookup for types.) Since  is its own type, both of these searches find .One of these searches takes priority. The way the choice is made, and the reason the choice even matters, is the descriptor protocol. If the first search wins, then the descriptor protocol is applied as normal for finding a class attribute (); if the second search wins, the descriptor protocol is applied as normal for finding an instance attribute (). The second search needs to win for  to behave like , but it would only win if  was a data descriptor, and it's not.The first search wins. The descriptor protocol is applied as normal for finding a class attribute, and the result of looking up  is an unbound method. It represents the general  method of instances of , rather than the  instance method of -as-an-instance-of-type. It would need to be called asto be equivalent to .After all that, you might be wondering how  works without running into all those complications. In terms of language semantics, Python only performs the second search when looking up 's  method to call it, so the first search can't win because it doesn't even happen. In terms of actual implementation, CPython doesn't actually look up the  method at all; it looks up 's type, goes to the C-level slot on 's type corresponding to , and calls the function it finds. For a  method implemented in Python, the C slot would contain a function that looks up and calls the Python method, but for a  implemented in C, the C slot contains the  implementation directly.
Because  is a class, you need its  method:Usually,  is equivalent to  followed by calling  on the returned object.Here's one possible implementation of this behavior of :See blhsing's answer for question 2.
To answer the second half of your question, since @iBug already answered the first half,  is a method of , so instead of , you should call it as a bound method:or:both of which returns:which is really  since  returns .
The reason, as @user2357112 said, is that  acts as both a built-in function (which also doubles as a metaclass but that's not important here) and a class., in accordance with Built-in Functions â€” Python 2.7.15 documentation, acts as a regular function that returns the type of an object or creates a new custom type object.It's implemented by  which is specified as ., on the other hand, is an implementation of the call for objects of the class  -- i.e. types -- which, as you know, creates an instance of that type. I.e. an unbound method:It's implemented by  which is returned on  attribute lookup, via  whose contents  is filled with during initialization.The reason for the difference in execution paths is that attribute lookup is not done in the first case:And when calling an object like a function,  takes priority.


Answer URL
https://docs.python.org/3/reference/datamodel.html#descriptors
