Natural Text
For example, if passed the following:How do I check to see if  is empty?
Using the implicit booleanness of the empty list is quite pythonic.
The pythonic way to do it is from the PEP 8 style guide (where Yes means “recommended” and No means “not recommended”):For sequences, (strings, lists, tuples), use the fact that empty sequences are false.  
I prefer it explicitly:This way it's 100% clear that  is a sequence (list) and we want to test its size. My problem with  is that it gives the false impression that  is a boolean variable.
Other people seem to be generalizing the question beyond just lists, so I thought I'd add a caveat for a different type of sequence that a lot of people might use, especially since this is the first google hit for "python test empty array".Other methods don't work for numpy arraysYou need to be careful with numpy arrays, because other methods that work fine for s or other standard containers fail for numpy arrays.  I explain why below, but in short, the preferred method is to use .The "pythonic" way doesn't work: Part 1The "pythonic" way fails with numpy arrays because numpy tries to cast the array to an array of s, and  tries to evaluate all of those s at once for some kind of aggregate truth value.  But this doesn't make any sense, so you get a :The "pythonic" way doesn't work: Part 2But at least the case above tells you that it failed.  If you happen to have a numpy array with exactly one element, the  statement will "work", in the sense that you don't get an error.  However, if that one element happens to be  (or , or , ...), the  statement will incorrectly result in :But clearly  exists and is not empty!  This result is not what you wanted.Using  can give unexpected resultsFor example,returns 1, even though the array has zero elements.The numpythonic wayAs explained in the scipy FAQ, the correct method in all cases where you know you have a numpy array is to use :If you're not sure whether it might be a , a numpy array, or something else, you could combine this approach with the answer @dubiousjim gives to make sure the right test is used for each type.  Not very "pythonic", but it turns out that numpy intentionally broke pythonicity in at least this sense.If you need to do more than just check if the input is empty, and you're using other numpy features like indexing or math operations, it's probably more efficient (and certainly more common) to force the input to be a numpy array.  There are a few nice functions for doing this quickly — most importantly .  This takes your input, does nothing if it's already an array, or wraps your input into an array if it's a list, tuple, etc., and optionally converts it to your chosen .  So it's very quick whenever it can be, and it ensures that you just get to assume the input is a numpy array.  We usually even just use the same name, as the conversion to an array won't make it back outside of the current scope:This will make the  check work in all cases I see on this page.
An empty list is itself considered false in true value testing (see python documentation):@Daren ThomasEDIT: Another point against testing  the empty list as False: What about  polymorphism? You shouldn't depend on  a list being a list. It should just  quack like a duck - how are you going  to get your duckCollection to quack  ''False'' when it has no elements?Your duckCollection should implement  or  so the if a: will work without problems.
Best way to check if a list is emptyFor example, if passed the following:How do I check to see if a is empty?Short Answer:Place the list in a boolean context (for example, with an  or  statement). It will test  if it is empty, and  otherwise. For example:Appeal to AuthorityPEP 8, the official Python style guide for Python code in Python's standard library, asserts:For sequences, (strings, lists, tuples), use the fact that empty sequences are false.We should expect that standard library code should be as performant and correct as possible. But why is that the case, and why do we need this guidance?ExplanationI frequently see code like this from experienced programmers new to Python:And users of lazy languages may be tempted to do this:These are correct in their respective other languages. And this is even semantically correct in Python. But we consider it un-Pythonic because Python supports these semantics directly in the list object's interface via boolean coercion.From the docs (and note specifically the inclusion of the empty list, ):By default, an object is considered true unless its class defines  either a  method that returns  or a  method  that returns zero, when called with the object. Here are most of the built-in objects considered false:constants defined to be false:  and .zero of any numeric type: , , , , empty sequences and collections: , , , , , And the datamodel documentation:Called to implement truth value testing and the built-in operation ; should return  or . When this method is not defined,   is called, if it is defined, and the object is considered true if its result is nonzero. If a class defines neither   nor , all its instances are considered true.and Called to implement the built-in function . Should return the length of the object, an integer >= 0. Also, an object that doesn’t define a  method and whose  method returns zero is considered to be false in a Boolean context.So instead of this:or this:Do this:Doing what's Pythonic usually pays off in performance:Does it pay off? (Note that less time to perform an equivalent operation is better:)For scale, here's the cost of calling the function and constructing and returning an empty list, which you might subtract from the costs of the emptiness checks used above:We see that either checking for length with the builtin function  compared to  or checking against an empty list is much less performant than using the builtin syntax of the language as documented.Why?For the  check:First Python has to check the globals to see if  is shadowed. Then it must call the function, load , and do the equality comparison in Python (instead of with C):And for the  it has to build an unnecessary list and then, again, do the comparison operation in Python's virtual machine (as opposed to C)The "Pythonic" way is a much simpler and faster check since the length of the list is cached in the object instance header:Evidence from the C source and documentationThis is an extension of  that adds the  field. This is only used for objects that have some notion of length. This type does not often appear in the Python/C API. It corresponds to the fields defined by the expansion of the  macro.From the c source in Include/listobject.h:I have enjoyed researching this and I spend a lot of time curating my answers. If you think I'm leaving something out, please let me know in a comment.
Patrick's (accepted) answer is right:  is the right way to do it. Harley Holcombe's answer is right that this is in the PEP 8 style guide. But what none of the answers explain is why it's a good idea to follow the idiom—even if you personally find it's not explicit enough or confusing to Ruby users or whatever.Python code, and the Python community, has very strong idioms. Following those idioms makes your code easier to read for anyone experienced in Python. And when you violate those idioms, that's a strong signal.It's true that  doesn't distinguish empty lists from , or numeric 0, or empty tuples, or empty user-created collection types, or empty user-created not-quite-collection types, or single-element NumPy array acting as scalars with falsey values, etc. And sometimes it's important to be explicit about that. And in that case, you know what you want to be explicit about, so you can test for exactly that. For example,  means "anything falsey except None", while  means "only empty sequences—and anything besides a sequence is an error here", and so on. Besides testing for exactly what you want to test, this also signals to the reader that this test is important.But when you don't have anything to be explicit about, anything other than  is misleading the reader. You're signaling something as important when it isn't. (You may also be making the code less flexible, or slower, or whatever, but that's all less important.) And if you habitually mislead the reader like this, then when you do need to make a distinction, it's going to pass unnoticed because you've been "crying wolf" all over your code.
I have seen the below as preferred:
Why check at all?No one seems to have addressed questioning your need to test the list in the first place.  Because you provided no additional context, I can imagine that you may not need to do this check in the first place, but are unfamiliar with list processing in Python.I would argue that the most pythonic way is to not check at all, but rather to just process the list.  That way it will do the right thing whether empty or full.This has the benefit of handling any contents of a, while not requiring a specific check for emptiness.  If a is empty, the dependent block will not execute and the interpreter will fall through to the next line.If you do actually need to check the array for emptiness, the other answers are sufficient.
 is an O(1) operation for Python lists, strings, dicts, and sets. Python internally keeps track of the number of elements in these containers.JavaScript has a similar notion of truthy/falsy.
I had written:which was voted -1. I'm not sure if that's because readers objected to the strategy or thought the answer wasn't helpful as presented. I'll pretend it was the latter, since---whatever counts as "pythonic"---this is the correct strategy. Unless you've already ruled out, or are prepared to handle cases where  is, for example, , you need a test more restrictive than just . You could use something like this:the first test is in response to @Mike's answer, above. The third line could also be replaced with:if you only want to accept instances of particular types (and their subtypes), or with:You can get away without the explicit type check, but only if the surrounding context already assures you that  is a value of the types you're prepared to handle, or if you're sure that types you're not prepared to handle are going to raise errors (e.g., a  if you call  on a value for which it's undefined) that you're prepared to handle. In general, the "pythonic" conventions seem to go this last way. Squeeze it like a duck and let it raise a DuckError if it doesn't know how to quack. You still have to think about what type assumptions you're making, though, and whether the cases you're not prepared to handle properly really are going to error out in the right places. The Numpy arrays are a good example where just blindly relying on  or the boolean typecast may not do precisely what you're expecting.
Python is very uniform about the treatment of emptiness. Given the following:You simply check list a with an "if" statement to see if it is empty.  From what I have read and been taught, this is the "Pythonic" way to see if a list or tuple is empty.
Some methods that I use:
From documentation on truth value testing:All values other than what is listed here are considered zero of any numeric type, for example, , , .any empty sequence, for example, , , .any empty mapping, for example, .instances of user-defined classes, if the class defines a  or  method, when that method returns the integer zero or bool value .As can be seen, empty list  is falsy, so doing what would be done to a boolean value sounds most efficient:
Here are a few ways you can check if a list is empty:1) The pretty simple pythonic way:In Python, empty containers such as lists,tuples,sets,dicts,variables etc are seen as . One could simply treat the list as a predicate (returning a Boolean value). And  a  value would indicate that it's non-empty.2) A much explicit way: using the  to find the length and check if it equals to :3) Or comparing it to an anonymous empty list:4) Another yet silly way to do is using  and :
I prefer the following:
It is sometimes good to test for  and for emptiness separately as those are two different states. The code above produces the following output:Although it's worth nothing that  is falsy. So if you don't want to separate test for -ness, you don't have to do that. produces expected
Method 1 (Preferred):Method 2 :Method 3: 
Another simple way could be
Many answers have been given, and a lot of them are pretty good. I just wanted to add that the checkwill also pass for  and other types of empty structures. If you truly want to check for an empty list, you can do this:
From python3 onwards you can useto check if the list is emptyEDIT : This works with python2.7 too.. I am not sure why there are so many complicated answers.It's pretty clear and straightforward
You can check if the length of the array is zero (or not.) If the length of the array is zero, then it is empty. try the following:
we could use a simple if else:
Being inspired by @dubiousjim's solution, I propose to use an additional general check of whether is it something iterableNote: a string is considered to be iterable. - add  if you want the empty string to be excludedTest:
You can even try using bool() like thisI love this way for checking list is empty or not. Very handy and useful.
Simple way is checking the length is equal zero.
a little more practical:
Check if:  returns: 
Simply use is_empty() or make function like:- It can be used for any data_structure like a list,tuples, dictionary and many more. By these, you can call it many times using just . 
If you want to check if list is empty;If you want to check weather all the values in list is empty.However this will be True for empty list.Now you can use:


Answer URL
https://docs.python.org/3/library/stdtypes.html#truth-value-testing
https://docs.python.org/3/reference/datamodel.html#object.__bool__
https://docs.python.org/3/reference/datamodel.html#object.__len__
https://docs.python.org/3/library/typing.html
https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertIsInstance
