Natural Text
Here is what I'm supposed to do:Write a function, , that accepts a file name and returns a dictionary where the keyis a letter and the value is a list of words from the file that begin with that letter. Make sure that the list containsonly unique values, is all lowercased, and contains no punctuation marks.And here is what I have right now.The code became longer and longer and I still didn't get what I wanted. I'm even not sure what I'm doing and if it's useful. I wonder if there is some functions of dictionary that I don't know. Really frustrated here.
This seems a little more Pythonic to me.Removing non-word characters (for non-English, you'll need something more clever) is probably enough for this exercise. Splitting on any combination of whitespace means you skip newlines, tabs, etc. By creating a set from the result, duplicates are automatically removed. Note that if you remove punctuation without adding a space, "don't" remains one word, but "something-else" becomes "somethingelse" and vice versa. So that might be a consideration.You could do  instead of the  block, but the result is the same; this method can result in the empty string being in your terms set, which would break the dict creation. lets you set a behavior on inserting a key, so there's no need to check for existence or pre-create keys.Yet another edit: I don't think it's totally clear from the phrasing whether the question requires all letters to be present as keys, but if it does, all it means is replacing the initialization of d as a defaultdict with .
You're making this more complicated than it needs to be, which is where the frustration comes from. The actual solution is much simpler than you think.A dictionary keeps track of its own keys. You don't need to initialized anything. If a word comes along for a letter not in the dictionary, you add a new key right then. Otherwise, you use the list that's already there.Another point is that the  module provides you with the tools to split on both  and . The price you pay is having to filter out some empty strings, but that's trivial.I'd recommend storing the intermediate results in s instead of lists to ensure uniqueness. You can always convert to lists as a final step.And use return values instead of printouts in your utility functions:Notice that I'm not using any special methods or attributes of a dictionary at all besides the most basic access.Appendix 1: Dictionary TransformationThe final loop replaces the sets with lists in-place: it doesn't create a new dictionary object. You could do the same thing with a very similar loop:In general, you shouldn't modify a dictionary when you iterate over it. However, if you're very careful to only touch the values and not the keys, you won't have any problems because the underlying structure of the hash table won't change.Creating dictionaries is cheap, so it might be faster to use a dictionary comprehension to make a new mapping instead:Appendix 2: Word SplittingThe word splitting algorithm shown above is extremely simple. It assumes that your file will contain only very well behaved printable ASCII characters. While this is probably true for your assignment, it irks me to write code that has known potential issues, because there will be so many unknown issues to occupy your time later. To that end, I'll present a couple of alternative ways of searching for words using regular expressions.The first alternative is to split on anything that isn't a word character. A word character (in a regular string) is matched by the  pattern, whichMatches Unicode word characters; this includes most characters that can be part of a word in any language, as well as numbers and the underscore. If the ASCII flag is used, only  is matched.The inverse of  is , so you can use it with :The second alternative is the complement of the first. Instead of splitting on a pattern, match a pattern and use  to list the words for you:I'm both cases, it's worth noting that you're better off pre-compiling your pattern of choice using  instead of recompiling the pattern every time. The most efficient way to set the pattern is either globally, or in a default argument to the function. That way it will only ever be evaluated once. A second best option is to do it before the  block, so you at least compile once per file instead of once per line. A global or in-function definition, would look likeAs a default argument:The latter approach gives you flexibility should you ever decide to modify the set of characters you include/split on.In either case, the loop would then be
You may be overthinking it a bit. Let's list the necessary steps (following the instructions):Create a dictionary with each letter of the alphabet as a key and an empty  as the value. The  is used to ensure uniqueness.Open the file, strip punctuation and lowercase the string and split it into a list of words.Iterate over the words in the word list and add each one to the corresponding  in the dictionary based on first letter.Transform all of the sets back into lists and return the dictionary.Here's the code:Sample output (using your question as input):Note that I've omitted error handling on both the file open and potential ; those would be important considerations if you were planning on turning this into a deployable function.


Answer URL
https://docs.python.org/3/library/string.html
https://docs.python.org/3/library/string.html#string.whitespace
https://docs.python.org/3/library/string.html#string.punctuation
https://docs.python.org/3/library/functions.html#func-set
https://docs.python.org/3/library/re.html#re.ASCII
https://docs.python.org/3/library/re.html#re.split
https://docs.python.org/3/library/re.html#re.finditer
https://docs.python.org/3/library/re.html#re.compile
