Natural Text
I understand that sets in Python are unordered, but I'm curious about the 'order' they're displayed in, as it seems to be consistent. They seem to be out-of-order in the same way every time:...and another example:I'm just curious why this would be. Any help?
You should watch this video (although it is CPython1 specific and about dictionaries -- but I assume it applies to sets as well).  Basically, python hashes the elements and takes the last N bits (where N is determined by the size of the set) and uses those bits as array indices to place the object in memory.  The objects are then yielded in the order they exist in memory.  Of course, the picture gets a little more complicated when you need to resolve collisions between hashes, but that's the gist of it.Also note that the order that they are printed out is determined by the order that you put them in (due to collisions).  So, if you reorder the list you pass to , you might get a different order out if there are key collisions.For example:Note the fact that the order is preserved in these sets is "coincidence" and has to do with collision resolution (which I don't know anything about).  The point is that the last 3 bits of ,  and  are the same.  Because they are the same, collision resolution takes over and puts the elements in "backup" memory locations instead of the first (best) choice and so whether  occupies a location or  is determined by which one arrived at the party first and took the "best seat".If we repeat the example with ,  and , you will get a consistent order no matter what order they have in the input list:since the last 3 bits of ,  and  are unique.1Note The implementation described here applies to CPython  and .  I think that the general description is valid for all modern versions of CPython up to 3.6. However, starting with CPython3.6, there is an additional implementation detail that actually preserves the insertion order for iteration for .  It appears that  still do not have this property.  The data structure is described by this blog post by the pypy folks (who started using this before the CPython folks).  The original idea (at least for the python ecosystem) is archived on the python-dev mailing list.
The reason of such behavior is than Python use hash tables for dictionary implementation: https://en.wikipedia.org/wiki/Hash_table#Open_addressingPosition of the key is defined by it's memory address. If you know Python reuse memory for some objects:You can see that object a has different address every time it's init.But for small integers it isn't change:Even if we create second object with different name it would be the same:This approach allow to save memory which Python interpreter consume.
AFAIK Python sets are implemented using a hash table. The order in which the items appear depends on the hash function used. Within the same run of the program, the hash function probably does not change, hence you get the same order. But there are no guarantees that it will always use the same function, and the order will change across runs - or within the same run if you insert a lot of elements and the hash table has to resize.
Sets are based on a hash table. The hash of a value should be consistent so the order will be also - unless two elements hash to the same code, in which case the order of insertion will change the output order.
One key thing that's hinted at mgilson's great answer, but isn't mentioned explicitly in any of the existing answers:Small integers hash to themselves:Strings hash to values that are unpredictable. In fact, from 3.3 on, by default, they're built off a seed that's randomized at startup. So, you'll get different results for each new Python interpreter session, but:So, consider the simplest possible hash table implementation: just an array of N elements, where inserting a value means putting it in  (assuming no collisions). And you can make a rough guess at how large  will beâ€”it's going to be a little bigger than the number of elements in it. When creating a set from a sequence of 6 elements, N could easily be, say, 8.What happens when you store those 5 numbers with N=8? Well, , , etc. are just the numbers themselves, but  is 0. So, the hash table's array ends up holding . So it should be easy to figure out why iterating the set might give you .Of course Python doesn't guarantee that you'll get this order every time. A small change to the way it guesses at the right value for  could mean  ends up somewhere different (or ends up colliding with one of the other values). And, in fact, running CPython 3.7 on my Mac, I get .0Meanwhile, when you build a hash from a sequence of size 11 and then insert randomized hashes into it, what happens? Even assuming the simplest implementation, and assuming there are no collisions, you still have no idea what order you're going to get. It will be consistent within a single run of the Python interpreter, but different the next time you start it up. (Unless you set  to , or to some other int value.) Which is exactly what you see.Of course it's worth looking at the way sets are actually implemented rather than guessing. But what you'd guess based on the assumption of the simplest hash table implementation is (barring collisions and barring expansion of the hash table) exactly what happens.


Answer URL
https://docs.python.org/3/using/cmdline.html#envvar-PYTHONHASHSEED
