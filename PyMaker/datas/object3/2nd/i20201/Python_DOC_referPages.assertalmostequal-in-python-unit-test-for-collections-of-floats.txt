Natural Text
The assertAlmostEqual(x, y) method in Python's unit testing framework tests whether  and  are approximately equal assuming they are floats.The problem with  is that it only works on floats. I'm looking for a method like  which works on lists of floats, sets of floats, dictionaries of floats, tuples of floats, lists of tuples of floats, sets of lists of floats, etc.For instance, let , .  and  are almost equal because they agree on each and every digit except for the last one. Therefore  is  because  works for floats.I'm looking for a more generic  which also evaluates the following calls to :...Is there such a method or do I have to implement it myself?Clarifications: has an optional parameter named  and the numbers are compared by computing the difference rounded to number of decimal . By default , hence  is False while  is True. My speculative  should have the same functionality.Two lists are considered almost equal if they have almost equal numbers in exactly the same order. formally, .Similarly, two sets are considered almost equal if they can be converted to almost equal lists (by assigning an order to each set).Similarly, two dictionaries are considered almost equal if the key set of each dictionary is almost equal to the key set of the other dictionary, and for each such almost equal key pair there's a corresponding almost equal value.In general: I consider two collections almost equal if they're equal except for some corresponding floats which are just almost equal to each other. In other words, I would like to really compare objects but with a low (customized) precision when comparing floats along the way.
if you don't mind using NumPy (which comes with your Python(x,y)), you may want to look at the  module which defines, among others, a  function.The signature is 
Here's how I've implemented a generic  function:First, duplicate the objects you need to compare ( and ), but don't make an exact copy: cut the insignificant decimal digits of any float you encounter inside the object.Now that you have copies of  and  for which the insignificant decimal digits are gone, just compare  and  using the  operator.Let's assume we have a  function which duplicates  but leaves only the  most significant decimal digits of each float in the original . Here's a working implementation of :And here's a working implementation of :The code and its unit tests are available here: https://github.com/snakile/approximate_comparator. I welcome any improvement and bug fix.
As of python 3.5 you may compare usingAs described in pep-0485.The implementation should be equivalent to 
There is no such method, you'd have to do it yourself.For lists and tuples the definition is obvious, but note that the other cases you mention aren't obvious, so it's no wonder such a function isn't provided.  For instance, is  almost equal to ?  Handling such cases requires making a choice about whether closeness depends on keys or values or both.  For sets you are unlikely to find a meaningful definition, since sets are unordered, so there is no notion of "corresponding" elements.
If you don't mind using the  package then  has the  method. This works for  objects, so it is fine for arrays, lists and tuples of floats, but does it not work for sets and dictionaries.The documentation is here.
You may have to implement it yourself, while its true that list and sets can be iterated the same way, dictionaries are a different story, you iterate their keys not values, and the third example seems a bit ambiguous to me, do you mean to compare each value within the set, or each value from each set.heres a simple code snippet.
An alternative approach is to convert your data into a comparable form by e.g turning each float into a string with fixed precision.Then you can:
None of these answers work for me. The following code should work for python collections, classes, dataclasses, and namedtuples. I might have forgotten something, but so far this works for me.


Answer URL
https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertAlmostEqual
