Natural Text
The correct way to load unicode text from Python 2.7 is something like:(Update: No it isn't. See the answers.)However, if the file is very large, I might want to read, decode and process it one line at a time, so that the whole file is never loaded into memory at once. Something like:The  loop's iteration over the open filehandle is a generator that reads one line at a time.This doesn't work though, because if the file is utf32 encoded, for example, then the bytes in the file (in hex) look something like:And the split into lines done by the  loop splits on the  byte of the  character, resulting in (in hex):So part of the  character is left at the end of line 1, and the remaining three bytes end up in line 2 (followed by whatever text is actually in line 2.) Calling  on either of these lines understandably results in a .So, obviously enough, splitting a unicode byte stream on  bytes is not the correct way to split it into lines. Instead I should be splitting on occurrences of the full four-byte newline character (0x0a000000). However, I think the correct way to detect these characters is to decode the byte stream into a unicode string and look for  characters - and this decoding of the full stream is exactly the operation I'm trying to avoid.This can't be an uncommon requirement. What's the correct way to handle it?
 itself notes that  is a better option (note is just above link target). It's not deprecated, but only because it supports some esoteric uses (bytes->bytes codecs). is available in Python 2.6 and higher, and provides the same behaviors as Py3's built-in , is better optimized, and doesn't misbehave like  when it comes to stuff like line-ending conversions. The only reason to use  is if you need to support Python 2.5 and earlier, otherwise,  is strictly better.Incidentally, you can convert any already open binary file-like object to a seamless decoding text based object using , so if someone else provides you an existing file-like object in binary mode, you can still do line by line decoding implicitly with:
How about trying somethng like:I think this should work.The  module should do the translation for you.
Try using the codecs module:
Use codecs.open instead of builtin open:http://docs.python.org/library/codecs.html#codecs.openOf course, I discovered this mere moments after finishing my carefully-crafted stackoverflow question.


Answer URL
https://docs.python.org/3/library/codecs.html#codecs.open
