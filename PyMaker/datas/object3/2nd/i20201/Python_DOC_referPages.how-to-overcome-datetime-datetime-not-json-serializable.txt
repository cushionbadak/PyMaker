Natural Text
I have a basic dict as follows:When I try to do  I get:What can I do such that my dictionary sample can overcome the error above?Note: Though it may not be relevant, the dictionaries are generated from the retrieval of records out of mongodb where when I print out , the output is .
Updated for 2018The original answer accommodated the way MongoDB "date" fields were represented as:If you want a generic Python solution for serializing  to json, check out @jjmontes' answer for a quick solution which requires no dependencies.As you are using mongoengine (per comments) and pymongo is a dependency, pymongo has built-in utilities to help with json serialization:http://api.mongodb.org/python/1.10.1/api/bson/json_util.htmlExample usage (serialization):Example usage (deserialization):DjangoDjango provides a native  serializer that deals with this kind of properly.See https://docs.djangoproject.com/en/dev/topics/serialization/#djangojsonencoderOne difference I've noticed between  and using a custom  like this:Is that Django strips a bit of the data:So, you may need to be careful about that in some cases.
Building on other answers, a simple solution based on a specific serializer that just converts  and  objects to strings.As seen, the code just checks to find out if object is of class  or , and then uses  to produce a serialized version of it, according to ISO 8601 format, YYYY-MM-DDTHH:MM:SS (which is easily decoded by JavaScript). If more complex serialized representations are sought, other code could be used instead of str() (see other answers to this question for examples). The code ends by raising an exception, to deal with the case it is called with a non-serializable type.This json_serial function can be used as follows:The details about how the default parameter to json.dumps works can be found in Section Basic Usage of the json module documentation. 
My quick & dirty JSON dump that eats dates and everything:
I have just encountered this problem and my solution is to subclass :In your call do something like:  The  I got from one of the answers above.
Convert the date to a string
For others who do not need or want to use the pymongo library for this.. you can achieve datetime JSON conversion easily with this small snippet:Then use it like so:output:Â 
Here is my solution:Then you can use it like that:
I have an application with a similar issue; my approach was to JSONize the datetime value as a 6-item list (year, month, day, hour, minutes, seconds); you could go to microseconds as a 7-item list, but I had no need to:produces:
This Q repeats time and time again - a simple way to patch the json module such that serialization would support datetime.  Than use json serialization as you always do - this time with datetime being serialized as isoformat.Resulting in: '{"created": "2015-08-26T14:21:31.853855"}'See more details and some words of caution at:StackOverflow: JSON datetime between Python and JavaScript
My solution (with less verbosity, I think):Then use  instead of . It will print:I you want, later you can add other special cases to this with a simple twist of the  method. Example:  
Here is a simple solution to over come "datetime not JSON serializable"problem. Output:-> {"date": "2015-12-16T04:48:20.024609"} 
You have to supply a custom encoder class with the  parameter of . To quote from the docs:This uses complex numbers as the example, but you can just as easily create a class to encode dates (except I think JSON is a little fuzzy about dates)
You should use  method on  method to making it as a serializable method.Here's an example:Output:
The simplest way to do this is to change the part of the dict that is in datetime format to isoformat. That value will effectively be a string in isoformat which json is ok with.
The json.dumps method can accept an optional parameter called default which is expected to be a function. Every time JSON tries to convert a value it does not know how to convert it will call the function we passed to it. The function will receive the object in question, and it is expected to return the JSON representation of the object.
if you are using python3.7, then the best solution is using and; they work with both naive andaware  objects:output:if you are using python3.6 or below, and you only care about the time value (notthe timezone), then you can use  and instead;if you are using python3.6 or below, and you do care about the timezone, thenyou can get it via , but you have to serialize this fieldby yourself; the easiest way to do this is to add another field  in theserialized object;finally, beware of precisions in all these examples;
If you are using the result in a view be sure to return a proper response. According to the API, jsonify does the following:Creates a Response with the JSON representation of the given arguments  with an application/json mimetype.To mimic this behavior with json.dumps you have to add a few extra lines of code.You should also return a dict to fully replicate jsonify's response. So, the entire file will look like this
Here is my full solution for converting datetime to JSON and back..OutputJSON FileThis has enabled me to import and export strings, ints, floats and datetime objects.It shouldn't be to hard to extend for other types.
Convert the   to  
Generally there are several ways to serialize datetimes, like:ISO string, short and can include timezone info, e.g. @jgbarah's answerTimestamp (timezone data is lost), e.g. @JayTaylor's answerDictionary of  properties (including timezone).If you're okay with the last way, the json_tricks package handles dates, times and datetimes including timezones.which gives:So all you need to do isand then import from  instead of .The advantage of not storing it as a single string, int or float comes when decoding: if you encounter just a string or especially int or float, you need to know something about the data to know if it's a datetime. As a dict, you can store metadata so it can be decoded automatically, which is what  does for you. It's also easily editable for humans.Disclaimer: it's made by me. Because I had the same problem.
Try this one with an example to parse it:
Actually it is quite simple.If you need to often serialize dates, then work with them as strings. You can easily convert them back as datetime objects if needed.If you need to work mostly as datetime objects, then convert them as strings before serializing. As you can see, the output is the same in both cases. Only the type is different.
My solution ...Ok, now some tests.
I got the same error message while writing the serialize decorator inside a Class  with sqlalchemy. So instead of :I  simply borrowed jgbarah's idea of using isoformat() and appended the original value with isoformat(), so that it now looks like:
A quick fix if you want your own formatting
If you are on both sides of the communication you can use repr() and eval() functions along with json.You shouldn't import datetime assince eval will complain. Or you can pass datetime as a parameter to eval. In any case this should work.
I had encountered same problem when externalizing django model object to dump as JSON.Here is how you can solve it.
Usage of above utility:
I may not 100% correct but,this is the simple way to do serialize


Answer URL
https://docs.python.org/3/library/datetime.html#datetime.datetime.isoformat
https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat
