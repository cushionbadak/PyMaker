Natural Text
I have some legacy code with a legacy function that takes a filename as an argument and processes the file contents.  A working facsimile of the code is below.What I want to do is not have to write to disk with some content that I generate in order to use this legacy function, so I though I could use  to create an object in place of the physical filename.  However, this does not work, as you can see below.I thought  was the way to go with this.  Can anyone tell me if there is a way to use this legacy function and pass it something in the argument that isn't a file on disk but can be treated as such by the legacy function?  The legacy function does have the  context manager doing work on the  parameter value.The one thing I came across in google was: http://bugs.python.org/issue1286, but that didn't help me...CodeOutputThis is the output in :This is the error:
A  instance is an open file already. The  command, on the other hand, only takes filenames, to return an open file. A  instance is not suitable as a filename.Also, you don't need to close a  instance, so there is no need to use it as a context manager either.If all your legacy code can take is a filename, then a  instance is not the way to go. Use the  module to generate a temporary filename instead.Here is an example using a contextmanager to ensure the temp file is cleaned up afterwards:You can also switch to the newer Python 3 infrastructure offered by the  module (available in Python 2 and 3), where  is the more robust replacement for  / . This object does support being used as a context manager (but still can't be passed to ).
you could define your own open functionhowever with wants to call __exit__ after its done and StringIO does not have an exit method... you could define a custom class to use with this open
This one is based on the python doc of contextmanagerIt's just wrapping StringIO with simple context, and when exit is called, it will return to the yield point, and properly close the StringIO. This avoids the need of making tempfile, but with large string, this will still eat up the memory, since StringIO buffer that string.It works well on most cases where you know the string data is not going to be longThen you can do:


Answer URL
https://docs.python.org/3/library/io.html#io.BytesIO
