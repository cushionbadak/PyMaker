Natural Text
I want to do the following: I want to define a recursive function  in which the last reference of itself return a number of the array . The problem is that  must do an integral of itself (see the code below) and this would be very easy if  could accept the colon  as an argument. So, I have this (simplified) code so far:The problem is that  can't accept the colon  as argument, it doesn't matter if I want to vectorize to  later in the code.For instance, If I change this part of the above code for I have no problems. I just want to do the last part recursively.
First, Python doesn't have "range operators" like some other languages. The  generates s, which are a completely different type from s. And, more importantly, the  syntax is part of the slicing (aka extended indexing or extended subscription) syntax, it doesn't stand on its own.So, the simple way to write your code is to use a  literal:Of course you could also avoid all this mess and just use an explicit slice literal:So, why isn't there a syntax for "slice literals" that's more convenient than calling the  constructor? Because nobody's come up with a compelling argument, worked out potential syntax ambiguities, and submitted a patch.** Note that Python did add a syntax for ellipsis literals on their own— is a literal for , the singleton value of type . A lot of people wanted that, there were no ambiguities except in code that was already illegal, someone wrote a patch, and it was accepted with little fuss.While the syntax for extended indexing and the syntax for function calls are somewhat similar, they're not identical. That means you can't use function calls as, e.g., a domain-specific language for wrapping up delayed slicing.One thing you can do is create a slice-wrapper type, to using slicing expressions themselves as such a domain-specific language:Now  is a constructor for , and  is a constructor for . So you can write things like this:Your  class will get a tuple of  objects and integers, which it can later use to index an array by calling its  directly.And you can wrap up more of that if you want. For example:Now,  can be called as either  or —or as  or . That just means that  will be  or . And you can use that in an indexing expression;  may not look as nice as , but it means the same thing.


Answer URL
https://docs.python.org/3/reference/expressions.html#slicings
