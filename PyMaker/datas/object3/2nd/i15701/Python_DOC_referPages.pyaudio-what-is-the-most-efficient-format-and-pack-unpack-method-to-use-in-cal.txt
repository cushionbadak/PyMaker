Natural Text
I am using pyaudio in callback mode with  format, 2 channels, 1024 frames per buffer, and I am interested in a more efficient input/output audio buffer data exchange.To unpack an input audio buffer and get the list of float samples, I use:Using  and  is quite inefficient and it takes significant CPU resources, almost the same as the audio signal processing itself. Since most sound cards are 16 bit, I also tried to use the  format, but the results are almost identical.What would be the most efficient format and pack/unpack method to use in callback mode (of course maintaining full resolution)?Edit: PyAudio exchanges data using binary streams or buffers similar to the C data structures used with Portaudio. I need to unpack the  input buffer to get the float samples and analyze them. Everyting is OK, except the unpack is a bit slow.
Using either NumPy or the stdlib's  module is going to be much faster, because most of the cost of  isn't the unpacking, it's the boxing up of each float value in a Python  object.For example:That's 100x as fast. And you've got an iterable of floats either way, it's just that it's an  instead of a .However, if you're planning to actually do any arithmetic on these values, you're still going to have to iterate those valuesâ€”and  will have to unbox each of them as you do so, which is going to add back in a good chunk of the time you've saved.That's where NumPy comes in; I doubt  is going to be hugely faster than  to create, but it will allow you to do vectorized arithmetic directly on the unboxed values. For example:As you can see, using the  makes this twice as slow (I used  because the actual iteration and arithmetic are done in C), but using  instead makes it 5x as fast.


Answer URL
https://docs.python.org/3/library/array.html
