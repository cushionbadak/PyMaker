Natural Text
For example I was trying to write turtle.(direction[x]). direction is an array of strings, and the strings are turtle commands. So if I iterated through the direction array it would change the turtle command each time I call drawPoint. 
I can see what you're trying to do here:You want to use the string in  as the name of a method. You probably shouldn't want to do that, but you can. Just not directly; you have to use the  function:At any rate, using  is usually not a good idea. A better idea is to store the methods in a list, rather than their names. Like one of these:*The first version creates a list of bound methods, which know what object they're attached to (), so you can just call . The second creates a list of unbound methods, which don't know what object they're attached to; you have to pass it in explicitly like an argument, . I think the latter makes more sense in this case, because of the next point, but both are perfectly valid.You've also got another problem here:  isn't your turtle object, it's a module. You need some object to work on, but you don't have one in . Fortunately, you're creating one named  in , so you just need to pass it in to .And finally, if you want to iterate, use a loop, not a recursive call to yourself. Otherwise, on the 1000th loop, you'll get an exception and your program will quit with an ugly stack trace.**So:One more nifty trick. If you want to loop forever over a list, instead of keeping track of an index and using  to reset back to 0, you can use the  function. In this case, we only want to cycle over the first two elements of , so we'll use a slice:* In Python, everything is a first-class valueâ€”modules, classes, objects, functions, bound and unbound methods, etc. That means you can stick it in a list, pass it to a function, whatever you want.** Every time you call another function, it pushes another frame on the stack. When you return, it pops a frame off the stack. But if your function calls another function before returning, and it calls another function before returning, and so on, you eventually end up overflowing the stack. To avoid the nasty crashes (and security holes) of lower-level languages, Python won't let you get that far, and will raise an exception when you get 1000 deep. (If you're used to another language like, say, Scheme, and this surprises you, that's because Scheme does tail call elimination, while Python doesn't; more generally, Scheme is designed to encourage as much recursion as possible, while Python is designed to discouraged it.)


Answer URL
https://docs.python.org/3/library/functions.html#getattr
https://docs.python.org/3/library/itertools.html#itertools.cycle
