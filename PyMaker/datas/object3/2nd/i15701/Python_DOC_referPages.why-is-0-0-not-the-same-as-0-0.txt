Natural Text
I could be missing something fundamental, but consider this interpreter session1:You would think that the Python interpreter would realize that  and  are the same number.  In fact, it compares them as being equal:So why is Python differentiating between the two and generating a whole new object for ?  It doesn't do this with integers:Now, I realize that floating point numbers are a huge source of problems with computers, but those problems are always with regard to their accuracy.  For example:But this isn't an accuracy problem, is it?  I mean, we are talking about the sign of the number here, not its decimal places.1I can reproduce this behavior in both Python 2.7 and Python 3.4, so this is not a version-specific question.
In IEEE754, the format of floating point numbers, the sign is a separate bit. So -0.0 and 0.0 are different by this bit.Integers use the two's complement, to represent negative numbers; that's why there is only one .Use  only of you really want to compare instances of objects. Otherwise, especially for numbers, use :
The IEEE Standard for Floating-Point Arithmetic (IEEE 754) defines the inclusion of signed zeroes. In theory they allow you to distinguish between negative number underflow and positive number underflow.As far as python specifically is concerned, use  rather than  to compare numbers.
Because the binary representation of those two numbers is different.  In 0.0 the 32nd bit is 0 and in -0.0 the 32nd bit is 1.


Answer URL
https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy
