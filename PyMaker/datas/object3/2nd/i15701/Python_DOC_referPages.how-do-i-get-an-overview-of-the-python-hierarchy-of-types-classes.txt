Natural Text
I come from a solid Java (and Matlab) background, and have been trying to teach myself Python (3.4) recently. In the Java API docs (http://docs.oracle.com/javase/7/docs/api/), the documentation for a particular class always shows a nice overview of the ancestors of that class (see e.g. this screenshot).Now I'm wondering if there is any way of viewing a similar ancestor hierarchy for Python classes. I am working from the assumption that, since Python is an object-oriented language, all non-primitive types will be objects (please correct me if I'm wrong). Understanding the ancestry for different types should probably greatly aid my understanding of iterables, sequences, views, and lists.I've tried several things, as suggested in answers to similar questions (such as here); but  does not always seem to work; for instance, the following gives an error:even though dict_keys is a type:I was also highly surprised to learn that list does not inherit from iterable:So, although my question is mainly about how to view (and, ideally, browse) the hierarchy of the standard Python library, any other comments on how to understand the default types' hierarchy, mainly how lists/sequences/views/iterables relate formally, would also be very welcome. The (otherwise excellent) Python tutorial does not really cover this stuff, it seems.
Just because something is a type doesn't mean you have a reference to that type in the global namespace.  This is the case with dict_keys.  e.g.So it does have an MRO, and it is inspectable -- You just didn't have a handle on the  type before now.Note that the MRO can be a bit deceiving:so we see that  at least thinks that it is a subclass of  even though you won't find it in the MRO.  This is because  actually s itself using the  module.I think that this is one of the basic differences between python and java.  In python, you typically care more about the interface the object provides rather than the actual type and inheritance tree.  At some level this statement may seem a bit pedantic -- After all, you need to know the inheritance tree to know the interface an object provides.  But the fact that we work in interfaces is exactly why ,  and  objects can be iterated over despite not having a real common base class ( doesn't count as it is a virtual base class) above  (which can't be iterated over).


Answer URL
https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy
