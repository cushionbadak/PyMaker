Natural Text
I am confused about how to play around with the  module in Python 3.4. I have a  API for a search engine, and want to each search request to be run either parallel, or asynchronously, so that I don't have to wait for one search finish to start another.Here is my high-level searching API to build some objects with the raw search results. The search engine itself is using some kind of asyncio mechanism, so I won't bother with that.To try to async the requests, I wrote following test case to test how I can interact my stuff with the  module.By running with pytest, it will return a , when it hits the line . I also tried another way.By running this test case by pytest, it passes but some weird exception from the search engine will raise. And it says .Things I wish to ask:For my 1st try, is that the right way to use , by returning the actual result from a function call?I think I need to add some sleep to my 2nd test case to wait for the task finish, but how should I do that? And how can I get my function calls to return in my 2nd test case?Is that a good way to implement asyncio with an existing module, by creating an async handler to handle requests?If the answer to question 2 is NO, does every client calls to the class  needs to include  this kind of stuffs to async the requests?
The problem is that you can't just call existing synchronous code as if it was an  and get asynchronous behavior. When you call , you're only going to get asynchronous behavior if  itself is actually an , or at least returns an . Right now,  is just a regular synchronous function, so calling  is just going to throw an error, because it doesn't return a  or coroutine.To get the behavior you want, you'll need to have an asynchronous version of  in addition to a  version (or just drop the synchronous version altogether if you don't need it). You have a few options to support both:Rewrite  as an  that it uses -compatible calls to do its I/O, rather than blocking I/O.  This will make it work in an  context, but it means you won't be able to call it directly in a synchronous context anymore. Instead, you'd need to also provide an alternative synchronous  method that starts an  event loop and calls . See this question for more details on that.Keep your synchronous implementation of , and provide an alternative asynchronous API that uses  to run your the  method in a background thread:Testing script:This way, you can keep your synchronous code as is, and at least provide methods that can be used in  code without blocking the event loop. It's not as clean a solution as it would be if you actually used asynchronous I/O in your code, but its better than nothing.Provide two completely separate versions of , one that uses blocking I/O, and one that's -compatible. This gives ideal implementations for both contexts, but requires twice the work.


Answer URL
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.BaseEventLoop.run_in_executor
