Natural Text
I have written some codes as below, through which I wanted to test some specific problems with multiprocessing:However, when I ran this file, I found some weird phenomena. One particular output is as below:First of all, when passing data[i] to subprocess, id(data[i]) does not change at all, but AFAIK python fork() is copy-on-accessing because of ref-count changing. Secondly, suppose it is copy-on-write in python, when obj is modified in subprocess, int/File type object does change its id but this is not true with type list as we can see its id never changes even compared with the original id. Last but not least, I use join to wait for all subprocesses to complete, but output of parent process seems to always be messed up with subprocess ones, why? Thanks if any one could explain these for me.
None of this has anything to do with multiprocessing. You can run the exact same test just calling the same function in-process and you'll get the same results.First of all, when passing data[i] to subprocess, id(data[i]) does not change at allThat's because you don't change  anywhere.When you pass  as an argument, the  parameter doesn't become a reference to the variable , it becomes a reference to the same value that's in that variable.When you later do , that doesn't affect the value in any way; it just makes  refer to a different value instead.If you want to mutate , you have to pass  itself (and, presumably, ); then the function can do .Secondly, suppose it is copy-on-write in python, when obj is modified in subprocess, int/File type object does change its id but this is not true with type listNope. The difference has nothing to do with the types, or with copy-on-write.  never affects the original object. It doesn't matter whether it's an  or a .The reason you see different behavior isn't that the type is different, it's that you have different code. You don't do , you do . That's a method on the object, which mutates it in-place.(If you're curious about , that one is a bit trickier. Augmented assignment may mutate the value in-place as well as assigning a new value to the variable, or it may just assign a new value to the variable. It's up to the value's type. Generally, mutable types like  will mutate in-place and assign  back to the variable; immutable types like  will of course never mutate in-place, they'll always assign a new value.)My guess is that you're coming from a language like C++, where variables are actually memory locations where the values live, assignment is a mutating method (which normally copies values), and explicit references are references to variables, not to values. If so, it may help to think of every variable in Python a , not a .Last but not least, I use join to wait for all subprocesses to complete, but output of parent process seems to always be messed up with subprocess ones, why?Because you don't actually wait for all subprocesses to complete. This line:â€¦ iterates over , which is empty, so you don't  anything.This is one of the many reasons it's better to iterate directly over collections:If you do it that way, there's no place to insert a hard-to-debug counting error.Meanwhile, even though it turns out to be completely irrelevant to your actual code, if you're interested in what does and doesn't get inherited and how, read about start methods and the related programming recommendations. But briefly: if you're using the  method (the default on non-Windows systems), your globals are shared directly; if you're using  (the default on Windows), they're re-constructed from the source. But if you really need to share variables (which you really don't want to do anyway in most cases), you should almost never rely on the  behavior, even if you're only going to run on Unix; use explicit shared memory. (Also, if you really need to share anything that can be mutated by more than one process, you really need a  or other synchronization object.)


Answer URL
https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods
https://docs.python.org/3/library/multiprocessing.html#the-spawn-and-forkserver-start-methods
https://docs.python.org/3/library/multiprocessing.html#sharing-state-between-processes
