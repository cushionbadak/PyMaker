Natural Text
When , are  and  both references to the memory block of , instead of creating two memory blocks and copy the content of  to them respectively?When , is  just a reference to the memory occupied by , instead of creating a new memory block and copy the content from ? In Python, when is a reference created to point to an existing memory block, and when is a new memory block allocated and then copy? This language feature of Python is different from C. What is the name of this language feature?Thanks.
All variables (and other containers, such as dictionaries, lists, and object attributes) hold references to objects. Memory allocation occurs when the object is instantiated. Simple assignment always creates another reference to the existing object. For example, if you have:Then  and  point to the same object, a list. You can verify this using the  operator:If you change , then  changes too, because they are two names for the same object.If you want to create a copy, you must do so explicitly. Here are some ways of doing this:For lists, use a slice: .For many types, you can use the type name to copy an existing object of that type: . When creating your own classes, this is a good approach to take if you need copy functionality.The  module has methods that can be used to copy objects (either shallowly or deeply).For immutable types, such as strings, numbers, and tuples, there is never any need to make a copy. You can only "change" these kinds of values by referencing different ones.The best way of describing this is probably "everything's an object." In C, "primitive" types like integers are treated differently from arrays. In Python, they are not: all values are stored as references to objects—even integers.
This paragraph from the Python tutorial should help clear things up for you:Objects have individuality, and multiple names (in multiple scopes)  can be bound to the same object. This is known as aliasing in other  languages. This is usually not appreciated on a first glance at  Python, and can be safely ignored when dealing with immutable basic  types (numbers, strings, tuples). However, aliasing has a possibly  surprising effect on the semantics of Python code involving mutable  objects such as lists, dictionaries, and most other types. This is  usually used to the benefit of the program, since aliases behave like  pointers in some respects. For example, passing an object is cheap  since only a pointer is passed by the implementation; and if a  function modifies an object passed as an argument, the caller will see  the change — this eliminates the need for two different argument  passing mechanisms as in Pascal.To answer your individual questions in more detail:When lst = [d, d], are lst[0] and lst[1] both references to the memory block of d, instead of creating two memory blocks and copy the content of d to them respectively?No. They don't refer to the memory block of .  and  are aliasing the same object as , at that point in time. Proof: If you assign  to a new object after initializing the list,  and  will be unchanged. If you mutate the object aliased by , then the mutation is visible  and , because they alias the same object.When c=lst[0], is c just a reference to the memory occupied by lst[0], instead of creating a new memory block and copy the content from lst[0]?Again no. It's not a reference to the memory occupied by . Proof: if you assign  to a new object, c will be unchanged. If you modify a mutable object (like the dictionary that  points to) you will see the change in , because  is referring to the same object, the original dictionary.In Python, when is a reference created to point to an existing memory block, and when is a new memory block allocated and then copy?Python doesn't really work with "memory blocks" in the same way that C does. It is an abstraction away from that. Whenever you create a new object, and assign it to a variable, you've obviously got memory allocated for that object. But you will never work with that memory directly, you work with references to the objects in that memory.Those references are the values that get assigned to symbolic names, AKA variables, AKA aliases. "pass-by-reference" is a concept from pointer-based languages like C and C++, and does not apply to Python. There is a blog post which I believe covers this topic the best.It is often argued whether Python is pass-by-value, pass-by-reference, or pass-by-object-reference. The truth is that it doesn't matter how you think of it, as long as you understand that the entire language specification is just an abstraction for working with names and objects. Java and Ruby have similar execution models, but the Java docs call it pass-by-value while the Ruby docs call it pass-by-reference. The Python docs remain neutral on the subject, so it's best not to speculate and just see things for what they are.This language feature of Python is different from C. What is the name of this language feature?Associating names with objects is known as name binding. Allowing multiple names (in potentially multiple scopes) to be bound to the same object is known as aliasing. You can read more about aliasing in the Python tutorial and on Wikipedia.It might also be helpful for you to read would be the execution model documentation where it talks about name binding and scopes in more detail.
In short; Python is pass-by-reference. Objects are created and memory allocated upon their construction. Referencing objects does not allocate more memory unless you are either creating new objects or expanding existing objects ()This post Is Python pass-by-reference or pass-by-value covers it very well.As a side note; if you are worried about how memory is allocated in a manage programming language like Python then you're probably using the wrong language and/or prematurely optimizing. Also how memory is managed in Python is implemtnation specific as there are many implementations of Python; CPython (what you are probably using); Jython, IronPython, PyPy, MicroPython, etc.


Answer URL
https://docs.python.org/3/tutorial/classes.html#a-word-about-names-and-objects
https://docs.python.org/3/tutorial/classes.html#a-word-about-names-and-objects
https://docs.python.org/3/reference/executionmodel.html#execution-model
