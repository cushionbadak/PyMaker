Natural Text
Are there any built-in ways to have different threads have different destinations for  and similar?I'm exploring the creation of an interactive Python environment, so I can't just use  from module spamegg. It has to be the globally available one with no arguments.
You can replace  with an object that checks the current thread and writes to the appropriate file:
It is possible to do what you're asking, although it's complicated and clunky and possibly not portable, and I don't think it's what you want to do.Your objection to just using  is:I'm exploring the creation of an interactive Python environment, so I can't just use  from module . It has to be the globally available one with no arguments.But the solution to that is easy: Just use  from module  in your code, and  in the interactive interpreter. That's all there is to it.For that matter, there's no good reason this even needs to be called  in the first place. If all of your code used some other output function with a different name, you could do the same thing in the interactive interpreter.But how does that let each thread have a different destination?The easy way to do that is to just look up the destination in a .But if you really want to do both parts of this the hard way, you can.To do the global  the hard way, you can either have  replace the builtin  instead of just giving you a way to shadow it, or have it replace , so the builtin  with default arguments will print somewhere else.That still requires having  use a thread-local target.Alternatively, you can compile or wrap each thread function in its own custom  environment that replaces  and/or  from the default, allowing you to give a different one to each thread from the start. For example:
I might have solution for you, but it's quite more complicated than just print. Using this, you can create log handler for each thread and configure them to store logs to different locations.Keep in mind that this is developed with slightly different goal in mind (see comments) but you can adapt it by taking handler juggling feature of ClusteredLogging as a start.And some test code:


Answer URL
https://docs.python.org/3/library/threading.html#thread-local-data
