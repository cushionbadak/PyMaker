Natural Text
I'm trying to find the minimum in a list, above a certain threshold without using the min() function (I'm doing things the hard way for practice). I've managed by first creating a list of values above the threshold and then looping through the list, saving a value to a variable if it is smaller than the previously seen values: This correctly returns 53. Is it possible to do it without creating a second list (passed)?Why doesn't it work to add a second condition? e.g. This incorrectly returns 2 rather than 53. 
Since you're doing this as a learning experience:To avoid creating a second list, the most interesting alternative is to create a lazy iterator instead. Under the covers, this works out the next filtered value on demand, instead of building a list of them up-front. But from much of your code, it can actually look as if you created a list.There are different ways to create lazy iterators—an explicit iterator class, the  builtin, a generator function—but in your case, you can just use a generator expression instead of a list comprehension:All I had to do was change the square brackets to parentheses, and you've magically got a lazy iterator.However, an iterator can only be used to go through the values in order, once. You can't do things like indexing (). So you need to rethink your code a bit. But that turns out to be very easy:While we're at it, you might want to consider refactoring your code into two functions—write your own  function that takes any iterable (an iterable is a lazy iterator, or a sequence like a list, or anything else that can go in a  loop) and returns the minimum value:Or maybe refactor further:Notice that this approach solves your second problem automatically. Your problem was that  might not be . To rewrite things to work, you'd have to do something like this:But writing things as a chain of iterator transformations forces you to put them in order—do the filtering first, and then the min-finding, which means you're automatically getting the first filtered value rather than the first value—while still interleaving the work (and avoiding the time and space costs of creating a whole unnecessary list) the way you wanted.If you want a more in-depth introduction to these ideas, David Beazley's Generator Tricks for Systems Programmers is amazing.One last thing to consider: is there a way to get rid of the special treatment for the first value?You could start with a value that will be greater than anything, or you could use a flag to specify whether you'd found a minimum value so far:This has the advantage (or maybe disadvantage, depending on what you wanted…) of still failing when passed an empty list, but it simplifies the looping (no need to pull out the first value, which means no need to call ). But the manual flag management might add more noise than it helps you remove. Still, it's worth comparing the two and deciding for yourself.Other things you might want to consider trying for yourself:Rewrite  around .Rewrite  to use a "smaller than anything" value. will work if all of your values are ints or floats.If the values can be anything at all, you can define a  class with a custom  method, and use .Figure out all the different options for what to do with an empty input—or an input that isn't empty but doesn't have any values that pass the filter—and how to implement them.Try using a sorted data structure, like the one in  to do —then you can expand it to return the two lowest values instead of just the lowest, or take an  parameter and and return that many.
In general, find the  (or ) using a loop requires you to initialize the return variable to something huge (or a huge negative value).In your case you are initializing the minimum to the first element in the list. Then for subsequent elements, the  check will evaluate to  since this value is already the minimum of the whole list.Here is one way to modify your code:


Answer URL
https://docs.python.org/3/library/functools.html#functools.reduce
https://docs.python.org/3/reference/datamodel.html#special-method-names
https://docs.python.org/3/library/heapq.html
