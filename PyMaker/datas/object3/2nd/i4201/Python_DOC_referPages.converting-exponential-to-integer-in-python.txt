Natural Text
When I execute this python code:The output I receive is:  which does not equal to  .Why does this happen and how can I make the output equal to ? 
That result can be achieved in Python3 (or Python2 with true division imported from ), but not Python2 in stock mode.The operator  always generate "true" quotient (with fractional part), but first it converts both arguments to its  (which is the same as  in C). And this conversion is where precision is lost because this  has only 53 significant binary digits (guessing your platform is  based, as >99% are). The argument divided by 1 is already rounded in that way and gets equal to 18243150071292140668971909120.(It seems Python language documentation is not precise here in operatorʼs effects. It notes that "The numeric arguments are first converted to a common type" but forgets that, to get a  result, the simplest way is utilized - to rely on platformʼs floating division.)Then, conversion back to  (that is exact and essentially unlimited) gives the same value and you see it printed.To get what you expect, use  instead of : the "floor division" () doesn't convert its arguments to . (OTOH, if some of them is already , it can convert another one to perform floating division and them truncate result to flooring integer value.)This is essentially the same you are told by @PM2Ring but formed as answer.If you want to make calculations with not-only-integer numbers with precision more than a usual  provides, you should get out of intrinsic types and consider using  from the standard library,  library wrapper or a similar solution.


Answer URL
https://docs.python.org/3/reference/expressions.html#binary-arithmetic-operations
