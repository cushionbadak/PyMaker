Natural Text
I think my question is related to this, but not exactly similar. Consider this code:The output of this code is:Is it guaranteed that the line "In the finally block" is going to be printed before "Finished counting"? Or is this because of cPython implementation detail that an object will be garbage collected when the reference count reaches 0.Also I am curious on how  block of the  generator is executed? e.g. if I change the code of  tothen I do see  printed before . How does the garbage collector directly go to the  block? I think I have always taken  on its face value, but thinking in the context of generators is making me think twice about it. 
You are, as you expected, relying on implementation-specific behavior of CPython reference counting.1In fact, if you run this code in, say, PyPy, the output will usually be:And if you run it in an interactive PyPy session, that last line may come many lines later, or even only when you finally exit.If you look at how generators are implemented, they have methods roughly like this:CPython deletes objects immediately when the reference count becomes zero (it also has a garbage collector to break up cyclic references, but that isn't relevant here). As soon as the generator goes out of scope, it gets deleted, so it gets closed, so it raises a  into the generator frame and resumes it. And of course there's no handler for the , so the  clause gets executed and control passes up the stack, where the exception is swallowed.In PyPy, which uses a hybrid garbage collector, the generator doesn't get deleted until the next time the GC decides to scan. And in an interactive session, with low memory pressure, that could be as late as exit time. But once it does, the same thing happens.You can see this by handling the  explicitly:(If you leave the  off, you'll get the same results for only slightly different reasons.)You can explicitly  a generatorâ€”and, unlike the stuff above, this is part of the public interface of the generator type:Or, of course, you can use a  statement:1. As Tim Peters' answer points out, you're also relying of implementation-specific behavior of the CPython compiler in the second test.
I endorse @abarnert's answer, but since I already typed this ...Yes, the behavior in your first example is an artifact of 's referencing counting.  When you break out of the loop, the anonymous generator-iterator object  returned loses its last reference, and so is garbage-collected at once.  That in turn triggers the generator's  suite.In your second example, the generator-iterator remains bound to  until your  exits, so as far as  knows you may resume  at any time.   It's not "garbage" until  exits.  A fancier compiler could notice that  is never referenced after the loop ends, and decide to effectively  before then, but  makes no attempt to predict the future.  All local names remain bound until you explicitly unbind them yourself, or the scope in which they're local ends.


Answer URL
https://docs.python.org/3/library/gc.html
