Natural Text
I have tried to implement the first is_prime-function from this answer:https://stackoverflow.com/a/17298131/6208280Yet I have a little probleme while testing high numbers.For really high numbers, I get an overflow error: I checked the max for float:for  everything works fine... but for example with  there will be this overflow error (because of the float max?).Does that mean 1.7976931348623157e+308 is the limit for this kind of is_prime()-function or is there any solution to check higher numbers with the is_prime()-function?In my mind such solutions as "use decimal" will not really solve the problem, because of the lack of precision a prime number checking function will need?
If the only reason you need floats is to be able to do , you can find a reasonably efficient  function and use that instead. See this question, and the blog post linked from the accepted answer, for some ideas.Or you can just change your code so that it doesn't need to  at all. For example, instead of a range that ends with , you can use a  that tests . Or, since you've already got that  function:Or, if you don't need it to be a one-liner, you can probably write something less abstract (and maybe more efficient?) than either of those. (But really, any  could well be faster than the best possible  test, because you only have to do the  once, at the start of the loop, rather than every time through the loop.)Or, if you really want to keep things structured this way, you can just use . You say:In my mind such solutions as "use decimal" will not really solve the problem, because of the lack of precision a prime number checking function will need?But that's not right. Using  means you're inherently limited to 52 bits of precision, which if a problem long before you get to overflowing. Using  means you get as many digits of precision as you ask for—and even the default 30 digits is already much more than 52 bits. For example:(In fact, since you're constructing that  from a huge , it's going to automatically expand to track as many digits as are needed for the … but you do still need to set the precision before calling  on it.)It can be complicated to programmatically calculate and set the desired precision for an operation, but in this case, it's pretty simple. The bigger problem is that really big  are a lot slower than really big ints.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.takewhile
