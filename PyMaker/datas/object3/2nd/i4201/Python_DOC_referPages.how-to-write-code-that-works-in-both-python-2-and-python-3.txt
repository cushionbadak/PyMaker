Natural Text
A Django website I maintain currently uses Python 2.7 but I know that I'll have to upgrade it to Python 3 in a couple of months.  If I'm writing code right now that has to work in Python 2, is there a Pythonic way to write it such that it would also work in Python 3 without any changes if I know what the syntax is going to be in Python 3?  Ideally I'd like the code to continue to work even after the upgrade without changing it but it would be easy for me to spot where I've done this in the codebase so that I can change the code when I have time.  Here's an example of what I'm talking about:
There is official documentation suggesting ways to do this. That documentation has changed over time as the situation has changed, so it's worth going directly to the source (especially if you're reading this answer a year or two after it was written).It's also worth reading the Conservative Python 3 Porting Guide and skimming Nick Coghlan's Python 3 Q&A, especially this section.Going back in time from the early 2018:futurizeThe current official suggestions are:Only worry about supporting Python 2.7Make sure you have good test coverage (coverage.py can help; )Learn the differences between Python 2 & 3Use Futurize (or Modernize) to update your code (e.g. )Use Pylint to help make sure you don’t regress on your Python 3 support ()Use caniusepython3 to find out which of your dependencies are blocking your use of Python 3 ()Once your dependencies are no longer blocking you, use continuous integration to make sure you stay compatible with Python 2 & 3 (tox can help test against multiple versions of Python; )Consider using optional static type checking to make sure your type usage works in both Python 2 & 3 (e.g. use mypy to check your typing under both Python 2 & Python 3).Notice the last suggestion. Guido and another of the core devs have both been heavily involved in leading large teams to port large 2.7 codebases to 3.x, and found mypy to be very helpful (especially in dealing with bytes-vs.-unicode issues). In fact, that's a large part of the reason gradual static typing is now an official part of the language.You also almost certainly want to use all of the  statements available in 2.7. This is so obvious that they seem to have forgotten to leave it out of the docs, but, besides making your life easier (e.g., you can write  function calls),  and  (and  and ) require it.sixThe documentation is aimed at people making an irreversible transition to Python 3 in the near future. If you're planning to stick with dual-version code for a long time, you might be better off following the previous recommendations, which largely revolved around using six instead of futurize. Six covers more of the differences between the two languages, and also makes you write code that's explicit about being dual-version instead of being as close to Python 3 as possible while still running in 2.7. But the downside is that you're effectively doing two ports—one from 2.7 to six-based dual-version code, and then, later, from 3.x-only six code to 3.x-only "native" code.2to3The original recommended answer was to use 2to3, a tool that can automatically convert Python 2 code to Python 3 code, or guide you in doing so. If you want your code to work in both, you need to deliver Python 2 code, then run  at installation time to port it to Python 3. Which means you need to test your code both ways, and usually modify it so that it still works in 2.7 but also works in 3.x after 2to3, which isn't always easy to work out. This turns out to not be feasible for most non-trivial projects, so it's no longer recommended by the core devs—but it is still built in with Python 2.7 and 3.x, and getting updates.There are also two variations on 2to3: sixer auto-ports your Python 2.7 code to dual-version code that uses six, and 3to2 lets you write your code for Python 3 and auto-port back to 2.7 at install time. Both of these were popular for a time, but don't seem to be used much anymore; modernize and futurize, respectively, are their main successors.For your specific question, will work on both, if you don't mind a minor performance cost in 2.7.2to3 can automatically change that  to  at install time on 3.x.futurize can be used to do either of the above.six will allow you to write , which will do  in 2.7 and  in 3.x.six will also allow you to write , which will do  in 2.7 (which is identical to what  does in 3.x, rather than just similar).modernize and sixer will automatically change that  to .3to2 will let you write  and autmatically convert it to  at install time on 2.x.mypy can verify that you're just using the result as a general iterable (rather than specifically as an iterator), so changing to  or  leaves your code still correctly typed.
you can import the future packagenested_scopes   2.1.0b1 2.2 PEP 227: Statically Nested Scopesgenerators  2.2.0a1 2.3 PEP 255: Simple Generatorsdivision    2.2.0a2 3.0 PEP 238: Changing the Division Operatorabsolute_import 2.5.0a1 3.0 PEP 328: Imports: Multi-Line and Absolute/Relativewith_statement  2.5.0a1 2.6 PEP 343: The “with” Statementprint_function  2.6.0a2 3.0 PEP 3105: Make print a functionunicode_literals    2.6.0a2 3.0 PEP 3112: Bytes literals in Python 3000
Making your Django project compatible with both Python versions consists of the following steps:Add  at the top of each module and then use usual quotes without a u prefix for Unicode strings and a b prefix for bytestrings.To ensure that a value is bytestring, use the  function. To ensure that a value is Unicode, use the  or  function.In your models use  method instead of  and add the  decorator.To iterate through dictionaries, use iteritems() , iterkeys() , and itervalues() from django.utils.six . Take a look at the following:At the time of capturing exceptions, use the as keyword, as follows:Use django.utils.six to check the type of a value as shown in the following:Use range from django.utils.six.moves ,Instead of xrange , as follows:Source link
In addition to importing from future, there is also the six project that aims to provide api compatibility between Python 2 and Python 3: https://pypi.org/project/six/.Your example code could be made compatible between version 2 and 3:There are still things that won't be compatible between 2 and 3 like f-strings.
There are a few different tools that will help you make sure you are writing python2/3 compatible code. If you are interested in porting python2 code into python3, then the 2to3 program that comes with the standard library will try to convert a python 2 program to python 3.https://docs.python.org/2/library/2to3.htmlAnother great tool is pylint. pylint is a python linter that will describe issues to you without fixing them. If you pip install pylint on a python3 environment, then it will analyze your code based on python 3's rules. If you use python 2 to install pylint, it will do the same but with python 2's rules.There are other popular and similar tools like flake8 or autopep8, but I am not familiar with them enough to advertise them.
six and future is a golden rule, enough to make easy a coming migrationadd to every python2 file, this as first line:use below working with strings, iteration, metaclasses, ...and so on six reference


Answer URL
https://docs.python.org/3/howto/pyporting.html
https://docs.python.org/3/library/__future__.html
https://docs.python.org/3/library/2to3.html
