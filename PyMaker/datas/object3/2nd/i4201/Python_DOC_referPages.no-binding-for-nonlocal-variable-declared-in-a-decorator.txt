Natural Text
var is declared inside the returning() function before calling func(), yet I get a binding error. I don't understand why this happens.
Python determines scopes at compile time, making the scope model static, not dynamic. The  and  statements tell the compiler to alter the scope where a name is set.  tells the compiler that a given name is to be assigned to as a closure, living in an enclosing scope. See the Naming and binding section of the Python execution model documentation:If a name is bound in a block, it is a local variable of that block, unless declared as  or .andEach assignment or import statement occurs within a block defined by a class or function definition or at the module level (the top-level code block).andA scope defines the visibility of a name within a block. If a local variable is defined in a block, its scope includes that block. If the definition occurs in a function block, the scope extends to any blocks contained within the defining one, unless a contained block introduces a different binding for the name.So only function definitions, class definitions and the module level are blocks where assignments take place.  can only act on names in a nested scope:The  statement causes corresponding names to refer to previously bound variables in the nearest enclosing function scope. is not a nested block, there is no enclosing function scope.Decorators are a runtime feature, and do not produce a new encloding function scope. You didn't nest  inside the decorator, you only passed in a reference to the function object. The function has already been created, compilation is done and the scope of the names is set in stone.The only way to do what you want would require re-compilation or bytecode manipulation, both subjects that are very much on the very advanced side of Python hacking. For example, with access to the source code (usually the case), you could use  and  to merge the abstract syntax tree of  into that of  to create a nested scope, then compile that new tree into bytecode that would do what you want. Or you'd have to do something similar with the bytecode of both functions to make  produce a closure, and  take that closure for the value of . This would require an intimate knowledge of how Python closures work, and what bytecode the compiler produces to handle closures.All this means that it would be much easier to find yourself a different approach to your problem. Perhaps use a class with state to alter the state in different contexts, etc.


Answer URL
https://docs.python.org/3/reference/executionmodel.html#naming-and-binding
