Natural Text
I googled this issue for last 2 weeks and wasn't able to find an algorithm or solution. I have some short .wav file but it has MULAW compression and python doesn't seem to have function inside  that can successfully decompresses it. So I've taken upon myself to build a decoder in python.  I've found some info about MULAW in basic elements:  Wikipedia A-law u-Law comparison Some c-esc codec library So I need some guidance, since I don't know how to approach getting from signed short integer to a full wave signal. This is my initial thought from what I've gathered so far:  So from wiki I've got a equation for u-law compression and decompression :  compression :   decompression :   So judging by compression equation, it looks like the output is limited to a  range of -1 to +1 , and with signed short integer from â€“32,768 to 32,767 so it looks like I would need to convert it from  to  in specific range.   Now, to be honest, I've heard of quantisation before, but I am not sure if I should first try and dequantize and then decompress or in the other way, or even if in this case it is the same thing... the tutorials/documentation can be a bit of tricky with terminology. The wave file I am working with is supposed to contain 'A' sound like for speech synthesis, I could probably verify success by comparing 2 waveforms in some audio software and custom wave analyzer but I would really like to diminish trial and error section of this process. So what I've had in mind:  So is there some sort of algorithm or crucial steps I would need to take in form of first: decompression, second: quantisation : third ?Since everything I find on google is how to read a  PCM-modulated file type, not how to manage it if wild compression arises. 
So, after scouring the google the solution was found in github ( go figure ). I've searched for many many algorithms and found 1 that is within bounds of error for lossy compression. Which is for u law for positive values from 30 -> 1 and for negative values from -32 -> -1 To be honest i think this solution is adequate but not quite per equation per say, but it is best solution for now. This code is transcribed to python directly from gcc9108 audio codecWith test:  and output:  And as you can see 263-255 = 8 which is within bounds. When i tried to implement  method described in G.711 ,that kind user Oliver Charlesworth suggested that i look in to , the decoded value for maximum in data was -8036 which is close to the maximum of uLaw spec, but i couldn't reverse engineer decoding function to get binary equivalent of function from wikipedia.  Lastly, i must say that i am currently disappointed that python library doesn't support all kind of compression algorithms since it is not just a tool that people use, it is also a resource python consumers learn from since most of data for further dive into code isn't readily available or understandable.  EDIT After decoding the data and writing wav file via  i've successfully succeeded to write a new raw linear PCM file. This works... even though i was sceptical at first. EDIT 2: ::> you can find real solution oncompressions.py
Python actually supports decoding u-Law out of the box:Convert sound fragments in u-LAW encoding to linearly encoded sound fragments. u-LAW encoding always uses 8 bits samples, so width  refers only to the sample width of the output fragment here.https://docs.python.org/3/library/audioop.html#audioop.ulaw2lin


Answer URL
https://docs.python.org/3/library/audioop.html#audioop.ulaw2lin
