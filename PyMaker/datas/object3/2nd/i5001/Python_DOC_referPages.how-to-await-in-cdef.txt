Natural Text
I have this Cython code (simplified):What happens though: I get . And, in fact, it is never called.  However,  is called.Any idea what's going on / how to get it to actually wait for  to complete?Extended versionIn the example above some important details are missing: In particular, it is really difficult to get hold of return value from .  The real project setup has this:Bison parser that has rules.  Rules are given a reference to specially crafted struct, let's call it .  This struct contains references to callbacks, which are called by parser when rules match.In Cython code, there's a class, let's call it , that users of the package are supposed to extend to make their custom parsers.  This class has methods which then need to be called from callbacks of .Parsing is supposed to happen like this:The callbacks are of a general shape:I have to admit I don't know how exactly  implements , and so I don't know if it is in general possible to do this with the setup that I have.  My ultimate goal though is that multiple Python functions be able to iteratively parse different files, all at the same time more or less.
Your problem is mixing synchronous with asynchronous code. Case in point:This is similar to putting a subroutine in a Thread, but never starting it.Even when started, this is a deadlock: the synchronous part would prevent the asynchronous part from running.Asynchronous code must be edAn  coroutine is similar to a  generator: calling it only instantiates it. You must interact with it to actually run it:Similarly, when you have an  coroutine, you must either  it or schedule it in an event loop. Since  produces a coroutine, and you never  or schedule it, it is not run. This is the cause for your RuntimeWarning.Note that the purpose of putting a coroutine into  is purely to add a timeout. It is not meant to  or run the coroutine by itself.Asynchronous functions need asynchronous instructionsThe key for asynchronous programming is that it is cooperative: Only one coroutine executes until it yields control. Afterwards, another coroutine executes until it yields control. This means that any coroutine blocking without yielding control blocks all other coroutines as well.In general, if something performs work without an  context, it is blocking. Notably,  is blocking. You have to call it from a synchronous function:Return values from coroutinesA coroutine can  results like a regular function.If you  it from another coroutine, you directly get the return value:To get the value from a regular subroutine, use  to get the return value:A  function cannot be a coroutineCython supports coroutines via  and  only for Python functions. Even for a classical coroutine, a  is not possible:You are perfectly fine calling a synchronous  function from a coroutine. You are perfectly fine scheduling a coroutine from a  function.But you cannot  from inside a  function, nor  a  function. If you need to do that, as in your example, use a regular  function.You can however construct and return a coroutine in a  function. This allows you to  the result in an outer coroutine:Note that despite the ,  is not a coroutine. It is merely a factory for coroutines.


Answer URL
https://docs.python.org/3/library/asyncio-task.html#asyncio.wait_for
