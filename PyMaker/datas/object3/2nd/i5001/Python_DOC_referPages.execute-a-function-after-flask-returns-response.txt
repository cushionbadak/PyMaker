Natural Text
I have some code that needs to execute after Flask returns a response. I don't think it's complex enough to set up a task queue like Celery for it. The key requirement is that Flask must return the response to the client before running this function. It can't wait for the function to execute.There are some existing questions about this, but none of the answers seem to address running a task after the response is sent to the client, they still execute synchronously and then the response is returned.Need to execute a function after returning the response in FlaskPython Flask sending response immediatelyNeed to execute a function after returning the response in FlaskFlask end response and continue processing
The long story short is that Flask does not provide any special capabilities to accomplish this. For simple one-off tasks, consider Python's multithreading as shown below. For more complex configurations, use a task queue like RQ or Celery.Why?It's important to understand the functions Flask provides and why they do not accomplish the intended goal. All of these are useful in other cases and are good reading, but don't help with background tasks.Flask's  handlerFlask's  handler, as detailed in this pattern for deferred request callbacks and this snippet on attaching different functions per request, will pass the request to the callback function. The intended use case is to modify the request, such as to attach a cookie.Thus the request will wait around for these handlers to finish executing because the expectation is that the request itself will change as a result.Flask's  handlerThis is similar to , but  doesn't receive the  object. So that means it won't wait for the request, right?This seems like the solution, as this answer to a similar Stack Overflow question suggests. And since Flask's documentation explains that teardown callbacks are independent of the actual request and do not receive the request context, you'd have good reason to believe this.Unfortunately,  is still synchronous, it just happens at a later part of Flask's request handling when the request is no longer modifiable. Flask will still wait for teardown functions to complete before returning the response, as this list of Flask callbacks and errors dictates.Flask's streaming responsesFlask can stream responses by passing a generator to , as this Stack Overflow answer to a similar question suggests.With streaming, the client does begin receiving the response before the request concludes. However, the request still runs synchronously, so the worker handling the request is busy until the stream is finished.This Flask pattern for streaming includes some documentation on using , which is necessary to include the request context.So what's the solution?Flask doesn't offer a solution to run functions in the background because this isn't Flask's responsibility.In most cases, the best way to solve this problem is to use a task queue such as RQ or Celery. These manage tricky things like configuration, scheduling, and distributing workers for you.This is the most common answer to this type of question because it is the most correct, and forces you to set things up in a way where you consider context, etc. correctly.If you need to run a function in the background and don't want to set up a queue to manage this, you can use Python's built in  or  to spawn a background worker.You can't access  or others of Flask's thread locals from background tasks, since the request will not be active there. Instead, pass the data you need from the view to the background thread when you create it.
Flask is a WSGI app and as a result it fundamentally cannot handle anything after the response. This is why no such handler exists, the WSGI app itself is responsible only for constructing the response iterator object to the WSGI server. A WSGI server however (like gunicorn) can very easily provide this functionality, but tying the application to the server is a very bad idea for a number of reasons.For this exact reason, WSGI provides a spec for Middleware, and Werkzeug provides a number of helpers to simplify common Middleware functionality. Among them is a ClosingIterator class which allows you to hook methods up to the  method of the response iterator which is executed after the request is closed.Here's an example of a naive  implementation done as a Flask extension:You can use this extension like this:When you curl "/" you'll see the following in your logs:This solves the issue simply without introducing either threads (GIL??) or having to install and manage a task queue and client software.
You can use this code i have tried it.It works.this code will print the string "message". after the 3 second ,from the scheduling time. You can change the time your self according to you requirement.


Answer URL
https://docs.python.org/3/library/threading.html#threading.Thread
https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Process
