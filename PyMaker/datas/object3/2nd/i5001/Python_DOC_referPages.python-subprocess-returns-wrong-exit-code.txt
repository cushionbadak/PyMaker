Natural Text
I wrote a script to launch a number of processes (simple unit tests) to run in parallel. It will do  jobs with  parallel processes at a time. My first implementation ran the processes in batches of  and seemed to be working fine (I used the  command here to test the behavior)However, the tests do not take equal amounts of time so I was sometimes waiting for a slow test to finish. Thus I rewrote it to keep assigning tasks as they finishedHowever this produces wrong results for the last few processes. For instance, in the example above it produces 98/100 errors instead of 100. I checked and this has nothing to do with concurrency; the 2 latest jobs were returning with exit code 0 for some reason.Why does this happen?
The problem is with . It doesn't only wait for a child process to exit: it also returns the pid and "exit status indication" of that child, as the documentation says. This requires waiting until the child process has terminated; but once the child has terminated, its return code is no longer available for . Here's a simple test to reproduce the problem:false_runner.pyoutputThe source code for , called by , makes it clear what's happening here: when  tries to call  on its child process's pid, it gets , and assigns itself a  of 0, because there's no way to determine the child process's return code at this point.The reason this happens only for the last couple of subprocesses in your example is because  is only getting called for the  case, and only once or twice, because your subprocess is so fast. If you slow it down a bit, you'll get more random behavior.As for a fix: I'd probably just replace  with a sleep.


Answer URL
https://docs.python.org/3/library/os.html#os.wait
https://docs.python.org/3/library/multiprocessing.html
