Natural Text
Stumped on this thread sync I'm encountering.Basically, I'm writing to a out buffer, and waiting on a condition variable until the read buffer is populated with a response from a socket. It's an incredibly simple thread sync.Seems straightforward enough, right? There's 1 thread waiting on the condition variable, and 1 thread (asyncore async callback loop) that will populate self.readbuffer and notify on the condition variable. Even more curious : if I do a time.sleep() instead of using a condition variable, I get a perfectly populated self.readbuffer on the calling thread of write_wait_response(). Obviously this is not a solution I can accept.Here's what I'm expecting is happening:Call to write_wait_response(buffer), this writes to buffer and waitson self.cond asyncore callback loop calls handle_write, writes bytes to socket.Server receives bytes, writes response.asyncore callback loop sees bytes on the socket, reads intoself.readbuffer, notifies cv?????????? write_wait_response should unblock?Console output:Note: at the end of this log, thread 1 is STILL waiting on self.cond. What's going on?Full class:
Figured it out. This isn't related to asyncore. I was just signaling the condition variable incorrectly. The python3 threading api doc says the calling thread of notify() must acquire the underlying lock which makes sense, wouldn't want two producers to notify on the same condition variable. Would want one to block on the critical section while the other performs its task.


Answer URL
https://docs.python.org/3/library/threading.html#threading.Condition.notify
