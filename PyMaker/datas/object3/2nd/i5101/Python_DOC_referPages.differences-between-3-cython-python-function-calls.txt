Natural Text
I wanted to test  performance comparing it to standard python. So here I have 3 examples of a function which will loop through 200 ints adding the same number to the result over and over again and then returning the result. In the  module I made it to be called  times. So there's the first example:Here's the second (look closely, the first function definition matters):And there's the third one, which is placed in the main file:I compiled it with  and I got two s. Then when I run  - this shows up:So the first one is only . The second one (seems to be  faster than the first one) is . And the last one is just .The last ones performance is terrible, but that's what I wanted to see. The interesting thing for me is why those first two examples differ (I checked it many times, second is always ~ faster than the first one).Is it only because I specified the return type? And if so, does it mean that they're both  functions or is the first some kind of, I dunno, a mixed-type kinda function?
First, you must be aware, that in the case of cython-functions you are measuring just the overhead of calling a - vs. a -function:The C-compiler recognizes, that the loop will result in  and evaluates this multiplication directly without running the loop - and multiplication is equally fast for  and .This might come as surprise for a python-programmer, because the python-interpreter doesn't optimize and thus this loop has an -running time:Now, calling a  function is much faster! Just look at the generated C-code for calling the  version (actually the creation of python-integer is already incorporated): - is just a call of a C-function. Compared to call of -version which happens via the whole python-machinery (here kind of abbreviated):The Cython has to:Create a python-integer from the C-int  to be able to call a Python-function ()locate this method using its name ( + )and finally call the function.The first call is probably at least 100 times faster, but the overall speed-up is less than 2 only because calling the "inner"-function is not the only work that needs to be done: -functions  and  have to be called anyway + the resulting python-integer must be created. Fun-fact:The reason is the integer pool for values ...= so the values from this range can be constructed faster.Specifying the return type doesn't play that big role in your example: it only decides, where the conversion to python-integer happens - either in  or  - but it happens eventually.


Answer URL
https://docs.python.org/3/c-api/long.html#c.PyLong_FromLong
