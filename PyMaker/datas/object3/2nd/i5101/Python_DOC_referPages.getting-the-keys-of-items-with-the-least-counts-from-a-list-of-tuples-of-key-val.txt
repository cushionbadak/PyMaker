Natural Text
The input is an unsorted list of tuples: The goal is to find the last  keys with the least counts, i.e. desired output:I've tried doing this by:first convert the list of tuples to a dictcast the dict into a Counterthen find the  list of tuples from the cast the list of tuples from the  to a dictget the keys and then convert it into a listi.e. Is there a less convoluted way to get the same output? I could also do this:But now I've merely swapped out the  with  and . Then I would still need to  to extract the keys through unpacking the first value from each list of tuples after the zip.There must be a simpler way.NOTENote that the question is not asking to sort, it's to extract the list first element in the original list of tuples given. And the criterion to extract is based on the last nth items with the lowest value in the 2nd element.The answers from the possible duplicate linked still requires the step to unpack the list of sorted tuples and and the extract the top nth of the list of first elements. 
The goal is to find the last  keys with the least countsGiven this goal's definition neither of your two solutions fit. In one with  you use  which will make the order of keys undefined and you will not get the last keys, but some  keys with least value. The second solution has incorrect slicing, and if it's fixed it returns first  keys with least value.Taking into account that  implementation is stable it can be rewritten like this to fit the goal:But it's a better idea to use , which is the stdlib tool for questions like "n smallest/greatest values from an iterable" (as Martijn Pieters pointed out,  and  are also stable and the docs really say that, but in implicit way). Especially if the real list you have to deal with is big (for small  it should be faster that  as docs describe). You can improve performance even further, but at the cost of order (sorting stability), i.e. some  keys with least value instead of last  keys with least value. To do that you need to keep a "heapified" list and use it as your internal data structure instead of plain  (if you don't change the list and need the bottom-n only once, it will not give a performance benefit). You can push and pop from the list, for example:Here's the complete module you can use to benchmark the solutions. And here are the  results:But if we make  the difference will become noticeable:
Just use a heap, it will give you the desired output.has a key argument,you can use it inside of using  like me.
Where  is list of key, count tuples and  is desired number of keys.You may also adjust the sort criteria to include the keys themselves- if their order is important
Edit@alvas :Will generate the output you desire You can use this:Please refer to this (possible duplicate)Sort a list of tuples by 2nd item (integer value)
You could use pandas if you don't feel like reinventing the wheel.  Performance should be excellent since it's based on NumPy, which uses C under the hood instead of pure Python.Short answerResultExpanded, working example with comments
[i[0] for i in sorted(x.__reversed__(), key=lambda x: x[1])[:n]]Almost exactly the same as @Stacksonstacks answer, just that this actually gives you the 'desired output' (if you put n = 5)
You don't really need any imports for this task, you can also do it the following way: Output:
Here is my suggestion:   
This is a clean, simple approach without using python idioms: It is kind of like a fusion of min-value search plus filtering.  stores the min value up till now, and  stores the list of elements which have that min count. You reset them when you find a lower value.This can be modified to hold only 5 elements, so no splicing would be required in the end.
A Pure Python Solution Since we are trying to find the  elements in order of min to max, we cannot simply filter out those which do not have the smallest second element. We also have the second aim of trying to maintain order - this eliminates merely sorting on the second element of each tuple.My solution has complexity  - which is the best you can do here as we are creating a new list which is dependent on a pre-existing list.It works by creating a  (unordered) of the first  elements of each tuple in  - after  has been reversed () and then sorted based on the second element. This has the neat trick that since we are slicing before we convert to the set, there is still order within those tuples with equivalent second elements.Now, the neatness of using a  is that lookup is  (instant) as the elements are stored in order of their , so calling  is much faster than with a .We finally need to use a  to carry out the final filtering of :Also a test to shows that it works with 
Using list comprehension and sorted:  orwhere  is the number of keys you want in the resultant. Note that using the latter, with , is more expensive because it slices the list once more to reverse it back.Results with :Results with :
No Need of sorting in this solution Small Solution:output of above solution:Explanation of solution with commentsoutput of above explaination:


Answer URL
https://docs.python.org/3/library/functions.html#sorted
https://docs.python.org/3/library/heapq.html
https://docs.python.org/3/library/heapq.html#heapq.nsmallest
https://docs.python.org/3/library/functions.html#sorted
