Natural Text
I would like to implement and run custom Python coroutines (without using asyncio) to have a better "under the hood" understanding of asynchronous mechanisms.I was expected to be able to use concurrency to start a second task when the first task is waiting, doing nothing.Here the synchronous implementation of a stacker (which is an arbitrary use case).Here the output, as I was expected:Then an attempt of the asynchronous implementation of the same stacker.Expected output:Real output:I figure I missed something important. I hope my approach is relevant.With additional logs, I have noticed that the a_stack function never execute the append part.
Your problem is that your generators are paused at the  expression in the  function (via the ) delegation. The generator there is also infinite and so will never return. You can never advance your generators far enough to reach the  calls.I think you misunderstood what  does here.  moves control of the generator to another generator; that other generator has to complete iteration before the  expression completes and returns:Instead of using  and an infinite loop, record the time, and loop until the time has passed:You'll have to keep iterating over your generators (in a loop, perhaps?) to have them alternate execution.The  function is of course much more efficient than that; it uses a  object that attaches to the  functionality offered by the event loop. The loop lets the future object know when the time is up, at which point the future is marked 'ready' and the coroutine that produced it is continued again.
The line:does two things:create and run a new generatorsend the string  into the generatorThe created generator waits for item to arrive, and then, once resumed, does something with the item. And that is the problem, you never resume the generator, you throw it away and create a new one, and proceed to use in the same manner. To fix it, your sending code should do something like:But there is another problem. Before actually appending to the stack,  defers its execution to another iterator, which never stops yielding. One  way to code  that fixes the problem is:Then you need either a scheduler or at least a more resilient version of , which can actually deal with a task deferring its execution. A simple (and very inefficient) one could looks like this:After replacing  with , the expected output is displayed.A real scheduler would never busy-loop; it would be instructed by  and by other potentially blocking calls, such as reads from files or sockets, which IO/timing events it must wait for. After the appropriate event arrived, it would wake up the correct task. This is the core of what  does.To learn more about how generators and  are used as a core abstraction for asynchronous programming, I recommend the excellent lecture Python Concurrency From the Ground by Dave Beazley. In the lecture Dave implements a coroutine scheduler in front of live audience, showing the design of his curio library.


Answer URL
https://docs.python.org/3/library/asyncio-task.html#asyncio.sleep
https://docs.python.org/3/library/asyncio-task.html#asyncio.Future
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.call_later
