Natural Text
This question already has an answer here:Python Mocking a function from an imported module                    2 answers                I would like to test a email sending method I wrote. In file, format_email.py I import send_email.After formatting the email content in send_cars_email() I send the email using the method I imported earlier. in my test file test_car_emails.pyWhen I run the test it fails on assertion not called. I believe The issue is where I am mocking the send_email function. Where should I be mocking this function?
What you are mocking with the line  is the functionthat you don't have. This line will thus only add a new function to your  object. However, this function is not called from your code and the assignment will have no effect at all. Instead, you should mock the function  from the  module.mocking the function where it is usedOnce you have imported the function  via  in your module , it becomes available under the name . Since you know the function is called there, you can mock it under its new name:mocking the function where it is definedUpdate:It really helps to read the section Where to patch in the  docs (also see the comment from Martijn Pieters suggesting it):The basic principle is that you patch where an object is looked up, which is not necessarily the same place as where it is defined.So stick with the mocking of the function in usage places and don't start with refreshing the imports or aligning them in correct order. Even when there should be some obscure usecase when the source code of  would be inaccessible for some reason (like when it is a cythonized/compiled C/C++ extension module), you still have only two possible ways of doing the import, so just try out both mocking possibilities as described in Where to patch and use the one that succeeds.Original answer:You can also mock  function in its original module:but be aware that if you have called the import of  in  before the patching, patching  won't have any effect on code in  since the function is already imported, so the  in the example below won't be called:To fix that, you should either import  for the first time after the patch of :or reload the module e.g. with :Not that pretty either way, if you ask me. I'd stick with mocking the function in the module where it is called.
Since you are using pytest, I would suggest using pytest'sbuilt-in 'monkeypatch' fixture.Consider this simple setup:We define the function to be mocked.And in a separate file the class that calls the function.We mock the function where it is used using the 'monkeypatch' fixtureWe could also factor out the mocking into its own fixture if you want to reuse it.
The simplest fix would be belowBasically you have a module which has already imported  in the  and you have to update the loaded module now.But it is not the most recommended way of doing it because you loose the original  function. So you should use patch with context. There are different ways of doing that Way 1In this we mock the actual function which was importedWay 2This way any test within your file will used the patched function for other tests alsoWay 3In this method we patch the import itself and not the actual function which was called. In this case no reload needed as suchSo you can see there are different ways of doing mocking, some approaches comes as good practices and some come as personal choice


Answer URL
https://docs.python.org/3/library/unittest.mock.html#where-to-patch
https://docs.python.org/3/library/unittest.mock.html#where-to-patch
https://docs.python.org/3/library/unittest.mock.html#where-to-patch
https://docs.python.org/3/library/unittest.mock.html#the-patchers
