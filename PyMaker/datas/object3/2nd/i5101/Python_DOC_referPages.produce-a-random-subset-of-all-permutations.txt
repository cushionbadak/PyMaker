Natural Text
I'm looking for a way to randomly sample a fixed length subset of all permutations. APPROACH AApproach A below suffers from the problem that the permutations are too similar.['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T']['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'T', 'S']['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'S', 'R', 'T']APPROACH BApproach B gets me closer to my desired outcome, but here there's always a risk of producing identical ordering between lists, so this approach is not feasible.['J', 'B', 'M', 'A', 'O', 'C', 'K', 'S', 'H', 'Q', 'N', 'T', 'R', 'D', 'G', 'P', 'I', 'E', 'F', 'L']['R', 'O', 'C', 'I', 'G', 'E', 'Q', 'L', 'P', 'J', 'F', 'N', 'A', 'B', 'H', 'T', 'D', 'K', 'M', 'S']['L', 'O', 'I', 'G', 'B', 'E', 'R', 'A', 'D', 'N', 'J', 'S', 'H', 'F', 'K', 'M', 'Q', 'T', 'C', 'P']
but here there's always a risk of producing identical ordering between lists, so this approach is not feasible.You can use tuples (since lists aren't hashable) and sets (so that there are no duplicates/identical lists) to get around this:Edit: As @tobias_k points out:For the given list, there are 20! = 2432902008176640000 different permutations, so collisions are really very unlikely.
Consider the itertools  recipe:From the docs:CodeOutput is a third-party library that implements this recipe for you.
you could use this to generate the -th lexicographic perutation of  elements:then you just have to generate (and keep a  of - if you want to avoid duplicates) random integers that represent the permutations:note that this may loop forever if the number of test is bigger that the space of all the permutations...which prints (e.g.):but as mentioned in the other answers: if you have a permutation of 20 elements the chance of hitting a repeated permutation is very small!
I think your question is a special case of one I had, for k=NBased on this, the two solutions stated there should apply. The first one is a tad slow :)So the random sampling one (Which you also hint at your question, just discard duplicates...) seems to be the only answer for now.It would be very interesting to see if there is a generative solution to either this question, or the more general one...Here's the code based on that answer:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools-recipes
