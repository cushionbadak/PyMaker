Natural Text
I just wrote a simple  decorator for Python that instantiate classes based on type annotations.To enable lazy initialization of the class, the package provides a  function so that the caller can use it like this:This works very well, under the hood this  function just returns a function that returns the actual type and that has a lazy_init property set to . Also this does not break IDEs' (e.g., PyCharm) code completion feature.But I want to enable the use of a subscriptable  type use instead of the  function.Like this:This would behave very much like typing.Union. And while I'm able to implement the subscriptable type, IDEs' code completion feature will be rendered useless as it will present suggestions for attributes in the  class, not .I've been working with this code:I tried redefining  as a property to forward to the subscripted type's  but this seems to have no effect on the code completion feature of PyCharm.I strongly believe that what I'm trying to achieve is possible as typing.Union works well with IDEs' code completion. I've been trying to decipher what in the source code of typing.Union makes it to behave well with code completion features but with no success so far.
For the  notation to work you would want to create a user-defined generic type:You then use and  is seen as a container that holds the class. Note: this still means the IDE sees  as an object of type .  is a container type here, holding an object of type . Your IDE won't auto-complete for the  type, you can't use it that way.The notation also doesn't create an instance of the  class; it creates a subclass instead, via the  metaclass. The subclass has a special attribute  to let you introspect the subscription arguments:If all you wanted was to reach into the type annotations at runtime but resolve the name lazily, you could just support a string value:This is valid type annotation, and your decorator could resolve the name at runtime by using the  function (at a deferred time, not at decoration time), or by wrapping strings in your  callable at decoration time.If  is meant to flag a type to be treated differently from other type hints, then you are trying to overload the type hint annotations with some other meaning, and type hinting simply doesn't support such use cases, and using a   containing can't make it work.


Answer URL
https://docs.python.org/3/library/typing.html#user-defined-generic-types
https://docs.python.org/3/library/typing.html#typing.get_type_hints
