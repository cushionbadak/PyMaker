Natural Text
I am attempting to modify a value in a class  directly using something like . It is impossible to do the modification like that because a class  is actually a  object that does not allow direct modification of values. The reason for attempting direct modification or equivalent is that I am trying to hide the class attribute behind a property defined on the metaclass with the same name. Here is an example:This is example shows a scheme for creating an auto-incremented ID for each instance of . The line  can not be replaced by  because  is a  with no setter in . It would just change a  from  into an  from .I have tried messing with , but that has no effect. The implementation in  already returns a mutable  for the namespace. The immutable  seems to get set in , which I don't know how to avoid.I have also attempted to rebind the entire  reference to a mutable version, but that failed as well: https://ideone.com/w3HqNf, implying that perhaps the  is not created in .How can I modify a class  value directly, even when shadowed by a metaclass property? While it may be effectively impossible,  is able to do it somehow, so I would expect that there is a solution.My main requirement is to have a class attribute that appears to be read only and does not use additional names anywhere. I am not absolutely hung up on the idea of using a metaclass  with an eponymous class  entry, but that is usually how I hide read only values in regular instances.EDITI finally figured out where the class  becomes immutable. It is described in the last paragraph of the "Creating the Class Object" section of the Data Model reference:When a new class is created by , the object provided as the namespace parameter is copied to a new ordered mapping and the original object is discarded. The new copy is wrapped in a read-only proxy, which becomes the  attribute of the class object.
Probably the best way: just pick another name. Call the property  and the dict key , so you can access it the normal way.Alternative way: add another layer of indirection:That way you don't have to modify the actual entry in the class dict.Super-hacky way that might outright segfault your Python: access the underlying dict through the  module.This bypasses critical work  does to maintain internal invariants, particularly in things like CPython's type attribute cache. It is a terrible idea, and I'm only mentioning it so I can put this warning here, because if someone else comes up with it, they might not know that messing with the underlying dict is legitimately dangerous.It is very easy to end up with dangling references doing this, and I have segfaulted Python quite a few times experimenting with this. Here's one simple case that crashed on Ideone:Output:And here's a case with wrong results and no noisy error message to alert you to the fact that something has gone wrong:Output:I make absolutely no guarantees as to any safe way to use this, and even if things happen to work out on one Python version, they may not work on future versions. It can be fun to fiddle with, but it's not something to actually use. Seriously, don't do it. Do you want to explain to your boss that your website went down or your published data analysis will need to be retracted because you took this bad idea and used it?
This probably counts as an "additional name" you don't want, but I've implemented this using a dictionary in the metaclass where the keys are the classes. The  method on the metaclass makes the class itself iterable, such that you can just do  to get the next ID. The dunder method also keeps the method from being available through the instances. The dictionary storing the next id has a name starting with a double underscore, so it's not easily discoverable from any of the classes that use it. The incrementing ID functionality is thus entirely contained in the metaclass. I tucked the assignment of the id into a  method on a base class, so you don't have to worry about it in . This also allows you to  so all the machinery is a little harder to get to.Note that I've used the same name for the attribute on both the class and the object. That way  is the number of instances you've created, while  is the ID of that specific instance.
My main requirement is to have a class attribute that appears to be read only and does not use additional names anywhere. I am not absolutely hung up on the idea of using a metaclass  with an eponymous class  entry, but that is usually how I hide read only values in regular instances.What you are asking for is a contradiction: If your example worked, then  would be an "additional name" for the attribute.  So clearly we need a more specific definition of "additional name."  But to come up with that definition, we need to know what you are trying to accomplish (NB: The following goals are not mutually exclusive, so you may want to do all of these things):You want to make the value completely untouchable, except within the  method (and the same method of any subclasses): This is unPythonic and quite impossible.  If  can modify the value, then so can anyone else.  You might be able to accomplish something like this if the modifying code lives in , which the metaclass dynamically creates in , but that's extremely ugly and hard to understand.You want the code that manipulates the value to be "nicely encapsulated": Write a method in the metaclass that increments the private value (or does whatever other modification you need), and provide a read-only metaclass  that accesses it under the public name.You are concerned about a subclass accidentally clashing names with the private name: Prefix the private name with a double underscore to invoke automatic name mangling.  While this is usually seen as a bit unPythonic, it is appropriate for cases where name collisions may be less obvious to subclass authors, such as the internal names of a metaclass colliding with the internal names of a regular class instantiated from it.


Answer URL
https://docs.python.org/3/reference/datamodel.html#creating-the-class-object
https://docs.python.org/3/reference/datamodel.html
https://docs.python.org/3/reference/expressions.html#atom-identifiers
