Natural Text
I'm implementing simple socket programming which compute  operation. It's just computing a single operation such as " " "" and so on. (It can compute more complicate post-fix so far) There are four operators : , , ,  I'm programming server and client very defensively. And the question is... How do we impose (nontrivial) limits on the size of the integer? Anything we should know about the limitation of computing single operation in Python?My thought: I guess the python handle automatically unlike C because python is good. So we don't need to worry about it?
Since defensive programming is not about just limiting number sizes, I expanded my answer to reflect more aspects I find important.Secure your environment. Even before you start writing the server, decide who can use the application and how to get rid of malicious users. Authentication? (IP) Ban lists? (IP) White lists? Firewall rules? VPN?Control your buffers - have an explicit upper limit. Is the current transmission larger than N bytes? Discard it, then report an error to the client and probably drop the connection. This applies to both directions - an attacker might try to pass you a 10 Gb expression as well as pass you an expression that will weight 10 Gb when computed.This also applies for input/output queue if you have these - stop accepting more expressions if you already have a lot of work to do.If you go fully defensive - every piece of dynamically allocated memory must have a limit. Python integers too. Fun fact - according to NASA docs, Curiosity rover doesn't (or at least shouldn't) have any piece of dynamically allocated memory in its software.Employ simple application protocol. This means saying no to accepting anything pickled or ready-for-. Common formats have their vulnerabilities too - consult with OWASP before proceeding and use trusted libraries that have protection against known attacks (for example, see this wiki page about billion laughs XML).You can use a binary protocol in combination with  module to naturally limit sizes of your numbers to 4 bytes, 8 bytes, or to another arbitrary limit.Control your call stack. Don't use recursion (for whatever reason you think you need it) so you naturally avoid dealing with call stack issues. Don't make depth of your stack a function of program input.Control your compute resources. Make sure you control the number of concurrent computations in flight. Make sure computations can time out. Make sure the program can't hang the machine. Make sure you're not dealing with huge numbers - your program should try discard an expression early if it is complex enough.To illustrate. How would your server behave when given  input? A sum of two N-bit integers occupies up to N+1 bits. A product of two N-bit integers occupies up to 2N bits of memory. You can use these rules to predict at what point the size of result becomes unacceptable.Have a recovery strategy. If, after all, your application or server fails - how and in what cases can you help to make the app running again without manual intervention? Can you be notified when manual intervention is needed?


Answer URL
https://docs.python.org/3/library/pickle.html
https://docs.python.org/3/library/functions.html#eval
