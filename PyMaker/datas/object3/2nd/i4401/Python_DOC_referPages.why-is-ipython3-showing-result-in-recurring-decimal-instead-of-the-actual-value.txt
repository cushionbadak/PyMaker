Natural Text
This question already has an answer here:Is floating point math broken?                    28 answers                For simple calculation, like My ipython3 gives the resultinstead of   ??
iPython uses 64-bit floating-point arithmetic. However, floating-point arithmetic is really binary, internally expressed in terms of ones and zeroes.Floating-point arithmetic cannot determine something as simple as  or  exactly, meaning you still have roundoff errors. That is the binary equivalent of repeating/recurring decimals. The only workaround is to express these decimals as exact fractions or use an arbitrary precision or fixed-point library: https://docs.python.org/3/library/fractions.htmlIn fact, floating-point arithmetic can only exactly express some non-integer numbers  which can be expressed in the form  where  are in lowest terms,  are integers, and  is either  or a power of two. It cannot exactly express tenths, or anything where the denominator  is a multiple of five, or any number other than 1 or 2. This is much like how lowest-term fractions  cannt be exactly represented as a decimal if  contains any factors other than  and .And furthermore, you have to keep in mind of the most and least significant values: they cannot be too far apart:  as a double would drop the rightmost (least significant) 1.Here are some examples:100 = 100/1.  is 1, meaning 100 is integral. 100 is exactly represented.0.5 = 1/2.  is 2. 0.5 is exactly represented.0.125 = 1/8.  is a power of 2. 0.125 is exactly represented.0.9 = 9/10.  is 10, a multiple of 5. 0.9 cannot be exactly represented.0.92 = 41/50.  is 50, a multiple of 5. 0.92 also cannot be exactly represented.See Is Floating Point Math broken? for more information.


Answer URL
https://docs.python.org/3/library/fractions.html
