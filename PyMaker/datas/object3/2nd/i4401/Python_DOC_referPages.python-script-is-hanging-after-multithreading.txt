Natural Text
I know there are a few questions and answers related to hanging threads in Python, but my situation is slightly different as the script is hanging AFTER all the threads have been completed. The threading script is below, but obviously the first 2 functions are simplified massively. When I run the script shown, it works. When I use my real functions, the script hangs AFTER THE LAST LINE. So, all the scenarios are processed (and a message printed to confirm),  then collates all the results and writes to a csv.  is printed. And THEN it hangs.The script with threading functionality removed runs fine.I have tried enclosing the main script in  but no exception gets logged. If I use a debugger with a breakpoint on the final  and then step it forward, it hangs.I know there is not much to go on here, but short of including the whole 1500-line script, I don't know hat else to do. Any suggestions welcome! 
As the docs for  say:Remove and return an item from the queue. If optional args  is true and  is  (the default), block if necessary until an item is available. If  is a positive number, it blocks at most timeout seconds and raises the  exception if no item was available within that time. Otherwise ( is false), return an item if one is immediately available, else raise the  exception (timeout is ignored in that case).In other words, there is no way  can ever return , except by you calling  on the main thread, which you don't do.Notice that the example directly below those docs does this:The second one is technically necessary, but you usually get away with not doing it.But the first one is absolutely necessary. You need to either do this, or come up with some other mechanism to tell your workers to quit. Without that, your main thread just tries to exit, which means it tries to join every worker, but those workers are all blocked forever on a  that will never happen, so your program hangs forever.Building a thread pool may not be rocket science (if only because rocket scientists tend to need their calculations to be deterministic and hard real-time…), but it's not trivial, either, and there are plenty of things you can get wrong. You may want to consider using one of the two already-built threadpools in the Python standard library,  or . This would reduce your entire program to:Obviously you'll still need a lock around any mutable variables you change inside —although if you're only using a mutable variable there because you couldn't figure out how to return values to the main thread, that's trivial with an : just  the values from , and then you can use them like this:


Answer URL
https://docs.python.org/3/library/queue.html#queue.Queue.get
https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor
https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing.dummy
