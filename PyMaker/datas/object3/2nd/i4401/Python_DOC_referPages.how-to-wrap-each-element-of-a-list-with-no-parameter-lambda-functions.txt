Natural Text
I'm trying to create functions inside of a loop:The problem is that all functions end up being the same. Instead of returning 0, 1, and 2, all three functions return 2:Why is this happening, and what should I do to get 3 different functions that output 0, 1, and 2 respectively?
You're running into a problem with late binding -- each function looks up  as late as possible (thus, when called after the end of the loop,  will be set to ).  Easily fixed by forcing early binding: change  to  like this:Default values (the right-hand  in  is a default value for argument name , which is the left-hand  in ) are looked up at  time, not at  time, so essentially they're a way to specifically looking for early binding.If you're worried about  getting an extra argument (and thus potentially being called erroneously), there's a more sophisticated way which involved using a closure as a "function factory":and in your loop use  instead of the  statement.
The ExplanationThe issue here is that the value of  is not saved when the function  is created. Rather,  looks up the value of  when it is called.If you think about it, this behavior makes perfect sense. In fact, it's the only reasonable way functions can work. Imagine you have a function that accesses a global variable, like this:When you read this code, you would - of course - expect it to print "bar", not "foo", because the value of  has changed after the function was declared. The same thing is happening in your own code: By the time you call , the value of  has changed and been set to .The SolutionThere are actually many ways to solve this problem. Here are a few options:Force early binding of  by using it as a default argumentUnlike local variables (like ), default arguments are evaluated immediately when the function is defined:To give a little bit of insight into how/why this works: A function's default arguments are stored as an attribute of the function; thus the current value of  is snapshotted and saved.Use a function factory to capture the current value of  in a closureThe root of your problem is that  is a variable that can change. We can work around this problem by creating another variable that is guaranteed to never change - and the easiest way to do this is a closure:Use  to bind the current value of  to  lets you attach arguments to an existing function. In a way, it too is a kind of function factory.


Answer URL
https://docs.python.org/3/library/functools.html#functools.partial
