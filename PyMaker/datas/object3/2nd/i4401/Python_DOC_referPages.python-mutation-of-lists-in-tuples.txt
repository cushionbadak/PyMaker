Natural Text
After learning about lists and box-and-pointer diagrams, I decided to create random stuff for myself and test out my knowledge. I am going to use the words shallow copy and suspected shallow copies as I'm not really sure whether they are correct by definition. My queries are in the reasons provide for the behaviour of such code, please tell me whether I'm thinking soundly.Code AOutput A:Code BOutput B:I see TypeError in IDLE here, but the mutation of the list element is still done, and across ALL a,b,cContinuation from output B:Output C:Code D:Output D:From Output A, we observe the following:  1)For lists which have shallow copies, doing  does not affect the shallow copies. My reasons for the above could be a)  followed by  does  instead of (which is ), and doing  should not modify the object, only changing the value for one pointer(x and its hardcopy in this case)This is further supported in Output B but somehow contradicted in Output C, could be partly due to reason (b) below, but can't be too sure.b) We executed this in the first layer(only 1 slice operator), maybe there's some kind of rule which prevents these elements from being modified.This is supported by both Output B and Output C, though Output B might be argued to be in the first layer, think of it as increasing the elements in the 2nd layer, and it fits the above observation.2)What is the reason why the TypeError appeared in Output B, but is still executed? I know that whether an Exception might be triggered is based on the final sequence you are actually changing(the list in this case), but why is there still  ?I have presented my views for the above questions. I appreciate any thoughts(theoretical solutions preferably) on this question as I'm still relatively new to programming.
To answer question 1, which looks complex but whose answer is probably quite simple: when you have a another name referencing the original object, you will see the changes in the original. Those changes will not reflect in other copies (being those either shallow or deep) if(!) you change the objects using the form . This is because you are assigning a new object into , instead of making an in-place change like in .You can check that with the  function.To answer your question 2, and adapted from the official docs:let's make thenthis is the same asThe  changes the list in place, but then the assignment fails because you can't assign to a tuple (immutable type) index.If you makethe concatenation goes into a new list object, then the assignment to the tuple index fails too. But the new object gets lost.  wasn't changed in place.To clarify OP's comment, directly from the docs in here it says thatMany operations have an “in-place” version. Listed below are functions providing a more primitive access to in-place operators than the usual syntax does; for example, the statement x += y is equivalent to x = operator.iadd(x, y). Another way to put it is to say that z = operator.iadd(x, y) is equivalent to the compound statement z = x; z += y.In those examples, note that when an in-place method is called, the  computation and assignment are performed in two separate steps. The  in-place functions listed below only do the first step, calling the  in-place method. The second step, assignment, is not handled.As for your Output D:Writingdoes nothing more than writingreally,  is a new name referencing the same object that  references.This is because  is mutable and so a reference pointing to the original object is passed into local function name . Returning  just returns the same reference into .That's why you see further changes in  reflected in . Again you make  a new different object tuple by assignment, so now  and  reference a new tuple , while  and  still reference the old tuple object. And now because they are tuples you can't change them in place, like lists.As for the term "hardcopy", I wouldn't use it. It doesn't appear even once in official docs, and the mentions in Python SO questions beside this one, appear in other contexts. And it is ambiguous (contrary to "shallow" and "deep" which give a good clue for their meaning). I would think exactly the opposite (an object copy) for the term "hardcopy" you describe (an additional name/reference/pointer to the same object). Of course there are eventually many ways to say the same thing. We say "copy" because its shorter, and for immutables it doesn't matter if the copy happens or not (you can't change them anyway). For mutables saying "copy" usually means "shallow copy", because you have to "go further" in your code if you want a "deep copy".


Answer URL
https://docs.python.org/3/library/operator.html
