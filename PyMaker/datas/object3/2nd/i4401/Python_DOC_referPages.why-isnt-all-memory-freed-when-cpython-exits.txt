Natural Text
I want to be clear, I am not seeing the behavior described by this question. Instead my question is about the question itself:The python 3 official FAQ says this verbatim:Why isn't all memory freed when CPython exits?And provides this answer:Objects referenced from the global namespaces of Python modules are  not always deallocated when Python exits. This may happen if there are  circular references. There are also certain bits of memory that are  allocated by the C library that are impossible to free (e.g. a tool  like Purify will complain about these). Python is, however, aggressive  about cleaning up memory on exit and does try to destroy every single  object.If you want to force Python to delete certain things on deallocation  use the atexit module to run a function that will force those  deletions.This, assuming a managed memory operating system (Linux, Mac, Windows, GNU, BSD, Solaris...), sounds like total nonsense.On a program exiting (be it Python or anything else) any memory it requested from the OS is freed (as the OS has control of the virtual page tables, etc, etc). The program doesn't have to de-allocate or de-construct anything (something programs used to have to do, as highlighted by the time someone's use of  got bottlenecked by a hash table deconstruction), but I don't think any OS' Python 3 supports puts this requirement on programs.Does this make sense in some context I'm not aware of? What is this referring to?
The FAQ just says that cpython itself does not actively deallocate all the memory it has acquired when it terminatesIf you run cpython on a any normal server/desktop OS that releases all memory of a process when it exits, then there's no issue with memory leaks. The OS takes care of deallocating all memory when the process has exited.The FAQ is more to inform you that cpython does not call free() or similar on all the memory it has allocated with malloc() or similar. This can have consequences if you run cpython on an OS that does not release all memory acquired by the process when the process exits (These operating systems exists, it is in particular the case with many embedded kernels). And if you run cpython under a memory profiler/leak detector, that detector might report the memory not free()'d as leaks.
There are two cases in which this could make sense.First, running a memory leak analyzer on Python will report memory that hasn't been explicitly freed by the time Python exits, because it indicates a leak, even if it all gets cleaned up by the OS.Second, Python is designed to be embedded into other programs, and in such a situation, Python may be shut down (and even restarted) without the whole process ending. The OS will not clean up Python's memory until the whole process ends. See the tutorial for embedding Python in another application, and the Python C API docs.
I think the question in the FAQ is slightly disambiguous. The memory, once the Python process has exited is freed by the operating system and is able to be given to other processes. As you rightly point out, there is no way for the memory to be allocated (or not free) to a non-existent process.I think what the FAQ is referring to is that to is that while shutting down a python process, it is possible to end up in states where memory is still allocated to the process cannot be gracefully garbage collected and deallocated. This can happen (as the FAQ mentions) if you have circular references etc.


Answer URL
https://docs.python.org/3/faq/design.html#why-isn-t-all-memory-freed-when-cpython-exits
https://docs.python.org/3/library/atexit.html#module-atexit
https://docs.python.org/3/extending/embedding.html
https://docs.python.org/3/c-api/index.html
