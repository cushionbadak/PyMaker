Natural Text
I'm doing a lot of calculations with a python script. As it is CPU-bound my usual approach with the threading module didn't yield any performance improvements. I was now trying to use Multiprocessing instead of Multithreading to better use my CPU and speed up the lengthy calculations.I found some example codes here on stackoverflow, but I don't get the script to accept more than one argument. Could somebody help me out with this? I've never used these modules before an I'm pretty sure I'm using Pool.map wrong. - Any help is appreciated. Other ways to accomplish Multiprocessing are also welcome.
You are, as you suspected, using  wrong, in more ways than one.The point of  is to call a function on all elements of an iterable. Just like the builtin  function, but in parallel. If you want queue a single call, just use .For the problem you were specifically asking about:  takes a single-argument function. If you want to pass multiple arguments, you can modify or wrap your function to take a single tuple instead of multiple arguments (I'll show this at the end), or just use . Or, if you want to use , it takes a function of multiple arguments, but you pass  an argument tuple, not separate arguments.You need to call  on a  instance, not the  class. What you're trying to do is akin to try to  from the file type instead of reading from a particular open file.You're trying to close and join the  after every iteration. You don't want to do that until you've finished all of them, or your code will just wait for the first one to finish, and then raise an exception for the second one.So, the smallest change that would work is:Notice that I kept everything inside the  block—including the new  constructor. I won't show this in the later examples, but it's necessary for all of them, for reasons explained in the Programming guidelines section of the docs.1If you instead want to use one of the  functions, you need an iterable full of arguments, like this:Or, more simply:Assuming you're not using an old version of Python, you can simplify it even further by using the  in a  statement:One problem with using  or  is that it does extra work to make sure you get the results back in order. But you're just returning  and ignoring it, so why do that work? Using  doesn't have that problem.You can also replace  with , but there is no , so you'd need to wrap your function to not need :1. If you're using the  or  start methods—and  is the defaults on Windows—every child process does the equivalent of ing your module. So, all top-level code that isn't protected by a  guard will get run in every child. The module tries to protect you from some of the worst consequences of this (e.g., instead of forkbombing your computer with an exponential explosion of children creating new children, you will often get an exception), but it can't make the code actually work.
Try running  as 


Answer URL
https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.map
https://docs.python.org/3/library/functions.html#map
https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.apply_async
https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.starmap
https://docs.python.org/3/library/multiprocessing.html#programming-guidelines
