Natural Text
For a functionality for a program I'm currently working on, I need to be able to analyse a date and then return all the oncoming dates monthly.e.g. Insert: 13/04/2018 --> this is in the second week of April on a friday.Return: all the second friday's for the upcoming months (11/05/2018, 8/06/2018, 13/07/2018,...)Another limitation is that if the first day of one of the upcoming months falls on a saturday or sunday, this is not counted as the first week. The first week is counted from the first week there are more dates than just the weekend. Example: April 1st is on a Sunday, so the first week of April starts from the 2nd to the 8th. OR June 1st is on a Friday, so the first week of June is from 28th May to June 3th.I've tried doing some things, but it does not seem to return correct dates.Output:It looks like they're all off by one week, either one too much or one short.Basically, I get the day of the week (0-6) and then ask the first day of the current month. Then, using the calendar module I ask for all the weeks and their dates for that month and check in which week the inserted date is located. If the first_day of a month is on a saturday or sunday (6 or 7 using .isoweekday()) then we have to subtract one from the weeknumber to get the actual weeknumber.Then, I analyse all the further dates and if their first_day also falls on a saturday or sunday I have to add one to the tempWeek (which contains the original weekNumb) because I'm trying to extract the date from the week tuple I'm receiving from the calendar.I hope this kind of makes sense and my code is somewhat readable.
Your big problem is in your  loop when you're outputting the next 4 days of interest.  You have a line, , and you're setting tempWeek by the isoweek of that result.  The problem is, you don't update the month to reflect added_months.  This will throw everything off.  So, change the line toBut you also need to track years - it's great that you roll the month from 12 to 1, but when you do, you need to update the years, as well.  This won't impact your immediate test, but any others you try near the end of the year will be impacted.Doing that should solve your problem.Extra hints:I solved this simply by typing each line in the interactive python shell, and any time I set a variable, I looked at it afterwards.  As you get better at this, you'll likely learn to start using debuggers, which will give you the same effect but easier.I would recommend not stomping on .  What you did is perfectly valid, but it's weird that you're keeping some variables and stomping on others.  In keeping with the variable names you have, I would recommend , but in my code lower down, I change it to .It's also weird (but allowed) to overwrite  (an integer) with its string representation.  Again, I'd use a different variable, something like .  Having one variable do one thing usually makes for smoother reading.  In the sample code below, I get rid of the need for the string by taking advantage of the functionality of .It's generally good style to not put the results of your  statement on the same line as the .  Whitespace is really cheap nowadays, and it makes reading easier.Things are cleaner if the end result of your  loop is at the end instead of partway through.Also, you should aspire to be internally consistent with your names, either camelCase or underscored_names, but ideally not both.It's pythonic to avoid using for loops wherever possible, and usually if you use "for x in len(...", there's a more efficient way.  As mentioned in comments, enumerate can do that.A nice standard in python is to use  for variables you don't care about, like in your fixed for loop.The above code is the minimalist changes to getting your code working.  Below are the modifications I would make, given the hints I just mentioned.  Also, I included the import statements, since without them, the code is not executable.  We always try to post executable code here on Stack Overflow.
If you  will do what you expect for 2018-04-13.From your question I'm not sure what your expected output would be for 2018-09-01 (1st Saturday of September)  or 2018-01-29 (5th Friday in January). So you may want to change the month_week function to return the weeknumber of the month you expect it to be.
I've been playing around with this some more. The answers given were all helpful and helped me understand the problem further, thank you for that. You may see some code snippets from other people here that I've used. I decided to use the Calendar module to help me in this case.Output:What I do is ask for a start date and an end date (which follow eachother). Then, I ask the weeks and their dates using the calendar.monthdayscalendar(). I go over them and if in it finds a week where the weekday of the given date is not present, it removes it from the list because we won't need it. Then, here is where it became tricky: the platform that I'm gathering data from converts the fourth of something to the fifth of something when there's a fifth occurence for that day in that month.Example: I insert 2018-09-25, which is the fourth of Tuesday, but the next date will be 2018-10-30 which is the fifth Tuesday because there are five occurences in that month. It took me a while myself to find this (and also why I said in the beginning the weeks that start on saturday or sunday don't count, but that was not completely accurate: my apologies). Thus, if the month has five weeks and the original week number was 4, then we pop the first week because we won't need it and the index of the week number can stay the same to gather the right date. For the end date I simply keep on adding one day until the difference runs out. Once again, thank you all for your contributions. I tried looking at dateutil but because of the fact that a fourth something changes to a fifth something if there are five occurences in that month, this was not a solution.


Answer URL
https://docs.python.org/3/library/functions.html?highlight=enumerate#enumerate
