Natural Text
When a missing key is queried in a  object, the key is automatically added to the dictionary:However, often we want to only add keys when they are assigned explicitly or implicitly:One use case is simple counting, to avoid the higher overhead of , but this feature may also be desirable generally.Counter example [pardon the pun]This is the functionality I want:But  is significantly slower than . I find the performance hit usually ~2x slower vs .In addition, obviously  is only comparable to  argument in , while  can take , , etc.Is there a way to implement the above behaviour efficiently; for instance, by subclassing ?Benchmarking exampleTest code:Note Regarding Bounty Comment:@Aran-Fey's solution has been updated since Bounty was offered, so please disregard the Bounty comment.
Rather than messing about with  to make it do what we want, it seems easier to implement our own:This works the way you want:However, it can behave unexpectedly for mutable types:This is probably the reason why  remembers the value when a nonexistant key is accessed.Another option is to extend  and add a new method that looks up a value without remembering it:Note that the  method calls the  every time, regardless of whether the key already exists in the dict or not. If this is undesirable, you can implement it with a sentinel value instead:This has better support for mutable types, because it allows you to choose whether the value should be added to the dict or not.
If you just want a  that returns a default value when you access a non-existing key then you could simply subclass  and implement :Called by  to implement  for dict subclasses when  is not in the dictionary.That would look like this:In this case I used a -like approach so you have to pass in a  that should provide the default value when called:When you do assignments (explicitly or implicitly) the value will be added to the dictionary:You wondered how  is doing it and as of CPython 3.6.5 it also uses :Better performance?!You mentioned that speed is of concern, so you could make that class a C extension class (assuming you use CPython), for example using Cython (I'm using the Jupyter magic commands to create the extension class):BenchmarkBased on your benchmark:Given that this is just counting it would be an (unforgivable) oversight to not include a benchmark simply using the  initializer.I have recently written a small benchmarking tool that I think might come in handy here (but you could do it using  as well):With this result:Note that it uses log-log scale for better visibility of differences:For long iterables the  was by far the fastest.  and  were equal (with  being slightly faster most of the times, even if that's not visible here) followed by  and then  with the manual -loop. Funny how  is fastest and slowest.Implicitly add the returned value if it is modifieSomething I glossed over is the fact that it differs considerably from  because of the desired "just return the default don't save it" with mutable types:That means you actually need to set the element when you want the modified value to be visible in the dictionary.However this somewhat intrigued me so I want to share a way how you could make that work (if desired). But it's just a quick test and only works for  calls using a proxy. Please don't use that in production code (from my point of view this just has entertainment value):That's a dictionary that returns a proxy object (instead of the real default) and it overloads a method that, if called, adds the return value to the dictionary. And it "works":But it does have a few pitfalls (that could be solved but it's just a proof-of-concept so I won't attempt it here):If you really want something like that you probably need to implement a class that really tracks changes within the values (and not just  calls).If you want to avoid implicit assignmentsIn case you don't like the fact that  or similar operations add the value to the dictionary (opposed to the previous example which even tried to add the value in a very implicit fashion) then you probably should implement it as method instead of as special method.For example:Which is similar to the behavior of Aran-Feys answer but instead of  with a sentinel it uses a  and  approach.
Your bounty message says Aran-Fey's answer "does not work with mutable types". (For future readers, the bounty message is "The current answer is good, but it does not work with mutable types. If the existing answer can be adapted, or another option solution put forward, to suit this purpose, this would be ideal.")The thing is, it does work for mutable types:What doesn't work is something like :That's because this doesn't involve a store operation on the dict. The only dict operation involved is an item retrieval.There is no difference between what the dict object sees in  or . The dict is not involved in the  operation. Without nasty, fragile stack inspection or something similar, there is no way for the dict to store the list only for .So that's hopeless. What should you do instead?Well, one option is to use a regular , and just not use  when you don't want to store defaults. You can use  or :orAlternatively, you can turn off the default factory when you don't want it. This is frequently reasonable when you have separate "build" and "read" phases, and you don't want the default factory during the read phase:


Answer URL
https://docs.python.org/3/library/collections.html#collections.defaultdict
