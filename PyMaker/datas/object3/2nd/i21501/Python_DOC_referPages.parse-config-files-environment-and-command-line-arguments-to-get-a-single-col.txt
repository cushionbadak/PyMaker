Natural Text
Python's standard library has modules for configuration file parsing (configparser), environment variable reading (os.environ), and command-line argument parsing (argparse). I want to write a program that does all those, and also:Has a cascade of option values:default option values, overridden byconfig file options, overridden byenvironment variables, overridden bycommand-line options.Allows one or more configuration file locations specified on the command line with e.g. , and reads that (either instead of, or additional to, the usual configuration file). This must still obey the above cascade.Allows option definitions in a single place to determine the parsing behaviour for configuration files and the command line.Unifies the parsed options into a single collection of option values for the rest of the program to access without caring where they came from.Everything I need is apparently in the Python standard library, but they don't work together smoothly.How can I achieve this with minimum deviation from the Python standard library?
The argparse module makes this not nuts, as long as you're happy with a config file that looks like command line. (I think this is an advantage, because users will only have to learn one syntax.) Setting fromfile_prefix_chars to, for example, , makes it so that,is equivalent to if  is,You can even have your code look for  automatically by modifying The format of these configuration files is modifiable by making a subclass of ArgumentParser and adding a convert_arg_line_to_args method.
UPDATE:  I finally got around to putting this on pypi. Install latest version via:Full help and instructions are here.Original postHere's a little something that I hacked together. Feel free suggest improvements/bug-reports in the comments:TODOThis implementation is still incomplete.  Here's a partial TODO list:(easy) Interaction with parser defaults(easy) If type conversion doesn't work, check against how  handles error messages Conform to documented behavior(easy) Write a function that figures out  from  in , instead of relying on the  object(trivial) Write a  function which uses .  (e.g. copy  from the  implementation to guarantee it calls .)  Less Easy Stuff…I haven't tried any of this yet. It's unlikely—but still possible!—that it could just work…(hard?) Mutual Exclusion(hard?) Argument Groups  (If implemented, these groups should get a  in the config file.)(hard?) Sub Commands  (Sub-commands should also get a  in the config file.)
There's library that does exactly this called configglue.configglue is a library that glues together python's  optparse.OptionParser and ConfigParser.ConfigParser, so that you don't  have to repeat yourself when you want to export the same options to a  configuration file and a commandline interface.It also supports environment variables.There's also another library called ConfigArgParse which isA drop-in replacement for argparse that allows options to also be set  via config files and/or environment variables.You might be interested in PyCon talk about configuration by Łukasz Langa - Let Them Configure!
While I haven't tried it by my own, there is ConfigArgParse library which states that it does most of things that you want:A drop-in replacement for argparse that allows options to also be set via config files and/or environment variables.
It seems the standard library doesn't address this, leaving each programmer to cobble  and  and  all together in clunky ways.
The Python standard library does not provide this, as far as I know. I solved this for myself by writing code to use  and  to parse the command line and config files, and provide an abstraction layer on top of them. However, you would need this as a separate dependency, which from your earlier comment seems to be unpalatable.If you want to look at the code I wrote, it's at http://liw.fi/cliapp/. It's integrated into my "command line application framework" library, since that's a large part of what the framework needs to do.
To hit all those requirements, I would recommend writing your own library that uses both [opt|arg]parse and configparser for the underlying functionality. Given the first two and the last requirement, I'd say you want:Step one: Do a command line parser pass that only looks for the --config-file option. Step two: Parse the config file. Step three: set up a second command line parser pass using the output of the config file pass as the defaults.The third requirement likely means you have to design your own option definition system to expose all the functionality of optparse and configparser that you care about, and write some plumbing to do conversions in between.
I was tried something like this recently, using "optparse".I set it up as a sub-class of OptonParser, with a '--Store' and a '--Check' command.The code below should pretty much have you covered. You just need to define your own 'load' and 'store' methods which accept/return dictionaries and you're prey much set.
Here's a module I hacked together that reads command-line arguments, environment settings, ini files, and keyring values as well. It's also available in a gist.
The library confect I built is precisely to meet most of your needs. It can load configuration file multiple times through given file paths or module name.It loads configurations from environment variables with a given prefix.It can attach command line options to some click commands(sorry, it's not argparse, but click is better and much more advanced.  might support argparse in the future release).Most importantly,  loads Python configuration files not JSON/YMAL/TOML/INI. Just like IPython profile file or DJANGO settings file, Python configuration file is flexible and easier to maintain.For more information, please check the README.rst in the project repository. Be aware of that it supports only Python3.6 up.ExamplesAttaching command line optionsIt automatically creates a comprehensive help message with all properties and default values declared.Loading environment variablesIt only needs one line to load environment variables


Answer URL
