Natural Text
I have a subclass and I want it to not include a class attribute that's present on the base class.I tried this, but it doesn't work:How can I do this?
Think carefully about why you want to do this; you probably don't. Consider not making B inherit from A.The idea of subclassing is to specialise an object. In particular, children of a class should be valid instances of the parent class:If you implement this behaviour (with e.g. ), you are breaking the subclassing concept, and this is Bad.
You can use  to remove it from the class definition.Full example:
You don't need to delete it. Just override it. or simply don't reference it.Or consider a different design (instance attribute?).
Maybe you could set  as  and raise AttributeError whenever someone try to access it.
None of the answers had worked for me.For example  (or its exact equivalent, ) won't "hide" a parent method, because this is not how method resolution work. It would fail with  instead, as the subclass doesn't have . And, of course, replacing attribute with  doesn't actually remove it.Let's consider this base class:I know only two only ways to subclass it, hiding the  attribute:Using a descriptor class that raises  from . On attribute lookup, there will be an exception, generally indistinguishable from a lookup failure.The simplest way is just declaring a property that raises . This is essentially what @JBernardo had suggested.However, this only works for instances, and not for the classes (the  assertion would be broken).If you want all the assertions above to hold true, use this:I believe this is the most elegant method, as the code is clear, generic and compact. Of course, one should really think twice if removing the attribute is what they really want.Overriding attribute lookup with  magic method. You can do this either in a subclass (or a mixin, like in the example below, as I wanted to write it just once), and that would hide attribute on the subclass instances. If you want to hide the method from the subclass as well, you need to use metaclasses.This looks worse (more verbose and less generic) than the method above, but one may consider this approach as well.Note, this does not work on special ("magic") methods (e.g. ), because those bypass . Check out Special Method Lookup section of the Python documentation for more details. If this is what you need to undo, just override it and call 's implementation, skipping the parent.Needless to say, this only applies to the "new-style classes" (the ones that inherit from ), as magic methods and descriptor protocols aren't supported there. Hopefully, those are a thing of the past.
I'm had the same problem as well, and I thought I had a valid reason to delete the class attribute in the subclass:  my superclass (call it A) had a read-only property that provided the value of the attribute, but in my subclass (call it B), the attribute was a read/write instance variable.  I found that Python was calling the property function even though I thought the instance variable should have been overriding it.  I could have made a separate getter function to be used to access the underlying property, but that seemed like an unnecessary and inelegant cluttering of the interface namespace (as if that really matters).As it turns out, the answer was to create a new abstract superclass (call it S) with the original common attributes of A, and have A and B derive from S.  Since Python has duck typing, it does not really matter that B does not extend A, I can still use them in the same places, since they implicitly implement the same interface.
Trying to do this is probably a bad idea, but...It doesn't seem to be do this via "proper" inheritance because of how looking up  works by default. When getting  the  is first looked up in  and if it's not found there it's searched in , but on the other hand when setting or deleting  only  will be searched. So for exampleHere we see that first we doesn't seem to be able to delete  since it doesn't exist ( exists and is what gets served when you evaluate ). However by setting  to 6 the  will exist, it can be retrieved by  and deleted by  by which it ceases to exist so after that again  will be served as response to .What you could do on the other hand is to use metaclasses to make  raise :Now of course purists may yell that this breaks the LSP, but it's not that simple. It all boils down to if you consider that you've created a subtype by doing this. The  and  methods says yes, but LSP says no (and many programmers would assume "yes" since you inherit from ).The LSP means that if  is a subtype of  then we could use  whenever we could use , but since we can't do this while doing this construct we could conclude that  actually isn't a subtype of  and therefore LSP isn't violated.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__get__
https://docs.python.org/3/reference/datamodel.html#object.__getattribute__
https://docs.python.org/3/reference/datamodel.html#special-method-lookup
