Natural Text
I have a full inverted index in form of nested python dictionary. Its structure is :For example let the dictionary be called index, then for a word " spam ", entry would look like :I used this structure as python dict are pretty optimised and it makes programming easier.for any word 'spam', the documents containig it can be given by :and posting list for a document doc1 by:At present I am using cPickle to store and load this dictionary. But the pickled file is around 380 MB and takes a long time to load - 112 seconds(approx. I timed it using time.time()) and memory usage goes to 1.2 GB (Gnome system monitor). Once it loads, its fine. I have 4GB RAM. gives 229758CodeHow can I make it load faster? I only need to load it once, when the application starts. After that, the access time is important to respond to queries. Should I switch to a database like SQLite and create an index on its keys? If yes, how do I store the values to have an equivalent schema, which makes retrieval easy. Is there anything else that I should look into ?AddendumUsing  Tim's answer  the pickled file is considerably smaller - around 237 MB (took 300 seconds to dump)... and takes half the time to load now (61 seconds ... as opposed to 112 s earlier .... time.time()) But should I migrate to a database for scalability ? As for now I am marking Tim's answer as accepted. PS :I don't want to use Lucene or Xapian ...This question refers Storing an inverted index . I had to ask a new question because I wasn't able to delete the previous one.
Try the protocol argument when using /. From :Pickler(file, protocol=0) -- Create a pickler.This takes a file-like object for writing a pickle data stream.  The optional proto argument tells the pickler to use the given  protocol; supported protocols are 0, 1, 2.  The default  protocol is 0, to be backwards compatible.  (Protocol 0 is the  only protocol that can be written to a file opened in text  mode and read back successfully.  When using a protocol higher  than 0, make sure the file is opened in binary mode, both when  pickling and unpickling.)Protocol 1 is more efficient than protocol 0; protocol 2 is  more efficient than protocol 1.Specifying a negative protocol version selects the highest  protocol version supported.  The higher the protocol used, the  more recent the version of Python needed to read the pickle  produced.The file parameter must have a write() method that accepts a single  string argument.  It can thus be an open file object, a StringIO  object, or any other custom object that meets this interface.Converting JSON or YAML will probably take longer than pickling most of the time - pickle stores native Python types. 
Do you really need it to load all at once?  If you don't need all of it in memory, but only the select parts you want at any given time, you may want to map your dictionary to a set of files on disk instead of a single file… or map the dict to a database table. So, if you are looking for something that saves large dictionaries of data to disk or to a database, and can utilize pickling and encoding (codecs and hashmaps), then you might want to look at . provides a dictionary abstraction for writing to a database, including treating your filesystem as a database (i.e. writing the entire dictionary to a single file, or writing each entry to it's own file).  For large data, I often choose to represent the dictionary as a directory on my filesystem, and have each entry be a file.   also offers caching algorithms, so if you are using a filesystem backend for the dictionary you can avoid some speed penalty by utilizing memory caching. also has other flags such as  and  that can be used to customize how your data is stored (e.g. compression level, memory map mode, etc).It's equally easy (the same exact interface) to use a (MySQL, etc) database as a backend instead of your filesystem.  You can also turn off memory caching, so every read/write goes directly to the archive, simply by setting . provides access to customizing your encoding, by building a custom . also provides a lot of caching algorithms (like , , , etc), to help you manage your in-memory cache, and will use the algorithm do the dump and load to the archive backend for you.You can use the flag  to turn off memory caching completely, and directly read and write to and from disk or database. If your entries are large enough, you might pick to write to disk, where you put each entry in it's own file.  Here's an example that does both.However while this should greatly reduce load time, it might slow overall execution down a bit… it's usually better to specify the maximum amount to hold in memory cache and pick a good caching algorithm.  You have to play with it to get the right balance for your needs.Get  here: https://github.com/uqfoundation
A common pattern in Python 2.x is to have one version of a module implemented in pure Python, with an optional accelerated version implemented as a C extension; for example,  and . This places the burden of importing the accelerated version and falling back on the pure Python version on each user of these modules. In Python 3.0, the accelerated versions are considered implementation details of the pure Python versions. Users should always import the standard version, which attempts to import the accelerated version and falls back to the pure Python version. The pickle / cPickle pair received this treatment.Protocol version 0 is the original “human-readable” protocol and is backwards compatible with earlier versions of Python.Protocol version 1 is an old binary format which is also compatible with earlier versions of Python.Protocol version 2 was introduced in Python 2.3. It provides much more efficient pickling of new-style classes. Refer to PEP 307 for information about improvements brought by protocol 2.Protocol version 3 was added in Python 3.0. It has explicit support for bytes objects and cannot be unpickled by Python 2.x. This is the default protocol, and the recommended protocol when compatibility with other Python 3 versions is required.Protocol version 4 was added in Python 3.4. It adds support for very large objects, pickling more kinds of objects, and some data format optimizations. Refer to PEP 3154 for information about improvements brought by protocol 4.If your dictionary is huge and should only be compatible with Python 3.4 or higher, use:or:That said, in 2010 the  module was 25 times faster at encoding and 15 times faster at decoding simple types than . My 2014 benchmark says  >  > , but  coupled to specific Python versions.
Have you tried using an alternative storage format such as YAML or JSON? Python supports JSON natively from Python 2.6 using the  module I think, and there are third party modules for YAML.You may also try the  module.
Dependend on how long is 'long' you have to think about the trade-offs you have to make: either have all data ready in memory after (long) startup, or load only partial data (then you need to split up the date in multiple files or use SQLite or something like this). I doubt that loading all data upfront from e.g. sqlite into a dictionary will bring any improvement.


Answer URL
https://docs.python.org/3/whatsnew/3.0.html?highlight=cpickle#library-changes
https://docs.python.org/3/library/pickle.html#data-stream-format
