Natural Text
This question already has an answer here:What is the most “pythonic” way to iterate over a list in chunks?                    34 answers                I'm looking for a function that takes an iterable  and a size  and yields tuples of length  that are sequential values from :givesDoes such a function exist in the standard library?If it exists as part of the standard library, I can't seem to find it and I've run out of terms to search for. I could write my own, but I'd rather not.
See the  recipe in the docs for the   package (However, this is a duplicate of quite a few questions.)
When you want to group an iterator in chunks of  without padding the final group with a fill value, use :yieldsThere is an explanation of how it works in the second half of this answer.When you want to group an iterator in chunks of  and pad the final group with a fill value, use the grouper recipe :For example, in Python2:In Python3, what was  is now renamed :When you want to group a sequence in chunks of  you can use the  recipe:Note that, unlike iterators in general, sequences by definition have a length (i.e.  is defined).
How about this one? It doesn't have a fill value though.It utilizes a copy of the original iterable, which it exhausts for each successive splice. The only other way my tired brain could come up with was generating splice end-points with range.Maybe I should change  to  so it better corresponds to your output.
This is a very common request in Python. Common enough that it made it into the boltons unified utility package. First off, there are extensive docs here. Furthermore, the module is designed and tested to only rely on the standard library (Python 2 and 3 compatible), meaning you can just download the file directly into your project.There's an iterator/generator form for indefinite/long sequences as well:As you can see, you can also fill the sequence with a value of your choosing, as well. Finally, as the maintainer, I can assure you that, while the code has been downloaded/tested by thousands of developers, if you encounter any issues, you'll get the fastest support possible through the boltons GitHub Issues page. Hope this (and/or any of the other 150+ boltons recipes) helped!
I use the chunked function from the more_itertools package.
This is a very old quesiton, but I think it is useful to mention the following approach for the general case. Its main merit is that it only needs to iterate over the data once, so it will work with database cursors or other sequences that can only be used once. I also find it more readable.
I know this has been answered several times but I'm adding my solution which should improve in both, general applicability to sequences and iterators, readability (no invisible loop exit condition by StopIteration exception) and performance when compared to the grouper recipe. It is most similar to the last answer by Svein.
Here is a different solution which makes no use of itertools and, even though it has a couple more lines, it apparently outperforms the given answers when chunks are a lot shorter than the iterable lenght.However, for big chunks the other answers are much faster.



Answer URL
https://docs.python.org/3/glossary.html#term-sequence
