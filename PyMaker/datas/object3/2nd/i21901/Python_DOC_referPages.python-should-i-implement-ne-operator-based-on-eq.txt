Natural Text
I have a class where I want to override the  operator. It seems to make sense that I should override the  operator as well, but does it make sense to implement  based on  as such?Or is there something that I'm missing with the way Python uses these operators that makes this not a good idea?
Yes, that's perfectly fine.  In fact, the documentation urges you to define  when you define :There are no implied relationships  among the comparison operators. The  truth of  does not imply that   is false. Accordingly, when defining  , one should also define  so that the operators will behave as expected.In a lot of cases (such as this one), it will be as simple as negating the result of , but not always.
Python, should I implement  operator based on ?Short Answer: No. Use  instead of the In Python 3,  is the negation of  by default, so you are not even required to write a , and the documentation is no longer opinionated on writing one. Generally speaking, for Python 3-only code, don't write one unless you need to overshadow the parent implementation, e.g. for a builtin object.That is, keep in mind Raymond Hettinger's comment:The  method follows automatically from  only if   isn't already defined in a superclass.  So, if you're  inheriting from a builtin, it's best to override both.If you need your code to work in Python 2, follow the recommendation for Python 2 and it will work in Python 3 just fine.In Python 2, Python itself does not automatically implement any operation in terms of another - therefore, you should define the  in terms of  instead of the .E.G. See proof that implementing  operator based on  and not implementing  in Python 2 at allprovides incorrect behavior in the demonstration below.Long AnswerThe documentation for Python 2 says:There are no implied relationships among the comparison operators. The  truth of  does not imply that  is false. Accordingly, when  defining , one should also define  so that the  operators will behave as expected.So that means that if we define  in terms of the inverse of , we can get consistent behavior. This section of the documentation has been updated for Python 3:By default,  delegates to  and inverts the result  unless it is .and in the "what's new" section, we see this behavior has changed:  now returns the opposite of , unless  returns .For implementing , we prefer to use the  operator instead of using the  method directly so that if  of a subclass returns  for the type checked, Python will appropriately check  From the documentation:The  objectThis type has a single value. There is a single object with this value. This object is accessed through the built-in name  . Numeric methods and rich comparison methods may return  this value if they do not implement the operation for the operands  provided. (The interpreter will then try the reflected operation, or  some other fallback, depending on the operator.) Its truth value is  true.When given a rich comparison operator, if they're not the same type, Python checks if the  is a subtype, and if it has that operator defined, it uses the 's method first (inverse for , ,  and ). If  is returned, then it uses the opposite's method. (It does not check for the same method twice.) Using the  operator allows for this logic to take place.ExpectationsSemantically, you should implement  in terms of the check for equality because users of your class will expect the following functions to be equivalent for all instances of A.:That is, both of the above functions should always return the same result. But this is dependent on the programmer. Demonstration of unexpected behavior when defining  based on :First the setup:Instantiate non-equivalent instances:Expected Behavior:(Note: while every second assertion of each of the below is equivalent and therefore logically redundant to the one before it, I'm including them to demonstrate that order does not matter when one is a subclass of the other.)These instances have  implemented with :These instances, testing under Python 3, also work correctly:And recall that these have  implemented with  - while this is the expected behavior, the implementation is incorrect:Unexpected Behavior:Note that this comparison contradicts the comparisons above ().and,Don't skip  in Python 2For evidence that you should not skip implementing  in Python 2, see these equivalent objects:The above result should be !Python 3 sourceThe default CPython implementation for  is in  in :Here we seeBut the default  uses ?Python 3's default  implementation detail at the C level uses  because the higher level  (PyObject_RichCompare) would be less efficient - and therefore it must also handle .If  is correctly implemented, then the negation of  is also correct - and it allows us to avoid low level implementation details in our .Using  allows us to keep our low level logic in one place, and avoid addressing  in .One might incorrectly assume that  may return .It actually uses the same logic as the default implementation of , which checks for identity (see do_richcompare and our evidence below)And the comparisons:PerformanceDon't take my word for it, let's see what's more performant:I think these performance numbers speak for themselves:This makes sense when you consider that  is doing logic in Python that would otherwise be handled on the C level.Response to some criticsAnother answerer writes:Aaron Hall’s implementation  of the  method is incorrect as it can never return  ( is ) and therefore the  method that has priority can never fall back on the  method that does not have priority.Having  never return  does not make it incorrect. Instead, we handle prioritization with  via the check for equality with . Assuming  is correctly implemented, we're done. used to be the default Python 3 implementation of the  method but it was a bug and it was corrected in Python 3.4 on January 2015, as ShadowRanger noticed (see issue #21408).Well, let's explain this. As noted earlier, Python 3 by default handles  by first checking if  returns  (a singleton) - which should be checked for with  and returned if so, else it should return the inverse. Here is that logic written as a class mixin:This is necessary for correctness for C level Python API, and it was introduced in Python 3, making the  methods in this patch to close Issue 21408 andthe  methods in the follow-on cleanup removed hereredundant. All relevant  methods were removed, including ones implementing their own check as well as ones that delegate to  directly or via  - and  was the most common way of doing so.ConclusionFor Python 2 compatible code, use  to implement . It is more:correctsimpleperformantIn Python 3 only, use the low-level negation on the C level - it is even more simple and performant (though the programmer is responsible for determining that it is correct).Again, do not write low-level logic in high level Python.
Just for the record, a canonically correct and cross Py2/Py3 portable  would look like:This works with any  you might define:Unlike , doesn't interfere with in some annoying/complex cases involving comparisons where one of the classes involved doesn't imply that the result of  is the same as the result of  on  (e.g. SQLAlchemy's ORM, where both  and  return special proxy objects, not  or , and trying to  the result of  would return , rather than the correct proxy object). Unlike , this correctly delegates to the  of the other instance when  returns  ( would be extra wrong, because  is truthy, so when  didn't know how to perform the comparison,  would return , implying that the two objects were equal when in fact the only object asked had no idea, which would imply a default of not equal)If your  doesn't use  returns, this works (with meaningless overhead), if it does use  sometimes, this handles it properly. And the Python version check means that if the class is -ed in Python 3,  is left undefined, allowing Python's native, efficient fallback  implementation (a C version of the above) to take over.Why this is neededPython overloading rulesThe explanation of why you do this instead of other solutions is somewhat arcane. Python has a couple general rules about overloading operators, and comparison operators in particular:(Applies to all operators) When running , try , and if that returns , try . Exception: If  is a subclass of 's class, then test  first. In the case of comparison operators,  and  are their own "rop"s (so the test order for  is , then , reversed if  is a subclass of 's class)Aside from the idea of the "swapped" operator, there is no implied relationship between the operators. Even for instance of the same class,  returning  does not imply  returns  (in fact, the operators aren't even required to return boolean values; ORMs like SQLAlchemy intentionally do not, allowing for a more expressive query syntax). As of Python 3, the default  implementation behaves this way, but it's not contractual; you can override  in ways that aren't strict opposites of .How this applies to overloading comparatorsSo when you overload an operator, you have two jobs:If you know how to implement the operation yourself, do so, using only your own knowledge of how to do the comparison (never delegate, implicitly or explicitly, to the other side of the operation; doing so risks incorrectness and/or infinite recursion, depending on how you do it)If you don't know how to implement the operation yourself, always return , so Python can delegate to the other operand's implementationThe problem with never delegates to the other side (and is incorrect if  properly returns ). When  returns  (which is "truthy"), you silently return , so  returns , when it should have checked if  knew how to compare to instances of , and if it doesn't, it should have returned  (since if neither side knows how to compare to the other, they're considered not equal to one another). If  is incorrectly implemented (returning  instead of  when it doesn't recognize the other side), then this is "correct" from 's perspective, returning  (since  doesn't think it's equal, so it's not equal), but it might be wrong from 's perspective, since it never even asked ;  ends up , but  could , or any other return value.The problem with is more subtle. It's going to be correct for 99% of classes, including all classes for which  is the logical inverse of . But  breaks both of the rules mentioned above, which means for classes where  isn't the logical inverse of , the results are once again non-reflexive, because one of the operands is never asked if it can implement  at all, even if the other operand can't. The simplest example is a weirdo class which returns  for all comparisons, so  and  both return . With a correct implementation of  (one which returns  when it doesn't know how to do the comparison), the relationship is reflexive;  and  agree on the outcome (because in the former case,  returns , then  returns , while in the latter,  returns  directly). But when  is implemented as ,  returns  (because  returns, not , then  returns , and  inverts that to ), while  returns You can see an example of this in action here.Obviously, a class that always returns  for both  and  is a little strange. But as mentioned before,  and  don't even need to return /; the SQLAlchemy ORM has classes with comparators that returns a special proxy object for query building, not / at all (they're "truthy" if evaluated in a boolean context, but they're never supposed to be evaluated in such a context).By failing to overload  properly, you will break classes of that sort, as the code:will work (assuming SQLAlchemy knows how to insert  into a SQL string at all; this can be done with type adapters without  having to cooperate at all), passing the expected proxy object to , while:will end up passing  a plain , because  returns a proxy object, and  just converts the truthy proxy object to . Hopefully,  throws an exception on being handled invalid arguments like . While I'm sure many will argue that  should be consistently on the left hand side of the comparison, the fact remains that there is no programmatic reason to enforce this in the general case, and a correct generic  will work either way, while  only works in one arrangement.
Short answer: yes (but read the documentation to do it right)ShadowRanger's implementation of the  method is the correct one (in the sense that it behaves exactly like the default Python 3 implementation):Aaron Hall’s implementation  of the  method is incorrect as it can never return  ( is ) and therefore the  method that has priority can never fall back on the  method that does not have priority.  used to be the default Python 3 implementation of the  method but it was a bug and it was corrected in Python 3.4 on January 2015, as ShadowRanger noticed (see issue #21408).Implementation of the comparison operatorsThe Python Language Reference for Python 3 states in its chapter III Data model:These are the so-called “rich comparison” methods. The correspondence  between operator symbols and method names is as follows:  calls  ,  calls ,  calls ,   calls ,  calls , and   calls .A rich comparison method may return the singleton  if  it does not implement the operation for a given pair of arguments.There are no swapped-argument versions of these methods (to be used  when the left argument does not support the operation but the right  argument does); rather,  and  are each other’s  reflection,  and  are each other’s reflection, and   and  are their own reflection. If the operands  are of different types, and right operand’s type is a direct or  indirect subclass of the left operand’s type, the reflected method of  the right operand has priority, otherwise the left operand’s method  has priority. Virtual subclassing is not considered.Translating this into Python code gives (using  for ,  for ,  for ,  for ,  for  and  for ):Default implementation of the comparison methodsThe documentation adds:By default,  delegates to  and inverts the result  unless it is . There are no other implied  relationships among the comparison operators, for example, the truth  of  does not imply .The default implementation of the comparison methods (, , , ,  and ) can thus be given by:So this is the correct implementation of the  method. And it does not always return the inverse of the  method because when the  method returns , its inverse  is  (as  is ) instead of the desired .Incorrect implementations of As Aaron Hall demonstrated above,  is not the default implementation of the  method. But nor is . The latter is demonstrated below by comparing the behavior of the default implementation with the behavior of the  implementation in two cases:the  method returns ;the  method returns a value different from .Default implementationLet’s see what happens when the  method uses the default implementation and the  method returns : calls . calls . returns . calls . returns .This shows that when the  method returns , the  method falls back on the  method.Now let’s see what happens when the  method uses the default implementation and the  method returns a value different from : calls . calls . returns . returns , that is .This shows that in this case, the  method returns the inverse of the  method. Thus the  method behaves like advertised in the documentation.Overriding the default implementation of the  method with the correct implementation given above yields the same results. implementationLet’s see what happens when overriding the default implementation of the  method with the  implementation and the  method returns : calls . calls . calls . returns . calls . returns . returns , that is . returns , that is .The default implementation of the  method returned , not .Now let’s see what happens when overriding the default implementation of the  method with the  implementation and the  method returns a value different from : calls . calls . calls . returns . returns , that is .The default implementation of the  method also returned  in this case.Since this implementation fails to replicate the behavior of the default implementation of the  method when the  method returns , it is incorrect.
If all of , , , , , and  make sense for the class, then just implement  instead. Otherwise, do as you're doing, because of the bit Daniel DiPaolo said (while I was testing it instead of looking it up ;) )


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__ne__
https://docs.python.org/3/c-api/object.html#c.PyObject_RichCompare
