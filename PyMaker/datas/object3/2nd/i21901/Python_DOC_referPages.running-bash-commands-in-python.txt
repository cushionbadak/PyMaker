Natural Text
On my local machine, I run a python script which contains this lineThis works fine.Then I run the same code on a server and I get the following error messageSo what I did then is I inserted a "print bashCommand" which prints me than the command in the terminal before it runs it with os.system().Of course, I get again the error (caused by os.system(bashCommand)) but before that error it prints the command in the terminal. Then I just copied that output and did a copy paste into the terminal and hit enter and it works...Does anyone have a clue what's going on?
Don't use . It has been deprecated in favor of subprocess. From the docs: "This module intends to replace several older modules and functions: , ".Like in your case:
To somewhat expand on the earlier answers here, there are a number of details which are commonly overlooked.Prefer  over  and friends over  over  over  over Understand and probably use , aka .Understand the meaning of  or  and how it changes quoting and the availability of shell conveniences.Understand differences between  and BashUnderstand how a subprocess is separate from its parent, and generally cannot change the parent.Avoid running the Python interpreter as a subprocess of Python.These topics are covered in some more detail below.Prefer  or The  function is a low-level workhorse but it is tricky to use correctly and you end up copy/pasting multiple lines of code ... which conveniently already exist in the standard library as a set of higher-level wrapper functions for various purposes, which are presented in more detail in the following.Here's a paragraph from the documentation:The recommended approach to invoking subprocesses is to use the  function for all use cases it can handle. For more advanced use cases, the underlying  interface can be used directly.Unfortunately, the availability of these wrapper functions differs between Python versions. was officially introduced in Python 3.5. It is meant to replace all of the following. was introduced in Python 2.7 / 3.1. It is basically equivalent to  was introduced in Python 2.5.  It is basically equivalent to  was introduced in Python 2.4 in the original  module (PEP-324). It is basically equivalent to High-level API vs The refactored and extended  is more logical and more versatile than the older legacy functions it replaces.  It returns a  object which has various methods which allow you to retrieve the exit status, the standard output, and a few other results and status indicators from the finished subprocess. is the way to go if you simply need a program to run and return control to Python. For more involved scenarios (background processes, perhaps with interactive I/O with the Python parent program) you still need to use  and take care of all the plumbing yourself. This requires a fairly intricate understanding of all the moving parts and should not be undertaken lightly.  The simpler  object represents the (possibly still-running) process which needs to be managed from your code for the remainder of the lifetime of the subprocess.It should perhaps be emphasized that just  merely creates a process. If you leave it at that, you have a subprocess running concurrently alongside with Python, so a "background" process. If it doesn't need to do input or output or otherwise coordinate with you, it can do useful work in parallel with your Python program.Avoid  and Since time eternal (well, since Python 2.5) the  module documentation has contained the recommendation to prefer  over :The  module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using this function.The problems with  are that it's obviously system-dependent and doesn't offer ways to interact with the subprocess. It simply runs, with standard output and standard error outside of Python's reach. The only information Python receives back is the exit status of the command (zero means success, though the meaning of non-zero values is also somewhat system-dependent).PEP-324 (which was already mentioned above) contains a more detailed rationale for why  is problematic and how  attempts to solve those issues. used to be even more strongly discouraged:Deprecated since version 2.6: This function is obsolete. Use the  module.However, since sometime in Python 3, it has been reimplemented to simply use , and redirects to the  documentation for details.Understand and usually use You'll also notice that  has many of the same limitations as . In regular use, you should generally check whether the process finished successfully, which  and  do (where the latter also returns the standard output of the finished subprocess). Similarly, you should usually use  with  unless you specifically need to allow the subprocess to return an error status.In practice, with  or , Python will throw a  exception if the subprocess returns a nonzero exit status.A common error with  is to omit  and be surprised when downstream code fails if the subprocess failed.On the other hand, a common problem with  and  was that users who blindly used these functions were surprised when the exception was raised e.g. when  did not find a match. (You should probably replace  with native Python code anyway, as outlined below.)All things counted, you need to understand how shell commands return an exit code, and under what conditions they will return a non-zero (error) exit code, and make a conscious decision how exactly it should be handled.Understand and probably use  aka Since Python 3, strings internal to Python are Unicode strings. But there is no guarantee that a subprocess generates Unicode output, or strings at all.(If the differences are not immediately obvious, Ned Batchelder's Pragmatic Unicode is recommended, if not outright obligatory, reading. There is a 36-minute video presentation behind the link if you prefer, though reading the page yourself will probably take significantly less time.)Deep down, Python has to fetch a  buffer and interpret it somehow. If it contains a blob of binary data, it shouldn't be decoded into a Unicode string, because that's error-prone and bug-inducing behavior - precisely the sort of pesky behavior which riddled many Python 2 scripts, before there was a way to properly distinguish between encoded text and binary data.With , you tell Python that you, in fact, expect back textual data in the system's default encoding, and that it should be decoded into a Python (Unicode) string to the best of Python's ability (usually UTF-8 on any moderately up to date system, except perhaps Windows?)If that's not what you request back, Python will just give you  strings in the  and  strings. Maybe at some later point you do know that they were text strings after all, and you know their encoding. Then, you can decode them.Python 3.7 introduced the shorter and more descriptive and understandable alias  for the keyword argument which was previously somewhat misleadingly called .Understand  vs With  you pass a single string to your shell, and the shell takes it from there.With  you pass a list of arguments to the OS, bypassing the shell.When you don't have a shell, you save a process and get rid of a fairly substantial amount of hidden complexity, which may or may not harbor bugs or even security problems.On the other hand, when you don't have a shell, you don't have redirection, wildcard expansion, job control, and a large number of other shell features.A common mistake is to use  and then still pass Python a list of tokens, or vice versa. This happens to work in some cases, but is really ill-defined and could break in interesting ways.The common retort "but it works for me" is not a useful rebuttal unless you understand exactly under what circumstances it could stop working.Refactoring ExampleVery often, the features of the shell can be replaced with native Python code.  Simple Awk or  scripts should probably simply be translated to Python instead.To partially illustrate this, here is a typical but slightly silly example which involves many shell features.Some things to note here:With  you don't need the quoting that the shell requires around strings. Putting quotes anyway is probably an error.It often makes sense to run as little code as possible in a subprocess. This gives you more control over execution from within your Python code.Having said that, complex shell pipelines are tedious and sometimes challenging to reimplement in Python.The refactored code also illustrates just how much the shell really does for you with a very terse syntax -- for better or for worse. Python says explicit is better than implicit but the Python code is rather verbose and arguably looks more complex than this really is. On the other hand, it offers a number of points where you can grab control in the middle of something else, as trivially exemplified by the enhancement that we can easily include the host name along with the shell command output. (This is by no means challenging to do in the shell, either, but at the expense of yet another diversion and perhaps another process.)Common Shell ConstructsFor completeness, here are brief explanations of some of these shell features, and some notes on how they can perhaps be replaced with native Python facilities.Globbing aka wildcard expansion can be replaced with  or very often with simple Python string comparisons like .  Bash has various other expansion facilities like  brace expansion and  as well as tilde expansion ( expands to your home directory, and more generally  to the home directory of another user)Redirection allows you to read from a file as your standard input, and write your standard output to a file.  opens  for writing and  for reading, and passes its contents as standard input to , whose standard output then lands in . This is not generally hard to replace with native Python code.Pipelines are a form of redirection.  runs two subprocesses, where the standard output of  is the standard input of  (on the OS level, in Unix-like systems, this is a single file handle). If you cannot replace one or both ends of the pipeline with native Python code, perhaps think about using a shell after all, especially if the pipeline has more than two or three processes  (though look at the  module in the Python standard library or a number of more modern and versatile third-party competitors).Job control lets you interrupt jobs, run them in the background, return them to the foreground, etc.  The basic Unix signals to stop and continue a process are of course available from Python, too. But jobs are a higher-level abstraction in the shell which involve process groups etc which you have to understand if you want to do something like this from Python.Understand differences between  and Bash runs your shell commands with  unless you specifically request otherwise (except of course on Windows, where it uses the value of the  variable). This means that various Bash-only features like arrays,  etc are not available.If you need to use Bash-only syntax, you can pass in the path to the shell as  (where of course if your Bash is installed somewhere else, you need to adjust the path).A  is separate from its parent, and cannot change itA somewhat common mistake is doing something likewhich aside from the lack of elegance also betrays a fundamental lack of understanding of the "sub" part of the name "subprocess".A child process runs completely separate from Python, and when it finishes, Python has no idea what it did (apart from the vague indicators that it can infer from the exit status and output from the child process).  A child generally cannot change the parent's environment; it cannot set a variable, change the working directory, or, in so many words, communicate with its parent without cooperation from the parent.The immediate fix in this particular case is to run both commands in a single subprocess;though obviously this particular use case doesn't require the shell at all.  Remember, you can manipulate the environment of the current process (and thus also its children) viaor pass an environment setting to a child process with(not to mention the obvious refactoring ; but  is a poor example of something to run in a subprocess in the first place, of course).Don't run Python from PythonThis is slightly dubious advice; there are certainly situations where it does make sense or is even an absolute requirement to run the Python interpreter as a subprocess from a Python script. But very frequently, the correct approach is simply to  the other Python module into your calling script and call its functions directly.If the other Python script is under your control, and it isn't a module, consider turning it into one.  (This answer is too long already so I will not delve into details here.)If you need parallelism, you can run Python functions in subprocesses with the  module.  There is also  which runs multiple tasks in a single process (which is more lightweight and gives you more control, but also more constrained in that threads within a process are tightly coupled, and bound to a single GIL.)
Call it with subprocessThe error you are getting seems to be because there is no swap module on the server, you should install swap on the server then run the script again
It is possible you use the bash program, with the parameter -c for execute the commands:
You can use 'subprocess', but I always felt that it was not a 'Pythonic' way of doing it. So I created Sultan (shameless plug) that makes it easy to run command line functions.https://github.com/aeroxis/sultan
According to the error you are missing a package named swap on the server. This  requires it. If you're on Ubuntu/Debian, install  using aptitude.
To run the command without a shell, pass the command as a list and implement the redirection in Python using :Note: no  at the end.  implements the redirection.To run the command using the shell in Python, pass the command as a string and enable :Here's the shell is responsible for the output redirection ( is in the command).To run a bash command that uses bashisms, specify the bash executable explicitly e.g., to emulate bash process substitution:
Also you can use 'os.popen'.Example:Output:
The pythonic way of doing this is using  takes a list where the first element is the command to be run followed by any command line arguments.As an example:


Answer URL
https://docs.python.org/3/library/subprocess.html
https://docs.python.org/3/library/subprocess.html#using-the-subprocess-module
https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess
https://docs.python.org/3/library/subprocess.html#subprocess.Popen
https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError
https://docs.python.org/3/library/multiprocessing.html?highlight=multiprocessing
https://docs.python.org/3/library/threading.html#module-threading
https://docs.python.org/3/glossary.html#term-global-interpreter-lock
https://docs.python.org/3/library/shlex.html#shlex.split
