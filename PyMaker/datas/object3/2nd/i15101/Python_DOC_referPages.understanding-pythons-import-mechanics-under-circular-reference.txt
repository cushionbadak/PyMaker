Natural Text
I was playing with examples in order to answer a question posted here on SO and found hard to understand the mechanics through which python's  messes up the scope. First a bit of context: this question does not deal with practical issue; I understand well that  is frowned upon (rightly so) and I grasp that it is for reasons deeper than clarity in the code. My interest here is in understanding the mechanics that causes bad behaviour with circular s. In other words, I understand that the observed behaviour is expected; I don't understand why.The situation I'm not able to understand are the problems that arise when having, from an imported module (), a reference to the importing module (), using . I managed to observe subtle differences in behaviour when the importing module uses  or not, but the overall (bad) behaviour is the same. I couldn't find any clear explanation neither in the documentation nor on SO.   Investigating the behaviour through what is available on the scope, I managed to build a small example that illustrates the differences in its content based on the above mentioned question and a few searches I did here in SO and elsewhere. I try to demonstrate as concisely as I can. All code and experiments below were done with python 2.7.8.Working scenariosFirst a trivial module containing a trivial module containing one class, :A first variant of client code, importing module a, :Second variant of the same code, importing  from module , :Running both  and  produce the same output before the import, and both are able to instantiate A, as expected. After the import, however, again, as expected, they differ. I highlight the difference:, has in the scopewhile  does not, but has Both before and after the import, the scope contains  set to .Both variants succeed in instantiating .Not working scenariosThe intriguing behaviour is when changing  to contain a circular reference to  (in both the  and  variants). Adjusted code of :(for shortness's sake, only one case of  is shown; obviously in the case of  the import is for this module, not )In my observations of the contents of the scope in the scenario with a circular reference, I see: In both variants, before the import in ,  is similar to the cases above. After the import, however, it is changed and contains a  of 'ArithmeticError': ,'AssertionError': ,'AttributeError': ,...which is needlessly long to paste here.The changed  is present twice. This I can understand as being consequence of the importing and would probably not happen if the code were inside a function.In variant  the module  is present in the scope; it is present in variant . In both variants, instantiation of  fails. Given that in variant  the module is present in the scope (therefore, I assume was successfully imported), I had expected to be able to instantiate . This is not the case. There are differences, however: in case , it fails with an  and, as for , failure is a . In this later case, it is always the same error independently of whether I try to instantiate as  (as in the working example) of .Summarizing my questions: Through what mechanics a circular  messes up the scope? Why is it not possible to instantiate  in the case b_v1, although the module is in the scope?
Python modules are executed from top to bottom.  Import statements are executable just like any other.  When an import statement is run, it does these things (simplified for expository purposes, see the language reference for full details):Check whether the module is listed in .  If it is, return it immediatelyFind the module (usually but not always by searching through the filesystem).Create an empty entry for the module in , with an empty namespace.Execute the module from top to bottom within the newly-created namespace.Suppose we have files like this:::Further suppose that  gets imported first.  Let's go through this line-by-line:Someone else imports .  A reference to  is stored in  before we even begin executing it. runs .  This translates to " and then grab everything out of 's namespace into 's namespace."Python places an empty module object in  runs .  Python imports .The import of  returns immediately since  exists.Since  hasn't yet executed ,  doesn't yet exist, so it cannot be dumped into 's namespace. crashes on a .


Answer URL
https://docs.python.org/3/reference/simple_stmts.html#the-import-statement
