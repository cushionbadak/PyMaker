Natural Text
I've got fed up of continually typing the same, repetitive commands over and over again in my  function. I was wondering if I could write a decorator to do the work for me. Here's an example of my question:Is there some way in which I can automatically have all arguments passed into the function become instance variables with the same names? For example:Where  would automatically set  and . How could I do this?Thanks!EDIT: I should mention that I use CPython 2.7.
Here is my first try at the decorator:[EDIT second try: I added handling defaults for variables and checking for valid keywords. Thanks ivan_pozdeev ][EDIT 3: Added check for defaults is not None]Here is a example:
You could do this:But this is probably not a real improvement, readability-wise.
I disagree that this is useful. I find that forcing developers (including myself) to type out the painful boilerplate of member variable initiation is a good way to deter people from having  methods that accept a ridiculous number of arguments, which are turned into a ridiculous number of member variables. This happens a lot when someone wants to extend the features available in a class through the use of extra arguments, feature flags, and boolean switch variables that control customized instantiation. I consider all of those to be deficient ways to handle the need for accommodating new or optional extended complexity.Being required to type out this particular kind of boilerplate is like a tax on class bloatedness. If you find yourself accepting so many args in  that you need this feature, it's usually a good indicator that you should refactor your design with smaller, compartmentalized classes, maybe a MixIn design.Nonetheless, here is one way to do it without the misdirection of the decorator. I didn't make an attempt to handle  but then again in this particular case you would have to define special logic for what unnamed positional arguments meant anyway.Prints:
For Python 3.3+:Demo:A non-decorator approach for both Python 2 and 3 using frames:Demo: 
You can either use reflection to reduce code duplication(or almost equivalent ( must not be a meta-variable name))Or use CPython's implementation details to retrieve argument names from runtime as per Getting method parameter names in pythonThe 2nd approach appears more "automated" but, as I've said, it turns out to be rather inflexible. If your argument list is longer than 3-4, you probably only need to handle some of the arguments this way, in which case, you have no other options but to construct their list by hand.
I am searching for an autoinit decorator and come across this thread.I couldn't find any @autoinit in the web that handles variable arguments, variable keywords and the keyword-only arguments.  Inspired by the other solutions, I wrote my own version that support everything.I did some testing, it seems to work fine in all scenarios, but I haven't exhaustively test the code.  Let me know if it has a bug.   Thanks.


Answer URL
https://docs.python.org/3/library/inspect.html#introspecting-callables-with-the-signature-object
