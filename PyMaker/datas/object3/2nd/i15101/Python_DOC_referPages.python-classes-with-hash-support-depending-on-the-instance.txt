Natural Text
I have a mutable class in Python which I would like to be able to "freeze", at that point its immutable, therefor can have a  function.My concern is, will having the  function present will make Python behave strangely because it may check for the existence of a hash function.I realize I could use a subclass that has a hash function, copy the class to a subtype. But I'm interested to know if having an optional hash function is supported by Python.In the example below it works in basic cases (but may fail in others).Note: This assumes you don't touch  or  directly and only use access methods.Note: its probably more Pythonic not to use this method and instead have a  class, but Im curious if this can be considered to be supported in Python or not.Adding a note on the real-world use-case, We have some linear math module with Vector/Matrix/Quaternion/Euler classes. In some cases we want to have for eg, a "set of matrices" or a "dict with vector keys". Its always possible to expand them into tuples but they take up more memory & loose their abilities to behave a our own math types - so the ability to freeze them is attractive.
The original example didn't quite work "sensibly", because the class had  but not , and as https://docs.python.org/3/reference/datamodel.html#object.hash says "If a class does not define an eq() method it should not define a hash() operation either".  But the OP's edit fixed that side issue.This done, if the class and its instances are indeed used with the discipline outlined, behavior should comply with the specs: instances are "born unhashable" but "become hashable" -- "irreversibly" given said discipline, and only, of course, if their  is in turn hashable -- once their  method is called.Of course  will "mis-classify" unfrozen instances (as it only checks for the presence of , not its actual working), but that is hardly unique behavior:That  does appear "hashable", like all tuples (since its type does define ) -- but if you in fact try ing it, you nevertheless get a , as one of the items is a  (making the whole not actually hashable!-).  Not-yet-frozen instances of the OP's class would behave similarly to such a tuple.An alternative which does avoid this little glitch (yet doesn't require potentially onerous copies of data) is to model the "freezing" as the instance "changing type in-place", e.g...:This behaves essentially like the original example (I've removed the "slots" to avoid issues with  errors on  assignment) but may be considered an improved object model since "changing type in-place" models well such irreversible changes in behavior (and as a small side effect  now behaves impeccably:-).The concept of an object "changing type in-place" freaks some out because few languages indeed would even tolerate it, and even in Python of course it's a rare thing to have a practical use case for such an obscure feature of the language.  However, use cases do exist -- which is why  assignment is indeed supported!-)


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__hash__
https://docs.python.org/3/reference/datamodel.html#object.__hash__
