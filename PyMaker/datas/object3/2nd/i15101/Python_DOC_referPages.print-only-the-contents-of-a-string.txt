Natural Text
Here's my code:output:If I include the argument  in the call to , then I get the desired output:For the sake of better understanding the mysterious world of programming with text in the modern (Unicode) age, I would like to know how to generate the second output without specifying .  In other words, what function do I call to convert  so that it will produce the desired output.A working example would go a long way.  Detailed explanations are nice, but they tend to be a bit confusing for the uninitiated -- maybe due to the use of overloaded terminology, maybe because of differences between Python2 and Python3, or maybe just because I very rarely need to think about text encoding in my line of work -- most of the tools that I work with don't require special handling like this.Also: I believe the first output is of type , but what is the type of the second output?  My guess is  with UTF-8 encoding.
As originally implied by Ignacio's comment, you could use :
From  docs:By default, this function will return the data as encoded bytes. The  actual encoding of the output data may depend on the command being  invoked, so the decoding to text will often need to be handled at the  application level.This behaviour may be overridden by setting  to   as described below in Frequently Used Arguments.If you follow the link to Frequently Used Arguments; it describes what  does:If  is  the file objects stdin, stdout and  stderr will be opened as binary streams, and no line ending conversion  is done.If  is , these file objects will be opened as  text streams in universal newlines mode using the encoding returned by  . For stdin, line ending characters   in the input will be converted to the default line separator  . For stdout and stderr, all line endings in the output will  be converted to . For more information see the documentation of  the  class when the newline argument to its  constructor is .For more details you could look at  documentation.To run your  shell command and to return text without  and without using :Here's a couple of code examples that show how  pipes and  class could be used together.To understand what is text and what is binary data in Python, read Unicode HOWTO. Here's the most important part: there are two major string types in Python: bytestrings (a sequence of bytes) that represent binary data and Unicode strings (a sequence of Unicode codepoints) that represent human-readable text. It is simple to convert one into another (â˜¯):
Also: I believe the first output is of type  , but  what is the type of the second output?  My guess is    with UTF-8  encoding.Close, but not quite right.  In Python3 the  type is indexed by Unicode code points (note that code points usually, but not always, have a 1:1 correspondence with user perceived characters).  Therefore, the underlying encoding is abstracted away when using the  type -- consider it unencoded, even though that is fundamentally not the case.  It is the  type which is indexed as a simple array of bytes and therefore must use a particular encoding,  In this case (as in most similar usages),  would suffice for decoding what was generated by the subprocess script.Python2 has different defaults for the interpretation of the  type (see here), so string literals will be represented differently in that version of the language (this difference could be a big stumbling block when researching text handling).As a person who mostly uses C++, I found the following to be extremely enlightening about the practical storage, encoding, and indexing of Unicode text: How do I use 3 and 4-byte Unicode characters with standard C++ strings?So the answer to the first part of the question is :although simply usingwill typically produce the same results since ASCII is a subset of UTF-8.Alternatively, you can use  like so:but note that here an encoding must be specified if you want the "contents only" representation -- otherwise it will actually build a  type which internally contains the quote characters (including the 'b' prefix), which is exactly what was happening in the first output shown in the question. processes the data in binary mode (returning the raw byte sequence) by default, but the cryptic argument  basically tells it to decode the string and represent it as text (using the  type).  This conversion to the  type is necessary (in Python3) if you want to display the output (and "only the contents") using Python's  function.The funny thing about this conversion is that, for these purposes, it really doesn't do anything to the data.  What happens under the hood is an implementation detail, but if the data is ASCII (as is very typical for this type of program) it essentially just gets copied from one place to another without any  meaningful translation.  The decode operation is just hoop jumping to change the data type -- and the seemingly pointless nature of the operation further obfuscates the larger vision behind Python's text handling (for the uninitiated).  Further, since the docs don't make the return type(s) explicit (by name), it's hard to even know where to start looking for the appropriate conversion function.


Answer URL
https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals
https://docs.python.org/3/library/subprocess.html#subprocess.check_output
https://docs.python.org/3/library/subprocess.html#frequently-used-arguments
https://docs.python.org/3/library/subprocess.html#frequently-used-arguments
https://docs.python.org/3/library/io.html#io.TextIOWrapper
https://docs.python.org/3/library/io.html#io.TextIOWrapper
https://docs.python.org/3/howto/unicode.html
https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str
https://docs.python.org/3/library/stdtypes.html#bytes
https://docs.python.org/3/library/codecs.html#standard-encodings
https://docs.python.org/3/library/stdtypes.html#bytes.decode
https://docs.python.org/3/library/stdtypes.html#str
https://docs.python.org/3/library/subprocess.html#subprocess.check_output
https://docs.python.org/3/library/subprocess.html#subprocess.check_output
