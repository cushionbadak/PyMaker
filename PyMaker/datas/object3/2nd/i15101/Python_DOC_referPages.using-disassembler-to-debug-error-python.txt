Natural Text
Reading "97 things every programmer should know" I found interesting essay about code analysis tools.Author claims that disassembler from Python standard library can be very useful to debug your every day codeHere it goes:"One thing this library(Python standard library disassembler) can disassembleis your last stack trace, giving you feedback on exactly which bytecode instruction threw the last uncaught exception."But there is no explanation of this in the bookSo does anybody has idea how above module could be useful for debugging ?
While a disassembler can be a tool to help you understand how Python understands what you write, it is not the only tool. there are other tools that can help as well. And as we will see some of them can work together.So here's a little piece of Python:And here part of a disassembly of it using the cross platform disassembler I wrote which is called xdis:(This is Python 3.4, other versions vary the details a little.)The first thing to note is that python thinks this code comes from a file with a path name  . If you've happened to rename the file but not the python code, this can confuse Python. Or the filename could be  instead and then you should look for that instead. Also, in Python versions 3 and up there is the size of the file (modulo 2**32) as a check to see if the  on the filesystem is the same as the one Python saw when it compiled the file. I draw your attention to the beginning of the code: we are loading a constant object which happens to be code for a function! And then then name of the function and finally calling  and storing that in a variable called five. The thing that is a bit unusual if you are used to a compiled language like C++, Go, or Java which doesn't do this, is that the function is created right there on the spot when you run the program. If my program had another instruction before and were instead:This would fail because that the MAKE_FUNCTION hasn't been run and so at the beginning five hasn't been defined yet.Now I'll also suggest that you might be able to learn this using a debugger as well and I suggest again trepan2 or trepan3 which has a disassembly command built into them and even a deparser for that assembly.Another place where disassembly can be elucidating is in the rare cases where Python does optimization on the code.Consider this Python source code:Here, in Python versions after around 2.3 will simply notice that  is superfluous and remove that code. But if you had say instead:That is enough to confound Python to keep the test in. Disassembly is the only way I think you can know this.The last aspect, is understanding exactly where you are when you stopped in a debugger or hit an error.  You often (but not always) get the line you had the error, but sometimes that can be confusing.  NormalPython masks information that is useful here, the instruction offset, but I'll show you how to get that and the instruction where you had the error.Suppose my code is:If I run this I will get an IndexError exception.  But which "prev" was it?trepan2 (or trepan3k) exposes the instruction pointer here. It also gives access to both a disassembler and a deparser. So let's see how that can be used here:Ok. So we see where exactly we were, offset 32 (@32 after previously stopping at offset @19), but what does this mean? The trepan debuggers will convert this back into Python so you don't have to do that yourself: The above, then, shows you were at offset 32 (not 31 or 33) and that particular prev access wasn't the first access  but the one after that .Although having both a disasembler, deparser inside the debugger, makes it so you don't have to know that much about what's going on. But I don't think it hurts to know what the instructions do or what the sequence of instructions is.


Answer URL
https://docs.python.org/3/library/dis.html
