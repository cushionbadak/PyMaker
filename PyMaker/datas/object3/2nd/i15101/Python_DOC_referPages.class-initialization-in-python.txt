Natural Text
I found that some classes contain a  function, and some don’t. I’m confused about something described below.What is the difference between these two pieces of code:andI know that the result or any instance created by these two class and the way of getting their instance variable are pretty much the same. But is there any kind of “default” or “hidden” initialization mechanism of Python behind the scene when we don’t define the  function for a class? And why I can’t write the first code in this way:That’s my questions. Thank you very much!Thank you very much Antti Haapala! Your answer gives me further understanding of my questions. Now, I understand that they are different in a way that one is a "class variable", and the other is a "instance variable". But, as I tried it further, I got yet another confusing problem.Here is what it is. I created 2 new classes for understanding what you said:As you said in the answer to my first questions, I understand the class_variable is a "class variable" general to the class, and should be passed or changed by reference to the same location in the memory. And the instance_variable would be created distinctly for different instances.But as I tried out, what you said is true for the Test3's instances, they all share the same memory. If I change it in one instance, its value changes wherever I call it.But that's not true for instances of Test4. Shouldn't the int in the Test4 class also be changed by reference?i1 = Test3()Why is that? Does that "=" create an "instance variable" named "i" without changing the original "Test4.i" by default? Yet the "append" method just handles the "class variable"? Again, thank you for your exhaustive explanation of the most boring basic concepts to a newbie of Python. I really appreciate that!
In python the instance attributes (such as ) are stored in the instance dictionary (). All the variable declarations in the class body are stored as attributes of the class.Thusis equivalent toIf no  method is defined, the newly created instance usually starts with an empty instance dictionary, meaning that none of the properties are defined.Now, when Python does the get attribute (as in  operation, it first looks for the attribute named  that is set on the instance).  If that fails, the  attribute is looked up on  instead (that is, the class attribute ).So you can do things like:but what this actually does is:There is no  attribute on the newly created  at all! Thus in  the  was looked up in the  class for reading, but the new value was set into the .If you use :The newly created instance  will already have the attribute set.Now in the case of immutable value such as  there is not that much difference. But suppose that you used a list:vs Now, if you create 2 instances of both: and  refer to the exactly same list object in memory, whereas  and  are distinct. Modifying the  looks as if the  also changes.This is because the  itself is not set, it is just read. The  is identical in behaviour toThat is, it only tries read the value of attribute  on , and if not found there, then look it up in the superclass. The  does not change the attribute, it just changes the value that the attribute points to. Now if you were to write an example that superficially looks the same:It would work identical toAnd do a completely different thing: first of all the  would create a new list object. Then the attribute  would be created in , and set to point to this new list. That is, in case of , if the  is "read from", it can be looked up in the class (or superclass) if not set in the instance, but if it is written to, as in , it will always be set on the instance.As for this:Such thing does not work in Python, because there is no  defined when the class body (that is all lines of code within the class) is executed - actually, the class is created only after all the code in the class body has been executed. The class body is just like any other piece of code, only the s and variable assignments will create methods and attributes on the class instead of setting global variables.
I understood my newly added question. Thanks to Antti Haapala.Now, when Python does the get attribute (as in print(instance.i) operation, it first looks for the attribute named i that is set on the instance). If that fails, the i attribute is looked up on type(i) instead (that is, the class attribute i).I'm clear about why is:after few tests. The codeactually creates a new instance variable for j1 without changing the class variable. That's the difference between "=" and methods like "append".I'm a newbie of Python coming from c++. So, at the first glance, that's weird to me, since I never thought of creating a new instance variable which is not created in the class just using the "=". It's really a big difference between c++ and Python.Now I got it, thank you all.


Answer URL
https://docs.python.org/3/c-api/long.html#c.PyLong_FromLong
