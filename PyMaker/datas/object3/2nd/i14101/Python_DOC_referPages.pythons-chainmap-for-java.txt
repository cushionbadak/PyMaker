Natural Text
I have a deeply nested configuration hassle.The problem happens to be in machine learning, where an end-user calling a cross-validation routine, may, or may not specify any of various parameters (e.g. "randomSeed" = 17)Either way, the parameters then have to be passed first to the cross-validation algorithm, and then on to a first machine learning algorithm. The machine learning algorithm, must be able to set and pass on other parameters, all without the initial user knowing.   Most all of the consumers in the chain of parameter users expect a java Map interface to be doing the look-up from. Flattening the keys into one library is unattractive for performance reasons -- both CPU and memory  -- (the 'root key-name' space) will be used without modification many thousands of times, and each time a number of additional parameters need to be specified before the bundle is passed along. A decent analog is how the PATH variable works, each element in the path being a directory (key-namespace). When a query is made against the PATH variable (eg. you type 'emacs' at the command line), it looks in each directory (unnamed namespace of keys) for that file-name (specified value) in order, until it either finds it, or fails to find it.  If it finds it, you get to execute the specific contents of the executable file it found (get the value of the parameter set). If you have a PATH variable from another, you can append a new directory  (anonymous key-space ) in front of it as you pass that PATH variable setting along to a new end-user, without modifying the previous directories (preferences).Given the name-space on the configuration parameters is effectively flat, a solution like Python's ChainMap would be perfect (eg example usage) but I'm finding no equivalent solution in Java?  
Over the weekend I went ahead and created a  implementation as well; thanks to Java 8 it's a surprisingly small class.  My implementation is slightly different than yours; it doesn't attempt to mirror Python's behavior and instead follows the  interface's specifications.  Notably:Lookup order is insertion order; the first map passed to the constructor takes precedence over the following maps. doesn't match values that are masked by earlier maps. returns the previous value of the chain map, even if that value was in a later map. removes the key from all maps, not just the first map or the visible entry.  From the Javadoc: "The map will not contain a mapping for the specified key once the call returns."Similarly  clears all maps, not just the top map.Implements  and  on the basis of its entry set, so that it is equal to other  implementations.I also did not implement push/pop behavior as it felt like an anti-pattern;  is already an O(1) view into a series of maps, you can simply construct additional s with the maps you want as needed.Obviously, if your implementation works for your use case, that's great.  But it violates the  contract in several places; I'd strongly suggest removing  and just let it be a standalone class.Many of the class's methods are nice one-liners, e.g.:I've written some tests to verify the class's behavior as well.  Additional test cases are welcome.I also extended your idea of using  to create an immutable view of a collection of maps; if you don't need mutation this will work nicely.  (As I learned, you have to use the three-argument form of  to get the generics to behave).
Since there seems to be nothing off the shelf (thanks to  lopisan and dimo414 for their tips/pointers), I did a first crack implementation that will at least serve my immediate needs. I'll hold off marking this as an answer for a few days, in case someone knows about a library-grade version. I've included lots of example usage calls. They could be converted to unit tests. There's places it could be more efficient. Since this emulates the python ChainMap API, notice that  doesn't mean the key won't still be in there. That remove call will only work if the top map on the scope-stack contains the key. ( Updated to emulate dimo414's implementation of ,  and . ) Incidentally, while trying to build this, I noticed there's a one liner version of the implicit fusion of two maps with guava (if that is all you need). An example usage case: both maps have perhaps millions of keys, and your user may not even bother to query it at all. Modifications though, unlike the ChainMap above, will give you an UnsupportedOperationException. This one should work through nestings, like: composedMapView( map1, composedMapView( map2, map3)). 
Out of the box I'm not aware of an equivalent.  Guava doesn't provide a  method either, but perhaps it should.For normal use cases, I would simply construct a new ; with Guava you can do so succinctly, e.g.:You could define your own  implementation that stores a  with relative ease by extending .  However this introduces an  overhead (where  is the number of maps in the chain).  This would be worthwhile if your maps are so large that copying is prohibitive, or you intend to construct these chained mappings very frequently, but otherwise I wouldn't suggest it.For a use case like merging properties, I would just construct a new map and be done with it.


Answer URL
https://docs.python.org/3/library/collections.html#collections.ChainMap
https://docs.python.org/3/library/collections.html#chainmap-examples-and-recipes
