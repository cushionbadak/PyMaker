Natural Text
What is the difference between these two lines of code:and Is one more efficient than the other?Would it be better to use
Using  to look at the bytecode generated for the two versions:The latter has fewer operations, and is therefore likely to be slightly more efficient. It was pointed out in the commments (thanks, @Quincunx) that where you have  vs.  the number of operations is exactly the same, it's just that the  changes and  switches to ::In this case, unless there was a difference in the amount of work required for each comparison, it's unlikely you'd see any performance difference at all.However, note that the two versions won't always be logically identical, as it will depend on the implementations of  and  for the objects in question. Per the data model documentation:There are no implied relationships among the comparison operators. The  truth of  does not imply that  is false.For example:Finally, and perhaps most importantly: in general, where the two are logically identical,  is much more readable than .
@jonrsharpe has an excellent explanation of what's going on. I thought I'd just show the difference in time when running each of the 3 options 10,000,000 times (enough for a slight difference to show).Code used:And the cProfile profiler results:So we can see that there is a very minute difference of ~0.7% between  and . Of these,  is the fastest.However, most surprisingly, we can see that is in fact the fastest, and beats  by ~0.3%. This isn't very readable, but I guess if you wanted a negligible performance improvement, one could go down this route.
In the first one Python has to execute one more operations than necessary(instead of just checking not equal to it has to check if it is not true that it is equal, thus one more operation). It would be impossible to tell the difference from one execution, but if run many times, the second would be more efficient. Overall I would use the second one, but mathematically they are the same
Here you can see that  has one more instruction than . So the performance difference will be very small in most cases unless you are doing millions of comparisons and even then this will likely not be the cause of a bottleneck. 
An additional note, since the other answers answered your question mostly correctly, is that if a class only defines  and not , then your  will run  and negate it. At that time, your third option is likely to be a tiny bit more efficient, but should only be considered if you NEED the speed, since it's difficult to understand quickly.
It's about your way of reading it.  operator is dynamic, that's why you are able to apply it in But  could be read in a better context as an operator which does the opposite of what  does.
I want to expand on my readability comment above.Again, I completely agree with readability overriding other (performance-insignificant) concerns.What I would like to point out is the brain interprets "positive" faster than it does "negative".  E.g., "stop" vs. "do not go" (a rather lousy example due to the difference in number of words).So given a choice:is preferable to the functionally-equivalent:Less readability/understandability leads to more bugs.  Perhaps not in initial coding, but the (not as smart as you!) maintenance changes...


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__bool__
