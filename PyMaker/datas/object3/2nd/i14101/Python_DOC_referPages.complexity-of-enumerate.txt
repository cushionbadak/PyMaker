Natural Text
I see a lot of questions about the run-time complexity of python's built in methods, and there are a lot of answers for a lot of the methods (e.g. https://wiki.python.org/moin/TimeComplexity , https://www.ics.uci.edu/~pattis/ICS-33/lectures/complexitypython.txt , Cost of len() function , etc.)What I don't see anything that addresses enumerate.  I know it returns at least one new array (the indexes) but how long does it take to generate that and is the other array just the original array?In other words, I'm assuming it's O(n) for creating a new array (iteration) and O(1) for the reuse of the original array...O(n) in total (I think).  Is the another O(n) for the copy making it O(n^2), or something else...?
Assuming the na√Øve approach (enumerate duplicates the array, then iterates over it), you have O(n) time for duplicating the array, then O(n) time for iterating over it. If that was just n instead of O(n), you would have 2 * n time total, but that's not how O(n) works; all you know is that the amount of time it takes will be some multiple of n. That's (basically) what O(n) means anyway, so in any case, the enumerate function is O(n) time total.
The enumerate-function returns an iterator. The concept of an iterator is described here.Basically this means that the iterator gets initialized pointing to the first item of the list and then returning the next element of the list every time its next() method gets called.So the complexity should be:Initialization: O(1) Returning the next element: O(1) Returning all elements: n * O(1)Please note that enumerate does NOT create a new data structure (list of tuples or something like that)! It is just iterating over the existing list, keeping the element index in mind.You can try this out by yourself:
As martineau pointed out,  does not make a copy of the array.  Instead it returns an object which you use to iterate over the array.  The call to  itself is O(1).


Answer URL
https://docs.python.org/3/library/functions.html#enumerate
