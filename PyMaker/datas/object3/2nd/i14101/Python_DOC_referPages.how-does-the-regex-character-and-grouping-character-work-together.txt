Natural Text
I am trying to see which statements the following pattern matches:I am a little confused because the grouping characters  have a  before it. Does this mean that the statement must have a  and ? Would that mean the statements without  or  be unmatched? 
Context is important: matches a literal parenthesis. matches 0 or more literal parentheses, thus making the parens optional (and allowing more than one of them, but that's clearly a bug).Since the intended behavior isn't "0 or more" but rather "0 or 1", this should probably be written  instead.That said, there's a whole lot about this regex that's silly. I'd consider instead:Using  avoids backslashes, and consequently is easier to read whether it's rendered by  or  (which escapes backslashes).Mixing  and  is silly; better to pick one and stick with it.Using  in place of  is silly, unless you really want to match . matches three digits, then three or more additional digits. Why not just match six or more digits in the first place?
Normally, the parentheses would act as grouping characters, however regex metacharacters are reduced simply to the raw characters when preceded by a backslash. From the Python docs:As in Python string literals, the backslash can be followed by various characters to signal various special sequences. It’s also used to escape all the metacharacters so you can still match them in patterns; for example, if you need to match a  or , you can precede them with a backslash to remove their special meaning:  or .In your case, the statements don't need parentheses in order to match, as each  and  in the expression is followed by a , which means that the previous character can be matched any number of times, including none at all. From the Python docs: doesn’t match the literal character ; instead, it specifies that the previous character can be matched zero or more times, instead of exactly once.Thus the statements with or without parentheses around the first 3 digits may match.Source: https://docs.python.org/2/howto/regex.html


Answer URL
https://docs.python.org/3/reference/lexical_analysis.html
