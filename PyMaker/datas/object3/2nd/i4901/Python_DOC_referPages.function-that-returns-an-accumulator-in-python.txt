Natural Text
I am reading Hackers and Painters and am confused by a problem mentioned by the author to illustrate the power of different programming languages.The problem is:We want to write a function that generates accumulators—a function that takes a number n, and returns a function that takes another number i and returns n incremented by i. (That’s incremented by, not plus. An accumulator has to accumulate.)The author mentions several solutions with different programming languages. For example, Common Lisp:and JavaScript:However, when it comes to Python, the following codes do not work:A simple modification will make it work:I am new to Python. Why doesn the first solution not work while the second one does? The author mentions lexical variables but I still don't get it.
 is just sugar for .*This means you assign a new value to the variable  (instead of mutating it in place). When you assign to a variable, Python assumes it is local to the function. However, before assigning it needs to evaluate , but  is local and still unassigned -> Error.In the second case  you never assign to  directly, but only ever access an item from . So Python can clearly see that it is not a local variable and goes looking for it in the outer scope.Finally, a nicer alternative (in Python 3) is to explicitly tell it that  is not a local variable:(There is actually no need for  - you could simply use  instead inside .)*The situation is slightly more complex, but the important issue is that computation and assignment are performed in two separate steps.
An infinite generator is one implementation. You can call  on a generator instance to extract successive results iteratively.If you need a flexible incrementer, one possibility is an object-oriented approach:
The following will work:The inner function  looks to find  locally inside its scope, and if it fails to find it, it goes to look one level up in the enclosing scope where it finds  which is a local variable of . But if you say , you declare  as a new local variable in the scope of the  ("the assignment statement creates variables in the local scope"), which leads to an error because you haven't assigned a value to  before adding something to it (referencing to it). On the other example, saying  is different because you do not declare a new local variable inside the bar, you access the first element of  which is found in the enclosing scope of bar.
In Python if we use a variable and pass it to a function then it will be Call by Value whatever changes you make to the variable it will not be reflected to the original variable.But when you use a list instead of a variable then the changes that you make to the list in the functions are reflected in the original List outside the function so this is called call by reference.And this is the reason for the second option does work and the first option doesn't.


Answer URL
https://docs.python.org/3/library/operator.html#inplace-operators
