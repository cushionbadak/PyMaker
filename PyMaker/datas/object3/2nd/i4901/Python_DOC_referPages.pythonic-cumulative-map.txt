Natural Text
Is there a more pythonic way of doing the following:where  is iterable,  is a function that takes two inputs and returns two outputs, and  is an initial value that gets "transformed" by each call to ?I am asking because I use  and list-comprehension on a regular basis, but I cannot express the previous function as a combination of those, and this is something that has come up several times now. Am I missing a hidden idiom, or is this just too niche to deserve one?A concrete example is to calculate a duration in terms of (year, week, day, hour, minute, second) from a certain amount of seconds:where  is the duration tuple and  corresponds to the final remainder (either zero or decimal here, depending on the type of the initial value). This is not just cherry-picked, there are many other examples, such as: fixed-step methods to integrate differential equations (iterable steps, stepper function, initial state); simulating a bounded random walk; tree processing across depth without recursion; etc.
This structure is similar to what the  generator function was designed for. For example, your function might be used with a function like this:then called with:which would return:the accumulated sums of 0 through 4, and the final sum. can do the same thing, but it's lazy (it returns each accumulated value as it's requested), and only works with two operand to single output functions; for this case, it ends up being simpler:would produce the same  as  (and the second result would just be the last value of the ), but you could also use it lazily without storing the results in a , e.g.:You could likely massage  to handle a two input, two output function (or more precisely, discard the value you don't care about from the values output by ), but most of the time I'd expect the second output to be an accumulated value to date, not really separate, so avoiding the second output would be cleaner.For fun, a kind of terrible massage of your structure to match . Let's say you wanted to add a  value to each element in the input, but reduce the  by 1 each time. With your function, you'd do (for initial  of 10):which (thanks to passing it  that counteracts each decrease in ) produces . Similar code with  might be:then (with some ugliness because you can't specify an initial value for  directly):which leaves  as  and  as , just as in your code (apologies for the magic;  with generalized, nested unpacking is both beautiful and horrifying all at once).


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.accumulate
