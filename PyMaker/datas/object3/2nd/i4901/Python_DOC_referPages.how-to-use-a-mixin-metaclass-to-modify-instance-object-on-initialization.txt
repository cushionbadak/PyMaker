Natural Text
I'm working through the Advent of Code 2017 problems for fun, and a few of them require that you interpret and execute pseudo-assembly programs. I want to write a reuse module that provides the necessary infrastructure for this. Specifically, I want to provide sandboxed  and  functions, and a function that resolves a variable in the interpretation namespace. I read about metaclasses and started framing one up, but I'm getting stuck on the implementation details. I envision being able to do this:Here's my initial attempt at . How do I create properties and methods on the object that will use the mixin? Properties like a unique copy of the locals dict for  and , methods like .
I solved this problem without using a metaclass. I first had to step back and rethink my object model. Ultimately, the roles and relationships I want to define are:Executor: A class instance that defines the state of a sandboxed namespace and exposes an API for interacting with itInterpreter: A class that defines an API for translating specific input grammar into specific Python grammar. It uses an interpreter (instance) to execute the final grammar.Program: A list of statements to be executed in order and a covenient API for executing them and retrieving information about their results.Each executor (instance) needs to initialize itself with a sandbox for the  and  functions. That's not what metaclasses are for: metaclasses are for initializing class objects...not class instance objects. To intialize a class instance object, I need to write a class. That's it: just a class.So I wrote an Executor that initializes executor objects with their own  and  dicts. It also needs to provide functions that always use these dicts when called. That's what closures are for. And my approach to creating closures in each instance object was to monkey patch them in after initializing the object.Here's the resultant Executor class:Armed with this tool, I wrote a class that implements the Interpreter and Program roles at once, calling it . An interpreter (instance) composes an executor (instance) and implements the iterator protocol. It looks something like this:


Answer URL
https://docs.python.org/3/library/stdtypes.html#iterator-types
