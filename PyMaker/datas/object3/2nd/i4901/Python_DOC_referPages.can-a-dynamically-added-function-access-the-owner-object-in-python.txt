Natural Text
I'm making a program in python in which specific instances of an object must be decorated with new functions built at runtime.I've seen very simple examples of adding functions to objects through MethodType:But none of the examples I've seen show how a function added in this manner can reference to the new owner's attributes. As far as I know, even though this binds the  function to the instance ,  must still be a pure function, and cannot contain references to anything local.In my case, I need functions to change attributes of the object they are added to. Here are two examples of the kind of thing I need to be able to do:I would then need a way to add a copy of a  or  to an A object in such a way that they can access the object attributes named  and the function named  correctly.So, is this possible? Is there a way to do this kind of programming in vanilla Python? or at least Is there a programming pattern that achieves this kind of behavior?P.S.: In my system, I also add attributes dynamically to objects. Your first thought then might be "How can I ever be sure that the object I'm adding the  function to actually has an attribute named ?", but I also have a fairly robust tag system that makes sure that I never try to add a  function to an object that hasn't a  variable. The reason I mention this is that solutions that look at the class definition aren't very useful to me.
As said in the comments, your function actually must take at least one parameter: , the instance the method is being called on. The  parameter can be used as it would be used in a normal instance method. Here is an example:Without your function accepting , an exception would be raised:
prints
It's not entirely clear what you're trying to do, and I'm worried that whatever it is may be a bad idea. However, I can explain how to do what you're asking, even if it isn't what you want, or should want. I'll point out that it's very uncommon to want to do the second version below, and even rarer to want to do the third version, but Python does allow them both, because "even rarer than very uncommon" still isn't "never". And, in the same spirit…The short answer is "yes". A dynamically-added method can access the owner object exactly the same way a normal method can.First, here's a normal, non-dynamic method:Obviously, with a normal method like this, when you call , the  ends up as the value of the  parameter, so  is , which is 3.Now, here's how you dynamically add a method to a class:This is actually doing exactly the same thing. (Well, we've left another name for the same function object sitting around in globals, but that's the only difference) If  is the same function it was in the first version, then obviously whatever magic made  work in the first version will do the exact same thing here.(This used to be slightly more complicated in Python 2, because of unbound methods, and classic classes too… but fortunately you don't have to worry about that.)Finally, here's how you dynamically add a method to an instance:Here, you actually have to know the magic that makes  work in the first two cases. So read the Descriptor HOWTO. After that, it should be obvious.But if you just want to pretend that Guido is a wizard (Raymond definitely is a wizard) and it's magic… Well, in the first two versions, Guido's magic wand creates a special bound method object whenever you ask for , but even he isn't magical enough to do that when  doesn't exist. But we can painstakingly create that same bound method object and store it as . After that, we're going to get the same thing we stored whenever we ask for , which we explicitly built as the same thing we got in the first two examples, so it'll obviously do the same thing.But what if we did this:Here, you're not letting Guido do his descriptor magic to create , and you're not doing it manually, you're just sticking a regular function there. Which means if you want anything to show up as the  parameter, you have to explicitly pass it as an argument, as in that silly  line at the end. But if you're willing to do that, then even this one works. No matter how  ends up as ,  is going to be .


Answer URL
https://docs.python.org/3/howto/descriptor.html
