Natural Text
I have two classesas you can see, one inherits from another.When I run , no error is thrown. However, when I run , I was expecting an unbound function call (unbound to a hypothetical SomethingElse instance) and so was expecting that  would complain about not receiving an object for its  parameter, but instead I get this error:What is the meaning of this message?EDIT:  I often see people hand-wave answer a  question, so please don't answer unless you really know how the  delegate is working here, and know about descriptors and how they are used with .EDIT: Alex suggested I update my post with more details. I'm getting something different now in both ways I used it for 3.6 (Anaconda). Not sure what is going on. I don't receive what Alex did, but I get:The calls (on Anaconda's 3.6):My understanding of super was that, according to https://docs.python.org/3/library/functions.html#super, that  with just the first argument would leave the  object unbounded to an instance, so that if you called  on the  object, you'd need to pass in an instance as  would be unbounded as well. However, 3.6 complains about how, with ,  isn't a , which it should be as it inherits from a parent that inherits from . on 2.7.13 gives the original error for , which was . For  it throws 
Calling  with 1 argument produces an "unbound" super object. Those are weird and undocumented and mostly useless, and I won't go into how they were intended to be used, but for the purposes of this answer, we really only need to know one thing about them. doesn't go through the usual  proxy logic. You're getting the  instance's own  method, not anything related to .From there, the rest of the behavior follows. The  on Python 2 is because  takes at least 1 argument, and you're passing it 0. (You might expect it to say  because it's still getting  - the  object , not the  instance - but due to weird implementation details, methods implemented in C generally don't count  for this kind of error message.) succeeds on Python 3 because the  constructor pulls  and  from the usual stack inspection magic.Calling  manually from outside the class produces  because  tries to do its stack inspection magic and doesn't find  or . fails because the first argument to the  constructor is supposed to be a type, not an instance.


Answer URL
https://docs.python.org/3/library/functions.html#super
https://docs.python.org/3/library/functions.html#super
