Natural Text
I understand that Python built-in types have a "truthiness" value, and the empty string is considered , while any non-empty string is considered .This makes senseI can check this using the built-in function .I can also make use of these truthiness values when using conditionals. For example:This is confusingThis doesn't work with the  operator though:Can anyone explain why  seems to act differently than a conditional?
See the truth value testing and comparisons sections of the documentation, excerpted below.In a nutshell, most things are truthy by default, which is why  is true.  The  operator compares two objects for equality, as opposed to comparing their truthinesses, as I assume you had expected.4.1. Truth Value Testing Any object can be tested for truth value, for use in an if or while condition or as operand of the Boolean operations below.By default, an object is considered true unless its class defines  either a  method that returns False or a  method  that returns zero, when called with the object. Here are most of the built-in objects considered false:constants defined to be false:  and zero of any numeric type: , , , , empty sequences and collections: , , , , , Operations and built-in functions that have a Boolean result always   return 0 or False for false and 1 or True for true, unless otherwise  stated. (Important exception: the Boolean operations  and   always return one of their operands.)4.3. ComparisonsObjects of different types, except different numeric types, never  compare equal....Non-identical instances of a class normally compare as non-equal  unless the class defines the  method.
The basicsI believe your confusion might come from comparing Python to languages such as JavaScript where there is a  and a  operator. Python does not work this way.In Python the only way to compare for equality is with  and this compares both value and type.Thus if you compare , then the expression is immediately  because the types  and  are not types that can be compared.Although, note that it does not mean that there are no types that are comparable between themselves. Examples are  and :Or simply  and This is the behaviour for most built-in types.The classy partIn the case where you define your own types, i.e. when you define classes, you can write the  which is called when you compare a class object to another value.By example you could do this (which by the way was pointed out as a terrible idea in the comments, you should not inherit built-in types).In the case where you do not define , then Python fall back on comparing whether the objects are the same object with .
When you compare , you are also comparing the type of these objects and not just their boolean value.Now as  has a type  and  has a type , they are not equivalent according to the  operator, irrespective of their boolean values being equal.Note: Both the object's type,boolean values are being checked here.


Answer URL
https://docs.python.org/3/library/stdtypes.html#truth-value-testing
https://docs.python.org/3/library/stdtypes.html#comparisons
https://docs.python.org/3/library/stdtypes.html#memoryview.__eq__
