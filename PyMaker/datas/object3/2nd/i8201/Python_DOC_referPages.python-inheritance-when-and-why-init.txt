Natural Text
I'm a Python newbie, trying to understand the philosophy/logic behind the inheritance methods. Questions ultimately regards why and when one has to use the  method in a subclass. Example:It seems a subclass inheriting from a superclass need not have its own constructor ) method. Below, a dog inherits the attributes (name, age) and methods (makenoise) of a mammal. You can even add a method () Everything works as it ``should", it seems.However, if I wanted to add a new attribute in the subclass as I attempt to do in the Cats class, I get an error saying "self" is not defined. Yet I used "self" in the definition of the dog class. What's the nature of the difference?It seems to define Cats as I wish I need to use  and . Why the difference?
if I wanted to add a new attribute in the subclass as I attempt to do  in the Cats class, I get an error saying "self" is not defined. Yet I  used "self" in the definition of the dog class.In your superclass, Mammal, you have an  function, which takes an argument that you've chosen* to call . This argument is in scope when you're in the body of the  function - it's a local variable like any local variable, and it's not possible to refer to it after its containing function terminates. The function defined on the Dog class, , also takes an argument called , and it is also local to that function. What makes these variables special is not their name (you could call them anything you wanted) but the fact that, as the first arguments to instance methods in python, they get a reference to the object on which they're called as their value. (Read that last sentence again a few times, it's the key to understanding this, and you probably won't get it the first time.)Now, in , you have a line of code which is not in a function at all. Nothing is in scope at this point, including , which is why this fails. If you were to define a function in  that took an argument called , it would be possible to refer to that argument. If that argument happened to be the first argument to an instance method on , then it would have the value of the instance of  on which it had been called. Otherwise, it would have whatever got passed to it. *you have chosen wisely!
Explicit is better than implicit.However, you can do below:or
You can do something like in Chankey's answer by initiating all the variables in the constructor method ie However you can also do something like thisAnd then The reason you can't use  outside the functions is because  is used explicitly only for instances of the class. If you used it outside, it would lead to ambiguity. If my answer isn't clear please let me know in comments.
The  method runs once on the creation of an instance of a class. So if you want to set an attribute on an instance when it's created, that's where you do it.  is a special keyword that is passed as the first argument to every method, and it refers to the instance itself.  is no different from other methods in this regard."What's the nature of the difference": you define the method , and you receive   as an argument to the method as usual. But in  you've unintentionally (perhaps subconsciously!) attempted to work on the class scope -- this is how you'd set a class attribute whose value is identical for all cats:It's different so you can have both options available. Sometimes (not all the time, but once in a while) a class attribute is a useful thing to have. All cats have the same sound. But much of the time you'll work with instance attributes -- different cats have different names; when you need that, use .
Declarations at the top level of a Python class become class attributes. If you come from a C++ or Java background, this is similar to declaring a static member variable. You cannot assign instance attributes at that level.The variable  usually refers to a specific instance of a class, the one from which the method has been called. When a method call is made using the syntax , the first argument to the function is the object  on which the method was called. In your case, and usually by convention, that argument is named  within the function body of methods. You can think of  as only being a valid identifier within method bodies then. Your assignment  does not take place in a method, so self isn't defined there.You have basically two options for achieving what you want. The first is to properly define  as an attribute of the cat class:or you can set the value of an instance variable  in the cat constructor:If you're getting into Python I highly recommend to read these two parts of the Python documentation:Python classesPython data model special methods (more advanced)
Suppose you have a class named  which has a method named  defined as :And, you create an instance of  as . Now when you call the function  with this instance, it will converts internallySo, self is the instance itself.Without  you can write above code as :What I am trying to say is the name  is a convention only.And for inheritance, if you would like to have extra attributes in your subclass, you need to initiate your super class first and add your parameter as you wanted.For example, if you want to create a subclass from  named  with new attribute , the you can define it as:
As pointed out in the other answers, the  that you see in the otherfunctions is actually a parameter. By Python convention, the first parameter inan instance method is always .The class  inherits the  function from its base class,. You can override , and you can call or not call the baseclass implementation.In case the   wants to call the base implementation, but doesn't want to care about the parameters, you can use Python variable arguments. This is shown in the following code.Class declaration:See, for example, this Stack Overflow question for something about the starnotation for variable numbers of arguments:Can a variable number of arguments be passed to a function?Additional test code:Output:


Answer URL
https://docs.python.org/3/tutorial/classes.html
https://docs.python.org/3/reference/datamodel.html#special-method-names
