Natural Text
I am using Anaconda (Python 3.6). In the interactive mode, I did object identity test for positive integers >256:Clearly, large integers (>256) writing in separate lines are not reused in interactive mode. But if we write the assignment in one line, the large positive integer object is reused:That is, in interactive mode, writing the integer assignments in one or separate lines would make a difference for reusing the integer objects (>256). For integers in [-5,256] (as described https://docs.python.org/2/c-api/int.html), caching mechanism ensures that only one object is created, whether or not the assignment is in the same or different lines. Now let's consider small negative integers less than -5 (any negative integer beyond the range [-5, 256] would serve the purpose), surprising results come out:Clearly, this demonstrates inconsistency for object identity test between large positive integers (>256) and small negative integers (<-5). And for small negative integers (<-5), writing in the form a, b = -6, -6 and a = b =-6 also makes a difference (in contrast, it doesn't which form is used for large integers). Any explanations for these strange behaviors? For comparison, let's move on to IDE run (I am using PyCharm with the same Python 3.6 interpreter), I run the following script It prints True, different from the interactive run. Thanks to @Ahsanul Haque, who already gave a nice explanation to the inconsistency between IDE run and interactive run. But it still remains to answer my question on the inconsistency between large positive integer and small negative integer in the interactive run. 
When you run  in the interactive shell or as part of the bigger script, CPython generates the bytecode likeWhat it does is:Loads two constants (LOAD_CONST pushes co_consts[consti] onto the stack -- docs)Compares them using  ( if operands refer to the same object;  otherwise)Returns the resultAs CPython only creates one Python object for a constant used in a code block,  will result in a single integer constant being created:According to the bytecode above, Python will load that same object twice and compare it with itself, so the expression will evaluate to :The results are different for , because  is not immediately recognized as a constant: is an expression negating the value of the integer literal .Nevertheless, the bytecode for  is virtually the same as the first bytecode sample:So Python loads two  constants and compares them using .How does the  expression become a constant? CPython has a peephole optimizer, capable of optimizing simple expressions involving constants by evaluating them right after the compilation, and storing the results in the table of constants.As of CPython 3.6, folding unary operations is handled by  in . In particular,  (unary minus) is evaluated by  that returns a new Python object ( is not cached). After that, the newly created object is inserted to the  table. However, the optimizer does not check whether the result of the expression can be reused, so the results of identical expressions end up being distinct Python objects (again, as of CPython 3.6).To illustrate this, I'll compile the  expression:There're two  constants in the  tupleand they have different memory addressesOf course, this means that  evaluates to :For the most part the explanation above remains valid in presence of variables. When executed in the interactive shell, these three linesare parts of three different code blocks, so the  constant won't be reused. However, if you put them all in one code block (like a function body) the constant will be reused.In contrast, the  line is always executed in one code block (even in the interactive shell), and therefore CPython always reuses the constant. In ,  isn't reused for the reasons explained in the first part of my answer. is trivial. Since there's exactly one Python object involved,  would return  even if you replaced  with something else.
Only one copy of a particular constant is created for a particular source code and reused if needed further. So, in pycharm, you are getting  == .But, in the interpreter, things are different. Here, only one line/statement runs at once. A particular constant is created for each new line. It is not reused in the next line. So,  here. But, if you can initialize in same line, you can have the same behavior (Reusing the same constant).  Edit:A block is a piece of Python program text that is executed as a unit. In an IDE, the whole module get executed at once i.e. the whole module is a block. But in interactive mode, each instruction is actually a block of code that is executed at once. As I said earlier, a particular constant is created once for a block of code and reused if reappears in that block of code again. This is main difference between IDE and interpreter.Then, why actually interpreter gives same output as IDE for smaller numbers? This is when, integer caching comes into consideration. If numbers are smaller, then they are cached and reused in next code block. So, we get the same id in the IDE. But if they are bigger, they are not cached. Rather a new copy is created. So, as expected, the id is different.Hope this makes sense now,      
For complement the answer of the Ahsanul Haque, Try this in any IDE:Very likely you will see the same ID for 'x' and 'y', then run the code in the interpreter and ids will be different.See Here.


Answer URL
https://docs.python.org/3/library/dis.html#opcode-LOAD_CONST
https://docs.python.org/3/c-api/number.html#c.PyNumber_Negative
