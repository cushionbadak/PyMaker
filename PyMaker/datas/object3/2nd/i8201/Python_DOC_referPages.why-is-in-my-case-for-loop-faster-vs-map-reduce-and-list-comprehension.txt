Natural Text
I wrote a simple script that test the speed and this is what I found out. Actually for loop was fastest in my case. That really suprised me, check out bellow (was calculating sum of squares). Is that because it holds list in memory or is that intended? Can anyone explain this.Update - when I tried longer loops there are the results.
Python function calls have overheads which make them relatively slow, so code that uses a simple expression will always be faster than code that wraps that expression in a function; it doesn't matter whether it's a normal  function or a . For that reason, it's best to avoid  or  if you are going to pass them a Python function if you can do the equivalent job with a plain expression in a  loop or a comprehension or generator expression.There are a couple of minor optimizations that will speed up some of your functions. Don't make unnecessary assignments. Eg,Also,  is quite a bit faster than  because multiplication is faster than exponentiation.As I mentioned in the comments, it's more efficient to pass  a generator than a list comprehension, especially if the loop is large; it probably won't make difference with a small list of length 8, but it will be quite noticeable with large lists.BTW, you shouldn't use  or  as variable names as that masks the built-in functions with the same names. It won't hurt anything here, but it's still not a good idea, and it makes your code look odd in an editor with more comprehensive syntax highlighting than the SO syntax highlighter.Here's a new version of your code that uses the  module. It does 3 repetitions of 10,000 loops each and sorts the results. As explained in the timeit docs, the important figure to look at in the series of the repetitions is the minimum one.In a typical case, the lowest value gives a lower bound for how fast  your machine can run the given code snippet; higher values in the  result vector are typically not caused by variability in Pythonâ€™s  speed, but by other processes interfering with your timing accuracy.  So the  of the result is probably the only number you should be  interested in.outputThe results were obtained on an old single core 32 bit 2GHz machine running Python 3.6.0 on Linux.
This is almost independent of the underlying programming language, as in abstractions do not come for free.Meaning: there is always certain cost for calling methods. A stack needs to be established; control flow needs to "jump". And when you think of lower levels, such as CPUs: probably the code for that method needs to be loaded, and so on. In other words: when your primary requirement is hard-core number crunching, then you have to balance ease-of-use with the cost of the corresponding abstractions. Beyond: if you focus on speed, then you should look beyond python, or at least beyond "ordinary" python. Instead you could turn to modules such as numpy.


Answer URL
https://docs.python.org/3/library/timeit.html
