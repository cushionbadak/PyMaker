Natural Text
My problem, and whyI'm trying to write a decorator for a class method, . I want it to behave so that when the method is first called, the method is replaced with its return value. I also want it to behave like  so that it doesn't need to be explicitly called. Basically, it should be indistinguishable from  except that it's faster, because it only calculates the value once and then stores it. My idea is that this would not slow down instantiation like defining it in  would. That's why I want to do this.What I triedFirst, I tried to override the  method of the , but it's read-only.Next, I figured I'd try to implement a decorator that does needs to be called the first time but then caches the values. This isn't my final goal of a property-type decorator that never needs to be called, but I thought this would be a simpler problem to tackle first.Â In other words, this is a not-working solution to a slightly simpler problem.I tried:However, this doesn't seem work. I tested this with:but I get an error about how the class didn't pass itself to the method:At this point, me and my limited knowledge of deep Python methods are very confused, and I have no idea where my code went wrong or how to fix it. (I've never tried to write a decorator before)The questionHow can I write a decorator that will return the result of calling a class method the first time it's accessed (like  does), and be replaced with a cached value for all subsequent queries?I hope this question isn't too confusing, I tried to explain it as well as I could.
First of all  should be instantiatedSecond, there is no need for  cause we can get the property name from And third, we return  to make python to do all the magic."""
If you don't mind alternative solutions, I'd recommend for exampleExpected output
I think you're better off with a custom descriptor, since this is exactly the kind of thing descriptors are for. Like so: EDIT: By the way, you don't even actually need a custom descriptor. You could just cache the value inside of your property function. E.g.: That's all there is to it. However, many would consider this a bit of an abuse of , and to be an unexpected way of using it. And unexpected usually means you should do it another, more explicit way. A custom  descriptor is very explicit, so for that reason I would prefer it to the  approach, though it requires more code. 
You can use something like this:When adding to the cache dictionary it generates keys based on the convention   in case you are caching entities and the property could possibly return a different value for each one.It also checks a settings key  in case you want to turn it off temporarily when doing benchmarks.But it does not encapsulate the standard  decorator so you should still call it like a function, or you can use it like this (why restrict it to properties only):Also it may be worth noting that in case you are caching a result from lazy foreign key relationships, there are times depending on your data where it would be faster to simply run an aggregate function when doing your select query and fetching everything at once, than visiting the cache for every record in your result-set. So use some tool like  for your framework to compare what performs best in your scenario.
Django's version of this decorator does exactly what you describe and is simple, so besides my comment I'll just copy it here:(source).As you can see, it uses func.name to determine the name of the function (no need to fiddle with inspect.stack) and it replaces the method with its result by mutating . So subsequent "calls" are just an attribute lookup and there is no need for any caches, et cetera.


Answer URL
https://docs.python.org/3/library/functools.html#functools.lru_cache
