Natural Text
I'm trying to use the heappq module in the python 3.5 standard library to make a priority queue of objects of the same type. I'd like to be able to heapify based on an attribute of the objects, then change the value of some of those attributes, then re-heapify based on the new values. I'm wondering how I go about doing this.
There are a variety of ways of making your code work. For instance, you could make your items orderable by implementing some of the rich comparison operator methods (and perhaps use  to implement the rest):This will make your code work, but it may not be very efficient to reheapify your queue every time you make a change to a node within it, especially if there are a lot of nodes in the queue. A better approach might be to write some extra logic around the queue so that you can invalidate a queue entry without removing it or violating the heap property. Then when you have an item you need to update, you just invalidate it's old entry and add in a new one with the new priority.Here's a quick and dirty implementation that uses a dictionary to map from a node instance to a  list. If the node is getting its priority updated, the dictionary is checked and the  part of the list gets set to . Invalidated entries are ignored when popping nodes off the front of the queue.You may want to test this against reheapifying to see which is faster for your program's actual usage of the queue.A few final notes about your  class (unrelated to what you were asking about in your question):There are a number of things you're doing in the class that are not very Pythonic. To start with, the most common naming convention for Python uses  for classes, and  for almost everything else (variables of all kinds, functions, modules).Another issue using double leading underscores for . Double leading (and not trailing) undescrores invokes Python's name mangling system. This may seem like its intended as a way to make variables private, but it is not really. It's more intended to help prevent accidental name collisions, such as when you're setting an attribute in a proxy object (that otherwise mimics the attributes of some other object) or in a mixin class (which may be inherited by other types with unknown attributes). If code outside your class really wants to access the mangled attribute  in your  class, they can still do so by using . To hint that something is intended to be a private attribute, you should just use a single underscore .And that brings me right to my final issue, that  probably shouldn't be private at all. It is not very Pythonic to use  and  methods to modify a private instance variable. It's much more common to document that the attribute is part of the class's public API and let other code access it directly. If you later decide you need to do something fancy whenever the attribute is looked up or modified, you can use a  descriptor to automatically transform attribute access into calls to a getter and setter function. Other programming languages usually start with getters and setters rather than public attributes because there is no such way of changing implementation of an attribute API later on. So anyway, I'd make your class's  just set  and get rid of  and  completely!
A crude way of doing what you're looking for would be to use  and Python's built in  method. This method would basically allow you keep your heap as a heap of the 's of the objects that you create and then update those objects by accessing them in the  where their 's are the keys. I tried this on my local machine and it seems to do what you're looking for: won't really do too much here because the  of the object is going to be the same until it's deleted. It is more useful if you're adding new objects to the heap and taking objects out.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__lt__
https://docs.python.org/3/library/functools.html#functools.total_ordering
