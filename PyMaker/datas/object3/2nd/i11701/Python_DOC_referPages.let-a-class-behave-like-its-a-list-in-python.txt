Natural Text
I have a class which is essentially a collection/list of things. But I want to add some extra functions to this list. What I would like, is the following: I have an instance . Variable  should behave as it was a list whenever I use it as a list: , , . Plus it should have some special functions like , , .I currently use the following approach:This is ok for usage as iterator like , but I do not have the full list behavior like .A first guess is to inherit  into . But is that the recommended pythonic way to do? If yes, what is to consider? If no, what would be a better approach?
If you want only part of the list behavior, use composition (i.e. your instances hold a reference to an actual list) and implement only the methods necessary for the behavior you desire. These methods should delegate the work to the actual list any instance of your class holds a reference to, for example:Implementing  alone will give you a surprising amount of features, for example iteration and slicing.If you want the full behavior of a list, inherit from .  is a full Python implementation of the list datatype. So why not inherit from  directly?One major problem with inheriting directly from  (or any other builtin written in C) is that the code of the builtins may or may not call special methods overridden in classes defined by the user. Here's a relevant excerpt from the pypy docs:Officially, CPython has no rule at all for when exactly overridden method of subclasses of built-in types get implicitly called or not. As an approximation, these methods are never called by other built-in methods of the same object. For example, an overridden  in a subclass of dict will not be called by e.g. the built-in  method.Another quote, from Luciano Ramalho's Fluent Python, page 351:Subclassing built-in types like dict or list or str directly is error-  prone because the built-in methods mostly ignore user-defined  overrides. Instead of subclassing the built-ins, derive your classes  from UserDict , UserList and UserString from the collections  module, which are designed to be easily extended.... and more, page 370+:Misbehaving built-ins: bug or feature?  The built-in dict , list and str types are essential building blocks of Python itself, so  they must be fast — any performance issues in them would severely impact pretty much  everything else. That’s why CPython adopted the shortcuts that cause their built-in  methods to misbehave by not cooperating with methods overridden by subclasses.After playing around a bit, the issues with the  builtin seem to be less critical (I tried to break it in Python 3.4 for a while but did not find a really obvious unexpected behavior), but I still wanted to post a demonstration of what can happen in principle, so here's one with a  and a :As you can see, the  method from  ignored the overridden  method, while the  method from our  did not.
The simplest solution here is to inherit from  class:You can then use  type as a list, and use its specific methods.Inheritance introduces a strong coupling between your object and . The approach you implement is basically a proxy object.The way to use heavily depends of the way you will use the object. If it have to be a list, then inheritance is probably a good choice.EDIT: as pointed out by @acdr, some methods returning list copy should be overriden in order to return a  instead a .A simple way to implement that:
If you don't want to redefine every method of , I suggest you the following approach:This would make methods like ,  and so on, work out of the box. Beware, however, that magic methods (e.g. ,  etc.) are not going to work in this case, so you should at least redeclare them like this:Please note, that in this case if you want to override a method of  (, for instance), you can just declare your own so that the call won't pass through the  method. For instance:
Based on the two example methods you included in your post (, ), it doesn't seem that you need to store any extra state in your lists. If this is the case, you're best off simple declaring these as free functions and ignoring subtyping altogether; this completely avoids problems like  vs , fragile edge cases like return types for , unexpected Liskov issues, &c. Instead, you can write your functions, write your unit tests for their output, and rest assured that everything will work exactly as intended.As an added benefit, this means your functions will work with any iterable types (such as generator expressions) without any extra effort.


Answer URL
https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes
