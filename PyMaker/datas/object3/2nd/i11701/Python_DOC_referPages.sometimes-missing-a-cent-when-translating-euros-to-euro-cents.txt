Natural Text
I have to translate euro's (in a string) to euro cents (int):Examples: '12,1' => 1210  '14,51' => 1451I use this python function: But with this amount '1229,84' the result is : 122983 UpdateI use the solution from Wim, bacause I use integers in both Python / Jinja and javascript for currency artitmetic. See also the answer from Chepner.My questions was anwered by Mr. Me, who explained the above result.
What the Docs Say, and a simple explanationI tried it out, and was surprised that this was happening. So I turned to the documentation, and there is a little note in there that says.Note The behavior of round() for floats can be surprising: for  example, round(2.675, 2) gives 2.67 instead of the expected 2.68. This  is not a bug: it’s a result of the fact that most decimal fractions  can’t be represented exactly as a float. Now what does that mean, most decimal fractions can't be represented as a float. Well the documentations follows up with a great link at explains this, but since you probably didn't come here to read a nerdy technical document, let me summarize what is going on.Python uses the IEEE-754 floating point standard to represent floats. This standard compromises accuracy for speed. Some numbers cannot be accurately represented. For example  is actually represented as . Interestingly, .1 in binary is actually an infinitely repeating number, just like 1/3 is an infinitely repeating .333333.An Under the Hood Case StudyNow on to your particular case. This was pretty fun to look into, and this is what I discovered.first lets simplify what you where trying to dotoSometimes Python1 is unable to 100% accurately display binary floating point numbers, for the same reason we are unable to display the fraction 1/3 as a decimal. When this happens Python hides any extra digits.  is actually stored as 2, but Python will display it as .1 if you type it into the console. We can see those extra digits by doing 3. we can apply this  formula to most floating point numbers to see the extra hidden digits behind them.4. In your case we would do the following. is actually . Continuing on.5Now on to the last step. This is the part we are concerned about. Changing it back to an integer.It rounds downwards instead of upwards, however, if we never had multiplied it by 100, we would still have 2 more 9s at the end, and Python would round up.??? Now what is going on. Why is Python rounding  down, but it rounds  up? Well whenever Python turns a float into a integer it rounds down. However, you have to remember that to Python  with the extra two 99s at the end is the same thing as  For example.and without the two extra 99s on the end.Python is definitely treating  as  but not . Now back to casting  to an integer. Because we have created ourselves a decimal portion that is less than  that Python sees as being a seperate number from , and because casting to an integer always causes Python to round down, we get  as a result.Whew. That was a lot to go through, but I sure learned a lot writing this out, and I hope you did to. The solution to all of this is to use decimal numbers instead of floats which compromises speed for accuracy.What about rounding? The original problem had some rounding in it as well -- it's useless. See appendix item 6.The Solutiona) The easiest solution is to use the decimal module instead of floating point numbers. This is the preferred way of doing things in any finance or accounting program.The documentation also mentioned the following solutions which I've summarized.b) The exact value can be expressed and retrieved in a hexadecimal form via  and c) The exact value can also be retrieved as a fraction through d) The documentation briefly mentions using SciPy for floating point arithmitic, however this SO question mentions that SciPy's NumPy floats are nothing more than aliases to the built-in float type. The decimal module would be a better solution.Appendix1 - Even though I will often refer to Python's behavior, the things I talk about are part of the IEEE-754 floating point standard which is what the major programming languages use for their floating point numbers.2 -  gives me , but according to the documentation .1 is really 3 - We used  instead of  because  does not give us the hidden digits, but according to the documentation they should still be there for .1, hence I say  works most of the time, but not all of the time.4 - When we use the formula  what is happening is that casting the number to an integer will round the number down so  becomes 3, and when we minus  from  we are left with . However, for some reason that I do not know, when we get rid of all the whole numbers, and we're just left with the decimal portion, Python decides to show us everything -- the whole mantissa.5 - this does not really affect the outcome of our analysis, but when multiplying by 100, instead of the hidden digits being shifted over by 2 decimal places, they changed a little as well.6 - It may seem like we can get rid of all those extra digits by rounding to two decimal places.But when we use our  formula to see the hidden digits, they are still there.This is because Python cannot store 1229.84 as a binary floating point number. It can't be done. So... rounding 1229.84 does absolutely nothing.
Don't use floating-point arithmetic for currency; rounding error for values that cannot be represented exactly will cause the type of loss you are seeing. Instead, convert the string representation to an integer number of cents, which you can convert to euros-and-cents for display as needed.(Notice you'll need a check to handle cents without a trailing 0.)You can also use the  class from the  module, which essentially encapsulates all the logic for using integers to represent fractional values.
As @wim mentions in a comment, use the  type from the stdlib  module instead of the built in  type.  objects do not have the binary rounding behavior that floats have and also have a precision that can be user defined. should be used anywhere you are doing financial calculations or anywhere you need floating point calculations that behave like the decimal math people learn in school (as opposed to the binary floating point behavior of the built in  type).


Answer URL
https://docs.python.org/3/library/functions.html#round
https://docs.python.org/3/tutorial/floatingpoint.html#tut-fp-issues
