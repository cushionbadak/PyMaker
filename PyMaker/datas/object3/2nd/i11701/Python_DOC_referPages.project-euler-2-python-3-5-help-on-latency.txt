Natural Text
I'm new to coding and trying to do the project euler exercises to improve my knowledge on coding. I have come across several solutions with regards to Project Euler #2. However, I would want to know why my code takes so much longer to compute as compared to a solution I found. I would appreciate if anyone can guide me as to the differences between the two.My code:Online Solution I found:
To calculated , with your implementation:in which  is calculated recursively:See the problem? The result of  has to be calculated twice! To further expand the expression (e.g, to get the result of ), the redundant calculation is huge when the number is big.Recursion itself isn't the problem, but you have to store the result of smaller fibonacci numbers rather than calculating the same expression on and on. One possible solution is to use a dictionary to store the intermediate result.
You are using recursive calls to a function where the other solution uses a plain iterative loop.Making a function call is bound to some overhead for calling and returning from it. For bigger numbers of n you will have a lot of those function calls.Appending to a list over and over and summing it up is probably also slower than doing this via an accumulator.
Your solution calls a recursive function (with 2 recursions) each time it goes in your while loop. Then in the loop you run that same function again. The other solution only adds numbers and then does a permutation.I guess you didn't really need the fibonacci, but if you insist on using it, run it only once and save the result, instead of re-runing it. Plus you store all your results and sum it at the end. That consumes a bit of time (not only) too, maybe you didn't need to store intermediate results.
As several other answers pointed out, the recursion causes your  function to be called very often, 111 561 532 times in fact. This is easily seen by adding a counter:There are two ways to fix this; rewrite your program to be iterative rather than recursive (like the other solution you posted), or cache intermediate results from .See, you call , which in turn has to call  and , etc, etc. Just calculating  takes 67 calls to !But later, when you call , that also calls , which has to do all the work over again (67 more calls to ). This gets out of hand quickly. It would be better, if  could remember that it already calculated  and remember the result. This is known as caching or memoization.Luckily, Python's standard library has a decorator just for that purpose, functools.lru_cache:On my computer, your program execution goes from 111 561 532 invocations of  in 27 seconds to 35 invocations in 0.028 seconds.


Answer URL
https://docs.python.org/3/library/functools.html#functools.lru_cache
