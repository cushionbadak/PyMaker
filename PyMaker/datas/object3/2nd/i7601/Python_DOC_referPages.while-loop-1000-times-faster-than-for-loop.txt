Natural Text
So the question regarding the speed of for loops vs while loops has been asked many times before. The for loop is supposed to be faster. However, when I tested it in Python 3.5.1 the results were as follows:The while loop runs >3000 times faster than the for loop! I've also tried pre-generating a list for the for loop:Which made the for loop 3 times faster, but the difference is still 3 orders of magnitude. Why does this happen?
You are creating 10k  objects. These take some time to materialise. You then have to create iterator objects for those 10k objects too (for the  loop to iterate over the values). Next, the  loop uses the iterator protocol by calling the  method on the resulting iterator. Those latter two steps also apply to the  loop over a list.But most of all, you are cheating on the  loop test. The  loop only has to run once, because you never reset  back to  (thanks to Jim Fasarakis Hilliard pointing that out). You are in effect running a  loop through a total of 19999 comparisons; the first test runs 10k comparisons, the remaining 9999 tests run one comparison. And that comparison is fast:See how close those numbers are?My machine is a little faster, so lets create a baseline to compare against; this is using 3.6.1 on a Macbook Pro (Retina, 15-inch, Mid 2015) running on OS X 10.12.5. And lets also fix the  loop to set  in the test, not the setup (which is run just once):Oops, so a correctly running  is actually slower here, there goes your premise (and mine!).I used  to avoid having to answer question about how fast referencing that object is (it's fast but besides the point). My timings are going to be 6x faster than your machine.If you wanted to explore why the iteration is faster, you could time the various components of the  loop in Python, starting with creating the  object:So creating 10000  objects takes more time than running a single  loop that iterates 10k times.  objects are more expensive to create than integers.This does involves a global name lookup, which is slower, you could make it faster by using  then use ; this shaves of about 1/3rd of the timings.Next, create an iterator for this; here I'll use a local name for the  function, as the  loop doesn't have to do a hash-table lookup and just reaches for the C function instead. Hard-coded references to a memory location in a binary is a lot faster, of course:Fairly fast, but; it takes the same amount of time as your single  loop iterating 10k times. So creating iterable objects is cheap. The C implementation is faster still. We haven't iterated yet.Last, we call  on the iterator object, 10k times. This is again done in C code, with cached references to internal C implementations, but with a  object we can at least attempt to get a ball-park figure:Boy, 10k times 10k calls to  takes almost 4x more time than the  loop managed; this goes to show how efficient the actual C implementation really is.However, it does illustrate that looping in C code is a lot faster, and this is why the  loop is actually slower when executed correctly; summing integers and making boolean comparisons in bytecode takes more time than iterating over  in C code (where the CPU does the incrementing and comparisons directly in CPU registers):It is those operations that make the  loop about 3 seconds slower.TLDR: You didn't actually test a  loop correctly. I should have noticed this earlier too.
You are timing things incorrectly,  is only executed once and then the value of  is  for all consequent runs. See the documentation on :Time number executions of the main statement. This executes the  statement once, and then returns the time it takes to execute the main statement a number of times, measured in seconds as a float.Additionally verify it by printing  for each repetition:As a result, all consequent runs merely perform a comparison (which is ) and finish early.Time correctly and see how the  loop is actually faster:


Answer URL
https://docs.python.org/3/library/stdtypes.html#iterator-types
https://docs.python.org/3/library/stdtypes.html#iterator.__next__
https://docs.python.org/3/library/functions.html#iter
https://docs.python.org/3/library/functools.html#functools.partial
https://docs.python.org/3/library/timeit.html#timeit.Timer.timeit
