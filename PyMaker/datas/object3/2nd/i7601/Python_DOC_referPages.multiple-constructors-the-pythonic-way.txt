Natural Text
This question already has an answer here:How to overload __init__ method based on argument type?                    10 answers                I have a container class that holds data. When the container is created, there are different methods to pass data.Pass a file which contains the dataPass the data directly via argumentsDon't pass data; just create an empty containerIn Java, I would create three constructors. Here's how it would look like if it were possible in Python:In Python, I see three obvious solutions, but none of them is pretty:A: Using keyword arguments:B: Using default arguments:C: Only provide constructor to create empty containers. Provide methods to fill containers with data from different sources.Solutions A and B are basically the same. I don't like doing the if/else, especially since I have to check if all arguments required for this method were provided. A is a bit more flexible than B if the code is ever to be extended by a fourth method to add data.Solution C seems to be the nicest, but the user has to know which method he requires. For example: he cant do  if he doesn't know what  is.Whats the most Pythonic solution?
You can't have multiple methods with same name in . Function overloading - unlike in  - isn't supported.Use default parameters or  and  arguments.You can make static methods or class methods with the  or  decorator to return an instance of your class, or to add other constructors.I advise you to do:⚠ Never have mutable types as defaults in python. ⚠  See here.
You can't have multiple constructors, but you can have multiple aptly-named factory methods. You can't easily prevent the user from using the constructor directly, though. (If it is critical, as a safety precaution during development, you can analyze the call stack in the constructor and check that the call is made from one of the expected methods.)
Most Pythonic would be what the Python standard library already does. Core developer Raymond Hettinger (the  guy) gave a talk on this, plus general guidelines for how to write classes.Use separate, class-level functions to initialize instances, like how  isn't the class initializer but still returns an instance of . This allows you to be flexible toward the arguments you need without changing method signatures as requirements change.
What are the system goals for this code?  From my standpoint, your critical phrase is   What experience do you want your users to have with your code?  That should drive the interface design.Now, move to maintainability: which solution is easiest to read and maintain?  Again, I feel that solution C is inferior.  For most of the teams with whom I've worked, solution B is preferable to A: it's a little easier to read and understand, although both readily break into small code blocks for treatment.
I'm not sure if I understood right but wouldn't this work?Or you could even do:Thank to Jon Kiparsky advice theres a better way to avoid global declarations on  and  so this is the new way:
If you are on Python 3.4+ you can use the  decorator to do this (with a little extra help from the  decorator that @ZeroPiraeus wrote for his answer):
The most pythonic way is to make sure any optional arguments have default values. So include all arguments that you know you need and assign them appropriate defaults. An important thing to remember is that any required arguments should not have defaults since you want an error to be raised if they're not included.You can accept even more optional arguments using  and  at the end of your arguments list.


Answer URL
https://docs.python.org/3/library/functools.html#functools.singledispatch
