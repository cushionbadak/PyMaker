Natural Text
I have recently came across a few posts on stack overflow saying that subprocess is much better than os.system, however I am having difficulty finding the exact advantages. Some examples of things I have run into:https://docs.python.org/3/library/os.html#os.system"The subprocess module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using this function."No idea in what ways it is more powerful though, I know it is easier in many ways to use subprocess but is it actually more powerful in some way?Another example is:https://stackoverflow.com/a/89243/3339122The advantage of subprocess vs system is that it is more flexible (you can get the stdout, stderr, the "real" status code, better error handling, etc...).This post which has 2600+ votes. Again could not find any elaboration on what was meant by better error handling or real status code. Top comment on that post is:Can't see why you'd use os.system even for quick/dirty/one-time. subprocess seems so much better. Again, I understand it makes some things slightly easier, but I hardly can understand why for example:is any better thanCan anyone explain some reasons it is so much better?
First of all, you are cutting out the middleman;  by default avoids spawning a shell that examines your command, and directly spawns the requested process. This is important because, besides the efficiency side of the matter, you don't have much control over the default shell behavior, and it actually typically works against you regarding escaping.In particular, generally you never do this:sinceIf passing a single string, either  must be  (see below) or else the string must simply name the program to be executed without specifying any arguments.Instead, you'll do:Notice that here all the escaping nightmares are gone.  handles escaping (if the OS wants arguments as a single string - such as Windows) or passes the separated arguments straight to the relevant syscall ( on UNIX).Compare this with having to handle the escaping yourself, especially in a cross-platform way ( doesn't escape in the same way as POSIX ), especially with the shell in the middle messing with your stuff (trust me, you don't want to know what unholy mess is to provide a 100% safe escaping for your command when calling ).Also, when using  without the shell in the middle you are sure you are getting correct return codes. If there's a failure launching the process you get a Python exception, if you get a return code it's actually the return code of the launched program. With  you have no way to know if the return code you get comes from the launched command (which is generally the default behavior if the shell manages to launch it) or it is some error from the shell (if it didn't manage to launch it).Besides arguments splitting/escaping and return code, you have way better control over the launched process. Even with  (which is the most basic utility function over  functionalities) you can redirect ,  and , possibly communicating with the launched process.  is similar and it avoids the risk of ignoring a failure exit code.  covers the common use case of  + capturing all the program output into a string variable.Once you get past  & friends (which is blocking just as ), there are way more powerful functionalities - in particular, the  object allows you to work with the launched process asynchronously. You can start it, possibly talk with it through the redirected streams, check if it is running from time to time while doing other stuff, waiting for it to complete, sending signals to it and killing it - all stuff that is way besides the mere synchronous "start process with default stdin/stdout/stderr through the shell and wait it to finish" that  provides.So, to sum it up, with :even at the most basic level ( & friends), you:avoid escaping problems by passing a Python list of arguments;avoid the shell messing with your command line;either you have an exception or the true exit code of the process you launched; no confusion about program/shell exit code;have the possibility to capture stdout and in general redirect the standard streams;when you use :you aren't restricted to a synchronous interface, but you can actually do other stuff while the subprocess run;you can control the subprocess (check if it is running, communicate with it, kill it).Given that  does way more than  can do - and in a safer, more flexible (if you need it) way - there's just no reason to use  instead.
There are many reasons, but the main reason is mentioned directly in the docstring:For almost all cases where you need a subprocess, it is undesirable to spawn a subshell.  This is unnecessary and wasteful, it adds an extra layer of complexity, and introduces several new vulnerabilities and failure modes.  Using  module cuts out the middleman.  


Answer URL
https://docs.python.org/3/library/os.html#os.system
