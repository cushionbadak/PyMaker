Natural Text
This is more of a conceptual question. I recently saw a piece of code in Python (it worked in 2.7, and it might also have been run in 2.5 as well) in which a  loop used the same name for both the list that was being iterated over and the item in the list, which strikes me as both bad practice and something that should not work at all.For example:Yields:Now, it makes sense to me that the last value printed would be the last value assigned to x from the loop, but I fail to understand why you'd be able to use the same variable name for both your parts of the  loop and have it function as intended. Are they in different scopes? What's going on under the hood that allows something like this to work?
What does  tell us:The key bits are sections 2 and 3 - we load the value out of  () and then we get its iterator () and start iterating over it ().  Python never goes back to load the iterator again. Aside: It wouldn't make any sense to do so, since it already has the iterator, and as Abhijit points out in his answer, Section 7.3 of Python's specification actually requires this behavior).When the name  gets overwritten to point at each value inside of the list formerly known as  Python doesn't have any problems finding the iterator because it never needs to look at the name  again to finish the iteration protocol.
Using your example code as the core referenceI would like you to refer the section 7.3. The for statement in the manualExcerpt 1The expression list is evaluated once; it should yield an iterable  object. An iterator is created for the result of the expression_list.What it means is that your variable , which is a symbolic name of an object  :  is evaluated to an iterable object. Even if the variable, the symbolic reference changes its allegiance, as the expression-list is not evaluated again, there is no impact to the iterable object that has already been evaluated and generated.NoteEverything in Python is an Object, has an Identifier, attributes and methods. Variables are Symbolic name, a reference to one and only one object at any given instance.Variables at run-time can change its allegiance i.e. can refer to some other object. Excerpt 2The suite is then executed once for each item provided by the  iterator, in the order of ascending indices.Here the suite refers to the iterator and not to the expression-list. So, for each iteration, the iterator is executed to yield the next item instead of referring to the original expression-list. 
It is necessary for it to work this way, if you think about it. The expression for the sequence of a  loop could be anything:We can't query the sequence on each pass through the loop, or here we'd end up reading from the next batch of 5 bytes the second time. Naturally Python must in some way store the result of the expression privately before the loop begins.Are they in different scopes?No. To confirm this you could keep a reference to the original scope dictionary (locals()) and notice that you are in fact using the same variables inside the loop:What's going on under the hood that allows something like this to  work?Sean Vieira showed exactly what is going on under the hood, but to describe it in more readable python code, your  loop is essentially equivalent to this  loop:This is different from the traditional indexing approach to iteration you would see in older versions of Java, for example:This approach would fail when the item variable and the sequence variable are the same, because the sequence  would no longer be available to look up the next index after the first time  was reassigned to the first item.With the former approach, however, the first line () requests an iterator object which is what is actually responsible for providing the next item from then on. The sequence that  originally pointed to no longer needs to be accessed directly.
It's the difference between a variable (x) and the object it points to (the list). When the for loop starts, Python grabs an internal reference to the object pointed to by x. It uses the object and not what x happens to reference at any given time.If you reassign x, the for loop doesn't change. If x points to a mutable object (e.g., a list) and you change that object (e.g., delete an element) results can be unpredictable.
Basically, the for loop takes in the list , and then, storing that as a temporary variable, reassigns a  to each value in that temporary variable. Thus,  is now the last value in the list.Just like in this:In this example,  is stored in  as , so although  is being reassigned, it still exist(ed) in  so that we could use it to trigger our  loop.
 no longer refers to the original  list, and so there's no confusion. Basically, python remembers it's iterating over the original  list, but as soon as you start assigning the iteration value (0,1,2, etc) to the name , it no longer refers to the original  list. The name gets reassigned to the iteration value.


Answer URL
https://docs.python.org/3/reference/compound_stmts.html#the-for-statement
