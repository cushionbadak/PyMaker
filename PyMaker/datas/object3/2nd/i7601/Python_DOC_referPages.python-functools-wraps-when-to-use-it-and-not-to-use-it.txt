Natural Text
In a comment on this answer to another question, someone said that they weren't sure what  was doing. So, I'm asking this question so that there will be a record of it on StackOverflow for future reference: what does  do, exactly?
When you use a decorator, you're replacing one function with another.  In other words, if you have a decoratorthen when you sayit's exactly the same as sayingand your function  is replaced with the function with_logging.  Unfortunately, this means that if you then sayit will print  because that's the name of your new function.  In fact, if you look at the docstring for , it will be blank because  has no docstring, and so the docstring you wrote won't be there anymore.  Also, if you look at the pydoc result for that function, it won't be listed as taking one argument ; instead it'll be listed as taking  and  because that's what with_logging takes.If using a decorator always meant losing this information about a function, it would be a serious problem.  That's why we have .  This takes a function used in a decorator and adds the functionality of copying over the function name, docstring, arguments list, etc.  And since  is itself a decorator, the following code does the correct thing:
I very often use classes, rather than functions, for my decorators.  I was having some trouble with this because an object won't have all the same attributes that are expected of a function.  For example, an object won't have the attribute .  I had a specific issue with this that was pretty hard to trace where Django was reporting the error "object has no attribute ''".  Unfortunately, for class-style decorators, I don't believe that @wrap will do the job.  I have instead created a base decorator class like so:This class proxies all the attribute calls over to the function that is being decorated.  So, you can now create a simple decorator that checks that 2 arguments are specified like so:
this is the source code about wraps:
As of python 3.5+:Is an alias for . It does exactly three things:it copies the , , , , and  attributes of  on . This default list is in , you can see it in the functools source.it updates the  of  with all elements from . (see  in the source)it sets a new  attribute on The consequence is that  appears as having the same name, docstring, module name, and signature than . The only problem is that concerning the signature this is not actually true: it is just that  follows wrapper chains by default. You can check it by using  as explained in the doc. This has annoying consequences:the wrapper code will execute even when the provided arguments are invalid.the wrapper code can not easily access an argument using its name, from the received *args, **kwargs. Indeed one would have to handle all cases (positional, keyword, default) and therefore to use something like .Now there is a bit of confusion between  and decorators, because a very frequent use case for developing decorators is to wrap functions. But both are completely independent concepts. If you're interested in understanding the difference, I implemented helper libraries for both: decopatch to write decorators easily, and makefun to provide a signature-preserving replacement for . Note that  relies on the same proven trick than the famous  library.
Prerequisite: You must know how to use decorators and specially with wraps. This comment explains it a bit clear or this link also explains it pretty well.Whenever we use For eg: @wraps followed by our own wrapper function. As per the details given in this link , it says thatfunctools.wraps is convenience function for invoking update_wrapper() as a function decorator, when defining a wrapper function. It is equivalent to partial(update_wrapper, wrapped=wrapped, assigned=assigned, updated=updated).So @wraps decorator actually gives a call to  functools.partial(func[,*args][, **keywords]).The functools.partial() definition says that The partial() is used for partial function application which “freezes” some portion of a function’s arguments and/or keywords resulting in a new object with a simplified signature. For example, partial() can be used to create a callable that behaves like the int() function where the base argument defaults to two: Which brings me to the conclusion that, @wraps gives a call to partial() and it passes your wrapper function as a parameter to it. The partial() in the end returns the simplified version i.e the object of what's inside the wrapper function and not the wrapper function itself.
In short, functools.wraps is just a regular function. Let's consider this official example. With the help of the source code, we can see more details about the implementation and the running steps as follows:wraps(f) returns an object, say O1. It is an object of the class PartialThe next step is @O1... which is the decorator notation in python. It means wrapper=O1.__call__(wrapper)Checking the implementation of __call__, we see that after this step, (the left hand side )wrapper becomes the object resulted by self.func(*self.args, *args, **newkeywords) Checking the creation of O1 in __new__, we know self.func is the function update_wrapper. It uses the parameter *args, the right hand side wrapper, as its 1st parameter. Checking the last step of update_wrapper, one can see the right hand side wrapper is returned, with some of attributes modified as needed. 


Answer URL
https://docs.python.org/3/library/inspect.html#inspect.signature
