Natural Text
In the code below, class A has a member function which is set to point to a function defined outside the class. in class B, the same function is set to the external pointer in the class definition.Calling the function for an object of type A will fail, because the self does not get passed to the function. But for B, the self gets passed.Why does the self get passed for B, but not for A?Output: 
When you did  you just assigned a function to an instance variable of the class . So when you call it you have to pass two arguments.When you did:during creation process of the class  python found a function  in the class scope and created an  from it (replaced the variable with name  with an  created from the function that it held before). When you call an  on an object  gets automatically passed as the first argument.You can check this by typing:
In class  you bind a function to an instance. This could be really considered as "function pointer" so all arguments must be passed explicitly. In class  you bind the function to the class which will cause the function to work as method. You could modify class definition  to which will give the same behavior has class , i.e.  of all instances points to , or you could wrap .This will allow to change  for each instance individually. The latter variant is probably what you were looking for.
The magic that makes  equivalent to  is dependent on the function object being an attribute of the class. The details vary (and with them, the ugly workaround by which you can create such a method). In Python 3, all functions are descriptors. In Python 2, there are special unbound method objects which are implicitly created to wrap functions stored as class attributes and do roughly what all functions do by themselves in Python 3.In either case, accessing it through an instance creates a bound method which passes the instance along as first argument when called. In either case, a function accessed through an instance attribute is in no way special, it's just another object which can be passed around and used.You can achieve similar behavior by either using  (a bit of a leaky abstraction):or by creating a method which delegates:
In the first case you create a field in the class, that has a method object stored in it. So "a.fp1" is not a method call and therefore "a" is not put as the first argument. It's a retrieval of a method object, and then calling it.For the second case, you can refer to the documentation:Any function object that is a class attribute defines a method for  instances of that class.So, for b "fp1" becomes a method for instances of class b.You can find more detailed explanation here: method objects vs function objects , Python class instances vs class


Answer URL
