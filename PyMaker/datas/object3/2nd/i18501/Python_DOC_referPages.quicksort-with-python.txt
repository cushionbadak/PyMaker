Natural Text
I am totally new to python and I am trying to implement quicksort in it.Could someone please help me complete my code?I do not know how to concatenate the three arrays and printing them. 

Quick sort without additional memory (in place)Usage:
There is another concise and beautiful versionLet me explain the above codes for detailspick the first element of array  as pivot those elements of array which are less than pivot with  those elements of array which are larger than pivot with 
If I search "python quicksort implementation" in Google, this question is the first result to pop up. I understand that the initial question was to "help correct the code" but there already are many answers that disregard that request: the currently second most voted one, the horrendous one-liner with the hilarious "You are fired" comment and, in general, many implementations that are not in-place (i.e. use extra memory proportional to input list size). This answer provides an in-place solution but it is for . So, below follows my interpretation of the in-place solution from Rosetta Code which will work just fine for  too:And if you are willing to forgo the in-place property, below is yet another version which better illustrates the basic ideas behind quicksort. Apart from readability, its other advantage is that it is stable (equal elements appear in the sorted list in the same order that they used to have in the unsorted list). This stability property does not hold with the less memory-hungry in-place implementation presented above.
There are many answers to this already, but I think this approach is the most clean implementation:You can of course skip storing everything in variables and return them straight away like this:
Quicksort with PythonIn real life, we should always use the builtin sort provided by Python. However, understanding the quicksort algorithm is instructive. My goal here is to break down the subject such that it is easily understood and replicable by the reader without having to return to reference materials.The quicksort algorithm is essentially the following:Select a pivot data point.Move all data points less than (below) the pivot to a position below the pivot - move those greater than or equal to (above) the pivot to a position above it.Apply the algorithm to the areas above and below the pivotIf the data are randomly distributed, selecting the first data point as the pivot is equivalent to a random selection.Readable example:First, let's look at a readable example that uses comments and variable names to point to intermediate values:To restate the algorithm and code demonstrated here - we move values above the pivot to the right, and values below the pivot to the left, and then pass those partitions to same function to be further sorted.Golfed:This can be golfed to 88 characters:To see how we get there, first take our readable example, remove comments and docstrings, and find the pivot in-place:Now find below and above, in-place:Now, knowing that  returns the prior element if false, else if it is true, it evaluates and returns the following element, we have:Since lambdas return a single epression, and we have simplified to a single expression (even though it is getting more unreadable) we can now use a lambda:And to reduce to our example, shorten the function and variable names to one letter, and eliminate the whitespace that isn't required.Note that this lambda, like most code golfing, is rather bad style.In-place Quicksort, using the Hoare Partitioning schemeThe prior implementation creates a lot of unnecessary extra lists. If we can do this in-place, we'll avoid wasting space.The below implementation uses the Hoare partitioning scheme, which you can read more about on wikipedia (but we have apparently removed up to 4 redundant calculations per  call by using while-loop semantics instead of do-while and moving the narrowing steps to the end of the outer while loop.).Not sure if I tested it thoroughly enough:ConclusionThis algorithm is frequently taught in computer science courses and asked for on job interviews. It helps us think about recursion and divide-and-conquer. Quicksort is not very practical in Python since our builtin timsort algorithm is quite efficient, and we have recursion limits. We would expect to sort lists in-place with  or create new sorted lists with  - both of which take a  and  argument. 
functional approach:
functional programming aproach
I think both answers here works ok for the list provided (which answer the original question), but would breaks if an array containing non unique values is passed. So for completeness, I would just point out the small error in each and explain how to fix them.For example trying to sort the following array  [12,4,5,6,7,3,1,15,1] (Note that 1 appears twice) with Brionius algorithm .. at some point will end up with the less array empty and the equal array with a pair of values (1,1) that can not be separated in the next iteration and the len() > 1...hence you'll end up with an infinite loopYou can fix it by either returning array if less is empty or better by not calling sort in your equal array, as in zangw answer The fancier solution also breaks, but for a different cause, it is missing the return clause in the recursion line, which will cause at some point to return None and try to append it to a list ....To fix it just add a return to that line
Partition - Split an array by a pivot that smaller elements move to the left and greater elemets move to the right or vice versa. A pivot can be an random element from an array. To make this algorith we need to know what is begin and end index of an array and where is a pivot. Then set two auxiliary pointers L, R.So we have an array user[...,begin,...,end,...]The start position of L and R pointers[...,begin,next,...,end,...]     R       Lwhile L < end  1. If a user[pivot] > user[L] then move R by one and swap user[R] with user[L]  2. move L by oneAfter while swap user[R] with user[pivot]Quick sort - Use the partition algorithm until every next part of the split by a pivot will have begin index greater or equals than end index.
Or if you prefer a one-liner that also illustrates the Python equivalent of C/C++ varags, lambda expressions, and if expressions:


A "true" in-place implementation [Algorithms 8.9, 8.11 from the Algorithm Design and Applications Book by Michael T. Goodrich and Roberto Tamassia]:
The algorithm has 4 simple steps:Divide the array into 3 different parts: left, pivot and right, where pivot will have only one element. Let us choose this pivot element as the first element of arrayAppend elements to the respective part by comparing them to pivot element. (explanation in comments)Recurse this algorithm till all elements in the array have been sortedFinally, join left+pivot+right partsCode for the algorithm in python:Carry on with this algorithm recursively with the left and right parts.
Another quicksort implementation:
For Version Python 3.x: a functional-style using  module, primarily to improve readability. and is tested as        

This is a version of the quicksort using Hoare partition scheme and with fewer swaps and local variables
I know many people have answered this question correctly and I enjoyed reading them. My answer is almost the same as zangw but I think the previous contributors did not do a good job of explaining visually how things actually work...so here is my attempt to help others that might visit this question/answers in the future about a simple solution for quicksort implementation.How does it work ?We basically select the first item as our pivot from our list and then we create two sub lists.Our first sublist contains the items that are less than pivot Our second sublist contains our items that are great than or equal to pivotWe then quick sort each of those and we combine them the first group +  pivot + the second group to get the final result.Here is an example along with visual to go with it ...(pivot)9,11,2,0average: n log of n worse case: n^2 The code:items=[9,11,2,0]print(quicksort(items))
The algorithm contains two boundaries, one having elements less than the pivot  (tracked by index "j") and the other having elements greater than the pivot (tracked by index "i"). In each iteration, a new element is processed by incrementing j.Invariant:- all elements between pivot and i are less than the pivot, and all elements between i and j are greater than the pivot.If the invariant is violated, ith and jth elements are swapped, and i is incremented. After all elements have been processed, and everything after the pivot has been partitioned, the pivot element is swapped with the last element smaller than it.The pivot element will now be in its correct place in the sequence. The elements before it will be less than it and the ones after it will be greater than it, and they will be unsorted.Selecting a pivotA "good" pivot will result in two sub-sequences of roughly the same size. Deterministically, a pivot element can either be selected in a naive manner or by computing the median of the sequence.A naive implementation of selecting a pivot will be the first or last element. The worst-case runtime in this case will be when the input sequence is already sorted or reverse sorted, as one of the subsequences will be empty which will cause only one element to be removed per recursive call.A perfectly balanced split is achieved when the pivot is the medianelement of the sequence. There are an equal number of elements greater than it and less than it. This approach guarantees a better overall running time, but is much more time-consuming.A non-deterministic/random way of selecting the pivot would be to pick an element uniformly at random. This is a simple and lightweight approach that will minimize worst-case scenario and also lead to a roughly balanced split. This will also provide a balance between the naive approach and the median approach of selecting the pivot.
First we declare the first value in the array to be thepivot_value and we also set the left and right marksWe create the first while loop, this while loop is there to tellthe partition process to run again if it doesn't satisfy thenecessary conditionthen we apply the partition processafter both partition processes have ran, we check to see if itsatisfies the proper condition. If it does, we mark it as done,if not we switch the left and right values and apply it againOnce its done switch the left and right values and return thesplit_pointI am attaching the code below! This quicksort is a great learning tool because of the Location of the pivot value. Since it is in a constant place, you can walk through it multiple times and really get a hang of how it all works. In practice it is best to randomize the pivot to avoid O(N^2) runtime.

Full example with printed variables at partition step:
Here's an easy implementation:-


This algorithm doesn't use recursive functions.Let  be any list of numbers with . Set  and execute the following program.Note: This is a stable sorting algorithm.PROGRAM OUTPUT:




Answer URL
https://docs.python.org/3/library/stdtypes.html#list.sort
