Natural Text
I'm trying to raise an exception within an  block but the interpreter tries to be helpful and prints stack traces 'by force'. Is it possible to avoid this?A little bit of background information: I'm toying with urwid, a TUI library for python. The user interface is started by calling  and ended by raising . So far this works fine but what happens when another exception is raised? E.g. when I'm catching  (the urwid MainLoop does not), I do some cleanup and want to end the user interface - by raising the appropriate exception. But this results in a screen full of stack traces.Some little research showed python3 remembers chained exceptions and one can explicitly raise an exception with a 'cause': . I learned a few ways to change or append data regarding the raised exceptions but I found no way to 'disable' this feature. I'd like to avoid the printing of stack traces and lines like  and just raise the interface-ending exception within an  block like I would outside of one.Is this possible or am I doing something fundamentally wrong?Edit:Here's an example resembling my current architecture, resulting in the same problem:Unfortunately I can't change  to except  as well. Is there a pattern to solve this?
I still don't quite understand your explanation, but from the code:There is no way that  could ever see the  exception. By the time you get to the  handle,  is guaranteed to have already finished (in this case, because of an unhandled ), so its exception handler is no longer active.So, what happens is that you raise a new exception that nobody catches. And when an exception gets to the top of your code without being handled, Python handles it automatically by printing a traceback and quitting.If you want to convert one type of exception into another so  can handle it, you have to do that somewhere inside the  block.You say:Unfortunately I can't change main_loop to except KeyboardInterrupt as well. If that's true, there's no real answer to your problem… but I'm not sure there's a problem in the first place, other than the one you created. Just remove the  from your code, and isn't it already doing what you wanted? If you're just trying to prevent Python from printing a traceback and exiting, this will take care of it for you.If there really is a problem—e.g., the  code has some cleanup code that you need to get executed no matter what, and it's not getting executed because it doesn't handle —there are two ways you could work around this.First, as the  docs explain:The  function allows to define custom handlers to be executed when a signal is received. A small number of default handlers are installed: …  is translated into a  exception.So, all you have to do is replace the default handler with a different one:Just do this before you start , and you should be fine. Keep in mind that there are some limitations with threaded programs, and with Windows, but if none of those limitations apply, you're golden; a ctrl-C will trigger an  exception instead of a , so the main loop will handle it. (You may want to also add an  block in your wrapper code, in case there's an exception outside of . However, you could easily write a  that sets and restores the signal around the call to , so there isn't any outside code that could possibly raise it.)Alternatively, even if you can't edit the  source code, you can always monkeypatch it at runtime. Without knowing what the code looks like, it's impossible to explain exactly how to do this, but there's almost always a way to do it.


Answer URL
