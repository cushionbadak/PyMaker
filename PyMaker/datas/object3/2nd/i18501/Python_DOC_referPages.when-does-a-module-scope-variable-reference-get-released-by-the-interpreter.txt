Natural Text
I'm trying to implement a clean-up routine in a utility module I have.  In looking around for solutions to my problem, I finally settled on using a  callback to do my cleanup.  However, I'm concerned that it won't work as expected because of a strong reference to the object from within the same module.  To illustrate:Other classes then reference .  I did find an old document from 1.5.1 that sort of references my concerns (http://www.python.org/doc/essays/cleanup/) but nothing that makes me fully comfortable that  will be released in such a way that the callback will be triggered reliably.  Can anyone point me towards some docs that would clear this question up for me?
The right thing to do here is to explicitly release your strong reference at some point, rather than counting on shutdown to do it.In particular, if the module is released, its globals will be released… but it doesn't seem to be documented anywhere that the module will get released. So, there may still be a reference to your object at shutdown. And, as Martijn Pieters pointed out:It is not guaranteed that  methods are called for objects that still exist when the interpreter exits.However, if you can ensure that there are no (non-weak) references to your object some time before the interpreter exits, you can guarantee that your cleanup runs.You can use  handlers to explicitly clean up after yourself, but you can just do it explicitly before falling off the end of your main module (or calling , or finishing your last non-daemon thread, or whatever). The simplest thing to do is often to take your entire  function and wrap it in a  or /.Or, even more simply, don't try to put cleanup code into  methods or weakref callbacks; just put the cleanup code itself into your  or  or .In a comment on another answer:what I'm actually trying to do is close out a subprocess that is normally kept open by a timer, but needs to be nuked when the program exits. Is the only really "reliable" way to do this to start a daemonic subprocess to monitor and kill the other process separately?The usual way to do this kind of thing is to replace the timer with something signalable from outside. Without knowing your app architecture and what kind of timer you're using (e.g., a single-threaded async server where the reactor kicks the timer vs. a single-threaded async GUI app where an OS timer message kicks the timer vs. a multi-threaded app where the timer is just a thread that s between intervals vs. …), it's hard to explain more specifically.Meanwhile, you may also want to look at whether there's a simpler way to handle your subprocesses. For example, maybe using an explicit process group, and killing your process group instead of your process (which will kill all of the children, on both Windows and Unix… although the details are very different)? Or maybe give the subprocess a pipe and have it quit when the other end of the pipe goes down?Note that the documentation also gives you no guarantees about the order in which left-over references are deleted, if they are. In fact, if you're using CPython,  specifically says that it's "done in random order".The source is interesting. It's obviously not explicitly randomized, and it's not even entirely arbitrary. First it does GC collect until nothing is left, then it finalizes the GC itself, then it does a  (which is basically just ), then there's another collect commented out (with some discussion as to why), and finally a  (which is defined only as "For internal use only").But this means that, assuming your module really is holding the only (non-weak) reference(s) to your object, and there are no unbreakable cycles involving the module itself, your module will get cleaned up at shutdown, which will drop the last reference to your object, causing it to get cleaned up as well. (Of course you cannot count on anything other than builtins, extension modules, and things you have a direct reference to still existing at this point… but your code above should be fine, because  can't be cleaned up before , and it doesn't rely on any other non-builtins.)Keep in mind that this is CPython-specific—and in fact CPython 3.3-specific; you will want to read the relevant equivalent source for your version to be sure. Again, the documentation explicitly says things get deleted "in random order", so that's what you have to expect if you don't want to rely on implementation-specific behavior.Of course your cleanup code still isn't guaranteed to be called. For example, an unhandled signal (on Unix) or structured exception (on Windows) will kill the interpreter without giving it a chance to clean up anything. And even if you write handlers for that, someone could always pull the power cord. So, if you need a completely robust design, you need to be interruptable without cleanup at any point (by journaling, using atomic file operations, protocols with explicit acknowledgement, etc.).
Python modules are cleaned up when exiting, and any  methods probably are called:It is not guaranteed that  methods are called for objects that still exist when the interpreter exits.Names starting with an underscore are cleared first:Starting with version 1.5, Python guarantees that globals whose name begins with a single underscore are deleted from their module before other globals are deleted; if no other references to such globals exist, this may help in assuring that imported modules are still available at the time when the  method is called.Weak reference callbacks rely on the same mechanisms as  methods do; the C deallocation functions ().The  instance will retain a reference to the  class method, but the global name  could be cleared already (it is assigned  in CPython); your method should be safe as it never refers to  once the callback has been registered.


Answer URL
