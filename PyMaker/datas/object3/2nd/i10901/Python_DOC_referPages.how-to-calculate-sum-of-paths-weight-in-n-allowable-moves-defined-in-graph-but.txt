Natural Text
This is the graph, I have made for the allowable moves and defined the weights in moves as I need to calculate sum of the weight of the path after certain number of moves(n) starting from '0'. The path can be random but from within those paths defined in graph, given the destination is not defined.I have tried the functions like this where the parameters given are starting and ending point. This works to find the path and calculate the weight traveled. But I need to be able to have the parameters as starting point and the number of moves but not the destination and find the sum of path's weight. Also the nodes can be visited as many number of times. Please help me to edit this function or may be my approach should be different.My Desired Output is:From the comments:The problem statement is "It chooses amongst the allowable moves uniformly at random and keeps track of the running sum S of nodes on which it lands." So my problem is to find the sum S of all the nodes on which it lands in K moves.
Here's a diagram of the graph that I created using some Python code and Graphviz. In the code you posted you have a  list. The purpose of that list is to prevent a node from being visited more than once. However, you aren't adding the initial  node to the  list, so that node can get visited twice. Here's a repaired version:outputAs Antti mentioned in the comments, it's better to do this using a generator which yields paths as it finds them, rather than saving all the results in a big list that gets returned at the end. And we can make the "visited" test more efficient by using a set instead of a list:We can use a similar approach to generate all the paths of a fixed length from a given starting node.outputBecause your graph has such a simple structure, and the edge weights conform to  there's probably a more efficient way to do this. Also, you could simplify  in various ways, eg you could use integers instead of strings for the node names, which would allow  to be a list or tuple instead of a , and instead of each node having a  of (node, weight) pairs, each node could just be a list or tuple of the nodes it connects to, since it's so easy to calculate the edge weights.UpdateYour actual problem is much simpler than what you originally asked for.We don't need to use recursion for this, we can just use a simple  loop which calls the  function from the  module to choose moves uniformly at random.outputIf you don't need the actual paths, just the node sums, this function can be simplified even further, but that will be left as an exercise for the reader.
Since you need only the sum, the solution is much easier.Start with a dictionary with only ; this is your starting position. For a new position after a move:make a new empty . then for for each  pair in your current positionfind the each  connected to add the sum of  to the value of key  in the new dictionary. Repeat these steps until you've done all K moves. The time complexity for this algorithm is O(NMK) where N is number of nodes, M is number of connections between pair of nodes, K is the number of moves.


Answer URL
https://docs.python.org/3/library/random.html
