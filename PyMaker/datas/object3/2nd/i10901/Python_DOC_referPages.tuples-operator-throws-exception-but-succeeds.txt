Natural Text
This question already has an answer here:Append to a list defined in a tuple - is it a bug? [duplicate]                    4 answers                Why does the following throw an exception, although it succeeds?
Found the answer on IRC. is several discrete actions:loading building a new list with  in itadding that  to whatever  isreassigning It seems that  is basically  (but, is it?)The tricky bit is that  implies assignment to both the tuple  and to the list  is not literally , it is: What really happens is: both mutates the list and returns it. So the list (which is the first element in ) has already got  appended to it.tuple's mutation is attempted in-place as well, but tuples are immutable, resulting in the exception.Why is this not visible in plain sight? Because a n00b like me would expect  to either succeed all together or fail, because it's one short line of python. But that's not always the case.
It can also help to understand this behavior by taking a look at the bytecode with .  The value of  is placed on top of the stack with , which is a (mutable) list in this case. The value on the top of the stack has  performed on it with , where in this case the top of the stack refers to the list inside the tuple. The assigning of  to the top of the stack occurs with , which fails here as  itself is an immutable tuple, raising the error after the  assignment has already occurred. 
The Python developers wrote an official explanation about why it happens here: https://docs.python.org/2/faq/programming.html#why-does-a-tuple-i-item-raise-an-exception-when-the-addition-worksThe short version is that += actually does two things, one right after the other:Take the thing on the right and add it to the variable on the leftPut the result into the variable on the leftIn this case, step 1 works because you’re allowed to add stuff to lists (they’re mutable), but step 2 fails because you can’t put stuff into tuples after creating them (tuples are immutable). In a real program, I would suggest you don't do this because t[0].extend(['c']) does the exact same thing.


Answer URL
https://docs.python.org/3/library/dis.html
