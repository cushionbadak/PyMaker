Natural Text
I read this question, but it didn't give me a clear answer:How does Python interpreter look for types?How does python interpreter know the type of a variable? I'm not looking how do get the type. I'm here looking at what happens behind the scene. In the example below, how does it associate the class int or string to my variable.How does it know that is an int:or that string:
how does it associate the class int or string to my variablePython doesn't. Variables have no type. Only the object that a variable references has a type. Variables are simply names pointing to objects.For example, the following also shows the type of an object, but no variable is involved:When you use , the  part of the expression simply returns the object that name references, passing in the object to the  function. When using  or , the expression is a literal producing the object, which is then passed to the  function.Python objects are simply datastructures in the interpreter memory; in CPython C structs are used. Variables are merely references (pointers) to those structures. The basic type struct in CPython is called , and this struct has a  slot that tells Python what type something is. Types are simply more C structures.If you wanted to follow along in the CPython source code, you'd start at the  source code (since  is a built-in name), which defines  as the  structure. Calling a type ( is a type too) invokes their  function, and  defines that as the  function. This function handles calls with one argument as follows:Here  is the  object you passed in; note, not a variable, but an object! So for your  integer object or  string object, the  macro result is returned.  is a macro that simply returns the  value of any  struct. So now you have the type object for either  or ; how come you see  or  in your interpreter session? The Python interactive interpreter automatically uses the  function on any expression results. In the C structure for  definitions the  struct is incorporated so all the slots for that type are directly available; I'll omit here exactly how that works. For type objects, using  means the  function is called which returns this:So in the end,  gets the  slot, (which turns out to be the  struct in Python 3, long story), and that structure has a  slot set to .TL;DR: Python variables have no type, they are simply pointers to objects. Objects have types, and the Python interpreter will follow a series of indirect references to reach the type name to print if you are echoing the object in your interpreter.
The concept "type" of a variable is "implemented" by using objects of a specific class.So inan object of type , as defined by the class  is returned by .   Python knows what type it is because that's how objects work: you know what type they are.   is now a  object, with value 0.0.With builtins, it's the same, it's just that they have shorthands for declaring them.is the same as  returns an object of class integer, with value 123.similarly is the same as returns an object of class str, with value "123"
Python variables have no type, they are just references to objects.  The size of a reference is the same regardless of what it is referring to.  In the C implementation of Python it is a pointer, and does have a type, it a pointer to a Python object: .  The pointer is the same type regardless of class of object.  Objects, on the other hand, know which class they belong to. It has been argued that Python has no variables, only names, although that's a step too far for most people.References in the CPython implementation have an id (identifier) which is actually a virtual address.  The detail and value of this address is not worth pursuing - it can (and probably will) change between versions and is not meant to be used for anything other than a unique number identifying the object.  Nevertheless it can provide interesting pointers (pardon the pun) to what is happening:Note that the id (address) of  and  are the same - they are referencing the same object, an  with the value 42.  So, what happens when we change , does  change as well?Thankfully not.  Now  is just referring to a new object of class  with the value "Hello".  When we:The id of  changed!  This is because it is now referencing a different object.  s are immutable, so the assignment  did not change the original object (42) it created a new one.  The object with the value 42 has its reference count decremented and can now (in theory) be deleted.  In practice it would probably remain in memory for efficiency reason, but thats an implementation detail.   However:So changing the list  has changed !  This is because lists are mutable, they can change.  The assignment  only copied the reference, not the list.  See copy in the standard library.


Answer URL
https://docs.python.org/3/c-api/structures.html#c.PyObject
https://docs.python.org/3/c-api/structures.html#c.PyObject_HEAD
https://docs.python.org/3/c-api/typeobj.html
https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_new
https://docs.python.org/3/c-api/structures.html#c.Py_TYPE
https://docs.python.org/3/library/functions.html#repr
