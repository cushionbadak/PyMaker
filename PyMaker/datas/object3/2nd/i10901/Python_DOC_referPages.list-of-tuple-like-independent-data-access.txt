Natural Text
I have some paired objects linked together in a same level priority basis. They can be grouped as fixed length tuples, all have to be in a list. Some objects type are unique, other can be common).For example, in this data structure i have an object, an object name (both unique), an object type and a bool (both common).Then I need to find an easy way to access to the other data knowing the unique objects. If I pick up "Banana" I'd get (myBanana, fruit, True), if I pick "myCar" I get (Car, vehicle, False). I don't need to access by the common values, they're just there to show that the data structure can have common values and they might change. The order might not be important, I used a list for simplicity.Obviously, I can create 2 dictionaries using one of the unique objects each as keys, but I could actually have a more complex situation with more unique objects types and some related data (e.g. the last bool) might change, which would force me to change all the other dictionaries.One idea could be create a class which contains separate lists for each data type, use index() for a selected "column" and return a tuple of the other list[index] values.Is there a better/faster/nicer/more elegant and pythonic way to do this?
I tried the solution in making a class. It does work and I believe it's fairly pythonic. It uses two dicts: one where each unique is a key for the commons and one dict containing the keys. Since no one has given an answer I thought I might as well share it.I tried it out and it does work as expected.It works for multiple keys and multiple values as well:The problem is that it'll might use up some memory when it grows in size.
I came out with three different solutions, in the meantime.1. Common dictionaryThe first is a common dictionary that uses every unique field as a key and the full group tuple transformed in a dictionary as a value. This doesn't need a class, a function returning the common dictionary is enough. That's a test function:Using the example list, the returned structure is like this:This doesn't eat much memory when the data grows, since every value is a reference to the full group dictionary, is easy to use since I can call  and obtain directly the result and appending values is just a matter of ; also the implementation is very simple, but some side effects: it returns a (obviously unordered) dictionary which contains the search key itself too, while I'd prefer to keep the insertion order without the search key, and if you have two similar keys in different key fields, the result will be overwritten.2. List of lists with inverted axesThe second solution is a class that uses list of lists from the originally given data, where every embedded list actually contains the field values for each one of the group data list. A test code:Then, the final structure would be like this:The only disadvantage from the first solution (which uses a simple structure.get()) is that a search query will involve at first a list.index() for a given field, and then a data[field_id][index] for every other search field. Also, you have to know the field id for the search query.3. Dictionary with list referenceThe third solution is a class that uses the original list of lists and a list containing a dictionary for every key field, which has a reference to the forementioned list index. The structure would be like this:Again, calling search query requires the user to know the field where the search will occur: given a field id and the search key, the method will do a get for that dict and will return a list of the other field values (minus the given key). I could also create a method that would search for every search field and returns a list of possible matches.This is a test class I made:This is actually a much more complex solution, but I think it has more advantages than the others: the original data structure doesn't ever change, even if there are similar keys for different fields; when the main data structure grows, the actual growth for the dictionaries is minimal, since they just contain a reference to the main data structure index. In the given example I used every field as a possible search field, adding an allowed search field index to the  might use much less memory: for example, specifying that only the first two fields can be search fields, will need only 2 reference dictionaries, not 4.I suppose that one should choose the solution according to his/her case scenario. In my case I don't actually need "real time" results, and I think that I'd stick with the last solution, maybe adding dynamic method creation and requiring field names on class init, allowing something like .But. I'm no programmer, I just do this for fun; so, if anyone has other ideas, I'd like to know, even if it's just to know about a different point of view. :)Thanks!PS: Also, if anyone has a better and clearer title for this question, I'd be happy to edit it.


Answer URL
https://docs.python.org/3/library/collections.html#collections.namedtuple
