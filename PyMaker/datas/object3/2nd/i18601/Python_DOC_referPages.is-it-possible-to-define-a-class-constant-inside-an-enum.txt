Natural Text
Python 3.4 introduces a new module , which adds an enumerated type to the language. The documentation for  provides an example to demonstrate how it can be extended:This example also demonstrates a problem with : in the  property method, a constant  is defined which would normally be defined at class level - but attempting to do so inside an  would simply add it as one of the members of the enum, so instead it's been defined inside the method.If the class wanted to use this constant in other methods, it'd have to be defined there as well, which obviously isn't ideal.Is there any way to define a class constant inside an , or some workaround to achieve the same effect?
This is advanced behavior which will not be needed in 90+% of the enumerations created.According to the docs:The rules for what is allowed are as follows:  names (starting and ending with a single underscore) are reserved by enum and cannot be used; all other attributes defined within an enumeration will become members of this enumeration, with the exception of  names and  (methods are also descriptors).So if you want a class constant you have several choices:create it in add it after the class has been createduse a mixincreate your own Creating the constant in  and adding it after the class has been created both suffer from not having all the class info gathered in one place.Mixins can certainly be used when appropriate (see dnozay's answer for a good example), but that case can also be simplified by having a base  class with the actual constants built in.First, the constant that will be used in the examples below:And the single-use Enum example:And, finally, the multi-use Enum example:Note:The   really isn't.  One could rebind  to something else:If you really need it to be constant (aka not rebindable), then use the new aenum library [1] which will block attempts to reassign s as well as  members.1 Disclosure:  I am the author of the Python stdlib , the  backport, and the Advanced Enumeration ()  library.
The most elegant solution (IMHO) is to use mixins / base class to provide the correct behavior.base class to provide the behavior that's needed for all implementation that's common to e.g.  and .mixins are interesting if you decide to provide optional behavior (e.g.  and  may have to provide a different behavior)Here is an example, where you first define your behavior:Then create your  with the correct base classes / mixins.
The reason why @property does NOT work and classconstant DOES work is quite simple, and explained in the answer hereThe reason that the actual property object is returned when you access  it via a class Hello.foo lies in how the property implements the   special method. If a descriptor is accessed on an instance, then that instance is passed as the  appropriate argument, and owner is the class of that instance.On the other hand, if it is accessed through the class, then instance  is None and only owner is passed. The property object recognizes this  and returns self.Thus, the code in  is actually a generalization of , lacking the  part.
A  can be used to provide most of the behaviour of a class constant:This would be a little unwieldy if you wanted to define a large number of constants, so you could define a helper function outside the class:... and use it as follows:One limitation of this approach is that it will only work for instances of the class, and not the class itself:
TLDR; NO, it can not be done inside an Enum class. This said, as the other answers showed, there are ways to get such class owned values associated to an Enum (i.e. via class inheritance / mixins) but such values are not "defined .. inside an Enum".    


Answer URL
https://docs.python.org/3/library/enum.html
