Natural Text
I've tried some code about bound and unbound methods. When we call them, I think both of them would return objects. But when I use  for getting some information, it returns something I don't understand.IDE: EclipsePlugin: pydevAnd the output is...Why do #1 and #2 return the same id? Aren't they different objects? And if we assign  and  to two variables, #3 and #4 return the different id.I think #3 and #4 show that they are not the same object, but #1 and #2...What is the difference between the id of bound method, and an unbound method?
Whenever you look up a method via  (and in Python 2, ), the method object is created a-new. Python uses the descriptor protocol to wrap the function in a method object each time.So, when you look up , a new method object is created, you retrieve its id (a memory address), then discard the method object again. Then you look up , a new method object created that re-uses the now freed memory address and you see the same value. The method is then, again, discarded (garbage collected as the reference count drops to 0).Next, you stored a reference to the  unbound method in a variable. Now the memory address is not freed (the reference count is 1, instead of 0), and you create a second method instance by looking up  which has to use a new memory location. Thus you get two different values.See the documentation for :Return the “identity” of an object. This is an integer (or long integer) which is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same  value.CPython implementation detail: This is the address of the object in memory.Emphasis mine.You can re-create a method using a direct reference to the function via the  attribute of the class, then calling the  descriptor method:Note that in Python 3, the whole unbound / bound method distinction has been dropped; you get a function where before you'd get an unbound method, and a method otherwise, where a method is always bound:Furthermore, Python 3.7 adds a new  -  opcode pair that replaces the current  -  opcode pair precisely to avoid creating a new method object each time. This optimisation transforms the executon path for  from  with , so 'manually' passing in the instance directly to the function object.
Adding to @Martijn Pieters's very good answer:


Answer URL
