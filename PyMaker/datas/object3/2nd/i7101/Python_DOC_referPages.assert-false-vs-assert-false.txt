Natural Text
A recent coding error of mine has made me think...I have been using  instead of  in one of my functions.This function is invoked only inside  clauses.So I never noticed this "compilation error", until I actually printed the details of the exception.Then it made me wonder if there were any runtime differences between the two.Of course, the "" here can be replaced with any other undefined symbol.Obviously, the printouts themselves would be different.Here's a simple test that I conducted:The printout of this test is:So my question is, are there any other runtime differences here? In particularly, I am interested to know if using  over  could somehow hinder the performance of my program.
Both versions are wrong and should never be used.: the  statement is never reached, because the  expression raises a  exception. That smells of a bug in your code, and not of a deliberate act on your behalf.Never use deliberate errors to raise an exception. You'd have to add a comment explaining why you did this to future maintainers of the code, but there never should be a reason to use this, because better alternatives exist.: this is a deliberate assertion failure, and looks like an attempt at debugging and not production code. Make your assertions before code that could fail if the assertion doesn't hold instead. If you need to have an exception exit your code at that point, raise an exception.Be explicit. Raise an exception. Even raising an  exception is better:From the two versions you should never ever use, in Python 3  is 'faster' because at least doesn't trigger a global name search. That's because in Python 3,  is a keyword and the compiler can thus optimise it by referencing a constant. However, there is little actual difference between the two. Since a deliberately failing assertion should by design never be reached, or reached at most once, worrying about how they perform is rather a moot point.
It's not a compilation error, both are runtime errors, and obviously there are differences: Evaluating  produced a NameError, meaning you referred to an undefined name. It's possible for another code path to cause the name to be defined, in which case the assertion might not fail. The trivial example would be a  statement above it (which obviously would be horrible in another way, with such a poor variable name). Either way it is a logic error that a code path that doesn't define the name can reach the expression. Asserting  is a way to force an  to be thrown. It's a pretty bad technique because you've added explicit code to fail without any sort of explanation why; we can't interpret the error and have to locate it in the code to figure out why it happened. Assertions should have both logical expressions and descriptions to assist in the debugging they're for. Either way, the way you've handled any exception loses lots of information. In particular, anything about where within the  the error occurred. A normal exception traceback (which can be accessed with traceback.print_exception and its ilk) contains this information in detail. In effect, this style of handling both  and - is preventing you from receiving useful information on any error except compilation time errors like SyntaxError and ImportError. The only sensible use of  I can think of it to test the  statement itself. In all normal use we include the condition for failure. 


Answer URL
https://docs.python.org/3/library/exceptions.html#AssertionError
https://docs.python.org/3/library/traceback.html#traceback.print_exception
https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement
