Natural Text
I have been trying to implement a queue in Python, and I've been running into a problem. I am attempting to use lists to implement the Queue data structure, however I can't quite figure out how to make  and  O(1) operations. Every example I have seen online, seems to just append the  operation and remove the first element from the list for the  operation. But this would make the  operation O(n) (where n is the size of the list) correct?Is there something basic I have missed? Or do you have to use LinkedLists to implement a Queue efficiently? 
As Uri Goren astutely noted above, the Python stdlib already implemented an efficient queue on your fortunate behalf: .What Not to DoAvoid reinventing the wheel by hand-rolling your own:Linked list implementation. While doing so reduces the worst-case time complexity of your  and  methods to O(1), the  type already does so. It's also thread-safe and presumably more space and time efficient, given its C-based heritage.Python list implementation. As I note below, implementing the  methods in terms of a Python list increases its worst-case time complexity to O(n). Since removing the last item from a C-based array and hence Python list is a constant-time operation, implementing the  method in terms of a Python list retains the same worst-case time complexity of O(1). But who cares?  remains pitifully slow.To quote the official  documentation:Though  objects support similar operations, they are optimized for fast fixed-length operations and incur O(n) memory movement costs for  and  operations which change both the size and position of the underlying data representation.More critically,  also provides out-of-the-box support for a maximum length via the  parameter passed at initialization time, obviating the need for manual attempts to limit the queue size (which inevitably breaks thread safety due to race conditions implicit in if conditionals).What to DoInstead, implement your  class in terms of the standard  type as follows:The proof is in the hellish pudding:It Is Dangerous to Go AloneActually, don't do that either.You're better off just using a raw  object rather than attempting to manually encapsulate that object in a  wrapper. The  class defined above is given only as a trivial demonstration of the general-purpose utility of the  API.The  class provides significantly more features, including:...iteration, pickling, , , , , membership testing with the in operator, and subscript references such as .Just use  anywhere a single- or double-ended queue is required. That is all.
You can keep head and tail node instead of a queue list in 
Queue implementation using list in Python, handling enqueue and dqueue as per inbuild queue data structure:
In dequeue method there is no any loop. You only have to do list operations. Therefore the time complexity for dequeue is also O(n)(linear).


Answer URL
https://docs.python.org/3/library/collections.html#deque-objects
https://docs.python.org/3/library/collections.html#deque-objects
https://docs.python.org/3/library/collections.html#deque-objects
