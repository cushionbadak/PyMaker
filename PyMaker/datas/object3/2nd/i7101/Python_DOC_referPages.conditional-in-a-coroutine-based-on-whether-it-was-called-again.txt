Natural Text
I am trying to translate this key "debouncing" logic from Javascript to Python. The idea is that subsequent key presses extend the timeout. The Javascript version prints:I don't want to translate the JS timeout functions, I'd rather have idiomatic Python using asyncio. My attempt in Python (3.5) is below, but it doesn't work as  is not actually updated when I expect.It prints: I have looked into asyncio ,  and  but it isn't clear to me how to use them for this. How would you implement the desired behavior using Python's asyncio? EDITSome more details on how I'd like to use . I have an async function that checks for key presses.Which in turn is scheduled along with other program tasksQeek's use of  and  makes sense. But how would I use it within a loop like this? Or is there another way to schedule the async tasks that would allow  calls to "overlap"? Actual code on GitHub if you are interested.
What's wrongBasically the  is very similar to the normal function call. The difference between function call and  is that the function call immediately start processing called function. The  statement insert called coroutine into queue inside event loop and give control to event loop and it decide which coroutine in it's queue will be processed.Here is the explanation of what you code does:It adds the  into event loop's queue.The event loop start processing coroutine in the queue.The queue contains only the  coroutine so it starts that.The code hits the .It adds the  in the event loop's queue.The event loop now contains the  and  but the main cannot be started because it is waiting for the result of the .So the event loop starts the .It will do some stuff until it hits the .Now the event loop contains ,  and .The  is waiting for result from .The  is waiting for result from .The sleep has no dependency so it can be started.The  returns  after 0.5 second.The event loop takes the  and return it into the  coroutine.The return value is ignored because it isn't assign into anythingThe  prints the key (because nothing change the state)The  coroutine at the end return None (because there isn't return statement).The  is returned to the main.Again the return value is ignored.The code hits the  and start processing new key.It run same steps from step 5 (but with the key ).How to fix itThe  coroutinr replace with this:The  adds into the event loop's queue the  and  and then the  give control to the event loop. The event loop from this point contains , ,  and .The  wiating for result from The  waiting until all tasks given as parameters are finishedThe  and  has no dependencies so they can be started. The event loop now contains 2 coroutine which can start but which one will it pick? Well... who knows it is implementation depended. So for better simulation of pressed keys this one replace should be a little better:Python 3.5 bonusFrom the documentation:Coroutines used with asyncio may be implemented using the async def statement.The async def type of coroutine was added in Python 3.5, and is recommended if there is no need to support older Python versions.It means that you can replace: with newer statementIf you start using the new syntax then you have to also replace  with .
Why your code doesn't work now?Both  javascript functions don't block execution. Each just clear timeout callback and set new one. It happens immediately.Coroutines work another way: using  or newer syntax  on coroutine means that we want to resume execution flow only after this coroutine if fully done: in your code - is not setting callback by timeout, but code that should be done before  finsihed.Let's try to make code workYou can create task to start execution some coroutine "in background". You can also cancel task (just like you do with ) if you don't want it to be finished.Python version that emulates your javascript snippet:Idiomatic?While code above works, it is not how  should be used. Your javascript code based on callbacks, while  usually is about to avoid using of callbacks.It's hard to demonstrate difference on your example since it's callback based by nature (key handling - is some sort of global callback) and doesn't have more async logic. But this understanding would be important later when you'll add more async operations.Right now I advice you to read about / in modern javascript (it's similar to Python's /) and look at examples comparing it to callbacks/promises. This article looks good.It'll help you understand how you can use coroutine-based approach in Python.Upd:Since  needs to periodically call  you'll have to use loop. But it can be done as task along with your event loop.If you had some sort of  (this is usually how different libs allow to handle user input) you could use it to set some  directly and avoid loop.Consider possibility write some little gui app with  from the beginning. I think it may help you to better understand how you can adapt your existing project.Here's some pseudo-code that shows background task to handlebuttons and using asyncio to handle some simple UI events/states logic:.


Answer URL
https://docs.python.org/3/reference/compound_stmts.html#async-def
https://docs.python.org/3/library/asyncio-task.html#task
https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.cancel
