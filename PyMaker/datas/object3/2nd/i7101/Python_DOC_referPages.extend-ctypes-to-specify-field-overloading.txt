Natural Text
I would like to extend ctypes Structure, BigEndianStructure, LittleEndianStructure.The ability to specify each field to have a description, and overload how the variable is returned to possibly enum, polyco, etc attributes.Something like the following is what I would like to do, but am not sure how to make the ModifedCTypesStructure parent class.My goal is to use this for commanding / telemetry of binary data.
It is possible - most of the magic provided by  is due to its fields being "descriptors" - i.e. objects that follow Python's descriptor protocol - analog to what we get when we use the  decorator in a class body. has a metaclass that is responsible to convert each field listed in the special cased  variable name  into a  object (you can check that by verifying the result of  in an interactive Python prompt. Therefore, in order to extend the behavior for the fields themselves, we'd need to extend this  class - and modify the metaclass that creates your Strutcture to use our fields.  The CField class seems to be a normal Python class itself - so it is easy to modify, if we respect the call to the super-methods.however there are some catches in your "wishlist": using "help" requires the Python object to have the help string embedded in its class  attribute (not the instance). So we can do that each time the field itself is retrieved from the structure class, we ceae dynamically a new class with the required help.When retrieving a value from an object, Python can't "know" in advance if the value will be used just for being "viewed" by  or will actually be used. Therefore we either customize the value that is returned by  for one that have a custom representation or we don't do it at all. The code bellow does create a dynamic class on field retrieval that will have a custom representation, and try to preserve all other numeric properties of the underlying value. But that is set to be both slow and may present some incompatibilities - you may choose to turn that off when not debugging values, or simply get the raw value.Ctype's "Fields" will of course have some internal structure of their own, like the offset for each memory position and so on - thus, I'd suggest the following approach:(1) create a new "Field" class that does not inherit from ctypes.Field at all - and that implement the enhancements you want; (2) Upon ModifiedStructure creation create all the "_" prefixed names, and pass these for the original Ctypes.Structure metaclass to create its fields as it always does; (3) make our "Field" class read and write to the original ctypes.Fields, and have their custom transforms and representations.As you can see, I also took care of actually transforming Enum values upon writting.To try everything, just inherit from "ModifiedStructure" bellow, instead of : And testing it on the interactive prompt:
This is what I came up with after playing around with metaclasses for a while. I haven't ever used them so I wasnt sure if this was the correct approach.I couldnt figure out the repr thing.  Im going to play around with your solution @jsbueno.  I ended up building and appending properties to the classes on creation.Everything i read was saying not to use metaclasses 99% of the time so kind of wondering if I was going down the wrong path.Also I wanted to use the same metaclass for BigEndian / LittleEndian structures forgot to add that to the wish list.


Answer URL
https://docs.python.org/3/reference/datamodel.html#implementing-descriptors
