Natural Text
's type is "type":'s type is "builtin function or method":However, they seem the same in nature. Excluding the obvious difference in functionality (reversing vs. sorting sequences), what's the reason for this difference in implementation?
The difference is that  is an iterator (it's also lazy-evaluating) and  is a function that works "eagerly".All built-in iterators (at least in python-3.x) like , , , , ... are implemented as classes. While the eager-operating built-ins are functions, e.g. , , ,  and .You actually need to "consume" the iterator to get the values (e.g. ):On the other hand this "consuming" part isn't needed for functions like :In the comments it was asked why these are implemented as classes instead of functions. That's not really easy to answer but I'll try my best:Using lazy-evaluating operations has one huge benefit: They are very memory efficient when chained. They don't need to create intermediate lists unless they are explicitly "requested". That was the reason why ,  and  were changed from eager-operating functions (python-2.x) to lazy-operating classes (python-3.x).Generally there are two ways in Python to create iterators:classes that  in their  methodgenerator functions - functions that contain a However (at least CPython) implements all their built-ins (and several standard library modules) in C. It's very easy to create iterator classes in C but I haven't found any sensible way to create generator functions based on the Python-C-API. So the reason why these iterators are implemented as classes (in CPython) might just be convenience or the lack of (fast or implementable) alternatives.There is an additional reason to use classes instead of generators: You can implement special methods for classes but you can't implement them on generator functions. That might not sound impressive but it has definite advantages. For example most iterators can be pickled (at least on Python-3.x) using the  and  methods. That means you can store them on the disk, and allows copying them. Since Python-3.4 some iterators also implement  which makes consuming these iterators with  (and similar) much faster.Note that  could easily be implemented as factory-function (like ) but unlike , which can return two unique classes,  can only return one unique class.To illustrate the possible (and unique) classes you have to consider a class that has no  and no  method but are iterable and reverse-iterable (by implementing  and ):And while it makes sense to add an abstraction layer (a factory function) in case of  - because the returned class is depending on the number of input arguments:That reasoning doesn't apply to :
What's the difference between  and ?Interestingly,  is not a function, while  is.Open a REPL session and type :It is indeed a class which is used to return a reverse iterator.Okay, so  isn't a function. But why not?This is a bit hard to answer. One explanation is that iterators have lazy evaluation. This requires some sort of container to store information about the current state of the iterator at any given time. This is best done through an object, and hence, a .


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__length_hint__
https://docs.python.org/3/library/functions.html
