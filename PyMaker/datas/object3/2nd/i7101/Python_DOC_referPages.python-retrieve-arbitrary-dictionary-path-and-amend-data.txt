Natural Text
Simple Python question, but I'm scratching my head over the answer!I have an array of strings of arbitrary length called , like this:I also have a dictionary, , and a string, . I know that the dictionary is of arbitrary depth and is dictionaries all the way down, with the exception of the  property, which is always an array. [CLARIFICATION: The point of this question is that I don't know what the contents of  will be. They could be anything. I also don't know what the dictionary will look like. I need to walk down the dictionary as far as the path indicates, and then delete the unwanted properties from there, without knowing in advance what the path looks like, or how long it will be.]I want to retrieve the parts of the data object (if any) that matches the , and then delete the  from each. So in the example above, I would like to retrieve:and then delete  from each of the items in the array. I want to amend the original data, not a copy. (CLARIFICATION: By this I mean, I'd like to end up with the original dict, just minus the unwanted properties.)How can I do this in code? I've got this far:The problem is that this doesn't amend the original data. It also relies on  always being the last string in the path, which may not always be the case.CLARIFICATION: I mean that I'd like to end up with:Whereas what I have available in  is only .I feel like I need something like XPath for the dictionary. 
The problem you are overwriting the original  reference. Change your processing code toIn this version, you set  to point to the same object that  was referring to.  is not a copy, so any changes you make to it will be visible in the original object. Then you step  along itself, while  remains a reference to the root dictionary. When you find the path you are looking for, any changes made via  will be visible in .I also removed the line . It creates an unnecessary copy of the list that you never need, since you are not modifying the references stored in the list, just the contents of the references.The fact that  is not pre-determined (besides the fact that  is going to be a ) means that you may end up getting a  in the first loop if the path does not exist in your dictionary. You can handle that gracefully be doing something more like:
The problem you are facing is that you are re-assigning the  variable to an undesired value. In the body of your  loop you are setting  to the next level down on the tree, for instance given your example  will have the following values (in order), up to when it leaves the  loop:Then when you delete the items from your dictionaries at the end you are left with  being a list of those dictionaries as you have lost the higher parts of the structure. Thus if you make a backup reference for your data you can get the correct output, for example:

You need to remove the key .This will remove the key. The second parameter  is returned if the key  does not exist.EDIT:You can use  even without the second parameter. It will raise  if the key does not exist. EDIT 2: Updated to recursively go into depth of  dict until it finds the  key, where it pops the  as desired and append into the  list to get the desired output.
Using operator.itemgetter you can compose a function to return the final key's value.Then use it like this:Of course if the path contains non-existent keys it will throw a KeyError - you probably should account for that:
You can try this:Output:


Answer URL
https://docs.python.org/3/library/operator.html#operator.itemgetter
