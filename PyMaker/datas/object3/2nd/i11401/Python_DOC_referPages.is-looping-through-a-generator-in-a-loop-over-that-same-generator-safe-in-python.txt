Natural Text
From what I understand, a  loop in Python is roughly equivalent to this:That suggests that something like this:would do two things:Not raise any exceptions, segfault, or anything like thatIterate over  until it reaches some  where  returns truthy, then loop over it in the inner  until  returns true. Then, the outer loop resumes where the inner one left off.From my admittedly not very good tests, it seems to perform as above. However, I couldn't find anything in the spec guaranteeing that this behavior is constant across interpreters. Is there anywhere that says or implies that I can be sure it will always be like this? Can it cause errors, or perform in some other way? (i.e. do something other than what's described aboveN.B. The code equivalent above is taken from my own experience; I don't know if it's actually accurate. That's why I'm asking.
TL;DR: it is safe with CPython (but I could not find any specification of this), although it may not do what you want to do.First, let's talk about your first assumption, the equivalence.A for loop actually calls first  on the object, then runs  on its result, until it gets a .Here is the relevant bytecode (a low level form of Python, used by the interpreter itself): calls  (which itself calls ) and pushes its result on the stack (think of it as a bunch of local unnamed variables), then enters the loop at , which calls  (which itself calls ), then executes the code inside the loop, and the  makes the execution comes back to .Now, for the safety:Here are the methods of a generator: https://hg.python.org/cpython/file/101404/Objects/genobject.c#l589As you can see at line 617, the implementation of  is , whose implementation you can find here.  simply returns the object (ie. the generator) itself.So, when you nest the two loops, both iterate on the same iterator.And, as you said, they are just calling  on it, so it's safe.But be cautious: the inner loop will consume items that will not be consumed by the outer loop.Even if that is what you want to do, it may not be very readable.If that is not what you want to do, consider , which buffers the output of an iterator, allowing you to iterate over its output twice (or more). This is only efficient if the tee iterators stay close to each other in the output stream; if one tee iterator will be fully exhausted before the other is used, it's better to just call  on the iterator to materialize a list out of it.
No, it's not safe (as in, we won't get the outcome that we might have expected).Consider this:Of course, we will get 0 to 19 printed.Now let's add a bit of code:The only thing that will be printed is .By the time that we get to the second iteration of the outer loop, the generator will already be exhausted by the inner loop.We can also do this:If it was safe we would expect to get 0 to 19 printed 20 times, but we actually get it printed only once, for the same reason I mentioned above.
It's not really an answer to your question, but I would recommend not doing this because the code isn't readable. It took me a while to see that you were using  twice even though that's the entire point of your question. Don't make a future reader get confused by this. When I see a nested loop, I'm not expecting what you've done and my brain has trouble seeing it.I would do it like this:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.tee
