Natural Text
I want an array X of shape (n_samples,n_cols,n_rows,n_channels). I want an array y with a shape (n_sample,n_cols,n_rows,n_channels)I have tried and I get this error: ValueError: setting an array element with a sequence.I figure this must be a somewhat common operation - any time someone wants to load image data into an array in numpy so there must be something Im missing? 
 requires that you state the dtype. If you use , then each value from the iterable must be a float. If you yield single NumPy arrays from , you could use their  attribute to obtain iterators over the flatten array values which could be concatenated with  and then passed to :Since  returns a 1D array, you would then need to reshape it:Note that this relies on each image having the same shape.Finally, to load the  values into  and the  values into :Regarding the question in the comments:If I wanted to do extra processing to L and ab, where would I do that?I believe in separating the loading from the processing of the data. By keeping the two functions distinct, you leave open the possibility of passing different data from different sources to the same processing function. If you put both the loading and the processing of the data (such as a KNN classification of the ab values) into  then there is no way to reuse the KNN classification code without loading the data from files.If you allow us to change the order of the axes from  to,then the code could be simplified using :This code is simpler and therefore preferable to the code (using ) above. 
 does not support simultaneous array creation and then return them as a tuple, (to be unpacked into )  It is possible there is a way to do this in  but not to my knowledge, you may need to split the iterator into a  instead
Usually when we create an array with iteration we either collect the values in a list, and create the array from that.  Or we allocate an empty list and assign values to slots.Here's a way of doing the assignment, where the generator returns a tuple of arrays:I made one an array of ints, the other an array of floats.  That reduces the temptation to concatenate them into one.        Lets allocate target arrays of the right shape; here I put the iteration axis 3rd, but it could be anywhereMy guess this is as fast as any  or  alternative.  And when the components are generated by reading from files, that step is bound to be the most expensive - more so than the iteration mechanism or array copies.================If the iterator returned a tuple of scalars, we can use :producing a 1d structured array:which can be reshaped, and arrays separated by field name:================What if I define a more complex , one where each field has an array:This use of a compound dtype with  is also described in https://stackoverflow.com/a/12473478/901925This is, in effect, a variation on the usual way of building a structured array - from a list of tuples.  More than once I've use the expression:In sum we can time two methods of creating 2 arrays:For a wide range of  these 2 functions take nearly the same time.  I have to push run times to 1s before I starting an advantage for .


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.tee
