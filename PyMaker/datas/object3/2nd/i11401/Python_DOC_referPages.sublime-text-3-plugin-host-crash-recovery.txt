Natural Text
I develop a plugin for Sublime Text 3 and my python code uses c type bindings to clang. Sometimes calling libclang would segfault with  (I don't understand the reason yet, but it is irrelevant to this question). This then leads to crashing plugin host.So the question is: is there any way in python to recover from a failure in the underlying c binding? I would gladly just skip this action on this particular file where I experience the crash.Thanks! UPD: There was a short discussion in comments and it makes sense to elaborate further on the lack of a proper small reproducible example. It is not vecause of my laziness, I do try to make it as easy as possible to understand the issue for the people I expect help from. But in this case it is really hard. The original issue is caused by libclang segfaulting in some strange situation which I haven't nailed down yet. It probably has something to do with one library being compiled with no c++11 support and the other one using it while being compiled with c++11 support, but I want to emphasize - this is irrelevant to the question. The issue here is that there is a segfault in something that python is calling and this segfault causes Sublime Text plugin_host to exit. So there is simple example here, but not for the lack of trying. I am also open to suggestions if you have ideas how to construct one. And sorry for the poor quality of this question, this is currently my best.
Working with the detail that I have, I'm reasonably sure your question boils down to "can Python handle errors that occurred when using the foreign function interface."  I'm pretty sure that the answer is "no", and I put together the following test scenario to explain why:Here's our test C++ module (with a bit of C for name-mangling purposes) that will blow up in our face,  :And our calling script, :Call it:This crashes Python as expected and generates a nice "report error" detail on OS X:I copy and pasted this because it's cleaner/easier to parse than an strace (also, I'm lazy ;).The call to  is where we crashed; we never see a return to Python, which means it's out of our control.To prove this, modify our  into  to try to catch the exception:And running it again:Unfortunately, and as far as I know, we cannot catch the exception/crash at the Python layer because it happened "beneath" the control of bytecode.  A non-specific  clause will try to catch any exception that occurs, where the following statement is the action taken when an exception gets caught.  was never sent to stdout, and we crashed, which means Python doesn't get a chance to react.If you can, handle this exception in your C++ code.  You may be able to get creative and use multiprocessing to fork into a process that can crash without taking down your main process, but I doubt it.


Answer URL
https://docs.python.org/3/library/multiprocessing.html
