Natural Text
I want to keep track of objects of a certain type that are currently in use. For example: Keep track of all instances of a class or all classes that have been created by a metaclass.It is easy to keep track of instances like this:But if an instance is not referenced anywhere outside of that list it will not be needed anymore and I do not want to process that instance in a potentially time consuming loop.I tried to remove objects that are only referenced in the list using sys.getrefcount.The problem I have is that the reference count is very obscure.Opening a new shell and creating a dummy class with no content returns 5 forAnother idea is to copy the objects then deleting the list and checking which objects have been scheduled for garbage collecting and in the last step removing those objects. Something like:The objects don't have to be removed immediately when the reference count goes to 0. I just don't want to waste too much ressources on objects that are not used anymore.
This answer is the same as Kevin's but I was working up an example implementation with weak references and am posting it here. Using weak references solves the problem where an object is referenced by the  list, so it will never be deleted.One of the things about creating a weak reference for an object is that you can include a callback when the object is deleted. There are issues such as the callback not happening when the program exits... but that may be what you want anyway.
The standard way to solve this problem is through weak references.  The basic idea is that you keep a list of weak references to objects instead of the objects themselves, and periodically prune the dead weak references from the list.For dictionaries and sets, there are some more abstract types such as  which can be used when you want to put weak references in more complex places like the keys of a dictionary.  These types do not require manual pruning.
Try the . The  module Documentation
Thanks to @Barmar for pointing out to use weakref. We can combine it with the  method to implement a self managing instance list of a class. Thus, the  in OP's post can be extended as:TestingThe destructor  can be declared as a static method or a object-bound method like , although it is not documented. The latter can stop the object from being destroyed by creating another reference to it. Here I use the static one because there is no need for another reference to the dieing object. The code above is tested in both Python 2.7 and 3.3.The  callback behaves similar to  except that it is bound to the "weakref" object. So if you create multiple weakrefs for the same object with the same callback function, it will be called exact the same time as the number of weakrefs.


Answer URL
https://docs.python.org/3/library/weakref.html
