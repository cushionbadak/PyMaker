Natural Text
So I've seen similar questions about this error, and they all seem to be related to use cases where there are ManyToMany relationships. However, I'm getting this issue even though my model doesn't have M2M relationships, so I wanted to ask and see why this was happening.Here is my model:Whenever I create a new instance of this model, I get the  for the , , and  fields.I instantiate it like so:However if I change the affected fields to  and , then the error goes away.Why does this happen? I was under the impression that the  parameter was optional for ; I don't even know what it means in the context of an . Can someone explain this behavior, and/or what I'm doing wrong?
You are defining the fields as their classes' references, and not as an instance of those classes. It should be
If anyone's interested I think what happens in the  metaclass is fairly interesting. Overly verbose for answering this question? Almost certainly, I was originally not going to post but perhaps it will help (assuming what I have is correct of course). I've always found it more useful to understand why something works rather than why it doesn't. I'm not going to attempt to try to explain every little part that would be a monumental task, and am sticking to what's (hopefully) directly relevant.   ¯\_(ツ)_/¯(Also, it's likely I made a few errors in places, I don't dive into source code very often, please do feel free to correct)Let's create a random model:Let's see what happens behind the scenes for something this deceptively simple. For the more complicated stuff, it's turtles all the way down.We have  as the base class, but it has  as it's metaclass. And,  has a  method:The source for the  method of this metaclass is fairly long. Here's a link to the contents of the file in .There's two other classes we'll be concerned with  and .Were you to print  or if you were to simply look inside  in  you would see the  class and a method named .Remember the  method, more on this later.Let's break down the relevant components of the  method. If you've ever seen a metaclass then you should be familiar with the arguments to the new function.If not then check this link out: What is a metaclass in Python here is the dictionary that contains all methods, attributes, etc.Stuff happens, then we have this line:Now, what is add to class? It is this function:We could stop right here, and I could have actually started with this function. This is the entire problem. You never initialize models.FieldName and thus it is not an instance that passes the condition . Instead, the else statement is executed and it simply becomes a class attribute (which doesn't contribute). As the name suggests  simply checks if the object has said attribute available (passed as a string to hasattr).If you just did  with  you'd see that it was simply a reference to the class .Getting back on track, let's keep going! What if it does pass this condition? Then, we have that  now calls  with the parameters  and .But, what does  do?! Here's the function :Really, what we care about here is .Now, we need to backtrack. At this point things are probably starting to get confusing, but hopefully all will be clear in a moment.Recall the  line:Depending upon how long you've been using Django at some point it is very likely you've used the  attribute more than likely like this .Well, here it is!!Now, recall (again) the  function the  class instance has no method  and is thus added to the class as an attribute .I'm not going to paste the  function here. It's also a bit long-winded and is fairly well commented. You can find it here and it's about 1/4 of the way down. I'd recommend reading the comments and once you have the function should be more or less intuitive.So, now there's this new attribute  (which is an Option class instance) that has the class method  available to it.And, here's the  method:The comments are fairly self explanatory again. However, what might be confusing is the line . Here,  is simply short for bisect.bisect_right from the python module bisect. As the comments says the fields are inserted in the order in which they are created, which is a sorted order. Using bisect allows the list to retain sorted order while inserting, it locates the proper insertion index.What's next in the  method of the  metaclass?We have the following line:Now, recall that  is the dict containing well everything. So, it's looping through the object names (keys) and the objects (values) of this dictionary. And, as discussed earlier looking for instances with the  method otherwise it is simply added as an attribute to the class instance (the new class to be created remember  is actually creating the class here). And, that process sort of repeats.Then, the next two lines:Here, itertools.chain is flatting these lists into a single list and returns a chain object.This chain object is then iterated over calling the attribute  from the  class (remember the fields are actually instances of (subclasses) ) into a  and a  is simply a collection of objects without duplicates.More things happen, but I'm just going to end here as I think everything else is fairly redundant at this point for this example.


Answer URL
https://docs.python.org/3/library/bisect.html#bisect.bisect_right
