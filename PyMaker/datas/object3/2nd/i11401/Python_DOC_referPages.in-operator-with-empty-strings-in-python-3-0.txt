Natural Text
This question already has an answer here:Why empty string is on every string? [duplicate]                    2 answers                As I am going through tutorials on Python 3, I came across the following:My understanding is that  equals no blank spaces.When I try the following the shell terminal, I get the output shown below it:Can someone please help explain what is happening?
 is the empty string, same as . The empty string is a substring of every other string.When  and  are strings, the expression  checks that  is a substring of . That is, the sequence of characters of  must exist in ; there must be an index  such that . If  is empty, then any index  satisfies this condition.This does not mean that when you iterate over , you will get . Unlike other sequences, while every element produced by  satisfies ,  does not imply that  will be produced by iterating over .So  and  returns True for any string :
The string literal  represents the empty string. This is basically a string with a length of zero, which contains no characters.The  operator is defined for sequences to return “ if an item of  is equal to , else ” for an expression . For general sequences, this means that one of the items in  (usually accessible using iteration) equals the tested element . For strings however, the  operator has subsequence semantics. So  is true, when  is a substring of .Formally, this means that for a substring  with a length of , there must be an index  which satisfies the following expression: .This is easily understood with an example:Algorithmically, what the  operator (or the underlying  method) needs to do is iterate the  to all possible values () and check if the condition is true for any .Looking back at the empty string, it becomes clear why the  check is true for every string :  is zero, so we are checking ; and that is the empty string itself for every valid index :It is even true for  being the empty string itself, because sequence slicing is defined to return an empty sequence when a range outside of the sequence is specified (that’s why you could do  on short strings).So that explains why the containment check with  always returns  when checking the empty string as a substring. But even if you think about it logically, you can see the reason: A substring is part of a string which you can find in another string. The empty string however can be find between every two characters. It’s like how you can add an infinite amount of zeros to a number, you can add an infinite amount of empty strings to a string without actually modifying that string.
As Rushy Panchal points out,  inclusion operator follows set-theoretic convention and assumes that an empty string is a substring of any string.You can try to persuade yourself why this makes sense by considering the following: let  be a string such that . Then  better be false by transitivity (or else there is a subset of  that contains , but  does not contain , etc). But then , which isn't great either. So you cannot pick any string  such that  which does not create a problem.Of course, when in doubt, simulate it:


Answer URL
https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals
https://docs.python.org/3/library/stdtypes.html#common-sequence-operations
