Natural Text
So using 'php index.php' gives me the output I want in the command line. But will not give the output on the webpage. So first of all I have this python file which basically does everything I want:Secondly I just have a sh executable that will put the output of this python command into another text file: I then have the php file on an apache web server running on the raspberry pi, it reads:So if I'm not wrong, each time the page is refreshed it should execute that, wait for the exec to finish, then display the txt file contents? I have tried both shell_exec and just exec, they both do the same..
There are many rights, you have to ensure:the apache user has to be in the sudoers groupthe apache user must write to the apache user must write to must be executable for the apache userFor point 1 to 3, it is normally not a good idea, to give the apache users these rights.You can make it easier if you start your python script as CGI:The only point 1 and 4 must be fullfilled.
I suspect your problem is the  part of the  command line.  If you replace the  with , I think you will find that command raises a .Presumably, your user account is in the  file, but the Web server is not.Since the first thing the shell's output redirect operator () does is truncate the output file, that failed attempt to run  results in a zero-byte .  The rest of the Python script then does the same to , and you end up with nothing to display on your Web site.SolutionsNo  required.On my Linux desktop, I do not need to run  as root to do a local ping scan.  If that's true on your system, then you should be able to just drop the  part of your  command, and be done with it.There is a difference, though.   will perform a more thorough testing of each target when the  ping sweep is run by .  From an old  man page (emphasis added): (Skip port scan) .[...]The  option sends an ICMP echo request, TCP SYN to port 443, TCP ACK to port 80, and an ICMP timestamp request by default.  When executed by an unprivileged user, only SYN packets are sent (using a connect call) to ports 80 and 443 on the target.  When a privileged user tries to scan targets on a local ethernet network, ARP requests are used unless  was specified.  [...]Enable  for your Web server.If you need this extra information (and it sounds like you do), you'd need to run  (or the Python script that calls it) with super-user privileges.  I've never tried to force a Web server to do this, but I assume you would at least have to add your Web server's user to .  Something like:or:...and so on, depending on the user name, where your  is located, how strictly you want to limit the arguments to , etc.Create an SUID executable to run  for you.Alternatively (and I hate myself for recommending this --- there must be a better way) is to write a tiny SUID (Set User ID) program that executes only the  command you want.  Here's a C program that will do it:Save the above as something like , and compile with:Then, move it to wherever you keep your Web site's scripts, and as root, change its ownership and permissions:The leading  sets the SUID bit.  A color  of the directory will probably show that file highlighted.  The permissions should look like this:Any user who runs  will be temporarily promoted to whoever owns the  file (in this case, ) until the program exits.  That's extraordinarily generous, which is why I hard-coded everything in that program...  To change anything it does --- even just the IP range to scan --- you'll have to edit  file, re-compile, and re-install.I've tested  on my command line, and it produces privileged-user  output when run by an unprivileged user who normally gets only limited output.Comments on the Python scriptIn general, Python is vastly better at parsing shell arguments than the shell is (the default value for  is  for a reason), so have your Python script do as much of the job as possible, including parsing the shell command, redirecting input, and redirecting output.A major advantage of doing the work in Python is that failure to open, read, write, or close any of your files will result in an immediate crash and a stack trace --- instead of the silent failure you've been dealing with.I'd rewrite that  command to use a list of explicitly separated arguments.  You can handle the output redirection by passing an opened file stream to the  parameter.  You can eliminate your last bit of shell redirection by having Python open your output file and write to it explicitly.Also, unless you need that  file for something else, you can eliminate it entirely by using  to store the output from the  command as a string, and then splitting it into separate lines.  (The  parameter also handles converting the  object into a , at least in Python 3.)Note that I used  blocks to get the file closing for free.(Finally, that series of  commands is crying out to be rewritten as a  loop, with the strings you're searching for as the keys in that dictionary, and the output you want to print as the values.)


Answer URL
