Natural Text
I probably don't understand python's lambda very much. So it confuses me evry time. For example if I have this simple lambda construction with constant, everything works perfect:But if I substitute  random number generator instead of constant 0.5, it would stuck and never returns back....Why?! And what to do to avoid it?
Here are some ways to achieve what you want. First, some code-golf:I'll leave you to deciphering that as an exercise (a great way to explore itertools!). And also as a good lesson on why you shouldn't write cryptic one-liners...However, I would probably just do:See how much more readable and straight-forward that is? 6 months from now, I'll re-read that and know exactly what I was trying to do.Here it is in action:OK, here is a reward for reading this far... the one-liner works thusly: takes a function and an iterable. The  will yield from the iterable as long as the function returns . The function I use is , which is the partial-application of the ,  is equivalent to , so we take while  is greater than the value returned by the iteterable. Finally, the iterable is .  (only on Python 3) takes an iterable and keeps adding the iterables values to it... i.e. accumulating. So, e.g:The iterable I pass to  is  which just calls random.random until the value is , which is never.
 stops when the  function returns exactly . The function does return , so the iterator stops there, but that could have gone differently by a fluke of floating-point rounding. only stops if the  function returns exactly , but this time, it is extremely unlikely that the function will ever return that value. Your list comprehension filters iterator elements forever.Note that both of your code snippets rely on Python 2 list comprehension variable scope behavior, where the  in the comprehension's  clause is the same as the  from the function the comprehension appears in. That changed in Python 3, so neither of your code snippets work on Python 3.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.accumulate
