Natural Text
I have a master class for a planet:I also have a few classes that inherit from  and I want to make one of them unable to be destroyed (not to inherit the  function)Example:So when this is run,it should produce an error like:
The mixin approach in other answers is nice, and probably better for most cases. But nevertheless, it spoils part of the fun - maybe obliging you to have separate planet-hierarchies - like having to live with two abstract classes each ancestor of "destroyable" and "non-destroyable".First approach: descriptor decoratorBut Python has a powerful mechanism, called the "descriptor protocol", which is used to retrieve any attribute from a class or instance - it is even used to ordinarily retrieve methods from instances - so, it is possible to customize the method retrieval in a way it checks if it "should belong" to that class, and raise attribute error otherwise.The descriptor protocol mandates that whenever you try to get any attribute from an instance object in Python, Python will check if the attribute exists in that object's class, and if so, if the attribute itself has a method named . If it has,  is called (with the instance and class where it is defined as parameters) - and whatever it returns is the attribute. Python uses this to implement methods: functions in Python 3 have a  method that when called, will return another callable object that, in turn, when called will insert the  parameter in a call to the original function.  So, it is possible to create a class whose  method will decide whether to return a function as a bound method or not depending on the outer class been marked as so - for example, it could check an specific flag . This could be done by using a decorator to wrap the method with this descriptor functionalityAnd on the interactive prompt:         Perceive that unlike simply overriding the method, this approach raises the error when the attribute is retrieved - and will even make  work: Although, it won't work if one tries to retrieve the method directly from the class, instead of from an instance - in that case the  parameter to   is set to None, and we can't say from which class it was retrieved - just the  class, where it was declared.Second approach:  on the metaclass:While writting the above, it occurred me that Pythn does have the   special method. If the  class itself implements  and we'd try to delete the   method on specifc derived classes, it wuld nt work:  gards the attribute deletion of attributes in instances - and if you'd try to  the "destroy" method in an instance, it would fail anyway, since the method is in the class.However, in Python, the class itself is an instance - of its "metaclass". That is usually  . A proper  on the metaclass of "Planet" could make possible the "disinheitance" of the "destroy" method by issuing a `del UndestructiblePlanet.destroy" after class creation.Again, we use the descriptor protocol to have a proper "deleted method on the subclass":And with this method, even trying to retrieve or check for the method existense on the class itself will work:metaclass with a custom  method.Since metaclasses allow  one to customize the object that contains the class namespace, it is possible to have an object that responds to a  statement within the class body, adding a  descriptor. For the user (programmer) using this metaclass, it is almost the samething, but for the  statement been allowed into the class body itself:(The 'deleted' descriptor is the correct form to mark a method as 'deleted' - in this method, though, it can't know the class name at class creation time)As a class decorator:And given the "deleted" descriptor, one could simply inform the methods to be removed as a class decorator - there is no need for a metaclass in this case:Modifying the  mechanism:For sake of completeness - what really makes Python reach methods and attributes on the super-class is what happens inside the  call. n the  version of  is where the algorithm with the priorities for "data-descriptor, instance, class, chain of base-classes, ..." for attribute retrieval is encoded.So, changing that for the class is an easy an unique point to get a "legitimate" attribute error, without need for the "non-existent" descritor used on the previous methods.The problem is that 's  does not make use of 's one to search the attribute in the class - if it did so, just implementing the  on the metaclass would suffice. One have to do that on the instance to avoid instance lookp of an method, and on the metaclass to avoid metaclass look-up. A metaclass can, of course, inject the needed code:
If  is a unique (or at least unusual) case, it's probably easiest to just redefine :From the point of view of the user of the class, this will behave as though  doesn't exist … unless they go poking around with , which is always a possibility.If it happens more often that you want subclasses to inherit some properties and not others, the mixin approach in chepner's answer is likely to be more maintainable. You can improve it further by making  an abstract base class:This has the advantage that if you try to instantiate the abstract class , you'll get an error pointing you at the problem:… similarly if you inherit from  but forget to define :
Rather than remove an attribute that is inherited, only inherit  in the subclasses where it is applicable, via a mix-in class. This preserves the correct "is-a" semantics of inheritance.You can provide suitable definitions for  in any of , , or any class that inherits from .
Metaclasses and descriptor protocols are fun, but perhaps overkill.  Sometimes, for raw functionality, you can't beat good ole' .
You cannot inherit only a portion of a class. Its all or nothing.What you can do is to put the destroy function in a second level of the class, such you have the Planet-class without the destry-function, and then you make a DestroyablePlanet-Class where you add the destroy-function, which all the destroyable planets use.Or you can put a flag in the construct of the Planet-Class which determines if the destroy function will be able to succeed or not, which is then checked in the destroy-function.


Answer URL
https://docs.python.org/3/library/abc.html
