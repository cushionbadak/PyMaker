Natural Text
I have a lists of floats with some hidden "level" information encoded in the scale of the float, and I can split the "levels" of floats as such:[out]:And I have another list that will correspond to the  list:I need to check how many of the easy, med and hard matches the all scores, I could do this to get the boolean of whether there's a match on the flatten  list as such:[out]:Is there a way to know how many easy/med/hard there are in the matches and the sum of the matches per level?I have tried this and it works:[out]:But there must be a less verbose way to achieve the same output.
Here is a numpy solution using  to create the categories and  to count and sum the matches. As a free bonus these stats are also created for the left-overs.
Sounds to me like a job for... Counter!If you haven't come across it yet,  is like dict, but instead of new values replacing old values in methods like  they just get added onto them. So:So you get your result above with the following code:
You can work around with  :
You can use a series of dicts as lookup tables:
I am not sure if this method is less verbose or not, but I would use  to match the scores:This code does not yield the same output as the one you have, but I think the data you provided has been corrupted somehow. For example, you have two copies of both  and  in your -array. Is this expected? There is also two  in the easy array.Output with my method given the current dataAlso, I'm not entirely sure how you do your summing, and so I simply do a sum over all the matched scores (and thus our values will be different).EDIT: Using matching  with  instead. The only thing that changes is that we'll have to do a double matching with  instead:This removes the problem of duplicates before. Output:EDIT 2: I realised that my use of  is superfluous, and it's possible to remove them altogether.Yields the same output as the first edit.EDIT 3: I put it all together in one program. It's also possible to use numpy to conveniently do the splitting of easy/medium/hard scores. It could probably be made more efficient, but this is quite readable:
Though your question has been answered, I still wanted to give it a try (for practice sake). The function is giving the expected output but Paul Panzer's solution is by far the most optimal one. :)   


Answer URL
https://docs.python.org/3/library/collections.html#collections.Counter
