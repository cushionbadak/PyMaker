Natural Text
I have a python program that loads quite a bit of data before running. As such, I'd like to be able to reload code without reloading data. With regular python,  has been working fine. Here's an example:setup.py:foo/bar.pyrunner.py:But this doesn't seem to work. If I edit bar.pyx and run  I don't see my changes. I also tried  with no luck -- the module rebuilt but didn't reload. I'm running in a "normal" python shell, not IPython if it makes a difference.
I was able to get a solution working for Python 2.x a lot easier than Python 3.x. For whatever reason, Cython seems to be caching the shareable object () file it imports your module from, and even after rebuilding and deleting the old file while running, it still imports from the old shareable object file. However, this isn't necessary anyways (when you , it doesn't create one), so we can just skip this anyways.The largest problem was that python kept a reference to the old module, even after ing. Normal python modules seem to work find, but not anything cython related. To fix this, I run execute two statements in place of This successfully (though probably less efficiently) reloads the cython module. The only issue that remains in in Python 3.x running that subprocess creates a problematic shareable objects. Instead, skip that all together and let the  work its magic with the  module, and recompile for you. I also added an option to the  command to specify the language level to match what you've specified in the So all together:runner.pyOther two files remained unchangedRunning:-replace  in foo/bar.pyx with , and press Enter.
Cython-extensions are not the usual python-modules and thus the behavior of the underlying OS shimmers through. This answer is about Linux, but also other OSes have similar behavior/problems (ok, Windows wouldn't even allow you to rebuild the extension).A cython-extension is a shared object. CPython opens this shared object via  and calls the init-function, i.e.  in Python3, which among other things registers the functions/functionality provided by the extension.The most important thing: When  loads a shared object with the same path as one already loaded shared object, it will not read it from the disc, but just reuse the already loaded version - even if it is a different version on the disc.And this is the problem with our approach: As long as the resulting shared object has the same name as the old one, you will never get to see the new functionality in the interpreter without restarting it.What are your options?A: Use  with Let's assume your Cython () module looks as follows:Now import it with pyximport: was built and loaded (we can see, it prints 42 while loading, as expected). Let's take a look at the file of :You can see the additional -prefix compared to the case built with . Seeing the file-name, we also verify that there is no other  lying in the path somewhere and being wrongly loaded.Now let's change  to  in the  and reload the file: What happened?  built an extension with a different prefix () and loaded it. It was successful, because the name/path of the new extension is different due to the new prefix and we can see  printed while loaded.However,  is still the old version! If we look up the -documentation, we see:When reload() is executed:Python module’s code is recompiled and the module-level code re-executed,    defining a new set of objects which are bound to names in    the module’s dictionary by reusing the loader which originally loaded    the module. The  function of extension modules is not called a    second time. (i.e. )  isn't executed for extension (that means also for Cython-extensions), thus  with -module-definition isn't called and one is stuck with the old definition bound to . This behavior is sane, because for some extension, -function isn't supposed to be called twice. To fix it we have to import the module  once again:Now  is reloaded as good as it gets - which means there might be still old objects being in use. But I trust you to know what you do.B: Change the name of your extensions with every versionAnother strategy could be to build the module  as  and then  and so on and load it as This is strategy used by -magic in IPython, which uses sha1-hash of the Cython-code as prefix.Even if reloading and reloading of extension in particular is kind of hacky, for prototyping purposes I would probably go with -solution... or use IPython and -magic.


Answer URL
https://docs.python.org/3/library/importlib.html#importlib.reload
https://docs.python.org/3/c-api/module.html#c.PyModuleDef_Init
