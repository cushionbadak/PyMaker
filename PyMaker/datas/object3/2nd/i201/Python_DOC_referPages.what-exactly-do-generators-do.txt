Natural Text
I am reading the Python cookbook at the moment and am currently looking at generators. I'm finding it hard to get my head round.As I come from a Java background, is there a Java equivalent? The book was speaking about 'Producer / Consumer', however when I hear that I think of threading.What is a generator and why would you use it? Without quoting any books, obviously (unless you can find a decent, simplistic answer direct from a book). Perhaps with examples, if you're feeling generous!
Note: this post assumes Python 3.x syntax.†A generator is simply a function which returns an object on which you can call , such that for every call it returns some value, until it raises a  exception, signaling that all values have been generated. Such an object is called an iterator.Normal functions return a single value using , just like in Java. In Python, however, there is an alternative, called . Using  anywhere in a function makes it a generator. Observe this code:As you can see,  is a function which yields  and . Every call to  yields a single value, until all values have been yielded.  loops call  in the background, thus:Likewise there are generator expressions, which provide a means to succinctly describe certain common types of generators:Note that generator expressions are much like list comprehensions:Observe that a generator object is generated once, but its code is not run all at once. Only calls to  actually execute (part of) the code. Execution of the code in a generator stops once a  statement has been reached, upon which it returns a value. The next call to  then causes execution to continue in the state in which the generator was left after the last . This is a fundamental difference with regular functions: those always start execution at the "top" and discard their state upon returning a value.There are more things to be said about this subject. It is e.g. possible to  data back into a generator (reference). But that is something I suggest you do not look into until you understand the basic concept of a generator.Now you may ask: why use generators? There are a couple of good reasons:Certain concepts can be described much more succinctly using generators.Instead of creating a function which returns a list of values, one can write a generator which generates the values on the fly. This means that no list needs to be constructed, meaning that the resulting code is more memory efficient. In this way one can even describe data streams which would simply be too large to fit in memory.Generators allow for a natural way to describe infinite streams. Consider for example the Fibonacci numbers:This code uses  to take a finite number of elements from an infinite stream. You are advised to have a good look at the functions in the  module, as they are essential tools for writing advanced generators with great ease.  † About Python <=2.6: in the above examples  is a function which calls the method  on the given object. In Python <=2.6 one uses a slightly different technique, namely  instead of . Python 2.7 has  call  so you need not use the following in 2.7:
A generator is effectively a function that returns (data) before it is finished, but it pauses at that point, and you can resume the function at that point.and so on.  The (or one) benefit of generators is that because they deal with data one piece at a time, you can deal with large amounts of data; with lists, excessive memory requirements could become a problem.   Generators, just like lists, are iterable, so they can be used in the same ways:Note that generators provide another way to deal with infinity, for exampleThe generator encapsulates an infinite loop, but this isn't a problem because you only get each answer every time you ask for it.
First of all, the term generator originally was somewhat ill-defined in Python, leading to lots of confusion. You probably mean iterators and iterables (see here). Then in Python there are also generator functions (which return a generator object), generator objects (which are iterators) and generator expressions (which are evaluated to a generator object).According to the glossary entry for generator it seems that the official terminology is now that generator is short for "generator function". In the past the documentation defined the terms inconsistently, but fortunately this has been fixed.It might still be a good idea to be precise and avoid the term "generator" without further specification.
Generators could be thought of as shorthand for creating an iterator.  They behave like a Java Iterator.  Example:Hope this helps/is what you are looking for.Update:As many other answers are showing, there are different ways to create a generator.  You can use the parentheses syntax as in my example above, or you can use yield.  Another interesting feature is that generators can be "infinite" -- iterators that don't stop:
There is no Java equivalent.Here is a bit of a contrived example:There is a loop in the generator that runs from 0 to n, and if the loop variable is a multiple of 3, it yields the variable.During each iteration of the  loop the generator is executed. If it is the first time the generator executes, it starts at the beginning, otherwise it continues from the previous time it yielded.
I like to describe generators, to those with a decent background in programming languages and computing, in terms of stack frames.In many languages, there is a stack on top of which is the current stack "frame".  The stack frame includes space allocated for variables local to the function including the arguments passed in to that function.  When you call a function, the current point of execution (the "program counter" or equivalent) is pushed onto the stack, and a new stack frame is created.  Execution then transfers to the beginning of the function being called.With regular functions, at some point the function returns a value, and the stack is "popped".  The function's stack frame is discarded and execution resumes at the previous location.When a function is a generator, it can return a value without the stack frame being discarded, using the yield statement.  The values of local variables and the program counter within the function are preserved.  This allows the generator to be resumed at a later time, with execution continuing from the yield statement, and it can execute more code and return another value.Before Python 2.5 this was all generators did.  Python 2.5 added the ability to pass values back in to the generator as well.  In doing so, the passed-in value is available as an expression resulting from the yield statement which had temporarily returned control (and a value) from the generator.The key advantage to generators is that the "state" of the function is preserved, unlike with regular functions where each time the stack frame is discarded, you lose all that "state".  A secondary advantage is that some of the function call overhead (creating and deleting stack frames) is avoided, though this is a usually a minor advantage.
The only thing I can add to Stephan202's answer is a recommendation that you take a look at David Beazley's PyCon '08 presentation "Generator Tricks for Systems Programmers," which is the best single explanation of the how and why of generators that I've seen anywhere.  This is the thing that took me from "Python looks kind of fun" to "This is what I've been looking for."  It's at http://www.dabeaz.com/generators/.
It helps to make a clear distinction between the function foo, and the generator foo(n):foo is a function.foo(6) is a generator object.The typical way to use a generator object is in a loop:The loop printsThink of a generator as a resumable function. behaves like  in the sense that values that are yielded get "returned" by the generator. Unlike return, however, the next time the generator gets asked for a value, the generator's function, foo, resumes where it left off -- after the last yield statement -- and continues to run until it hits another yield statement.Behind the scenes, when you call  the generator object bar is defined for you to have a  attribute.You can call it yourself to retrieve values yielded from foo:When foo ends (and there are no more yielded values), calling  throws a StopInteration error.
This post will use Fibonacci numbers as a tool to build up to explaining the usefulness of Python generators.This post will feature both C++ and Python code.Fibonacci numbers are defined as the sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ....Or in general:This can be transferred into a C++ function extremely easily:But if you want to print the first six Fibonacci numbers, you will be recalculating a lot of the values with the above function.For example: , but  also recalculates .  The higher the value you want to calculate, the worse off you will be.So one may be tempted to rewrite the above by keeping track of the state in .But this is very ugly, and it complicates our logic in . It would be better to not have to worry about state in our  function.We could return a  of values and use an  to iterate over that set of values, but this requires a lot of memory all at once for a large number of return values.So back to our old approach, what happens if we wanted to do something else besides print the numbers? We'd have to copy and paste the whole block of code in  and change the output statements to whatever else we wanted to do.And if you copy and paste code, then you should be shot.  You don't want to get shot, do you?To solve these problems, and to avoid getting shot, we may rewrite this block of code using a callback function.  Every time a new Fibonacci number is encountered, we would call the callback function.This is clearly an improvement, your logic in  is not as cluttered, and you can do anything you want with the Fibonacci numbers, simply define new callbacks.But this is still not perfect. What if you wanted to only get the first two Fibonacci numbers, and then do something, then get some more, then do something else?Well, we could go on like we have been, and we could start adding state again into , allowing GetFibNumbers to start from an arbitrary point.But this will further bloat our code, and it already looks too big for a simple task like printing Fibonacci numbers.We could implement a producer and consumer model via a couple of threads. But this complicates the code even more.Instead let's talk about generators.Python has a very nice language feature that solves problems like these called generators.A generator allows you to execute a function, stop at an arbitrary point, and then continue again where you left off.Each time returning a value.Consider the following code that uses a generator:Which gives us the results:0  1  1  2  3  5The  statement is used in conjuction with Python generators.  It saves the state of the function and returns the yeilded value.  The next time you call the next() function on the generator, it will continue where the yield left off.This is by far more clean than the callback function code. We have cleaner code, smaller code, and not to mention much more functional code (Python allows arbitrarily large integers).Source
I believe the first appearance of iterators and generators were in the Icon programming language, about 20 years ago.You may enjoy the Icon overview, which lets you wrap your head around them without concentrating on the syntax (since Icon is a language you probably don't know, and Griswold was explaining the benefits of his language to people coming from other languages).After reading just a few paragraphs there, the utility of generators and iterators might become more apparent.
Experience with list comprehensions has shown their widespread utility throughout Python. However, many of the use cases do not need to have a full list created in memory. Instead, they only need to iterate over the elements one at a time.For instance, the following summation code will build a full list of squares in memory, iterate over those values, and, when the reference is no longer needed, delete the list:Memory is conserved by using a generator expression instead:Similar benefits are conferred on constructors for container objects:Generator expressions are especially useful with functions like sum(), min(), and max() that reduce an iterable input to a single value:more


Answer URL
