Natural Text
I have the following SQL query and would like to parse it using would give all the tokens included in the SQL statement:How can I parse these tokens in order to process  statements in a way that I can extract all the conditions and maintain their precedence as defined by the use of parentheses. I was not able to find any relevant examples in the documentation. Any thoughts on this?
The project is indeed a little underdocumented. I looked at the examples and scanned the source code a little. The documentation unfortunately doesn't include all methods on the  and  classes that are useful for this task.For example, an important but omitted method is the  method, which lets you traverse over nested token lists more easily than other methods do; the  method only yields ungrouped tokens in the tree, whereas  is a grouped token, so going purely by the documentation you might find it hard to do something useful with the parsed token tree.Another handy method that I noticed in the codebase is the  method, which dumps out the current token tree to stdout. This is very helpful when trying to write code that analyses the tree.All in all my overall impression of  is that it is less of a parsing library than a tool to re-format SQL. It includes a good parser but doesn't include the tools necessary to make general use of the tree it produces.What is really missing in the library is a base node visitor class such as that provided by the Python  module, or a tree node walker, again like the  module provides. Either is easy enough to build yourself, luckily:Now you can use either to access the  nodes:orThe difference between the  and  patterns is negligible in this example, but we are simply extracting the separated tokens for each of the  statements, with no processing of the  tokens. In the  pattern you'd set more attributes on the current visitor instance to 'switch gears' and capture further information about those subtree tokens in more  methods, which may be easier to follow than a nested  loop over a generator.On the other hand, with the  generator, if you create a separate variable to reference the generator, you can hand over iteration to helper functions:where  would further iterate until it came to the end of the case statement.


Answer URL
https://docs.python.org/3/library/ast.html#ast.NodeVisitor
https://docs.python.org/3/library/ast.html#ast.walk
