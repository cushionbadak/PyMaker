Natural Text
EDIT FOR CLARITY: This question is in reference to venv, which is often confused with virtualenv.What are the consequences of removing the system's Python installation which was the source used to create virtual environments on the system using ?Ultimately, what I'm looking to do is remove the 3.7 installation and install 3.8 when it is released, but I'm unsure of how strongly tethered a virtual environment is to the system environment.Some system details that may be relevant when asking this question:OS = Red Hat Enterprise Linux 73.7 installed from source at Python.org, not the  packge in the yum repo.Python 3.7 is installed to the default location,  is a link to Given the above details, I am under the impression that Python 3.8 would install to  and  would then be pointing to that version.Does the virtual environment have enough within it to be a stable 3.7 environment of its own? Or will it fall apart, trying to reference a system install that no longer exists?tl;dr:What happens to all those virtual environments that were created from a Python source that is no longer existent / replaced with a newer version?
Bad news: You're using , and  virtual environments are not completely standalone. Even when created with , all it copies is the  executable itself, not the standard libraries, not even (if your install creates a shared  rather than a static one) ; it relies on the system copy. The virtual environment will break if the Python install it was based on goes away. How it breaks will differ based on how it was created. For example, if you created it with:when  meant Python 3.7, then replaced  with Python 3.8, then you can fix up the virtual env for the new version with:but your installed third party packages will be (effectively) gone (they'll be in , but Python 3.8 will only be looking in ), so you'll have to reinstall them.If you created the virtual environment with:then it's completely broken (at least as documented), the  switch is only documented to work for upgrading when Python was upgraded in place; since the new Python would not be named , you can't upgrade in place. That said,  really only works well when upgrading micro versions (from 3.7.1 to 3.7.2 or the like), due to aforementioned per-minor version  directories, so either way, you're best off just creating a new virtual environment from scratch.To be clear, the third party  package does not have this limitation if and only if the system Python installation statically linked . Oddly, while the  flag will make it copy the main binary and the standard library modules, it doesn't cause  itself (the interpreter core) to be copied, so if the main binary depends on a system copy of , then removing the system copy breaks the virtual environment. If you did use  and your  executable statically linked  ( should show no  dependency), then yes,  makes much more heavyweight (in local tests on 3.6, forcing copies via the appropriate switch, freshly created  environments were ~11 MB, while  environments were ~48 MB; sadly, my  dynamically links , so it still wouldn't work) virtual environments that should survive the removal of the system installed copy of Python.In any event, it's probably best to leave your Python 3.7 install in place, and just upgrade to 3.8 without removing 3.7 (are you really hard up for a few dozen MB of disk space?). Even if you replace  with the new 3.8 install, ,  or the like and the rest of the 3.7 standard library will continue to exist for the virtual environment to depend on; at worst you might need to manually change the symlink in the virtual environment to point to  rather than  to keep using the old version (including all your installed third party packages).An alternative to trying to keep the old virtual environment working is to just back up the installed state of that virtual environment, delete it, install the new Python, create a fresh virtual environment, and then use the backed up state to reinstall all your packages in the upgraded virtual env. An example might be:
A virtualenv includes a copy of the python binary itself, so nothing should happen. See a more detailed explanation herevirtualenv solves this problem by creating a completely isolated virtual environment for each of your programs. An environment is simply a directory that contains a complete copy of everything needed to run a Python program, including a copy of the python binary itself, a copy of the entire Python standard library, a copy of the pip installer, and (crucially) a copy of the site-packages directory mentioned above. When you install a package from PyPI using the copy of pip that's created by the virtualenv tool, it will install the package into the site-packages directory inside the virtualenv directory. You can then use it in your program just as before.Edit (accounting for venv vs virtualenv): According to the venv-documentation, it can either copy or symlink the binary:The venv module provides support for creating lightweight “virtual environments” with their own site directories, optionally isolated from system site directories. Each virtual environment has its own Python binary (which matches the version of the binary that was used to create this environment) and can have its own independent set of installed Python packages in its site directories.


Answer URL
https://docs.python.org/3/library/venv.html
https://docs.python.org/3/library/venv.html#creating-virtual-environments
