Natural Text
I have a function to simultaneously retrieve the min and max values of a list:But it got me wondering, since I do two comparisons in the for loop anyways, would it not be faster to simply use  and  separately? If it is, how could I edit this function to make it more efficient?
The expensive part in finding out the minimum or maximum value in a list is not the comparison. Comparing values is pretty fast, and won’t make a problem here. Instead, what impacts the run time is the loop.When you are using  or , then each of those will have to iterate over the iterable once. They do that separately, so when you need both the minimum and the maximum value, by using the built-in functions, you are iterating twice.Your function just iterates once over it, so its theoretical run time is shorter. Now as chepter mentioned in the comments,  and  are implemented in native code, so they are most certainly faster than when implementing it in Python code yourself.Now, it depends a lot on your iterable whether the two native loops will be faster than your Python function. For longer lists, where iterating it is already expensive, iterating it once will definitely be better, but for shorter ones, you probably get better results with the native code. I can’t tell where the exact threshold is, but you can easily test out for your actual data what’s faster. In most cases though, it rarely matters as a min/max won’t be the bottleneck of your application, so you just shouldn’t worry about it until it becomes a problem.Btw. your implementation has a few problems right now, which you should fix if you want to use it:It requires  to be a sequence, and not an iterable (as you use indexes on it)You also require it to have at least one item—which technically isn’t required either. While you do check for , that won’t necessarily tell you something about the length of the sequence/iterable. Custom types can easily provide their own boolean value and/or sequence behavior.Finally, you initialize your  and  with the keyed values of the iterable item, but later you (correctly) just assign the original item from the iterable.So I would suggest you to use iterators instead, and fix that key thing—you can also store the key results to save some computation for more complex key functions:I did some testing on this, and it turns out that—without a custom key function—using the built-in max/min is kind-of impossible to beat. Even for very large lists, the purce C implementation is just way too fast. However, as soon as you add in a key function (which is written in Python code), the situation is completely reversed. With a key function, you get pretty much the same timing result for a single  or  call as for the full function doing both. So using the solution written in Python is a lot faster.So this lead to the idea that, maybe, the implementation in Python wasn’t the actual problem, but instead the  function that is used. And indeed, the actual key function is what makes the Python implementation expensive. And it makes a lot of sense too. Even with an identity-lamba, you still have the overhead of function calls;  many function calls (with my optimized variant above). And function calls are quite expensive.In my tests, with support for the key function taken out, the actually expected results appeared: Iterating just once is faster than twice. But for non very-large iterables, the difference is really small. So unless iterating the iterable is very expensive (although you could then use  and still iterate twice) or you want to loop over it anyway (in which case you would combine that with the min/max check), using the built-in  and  functions separately will be faster and also a lot easier to use. And, they both come with the internal optimization that they skip key functions if you don’t specify one.Finally though, how could you add that key function optimization into your code? Well, unfortunately, there’s only one way to do this and that involves duplicating code. You essentially have to check whether or not a key function is specified and skip the function call when it wasn’t. So, something like this:
Please check here:This is not exactly what you are looking but, I can reduce the loop:Output:
use this code:


Answer URL
