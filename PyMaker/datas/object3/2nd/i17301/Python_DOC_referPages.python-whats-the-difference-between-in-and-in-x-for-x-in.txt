Natural Text
This is my Python code:Where y could be a list like:Can somebody explain me the difference between these two sentences?Thank you!
Let’s start with the simple one first:The parentheses don’t carry any meaning there, so this is equivalent to this:The  operator checks if something is contained within something else. In your case, you have a list , so you are checking if something () is not contained within () that list . So  would be  because  is an element of , and  would be  because  is not an element of .The other one is something completely different though:Here we have a generator expression. Generator expressions are of the format  and are equivalent to this code:You might have heard about list comprehensions before; those are similar but use square brackets instead of parentheses: . As they return a list, they are a bit easier to understand. They are equivalent to this:Essentially, you are looping over the elements of , calling each element in an iteration and return  for that element. In your case,  is an expression itself:  which is basically the same as above: You are checking if  is not contained within .Now, generator expressions are a bit complicated, because they are evaluated when an element is requested from it, so let’s assume for now that we have a list comprehension insteadSo what this does is calculate  for each element  in . So for your , the resulting list would be this:With a real , this would as such result in a list with three boolean values. Now a non-empty list is always trueish, so regardless of the result in this check, the -check would succeed.The generator expression will return a generator though, which is a more complex object that a list. It is just as well true-ish though, so your check will also succeed regardless of the individual values.Now imagine, we want to make sure, that for those three elements in the list, we want all checks to result in . For that, we can use the  function which essentially checks if a list—or the values in a generator—contains only true values.So this will succeed if  is not contained within any element of the list . If on the other hand we wanted to check if at least one trueish value is in the list or generator, then we could instead use the  function.
GeneratorTo begin with,  is a generator statement, and if  is in front of it, it will always return True.This could be used to see if any or all of the nested iterables contain .e.g. So if  is this:then if  is, for example, , then the  comprehension above would return , but the  comprehension would return . ConditionalSo here's what going on inside that generator comprehension: if y is a list, and you test with:the z in y must be an iterable in order to test for inclusion, which strings are, but you're only seeing if something is in a string of length one in this case. A better example would be to use integers:and would fail, because integers are not iterable, but would succeed because you can test for membership in the actual list.When you have a similar level of nesting would be:and with you are testing if x is in one of those tuples.Does that make sense?
Thisis equivalent toBecauseThisIs the same asWhich resolves internally toIn the first case, you might have meant to write:or:
I'll assume this is a general question, and the actual values in the list don't matter much. For:The  in the statement means you have a  "list comprehension" or "generator expression" (inside parens). It will generate a list. This one is a list comprehension with a filter (the  part). But the end result will be a list that may or may not be empty. Now the  statement will evaluate this for "truthiness", where an empty list is considered false, and non-empty is true.  This is a straight "containment test" that tests directly if  is contained (or not) in the iterable , and returns a Boolean value. This can be a fast test, depending on what kind of object  is.  The first form is probably slower and unnecessary in most cases. The first one has to create and then destroy a temporary list.


Answer URL
