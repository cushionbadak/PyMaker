Natural Text
Let's say I have the following script, :I'm curious as to what exactly happens when I run . Obviously Python doesn't just read programs line-by-line - otherwise it wouldn't catch syntax errors before actually executing the program. But this makes the workings of the interpreter seem somewhat nebulous. I was wondering if someone would help clear things up for me. In particular, I would like to know:At what point does Python realize there is a syntax error on line 13?At what point does Python read the nested functions and add them to the scope of ?Similarly, how does Python add the function  to its namespace when it encounters it, without executing it?Suppose  were an invalid import. Would Python necessarily raise an  before executing any other commands?Suppose  were a valid module, but it has no function . At what point would Python realize this, during execution of  or before?If anyone could point me to documentation on how Python parses and executes scripts it would be very much appreciated. 
There's some information in the tutorial's section on modules, but I don't think the documentation has a complete reference for this.  So, here's what happens.When you first run a script or import a module, Python parses the syntax into an AST and then compiles that into bytecode.  It hasn't executed anything yet; it's just compiled your code into instructions for a little stack-based machine.  This is where syntax errors are caught.  (You can see the guts of all this in the  module, the  module, the  builtin, the grammar reference, and sprinkled around various other places.)You can actually compile a module independently of running the generated code; that's what the builtin  method does.So that's the first phase: compiling.  Python only has one other phase, which is actually running the code.  Every statement in your module, except those contained within  or , is executed in order.  That means that s happen at runtime, wherever you happen to put them in your module.  Which is part of the reason it's good hygiene to put them all at the top.  Same for  and : these are just statements that create a specific type of object, and they're executed as they're encountered, like anything else.The only tricky bit here is that the phases can happen more than once — for example, an  is only executed at runtime, but if you've never imported that module before, then it has to be compiled, and now you're back in compile time.  But "outside" the import it's still runtime, which is why you can catch a  thrown by an .Anyway, to answer your specific questions:At compile time.  When you run this as a script, or when you import it as a module, or when you compile it with , or otherwise ask Python to make any sense of it.  In practical terms, this can happen at any time: if you tried to import this module within a function, you'd only get a  when calling that function, which might be halfway through your program.During the execution of , because  and  just create a new object and assign it to a name.  But Python still knows how to create the nested function, because it's already compiled all the code within it.The same way it would add  to a namespace without executing it.  A function is just an object that contains a "code" attribute — literally just a block of Python bytecode.  You can manipulate the  type as data, because it is data, independently of executing it.  Try looking at a function's , read the "code objects" section of the data model, or even play around with the disassembler.  (You can even execute a code object directly with custom locals and globals using , or change the code object a function uses!)Yes, because  is a plain old statement like any other, executed in order.  But if there were other code before the , that would run first.  And if it were in a function, you wouldn't get an error until that function ran.  Note that , just like  and , is just a fancy form of assignment.Only during the execution of .  Python has no way of knowing whether other code will add a  to your module before that point, or even change  to some other object entirely.  Attribute lookups are always done just-in-time, when you ask for them, never in advance.
As a general rule, python first parses the file, compiles the abstract syntax tree to byte code, then attempt to execute it sequentially. That means all statements are executed line by line. Thus, this means:Syntax errors are caught at parse time, before anything is executed. If you add some side effect to the script, e.g. create a file, you will see that it never gets executed.A function becomes defined in the scope after the definition. If you try to call  right before  you will see that it would fail because  has not been defined at that point.Same as 2.If python cannot import a library, where import means it tries to execute the module, then it fails with an .Since you don't try to access  at import time (i.e. you are not doing ), an error only occurs when you attempt to call .


Answer URL
https://docs.python.org/3/tutorial/modules.html
https://docs.python.org/3/library/ast.html
https://docs.python.org/3/library/functions.html#compile
https://docs.python.org/3/reference/grammar.html
https://docs.python.org/3/library/compileall.html
https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy
https://docs.python.org/3/library/dis.html
