Natural Text
I'm using python  module to parallelize some computationally heavy tasks. The obvious choice is to use a  of workers and then use the  method.However, processes can fail. For instance, they may be silently killed for instance by the . Therefore I would like to be able to retrieve the exit code of the processes launched with .Additionally, for logging purpose, I would like to be able to know the PID of the process launched to execute each value in the the iterable.
If you're using  you're generally not interested in the exit code of the sub-processes in the pool, you're interested in what value they returned from their work item. This is because under normal conditions, the processes in a  won't exit until you / the pool, so there's no exit codes to retrieve until all work is complete, and the  is about to be destroyed. Because of this, there is no public API to get the exit codes of those sub-processes.Now, you're worried about exceptional conditions, where something out-of-band kills one of the sub-processes while it's doing work. If you hit an issue like this, you're probably going to run into some strange behavior. In fact, in my tests where I killed a process in a  while it was doing work as part of a  call,  never completed, because the killed process didn't complete. Python did, however, immediately launch a new process to replace the one I killed.That said, you can get the pid of each process in your pool by accessing the  objects inside the pool directly, using the private  attribute:So, one thing you could do to try to detect when a process had died unexpectedly (assuming you don't get stuck in a blocking call as a result). You can do this by examining the list of processes in the pool before and after making a call to :We have to make a copy of the list because when a process in the  dies, Python immediately replaces it with a new process, and removes the dead one from the list.This worked for me in my tests, but because it's relying on a private attribute of the  object () it's risky to use in production code. I would also suggest that it may be overkill to worry too much about this scenario, since it's very unlikely to occur and complicates the implementation significantly.


Answer URL
https://docs.python.org/3/library/concurrent.futures.html#processpoolexecutor
