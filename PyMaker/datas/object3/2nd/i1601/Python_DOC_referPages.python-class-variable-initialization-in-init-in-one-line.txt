Natural Text
I have a python class that looks like this:followed by:Is there any way to autoinitialize these instance variables, like C++'s initialization list? It would spare lots of redundant code.
You can use a decorator:Use it to decorate the  method:Output:
If you're using Python 2.6 or higher, you can use collections.namedtuple:This is appropriate especially when your class is really just a big bag of values.
Quoting the Zen of Python,Explicit is better than implicit.
Another thing you can do:But the only solution I would recommend, besides just spelling it out, is "make a macro in your editor" ;-p
For Python 3.7+ you can use a Data Class, which is a very pythonic and maintainable way to do what you want. It allows you to define fields for your class, which are your automatically initialized instance variables. It would look something like that: The method will already be in your class. Note that here type hinting is required, that is why I have used  and  in the example. If you don't know the type of your field, you can use Any from the  module.  The Data Class has many advantages compared to the proposed solutions:It is explicit: all fields are visible, which respects the Zen of Python and makes it readable and maintainable. Compare it to the use of . It can have methods. Just like any other class. The absence of methods, if you want to use them, is one downside of . It allows you to go beyond the automatic  using the  method. 
You could do it easily with the keyword arguments, e.g. like this:similar implementation for the positional arguments would be:which to me doesn't seem to solve your problem.
Nadia's solution is better and more powerful, but I think this is also interesting:
I needed something for the same purpose, but none of the existing answers covered all of the cases I tested.  Nadia's answer was the closest to what I was looking for, so I started with her code as a base.  The decorator below works with all valid combinations of arguments:  It also implements the standard -prefix convention to allow for -private variables that won't be assigned to class instances.  Note:I included tests, but collapsed them into the last line (58) for brevity.  You can expand the tests, which detail all of the potential use cases, by -ing all  characters with a newline.
There may not be a need to initialize variables, as locals() already contains the values!class Dummy(object):d = Dummy(2, 3)d.params{'a': 2, 'b': 3, 'default': 'Fred'}d.params['b']3Of course, within a class one could use self.params
As soon as  is deprecated since Python 3.5, here's solution using :Check if works:
nu11ptr has made a small module, PyInstanceVars, which includes this functionality as a function decorator. In the module's README is states that the "[...] performance is now only 30-40% worse than explicit initialization under CPython".Usage example, lifted straight from the module's documentation:
For Python 3.3+:Demo:A non-decorator approach for both Python 2 and 3 using frames:Demo: 
Maybe this is a closed question, but I would like to propose my solution in order to know what you think about it. I have used a metaclass which applies a decorator to init method
The attrs library does something like this.


Answer URL
https://docs.python.org/3/library/typing.html#typing.Any
