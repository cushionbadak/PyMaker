Natural Text
The standard library in 3.7 can recursively convert a dataclass into a dict (example from the docs):I am looking for a way to turn a dict back into a dataclass when there is nesting. Something like  only works if the fields of the data class are simple types and not themselves dataclasses. I am familiar with jsonpickle, which however comes with a prominent security warning. 
Below is the CPython implementation of â€“ or specifically, the internal recursive helper function  that it uses: simply calls the above with some assertions, and  by default.How can this be adapted to create an output dictionary with the required type-tagging, as mentioned in the comments?1. Adding type informationMy attempt involved creating a custom return wrapper inheriting from :Looking at the original code, only the first clause needs to be modified to use this wrapper, as the other clauses only handle containers of -es:Imports:Functions used:Tests with the example dataclasses:Results are as expected.2. Converting back to a The recursive routine used by  can be re-used for the reverse process, with some relatively minor changes:Functions used:Test:Again as expected.
I'm the author of  - the tool that simplifies creation of data classes from dictionaries.This library has only one function  - this is a quick example of usage:Moreover  supports following features:nested structures(basic) types checkingoptional fields (i.e. typing.Optional)unionscollectionsvalues casting and transformationremapping of fields names... and it's well tested - 100% code coverage!To install dacite, simply use pip (or pipenv):
You can use mashumaro for creating dataclass object from a dict according to the scheme. Mixin from this library adds convenient  and  methods to dataclasses:
If your goal is to produce JSON from and to existing, predefined dataclasses, then just write custom encoder and decoder hooks. Do not use  here, instead record in JSON a (safe) reference to the original dataclass. is not safe because it stores references to arbitrary Python objects and passes in data to their constructors. With such references I can get jsonpickle to reference internal Python data structures and create and execute functions, classes and modules at will. But that doesn't mean you can't handle such references unsafely. Just verify that you only import (not call) and then verify that the object is an actual dataclass type, before you use it.The framework can be made generic enough but still limited only to JSON-serialisable types plus -based instances:This uses JSON-RPC-style class hints to name the dataclass, and on loading this is verified to still be a data class with the same fields. No type checking is done on the values of the fields (as that's a whole different kettle of fish).Use these as the  and  arguments to  and :or create instances of the  and  classes with those same hooks.Instead of using fully qualifying module and class names, you could also use a separate registry to map permissible type names; check against the registry on encoding, and again on decoding to ensure you don't forget to register dataclasses as you develop.
All it takes is a five-liner:Sample usage:Full code, including to/from json, here at gist: https://gist.github.com/gatopeich/1efd3e1e4269e1e98fae9983bb914f22


Answer URL
https://docs.python.org/3/library/json.html#json.JSONEncoder
https://docs.python.org/3/library/json.html#json.JSONDecoder
