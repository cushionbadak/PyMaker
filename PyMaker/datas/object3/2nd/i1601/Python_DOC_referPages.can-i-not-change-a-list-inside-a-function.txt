Natural Text
Result:When I print the array outside the function it is not rotated anymore and remains how it originally was. Can someone help me understand this?
Yes, you can change a list from within a function, but you need to use the correct syntax.  As you've seen already, this is not the correct way:I will try to explain why this did not work, and hope to give you a better intuition about what really happens.  Inside the scope of the function shown above, there are 3 local variables: , , and .  The right-hand side operations  creates a new list object, without modifying the original list, and this resulting object is bound to the local variable name  .  This does not modify the original object, because such assignment statements in Python are never mutating objects. They will only bind a name in a namespace. Think of it as if you're taking the nametag "arr" off of the old list object, which was passed in as argument, and sticking it on the new list object which was just created. The old list object is not modified by such an operation, only the local namespace is modified - the old list object becomes "anonymous" and is no longer reachable in this scope.The solution is to use a different kind of assignment statement, a slice assignment, which does mutate:As a final note, there is a list-like data structure in stdlib which provides more efficient rotation operations (at the cost of less-efficient indexing into the middle of the collection). If you're interested in this,  read the docs on the .
The problem is list slicing is not being applied in place. Effectively a new list is created and assigned to a variable  scoped to , i.e. it can can be accessed within your function only. A method which does work in place will work as expected:In your example, you can have your function return a list and assign it to :
Your problem is because you can't change a variable inside a python function because of the scope. Read this for more info.But resuming, you need to either return arr and assign it outside. Like this:Or if you would like, you could make arr a global. (Check this for more info on that). (Don't recommend this last one, but exists)Hope it helped :)
There are a lot of really complicated answers. Here's the "for dummies" version:You are passing  into For nearly all purposes, you can think of this as creating another variable, also called  which  works on. 's  is not the same as the  you are passing in to . It is a copy (technically it's not a copy until you assign  to something else, but close enough for these purposes).You're not getting your modified  back out of  again.You can solve this in two ways:Define  outside of , and don't pass  in. I'll call this the "" approach. Not recommended unless you have a very good reason.Use  after your function completes. Essentially,  means . In 99.99999% of cases, this is what you want.Therefore, in your example, what you really want is this:


Answer URL
https://docs.python.org/3/library/collections.html#collections.deque
