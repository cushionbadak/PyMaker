Natural Text
Is there a reason to prefer using  over list comprehension or vice versa?  Is either of them generally more efficient or considered generally more pythonic than the other?
 may be microscopically faster in some cases (when you're NOT making a lambda for the purpose, but using the same function in map and a listcomp). List comprehensions may be faster in other cases and most (not all) pythonistas consider them more direct and clearer.An example of the tiny speed advantage of map when using exactly the same function:An example of how performance comparison gets completely reversed when map needs a lambda:
CasesCommon case: Almost always, you will want to use a list comprehension in python because it will be more obvious what you're doing to novice programmers reading your code. (This does not apply to other languages, where other idioms may apply.) It will even be more obvious what you're doing to python programmers, since list comprehensions are the de-facto standard in python for iteration; they are expected.Less-common case: However if you already have a function defined, it is often reasonable to use , though it is considered 'unpythonic'. For example,  is more elegant/terse than . You gain the elegance of not having to make up a dummy variable (e.g.  or  or ) which you have to type twice, just to iterate. The same argument holds for  and  and anything from the  module: if you already have a function handy, you could go ahead and do some functional programming. This gains readability in some situations, and loses it in others (e.g. novice programmers, multiple arguments)... but the readability of your code highly depends on your comments anyway.Almost never: You may want to use the  function as a pure abstract function while doing functional programming, where you're mapping , or currying , or otherwise benefit from talking about  as a function. In Haskell for example, a functor interface called  generalizes mapping over any data structure. This is very uncommon in python because the python grammar compels you to use generator-style to talk about iteration; you can't generalize it easily. (This is sometimes good and sometimes bad.) You can probably come up with rare python examples where  is a reasonable thing to do. The closest example I can come up with would be , which is a one-liner that is very roughly equivalent to:Just using a -loop: You can also of course just use a for-loop. While not as elegant from a functional-programming viewpoint, sometimes non-local variables make code clearer in imperative programming languages such as python, because people are very used to reading code that way. For-loops are also, generally, the most efficient when you are merely doing any complex operation that is not building a list like list-comprehensions and map are optimized for (e.g. summing, or making a tree, etc.) -- at least efficient in terms of memory (not necessarily in terms of time, where I'd expect at worst a constant factor, barring some rare pathological garbage-collection hiccuping)."Pythonism"I dislike the word "pythonic" because I don't find that pythonic is always elegant in my eyes. Nevertheless,  and  and similar functions (like the very useful  module) are probably considered unpythonic in terms of style.LazinessIn terms of efficiency, like most functional programming constructs, MAP CAN BE LAZY, and in fact is lazy in python. That means you can do this (in python3) and your computer will not run out of memory and lose all your unsaved data:Try doing that with a list comprehension:Do note that list comprehensions are also inherently lazy, but python has chosen to implement them as non-lazy. Nevertheless, python does support lazy list comprehensions in the form of generator expressions, as follows:You can basically think of the  syntax as passing in a generator expression to the list constructor, like .Brief contrived exampleList comprehensions are non-lazy, so may require more memory (unless you use generator comprehensions). The square brackets  often make things obvious, especially when in a mess of parentheses. On the other hand, sometimes you end up being verbose like typing . As long as you keep your iterator variables short, list comprehensions are usually clearer if you don't indent your code. But you could always indent your code.or break things up:Efficiency comparison for python3 is now lazy:Therefore if you will not be using all your data, or do not know ahead of time how much data you need,  in python3 (and generator expressions in python2 or python3) will avoid calculating their values until the last moment necessary. Usually this will usually outweigh any overhead from using . The downside is that this is very limited in python as opposed to most functional languages: you only get this benefit if you access your data left-to-right "in order", because python generator expressions can only be evaluated the order .However let's say that we have a pre-made function  we'd like to , and we ignore the laziness of  by immediately forcing evaluation with . We get some very interesting results:In results are in the form AAA/BBB/CCC where A was performed with on a circa-2010 Intel workstation with python 3.?.?, and B and C were performed with a circa-2013 AMD workstation with python 3.2.1, with extremely different hardware. The result seems to be that map and list comprehensions are comparable in performance, which is most strongly affected by other random factors. The only thing we can tell seems to be that, oddly, while we expect list comprehensions  to perform better than generator expressions ,  is ALSO more efficient that generator expressions (again assuming that all values are evaluated/used).It is important to realize that these tests assume a very simple function (the identity function); however this is fine because if the function were complicated, then performance overhead would be negligible compared to other factors in the program. (It may still be interesting to test with other simple things like )If you're skilled at reading python assembly, you can use the  module to see if that's actually what's going on behind the scenes:  It seems it is better to use  syntax than . Sadly the  class is a bit opaque to disassembly, but we can make due with our speed test.
You should use  and  instead of list comprehensions.An objective reason why you should prefer them even though they're not "Pythonic" is this:They require functions/lambdas as arguments, which introduce a new scope.I've gotten bitten by this more than once:but if instead I had said:then everything would've been fine.You could say I was being silly for using the same variable name in the same scope.I wasn't. The code was fine originally -- the two s weren't in the same scope.It was only after I moved the inner block to a different section of the code that the problem came up (read: problem during maintenance, not development), and I didn't expect it.Yes, if you never make this mistake then list comprehensions are more elegant.But from personal experience (and from seeing others make the same mistake) I've seen it happen enough times that I think it's not worth the pain you have to go through when these bugs creep into your code.Conclusion:Use  and . They prevent subtle hard-to-diagnose scope-related bugs.Side note:Don't forget to consider using  and  (in ) if they are appropriate for your situation!
Actually,  and list comprehensions behave quite differently in the Python 3 language. Take a look at the following Python 3 program:You might expect it to print the line "[1, 4, 9]" twice, but instead it prints "[1, 4, 9]" followed by "[]". The first time you look at  it seems to behave as a sequence of three elements, but the second time as an empty one.In the Python 2 language  returns a plain old list, just like list comprehensions do in both languages. The crux is that the return value of  in Python 3 (and  in Python 2) is not a list - it's an iterator!The elements are consumed when you iterate over an iterator unlike when you iterate over a list. This is why  looks empty in the last  line.To summarize:When dealing with iterators you have to remember that they are stateful and that they mutate as you traverse them.Lists are more predictable since they only change when you explicitly mutate them; they are containers.And a bonus: numbers, strings, and tuples are even more predictable since they cannot change at all; they are values.
I find list comprehensions are generally more expressive of what I'm trying to do than  - they both get it done, but the former saves the mental load of trying to understand what could be a complex  expression.There's also an interview out there somewhere (I can't find it offhand) where Guido lists s and the functional functions as the thing he most regrets about accepting into Python, so you could make the argument that they're un-Pythonic by virtue of that.
If you plan on writing any asynchronous, parallel, or distributed code, you will probably prefer  over a list comprehension -- as most asynchronous, parallel, or distributed packages provide a  function to overload python's .  Then by passing the appropriate  function to the rest of your code, you may not have to modify your original serial code to have it run in parallel (etc).
Here is one possible case:versus:I am guessing the zip() is an unfortunate and unnecessary overhead you need to indulge in if you insist on using list comprehensions instead of the map.  Would be great if someone clarifies this whether affirmatively or negatively.
So since Python 3,  is an iterator, you need to keep in mind what do you need: an iterator or  object.As @AlexMartelli already mentioned,  is faster than list comprehension only if you don't use  function.I will present you some time comparisons.Python 3.5.2 and CPythonI've used Jupiter notebook and especially  built-in magic commandMeasurements: s == 1000 ms == 1000 * 1000 µs = 1000 * 1000 * 1000 ns Setup:Built-in function: function:There is also such thing as generator expression, see PEP-0289. So i thought it would be useful to add it to comparisonYou need  object:Use list comprehension if it's custom function, use  if there is builtin functionYou don't need  object, you just need iterable one:Always use !
I consider that the most Pythonic way is to use a list comprehension instead of  and . The reason is that list comprehensions are clearer than  and .As you an see, a comprehension does not require extra  expressions as  needs. Furthermore, a comprehension also allows filtering easily, while  requires  to allow filtering.


Answer URL
https://docs.python.org/3/library/functions.html#map
