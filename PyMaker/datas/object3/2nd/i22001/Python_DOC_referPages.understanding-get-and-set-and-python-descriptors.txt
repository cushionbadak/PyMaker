Natural Text
I am trying to understand what Python's descriptors are and what they can be useful for. However, I am failing at it. I understand how they work, but here are my doubts. Consider the following code:Why do I need the descriptor class?What is  and  here? (in ). What is the purpose of these parameters?How would I call/use this example?
The descriptor is how Python's  type is implemented. A descriptor simply implements , , etc. and is then added to another class in its definition (as you did above with the Temperature class). For example:Accessing the property you assigned the descriptor to ( in the above example) calls the appropriate descriptor method. in  is the instance of the class (so above,  would receive , while  is the class with the descriptor (so it would be ).You need to use a descriptor class to encapsulate the logic that powers it. That way, if the descriptor is used to cache some expensive operation (for example), it could store the value on itself and not its class.An article about descriptors can be found here.EDIT: As jchl pointed out in the comments, if you simply try ,  will be .
Why do I need the descriptor class?It gives you extra control over how attributes work. If you're used to getters and setters in Java, for example, then it's Python's way of doing that. One advantage is that it looks to users just like an attribute (there's no change in syntax). So you can start with an ordinary attribute and then, when you need to do something fancy, switch to a descriptor.An attribute is just a mutable value. A descriptor lets you execute arbitrary code when reading or setting (or deleting) a value. So you could imagine using it to map an attribute to a field in a database, for example – a kind of ORM.Another use might be refusing to accept a new value by throwing an exception in  – effectively making the "attribute" read only.What is  and  here? (in ). What is the purpose of these parameters?This is pretty subtle (and the reason I am writing a new answer here - I found this question while wondering the same thing and didn't find the existing answer that great).A descriptor is defined on a class, but is typically called from an instance. When it's called from an instance both  and  are set (and you can work out  from  so it seems kinda pointless). But when called from a class, only  is set – which is why it's there.This is only needed for  because it's the only one that can be called on a class. If you set the class value you set the descriptor itself. Similarly for deletion. Which is why the  isn't needed there.How would I call/use this example?Well, here's a cool trick using similar classes:(I'm using Python 3; for python 2 you need to make sure those divisions are  and ). That gives:Now there are other, arguably better ways to achieve the same effect in python (e.g. if celsius were a property, which is the same basic mechanism but places all the source inside the Temperature class), but that shows what can be done...
I am trying to understand what Python's descriptors are and what they can be useful for.Descriptors are class attributes (like properties or methods) with any of the following special methods: (non-data descriptor method, for example on a method/function) (data descriptor method, for example on a property instance) (data descriptor method)These descriptor objects can be used as attributes on other object class definitions. (That is, they live in the  of the class object.)Descriptor objects can be used to programmatically manage the results of a dotted lookup (e.g. ) in a normal expression, an assignment, and even a deletion. Functions/methods, bound methods, , , and  all use these special methods to control how they are accessed via the dotted lookup.A data descriptor, like , can allow for lazy evaluation of attributes based on a simpler state of the object, allowing instances to use less memory than if you precomputed each possible attribute. Another data descriptor, a , created by , allow memory savings by allowing the class to store data in a mutable tuple-like datastructure instead of the more flexible but space-consuming .Non-data descriptors, usually instance, class, and static methods, get their implicit first arguments (usually named  and , respectively) from their non-data descriptor method, .Most users of Python need to learn only the simple usage, and have no need to learn or understand the implementation of descriptors further.In Depth: What Are Descriptors?A descriptor is an object with any of the following methods (, , or ), intended to be used via dotted-lookup as if it were a typical attribute of an instance. For an owner-object, , with a  object: invokes returning a This is how all methods and the  on a property work. invokes returning This is how the  on a property works. invokes returning This is how the  on a property works. is the instance whose class contains the descriptor object's instance.  is the instance of the descriptor (probably just one for the class of the )To define this with code, an object is a descriptor if the set of its attributes intersects with any of the required attributes:A Data Descriptor has a  and/or .A Non-Data-Descriptor has neither  nor .Builtin Descriptor Object Examples:functions in generalNon-Data DescriptorsWe can see that  and  are Non-Data-Descriptors:Both only have the  method:Note that all functions are also Non-Data-Descriptors:Data Descriptor, However,  is a Data-Descriptor:Dotted Lookup OrderThese are important distinctions, as they affect the lookup order for a dotted lookup. First the above looks to see if the attribute is a Data-Descriptor on the class of the instance, If not, it looks to see if the attribute is in the 's , then it finally falls back to a Non-Data-Descriptor. The consequence of this lookup order is that Non-Data-Descriptors like functions/methods can be overridden by instances.Recap and Next StepsWe have learned that descriptors are objects with any of , , or . These descriptor objects can be used as attributes on other object class definitions. Now we will look at how they are used, using your code as an example.Analysis of Code from the QuestionHere's your code, followed by your questions and answers to each:Why do I need the descriptor class?Your descriptor ensures you always have a float for this class attribute of , and that you can't use  to delete the attribute:Otherwise, your descriptors ignore the owner-class and instances of the owner, instead, storing state in the descriptor. You could just as easily share state across all instances with a simple class attribute (so long as you always set it as a float to the class and never delete it, or are comfortable with users of your code doing so):This gets you exactly the same behavior as your example (see response to question 3 below), but uses a Pythons builtin (), and would be considered more idiomatic:What is instance and owner here? (in get). What is the purpose of these parameters? is the instance of the owner that is calling the descriptor. The owner is the class in which the descriptor object is used to manage access to the data point. See the descriptions of the special methods that define descriptors next to the first paragraph of this answer for more descriptive variable names.How would I call/use this example?Here's a demonstration:You can't delete the attribute:And you can't assign a variable that can't be converted to a float:Otherwise, what you have here is a global state for all instances, that is managed by assigning to any instance.  The expected way that most experienced Python programmers would accomplish this outcome would be to use the  decorator, which makes use of the same descriptors under the hood, but brings the behavior into the implementation of the owner class (again, as defined above):Which has the exact same expected behavior of the original piece of code:ConclusionWe've covered the attributes that define descriptors, the difference between data- and non-data-descriptors, builtin objects that use them, and specific questions about use.So again, how would you use the question's example? I hope you wouldn't. I hope you would start with my first suggestion (a simple class attribute) and move on to the second suggestion (the property decorator) if you feel it is necessary. 
Why do I need the descriptor class?Inspired by Fluent Python by Buciano RamalhoImaging you have a class like thisWe should validate the weight and price in avoid to assign them a negative number, we can write less code if we use descriptor as a proxy as thisthen define class LineItem like this:and we can extend the Quantity class to do more common validating
Before going into the details of descriptors it may be important to know how attribute lookup in Python works. This assumes that the class has no metaclass and that it uses the default implementation of  (both can be used to "customize" the behavior).The best illustration of attribute lookup (in Python 3.x or for new-style classes in Python 2.x) in this case is from Understanding Python metaclasses (ionel's codelog). The image uses  as substitute for "non-customizable attribute lookup".This represents the lookup of an attribute  on an  of :Two conditions are important here:If the class of  has an entry for the attribute name and it has  and .If the  has no entry for the attribute name but the class has one and it has .That's where descriptors come into it:Data descriptors which have both  and .Non-data descriptors which only have .In both cases the returned value goes through  called with the instance as first argument and the class as second argument.The lookup is even more complicated for class attribute lookup (see for example Class attribute lookup (in the above mentioned blog)).Let's move to your specific questions:Why do I need the descriptor class?In most cases you don't need to write descriptor classes! However you're probably a very regular end user. For example functions. Functions are descriptors, that's how functions can be used as methods with  implicitly passed as first argument.If you look up  on an instance you'll get back a "bound method":Similarly you could also bind a function by invoking its  method manually (not really recommended, just for illustrative purposes):You can even call this "self-bound method":Note that I did not provide any arguments and the function did return the instance I had bound!Functions are Non-data descriptors!Some built-in examples of a data-descriptor would be . Neglecting , , and  the  descriptor is (from Descriptor HowTo Guide "Properties"):Since it's a data descriptor it's invoked whenever you look up the "name" of the  and it simply delegates to the functions decorated with , , and  (if present).There are several other descriptors in the standard library, for example , .The point of descriptors is easy (although you rarely need them): Abstract common code for attribute access.  is an abstraction for instance variable access,  provides an abstraction for methods,  provides an abstraction for methods that don't need instance access and  provides an abstraction for methods that need class access rather than instance access (this is a bit simplified).Another example would be a class property.One fun example (using  from Python 3.6) could also be a property that only allows a specific type:Then you can use the descriptor in a class:And playing a bit with it:Or a "lazy property":These are cases where moving the logic into a common descriptor might make sense, however one could also solve them (but maybe with repeating some code) with other means.What is  and  here? (in ). What is the purpose of these parameters?It depends on how you look up the attribute. If you look up the attribute on an instance then:the second argument is the instance on which you look up the attributethe third argument is the class of the instanceIn case you look up the attribute on the class (assuming the descriptor is defined on the class):the second argument is the third argument is the class where you look up the attributeSo basically the third argument is necessary if you want to customize the behavior when you do class-level look-up (because the  is ).How would I call/use this example?Your example is basically a property that only allows values that can be converted to  and that is shared between all instances of the class (and on the class - although one can only use "read" access on the class otherwise you would replace the descriptor instance):That's why descriptors generally use the second argument () to store the value to avoid sharing it. However in some cases sharing a value between instances might be desired (although I cannot think of a scenario at this moment). However it makes practically no sense for a celsius property on a temperature class... except maybe as purely academic exercise.
I tried (with minor changes as suggested) the code from Andrew Cooke's answer. (I am running python 2.7).The code:The result:With Python prior to 3, make sure you subclass from object which will make the descriptor work correctly as the get magic does not work for old style classes.
You'd see https://docs.python.org/3/howto/descriptor.html#properties


Answer URL
https://docs.python.org/3/howto/descriptor.html#properties
