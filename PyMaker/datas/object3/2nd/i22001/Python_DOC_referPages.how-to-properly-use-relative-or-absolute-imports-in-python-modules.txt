Natural Text
Usage of relative imports in Python has one drawback, you will not be able to run the modules as standalones anymore because you will get an exception: How should I modify the sample code in order to be able to execute all: ,  and I'm looking for a solution that works with python 2.6+ (including 3.x).
First, I assume you realize what you've written would lead to a circular import issue, because foo imports bar and viceversa; try adding to test.py, and you'll see it fails. The example must be changed in order to work.So, what you're asking is really to fallback to absolute import when relative import fails; in fact, if you're executing foo.py or bar.py as the main module, the other modules will just lie at the root level, and if they share the name with another module on the system which one will be picked depends on the order in sys.path. Since the current dir is usually the first, local modules will be picked if available - i.e., if you've got an 'os.py' file in the current working dir, it'll be picked instead of the builtin one.A possibile suggestion is:foo.pybar.py:By the way calling scripts from the proper position is usually way better.Is probably the best way to go. This runs the module as a script.
You could just start 'to run the modules as standalones' in a bit a different way:Instead of:Use:Of course, the  file must be present.Please also note, that you have a circular dependency between  and  â€“ this won't work. I guess it is just a mistake in your example.Update: it seems it also works perfectly well to use this as the first line of the :Then you can execute the script directly in POSIX systems.
Ditch relative imports: you should think of your package namespace as a global one, anyway.The trick to making this palatable is editing  appropriately. Here is some food for thought:
You need  in each folder.Relative import works only when you do:test.py imports foo.py and foo.py can relative import anything from the folder of test.py and above.You can't do:It will never work.You can try the sys.path.append or sys.path.insert solution but you gonna screw up the paths and you'll have problems with the f=open(filename).
Why not just put the "main" in a different .py file?
So far the only solution I found was not to use relative imports at all. Due to current limitation, I'm wondering when someone is supposed to use relative imports in python.On all configurations that I used the  contained the current directory as first argument so just use  instead of  because it will do the same.


Answer URL
https://docs.python.org/3/using/cmdline.html#cmdoption-m
